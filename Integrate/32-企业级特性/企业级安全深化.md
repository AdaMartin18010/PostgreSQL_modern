# PostgreSQL企业级安全深化指南

> **PostgreSQL版本**: 17+/18+
> **适用场景**: 企业级数据库、合规性要求高的行业
> **难度等级**: ⭐⭐⭐⭐⭐ 专家级
> **参考**: [05-安全与合规/安全加固](../05-安全与合规/安全加固/PostgreSQL安全加固完整指南.md)

---

## 📋 目录

- [PostgreSQL企业级安全深化指南](#postgresql企业级安全深化指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 企业级安全目标](#11-企业级安全目标)
    - [1.2 安全层次](#12-安全层次)
  - [2. 高级安全策略](#2-高级安全策略)
    - [2.1 细粒度访问控制](#21-细粒度访问控制)
      - [2.1.1 基于角色的访问控制（RBAC）](#211-基于角色的访问控制rbac)
      - [2.1.2 行级安全（RLS）深化](#212-行级安全rls深化)
    - [2.2 数据加密](#22-数据加密)
      - [2.2.1 透明数据加密（TDE）](#221-透明数据加密tde)
      - [2.2.2 列级加密](#222-列级加密)
    - [2.3 数据脱敏](#23-数据脱敏)
  - [3. 安全审计深化](#3-安全审计深化)
    - [3.1 完整审计日志](#31-完整审计日志)
      - [3.1.1 pgAudit配置](#311-pgaudit配置)
      - [3.1.2 自定义审计表](#312-自定义审计表)
    - [3.2 审计查询](#32-审计查询)
  - [4. 合规性管理](#4-合规性管理)
    - [4.1 GDPR合规](#41-gdpr合规)
      - [4.1.1 数据主体权利](#411-数据主体权利)
    - [4.2 HIPAA合规](#42-hipaa合规)
    - [4.3 SOC2合规](#43-soc2合规)
  - [5. 数据主权管理](#5-数据主权管理)
    - [5.1 数据本地化](#51-数据本地化)
    - [5.2 跨境数据传输控制](#52-跨境数据传输控制)
  - [6. 安全事件响应](#6-安全事件响应)
    - [6.1 威胁检测](#61-威胁检测)
    - [6.2 安全事件响应流程](#62-安全事件响应流程)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 安全策略](#71-安全策略)
    - [7.2 合规性管理](#72-合规性管理)
    - [7.3 数据保护](#73-数据保护)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 企业级安全目标

企业级安全深化是在基础安全加固之上的高级安全措施，旨在：

- ✅ **深度防御**: 多层安全防护
- ✅ **合规性**: 满足GDPR、HIPAA、SOC2等合规要求
- ✅ **审计追踪**: 完整的操作审计
- ✅ **数据保护**: 数据加密、脱敏、主权管理
- ✅ **威胁检测**: 实时威胁检测和响应

### 1.2 安全层次

```text
应用层安全
    ↓
数据库层安全
    ↓
操作系统层安全
    ↓
网络层安全
```

---

## 2. 高级安全策略

### 2.1 细粒度访问控制

#### 2.1.1 基于角色的访问控制（RBAC）

```sql
-- 创建角色层次
CREATE ROLE security_admin;
CREATE ROLE data_admin;
CREATE ROLE app_user;
CREATE ROLE readonly_user;

-- 授予权限
GRANT security_admin TO data_admin;
GRANT data_admin TO app_user;

-- 表级权限
GRANT SELECT, INSERT, UPDATE ON orders TO app_user;
GRANT SELECT ON orders TO readonly_user;
```

#### 2.1.2 行级安全（RLS）深化

```sql
-- 启用RLS
ALTER TABLE sensitive_data ENABLE ROW LEVEL SECURITY;

-- 基于角色的RLS策略
CREATE POLICY manager_access ON sensitive_data
    FOR ALL
    USING (
        current_user = 'manager'
        OR department_id = (
            SELECT department_id
            FROM employees
            WHERE employee_id = current_user
        )
    );

-- 基于时间的RLS策略
CREATE POLICY business_hours_access ON sensitive_data
    FOR SELECT
    USING (
        EXTRACT(HOUR FROM NOW()) BETWEEN 9 AND 17
        AND EXTRACT(DOW FROM NOW()) BETWEEN 1 AND 5
    );
```

### 2.2 数据加密

#### 2.2.1 透明数据加密（TDE）

```sql
-- PostgreSQL 15+支持TDE
-- 配置加密
ALTER SYSTEM SET encryption_key = 'your-encryption-key';
ALTER SYSTEM SET encryption_algorithm = 'AES-256';

-- 创建加密表空间
CREATE TABLESPACE encrypted_tablespace
LOCATION '/data/encrypted'
WITH (encryption = 'on');
```

#### 2.2.2 列级加密

```sql
-- 使用pgcrypto扩展
CREATE EXTENSION pgcrypto;

-- 加密存储
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username TEXT,
    password_hash BYTEA,
    email_encrypted BYTEA,
    ssn_encrypted BYTEA
);

-- 加密函数
CREATE OR REPLACE FUNCTION encrypt_sensitive(data TEXT, key TEXT)
RETURNS BYTEA AS $$
BEGIN
    RETURN pgp_sym_encrypt(data, key);
END;
$$ LANGUAGE plpgsql;

-- 解密函数
CREATE OR REPLACE FUNCTION decrypt_sensitive(data BYTEA, key TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN pgp_sym_decrypt(data, key);
END;
$$ LANGUAGE plpgsql;

-- 使用加密
INSERT INTO users (username, email_encrypted)
VALUES ('user1', encrypt_sensitive('user1@example.com', 'encryption_key'));

-- 解密查询
SELECT username, decrypt_sensitive(email_encrypted, 'encryption_key') as email
FROM users;
```

### 2.3 数据脱敏

```sql
-- 创建脱敏函数
CREATE OR REPLACE FUNCTION mask_email(email TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN regexp_replace(email, '(.)(.*)(@)', '\1***\3', 'g');
END;
$$ LANGUAGE plpgsql;

-- 创建脱敏视图
CREATE VIEW users_masked AS
SELECT
    id,
    username,
    mask_email(email) as email,
    '***-**-****' as ssn
FROM users;

-- 授予脱敏视图访问权限
GRANT SELECT ON users_masked TO readonly_user;
```

---

## 3. 安全审计深化

### 3.1 完整审计日志

#### 3.1.1 pgAudit配置

```sql
-- 安装pgAudit
CREATE EXTENSION pgaudit;

-- 配置审计日志
ALTER DATABASE mydb SET pgaudit.log = 'all';
ALTER DATABASE mydb SET pgaudit.log_catalog = 'on';
ALTER DATABASE mydb SET pgaudit.log_parameter = 'on';
ALTER DATABASE mydb SET pgaudit.log_statement_once = 'off';
```

#### 3.1.2 自定义审计表

```sql
-- 创建审计表
CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMPTZ DEFAULT NOW(),
    username TEXT,
    database_name TEXT,
    table_name TEXT,
    operation TEXT,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    user_agent TEXT
);

-- 创建审计触发器函数
CREATE OR REPLACE FUNCTION audit_trigger_func()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (username, database_name, table_name, operation, new_values, ip_address)
        VALUES (
            current_user,
            current_database(),
            TG_TABLE_NAME,
            'INSERT',
            to_jsonb(NEW),
            inet_client_addr()
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (username, database_name, table_name, operation, old_values, new_values, ip_address)
        VALUES (
            current_user,
            current_database(),
            TG_TABLE_NAME,
            'UPDATE',
            to_jsonb(OLD),
            to_jsonb(NEW),
            inet_client_addr()
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (username, database_name, table_name, operation, old_values, ip_address)
        VALUES (
            current_user,
            current_database(),
            TG_TABLE_NAME,
            'DELETE',
            to_jsonb(OLD),
            inet_client_addr()
        );
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 创建审计触发器
CREATE TRIGGER audit_trigger
AFTER INSERT OR UPDATE OR DELETE ON sensitive_data
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();
```

### 3.2 审计查询

```sql
-- 查询审计日志
SELECT
    event_time,
    username,
    table_name,
    operation,
    ip_address
FROM audit_log
WHERE event_time >= NOW() - INTERVAL '24 hours'
ORDER BY event_time DESC;

-- 统计审计事件
SELECT
    operation,
    COUNT(*) as event_count,
    COUNT(DISTINCT username) as user_count
FROM audit_log
WHERE event_time >= NOW() - INTERVAL '7 days'
GROUP BY operation
ORDER BY event_count DESC;
```

---

## 4. 合规性管理

### 4.1 GDPR合规

#### 4.1.1 数据主体权利

```sql
-- 数据访问权（Right to Access）
CREATE OR REPLACE FUNCTION get_user_data(user_id INT)
RETURNS TABLE (
    table_name TEXT,
    data JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'users'::TEXT,
        to_jsonb(u.*)
    FROM users u
    WHERE u.id = user_id;
END;
$$ LANGUAGE plpgsql;

-- 数据删除权（Right to Erasure）
CREATE OR REPLACE FUNCTION delete_user_data(user_id INT)
RETURNS void AS $$
BEGIN
    -- 删除用户数据
    DELETE FROM users WHERE id = user_id;
    DELETE FROM orders WHERE user_id = user_id;
    -- 记录删除操作
    INSERT INTO audit_log (username, operation, new_values)
    VALUES (current_user, 'GDPR_DELETE', jsonb_build_object('user_id', user_id));
END;
$$ LANGUAGE plpgsql;
```

### 4.2 HIPAA合规

```sql
-- 健康信息访问控制
CREATE POLICY hipaa_access ON patient_records
    FOR ALL
    USING (
        current_user IN (
            SELECT employee_id
            FROM authorized_healthcare_providers
            WHERE department = 'authorized'
        )
    );

-- 审计健康信息访问
CREATE TRIGGER hipaa_audit_trigger
AFTER SELECT OR INSERT OR UPDATE OR DELETE ON patient_records
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();
```

### 4.3 SOC2合规

```sql
-- 访问控制审计
SELECT
    username,
    COUNT(*) as access_count,
    MIN(event_time) as first_access,
    MAX(event_time) as last_access
FROM audit_log
WHERE event_time >= NOW() - INTERVAL '90 days'
GROUP BY username
ORDER BY access_count DESC;

-- 变更管理审计
SELECT
    table_name,
    operation,
    COUNT(*) as change_count
FROM audit_log
WHERE operation IN ('INSERT', 'UPDATE', 'DELETE')
AND event_time >= NOW() - INTERVAL '30 days'
GROUP BY table_name, operation
ORDER BY change_count DESC;
```

---

## 5. 数据主权管理

### 5.1 数据本地化

```sql
-- 按地区创建表空间
CREATE TABLESPACE eu_tablespace LOCATION '/data/eu';
CREATE TABLESPACE us_tablespace LOCATION '/data/us';
CREATE TABLESPACE asia_tablespace LOCATION '/data/asia';

-- 按地区存储数据
CREATE TABLE eu_users (
    id SERIAL PRIMARY KEY,
    ...
) TABLESPACE eu_tablespace;

CREATE TABLE us_users (
    id SERIAL PRIMARY KEY,
    ...
) TABLESPACE us_tablespace;
```

### 5.2 跨境数据传输控制

```sql
-- 数据导出控制
CREATE OR REPLACE FUNCTION export_data_with_consent(
    table_name TEXT,
    region TEXT,
    consent_given BOOLEAN
)
RETURNS TABLE (data JSONB) AS $$
BEGIN
    IF NOT consent_given THEN
        RAISE EXCEPTION 'Data export requires explicit consent';
    END IF;

    IF region != current_setting('app.data_region') THEN
        RAISE EXCEPTION 'Cross-region data transfer not allowed';
    END IF;

    RETURN QUERY
    EXECUTE format('SELECT to_jsonb(t.*) FROM %I t', table_name);
END;
$$ LANGUAGE plpgsql;
```

---

## 6. 安全事件响应

### 6.1 威胁检测

```sql
-- 异常登录检测
SELECT
    username,
    ip_address,
    COUNT(*) as login_attempts,
    MIN(event_time) as first_attempt,
    MAX(event_time) as last_attempt
FROM audit_log
WHERE operation = 'LOGIN'
AND event_time >= NOW() - INTERVAL '1 hour'
GROUP BY username, ip_address
HAVING COUNT(*) > 5;  -- 超过5次登录尝试

-- 异常查询检测
SELECT
    username,
    query,
    COUNT(*) as query_count
FROM pg_stat_statements
WHERE calls > 1000
AND mean_exec_time > 1000
GROUP BY username, query
ORDER BY query_count DESC;
```

### 6.2 安全事件响应流程

```sql
-- 创建安全事件表
CREATE TABLE security_incidents (
    id SERIAL PRIMARY KEY,
    incident_time TIMESTAMPTZ DEFAULT NOW(),
    incident_type TEXT,
    severity TEXT,
    description TEXT,
    username TEXT,
    ip_address INET,
    status TEXT DEFAULT 'open',
    resolution TEXT
);

-- 自动记录安全事件
CREATE OR REPLACE FUNCTION log_security_incident(
    p_type TEXT,
    p_severity TEXT,
    p_description TEXT
)
RETURNS void AS $$
BEGIN
    INSERT INTO security_incidents (
        incident_type,
        severity,
        description,
        username,
        ip_address
    )
    VALUES (
        p_type,
        p_severity,
        p_description,
        current_user,
        inet_client_addr()
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 7. 最佳实践

### 7.1 安全策略

- ✅ **最小权限原则**: 只授予必要的权限
- ✅ **深度防御**: 多层安全防护
- ✅ **定期审计**: 定期审查安全配置
- ✅ **持续监控**: 24/7安全监控

### 7.2 合规性管理

- ✅ **明确合规要求**: 了解适用的合规标准
- ✅ **实施合规措施**: 实施必要的技术措施
- ✅ **定期合规审计**: 定期进行合规性检查
- ✅ **文档化**: 完整记录合规措施

### 7.3 数据保护

- ✅ **数据加密**: 敏感数据加密存储
- ✅ **数据脱敏**: 非生产环境使用脱敏数据
- ✅ **数据备份**: 定期备份加密数据
- ✅ **数据销毁**: 安全的数据销毁流程

---

## 📚 相关文档

- [05-安全与合规/安全加固](../05-安全与合规/安全加固/PostgreSQL安全加固完整指南.md) - 基础安全加固
- [合规性管理](./合规性管理.md) - 合规性管理详细指南
- [数据主权管理](./数据主权管理.md) - 数据主权管理
- [多租户架构完整指南](./多租户架构完整指南.md) - 多租户安全

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
