# PostgreSQLåˆè§„æ€§ç®¡ç†æŒ‡å—

> **PostgreSQLç‰ˆæœ¬**: 17+/18+
> **é€‚ç”¨åœºæ™¯**: é‡‘èã€åŒ»ç–—ã€æ”¿åºœç­‰åˆè§„æ€§è¦æ±‚é«˜çš„è¡Œä¸š
> **éš¾åº¦ç­‰çº§**: â­â­â­â­ é«˜çº§

---

## ğŸ“‹ ç›®å½•

- [PostgreSQLåˆè§„æ€§ç®¡ç†æŒ‡å—](#postgresqlåˆè§„æ€§ç®¡ç†æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯åˆè§„æ€§ç®¡ç†ï¼Ÿ](#11-ä»€ä¹ˆæ˜¯åˆè§„æ€§ç®¡ç†)
    - [1.2 åˆè§„æ€§ç®¡ç†ç›®æ ‡](#12-åˆè§„æ€§ç®¡ç†ç›®æ ‡)
  - [2. GDPRåˆè§„](#2-gdpråˆè§„)
    - [2.1 GDPRæ ¸å¿ƒè¦æ±‚](#21-gdpræ ¸å¿ƒè¦æ±‚)
      - [2.1.1 æ•°æ®ä¸»ä½“æƒåˆ©](#211-æ•°æ®ä¸»ä½“æƒåˆ©)
      - [2.1.2 æ•°æ®å¤„ç†åˆæ³•æ€§](#212-æ•°æ®å¤„ç†åˆæ³•æ€§)
    - [2.2 æ•°æ®ä¿æŠ¤æªæ–½](#22-æ•°æ®ä¿æŠ¤æªæ–½)
  - [3. HIPAAåˆè§„](#3-hipaaåˆè§„)
    - [3.1 HIPAAæ ¸å¿ƒè¦æ±‚](#31-hipaaæ ¸å¿ƒè¦æ±‚)
      - [3.1.1 å—ä¿æŠ¤å¥åº·ä¿¡æ¯ï¼ˆPHIï¼‰ä¿æŠ¤](#311-å—ä¿æŠ¤å¥åº·ä¿¡æ¯phiä¿æŠ¤)
      - [3.1.2 è®¿é—®æ§åˆ¶](#312-è®¿é—®æ§åˆ¶)
    - [3.2 å®¡è®¡è¦æ±‚](#32-å®¡è®¡è¦æ±‚)
  - [4. SOC2åˆè§„](#4-soc2åˆè§„)
    - [4.1 SOC2æ§åˆ¶è¦æ±‚](#41-soc2æ§åˆ¶è¦æ±‚)
      - [4.1.1 è®¿é—®æ§åˆ¶](#411-è®¿é—®æ§åˆ¶)
      - [4.1.2 å˜æ›´ç®¡ç†](#412-å˜æ›´ç®¡ç†)
    - [4.2 ç›‘æ§å’Œæ—¥å¿—](#42-ç›‘æ§å’Œæ—¥å¿—)
  - [5. PCI DSSåˆè§„](#5-pci-dssåˆè§„)
    - [5.1 æ”¯ä»˜å¡æ•°æ®ä¿æŠ¤](#51-æ”¯ä»˜å¡æ•°æ®ä¿æŠ¤)
    - [5.2 ç½‘ç»œéš”ç¦»](#52-ç½‘ç»œéš”ç¦»)
  - [6. è¡Œä¸šç‰¹å®šåˆè§„](#6-è¡Œä¸šç‰¹å®šåˆè§„)
    - [6.1 é‡‘èè¡Œä¸š](#61-é‡‘èè¡Œä¸š)
    - [6.2 æ”¿åºœè¡Œä¸š](#62-æ”¿åºœè¡Œä¸š)
  - [7. åˆè§„æ€§æ£€æŸ¥æ¸…å•](#7-åˆè§„æ€§æ£€æŸ¥æ¸…å•)
    - [7.1 GDPRæ£€æŸ¥æ¸…å•](#71-gdpræ£€æŸ¥æ¸…å•)
    - [7.2 HIPAAæ£€æŸ¥æ¸…å•](#72-hipaaæ£€æŸ¥æ¸…å•)
    - [7.3 SOC2æ£€æŸ¥æ¸…å•](#73-soc2æ£€æŸ¥æ¸…å•)
    - [7.4 PCI DSSæ£€æŸ¥æ¸…å•](#74-pci-dssæ£€æŸ¥æ¸…å•)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯åˆè§„æ€§ç®¡ç†ï¼Ÿ

åˆè§„æ€§ç®¡ç†æ˜¯ç¡®ä¿æ•°æ®åº“ç³»ç»Ÿç¬¦åˆç›¸å…³æ³•å¾‹æ³•è§„ã€è¡Œä¸šæ ‡å‡†å’Œå†…éƒ¨æ”¿ç­–çš„è¿‡ç¨‹ã€‚

**ä¸»è¦åˆè§„æ ‡å‡†**:

- âœ… **GDPR**: æ¬§ç›Ÿé€šç”¨æ•°æ®ä¿æŠ¤æ¡ä¾‹
- âœ… **HIPAA**: ç¾å›½å¥åº·ä¿é™©æµé€šä¸è´£ä»»æ³•æ¡ˆ
- âœ… **SOC2**: æœåŠ¡ç»„ç»‡æ§åˆ¶2
- âœ… **PCI DSS**: æ”¯ä»˜å¡è¡Œä¸šæ•°æ®å®‰å…¨æ ‡å‡†
- âœ… **è¡Œä¸šç‰¹å®š**: é‡‘èã€åŒ»ç–—ã€æ”¿åºœç­‰è¡Œä¸šæ ‡å‡†

### 1.2 åˆè§„æ€§ç®¡ç†ç›®æ ‡

- **æ•°æ®ä¿æŠ¤**: ä¿æŠ¤ä¸ªäººå’Œæ•æ„Ÿæ•°æ®
- **éšç§ä¿æŠ¤**: å°Šé‡ç”¨æˆ·éšç§æƒ
- **å®¡è®¡è¿½è¸ª**: å®Œæ•´çš„æ“ä½œå®¡è®¡
- **é£é™©æ§åˆ¶**: é™ä½åˆè§„é£é™©

---

## 2. GDPRåˆè§„

### 2.1 GDPRæ ¸å¿ƒè¦æ±‚

#### 2.1.1 æ•°æ®ä¸»ä½“æƒåˆ©

```sql
-- 1. æ•°æ®è®¿é—®æƒï¼ˆRight to Accessï¼‰
CREATE OR REPLACE FUNCTION get_user_data(user_id INT)
RETURNS TABLE (
    table_name TEXT,
    data JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 'users'::TEXT, to_jsonb(u.*)
    FROM users u WHERE u.id = user_id
    UNION ALL
    SELECT 'orders'::TEXT, to_jsonb(o.*)
    FROM orders o WHERE o.user_id = user_id;
END;
$$ LANGUAGE plpgsql;

-- 2. æ•°æ®åˆ é™¤æƒï¼ˆRight to Erasureï¼‰
CREATE OR REPLACE FUNCTION delete_user_data(user_id INT)
RETURNS void AS $$
BEGIN
    -- åˆ é™¤ç”¨æˆ·æ•°æ®
    DELETE FROM orders WHERE user_id = user_id;
    DELETE FROM users WHERE id = user_id;

    -- è®°å½•åˆ é™¤æ“ä½œ
    INSERT INTO audit_log (username, operation, new_values)
    VALUES (current_user, 'GDPR_DELETE', jsonb_build_object('user_id', user_id));
END;
$$ LANGUAGE plpgsql;

-- 3. æ•°æ®å¯ç§»æ¤æƒï¼ˆRight to Data Portabilityï¼‰
CREATE OR REPLACE FUNCTION export_user_data(user_id INT)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user', (SELECT to_jsonb(u.*) FROM users u WHERE u.id = user_id),
        'orders', (SELECT jsonb_agg(to_jsonb(o.*)) FROM orders o WHERE o.user_id = user_id)
    ) INTO result;

    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

#### 2.1.2 æ•°æ®å¤„ç†åˆæ³•æ€§

```sql
-- è®°å½•æ•°æ®å¤„ç†åˆæ³•æ€§åŸºç¡€
CREATE TABLE data_processing_consent (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    processing_purpose TEXT NOT NULL,
    legal_basis TEXT NOT NULL,  -- 'consent', 'contract', 'legal_obligation', etc.
    consent_given BOOLEAN DEFAULT false,
    consent_date TIMESTAMPTZ,
    withdrawal_date TIMESTAMPTZ
);

-- æ£€æŸ¥æ•°æ®å¤„ç†åˆæ³•æ€§
CREATE OR REPLACE FUNCTION check_processing_consent(
    p_user_id INT,
    p_purpose TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    v_consent BOOLEAN;
BEGIN
    SELECT consent_given INTO v_consent
    FROM data_processing_consent
    WHERE user_id = p_user_id
    AND processing_purpose = p_purpose
    AND withdrawal_date IS NULL;

    RETURN COALESCE(v_consent, false);
END;
$$ LANGUAGE plpgsql;
```

### 2.2 æ•°æ®ä¿æŠ¤æªæ–½

```sql
-- æ•°æ®åŠ å¯†
CREATE EXTENSION pgcrypto;

-- åŠ å¯†å­˜å‚¨ä¸ªäººæ•°æ®
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username TEXT,
    email_encrypted BYTEA,
    phone_encrypted BYTEA
);

-- æ•°æ®è„±æ•ï¼ˆç”¨äºéç”Ÿäº§ç¯å¢ƒï¼‰
CREATE OR REPLACE FUNCTION mask_personal_data(data TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN regexp_replace(data, '(.)(.*)', '\1***', 'g');
END;
$$ LANGUAGE plpgsql;
```

---

## 3. HIPAAåˆè§„

### 3.1 HIPAAæ ¸å¿ƒè¦æ±‚

#### 3.1.1 å—ä¿æŠ¤å¥åº·ä¿¡æ¯ï¼ˆPHIï¼‰ä¿æŠ¤

```sql
-- åˆ›å»ºæ‚£è€…è®°å½•è¡¨
CREATE TABLE patient_records (
    id SERIAL PRIMARY KEY,
    patient_id TEXT NOT NULL,
    medical_record_number TEXT,
    diagnosis TEXT,
    treatment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å¯ç”¨RLS
ALTER TABLE patient_records ENABLE ROW LEVEL SECURITY;

-- åŸºäºæˆæƒçš„è®¿é—®æ§åˆ¶
CREATE POLICY hipaa_access ON patient_records
    FOR ALL
    USING (
        current_user IN (
            SELECT employee_id
            FROM authorized_healthcare_providers
            WHERE department = 'authorized'
            AND access_level >= (
                SELECT required_access_level
                FROM access_requirements
                WHERE record_type = 'patient_records'
            )
        )
    );

-- å®¡è®¡æ‰€æœ‰PHIè®¿é—®
CREATE TRIGGER hipaa_audit_trigger
AFTER SELECT OR INSERT OR UPDATE OR DELETE ON patient_records
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();
```

#### 3.1.2 è®¿é—®æ§åˆ¶

```sql
-- åˆ›å»ºæˆæƒåŒ»ç–—æä¾›è€…è¡¨
CREATE TABLE authorized_healthcare_providers (
    employee_id TEXT PRIMARY KEY,
    department TEXT,
    access_level INT,
    authorization_date DATE,
    expiration_date DATE
);

-- æ£€æŸ¥è®¿é—®æˆæƒ
CREATE OR REPLACE FUNCTION check_hipaa_access(
    p_employee_id TEXT,
    p_record_type TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    v_authorized BOOLEAN;
BEGIN
    SELECT EXISTS(
        SELECT 1
        FROM authorized_healthcare_providers
        WHERE employee_id = p_employee_id
        AND expiration_date > CURRENT_DATE
        AND access_level >= (
            SELECT required_access_level
            FROM access_requirements
            WHERE record_type = p_record_type
        )
    ) INTO v_authorized;

    RETURN v_authorized;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 å®¡è®¡è¦æ±‚

```sql
-- HIPAAè¦æ±‚å®Œæ•´çš„å®¡è®¡æ—¥å¿—
CREATE TABLE hipaa_audit_log (
    id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMPTZ DEFAULT NOW(),
    user_id TEXT,
    patient_id TEXT,
    action TEXT,
    resource_type TEXT,
    resource_id TEXT,
    ip_address INET,
    success BOOLEAN
);

-- è®°å½•æ‰€æœ‰PHIè®¿é—®
CREATE OR REPLACE FUNCTION log_hipaa_access(
    p_user_id TEXT,
    p_patient_id TEXT,
    p_action TEXT,
    p_resource_type TEXT,
    p_resource_id TEXT
)
RETURNS void AS $$
BEGIN
    INSERT INTO hipaa_audit_log (
        user_id,
        patient_id,
        action,
        resource_type,
        resource_id,
        ip_address,
        success
    )
    VALUES (
        p_user_id,
        p_patient_id,
        p_action,
        p_resource_type,
        p_resource_id,
        inet_client_addr(),
        true
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 4. SOC2åˆè§„

### 4.1 SOC2æ§åˆ¶è¦æ±‚

#### 4.1.1 è®¿é—®æ§åˆ¶

```sql
-- ç”¨æˆ·è®¿é—®ç®¡ç†
CREATE TABLE user_access_management (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    role TEXT NOT NULL,
    granted_date DATE,
    revoked_date DATE,
    granted_by TEXT,
    status TEXT DEFAULT 'active'
);

-- å®šæœŸå®¡æŸ¥è®¿é—®æƒé™
CREATE OR REPLACE FUNCTION review_user_access()
RETURNS TABLE (
    user_id TEXT,
    role TEXT,
    last_review_date DATE,
    days_since_review INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        uam.user_id,
        uam.role,
        MAX(ar.review_date) as last_review_date,
        EXTRACT(DAY FROM CURRENT_DATE - MAX(ar.review_date))::INT as days_since_review
    FROM user_access_management uam
    LEFT JOIN access_reviews ar ON ar.user_id = uam.user_id
    WHERE uam.status = 'active'
    GROUP BY uam.user_id, uam.role
    HAVING MAX(ar.review_date) IS NULL
    OR EXTRACT(DAY FROM CURRENT_DATE - MAX(ar.review_date)) > 90;
END;
$$ LANGUAGE plpgsql;
```

#### 4.1.2 å˜æ›´ç®¡ç†

```sql
-- å˜æ›´ç®¡ç†è¡¨
CREATE TABLE change_management (
    id SERIAL PRIMARY KEY,
    change_id TEXT UNIQUE,
    change_type TEXT,
    description TEXT,
    requested_by TEXT,
    approved_by TEXT,
    change_date TIMESTAMPTZ,
    status TEXT,
    rollback_plan TEXT
);

-- è®°å½•æ‰€æœ‰æ•°æ®åº“å˜æ›´
CREATE OR REPLACE FUNCTION log_database_change(
    p_change_type TEXT,
    p_description TEXT
)
RETURNS void AS $$
BEGIN
    INSERT INTO change_management (
        change_id,
        change_type,
        description,
        requested_by,
        change_date,
        status
    )
    VALUES (
        gen_random_uuid()::TEXT,
        p_change_type,
        p_description,
        current_user,
        NOW(),
        'pending'
    );
END;
$$ LANGUAGE plpgsql;
```

### 4.2 ç›‘æ§å’Œæ—¥å¿—

```sql
-- SOC2è¦æ±‚å®Œæ•´çš„ç›‘æ§å’Œæ—¥å¿—
SELECT
    event_time,
    username,
    operation,
    table_name,
    ip_address
FROM audit_log
WHERE event_time >= NOW() - INTERVAL '90 days'
ORDER BY event_time DESC;

-- å¼‚å¸¸æ´»åŠ¨æ£€æµ‹
SELECT
    username,
    COUNT(*) as event_count,
    COUNT(DISTINCT ip_address) as unique_ips
FROM audit_log
WHERE event_time >= NOW() - INTERVAL '24 hours'
GROUP BY username
HAVING COUNT(*) > 100 OR COUNT(DISTINCT ip_address) > 5;
```

---

## 5. PCI DSSåˆè§„

### 5.1 æ”¯ä»˜å¡æ•°æ®ä¿æŠ¤

```sql
-- æ”¯ä»˜å¡æ•°æ®åŠ å¯†å­˜å‚¨
CREATE TABLE payment_cards (
    id SERIAL PRIMARY KEY,
    card_number_encrypted BYTEA,
    cardholder_name TEXT,
    expiry_date TEXT,
    cvv_encrypted BYTEA,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_card_data(
    card_number TEXT,
    cvv TEXT,
    encryption_key TEXT
)
RETURNS TABLE (
    card_number_encrypted BYTEA,
    cvv_encrypted BYTEA
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        pgp_sym_encrypt(card_number, encryption_key),
        pgp_sym_encrypt(cvv, encryption_key);
END;
$$ LANGUAGE plpgsql;

-- è®¿é—®æ§åˆ¶
ALTER TABLE payment_cards ENABLE ROW LEVEL SECURITY;

CREATE POLICY pci_access ON payment_cards
    FOR SELECT
    USING (
        current_user IN (
            SELECT employee_id
            FROM authorized_payment_handlers
            WHERE department = 'payment_processing'
        )
    );
```

### 5.2 ç½‘ç»œéš”ç¦»

```sql
-- PCI DSSè¦æ±‚ç½‘ç»œéš”ç¦»
-- ä½¿ç”¨ä¸åŒçš„æ•°æ®åº“æˆ–Schemaéš”ç¦»æ”¯ä»˜æ•°æ®
CREATE SCHEMA payment_data;
CREATE SCHEMA general_data;

-- é™åˆ¶è®¿é—®
REVOKE ALL ON SCHEMA payment_data FROM PUBLIC;
GRANT USAGE ON SCHEMA payment_data TO payment_processor_role;
```

---

## 6. è¡Œä¸šç‰¹å®šåˆè§„

### 6.1 é‡‘èè¡Œä¸š

```sql
-- é‡‘èæ•°æ®ä¿ç•™è¦æ±‚
CREATE POLICY financial_data_retention ON financial_transactions
    FOR DELETE
    USING (transaction_date < NOW() - INTERVAL '7 years');

-- äº¤æ˜“å®¡è®¡
CREATE TRIGGER financial_audit_trigger
AFTER INSERT OR UPDATE OR DELETE ON financial_transactions
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();
```

### 6.2 æ”¿åºœè¡Œä¸š

```sql
-- æ•°æ®åˆ†ç±»
CREATE TABLE classified_data (
    id SERIAL PRIMARY KEY,
    classification_level TEXT,  -- 'public', 'internal', 'confidential', 'secret'
    data_content TEXT,
    access_control_list TEXT[]
);

-- åŸºäºåˆ†ç±»çš„è®¿é—®æ§åˆ¶
CREATE POLICY classified_access ON classified_data
    FOR ALL
    USING (
        classification_level = ANY(
            SELECT security_clearance
            FROM authorized_personnel
            WHERE employee_id = current_user
        )
    );
```

---

## 7. åˆè§„æ€§æ£€æŸ¥æ¸…å•

### 7.1 GDPRæ£€æŸ¥æ¸…å•

- [ ] æ•°æ®ä¸»ä½“æƒåˆ©å®ç°ï¼ˆè®¿é—®ã€åˆ é™¤ã€å¯ç§»æ¤ï¼‰
- [ ] æ•°æ®å¤„ç†åˆæ³•æ€§è®°å½•
- [ ] æ•°æ®ä¿æŠ¤æªæ–½ï¼ˆåŠ å¯†ã€è„±æ•ï¼‰
- [ ] æ•°æ®æ³„éœ²é€šçŸ¥æœºåˆ¶
- [ ] æ•°æ®å¤„ç†åè®®ï¼ˆDPAï¼‰

### 7.2 HIPAAæ£€æŸ¥æ¸…å•

- [ ] PHIè®¿é—®æ§åˆ¶
- [ ] æˆæƒåŒ»ç–—æä¾›è€…ç®¡ç†
- [ ] å®Œæ•´å®¡è®¡æ—¥å¿—
- [ ] æ•°æ®åŠ å¯†
- [ ] ä¸šåŠ¡ä¼™ä¼´åè®®ï¼ˆBAAï¼‰

### 7.3 SOC2æ£€æŸ¥æ¸…å•

- [ ] è®¿é—®æ§åˆ¶ç®¡ç†
- [ ] å˜æ›´ç®¡ç†æµç¨‹
- [ ] ç›‘æ§å’Œæ—¥å¿—
- [ ] å®‰å…¨äº‹ä»¶å“åº”
- [ ] å®šæœŸåˆè§„å®¡è®¡

### 7.4 PCI DSSæ£€æŸ¥æ¸…å•

- [ ] æ”¯ä»˜å¡æ•°æ®åŠ å¯†
- [ ] ç½‘ç»œéš”ç¦»
- [ ] è®¿é—®æ§åˆ¶
- [ ] å®‰å…¨ç›‘æ§
- [ ] æ¼æ´ç®¡ç†

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [ä¼ä¸šçº§å®‰å…¨æ·±åŒ–](./ä¼ä¸šçº§å®‰å…¨æ·±åŒ–.md) - ä¼ä¸šçº§å®‰å…¨æ·±åŒ–
- [æ•°æ®ä¸»æƒç®¡ç†](./æ•°æ®ä¸»æƒç®¡ç†.md) - æ•°æ®ä¸»æƒç®¡ç†
- [05-å®‰å…¨ä¸åˆè§„](../05-å®‰å…¨ä¸åˆè§„/README.md) - å®‰å…¨ä¸åˆè§„ä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
