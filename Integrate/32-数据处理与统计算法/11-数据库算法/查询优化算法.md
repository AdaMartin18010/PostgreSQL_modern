# PostgreSQL 查询优化算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 查询优化 | 执行计划
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)

---

## 📋 目录

- [PostgreSQL 查询优化算法完整指南](#postgresql-查询优化算法完整指南)
  - [📋 目录](#-目录)
  - [查询优化概述](#查询优化概述)
    - [核心算法](#核心算法)
  - [1. 查询计划分析](#1-查询计划分析)
    - [1.1 执行计划统计](#11-执行计划统计)
  - [2. 查询重写](#2-查询重写)
    - [2.1 查询简化](#21-查询简化)
  - [3. 成本估算](#3-成本估算)
    - [3.1 查询成本分析](#31-查询成本分析)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 慢查询优化](#41-慢查询优化)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 查询优化概述

**查询优化**通过分析查询计划，选择最优执行策略。

### 核心算法

| 算法 | 用途 | 复杂度 |
|------|------|--------|
| **计划枚举** | 生成执行计划 | O(n!) |
| **成本估算** | 评估计划成本 | O(n) |
| **查询重写** | 优化查询结构 | O(n) |

---

## 1. 查询计划分析

### 1.1 执行计划统计

**执行计划统计**分析查询执行计划的关键指标。

```sql
-- 创建查询计划统计表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 已存在，先删除';
            DROP TABLE query_plan_stats CASCADE;
        END IF;

        CREATE TABLE query_plan_stats (
            query_id VARCHAR(100) PRIMARY KEY,
            query_text TEXT NOT NULL,
            execution_time_ms NUMERIC(10, 2) NOT NULL,
            plan_rows BIGINT NOT NULL,
            plan_width INTEGER NOT NULL,
            total_cost NUMERIC(10, 2) NOT NULL,
            actual_rows BIGINT,
            actual_time_ms NUMERIC(10, 2)
        );

        INSERT INTO query_plan_stats (query_id, query_text, execution_time_ms, plan_rows, plan_width, total_cost, actual_rows, actual_time_ms) VALUES
            ('Q001', 'SELECT * FROM users WHERE email = $1', 125.5, 1, 200, 25.5, 1, 120.3),
            ('Q002', 'SELECT * FROM orders WHERE date > $1', 2500.0, 10000, 300, 500.0, 50000, 2800.0),
            ('Q003', 'SELECT COUNT(*) FROM products', 50.2, 1, 4, 10.2, 1, 45.8);

        RAISE NOTICE '表 query_plan_stats 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 query_plan_stats 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 执行计划分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法分析执行计划';
            RETURN;
        END IF;
        RAISE NOTICE '开始分析执行计划';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '执行计划分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 分析查询计划准确性
SELECT
    query_id,
    LEFT(query_text, 50) AS query_preview,
    plan_rows AS estimated_rows,
    actual_rows,
    CASE
        WHEN actual_rows = 0 THEN NULL
        ELSE ROUND(ABS(plan_rows - actual_rows)::numeric / NULLIF(actual_rows, 0), 4)
    END AS estimation_error,
    total_cost AS estimated_cost,
    actual_time_ms,
    CASE
        WHEN actual_rows IS NULL OR actual_rows = 0 THEN 'No data'
        WHEN ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 10 THEN 'Poor estimation'
        WHEN ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 2 THEN 'Moderate estimation'
        ELSE 'Good estimation'
    END AS estimation_quality,
    CASE
        WHEN actual_time_ms > 1000 THEN 'Slow query'
        WHEN actual_time_ms > 100 THEN 'Moderate'
        ELSE 'Fast'
    END AS performance_category
FROM query_plan_stats
ORDER BY actual_time_ms DESC NULLS LAST;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    query_id,
    AVG(execution_time_ms) AS avg_execution_time
FROM query_plan_stats
GROUP BY query_id;
```

---

## 2. 查询重写

### 2.1 查询简化

**查询简化**识别可以优化的查询模式。

```sql
-- 查询重写建议（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法生成查询重写建议';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成查询重写建议';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询重写建议生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 识别可优化的查询模式
WITH query_patterns AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        CASE
            WHEN query_text LIKE '%SELECT *%' THEN 'Avoid SELECT *'
            WHEN query_text LIKE '%LIKE ''%''%' THEN 'Consider full-text search'
            WHEN query_text LIKE '%NOT IN%' THEN 'Consider NOT EXISTS'
            WHEN query_text LIKE '%OR%' AND execution_time_ms > 500 THEN 'Consider UNION'
            ELSE NULL
        END AS optimization_pattern,
        CASE
            WHEN plan_rows::numeric / NULLIF(actual_rows, 0) > 10 OR
                 actual_rows::numeric / NULLIF(plan_rows, 0) > 10 THEN TRUE
            ELSE FALSE
        END AS needs_statistics_update
    FROM query_plan_stats
)
SELECT
    query_id,
    LEFT(query_text, 60) AS query_preview,
    execution_time_ms,
    optimization_pattern,
    needs_statistics_update,
    CASE
        WHEN optimization_pattern IS NOT NULL THEN 'Rewrite recommended'
        WHEN needs_statistics_update THEN 'Update statistics'
        ELSE 'No optimization needed'
    END AS recommendation
FROM query_patterns
WHERE optimization_pattern IS NOT NULL OR needs_statistics_update
ORDER BY execution_time_ms DESC;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) FILTER (WHERE query_text LIKE '%SELECT *%') AS select_star_queries,
    COUNT(*) FILTER (WHERE execution_time_ms > 1000) AS slow_queries
FROM query_plan_stats;
```

---

## 3. 成本估算

### 3.1 查询成本分析

**查询成本分析**评估查询的资源消耗。

```sql
-- 查询成本分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法进行成本分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行查询成本分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询成本分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 分析查询成本
SELECT
    query_id,
    LEFT(query_text, 50) AS query_preview,
    total_cost AS estimated_cost,
    actual_time_ms,
    plan_rows AS estimated_rows,
    actual_rows,
    CASE
        WHEN actual_rows = 0 THEN NULL
        ELSE ROUND((total_cost / NULLIF(actual_rows, 0))::numeric, 4)
    END AS cost_per_row,
    CASE
        WHEN actual_time_ms > 1000 THEN 'High cost'
        WHEN actual_time_ms > 100 THEN 'Medium cost'
        ELSE 'Low cost'
    END AS cost_category,
    CASE
        WHEN actual_rows IS NOT NULL AND ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 5 THEN
            'Consider ANALYZE to update statistics'
        WHEN actual_time_ms > 1000 THEN
            'Consider query optimization or indexing'
        ELSE 'Query is efficient'
    END AS optimization_suggestion
FROM query_plan_stats
ORDER BY actual_time_ms DESC NULLS LAST;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    AVG(total_cost) AS avg_estimated_cost,
    AVG(actual_time_ms) AS avg_actual_time
FROM query_plan_stats
WHERE actual_time_ms IS NOT NULL;
```

---

## 4. 实际应用案例

### 4.1 慢查询优化

**慢查询优化**识别和优化慢查询。

```sql
-- 慢查询优化示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法进行慢查询优化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行慢查询优化分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '慢查询优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 识别慢查询并提供优化建议
WITH slow_queries AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        total_cost,
        CASE
            WHEN query_text LIKE '%JOIN%' AND execution_time_ms > 500 THEN 'Consider index on join columns'
            WHEN query_text LIKE '%WHERE%' AND execution_time_ms > 500 THEN 'Check WHERE clause indexes'
            WHEN query_text LIKE '%ORDER BY%' AND execution_time_ms > 500 THEN 'Consider index on ORDER BY columns'
            WHEN query_text LIKE '%GROUP BY%' AND execution_time_ms > 500 THEN 'Consider index on GROUP BY columns'
            ELSE 'Review query structure'
        END AS optimization_hint
    FROM query_plan_stats
    WHERE execution_time_ms > 100
)
SELECT
    query_id,
    LEFT(query_text, 80) AS query_preview,
    execution_time_ms,
    ROUND((plan_rows::numeric / NULLIF(actual_rows, 0))::numeric, 2) AS estimation_ratio,
    optimization_hint,
    CASE
        WHEN execution_time_ms > 5000 THEN 'Critical - Immediate optimization needed'
        WHEN execution_time_ms > 1000 THEN 'High priority'
        ELSE 'Medium priority'
    END AS priority
FROM slow_queries
ORDER BY execution_time_ms DESC;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) AS slow_query_count,
    AVG(execution_time_ms) AS avg_execution_time
FROM query_plan_stats
WHERE execution_time_ms > 100;
```

---

## 📊 性能优化建议

1. **统计信息**: 定期更新表统计信息
2. **索引**: 为常用查询创建索引
3. **查询重写**: 优化查询结构
4. **监控**: 持续监控查询性能

## 🎯 最佳实践

1. **执行计划**: 定期分析执行计划
2. **参数化**: 使用参数化查询
3. **避免全表扫描**: 确保有适当的索引
4. **批量操作**: 优化批量操作

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
