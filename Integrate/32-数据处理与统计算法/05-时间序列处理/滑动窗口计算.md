# PostgreSQL 滑动窗口计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 滑动窗口 | 移动平均
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 滑动窗口计算完整指南](#postgresql-滑动窗口计算完整指南)
  - [📋 目录](#-目录)
  - [滑动窗口计算概述](#滑动窗口计算概述)
    - [核心窗口功能](#核心窗口功能)
  - [1. 移动平均](#1-移动平均)
    - [1.1 简单移动平均](#11-简单移动平均)
  - [2. 指数移动平均](#2-指数移动平均)
    - [2.1 EMA计算](#21-ema计算)
  - [3. 滚动统计](#3-滚动统计)
    - [3.1 滚动统计指标](#31-滚动统计指标)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 趋势分析](#41-趋势分析)

---

## 滑动窗口计算概述

**滑动窗口计算**在固定大小的窗口内进行统计计算，用于平滑处理和趋势分析。

### 核心窗口功能

| 功能 | 用途 | 复杂度 |
|------|------|--------|
| **移动平均** | 平滑处理 | O(n) |
| **指数移动平均** | 加权平滑 | O(n) |
| **滚动统计** | 窗口统计 | O(n) |

---

## 1. 移动平均

### 1.1 简单移动平均

**简单移动平均**计算固定窗口内的平均值。

```sql
-- 简单移动平均（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行简单移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '移动平均准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS moving_avg_30
FROM time_series
ORDER BY date;
```

---

## 2. 指数移动平均

### 2.1 EMA计算

**指数移动平均**使用指数加权计算移动平均。

```sql
-- 指数移动平均（带错误处理和性能测试）
DO $$
DECLARE
    alpha NUMERIC := 0.3;  -- 平滑系数
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行指数移动平均';
            RETURN;
        END IF;

        RAISE NOTICE '开始执行指数移动平均，平滑系数: %', alpha;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '指数移动平均准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH ema_calc AS (
    SELECT
        date,
        value,
        value AS ema,
        0.3 AS alpha
    FROM time_series
    WHERE date = (SELECT MIN(date) FROM time_series)
    UNION ALL
    SELECT
        t.date,
        t.value,
        e.ema * (1 - e.alpha) + t.value * e.alpha AS ema,
        e.alpha
    FROM time_series t
    JOIN ema_calc e ON t.date = e.date + INTERVAL '1 day'
)
SELECT * FROM ema_calc ORDER BY date;
```

---

## 3. 滚动统计

### 3.1 滚动统计指标

**滚动统计**计算窗口内的多种统计指标。

```sql
-- 滚动统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行滚动统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行滚动统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '滚动统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_avg_30,
    STDDEV(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_stddev_30,
    MIN(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_min_30,
    MAX(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_max_30
FROM time_series
ORDER BY date;
```

---

## 4. 实际应用案例

### 4.1 趋势分析

**趋势分析**使用滑动窗口分析趋势。

```sql
-- 趋势分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行趋势分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行趋势分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH daily_sales AS (
    SELECT
        DATE_TRUNC('day', sale_date) AS date,
        SUM(amount) AS daily_amount
    FROM sales
    GROUP BY DATE_TRUNC('day', sale_date)
)
SELECT
    date,
    daily_amount,
    AVG(daily_amount) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    daily_amount - LAG(daily_amount, 1) OVER (ORDER BY date) AS day_over_day_change,
    (daily_amount - LAG(daily_amount, 7) OVER (ORDER BY date)) / NULLIF(LAG(daily_amount, 7) OVER (ORDER BY date), 0) * 100 AS week_over_week_change_pct
FROM daily_sales
ORDER BY date;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
