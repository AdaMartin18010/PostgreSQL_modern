# PostgreSQL 时间序列聚合完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 时间序列 | 时间聚合
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 时间序列聚合完整指南](#postgresql-时间序列聚合完整指南)
  - [📋 目录](#-目录)
  - [时间序列聚合概述](#时间序列聚合概述)
    - [核心聚合功能](#核心聚合功能)
  - [1. 时间桶聚合](#1-时间桶聚合)
    - [1.1 date\_bin聚合](#11-date_bin聚合)
  - [2. 时间分组聚合](#2-时间分组聚合)
    - [2.1 DATE\_TRUNC聚合](#21-date_trunc聚合)
  - [3. 时间序列填充](#3-时间序列填充)
    - [3.1 生成连续时间序列](#31-生成连续时间序列)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 多时间粒度聚合](#41-多时间粒度聚合)

---

## 时间序列聚合概述

**时间序列聚合**将时间序列数据按时间间隔进行聚合统计。

### 核心聚合功能

| 功能 | 用途 | 复杂度 |
|------|------|--------|
| **DATE_TRUNC** | 时间截断 | O(n) |
| **date_bin** | 时间桶 | O(n) |
| **时间填充** | 连续时间序列 | O(n) |

---

## 1. 时间桶聚合

### 1.1 date_bin聚合

**date_bin聚合**使用固定时间间隔进行聚合。

```sql
-- date_bin时间桶聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行date_bin聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行date_bin时间桶聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'date_bin聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date_bin('1 hour', timestamp, '2024-01-01 00:00:00'::timestamp) AS hour_bucket,
    COUNT(*) AS count,
    AVG(value) AS avg_value,
    SUM(value) AS total_value
FROM metrics
GROUP BY hour_bucket
ORDER BY hour_bucket;
```

---

## 2. 时间分组聚合

### 2.1 DATE_TRUNC聚合

**DATE_TRUNC聚合**按时间单位进行分组聚合。

```sql
-- DATE_TRUNC时间分组聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行DATE_TRUNC聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行DATE_TRUNC时间分组聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'DATE_TRUNC聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('day', sale_date) AS date,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY DATE_TRUNC('day', sale_date)
ORDER BY date;
```

---

## 3. 时间序列填充

### 3.1 生成连续时间序列

**时间序列填充**生成连续的时间序列并填充缺失值。

```sql
-- 时间序列填充（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始执行时间序列填充';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '时间序列填充准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH time_series AS (
    SELECT generate_series(
        '2024-01-01'::date,
        '2024-12-31'::date,
        '1 day'::interval
    )::date AS date
),
data_points AS (
    SELECT
        DATE_TRUNC('day', sale_date)::date AS date,
        COUNT(*) AS count,
        SUM(amount) AS amount
    FROM sales
    GROUP BY DATE_TRUNC('day', sale_date)::date
)
SELECT
    ts.date,
    COALESCE(dp.count, 0) AS count,
    COALESCE(dp.amount, 0) AS amount
FROM time_series ts
LEFT JOIN data_points dp ON ts.date = dp.date
ORDER BY ts.date;
```

---

## 4. 实际应用案例

### 4.1 多时间粒度聚合

**多时间粒度聚合**同时生成多个时间粒度的聚合结果。

```sql
-- 多时间粒度聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行多时间粒度聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多时间粒度聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多时间粒度聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT
    DATE_TRUNC('hour', sale_date) AS hour,
    DATE_TRUNC('day', sale_date) AS day,
    DATE_TRUNC('week', sale_date) AS week,
    DATE_TRUNC('month', sale_date) AS month,
    COUNT(*) AS count,
    SUM(amount) AS total_amount
FROM sales
GROUP BY GROUPING SETS (
    (DATE_TRUNC('hour', sale_date)),
    (DATE_TRUNC('day', sale_date)),
    (DATE_TRUNC('week', sale_date)),
    (DATE_TRUNC('month', sale_date))
)
ORDER BY hour NULLS LAST, day NULLS LAST, week NULLS LAST, month NULLS LAST;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
