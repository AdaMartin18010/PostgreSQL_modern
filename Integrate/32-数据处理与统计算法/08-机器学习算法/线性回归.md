# PostgreSQL 线性回归完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 线性回归 | 机器学习
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 线性回归完整指南](#postgresql-线性回归完整指南)
  - [📋 目录](#-目录)
  - [线性回归概述](#线性回归概述)
    - [核心算法](#核心算法)
  - [1. 简单线性回归](#1-简单线性回归)
    - [1.1 最小二乘法实现](#11-最小二乘法实现)
  - [2. 多元线性回归](#2-多元线性回归)
    - [2.1 多变量回归](#21-多变量回归)
  - [3. 回归评估](#3-回归评估)
    - [3.1 R²决定系数](#31-r决定系数)
    - [3.2 均方误差](#32-均方误差)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 销售预测](#41-销售预测)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 线性回归概述

**线性回归**用于建立因变量与自变量之间的线性关系模型，用于预测和趋势分析。

### 核心算法

| 算法 | 用途 | 复杂度 |
|------|------|--------|
| **最小二乘法** | 简单线性回归 | O(n) |
| **多元回归** | 多变量回归 | O(n*m) |
| **R²评估** | 模型拟合度 | O(n) |

---

## 1. 简单线性回归

### 1.1 最小二乘法实现

**最小二乘法**使用SQL实现简单线性回归，计算斜率和截距。

```sql
-- 创建示例数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'regression_data') THEN
            RAISE WARNING '表 regression_data 已存在，先删除';
            DROP TABLE regression_data CASCADE;
        END IF;

        CREATE TABLE regression_data (
            id SERIAL PRIMARY KEY,
            x NUMERIC NOT NULL,
            y NUMERIC NOT NULL
        );

        -- 插入示例数据
        INSERT INTO regression_data (x, y) VALUES
            (1, 2.1), (2, 4.2), (3, 6.1), (4, 8.0), (5, 10.1),
            (6, 12.2), (7, 14.1), (8, 16.0), (9, 18.1), (10, 20.0);

        RAISE NOTICE '表 regression_data 创建成功，已插入10条数据';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 regression_data 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 简单线性回归计算（带错误处理和性能测试）
DO $$
DECLARE
    n BIGINT;
    sum_x NUMERIC;
    sum_y NUMERIC;
    sum_xy NUMERIC;
    sum_x2 NUMERIC;
    slope NUMERIC;
    intercept NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'regression_data') THEN
            RAISE WARNING '表 regression_data 不存在，无法执行线性回归';
            RETURN;
        END IF;

        -- 检查数据
        SELECT COUNT(*) INTO n FROM regression_data WHERE x IS NOT NULL AND y IS NOT NULL;
        IF n < 2 THEN
            RAISE WARNING '数据点不足，至少需要2个点';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算简单线性回归，数据点数: %', n;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '线性回归准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算回归系数
WITH stats AS (
    SELECT
        COUNT(*) AS n,
        SUM(x) AS sum_x,
        SUM(y) AS sum_y,
        SUM(x * y) AS sum_xy,
        SUM(x * x) AS sum_x2,
        AVG(x) AS avg_x,
        AVG(y) AS avg_y
    FROM regression_data
    WHERE x IS NOT NULL AND y IS NOT NULL
)
SELECT
    n,
    avg_x,
    avg_y,
    CASE
        WHEN (n * sum_x2 - sum_x * sum_x) = 0 THEN NULL
        ELSE (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
    END AS slope,
    CASE
        WHEN (n * sum_x2 - sum_x * sum_x) = 0 THEN NULL
        ELSE (sum_y * sum_x2 - sum_x * sum_xy) / (n * sum_x2 - sum_x * sum_x)
    END AS intercept
FROM stats;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stats AS (
    SELECT
        COUNT(*) AS n,
        SUM(x) AS sum_x,
        SUM(y) AS sum_y,
        SUM(x * y) AS sum_xy,
        SUM(x * x) AS sum_x2
    FROM regression_data
    WHERE x IS NOT NULL AND y IS NOT NULL
)
SELECT
    (n * sum_xy - sum_x * sum_y) / NULLIF(n * sum_x2 - sum_x * sum_x, 0) AS slope,
    (sum_y * sum_x2 - sum_x * sum_xy) / NULLIF(n * sum_x2 - sum_x * sum_x, 0) AS intercept
FROM stats;
```

---

## 2. 多元线性回归

### 2.1 多变量回归

**多元线性回归**处理多个自变量的情况。

```sql
-- 创建多元回归数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multivariate_data') THEN
            RAISE WARNING '表 multivariate_data 已存在，先删除';
            DROP TABLE multivariate_data CASCADE;
        END IF;

        CREATE TABLE multivariate_data (
            id SERIAL PRIMARY KEY,
            x1 NUMERIC NOT NULL,
            x2 NUMERIC NOT NULL,
            y NUMERIC NOT NULL
        );

        -- 插入示例数据
        INSERT INTO multivariate_data (x1, x2, y) VALUES
            (1, 2, 5.1), (2, 3, 8.2), (3, 4, 11.1), (4, 5, 14.0), (5, 6, 17.1);

        RAISE NOTICE '表 multivariate_data 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 multivariate_data 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 多元线性回归（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multivariate_data') THEN
            RAISE WARNING '表 multivariate_data 不存在，无法执行多元回归';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多元线性回归';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多元回归准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用矩阵方法计算多元回归系数（简化版）
WITH stats AS (
    SELECT
        COUNT(*) AS n,
        AVG(x1) AS avg_x1,
        AVG(x2) AS avg_x2,
        AVG(y) AS avg_y,
        SUM((x1 - AVG(x1) OVER ()) * (y - AVG(y) OVER ())) AS cov_x1y,
        SUM((x2 - AVG(x2) OVER ()) * (y - AVG(y) OVER ())) AS cov_x2y,
        SUM(POWER(x1 - AVG(x1) OVER (), 2)) AS var_x1,
        SUM(POWER(x2 - AVG(x2) OVER (), 2)) AS var_x2
    FROM multivariate_data
    WHERE x1 IS NOT NULL AND x2 IS NOT NULL AND y IS NOT NULL
    GROUP BY ()
)
SELECT
    n,
    avg_x1,
    avg_x2,
    avg_y,
    cov_x1y / NULLIF(var_x1, 0) AS beta1,
    cov_x2y / NULLIF(var_x2, 0) AS beta2,
    avg_y - (cov_x1y / NULLIF(var_x1, 0)) * avg_x1 - (cov_x2y / NULLIF(var_x2, 0)) * avg_x2 AS intercept
FROM stats;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stats AS (
    SELECT
        COUNT(*) AS n,
        AVG(x1) AS avg_x1,
        AVG(x2) AS avg_x2,
        AVG(y) AS avg_y
    FROM multivariate_data
    WHERE x1 IS NOT NULL AND x2 IS NOT NULL AND y IS NOT NULL
)
SELECT * FROM stats;
```

---

## 3. 回归评估

### 3.1 R²决定系数

**R²决定系数**衡量模型对数据的拟合程度。

```sql
-- R²决定系数计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'regression_data') THEN
            RAISE WARNING '表 regression_data 不存在，无法计算R²';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算R²决定系数';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'R²计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算R²
WITH regression AS (
    SELECT
        AVG(x) AS avg_x,
        AVG(y) AS avg_y,
        (COUNT(*) * SUM(x * y) - SUM(x) * SUM(y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS slope,
        (SUM(y) * SUM(x * x) - SUM(x) * SUM(x * y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS intercept
    FROM regression_data
    WHERE x IS NOT NULL AND y IS NOT NULL
),
predictions AS (
    SELECT
        y,
        r.slope * x + r.intercept AS y_pred,
        r.avg_y
    FROM regression_data, regression r
    WHERE x IS NOT NULL AND y IS NOT NULL
),
ss_res AS (
    SELECT SUM(POWER(y - y_pred, 2)) AS ss_residual
    FROM predictions
),
ss_tot AS (
    SELECT SUM(POWER(y - avg_y, 2)) AS ss_total
    FROM predictions
)
SELECT
    ss_residual,
    ss_total,
    CASE
        WHEN ss_total = 0 THEN NULL
        ELSE 1 - (ss_residual / ss_total)
    END AS r_squared
FROM ss_res, ss_tot;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH regression AS (
    SELECT
        AVG(x) AS avg_x,
        AVG(y) AS avg_y,
        (COUNT(*) * SUM(x * y) - SUM(x) * SUM(y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS slope,
        (SUM(y) * SUM(x * x) - SUM(x) * SUM(x * y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS intercept
    FROM regression_data
    WHERE x IS NOT NULL AND y IS NOT NULL
)
SELECT slope, intercept FROM regression;
```

### 3.2 均方误差

**均方误差（MSE）**衡量预测值与实际值的差异。

```sql
-- 均方误差计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'regression_data') THEN
            RAISE WARNING '表 regression_data 不存在，无法计算MSE';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算均方误差';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'MSE计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH regression AS (
    SELECT
        (COUNT(*) * SUM(x * y) - SUM(x) * SUM(y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS slope,
        (SUM(y) * SUM(x * x) - SUM(x) * SUM(x * y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS intercept
    FROM regression_data
    WHERE x IS NOT NULL AND y IS NOT NULL
),
predictions AS (
    SELECT
        y,
        r.slope * x + r.intercept AS y_pred
    FROM regression_data, regression r
    WHERE x IS NOT NULL AND y IS NOT NULL
)
SELECT
    COUNT(*) AS n,
    AVG(POWER(y - y_pred, 2)) AS mse,
    SQRT(AVG(POWER(y - y_pred, 2))) AS rmse,
    AVG(ABS(y - y_pred)) AS mae
FROM predictions;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH regression AS (
    SELECT
        (COUNT(*) * SUM(x * y) - SUM(x) * SUM(y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS slope,
        (SUM(y) * SUM(x * x) - SUM(x) * SUM(x * y)) / NULLIF(COUNT(*) * SUM(x * x) - SUM(x) * SUM(x), 0) AS intercept
    FROM regression_data
    WHERE x IS NOT NULL AND y IS NOT NULL
)
SELECT slope, intercept FROM regression;
```

---

## 4. 实际应用案例

### 4.1 销售预测

**销售预测**使用线性回归预测未来销售额。

```sql
-- 销售预测示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_history') THEN
            RAISE WARNING '表 sales_history 不存在，创建示例表';

            CREATE TABLE sales_history (
                id SERIAL PRIMARY KEY,
                month_num INTEGER NOT NULL,
                sales_amount NUMERIC NOT NULL
            );

            INSERT INTO sales_history (month_num, sales_amount) VALUES
                (1, 1000), (2, 1200), (3, 1400), (4, 1600), (5, 1800),
                (6, 2000), (7, 2200), (8, 2400), (9, 2600), (10, 2800);

            RAISE NOTICE '表 sales_history 创建成功';
        END IF;
        RAISE NOTICE '开始执行销售预测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '销售预测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算回归模型并预测未来3个月
WITH regression AS (
    SELECT
        (COUNT(*) * SUM(month_num * sales_amount) - SUM(month_num) * SUM(sales_amount)) /
        NULLIF(COUNT(*) * SUM(month_num * month_num) - SUM(month_num) * SUM(month_num), 0) AS slope,
        (SUM(sales_amount) * SUM(month_num * month_num) - SUM(month_num) * SUM(month_num * sales_amount)) /
        NULLIF(COUNT(*) * SUM(month_num * month_num) - SUM(month_num) * SUM(month_num), 0) AS intercept
    FROM sales_history
    WHERE month_num IS NOT NULL AND sales_amount IS NOT NULL
),
predictions AS (
    SELECT
        month_num,
        sales_amount AS actual,
        r.slope * month_num + r.intercept AS predicted
    FROM sales_history, regression r
    WHERE month_num IS NOT NULL AND sales_amount IS NOT NULL

    UNION ALL

    -- 预测未来3个月
    SELECT
        11 AS month_num,
        NULL AS actual,
        r.slope * 11 + r.intercept AS predicted
    FROM regression r

    UNION ALL

    SELECT
        12 AS month_num,
        NULL AS actual,
        r.slope * 12 + r.intercept AS predicted
    FROM regression r

    UNION ALL

    SELECT
        13 AS month_num,
        NULL AS actual,
        r.slope * 13 + r.intercept AS predicted
    FROM regression r
)
SELECT
    month_num,
    actual,
    ROUND(predicted::numeric, 2) AS predicted,
    CASE WHEN actual IS NOT NULL THEN ROUND(ABS(actual - predicted)::numeric, 2) ELSE NULL END AS error
FROM predictions
ORDER BY month_num;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH regression AS (
    SELECT
        (COUNT(*) * SUM(month_num * sales_amount) - SUM(month_num) * SUM(sales_amount)) /
        NULLIF(COUNT(*) * SUM(month_num * month_num) - SUM(month_num) * SUM(month_num), 0) AS slope,
        (SUM(sales_amount) * SUM(month_num * month_num) - SUM(month_num) * SUM(month_num * sales_amount)) /
        NULLIF(COUNT(*) * SUM(month_num * month_num) - SUM(month_num) * SUM(month_num), 0) AS intercept
    FROM sales_history
    WHERE month_num IS NOT NULL AND sales_amount IS NOT NULL
)
SELECT slope, intercept FROM regression;
```

---

## 📊 性能优化建议

1. **索引优化**: 在回归变量上创建索引以提高查询性能
2. **数据采样**: 对于大数据集，使用采样方法减少计算量
3. **并行处理**: 利用PostgreSQL的并行查询功能加速计算

## 🎯 最佳实践

1. **数据质量**: 确保输入数据没有缺失值和异常值
2. **模型验证**: 使用交叉验证评估模型性能
3. **特征选择**: 选择相关性高的特征进行回归分析
4. **误差分析**: 分析残差分布，检查模型假设

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
