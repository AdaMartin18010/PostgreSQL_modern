# PostgreSQL å†³ç­–æ ‘ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | å†³ç­–æ ‘ | åˆ†ç±»ç®—æ³•
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å†³ç­–æ ‘ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å†³ç­–æ ‘ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å†³ç­–æ ‘æ¦‚è¿°](#å†³ç­–æ ‘æ¦‚è¿°)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. ä¿¡æ¯ç†µè®¡ç®—](#1-ä¿¡æ¯ç†µè®¡ç®—)
    - [1.1 ç†µå‡½æ•°å®ç°](#11-ç†µå‡½æ•°å®ç°)
  - [2. ä¿¡æ¯å¢ç›Š](#2-ä¿¡æ¯å¢ç›Š)
    - [2.1 ä¿¡æ¯å¢ç›Šè®¡ç®—](#21-ä¿¡æ¯å¢ç›Šè®¡ç®—)
  - [3. å†³ç­–æ ‘æ„å»º](#3-å†³ç­–æ ‘æ„å»º)
    - [3.1 ç®€å•å†³ç­–æ ‘å®ç°](#31-ç®€å•å†³ç­–æ ‘å®ç°)
  - [4. å®é™…åº”ç”¨æ¡ˆä¾‹](#4-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [4.1 å®¢æˆ·åˆ†ç±»](#41-å®¢æˆ·åˆ†ç±»)

---

## å†³ç­–æ ‘æ¦‚è¿°

**å†³ç­–æ ‘**æ˜¯ä¸€ç§æ ‘å½¢ç»“æ„çš„åˆ†ç±»å’Œå›å½’ç®—æ³•ï¼Œé€šè¿‡é€’å½’åˆ†å‰²æ•°æ®æ¥æ„å»ºå†³ç­–è§„åˆ™ã€‚

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ |
|------|------|--------|
| **ä¿¡æ¯ç†µ** | è¡¡é‡æ•°æ®çº¯åº¦ | O(n) |
| **ä¿¡æ¯å¢ç›Š** | é€‰æ‹©æœ€ä½³åˆ†å‰²ç‚¹ | O(n*m) |
| **ID3ç®—æ³•** | æ„å»ºå†³ç­–æ ‘ | O(n*m*log(n)) |

---

## 1. ä¿¡æ¯ç†µè®¡ç®—

### 1.1 ç†µå‡½æ•°å®ç°

**ä¿¡æ¯ç†µ**è¡¡é‡æ•°æ®é›†çš„æ··ä¹±ç¨‹åº¦ã€‚

```sql
-- åˆ›å»ºå†³ç­–æ ‘æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE decision_tree_data CASCADE;
        END IF;

        CREATE TABLE decision_tree_data (
            id SERIAL PRIMARY KEY,
            outlook VARCHAR(20) NOT NULL,
            temperature NUMERIC NOT NULL,
            humidity NUMERIC NOT NULL,
            windy BOOLEAN NOT NULL,
            play_tennis INTEGER NOT NULL CHECK (play_tennis IN (0, 1))
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO decision_tree_data (outlook, temperature, humidity, windy, play_tennis) VALUES
            ('sunny', 85, 85, false, 0), ('sunny', 80, 90, true, 0),
            ('overcast', 83, 86, false, 1), ('rain', 70, 96, false, 1),
            ('rain', 68, 80, false, 1), ('rain', 65, 70, true, 0),
            ('overcast', 64, 65, true, 1), ('sunny', 72, 95, false, 0),
            ('sunny', 69, 70, false, 1), ('rain', 75, 80, false, 1);

        RAISE NOTICE 'è¡¨ decision_tree_data åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥10æ¡æ•°æ®';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ decision_tree_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- ä¿¡æ¯ç†µè®¡ç®—å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION calculate_entropy(class_counts NUMERIC[])
RETURNS NUMERIC
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
    total NUMERIC;
    entropy NUMERIC := 0;
    p NUMERIC;
    i INTEGER;
BEGIN
    BEGIN
        IF class_counts IS NULL OR array_length(class_counts, 1) IS NULL THEN
            RAISE WARNING 'ç±»åˆ«è®¡æ•°æ•°ç»„ä¸ºç©º';
            RETURN 0;
        END IF;

        -- è®¡ç®—æ€»æ•°
        SELECT SUM(unnest) INTO total FROM unnest(class_counts) AS unnest;

        IF total = 0 THEN
            RETURN 0;
        END IF;

        -- è®¡ç®—ç†µ: -Î£(p * log2(p))
        FOR i IN 1..array_length(class_counts, 1) LOOP
            p := class_counts[i] / total;
            IF p > 0 THEN
                entropy := entropy - p * LOG(2, p);
            END IF;
        END LOOP;

        RETURN entropy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç†µè®¡ç®—å¤±è´¥: %', SQLERRM;
            RETURN NULL;
    END;
END;
$$;

-- è®¡ç®—æ•°æ®é›†çš„æ€»ç†µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ç†µ';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'calculate_entropy') THEN
            RAISE WARNING 'calculate_entropyå‡½æ•°ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º';
            RETURN;
        END IF;

        RAISE NOTICE 'å¼€å§‹è®¡ç®—ä¿¡æ¯ç†µ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç†µè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—æ€»ç†µ
WITH class_distribution AS (
    SELECT
        play_tennis,
        COUNT(*) AS count
    FROM decision_tree_data
    GROUP BY play_tennis
),
class_counts AS (
    SELECT ARRAY_AGG(count ORDER BY play_tennis) AS counts
    FROM class_distribution
)
SELECT
    counts,
    calculate_entropy(counts) AS entropy
FROM class_counts;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    play_tennis,
    COUNT(*) AS count
FROM decision_tree_data
GROUP BY play_tennis;
```

---

## 2. ä¿¡æ¯å¢ç›Š

### 2.1 ä¿¡æ¯å¢ç›Šè®¡ç®—

**ä¿¡æ¯å¢ç›Š**è¡¡é‡ä½¿ç”¨æŸä¸ªç‰¹å¾åˆ†å‰²æ•°æ®åç†µçš„å‡å°‘é‡ã€‚

```sql
-- ä¿¡æ¯å¢ç›Šè®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ä¿¡æ¯å¢ç›Š';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—ä¿¡æ¯å¢ç›Š';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¿¡æ¯å¢ç›Šè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—outlookç‰¹å¾çš„ä¿¡æ¯å¢ç›Š
WITH total_entropy AS (
    SELECT calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS entropy
    FROM (
        SELECT play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY play_tennis
    ) t
),
outlook_entropy AS (
    SELECT
        outlook,
        COUNT(*) AS outlook_count,
        calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
    FROM (
        SELECT outlook, play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY outlook, play_tennis
    ) t
    GROUP BY outlook
),
weighted_entropy AS (
    SELECT
        SUM(outlook_count * conditional_entropy) / SUM(outlook_count) AS weighted_avg_entropy,
        SUM(outlook_count) AS total_count
    FROM outlook_entropy
)
SELECT
    t.entropy AS total_entropy,
    w.weighted_avg_entropy AS weighted_entropy,
    t.entropy - w.weighted_avg_entropy AS information_gain
FROM total_entropy t, weighted_entropy w;

-- è®¡ç®—æ‰€æœ‰ç‰¹å¾çš„ä¿¡æ¯å¢ç›Š
WITH total_entropy AS (
    SELECT calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS entropy
    FROM (
        SELECT play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY play_tennis
    ) t
),
feature_gains AS (
    -- Outlookç‰¹å¾
    SELECT
        'outlook' AS feature,
        t.entropy - (
            SELECT SUM(outlook_count * conditional_entropy) / SUM(outlook_count)
            FROM (
                SELECT
                    outlook,
                    COUNT(*) AS outlook_count,
                    calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
                FROM (
                    SELECT outlook, play_tennis, COUNT(*) AS count
                    FROM decision_tree_data
                    GROUP BY outlook, play_tennis
                ) t2
                GROUP BY outlook
            ) t3
        ) AS information_gain
    FROM total_entropy t

    UNION ALL

    -- Temperatureç‰¹å¾ï¼ˆç¦»æ•£åŒ–ï¼‰
    SELECT
        'temperature' AS feature,
        t.entropy - (
            SELECT SUM(temp_count * conditional_entropy) / SUM(temp_count)
            FROM (
                SELECT
                    CASE
                        WHEN temperature < 70 THEN 'cool'
                        WHEN temperature < 80 THEN 'mild'
                        ELSE 'hot'
                    END AS temp_category,
                    COUNT(*) AS temp_count,
                    calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
                FROM (
                    SELECT
                        CASE
                            WHEN temperature < 70 THEN 'cool'
                            WHEN temperature < 80 THEN 'mild'
                            ELSE 'hot'
                        END AS temp_category,
                        play_tennis,
                        COUNT(*) AS count
                    FROM decision_tree_data
                    GROUP BY temp_category, play_tennis
                ) t2
                GROUP BY temp_category
            ) t3
        ) AS information_gain
    FROM total_entropy t
)
SELECT
    feature,
    ROUND(information_gain::numeric, 4) AS information_gain
FROM feature_gains
ORDER BY information_gain DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    outlook,
    play_tennis,
    COUNT(*) AS count
FROM decision_tree_data
GROUP BY outlook, play_tennis;
```

---

## 3. å†³ç­–æ ‘æ„å»º

### 3.1 ç®€å•å†³ç­–æ ‘å®ç°

**å†³ç­–æ ‘æ„å»º**ä½¿ç”¨é€’å½’æ–¹å¼é€‰æ‹©æœ€ä½³ç‰¹å¾è¿›è¡Œåˆ†å‰²ã€‚

```sql
-- ç®€å•å†³ç­–æ ‘é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ„å»ºå†³ç­–æ ‘';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ„å»ºå†³ç­–æ ‘';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å†³ç­–æ ‘æ„å»ºå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨ç®€åŒ–çš„å†³ç­–è§„åˆ™è¿›è¡Œé¢„æµ‹
WITH predictions AS (
    SELECT
        id,
        outlook,
        temperature,
        humidity,
        windy,
        play_tennis AS actual,
        CASE
            -- ç¬¬ä¸€å±‚ï¼šæ ¹æ®outlookåˆ†å‰²
            WHEN outlook = 'overcast' THEN 1
            WHEN outlook = 'sunny' THEN
                CASE
                    -- ç¬¬äºŒå±‚ï¼šæ ¹æ®humidityåˆ†å‰²
                    WHEN humidity <= 75 THEN 1
                    ELSE 0
                END
            WHEN outlook = 'rain' THEN
                CASE
                    -- ç¬¬äºŒå±‚ï¼šæ ¹æ®windyåˆ†å‰²
                    WHEN windy = false THEN 1
                    ELSE 0
                END
            ELSE 0
        END AS predicted
    FROM decision_tree_data
)
SELECT
    id,
    outlook,
    temperature,
    humidity,
    windy,
    actual,
    predicted,
    CASE WHEN actual = predicted THEN 'Correct' ELSE 'Wrong' END AS status
FROM predictions
ORDER BY id;

-- è®¡ç®—å‡†ç¡®ç‡
WITH predictions AS (
    SELECT
        play_tennis AS actual,
        CASE
            WHEN outlook = 'overcast' THEN 1
            WHEN outlook = 'sunny' AND humidity <= 75 THEN 1
            WHEN outlook = 'rain' AND windy = false THEN 1
            ELSE 0
        END AS predicted
    FROM decision_tree_data
)
SELECT
    COUNT(*) AS total,
    SUM(CASE WHEN actual = predicted THEN 1 ELSE 0 END) AS correct,
    ROUND(SUM(CASE WHEN actual = predicted THEN 1 ELSE 0 END)::numeric / COUNT(*), 4) AS accuracy
FROM predictions;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    CASE
        WHEN outlook = 'overcast' THEN 1
        WHEN outlook = 'sunny' AND humidity <= 75 THEN 1
        WHEN outlook = 'rain' AND windy = false THEN 1
        ELSE 0
    END AS predicted
FROM decision_tree_data;
```

---

## 4. å®é™…åº”ç”¨æ¡ˆä¾‹

### 4.1 å®¢æˆ·åˆ†ç±»

**å®¢æˆ·åˆ†ç±»**ä½¿ç”¨å†³ç­–æ ‘å¯¹å®¢æˆ·è¿›è¡Œåˆ†ç±»ã€‚

```sql
-- å®¢æˆ·åˆ†ç±»ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customer_data') THEN
            RAISE WARNING 'è¡¨ customer_data ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE customer_data (
                customer_id SERIAL PRIMARY KEY,
                age INTEGER NOT NULL,
                income NUMERIC NOT NULL,
                credit_score INTEGER NOT NULL,
                purchase_history INTEGER NOT NULL,
                customer_segment VARCHAR(20) NOT NULL
            );

            INSERT INTO customer_data (age, income, credit_score, purchase_history, customer_segment) VALUES
                (25, 30000, 650, 5, 'low'), (35, 50000, 720, 15, 'medium'),
                (45, 80000, 780, 30, 'high'), (30, 40000, 680, 8, 'low'),
                (50, 100000, 800, 50, 'high'), (28, 35000, 660, 6, 'low'),
                (40, 70000, 750, 25, 'medium'), (55, 120000, 820, 60, 'high');

            RAISE NOTICE 'è¡¨ customer_data åˆ›å»ºæˆåŠŸ';
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®¢æˆ·åˆ†ç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·åˆ†ç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨å†³ç­–æ ‘è§„åˆ™è¿›è¡Œå®¢æˆ·åˆ†ç±»
WITH predictions AS (
    SELECT
        customer_id,
        age,
        income,
        credit_score,
        purchase_history,
        customer_segment AS actual_segment,
        CASE
            WHEN income >= 90000 THEN 'high'
            WHEN income >= 60000 AND credit_score >= 750 THEN 'high'
            WHEN income >= 40000 AND purchase_history >= 20 THEN 'medium'
            WHEN income >= 40000 THEN 'medium'
            ELSE 'low'
        END AS predicted_segment
    FROM customer_data
)
SELECT
    customer_id,
    age,
    income,
    credit_score,
    purchase_history,
    actual_segment,
    predicted_segment,
    CASE WHEN actual_segment = predicted_segment THEN 'Correct' ELSE 'Wrong' END AS status
FROM predictions
ORDER BY customer_id;

-- è®¡ç®—æ··æ·†çŸ©é˜µ
WITH predictions AS (
    SELECT
        customer_segment AS actual,
        CASE
            WHEN income >= 90000 THEN 'high'
            WHEN income >= 60000 AND credit_score >= 750 THEN 'high'
            WHEN income >= 40000 AND purchase_history >= 20 THEN 'medium'
            WHEN income >= 40000 THEN 'medium'
            ELSE 'low'
        END AS predicted
    FROM customer_data
)
SELECT
    actual,
    predicted,
    COUNT(*) AS count
FROM predictions
GROUP BY actual, predicted
ORDER BY actual, predicted;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    customer_id,
    CASE
        WHEN income >= 90000 THEN 'high'
        WHEN income >= 60000 AND credit_score >= 750 THEN 'high'
        WHEN income >= 40000 AND purchase_history >= 20 THEN 'medium'
        WHEN income >= 40000 THEN 'medium'
        ELSE 'low'
    END AS predicted_segment
FROM customer_data;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç‰¹å¾é€‰æ‹©**: ä½¿ç”¨ä¿¡æ¯å¢ç›Šé€‰æ‹©æœ€é‡è¦çš„ç‰¹å¾
2. **å‰ªæ**: ä½¿ç”¨é¢„å‰ªæå’Œåå‰ªæé˜²æ­¢è¿‡æ‹Ÿåˆ
3. **ç¦»æ•£åŒ–**: å¯¹è¿ç»­ç‰¹å¾è¿›è¡Œç¦»æ•£åŒ–å¤„ç†

## ğŸ¯ æœ€ä½³å®è·µ

1. **æ•°æ®é¢„å¤„ç†**: å¤„ç†ç¼ºå¤±å€¼å’Œå¼‚å¸¸å€¼
2. **ç‰¹å¾å·¥ç¨‹**: åˆ›å»ºæœ‰æ„ä¹‰çš„ç‰¹å¾ç»„åˆ
3. **æ¨¡å‹è¯„ä¼°**: ä½¿ç”¨äº¤å‰éªŒè¯è¯„ä¼°æ¨¡å‹æ€§èƒ½
4. **å¯è§£é‡Šæ€§**: åˆ©ç”¨å†³ç­–æ ‘çš„å¯è§£é‡Šæ€§ä¼˜åŠ¿

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
