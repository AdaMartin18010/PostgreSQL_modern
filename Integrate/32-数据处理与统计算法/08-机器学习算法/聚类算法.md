# PostgreSQL æœºå™¨å­¦ä¹ èšç±»ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | èšç±»ç®—æ³• | æ— ç›‘ç£å­¦ä¹ 
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æœºå™¨å­¦ä¹ èšç±»ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æœºå™¨å­¦ä¹ èšç±»ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [èšç±»ç®—æ³•æ¦‚è¿°](#èšç±»ç®—æ³•æ¦‚è¿°)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. K-meansèšç±»](#1-k-meansèšç±»)
    - [1.1 è¿­ä»£K-meanså®ç°](#11-è¿­ä»£k-meanså®ç°)
  - [2. DBSCANèšç±»](#2-dbscanèšç±»)
    - [2.1 å¯†åº¦èšç±»å®ç°](#21-å¯†åº¦èšç±»å®ç°)
  - [3. èšç±»è¯„ä¼°](#3-èšç±»è¯„ä¼°)
    - [3.1 è½®å»“ç³»æ•°](#31-è½®å»“ç³»æ•°)
    - [3.2 è‚˜éƒ¨æ³•åˆ™](#32-è‚˜éƒ¨æ³•åˆ™)
  - [4. å®é™…åº”ç”¨æ¡ˆä¾‹](#4-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [4.1 å®¢æˆ·ç»†åˆ†](#41-å®¢æˆ·ç»†åˆ†)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## èšç±»ç®—æ³•æ¦‚è¿°

**èšç±»ç®—æ³•**æ˜¯æ— ç›‘ç£å­¦ä¹ çš„æ ¸å¿ƒæ–¹æ³•ï¼Œç”¨äºå‘ç°æ•°æ®ä¸­çš„éšè—æ¨¡å¼å’Œåˆ†ç»„ã€‚

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ |
|------|------|--------|
| **K-means** | åŸºäºä¸­å¿ƒçš„èšç±» | O(n*k*i) |
| **DBSCAN** | åŸºäºå¯†åº¦çš„èšç±» | O(n log n) |
| **å±‚æ¬¡èšç±»** | æ ‘çŠ¶èšç±» | O(nÂ²) |

---

## 1. K-meansèšç±»

### 1.1 è¿­ä»£K-meanså®ç°

**K-meansèšç±»**é€šè¿‡è¿­ä»£ä¼˜åŒ–èšç±»ä¸­å¿ƒã€‚

```sql
-- åˆ›å»ºèšç±»æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE cluster_data CASCADE;
        END IF;

        CREATE TABLE cluster_data (
            id SERIAL PRIMARY KEY,
            x NUMERIC NOT NULL,
            y NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®ï¼ˆ3ä¸ªç°‡ï¼‰
        INSERT INTO cluster_data (x, y) VALUES
            -- ç°‡1
            (2, 3), (2.5, 3.5), (3, 4), (2.2, 3.2), (2.8, 3.8),
            -- ç°‡2
            (8, 9), (8.5, 9.5), (9, 10), (8.2, 9.2), (8.8, 9.8),
            -- ç°‡3
            (5, 2), (5.5, 2.5), (6, 3), (5.2, 2.2), (5.8, 2.8);

        RAISE NOTICE 'è¡¨ cluster_data åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥15æ¡æ•°æ®';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ cluster_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- K-meansè¿­ä»£å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    k INTEGER := 3;
    max_iterations INTEGER := 10;
    iteration INTEGER := 0;
    converged BOOLEAN := false;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒK-meansèšç±»';
            RETURN;
        END IF;

        -- åˆ›å»ºä¸´æ—¶è¡¨å­˜å‚¨èšç±»ä¸­å¿ƒ
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_centers') THEN
            DROP TABLE cluster_centers CASCADE;
        END IF;

        -- åˆå§‹åŒ–èšç±»ä¸­å¿ƒï¼ˆéšæœºé€‰æ‹©kä¸ªç‚¹ï¼‰
        CREATE TEMP TABLE cluster_centers AS
        SELECT
            ROW_NUMBER() OVER () AS cluster_id,
            x AS center_x,
            y AS center_y
        FROM (
            SELECT x, y FROM cluster_data ORDER BY RANDOM() LIMIT k
        ) t;

        RAISE NOTICE 'K-meansèšç±»å¼€å§‹ï¼Œk=%, æœ€å¤§è¿­ä»£æ¬¡æ•°=%', k, max_iterations;

        -- è¿­ä»£ä¼˜åŒ–ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…éœ€è¦å¾ªç¯ï¼‰
        RAISE NOTICE 'è¿­ä»£å®Œæˆï¼ˆç®€åŒ–å®ç°ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'K-meansèšç±»å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- K-meansèšç±»ï¼ˆä½¿ç”¨çª—å£å‡½æ•°å®ç°ï¼‰
WITH initial_centers AS (
    SELECT
        ROW_NUMBER() OVER () AS cluster_id,
        x AS center_x,
        y AS center_y
    FROM (
        SELECT x, y FROM cluster_data ORDER BY RANDOM() LIMIT 3
    ) t
),
distances AS (
    SELECT
        d.id,
        d.x,
        d.y,
        c.cluster_id,
        SQRT(POWER(d.x - c.center_x, 2) + POWER(d.y - c.center_y, 2)) AS distance
    FROM cluster_data d
    CROSS JOIN initial_centers c
),
closest_clusters AS (
    SELECT
        id,
        x,
        y,
        cluster_id,
        ROW_NUMBER() OVER (PARTITION BY id ORDER BY distance) AS rn
    FROM distances
),
assignments AS (
    SELECT
        id,
        x,
        y,
        cluster_id
    FROM closest_clusters
    WHERE rn = 1
),
new_centers AS (
    SELECT
        cluster_id,
        AVG(x) AS center_x,
        AVG(y) AS center_y,
        COUNT(*) AS cluster_size
    FROM assignments
    GROUP BY cluster_id
)
SELECT
    a.id,
    a.x,
    a.y,
    a.cluster_id,
    nc.center_x,
    nc.center_y,
    nc.cluster_size
FROM assignments a
JOIN new_centers nc ON a.cluster_id = nc.cluster_id
ORDER BY a.cluster_id, a.id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH initial_centers AS (
    SELECT ROW_NUMBER() OVER () AS cluster_id, x AS center_x, y AS center_y
    FROM (SELECT x, y FROM cluster_data ORDER BY RANDOM() LIMIT 3) t
)
SELECT
    d.id,
    c.cluster_id,
    SQRT(POWER(d.x - c.center_x, 2) + POWER(d.y - c.center_y, 2)) AS distance
FROM cluster_data d
CROSS JOIN initial_centers c
LIMIT 100;
```

---

## 2. DBSCANèšç±»

### 2.1 å¯†åº¦èšç±»å®ç°

**DBSCAN**åŸºäºå¯†åº¦çš„èšç±»ç®—æ³•ï¼Œå¯ä»¥å‘ç°ä»»æ„å½¢çŠ¶çš„ç°‡ã€‚

```sql
-- DBSCANèšç±»å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒDBSCANèšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒDBSCANèšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'DBSCANèšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- DBSCANæ ¸å¿ƒå‡½æ•°ï¼šè®¡ç®—é‚»åŸŸå†…çš„ç‚¹æ•°
WITH point_neighbors AS (
    SELECT
        p1.id AS point_id,
        p1.x,
        p1.y,
        COUNT(*) - 1 AS neighbor_count  -- å‡å»è‡ªå·±
    FROM cluster_data p1
    CROSS JOIN cluster_data p2
    WHERE SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) <= 2.0  -- eps = 2.0
    GROUP BY p1.id, p1.x, p1.y
),
core_points AS (
    SELECT
        point_id,
        x,
        y,
        neighbor_count
    FROM point_neighbors
    WHERE neighbor_count >= 3  -- min_pts = 3
),
dbscan_clusters AS (
    SELECT
        c.id,
        c.x,
        c.y,
        CASE
            WHEN cp.point_id IS NOT NULL THEN
                DENSE_RANK() OVER (ORDER BY cp.point_id)
            ELSE -1  -- å™ªå£°ç‚¹
        END AS cluster_id
    FROM cluster_data c
    LEFT JOIN core_points cp ON SQRT(POWER(c.x - cp.x, 2) + POWER(c.y - cp.y, 2)) <= 2.0
)
SELECT
    id,
    x,
    y,
    cluster_id,
    CASE WHEN cluster_id = -1 THEN 'Noise' ELSE 'Cluster' END AS point_type
FROM dbscan_clusters
ORDER BY cluster_id, id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    p1.id,
    COUNT(*) - 1 AS neighbor_count
FROM cluster_data p1
CROSS JOIN cluster_data p2
WHERE SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) <= 2.0
GROUP BY p1.id
LIMIT 100;
```

---

## 3. èšç±»è¯„ä¼°

### 3.1 è½®å»“ç³»æ•°

**è½®å»“ç³»æ•°**è¡¡é‡èšç±»è´¨é‡ï¼Œå€¼è¶Šæ¥è¿‘1è¶Šå¥½ã€‚

```sql
-- è½®å»“ç³»æ•°è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—è½®å»“ç³»æ•°';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—è½®å»“ç³»æ•°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è½®å»“ç³»æ•°è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—è½®å»“ç³»æ•°
WITH kmeans_clusters AS (
    SELECT
        id,
        x,
        y,
        NTILE(3) OVER (ORDER BY x, y) AS cluster_id
    FROM cluster_data
),
intra_cluster_distances AS (
    SELECT
        c1.id,
        c1.cluster_id,
        AVG(SQRT(POWER(c1.x - c2.x, 2) + POWER(c1.y - c2.y, 2))) AS avg_intra_distance
    FROM kmeans_clusters c1
    JOIN kmeans_clusters c2 ON c1.cluster_id = c2.cluster_id AND c1.id != c2.id
    GROUP BY c1.id, c1.cluster_id
),
inter_cluster_distances AS (
    SELECT
        c1.id,
        c1.cluster_id,
        c2.cluster_id AS other_cluster,
        AVG(SQRT(POWER(c1.x - c2.x, 2) + POWER(c1.y - c2.y, 2))) AS avg_inter_distance
    FROM kmeans_clusters c1
    JOIN kmeans_clusters c2 ON c1.cluster_id != c2.cluster_id
    GROUP BY c1.id, c1.cluster_id, c2.cluster_id
),
min_inter_distances AS (
    SELECT
        id,
        cluster_id,
        MIN(avg_inter_distance) AS min_inter_distance
    FROM inter_cluster_distances
    GROUP BY id, cluster_id
),
silhouette_scores AS (
    SELECT
        i.id,
        i.cluster_id,
        i.avg_intra_distance AS a,
        m.min_inter_distance AS b,
        CASE
            WHEN GREATEST(a, b) = 0 THEN 0
            ELSE (b - a) / GREATEST(a, b)
        END AS silhouette
    FROM intra_cluster_distances i
    JOIN min_inter_distances m ON i.id = m.id
)
SELECT
    cluster_id,
    COUNT(*) AS cluster_size,
    ROUND(AVG(silhouette)::numeric, 4) AS avg_silhouette,
    ROUND(MIN(silhouette)::numeric, 4) AS min_silhouette,
    ROUND(MAX(silhouette)::numeric, 4) AS max_silhouette
FROM silhouette_scores
GROUP BY cluster_id
ORDER BY cluster_id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    NTILE(3) OVER (ORDER BY x, y) AS cluster_id
FROM cluster_data;
```

### 3.2 è‚˜éƒ¨æ³•åˆ™

**è‚˜éƒ¨æ³•åˆ™**ç”¨äºç¡®å®šæœ€ä¼˜çš„Kå€¼ã€‚

```sql
-- è‚˜éƒ¨æ³•åˆ™è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—è‚˜éƒ¨æ³•åˆ™';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—è‚˜éƒ¨æ³•åˆ™';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è‚˜éƒ¨æ³•åˆ™è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—ä¸åŒKå€¼çš„SSEï¼ˆè¯¯å·®å¹³æ–¹å’Œï¼‰
WITH k_values AS (
    SELECT unnest(ARRAY[1, 2, 3, 4, 5]) AS k
),
kmeans_results AS (
    SELECT
        k,
        id,
        x,
        y,
        NTILE(k) OVER (PARTITION BY k ORDER BY x, y) AS cluster_id
    FROM cluster_data
    CROSS JOIN k_values
),
cluster_centers AS (
    SELECT
        k,
        cluster_id,
        AVG(x) AS center_x,
        AVG(y) AS center_y
    FROM kmeans_results
    GROUP BY k, cluster_id
),
sse AS (
    SELECT
        kr.k,
        SUM(POWER(kr.x - cc.center_x, 2) + POWER(kr.y - cc.center_y, 2)) AS sse_value
    FROM kmeans_results kr
    JOIN cluster_centers cc ON kr.k = cc.k AND kr.cluster_id = cc.cluster_id
    GROUP BY kr.k
)
SELECT
    k,
    ROUND(sse_value::numeric, 2) AS sse,
    ROUND((sse_value - LAG(sse_value) OVER (ORDER BY k))::numeric, 2) AS sse_reduction
FROM sse
ORDER BY k;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    k,
    COUNT(*) AS cluster_count
FROM (
    SELECT
        unnest(ARRAY[1, 2, 3, 4, 5]) AS k,
        NTILE(unnest) OVER (PARTITION BY unnest ORDER BY x, y) AS cluster_id
    FROM cluster_data
    CROSS JOIN generate_series(1, 5) AS k
) t
GROUP BY k;
```

---

## 4. å®é™…åº”ç”¨æ¡ˆä¾‹

### 4.1 å®¢æˆ·ç»†åˆ†

**å®¢æˆ·ç»†åˆ†**ä½¿ç”¨èšç±»ç®—æ³•å¯¹å®¢æˆ·è¿›è¡Œåˆ†ç»„ã€‚

```sql
-- å®¢æˆ·ç»†åˆ†ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customer_features') THEN
            RAISE WARNING 'è¡¨ customer_features ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE customer_features (
                customer_id SERIAL PRIMARY KEY,
                annual_spending NUMERIC NOT NULL,
                purchase_frequency NUMERIC NOT NULL,
                avg_order_value NUMERIC NOT NULL
            );

            INSERT INTO customer_features (annual_spending, purchase_frequency, avg_order_value) VALUES
                (500, 2, 250), (600, 3, 200), (800, 4, 200),
                (1200, 6, 200), (1500, 8, 187.5), (2000, 10, 200),
                (3000, 12, 250), (5000, 15, 333.33), (8000, 20, 400);

            RAISE NOTICE 'è¡¨ customer_features åˆ›å»ºæˆåŠŸ';
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®¢æˆ·ç»†åˆ†';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·ç»†åˆ†å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨K-meansè¿›è¡Œå®¢æˆ·ç»†åˆ†
WITH normalized_features AS (
    SELECT
        customer_id,
        annual_spending,
        purchase_frequency,
        avg_order_value,
        (annual_spending - AVG(annual_spending) OVER ()) / NULLIF(STDDEV(annual_spending) OVER (), 0) AS norm_spending,
        (purchase_frequency - AVG(purchase_frequency) OVER ()) / NULLIF(STDDEV(purchase_frequency) OVER (), 0) AS norm_frequency,
        (avg_order_value - AVG(avg_order_value) OVER ()) / NULLIF(STDDEV(avg_order_value) OVER (), 0) AS norm_order_value
    FROM customer_features
),
kmeans_clusters AS (
    SELECT
        customer_id,
        annual_spending,
        purchase_frequency,
        avg_order_value,
        NTILE(3) OVER (ORDER BY norm_spending, norm_frequency, norm_order_value) AS segment_id
    FROM normalized_features
),
segment_profiles AS (
    SELECT
        segment_id,
        COUNT(*) AS customer_count,
        ROUND(AVG(annual_spending)::numeric, 2) AS avg_spending,
        ROUND(AVG(purchase_frequency)::numeric, 2) AS avg_frequency,
        ROUND(AVG(avg_order_value)::numeric, 2) AS avg_order_value,
        CASE segment_id
            WHEN 1 THEN 'ä½ä»·å€¼å®¢æˆ·'
            WHEN 2 THEN 'ä¸­ä»·å€¼å®¢æˆ·'
            WHEN 3 THEN 'é«˜ä»·å€¼å®¢æˆ·'
        END AS segment_name
    FROM kmeans_clusters
    GROUP BY segment_id
)
SELECT
    c.customer_id,
    c.annual_spending,
    c.purchase_frequency,
    c.avg_order_value,
    c.segment_id,
    sp.segment_name,
    sp.avg_spending AS segment_avg_spending
FROM kmeans_clusters c
JOIN segment_profiles sp ON c.segment_id = sp.segment_id
ORDER BY c.segment_id, c.annual_spending DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    customer_id,
    NTILE(3) OVER (ORDER BY annual_spending, purchase_frequency) AS segment_id
FROM customer_features;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **æ•°æ®æ ‡å‡†åŒ–**: å¯¹ç‰¹å¾è¿›è¡Œæ ‡å‡†åŒ–å¤„ç†
2. **é™ç»´**: ä½¿ç”¨PCAç­‰æ–¹æ³•å‡å°‘ç‰¹å¾ç»´åº¦
3. **é‡‡æ ·**: å¯¹å¤§æ•°æ®é›†è¿›è¡Œé‡‡æ ·å¤„ç†

## ğŸ¯ æœ€ä½³å®è·µ

1. **Kå€¼é€‰æ‹©**: ä½¿ç”¨è‚˜éƒ¨æ³•åˆ™æˆ–è½®å»“ç³»æ•°é€‰æ‹©æœ€ä¼˜K
2. **åˆå§‹åŒ–**: ä½¿ç”¨K-means++æ”¹è¿›åˆå§‹åŒ–æ–¹æ³•
3. **è¯„ä¼°æŒ‡æ ‡**: ç»“åˆå¤šä¸ªæŒ‡æ ‡è¯„ä¼°èšç±»è´¨é‡
4. **ä¸šåŠ¡ç†è§£**: ç»“åˆä¸šåŠ¡çŸ¥è¯†è§£é‡Šèšç±»ç»“æœ

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
