# PostgreSQL 金融时间序列分析完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 时间序列 | 金融分析
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 金融时间序列分析完整指南](#postgresql-金融时间序列分析完整指南)
  - [📋 目录](#-目录)
  - [金融时间序列分析概述](#金融时间序列分析概述)
    - [核心分析方法](#核心分析方法)
  - [1. 移动平均](#1-移动平均)
    - [1.1 简单移动平均](#11-简单移动平均)
    - [1.2 指数移动平均](#12-指数移动平均)
  - [2. 技术指标](#2-技术指标)
    - [2.1 MACD指标](#21-macd指标)
    - [2.2 RSI指标](#22-rsi指标)
  - [3. 趋势分析](#3-趋势分析)
    - [3.1 趋势识别](#31-趋势识别)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 交易信号生成](#41-交易信号生成)

---

## 金融时间序列分析概述

**金融时间序列分析**用于识别价格趋势、预测未来走势和生成交易信号。

### 核心分析方法

| 方法 | 用途 | 复杂度 |
|------|------|--------|
| **移动平均** | 平滑价格波动 | O(n) |
| **技术指标** | 识别买卖信号 | O(n) |
| **趋势分析** | 判断市场方向 | O(n) |

---

## 1. 移动平均

### 1.1 简单移动平均

**简单移动平均（SMA）**计算指定窗口内的平均价格。

```sql
-- 创建价格数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 已存在，先删除';
            DROP TABLE price_data CASCADE;
        END IF;

        CREATE TABLE price_data (
            date DATE NOT NULL,
            symbol VARCHAR(10) NOT NULL,
            close_price NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (date, symbol)
        );

        -- 插入示例数据
        INSERT INTO price_data (date, symbol, close_price) VALUES
            ('2024-01-01', 'AAPL', 150.00), ('2024-01-02', 'AAPL', 152.00),
            ('2024-01-03', 'AAPL', 151.00), ('2024-01-04', 'AAPL', 153.00),
            ('2024-01-05', 'AAPL', 155.00), ('2024-01-06', 'AAPL', 154.00),
            ('2024-01-07', 'AAPL', 156.00), ('2024-01-08', 'AAPL', 157.00),
            ('2024-01-09', 'AAPL', 158.00), ('2024-01-10', 'AAPL', 159.00);

        RAISE NOTICE '表 price_data 创建成功，已插入10条数据';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 price_data 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算简单移动平均（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算简单移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '移动平均计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算5日和10日移动平均
SELECT
    date,
    symbol,
    close_price,
    AVG(close_price) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS sma_5,
    AVG(close_price) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
    ) AS sma_10
FROM price_data
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    close_price,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS sma_5
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

### 1.2 指数移动平均

**指数移动平均（EMA）**给予近期价格更高权重。

```sql
-- 指数移动平均计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算指数移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算指数移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '指数移动平均计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算EMA（使用递归CTE）
WITH RECURSIVE ema_calculation AS (
    SELECT
        date,
        symbol,
        close_price,
        close_price AS ema_5,
        ROW_NUMBER() OVER (PARTITION BY symbol ORDER BY date) AS rn
    FROM price_data
    WHERE (symbol, date) IN (
        SELECT symbol, MIN(date) FROM price_data GROUP BY symbol
    )

    UNION ALL

    SELECT
        pd.date,
        pd.symbol,
        pd.close_price,
        CASE
            WHEN ec.rn < 5 THEN
                (pd.close_price * 2.0 / 6.0) + (ec.ema_5 * 4.0 / 6.0)
            ELSE
                (pd.close_price * 2.0 / 6.0) + (ec.ema_5 * 4.0 / 6.0)
        END AS ema_5,
        ec.rn + 1
    FROM ema_calculation ec
    JOIN price_data pd ON pd.symbol = ec.symbol
        AND pd.date = (
            SELECT MIN(date) FROM price_data
            WHERE symbol = ec.symbol AND date > ec.date
        )
    WHERE ec.rn < 20
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(ema_5::numeric, 2) AS ema_5
FROM ema_calculation
ORDER BY symbol, date;

-- 性能测试（简化版）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    close_price,
    close_price AS ema_approx
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date
LIMIT 10;
```

---

## 2. 技术指标

### 2.1 MACD指标

**MACD（移动平均收敛散度）**用于识别趋势变化。

```sql
-- MACD指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算MACD';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算MACD指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'MACD计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算MACD（简化版：使用SMA代替EMA）
WITH price_series AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        ) AS ema_12,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 25 PRECEDING AND CURRENT ROW
        ) AS ema_26
    FROM price_data
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(ema_12::numeric, 2) AS ema_12,
    ROUND(ema_26::numeric, 2) AS ema_26,
    ROUND((ema_12 - ema_26)::numeric, 2) AS macd_line,
    ROUND(AVG(ema_12 - ema_26) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 8 PRECEDING AND CURRENT ROW
    )::numeric, 2) AS signal_line,
    ROUND(((ema_12 - ema_26) - AVG(ema_12 - ema_26) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 8 PRECEDING AND CURRENT ROW
    ))::numeric, 2) AS histogram
FROM price_series
WHERE ema_26 IS NOT NULL
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS ema_12
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

### 2.2 RSI指标

**RSI（相对强弱指标）**衡量价格动量。

```sql
-- RSI指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算RSI';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算RSI指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'RSI计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算RSI（14日周期）
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS price_change
    FROM price_data
),
gains_losses AS (
    SELECT
        date,
        symbol,
        close_price,
        CASE WHEN price_change > 0 THEN price_change ELSE 0 END AS gain,
        CASE WHEN price_change < 0 THEN ABS(price_change) ELSE 0 END AS loss
    FROM price_changes
),
avg_gains_losses AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(gain) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
        ) AS avg_gain,
        AVG(loss) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
        ) AS avg_loss
    FROM gains_losses
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(avg_gain::numeric, 4) AS avg_gain,
    ROUND(avg_loss::numeric, 4) AS avg_loss,
    CASE
        WHEN avg_loss = 0 THEN 100
        ELSE ROUND((100 - (100 / (1 + avg_gain / NULLIF(avg_loss, 0))))::numeric, 2)
    END AS rsi
FROM avg_gains_losses
WHERE avg_gain IS NOT NULL AND avg_loss IS NOT NULL
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    close_price - LAG(close_price) OVER (ORDER BY date) AS price_change
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

---

## 3. 趋势分析

### 3.1 趋势识别

**趋势识别**判断价格是处于上升、下降还是横盘趋势。

```sql
-- 趋势识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法识别趋势';
            RETURN;
        END IF;
        RAISE NOTICE '开始识别趋势';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 识别趋势（基于移动平均交叉）
WITH moving_averages AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS sma_5,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS sma_10
    FROM price_data
),
trend_signals AS (
    SELECT
        date,
        symbol,
        close_price,
        sma_5,
        sma_10,
        CASE
            WHEN sma_5 > sma_10 AND LAG(sma_5) OVER (PARTITION BY symbol ORDER BY date) <= LAG(sma_10) OVER (PARTITION BY symbol ORDER BY date) THEN 'Bullish Cross'
            WHEN sma_5 < sma_10 AND LAG(sma_5) OVER (PARTITION BY symbol ORDER BY date) >= LAG(sma_10) OVER (PARTITION BY symbol ORDER BY date) THEN 'Bearish Cross'
            WHEN sma_5 > sma_10 THEN 'Uptrend'
            WHEN sma_5 < sma_10 THEN 'Downtrend'
            ELSE 'Sideways'
        END AS trend
    FROM moving_averages
    WHERE sma_5 IS NOT NULL AND sma_10 IS NOT NULL
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(sma_5::numeric, 2) AS sma_5,
    ROUND(sma_10::numeric, 2) AS sma_10,
    trend
FROM trend_signals
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS sma_5,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS sma_10
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

---

## 4. 实际应用案例

### 4.1 交易信号生成

**交易信号生成**基于技术指标生成买卖信号。

```sql
-- 交易信号生成示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法生成交易信号';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成交易信号';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '交易信号生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 生成交易信号（基于MACD和RSI）
WITH macd_data AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS ema_12,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 25 PRECEDING AND CURRENT ROW) AS ema_26
    FROM price_data
),
macd_signals AS (
    SELECT
        date,
        symbol,
        close_price,
        (ema_12 - ema_26) AS macd_line,
        AVG(ema_12 - ema_26) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS signal_line
    FROM macd_data
    WHERE ema_26 IS NOT NULL
),
rsi_data AS (
    SELECT
        date,
        symbol,
        AVG(CASE WHEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) > 0
            THEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) ELSE 0 END)
        OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS avg_gain,
        AVG(CASE WHEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) < 0
            THEN ABS(close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) ELSE 0 END)
        OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS avg_loss
    FROM price_data
),
rsi_values AS (
    SELECT
        date,
        symbol,
        CASE
            WHEN avg_loss = 0 THEN 100
            ELSE 100 - (100 / (1 + avg_gain / NULLIF(avg_loss, 0)))
        END AS rsi
    FROM rsi_data
    WHERE avg_gain IS NOT NULL AND avg_loss IS NOT NULL
),
trading_signals AS (
    SELECT
        ms.date,
        ms.symbol,
        ms.close_price,
        ms.macd_line,
        ms.signal_line,
        rv.rsi,
        CASE
            WHEN ms.macd_line > ms.signal_line AND LAG(ms.macd_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date) <= LAG(ms.signal_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date)
                AND rv.rsi < 70 THEN 'BUY'
            WHEN ms.macd_line < ms.signal_line AND LAG(ms.macd_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date) >= LAG(ms.signal_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date)
                AND rv.rsi > 30 THEN 'SELL'
            ELSE 'HOLD'
        END AS signal
    FROM macd_signals ms
    JOIN rsi_values rv ON ms.date = rv.date AND ms.symbol = rv.symbol
)
SELECT
    date,
    symbol,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(macd_line::numeric, 2) AS macd,
    ROUND(signal_line::numeric, 2) AS signal,
    ROUND(rsi::numeric, 2) AS rsi,
    signal AS trading_signal
FROM trading_signals
WHERE signal != 'HOLD'
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS ema_12
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date
LIMIT 100;
```

---

## 📊 性能优化建议

1. **索引优化**: 在(date, symbol)上创建复合索引
2. **窗口函数**: 充分利用窗口函数优化计算
3. **物化视图**: 对常用指标创建物化视图

## 🎯 最佳实践

1. **参数调优**: 根据市场特点调整指标参数
2. **组合使用**: 结合多个指标提高准确性
3. **回测验证**: 使用历史数据验证策略
4. **风险管理**: 设置止损和止盈点

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
