# PostgreSQL 收益率计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 金融计算 | 收益率
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 收益率计算完整指南](#postgresql-收益率计算完整指南)
  - [📋 目录](#-目录)
  - [收益率计算概述](#收益率计算概述)
    - [核心指标](#核心指标)
  - [1. 简单收益率](#1-简单收益率)
    - [1.1 日收益率计算](#11-日收益率计算)
  - [2. 对数收益率](#2-对数收益率)
    - [2.1 对数收益率计算](#21-对数收益率计算)
  - [3. 累计收益率](#3-累计收益率)
    - [3.1 累计收益率计算](#31-累计收益率计算)
  - [4. 年化收益率](#4-年化收益率)
    - [4.1 年化收益率计算](#41-年化收益率计算)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 投资组合收益率分析](#51-投资组合收益率分析)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 收益率计算概述

**收益率**衡量投资的盈利能力，是金融分析的基础指标。

### 核心指标

| 指标 | 公式 | 用途 |
|------|------|------|
| **简单收益率** | (P_t - P_{t-1}) / P_{t-1} | 基础收益计算 |
| **对数收益率** | ln(P_t / P_{t-1}) | 时间序列分析 |
| **累计收益率** | Π(1 + r_i) - 1 | 多期收益 |
| **年化收益率** | (1 + r)^n - 1 | 标准化比较 |

---

## 1. 简单收益率

### 1.1 日收益率计算

**日收益率**计算每日的价格变化率。

```sql
-- 创建股票价格表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING '表 stock_prices 已存在，先删除';
            DROP TABLE stock_prices CASCADE;
        END IF;

        CREATE TABLE stock_prices (
            date DATE NOT NULL,
            symbol VARCHAR(10) NOT NULL,
            close_price NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (date, symbol)
        );

        -- 插入示例数据
        INSERT INTO stock_prices (date, symbol, close_price) VALUES
            ('2024-01-01', 'AAPL', 150.00),
            ('2024-01-02', 'AAPL', 152.50),
            ('2024-01-03', 'AAPL', 151.00),
            ('2024-01-04', 'AAPL', 153.75),
            ('2024-01-05', 'AAPL', 155.00),
            ('2024-01-01', 'GOOGL', 2800.00),
            ('2024-01-02', 'GOOGL', 2820.00),
            ('2024-01-03', 'GOOGL', 2810.00),
            ('2024-01-04', 'GOOGL', 2835.00),
            ('2024-01-05', 'GOOGL', 2850.00);

        RAISE NOTICE '表 stock_prices 创建成功，已插入10条数据';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 stock_prices 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算日收益率（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING '表 stock_prices 不存在，无法计算收益率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算日收益率';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '收益率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用窗口函数计算日收益率
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
    FROM stock_prices
)
SELECT
    date,
    symbol,
    close_price,
    prev_price,
    CASE
        WHEN prev_price IS NULL THEN NULL
        WHEN prev_price = 0 THEN NULL
        ELSE ROUND(((close_price - prev_price) / prev_price * 100)::numeric, 4)
    END AS daily_return_pct
FROM price_changes
WHERE prev_price IS NOT NULL
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    symbol,
    close_price,
    LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
FROM stock_prices
ORDER BY symbol, date;
```

---

## 2. 对数收益率

### 2.1 对数收益率计算

**对数收益率**具有时间可加性，适合时间序列分析。

```sql
-- 对数收益率计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING '表 stock_prices 不存在，无法计算对数收益率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算对数收益率';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '对数收益率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算对数收益率
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
    FROM stock_prices
)
SELECT
    date,
    symbol,
    close_price,
    prev_price,
    CASE
        WHEN prev_price IS NULL THEN NULL
        WHEN prev_price <= 0 THEN NULL
        ELSE ROUND(LN(close_price / prev_price)::numeric, 6)
    END AS log_return
FROM price_changes
WHERE prev_price IS NOT NULL AND prev_price > 0
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    symbol,
    CASE
        WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) > 0 THEN
            LN(close_price / LAG(close_price) OVER (PARTITION BY symbol ORDER BY date))
        ELSE NULL
    END AS log_return
FROM stock_prices
ORDER BY symbol, date;
```

---

## 3. 累计收益率

### 3.1 累计收益率计算

**累计收益率**计算多期投资的总体收益。

```sql
-- 累计收益率计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING '表 stock_prices 不存在，无法计算累计收益率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算累计收益率';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '累计收益率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算累计收益率（使用简单收益率）
WITH daily_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) IS NULL THEN NULL
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END AS daily_return
    FROM stock_prices
),
cumulative_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        daily_return,
        EXP(SUM(LN(1 + COALESCE(daily_return, 0))) OVER (PARTITION BY symbol ORDER BY date)) - 1 AS cumulative_return
    FROM daily_returns
    WHERE daily_return IS NOT NULL
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(COALESCE(daily_return, 0)::numeric, 6) AS daily_return,
    ROUND(cumulative_return::numeric, 6) AS cumulative_return,
    ROUND((cumulative_return * 100)::numeric, 2) AS cumulative_return_pct
FROM cumulative_returns
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    symbol,
    EXP(SUM(LN(1 + COALESCE(
        (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
        NULLIF(LAG(close_price) OVER (PARTITION BY symbol ORDER BY date), 0),
        0
    ))) OVER (PARTITION BY symbol ORDER BY date)) - 1 AS cumulative_return
FROM stock_prices
ORDER BY symbol, date;
```

---

## 4. 年化收益率

### 4.1 年化收益率计算

**年化收益率**将不同期限的收益率标准化为年度收益率。

```sql
-- 年化收益率计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING '表 stock_prices 不存在，无法计算年化收益率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算年化收益率';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '年化收益率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算年化收益率
WITH period_stats AS (
    SELECT
        symbol,
        MIN(date) AS start_date,
        MAX(date) AS end_date,
        COUNT(*) - 1 AS trading_days,
        FIRST_VALUE(close_price) OVER (PARTITION BY symbol ORDER BY date) AS start_price,
        LAST_VALUE(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS end_price
    FROM stock_prices
    GROUP BY symbol
),
total_return AS (
    SELECT
        symbol,
        start_date,
        end_date,
        trading_days,
        start_price,
        end_price,
        CASE
            WHEN start_price = 0 THEN NULL
            ELSE (end_price - start_price) / start_price
        END AS total_return,
        -- 假设一年252个交易日
        252.0 AS trading_days_per_year
    FROM period_stats
)
SELECT
    symbol,
    start_date,
    end_date,
    trading_days,
    start_price,
    end_price,
    ROUND(total_return::numeric, 6) AS total_return,
    ROUND((total_return * 100)::numeric, 2) AS total_return_pct,
    CASE
        WHEN trading_days = 0 THEN NULL
        ELSE ROUND((POWER(1 + total_return, trading_days_per_year / trading_days) - 1)::numeric, 6)
    END AS annualized_return,
    ROUND((POWER(1 + total_return, trading_days_per_year / NULLIF(trading_days, 0)) - 1) * 100, 2) AS annualized_return_pct
FROM total_return
WHERE total_return IS NOT NULL
ORDER BY symbol;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    symbol,
    COUNT(*) AS trading_days,
    MIN(close_price) AS min_price,
    MAX(close_price) AS max_price
FROM stock_prices
GROUP BY symbol;
```

---

## 5. 实际应用案例

### 5.1 投资组合收益率分析

**投资组合收益率分析**计算多只股票组合的整体收益。

```sql
-- 投资组合收益率分析示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'portfolio_weights') THEN
            RAISE WARNING '表 portfolio_weights 不存在，创建示例表';

            CREATE TABLE portfolio_weights (
                symbol VARCHAR(10) PRIMARY KEY,
                weight NUMERIC(5, 4) NOT NULL CHECK (weight >= 0 AND weight <= 1)
            );

            INSERT INTO portfolio_weights (symbol, weight) VALUES
                ('AAPL', 0.4),
                ('GOOGL', 0.6);

            RAISE NOTICE '表 portfolio_weights 创建成功';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING '表 stock_prices 不存在，请先创建';
            RETURN;
        END IF;

        RAISE NOTICE '开始执行投资组合收益率分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '投资组合分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算投资组合日收益率
WITH daily_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) IS NULL THEN NULL
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END AS daily_return
    FROM stock_prices
),
portfolio_returns AS (
    SELECT
        dr.date,
        SUM(dr.daily_return * pw.weight) AS portfolio_return
    FROM daily_returns dr
    JOIN portfolio_weights pw ON dr.symbol = pw.symbol
    WHERE dr.daily_return IS NOT NULL
    GROUP BY dr.date
)
SELECT
    date,
    ROUND(portfolio_return::numeric, 6) AS portfolio_daily_return,
    ROUND((portfolio_return * 100)::numeric, 4) AS portfolio_daily_return_pct,
    ROUND(EXP(SUM(LN(1 + portfolio_return)) OVER (ORDER BY date)) - 1, 6) AS cumulative_return,
    ROUND((EXP(SUM(LN(1 + portfolio_return)) OVER (ORDER BY date)) - 1) * 100, 2) AS cumulative_return_pct
FROM portfolio_returns
ORDER BY date;

-- 计算投资组合统计指标
WITH daily_returns AS (
    SELECT
        date,
        symbol,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END AS daily_return
    FROM stock_prices
),
portfolio_returns AS (
    SELECT
        dr.date,
        SUM(dr.daily_return * pw.weight) AS portfolio_return
    FROM daily_returns dr
    JOIN portfolio_weights pw ON dr.symbol = pw.symbol
    WHERE dr.daily_return IS NOT NULL
    GROUP BY dr.date
)
SELECT
    COUNT(*) AS trading_days,
    ROUND(AVG(portfolio_return)::numeric, 6) AS avg_daily_return,
    ROUND(STDDEV(portfolio_return)::numeric, 6) AS std_daily_return,
    ROUND(MIN(portfolio_return)::numeric, 6) AS min_daily_return,
    ROUND(MAX(portfolio_return)::numeric, 6) AS max_daily_return,
    ROUND((AVG(portfolio_return) * 252)::numeric, 6) AS annualized_return,
    ROUND((STDDEV(portfolio_return) * SQRT(252))::numeric, 6) AS annualized_volatility,
    CASE
        WHEN STDDEV(portfolio_return) = 0 THEN NULL
        ELSE ROUND((AVG(portfolio_return) / STDDEV(portfolio_return) * SQRT(252))::numeric, 4)
    END AS sharpe_ratio
FROM portfolio_returns;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    SUM(daily_return * weight) AS portfolio_return
FROM (
    SELECT
        date,
        symbol,
        (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
        NULLIF(LAG(close_price) OVER (PARTITION BY symbol ORDER BY date), 0) AS daily_return
    FROM stock_prices
) dr
JOIN portfolio_weights pw ON dr.symbol = pw.symbol
WHERE daily_return IS NOT NULL
GROUP BY date
ORDER BY date;
```

---

## 📊 性能优化建议

1. **索引优化**: 在(date, symbol)上创建复合索引
2. **物化视图**: 对常用收益率指标创建物化视图
3. **分区表**: 对历史数据使用分区表

## 🎯 最佳实践

1. **数据质量**: 处理缺失值和异常值
2. **精度控制**: 使用NUMERIC类型保证精度
3. **边界检查**: 检查除零和负数情况
4. **标准化**: 统一收益率计算口径

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
