# PostgreSQL 最短路径算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 最短路径 | Dijkstra算法
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)

---

## 📋 目录

- [PostgreSQL 最短路径算法完整指南](#postgresql-最短路径算法完整指南)
  - [📋 目录](#-目录)
  - [最短路径算法概述](#最短路径算法概述)
    - [核心算法](#核心算法)
  - [1. Dijkstra算法](#1-dijkstra算法)
    - [1.1 递归实现](#11-递归实现)
  - [2. Floyd-Warshall算法](#2-floyd-warshall算法)
    - [2.1 全对最短路径](#21-全对最短路径)
  - [3. 路径权重计算](#3-路径权重计算)
    - [3.1 加权路径查找](#31-加权路径查找)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 路由规划](#41-路由规划)

---

## 最短路径算法概述

**最短路径算法**用于查找图中两个节点之间的最短路径，常用于路径规划和网络分析。

### 核心算法

| 算法 | 用途 | 复杂度 |
|------|------|--------|
| **Dijkstra** | 单源最短路径 | O(V²) |
| **Floyd-Warshall** | 全对最短路径 | O(V³) |
| **A*** | 启发式搜索 | O(V+E) |

---

## 1. Dijkstra算法

### 1.1 递归实现

**Dijkstra算法**使用递归CTE实现最短路径查找。

```sql
-- Dijkstra算法（带错误处理和性能测试）
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行Dijkstra算法';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行Dijkstra算法';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行Dijkstra算法，从节点 % 到节点 %', start_node_id, end_node_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Dijkstra算法准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE dijkstra AS (
    SELECT
        start_node_id AS current_node,
        0 AS total_distance,
        ARRAY[start_node_id] AS path
    UNION ALL
    SELECT
        e.target_id,
        d.total_distance + e.weight,
        d.path || e.target_id
    FROM dijkstra d
    JOIN edges e ON d.current_node = e.source_id
    WHERE e.target_id != ALL(d.path)
      AND d.total_distance + e.weight < (
          SELECT COALESCE(MIN(total_distance), 999999)
          FROM dijkstra
          WHERE current_node = e.target_id
      )
)
SELECT
    current_node AS target_node,
    MIN(total_distance) AS shortest_distance,
    (SELECT path FROM dijkstra
     WHERE current_node = d.current_node
       AND total_distance = MIN(d.total_distance)
     LIMIT 1) AS shortest_path
FROM dijkstra d
WHERE current_node = end_node_id
GROUP BY current_node;
```

---

## 2. Floyd-Warshall算法

### 2.1 全对最短路径

**Floyd-Warshall算法**计算所有节点对之间的最短路径。

```sql
-- Floyd-Warshall算法（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行Floyd-Warshall算法';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行Floyd-Warshall算法';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Floyd-Warshall算法准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE floyd_warshall AS (
    -- 初始化：直接连接的边
    SELECT
        source_id AS i,
        target_id AS j,
        weight AS distance
    FROM edges
    UNION
    -- 自身距离为0
    SELECT DISTINCT
        id AS i,
        id AS j,
        0 AS distance
    FROM nodes
    UNION ALL
    -- 递归：通过中间节点k更新距离
    SELECT
        fw1.i,
        fw2.j,
        LEAST(fw1.distance, fw1.distance + fw2.distance)
    FROM floyd_warshall fw1
    JOIN floyd_warshall fw2 ON fw1.j = fw2.i
    WHERE fw1.distance + fw2.distance < fw1.distance
)
SELECT
    i AS from_node,
    j AS to_node,
    MIN(distance) AS shortest_distance
FROM floyd_warshall
GROUP BY i, j
ORDER BY i, j;
```

---

## 3. 路径权重计算

### 3.1 加权路径查找

**路径权重计算**计算带权重的最短路径。

```sql
-- 加权路径查找（带错误处理和性能测试）
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行加权路径查找';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行加权路径查找';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '加权路径查找准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE weighted_paths AS (
    SELECT
        start_node_id AS current_node,
        0 AS total_weight,
        ARRAY[start_node_id] AS path
    UNION ALL
    SELECT
        e.target_id,
        wp.total_weight + e.weight,
        wp.path || e.target_id
    FROM weighted_paths wp
    JOIN edges e ON wp.current_node = e.source_id
    WHERE e.target_id != ALL(wp.path)
      AND wp.total_weight + e.weight < (
          SELECT COALESCE(MIN(total_weight), 999999)
          FROM weighted_paths
          WHERE current_node = e.target_id
      )
)
SELECT
    current_node,
    MIN(total_weight) AS min_weight,
    (SELECT path FROM weighted_paths
     WHERE current_node = wp.current_node
       AND total_weight = MIN(wp.total_weight)
     LIMIT 1) AS shortest_path
FROM weighted_paths wp
WHERE current_node = end_node_id
GROUP BY current_node;
```

---

## 4. 实际应用案例

### 4.1 路由规划

**路由规划**规划最优路径。

```sql
-- 路由规划（带错误处理和性能测试）
DO $$
DECLARE
    origin_id INTEGER := 1;
    destination_id INTEGER := 20;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'routes') THEN
            RAISE WARNING '表 routes 不存在，无法执行路由规划';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行路由规划，从节点 % 到节点 %', origin_id, destination_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '路由规划准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE route_planning AS (
    SELECT
        origin_id AS current_location,
        0 AS total_time,
        ARRAY[origin_id] AS route
    UNION ALL
    SELECT
        r.to_location,
        rp.total_time + r.travel_time,
        rp.route || r.to_location
    FROM route_planning rp
    JOIN routes r ON rp.current_location = r.from_location
    WHERE r.to_location != ALL(rp.route)
      AND rp.total_time + r.travel_time < (
          SELECT COALESCE(MIN(total_time), 999999)
          FROM route_planning
          WHERE current_location = r.to_location
      )
)
SELECT
    current_location,
    MIN(total_time) AS shortest_time,
    (SELECT route FROM route_planning
     WHERE current_location = rp.current_location
       AND total_time = MIN(rp.total_time)
     LIMIT 1) AS optimal_route
FROM route_planning rp
WHERE current_location = destination_id
GROUP BY current_location;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
