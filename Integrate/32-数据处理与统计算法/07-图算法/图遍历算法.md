# PostgreSQL 图遍历算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 图遍历 | 递归CTE
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 图遍历算法完整指南](#postgresql-图遍历算法完整指南)
  - [📋 目录](#-目录)
  - [图遍历算法概述](#图遍历算法概述)
    - [核心遍历算法](#核心遍历算法)
  - [1. 深度优先搜索](#1-深度优先搜索)
    - [1.1 递归DFS实现](#11-递归dfs实现)
  - [2. 广度优先搜索](#2-广度优先搜索)
    - [2.1 递归BFS实现](#21-递归bfs实现)
  - [3. 路径查找](#3-路径查找)
    - [3.1 查找所有路径](#31-查找所有路径)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 组织架构遍历](#41-组织架构遍历)

---

## 图遍历算法概述

**图遍历算法**用于遍历图中的所有节点，PostgreSQL可以使用递归CTE实现图遍历。

### 核心遍历算法

| 算法 | 用途 | 复杂度 |
|------|------|--------|
| **DFS** | 深度优先搜索 | O(V+E) |
| **BFS** | 广度优先搜索 | O(V+E) |
| **路径查找** | 查找路径 | O(V+E) |

---

## 1. 深度优先搜索

### 1.1 递归DFS实现

**深度优先搜索**使用递归CTE实现DFS遍历。

```sql
-- 深度优先搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行深度优先搜索';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行深度优先搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行深度优先搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '深度优先搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE dfs AS (
    -- 起始节点
    SELECT
        id,
        ARRAY[id] AS path,
        0 AS depth
    FROM nodes
    WHERE id = 1  -- 起始节点ID

    UNION ALL

    -- 递归：访问相邻节点
    SELECT
        e.target_id,
        d.path || e.target_id,
        d.depth + 1
    FROM dfs d
    JOIN edges e ON d.id = e.source_id
    WHERE e.target_id != ALL(d.path)  -- 避免循环
      AND d.depth < 10  -- 最大深度限制
)
SELECT * FROM dfs ORDER BY depth, id;
```

---

## 2. 广度优先搜索

### 2.1 递归BFS实现

**广度优先搜索**使用递归CTE实现BFS遍历。

```sql
-- 广度优先搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行广度优先搜索';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行广度优先搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行广度优先搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '广度优先搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE bfs AS (
    SELECT
        id,
        ARRAY[id] AS path,
        0 AS level
    FROM nodes
    WHERE id = 1

    UNION ALL

    SELECT
        e.target_id,
        b.path || e.target_id,
        b.level + 1
    FROM bfs b
    JOIN edges e ON b.id = e.source_id
    WHERE e.target_id != ALL(b.path)
      AND b.level < 10
)
SELECT
    id,
    path,
    level
FROM bfs
WHERE level = (
    SELECT MIN(level)
    FROM bfs
    WHERE id = bfs.id
)
ORDER BY level, id;
```

---

## 3. 路径查找

### 3.1 查找所有路径

**路径查找**查找两个节点之间的所有路径。

```sql
-- 路径查找（带错误处理和性能测试）
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行路径查找';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行路径查找';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行路径查找，从节点 % 到节点 %', start_node_id, end_node_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '路径查找准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE paths AS (
    SELECT
        start_node_id AS current_node,
        ARRAY[start_node_id] AS path,
        0 AS depth
    UNION ALL
    SELECT
        e.target_id,
        p.path || e.target_id,
        p.depth + 1
    FROM paths p
    JOIN edges e ON p.current_node = e.source_id
    WHERE e.target_id != ALL(p.path)
      AND p.depth < 20
      AND e.target_id != end_node_id OR p.depth = 0
)
SELECT
    path,
    depth AS path_length
FROM paths
WHERE path[array_length(path, 1)] = end_node_id
ORDER BY path_length, path;
```

---

## 4. 实际应用案例

### 4.1 组织架构遍历

**组织架构遍历**遍历组织架构树。

```sql
-- 组织架构遍历（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'organizations') THEN
            RAISE WARNING '表 organizations 不存在，无法执行组织架构遍历';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行组织架构遍历';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '组织架构遍历准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE org_tree AS (
    SELECT
        org_id,
        name,
        parent_id,
        1 AS level,
        ARRAY[org_id] AS path,
        name AS full_path
    FROM organizations
    WHERE parent_id IS NULL

    UNION ALL

    SELECT
        o.org_id,
        o.name,
        o.parent_id,
        ot.level + 1,
        ot.path || o.org_id,
        ot.full_path || ' > ' || o.name
    FROM organizations o
    JOIN org_tree ot ON o.parent_id = ot.org_id
)
SELECT
    org_id,
    name,
    level,
    full_path
FROM org_tree
ORDER BY path;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
