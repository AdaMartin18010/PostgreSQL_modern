# PostgreSQL 性能指标计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 性能监控 | 指标计算
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 性能指标计算完整指南](#postgresql-性能指标计算完整指南)
  - [📋 目录](#-目录)
  - [性能指标概述](#性能指标概述)
    - [核心指标](#核心指标)
  - [1. CPU使用率](#1-cpu使用率)
    - [1.1 CPU使用率计算](#11-cpu使用率计算)
  - [2. 内存使用率](#2-内存使用率)
    - [2.1 内存使用率计算](#21-内存使用率计算)
  - [3. 磁盘I/O](#3-磁盘io)
    - [3.1 磁盘I/O统计](#31-磁盘io统计)
  - [4. 数据库性能指标](#4-数据库性能指标)
    - [4.1 查询性能统计](#41-查询性能统计)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 性能监控仪表板](#51-性能监控仪表板)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 性能指标概述

**性能指标**用于监控系统运行状态，识别性能瓶颈。

### 核心指标

| 指标 | 用途 | 单位 |
|------|------|------|
| **CPU使用率** | CPU负载 | % |
| **内存使用率** | 内存占用 | % |
| **磁盘I/O** | 磁盘读写 | IOPS |
| **查询性能** | 数据库性能 | ms |

---

## 1. CPU使用率

### 1.1 CPU使用率计算

**CPU使用率**计算CPU的繁忙程度。

```sql
-- 创建系统监控数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 已存在，先删除';
            DROP TABLE system_metrics CASCADE;
        END IF;

        CREATE TABLE system_metrics (
            timestamp TIMESTAMP NOT NULL,
            metric_name VARCHAR(50) NOT NULL,
            metric_value NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (timestamp, metric_name)
        );

        -- 插入示例数据
        INSERT INTO system_metrics (timestamp, metric_name, metric_value) VALUES
            ('2024-01-01 10:00:00', 'cpu_usage', 45.5),
            ('2024-01-01 10:01:00', 'cpu_usage', 52.3),
            ('2024-01-01 10:02:00', 'cpu_usage', 48.7),
            ('2024-01-01 10:00:00', 'memory_usage', 65.2),
            ('2024-01-01 10:01:00', 'memory_usage', 67.8),
            ('2024-01-01 10:02:00', 'memory_usage', 69.1);

        RAISE NOTICE '表 system_metrics 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 system_metrics 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算CPU使用率统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法计算CPU使用率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算CPU使用率统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'CPU使用率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算CPU使用率统计
SELECT
    metric_name,
    COUNT(*) AS sample_count,
    ROUND(AVG(metric_value)::numeric, 2) AS avg_value,
    ROUND(MIN(metric_value)::numeric, 2) AS min_value,
    ROUND(MAX(metric_value)::numeric, 2) AS max_value,
    ROUND(STDDEV(metric_value)::numeric, 2) AS std_value
FROM system_metrics
WHERE metric_name = 'cpu_usage'
GROUP BY metric_name;

-- 计算移动平均CPU使用率
SELECT
    timestamp,
    metric_value,
    AVG(metric_value) OVER (
        ORDER BY timestamp
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS moving_avg_5min
FROM system_metrics
WHERE metric_name = 'cpu_usage'
ORDER BY timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    timestamp,
    AVG(metric_value) OVER (ORDER BY timestamp ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS moving_avg
FROM system_metrics
WHERE metric_name = 'cpu_usage'
ORDER BY timestamp;
```

---

## 2. 内存使用率

### 2.1 内存使用率计算

**内存使用率**监控内存占用情况。

```sql
-- 内存使用率计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法计算内存使用率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算内存使用率统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '内存使用率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算内存使用率统计
SELECT
    timestamp,
    metric_value AS memory_usage_pct,
    CASE
        WHEN metric_value > 90 THEN 'Critical'
        WHEN metric_value > 80 THEN 'Warning'
        WHEN metric_value > 70 THEN 'Caution'
        ELSE 'Normal'
    END AS status
FROM system_metrics
WHERE metric_name = 'memory_usage'
ORDER BY timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    timestamp,
    metric_value
FROM system_metrics
WHERE metric_name = 'memory_usage'
ORDER BY timestamp;
```

---

## 3. 磁盘I/O

### 3.1 磁盘I/O统计

**磁盘I/O统计**监控磁盘读写性能。

```sql
-- 创建磁盘I/O数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'disk_io_metrics') THEN
            RAISE WARNING '表 disk_io_metrics 已存在，先删除';
            DROP TABLE disk_io_metrics CASCADE;
        END IF;

        CREATE TABLE disk_io_metrics (
            timestamp TIMESTAMP NOT NULL,
            device VARCHAR(50) NOT NULL,
            read_iops INTEGER NOT NULL,
            write_iops INTEGER NOT NULL,
            read_bytes BIGINT NOT NULL,
            write_bytes BIGINT NOT NULL,
            PRIMARY KEY (timestamp, device)
        );

        INSERT INTO disk_io_metrics (timestamp, device, read_iops, write_iops, read_bytes, write_bytes) VALUES
            ('2024-01-01 10:00:00', 'sda', 100, 50, 1048576, 524288),
            ('2024-01-01 10:01:00', 'sda', 120, 60, 1258291, 629146),
            ('2024-01-01 10:02:00', 'sda', 110, 55, 1153434, 576717);

        RAISE NOTICE '表 disk_io_metrics 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 disk_io_metrics 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算磁盘I/O统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'disk_io_metrics') THEN
            RAISE WARNING '表 disk_io_metrics 不存在，无法计算磁盘I/O统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算磁盘I/O统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '磁盘I/O统计计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算磁盘I/O统计
SELECT
    device,
    COUNT(*) AS sample_count,
    ROUND(AVG(read_iops)::numeric, 2) AS avg_read_iops,
    ROUND(AVG(write_iops)::numeric, 2) AS avg_write_iops,
    ROUND(AVG(read_iops + write_iops)::numeric, 2) AS avg_total_iops,
    ROUND(AVG(read_bytes)::numeric / 1024 / 1024, 2) AS avg_read_mbps,
    ROUND(AVG(write_bytes)::numeric / 1024 / 1024, 2) AS avg_write_mbps
FROM disk_io_metrics
GROUP BY device
ORDER BY device;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    device,
    AVG(read_iops + write_iops) AS avg_total_iops
FROM disk_io_metrics
GROUP BY device;
```

---

## 4. 数据库性能指标

### 4.1 查询性能统计

**查询性能统计**监控数据库查询性能。

```sql
-- 创建查询性能数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_performance') THEN
            RAISE WARNING '表 query_performance 已存在，先删除';
            DROP TABLE query_performance CASCADE;
        END IF;

        CREATE TABLE query_performance (
            timestamp TIMESTAMP NOT NULL,
            query_id VARCHAR(100) NOT NULL,
            execution_time_ms NUMERIC(10, 2) NOT NULL,
            rows_returned INTEGER NOT NULL,
            PRIMARY KEY (timestamp, query_id)
        );

        INSERT INTO query_performance (timestamp, query_id, execution_time_ms, rows_returned) VALUES
            ('2024-01-01 10:00:00', 'query_001', 125.5, 1000),
            ('2024-01-01 10:01:00', 'query_001', 130.2, 1050),
            ('2024-01-01 10:02:00', 'query_001', 118.7, 980),
            ('2024-01-01 10:00:00', 'query_002', 45.3, 500),
            ('2024-01-01 10:01:00', 'query_002', 42.1, 480);

        RAISE NOTICE '表 query_performance 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 query_performance 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算查询性能统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_performance') THEN
            RAISE WARNING '表 query_performance 不存在，无法计算查询性能统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算查询性能统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询性能统计计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算查询性能统计
SELECT
    query_id,
    COUNT(*) AS execution_count,
    ROUND(AVG(execution_time_ms)::numeric, 2) AS avg_execution_time,
    ROUND(MIN(execution_time_ms)::numeric, 2) AS min_execution_time,
    ROUND(MAX(execution_time_ms)::numeric, 2) AS max_execution_time,
    ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY execution_time_ms)::numeric, 2) AS p95_execution_time,
    ROUND(AVG(rows_returned)::numeric, 0) AS avg_rows_returned
FROM query_performance
GROUP BY query_id
ORDER BY avg_execution_time DESC;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    query_id,
    AVG(execution_time_ms) AS avg_time
FROM query_performance
GROUP BY query_id;
```

---

## 5. 实际应用案例

### 5.1 性能监控仪表板

**性能监控仪表板**综合展示各项性能指标。

```sql
-- 性能监控仪表板数据查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法生成监控仪表板';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成性能监控仪表板数据';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '监控仪表板生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 生成性能监控仪表板数据
WITH latest_metrics AS (
    SELECT
        metric_name,
        metric_value,
        timestamp
    FROM system_metrics
    WHERE timestamp = (SELECT MAX(timestamp) FROM system_metrics)
),
summary_stats AS (
    SELECT
        metric_name,
        COUNT(*) AS sample_count,
        AVG(metric_value) AS avg_value,
        MIN(metric_value) AS min_value,
        MAX(metric_value) AS max_value
    FROM system_metrics
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
    GROUP BY metric_name
)
SELECT
    lm.metric_name,
    lm.metric_value AS current_value,
    ROUND(ss.avg_value::numeric, 2) AS avg_value_1h,
    ROUND(ss.min_value::numeric, 2) AS min_value_1h,
    ROUND(ss.max_value::numeric, 2) AS max_value_1h,
    CASE
        WHEN lm.metric_name = 'cpu_usage' AND lm.metric_value > 80 THEN 'Critical'
        WHEN lm.metric_name = 'cpu_usage' AND lm.metric_value > 70 THEN 'Warning'
        WHEN lm.metric_name = 'memory_usage' AND lm.metric_value > 90 THEN 'Critical'
        WHEN lm.metric_name = 'memory_usage' AND lm.metric_value > 80 THEN 'Warning'
        ELSE 'Normal'
    END AS status
FROM latest_metrics lm
JOIN summary_stats ss ON lm.metric_name = ss.metric_name
ORDER BY lm.metric_name;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    metric_name,
    AVG(metric_value) AS avg_value
FROM system_metrics
WHERE timestamp >= NOW() - INTERVAL '1 hour'
GROUP BY metric_name;
```

---

## 📊 性能优化建议

1. **索引优化**: 在timestamp和metric_name上创建索引
2. **分区表**: 按时间分区存储历史数据
3. **物化视图**: 对常用统计创建物化视图

## 🎯 最佳实践

1. **采样频率**: 根据需求设置合适的采样频率
2. **数据保留**: 设置合理的数据保留策略
3. **告警阈值**: 设置合理的告警阈值
4. **趋势分析**: 关注指标趋势而非单点值

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
