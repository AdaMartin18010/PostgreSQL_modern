# PostgreSQL åˆ†ç±»ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | åˆ†ç±»ç®—æ³• | é¢„æµ‹åˆ†æ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL åˆ†ç±»ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-åˆ†ç±»ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [åˆ†ç±»ç®—æ³•æ¦‚è¿°](#åˆ†ç±»ç®—æ³•æ¦‚è¿°)
    - [æ ¸å¿ƒåˆ†ç±»ç®—æ³•](#æ ¸å¿ƒåˆ†ç±»ç®—æ³•)
  - [1. æœ´ç´ è´å¶æ–¯åˆ†ç±»](#1-æœ´ç´ è´å¶æ–¯åˆ†ç±»)
    - [1.1 æ¦‚ç‡è®¡ç®—](#11-æ¦‚ç‡è®¡ç®—)
  - [2. å†³ç­–æ ‘åˆ†ç±»](#2-å†³ç­–æ ‘åˆ†ç±»)
    - [2.1 ä¿¡æ¯å¢ç›Šè®¡ç®—](#21-ä¿¡æ¯å¢ç›Šè®¡ç®—)
  - [3. åˆ†ç±»è¯„ä¼°](#3-åˆ†ç±»è¯„ä¼°)
    - [3.1 æ··æ·†çŸ©é˜µ](#31-æ··æ·†çŸ©é˜µ)
    - [3.2 å‡†ç¡®ç‡å’Œå¬å›ç‡](#32-å‡†ç¡®ç‡å’Œå¬å›ç‡)
  - [4. å®é™…åº”ç”¨æ¡ˆä¾‹](#4-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [4.1 å®¢æˆ·åˆ†ç±»](#41-å®¢æˆ·åˆ†ç±»)

---

## åˆ†ç±»ç®—æ³•æ¦‚è¿°

**åˆ†ç±»ç®—æ³•**ç”¨äºé¢„æµ‹æ•°æ®ç‚¹çš„ç±»åˆ«ï¼ŒPostgreSQLå¯ä»¥é€šè¿‡SQLå®ç°ç®€å•çš„åˆ†ç±»ç®—æ³•ã€‚

### æ ¸å¿ƒåˆ†ç±»ç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ |
|------|------|--------|
| **æœ´ç´ è´å¶æ–¯** | æ¦‚ç‡åˆ†ç±» | O(n) |
| **å†³ç­–æ ‘** | è§„åˆ™åˆ†ç±» | O(n log n) |
| **KNN** | æœ€è¿‘é‚»åˆ†ç±» | O(nÂ²) |

---

## 1. æœ´ç´ è´å¶æ–¯åˆ†ç±»

### 1.1 æ¦‚ç‡è®¡ç®—

**æœ´ç´ è´å¶æ–¯åˆ†ç±»**åŸºäºæ¡ä»¶æ¦‚ç‡è¿›è¡Œåˆ†ç±»ã€‚

```sql
-- æœ´ç´ è´å¶æ–¯åˆ†ç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    total_count BIGINT;
    class_a_count BIGINT;
    class_b_count BIGINT;
    class_a_prob NUMERIC;
    class_b_prob NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'training_data') THEN
            RAISE WARNING 'è¡¨ training_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæœ´ç´ è´å¶æ–¯åˆ†ç±»';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO total_count FROM training_data;
        SELECT COUNT(*) INTO class_a_count FROM training_data WHERE class = 'A';
        SELECT COUNT(*) INTO class_b_count FROM training_data WHERE class = 'B';

        class_a_prob := class_a_count::NUMERIC / NULLIF(total_count, 0);
        class_b_prob := class_b_count::NUMERIC / NULLIF(total_count, 0);

        RAISE NOTICE 'å…ˆéªŒæ¦‚ç‡:';
        RAISE NOTICE '  P(A) = %', class_a_prob;
        RAISE NOTICE '  P(B) = %', class_b_prob;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æœ´ç´ è´å¶æ–¯åˆ†ç±»å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—æ¡ä»¶æ¦‚ç‡
WITH class_probs AS (
    SELECT
        class,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () AS prior_prob
    FROM training_data
    GROUP BY class
),
feature_probs AS (
    SELECT
        class,
        feature_value,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY class) AS conditional_prob
    FROM training_data
    GROUP BY class, feature_value
)
SELECT
    cp.class,
    cp.prior_prob,
    fp.feature_value,
    fp.conditional_prob,
    cp.prior_prob * fp.conditional_prob AS posterior_prob
FROM class_probs cp
JOIN feature_probs fp ON cp.class = fp.class
ORDER BY cp.class, fp.feature_value;
```

---

## 2. å†³ç­–æ ‘åˆ†ç±»

### 2.1 ä¿¡æ¯å¢ç›Šè®¡ç®—

**ä¿¡æ¯å¢ç›Š**ç”¨äºå†³ç­–æ ‘èŠ‚ç‚¹åˆ†è£‚ã€‚

```sql
-- ä¿¡æ¯å¢ç›Šè®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    entropy_before NUMERIC;
    entropy_after NUMERIC;
    information_gain NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'training_data') THEN
            RAISE WARNING 'è¡¨ training_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ä¿¡æ¯å¢ç›Š';
            RETURN;
        END IF;

        -- è®¡ç®—åˆ†è£‚å‰çš„ç†µ
        WITH class_counts AS (
            SELECT
                class,
                COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () AS prob
            FROM training_data
            GROUP BY class
        )
        SELECT -SUM(prob * LN(NULLIF(prob, 0))) INTO entropy_before
        FROM class_counts;

        -- è®¡ç®—åˆ†è£‚åçš„åŠ æƒç†µï¼ˆç®€åŒ–ç‰ˆï¼‰
        WITH split_entropy AS (
            SELECT
                feature_value,
                -SUM((class_count::NUMERIC / NULLIF(total_count, 0)) * LN(NULLIF(class_count::NUMERIC / NULLIF(total_count, 0), 0))) AS entropy
            FROM (
                SELECT
                    feature_value,
                    class,
                    COUNT(*) AS class_count,
                    SUM(COUNT(*)) OVER (PARTITION BY feature_value) AS total_count
                FROM training_data
                GROUP BY feature_value, class
            ) AS split_counts
            GROUP BY feature_value
        )
        SELECT AVG(entropy) INTO entropy_after FROM split_entropy;

        information_gain := entropy_before - entropy_after;

        RAISE NOTICE 'ä¿¡æ¯å¢ç›Šè®¡ç®—:';
        RAISE NOTICE '  åˆ†è£‚å‰ç†µ: %', entropy_before;
        RAISE NOTICE '  åˆ†è£‚åç†µ: %', entropy_after;
        RAISE NOTICE '  ä¿¡æ¯å¢ç›Š: %', information_gain;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¿¡æ¯å¢ç›Šè®¡ç®—å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 3. åˆ†ç±»è¯„ä¼°

### 3.1 æ··æ·†çŸ©é˜µ

**æ··æ·†çŸ©é˜µ**è¯„ä¼°åˆ†ç±»æ€§èƒ½ã€‚

```sql
-- æ··æ·†çŸ©é˜µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'predictions') THEN
            RAISE WARNING 'è¡¨ predictions ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—æ··æ·†çŸ©é˜µ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—æ··æ·†çŸ©é˜µ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ··æ·†çŸ©é˜µè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    actual_class,
    predicted_class,
    COUNT(*) AS count
FROM predictions
GROUP BY actual_class, predicted_class
ORDER BY actual_class, predicted_class;
```

### 3.2 å‡†ç¡®ç‡å’Œå¬å›ç‡

**å‡†ç¡®ç‡å’Œå¬å›ç‡**è¯„ä¼°åˆ†ç±»æ€§èƒ½æŒ‡æ ‡ã€‚

```sql
-- å‡†ç¡®ç‡å’Œå¬å›ç‡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    true_positive BIGINT;
    false_positive BIGINT;
    false_negative BIGINT;
    precision_val NUMERIC;
    recall_val NUMERIC;
    f1_score NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'predictions') THEN
            RAISE WARNING 'è¡¨ predictions ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—å‡†ç¡®ç‡å’Œå¬å›ç‡';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO true_positive
        FROM predictions
        WHERE actual_class = 'positive' AND predicted_class = 'positive';

        SELECT COUNT(*) INTO false_positive
        FROM predictions
        WHERE actual_class = 'negative' AND predicted_class = 'positive';

        SELECT COUNT(*) INTO false_negative
        FROM predictions
        WHERE actual_class = 'positive' AND predicted_class = 'negative';

        precision_val := true_positive::NUMERIC / NULLIF(true_positive + false_positive, 0);
        recall_val := true_positive::NUMERIC / NULLIF(true_positive + false_negative, 0);
        f1_score := 2 * precision_val * recall_val / NULLIF(precision_val + recall_val, 0);

        RAISE NOTICE 'åˆ†ç±»æ€§èƒ½æŒ‡æ ‡:';
        RAISE NOTICE '  ç²¾ç¡®ç‡ (Precision): %', precision_val;
        RAISE NOTICE '  å¬å›ç‡ (Recall): %', recall_val;
        RAISE NOTICE '  F1åˆ†æ•°: %', f1_score;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å‡†ç¡®ç‡å’Œå¬å›ç‡è®¡ç®—å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 4. å®é™…åº”ç”¨æ¡ˆä¾‹

### 4.1 å®¢æˆ·åˆ†ç±»

**å®¢æˆ·åˆ†ç±»**æ ¹æ®å®¢æˆ·ç‰¹å¾è¿›è¡Œåˆ†ç±»ã€‚

```sql
-- å®¢æˆ·åˆ†ç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customers') THEN
            RAISE WARNING 'è¡¨ customers ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå®¢æˆ·åˆ†ç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®¢æˆ·åˆ†ç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·åˆ†ç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH customer_features AS (
    SELECT
        customer_id,
        total_orders,
        total_amount,
        avg_order_amount,
        last_order_days,
        CASE
            WHEN total_orders >= 10 AND total_amount >= 10000 THEN 'VIP'
            WHEN total_orders >= 5 AND total_amount >= 5000 THEN 'Regular'
            WHEN total_orders >= 1 THEN 'Occasional'
            ELSE 'New'
        END AS customer_segment
    FROM customers
)
SELECT
    customer_segment,
    COUNT(*) AS customer_count,
    AVG(total_orders) AS avg_orders,
    AVG(total_amount) AS avg_amount
FROM customer_features
GROUP BY customer_segment
ORDER BY avg_amount DESC;
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
