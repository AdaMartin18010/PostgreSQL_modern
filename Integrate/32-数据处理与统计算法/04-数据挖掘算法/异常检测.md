# PostgreSQL 异常检测完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 异常检测 | 数据质量
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 异常检测完整指南](#postgresql-异常检测完整指南)
  - [📋 目录](#-目录)
  - [异常检测概述](#异常检测概述)
    - [核心检测方法](#核心检测方法)
  - [1. 统计异常检测](#1-统计异常检测)
    - [1.1 基于均值和标准差](#11-基于均值和标准差)
  - [2. Z-score异常检测](#2-z-score异常检测)
    - [2.1 Z-score计算](#21-z-score计算)
  - [3. IQR异常检测](#3-iqr异常检测)
    - [3.1 四分位距检测](#31-四分位距检测)
  - [4. 孤立点检测](#4-孤立点检测)
    - [4.1 距离异常检测](#41-距离异常检测)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 系统监控异常检测](#51-系统监控异常检测)

---

## 异常检测概述

**异常检测**用于识别数据中的异常值，常用于数据质量监控和异常监控。

### 核心检测方法

| 方法 | 用途 | 复杂度 |
|------|------|--------|
| **Z-score** | 标准差异常 | O(n) |
| **IQR** | 四分位距异常 | O(n log n) |
| **孤立点** | 距离异常 | O(n²) |

---

## 1. 统计异常检测

### 1.1 基于均值和标准差

**统计异常检测**使用均值和标准差识别异常。

```sql
-- 统计异常检测（带错误处理和性能测试）
DO $$
DECLARE
    mean_val NUMERIC;
    stddev_val NUMERIC;
    lower_bound NUMERIC;
    upper_bound NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行统计异常检测';
            RETURN;
        END IF;

        SELECT AVG(value), STDDEV(value) INTO mean_val, stddev_val
        FROM metrics
        WHERE value IS NOT NULL;

        lower_bound := mean_val - 3 * stddev_val;
        upper_bound := mean_val + 3 * stddev_val;

        RAISE NOTICE '统计异常检测阈值:';
        RAISE NOTICE '  均值: %', mean_val;
        RAISE NOTICE '  标准差: %', stddev_val;
        RAISE NOTICE '  下界: %', lower_bound;
        RAISE NOTICE '  上界: %', upper_bound;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '统计异常检测失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 检测异常值
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stats AS (
    SELECT
        AVG(value) AS mean,
        STDDEV(value) AS stddev
    FROM metrics
    WHERE value IS NOT NULL
)
SELECT
    timestamp,
    value,
    CASE
        WHEN value < s.mean - 3 * s.stddev OR value > s.mean + 3 * s.stddev THEN '异常'
        ELSE '正常'
    END AS status
FROM metrics
CROSS JOIN stats s
WHERE value IS NOT NULL
ORDER BY ABS(value - s.mean) DESC;
```

---

## 2. Z-score异常检测

### 2.1 Z-score计算

**Z-score异常检测**使用标准化分数识别异常。

```sql
-- Z-score异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行Z-score异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行Z-score异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Z-score异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stats AS (
    SELECT
        AVG(value) AS mean,
        STDDEV(value) AS stddev
    FROM metrics
    WHERE value IS NOT NULL
      AND timestamp >= NOW() - INTERVAL '7 days'
)
SELECT
    timestamp,
    value,
    (value - s.mean) / NULLIF(s.stddev, 0) AS z_score,
    CASE
        WHEN ABS((value - s.mean) / NULLIF(s.stddev, 0)) > 3 THEN '异常'
        ELSE '正常'
    END AS status
FROM metrics
CROSS JOIN stats s
WHERE value IS NOT NULL
  AND timestamp >= NOW() - INTERVAL '1 day'
ORDER BY ABS((value - s.mean) / NULLIF(s.stddev, 0)) DESC;
```

---

## 3. IQR异常检测

### 3.1 四分位距检测

**IQR异常检测**使用四分位距识别异常。

```sql
-- IQR异常检测（带错误处理和性能测试）
DO $$
DECLARE
    q1_val NUMERIC;
    q3_val NUMERIC;
    iqr_val NUMERIC;
    lower_bound NUMERIC;
    upper_bound NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行IQR异常检测';
            RETURN;
        END IF;

        SELECT
            PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS q1,
            PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) AS q3
        INTO q1_val, q3_val
        FROM metrics
        WHERE value IS NOT NULL;

        iqr_val := q3_val - q1_val;
        lower_bound := q1_val - 1.5 * iqr_val;
        upper_bound := q3_val + 1.5 * iqr_val;

        RAISE NOTICE 'IQR异常检测阈值:';
        RAISE NOTICE '  Q1: %', q1_val;
        RAISE NOTICE '  Q3: %', q3_val;
        RAISE NOTICE '  IQR: %', iqr_val;
        RAISE NOTICE '  下界: %', lower_bound;
        RAISE NOTICE '  上界: %', upper_bound;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'IQR异常检测失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 检测异常值
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH quartiles AS (
    SELECT
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) AS q3
    FROM metrics
    WHERE value IS NOT NULL
),
bounds AS (
    SELECT
        q1,
        q3,
        q1 - 1.5 * (q3 - q1) AS lower_bound,
        q3 + 1.5 * (q3 - q1) AS upper_bound
    FROM quartiles
)
SELECT
    timestamp,
    value,
    CASE
        WHEN value < b.lower_bound OR value > b.upper_bound THEN '异常值'
        ELSE '正常值'
    END AS status
FROM metrics
CROSS JOIN bounds b
WHERE value IS NOT NULL
ORDER BY value DESC;
```

---

## 4. 孤立点检测

### 4.1 距离异常检测

**孤立点检测**使用距离计算识别孤立点。

```sql
-- 孤立点检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING '表 data_points 不存在，无法执行孤立点检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行孤立点检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '孤立点检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH point_distances AS (
    SELECT
        p1.id,
        AVG(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))) AS avg_distance
    FROM data_points p1
    CROSS JOIN data_points p2
    WHERE p1.id != p2.id
    GROUP BY p1.id
),
distance_stats AS (
    SELECT
        AVG(avg_distance) AS mean_distance,
        STDDEV(avg_distance) AS stddev_distance
    FROM point_distances
)
SELECT
    pd.id,
    pd.avg_distance,
    CASE
        WHEN pd.avg_distance > ds.mean_distance + 2 * ds.stddev_distance THEN '孤立点'
        ELSE '正常点'
    END AS status
FROM point_distances pd
CROSS JOIN distance_stats ds
ORDER BY pd.avg_distance DESC;
```

---

## 5. 实际应用案例

### 5.1 系统监控异常检测

**系统监控异常检测**检测系统指标的异常。

```sql
-- 系统监控异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法执行系统监控异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行系统监控异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '系统监控异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH recent_stats AS (
    SELECT
        metric_name,
        AVG(metric_value) AS mean_value,
        STDDEV(metric_value) AS stddev_value
    FROM system_metrics
    WHERE timestamp >= NOW() - INTERVAL '7 days'
      AND metric_value IS NOT NULL
    GROUP BY metric_name
)
SELECT
    sm.timestamp,
    sm.metric_name,
    sm.metric_value,
    rs.mean_value,
    rs.stddev_value,
    (sm.metric_value - rs.mean_value) / NULLIF(rs.stddev_value, 0) AS z_score,
    CASE
        WHEN ABS((sm.metric_value - rs.mean_value) / NULLIF(rs.stddev_value, 0)) > 3 THEN '异常'
        ELSE '正常'
    END AS status
FROM system_metrics sm
JOIN recent_stats rs ON sm.metric_name = rs.metric_name
WHERE sm.timestamp >= NOW() - INTERVAL '1 day'
  AND sm.metric_value IS NOT NULL
ORDER BY ABS((sm.metric_value - rs.mean_value) / NULLIF(rs.stddev_value, 0)) DESC;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
