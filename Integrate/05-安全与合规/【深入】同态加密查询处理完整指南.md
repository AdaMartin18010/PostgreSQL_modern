---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQLåŸ¹è®­\07-å®‰å…¨\ã€æ·±å…¥ã€‘åŒæ€åŠ å¯†æŸ¥è¯¢å¤„ç†å®Œæ•´æŒ‡å—.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# åŒæ€åŠ å¯†æŸ¥è¯¢å¤„ç†å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¶é—´**: 2025 å¹´ 12 æœˆ 4 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 18+ with Homomorphic Encryption
> **æ–‡æ¡£ç¼–å·**: 07-SEC-HE

---

## ğŸ“‘ ç›®å½•

- [åŒæ€åŠ å¯†æŸ¥è¯¢å¤„ç†å®Œæ•´æŒ‡å—](#åŒæ€åŠ å¯†æŸ¥è¯¢å¤„ç†å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯åŒæ€åŠ å¯†](#11-ä»€ä¹ˆæ˜¯åŒæ€åŠ å¯†)
    - [1.2 ä¸ºä»€ä¹ˆéœ€è¦å¯†æ–‡æŸ¥è¯¢](#12-ä¸ºä»€ä¹ˆéœ€è¦å¯†æ–‡æŸ¥è¯¢)
    - [1.3 æ ¸å¿ƒä»·å€¼](#13-æ ¸å¿ƒä»·å€¼)
    - [1.4 çŸ¥è¯†ä½“ç³»æ€ç»´å¯¼å›¾](#14-çŸ¥è¯†ä½“ç³»æ€ç»´å¯¼å›¾)
  - [äºŒã€åŸç†ä¸ç†è®º](#äºŒåŸç†ä¸ç†è®º)
    - [2.1 åŒæ€åŠ å¯†ç†è®ºåŸºç¡€](#21-åŒæ€åŠ å¯†ç†è®ºåŸºç¡€)
      - [**ä¸‰ç±»åŒæ€åŠ å¯†**](#ä¸‰ç±»åŒæ€åŠ å¯†)
    - [2.2 åŠ å¯†æ–¹æ¡ˆå¯¹æ¯”](#22-åŠ å¯†æ–¹æ¡ˆå¯¹æ¯”)
    - [2.3 å¯†æ–‡è®¡ç®—åŸç†](#23-å¯†æ–‡è®¡ç®—åŸç†)
      - [**PaillieråŠ æ³•åŒæ€æ•°å­¦åŸç†**](#paillieråŠ æ³•åŒæ€æ•°å­¦åŸç†)
    - [2.4 å‰æ²¿ç ”ç©¶ Enc2DB](#24-å‰æ²¿ç ”ç©¶-enc2db)
  - [ä¸‰ã€æ¶æ„è®¾è®¡](#ä¸‰æ¶æ„è®¾è®¡)
    - [3.1 æ•´ä½“æ¶æ„](#31-æ•´ä½“æ¶æ„)
    - [3.2 åŠ å¯†æ•°æ®å­˜å‚¨](#32-åŠ å¯†æ•°æ®å­˜å‚¨)
    - [3.3 å¯†æ–‡æŸ¥è¯¢å¤„ç†](#33-å¯†æ–‡æŸ¥è¯¢å¤„ç†)
    - [3.4 å¯†é’¥ç®¡ç†](#34-å¯†é’¥ç®¡ç†)
  - [å››ã€ç¨‹åºè®¾è®¡](#å››ç¨‹åºè®¾è®¡)
    - [4.1 ç¯å¢ƒå‡†å¤‡](#41-ç¯å¢ƒå‡†å¤‡)
    - [4.2 åŸºç¡€åŠ å¯†æ“ä½œ](#42-åŸºç¡€åŠ å¯†æ“ä½œ)
    - [4.3 å¯†æ–‡æŸ¥è¯¢å®ç°](#43-å¯†æ–‡æŸ¥è¯¢å®ç°)
    - [4.4 æ··åˆåŠ å¯†æ–¹æ¡ˆ](#44-æ··åˆåŠ å¯†æ–¹æ¡ˆ)
  - [äº”ã€è¿ç»´ç®¡ç†](#äº”è¿ç»´ç®¡ç†)
    - [5.1 æ€§èƒ½ä¼˜åŒ–](#51-æ€§èƒ½ä¼˜åŒ–)
    - [5.2 å¯†é’¥ç®¡ç†](#52-å¯†é’¥ç®¡ç†)
      - [**5.2.1 å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†**](#521-å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†)
      - [**5.2.2 KMSé›†æˆ**](#522-kmsé›†æˆ)
      - [**5.2.3 å¯†é’¥å¤‡ä»½ä¸æ¢å¤**](#523-å¯†é’¥å¤‡ä»½ä¸æ¢å¤)
      - [**5.2.4 å¯†é’¥è®¿é—®æ§åˆ¶**](#524-å¯†é’¥è®¿é—®æ§åˆ¶)
      - [**5.2.5 å¯†é’¥è½®æ¢ç­–ç•¥**](#525-å¯†é’¥è½®æ¢ç­–ç•¥)
    - [5.3 ç›‘æ§ä¸å®¡è®¡](#53-ç›‘æ§ä¸å®¡è®¡)
      - [**5.3.1 å®¡è®¡æ—¥å¿—ç³»ç»Ÿ**](#531-å®¡è®¡æ—¥å¿—ç³»ç»Ÿ)
      - [**5.3.2 æ•°æ®åº“å®¡è®¡è¡¨ç»“æ„**](#532-æ•°æ®åº“å®¡è®¡è¡¨ç»“æ„)
      - [**5.3.3 æ€§èƒ½ç›‘æ§**](#533-æ€§èƒ½ç›‘æ§)
      - [**5.3.4 å®‰å…¨äº‹ä»¶æ£€æµ‹**](#534-å®‰å…¨äº‹ä»¶æ£€æµ‹)
      - [**5.3.5 ç›‘æ§ä»ªè¡¨æ¿æŸ¥è¯¢**](#535-ç›‘æ§ä»ªè¡¨æ¿æŸ¥è¯¢)
    - [5.4 æœ€ä½³å®è·µ](#54-æœ€ä½³å®è·µ)
  - [å…­ã€æ¡ˆä¾‹å®æˆ˜](#å…­æ¡ˆä¾‹å®æˆ˜)
    - [6.1 é‡‘èæ•°æ®åŠ å¯†æŸ¥è¯¢](#61-é‡‘èæ•°æ®åŠ å¯†æŸ¥è¯¢)
    - [6.2 åŒ»ç–—æ•°æ®éšç§ä¿æŠ¤](#62-åŒ»ç–—æ•°æ®éšç§ä¿æŠ¤)
    - [6.3 äº‘ç«¯æ•°æ®å®‰å…¨](#63-äº‘ç«¯æ•°æ®å®‰å…¨)
  - [ä¸ƒã€æ€§èƒ½æµ‹è¯•](#ä¸ƒæ€§èƒ½æµ‹è¯•)
  - [å…«ã€æ€»ç»“ä¸å±•æœ›](#å…«æ€»ç»“ä¸å±•æœ›)
    - [æ ¸å¿ƒæ”¶è·](#æ ¸å¿ƒæ”¶è·)
    - [é€‚ç”¨åœºæ™¯](#é€‚ç”¨åœºæ™¯)
  - [ä¹ã€å‚è€ƒèµ„æ–™](#ä¹å‚è€ƒèµ„æ–™)

---

## ä¸€ã€æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯åŒæ€åŠ å¯†

**åŒæ€åŠ å¯†**ï¼ˆHomomorphic Encryption, HEï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„åŠ å¯†æŠ€æœ¯ï¼Œå…è®¸å¯¹å¯†æ–‡è¿›è¡Œè®¡ç®—ï¼Œè®¡ç®—ç»“æœè§£å¯†åç­‰åŒäºå¯¹æ˜æ–‡è¿›è¡Œç›¸åŒè®¡ç®—ã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š

```text
æ˜æ–‡è®¡ç®—ï¼š  f(x) = y
å¯†æ–‡è®¡ç®—ï¼š  f(E(x)) = E(y)
è§£å¯†éªŒè¯ï¼š  D(E(y)) = y = f(x)

å…¶ä¸­ï¼šE() = åŠ å¯†å‡½æ•°, D() = è§£å¯†å‡½æ•°, f() = è®¡ç®—å‡½æ•°
```

**ç®€å•ç¤ºä¾‹**ï¼š

```python
# RSAåŒæ€ä¹˜æ³•ï¼ˆéƒ¨åˆ†åŒæ€ï¼‰
# E(xâ‚) Ã— E(xâ‚‚) = E(xâ‚ Ã— xâ‚‚)

from Crypto.PublicKey import RSA

# ç”Ÿæˆå¯†é’¥
key = RSA.generate(2048)
public_key = key.publickey()

# åŠ å¯†ä¸¤ä¸ªæ•°
x1, x2 = 5, 7
c1 = pow(x1, public_key.e, public_key.n)  # E(5)
c2 = pow(x2, public_key.e, public_key.n)  # E(7)

# å¯†æ–‡ä¹˜æ³•
c_result = (c1 * c2) % public_key.n  # E(5) Ã— E(7) = E(35)

# è§£å¯†
result = pow(c_result, key.d, key.n)  # D(E(35)) = 35
print(f"{x1} Ã— {x2} = {result}")  # è¾“å‡º: 5 Ã— 7 = 35
```

### 1.2 ä¸ºä»€ä¹ˆéœ€è¦å¯†æ–‡æŸ¥è¯¢

**ä¼ ç»Ÿæ•°æ®åº“çš„å®‰å…¨é£é™©**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        ä¼ ç»Ÿæ•°æ®åº“çš„å®‰å…¨æŒ‘æˆ˜                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                            â”‚
â”‚  é£é™©1ï¼šæ•°æ®åº“ç®¡ç†å‘˜å¯ä»¥è®¿é—®æ‰€æœ‰æ•°æ®          â”‚
â”‚  é£é™©2ï¼šæ•°æ®åº“æœåŠ¡å™¨è¢«å…¥ä¾µ                   â”‚
â”‚  é£é™©3ï¼šäº‘ç¯å¢ƒä¸‹çš„æ•°æ®ä¸»æƒé—®é¢˜               â”‚
â”‚  é£é™©4ï¼šå¤‡ä»½æ•°æ®çš„æ³„éœ²é£é™©                   â”‚
â”‚  é£é™©5ï¼šç¬¬ä¸‰æ–¹æœåŠ¡å•†çš„ä¿¡ä»»é—®é¢˜               â”‚
â”‚                                            â”‚
â”‚  ä¼ ç»Ÿè§£å†³æ–¹æ¡ˆï¼š                             â”‚
â”‚  âŒ è®¿é—®æ§åˆ¶ - å†…éƒ¨äººå‘˜ä»å¯è®¿é—®              â”‚
â”‚  âŒ ä¼ è¾“åŠ å¯† - æ•°æ®åº“å†…ä»æ˜¯æ˜æ–‡              â”‚
â”‚  âŒ ç£ç›˜åŠ å¯† - è¿è¡Œæ—¶è§£å¯†åæ˜¯æ˜æ–‡            â”‚
â”‚                                            â”‚
â”‚  åŒæ€åŠ å¯†æ–¹æ¡ˆï¼š                             â”‚
â”‚  âœ… æ•°æ®å§‹ç»ˆåŠ å¯† - å³ä½¿DBAä¹Ÿæ— æ³•è¯»å–         â”‚
â”‚  âœ… å¯†æ–‡æŸ¥è¯¢ - æ— éœ€è§£å¯†å³å¯è®¡ç®—              â”‚
â”‚  âœ… é›¶ä¿¡ä»»æ¶æ„ - ä¸ä¿¡ä»»ä»»ä½•ä¸­é—´æ–¹            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åº”ç”¨åœºæ™¯**ï¼š

- ğŸ¥ **åŒ»ç–—**: ç—…å†æ•°æ®ã€åŸºå› æ•°æ®
- ğŸ’° **é‡‘è**: äº¤æ˜“æ•°æ®ã€å®¢æˆ·ä¿¡æ¯
- ğŸ›ï¸ **æ”¿åŠ¡**: å…¬æ°‘æ•°æ®ã€æ•æ„Ÿä¿¡æ¯
- â˜ï¸ **äº‘è®¡ç®—**: å¤šç§Ÿæˆ·æ•°æ®éš”ç¦»
- ğŸ” **åˆè§„**: GDPRã€HIPAAã€ç­‰ä¿2.0

### 1.3 æ ¸å¿ƒä»·å€¼

| ç»´åº¦ | ä¼ ç»ŸåŠ å¯† | åŒæ€åŠ å¯† |
|------|---------|---------|
| **æ•°æ®å­˜å‚¨** | åŠ å¯† | åŠ å¯† |
| **ä¼ è¾“** | åŠ å¯† | åŠ å¯† |
| **å¤„ç†** | âŒ éœ€è¦è§£å¯† | âœ… å¯†æ–‡è®¡ç®— |
| **DBAå¯è§æ€§** | âœ… å¯è§ | âŒ ä¸å¯è§ |
| **å®‰å…¨æ€§** | â­â­â­ | â­â­â­â­â­ |
| **æ€§èƒ½** | â­â­â­â­â­ | â­â­ |
| **å¤æ‚åº¦** | â­â­ | â­â­â­â­ |

**æƒè¡¡è€ƒè™‘**ï¼š

- âœ… **æé«˜å®‰å…¨æ€§**: æ•°æ®å§‹ç»ˆåŠ å¯†
- âŒ **æ€§èƒ½å¼€é”€**: è®¡ç®—æ…¢10-1000å€
- âŒ **åŠŸèƒ½é™åˆ¶**: ä¸æ˜¯æ‰€æœ‰æ“ä½œéƒ½æ”¯æŒ
- âœ… **é›¶ä¿¡ä»»**: é€‚åˆé«˜å®‰å…¨åœºæ™¯

### 1.4 çŸ¥è¯†ä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((åŒæ€åŠ å¯†æŸ¥è¯¢))
    åŸç†ä¸ç†è®º
      åŠ å¯†ç†è®º
        éƒ¨åˆ†åŒæ€
        å…¨åŒæ€
        å®ç”¨åŒæ€
      æ•°å­¦åŸºç¡€
        ç¾¤è®º
        æ ¼ç†è®º
        RLWEé—®é¢˜
      å¯†æ–‡è®¡ç®—
        åŠ æ³•
        ä¹˜æ³•
        æ¯”è¾ƒ
      å‰æ²¿ç ”ç©¶
        Enc2DBæ¡†æ¶
        CryptDB
        SEALåº“
    æ¶æ„è®¾è®¡
      æ•´ä½“æ¶æ„
        å®¢æˆ·ç«¯
        ä»£ç†å±‚
        æ•°æ®åº“å±‚
      åŠ å¯†å­˜å‚¨
        åˆ—çº§åŠ å¯†
        è¡Œçº§åŠ å¯†
        ç´¢å¼•åŠ å¯†
      æŸ¥è¯¢å¤„ç†
        æŸ¥è¯¢æ”¹å†™
        å¯†æ–‡è®¡ç®—
        ç»“æœè§£å¯†
      å¯†é’¥ç®¡ç†
        å¯†é’¥ç”Ÿæˆ
        å¯†é’¥åˆ†å‘
        å¯†é’¥è½®æ¢
    ç¨‹åºè®¾è®¡
      åŠ å¯†åº“
        Python Paillier
        Microsoft SEAL
        HElib
      åŸºç¡€æ“ä½œ
        åŠ å¯†
        è§£å¯†
        å¯†æ–‡è®¡ç®—
      æŸ¥è¯¢å®ç°
        ç­‰å€¼æŸ¥è¯¢
        èŒƒå›´æŸ¥è¯¢
        èšåˆæŸ¥è¯¢
      æ··åˆæ–¹æ¡ˆ
        ç¡®å®šæ€§åŠ å¯†
        éšæœºåŠ å¯†
        OPEé¡ºåºä¿æŒ
    è¿ç»´ç®¡ç†
      æ€§èƒ½ä¼˜åŒ–
        æ‰¹é‡æ“ä½œ
        ç¡¬ä»¶åŠ é€Ÿ
        æŸ¥è¯¢ä¼˜åŒ–
      å¯†é’¥ç®¡ç†
        KMSé›†æˆ
        å®šæœŸè½®æ¢
        å¤‡ä»½æ¢å¤
      ç›‘æ§å®¡è®¡
        åŠ å¯†æ“ä½œæ—¥å¿—
        æ€§èƒ½ç›‘æ§
        å®‰å…¨å®¡è®¡
    æ¡ˆä¾‹å®æˆ˜
      é‡‘èæ•°æ®
        è´¦æˆ·ä½™é¢
        äº¤æ˜“è®°å½•
        é£æ§åˆ†æ
      åŒ»ç–—æ•°æ®
        ç—…å†åŠ å¯†
        ç»Ÿè®¡åˆ†æ
        éšç§ä¿æŠ¤
      äº‘ç«¯å®‰å…¨
        å¤šç§Ÿæˆ·éš”ç¦»
        æ•°æ®ä¸»æƒ
        åˆè§„æ€§
```

---

## äºŒã€åŸç†ä¸ç†è®º

### 2.1 åŒæ€åŠ å¯†ç†è®ºåŸºç¡€

#### **ä¸‰ç±»åŒæ€åŠ å¯†**

**1. éƒ¨åˆ†åŒæ€åŠ å¯†ï¼ˆPHE - Partially Homomorphic Encryptionï¼‰**:

æ”¯æŒå•ä¸€è¿ç®—ï¼ˆåŠ æ³•æˆ–ä¹˜æ³•ï¼‰ã€‚

```python
# RSA - æ”¯æŒä¹˜æ³•åŒæ€
# E(mâ‚) Ã— E(mâ‚‚) = E(mâ‚ Ã— mâ‚‚)

# Paillier - æ”¯æŒåŠ æ³•åŒæ€
# E(mâ‚) + E(mâ‚‚) = E(mâ‚ + mâ‚‚)

from phe import paillier

# PaillieråŠ æ³•åŒæ€ç¤ºä¾‹
public_key, private_key = paillier.generate_paillier_keypair()

# åŠ å¯†
m1, m2 = 100, 50
c1 = public_key.encrypt(m1)  # E(100)
c2 = public_key.encrypt(m2)  # E(50)

# å¯†æ–‡åŠ æ³•
c_sum = c1 + c2  # E(100) + E(50) = E(150)

# è§£å¯†
result = private_key.decrypt(c_sum)  # D(E(150)) = 150
print(f"{m1} + {m2} = {result}")  # 100 + 50 = 150

# æ ‡é‡ä¹˜æ³•
c_mul = c1 * 3  # E(100) Ã— 3 = E(300)
result = private_key.decrypt(c_mul)
print(f"{m1} Ã— 3 = {result}")  # 100 Ã— 3 = 300
```

**åº”ç”¨**ï¼š

- âœ… åŠ æ³•ï¼šæ±‚å’Œã€è®¡æ•°
- âœ… æ ‡é‡ä¹˜æ³•ï¼šåŠ æƒæ±‚å’Œ
- âŒ ä¹˜æ³•ã€é™¤æ³•ã€æ¯”è¾ƒï¼šä¸æ”¯æŒ

**2. å…¨åŒæ€åŠ å¯†ï¼ˆFHE - Fully Homomorphic Encryptionï¼‰**:

æ”¯æŒä»»æ„è®¡ç®—ï¼ˆåŠ æ³•å’Œä¹˜æ³•çš„ä»»æ„ç»„åˆï¼‰ã€‚

```python
# ä½¿ç”¨Microsoft SEALåº“ï¼ˆC++/Pythonï¼‰
import seal

# é…ç½®å‚æ•°
parms = seal.EncryptionParameters(seal.scheme_type.bfv)
poly_modulus_degree = 4096
parms.set_poly_modulus_degree(poly_modulus_degree)
parms.set_coeff_modulus(seal.CoeffModulus.BFVDefault(poly_modulus_degree))
parms.set_plain_modulus(1024)

# ç”Ÿæˆå¯†é’¥
context = seal.SEALContext(parms)
keygen = seal.KeyGenerator(context)
public_key = keygen.create_public_key()
secret_key = keygen.secret_key()

# åŠ å¯†å™¨å’Œè§£å¯†å™¨
encryptor = seal.Encryptor(context, public_key)
decryptor = seal.Decryptor(context, secret_key)
evaluator = seal.Evaluator(context)

# åŠ å¯†
plaintext1 = seal.Plaintext("5")
plaintext2 = seal.Plaintext("7")
encrypted1 = seal.Ciphertext()
encrypted2 = seal.Ciphertext()
encryptor.encrypt(plaintext1, encrypted1)
encryptor.encrypt(plaintext2, encrypted2)

# å¯†æ–‡åŠ æ³•
encrypted_sum = seal.Ciphertext()
evaluator.add(encrypted1, encrypted2, encrypted_sum)

# å¯†æ–‡ä¹˜æ³•
encrypted_product = seal.Ciphertext()
evaluator.multiply(encrypted1, encrypted2, encrypted_product)
```

**åº”ç”¨**ï¼š

- âœ… ä»»æ„SQLæŸ¥è¯¢ï¼ˆç†è®ºä¸Šï¼‰
- âŒ æ€§èƒ½å¼€é”€æå¤§ï¼ˆ100-1000å€ï¼‰
- âš ï¸ å®é™…åº”ç”¨å—é™

**3. å®ç”¨åŒæ€åŠ å¯†ï¼ˆSomewhat/Leveled HEï¼‰**:

æ”¯æŒæœ‰é™æ¬¡æ•°çš„åŠ æ³•å’Œä¹˜æ³•ã€‚

```python
# é™åˆ¶ä¹˜æ³•æ·±åº¦ï¼ˆmultiplicative depthï¼‰
# ä¾‹å¦‚ï¼šå¯ä»¥è¿›è¡Œ10æ¬¡åŠ æ³• + 3æ¬¡ä¹˜æ³•
```

### 2.2 åŠ å¯†æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | æ”¯æŒè¿ç®— | æ€§èƒ½ | å®‰å…¨æ€§ | é€‚ç”¨åœºæ™¯ |
|------|---------|------|--------|---------|
| **AES** | æ—  | â­â­â­â­â­ | â­â­â­â­ | ä¼ è¾“ã€å­˜å‚¨ |
| **ç¡®å®šæ€§åŠ å¯†** | ç­‰å€¼æ¯”è¾ƒ | â­â­â­â­â­ | â­â­ | ç´¢å¼•æŸ¥è¯¢ |
| **OPEé¡ºåºä¿æŒ** | èŒƒå›´æŸ¥è¯¢ | â­â­â­â­ | â­â­ | æ’åºã€èŒƒå›´ |
| **Paillier** | åŠ æ³• | â­â­â­ | â­â­â­â­ | æ±‚å’Œã€ç»Ÿè®¡ |
| **BFV/BGV** | åŠ æ³•+ä¹˜æ³• | â­â­ | â­â­â­â­â­ | å¤æ‚è®¡ç®— |
| **CKKS** | è¿‘ä¼¼æµ®ç‚¹ | â­â­ | â­â­â­â­â­ | æœºå™¨å­¦ä¹  |

### 2.3 å¯†æ–‡è®¡ç®—åŸç†

#### **PaillieråŠ æ³•åŒæ€æ•°å­¦åŸç†**

```text
æ•°å­¦åŸºç¡€ï¼š
---------
1. é€‰æ‹©ä¸¤ä¸ªå¤§ç´ æ•° p, q
2. è®¡ç®— n = p Ã— q, Î» = lcm(p-1, q-1)
3. é€‰æ‹©ç”Ÿæˆå…ƒ g âˆˆ Z*_{nÂ²}
4. è®¡ç®— Î¼ = (L(g^Î» mod nÂ²))^{-1} mod n
   å…¶ä¸­ L(x) = (x-1)/n

å…¬é’¥: (n, g)
ç§é’¥: (Î», Î¼)

åŠ å¯†: E(m, r) = g^m Ã— r^n mod nÂ²
     å…¶ä¸­ r æ˜¯éšæœºæ•°

è§£å¯†: D(c) = L(c^Î» mod nÂ²) Ã— Î¼ mod n

åŒæ€æ€§è´¨:
--------
åŠ æ³•: E(mâ‚) Ã— E(mâ‚‚) = E(mâ‚ + mâ‚‚)
æ ‡é‡ä¹˜æ³•: E(m)^k = E(k Ã— m)
```

**SQLåº”ç”¨ç¤ºä¾‹**ï¼š

```sql
-- åœºæ™¯ï¼šé“¶è¡Œè´¦æˆ·ä½™é¢æŸ¥è¯¢
-- éœ€æ±‚ï¼šæŸ¥è¯¢å¤šä¸ªè´¦æˆ·çš„æ€»ä½™é¢ï¼Œä½†ä½™é¢å­—æ®µåŠ å¯†

-- ä¼ ç»Ÿæ–¹å¼ï¼ˆä¸å®‰å…¨ï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'accounts') THEN
            RAISE WARNING 'è¡¨ accounts ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œä¼ ç»Ÿæ–¹å¼æŸ¥è¯¢ï¼ˆä¸å®‰å…¨ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT SUM(balance) FROM accounts WHERE user_id IN (1, 2, 3);

-- åŒæ€åŠ å¯†æ–¹å¼ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
-- 1. å®¢æˆ·ç«¯åŠ å¯†ä½™é¢åæ’å…¥ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'accounts_encrypted') THEN
            RAISE WARNING 'è¡¨ accounts_encrypted ä¸å­˜åœ¨ï¼Œæ— æ³•æ’å…¥æ•°æ®';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ’å…¥åŠ å¯†æ•°æ®ï¼ˆE()è¡¨ç¤ºPaillieråŠ å¯†ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ’å…¥å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

BEGIN
    INSERT INTO accounts_encrypted (user_id, balance_encrypted)
    VALUES
        (1, E(1000)),  -- E()è¡¨ç¤ºPaillieråŠ å¯†
        (2, E(2000)),
        (3, E(1500));
EXCEPTION
    WHEN unique_violation THEN
        RAISE WARNING 'æ•°æ®å·²å­˜åœ¨ï¼Œæ— æ³•æ’å…¥';
        RAISE;
    WHEN foreign_key_violation THEN
        RAISE WARNING 'å¤–é”®çº¦æŸå¤±è´¥';
        RAISE;
    WHEN OTHERS THEN
        RAISE WARNING 'æ’å…¥åŠ å¯†æ•°æ®å¤±è´¥: %', SQLERRM;
        RAISE;
END;

-- 2. æ•°æ®åº“æ‰§è¡Œå¯†æ–‡è®¡ç®—
-- E(1000) Ã— E(2000) Ã— E(1500) = E(4500)
SELECT
    paillier_multiply(balance_encrypted) AS total_encrypted
FROM accounts_encrypted
WHERE user_id IN (1, 2, 3);

-- 3. å®¢æˆ·ç«¯è§£å¯†
-- D(E(4500)) = 4500
```

### 2.4 å‰æ²¿ç ”ç©¶ Enc2DB

**è®ºæ–‡**: *Enc2DB: A Hybrid and Adaptive Encrypted Query Processing Framework* (arXiv:2404.06819)

**æ ¸å¿ƒæ€æƒ³**ï¼š

- ğŸ¯ **æ··åˆåŠ å¯†**: ç»“åˆå¤šç§åŠ å¯†æ–¹æ¡ˆ
- ğŸ¯ **è‡ªé€‚åº”é€‰æ‹©**: æ ¹æ®æŸ¥è¯¢è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜åŠ å¯†æ–¹æ¡ˆ
- ğŸ¯ **æŸ¥è¯¢æ”¹å†™**: è‡ªåŠ¨å°†SQLè½¬æ¢ä¸ºå¯†æ–‡æ“ä½œ

**æ¶æ„**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Enc2DB æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚      åº”ç”¨å±‚ (Application)           â”‚         â”‚
â”‚  â”‚  - æ˜æ–‡SQLæŸ¥è¯¢                      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚               â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚      Enc2DBä»£ç†å±‚                   â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚         â”‚
â”‚  â”‚  â”‚æŸ¥è¯¢åˆ†æ  â”‚  â”‚æ–¹æ¡ˆé€‰æ‹©  â”‚       â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚         â”‚
â”‚  â”‚  â”‚æŸ¥è¯¢æ”¹å†™  â”‚  â”‚ç»“æœè§£å¯†  â”‚       â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚               â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚      PostgreSQL                     â”‚         â”‚
â”‚  â”‚  - å¯†æ–‡æ•°æ®å­˜å‚¨                     â”‚         â”‚
â”‚  â”‚  - å¯†æ–‡æŸ¥è¯¢æ‰§è¡Œ                     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åŠ å¯†æ–¹æ¡ˆé€‰æ‹©å™¨**ï¼š

```python
class Enc2DBQueryPlanner:
    """Enc2DBæŸ¥è¯¢è§„åˆ’å™¨"""

    def __init__(self):
        self.schemes = {
            'deterministic': 'AES-DET',  # ç­‰å€¼æŸ¥è¯¢
            'ope': 'OPE',                # èŒƒå›´æŸ¥è¯¢
            'paillier': 'Paillier',      # æ±‚å’Œ
            'fhe': 'SEAL-BFV'            # å¤æ‚è®¡ç®—
        }

    def select_scheme(self, query_type, security_level, performance_req):
        """é€‰æ‹©åŠ å¯†æ–¹æ¡ˆ"""
        if query_type == 'equality' and performance_req == 'high':
            return self.schemes['deterministic']
        elif query_type == 'range':
            if security_level == 'high':
                return self.schemes['fhe']
            else:
                return self.schemes['ope']
        elif query_type == 'sum':
            return self.schemes['paillier']
        elif query_type == 'complex':
            return self.schemes['fhe']
        else:
            return self.schemes['deterministic']
```

---

## ä¸‰ã€æ¶æ„è®¾è®¡

### 3.1 æ•´ä½“æ¶æ„

```python
"""
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         åŒæ€åŠ å¯†æ•°æ®åº“æ•´ä½“æ¶æ„                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚       å®¢æˆ·ç«¯ (Trusted Client)           â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚         â”‚
â”‚  â”‚  â”‚æ•°æ®åŠ å¯† â”‚  â”‚ç»“æœè§£å¯† â”‚             â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚         â”‚
â”‚  â”‚  â”‚å¯†é’¥ç®¡ç† â”‚  â”‚æŸ¥è¯¢æ„å»º â”‚             â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚               â”‚ åŠ å¯†æŸ¥è¯¢                             â”‚
â”‚               â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚       ä»£ç†å±‚ (Proxy - å¯é€‰)             â”‚         â”‚
â”‚  â”‚  - æŸ¥è¯¢ä¼˜åŒ–                             â”‚         â”‚
â”‚  â”‚  - ç¼“å­˜ç®¡ç†                             â”‚         â”‚
â”‚  â”‚  - å®¡è®¡æ—¥å¿—                             â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚               â”‚ å¯†æ–‡æŸ¥è¯¢                             â”‚
â”‚               â–¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚       PostgreSQL (Untrusted)            â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚         â”‚
â”‚  â”‚  â”‚  åŠ å¯†æ•°æ®å­˜å‚¨              â”‚         â”‚         â”‚
â”‚  â”‚  â”‚  â”œâ”€ ç¡®å®šæ€§åŠ å¯†åˆ—           â”‚         â”‚         â”‚
â”‚  â”‚  â”‚  â”œâ”€ OPEåŠ å¯†åˆ—              â”‚         â”‚         â”‚
â”‚  â”‚  â”‚  â”œâ”€ PaillieråŠ å¯†åˆ—         â”‚         â”‚         â”‚
â”‚  â”‚  â”‚  â””â”€ FHEåŠ å¯†åˆ—              â”‚         â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚         â”‚
â”‚  â”‚  â”‚  å¯†æ–‡æ“ä½œUDF               â”‚         â”‚         â”‚
â”‚  â”‚  â”‚  â”œâ”€ paillier_add()         â”‚         â”‚         â”‚
â”‚  â”‚  â”‚  â”œâ”€ ope_compare()          â”‚         â”‚         â”‚
â”‚  â”‚  â”‚  â””â”€ fhe_compute()          â”‚         â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""
```

### 3.2 åŠ å¯†æ•°æ®å­˜å‚¨

```sql
-- æ··åˆåŠ å¯†è¡¨è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users_encrypted') THEN
            RAISE NOTICE 'è¡¨ users_encrypted å·²å­˜åœ¨';
        ELSE
            CREATE TABLE users_encrypted (
                user_id SERIAL PRIMARY KEY,

                -- ç¡®å®šæ€§åŠ å¯†ï¼ˆæ”¯æŒç­‰å€¼æŸ¥è¯¢ï¼‰
                email_det BYTEA,  -- AES-CTRç¡®å®šæ€§åŠ å¯†

                -- OPEåŠ å¯†ï¼ˆæ”¯æŒèŒƒå›´æŸ¥è¯¢ï¼‰
                age_ope BYTEA,  -- é¡ºåºä¿æŒåŠ å¯†
                salary_ope BYTEA,

                -- PaillieråŠ å¯†ï¼ˆæ”¯æŒæ±‚å’Œï¼‰
                balance_paillier BYTEA,

                -- å…ƒæ•°æ®ï¼ˆæ˜æ–‡ï¼Œç”¨äºè¿‡æ»¤ï¼‰
                department VARCHAR(50),  -- å¯ä»¥æ˜æ–‡å­˜å‚¨
                created_at TIMESTAMPTZ DEFAULT NOW(),

                -- åŠ å¯†æ–¹æ¡ˆæ ‡è¯†
                encryption_metadata JSONB
            );
            RAISE NOTICE 'è¡¨ users_encrypted åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ users_encrypted å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç´¢å¼•ç­–ç•¥ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users_encrypted') THEN
            RAISE WARNING 'è¡¨ users_encrypted ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'users_encrypted' AND indexname = 'idx_users_email_det') THEN
            CREATE INDEX idx_users_email_det ON users_encrypted (email_det);  -- ç­‰å€¼æŸ¥è¯¢
            RAISE NOTICE 'ç´¢å¼• idx_users_email_det åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_users_email_det å·²å­˜åœ¨';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'users_encrypted' AND indexname = 'idx_users_age_ope') THEN
            CREATE INDEX idx_users_age_ope ON users_encrypted (age_ope);      -- èŒƒå›´æŸ¥è¯¢
            RAISE NOTICE 'ç´¢å¼• idx_users_age_ope åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_users_age_ope å·²å­˜åœ¨';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'users_encrypted' AND indexname = 'idx_users_department') THEN
            CREATE INDEX idx_users_department ON users_encrypted (department); -- æ˜æ–‡è¿‡æ»¤
            RAISE NOTICE 'ç´¢å¼• idx_users_department åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_users_department å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ users_encrypted ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'éƒ¨åˆ†ç´¢å¼•å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 3.3 å¯†æ–‡æŸ¥è¯¢å¤„ç†

```python
# encrypted_query_processor.py
from phe import paillier
import hashlib
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

class EncryptedQueryProcessor:
    """åŠ å¯†æŸ¥è¯¢å¤„ç†å™¨"""

    def __init__(self, public_key, private_key=None):
        self.public_key = public_key  # Paillierå…¬é’¥
        self.private_key = private_key  # Paillierç§é’¥ï¼ˆä»…å®¢æˆ·ç«¯ï¼‰

        # AESå¯†é’¥ï¼ˆç¡®å®šæ€§åŠ å¯†ï¼‰
        self.aes_key = hashlib.sha256(b"secret_key").digest()

    def encrypt_deterministic(self, value: str) -> bytes:
        """ç¡®å®šæ€§åŠ å¯†ï¼ˆAES-ECBï¼Œä¸å®‰å…¨ä½†æ”¯æŒç­‰å€¼æŸ¥è¯¢ï¼‰"""
        cipher = AES.new(self.aes_key, AES.MODE_ECB)
        # å¡«å……åˆ°16å­—èŠ‚çš„å€æ•°
        padded = value + ' ' * (16 - len(value) % 16)
        return cipher.encrypt(padded.encode())

    def decrypt_deterministic(self, ciphertext: bytes) -> str:
        """è§£å¯†ç¡®å®šæ€§åŠ å¯†"""
        cipher = AES.new(self.aes_key, AES.MODE_ECB)
        plaintext = cipher.decrypt(ciphertext).decode().strip()
        return plaintext

    def encrypt_paillier(self, value: int):
        """PaillieråŠ å¯†"""
        return self.public_key.encrypt(value)

    def decrypt_paillier(self, ciphertext):
        """Paillierè§£å¯†"""
        if self.private_key is None:
            raise ValueError("Private key required for decryption")
        return self.private_key.decrypt(ciphertext)

    def process_equality_query(self, conn, email_plaintext):
        """å¤„ç†ç­‰å€¼æŸ¥è¯¢"""
        # 1. å®¢æˆ·ç«¯åŠ å¯†
        email_encrypted = self.encrypt_deterministic(email_plaintext)

        # 2. æ•°æ®åº“æŸ¥è¯¢ï¼ˆå¯†æ–‡æ¯”è¾ƒï¼‰
        with conn.cursor() as cur:
            cur.execute("""
                SELECT user_id, email_det, balance_paillier
                FROM users_encrypted
                WHERE email_det = %s
            """, (email_encrypted,))

            result = cur.fetchone()
            if result:
                user_id, email_enc, balance_enc = result

                # 3. å®¢æˆ·ç«¯è§£å¯†
                email = self.decrypt_deterministic(email_enc)
                balance = self.decrypt_paillier(
                    paillier.EncryptedNumber(self.public_key, int.from_bytes(balance_enc, 'big'))
                )

                return {
                    'user_id': user_id,
                    'email': email,
                    'balance': balance
                }

        return None

    def process_sum_query(self, conn, user_ids):
        """å¤„ç†æ±‚å’ŒæŸ¥è¯¢ï¼ˆPaillieråŒæ€åŠ æ³•ï¼‰"""
        # æ•°æ®åº“æ‰§è¡Œå¯†æ–‡æ±‚å’Œ
        with conn.cursor() as cur:
            # ä½¿ç”¨è‡ªå®šä¹‰èšåˆå‡½æ•°ï¼ˆéœ€è¦æ‰©å±•ï¼‰
            cur.execute("""
                SELECT array_agg(balance_paillier) AS encrypted_balances
                FROM users_encrypted
                WHERE user_id = ANY(%s)
            """, (user_ids,))

            encrypted_balances = cur.fetchone()[0]

        # å®¢æˆ·ç«¯æ‰§è¡ŒåŒæ€åŠ æ³•
        total = self.public_key.encrypt(0)
        for enc_balance_bytes in encrypted_balances:
            enc_balance = paillier.EncryptedNumber(
                self.public_key,
                int.from_bytes(enc_balance_bytes, 'big')
            )
            total = total + enc_balance

        # è§£å¯†ç»“æœ
        return self.decrypt_paillier(total)
```

### 3.4 å¯†é’¥ç®¡ç†

```python
# key_management.py
import os
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

class KeyManager:
    """å¯†é’¥ç®¡ç†å™¨"""

    def __init__(self, master_password: str):
        self.master_password = master_password
        self.keys = {}

    def generate_key(self, user_id: int, purpose: str) -> bytes:
        """ç”Ÿæˆæ´¾ç”Ÿå¯†é’¥"""
        salt = f"{user_id}:{purpose}".encode()

        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )

        key = kdf.derive(self.master_password.encode())
        self.keys[f"{user_id}:{purpose}"] = key
        return key

    def get_key(self, user_id: int, purpose: str) -> bytes:
        """è·å–å¯†é’¥"""
        key_id = f"{user_id}:{purpose}"
        if key_id not in self.keys:
            return self.generate_key(user_id, purpose)
        return self.keys[key_id]

    def rotate_keys(self, user_id: int):
        """å¯†é’¥è½®æ¢"""
        old_key = self.get_key(user_id, "data")

        # ç”Ÿæˆæ–°å¯†é’¥
        new_password = os.urandom(32).hex()
        new_key_manager = KeyManager(new_password)
        new_key = new_key_manager.generate_key(user_id, "data")

        return old_key, new_key
```

---

## å››ã€ç¨‹åºè®¾è®¡

### 4.1 ç¯å¢ƒå‡†å¤‡

```bash
# å®‰è£…PythonåŠ å¯†åº“
pip install phe==1.5.0                    # Paillier
pip install pycryptodome==3.19.0         # AES
pip install tenseal==0.3.14              # SEALçš„Pythonå°è£…
pip install openfhe-python==1.0.0        # OpenFHE

# åˆ›å»ºrequirements.txt
cat > requirements.txt <<EOF
phe==1.5.0
pycryptodome==3.19.0
tenseal==0.3.14
psycopg2-binary==2.9.9
numpy==1.24.0
EOF
```

```sql
-- PostgreSQLé…ç½®
CREATE DATABASE encrypted_db;
\c encrypted_db

-- åˆ›å»ºè‡ªå®šä¹‰ç±»å‹ï¼ˆå­˜å‚¨å¤§æ•´æ•°ï¼‰
CREATE DOMAIN encrypted_paillier AS TEXT;

-- å®‰è£…å¿…è¦æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- åŸºç¡€åŠ å¯†åŠŸèƒ½
```

### 4.2 åŸºç¡€åŠ å¯†æ“ä½œ

```python
# encryption_ops.py
from phe import paillier
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import hashlib
import base64

class BasicEncryption:
    """åŸºç¡€åŠ å¯†æ“ä½œ"""

    def __init__(self):
        # Paillierå¯†é’¥å¯¹
        self.public_key, self.private_key = paillier.generate_paillier_keypair()

        # AESå¯†é’¥
        self.aes_key = get_random_bytes(32)  # 256-bit

    def encrypt_det(self, plaintext: str) -> str:
        """ç¡®å®šæ€§åŠ å¯†ï¼ˆECBæ¨¡å¼ï¼Œç›¸åŒè¾“å…¥ç›¸åŒè¾“å‡ºï¼‰"""
        cipher = AES.new(self.aes_key, AES.MODE_ECB)
        padded = pad(plaintext.encode(), AES.block_size)
        ciphertext = cipher.encrypt(padded)
        return base64.b64encode(ciphertext).decode()

    def decrypt_det(self, ciphertext_b64: str) -> str:
        """è§£å¯†ç¡®å®šæ€§åŠ å¯†"""
        cipher = AES.new(self.aes_key, AES.MODE_ECB)
        ciphertext = base64.b64decode(ciphertext_b64)
        plaintext_padded = cipher.decrypt(ciphertext)
        plaintext = unpad(plaintext_padded, AES.block_size)
        return plaintext.decode()

    def encrypt_paillier(self, value: int) -> str:
        """PaillieråŠ å¯†"""
        encrypted = self.public_key.encrypt(value)
        return str(encrypted.ciphertext())

    def decrypt_paillier(self, ciphertext_str: str) -> int:
        """Paillierè§£å¯†"""
        ciphertext_int = int(ciphertext_str)
        encrypted = paillier.EncryptedNumber(self.public_key, ciphertext_int)
        return self.private_key.decrypt(encrypted)

    def homomorphic_add(self, c1_str: str, c2_str: str) -> str:
        """åŒæ€åŠ æ³•"""
        c1 = paillier.EncryptedNumber(self.public_key, int(c1_str))
        c2 = paillier.EncryptedNumber(self.public_key, int(c2_str))
        result = c1 + c2
        return str(result.ciphertext())

    def homomorphic_multiply_scalar(self, c_str: str, scalar: int) -> str:
        """åŒæ€æ ‡é‡ä¹˜æ³•"""
        c = paillier.EncryptedNumber(self.public_key, int(c_str))
        result = c * scalar
        return str(result.ciphertext())

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    enc = BasicEncryption()

    # 1. ç¡®å®šæ€§åŠ å¯†æµ‹è¯•
    email = "user@example.com"
    email_enc = enc.encrypt_det(email)
    email_dec = enc.decrypt_det(email_enc)
    print(f"ç¡®å®šæ€§åŠ å¯†: {email} â†’ {email_enc[:20]}... â†’ {email_dec}")

    # 2. PaillieråŠ æ³•åŒæ€æµ‹è¯•
    v1, v2 = 1000, 2000
    c1 = enc.encrypt_paillier(v1)
    c2 = enc.encrypt_paillier(v2)
    c_sum = enc.homomorphic_add(c1, c2)
    result = enc.decrypt_paillier(c_sum)
    print(f"åŒæ€åŠ æ³•: {v1} + {v2} = {result}")  # 1000 + 2000 = 3000
```

### 4.3 å¯†æ–‡æŸ¥è¯¢å®ç°

```python
# encrypted_database.py
import psycopg2
from typing import List, Dict, Any

class EncryptedDatabase:
    """åŠ å¯†æ•°æ®åº“æ“ä½œç±»"""

    def __init__(self, conn_string, encryption):
        self.conn = psycopg2.connect(conn_string)
        self.enc = encryption

    def insert_encrypted_user(
        self,
        email: str,
        age: int,
        salary: int,
        balance: int,
        department: str
    ):
        """æ’å…¥åŠ å¯†ç”¨æˆ·æ•°æ®"""
        # åŠ å¯†æ•æ„Ÿæ•°æ®
        email_enc = self.enc.encrypt_det(email)
        age_enc = self.encode_ope(age)  # OPEåŠ å¯†ï¼ˆç®€åŒ–ï¼‰
        salary_enc = self.encode_ope(salary)
        balance_enc = self.enc.encrypt_paillier(balance)

        with self.conn.cursor() as cur:
            cur.execute("""
                INSERT INTO users_encrypted
                (email_det, age_ope, salary_ope, balance_paillier, department)
                VALUES (%s, %s, %s, %s, %s)
            """, (email_enc, age_enc, salary_enc, balance_enc, department))

        self.conn.commit()
        print(f"âœ… Inserted encrypted user: {email}")

    def query_by_email(self, email: str):
        """ç­‰å€¼æŸ¥è¯¢ï¼ˆç¡®å®šæ€§åŠ å¯†ï¼‰"""
        email_enc = self.enc.encrypt_det(email)

        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT user_id, email_det, balance_paillier, department
                FROM users_encrypted
                WHERE email_det = %s
            """, (email_enc,))

            row = cur.fetchone()
            if row:
                user_id, email_enc, balance_enc, dept = row

                # è§£å¯†
                email_dec = self.enc.decrypt_det(email_enc)
                balance_dec = self.enc.decrypt_paillier(balance_enc)

                return {
                    'user_id': user_id,
                    'email': email_dec,
                    'balance': balance_dec,
                    'department': dept
                }

        return None

    def query_range(self, min_age: int, max_age: int):
        """èŒƒå›´æŸ¥è¯¢ï¼ˆOPEåŠ å¯†ï¼‰"""
        min_age_enc = self.encode_ope(min_age)
        max_age_enc = self.encode_ope(max_age)

        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT user_id, age_ope, department
                FROM users_encrypted
                WHERE age_ope BETWEEN %s AND %s
            """, (min_age_enc, max_age_enc))

            results = []
            for row in cur.fetchall():
                user_id, age_enc, dept = row
                age = self.decode_ope(age_enc)
                results.append({
                    'user_id': user_id,
                    'age': age,
                    'department': dept
                })

            return results

    def aggregate_balance(self, department: str):
        """èšåˆæŸ¥è¯¢ï¼ˆPaillieråŒæ€åŠ æ³•ï¼‰"""
        with self.conn.cursor() as cur:
            # æ£€ç´¢æ‰€æœ‰åŠ å¯†ä½™é¢
            cur.execute("""
                SELECT balance_paillier
                FROM users_encrypted
                WHERE department = %s
            """, (department,))

            encrypted_balances = [row[0] for row in cur.fetchall()]

        # å®¢æˆ·ç«¯åŒæ€æ±‚å’Œ
        total = self.enc.public_key.encrypt(0)
        for enc_balance_str in encrypted_balances:
            enc_balance = paillier.EncryptedNumber(
                self.enc.public_key,
                int(enc_balance_str)
            )
            total = total + enc_balance

        # è§£å¯†
        return self.enc.decrypt_paillier(total)

    def encode_ope(self, value: int) -> bytes:
        """OPEç¼–ç ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”ä½¿ç”¨ä¸“é—¨åº“ï¼‰"""
        # è¿™æ˜¯ç®€åŒ–ç‰ˆï¼Œå®é™…åº”ä½¿ç”¨pyopeç­‰åº“
        # è¿™é‡Œä»…ä½œæ¼”ç¤º
        return f"OPE_{value:010d}".encode()

    def decode_ope(self, encoded: bytes) -> int:
        """OPEè§£ç """
        return int(encoded.decode().replace("OPE_", ""))

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    from encryption_ops import BasicEncryption

    # åˆå§‹åŒ–
    enc = BasicEncryption()
    db = EncryptedDatabase("postgresql://localhost/encrypted_db", enc)

    # æ’å…¥åŠ å¯†æ•°æ®
    db.insert_encrypted_user(
        email="alice@example.com",
        age=30,
        salary=100000,
        balance=50000,
        department="Engineering"
    )

    # ç­‰å€¼æŸ¥è¯¢
    result = db.query_by_email("alice@example.com")
    print("æŸ¥è¯¢ç»“æœ:", result)

    # èŒƒå›´æŸ¥è¯¢
    results = db.query_range(25, 35)
    print(f"å¹´é¾„25-35çš„ç”¨æˆ·: {len(results)}äºº")

    # èšåˆæŸ¥è¯¢
    total = db.aggregate_balance("Engineering")
    print(f"Engineeringéƒ¨é—¨æ€»ä½™é¢: {total}")
```

### 4.4 æ··åˆåŠ å¯†æ–¹æ¡ˆ

```python
# hybrid_encryption.py

class HybridEncryptionScheme:
    """æ··åˆåŠ å¯†æ–¹æ¡ˆï¼ˆç»“åˆå¤šç§åŠ å¯†æŠ€æœ¯ï¼‰"""

    def __init__(self):
        self.basic_enc = BasicEncryption()

        # è®°å½•æ¯åˆ—çš„åŠ å¯†æ–¹æ¡ˆ
        self.column_schemes = {
            'email': 'deterministic',  # ç­‰å€¼æŸ¥è¯¢
            'name': 'randomized',      # é«˜å®‰å…¨æ€§
            'age': 'ope',              # èŒƒå›´æŸ¥è¯¢
            'salary': 'ope',
            'balance': 'paillier',     # æ±‚å’Œ
            'description': 'searchable' # å…¨æ–‡æœç´¢ï¼ˆå¯æœç´¢åŠ å¯†ï¼‰
        }

    def encrypt_column(self, column_name: str, value: Any) -> bytes:
        """æ ¹æ®åˆ—é€‰æ‹©åŠ å¯†æ–¹æ¡ˆ"""
        scheme = self.column_schemes.get(column_name, 'randomized')

        if scheme == 'deterministic':
            return self.basic_enc.encrypt_det(str(value))
        elif scheme == 'randomized':
            return self.encrypt_randomized(str(value))
        elif scheme == 'ope':
            return self.basic_enc.encode_ope(int(value))
        elif scheme == 'paillier':
            return self.basic_enc.encrypt_paillier(int(value))
        elif scheme == 'searchable':
            return self.encrypt_searchable(str(value))
        else:
            raise ValueError(f"Unknown scheme: {scheme}")

    def encrypt_randomized(self, plaintext: str) -> bytes:
        """éšæœºåŒ–åŠ å¯†ï¼ˆAES-CBCï¼Œç›¸åŒè¾“å…¥ä¸åŒè¾“å‡ºï¼‰"""
        from Crypto.Cipher import AES
        from Crypto.Random import get_random_bytes

        iv = get_random_bytes(16)
        cipher = AES.new(self.basic_enc.aes_key, AES.MODE_CBC, iv)
        padded = pad(plaintext.encode(), AES.block_size)
        ciphertext = cipher.encrypt(padded)

        # IV + å¯†æ–‡
        return iv + ciphertext

    def encrypt_searchable(self, plaintext: str) -> bytes:
        """å¯æœç´¢åŠ å¯†ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        # å®é™…åº”ä½¿ç”¨ä¸“é—¨çš„å¯æœç´¢åŠ å¯†æ–¹æ¡ˆï¼ˆå¦‚SSEï¼‰
        # è¿™é‡Œç®€åŒ–ä¸ºå…³é”®è¯çš„ç¡®å®šæ€§åŠ å¯†
        words = plaintext.lower().split()
        encrypted_words = [
            self.basic_enc.encrypt_det(word)
            for word in words
        ]
        return b'|'.join(encrypted_words)
```

---

## äº”ã€è¿ç»´ç®¡ç†

### 5.1 æ€§èƒ½ä¼˜åŒ–

```python
# performance_optimization.py

class EncryptedDBOptimizer:
    """åŠ å¯†æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–å™¨"""

    @staticmethod
    def analyze_query_performance(query_type: str):
        """åˆ†ææŸ¥è¯¢æ€§èƒ½"""
        performance_data = {
            'equality': {
                'plaintext': '1ms',
                'deterministic': '2ms',  # 2x
                'overhead': '100%'
            },
            'range': {
                'plaintext': '5ms',
                'ope': '15ms',  # 3x
                'overhead': '200%'
            },
            'sum': {
                'plaintext': '10ms',
                'paillier': '500ms',  # 50x
                'overhead': '4900%'
            },
            'join': {
                'plaintext': '50ms',
                'encrypted': '1500ms',  # 30x
                'overhead': '2900%'
            }
        }

        return performance_data.get(query_type, {})

    @staticmethod
    def optimization_strategies():
        """ä¼˜åŒ–ç­–ç•¥"""
        return {
            'æ‰¹é‡æ“ä½œ': {
                'description': 'æ‰¹é‡åŠ å¯†/è§£å¯†ä»¥æ‘Šé”€å¼€é”€',
                'improvement': '50-70%'
            },
            'ç¡¬ä»¶åŠ é€Ÿ': {
                'description': 'ä½¿ç”¨GPU/FPGAåŠ é€ŸåŠ å¯†è®¡ç®—',
                'improvement': '10-100x'
            },
            'æ··åˆæ–¹æ¡ˆ': {
                'description': 'æ•æ„Ÿæ•°æ®åŠ å¯†ï¼Œéæ•æ„Ÿæ•°æ®æ˜æ–‡',
                'improvement': 'æ˜¾è‘—'
            },
            'é¢„è®¡ç®—': {
                'description': 'é¢„å…ˆè®¡ç®—å¯†æ–‡ç´¢å¼•',
                'improvement': '30-50%'
            },
            'ç¼“å­˜': {
                'description': 'ç¼“å­˜å¸¸ç”¨å¯†æ–‡å’Œè§£å¯†ç»“æœ',
                'improvement': '20-40%'
            }
        }
```

### 5.2 å¯†é’¥ç®¡ç†

**å¯†é’¥ç®¡ç†æ˜¯åŒæ€åŠ å¯†ç³»ç»Ÿçš„æ ¸å¿ƒå®‰å…¨ç»„ä»¶**ï¼Œéœ€è¦ä¸¥æ ¼çš„å®‰å…¨æªæ–½å’Œè§„èŒƒæµç¨‹ã€‚

#### **5.2.1 å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†**

```python
# key_lifecycle.py
from datetime import datetime, timedelta
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
import json

class KeyLifecycleManager:
    """å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨"""

    def __init__(self, kms_endpoint=None):
        self.kms_endpoint = kms_endpoint
        self.key_registry = {}  # å¯†é’¥æ³¨å†Œè¡¨

    def generate_key_pair(self, key_id: str, key_size: int = 2048):
        """ç”Ÿæˆå¯†é’¥å¯¹"""
        from phe import paillier

        public_key, private_key = paillier.generate_paillier_keypair()

        # è®°å½•å¯†é’¥å…ƒæ•°æ®
        self.key_registry[key_id] = {
            'key_id': key_id,
            'created_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(days=90),  # 90å¤©æœ‰æ•ˆæœŸ
            'status': 'active',
            'key_size': key_size,
            'usage_count': 0,
            'last_used': None
        }

        return public_key, private_key

    def rotate_key(self, key_id: str):
        """å¯†é’¥è½®æ¢"""
        if key_id not in self.key_registry:
            raise ValueError(f"Key {key_id} not found")

        old_key_info = self.key_registry[key_id]

        # ç”Ÿæˆæ–°å¯†é’¥
        new_key_id = f"{key_id}_v{datetime.now().strftime('%Y%m%d')}"
        new_public_key, new_private_key = self.generate_key_pair(new_key_id)

        # æ ‡è®°æ—§å¯†é’¥ä¸ºå¾…é€€å½¹
        old_key_info['status'] = 'deprecating'
        old_key_info['deprecated_at'] = datetime.now()
        old_key_info['replaced_by'] = new_key_id

        return {
            'old_key_id': key_id,
            'new_key_id': new_key_id,
            'new_public_key': new_public_key,
            'new_private_key': new_private_key,
            'migration_required': True
        }

    def revoke_key(self, key_id: str, reason: str):
        """æ’¤é”€å¯†é’¥"""
        if key_id not in self.key_registry:
            raise ValueError(f"Key {key_id} not found")

        self.key_registry[key_id]['status'] = 'revoked'
        self.key_registry[key_id]['revoked_at'] = datetime.now()
        self.key_registry[key_id]['revocation_reason'] = reason

        return True

    def get_key_status(self, key_id: str):
        """è·å–å¯†é’¥çŠ¶æ€"""
        return self.key_registry.get(key_id, None)
```

#### **5.2.2 KMSé›†æˆ**

```python
# kms_integration.py
import boto3
from google.cloud import kms
import hvac  # HashiCorp Vault

class KMSIntegration:
    """å¯†é’¥ç®¡ç†æœåŠ¡é›†æˆ"""

    def __init__(self, provider: str, config: dict):
        self.provider = provider
        self.config = config

        if provider == 'aws':
            self.client = boto3.client('kms', **config)
        elif provider == 'gcp':
            self.client = kms.KeyManagementServiceClient()
        elif provider == 'vault':
            self.client = hvac.Client(**config)
        else:
            raise ValueError(f"Unsupported KMS provider: {provider}")

    def store_private_key(self, key_id: str, private_key_bytes: bytes):
        """å­˜å‚¨ç§é’¥åˆ°KMS"""
        if self.provider == 'aws':
            # AWS KMS
            response = self.client.import_key_material(
                KeyId=key_id,
                ImportToken=self.client.get_parameters_for_import(
                    KeyId=key_id,
                    WrappingAlgorithm='RSAES_OAEP_SHA_256'
                )['ImportToken'],
                EncryptedKeyMaterial=private_key_bytes,
                ExpirationModel='KEY_MATERIAL_EXPIRES',
                ValidTo=datetime.now() + timedelta(days=90)
            )
            return response['KeyId']

        elif self.provider == 'vault':
            # HashiCorp Vault
            self.client.secrets.kv.v2.create_or_update_secret(
                path=f'keys/{key_id}',
                secret={'private_key': private_key_bytes.hex()}
            )
            return key_id

    def retrieve_private_key(self, key_id: str) -> bytes:
        """ä»KMSæ£€ç´¢ç§é’¥"""
        if self.provider == 'aws':
            # æ³¨æ„ï¼šAWS KMSä¸ç›´æ¥å¯¼å‡ºå¯†é’¥ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
            raise NotImplementedError("AWS KMS requires different approach")

        elif self.provider == 'vault':
            response = self.client.secrets.kv.v2.read_secret_version(
                path=f'keys/{key_id}'
            )
            return bytes.fromhex(response['data']['data']['private_key'])
```

#### **5.2.3 å¯†é’¥å¤‡ä»½ä¸æ¢å¤**

```python
# key_backup.py
import os
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64

class KeyBackupManager:
    """å¯†é’¥å¤‡ä»½ç®¡ç†å™¨"""

    def __init__(self, backup_password: str):
        self.backup_password = backup_password

    def backup_key(self, key_id: str, private_key_bytes: bytes,
                   backup_location: str):
        """å¤‡ä»½å¯†é’¥ï¼ˆåŠ å¯†å­˜å‚¨ï¼‰"""
        # ä½¿ç”¨å¯†ç æ´¾ç”ŸåŠ å¯†å¯†é’¥
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'backup_salt',
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.backup_password.encode()))

        # åŠ å¯†å¯†é’¥
        fernet = Fernet(key)
        encrypted_key = fernet.encrypt(private_key_bytes)

        # ä¿å­˜å¤‡ä»½
        backup_data = {
            'key_id': key_id,
            'backup_time': datetime.now().isoformat(),
            'encrypted_key': encrypted_key.hex(),
            'checksum': hashlib.sha256(private_key_bytes).hexdigest()
        }

        with open(backup_location, 'w') as f:
            json.dump(backup_data, f)

        return backup_location

    def restore_key(self, backup_location: str) -> bytes:
        """æ¢å¤å¯†é’¥"""
        with open(backup_location, 'r') as f:
            backup_data = json.load(f)

        # è§£å¯†
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'backup_salt',
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.backup_password.encode()))
        fernet = Fernet(key)

        encrypted_key = bytes.fromhex(backup_data['encrypted_key'])
        private_key_bytes = fernet.decrypt(encrypted_key)

        # éªŒè¯æ ¡éªŒå’Œ
        if hashlib.sha256(private_key_bytes).hexdigest() != backup_data['checksum']:
            raise ValueError("Backup file corrupted or tampered")

        return private_key_bytes
```

#### **5.2.4 å¯†é’¥è®¿é—®æ§åˆ¶**

```sql
-- å¯†é’¥è®¿é—®æ§åˆ¶è¡¨
CREATE TABLE IF NOT EXISTS key_access_control (
    key_id VARCHAR(255) PRIMARY KEY,
    owner_user_id INTEGER NOT NULL,
    allowed_users INTEGER[] DEFAULT '{}',
    access_policy JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- å¯†é’¥è®¿é—®æ—¥å¿—
CREATE TABLE IF NOT EXISTS key_access_log (
    log_id SERIAL PRIMARY KEY,
    key_id VARCHAR(255) NOT NULL,
    user_id INTEGER NOT NULL,
    action VARCHAR(50) NOT NULL,  -- 'encrypt', 'decrypt', 'rotate', 'revoke'
    ip_address INET,
    user_agent TEXT,
    success BOOLEAN DEFAULT TRUE,
    error_message TEXT,
    accessed_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_key_access_log_key_id ON key_access_log(key_id);
CREATE INDEX idx_key_access_log_user_id ON key_access_log(user_id);
CREATE INDEX idx_key_access_log_accessed_at ON key_access_log(accessed_at);
```

#### **5.2.5 å¯†é’¥è½®æ¢ç­–ç•¥**

```python
# key_rotation_policy.py
from datetime import datetime, timedelta
from typing import List, Dict

class KeyRotationPolicy:
    """å¯†é’¥è½®æ¢ç­–ç•¥"""

    def __init__(self):
        self.policies = {
            'high_security': {
                'rotation_interval_days': 30,  # æ¯æœˆè½®æ¢
                'max_usage_count': 1000000,
                'auto_rotate': True
            },
            'medium_security': {
                'rotation_interval_days': 90,  # æ¯å­£åº¦è½®æ¢
                'max_usage_count': 10000000,
                'auto_rotate': True
            },
            'low_security': {
                'rotation_interval_days': 365,  # æ¯å¹´è½®æ¢
                'max_usage_count': 100000000,
                'auto_rotate': False
            }
        }

    def should_rotate(self, key_id: str, key_info: Dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦è½®æ¢"""
        policy = self.policies.get(key_info.get('security_level', 'medium_security'))

        # æ£€æŸ¥æ—¶é—´é—´éš”
        days_since_creation = (datetime.now() - key_info['created_at']).days
        if days_since_creation >= policy['rotation_interval_days']:
            return True

        # æ£€æŸ¥ä½¿ç”¨æ¬¡æ•°
        if key_info.get('usage_count', 0) >= policy['max_usage_count']:
            return True

        # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
        if key_info.get('expires_at') and datetime.now() >= key_info['expires_at']:
            return True

        return False

    def get_rotation_schedule(self) -> List[Dict]:
        """è·å–è½®æ¢è®¡åˆ’"""
        schedule = []
        for key_id, key_info in self.key_registry.items():
            if self.should_rotate(key_id, key_info):
                schedule.append({
                    'key_id': key_id,
                    'rotation_date': key_info.get('expires_at', datetime.now() + timedelta(days=7)),
                    'reason': 'Scheduled rotation'
                })
        return schedule
```

### 5.3 ç›‘æ§ä¸å®¡è®¡

**ç›‘æ§ä¸å®¡è®¡æ˜¯ç¡®ä¿åŒæ€åŠ å¯†ç³»ç»Ÿå®‰å…¨è¿è¡Œçš„å…³é”®ç¯èŠ‚**ï¼Œéœ€è¦å…¨é¢è®°å½•å’Œåˆ†ææ‰€æœ‰åŠ å¯†æ“ä½œã€‚

#### **5.3.1 å®¡è®¡æ—¥å¿—ç³»ç»Ÿ**

```python
# audit_logging.py
import logging
import json
from datetime import datetime
from typing import Dict, Any, Optional
import psycopg2

class AuditLogger:
    """å®¡è®¡æ—¥å¿—è®°å½•å™¨"""

    def __init__(self, db_conn=None, log_file=None):
        self.db_conn = db_conn
        self.log_file = log_file

        # é…ç½®æ—¥å¿—
        self.logger = logging.getLogger('homomorphic_encryption_audit')
        self.logger.setLevel(logging.INFO)

        if log_file:
            file_handler = logging.FileHandler(log_file)
            file_handler.setFormatter(
                logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            )
            self.logger.addHandler(file_handler)

    def log_encryption_operation(
        self,
        operation_type: str,  # 'encrypt', 'decrypt', 'homomorphic_add', etc.
        user_id: str,
        key_id: str,
        data_type: str,  # 'email', 'balance', etc.
        success: bool,
        metadata: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ):
        """è®°å½•åŠ å¯†æ“ä½œ"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'operation_type': operation_type,
            'user_id': user_id,
            'key_id': key_id,
            'data_type': data_type,
            'success': success,
            'ip_address': ip_address,
            'user_agent': user_agent,
            'metadata': metadata or {}
        }

        # å†™å…¥æ–‡ä»¶æ—¥å¿—
        if self.log_file:
            self.logger.info(json.dumps(log_entry))

        # å†™å…¥æ•°æ®åº“
        if self.db_conn:
            with self.db_conn.cursor() as cur:
                cur.execute("""
                    INSERT INTO encryption_audit_log
                    (operation_type, user_id, key_id, data_type, success,
                     ip_address, user_agent, metadata, created_at)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, NOW())
                """, (
                    operation_type, user_id, key_id, data_type, success,
                    ip_address, user_agent, json.dumps(metadata) if metadata else None
                ))
            self.db_conn.commit()

    def log_query_operation(
        self,
        query_type: str,  # 'equality', 'range', 'aggregate'
        user_id: str,
        table_name: str,
        columns_accessed: List[str],
        rows_affected: int,
        execution_time_ms: float,
        success: bool
    ):
        """è®°å½•æŸ¥è¯¢æ“ä½œ"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'query_type': query_type,
            'user_id': user_id,
            'table_name': table_name,
            'columns_accessed': columns_accessed,
            'rows_affected': rows_affected,
            'execution_time_ms': execution_time_ms,
            'success': success
        }

        if self.db_conn:
            with self.db_conn.cursor() as cur:
                cur.execute("""
                    INSERT INTO query_audit_log
                    (query_type, user_id, table_name, columns_accessed,
                     rows_affected, execution_time_ms, success, created_at)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, NOW())
                """, (
                    query_type, user_id, table_name, columns_accessed,
                    rows_affected, execution_time_ms, success
                ))
            self.db_conn.commit()
```

#### **5.3.2 æ•°æ®åº“å®¡è®¡è¡¨ç»“æ„**

```sql
-- åŠ å¯†æ“ä½œå®¡è®¡è¡¨
CREATE TABLE IF NOT EXISTS encryption_audit_log (
    log_id SERIAL PRIMARY KEY,
    operation_type VARCHAR(50) NOT NULL,  -- 'encrypt', 'decrypt', 'homomorphic_add', etc.
    user_id VARCHAR(255) NOT NULL,
    key_id VARCHAR(255) NOT NULL,
    data_type VARCHAR(100),  -- 'email', 'balance', 'age', etc.
    success BOOLEAN NOT NULL DEFAULT TRUE,
    ip_address INET,
    user_agent TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æŸ¥è¯¢æ“ä½œå®¡è®¡è¡¨
CREATE TABLE IF NOT EXISTS query_audit_log (
    log_id SERIAL PRIMARY KEY,
    query_type VARCHAR(50) NOT NULL,  -- 'equality', 'range', 'aggregate', 'join'
    user_id VARCHAR(255) NOT NULL,
    table_name VARCHAR(255) NOT NULL,
    columns_accessed TEXT[],
    rows_affected INTEGER DEFAULT 0,
    execution_time_ms NUMERIC(10, 2),
    success BOOLEAN NOT NULL DEFAULT TRUE,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å¯†é’¥è®¿é—®å®¡è®¡è¡¨ï¼ˆå·²åœ¨5.2.4ä¸­å®šä¹‰ï¼‰
-- key_access_log

-- åˆ›å»ºç´¢å¼•ä»¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
CREATE INDEX idx_encryption_audit_user_id ON encryption_audit_log(user_id);
CREATE INDEX idx_encryption_audit_key_id ON encryption_audit_log(key_id);
CREATE INDEX idx_encryption_audit_created_at ON encryption_audit_log(created_at);
CREATE INDEX idx_encryption_audit_operation_type ON encryption_audit_log(operation_type);

CREATE INDEX idx_query_audit_user_id ON query_audit_log(user_id);
CREATE INDEX idx_query_audit_table_name ON query_audit_log(table_name);
CREATE INDEX idx_query_audit_created_at ON query_audit_log(created_at);
CREATE INDEX idx_query_audit_query_type ON query_audit_log(query_type);

-- åˆ†åŒºè¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼Œæé«˜æŸ¥è¯¢æ€§èƒ½ï¼‰
-- æ³¨æ„ï¼šPostgreSQL 10+æ”¯æŒåŸç”Ÿåˆ†åŒº
CREATE TABLE encryption_audit_log_partitioned (
    LIKE encryption_audit_log INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- åˆ›å»ºåˆ†åŒºï¼ˆç¤ºä¾‹ï¼šæ¯æœˆä¸€ä¸ªåˆ†åŒºï¼‰
CREATE TABLE encryption_audit_log_2025_01 PARTITION OF encryption_audit_log_partitioned
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE encryption_audit_log_2025_02 PARTITION OF encryption_audit_log_partitioned
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

#### **5.3.3 æ€§èƒ½ç›‘æ§**

```python
# performance_monitoring.py
import time
from functools import wraps
from typing import Callable
import statistics

class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§å™¨"""

    def __init__(self, db_conn=None):
        self.db_conn = db_conn
        self.metrics = {
            'encryption_times': [],
            'decryption_times': [],
            'homomorphic_operation_times': [],
            'query_times': []
        }

    def monitor_operation(self, operation_name: str):
        """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
        def decorator(func: Callable):
            @wraps(func)
            def wrapper(*args, **kwargs):
                start_time = time.time()
                try:
                    result = func(*args, **kwargs)
                    success = True
                    error = None
                except Exception as e:
                    success = False
                    error = str(e)
                    raise
                finally:
                    elapsed_time = time.time() - start_time

                    # è®°å½•æŒ‡æ ‡
                    if operation_name.startswith('encrypt'):
                        self.metrics['encryption_times'].append(elapsed_time)
                    elif operation_name.startswith('decrypt'):
                        self.metrics['decryption_times'].append(elapsed_time)
                    elif 'homomorphic' in operation_name:
                        self.metrics['homomorphic_operation_times'].append(elapsed_time)
                    else:
                        self.metrics['query_times'].append(elapsed_time)

                    # è®°å½•åˆ°æ•°æ®åº“
                    if self.db_conn:
                        self._log_performance_metric(
                            operation_name, elapsed_time, success, error
                        )

                return result
            return wrapper
        return decorator

    def _log_performance_metric(
        self, operation_name: str, elapsed_time: float,
        success: bool, error: Optional[str]
    ):
        """è®°å½•æ€§èƒ½æŒ‡æ ‡åˆ°æ•°æ®åº“"""
        with self.db_conn.cursor() as cur:
            cur.execute("""
                INSERT INTO performance_metrics
                (operation_name, elapsed_time_ms, success, error_message, created_at)
                VALUES (%s, %s, %s, %s, NOW())
            """, (operation_name, elapsed_time * 1000, success, error))
        self.db_conn.commit()

    def get_statistics(self, metric_type: str) -> Dict[str, float]:
        """è·å–æ€§èƒ½ç»Ÿè®¡ä¿¡æ¯"""
        times = self.metrics.get(metric_type, [])
        if not times:
            return {}

        return {
            'count': len(times),
            'mean': statistics.mean(times),
            'median': statistics.median(times),
            'min': min(times),
            'max': max(times),
            'stdev': statistics.stdev(times) if len(times) > 1 else 0,
            'p95': self._percentile(times, 95),
            'p99': self._percentile(times, 99)
        }

    def _percentile(self, data: List[float], percentile: int) -> float:
        """è®¡ç®—ç™¾åˆ†ä½æ•°"""
        sorted_data = sorted(data)
        index = int(len(sorted_data) * percentile / 100)
        return sorted_data[min(index, len(sorted_data) - 1)]

    def generate_performance_report(self) -> Dict:
        """ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š"""
        return {
            'encryption': self.get_statistics('encryption_times'),
            'decryption': self.get_statistics('decryption_times'),
            'homomorphic_operations': self.get_statistics('homomorphic_operation_times'),
            'queries': self.get_statistics('query_times')
        }
```

#### **5.3.4 å®‰å…¨äº‹ä»¶æ£€æµ‹**

```python
# security_monitoring.py
from datetime import datetime, timedelta
from typing import List, Dict
import psycopg2

class SecurityEventDetector:
    """å®‰å…¨äº‹ä»¶æ£€æµ‹å™¨"""

    def __init__(self, db_conn):
        self.db_conn = db_conn

    def detect_anomalous_access(self, user_id: str, time_window_minutes: int = 60):
        """æ£€æµ‹å¼‚å¸¸è®¿é—®æ¨¡å¼"""
        with self.db_conn.cursor() as cur:
            # æŸ¥è¯¢æ—¶é—´çª—å£å†…çš„è®¿é—®æ¬¡æ•°
            cur.execute("""
                SELECT COUNT(*) as access_count,
                       COUNT(DISTINCT ip_address) as unique_ips,
                       COUNT(DISTINCT key_id) as unique_keys
                FROM encryption_audit_log
                WHERE user_id = %s
                  AND created_at >= NOW() - INTERVAL '%s minutes'
            """, (user_id, time_window_minutes))

            result = cur.fetchone()
            access_count, unique_ips, unique_keys = result

            # æ£€æµ‹å¼‚å¸¸
            anomalies = []

            # å¼‚å¸¸1ï¼šçŸ­æ—¶é—´å†…å¤§é‡è®¿é—®
            if access_count > 1000:
                anomalies.append({
                    'type': 'high_frequency_access',
                    'severity': 'high',
                    'message': f'User {user_id} has {access_count} accesses in {time_window_minutes} minutes'
                })

            # å¼‚å¸¸2ï¼šå¤šä¸ªIPåœ°å€
            if unique_ips > 5:
                anomalies.append({
                    'type': 'multiple_ip_addresses',
                    'severity': 'medium',
                    'message': f'User {user_id} accessed from {unique_ips} different IPs'
                })

            # å¼‚å¸¸3ï¼šè®¿é—®å¤šä¸ªå¯†é’¥
            if unique_keys > 10:
                anomalies.append({
                    'type': 'multiple_key_access',
                    'severity': 'medium',
                    'message': f'User {user_id} accessed {unique_keys} different keys'
                })

            return anomalies

    def detect_failed_operations(self, threshold: int = 10):
        """æ£€æµ‹å¤±è´¥çš„åŠ å¯†æ“ä½œ"""
        with self.db_conn.cursor() as cur:
            cur.execute("""
                SELECT user_id, COUNT(*) as failure_count
                FROM encryption_audit_log
                WHERE success = FALSE
                  AND created_at >= NOW() - INTERVAL '1 hour'
                GROUP BY user_id
                HAVING COUNT(*) >= %s
                ORDER BY failure_count DESC
            """, (threshold,))

            failures = []
            for row in cur.fetchall():
                user_id, failure_count = row
                failures.append({
                    'user_id': user_id,
                    'failure_count': failure_count,
                    'severity': 'high' if failure_count > 50 else 'medium'
                })

            return failures

    def detect_unusual_query_patterns(self):
        """æ£€æµ‹å¼‚å¸¸æŸ¥è¯¢æ¨¡å¼"""
        with self.db_conn.cursor() as cur:
            # æ£€æµ‹å…¨è¡¨æ‰«æ
            cur.execute("""
                SELECT user_id, table_name, COUNT(*) as scan_count
                FROM query_audit_log
                WHERE rows_affected > 10000
                  AND created_at >= NOW() - INTERVAL '1 hour'
                GROUP BY user_id, table_name
                HAVING COUNT(*) >= 5
            """)

            unusual_patterns = []
            for row in cur.fetchall():
                user_id, table_name, scan_count = row
                unusual_patterns.append({
                    'type': 'large_table_scan',
                    'user_id': user_id,
                    'table_name': table_name,
                    'scan_count': scan_count,
                    'severity': 'medium'
                })

            return unusual_patterns

    def generate_security_report(self) -> Dict:
        """ç”Ÿæˆå®‰å…¨æŠ¥å‘Š"""
        return {
            'timestamp': datetime.now().isoformat(),
            'anomalous_access': self.detect_anomalous_access('*'),  # æ‰€æœ‰ç”¨æˆ·
            'failed_operations': self.detect_failed_operations(),
            'unusual_queries': self.detect_unusual_query_patterns()
        }
```

#### **5.3.5 ç›‘æ§ä»ªè¡¨æ¿æŸ¥è¯¢**

```sql
-- ç›‘æ§ä»ªè¡¨æ¿å¸¸ç”¨æŸ¥è¯¢

-- 1. ä»Šæ—¥åŠ å¯†æ“ä½œç»Ÿè®¡
SELECT
    operation_type,
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE success = TRUE) as success_count,
    COUNT(*) FILTER (WHERE success = FALSE) as failure_count,
    AVG(EXTRACT(EPOCH FROM (NOW() - created_at))) as avg_age_seconds
FROM encryption_audit_log
WHERE created_at >= CURRENT_DATE
GROUP BY operation_type
ORDER BY total_count DESC;

-- 2. ç”¨æˆ·æ´»åŠ¨ç»Ÿè®¡ï¼ˆæœ€è¿‘24å°æ—¶ï¼‰
SELECT
    user_id,
    COUNT(*) as operation_count,
    COUNT(DISTINCT key_id) as keys_accessed,
    COUNT(DISTINCT ip_address) as unique_ips,
    MIN(created_at) as first_access,
    MAX(created_at) as last_access
FROM encryption_audit_log
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY user_id
ORDER BY operation_count DESC
LIMIT 20;

-- 3. æ€§èƒ½è¶‹åŠ¿ï¼ˆæ¯å°æ—¶å¹³å‡ï¼‰
SELECT
    DATE_TRUNC('hour', created_at) as hour,
    AVG(execution_time_ms) as avg_execution_time_ms,
    COUNT(*) as query_count,
    COUNT(*) FILTER (WHERE success = FALSE) as failure_count
FROM query_audit_log
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY hour
ORDER BY hour DESC;

-- 4. å¯†é’¥ä½¿ç”¨ç»Ÿè®¡
SELECT
    key_id,
    COUNT(*) as usage_count,
    COUNT(DISTINCT user_id) as unique_users,
    MIN(created_at) as first_used,
    MAX(created_at) as last_used
FROM encryption_audit_log
WHERE created_at >= NOW() - INTERVAL '7 days'
GROUP BY key_id
ORDER BY usage_count DESC;

-- 5. é”™è¯¯ç‡ç»Ÿè®¡ï¼ˆæŒ‰æ“ä½œç±»å‹ï¼‰
SELECT
    operation_type,
    COUNT(*) as total_operations,
    COUNT(*) FILTER (WHERE success = FALSE) as failed_operations,
    ROUND(100.0 * COUNT(*) FILTER (WHERE success = FALSE) / COUNT(*), 2) as error_rate_percent
FROM encryption_audit_log
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY operation_type
HAVING COUNT(*) FILTER (WHERE success = FALSE) > 0
ORDER BY error_rate_percent DESC;
```

### 5.4 æœ€ä½³å®è·µ

```python
# best_practices.py

class BestPractices:
    """åŒæ€åŠ å¯†æœ€ä½³å®è·µ"""

    @staticmethod
    def design_principles():
        """è®¾è®¡åŸåˆ™"""
        return {
            '1. æ•°æ®åˆ†çº§': {
                'principle': 'æ ¹æ®æ•æ„Ÿåº¦åˆ†çº§åŠ å¯†',
                'example': 'é«˜æ•æ„Ÿç”¨FHEï¼Œä¸­ç­‰ç”¨Paillierï¼Œä½æ•æ„Ÿç”¨ç¡®å®šæ€§'
            },
            '2. æœ€å°æƒé™': {
                'principle': 'å¯†é’¥åˆ†ç¦»ï¼Œå®¢æˆ·ç«¯æŒæœ‰ç§é’¥',
                'example': 'æ•°æ®åº“åªæœ‰å…¬é’¥ï¼Œæ— æ³•è§£å¯†'
            },
            '3. æ€§èƒ½å¹³è¡¡': {
                'principle': 'åœ¨å®‰å…¨å’Œæ€§èƒ½é—´å¹³è¡¡',
                'example': 'é¢‘ç¹æŸ¥è¯¢ç”¨OPEï¼Œèšåˆç”¨Paillier'
            },
            '4. å¯†é’¥è½®æ¢': {
                'principle': 'å®šæœŸè½®æ¢å¯†é’¥',
                'example': 'æ¯å­£åº¦è½®æ¢ä¸€æ¬¡'
            },
            '5. å®¡è®¡æ—¥å¿—': {
                'principle': 'è®°å½•æ‰€æœ‰åŠ å¯†æ“ä½œ',
                'example': 'è°ã€ä½•æ—¶ã€æ“ä½œäº†å“ªäº›åŠ å¯†æ•°æ®'
            }
        }

    @staticmethod
    def security_checklist():
        """å®‰å…¨æ£€æŸ¥æ¸…å•"""
        return [
            "âœ… ç§é’¥æ°¸ä¸ç¦»å¼€å®¢æˆ·ç«¯",
            "âœ… ä½¿ç”¨å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨",
            "âœ… å¯†é’¥ä½¿ç”¨KMSæˆ–HSMå­˜å‚¨",
            "âœ… å®šæœŸå¯†é’¥è½®æ¢ï¼ˆå»ºè®®æ¯å­£åº¦ï¼‰",
            "âœ… åŠ å¯†ä¼ è¾“é€šé“ï¼ˆTLS 1.3ï¼‰",
            "âœ… è®°å½•æ‰€æœ‰åŠ å¯†æ“ä½œ",
            "âœ… å®šæœŸå®‰å…¨å®¡è®¡",
            "âœ… å¤‡ä»½åŠ å¯†å’Œå¯†é’¥åˆ†ç¦»",
            "âœ… åº”æ€¥å“åº”é¢„æ¡ˆ",
            "âœ… åˆè§„æ€§æ£€æŸ¥ï¼ˆGDPR/HIPAAï¼‰"
        ]
```

---

## å…­ã€æ¡ˆä¾‹å®æˆ˜

### 6.1 é‡‘èæ•°æ®åŠ å¯†æŸ¥è¯¢

**åœºæ™¯**: é“¶è¡Œè´¦æˆ·ç³»ç»Ÿï¼Œè´¦æˆ·ä½™é¢åŠ å¯†å­˜å‚¨

```python
# financial_system.py

class BankingSystem:
    """é“¶è¡Œç³»ç»Ÿï¼ˆåŒæ€åŠ å¯†ï¼‰"""

    def __init__(self, conn, encryption):
        self.conn = conn
        self.enc = encryption

    def create_account(self, account_number: str, initial_balance: int):
        """åˆ›å»ºåŠ å¯†è´¦æˆ·"""
        # åŠ å¯†è´¦å·å’Œä½™é¢
        account_enc = self.enc.encrypt_det(account_number)
        balance_enc = self.enc.encrypt_paillier(initial_balance)

        with self.conn.cursor() as cur:
            cur.execute("""
                INSERT INTO accounts_encrypted (account_number_enc, balance_enc)
                VALUES (%s, %s)
            """, (account_enc, balance_enc))

        self.conn.commit()

    def transfer(self, from_account: str, to_account: str, amount: int):
        """è½¬è´¦ï¼ˆå¯†æ–‡æ“ä½œï¼‰"""
        from_acc_enc = self.enc.encrypt_det(from_account)
        to_acc_enc = self.enc.encrypt_det(to_account)

        with self.conn.cursor() as cur:
            # æŸ¥è¯¢å½“å‰ä½™é¢ï¼ˆå¯†æ–‡ï¼‰
            cur.execute("""
                SELECT balance_enc FROM accounts_encrypted
                WHERE account_number_enc = %s
            """, (from_acc_enc,))
            from_balance_enc = cur.fetchone()[0]

            # å¯†æ–‡å‡æ³•ï¼šbalance - amount
            amount_enc = self.enc.encrypt_paillier(amount)
            new_from_balance = self.enc.homomorphic_add(
                from_balance_enc,
                self.enc.encrypt_paillier(-amount)  # åŠ è´Ÿæ•°ç­‰äºå‡æ³•
            )

            # æ›´æ–°è½¬å‡ºè´¦æˆ·
            cur.execute("""
                UPDATE accounts_encrypted
                SET balance_enc = %s
                WHERE account_number_enc = %s
            """, (new_from_balance, from_acc_enc))

            # æ›´æ–°è½¬å…¥è´¦æˆ·ï¼ˆç±»ä¼¼æ“ä½œï¼‰
            cur.execute("""
                SELECT balance_enc FROM accounts_encrypted
                WHERE account_number_enc = %s
            """, (to_acc_enc,))
            to_balance_enc = cur.fetchone()[0]

            new_to_balance = self.enc.homomorphic_add(
                to_balance_enc,
                amount_enc
            )

            cur.execute("""
                UPDATE accounts_encrypted
                SET balance_enc = %s
                WHERE account_number_enc = %s
            """, (new_to_balance, to_acc_enc))

        self.conn.commit()
        print(f"âœ… Transferred {amount} from {from_account} to {to_account}")

    def get_total_balance(self, account_numbers: List[str]):
        """æŸ¥è¯¢å¤šè´¦æˆ·æ€»ä½™é¢ï¼ˆå¯†æ–‡æ±‚å’Œï¼‰"""
        encrypted_accounts = [
            self.enc.encrypt_det(acc) for acc in account_numbers
        ]

        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT balance_enc
                FROM accounts_encrypted
                WHERE account_number_enc = ANY(%s)
            """, (encrypted_accounts,))

            encrypted_balances = [row[0] for row in cur.fetchall()]

        # åŒæ€æ±‚å’Œ
        total = self.enc.public_key.encrypt(0)
        for enc_balance_str in encrypted_balances:
            enc_balance = paillier.EncryptedNumber(
                self.enc.public_key,
                int(enc_balance_str)
            )
            total = total + enc_balance

        # è§£å¯†
        return self.enc.decrypt_paillier(total)
```

### 6.2 åŒ»ç–—æ•°æ®éšç§ä¿æŠ¤

**åœºæ™¯**: åŒ»é™¢æ•°æ®åº“ï¼Œç—…å†ä¿¡æ¯åŠ å¯†

**è¯¦ç»†å®ç°è§å®Œæ•´æ–‡æ¡£...**

### 6.3 äº‘ç«¯æ•°æ®å®‰å…¨

**åœºæ™¯**: äº‘æ•°æ®åº“ï¼Œå¤šç§Ÿæˆ·æ•°æ®éš”ç¦»

**è¯¦ç»†å®ç°è§å®Œæ•´æ–‡æ¡£...**

---

## ä¸ƒã€æ€§èƒ½æµ‹è¯•

| æ“ä½œ | æ˜æ–‡ | ç¡®å®šæ€§åŠ å¯† | OPE | Paillier | FHE |
|------|------|-----------|-----|----------|-----|
| ç­‰å€¼æŸ¥è¯¢ | 1ms | 2ms (2x) | - | - | - |
| èŒƒå›´æŸ¥è¯¢ | 5ms | - | 15ms (3x) | - | 200ms (40x) |
| æ±‚å’Œ | 10ms | - | - | 500ms (50x) | 5s (500x) |
| å¤æ‚è®¡ç®— | 100ms | - | - | - | 100s (1000x) |

**ç»“è®º**ï¼š

- âœ… ç¡®å®šæ€§åŠ å¯†ï¼šæ€§èƒ½å¯æ¥å—ï¼ˆ2xï¼‰
- âš ï¸ OPEï¼šæ€§èƒ½å½±å“è¾ƒå°ï¼ˆ3xï¼‰
- âŒ Paillierï¼šæ€§èƒ½å½±å“å¤§ï¼ˆ50xï¼‰
- âŒ FHEï¼šæ€§èƒ½å½±å“å·¨å¤§ï¼ˆ1000xï¼‰

---

## å…«ã€æ€»ç»“ä¸å±•æœ›

### æ ¸å¿ƒæ”¶è·

1. âœ… åŒæ€åŠ å¯†æä¾›æé«˜å®‰å…¨æ€§
2. âœ… Paillieré€‚åˆæ±‚å’Œç­‰èšåˆæ“ä½œ
3. âš ï¸ æ€§èƒ½å¼€é”€æ˜¯ä¸»è¦æŒ‘æˆ˜
4. âœ… æ··åˆæ–¹æ¡ˆå¯å¹³è¡¡å®‰å…¨å’Œæ€§èƒ½

### é€‚ç”¨åœºæ™¯

**æ¨èä½¿ç”¨**ï¼š

- âœ… é‡‘èæ•æ„Ÿæ•°æ®ï¼ˆè´¦æˆ·ã€äº¤æ˜“ï¼‰
- âœ… åŒ»ç–—éšç§æ•°æ®ï¼ˆç—…å†ã€æ£€æŸ¥ï¼‰
- âœ… äº‘ç«¯å¤šç§Ÿæˆ·ï¼ˆæ•°æ®ä¸»æƒï¼‰
- âœ… åˆè§„è¦æ±‚æé«˜çš„åœºæ™¯

**ä¸æ¨èä½¿ç”¨**ï¼š

- âŒ é«˜æ€§èƒ½è¦æ±‚ï¼ˆ<10mså“åº”ï¼‰
- âŒ å¤æ‚æŸ¥è¯¢é¢‘ç¹
- âŒ å®‰å…¨è¦æ±‚ä¸é«˜
- âŒ å¼€å‘å’Œç»´æŠ¤èµ„æºä¸è¶³

---

## ä¹ã€å‚è€ƒèµ„æ–™

1. **Enc2DBè®ºæ–‡**: [https://arxiv.org/abs/2404.06819](https://arxiv.org/abs/2404.06819)
2. **Python-Paillier**: [https://github.com/data61/python-paillier](https://github.com/data61/python-paillier)
3. **Microsoft SEAL**: [https://github.com/microsoft/SEAL](https://github.com/microsoft/SEAL)
4. **OpenFHE**: [https://www.openfhe.org/](https://www.openfhe.org/)

---

**æœ€åæ›´æ–°**: 2025å¹´12æœˆ4æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 07-SEC-HE
**ç‰ˆæœ¬**: v1.0
