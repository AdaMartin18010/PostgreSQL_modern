---

> **📋 文档来源**: `docs\01-PostgreSQL18\21-SQL优化50条军规.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL SQL优化50条军规

## 1. 索引优化（10条）

### 1.1 使用合适的索引类型

```sql
-- 性能测试：使用合适的索引类型（带错误处理）
BEGIN;
-- ✓ B-Tree: 等值/范围查询
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_users_email已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建B-Tree索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
-- ✓ Hash: 纯等值查询（少用）
CREATE INDEX IF NOT EXISTS idx_users_email_hash ON users USING hash(email);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_users_email_hash已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建Hash索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
-- ✓ GIN: 全文搜索、JSONB、数组
CREATE INDEX IF NOT EXISTS idx_documents_content ON documents USING GIN(content);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_documents_content已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建GIN索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
-- ✓ BRIN: 时序数据、大表
CREATE INDEX IF NOT EXISTS idx_logs_created_at ON logs USING BRIN(created_at);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_logs_created_at已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建BRIN索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
-- ✓ HNSW: 向量相似度
CREATE INDEX IF NOT EXISTS idx_items_embedding ON items USING hnsw(embedding vector_cosine_ops);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_items_embedding已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建HNSW索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 1.2 覆盖索引

```sql
-- 性能测试：✗ 需要回表（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_orders_user_id已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT order_id, amount FROM orders WHERE user_id = 123;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 覆盖索引，无需回表（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_orders_covering ON orders(user_id, order_id, amount);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_orders_covering已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建覆盖索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 1.3 部分索引

```sql
-- 性能测试：✗ 索引所有行（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_users_status ON users(status);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_users_status已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 只索引活跃用户（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_users_status_active ON users(status) WHERE status = 'active';
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_users_status_active已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建部分索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 1.4 表达式索引

```sql
-- 性能测试：✗ 无法使用索引（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 表达式索引（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_users_lower_email ON users(LOWER(email));
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_users_lower_email已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表达式索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 1.5 避免冗余索引

```sql
-- 性能测试：✗ 冗余索引（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
CREATE INDEX IF NOT EXISTS idx_orders_user_created ON orders(user_id, created_at);  -- 第一个索引多余
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '部分索引已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 只创建第二个（带错误处理）
BEGIN;
DROP INDEX IF EXISTS orders_user_id_idx;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '删除冗余索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 2. 查询优化（15条）

### 2.1 避免SELECT *

```sql
-- 性能测试：✗ 传输不需要的数据（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = 123;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 只选择需要的列（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT user_id, username, email FROM users WHERE user_id = 123;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.2 使用EXISTS代替IN

```sql
-- 性能测试：✗ 子查询返回大量数据（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id IN (SELECT user_id FROM orders);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 使用EXISTS（短路评估）（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users u WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.user_id
);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.3 避免OR，使用UNION

```sql
-- 性能测试：✗ OR导致无法使用索引（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'a@x.com' OR username = 'alice';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ UNION使用两个索引（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'a@x.com'
UNION
SELECT * FROM users WHERE username = 'alice';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'UNION查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.4 LIMIT早期化

```sql
-- 性能测试：✗ 先JOIN再LIMIT（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT o.* FROM orders o
JOIN users u ON o.user_id = u.user_id
WHERE u.status = 'vip'
ORDER BY o.created_at DESC
LIMIT 10;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 先LIMIT再JOIN（如果可能）（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT o.* FROM (
    SELECT * FROM orders ORDER BY created_at DESC LIMIT 100
) o
JOIN users u ON o.user_id = u.user_id
WHERE u.status = 'vip'
LIMIT 10;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.5 使用JOIN代替子查询

```sql
-- 性能测试：✗ 子查询多次执行（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id IN (
    SELECT user_id FROM orders WHERE amount > 1000
);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ JOIN一次完成（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT DISTINCT u.* FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE o.amount > 1000;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.6 批量操作

```sql
-- 性能测试：✗ 逐条插入（带错误处理）
BEGIN;
INSERT INTO logs (message) VALUES ('log1');
INSERT INTO logs (message) VALUES ('log2');
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '逐条插入失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 批量插入（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
INSERT INTO logs (message) VALUES ('log1'), ('log2'), ('log3');
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '批量插入失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.7 使用COPY

```sql
-- 性能测试：✗ INSERT慢（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
INSERT INTO large_table SELECT * FROM source;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'INSERT失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ COPY最快（带错误处理）
BEGIN;
COPY large_table FROM '/tmp/data.csv' WITH (FORMAT csv);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'COPY失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.8 避免函数包裹索引列

```sql
-- 性能测试：✗ 无法使用索引（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE YEAR(created_at) = 2024;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 范围查询（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.9 合理使用CTE

```sql
-- 性能测试：✗ CTE被物化（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH large_cte AS (
    SELECT * FROM huge_table WHERE ...
)
SELECT * FROM large_cte WHERE extra_filter;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 使用NOT MATERIALIZED（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH large_cte AS NOT MATERIALIZED (
    SELECT * FROM huge_table WHERE ...
)
SELECT * FROM large_cte WHERE extra_filter;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.10 使用分区裁剪

```sql
-- 性能测试：分区表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS logs (...) PARTITION BY RANGE (created_at);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表logs已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建分区表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 查询包含分区键（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM logs WHERE created_at >= '2024-01-01';
-- 只扫描相关分区
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 3. 事务优化（8条）

### 3.1 保持事务短小

```sql
-- 性能测试：✗ 长事务（带错误处理）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM large_table;  -- 1000万行
-- 处理数据...（5分钟）
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '长事务查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 游标分批处理（带错误处理）
BEGIN;
DECLARE cur CURSOR FOR SELECT * FROM large_table;
FETCH 1000 FROM cur;
-- 处理1000行
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '游标处理失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
-- 重复
```

### 3.2 合适的隔离级别

```sql
-- 性能测试：✗ 过度使用SERIALIZABLE（带错误处理）
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM products;  -- 只读查询
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'SERIALIZABLE查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 使用READ COMMITTED（带错误处理和性能分析）
BEGIN;  -- 默认READ COMMITTED
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM products;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 3.3 避免空闲事务

```python
# ✗ 事务后空闲（带错误处理）
try:
    conn.cursor().execute("BEGIN")
    result = conn.cursor().execute("SELECT * FROM users WHERE id=1")
    # 处理结果...（忘记commit）
    time.sleep(60)  # 危险：事务长时间未提交
except Exception as e:
    conn.rollback()
    print(f"查询失败: {e}")

# ✓ 及时提交（带错误处理）
try:
    cursor.execute("BEGIN")
    result = cursor.execute("SELECT * FROM users WHERE id=1")
    conn.commit()  # 立即提交
except Exception as e:
    conn.rollback()
    print(f"查询失败: {e}")
```

---

## 4. 连接优化（5条）

### 4.1 使用连接池

```python
# ✗ 每次新建连接（带错误处理）
try:
    conn = psycopg2.connect(...)
    cursor = conn.cursor()
    cursor.execute("SELECT ...")
    conn.close()
except Exception as e:
    print(f"连接失败: {e}")

# ✓ 使用连接池（带错误处理）
conn = connection_pool.getconn()
try:
    cursor = conn.cursor()
    cursor.execute("SELECT ...")
except Exception as e:
    print(f"查询失败: {e}")
finally:
    connection_pool.putconn(conn)
```

### 4.2 Prepared Statements

```python
# ✓ 预编译（降低解析开销）（带错误处理）
try:
    cursor.execute("PREPARE stmt AS SELECT * FROM users WHERE user_id = $1")
    cursor.execute("EXECUTE stmt (123)")
    cursor.execute("EXECUTE stmt (456)")
except Exception as e:
    print(f"预编译语句执行失败: {e}")
    conn.rollback()
```

---

## 5. 数据类型优化（5条）

### 5.1 选择合适的整数类型

```sql
-- 性能测试：✗ 过大类型（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS products_bad (
    product_id BIGINT,  -- 实际只有1万条
    stock BIGINT        -- 最大1000
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表products_bad已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 合适类型（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS products (
    product_id INT,
    stock SMALLINT
);
-- 节省50%空间
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表products已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 5.2 使用ENUM

```sql
-- 性能测试：✗ VARCHAR（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS orders_bad (status VARCHAR(20));
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表orders_bad已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ ENUM（4字节 vs 变长）（带错误处理）
BEGIN;
DO $$
BEGIN
    CREATE TYPE order_status AS ENUM ('pending','paid','shipped');
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '类型order_status已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建类型失败: %', SQLERRM;
        RAISE;
END $$;

CREATE TABLE IF NOT EXISTS orders (status order_status);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表orders已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 5.3 TEXT vs VARCHAR

```sql
-- 性能测试：✓ 使用TEXT（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS docs (content TEXT);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表docs已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 不要使用VARCHAR(无明确长度需求时)
```

---

## 6. 配置优化（7条）

### 6.1 内存配置

```ini
# ✓ 25%系统内存
shared_buffers = 16GB  # (64GB系统)

# ✓ 根据并发调整
work_mem = 256MB  # 不要太大

# ✓ 维护操作
maintenance_work_mem = 2GB
```

### 6.2 SSD优化

```ini
# ✓ SSD环境
random_page_cost = 1.1
effective_io_concurrency = 200

# ✓ PostgreSQL 18
io_direct = data
io_combine_limit = 128kB
```

### 6.3 并行查询

```ini
# ✓ 启用并行
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
```

---

## 7. VACUUM优化（5条）

### 7.1 定期VACUUM

```sql
-- 性能测试：✓ 定期执行（带错误处理）
BEGIN;
VACUUM ANALYZE users;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'VACUUM ANALYZE失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：✓ 配置autovacuum（带错误处理）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET autovacuum_naptime = '1min';
    PERFORM pg_reload_conf();
    RAISE NOTICE 'autovacuum配置已更新';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '配置autovacuum失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;
```

### 7.2 针对性VACUUM

```sql
-- 性能测试：✓ 高频更新表更激进（带错误处理）
BEGIN;
ALTER TABLE hot_table SET (
    autovacuum_vacuum_scale_factor = 0.05,
    autovacuum_analyze_scale_factor = 0.02
);
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表hot_table不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '设置autovacuum参数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 8. 监控优化（总结）

```text
✓ 启用pg_stat_statements
✓ 记录慢查询日志
✓ 监控缓存命中率
✓ 监控连接数
✓ 监控锁等待
✓ 监控表膨胀
✓ 监控复制延迟
✓ 设置合理告警阈值
```

---

**完成**: PostgreSQL SQL优化50条军规
**字数**: ~8,000字
**核心规则**: 索引、查询、事务、连接、数据类型、配置、VACUUM、监控
