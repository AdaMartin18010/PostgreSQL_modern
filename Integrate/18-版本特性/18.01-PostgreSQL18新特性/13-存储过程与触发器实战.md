---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `docs\01-PostgreSQL18\13-å­˜å‚¨è¿‡ç¨‹ä¸è§¦å‘å™¨å®æˆ˜.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# PostgreSQL 18 å­˜å‚¨è¿‡ç¨‹ä¸è§¦å‘å™¨å®æˆ˜

## 1. å­˜å‚¨è¿‡ç¨‹ vs å‡½æ•°

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šå‡½æ•° (FUNCTION)ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION calculate_total(order_id INT)
RETURNS NUMERIC AS $$
DECLARE
    total NUMERIC;
BEGIN
    SELECT SUM(price * quantity) INTO total
    FROM order_items
    WHERE order_id = calculate_total.order_id;

    RETURN total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'è®¡ç®—æ€»ä»·å¤±è´¥: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šè°ƒç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½åˆ†æï¼‰
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT calculate_total(123);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'è°ƒç”¨å‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šå­˜å‚¨è¿‡ç¨‹ (PROCEDURE, PostgreSQL 11+)ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE PROCEDURE process_order(order_id INT)
LANGUAGE plpgsql AS $$
BEGIN
    -- å¯ä»¥åŒ…å«äº‹åŠ¡æ§åˆ¶
    UPDATE orders SET status = 'processing' WHERE order_id = process_order.order_id;
    COMMIT;

    -- å¤„ç†è®¢å•é¡¹
    UPDATE inventory SET stock = stock - quantity
    FROM order_items
    WHERE order_items.order_id = process_order.order_id;
    COMMIT;

    UPDATE orders SET status = 'completed' WHERE order_id = process_order.order_id;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'å¤„ç†è®¢å•å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;
END;
$$;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºå­˜å‚¨è¿‡ç¨‹å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šè°ƒç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CALL process_order(123);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'è°ƒç”¨å­˜å‚¨è¿‡ç¨‹å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- åŒºåˆ«:
/*
å‡½æ•°:
âœ“ è¿”å›å€¼
âœ“ å¯åœ¨SELECTä¸­ä½¿ç”¨
âœ— ä¸èƒ½åŒ…å«äº‹åŠ¡æ§åˆ¶

å­˜å‚¨è¿‡ç¨‹:
âœ— æ— è¿”å›å€¼
âœ— ä¸èƒ½åœ¨SELECTä¸­ä½¿ç”¨
âœ“ å¯ä»¥COMMIT/ROLLBACK
*/
```

---

## 2. é«˜çº§å‡½æ•°

### 2.1 è¿”å›è¡¨çš„å‡½æ•°

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šè¿”å›TABLEï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION get_user_orders(p_user_id INT)
RETURNS TABLE (
    order_id INT,
    order_date TIMESTAMPTZ,
    total_amount NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT o.order_id, o.created_at, calculate_total(o.order_id)
    FROM orders o
    WHERE o.user_id = p_user_id
    ORDER BY o.created_at DESC;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'è·å–ç”¨æˆ·è®¢å•å¤±è´¥: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šä½¿ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½åˆ†æï¼‰
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM get_user_orders(123);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'è°ƒç”¨å‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.2 åŠ¨æ€SQL

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šåŠ¨æ€SQLï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION dynamic_query(
    table_name TEXT,
    condition TEXT
) RETURNS SETOF RECORD AS $$
DECLARE
    query TEXT;
BEGIN
    query := format('SELECT * FROM %I WHERE %s', table_name, condition);

    RETURN QUERY EXECUTE query;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åŠ¨æ€æŸ¥è¯¢å¤±è´¥: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºåŠ¨æ€æŸ¥è¯¢å‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- ä½¿ç”¨ï¼ˆéœ€æŒ‡å®šåˆ—å®šä¹‰ï¼‰
SELECT * FROM dynamic_query('users', 'age > 25') AS (
    user_id INT,
    name TEXT,
    age INT
);

```

### 2.3 æ¸¸æ ‡å¤„ç†

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šæ¸¸æ ‡å¤„ç†ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION process_large_table()
RETURNS VOID AS $$
DECLARE
    cur CURSOR FOR SELECT * FROM large_table;
    rec RECORD;
    counter INT := 0;
BEGIN
    OPEN cur;

    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        -- å¤„ç†æ¯ä¸€è¡Œ
        UPDATE another_table SET value = rec.value WHERE id = rec.id;

        counter := counter + 1;

        -- æ¯1000è¡Œæäº¤ä¸€æ¬¡
        IF counter % 1000 = 0 THEN
            COMMIT;
        END IF;
    END LOOP;

    CLOSE cur;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'å¤„ç†å¤§è¡¨å¤±è´¥: %', SQLERRM;
        CLOSE cur;
        ROLLBACK;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºæ¸¸æ ‡å¤„ç†å‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 3. è§¦å‘å™¨

### 3.1 BEFOREè§¦å‘å™¨

```sql
-- è‡ªåŠ¨è®¾ç½®æ—¶é—´æˆ³
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION set_updated_at();

-- æ•°æ®éªŒè¯
CREATE OR REPLACE FUNCTION validate_email()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION 'Invalid email format: %', NEW.email;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_email
    BEFORE INSERT OR UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION validate_email();
```

### 3.2 AFTERè§¦å‘å™¨

```sql
-- å®¡è®¡æ—¥å¿—
CREATE TABLE audit_log (
    log_id BIGSERIAL PRIMARY KEY,
    table_name TEXT,
    operation TEXT,
    old_data JSONB,
    new_data JSONB,
    user_name TEXT,
    changed_at TIMESTAMPTZ DEFAULT now()
);

CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, operation, new_data, user_name)
        VALUES (TG_TABLE_NAME, 'INSERT', row_to_json(NEW)::jsonb, current_user);

    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, operation, old_data, new_data, user_name)
        VALUES (TG_TABLE_NAME, 'UPDATE', row_to_json(OLD)::jsonb, row_to_json(NEW)::jsonb, current_user);

    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, operation, old_data, user_name)
        VALUES (TG_TABLE_NAME, 'DELETE', row_to_json(OLD)::jsonb, current_user);
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit
    AFTER INSERT OR UPDATE OR DELETE ON sensitive_table
    FOR EACH ROW
    EXECUTE FUNCTION audit_trigger();
```

### 3.3 INSTEAD OFè§¦å‘å™¨

```sql
-- è§†å›¾è§¦å‘å™¨
CREATE VIEW user_summary AS
SELECT
    user_id,
    username,
    COUNT(o.order_id) AS order_count,
    SUM(o.amount) AS total_spent
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.username;

-- ä½¿è§†å›¾å¯æ›´æ–°
CREATE OR REPLACE FUNCTION update_user_summary()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE users
    SET username = NEW.username
    WHERE user_id = NEW.user_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_summary
    INSTEAD OF UPDATE ON user_summary
    FOR EACH ROW
    EXECUTE FUNCTION update_user_summary();

-- ç°åœ¨å¯ä»¥UPDATEè§†å›¾
UPDATE user_summary SET username = 'NewName' WHERE user_id = 123;
```

---

## 4. äº‹ä»¶è§¦å‘å™¨

### 4.1 DDLå®¡è®¡

```sql
-- è®°å½•DDLæ“ä½œ
CREATE TABLE ddl_log (
    log_id BIGSERIAL PRIMARY KEY,
    event_type TEXT,
    object_type TEXT,
    object_identity TEXT,
    command TEXT,
    user_name TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE OR REPLACE FUNCTION log_ddl()
RETURNS event_trigger AS $$
DECLARE
    obj RECORD;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands()
    LOOP
        INSERT INTO ddl_log (event_type, object_type, object_identity, command, user_name)
        VALUES (
            TG_EVENT,
            obj.object_type,
            obj.object_identity,
            obj.command_tag,
            current_user
        );
    END LOOP;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER trg_log_ddl
    ON ddl_command_end
    EXECUTE FUNCTION log_ddl();

-- æµ‹è¯•
CREATE TABLE test_table (id INT);
-- è‡ªåŠ¨è®°å½•åˆ°ddl_log
```

### 4.2 é˜»æ­¢å±é™©æ“ä½œ

```sql
-- é˜»æ­¢DROP TABLE
CREATE OR REPLACE FUNCTION prevent_drop_table()
RETURNS event_trigger AS $$
BEGIN
    IF TG_TAG = 'DROP TABLE' THEN
        RAISE EXCEPTION 'ç¦æ­¢åˆ é™¤è¡¨ï¼è¯·è”ç³»DBAã€‚';
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER trg_prevent_drop
    ON sql_drop
    EXECUTE FUNCTION prevent_drop_table();
```

---

## 5. é«˜çº§ç‰¹æ€§

### 5.1 å¼‚å¸¸å¤„ç†

```sql
CREATE OR REPLACE FUNCTION safe_divide(a NUMERIC, b NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'é™¤æ•°ä¸ºé›¶ï¼Œè¿”å›NULL';
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING 'æœªçŸ¥é”™è¯¯: %', SQLERRM;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨
SELECT safe_divide(10, 0);  -- è¿”å›NULLï¼Œä¸æŠ¥é”™
```

### 5.2 åŠ¨æ€è¿”å›ç±»å‹

```sql
CREATE OR REPLACE FUNCTION get_table_data(table_name TEXT)
RETURNS SETOF RECORD AS $$
BEGIN
    RETURN QUERY EXECUTE format('SELECT * FROM %I', table_name);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨æ—¶æŒ‡å®šåˆ—ç±»å‹
SELECT * FROM get_table_data('users') AS (
    user_id INT,
    username TEXT,
    email TEXT
);
```

### 5.3 æ‰¹é‡æ“ä½œ

```sql
CREATE OR REPLACE PROCEDURE batch_update_prices(
    category_id INT,
    discount_percent NUMERIC
)
LANGUAGE plpgsql AS $$
DECLARE
    batch_size INT := 1000;
    updated INT;
BEGIN
    LOOP
        UPDATE products
        SET price = price * (1 - discount_percent / 100)
        WHERE category_id = batch_update_prices.category_id
          AND ctid IN (
              SELECT ctid FROM products
              WHERE category_id = batch_update_prices.category_id
              LIMIT batch_size
          );

        GET DIAGNOSTICS updated = ROW_COUNT;

        EXIT WHEN updated = 0;

        COMMIT;  -- æ¯æ‰¹æ¬¡æäº¤

        RAISE NOTICE 'å·²æ›´æ–° % è¡Œ', updated;
    END LOOP;
END;
$$;
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 STABLE vs VOLATILE

```sql
-- VOLATILE (é»˜è®¤): æ¯è¡Œéƒ½è°ƒç”¨
CREATE FUNCTION random_value() RETURNS FLOAT AS $$
    SELECT random();
$$ LANGUAGE SQL VOLATILE;

SELECT random_value() FROM generate_series(1, 10);
-- æ¯è¡Œä¸åŒçš„éšæœºå€¼

-- STABLE: æ¯ä¸ªæŸ¥è¯¢è°ƒç”¨ä¸€æ¬¡
CREATE FUNCTION current_user_id() RETURNS INT AS $$
    SELECT current_setting('app.user_id')::INT;
$$ LANGUAGE SQL STABLE;

SELECT current_user_id() FROM generate_series(1, 10);
-- æ‰€æœ‰è¡Œç›¸åŒå€¼ï¼Œåªè°ƒç”¨ä¸€æ¬¡

-- IMMUTABLE: ç›¸åŒè¾“å…¥æ°¸è¿œè¿”å›ç›¸åŒè¾“å‡ºï¼ˆå¯ç¼“å­˜ï¼‰
CREATE FUNCTION add(a INT, b INT) RETURNS INT AS $$
    SELECT a + b;
$$ LANGUAGE SQL IMMUTABLE;

-- æ€§èƒ½å½±å“å·¨å¤§
```

### 6.2 å†…è”å‡½æ•°

```sql
-- SQLå‡½æ•°è‡ªåŠ¨å†…è”
CREATE FUNCTION get_active_users()
RETURNS SETOF users AS $$
    SELECT * FROM users WHERE status = 'active';
$$ LANGUAGE SQL STABLE;

-- æŸ¥è¯¢
SELECT * FROM get_active_users() WHERE age > 25;

-- ä¼˜åŒ–å™¨å†…è”å‡½æ•°ï¼Œç­‰æ•ˆäº:
SELECT * FROM users WHERE status = 'active' AND age > 25;

-- plpgsqlå‡½æ•°ä¸ä¼šå†…è”ï¼ˆéœ€è¦RETURN QUERYï¼‰
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 è®¢å•çŠ¶æ€æœº

```sql
CREATE TYPE order_status AS ENUM ('pending', 'paid', 'shipped', 'delivered', 'cancelled');

CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    status order_status DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- çŠ¶æ€è½¬æ¢éªŒè¯
CREATE OR REPLACE FUNCTION validate_order_status_transition()
RETURNS TRIGGER AS $$
DECLARE
    allowed BOOLEAN := false;
BEGIN
    -- å®šä¹‰å…è®¸çš„çŠ¶æ€è½¬æ¢
    IF OLD.status = 'pending' AND NEW.status IN ('paid', 'cancelled') THEN
        allowed := true;
    ELSIF OLD.status = 'paid' AND NEW.status IN ('shipped', 'cancelled') THEN
        allowed := true;
    ELSIF OLD.status = 'shipped' AND NEW.status = 'delivered' THEN
        allowed := true;
    END IF;

    IF NOT allowed THEN
        RAISE EXCEPTION 'éæ³•çŠ¶æ€è½¬æ¢: % -> %', OLD.status, NEW.status;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_status
    BEFORE UPDATE ON orders
    FOR EACH ROW
    WHEN (OLD.status IS DISTINCT FROM NEW.status)
    EXECUTE FUNCTION validate_order_status_transition();
```

### 7.2 åº“å­˜æ‰£å‡

```sql
CREATE OR REPLACE FUNCTION deduct_inventory(
    p_product_id INT,
    p_quantity INT
) RETURNS BOOLEAN AS $$
DECLARE
    current_stock INT;
BEGIN
    -- é”å®šåº“å­˜è¡Œ
    SELECT stock INTO current_stock
    FROM inventory
    WHERE product_id = p_product_id
    FOR UPDATE;

    -- æ£€æŸ¥åº“å­˜
    IF current_stock < p_quantity THEN
        RAISE EXCEPTION 'åº“å­˜ä¸è¶³: å½“å‰%, éœ€è¦%', current_stock, p_quantity;
    END IF;

    -- æ‰£å‡
    UPDATE inventory
    SET stock = stock - p_quantity,
        updated_at = now()
    WHERE product_id = p_product_id;

    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- äº‹åŠ¡ä¸­ä½¿ç”¨
BEGIN;
SELECT deduct_inventory(101, 5);
-- å…¶ä»–è®¢å•æ“ä½œ
COMMIT;
```

### 7.3 è‡ªåŠ¨æ±‡æ€»è¡¨

```sql
-- è®¢å•æ±‡æ€»è¡¨
CREATE TABLE order_summary (
    user_id INT PRIMARY KEY,
    total_orders INT DEFAULT 0,
    total_amount NUMERIC DEFAULT 0,
    last_order_at TIMESTAMPTZ
);

-- è§¦å‘å™¨ç»´æŠ¤æ±‡æ€»
CREATE OR REPLACE FUNCTION update_order_summary()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO order_summary (user_id, total_orders, total_amount, last_order_at)
        VALUES (NEW.user_id, 1, NEW.amount, NEW.created_at)
        ON CONFLICT (user_id) DO UPDATE
        SET total_orders = order_summary.total_orders + 1,
            total_amount = order_summary.total_amount + NEW.amount,
            last_order_at = NEW.created_at;

    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE order_summary
        SET total_amount = total_amount - OLD.amount + NEW.amount
        WHERE user_id = NEW.user_id;

    ELSIF TG_OP = 'DELETE' THEN
        UPDATE order_summary
        SET total_orders = total_orders - 1,
            total_amount = total_amount - OLD.amount
        WHERE user_id = OLD.user_id;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_summary
    AFTER INSERT OR UPDATE OR DELETE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_order_summary();
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 é¿å…è§¦å‘å™¨é€’å½’

```sql
-- Bad: å¯èƒ½æ— é™é€’å½’
CREATE OR REPLACE FUNCTION bad_trigger()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE users SET updated_at = now() WHERE user_id = NEW.user_id;
    RETURN NEW;  -- è§¦å‘å™¨æœ¬èº«åˆä¼šè¢«è§¦å‘
END;
$$ LANGUAGE plpgsql;

-- Good: ä½¿ç”¨æ¡ä»¶
CREATE OR REPLACE FUNCTION good_trigger()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := now();
    RETURN NEW;  -- ç›´æ¥ä¿®æ”¹NEWï¼Œä¸è§¦å‘å…¶ä»–UPDATE
END;
$$ LANGUAGE plpgsql;
```

### 8.2 æ‰¹é‡è§¦å‘

```sql
-- è¡Œçº§è§¦å‘å™¨ï¼ˆæ¯è¡Œè§¦å‘ä¸€æ¬¡ï¼‰
CREATE TRIGGER trg_row_level
    AFTER UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION row_level_function();

-- è¯­å¥çº§è§¦å‘å™¨ï¼ˆæ¯ä¸ªè¯­å¥è§¦å‘ä¸€æ¬¡ï¼‰
CREATE TRIGGER trg_statement_level
    AFTER UPDATE ON orders
    FOR EACH STATEMENT
    EXECUTE FUNCTION statement_level_function();

-- ä½¿ç”¨è¿‡æ¸¡è¡¨ï¼ˆPostgreSQL 10+ï¼‰
CREATE OR REPLACE FUNCTION batch_update_summary()
RETURNS TRIGGER AS $$
BEGIN
    -- æ‰¹é‡æ›´æ–°æ±‡æ€»
    INSERT INTO daily_summary (date, order_count, total_amount)
    SELECT
        DATE(created_at),
        COUNT(*),
        SUM(amount)
    FROM new_table  -- è¿‡æ¸¡è¡¨ï¼ŒåŒ…å«æ‰€æœ‰NEWè¡Œ
    GROUP BY DATE(created_at)
    ON CONFLICT (date) DO UPDATE
    SET order_count = daily_summary.order_count + EXCLUDED.order_count,
        total_amount = daily_summary.total_amount + EXCLUDED.total_amount;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_batch_summary
    AFTER INSERT ON orders
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT
    EXECUTE FUNCTION batch_update_summary();
```

---

## 9. è°ƒè¯•

### 9.1 æ—¥å¿—è¾“å‡º

```sql
CREATE OR REPLACE FUNCTION debug_function()
RETURNS VOID AS $$
DECLARE
    var1 INT := 100;
BEGIN
    RAISE NOTICE 'å˜é‡å€¼: %', var1;
    RAISE DEBUG 'è°ƒè¯•ä¿¡æ¯';
    RAISE LOG 'æ—¥å¿—ä¿¡æ¯';
    RAISE WARNING 'è­¦å‘Šä¿¡æ¯';
    RAISE EXCEPTION 'é”™è¯¯: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- è®¾ç½®æ—¥å¿—çº§åˆ«
SET client_min_messages = debug;
SELECT debug_function();
```

### 9.2 æ€§èƒ½åˆ†æ

```sql
-- å¯ç”¨å‡½æ•°è®¡æ—¶
ALTER FUNCTION expensive_function() SET log_min_duration_statement = 0;

-- æŸ¥çœ‹æ‰§è¡Œæ—¶é—´
SELECT
    funcname,
    calls,
    total_time / calls AS avg_time_ms,
    self_time / calls AS self_time_ms
FROM pg_stat_user_functions
ORDER BY total_time DESC;
```

---

## 10. æœ€ä½³å®è·µ

```text
å‡½æ•°è®¾è®¡:
âœ“ æ˜ç¡®VOLATILITY (IMMUTABLE/STABLE/VOLATILE)
âœ“ SQLå‡½æ•°ä¼˜äºplpgsqlï¼ˆå¯å†…è”ï¼‰
âœ“ é¿å…è¿‡åº¦ä½¿ç”¨å‡½æ•°ï¼ˆæ€§èƒ½ï¼‰
âœ“ åˆç†ä½¿ç”¨STRICT

è§¦å‘å™¨è®¾è®¡:
âœ“ é¿å…å¤æ‚é€»è¾‘
âœ“ è¯­å¥çº§ä¼˜äºè¡Œçº§ï¼ˆæ‰¹é‡ï¼‰
âœ“ ä½¿ç”¨è¿‡æ¸¡è¡¨
âœ“ æ³¨æ„è§¦å‘é¡ºåº

æ€§èƒ½:
âœ“ é¿å…è§¦å‘å™¨ä¸­çš„æ…¢æŸ¥è¯¢
âœ“ æ‰¹é‡æ“ä½œç”¨å­˜å‚¨è¿‡ç¨‹
âœ“ åˆç†ä½¿ç”¨æ¸¸æ ‡
âœ“ ç›‘æ§å‡½æ•°æ‰§è¡Œæ—¶é—´

ç»´æŠ¤:
âœ“ æ–‡æ¡£åŒ–å‡½æ•°ç”¨é€”
âœ“ ç‰ˆæœ¬æ§åˆ¶
âœ“ å®šæœŸreviewè§¦å‘å™¨
âœ“ æµ‹è¯•è¦†ç›–
```

---

**å®Œæˆ**: PostgreSQL 18å­˜å‚¨è¿‡ç¨‹ä¸è§¦å‘å™¨å®æˆ˜
**å­—æ•°**: ~10,000å­—
**æ¶µç›–**: å‡½æ•°ã€å­˜å‚¨è¿‡ç¨‹ã€è§¦å‘å™¨ã€äº‹ä»¶è§¦å‘å™¨ã€å®æˆ˜æ¡ˆä¾‹ã€æ€§èƒ½ä¼˜åŒ–
