---

> **📋 文档来源**: `docs\01-PostgreSQL18\11-查询优化器深度解析.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL 18 查询优化器深度解析

## 1. 优化器架构

### 1.1 查询处理流程

```text
┌────────────────────────────────────────────────────┐
│         PostgreSQL查询处理流程                      │
├────────────────────────────────────────────────────┤
│                                                    │
│  SQL查询                                           │
│    ↓                                               │
│  [Parser] 语法解析                                 │
│    ↓                                               │
│  [Analyzer] 语义分析                               │
│    ↓                                               │
│  [Rewriter] 规则重写                               │
│    ↓                                               │
│  [Planner/Optimizer] 查询优化 ← 核心               │
│    ├─ 路径生成                                     │
│    ├─ 成本估算                                     │
│    └─ 计划选择                                     │
│    ↓                                               │
│  [Executor] 执行                                   │
│    ↓                                               │
│  结果                                              │
└────────────────────────────────────────────────────┘
```

### 1.2 成本模型

```sql
-- 性能测试：查看成本参数（带错误处理）
BEGIN;
DO $$
DECLARE
    seq_cost TEXT;
    random_cost TEXT;
    tuple_cost TEXT;
BEGIN
    SHOW seq_page_cost INTO seq_cost;
    SHOW random_page_cost INTO random_cost;
    SHOW cpu_tuple_cost INTO tuple_cost;
    RAISE NOTICE 'seq_page_cost: %', seq_cost;
    RAISE NOTICE 'random_page_cost: %', random_cost;
    RAISE NOTICE 'cpu_tuple_cost: %', tuple_cost;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询成本参数失败: %', SQLERRM;
        RAISE;
END $$;
COMMIT;

-- 顺序页成本: 1.0
-- 随机页成本: 4.0 (HDD) / 1.1 (SSD)
-- 元组处理成本: 0.01
-- 索引元组成本: 0.005
-- 操作符成本: 0.0025

-- 性能测试：SSD优化（带错误处理）
BEGIN;
ALTER SYSTEM SET random_page_cost = 1.1;
ALTER SYSTEM SET effective_io_concurrency = 200;
SELECT pg_reload_conf();
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置SSD优化参数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 2. 统计信息

### 2.1 收集统计

```sql
-- 性能测试：全库统计（带错误处理）
-- 注意：ANALYZE不支持事务块，需直接执行
-- ANALYZE;

-- 性能测试：单表统计（带错误处理）
-- 注意：ANALYZE不支持事务块，需直接执行
-- ANALYZE users;

-- 性能测试：指定列统计（带错误处理）
-- 注意：ANALYZE不支持事务块，需直接执行
-- ANALYZE users (email, created_at);

-- 性能测试：详细统计（带错误处理）
-- 注意：ANALYZE不支持事务块，需直接执行
-- ANALYZE VERBOSE users;
```

### 2.2 统计信息视图

```sql
-- 性能测试：查看统计信息（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    tablename,
    attname,
    n_distinct,        -- 不同值数量
    correlation,       -- 物理顺序相关性
    most_common_vals,  -- 最常见值
    most_common_freqs  -- 最常见值频率
FROM pg_stats
WHERE tablename = 'users';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询统计信息失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 解读
-- n_distinct:
--   >0: 实际不同值数
--   -1: 唯一值
--   -0.5: 50%的值不同
--
-- correlation:
--   1.0: 完全有序
--   0.0: 随机
--   -1.0: 完全反序
--
--   高相关性 → 顺序扫描快
--   低相关性 → 索引扫描快
-- 性能指标：
-- - 查询执行时间
-- - 统计信息准确性
```

### 2.3 统计精度

```sql
-- 性能测试：提高统计精度（带错误处理）
BEGIN;
ALTER TABLE users ALTER COLUMN email
SET STATISTICS 1000;  -- 默认100
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN undefined_column THEN
        RAISE NOTICE '列email不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '设置统计精度失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：全局设置（带错误处理）
BEGIN;
ALTER SYSTEM SET default_statistics_target = 500;
SELECT pg_reload_conf();
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置全局统计目标失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 重新收集
-- 注意：ANALYZE不支持事务块，需直接执行
-- ANALYZE users;

-- 影响:
-- 更准确的基数估算
-- 更好的计划选择
-- ANALYZE时间增加
```

---

## 3. 连接算法

### 3.1 Nested Loop Join

```sql
-- 性能测试：适用场景: 小表 JOIN 大表（有索引，带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders o
JOIN users u ON o.user_id = u.user_id
WHERE u.user_id = 123;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Nested Loop
--   ->  Index Scan on users (cost=0..8 rows=1)
--         Index Cond: (user_id = 123)
--   ->  Index Scan on orders (cost=0..100 rows=50)
--         Index Cond: (user_id = 123)
--
-- 复杂度: O(n * m)
-- 适用: n很小 或 m有索引
-- 性能指标：
-- - 执行时间
-- - JOIN方法选择
-- - 索引使用情况
```

### 3.2 Hash Join

```sql
-- 性能测试：适用场景: 等值JOIN，中等大小表（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders o
JOIN products p ON o.product_id = p.product_id
WHERE o.created_at > '2023-01-01';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Hash Join
--   Hash Cond: (o.product_id = p.product_id)
--   ->  Seq Scan on orders (cost=0..1000 rows=5000)
--   ->  Hash (cost=500..500 rows=10000)
--         ->  Seq Scan on products
--
-- 复杂度: O(n + m)
-- 适用: 等值JOIN，两表都较大
-- 内存: work_mem (构建哈希表)
-- 性能指标：
-- - 执行时间
-- - Hash表大小
-- - 内存使用情况
```

### 3.3 Merge Join

```sql
-- 性能测试：适用场景: 有序数据，大表JOIN（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM logs l
JOIN events e ON l.timestamp = e.timestamp
WHERE l.timestamp > '2023-01-01';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Merge Join
--   Merge Cond: (l.timestamp = e.timestamp)
--   ->  Index Scan on logs (cost=0..1000 rows=10000)
--   ->  Index Scan on events (cost=0..2000 rows=20000)
--
-- 复杂度: O(n + m)
-- 适用: 两表都有序
-- 前提: 排序开销小或已有序
-- 性能指标：
-- - 执行时间
-- - JOIN方法选择
-- - 索引使用情况

-- 性能测试：强制Merge Join（带错误处理）
BEGIN;
SET enable_hashjoin = off;
SET enable_nestloop = off;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置JOIN选项失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 4. 扫描方式

### 4.1 顺序扫描

```sql
-- 性能测试：全表扫描（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Seq Scan on users (cost=0.00..10000.00 rows=100000)
--
-- 适用:
-- ✓ 小表
-- ✓ 返回大部分行 (>10%)
-- ✓ 无合适索引
-- 性能指标：
-- - 执行时间
-- - 扫描行数
-- - 缓冲区使用情况
```

### 4.2 索引扫描

```sql
-- 性能测试：Index Scan（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = 123;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Index Scan using users_pkey on users
--   Index Cond: (user_id = 123)
--
-- 适用:
-- ✓ 高选择性查询
-- ✓ 少量行返回
-- 性能指标：
-- - 执行时间
-- - 索引使用情况
-- - 缓冲区命中率

-- 性能测试：Index Only Scan（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT user_id, email FROM users
WHERE email = 'test@example.com';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Index Only Scan using idx_users_email
--   Index Cond: (email = 'test@example.com')
--   Heap Fetches: 0  ← 无需访问表
--
-- 前提: 覆盖索引 + VACUUM及时
-- 性能指标：
-- - 执行时间
-- - Index Only Scan效果
-- - Heap Fetches数量
```

### 4.3 位图扫描

```sql
-- 性能测试：Bitmap Index Scan（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users
WHERE status = 'active' OR created_at > '2023-01-01';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Bitmap Heap Scan on users
--   Recheck Cond: ((status = 'active') OR (created_at > '2023-01-01'))
--   ->  BitmapOr
--         ->  Bitmap Index Scan on idx_status
--         ->  Bitmap Index Scan on idx_created_at
--
-- 适用:
-- ✓ 多索引OR查询
-- ✓ 中等选择性 (1-10%)
-- ✓ 避免随机I/O
-- 性能指标：
-- - 执行时间
-- - Bitmap操作效果
-- - 缓冲区使用情况
```

---

## 5. 子查询优化

### 5.1 子查询展平

```sql
-- 性能测试：原始查询（子查询，带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users
WHERE user_id IN (
    SELECT user_id FROM orders WHERE amount > 1000
);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 优化器自动改写为JOIN
-- Hash Join
--   Hash Cond: (users.user_id = orders.user_id)
--   ->  Seq Scan on users
--   ->  Hash
--         ->  HashAggregate
--               ->  Seq Scan on orders
--                     Filter: (amount > 1000)
-- 性能指标：
-- - 子查询优化效果
-- - 执行时间
-- - JOIN方法选择

-- 性能测试：手动改写（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT DISTINCT u.*
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE o.amount > 1000;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 5.2 CTE优化

```sql
-- 性能测试：Materialized CTE (默认，带错误处理和性能分析)
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH recent_orders AS (
    SELECT user_id, COUNT(*) AS order_count
    FROM orders
    WHERE created_at > '2023-01-01'
    GROUP BY user_id
)
SELECT * FROM users u
JOIN recent_orders ro ON u.user_id = ro.user_id;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- CTE物化（执行一次）
-- 适用: CTE被多次引用
-- 性能指标：
-- - CTE物化效果
-- - 执行时间
-- - 内存使用情况

-- 性能测试：NOT MATERIALIZED (PostgreSQL 12+，带错误处理和性能分析)
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH recent_orders AS NOT MATERIALIZED (
    SELECT user_id, COUNT(*) AS order_count
    FROM orders
    WHERE created_at > '2023-01-01'
    GROUP BY user_id
)
SELECT * FROM users u
JOIN recent_orders ro ON u.user_id = ro.user_id;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- CTE内联（可能推入WHERE条件）
-- 性能指标：
-- - CTE内联效果
-- - 执行时间
-- - 优化器选择
```

---

## 6. 并行查询

### 6.1 并行配置

```sql
-- 性能测试：全局配置（带错误处理）
BEGIN;
SET max_parallel_workers_per_gather = 4;
SET max_parallel_workers = 8;
SET max_worker_processes = 16;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置并行配置失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：并行阈值（带错误处理）
BEGIN;
SET min_parallel_table_scan_size = 8MB;
SET min_parallel_index_scan_size = 512kB;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置并行阈值失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：成本参数（带错误处理）
BEGIN;
SET parallel_setup_cost = 1000;
SET parallel_tuple_cost = 0.1;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置并行成本参数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 6.2 并行执行计划

```sql
-- 性能测试：并行执行计划（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT COUNT(*) FROM large_table;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Finalize Aggregate
--   ->  Gather
--         Workers Planned: 4
--         Workers Launched: 4
--         ->  Partial Aggregate
--               ->  Parallel Seq Scan on large_table
--
-- 性能: 单线程25秒 → 4线程7秒 (-72%)
-- 性能指标：
-- - 并行worker数量
-- - 执行时间
-- - 加速比

-- 性能测试：强制并行（带错误处理）
BEGIN;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置并行成本参数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 7. PostgreSQL 18优化改进

### 7.1 增量排序优化

```sql
-- 性能测试：部分有序数据（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_users_status_created ON users(status, created_at);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_users_status_created已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users
WHERE status = 'active'
ORDER BY status, created_at, user_id
LIMIT 100;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- PostgreSQL 17:
-- Sort (cost=15000..15100)
--   Sort Key: status, created_at, user_id
--   Sort Method: quicksort Memory: 5000kB
--
-- PostgreSQL 18: Incremental Sort
-- Limit
--   ->  Incremental Sort
--         Sort Key: status, created_at, user_id
--         Presorted Key: status, created_at
--         Sort Method: quicksort Memory: 50kB  ← 内存-99%
--
-- 性能提升: 避免大量内存排序
-- 性能指标：
-- - 执行时间
-- - 内存使用情况
-- - Incremental Sort效果
```

### 7.2 Skip Scan

```sql
-- 性能测试：多列索引非前导列查询（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_country_email ON users(country, email);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_country_email已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：PostgreSQL 17: 全表扫描 vs PostgreSQL 18: Skip Scan（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'test@example.com';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Index Skip Scan using idx_country_email
--   Filter: (email = 'test@example.com')
--   Skipped Countries: 5
--
-- 时间: 15ms vs 850ms (-98%)
-- 性能指标：
-- - 执行时间
-- - Skip Scan效果
-- - 缓冲区使用情况
```

### 7.3 并行Hash JOIN改进

```sql
-- 性能测试：PostgreSQL 18: 更智能的并行哈希（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.ref_id;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Gather
--   Workers: 4
--   ->  Parallel Hash Join
--         Hash Cond: (t1.id = t2.ref_id)
--         ->  Parallel Seq Scan on large_table1
--         ->  Parallel Hash
--               ->  Parallel Seq Scan on large_table2
--
-- PostgreSQL 18改进:
-- ├─ 更好的哈希表分区
-- ├─ 更少的锁竞争
-- └─ 性能提升15-20%
-- 性能指标：
-- - 并行worker数量
-- - 执行时间
-- - 哈希表分区效果
```

---

## 8. 统计信息扩展

### 8.1 扩展统计

```sql
-- 性能测试：多列统计（处理列相关性，带错误处理）
BEGIN;
CREATE STATISTICS IF NOT EXISTS stats_user_country_city
ON country, city FROM users;
COMMIT;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '统计信息stats_user_country_city已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建统计信息失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：示例查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users
WHERE country = 'US' AND city = 'New York';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 无扩展统计: 独立性假设
-- Rows估算 = (国家US比例) × (城市NY比例) × 总行数
-- 误差可能很大
--
-- 有扩展统计: 准确估算
-- Rows估算基于实际(US, New York)组合频率
-- 性能指标：
-- - 代价估算准确性
-- - 执行时间
-- - 优化器选择

-- 性能测试：函数依赖（带错误处理）
BEGIN;
CREATE STATISTICS IF NOT EXISTS stats_zip_city (dependencies)
ON zip_code, city FROM addresses;
COMMIT;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '统计信息stats_zip_city已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表addresses不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建统计信息失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：表达式统计（带错误处理）
BEGIN;
CREATE STATISTICS IF NOT EXISTS stats_lower_email (dependencies)
ON lower(email), domain FROM users;
COMMIT;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '统计信息stats_lower_email已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建统计信息失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 重新分析
-- 注意：ANALYZE不支持事务块，需直接执行
-- ANALYZE users;
```

---

## 9. 查询提示（Hint）

### 9.1 禁用特定操作

```sql
-- 性能测试：禁用顺序扫描（带错误处理）
BEGIN;
SET enable_seqscan = off;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置enable_seqscan失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：禁用索引扫描（带错误处理）
BEGIN;
SET enable_indexscan = off;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置enable_indexscan失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：禁用Nested Loop（带错误处理）
BEGIN;
SET enable_nestloop = off;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置enable_nestloop失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：禁用Hash Join（带错误处理）
BEGIN;
SET enable_hashjoin = off;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置enable_hashjoin失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：禁用Merge Join（带错误处理）
BEGIN;
SET enable_mergejoin = off;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置enable_mergejoin失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：禁用并行（带错误处理）
BEGIN;
SET max_parallel_workers_per_gather = 0;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置并行度失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 恢复默认
-- RESET ALL;
```

### 9.2 调整成本

```sql
-- 性能测试：降低某个路径成本（带错误处理）
BEGIN;
SET random_page_cost = 1.0;  -- 让索引更"便宜"
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置random_page_cost失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：提高并行度（带错误处理）
BEGIN;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置并行成本参数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：临时调整（单个查询，带错误处理）
BEGIN;
SET LOCAL random_page_cost = 1.0;
-- SELECT ...;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置LOCAL参数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 10. EXPLAIN详解

### 10.1 基础EXPLAIN

```sql
-- 性能测试：估算计划（带错误处理）
BEGIN;
EXPLAIN (COSTS, VERBOSE)
SELECT * FROM users WHERE user_id = 123;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Index Scan using users_pkey on users (cost=0.42..8.44 rows=1 width=100)
--   Index Cond: (user_id = 123)
--
-- cost=0.42..8.44:
--   0.42: 启动成本
--   8.44: 总成本
--
-- rows=1: 估算返回行数
-- width=100: 平均行宽(字节)
-- 性能指标：
-- - 成本估算
-- - 行数估算
-- - 计划选择

```

### 10.2 ANALYZE执行

```sql
-- 性能测试：实际执行（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = 123;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Index Scan using users_pkey on users (cost=0.42..8.44 rows=1 width=100) (actual time=0.015..0.016 rows=1 loops=1)
--   Index Cond: (user_id = 123)
-- Planning Time: 0.123 ms
-- Execution Time: 0.045 ms
--
-- actual time=0.015..0.016:
--   0.015: 首行返回时间
--   0.016: 总时间
--
-- rows=1: 实际返回行数
-- loops=1: 循环次数
-- 性能指标：
-- - Planning Time
-- - Execution Time
-- - 实际vs估算对比
```

### 10.3 BUFFERS信息

```sql
-- 性能测试：BUFFERS信息（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE status = 'active';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Seq Scan on users (cost=0.00..10000.00 rows=5000 width=100) (actual time=0.010..25.123 rows=5123 loops=1)
--   Filter: (status = 'active')
--   Rows Removed by Filter: 94877
--   Buffers: shared hit=850 read=150
--
-- Buffers:
--   shared hit=850: 缓存命中850个块
--   shared read=150: 从磁盘读取150个块
--
-- 缓存命中率 = 850/(850+150) = 85%
-- 性能指标：
-- - 缓冲区命中率
-- - 磁盘读取次数
-- - 执行时间
```

---

## 11. 优化技巧

### 11.1 强制索引使用

```sql
-- 性能测试：方法1: 禁用顺序扫描（带错误处理）
BEGIN;
SET enable_seqscan = off;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置enable_seqscan失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'test@example.com';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 恢复设置
-- RESET enable_seqscan;

-- 性能测试：方法2: 降低随机页成本（带错误处理）
BEGIN;
SET random_page_cost = 0.1;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置random_page_cost失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'test@example.com';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 恢复设置
-- RESET random_page_cost;
```

### 11.2 JOIN顺序优化

```sql
-- 性能测试：小表驱动大表（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM
    small_table s
    JOIN large_table l ON s.id = l.ref_id;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 优化器自动调整JOIN顺序
-- 性能指标：
-- - JOIN顺序
-- - 执行时间
-- - 优化器选择

-- 性能测试：查看实际顺序（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM
    table1 t1
    JOIN table2 t2 ON t1.id = t2.id
    JOIN table3 t3 ON t2.id = t3.id;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：强制JOIN顺序（带错误处理）
BEGIN;
SET join_collapse_limit = 1;  -- 禁用JOIN重排序
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置join_collapse_limit失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 11.3 分区裁剪

```sql
-- 性能测试：分区表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS logs_partitioned (...) PARTITION BY RANGE (created_at);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表logs_partitioned已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查询自动裁剪（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM logs_partitioned
WHERE created_at BETWEEN '2023-12-01' AND '2023-12-31';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- Append
--   ->  Seq Scan on logs_2023_12  ← 只扫描相关分区
--         Filter: (created_at >= '2023-12-01' AND ...)
--
-- 优化器自动识别只需扫描12月分区
-- 性能指标：
-- - 分区裁剪效果
-- - 执行时间
-- - 扫描分区数

-- 性能测试：确保constraint_exclusion启用（带错误处理）
BEGIN;
DO $$
DECLARE
    constraint_excl TEXT;
BEGIN
    SHOW constraint_exclusion INTO constraint_excl;
    RAISE NOTICE 'constraint_exclusion: %', constraint_excl;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询constraint_exclusion失败: %', SQLERRM;
        RAISE;
END $$;
COMMIT;

-- partition (默认)
```

---

## 12. 调优清单

```text
统计信息:
✓ 定期ANALYZE
✓ 提高重要列的statistics_target
✓ 使用扩展统计（多列相关性）

索引:
✓ 高选择性列建索引
✓ 覆盖索引（Index Only Scan）
✓ 部分索引（WHERE条件）
✓ 多列索引顺序（查询模式）

配置参数:
✓ random_page_cost = 1.1 (SSD)
✓ effective_cache_size = 75%内存
✓ work_mem = 合理值
✓ shared_buffers = 25%内存

查询编写:
✓ 避免SELECT *
✓ 使用显式JOIN
✓ 合理使用CTE
✓ 限制返回行数

监控:
✓ pg_stat_statements
✓ EXPLAIN (ANALYZE, BUFFERS, TIMING)
✓ auto_explain扩展
✓ 慢查询日志
```

---

**完成**: PostgreSQL 18查询优化器深度解析
**字数**: ~10,000字
**涵盖**: 优化器架构、统计信息、JOIN算法、扫描方式、PG18改进
