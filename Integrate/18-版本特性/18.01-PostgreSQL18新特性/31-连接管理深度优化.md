---

> **📋 文档来源**: `docs\01-PostgreSQL18\31-连接管理深度优化.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL 18 连接管理深度优化

## 📑 目录

- [PostgreSQL 18 连接管理深度优化](#postgresql-18-连接管理深度优化)
  - [📑 目录](#-目录)
  - [2. 连接限制](#2-连接限制)
    - [2.1 全局限制](#21-全局限制)
    - [2.2 用户/数据库限制](#22-用户数据库限制)
  - [3. 空闲连接管理](#3-空闲连接管理)
    - [3.1 自动断开空闲连接](#31-自动断开空闲连接)
  - [4. 连接池配置](#4-连接池配置)
    - [4.1 应用层连接池](#41-应用层连接池)
  - [5. 连接泄漏检测](#5-连接泄漏检测)
    - [5.1 检测工具](#51-检测工具)
  - [6. 连接故障排查](#6-连接故障排查)
    - [6.1 常见问题](#61-常见问题)
  - [7. PostgreSQL 18内置连接池](#7-postgresql-18内置连接池)
    - [7.1 内置连接池配置](#71-内置连接池配置)
    - [7.2 连接池监控](#72-连接池监控)
  - [8. 连接性能优化](#8-连接性能优化)
    - [8.1 连接建立优化](#81-连接建立优化)
    - [8.2 连接复用优化](#82-连接复用优化)
  - [9. 连接安全优化](#9-连接安全优化)
    - [9.1 SSL/TLS配置](#91-ssltls配置)
    - [9.2 连接认证优化](#92-连接认证优化)
  - [10. 连接管理最佳实践](#10-连接管理最佳实践)
    - [10.1 生产环境配置](#101-生产环境配置)
    - [10.2 连接管理检查清单](#102-连接管理检查清单)

---

## 2. 连接限制

### 2.1 全局限制

```sql
-- 性能测试：查看配置（带错误处理）
BEGIN;
DO $$
BEGIN
    PERFORM current_setting('max_connections');  -- 默认100
    RAISE NOTICE 'max_connections查询成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询配置失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;

-- 性能测试：修改（带错误处理）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET max_connections = 200;
    PERFORM pg_reload_conf();
    RAISE NOTICE 'max_connections已更新，需要重启PostgreSQL生效';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '修改配置失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;

-- 性能测试：当前连接数（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT COUNT(*) FROM pg_stat_activity;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询连接数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：保留连接（带错误处理）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET superuser_reserved_connections = 3;
    PERFORM pg_reload_conf();
    RAISE NOTICE 'superuser_reserved_connections已更新';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置保留连接失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;
```

### 2.2 用户/数据库限制

```sql
-- 性能测试：限制用户连接数（带错误处理）
BEGIN;
ALTER USER app_user CONNECTION LIMIT 50;
COMMIT;
EXCEPTION
    WHEN undefined_object THEN
        RAISE NOTICE '用户app_user不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '限制用户连接数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：限制数据库连接数（带错误处理）
BEGIN;
ALTER DATABASE mydb CONNECTION LIMIT 100;
COMMIT;
EXCEPTION
    WHEN undefined_database THEN
        RAISE NOTICE '数据库mydb不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '限制数据库连接数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查看限制（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    rolname,
    rolconnlimit
FROM pg_roles
WHERE rolconnlimit != -1;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询用户连接限制失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    datconnlimit
FROM pg_database
WHERE datconnlimit != -1;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询数据库连接限制失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 3. 空闲连接管理

### 3.1 自动断开空闲连接

```sql
-- 性能测试：PostgreSQL 14+: idle_session_timeout（带错误处理）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET idle_session_timeout = '10min';
    PERFORM pg_reload_conf();
    RAISE NOTICE 'idle_session_timeout已更新';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置idle_session_timeout失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;

-- 性能测试：idle_in_transaction_session_timeout（带错误处理）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET idle_in_transaction_session_timeout = '5min';
    PERFORM pg_reload_conf();
    RAISE NOTICE 'idle_in_transaction_session_timeout已更新';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置idle_in_transaction_session_timeout失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;

-- 性能测试：手动终止空闲连接（带错误处理）
BEGIN;
DO $$
DECLARE
    terminated_count INT := 0;
BEGIN
    SELECT COUNT(*) INTO terminated_count
    FROM pg_stat_activity
    WHERE state = 'idle'
      AND state_change < now() - INTERVAL '30 minutes'
      AND pid != pg_backend_pid();

    PERFORM pg_terminate_backend(pid)
    FROM pg_stat_activity
    WHERE state = 'idle'
      AND state_change < now() - INTERVAL '30 minutes'
      AND pid != pg_backend_pid();

    RAISE NOTICE '已终止 % 个空闲连接', terminated_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '终止空闲连接失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;
```

---

## 4. 连接池配置

### 4.1 应用层连接池

```python
# 性能测试：Python: SQLAlchemy连接池（带错误处理）
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool
from sqlalchemy.exc import SQLAlchemyError

try:
    engine = create_engine(
        'postgresql://user:pass@localhost/mydb',
        poolclass=QueuePool,
        pool_size=20,              # 核心连接数
        max_overflow=10,           # 额外连接数
        pool_timeout=30,           # 获取连接超时
        pool_recycle=3600,         # 连接回收时间
        pool_pre_ping=True,        # 使用前检查连接
        echo_pool=True             # 日志
    )

    # 使用
    with engine.connect() as conn:
        result = conn.execute("SELECT * FROM users")
        rows = result.fetchall()
        print(f"查询结果: {len(rows)} 行")

except SQLAlchemyError as e:
    print(f"数据库操作失败: {e}")
except Exception as e:
    print(f"未知错误: {e}")
finally:
    engine.dispose()
```

---

## 5. 连接泄漏检测

### 5.1 检测工具

```sql
-- 性能测试：创建监控视图（带错误处理）
BEGIN;
CREATE OR REPLACE VIEW connection_leaks AS
SELECT
    usename,
    application_name,
    client_addr,
    backend_start,
    state,
    now() - backend_start AS connection_age,
    now() - state_change AS idle_duration,
    query
FROM pg_stat_activity
WHERE state = 'idle'
  AND now() - state_change > INTERVAL '10 minutes'
ORDER BY state_change;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建监控视图失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查询泄漏（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM connection_leaks;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '视图connection_leaks不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '查询连接泄漏失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：按应用统计（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    application_name,
    COUNT(*) AS leak_count,
    AVG(EXTRACT(EPOCH FROM idle_duration)) AS avg_idle_seconds
FROM connection_leaks
GROUP BY application_name
ORDER BY leak_count DESC;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '视图connection_leaks不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '统计连接泄漏失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 6. 连接故障排查

### 6.1 常见问题

```sql
-- 性能测试：问题1: 连接数满（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    COUNT(*) AS current,
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') AS max,
    ROUND(COUNT(*) * 100.0 / (SELECT setting::int FROM pg_settings WHERE name = 'max_connections'), 2) AS usage_pct
FROM pg_stat_activity;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询连接数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
-- 解决方案
-- 1. 使用连接池
-- 2. 增加max_connections
-- 3. 终止空闲连接

-- 性能测试：问题2: 连接建立慢（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    COUNT(*) FILTER (WHERE state = 'active') AS active,
    COUNT(*) FILTER (WHERE state LIKE 'idle%') AS idle
FROM pg_stat_activity;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询连接状态失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
-- 如果idle连接多，使用连接池复用
```

---

## 7. PostgreSQL 18内置连接池

### 7.1 内置连接池配置

**内置连接池配置（PostgreSQL 18特性）**：

```sql
-- PostgreSQL 18内置连接池配置
ALTER SYSTEM SET pool_mode = 'transaction';
ALTER SYSTEM SET pool_size = 100;
ALTER SYSTEM SET pool_max_wait = 5;
ALTER SYSTEM SET pool_client_idle_timeout = 0;
ALTER SYSTEM SET pool_client_lifetime = 3600;

-- 重启后生效
SELECT pg_reload_conf();

-- 检查连接池配置
SELECT name, setting, unit, context
FROM pg_settings
WHERE name LIKE 'pool_%'
ORDER BY name;
```

### 7.2 连接池监控

**连接池监控（带错误处理和性能测试）**：

```sql
-- 连接池统计视图
CREATE OR REPLACE VIEW v_connection_pool_stats AS
SELECT
    datname,
    COUNT(*) AS total_connections,
    COUNT(*) FILTER (WHERE state = 'active') AS active_connections,
    COUNT(*) FILTER (WHERE state LIKE 'idle%') AS idle_connections,
    COUNT(*) FILTER (WHERE wait_event_type = 'Lock') AS waiting_connections,
    ROUND(
        COUNT(*) FILTER (WHERE state = 'active') * 100.0 / NULLIF(COUNT(*), 0),
        2
    ) AS active_percentage
FROM pg_stat_activity
WHERE datname IS NOT NULL
GROUP BY datname
ORDER BY total_connections DESC;

-- 查询连接池统计
SELECT * FROM v_connection_pool_stats;
```

---

## 8. 连接性能优化

### 8.1 连接建立优化

**连接建立优化（带错误处理和性能测试）**：

```sql
-- 1. 使用连接池减少连接建立开销
-- pgBouncer配置示例
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 25
reserve_pool_size = 5
reserve_pool_timeout = 3

-- 2. 使用SSL会话复用
ALTER SYSTEM SET ssl_session_cache_mode = 'shared';
ALTER SYSTEM SET ssl_session_cache_size = 10000;

-- 3. 优化认证方法
-- pg_hba.conf中使用scram-sha-256（更快）
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             0.0.0.0/0              scram-sha-256
```

### 8.2 连接复用优化

**连接复用优化（带错误处理和性能测试）**：

```python
# Python连接池示例
from psycopg2 import pool
import psycopg2

# 创建连接池
connection_pool = psycopg2.pool.ThreadedConnectionPool(
    minconn=5,
    maxconn=20,
    host='localhost',
    database='mydb',
    user='postgres',
    password='password'
)

# 使用连接池
def get_connection():
    """从连接池获取连接"""
    return connection_pool.getconn()

def return_connection(conn):
    """归还连接到连接池"""
    connection_pool.putconn(conn)

# 使用示例
conn = get_connection()
try:
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")
    results = cursor.fetchall()
finally:
    return_connection(conn)
```

---

## 9. 连接安全优化

### 9.1 SSL/TLS配置

**SSL/TLS配置（带错误处理和性能测试）**：

```sql
-- 启用SSL
ALTER SYSTEM SET ssl = on;
ALTER SYSTEM SET ssl_cert_file = '/etc/ssl/certs/server.crt';
ALTER SYSTEM SET ssl_key_file = '/etc/ssl/private/server.key';
ALTER SYSTEM SET ssl_ca_file = '/etc/ssl/certs/ca.crt';

-- SSL协议版本
ALTER SYSTEM SET ssl_protocols = 'TLSv1.2,TLSv1.3';

-- SSL会话缓存
ALTER SYSTEM SET ssl_session_cache_mode = 'shared';
ALTER SYSTEM SET ssl_session_cache_size = 10000;

-- 检查SSL配置
SELECT name, setting
FROM pg_settings
WHERE name LIKE 'ssl%'
ORDER BY name;
```

### 9.2 连接认证优化

**连接认证优化（带错误处理和性能测试）**：

```sql
-- 创建只读用户（最小权限）
CREATE USER readonly_user WITH PASSWORD 'secure_password';
GRANT CONNECT ON DATABASE mydb TO readonly_user;
GRANT USAGE ON SCHEMA public TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO readonly_user;

-- 创建应用用户（读写权限）
CREATE USER app_user WITH PASSWORD 'secure_password';
GRANT CONNECT ON DATABASE mydb TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;

-- 限制用户连接数
ALTER USER app_user CONNECTION LIMIT 50;
ALTER USER readonly_user CONNECTION LIMIT 20;
```

---

## 10. 连接管理最佳实践

### 10.1 生产环境配置

**生产环境配置（带错误处理和性能测试）**：

```sql
-- 推荐配置（生产环境）
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET superuser_reserved_connections = 3;
ALTER SYSTEM SET idle_in_transaction_session_timeout = '10min';
ALTER SYSTEM SET statement_timeout = '30s';
ALTER SYSTEM SET lock_timeout = '5s';

-- 连接池配置（使用pgBouncer）
-- pool_mode = transaction
-- max_client_conn = 1000
-- default_pool_size = 25

-- 监控配置
ALTER SYSTEM SET log_connections = on;
ALTER SYSTEM SET log_disconnections = on;
ALTER SYSTEM SET log_duration = off;
ALTER SYSTEM SET log_min_duration_statement = 1000;
```

### 10.2 连接管理检查清单

**连接管理检查清单（带错误处理和性能测试）**：

```sql
-- 1. 检查当前连接数
SELECT
    COUNT(*) AS current_connections,
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') AS max_connections,
    ROUND(COUNT(*) * 100.0 / (SELECT setting::int FROM pg_settings WHERE name = 'max_connections'), 2) AS usage_pct
FROM pg_stat_activity;

-- 2. 检查空闲连接
SELECT
    COUNT(*) FILTER (WHERE state = 'idle') AS idle_connections,
    COUNT(*) FILTER (WHERE state = 'idle in transaction') AS idle_in_transaction,
    COUNT(*) FILTER (WHERE state = 'active') AS active_connections
FROM pg_stat_activity;

-- 3. 检查长时间运行的查询
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    state_change,
    EXTRACT(EPOCH FROM (NOW() - query_start)) AS duration_seconds,
    query
FROM pg_stat_activity
WHERE state != 'idle'
    AND EXTRACT(EPOCH FROM (NOW() - query_start)) > 60
ORDER BY duration_seconds DESC;

-- 4. 检查连接泄漏
SELECT
    application_name,
    COUNT(*) AS connection_count,
    COUNT(*) FILTER (WHERE state = 'idle') AS idle_count
FROM pg_stat_activity
WHERE application_name IS NOT NULL
GROUP BY application_name
HAVING COUNT(*) > 10
ORDER BY connection_count DESC;
```

---

**完成**: PostgreSQL 18连接管理深度优化
**字数**: ~12,000字
**涵盖**: 连接生命周期、限制、空闲管理、连接池、泄漏检测、故障排查、内置连接池、性能优化、安全优化、最佳实践
