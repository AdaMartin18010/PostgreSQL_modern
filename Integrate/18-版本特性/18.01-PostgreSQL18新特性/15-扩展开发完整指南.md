---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `docs\01-PostgreSQL18\15-æ‰©å±•å¼€å‘å®Œæ•´æŒ‡å—.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# PostgreSQL 18 æ‰©å±•å¼€å‘å®Œæ•´æŒ‡å—

## 1. æ‰©å±•åŸºç¡€

### 1.1 æ‰©å±•ç»“æ„

```text
my_extension/
â”œâ”€â”€ my_extension.control   # æ‰©å±•å…ƒæ•°æ®
â”œâ”€â”€ my_extension--1.0.sql  # å®‰è£…è„šæœ¬
â”œâ”€â”€ my_extension--1.0--1.1.sql  # å‡çº§è„šæœ¬
â”œâ”€â”€ Makefile               # æ„å»ºé…ç½®
â””â”€â”€ src/
    â”œâ”€â”€ my_extension.c     # Cä»£ç 
    â””â”€â”€ my_extension.h     # å¤´æ–‡ä»¶
```

### 1.2 controlæ–‡ä»¶

```ini
# my_extension.control
comment = 'My PostgreSQL extension'
default_version = '1.0'
module_pathname = '$libdir/my_extension'
relocatable = true
requires = 'plpgsql'
```

---

## 2. SQLæ‰©å±•å¼€å‘

### 2.1 ç®€å•æ‰©å±•

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šmy_extension--1.0.sqlï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
-- åˆ›å»ºschema
CREATE SCHEMA IF NOT EXISTS my_extension;
COMMIT;
EXCEPTION
    WHEN duplicate_schema THEN
        RAISE NOTICE 'schema my_extensionå·²å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºschemaå¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šåˆ›å»ºå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION my_extension.hello(name TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN 'Hello, ' || name || '!';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'å‡½æ•°æ‰§è¡Œå¤±è´¥: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šåˆ›å»ºèšåˆå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION my_extension.median_state(state NUMERIC[], val NUMERIC)
RETURNS NUMERIC[] AS $$
BEGIN
    RETURN array_append(state, val);
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'median_stateæ‰§è¡Œå¤±è´¥: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION my_extension.median_final(state NUMERIC[])
RETURNS NUMERIC AS $$
DECLARE
    sorted NUMERIC[];
    len INT;
BEGIN
    sorted := ARRAY(SELECT unnest(state) ORDER BY 1);
    len := array_length(sorted, 1);

    IF len % 2 = 0 THEN
        RETURN (sorted[len/2] + sorted[len/2+1]) / 2.0;
    ELSE
        RETURN sorted[len/2+1];
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'median_finalæ‰§è¡Œå¤±è´¥: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;

CREATE AGGREGATE IF NOT EXISTS my_extension.median(NUMERIC) (
    SFUNC = my_extension.median_state,
    STYPE = NUMERIC[],
    FINALFUNC = my_extension.median_final,
    INITCOND = '{}'
);
COMMIT;
EXCEPTION
    WHEN duplicate_function THEN
        RAISE NOTICE 'èšåˆå‡½æ•°medianå·²å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºèšåˆå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šä½¿ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½åˆ†æï¼‰
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT my_extension.median(value) FROM measurements;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE 'è¡¨measurementsä¸å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE NOTICE 'ä½¿ç”¨èšåˆå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.2 Makefile

```makefile
# Makefile
EXTENSION = my_extension
DATA = my_extension--1.0.sql
PGFILEDESC = "my_extension - My PostgreSQL extension"

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
```

### 2.3 å®‰è£…

```bash
#!/bin/bash
# æ€§èƒ½æµ‹è¯•ï¼šæ‰©å±•å®‰è£…ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
set -e
set -u

error_exit() {
    echo "é”™è¯¯: $1" >&2
    exit 1
}

# æ„å»º
make || error_exit "æ„å»ºå¤±è´¥"

# å®‰è£…
sudo make install || error_exit "å®‰è£…å¤±è´¥"

# åœ¨æ•°æ®åº“ä¸­å®‰è£…
psql -d mydb -c "CREATE EXTENSION IF NOT EXISTS my_extension;" || error_exit "åˆ›å»ºæ‰©å±•å¤±è´¥"

# æŸ¥çœ‹
psql -d mydb -c "\dx my_extension" || error_exit "æŸ¥çœ‹æ‰©å±•å¤±è´¥"

echo "æ‰©å±•å®‰è£…å®Œæˆ"
```

---

## 3. Cæ‰©å±•å¼€å‘

### 3.1 åŸºç¡€Cæ‰©å±•

```c
// my_extension.c
#include "postgres.h"
#include "fmgr.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

// å‡½æ•°å£°æ˜
PG_FUNCTION_INFO_V1(add_numbers);

// å®ç°
Datum
add_numbers(PG_FUNCTION_ARGS)
{
    int32 arg1 = PG_GETARG_INT32(0);
    int32 arg2 = PG_GETARG_INT32(1);
    int32 result = arg1 + arg2;

    PG_RETURN_INT32(result);
}
```

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šSQLåŒ…è£…ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION add_numbers(INT, INT)
RETURNS INT AS '$libdir/my_extension', 'add_numbers'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šä½¿ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½åˆ†æï¼‰
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT add_numbers(10, 20);  -- 30
COMMIT;
EXCEPTION
    WHEN undefined_function THEN
        RAISE NOTICE 'å‡½æ•°add_numbersä¸å­˜åœ¨ï¼Œè¯·å…ˆç¼–è¯‘å¹¶å®‰è£…æ‰©å±•';
    WHEN OTHERS THEN
        RAISE NOTICE 'è°ƒç”¨å‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 3.2 å¤æ‚ç±»å‹å¤„ç†

```c
// å¤„ç†TEXTç±»å‹
PG_FUNCTION_INFO_V1(uppercase);

Datum
uppercase(PG_FUNCTION_ARGS)
{
    text *input = PG_GETARG_TEXT_PP(0);
    char *str = text_to_cstring(input);

    // è½¬å¤§å†™
    for (int i = 0; str[i]; i++) {
        str[i] = toupper(str[i]);
    }

    text *result = cstring_to_text(str);
    PG_RETURN_TEXT_P(result);
}
```

---

## 4. è‡ªå®šä¹‰ç±»å‹

### 4.1 åˆ›å»ºè‡ªå®šä¹‰ç±»å‹

```c
// complex.c - å¤æ•°ç±»å‹
typedef struct Complex {
    float8 x;  // å®éƒ¨
    float8 y;  // è™šéƒ¨
} Complex;

// è¾“å…¥å‡½æ•°
PG_FUNCTION_INFO_V1(complex_in);
Datum
complex_in(PG_FUNCTION_ARGS)
{
    char *str = PG_GETARG_CSTRING(0);
    Complex *result = (Complex *) palloc(sizeof(Complex));

    if (sscanf(str, " ( %lf , %lf )", &result->x, &result->y) != 2)
        ereport(ERROR, (errmsg("invalid input syntax for complex: \"%s\"", str)));

    PG_RETURN_POINTER(result);
}

// è¾“å‡ºå‡½æ•°
PG_FUNCTION_INFO_V1(complex_out);
Datum
complex_out(PG_FUNCTION_ARGS)
{
    Complex *complex = (Complex *) PG_GETARG_POINTER(0);
    char *result = psprintf("(%g,%g)", complex->x, complex->y);
    PG_RETURN_CSTRING(result);
}

// åŠ æ³•æ“ä½œç¬¦
PG_FUNCTION_INFO_V1(complex_add);
Datum
complex_add(PG_FUNCTION_ARGS)
{
    Complex *a = (Complex *) PG_GETARG_POINTER(0);
    Complex *b = (Complex *) PG_GETARG_POINTER(1);
    Complex *result = (Complex *) palloc(sizeof(Complex));

    result->x = a->x + b->x;
    result->y = a->y + b->y;

    PG_RETURN_POINTER(result);
}
```

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šSQLå®šä¹‰ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
DO $$
BEGIN
    CREATE TYPE IF NOT EXISTS complex;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE 'ç±»å‹complexå·²å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºç±»å‹å¤±è´¥: %', SQLERRM;
        RAISE;
END $$;
COMMIT;

BEGIN;
CREATE OR REPLACE FUNCTION complex_in(cstring)
RETURNS complex AS '$libdir/complex'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºcomplex_inå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
CREATE OR REPLACE FUNCTION complex_out(complex)
RETURNS cstring AS '$libdir/complex'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºcomplex_outå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
DO $$
BEGIN
    CREATE TYPE complex (
        INPUT = complex_in,
        OUTPUT = complex_out,
        INTERNALLENGTH = 16,
        ALIGNMENT = double
    );
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE 'ç±»å‹complexå·²å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºç±»å‹å®šä¹‰å¤±è´¥: %', SQLERRM;
        RAISE;
END $$;
COMMIT;

-- æ€§èƒ½æµ‹è¯•ï¼šæ“ä½œç¬¦ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
BEGIN;
CREATE OR REPLACE FUNCTION complex_add(complex, complex)
RETURNS complex AS '$libdir/complex'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºcomplex_addå‡½æ•°å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
DROP OPERATOR IF EXISTS + (complex, complex);
CREATE OPERATOR + (
    LEFTARG = complex,
    RIGHTARG = complex,
    FUNCTION = complex_add
);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'åˆ›å»ºæ“ä½œç¬¦å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- æ€§èƒ½æµ‹è¯•ï¼šä½¿ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½åˆ†æï¼‰
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT '(1.0, 2.0)'::complex + '(3.0, 4.0)'::complex;
-- ç»“æœ: (4.0, 6.0)
COMMIT;
EXCEPTION
    WHEN undefined_type THEN
        RAISE NOTICE 'ç±»å‹complexä¸å­˜åœ¨ï¼Œè¯·å…ˆç¼–è¯‘å¹¶å®‰è£…æ‰©å±•';
    WHEN undefined_function THEN
        RAISE NOTICE 'å‡½æ•°complex_addä¸å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE NOTICE 'ä½¿ç”¨è‡ªå®šä¹‰ç±»å‹å¤±è´¥: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 5. åå°Worker

### 5.1 Background Worker

```c
// bgworker.c
#include "postgres.h"
#include "postmaster/bgworker.h"
#include "storage/ipc.h"
#include "storage/latch.h"

void _PG_init(void);
void my_worker_main(Datum main_arg);

void
_PG_init(void)
{
    BackgroundWorker worker;

    memset(&worker, 0, sizeof(worker));
    worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
    worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
    snprintf(worker.bgw_name, BGW_MAXLEN, "my background worker");
    sprintf(worker.bgw_library_name, "my_extension");
    sprintf(worker.bgw_function_name, "my_worker_main");
    worker.bgw_restart_time = 10;  // 10ç§’åé‡å¯

    RegisterBackgroundWorker(&worker);
}

void
my_worker_main(Datum main_arg)
{
    // è¿æ¥æ•°æ®åº“
    BackgroundWorkerInitializeConnection("mydb", NULL, 0);

    while (!got_SIGTERM)
    {
        // æ‰§è¡Œå®šæ—¶ä»»åŠ¡
        // ...

        // ç­‰å¾…10ç§’
        WaitLatch(MyLatch, WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH, 10000L, PG_WAIT_EXTENSION);
        ResetLatch(MyLatch);
    }

    proc_exit(0);
}
```

---

## 6. é’©å­ï¼ˆHookï¼‰

### 6.1 è‡ªå®šä¹‰é’©å­

```c
// æ‰§è¡Œå™¨é’©å­
static ExecutorStart_hook_type prev_ExecutorStart = NULL;

static void
my_ExecutorStart(QueryDesc *queryDesc, int eflags)
{
    // åœ¨æŸ¥è¯¢å¼€å§‹å‰æ‰§è¡Œ
    elog(LOG, "Query starting: %s", queryDesc->sourceText);

    // è°ƒç”¨åŸå§‹é’©å­
    if (prev_ExecutorStart)
        prev_ExecutorStart(queryDesc, eflags);
    else
        standard_ExecutorStart(queryDesc, eflags);
}

void
_PG_init(void)
{
    // å®‰è£…é’©å­
    prev_ExecutorStart = ExecutorStart_hook;
    ExecutorStart_hook = my_ExecutorStart;
}

// åº”ç”¨: æŸ¥è¯¢æ—¥å¿—ã€æƒé™æ£€æŸ¥ã€å®¡è®¡ç­‰
```

---

## 7. å®æˆ˜æ¡ˆä¾‹

### 7.1 è‡ªåŠ¨åˆ†åŒºæ‰©å±•

```sql
-- auto_partitionæ‰©å±•
CREATE OR REPLACE FUNCTION auto_partition.create_partition_if_not_exists(
    parent_table TEXT,
    partition_column TEXT,
    partition_value DATE
) RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    partition_name := parent_table || '_' || to_char(partition_value, 'YYYYMM');
    start_date := date_trunc('month', partition_value);
    end_date := start_date + INTERVAL '1 month';

    -- æ£€æŸ¥åˆ†åŒºæ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (
        SELECT 1 FROM pg_tables WHERE tablename = partition_name
    ) THEN
        EXECUTE format(
            'CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
            partition_name, parent_table, start_date, end_date
        );

        RAISE NOTICE 'åˆ›å»ºåˆ†åŒº: %', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- è§¦å‘å™¨è‡ªåŠ¨åˆ›å»ºåˆ†åŒº
CREATE OR REPLACE FUNCTION auto_partition.partition_trigger()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM auto_partition.create_partition_if_not_exists(
        TG_TABLE_NAME,
        TG_ARGV[0],  -- åˆ†åŒºåˆ—å
        NEW.created_at::DATE
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åº”ç”¨
CREATE TRIGGER trg_auto_partition
    BEFORE INSERT ON logs_partitioned
    FOR EACH ROW
    EXECUTE FUNCTION auto_partition.partition_trigger('created_at');
```

---

## 8. æµ‹è¯•ä¸è°ƒè¯•

### 8.1 å•å…ƒæµ‹è¯•

```sql
-- ä½¿ç”¨pgTAP
CREATE EXTENSION pgtap;

-- æµ‹è¯•è„šæœ¬
BEGIN;
SELECT plan(5);

SELECT has_function('my_extension', 'hello', ARRAY['text']);
SELECT function_returns('my_extension', 'hello', ARRAY['text'], 'text');

SELECT is(
    my_extension.hello('World'),
    'Hello, World!',
    'helloå‡½æ•°è¿”å›æ­£ç¡®'
);

SELECT finish();
ROLLBACK;
```

### 8.2 æ€§èƒ½æµ‹è¯•

```sql
-- æ€§èƒ½æ¯”è¾ƒ
\timing on

-- æµ‹è¯•1000æ¬¡è°ƒç”¨
SELECT my_extension.expensive_function(i)
FROM generate_series(1, 1000) i;

-- ä¸åŸç”Ÿå‡½æ•°å¯¹æ¯”
SELECT built_in_function(i)
FROM generate_series(1, 1000) i;
```

---

## 9. å‘å¸ƒæ‰©å±•

### 9.1 PGXNå‘å¸ƒ

```bash
# åˆ›å»ºMETA.json
cat > META.json <<EOF
{
    "name": "my_extension",
    "abstract": "My PostgreSQL extension",
    "version": "1.0.0",
    "maintainer": "Your Name <you@example.com>",
    "license": "postgresql",
    "provides": {
        "my_extension": {
            "file": "sql/my_extension--1.0.sql",
            "version": "1.0.0"
        }
    },
    "resources": {
        "homepage": "https://github.com/yourusername/my_extension",
        "repository": {
            "url": "git://github.com/yourusername/my_extension.git",
            "web": "https://github.com/yourusername/my_extension"
        }
    }
}
EOF

# æ‰“åŒ…
zip -r my_extension-1.0.0.zip *

# ä¸Šä¼ åˆ°PGXN
# https://manager.pgxn.org/
```

---

## 10. å¸¸ç”¨æ‰©å±•æ¡ˆä¾‹

### 10.1 ç›‘æ§æ‰©å±•

```sql
-- åˆ›å»ºç›‘æ§å‡½æ•°
CREATE OR REPLACE FUNCTION monitor.table_stats()
RETURNS TABLE (
    table_name TEXT,
    row_count BIGINT,
    total_size TEXT,
    index_size TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.tablename::TEXT,
        t.n_live_tup,
        pg_size_pretty(pg_total_relation_size(t.schemaname||'.'||t.tablename)),
        pg_size_pretty(pg_indexes_size(t.schemaname||'.'||t.tablename))
    FROM pg_stat_user_tables t
    ORDER BY pg_total_relation_size(t.schemaname||'.'||t.tablename) DESC;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨
SELECT * FROM monitor.table_stats();
```

### 10.2 å·¥å…·å‡½æ•°æ‰©å±•

```sql
-- å­—ç¬¦ä¸²å·¥å…·
CREATE OR REPLACE FUNCTION utils.slugify(input TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN lower(regexp_replace(
        regexp_replace(input, '[^a-zA-Z0-9\s-]', '', 'g'),
        '[\s-]+', '-', 'g'
    ));
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ä½¿ç”¨
SELECT utils.slugify('Hello World! 2024');  -- hello-world-2024

-- JSONå·¥å…·
CREATE OR REPLACE FUNCTION utils.jsonb_merge(a JSONB, b JSONB)
RETURNS JSONB AS $$
BEGIN
    RETURN jsonb_strip_nulls(a || b);
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

**å®Œæˆ**: PostgreSQL 18æ‰©å±•å¼€å‘å®Œæ•´æŒ‡å—
**å­—æ•°**: ~8,000å­—
**æ¶µç›–**: SQLæ‰©å±•ã€Cæ‰©å±•ã€è‡ªå®šä¹‰ç±»å‹ã€åå°Workerã€é’©å­ã€æµ‹è¯•ã€å‘å¸ƒ
