---

> **📋 文档来源**: `docs\01-PostgreSQL18\35-慢查询优化实战案例.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL慢查询优化实战案例

## 📑 目录

- [PostgreSQL慢查询优化实战案例](#postgresql慢查询优化实战案例)
  - [📑 目录](#-目录)
  - [案例2: 统计信息过时](#案例2-统计信息过时)
    - [问题2](#问题2)
    - [解决方案2](#解决方案2)
  - [案例3: N+1查询](#案例3-n1查询)
    - [问题3](#问题3)
    - [解决方案3](#解决方案3)
  - [案例4: 函数包裹索引列](#案例4-函数包裹索引列)
    - [问题4](#问题4)
    - [解决方案4](#解决方案4)
  - [案例5: JOIN顺序不当](#案例5-join顺序不当)
    - [问题5](#问题5)
    - [解决方案5](#解决方案5)
  - [案例6: 隐式类型转换](#案例6-隐式类型转换)
    - [问题6](#问题6)
    - [解决方案6](#解决方案6)
  - [案例7: LIMIT陷阱](#案例7-limit陷阱)
    - [问题7](#问题7)
    - [解决方案7](#解决方案7)
  - [案例8: 子查询优化](#案例8-子查询优化)
    - [问题8](#问题8)
    - [解决方案8](#解决方案8)
  - [案例9: DISTINCT优化](#案例9-distinct优化)
    - [问题9](#问题9)
    - [解决方案9](#解决方案9)
  - [案例10: 分页优化](#案例10-分页优化)
    - [问题10](#问题10)
    - [解决方案10](#解决方案10)

---

## 案例2: 统计信息过时

### 问题2

```sql
-- 性能测试：查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM products WHERE category_id = 5;
-- 执行时间: 3.2秒
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
Seq Scan on products  (cost=0.00..50000.00 rows=100 width=200) (actual time=0.125..3156.789 rows=850000 loops=1)
  Filter: (category_id = 5)

问题: 估算100行，实际85万行（估算严重错误）
原因: 统计信息过时，优化器选择错误计划
*/

```

### 解决方案2

```sql
-- 性能测试：更新统计信息（带错误处理）
BEGIN;
ANALYZE products;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'ANALYZE失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：再次查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM products WHERE category_id = 5;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '优化后查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
Index Scan using idx_products_category on products  (cost=0.56..25000.00 rows=850000 width=200) (actual time=0.025..125.456 rows=850000 loops=1)

优化后: 3.2秒 → 0.125秒 (-96%)
估算准确，选择了正确的索引
*/

```

---

## 案例3: N+1查询

### 问题3

```python
# 性能测试：ORM查询（Django/SQLAlchemy）（带错误处理）
try:
    # ORM查询（Django/SQLAlchemy）
    users = User.objects.all()
    for user in users:  # 1次查询
        orders = user.orders.all()  # N次查询
        print(f"{user.name}: {len(orders)} orders")

    # 生成SQL:
    # SELECT * FROM users;
    # SELECT * FROM orders WHERE user_id = 1;
    # SELECT * FROM orders WHERE user_id = 2;
    # ...
    # 总计: 1 + N次查询

    # 1000个用户 = 1001次查询 = 10秒
except Exception as e:
    print(f"N+1查询失败: {e}")
```

### 解决方案3

```python
# 使用JOIN或prefetch
users = User.objects.prefetch_related('orders').all()
for user in users:
    orders = user.orders.all()  # 无额外查询
    print(f"{user.name}: {len(orders)} orders")

# 生成SQL:
# SELECT * FROM users;
# SELECT * FROM orders WHERE user_id IN (1,2,3,...);
# 总计: 2次查询

# 优化后: 10秒 → 0.2秒 (-98%)
```

---

## 案例4: 函数包裹索引列

### 问题4

```sql
-- 性能测试：查询（问题）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';
-- 执行时间: 1.8秒
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
Seq Scan on users  (cost=0.00..50000.00 rows=5000 width=100)
  Filter: (lower((email)::text) = 'test@example.com')

问题: LOWER()函数导致无法使用索引
*/
```

### 解决方案4

```sql
-- 性能测试：方案1: 表达式索引（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_users_lower_email ON users(LOWER(email));
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_users_lower_email已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表达式索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：再次查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '优化后查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
Index Scan using idx_users_lower_email  (cost=0.42..8.44 rows=1 width=100)

优化后: 1.8秒 → 5ms (-99.7%)
*/

-- 性能测试：方案2: 改写查询（如果email存储时已标准化）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'test@example.com';
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '改写查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 案例5: JOIN顺序不当

### 问题5

```sql
-- 性能测试：三表JOIN（问题）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM
    large_table1 t1  -- 1000万行
    JOIN large_table2 t2 ON t1.id = t2.ref_id  -- 1000万行
    JOIN small_table t3 ON t2.category = t3.category  -- 100行
WHERE t3.category = 'electronics';
-- 执行时间: 45秒
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表large_table1、large_table2或small_table不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '三表JOIN查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Hash Join (actual time=25000..45000)
  ->  Hash Join (actual time=20000..40000)
        ->  Seq Scan on large_table1  -- 1000万行
        ->  Hash (Seq Scan on large_table2)  -- 1000万行
  ->  Hash (Seq Scan on small_table WHERE category = 'electronics')  -- 1行

问题: 先JOIN两个大表，再过滤
*/
```

### 解决方案5

```sql
-- 性能测试：改写查询：小表驱动（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM
    small_table t3
    JOIN large_table2 t2 ON t3.category = t2.category
    JOIN large_table1 t1 ON t2.ref_id = t1.id
WHERE t3.category = 'electronics';
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表small_table、large_table2或large_table1不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '小表驱动查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：或使用CTE（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH filtered AS (
    SELECT category FROM small_table WHERE category = 'electronics'
)
SELECT * FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.ref_id
JOIN filtered f ON t2.category = f.category;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表small_table、large_table1或large_table2不存在';
    WHEN OTHERS THEN
        RAISE NOTICE 'CTE优化查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
优化后: 45秒 → 2.5秒 (-94%)
先过滤，再JOIN
*/
```

---

## 案例6: 隐式类型转换

### 问题6

```sql
-- 性能测试：隐式类型转换（问题）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = '12345';  -- 字符串
-- 执行时间: 850ms
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Seq Scan on users  (cost=0.00..50000.00 rows=5000 width=100)
  Filter: ((user_id)::text = '12345'::text)

问题: 类型转换导致无法使用索引
*/
```

### 解决方案6

```sql
-- 性能测试：使用正确类型（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = 12345;  -- 整数
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Index Scan using users_pkey  (cost=0.42..8.44 rows=1 width=100)

优化后: 850ms → 2ms (-99.8%)
*/
```

---

## 案例7: LIMIT陷阱

### 问题7

```sql
-- 性能测试：查询前10个结果（问题）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders
WHERE status = 'pending'
ORDER BY created_at DESC
LIMIT 10;
-- 执行时间: 5.8秒
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE 'LIMIT查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Limit  (actual time=5234.567..5789.123 rows=10 loops=1)
  ->  Sort  (actual time=5234.456..5789.012 rows=10 loops=1)
        Sort Key: created_at DESC
        Sort Method: top-N heapsort  Memory: 25kB
        ->  Seq Scan on orders  (actual time=0.012..4523.789 rows=2000000 loops=1)
              Filter: (status = 'pending')
              Rows Removed by Filter: 8000000

问题: 扫描整表，排序，再LIMIT
*/
```

### 解决方案7

```sql
-- 性能测试：创建组合索引（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_orders_status_created ON orders(status, created_at DESC);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_orders_status_created已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：优化后查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders
WHERE status = 'pending'
ORDER BY created_at DESC
LIMIT 10;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '优化后查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Limit  (actual time=0.025..0.156 rows=10 loops=1)
  ->  Index Scan using idx_orders_status_created on orders
        Index Cond: (status = 'pending')

优化后: 5.8秒 → 0.15ms (-99.997%)
使用索引，无需排序
*/
```

---

## 案例8: 子查询优化

### 问题8

```sql
-- 性能测试：相关子查询（问题）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    u.user_id,
    u.username,
    (SELECT COUNT(*) FROM orders WHERE user_id = u.user_id) AS order_count
FROM users u;
-- 执行时间: 25秒
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users或orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '相关子查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Seq Scan on users u  (actual time=0.012..25678.456 rows=10000 loops=1)
  SubPlan 1
    ->  Aggregate  (actual time=2.456..2.457 rows=1 loops=10000)
          ->  Index Scan on orders  (actual time=0.012..2.345 rows=5 loops=10000)
                Index Cond: (user_id = u.user_id)

问题: 子查询执行10000次（每个用户一次）
*/
```

### 解决方案8

```sql
-- 性能测试：改写为JOIN（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    u.user_id,
    u.username,
    COUNT(o.order_id) AS order_count
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.username;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users或orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE 'JOIN优化查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
HashAggregate  (actual time=125.456..156.789 rows=10000 loops=1)
  ->  Hash Left Join  (actual time=5.234..98.765 rows=50000 loops=1)

优化后: 25秒 → 0.16秒 (-99.4%)
一次JOIN完成
*/
```

---

## 案例9: DISTINCT优化

### 问题9

```sql
-- 性能测试：DISTINCT查询（问题）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT DISTINCT user_id FROM orders;
-- 执行时间: 8.5秒
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE 'DISTINCT查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
HashAggregate  (actual time=6234.567..8456.789 rows=10000 loops=1)
  Batches: 8  Memory Usage: 256MB  Disk Usage: 128MB
  ->  Seq Scan on orders  (actual time=0.012..3456.789 rows=10000000 loops=1)

问题: 哈希聚合溢出到磁盘
*/
```

### 解决方案9

```sql
-- 性能测试：方案1: 使用索引（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_orders_user_id已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：优化后查询（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT DISTINCT user_id FROM orders;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '优化后DISTINCT查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
HashAggregate  (actual time=125.456..156.789 rows=10000 loops=1)
  ->  Index Only Scan using idx_orders_user_id on orders

优化后: 8.5秒 → 0.16秒 (-98%)
*/

-- 性能测试：方案2: GROUP BY代替DISTINCT（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT user_id FROM orders GROUP BY user_id;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表orders不存在';
    WHEN OTHERS THEN
        RAISE NOTICE 'GROUP BY查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 案例10: 分页优化

### 问题10

```sql
-- 性能测试：深度分页（问题）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM products
ORDER BY product_id
LIMIT 20 OFFSET 100000;
-- 执行时间: 1.2秒
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表products不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '深度分页查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Limit  (actual time=1156.789..1189.012 rows=20 loops=1)
  ->  Seq Scan on products  (actual time=0.012..1123.456 rows=100020 loops=1)

问题: 扫描100020行，只返回20行
*/
```

### 解决方案10

```sql
-- 性能测试：Keyset分页（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM products
WHERE product_id > 100000  -- 上一页最后的ID
ORDER BY product_id
LIMIT 20;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表products不存在';
    WHEN OTHERS THEN
        RAISE NOTICE 'Keyset分页查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
/*
Index Scan using products_pkey on products  (actual time=0.025..0.156 rows=20 loops=1)
  Index Cond: (product_id > 100000)

优化后: 1.2秒 → 0.15ms (-99.99%)
*/

-- 性能测试：复合keyset（多列排序）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM events
WHERE (created_at, event_id) < ('2024-01-01 12:00:00', 12345)
ORDER BY created_at DESC, event_id DESC
LIMIT 20;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表events不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '复合keyset分页查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：创建索引（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_events_created_id ON events(created_at DESC, event_id DESC);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_events_created_id已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表events不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

**完成**: PostgreSQL慢查询优化实战案例
**字数**: ~10,000字
**10个真实案例**: 缺索引、统计过时、N+1、函数包裹、JOIN顺序、类型转换、LIMIT、子查询、DISTINCT、分页
