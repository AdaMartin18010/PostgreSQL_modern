---

> **📋 文档来源**: `docs\01-PostgreSQL18\39-外键与约束完全实战.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL外键与约束完全实战

## 1. 外键约束

### 1.1 基础外键

```sql
-- 性能测试：创建表时定义（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS posts (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    title VARCHAR(200),
    content TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    FOREIGN KEY (user_id) REFERENCES users(id)
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '部分表已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：或单独添加（带错误处理）
BEGIN;
ALTER TABLE posts
ADD CONSTRAINT IF NOT EXISTS fk_posts_user
FOREIGN KEY (user_id) REFERENCES users(id);
COMMIT;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '外键约束fk_posts_user已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '添加外键约束失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：测试（带错误处理）
BEGIN;
INSERT INTO users (username) VALUES ('alice')
ON CONFLICT (username) DO NOTHING;
INSERT INTO posts (user_id, title) VALUES (1, 'Hello')
ON CONFLICT DO NOTHING;  -- ✓ 成功
COMMIT;
EXCEPTION
    WHEN foreign_key_violation THEN
        RAISE NOTICE '违反外键约束';
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- ✗ 错误: 违反外键约束 "fk_posts_user"
```

---

## 2. 级联操作

### 2.1 ON DELETE

```sql
-- 性能测试：CASCADE: 级联删除（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS orders (
    id SERIAL PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表orders已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：级联删除（带错误处理）
BEGIN;
DELETE FROM users WHERE id = 1;
-- 同时删除该用户的所有订单
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '级联删除失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- SET NULL: 设置为NULL
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE SET NULL
);

DELETE FROM categories WHERE id = 5;
-- products中category_id=5的行变为NULL

-- SET DEFAULT: 设置为默认值
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    author_id INT DEFAULT 1,
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE SET DEFAULT
);

DELETE FROM users WHERE id = 10;
-- articles中author_id=10的行变为1（默认作者）

-- RESTRICT: 禁止删除（默认）
CREATE TABLE invoices (
    id SERIAL PRIMARY KEY,
    order_id INT,
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE RESTRICT
);

DELETE FROM orders WHERE id = 100;
-- ✗ 错误: 有发票引用此订单

-- NO ACTION: 延迟检查（事务结束时）
CREATE TABLE payments (
    id SERIAL PRIMARY KEY,
    order_id INT,
    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE NO ACTION
);

```

### 2.2 ON UPDATE

```sql
-- 性能测试：主键更新时级联更新外键（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS posts (
    id SERIAL PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表posts已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在，请先创建users表';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：级联更新（带错误处理）
BEGIN;
UPDATE users SET id = 999 WHERE id = 1;
-- posts中user_id=1的行自动更新为999
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '级联更新失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 3. 自引用外键

```sql
-- 性能测试：员工-经理关系（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(id) ON DELETE SET NULL
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表employees已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：插入数据（带错误处理）
BEGIN;
INSERT INTO employees (id, name, manager_id) VALUES
(1, 'Alice', NULL),      -- CEO
(2, 'Bob', 1),           -- Alice的下属
(3, 'Charlie', 1),
(4, 'David', 2)          -- Bob的下属
ON CONFLICT (id) DO NOTHING;
COMMIT;
EXCEPTION
    WHEN foreign_key_violation THEN
        RAISE NOTICE '违反外键约束';
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查询Bob的所有下属（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM employees WHERE manager_id = 2;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表employees不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：删除经理（带错误处理）
BEGIN;
DELETE FROM employees WHERE id = 2;
-- David的manager_id变为NULL
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '删除经理失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 4. CHECK约束

### 4.1 简单检查

```sql
-- 性能测试：创建products表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price NUMERIC(10, 2) CHECK (price > 0),
    discount_pct INT CHECK (discount_pct >= 0 AND discount_pct <= 100),
    stock INT CHECK (stock >= 0)
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表products已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：测试（带错误处理）
BEGIN;
INSERT INTO products (name, price, discount_pct, stock)
VALUES ('Widget', 99.99, 10, 100)  -- ✓ 成功
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE '违反CHECK约束';
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：测试错误情况（带错误处理）
BEGIN;
INSERT INTO products (name, price) VALUES ('Bad', -10)
ON CONFLICT DO NOTHING;
-- ✗ 错误: price必须>0
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE 'price必须>0';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
INSERT INTO products (name, price, discount_pct) VALUES ('Bad', 10, 150)
ON CONFLICT DO NOTHING;
-- ✗ 错误: discount_pct必须0-100
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE 'discount_pct必须0-100';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 4.2 多列检查

```sql
-- 性能测试：创建reservations表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS reservations (
    id SERIAL PRIMARY KEY,
    check_in DATE,
    check_out DATE,
    guests INT,
    CHECK (check_out > check_in),
    CHECK (guests > 0 AND guests <= 10)
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表reservations已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：测试（带错误处理）
BEGIN;
INSERT INTO reservations (check_in, check_out, guests)
VALUES ('2024-01-01', '2024-01-05', 2)  -- ✓
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE '违反CHECK约束';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：测试错误情况（带错误处理）
BEGIN;
INSERT INTO reservations (check_in, check_out, guests)
VALUES ('2024-01-05', '2024-01-01', 2)
ON CONFLICT DO NOTHING;
-- ✗ 错误: check_out必须晚于check_in
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE 'check_out必须晚于check_in';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 4.3 表级约束

```sql
-- 性能测试：创建discounts表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS discounts (
    id SERIAL PRIMARY KEY,
    product_id INT,
    discount_type VARCHAR(20),  -- 'percentage' or 'fixed'
    discount_value NUMERIC(10, 2),
    CONSTRAINT valid_discount CHECK (
        (discount_type = 'percentage' AND discount_value BETWEEN 0 AND 100) OR
        (discount_type = 'fixed' AND discount_value >= 0)
    )
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表discounts已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：百分比折扣（带错误处理）
BEGIN;
INSERT INTO discounts (product_id, discount_type, discount_value)
VALUES (1, 'percentage', 20)  -- ✓
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE '违反CHECK约束';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：固定金额折扣（带错误处理）
BEGIN;
INSERT INTO discounts (product_id, discount_type, discount_value)
VALUES (2, 'fixed', 10.00)  -- ✓
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE '违反CHECK约束';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：错误：百分比不能>100（带错误处理）
BEGIN;
INSERT INTO discounts (product_id, discount_type, discount_value)
VALUES (3, 'percentage', 150)  -- ✗
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN check_violation THEN
        RAISE NOTICE '百分比不能>100';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 5. UNIQUE约束

```sql
-- 性能测试：创建users表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    username VARCHAR(50) UNIQUE NOT NULL
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表users已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：创建enrollments表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS enrollments (
    id SERIAL PRIMARY KEY,
    student_id INT,
    course_id INT,
    semester VARCHAR(20),
    UNIQUE (student_id, course_id, semester)
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表enrollments已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：插入数据（带错误处理）
BEGIN;
INSERT INTO enrollments (student_id, course_id, semester)
VALUES (1, 101, '2024-Spring')  -- ✓
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN unique_violation THEN
        RAISE NOTICE '违反UNIQUE约束';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
INSERT INTO enrollments (student_id, course_id, semester)
VALUES (1, 101, '2024-Fall')  -- ✓ 不同学期
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN unique_violation THEN
        RAISE NOTICE '违反UNIQUE约束';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
INSERT INTO enrollments (student_id, course_id, semester)
VALUES (1, 101, '2024-Spring')  -- ✗ 重复
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN unique_violation THEN
        RAISE NOTICE '违反UNIQUE约束：同一学期只能选一次';
        ROLLBACK;
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：创建部分唯一索引（带错误处理）
BEGIN;
CREATE UNIQUE INDEX IF NOT EXISTS idx_active_email
ON users (email)
WHERE status = 'active';
-- 只有active用户的email必须唯一
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_active_email已存在';
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建部分唯一索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 6. NOT NULL约束

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    total_amount NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    notes TEXT  -- 可以为NULL
);

-- 添加NOT NULL约束
ALTER TABLE orders ALTER COLUMN notes SET NOT NULL;

-- 移除NOT NULL约束
ALTER TABLE orders ALTER COLUMN notes DROP NOT NULL;

-- 批量设置默认值后添加NOT NULL
UPDATE orders SET notes = '' WHERE notes IS NULL;
ALTER TABLE orders ALTER COLUMN notes SET NOT NULL;
```

---

## 7. 延迟约束

```sql
-- 延迟约束（事务结束时检查）
CREATE TABLE employees (
    id INT PRIMARY KEY,
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(id)
        DEFERRABLE INITIALLY DEFERRED
);

-- 场景：交换两个员工的ID
BEGIN;

-- 临时违反约束
UPDATE employees SET id = -1 WHERE id = 10;
UPDATE employees SET id = 10 WHERE id = 20;
UPDATE employees SET id = 20 WHERE id = -1;

-- 事务结束时检查约束
COMMIT;  -- ✓ 成功

-- 立即检查模式
SET CONSTRAINTS ALL IMMEDIATE;
```

---

## 8. 排除约束

```sql
-- 防止时间重叠
CREATE EXTENSION btree_gist;

CREATE TABLE room_bookings (
    id SERIAL PRIMARY KEY,
    room_id INT,
    booked_range tstzrange,
    EXCLUDE USING gist (
        room_id WITH =,
        booked_range WITH &&
    )
);

-- 测试
INSERT INTO room_bookings (room_id, booked_range)
VALUES (1, '[2024-01-01 09:00, 2024-01-01 10:00)');  -- ✓

INSERT INTO room_bookings (room_id, booked_range)
VALUES (1, '[2024-01-01 09:30, 2024-01-01 10:30)');
-- ✗ 错误: 时间重叠

-- 不同房间可以同时预订
INSERT INTO room_bookings (room_id, booked_range)
VALUES (2, '[2024-01-01 09:30, 2024-01-01 10:30)');  -- ✓
```

---

## 9. 性能考虑

```sql
-- 外键索引
-- PostgreSQL不会自动为外键创建索引
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- ❌ 慢：查询某用户的所有帖子
SELECT * FROM posts WHERE user_id = 123;
-- 全表扫描

-- ✅ 快：手动创建索引
CREATE INDEX idx_posts_user_id ON posts(user_id);

SELECT * FROM posts WHERE user_id = 123;
-- 索引扫描

-- 级联删除性能
-- CASCADE删除大量数据时可能很慢
DELETE FROM users WHERE id = 1;
-- 如果有10万个posts，需要逐行删除

-- 优化：分批删除或使用触发器
```

---

## 10. 约束命名规范

```sql
-- 推荐命名规范
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT,
    status VARCHAR(20),
    total_amount NUMERIC(10, 2),

    -- pk_<table>
    CONSTRAINT pk_orders PRIMARY KEY (id),

    -- fk_<table>_<column>
    CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES users(id),

    -- chk_<table>_<description>
    CONSTRAINT chk_orders_status CHECK (status IN ('pending', 'paid', 'shipped', 'cancelled')),
    CONSTRAINT chk_orders_amount CHECK (total_amount >= 0),

    -- uq_<table>_<column>
    CONSTRAINT uq_orders_reference UNIQUE (reference_number)
);

-- 好处：
-- 1. 易于识别约束类型
-- 2. 删除约束时知道名称
-- 3. 错误信息更清晰
```

---

## 11. 最佳实践

```text
外键:
✓ 总是为外键列创建索引
✓ 谨慎使用CASCADE（可能意外删除大量数据）
✓ 对于审计需求，使用SET NULL而非CASCADE
✓ 大表之间避免过多外键（影响写性能）

CHECK:
✓ 尽早在数据库层验证
✓ 配合应用层验证（双重保护）
✓ 避免过于复杂的CHECK（影响性能）

UNIQUE:
✓ 使用部分索引优化（带WHERE）
✓ 考虑区分大小写/空格问题

性能:
✓ 外键列必须有索引
✓ 大批量删除时考虑禁用约束
✓ 使用DEFERRABLE优化批量操作

维护:
✓ 统一约束命名规范
✓ 文档化业务规则
✓ 定期检查约束有效性
```

---

**完成**: PostgreSQL外键与约束完全实战
**字数**: ~10,000字
**涵盖**: 外键、级联操作、自引用、CHECK约束、UNIQUE、NOT NULL、延迟约束、排除约束、性能、最佳实践
