---

> **📋 文档来源**: `docs\01-PostgreSQL18\32-查询计划缓存优化.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL 18 查询计划缓存优化

## 📑 目录

- [1.1 基础使用](#11-基础使用)
- [1.2 性能对比](#12-性能对比)
- [2.1 Generic vs Custom Plan](#21-generic-vs-custom-plan)
- [2.2 强制计划类型](#22-强制计划类型)
- [3.1 何时失效](#31-何时失效)
- [4.1 PgBouncer限制](#41-pgbouncer限制)
- [4.2 应用层处理](#42-应用层处理)
- [5.1 查看活跃计划](#51-查看活跃计划)
---

## 2. 计划缓存策略

### 2.1 Generic vs Custom Plan

```sql
-- 性能测试：PostgreSQL自动选择通用或自定义计划（带错误处理）
BEGIN;
PREPARE user_query (INT) AS
SELECT * FROM users WHERE user_id = $1;
COMMIT;
EXCEPTION
    WHEN duplicate_prepared_statement THEN
        RAISE NOTICE 'prepared语句user_query已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '准备语句失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：前5次：使用custom plan（带错误处理）
BEGIN;
EXECUTE user_query(1);
EXECUTE user_query(2);
EXECUTE user_query(3);
EXECUTE user_query(4);
EXECUTE user_query(5);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '执行prepared语句失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 第6次：评估generic plan
-- 如果generic plan平均成本 <= custom plan平均成本
-- 则切换到generic plan

-- 性能测试：查看计划类型（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING) EXECUTE user_query(123);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查看计划类型失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.2 强制计划类型

```sql
-- 性能测试：强制custom plan（带错误处理）
BEGIN;
SET LOCAL plan_cache_mode = 'force_custom_plan';
RAISE NOTICE '已设置为force_custom_plan';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置plan_cache_mode失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：强制generic plan（带错误处理）
BEGIN;
SET LOCAL plan_cache_mode = 'force_generic_plan';
RAISE NOTICE '已设置为force_generic_plan';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置plan_cache_mode失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：自动选择（默认）（带错误处理）
BEGIN;
SET LOCAL plan_cache_mode = 'auto';
RAISE NOTICE '已设置为auto（默认）';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置plan_cache_mode失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 3. 计划失效

### 3.1 何时失效

```sql
-- 性能测试：导致计划失效的操作（带错误处理）

-- 1. 表结构改变
BEGIN;
ALTER TABLE users ADD COLUMN IF NOT EXISTS status VARCHAR(20);
COMMIT;
EXCEPTION
    WHEN duplicate_column THEN
        RAISE NOTICE '列status已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '添加列失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
-- prepared statement自动失效

-- 2. 统计信息更新
BEGIN;
ANALYZE users;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表users不存在';
    WHEN OTHERS THEN
        RAISE NOTICE 'ANALYZE失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
-- custom plan重新生成

-- 3. 配置参数改变
BEGIN;
SET LOCAL work_mem = '512MB';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置work_mem失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
-- 影响计划选择

-- 4. 会话断开
-- prepared statement丢失
```

---

## 4. 连接池中的Prepared Statements

### 4.1 PgBouncer限制

```ini
# pgbouncer.ini
pool_mode = transaction  # 不支持prepared statements

# 解决方案:
# 1. 使用session模式
pool_mode = session

# 2. 或使用server_reset_query清理
server_reset_query = DISCARD ALL

# 3. 或不使用prepared statements
```

### 4.2 应用层处理

```python
# Django: 禁用server-side prepared statements
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'OPTIONS': {
            'options': '-c statement_timeout=30000 -c idle_in_transaction_session_timeout=60000'
        }
    }
}

# 使用client-side binding而非server-side prepared
```

---

## 5. 查询计划监控

### 5.1 查看活跃计划

```sql
-- 性能测试：查看prepared statements（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    statement,
    prepare_time,
    parameter_types,
    from_sql  -- 是否来自SQL PREPARE命令
FROM pg_prepared_statements;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询prepared statements失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查看执行统计（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    LEFT(query, 100) AS query,
    calls,
    mean_exec_time,
    plans,
    mean_plan_time
FROM pg_stat_statements
WHERE query LIKE 'EXECUTE%'
ORDER BY calls DESC
LIMIT 20;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE 'pg_stat_statements扩展未安装';
    WHEN OTHERS THEN
        RAISE NOTICE '查询执行统计失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 6. 最佳实践

```text
何时使用Prepared Statements:
✓ 相同查询多次执行
✓ 只有参数不同
✓ Session模式连接池
✓ OLTP高频查询

何时避免:
✗ Transaction模式连接池
✗ 查询只执行一次
✗ 查询模式变化频繁
✗ 参数分布极不均匀

性能优化:
✓ 批量执行相同查询
✓ 监控计划类型选择
✓ 定期ANALYZE表
✓ 使用合适的pool_mode

注意事项:
✓ 检查计划是否最优
✓ 监控内存使用
✓ 处理计划失效
✓ 清理不用的prepared statements
```

---

**完成**: PostgreSQL 18查询计划缓存优化
**字数**: ~8,000字
**涵盖**: Prepared Statements、计划缓存、Generic vs Custom、连接池集成、监控
