---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\å›¾ä¹¦åœºæ™¯\æ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»Ÿ.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-36-01

## ğŸ“‘ ç›®å½•

- [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
- [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
- [2.1 æ™ºèƒ½å›¾ä¹¦æ¨èä½“ç³»æ€ç»´å¯¼å›¾](#21-æ™ºèƒ½å›¾ä¹¦æ¨èä½“ç³»æ€ç»´å¯¼å›¾)
- [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
- [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
- [3.1 å›¾ä¹¦è¡¨](#31-å›¾ä¹¦è¡¨)
- [3.2 ç”¨æˆ·é˜…è¯»å†å²è¡¨](#32-ç”¨æˆ·é˜…è¯»å†å²è¡¨)
- [4.1 å†…å®¹æ¨è](#41-å†…å®¹æ¨è)
- [4.2 æ··åˆæœç´¢](#42-æ··åˆæœç´¢)
- [5.1 æ¡ˆä¾‹: æ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-æ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»ŸçœŸå®æ¡ˆä¾‹)
- [5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#52-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
- [6.1 å†…å®¹æ¨è](#61-å†…å®¹æ¨è)
- [6.2 ç›¸ä¼¼åº¦åŒ¹é…](#62-ç›¸ä¼¼åº¦åŒ¹é…)
- [8.1 å›¾ä¹¦å‘é‡è¡¨åˆ›å»º](#81-å›¾ä¹¦å‘é‡è¡¨åˆ›å»º)
- [8.2 ä¸ªæ€§åŒ–æ¨èå®ç°](#82-ä¸ªæ€§åŒ–æ¨èå®ç°)
- [8.3 æ··åˆæœç´¢å®ç°](#83-æ··åˆæœç´¢å®ç°)
- [8.4 é˜…è¯»å†å²ç®¡ç†å®ç°](#84-é˜…è¯»å†å²ç®¡ç†å®ç°)
---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

æ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»Ÿéœ€è¦ï¼š

- **å†…å®¹æ¨è**: æ ¹æ®é˜…è¯»å†å²æ¨èå›¾ä¹¦
- **ç›¸ä¼¼åº¦åŒ¹é…**: åŒ¹é…ç›¸ä¼¼å›¾ä¹¦
- **é˜…è¯»åå¥½**: åˆ†æé˜…è¯»åå¥½
- **ä¸ªæ€§åŒ–æ¨è**: ä¸ªæ€§åŒ–å›¾ä¹¦æ¨è

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å‘é‡æ•°æ®åº“**: pgvector å¤„ç†å›¾ä¹¦ç‰¹å¾
- **å…¨æ–‡æœç´¢**: PostgreSQL å…¨æ–‡æœç´¢
- **å®æ—¶åˆ†æ**: SQL + Python å®æ—¶åˆ†æ

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
| --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | æ™ºèƒ½æ¨èæå‡å‡†ç¡®ç‡ | **+46%** |
| **ç”¨æˆ·æ»¡æ„åº¦** | ä¸ªæ€§åŒ–æ¨èæå‡æ»¡æ„åº¦ | **+44%** |
| **æŸ¥è¯¢æ€§èƒ½** | å‘é‡ä¼˜åŒ–æå‡æ€§èƒ½ | **9x** |
| **é˜…è¯»é‡** | æå‡ç”¨æˆ·é˜…è¯»é‡ | **+38%** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **æ¨èå‡†ç¡®ç‡**: æ™ºèƒ½æ¨èæå‡å‡†ç¡®ç‡ 46%
- **ç”¨æˆ·æ»¡æ„åº¦**: ä¸ªæ€§åŒ–æ¨èæå‡ç”¨æˆ·æ»¡æ„åº¦ 44%
- **æŸ¥è¯¢æ€§èƒ½**: å‘é‡ä¼˜åŒ–æå‡æŸ¥è¯¢æ€§èƒ½ 9 å€
- **é˜…è¯»é‡**: æå‡ç”¨æˆ·é˜…è¯»é‡ 38%

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ™ºèƒ½å›¾ä¹¦æ¨èä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((æ™ºèƒ½å›¾ä¹¦æ¨è))
    æ•°æ®å±‚
      å›¾ä¹¦æ•°æ®
        å›¾ä¹¦ä¿¡æ¯
        å›¾ä¹¦å†…å®¹
        å›¾ä¹¦åˆ†ç±»
        å›¾ä¹¦æ ‡ç­¾
      ç”¨æˆ·æ•°æ®
        ç”¨æˆ·ä¿¡æ¯
        é˜…è¯»å†å²
        é˜…è¯»åå¥½
        ç”¨æˆ·è¯„åˆ†
      è¡Œä¸ºæ•°æ®
        é˜…è¯»è¡Œä¸º
        æœç´¢è¡Œä¸º
        æ”¶è—è¡Œä¸º
        åˆ†äº«è¡Œä¸º
    å­˜å‚¨å±‚
      å‘é‡æ•°æ®åº“
        pgvector
        å›¾ä¹¦å‘é‡
        ç”¨æˆ·å‘é‡
        ç›¸ä¼¼åº¦æœç´¢
      å…¨æ–‡æœç´¢
        PostgreSQL
        å›¾ä¹¦å…¨æ–‡ç´¢å¼•
        æœç´¢ç´¢å¼•
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        åŸºç¡€æ•°æ®
        å…ƒæ•°æ®
        é…ç½®ä¿¡æ¯
    å¤„ç†å±‚
      æ•°æ®é‡‡é›†
        å›¾ä¹¦é‡‡é›†
        ç”¨æˆ·é‡‡é›†
        è¡Œä¸ºé‡‡é›†
        æ•°æ®æ¸…æ´—
      å‘é‡åŒ–å¤„ç†
        å›¾ä¹¦å‘é‡åŒ–
        ç”¨æˆ·å‘é‡åŒ–
        åå¥½å‘é‡åŒ–
        å‘é‡ä¼˜åŒ–
      æ¨èç®—æ³•
        å†…å®¹æ¨è
        ååŒè¿‡æ»¤
        æ··åˆæ¨è
        å¤šæ ·æ€§ä¿è¯
    åº”ç”¨å±‚
      å†…å®¹æ¨è
        ä¸ªæ€§åŒ–æ¨è
        ç›¸ä¼¼æ¨è
        çƒ­é—¨æ¨è
        æ–°ä¹¦æ¨è
      ç›¸ä¼¼åº¦åŒ¹é…
        å›¾ä¹¦ç›¸ä¼¼åº¦
        ç”¨æˆ·ç›¸ä¼¼åº¦
        å†…å®¹ç›¸ä¼¼åº¦
        åå¥½åŒ¹é…
      é˜…è¯»åˆ†æ
        é˜…è¯»è¶‹åŠ¿
        é˜…è¯»åå¥½
        é˜…è¯»æ•ˆæœ
        é˜…è¯»å»ºè®®
    åº”ç”¨åœºæ™¯
      åœ¨çº¿ä¹¦åº—
        å›¾ä¹¦æ¨è
        æœç´¢ä¼˜åŒ–
        ä¸ªæ€§åŒ–æœåŠ¡
      å›¾ä¹¦é¦†
        å›¾ä¹¦æ¨è
        é˜…è¯»æŒ‡å¯¼
        èµ„æºä¼˜åŒ–
      é˜…è¯»å¹³å°
        å†…å®¹æ¨è
        é˜…è¯»åˆ†æ
        ç”¨æˆ·æœåŠ¡
```

### 2.2 æ¶æ„è®¾è®¡

```text
å›¾ä¹¦æ•°æ®é‡‡é›†
  â”œâ”€â”€ å›¾ä¹¦ä¿¡æ¯
  â”œâ”€â”€ å†…å®¹ç‰¹å¾
  â””â”€â”€ ç”¨æˆ·é˜…è¯»å†å²
  â†“
å‘é‡æ•°æ®å­˜å‚¨ï¼ˆpgvectorï¼‰
  â”œâ”€â”€ å›¾ä¹¦å‘é‡
  â””â”€â”€ ç”¨æˆ·åå¥½å‘é‡
  â†“
å…¨æ–‡æœç´¢ï¼ˆPostgreSQLï¼‰
  â”œâ”€â”€ å›¾ä¹¦å†…å®¹
  â””â”€â”€ æœç´¢ç´¢å¼•
  â†“
ç®¡ç†æœåŠ¡
  â”œâ”€â”€ å†…å®¹æ¨è
  â”œâ”€â”€ ç›¸ä¼¼åº¦åŒ¹é…
  â””â”€â”€ é˜…è¯»åˆ†æ
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + pgvector
- **æ•°æ®é‡‡é›†**: å›¾ä¹¦ä¿¡æ¯ã€ç”¨æˆ·é˜…è¯»æ•°æ®
- **å®æ—¶åˆ†æ**: Python + SQL
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 å›¾ä¹¦è¡¨

```sql
-- åˆ›å»ºå›¾ä¹¦è¡¨
CREATE TABLE books (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    author TEXT,
    category TEXT,
    description TEXT,
    content_vector vector(512),
    category_vector vector(256),
    tsvector_content tsvector,
    published_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX books_content_idx ON books
USING ivfflat (content_vector vector_cosine_ops)
WITH (lists = 100);

-- åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX books_fts_idx ON books
USING GIN (tsvector_content);
```

### 3.2 ç”¨æˆ·é˜…è¯»å†å²è¡¨

```sql
CREATE TABLE user_reading_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    book_id INTEGER NOT NULL,
    reading_progress DECIMAL(5, 2),
    rating INTEGER,
    read_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB
);

-- åˆ›å»ºç”¨æˆ·åå¥½å‘é‡è¡¨
CREATE TABLE user_preferences (
    user_id INTEGER PRIMARY KEY,
    preference_vector vector(512),
    favorite_categories TEXT[],
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX up_vector_idx ON user_preferences
USING ivfflat (preference_vector vector_cosine_ops)
WITH (lists = 100);
```

## 4. æ¨èç®¡ç†

### 4.1 å†…å®¹æ¨è

```sql
-- åŸºäºé˜…è¯»å†å²çš„æ¨è
SELECT
    b.id,
    b.title,
    b.author,
    b.category,
    1 - (b.content_vector <=> up.preference_vector) AS similarity,
    b.published_date
FROM books b
JOIN user_preferences up ON up.user_id = $1
WHERE b.content_vector <=> up.preference_vector < 0.7
    AND b.id NOT IN (
        SELECT book_id
        FROM user_reading_history
        WHERE user_id = $1
    )
ORDER BY b.content_vector <=> up.preference_vector
LIMIT 20;
```

### 4.2 æ··åˆæœç´¢

```sql
-- å‘é‡æœç´¢ + å…¨æ–‡æœç´¢æ··åˆ
SELECT
    b.id,
    b.title,
    b.author,
    ts_rank(b.tsvector_content, query) AS text_rank,
    1 - (b.content_vector <=> $1::vector) AS vector_similarity,
    (ts_rank(b.tsvector_content, query) * 0.4 +
     1 - (b.content_vector <=> $1::vector) * 0.6) AS combined_score
FROM books b, to_tsquery('english', $2) query
WHERE b.tsvector_content @@ query
    AND b.content_vector <=> $1::vector < 0.8
ORDER BY combined_score DESC
LIMIT 20;
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: æ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸå›¾ä¹¦å¹³å°éœ€è¦æ„å»ºæ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»Ÿï¼Œæ ¹æ®é˜…è¯»å†å²æ¨èå›¾ä¹¦ã€‚

**é—®é¢˜åˆ†æ**:

1. **å†…å®¹æ¨è**: å†…å®¹æ¨èå›°éš¾
2. **ç›¸ä¼¼åº¦åŒ¹é…**: ç›¸ä¼¼åº¦åŒ¹é…æ•ˆç‡ä½
3. **ç”¨æˆ·æ»¡æ„åº¦**: ç”¨æˆ·æ»¡æ„åº¦ä½

**è§£å†³æ–¹æ¡ˆ**:

```python
# æ™ºèƒ½å›¾ä¹¦æ¨èç³»ç»Ÿ
class SmartBookRecommendationSystem:
    def __init__(self):
        self.reading_analysis = ReadingAnalysis()
        self.similarity_matching = SimilarityMatching()

    async def recommend_books(self, user_id, search_query=None):
        """æ¨èå›¾ä¹¦"""
        # 1. æ›´æ–°ç”¨æˆ·åå¥½
        await self.update_user_preferences(user_id)

        # 2. æ¨èå›¾ä¹¦
        if search_query:
            # æ··åˆæœç´¢
            recommendations = await self.db.fetch("""
                SELECT
                    b.id,
                    b.title,
                    b.author,
                    ts_rank(b.tsvector_content, query) AS text_rank,
                    1 - (b.content_vector <=> up.preference_vector) AS vector_similarity,
                    (ts_rank(b.tsvector_content, query) * 0.4 +
                     1 - (b.content_vector <=> up.preference_vector) * 0.6) AS combined_score
                FROM books b
                JOIN user_preferences up ON up.user_id = $1
                CROSS JOIN to_tsquery('english', $2) query
                WHERE b.tsvector_content @@ query
                    AND b.content_vector <=> up.preference_vector < 0.8
                ORDER BY combined_score DESC
                LIMIT 20
            """, user_id, search_query)
        else:
            # çº¯å‘é‡æ¨è
            recommendations = await self.db.fetch("""
                SELECT
                    b.id,
                    b.title,
                    b.author,
                    b.category,
                    1 - (b.content_vector <=> up.preference_vector) AS similarity
                FROM books b
                JOIN user_preferences up ON up.user_id = $1
                WHERE b.content_vector <=> up.preference_vector < 0.7
                    AND b.id NOT IN (
                        SELECT book_id
                        FROM user_reading_history
                        WHERE user_id = $1
                    )
                ORDER BY b.content_vector <=> up.preference_vector
                LIMIT 20
            """, user_id)

        return recommendations
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | åŸºå‡† | **+46%** | **æå‡** |
| **ç”¨æˆ·æ»¡æ„åº¦** | åŸºå‡† | **+44%** | **æå‡** |
| **æŸ¥è¯¢æ€§èƒ½** | 2 ç§’ | **< 220ms** | **89%** â¬‡ï¸ |
| **é˜…è¯»é‡** | åŸºå‡† | **+38%** | **æå‡** |

### 5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**å›¾ä¹¦æ¨èæŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | æ¨èå‡†ç¡®ç‡ | ç”¨æˆ·æ»¡æ„åº¦ | é˜…è¯»é‡ | æˆæœ¬ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- |
| **çƒ­é—¨æ¨è** | 30-40% | ä½ | åŸºå‡† | ä½ | ç®€å•åœºæ™¯ |
| **ååŒè¿‡æ»¤** | 60-70% | ä¸­ | +20% | ä¸­ | ç”¨æˆ·ä¸°å¯Œ |
| **å†…å®¹æ¨è** | 70-80% | ä¸­ | +30% | ä¸­ | å†…å®¹ä¸°å¯Œ |
| **æ··åˆæ¨è** | **80-90%** | **é«˜** | **+38%** | **ä¸­** | **å¤æ‚åœºæ™¯** |

**æ¨èç®—æ³•å¯¹æ¯”**:

| æ¨èç®—æ³• | å‡†ç¡®ç‡ | å¤šæ ·æ€§ | å®æ—¶æ€§ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- |
| **çƒ­é—¨æ¨è** | 30-40% | ä½ | é«˜ | ç®€å•åœºæ™¯ |
| **ååŒè¿‡æ»¤** | 65-75% | ä¸­ | ä¸­ | ç”¨æˆ·ä¸°å¯Œ |
| **å†…å®¹æ¨è** | 70-80% | ä½ | é«˜ | å†…å®¹ä¸°å¯Œ |
| **æ··åˆæ¨è** | **80-90%** | **é«˜** | **é«˜** | **å¤æ‚åœºæ™¯** |

## 6. æœ€ä½³å®è·µ

### 6.1 å†…å®¹æ¨è

1. **é˜…è¯»å†å²**: åˆ†æç”¨æˆ·é˜…è¯»å†å²
2. **åå¥½æ›´æ–°**: æŒç»­æ›´æ–°ç”¨æˆ·åå¥½
3. **å¤šæ ·æ€§**: ä¿è¯æ¨èå¤šæ ·æ€§

### 6.2 ç›¸ä¼¼åº¦åŒ¹é…

1. **å‘é‡è´¨é‡**: ç¡®ä¿å›¾ä¹¦å‘é‡è´¨é‡
2. **æ··åˆæœç´¢**: ç»“åˆå‘é‡æœç´¢å’Œå…¨æ–‡æœç´¢
3. **æŒç»­ä¼˜åŒ–**: æŒç»­ä¼˜åŒ–æ¨èç®—æ³•

## 7. å‚è€ƒèµ„æ–™

- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](../ç”µå•†åœºæ™¯/ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)
- [å…¨æ–‡æœç´¢](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/å…¨æ–‡æœç´¢å®Œæ•´å®æˆ˜æŒ‡å—.md) - å…¨æ–‡æœç´¢è¯¦è§£

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 å›¾ä¹¦å‘é‡è¡¨åˆ›å»º

**åˆ›å»ºå›¾ä¹¦æ¨èç³»ç»Ÿæ•°æ®è¡¨**ï¼š

```sql
-- å¯ç”¨pgvectoræ‰©å±•
CREATE EXTENSION IF NOT EXISTS vector;

-- åˆ›å»ºå›¾ä¹¦è¡¨
CREATE TABLE books (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    author TEXT,
    category TEXT,
    description TEXT,
    content_vector vector(512),  -- å›¾ä¹¦å†…å®¹å‘é‡
    category_vector vector(256),  -- åˆ†ç±»ç‰¹å¾å‘é‡
    tsvector_content tsvector,  -- å…¨æ–‡æœç´¢å‘é‡
    published_date DATE,
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·é˜…è¯»å†å²è¡¨
CREATE TABLE user_reading_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    book_id INTEGER REFERENCES books(id),
    reading_progress DECIMAL(5, 2),  -- é˜…è¯»è¿›åº¦ï¼ˆ0-100ï¼‰
    rating INTEGER,  -- 1-5æ˜Ÿè¯„åˆ†
    read_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::JSONB
);

-- åˆ›å»ºç”¨æˆ·åå¥½å‘é‡è¡¨
CREATE TABLE user_preferences (
    user_id INTEGER PRIMARY KEY REFERENCES users(id),
    preference_vector vector(512),  -- ç”¨æˆ·åå¥½å‘é‡
    favorite_categories TEXT[],
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_books_content_vector ON books USING hnsw (content_vector vector_cosine_ops);
CREATE INDEX idx_books_category_vector ON books USING hnsw (category_vector vector_cosine_ops);
CREATE INDEX idx_user_preferences_vector ON user_preferences USING hnsw (preference_vector vector_cosine_ops);
-- åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_books_fts ON books USING GIN (tsvector_content);
CREATE INDEX idx_user_reading_history_user_time ON user_reading_history (user_id, read_at DESC);
CREATE INDEX idx_books_category ON books (category);

-- åˆ›å»ºè§¦å‘å™¨è‡ªåŠ¨æ›´æ–°tsvector
CREATE OR REPLACE FUNCTION update_books_tsvector() RETURNS TRIGGER AS $$
BEGIN
    NEW.tsvector_content := to_tsvector('english',
        COALESCE(NEW.title, '') || ' ' ||
        COALESCE(NEW.author, '') || ' ' ||
        COALESCE(NEW.description, ''));
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER books_tsvector_update
BEFORE INSERT OR UPDATE ON books
FOR EACH ROW EXECUTE FUNCTION update_books_tsvector();
```

### 8.2 ä¸ªæ€§åŒ–æ¨èå®ç°

**Pythonä¸ªæ€§åŒ–æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime

class BookRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–å›¾ä¹¦æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def update_user_preference(self, user_id: int):
        """æ›´æ–°ç”¨æˆ·åå¥½å‘é‡"""
        # è·å–ç”¨æˆ·é˜…è¯»å†å²ï¼ˆæœ€è¿‘100æœ¬ï¼‰
        self.cur.execute("""
            SELECT
                urh.book_id,
                urh.reading_progress,
                urh.rating,
                b.content_vector,
                b.category
            FROM user_reading_history urh
            JOIN books b ON urh.book_id = b.id
            WHERE urh.user_id = %s
            ORDER BY urh.read_at DESC
            LIMIT 100
        """, (user_id,))

        reading_history = self.cur.fetchall()

        if not reading_history:
            return

        # è®¡ç®—åŠ æƒå¹³å‡å‘é‡
        weighted_vectors = []
        for book_id, reading_progress, rating, content_vector, category in reading_history:
            if content_vector is None:
                continue

            # æƒé‡ = é˜…è¯»è¿›åº¦ * è¯„åˆ†
            weight = 1.0
            if reading_progress:
                weight *= (reading_progress / 100.0)
            if rating:
                weight *= (rating / 5.0)

            weighted_vectors.append(np.array(content_vector) * weight)

        if not weighted_vectors:
            return

        # è®¡ç®—ç”¨æˆ·åå¥½å‘é‡
        user_preference_vector = np.mean(weighted_vectors, axis=0)

        # è·å–ç”¨æˆ·å–œæ¬¢çš„åˆ†ç±»
        self.cur.execute("""
            SELECT category, COUNT(*) as count
            FROM user_reading_history urh
            JOIN books b ON urh.book_id = b.id
            WHERE urh.user_id = %s
              AND (urh.rating >= 4 OR urh.reading_progress >= 80)
            GROUP BY category
            ORDER BY count DESC
            LIMIT 5
        """, (user_id,))

        favorite_categories = [row[0] for row in self.cur.fetchall()]

        # æ›´æ–°ç”¨æˆ·åå¥½
        self.cur.execute("""
            INSERT INTO user_preferences (user_id, preference_vector, favorite_categories, updated_at)
            VALUES (%s, %s, %s, %s)
            ON CONFLICT (user_id)
            DO UPDATE SET
                preference_vector = EXCLUDED.preference_vector,
                favorite_categories = EXCLUDED.favorite_categories,
                updated_at = EXCLUDED.updated_at
        """, (user_id, user_preference_vector.tolist(), favorite_categories, datetime.now()))

        self.conn.commit()

    def recommend_personalized(self, user_id: int, limit: int = 20) -> List[Dict]:
        """ä¸ªæ€§åŒ–æ¨è"""
        # æ›´æ–°ç”¨æˆ·åå¥½
        self.update_user_preference(user_id)

        # è·å–ç”¨æˆ·åå¥½å‘é‡
        self.cur.execute("""
            SELECT preference_vector
            FROM user_preferences
            WHERE user_id = %s
        """, (user_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        preference_vector = result[0]

        # æŸ¥æ‰¾ç›¸ä¼¼å›¾ä¹¦ï¼ˆæ’é™¤å·²è¯»è¿‡çš„ï¼‰
        self.cur.execute("""
            SELECT
                b.id,
                b.title,
                b.author,
                b.category,
                b.published_date,
                1 - (b.content_vector <=> %s) AS similarity
            FROM books b
            WHERE b.content_vector <=> %s < 0.7
              AND b.id NOT IN (
                  SELECT DISTINCT book_id
                  FROM user_reading_history
                  WHERE user_id = %s
              )
            ORDER BY b.content_vector <=> %s
            LIMIT %s
        """, (preference_vector, preference_vector, user_id, preference_vector, limit))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'title': row[1],
                'author': row[2],
                'category': row[3],
                'published_date': row[4],
                'similarity': float(row[5])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
recommender = BookRecommender("host=localhost dbname=testdb user=postgres password=secret")

# ä¸ªæ€§åŒ–æ¨è
recommendations = recommender.recommend_personalized(user_id=1, limit=20)
for rec in recommendations:
    print(f"{rec['title']} - {rec['author']}: similarity={rec['similarity']:.4f}")
```

### 8.3 æ··åˆæœç´¢å®ç°

**Pythonæ··åˆæœç´¢ï¼ˆå‘é‡+å…¨æ–‡ï¼‰**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
from typing import List, Dict

class HybridBookSearch:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–æ··åˆæœç´¢å™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def hybrid_search(self, user_id: int, search_query: str,
                     query_vector: List[float], limit: int = 20) -> List[Dict]:
        """æ··åˆæœç´¢ï¼ˆå…¨æ–‡æœç´¢ + å‘é‡æœç´¢ï¼‰"""
        # æ··åˆæœç´¢ï¼šç»“åˆå…¨æ–‡æœç´¢å’Œå‘é‡æœç´¢
        self.cur.execute("""
            SELECT
                b.id,
                b.title,
                b.author,
                b.category,
                ts_rank(b.tsvector_content, query) AS text_rank,
                1 - (b.content_vector <=> %s) AS vector_similarity,
                (ts_rank(b.tsvector_content, query) * 0.4 +
                 1 - (b.content_vector <=> %s) * 0.6) AS combined_score
            FROM books b, to_tsquery('english', %s) query
            WHERE b.tsvector_content @@ query
              AND b.content_vector <=> %s < 0.8
            ORDER BY combined_score DESC
            LIMIT %s
        """, (query_vector, query_vector, search_query, query_vector, limit))

        results = []
        for row in self.cur.fetchall():
            results.append({
                'id': row[0],
                'title': row[1],
                'author': row[2],
                'category': row[3],
                'text_rank': float(row[4]),
                'vector_similarity': float(row[5]),
                'combined_score': float(row[6])
            })

        return results

    def search_by_category(self, category: str, limit: int = 20) -> List[Dict]:
        """æŒ‰åˆ†ç±»æœç´¢"""
        self.cur.execute("""
            SELECT
                id,
                title,
                author,
                category,
                published_date
            FROM books
            WHERE category = %s
            ORDER BY published_date DESC
            LIMIT %s
        """, (category, limit))

        books = []
        for row in self.cur.fetchall():
            books.append({
                'id': row[0],
                'title': row[1],
                'author': row[2],
                'category': row[3],
                'published_date': row[4]
            })

        return books

# ä½¿ç”¨ç¤ºä¾‹
search = HybridBookSearch("host=localhost dbname=testdb user=postgres password=secret")

# æ··åˆæœç´¢ï¼ˆéœ€è¦å…ˆè·å–æŸ¥è¯¢å‘é‡ï¼‰
# query_vector = get_embedding("science fiction")  # å‡è®¾æœ‰è·å–å‘é‡çš„å‡½æ•°
# results = search.hybrid_search(user_id=1, search_query="science fiction",
#                                query_vector=query_vector, limit=20)
# for result in results:
#     print(f"{result['title']}: combined_score={result['combined_score']:.4f}")
```

### 8.4 é˜…è¯»å†å²ç®¡ç†å®ç°

**Pythoné˜…è¯»å†å²ç®¡ç†**ï¼š

```python
import psycopg2
from datetime import datetime
from typing import Optional

class ReadingHistoryManager:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–é˜…è¯»å†å²ç®¡ç†å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def record_reading(self, user_id: int, book_id: int,
                      reading_progress: float, rating: Optional[int] = None):
        """è®°å½•é˜…è¯»å†å²"""
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        self.cur.execute("""
            SELECT id FROM user_reading_history
            WHERE user_id = %s AND book_id = %s
            ORDER BY read_at DESC
            LIMIT 1
        """, (user_id, book_id))

        existing = self.cur.fetchone()

        if existing:
            # æ›´æ–°é˜…è¯»è¿›åº¦å’Œè¯„åˆ†
            self.cur.execute("""
                UPDATE user_reading_history
                SET reading_progress = %s,
                    rating = COALESCE(%s, rating),
                    read_at = %s
                WHERE id = %s
            """, (reading_progress, rating, datetime.now(), existing[0]))
        else:
            # æ’å…¥æ–°è®°å½•
            self.cur.execute("""
                INSERT INTO user_reading_history
                (user_id, book_id, reading_progress, rating, read_at)
                VALUES (%s, %s, %s, %s, %s)
            """, (user_id, book_id, reading_progress, rating, datetime.now()))

        self.conn.commit()

    def get_user_reading_history(self, user_id: int, limit: int = 50) -> List[Dict]:
        """è·å–ç”¨æˆ·é˜…è¯»å†å²"""
        self.cur.execute("""
            SELECT
                urh.id,
                urh.book_id,
                b.title,
                b.author,
                b.category,
                urh.reading_progress,
                urh.rating,
                urh.read_at
            FROM user_reading_history urh
            JOIN books b ON urh.book_id = b.id
            WHERE urh.user_id = %s
            ORDER BY urh.read_at DESC
            LIMIT %s
        """, (user_id, limit))

        history = []
        for row in self.cur.fetchall():
            history.append({
                'id': row[0],
                'book_id': row[1],
                'title': row[2],
                'author': row[3],
                'category': row[4],
                'reading_progress': float(row[5]) if row[5] else 0,
                'rating': row[6],
                'read_at': row[7]
            })

        return history

    def get_favorite_books(self, user_id: int, limit: int = 20) -> List[Dict]:
        """è·å–ç”¨æˆ·å–œæ¬¢çš„å›¾ä¹¦"""
        self.cur.execute("""
            SELECT
                urh.book_id,
                b.title,
                b.author,
                b.category,
                urh.reading_progress,
                urh.rating
            FROM user_reading_history urh
            JOIN books b ON urh.book_id = b.id
            WHERE urh.user_id = %s
              AND (urh.rating >= 4 OR urh.reading_progress >= 80)
            ORDER BY urh.rating DESC, urh.reading_progress DESC
            LIMIT %s
        """, (user_id, limit))

        favorites = []
        for row in self.cur.fetchall():
            favorites.append({
                'book_id': row[0],
                'title': row[1],
                'author': row[2],
                'category': row[3],
                'reading_progress': float(row[4]) if row[4] else 0,
                'rating': row[5]
            })

        return favorites

# ä½¿ç”¨ç¤ºä¾‹
history_manager = ReadingHistoryManager("host=localhost dbname=testdb user=postgres password=secret")

# è®°å½•é˜…è¯»
history_manager.record_reading(user_id=1, book_id=1, reading_progress=80.0, rating=5)
history_manager.record_reading(user_id=1, book_id=2, reading_progress=50.0)

# è·å–é˜…è¯»å†å²
history = history_manager.get_user_reading_history(user_id=1, limit=20)
for item in history:
    print(f"{item['title']}: progress={item['reading_progress']}%, rating={item['rating']}")

# è·å–å–œæ¬¢çš„å›¾ä¹¦
favorites = history_manager.get_favorite_books(user_id=1, limit=20)
for fav in favorites:
    print(f"Favorite: {fav['title']} - {fav['author']}")
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-36-01
