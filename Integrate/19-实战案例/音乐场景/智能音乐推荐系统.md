---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\éŸ³ä¹åœºæ™¯\æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿ.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

> **âš ï¸ é‡è¦æç¤º**: æœ¬æ–‡æ¡£å·²æ•´åˆåˆ°é€šç”¨æ¨èç³»ç»Ÿæ¶æ„æ–‡æ¡£ä¸­ã€‚
>
> **æ¨èé˜…è¯»**:
>
> - [é€šç”¨æ¨èç³»ç»Ÿæ¶æ„](../é€šç”¨æ¨èç³»ç»Ÿæ¶æ„.md) - é€šç”¨æ¶æ„å’Œæœ€ä½³å®è·µ
> - [æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿ-è¯¦ç»†å®ç°](./æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿ-è¯¦ç»†å®ç°.md) - éŸ³ä¹åœºæ™¯ç‰¹å®šå®ç°
>
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºå‚è€ƒï¼Œå»ºè®®ä¼˜å…ˆé˜…è¯»é€šç”¨æ¶æ„æ–‡æ¡£ã€‚

---

# æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-37-01

## ğŸ“‘ ç›®å½•

- [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
- [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
- [2.1 æ™ºèƒ½éŸ³ä¹æ¨èä½“ç³»æ€ç»´å¯¼å›¾](#21-æ™ºèƒ½éŸ³ä¹æ¨èä½“ç³»æ€ç»´å¯¼å›¾)
- [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
- [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
- [3.1 éŸ³ä¹è¡¨](#31-éŸ³ä¹è¡¨)
- [3.2 ç”¨æˆ·æ’­æ”¾å†å²è¡¨](#32-ç”¨æˆ·æ’­æ”¾å†å²è¡¨)
- [4.1 ä¸ªæ€§åŒ–æ¨è](#41-ä¸ªæ€§åŒ–æ¨è)
- [4.2 ç›¸ä¼¼éŸ³ä¹æ¨è](#42-ç›¸ä¼¼éŸ³ä¹æ¨è)
- [5.1 æ¡ˆä¾‹: æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»ŸçœŸå®æ¡ˆä¾‹)
- [5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#52-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
- [6.1 ä¸ªæ€§åŒ–æ¨è](#61-ä¸ªæ€§åŒ–æ¨è)
- [6.2 ç›¸ä¼¼åº¦åŒ¹é…](#62-ç›¸ä¼¼åº¦åŒ¹é…)
- [8.1 éŸ³ä¹å‘é‡è¡¨åˆ›å»º](#81-éŸ³ä¹å‘é‡è¡¨åˆ›å»º)
- [8.2 ä¸ªæ€§åŒ–æ¨èå®ç°](#82-ä¸ªæ€§åŒ–æ¨èå®ç°)
- [8.3 ç›¸ä¼¼éŸ³ä¹æ¨èå®ç°](#83-ç›¸ä¼¼éŸ³ä¹æ¨èå®ç°)
- [8.4 æ’­æ”¾å†å²ç®¡ç†å®ç°](#84-æ’­æ”¾å†å²ç®¡ç†å®ç°)
- [8.5 æ’­æ”¾åˆ—è¡¨ç”Ÿæˆå®ç°](#85-æ’­æ”¾åˆ—è¡¨ç”Ÿæˆå®ç°)
---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿéœ€è¦ï¼š

- **ä¸ªæ€§åŒ–æ¨è**: æ ¹æ®å¬æ­Œå†å²æ¨èéŸ³ä¹
- **ç›¸ä¼¼åº¦åŒ¹é…**: åŒ¹é…ç›¸ä¼¼éŸ³ä¹
- **æ’­æ”¾åˆ—è¡¨**: ç”Ÿæˆä¸ªæ€§åŒ–æ’­æ”¾åˆ—è¡¨
- **è¶‹åŠ¿åˆ†æ**: åˆ†æéŸ³ä¹è¶‹åŠ¿

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å‘é‡æ•°æ®åº“**: pgvector å¤„ç†éŸ³ä¹ç‰¹å¾
- **ç›¸ä¼¼åº¦æœç´¢**: å‘é‡ç›¸ä¼¼åº¦æœç´¢
- **å®æ—¶åˆ†æ**: SQL + Python å®æ—¶åˆ†æ

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
| --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | æ™ºèƒ½æ¨èæå‡å‡†ç¡®ç‡ | **+50%** |
| **ç”¨æˆ·æ»¡æ„åº¦** | ä¸ªæ€§åŒ–æ¨èæå‡æ»¡æ„åº¦ | **+46%** |
| **æŸ¥è¯¢æ€§èƒ½** | å‘é‡ä¼˜åŒ–æå‡æ€§èƒ½ | **10x** |
| **æ’­æ”¾æ—¶é•¿** | æå‡ç”¨æˆ·æ’­æ”¾æ—¶é•¿ | **+42%** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **æ¨èå‡†ç¡®ç‡**: æ™ºèƒ½æ¨èæå‡å‡†ç¡®ç‡ 50%
- **ç”¨æˆ·æ»¡æ„åº¦**: ä¸ªæ€§åŒ–æ¨èæå‡ç”¨æˆ·æ»¡æ„åº¦ 46%
- **æŸ¥è¯¢æ€§èƒ½**: å‘é‡ä¼˜åŒ–æå‡æŸ¥è¯¢æ€§èƒ½ 10 å€
- **æ’­æ”¾æ—¶é•¿**: æå‡ç”¨æˆ·æ’­æ”¾æ—¶é•¿ 42%

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ™ºèƒ½éŸ³ä¹æ¨èä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((æ™ºèƒ½éŸ³ä¹æ¨è))
    æ•°æ®å±‚
      éŸ³ä¹æ•°æ®
        éŸ³ä¹ä¿¡æ¯
        éŸ³é¢‘ç‰¹å¾
        éŸ³ä¹å†…å®¹
        éŸ³ä¹æ ‡ç­¾
      ç”¨æˆ·æ•°æ®
        ç”¨æˆ·ä¿¡æ¯
        æ’­æ”¾å†å²
        ç”¨æˆ·åå¥½
        ç”¨æˆ·è¡Œä¸º
      è¡Œä¸ºæ•°æ®
        æ’­æ”¾è¡Œä¸º
        æ”¶è—è¡Œä¸º
        åˆ†äº«è¡Œä¸º
        è¯„ä»·è¡Œä¸º
    å­˜å‚¨å±‚
      å‘é‡æ•°æ®åº“
        pgvector
        éŸ³ä¹å‘é‡
        ç”¨æˆ·å‘é‡
        ç›¸ä¼¼åº¦æœç´¢
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        åŸºç¡€æ•°æ®
        å…ƒæ•°æ®
        é…ç½®ä¿¡æ¯
      ç¼“å­˜å±‚
        Redis
        æ¨èç¼“å­˜
        ç”¨æˆ·ç¼“å­˜
        çƒ­ç‚¹ç¼“å­˜
    å¤„ç†å±‚
      æ•°æ®é‡‡é›†
        éŸ³ä¹é‡‡é›†
        è¡Œä¸ºé‡‡é›†
        æ•°æ®æ¸…æ´—
        æ•°æ®éªŒè¯
      å‘é‡åŒ–å¤„ç†
        éŸ³ä¹å‘é‡åŒ–
        ç”¨æˆ·å‘é‡åŒ–
        ç‰¹å¾æå–
        å‘é‡ä¼˜åŒ–
      æ¨èç®—æ³•
        ä¸ªæ€§åŒ–æ¨è
        ç›¸ä¼¼æ¨è
        çƒ­é—¨æ¨è
        æ··åˆæ¨è
    åº”ç”¨å±‚
      ä¸ªæ€§åŒ–æ¨è
        å®æ—¶æ¨è
        ç¦»çº¿æ¨è
        çƒ­é—¨æ¨è
        æ–°éŸ³ä¹æ¨è
      ç›¸ä¼¼åº¦åŒ¹é…
        éŸ³ä¹ç›¸ä¼¼åº¦
        å†…å®¹ç›¸ä¼¼åº¦
        ç”¨æˆ·ç›¸ä¼¼åº¦
        åå¥½åŒ¹é…
      æ’­æ”¾åˆ—è¡¨
        åˆ—è¡¨ç”Ÿæˆ
        åˆ—è¡¨ä¼˜åŒ–
        åˆ—è¡¨æ¨è
        åˆ—è¡¨ç®¡ç†
    åº”ç”¨åœºæ™¯
      éŸ³ä¹å¹³å°
        éŸ³ä¹æ¨è
        æ’­æ”¾ä¼˜åŒ–
        ç”¨æˆ·ç•™å­˜
      å†…å®¹å¹³å°
        å†…å®¹æ¨è
        å†…å®¹ä¼˜åŒ–
        ç”¨æˆ·æœåŠ¡
      å¨±ä¹å¹³å°
        å¨±ä¹æ¨è
        ä½“éªŒä¼˜åŒ–
        ç”¨æˆ·ç²˜æ€§
```

### 2.2 æ¶æ„è®¾è®¡

```text
éŸ³ä¹æ•°æ®é‡‡é›†
  â”œâ”€â”€ éŸ³é¢‘ç‰¹å¾
  â”œâ”€â”€ å…ƒæ•°æ®
  â””â”€â”€ ç”¨æˆ·è¡Œä¸º
  â†“
å‘é‡æ•°æ®å­˜å‚¨ï¼ˆpgvectorï¼‰
  â”œâ”€â”€ éŸ³ä¹å‘é‡
  â””â”€â”€ ç”¨æˆ·åå¥½å‘é‡
  â†“
ç®¡ç†æœåŠ¡
  â”œâ”€â”€ ä¸ªæ€§åŒ–æ¨è
  â”œâ”€â”€ ç›¸ä¼¼åº¦åŒ¹é…
  â””â”€â”€ æ’­æ”¾åˆ—è¡¨ç”Ÿæˆ
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + pgvector
- **æ•°æ®é‡‡é›†**: éŸ³é¢‘å¤„ç†ã€ç‰¹å¾æå–
- **å®æ—¶åˆ†æ**: Python + SQL
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 éŸ³ä¹è¡¨

```sql
-- åˆ›å»ºéŸ³ä¹è¡¨
CREATE TABLE songs (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    artist TEXT,
    album TEXT,
    genre TEXT,
    audio_vector vector(512),
    genre_vector vector(256),
    duration INTEGER,
    release_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX songs_audio_idx ON songs
USING ivfflat (audio_vector vector_cosine_ops)
WITH (lists = 100);

CREATE INDEX songs_genre_idx ON songs
USING ivfflat (genre_vector vector_cosine_ops)
WITH (lists = 50);
```

### 3.2 ç”¨æˆ·æ’­æ”¾å†å²è¡¨

```sql
CREATE TABLE user_play_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    song_id INTEGER NOT NULL,
    play_count INTEGER DEFAULT 1,
    last_played_at TIMESTAMPTZ DEFAULT NOW(),
    rating INTEGER,
    metadata JSONB
);

-- åˆ›å»ºç”¨æˆ·åå¥½å‘é‡è¡¨
CREATE TABLE user_preferences (
    user_id INTEGER PRIMARY KEY,
    preference_vector vector(512),
    favorite_genres TEXT[],
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX up_vector_idx ON user_preferences
USING ivfflat (preference_vector vector_cosine_ops)
WITH (lists = 100);
```

## 4. æ¨èç®¡ç†

### 4.1 ä¸ªæ€§åŒ–æ¨è

```sql
-- åŸºäºæ’­æ”¾å†å²çš„ä¸ªæ€§åŒ–æ¨è
SELECT
    s.id,
    s.title,
    s.artist,
    s.genre,
    1 - (s.audio_vector <=> up.preference_vector) AS similarity,
    s.duration
FROM songs s
JOIN user_preferences up ON up.user_id = $1
WHERE s.audio_vector <=> up.preference_vector < 0.7
    AND s.id NOT IN (
        SELECT song_id
        FROM user_play_history
        WHERE user_id = $1
    )
ORDER BY s.audio_vector <=> up.preference_vector
LIMIT 50;
```

### 4.2 ç›¸ä¼¼éŸ³ä¹æ¨è

```python
# ç›¸ä¼¼éŸ³ä¹æ¨è
class SimilarMusicRecommendation:
    async def find_similar_songs(self, song_id, limit=20):
        """æŸ¥æ‰¾ç›¸ä¼¼éŸ³ä¹"""
        # 1. è·å–æ­Œæ›²å‘é‡
        song = await self.db.fetchrow("""
            SELECT audio_vector, genre_vector
            FROM songs
            WHERE id = $1
        """, song_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼éŸ³ä¹
        similar_songs = await self.db.fetch("""
            SELECT
                id,
                title,
                artist,
                genre,
                1 - (audio_vector <=> $1::vector) AS audio_similarity,
                1 - (genre_vector <=> $2::vector) AS genre_similarity,
                (1 - (audio_vector <=> $1::vector) * 0.7 +
                 1 - (genre_vector <=> $2::vector) * 0.3) AS combined_similarity
            FROM songs
            WHERE id != $3
                AND audio_vector <=> $1::vector < 0.6
            ORDER BY combined_similarity DESC
            LIMIT $4
        """, song['audio_vector'], song['genre_vector'], song_id, limit)

        return similar_songs
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸéŸ³ä¹å¹³å°éœ€è¦æ„å»ºæ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿï¼Œæ ¹æ®å¬æ­Œå†å²æ¨èéŸ³ä¹ã€‚

**é—®é¢˜åˆ†æ**:

1. **ä¸ªæ€§åŒ–æ¨è**: ä¸ªæ€§åŒ–æ¨èå›°éš¾
2. **ç›¸ä¼¼åº¦åŒ¹é…**: ç›¸ä¼¼åº¦åŒ¹é…æ•ˆç‡ä½
3. **ç”¨æˆ·æ»¡æ„åº¦**: ç”¨æˆ·æ»¡æ„åº¦ä½

**è§£å†³æ–¹æ¡ˆ**:

```python
# æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿ
class SmartMusicRecommendationSystem:
    def __init__(self):
        self.similar_music = SimilarMusicRecommendation()
        self.playlist_generator = PlaylistGenerator()

    async def recommend_music(self, user_id, context=None):
        """æ¨èéŸ³ä¹"""
        # 1. æ›´æ–°ç”¨æˆ·åå¥½
        await self.update_user_preferences(user_id)

        # 2. æ¨èéŸ³ä¹
        recommendations = await self.db.fetch("""
            SELECT
                s.id,
                s.title,
                s.artist,
                s.genre,
                1 - (s.audio_vector <=> up.preference_vector) AS similarity,
                s.duration
            FROM songs s
            JOIN user_preferences up ON up.user_id = $1
            WHERE s.audio_vector <=> up.preference_vector < 0.7
                AND s.id NOT IN (
                    SELECT song_id
                    FROM user_play_history
                    WHERE user_id = $1
                )
            ORDER BY s.audio_vector <=> up.preference_vector
            LIMIT 50
        """, user_id)

        # 3. ç”Ÿæˆæ’­æ”¾åˆ—è¡¨
        if context == 'playlist':
            playlist = await self.playlist_generator.generate_playlist(
                user_id, recommendations
            )
            return playlist

        return recommendations
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | åŸºå‡† | **+50%** | **æå‡** |
| **ç”¨æˆ·æ»¡æ„åº¦** | åŸºå‡† | **+46%** | **æå‡** |
| **æŸ¥è¯¢æ€§èƒ½** | 2 ç§’ | **< 200ms** | **90%** â¬‡ï¸ |
| **æ’­æ”¾æ—¶é•¿** | åŸºå‡† | **+42%** | **æå‡** |

### 5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**éŸ³ä¹æ¨èæŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | æ¨èå‡†ç¡®ç‡ | ç”¨æˆ·æ»¡æ„åº¦ | æ’­æ”¾æ—¶é•¿ | æŸ¥è¯¢æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- |
| **çƒ­é—¨æ¨è** | åŸºå‡† | åŸºå‡† | åŸºå‡† | åŸºå‡† | å°è§„æ¨¡ |
| **ååŒè¿‡æ»¤** | +30% | +25% | +20% | +200% | ä¸­ç­‰è§„æ¨¡ |
| **æ™ºèƒ½æ¨è** | **+50%** | **+46%** | **+42%** | **+900%** | **å¤§è§„æ¨¡** |

**æ¨èç®—æ³•å¯¹æ¯”**:

| æ¨èç®—æ³• | å‡†ç¡®ç‡ | å®æ—¶æ€§ | å¯æ‰©å±•æ€§ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- |
| **å†…å®¹æ¨è** | 70-80% | é«˜ | ä¸­ | ç®€å•åœºæ™¯ |
| **ååŒè¿‡æ»¤** | 75-85% | ä¸­ | ä¸­ | ä¸­ç­‰åœºæ™¯ |
| **æ··åˆæ¨è** | **85-95%** | **é«˜** | **é«˜** | **å¤æ‚åœºæ™¯** |

## 6. æœ€ä½³å®è·µ

### 6.1 ä¸ªæ€§åŒ–æ¨è

1. **æ’­æ”¾å†å²**: åˆ†æç”¨æˆ·æ’­æ”¾å†å²
2. **åå¥½æ›´æ–°**: æŒç»­æ›´æ–°ç”¨æˆ·åå¥½
3. **å¤šæ ·æ€§**: ä¿è¯æ¨èå¤šæ ·æ€§

### 6.2 ç›¸ä¼¼åº¦åŒ¹é…

1. **ç‰¹å¾æå–**: å‡†ç¡®æå–éŸ³é¢‘ç‰¹å¾
2. **å‘é‡è´¨é‡**: ç¡®ä¿éŸ³ä¹å‘é‡è´¨é‡
3. **æŒç»­ä¼˜åŒ–**: æŒç»­ä¼˜åŒ–æ¨èç®—æ³•

## 7. å‚è€ƒèµ„æ–™

- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](../ç”µå•†åœºæ™¯/ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)
- [å†…å®¹æ¨èç³»ç»Ÿ](../åª’ä½“åœºæ™¯/å†…å®¹æ¨èç³»ç»Ÿ.md)

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 éŸ³ä¹å‘é‡è¡¨åˆ›å»º

**åˆ›å»ºéŸ³ä¹æ¨èç³»ç»Ÿæ•°æ®è¡¨**ï¼š

```sql
-- å¯ç”¨pgvectoræ‰©å±•
CREATE EXTENSION IF NOT EXISTS vector;

-- åˆ›å»ºéŸ³ä¹è¡¨
CREATE TABLE songs (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    artist TEXT,
    album TEXT,
    genre TEXT,
    audio_vector vector(512),  -- éŸ³é¢‘ç‰¹å¾å‘é‡
    genre_vector vector(256),  -- é£æ ¼ç‰¹å¾å‘é‡
    duration INTEGER,  -- æ—¶é•¿ï¼ˆç§’ï¼‰
    release_date DATE,
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·æ’­æ”¾å†å²è¡¨
CREATE TABLE user_play_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    song_id INTEGER REFERENCES songs(id),
    play_count INTEGER DEFAULT 1,
    last_played_at TIMESTAMPTZ DEFAULT NOW(),
    rating INTEGER,  -- 1-5æ˜Ÿè¯„åˆ†
    metadata JSONB DEFAULT '{}'::JSONB
);

-- åˆ›å»ºç”¨æˆ·åå¥½å‘é‡è¡¨
CREATE TABLE user_preferences (
    user_id INTEGER PRIMARY KEY REFERENCES users(id),
    preference_vector vector(512),  -- ç”¨æˆ·åå¥½å‘é‡
    favorite_genres TEXT[],
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_songs_audio_vector ON songs USING hnsw (audio_vector vector_cosine_ops);
CREATE INDEX idx_songs_genre_vector ON songs USING hnsw (genre_vector vector_cosine_ops);
CREATE INDEX idx_user_preferences_vector ON user_preferences USING hnsw (preference_vector vector_cosine_ops);
CREATE INDEX idx_user_play_history_user_time ON user_play_history (user_id, last_played_at DESC);
CREATE INDEX idx_user_play_history_song ON user_play_history (song_id);
```

### 8.2 ä¸ªæ€§åŒ–æ¨èå®ç°

**Pythonä¸ªæ€§åŒ–æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime

class MusicRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–éŸ³ä¹æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def update_user_preference(self, user_id: int):
        """æ›´æ–°ç”¨æˆ·åå¥½å‘é‡"""
        # è·å–ç”¨æˆ·æ’­æ”¾å†å²ï¼ˆæœ€è¿‘100é¦–ï¼‰
        self.cur.execute("""
            SELECT
                uph.song_id,
                uph.play_count,
                uph.rating,
                s.audio_vector,
                s.genre_vector
            FROM user_play_history uph
            JOIN songs s ON uph.song_id = s.id
            WHERE uph.user_id = %s
            ORDER BY uph.last_played_at DESC
            LIMIT 100
        """, (user_id,))

        play_history = self.cur.fetchall()

        if not play_history:
            return

        # è®¡ç®—åŠ æƒå¹³å‡å‘é‡
        weighted_audio_vectors = []
        for song_id, play_count, rating, audio_vector, genre_vector in play_history:
            if audio_vector is None:
                continue

            # æƒé‡ = æ’­æ”¾æ¬¡æ•° * è¯„åˆ†ï¼ˆå¦‚æœæœ‰ï¼‰
            weight = play_count
            if rating:
                weight *= (rating / 5.0)  # è¯„åˆ†æƒé‡

            weighted_audio_vectors.append(np.array(audio_vector) * weight)

        if not weighted_audio_vectors:
            return

        # è®¡ç®—ç”¨æˆ·åå¥½å‘é‡
        user_preference_vector = np.mean(weighted_audio_vectors, axis=0)

        # è·å–ç”¨æˆ·å–œæ¬¢çš„é£æ ¼
        self.cur.execute("""
            SELECT genre, COUNT(*) as count
            FROM user_play_history uph
            JOIN songs s ON uph.song_id = s.id
            WHERE uph.user_id = %s
              AND uph.rating >= 4
            GROUP BY genre
            ORDER BY count DESC
            LIMIT 5
        """, (user_id,))

        favorite_genres = [row[0] for row in self.cur.fetchall()]

        # æ›´æ–°ç”¨æˆ·åå¥½
        self.cur.execute("""
            INSERT INTO user_preferences (user_id, preference_vector, favorite_genres, updated_at)
            VALUES (%s, %s, %s, %s)
            ON CONFLICT (user_id)
            DO UPDATE SET
                preference_vector = EXCLUDED.preference_vector,
                favorite_genres = EXCLUDED.favorite_genres,
                updated_at = EXCLUDED.updated_at
        """, (user_id, user_preference_vector.tolist(), favorite_genres, datetime.now()))

        self.conn.commit()

    def recommend_personalized(self, user_id: int, limit: int = 20) -> List[Dict]:
        """ä¸ªæ€§åŒ–æ¨è"""
        # æ›´æ–°ç”¨æˆ·åå¥½
        self.update_user_preference(user_id)

        # è·å–ç”¨æˆ·åå¥½å‘é‡
        self.cur.execute("""
            SELECT preference_vector, favorite_genres
            FROM user_preferences
            WHERE user_id = %s
        """, (user_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        preference_vector = result[0]
        favorite_genres = result[1] or []

        # æŸ¥æ‰¾ç›¸ä¼¼éŸ³ä¹ï¼ˆæ’é™¤å·²æ’­æ”¾è¿‡çš„ï¼‰
        self.cur.execute("""
            SELECT
                s.id,
                s.title,
                s.artist,
                s.album,
                s.genre,
                s.duration,
                1 - (s.audio_vector <=> %s) AS similarity
            FROM songs s
            WHERE s.audio_vector <=> %s < 0.7
              AND s.id NOT IN (
                  SELECT DISTINCT song_id
                  FROM user_play_history
                  WHERE user_id = %s
              )
            ORDER BY s.audio_vector <=> %s
            LIMIT %s
        """, (
            preference_vector,
            preference_vector,
            user_id,
            preference_vector,
            limit
        ))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'title': row[1],
                'artist': row[2],
                'album': row[3],
                'genre': row[4],
                'duration': row[5],
                'similarity': float(row[6])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
recommender = MusicRecommender("host=localhost dbname=testdb user=postgres password=secret")

# ä¸ªæ€§åŒ–æ¨è
recommendations = recommender.recommend_personalized(user_id=1, limit=20)
for rec in recommendations:
    print(f"{rec['title']} - {rec['artist']}: similarity={rec['similarity']:.4f}")
```

### 8.3 ç›¸ä¼¼éŸ³ä¹æ¨èå®ç°

**Pythonç›¸ä¼¼éŸ³ä¹æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict

class SimilarMusicRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–ç›¸ä¼¼éŸ³ä¹æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def find_similar_songs(self, song_id: int, limit: int = 20) -> List[Dict]:
        """æŸ¥æ‰¾ç›¸ä¼¼éŸ³ä¹"""
        # è·å–æ­Œæ›²å‘é‡
        self.cur.execute("""
            SELECT audio_vector, genre_vector, title, artist
            FROM songs
            WHERE id = %s
        """, (song_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        audio_vector = result[0]
        genre_vector = result[1]
        song_title = result[2]
        song_artist = result[3]

        # æŸ¥æ‰¾ç›¸ä¼¼éŸ³ä¹ï¼ˆç»“åˆéŸ³é¢‘å‘é‡å’Œé£æ ¼å‘é‡ï¼‰
        self.cur.execute("""
            SELECT
                id,
                title,
                artist,
                album,
                genre,
                duration,
                1 - (audio_vector <=> %s) AS audio_similarity,
                1 - (genre_vector <=> %s) AS genre_similarity,
                (1 - (audio_vector <=> %s)) * 0.7 +
                (1 - (genre_vector <=> %s)) * 0.3 AS combined_similarity
            FROM songs
            WHERE id != %s
              AND audio_vector <=> %s < 0.6
            ORDER BY combined_similarity DESC
            LIMIT %s
        """, (
            audio_vector,
            genre_vector,
            audio_vector,
            genre_vector,
            song_id,
            audio_vector,
            limit
        ))

        similar_songs = []
        for row in self.cur.fetchall():
            similar_songs.append({
                'id': row[0],
                'title': row[1],
                'artist': row[2],
                'album': row[3],
                'genre': row[4],
                'duration': row[5],
                'audio_similarity': float(row[6]),
                'genre_similarity': float(row[7]),
                'combined_similarity': float(row[8])
            })

        return similar_songs

    def recommend_by_genre(self, genre: str, limit: int = 20) -> List[Dict]:
        """æŒ‰é£æ ¼æ¨èéŸ³ä¹"""
        self.cur.execute("""
            SELECT
                id,
                title,
                artist,
                album,
                genre,
                duration
            FROM songs
            WHERE genre = %s
            ORDER BY RANDOM()
            LIMIT %s
        """, (genre, limit))

        songs = []
        for row in self.cur.fetchall():
            songs.append({
                'id': row[0],
                'title': row[1],
                'artist': row[2],
                'album': row[3],
                'genre': row[4],
                'duration': row[5]
            })

        return songs

# ä½¿ç”¨ç¤ºä¾‹
similar_recommender = SimilarMusicRecommender("host=localhost dbname=testdb user=postgres password=secret")

# æŸ¥æ‰¾ç›¸ä¼¼éŸ³ä¹
similar_songs = similar_recommender.find_similar_songs(song_id=1, limit=20)
for song in similar_songs:
    print(f"{song['title']} - {song['artist']}: similarity={song['combined_similarity']:.4f}")

# æŒ‰é£æ ¼æ¨è
genre_songs = similar_recommender.recommend_by_genre('Pop', limit=20)
for song in genre_songs:
    print(f"{song['title']} - {song['artist']}")
```

### 8.4 æ’­æ”¾å†å²ç®¡ç†å®ç°

**Pythonæ’­æ”¾å†å²ç®¡ç†**ï¼š

```python
import psycopg2
from datetime import datetime
from typing import Optional

class PlayHistoryManager:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–æ’­æ”¾å†å²ç®¡ç†å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def record_play(self, user_id: int, song_id: int, rating: Optional[int] = None):
        """è®°å½•æ’­æ”¾å†å²"""
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        self.cur.execute("""
            SELECT id, play_count
            FROM user_play_history
            WHERE user_id = %s AND song_id = %s
        """, (user_id, song_id))

        existing = self.cur.fetchone()

        if existing:
            # æ›´æ–°æ’­æ”¾æ¬¡æ•°å’Œæœ€åæ’­æ”¾æ—¶é—´
            self.cur.execute("""
                UPDATE user_play_history
                SET play_count = play_count + 1,
                    last_played_at = %s,
                    rating = COALESCE(%s, rating)
                WHERE id = %s
            """, (datetime.now(), rating, existing[0]))
        else:
            # æ’å…¥æ–°è®°å½•
            self.cur.execute("""
                INSERT INTO user_play_history
                (user_id, song_id, play_count, last_played_at, rating)
                VALUES (%s, %s, 1, %s, %s)
            """, (user_id, song_id, datetime.now(), rating))

        self.conn.commit()

    def get_user_play_history(self, user_id: int, limit: int = 50) -> List[Dict]:
        """è·å–ç”¨æˆ·æ’­æ”¾å†å²"""
        self.cur.execute("""
            SELECT
                uph.id,
                uph.song_id,
                s.title,
                s.artist,
                s.genre,
                uph.play_count,
                uph.rating,
                uph.last_played_at
            FROM user_play_history uph
            JOIN songs s ON uph.song_id = s.id
            WHERE uph.user_id = %s
            ORDER BY uph.last_played_at DESC
            LIMIT %s
        """, (user_id, limit))

        history = []
        for row in self.cur.fetchall():
            history.append({
                'id': row[0],
                'song_id': row[1],
                'title': row[2],
                'artist': row[3],
                'genre': row[4],
                'play_count': row[5],
                'rating': row[6],
                'last_played_at': row[7]
            })

        return history

    def get_user_favorite_songs(self, user_id: int, limit: int = 20) -> List[Dict]:
        """è·å–ç”¨æˆ·å–œæ¬¢çš„éŸ³ä¹"""
        self.cur.execute("""
            SELECT
                uph.song_id,
                s.title,
                s.artist,
                s.genre,
                uph.play_count,
                uph.rating
            FROM user_play_history uph
            JOIN songs s ON uph.song_id = s.id
            WHERE uph.user_id = %s
              AND (uph.rating >= 4 OR uph.play_count >= 5)
            ORDER BY uph.rating DESC, uph.play_count DESC
            LIMIT %s
        """, (user_id, limit))

        favorites = []
        for row in self.cur.fetchall():
            favorites.append({
                'song_id': row[0],
                'title': row[1],
                'artist': row[2],
                'genre': row[3],
                'play_count': row[4],
                'rating': row[5]
            })

        return favorites

# ä½¿ç”¨ç¤ºä¾‹
history_manager = PlayHistoryManager("host=localhost dbname=testdb user=postgres password=secret")

# è®°å½•æ’­æ”¾
history_manager.record_play(user_id=1, song_id=1, rating=5)
history_manager.record_play(user_id=1, song_id=2)

# è·å–æ’­æ”¾å†å²
history = history_manager.get_user_play_history(user_id=1, limit=20)
for item in history:
    print(f"{item['title']} - {item['artist']}: {item['play_count']} plays, rating={item['rating']}")

# è·å–å–œæ¬¢çš„éŸ³ä¹
favorites = history_manager.get_user_favorite_songs(user_id=1, limit=20)
for fav in favorites:
    print(f"Favorite: {fav['title']} - {fav['artist']}")
```

### 8.5 æ’­æ”¾åˆ—è¡¨ç”Ÿæˆå®ç°

**Pythonæ’­æ”¾åˆ—è¡¨ç”Ÿæˆ**ï¼š

```python
import psycopg2
from typing import List, Dict
import random

class PlaylistGenerator:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨ç”Ÿæˆå™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()
        self.recommender = MusicRecommender(conn_str)

    def generate_personalized_playlist(self, user_id: int, playlist_name: str,
                                      song_count: int = 30) -> Dict:
        """ç”Ÿæˆä¸ªæ€§åŒ–æ’­æ”¾åˆ—è¡¨"""
        # è·å–æ¨èéŸ³ä¹
        recommendations = self.recommender.recommend_personalized(user_id, limit=song_count)

        if not recommendations:
            return {'playlist_name': playlist_name, 'songs': []}

        # åˆ›å»ºæ’­æ”¾åˆ—è¡¨
        playlist = {
            'playlist_name': playlist_name,
            'user_id': user_id,
            'song_count': len(recommendations),
            'songs': recommendations
        }

        return playlist

    def generate_similar_playlist(self, song_id: int, playlist_name: str,
                                  song_count: int = 30) -> Dict:
        """åŸºäºç›¸ä¼¼éŸ³ä¹ç”Ÿæˆæ’­æ”¾åˆ—è¡¨"""
        similar_recommender = SimilarMusicRecommender(self.conn.get_dsn())
        similar_songs = similar_recommender.find_similar_songs(song_id, limit=song_count)

        playlist = {
            'playlist_name': playlist_name,
            'base_song_id': song_id,
            'song_count': len(similar_songs),
            'songs': similar_songs
        }

        return playlist

    def generate_genre_playlist(self, genre: str, playlist_name: str,
                                song_count: int = 30) -> Dict:
        """æŒ‰é£æ ¼ç”Ÿæˆæ’­æ”¾åˆ—è¡¨"""
        similar_recommender = SimilarMusicRecommender(self.conn.get_dsn())
        genre_songs = similar_recommender.recommend_by_genre(genre, limit=song_count)

        playlist = {
            'playlist_name': playlist_name,
            'genre': genre,
            'song_count': len(genre_songs),
            'songs': genre_songs
        }

        return playlist

# ä½¿ç”¨ç¤ºä¾‹
playlist_generator = PlaylistGenerator("host=localhost dbname=testdb user=postgres password=secret")

# ç”Ÿæˆä¸ªæ€§åŒ–æ’­æ”¾åˆ—è¡¨
personalized_playlist = playlist_generator.generate_personalized_playlist(
    user_id=1,
    playlist_name='æˆ‘çš„æ¨è',
    song_count=30
)
print(f"Playlist: {personalized_playlist['playlist_name']}, {personalized_playlist['song_count']} songs")

# ç”Ÿæˆç›¸ä¼¼éŸ³ä¹æ’­æ”¾åˆ—è¡¨
similar_playlist = playlist_generator.generate_similar_playlist(
    song_id=1,
    playlist_name='ç›¸ä¼¼éŸ³ä¹',
    song_count=30
)
print(f"Similar Playlist: {similar_playlist['playlist_name']}, {similar_playlist['song_count']} songs")
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-37-01
