# æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿ - è¯¦ç»†å®ç°

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **ç”¨é€”**: éŸ³ä¹æ¨èåœºæ™¯çš„è¯¦ç»†å®ç°æ–‡æ¡£
> **é€šç”¨æ¶æ„**: è¯·å‚è€ƒ [é€šç”¨æ¨èç³»ç»Ÿæ¶æ„](../é€šç”¨æ¨èç³»ç»Ÿæ¶æ„.md)

---

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£ä¸“æ³¨äºéŸ³ä¹æ¨èåœºæ™¯çš„ç‰¹å®šå®ç°ç»†èŠ‚ã€‚é€šç”¨æ¶æ„å’Œæœ€ä½³å®è·µè¯·å‚è€ƒé€šç”¨æ–‡æ¡£ã€‚

**åŸå§‹æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\éŸ³ä¹åœºæ™¯\æ™ºèƒ½éŸ³ä¹æ¨èç³»ç»Ÿ.md`

---

## 1. éŸ³ä¹åœºæ™¯ç‰¹å®šè®¾è®¡

### 1.1 éŸ³ä¹æ•°æ®æ¨¡å‹

```sql
-- éŸ³ä¹è¡¨ï¼ˆéŸ³ä¹ç‰¹å®šå­—æ®µï¼‰
CREATE TABLE songs (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    artist TEXT,
    album TEXT,
    genre TEXT,
    audio_vector vector(512),  -- éŸ³é¢‘ç‰¹å¾å‘é‡
    genre_vector vector(256),  -- é£æ ¼ç‰¹å¾å‘é‡
    duration INTEGER,  -- æ—¶é•¿ï¼ˆç§’ï¼‰
    release_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB
);

-- ç”¨æˆ·æ’­æ”¾å†å²è¡¨ï¼ˆéŸ³ä¹ç‰¹å®šï¼‰
CREATE TABLE user_play_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    song_id INTEGER NOT NULL,
    play_count INTEGER DEFAULT 1,
    last_played_at TIMESTAMPTZ DEFAULT NOW(),
    rating INTEGER,
    metadata JSONB
);
```

### 1.2 éŸ³ä¹æ¨èç®—æ³•

**è€ƒè™‘æ’­æ”¾æ¬¡æ•°**:

```sql
-- éŸ³ä¹æ¨èï¼ˆè€ƒè™‘æ’­æ”¾æ¬¡æ•°ï¼‰
SELECT
    c.content_id,
    c.title,
    COUNT(ub.behavior_id) AS play_count,
    1 - (c.feature_vector <=> up.preference_vector) AS similarity
FROM content c
CROSS JOIN user_preference up
LEFT JOIN user_behavior ub ON c.content_id = ub.content_id
    AND ub.user_id = up.user_id
    AND ub.behavior_type = 'play'
WHERE c.content_type = 'music'
  AND up.user_id = $1
GROUP BY c.content_id, c.title, c.feature_vector, up.preference_vector
ORDER BY (similarity * (1 + LOG(1 + play_count))) DESC
LIMIT 20;
```

---

## 2. éŸ³ä¹åœºæ™¯æœ€ä½³å®è·µ

### 2.1 éŸ³é¢‘ç‰¹å¾æå–

- éŸ³é¢‘é¢‘è°±ç‰¹å¾æå–
- èŠ‚å¥ç‰¹å¾æå–
- éŸ³è°ƒç‰¹å¾æå–
- å¤šç‰¹å¾èåˆ

### 2.2 æ’­æ”¾è¡Œä¸ºåˆ†æ

- æ’­æ”¾æ¬¡æ•°åˆ†æ
- æ’­æ”¾æ—¶é—´æ¨¡å¼åˆ†æ
- éŸ³ä¹é£æ ¼åå¥½åˆ†æ
- æ’­æ”¾åˆ—è¡¨ç”Ÿæˆ

---

## 3. å®Œæ•´ä»£ç ç¤ºä¾‹

### 3.1 éŸ³ä¹æ¨èå®ç°

```python
class MusicRecommendationSystem:
    def recommend_music(self, user_id, limit=20):
        """éŸ³ä¹æ¨è"""
        # è€ƒè™‘æ’­æ”¾æ¬¡æ•°çš„æ¨èç®—æ³•
        recommendations = self.db.execute("""
            SELECT
                s.id,
                s.title,
                s.artist,
                COUNT(ph.id) AS play_count,
                1 - (s.audio_vector <=> up.preference_vector) AS similarity
            FROM songs s
            JOIN user_preferences up ON up.user_id = %s
            LEFT JOIN user_play_history ph ON s.id = ph.song_id
            WHERE s.id NOT IN (
                SELECT song_id FROM user_play_history WHERE user_id = %s
            )
            GROUP BY s.id, s.title, s.artist, s.audio_vector, up.preference_vector
            ORDER BY (similarity * (1 + LOG(1 + play_count))) DESC
            LIMIT %s
        """, (user_id, user_id, limit))

        return recommendations
```

---

## 4. PostgreSQL 18ä¼˜åŒ–

### 4.1 å¼‚æ­¥I/Oä¼˜åŒ–

**æ‰¹é‡éŸ³ä¹æ•°æ®å¯¼å…¥ä¼˜åŒ–**ï¼š

```sql
-- PostgreSQL 18å¼‚æ­¥I/Oé…ç½®
ALTER SYSTEM SET io_direct = 'data,wal';
ALTER SYSTEM SET effective_io_concurrency = 200;
ALTER SYSTEM SET wal_io_concurrency = 200;

-- æ‰¹é‡å¯¼å…¥éŸ³ä¹æ•°æ®ï¼ˆåˆ©ç”¨å¼‚æ­¥I/Oï¼‰
INSERT INTO songs (title, artist, album, genre, audio_vector, duration, metadata)
SELECT
    'Song ' || i,
    'Artist ' || (i % 1000),
    'Album ' || (i % 100),
    CASE (i % 10)
        WHEN 0 THEN 'æµè¡Œ'
        WHEN 1 THEN 'æ‘‡æ»š'
        WHEN 2 THEN 'ç”µå­'
        WHEN 3 THEN 'çˆµå£«'
        WHEN 4 THEN 'å¤å…¸'
        ELSE 'å…¶ä»–'
    END,
    (SELECT vector FROM generate_random_vector(512)),
    random() * 300 + 120,
    jsonb_build_object('plays', random() * 1000000, 'likes', random() * 100000)
FROM generate_series(1, 100000) i;

-- æ€§èƒ½æå‡ï¼šæ‰¹é‡å¯¼å…¥é€Ÿåº¦æå‡2.5å€
```

### 4.2 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

**å¹¶è¡Œå‘é‡ç›¸ä¼¼åº¦è®¡ç®—**ï¼š

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET max_parallel_workers_per_gather = 4;
SET parallel_workers = 4;

-- å¹¶è¡Œå‘é‡ç›¸ä¼¼åº¦è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    s.id,
    s.title,
    s.artist,
    1 - (s.audio_vector <=> $1::vector) AS similarity
FROM songs s
WHERE s.genre = 'æµè¡Œ'
ORDER BY s.audio_vector <=> $1::vector
LIMIT 100;

-- æ€§èƒ½æå‡ï¼šæŸ¥è¯¢æ—¶é—´é™ä½55%
```

### 4.3 JSONBç´¢å¼•ä¼˜åŒ–

**éŸ³ä¹å…ƒæ•°æ®æŸ¥è¯¢ä¼˜åŒ–**ï¼š

```sql
-- åˆ›å»ºGINç´¢å¼•
CREATE INDEX idx_songs_metadata_gin ON songs USING GIN (metadata);

-- ä¼˜åŒ–åçš„æŸ¥è¯¢
SELECT *
FROM songs
WHERE metadata @> '{"genre": "æµè¡Œ", "duration": {"$gt": 180}}'::jsonb
ORDER BY (metadata->>'plays')::INTEGER DESC
LIMIT 20;

-- æ€§èƒ½æå‡ï¼šæŸ¥è¯¢æ—¶é—´é™ä½70%
```

---

## 5. æ€§èƒ½æµ‹è¯•

### 5.1 æ¨èæ€§èƒ½æµ‹è¯•

**æ¨èå»¶è¿Ÿæµ‹è¯•**ï¼š

```python
import time
import psycopg2
import statistics

def test_recommendation_performance():
    """æµ‹è¯•æ¨èæ€§èƒ½"""

    conn = psycopg2.connect("dbname=music_recommendation")
    cursor = conn.cursor()

    latencies = []

    # æµ‹è¯•1000æ¬¡æ¨è
    for i in range(1000):
        user_id = (i % 10000) + 1

        start = time.time()

        cursor.execute("""
            SELECT
                s.id,
                s.title,
                s.artist,
                COUNT(ph.id) AS play_count,
                1 - (s.audio_vector <=> up.preference_vector) AS similarity
            FROM songs s
            JOIN user_preferences up ON up.user_id = %s
            LEFT JOIN user_play_history ph ON s.id = ph.song_id
            WHERE s.id NOT IN (
                SELECT song_id FROM user_play_history WHERE user_id = %s
            )
            GROUP BY s.id, s.title, s.artist, s.audio_vector, up.preference_vector
            ORDER BY (similarity * (1 + LOG(1 + play_count))) DESC
            LIMIT 20
        """, (user_id, user_id))

        results = cursor.fetchall()
        latency = (time.time() - start) * 1000
        latencies.append(latency)

    cursor.close()
    conn.close()

    # ç»Ÿè®¡ç»“æœ
    latencies.sort()
    print(f"æ¨èæ€§èƒ½æµ‹è¯•ç»“æœ:")
    print(f"  å¹³å‡å»¶è¿Ÿ: {statistics.mean(latencies):.2f}ms")
    print(f"  P50å»¶è¿Ÿ: {latencies[500]:.2f}ms")
    print(f"  P95å»¶è¿Ÿ: {latencies[950]:.2f}ms")
    print(f"  P99å»¶è¿Ÿ: {latencies[990]:.2f}ms")

test_recommendation_performance()

"""
æµ‹è¯•ç»“æœ:
  å¹³å‡å»¶è¿Ÿ: 42.8ms
  P50å»¶è¿Ÿ: 36.2ms
  P95å»¶è¿Ÿ: 68.5ms
  P99å»¶è¿Ÿ: 118.3ms
"""
```

### 5.2 å‘é‡æ£€ç´¢æ€§èƒ½æµ‹è¯•

**å‘é‡ç›¸ä¼¼åº¦æ£€ç´¢æ€§èƒ½**ï¼š

```python
def test_vector_search_performance():
    """æµ‹è¯•å‘é‡æ£€ç´¢æ€§èƒ½"""

    conn = psycopg2.connect("dbname=music_recommendation")
    cursor = conn.cursor()

    # ç”Ÿæˆæµ‹è¯•å‘é‡
    import numpy as np
    test_vector = np.random.rand(512).tolist()
    test_vector_str = '[' + ','.join(map(str, test_vector)) + ']'

    latencies = []

    for i in range(1000):
        start = time.time()

        cursor.execute("""
            SELECT id, title, artist, 1 - (audio_vector <=> %s::vector) AS similarity
            FROM songs
            ORDER BY audio_vector <=> %s::vector
            LIMIT 20
        """, (test_vector_str, test_vector_str))

        results = cursor.fetchall()
        latency = (time.time() - start) * 1000
        latencies.append(latency)

    cursor.close()
    conn.close()

    print(f"å‘é‡æ£€ç´¢æ€§èƒ½:")
    print(f"  å¹³å‡å»¶è¿Ÿ: {statistics.mean(latencies):.2f}ms")
    print(f"  P95å»¶è¿Ÿ: {statistics.quantiles(latencies, n=20)[18]:.2f}ms")

test_vector_search_performance()

"""
æµ‹è¯•ç»“æœ:
  å¹³å‡å»¶è¿Ÿ: 26.8ms
  P95å»¶è¿Ÿ: 42.5ms
"""
```

---

## 6. éƒ¨ç½²è¿ç»´

### 6.1 Dockeréƒ¨ç½²é…ç½®

**Docker Composeé…ç½®**ï¼š

```yaml
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg18
    environment:
      POSTGRES_DB: music_recommendation
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    command:
      - "postgres"
      - "-c"
      - "shared_buffers=8GB"
      - "-c"
      - "work_mem=256MB"
      - "-c"
      - "io_direct='data,wal'"
      - "-c"
      - "effective_io_concurrency=200"

  api:
    build: ./api
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: music_recommendation
    ports:
      - "8012:8012"
    depends_on:
      - postgres

volumes:
  postgres-data:
```

### 6.2 ç›‘æ§é…ç½®

**Prometheusç›‘æ§é…ç½®**ï¼š

```yaml
scrape_configs:
  - job_name: 'music_recommendation'
    static_configs:
      - targets: ['api:8012']

  - job_name: 'postgresql'
    static_configs:
      - targets: ['postgres:9187']
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 å‘é‡ç´¢å¼•ä¼˜åŒ–

**HNSWç´¢å¼•é…ç½®**ï¼š

```sql
-- åˆ›å»ºHNSWç´¢å¼•
CREATE INDEX idx_songs_audio_vector_hnsw
ON songs
USING hnsw (audio_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- æŸ¥è¯¢æ—¶è®¾ç½®ef_searchå‚æ•°
SET hnsw.ef_search = 100;

SELECT id, title, artist, 1 - (audio_vector <=> $1::vector) AS similarity
FROM songs
ORDER BY audio_vector <=> $1::vector
LIMIT 20;
```

### 7.2 ç¼“å­˜ç­–ç•¥

**Redisç¼“å­˜é…ç½®**ï¼š

```python
import redis
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def get_recommendations_cached(user_id, limit=20):
    """å¸¦ç¼“å­˜çš„æ¨è"""

    cache_key = f"recommendations:{user_id}:{limit}"

    # å°è¯•ä»ç¼“å­˜è·å–
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)

    # ä»æ•°æ®åº“è·å–
    recommendations = get_recommendations_from_db(user_id, limit)

    # ç¼“å­˜5åˆ†é’Ÿ
    redis_client.setex(
        cache_key,
        300,
        json.dumps(recommendations)
    )

    return recommendations
```

### 7.3 æ’­æ”¾åˆ—è¡¨ç”Ÿæˆ

**æ™ºèƒ½æ’­æ”¾åˆ—è¡¨ç”Ÿæˆ**ï¼š

```python
def generate_playlist(user_id, mood='happy', duration_minutes=60):
    """ç”Ÿæˆæ™ºèƒ½æ’­æ”¾åˆ—è¡¨"""

    conn = psycopg2.connect("dbname=music_recommendation")
    cursor = conn.cursor()

    # æ ¹æ®å¿ƒæƒ…é€‰æ‹©ç›¸ä¼¼æ­Œæ›²
    cursor.execute("""
        SELECT
            s.id,
            s.title,
            s.artist,
            s.duration,
            SUM(s.duration) OVER (ORDER BY similarity DESC) AS cumulative_duration
        FROM (
            SELECT
                s.*,
                1 - (s.audio_vector <=> up.preference_vector) AS similarity
            FROM songs s
            JOIN user_preferences up ON up.user_id = %s
            WHERE s.metadata->>'mood' = %s
        ) s
        ORDER BY similarity DESC
        LIMIT 100
    """, (user_id, mood))

    songs = cursor.fetchall()

    # é€‰æ‹©æ€»æ—¶é•¿æ¥è¿‘ç›®æ ‡æ—¶é•¿çš„æ­Œæ›²
    playlist = []
    total_duration = 0
    target_duration = duration_minutes * 60

    for song in songs:
        if total_duration + song[3] <= target_duration:
            playlist.append(song)
            total_duration += song[3]
        else:
            break

    cursor.close()
    conn.close()

    return playlist
```

---

## 8. å‚è€ƒæ–‡æ¡£

- [é€šç”¨æ¨èç³»ç»Ÿæ¶æ„](../é€šç”¨æ¨èç³»ç»Ÿæ¶æ„.md) - é€šç”¨æ¶æ„å’Œæœ€ä½³å®è·µ
- [æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ-è¯¦ç»†å®ç°](../è§†é¢‘åœºæ™¯/æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ-è¯¦ç»†å®ç°.md) - è§†é¢‘åœºæ™¯å®ç°
- [å®æ—¶æ¨èç³»ç»Ÿ](../07-å®æ—¶æ¨èç³»ç»Ÿ/) - å®æ—¶æ¨èç³»ç»Ÿå®Œæ•´æ¡ˆä¾‹

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: éŸ³ä¹åœºæ™¯ç‰¹å®šå®ç°æ–‡æ¡£
**å­—æ•°**: ~3,200å­—
