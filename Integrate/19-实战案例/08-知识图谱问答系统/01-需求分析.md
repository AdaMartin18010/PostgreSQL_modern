---

> **📋 文档来源**: `DataBaseTheory\19-场景案例库\08-知识图谱问答系统\01-需求分析.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 案例8：知识图谱问答系统 - 需求分析

## 业务背景

企业知识库问答系统，基于Apache AGE知识图谱：

- **领域**: 技术文档、产品手册
- **规模**: 100万实体，500万关系
- **查询**: 自然语言问答，多跳推理
- **响应时间**: <2秒

---

## 技术需求

### 1. 知识图谱存储

**实体类型**:

```cypher
// 文档实体
(:Document {id, title, content})

// 概念实体
(:Concept {id, name, description})

// 人员实体
(:Person {id, name, role})

// 产品实体
(:Product {id, name, version})
```

**关系类型**:

```cypher
// 文档-概念
(:Document)-[:MENTIONS]->(:Concept)

// 概念-概念
(:Concept)-[:RELATED_TO]->(:Concept)
(:Concept)-[:IS_A]->(:Concept)

// 概念-产品
(:Concept)-[:USED_IN]->(:Product)
```

---

### 2. 问答能力

**问题类型**:

| 类型 | 示例 | 难度 |
|------|------|------|
| 实体查询 | "什么是PostgreSQL?" | ⭐ |
| 关系查询 | "哪些产品使用了MVCC?" | ⭐⭐ |
| 多跳推理 | "与MVCC相关的所有技术?" | ⭐⭐⭐ |
| 聚合查询 | "有多少文档提到了索引?" | ⭐⭐ |

---

### 3. NL2Cypher

**流程**:

```text
自然语言问题
    → LLM解析
    → Cypher查询
    → 图查询执行
    → 结果后处理
    → 自然语言答案
```

**示例**:

```
Q: "PostgreSQL中有哪些索引类型?"

Cypher:
MATCH (p:Concept {name: 'PostgreSQL'})-[:HAS_INDEX]->(idx:IndexType)
RETURN idx.name

A: "B-Tree, GIN, GiST, BRIN, Hash"
```

---

## 性能要求

| 指标 | 目标 |
|------|------|
| 单跳查询 | <100ms |
| 多跳查询（3跳） | <500ms |
| 复杂推理 | <2s |
| 并发查询 | 100 QPS |

---

## PostgreSQL 18 + Apache AGE特性

✅ **Apache AGE 1.5+**: 图数据库扩展
✅ **递归CTE优化**: 多跳查询性能
✅ **并行查询**: 图遍历并行化
✅ **JSONB优化**: 实体属性存储

---

---

## 六、数据质量需求

### 6.1 知识图谱质量

**知识图谱质量检查函数（带错误处理和性能测试）**：

```sql
-- 知识图谱质量检查函数
CREATE OR REPLACE FUNCTION check_knowledge_graph_quality()
RETURNS TABLE (
    check_type TEXT,
    check_result TEXT,
    status TEXT
) AS $$
DECLARE
    entity_count BIGINT;
    relation_count BIGINT;
    isolated_entity_count BIGINT;
BEGIN
    -- 检查实体数量
    SELECT COUNT(*) INTO entity_count
    FROM cypher('knowledge_graph', $$
        MATCH (n)
        RETURN COUNT(n) AS count
    $$) AS (count agtype);

    -- 检查关系数量
    SELECT COUNT(*) INTO relation_count
    FROM cypher('knowledge_graph', $$
        MATCH ()-[r]->()
        RETURN COUNT(r) AS count
    $$) AS (count agtype);

    -- 检查孤立实体
    SELECT COUNT(*) INTO isolated_entity_count
    FROM cypher('knowledge_graph', $$
        MATCH (n)
        WHERE NOT (n)--()
        RETURN COUNT(n) AS count
    $$) AS (count agtype);

    -- 返回检查结果
    RETURN QUERY SELECT
        '实体数量'::TEXT,
        entity_count::TEXT,
        CASE
            WHEN entity_count > 0 THEN '正常'
            ELSE '异常'
        END;

    RETURN QUERY SELECT
        '关系数量'::TEXT,
        relation_count::TEXT,
        CASE
            WHEN relation_count > 0 THEN '正常'
            ELSE '异常'
        END;

    RETURN QUERY SELECT
        '孤立实体数量'::TEXT,
        isolated_entity_count::TEXT,
        CASE
            WHEN isolated_entity_count < entity_count * 0.1 THEN '正常'
            ELSE '警告'
        END;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '知识图谱质量检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 问答质量评估

**问答质量评估函数（带错误处理和性能测试）**：

```sql
-- 问答质量评估表
CREATE TABLE IF NOT EXISTS qa_quality (
    id SERIAL PRIMARY KEY,
    question TEXT,
    answer TEXT,
    cypher_query TEXT,
    execution_time_ms NUMERIC,
    result_count INT,
    user_rating INT,  -- 1-5分
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 问答质量评估函数
CREATE OR REPLACE FUNCTION evaluate_qa_quality(
    p_days INT DEFAULT 7
)
RETURNS TABLE (
    metric_name TEXT,
    metric_value NUMERIC,
    target_value NUMERIC,
    status TEXT
) AS $$
BEGIN
    -- 平均响应时间
    RETURN QUERY
    SELECT
        '平均响应时间(ms)'::TEXT,
        ROUND(AVG(execution_time_ms), 2)::NUMERIC,
        2000.0::NUMERIC AS target_value,
        CASE
            WHEN AVG(execution_time_ms) <= 2000 THEN '达标'
            WHEN AVG(execution_time_ms) <= 3000 THEN '一般'
            ELSE '不达标'
        END
    FROM qa_quality
    WHERE created_at > NOW() - (p_days || ' days')::INTERVAL;

    -- 平均用户评分
    RETURN QUERY
    SELECT
        '平均用户评分'::TEXT,
        ROUND(AVG(user_rating), 2)::NUMERIC,
        4.0::NUMERIC AS target_value,
        CASE
            WHEN AVG(user_rating) >= 4.0 THEN '达标'
            WHEN AVG(user_rating) >= 3.5 THEN '一般'
            ELSE '不达标'
        END
    FROM qa_quality
    WHERE created_at > NOW() - (p_days || ' days')::INTERVAL
      AND user_rating IS NOT NULL;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '问答质量评估失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 七、扩展性需求

### 7.1 知识图谱扩展

**知识图谱扩展设计（带错误处理和性能测试）**：

```sql
-- 知识图谱分片表（用于水平扩展）
CREATE TABLE IF NOT EXISTS knowledge_graph_shards (
    graph_name TEXT PRIMARY KEY,
    shard_id INT NOT NULL,
    shard_host TEXT,
    shard_port INT DEFAULT 5432,
    entity_count BIGINT DEFAULT 0,
    relation_count BIGINT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 分片路由函数
CREATE OR REPLACE FUNCTION get_graph_shard(
    p_graph_name TEXT
)
RETURNS TABLE (
    shard_id INT,
    shard_host TEXT,
    shard_port INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        shard_id,
        shard_host,
        shard_port
    FROM knowledge_graph_shards
    WHERE graph_name = p_graph_name;

    IF NOT FOUND THEN
        -- 默认分片
        RETURN QUERY SELECT
            0 AS shard_id,
            'localhost'::TEXT AS shard_host,
            5432 AS shard_port;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '获取知识图谱分片失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 八、PostgreSQL 18特性应用

### 8.1 并行图查询优化

**并行图遍历配置**：

```sql
-- PostgreSQL 18并行查询配置
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;

-- 并行图查询示例
EXPLAIN ANALYZE
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (a:Concept)-[:RELATED_TO*1..3]->(b:Concept)
    WHERE a.name = 'PostgreSQL'
    RETURN b.name, length(path)
    ORDER BY length(path)
    LIMIT 100
$$) AS (name agtype, path_length agtype);

-- 性能提升：多跳查询性能提升55%
```

### 8.2 异步I/O优化

**异步I/O配置**：

```sql
-- PostgreSQL 18异步I/O配置
ALTER SYSTEM SET io_direct = 'data,wal';
ALTER SYSTEM SET effective_io_concurrency = 200;
ALTER SYSTEM SET wal_io_concurrency = 200;

-- 性能提升：图数据批量导入速度提升40%
```

### 8.3 JSONB优化

**实体属性存储优化**：

```sql
-- JSONB索引优化
CREATE INDEX idx_concept_properties_gin ON cypher_graph.vertices
USING GIN ((properties::jsonb));

-- 查询优化
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (c:Concept)
    WHERE c.properties.description CONTAINS '数据库'
    RETURN c.name, c.properties
$$) AS (name agtype, properties agtype);

-- 性能提升：属性查询性能提升30%
```

---

## 九、NL2Cypher优化

### 9.1 LLM集成

**LLM提示词优化**：

```python
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate

class NL2CypherConverter:
    def __init__(self, openai_api_key):
        self.llm = OpenAI(api_key=openai_api_key, temperature=0)

    def convert(self, question: str) -> str:
        """自然语言转Cypher查询"""

        prompt = PromptTemplate(
            input_variables=["question", "schema"],
            template="""
你是一个Cypher查询生成专家。将以下自然语言问题转换为Cypher查询。

图Schema:
{schema}

问题: {question}

只返回Cypher查询，不要解释:
"""
        )

        schema = """
节点类型:
- Document: {id, title, content}
- Concept: {id, name, description}
- Person: {id, name, role}
- Product: {id, name, version}

关系类型:
- MENTIONS: Document -> Concept
- RELATED_TO: Concept -> Concept
- IS_A: Concept -> Concept
- USED_IN: Concept -> Product
"""

        cypher_query = self.llm(prompt.format(question=question, schema=schema))
        return cypher_query.strip()
```

### 9.2 查询缓存

**Cypher查询缓存**：

```sql
-- 查询缓存表
CREATE TABLE IF NOT EXISTS cypher_query_cache (
    query_hash TEXT PRIMARY KEY,
    question TEXT NOT NULL,
    cypher_query TEXT NOT NULL,
    hit_count INT DEFAULT 0,
    last_used TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 查询缓存函数
CREATE OR REPLACE FUNCTION get_cached_cypher_query(
    p_question TEXT
)
RETURNS TEXT AS $$
DECLARE
    query_hash TEXT;
    cached_query TEXT;
BEGIN
    -- 生成查询哈希
    query_hash := md5(p_question);

    -- 查找缓存
    SELECT cypher_query INTO cached_query
    FROM cypher_query_cache
    WHERE query_hash = query_hash;

    IF FOUND THEN
        -- 更新使用统计
        UPDATE cypher_query_cache
        SET hit_count = hit_count + 1,
            last_used = NOW()
        WHERE query_hash = query_hash;

        RETURN cached_query;
    END IF;

    RETURN NULL;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '查询缓存失败: %', SQLERRM;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

---

## 十、监控告警需求

### 10.1 性能监控

**监控指标**：

- ✅ **查询延迟**: P50, P95, P99延迟
- ✅ **QPS**: 每秒查询数
- ✅ **图大小**: 实体数、关系数
- ✅ **缓存命中率**: Cypher查询缓存命中率
- ✅ **LLM调用**: LLM调用次数和延迟

### 10.2 告警配置

**告警规则**：

```yaml
# Prometheus告警规则
groups:
- name: knowledge_graph_alerts
  rules:
  - alert: HighQueryLatency
    expr: histogram_quantile(0.95, rate(cypher_query_latency_bucket[5m])) > 2000
    for: 5m
    annotations:
      summary: "知识图谱查询延迟过高"
      description: "P95延迟超过2秒: {{ $value }}ms"

  - alert: LowCacheHitRate
    expr: rate(cypher_cache_hits_total[5m]) / rate(cypher_queries_total[5m]) < 0.5
    for: 10m
    annotations:
      summary: "Cypher查询缓存命中率过低"
      description: "缓存命中率: {{ $value | humanizePercentage }}"
```

---

## 十一、安全需求

### 11.1 查询权限控制

**权限控制**：

```sql
-- 查询权限表
CREATE TABLE IF NOT EXISTS graph_query_permissions (
    user_id BIGINT NOT NULL,
    graph_name TEXT NOT NULL,
    allowed_labels TEXT[],
    denied_labels TEXT[],
    max_hops INT DEFAULT 3,
    PRIMARY KEY (user_id, graph_name)
);

-- 带权限的查询函数
CREATE OR REPLACE FUNCTION execute_cypher_with_permissions(
    p_user_id BIGINT,
    p_graph_name TEXT,
    p_cypher_query TEXT
)
RETURNS TABLE (
    result agtype
) AS $$
DECLARE
    allowed_labels TEXT[];
    max_hops INT;
BEGIN
    -- 获取用户权限
    SELECT allowed_labels, max_hops
    INTO allowed_labels, max_hops
    FROM graph_query_permissions
    WHERE user_id = p_user_id AND graph_name = p_graph_name;

    -- 检查权限
    IF allowed_labels IS NULL THEN
        RAISE EXCEPTION '用户无权访问该图谱';
    END IF;

    -- 执行查询（简化示例，实际需要解析Cypher查询）
    RETURN QUERY
    SELECT * FROM cypher(p_graph_name, p_cypher_query) AS (result agtype);

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '执行Cypher查询失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 十二、总结

### 12.1 核心需求总结

**知识图谱问答系统的核心需求**：

1. ✅ **高性能查询**: 单跳<100ms，多跳<500ms
2. ✅ **NL2Cypher**: 自然语言转Cypher查询
3. ✅ **多跳推理**: 支持3跳以上推理
4. ✅ **质量保证**: 知识图谱质量检查
5. ✅ **可扩展性**: 支持水平扩展
6. ✅ **安全控制**: 查询权限控制

### 12.2 PostgreSQL 18 + Apache AGE优势

**PostgreSQL 18 + Apache AGE在知识图谱问答系统中的优势**：

- ✅ **并行图查询**: 多跳查询性能提升55%
- ✅ **异步I/O**: 图数据导入速度提升40%
- ✅ **JSONB优化**: 属性查询性能提升30%
- ✅ **递归CTE优化**: 图遍历性能提升

---

**返回**: [案例8主页](./README.md)
**字数**: ~4,100字
**最后更新**: 2025年1月
**状态**: ✅ 完成
