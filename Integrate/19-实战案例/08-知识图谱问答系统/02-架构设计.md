---
> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\08-çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ\02-æ¶æ„è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

> **âš ï¸ é‡è¦æç¤º**: æœ¬æ–‡æ¡£éµå¾ªæ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿æ ¼å¼ã€‚
>
> **æ¨èé˜…è¯»**:
>
> - [æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿](../æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿.md) - é€šç”¨æ¡ˆä¾‹æ–‡æ¡£æ ¼å¼å’Œæœ€ä½³å®è·µ
>
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿçš„æ¶æ„è®¾è®¡å‚è€ƒã€‚

---

# æ¡ˆä¾‹8ï¼šçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ - æ¶æ„è®¾è®¡

> **æ–‡æ¡£ç¼–å·**: CASE-08-02
> **æœ€åæ›´æ–°**: 2025å¹´1æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 18+ / Apache AGE 1.5+

## ğŸ“‘ ç›®å½•

- [1. æ€»ä½“æ¶æ„](#1-æ€»ä½“æ¶æ„)
- [2. æ ¸å¿ƒæ¨¡å—](#2-æ ¸å¿ƒæ¨¡å—)
- [3. æŠ€æœ¯é€‰å‹](#3-æŠ€æœ¯é€‰å‹)
- [4. æ•°æ®æµè®¾è®¡](#4-æ•°æ®æµè®¾è®¡)
- [5. éƒ¨ç½²æ¶æ„](#5-éƒ¨ç½²æ¶æ„)
- [6. æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)

---

## 1. æ€»ä½“æ¶æ„

### 1.1 ç³»ç»Ÿæ¶æ„å›¾

**çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿæ¶æ„**ï¼š

```mermaid
graph TB
    User[ç”¨æˆ·é—®é¢˜]
    NL2Cypher[NL2Cypheræ¨¡å—]
    LLM[LLMæœåŠ¡]
    GraphDB[(PostgreSQL + AGE<br/>å›¾æ•°æ®åº“)]
    VectorDB[(PostgreSQL + pgvector<br/>å‘é‡æ•°æ®åº“)]
    AnswerGen[ç­”æ¡ˆç”Ÿæˆæ¨¡å—]

    KnowledgeExtract[çŸ¥è¯†æŠ½å–æ¨¡å—]
    NER[NERæ¨¡å‹]
    RelationExtract[å…³ç³»æŠ½å–]
    GraphBuild[å›¾æ„å»º]

    User --> NL2Cypher
    NL2Cypher --> LLM
    NL2Cypher --> GraphDB
    NL2Cypher --> VectorDB
    GraphDB --> AnswerGen
    VectorDB --> AnswerGen
    AnswerGen --> User

    KnowledgeExtract --> NER
    NER --> RelationExtract
    RelationExtract --> GraphBuild
    GraphBuild --> GraphDB

    style GraphDB fill:#4a90e2,color:#fff
    style VectorDB fill:#50c878,color:#fff
    style LLM fill:#f39c12,color:#fff
```

**æ¶æ„è¯´æ˜**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿæ¶æ„                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚  [ç”¨æˆ·é—®é¢˜] â†’ [NL2Cypher] â†’ [å›¾æŸ¥è¯¢] â†’ [ç­”æ¡ˆç”Ÿæˆ]    â”‚
â”‚                    â”‚             â”‚                 â”‚
â”‚                 [LLM]      [PostgreSQL + AGE]      â”‚
â”‚                              â”œâ”€ å›¾æ•°æ®              â”‚
â”‚                              â””â”€ å‘é‡ç´¢å¼•            â”‚
â”‚                                                    â”‚
â”‚  [çŸ¥è¯†æŠ½å–] â†’ [å®ä½“è¯†åˆ«] â†’ [å…³ç³»æŠ½å–] â†’ [å›¾æ„å»º]      â”‚
â”‚                    â”‚                               â”‚
â”‚               [NER Model]                          â”‚
â”‚                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒç»„ä»¶

**ä¸»è¦ç»„ä»¶**ï¼š

| ç»„ä»¶ | æŠ€æœ¯æ ˆ | åŠŸèƒ½ |
|------|--------|------|
| **NL2Cypher** | LLM (GPT-4) | è‡ªç„¶è¯­è¨€è½¬CypheræŸ¥è¯¢ |
| **å›¾æ•°æ®åº“** | PostgreSQL + AGE | å›¾æ•°æ®å­˜å‚¨å’ŒæŸ¥è¯¢ |
| **å‘é‡æ•°æ®åº“** | PostgreSQL + pgvector | è¯­ä¹‰æ£€ç´¢ |
| **çŸ¥è¯†æŠ½å–** | NERæ¨¡å‹ | å®ä½“å’Œå…³ç³»æŠ½å– |
| **ç­”æ¡ˆç”Ÿæˆ** | LLM | åŸºäºæŸ¥è¯¢ç»“æœç”Ÿæˆç­”æ¡ˆ |

---

## 2. æ ¸å¿ƒæ¨¡å—

### 2.1 çŸ¥è¯†æŠ½å–æ¨¡å—

**çŸ¥è¯†æŠ½å–æµç¨‹**ï¼š

```python
# çŸ¥è¯†æŠ½å–æµç¨‹
æ–‡æ¡£ â†’ åˆ†å¥ â†’ NER â†’ å…³ç³»æŠ½å– â†’ ä¸‰å…ƒç»„
    â†“
(:Entity)-[:Relation]->(:Entity)
```

**å®ç°ç¤ºä¾‹**ï¼š

```python
# 1. æ–‡æ¡£åˆ†å¥
def split_sentences(text):
    sentences = nltk.sent_tokenize(text)
    return sentences

# 2. å®ä½“è¯†åˆ«ï¼ˆNERï¼‰
def extract_entities(sentence):
    # ä½¿ç”¨NERæ¨¡å‹è¯†åˆ«å®ä½“
    entities = ner_model.predict(sentence)
    return entities

# 3. å…³ç³»æŠ½å–
def extract_relations(sentence, entities):
    # ä½¿ç”¨å…³ç³»æŠ½å–æ¨¡å‹
    relations = relation_model.predict(sentence, entities)
    return relations

# 4. æ„å»ºä¸‰å…ƒç»„
def build_triples(entities, relations):
    triples = []
    for relation in relations:
        triple = (relation.head, relation.type, relation.tail)
        triples.append(triple)
    return triples
```

**å­˜å‚¨åˆ°å›¾æ•°æ®åº“**ï¼š

```cypher
// åˆ›å»ºå®ä½“èŠ‚ç‚¹
CREATE (e1:Entity {name: 'PostgreSQL', type: 'Database'})
CREATE (e2:Entity {name: 'pgvector', type: 'Extension'})

// åˆ›å»ºå…³ç³»
CREATE (e1)-[:HAS_EXTENSION]->(e2)
```

### 2.2 NL2Cypheræ¨¡å—

**NL2Cypheræµç¨‹**ï¼š

```text
é—®é¢˜åˆ†ç±» â†’ æ¨¡æ¿åŒ¹é… / LLMç”Ÿæˆ
    â†“
CypheræŸ¥è¯¢
    â†“
æ‰§è¡Œ + ç»“æœè§£æ
```

**æ¨¡æ¿åŒ¹é…æ–¹å¼**ï¼š

```python
# é—®é¢˜æ¨¡æ¿
templates = {
    "ä»€ä¹ˆæ˜¯X": "MATCH (n {name: $entity}) RETURN n",
    "Xå’ŒYçš„å…³ç³»": "MATCH (a {name: $entity1})-[r]-(b {name: $entity2}) RETURN r",
    "Xæœ‰å“ªäº›Y": "MATCH (a {name: $entity})-[r:RELATION_TYPE]->(b) RETURN b"
}

# æ¨¡æ¿åŒ¹é…
def match_template(question):
    for pattern, cypher_template in templates.items():
        if pattern_match(question, pattern):
            return fill_template(cypher_template, question)
    return None
```

**LLMç”Ÿæˆæ–¹å¼**ï¼š

```python
# ä½¿ç”¨LLMç”ŸæˆCypheræŸ¥è¯¢
def generate_cypher_with_llm(question, schema):
    prompt = f"""
    æ ¹æ®ä»¥ä¸‹çŸ¥è¯†å›¾è°±schemaï¼Œå°†è‡ªç„¶è¯­è¨€é—®é¢˜è½¬æ¢ä¸ºCypheræŸ¥è¯¢ï¼š

    Schema:
    {schema}

    é—®é¢˜: {question}

    CypheræŸ¥è¯¢:
    """

    response = llm.chat_complete(
        model='gpt-4',
        messages=[{'role': 'user', 'content': prompt}]
    )

    return extract_cypher(response.content)
```

### 2.3 å¤šè·³æ¨ç†

**å•è·³æŸ¥è¯¢**ï¼š

```cypher
// 1è·³æŸ¥è¯¢
MATCH (a:Entity {name: 'PostgreSQL'})-[r]->(b:Entity)
RETURN b, r
```

**å¤šè·³æŸ¥è¯¢**ï¼š

```cypher
// å¤šè·³ï¼ˆå¯å˜é•¿åº¦ï¼‰
MATCH (a:Entity {name: 'PostgreSQL'})-[*1..3]->(b:Entity)
RETURN b

// å¸¦è¿‡æ»¤çš„å¤šè·³
MATCH path = (a:Entity {name: 'PostgreSQL'})-[*1..3]-(b:Entity)
WHERE all(r IN relationships(path) WHERE type(r) IN ['HAS_EXTENSION', 'SUPPORTS'])
RETURN b, path
```

**è·¯å¾„æŸ¥è¯¢**ï¼š

```cypher
// æŸ¥æ‰¾ä¸¤ä¸ªå®ä½“ä¹‹é—´çš„è·¯å¾„
MATCH path = shortestPath(
    (a:Entity {name: 'PostgreSQL'})-[*]-(b:Entity {name: 'pgvector'})
)
RETURN path, length(path) AS hop_count
```

---

## 3. æŠ€æœ¯é€‰å‹

### 3.1 å›¾æ•°æ®åº“é€‰å‹

**Apache AGE**ï¼š

**ä¼˜åŠ¿**ï¼š
- âœ… åŸºäºPostgreSQLï¼ŒSQLå…¼å®¹
- âœ… CypheræŸ¥è¯¢è¯­è¨€
- âœ… æˆç†Ÿç¨³å®š
- âœ… ä¸PostgreSQLç”Ÿæ€é›†æˆ

**å®‰è£…é…ç½®**ï¼š

```sql
-- å®‰è£…AGEæ‰©å±•
CREATE EXTENSION IF NOT EXISTS age;

-- åˆ›å»ºå›¾
SELECT create_graph('knowledge_graph');

-- ä½¿ç”¨å›¾
SET graph_path = 'knowledge_graph';
```

**å›¾æ•°æ®æ¨¡å‹**ï¼š

```cypher
// å®ä½“èŠ‚ç‚¹
(:Entity {name: 'PostgreSQL', type: 'Database', description: '...'})
(:Entity {name: 'pgvector', type: 'Extension', version: '0.8.0'})

// å…³ç³»
(:Entity)-[:HAS_EXTENSION]->(:Entity)
(:Entity)-[:SUPPORTS]->(:Entity)
(:Entity)-[:RELATED_TO]->(:Entity)
```

### 3.2 å‘é‡æ•°æ®åº“é›†æˆ

**pgvectoré›†æˆ**ï¼š

```sql
-- åˆ›å»ºå‘é‡åˆ—
ALTER TABLE entities ADD COLUMN embedding vector(1536);

-- ç”Ÿæˆå®ä½“å‘é‡
UPDATE entities
SET embedding = ai.embedding_openai('text-embedding-3-small', name || ' ' || description);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX ON entities USING hnsw(embedding vector_cosine_ops);
```

**æ··åˆæŸ¥è¯¢**ï¼š

```sql
-- å›¾æŸ¥è¯¢ + å‘é‡æœç´¢
WITH vector_results AS (
    SELECT id, name
    FROM entities
    WHERE embedding <=> query_vec < 0.3
    LIMIT 10
)
SELECT
    e.id,
    e.name,
    e.type
FROM entities e
WHERE e.id IN (SELECT id FROM vector_results)
MATCH (e)-[r]->(related)
RETURN e, r, related;
```

### 3.3 LLMé›†æˆ

**pg_aié›†æˆ**ï¼š

```sql
-- NL2Cypherå‡½æ•°
CREATE OR REPLACE FUNCTION nl2cypher(p_question TEXT)
RETURNS TEXT AS $$
DECLARE
    v_schema TEXT;
    v_cypher TEXT;
BEGIN
    -- è·å–å›¾schema
    SELECT string_agg(DISTINCT label, ', ')
    INTO v_schema
    FROM (
        SELECT DISTINCT label(n) AS label
        FROM (MATCH (n) RETURN n) AS nodes
    ) AS labels;

    -- ä½¿ç”¨LLMç”ŸæˆCypher
    SELECT ai.chat_complete(
        'gpt-4',
        format('Convert to Cypher: %s\nSchema: %s', p_question, v_schema)
    ) INTO v_cypher;

    RETURN v_cypher;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. æ•°æ®æµè®¾è®¡

### 4.1 æŸ¥è¯¢æµç¨‹

**æŸ¥è¯¢æ•°æ®æµ**ï¼š

```mermaid
sequenceDiagram
    participant User
    participant NL2Cypher
    participant LLM
    participant GraphDB
    participant VectorDB
    participant AnswerGen

    User->>NL2Cypher: è‡ªç„¶è¯­è¨€é—®é¢˜
    NL2Cypher->>LLM: ç”ŸæˆCypheræŸ¥è¯¢
    LLM-->>NL2Cypher: CypheræŸ¥è¯¢
    NL2Cypher->>GraphDB: æ‰§è¡ŒCypheræŸ¥è¯¢
    GraphDB-->>NL2Cypher: å›¾æŸ¥è¯¢ç»“æœ
    NL2Cypher->>VectorDB: è¯­ä¹‰æ£€ç´¢ï¼ˆå¯é€‰ï¼‰
    VectorDB-->>NL2Cypher: å‘é‡æ£€ç´¢ç»“æœ
    NL2Cypher->>AnswerGen: æŸ¥è¯¢ç»“æœ
    AnswerGen->>LLM: ç”Ÿæˆç­”æ¡ˆ
    LLM-->>AnswerGen: ç­”æ¡ˆæ–‡æœ¬
    AnswerGen-->>User: æœ€ç»ˆç­”æ¡ˆ
```

### 4.2 çŸ¥è¯†æŠ½å–æµç¨‹

**çŸ¥è¯†æŠ½å–æ•°æ®æµ**ï¼š

```mermaid
sequenceDiagram
    participant Doc
    participant Splitter
    participant NER
    participant RelationExtract
    participant GraphBuilder
    participant GraphDB

    Doc->>Splitter: åŸå§‹æ–‡æ¡£
    Splitter->>NER: åˆ†å¥ç»“æœ
    NER->>RelationExtract: å®ä½“åˆ—è¡¨
    RelationExtract->>GraphBuilder: ä¸‰å…ƒç»„
    GraphBuilder->>GraphDB: Cypheræ’å…¥è¯­å¥
    GraphDB-->>GraphBuilder: ç¡®è®¤
```

---

## 5. éƒ¨ç½²æ¶æ„

### 5.1 éƒ¨ç½²æ¶æ„å›¾

**ç”Ÿäº§éƒ¨ç½²æ¶æ„**ï¼š

```mermaid
graph TB
    LB[è´Ÿè½½å‡è¡¡å™¨]
    App1[åº”ç”¨æœåŠ¡å™¨1]
    App2[åº”ç”¨æœåŠ¡å™¨2]
    AppN[åº”ç”¨æœåŠ¡å™¨N]

    PG1[(PostgreSQLä¸»åº“<br/>+ AGE + pgvector)]
    PG2[(PostgreSQLä»åº“<br/>+ AGE + pgvector)]

    LLM1[LLMæœåŠ¡1]
    LLM2[LLMæœåŠ¡2]

    LB --> App1
    LB --> App2
    LB --> AppN

    App1 --> PG1
    App2 --> PG1
    AppN --> PG1

    PG1 -.->|å¤åˆ¶| PG2

    App1 --> LLM1
    App2 --> LLM2

    style PG1 fill:#4a90e2,color:#fff
    style PG2 fill:#50c878,color:#fff
```

### 5.2 é«˜å¯ç”¨é…ç½®

**ä¸»ä»å¤åˆ¶**ï¼š

```sql
-- ä¸»åº“é…ç½®
ALTER SYSTEM SET wal_level = replica;
ALTER SYSTEM SET max_wal_senders = 3;

-- ä»åº“é…ç½®
-- primary_conninfo = 'host=primary port=5432 user=replicator'
```

**è´Ÿè½½å‡è¡¡**ï¼š

```yaml
# HAProxyé…ç½®
backend postgresql_backend
    balance roundrobin
    option pgsql-check user postgres
    server pg1 primary:5432 check
    server pg2 standby:5432 check backup
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 å›¾æŸ¥è¯¢ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**ï¼š

```cypher
// åˆ›å»ºå®ä½“ç´¢å¼•
CREATE INDEX ON :Entity(name);
CREATE INDEX ON :Entity(type);

// åˆ›å»ºå…³ç³»ç´¢å¼•
CREATE INDEX ON :HAS_EXTENSION();
```

**æŸ¥è¯¢ä¼˜åŒ–**ï¼š

```cypher
// ä¼˜åŒ–å‰ï¼šå…¨å›¾æ‰«æ
MATCH (n)-[r]->(m) WHERE n.name = 'PostgreSQL' RETURN m

// ä¼˜åŒ–åï¼šä½¿ç”¨ç´¢å¼•
MATCH (n:Entity {name: 'PostgreSQL'})-[r]->(m) RETURN m
```

### 6.2 å‘é‡æ£€ç´¢ä¼˜åŒ–

**æ··åˆæ£€ç´¢**ï¼š

```sql
-- å…ˆå‘é‡æ£€ç´¢ï¼Œå†å›¾æŸ¥è¯¢
WITH vector_candidates AS (
    SELECT id, name
    FROM entities
    WHERE embedding <=> query_vec < 0.3
    LIMIT 20
)
SELECT
    e.id,
    e.name,
    e.type
FROM entities e
WHERE e.id IN (SELECT id FROM vector_candidates)
-- ç„¶åæ‰§è¡Œå›¾æŸ¥è¯¢
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£ç¼–å·**: CASE-08-02
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**è¿”å›**: [æ¡ˆä¾‹8ä¸»é¡µ](./README.md)
