---

> **ðŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\08-çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ðŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŽŸæ–‡ä»¶ä¿æŒä¸å˜

---

> **âš ï¸ é‡è¦æç¤º**: æœ¬æ–‡æ¡£éµå¾ªæ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿æ ¼å¼ã€‚
>
> **æŽ¨èé˜…è¯»**:
> - [æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿](../æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿.md) - é€šç”¨æ¡ˆä¾‹æ–‡æ¡£æ ¼å¼å’Œæœ€ä½³å®žè·µ
>
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿçš„æ•°æ®åº“è®¾è®¡å‚è€ƒã€‚

---

# æ¡ˆä¾‹8ï¼šçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

## Apache AGEå›¾Schema

```sql
-- 1. åˆ›å»ºå›¾
SELECT create_graph('knowledge_graph');

-- 2. åˆ›å»ºé¡¶ç‚¹æ ‡ç­¾
SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Document
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Concept
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Person
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Product
$$) as (v agtype);

-- 3. åˆ›å»ºè¾¹æ ‡ç­¾
SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL MENTIONS
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL RELATED_TO
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL IS_A
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL USED_IN
$$) as (e agtype);
```

---

## è¾…åŠ©è¡¨

```sql
-- å®žä½“å‘é‡è¡¨ï¼ˆç”¨äºŽè¯­ä¹‰æœç´¢ï¼‰
CREATE TABLE entity_embeddings (
    entity_id VARCHAR(100) PRIMARY KEY,
    entity_type VARCHAR(50),
    entity_name TEXT,
    embedding vector(768),  -- BERT embedding
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_entity_embeddings_vector
ON entity_embeddings USING hnsw (embedding vector_l2_ops);

-- æŸ¥è¯¢æ—¥å¿—
CREATE TABLE query_logs (
    log_id BIGSERIAL PRIMARY KEY,
    question TEXT,
    cypher_query TEXT,
    result_count INT,
    duration_ms FLOAT,
    success BOOLEAN,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_query_logs_created ON query_logs (created_at);
```

---

## æ ¸å¿ƒæŸ¥è¯¢å‡½æ•°

```sql
-- 1. å•è·³æŸ¥è¯¢
CREATE OR REPLACE FUNCTION find_related_concepts(
    concept_name TEXT
) RETURNS TABLE (
    related_name TEXT,
    relation_type TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM cypher('knowledge_graph', $$
        MATCH (c:Concept {name: $concept_name})-[r]->(related:Concept)
        RETURN related.name AS related_name, type(r) AS relation_type
    $$, jsonb_build_object('concept_name', concept_name))
    AS (related_name TEXT, relation_type TEXT);
END;
$$ LANGUAGE plpgsql;

-- 2. å¤šè·³æŸ¥è¯¢ï¼ˆæœ€çŸ­è·¯å¾„ï¼‰
CREATE OR REPLACE FUNCTION find_shortest_path(
    start_concept TEXT,
    end_concept TEXT,
    max_depth INT DEFAULT 5
) RETURNS TEXT AS $$
DECLARE
    path_result TEXT;
BEGIN
    SELECT * INTO path_result FROM cypher('knowledge_graph', $$
        MATCH path = shortestPath((start:Concept {name: $start})-[*1..$max_depth]-(end:Concept {name: $end}))
        RETURN [n IN nodes(path) | n.name] AS path
    $$, jsonb_build_object('start', start_concept, 'end', end_concept, 'max_depth', max_depth))
    AS (path TEXT);

    RETURN path_result;
END;
$$ LANGUAGE plpgsql;

-- 3. å­å›¾æå–
CREATE OR REPLACE FUNCTION extract_subgraph(
    center_concept TEXT,
    radius INT DEFAULT 2
) RETURNS JSONB AS $$
DECLARE
    subgraph JSONB;
BEGIN
    SELECT jsonb_agg(row_to_json(t)) INTO subgraph
    FROM (
        SELECT * FROM cypher('knowledge_graph', $$
            MATCH (center:Concept {name: $center})-[r*1..$radius]-(node)
            RETURN DISTINCT node.name AS entity, labels(node) AS labels
        $$, jsonb_build_object('center', center_concept, 'radius', radius))
        AS (entity TEXT, labels TEXT[])
    ) t;

    RETURN subgraph;
END;
$$ LANGUAGE plpgsql;

-- 4. èšåˆæŸ¥è¯¢
CREATE OR REPLACE FUNCTION count_entity_relations(
    entity_name TEXT
) RETURNS TABLE (
    relation_type TEXT,
    count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM cypher('knowledge_graph', $$
        MATCH (:Concept {name: $entity})-[r]->()
        RETURN type(r) AS relation_type, count(*) AS count
        ORDER BY count DESC
    $$, jsonb_build_object('entity', entity_name))
    AS (relation_type TEXT, count BIGINT);
END;
$$ LANGUAGE plpgsql;
```

---

## æ•°æ®å¯¼å…¥ç¤ºä¾‹

```sql
-- æ‰¹é‡æ’å…¥å®žä½“
DO $$
DECLARE
    concepts TEXT[] := ARRAY['PostgreSQL', 'MVCC', 'ACID', 'Transaction', 'Index'];
    c TEXT;
BEGIN
    FOREACH c IN ARRAY concepts LOOP
        PERFORM * FROM cypher('knowledge_graph', $$
            CREATE (n:Concept {name: $name, description: 'Database concept'})
        $$, jsonb_build_object('name', c)) AS (v agtype);
    END LOOP;
END $$;

-- æ‰¹é‡æ’å…¥å…³ç³»
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (pg:Concept {name: 'PostgreSQL'}), (mvcc:Concept {name: 'MVCC'})
    CREATE (pg)-[:USES]->(mvcc)
$$) AS (e agtype);
```

---

**è¿”å›ž**: [æ¡ˆä¾‹8ä¸»é¡µ](./README.md)
