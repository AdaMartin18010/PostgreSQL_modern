---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\08-çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

> **âš ï¸ é‡è¦æç¤º**: æœ¬æ–‡æ¡£éµå¾ªæ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿æ ¼å¼ã€‚
>
> **æ¨èé˜…è¯»**:
> - [æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿](../æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿.md) - é€šç”¨æ¡ˆä¾‹æ–‡æ¡£æ ¼å¼å’Œæœ€ä½³å®è·µ
>
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿçš„æ•°æ®åº“è®¾è®¡å‚è€ƒã€‚

---

# æ¡ˆä¾‹8ï¼šçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

## Apache AGEå›¾Schema

```sql
-- 1. åˆ›å»ºå›¾
SELECT create_graph('knowledge_graph');

-- 2. åˆ›å»ºé¡¶ç‚¹æ ‡ç­¾
SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Document
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Concept
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Person
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Product
$$) as (v agtype);

-- 3. åˆ›å»ºè¾¹æ ‡ç­¾
SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL MENTIONS
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL RELATED_TO
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL IS_A
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL USED_IN
$$) as (e agtype);
```

---

## è¾…åŠ©è¡¨

```sql
-- å®ä½“å‘é‡è¡¨ï¼ˆç”¨äºè¯­ä¹‰æœç´¢ï¼‰
CREATE TABLE entity_embeddings (
    entity_id VARCHAR(100) PRIMARY KEY,
    entity_type VARCHAR(50),
    entity_name TEXT,
    embedding vector(768),  -- BERT embedding
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_entity_embeddings_vector
ON entity_embeddings USING hnsw (embedding vector_l2_ops);

-- æŸ¥è¯¢æ—¥å¿—
CREATE TABLE query_logs (
    log_id BIGSERIAL PRIMARY KEY,
    question TEXT,
    cypher_query TEXT,
    result_count INT,
    duration_ms FLOAT,
    success BOOLEAN,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_query_logs_created ON query_logs (created_at);
```

---

## æ ¸å¿ƒæŸ¥è¯¢å‡½æ•°

```sql
-- 1. å•è·³æŸ¥è¯¢
CREATE OR REPLACE FUNCTION find_related_concepts(
    concept_name TEXT
) RETURNS TABLE (
    related_name TEXT,
    relation_type TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM cypher('knowledge_graph', $$
        MATCH (c:Concept {name: $concept_name})-[r]->(related:Concept)
        RETURN related.name AS related_name, type(r) AS relation_type
    $$, jsonb_build_object('concept_name', concept_name))
    AS (related_name TEXT, relation_type TEXT);
END;
$$ LANGUAGE plpgsql;

-- 2. å¤šè·³æŸ¥è¯¢ï¼ˆæœ€çŸ­è·¯å¾„ï¼‰
CREATE OR REPLACE FUNCTION find_shortest_path(
    start_concept TEXT,
    end_concept TEXT,
    max_depth INT DEFAULT 5
) RETURNS TEXT AS $$
DECLARE
    path_result TEXT;
BEGIN
    SELECT * INTO path_result FROM cypher('knowledge_graph', $$
        MATCH path = shortestPath((start:Concept {name: $start})-[*1..$max_depth]-(end:Concept {name: $end}))
        RETURN [n IN nodes(path) | n.name] AS path
    $$, jsonb_build_object('start', start_concept, 'end', end_concept, 'max_depth', max_depth))
    AS (path TEXT);

    RETURN path_result;
END;
$$ LANGUAGE plpgsql;

-- 3. å­å›¾æå–
CREATE OR REPLACE FUNCTION extract_subgraph(
    center_concept TEXT,
    radius INT DEFAULT 2
) RETURNS JSONB AS $$
DECLARE
    subgraph JSONB;
BEGIN
    SELECT jsonb_agg(row_to_json(t)) INTO subgraph
    FROM (
        SELECT * FROM cypher('knowledge_graph', $$
            MATCH (center:Concept {name: $center})-[r*1..$radius]-(node)
            RETURN DISTINCT node.name AS entity, labels(node) AS labels
        $$, jsonb_build_object('center', center_concept, 'radius', radius))
        AS (entity TEXT, labels TEXT[])
    ) t;

    RETURN subgraph;
END;
$$ LANGUAGE plpgsql;

-- 4. èšåˆæŸ¥è¯¢
CREATE OR REPLACE FUNCTION count_entity_relations(
    entity_name TEXT
) RETURNS TABLE (
    relation_type TEXT,
    count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM cypher('knowledge_graph', $$
        MATCH (:Concept {name: $entity})-[r]->()
        RETURN type(r) AS relation_type, count(*) AS count
        ORDER BY count DESC
    $$, jsonb_build_object('entity', entity_name))
    AS (relation_type TEXT, count BIGINT);
END;
$$ LANGUAGE plpgsql;
```

---

## æ•°æ®å¯¼å…¥ç¤ºä¾‹

```sql
-- æ‰¹é‡æ’å…¥å®ä½“
DO $$
DECLARE
    concepts TEXT[] := ARRAY['PostgreSQL', 'MVCC', 'ACID', 'Transaction', 'Index'];
    c TEXT;
BEGIN
    FOREACH c IN ARRAY concepts LOOP
        PERFORM * FROM cypher('knowledge_graph', $$
            CREATE (n:Concept {name: $name, description: 'Database concept'})
        $$, jsonb_build_object('name', c)) AS (v agtype);
    END LOOP;
END $$;

-- æ‰¹é‡æ’å…¥å…³ç³»
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (pg:Concept {name: 'PostgreSQL'}), (mvcc:Concept {name: 'MVCC'})
    CREATE (pg)-[:USES]->(mvcc)
$$) AS (e agtype);
```

---

---

## 5. å‘é‡æ£€ç´¢é›†æˆ

### 5.1 å®ä½“å‘é‡åŒ–

**å®ä½“å‘é‡åŒ–å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å®ä½“å‘é‡åŒ–å‡½æ•°ï¼ˆä½¿ç”¨pg_aiï¼‰
CREATE OR REPLACE FUNCTION generate_entity_embedding(
    p_entity_name TEXT,
    p_entity_description TEXT DEFAULT NULL
)
RETURNS vector(768) AS $$
DECLARE
    v_text TEXT;
    v_embedding vector(768);
BEGIN
    -- æ„å»ºæ–‡æœ¬
    v_text := p_entity_name;
    IF p_entity_description IS NOT NULL THEN
        v_text := v_text || ' ' || p_entity_description;
    END IF;

    -- ç”Ÿæˆå‘é‡ï¼ˆä½¿ç”¨pg_aiï¼‰
    SELECT ai.embedding_openai('text-embedding-3-small', v_text)::vector(768)
    INTO v_embedding;

    -- å­˜å‚¨å‘é‡
    INSERT INTO entity_embeddings (entity_id, entity_type, entity_name, embedding)
    VALUES (p_entity_name, 'Concept', p_entity_name, v_embedding)
    ON CONFLICT (entity_id) DO UPDATE
    SET embedding = EXCLUDED.embedding,
        created_at = NOW();

    RETURN v_embedding;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å®ä½“å‘é‡åŒ–å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 æ··åˆæ£€ç´¢ï¼ˆå›¾+å‘é‡ï¼‰

**æ··åˆæ£€ç´¢å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ··åˆæ£€ç´¢å‡½æ•°ï¼ˆå›¾æŸ¥è¯¢ + å‘é‡æ£€ç´¢ï¼‰
CREATE OR REPLACE FUNCTION hybrid_search(
    p_query_text TEXT,
    p_vector_threshold FLOAT DEFAULT 0.3,
    p_graph_limit INT DEFAULT 10
)
RETURNS TABLE (
    entity_name TEXT,
    entity_type TEXT,
    similarity_score FLOAT,
    source TEXT  -- 'vector' or 'graph'
) AS $$
DECLARE
    v_query_vector vector(768);
BEGIN
    -- ç”ŸæˆæŸ¥è¯¢å‘é‡
    SELECT ai.embedding_openai('text-embedding-3-small', p_query_text)::vector(768)
    INTO v_query_vector;

    -- å‘é‡æ£€ç´¢ç»“æœ
    RETURN QUERY
    SELECT
        ee.entity_name,
        ee.entity_type,
        (1 - (ee.embedding <=> v_query_vector))::FLOAT AS similarity_score,
        'vector'::TEXT AS source
    FROM entity_embeddings ee
    WHERE ee.embedding <=> v_query_vector < p_vector_threshold
    ORDER BY ee.embedding <=> v_query_vector
    LIMIT p_graph_limit;

    -- å›¾æŸ¥è¯¢ç»“æœï¼ˆåŸºäºå‘é‡æ£€ç´¢åˆ°çš„å®ä½“ï¼‰
    RETURN QUERY
    SELECT DISTINCT
        related.name::TEXT AS entity_name,
        'Concept'::TEXT AS entity_type,
        0.8::FLOAT AS similarity_score,  -- å›¾æŸ¥è¯¢é»˜è®¤ç›¸ä¼¼åº¦
        'graph'::TEXT AS source
    FROM (
        SELECT entity_name FROM entity_embeddings
        WHERE embedding <=> v_query_vector < p_vector_threshold
        LIMIT 5
    ) AS vector_results,
    LATERAL (
        SELECT * FROM cypher('knowledge_graph', $$
            MATCH (c:Concept {name: $name})-[r]-(related:Concept)
            RETURN related.name AS name
            LIMIT 10
        $$, jsonb_build_object('name', vector_results.entity_name))
        AS (name TEXT)
    ) AS related
    WHERE related.name IS NOT NULL;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ··åˆæ£€ç´¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. NL2CypheræŸ¥è¯¢ç”Ÿæˆ

### 6.1 NL2Cypherå‡½æ•°

**NL2Cypherå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- NL2Cypherå‡½æ•°ï¼ˆä½¿ç”¨pg_aiï¼‰
CREATE OR REPLACE FUNCTION nl2cypher(
    p_question TEXT,
    p_schema_info JSONB DEFAULT NULL
)
RETURNS TEXT AS $$
DECLARE
    v_schema TEXT;
    v_prompt TEXT;
    v_cypher TEXT;
BEGIN
    -- è·å–å›¾schemaï¼ˆå¦‚æœæ²¡æœ‰æä¾›ï¼‰
    IF p_schema_info IS NULL THEN
        SELECT jsonb_agg(DISTINCT label) INTO p_schema_info
        FROM (
            SELECT * FROM cypher('knowledge_graph', $$
                MATCH (n)
                RETURN DISTINCT labels(n) AS label
            $$) AS (label TEXT[])
        ) AS labels;
    END IF;

    -- æ„å»ºprompt
    v_prompt := format('
        æ ¹æ®ä»¥ä¸‹çŸ¥è¯†å›¾è°±schemaï¼Œå°†è‡ªç„¶è¯­è¨€é—®é¢˜è½¬æ¢ä¸ºCypheræŸ¥è¯¢ï¼š

        Schema:
        %s

        é—®é¢˜: %s

        åªè¿”å›CypheræŸ¥è¯¢è¯­å¥ï¼Œä¸è¦åŒ…å«å…¶ä»–è§£é‡Šã€‚
    ', p_schema_info::TEXT, p_question);

    -- ä½¿ç”¨LLMç”ŸæˆCypheræŸ¥è¯¢
    SELECT ai.chat_complete('gpt-4', v_prompt) INTO v_cypher;

    -- æ¸…ç†è¿”å›çš„Cypherï¼ˆç§»é™¤markdownä»£ç å—æ ‡è®°ï¼‰
    v_cypher := regexp_replace(v_cypher, '```cypher\n?', '', 'g');
    v_cypher := regexp_replace(v_cypher, '```\n?', '', 'g');
    v_cypher := trim(v_cypher);

    -- è®°å½•æŸ¥è¯¢æ—¥å¿—
    INSERT INTO query_logs (question, cypher_query, success)
    VALUES (p_question, v_cypher, TRUE);

    RETURN v_cypher;

EXCEPTION
    WHEN OTHERS THEN
        -- è®°å½•å¤±è´¥æ—¥å¿—
        INSERT INTO query_logs (question, cypher_query, success)
        VALUES (p_question, NULL, FALSE);

        RAISE EXCEPTION 'NL2Cypherè½¬æ¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 CypheræŸ¥è¯¢éªŒè¯

**CypheræŸ¥è¯¢éªŒè¯å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- CypheræŸ¥è¯¢éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_cypher_query(
    p_cypher_query TEXT
)
RETURNS TABLE (
    is_valid BOOLEAN,
    error_message TEXT,
    estimated_cost NUMERIC
) AS $$
DECLARE
    v_result TEXT;
    v_error TEXT;
BEGIN
    -- å°è¯•æ‰§è¡ŒEXPLAINï¼ˆä¸å®é™…æ‰§è¡Œï¼‰
    BEGIN
        EXECUTE format('EXPLAIN %s', p_cypher_query);

        RETURN QUERY SELECT
            TRUE::BOOLEAN,
            NULL::TEXT,
            0::NUMERIC;  -- ç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è§£æEXPLAINç»“æœ

    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS v_error = MESSAGE_TEXT;

            RETURN QUERY SELECT
                FALSE::BOOLEAN,
                v_error::TEXT,
                NULL::NUMERIC;
    END;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'CypheræŸ¥è¯¢éªŒè¯å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

### 7.1 æŸ¥è¯¢ç¼“å­˜

**æŸ¥è¯¢ç¼“å­˜å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢ç¼“å­˜è¡¨
CREATE TABLE IF NOT EXISTS cypher_query_cache (
    cache_key TEXT PRIMARY KEY,
    question TEXT NOT NULL,
    cypher_query TEXT NOT NULL,
    result_cache JSONB,
    hit_count INT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

-- æŸ¥è¯¢ç¼“å­˜å‡½æ•°
CREATE OR REPLACE FUNCTION get_cached_query(
    p_question TEXT
)
RETURNS TABLE (
    cypher_query TEXT,
    result_cache JSONB,
    from_cache BOOLEAN
) AS $$
DECLARE
    cache_key_val TEXT;
    cached_query TEXT;
    cached_result JSONB;
BEGIN
    -- ç”Ÿæˆç¼“å­˜é”®
    cache_key_val := md5(p_question);

    -- æ£€æŸ¥ç¼“å­˜
    SELECT cypher_query, result_cache
    INTO cached_query, cached_result
    FROM cypher_query_cache
    WHERE cache_key = cache_key_val
      AND expires_at > NOW();

    IF cached_query IS NOT NULL THEN
        -- æ›´æ–°å‘½ä¸­æ¬¡æ•°
        UPDATE cypher_query_cache
        SET hit_count = hit_count + 1
        WHERE cache_key = cache_key_val;

        RETURN QUERY SELECT cached_query, cached_result, TRUE;
        RETURN;
    END IF;

    -- ç¼“å­˜æœªå‘½ä¸­
    RETURN QUERY SELECT NULL::TEXT, NULL::JSONB, FALSE;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢ç¼“å­˜è·å–å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 æŸ¥è¯¢æ€§èƒ½ç›‘æ§

**æŸ¥è¯¢æ€§èƒ½ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢æ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_query_performance AS
SELECT
    DATE_TRUNC('hour', created_at) AS hour,
    COUNT(*) AS total_queries,
    COUNT(*) FILTER (WHERE success) AS success_queries,
    COUNT(*) FILTER (WHERE NOT success) AS failed_queries,
    ROUND(AVG(duration_ms) FILTER (WHERE success), 2) AS avg_duration_ms,
    ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY duration_ms) FILTER (WHERE success), 2) AS p95_duration_ms,
    ROUND(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY duration_ms) FILTER (WHERE success), 2) AS p99_duration_ms,
    ROUND(AVG(result_count) FILTER (WHERE success), 2) AS avg_result_count
FROM query_logs
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY DATE_TRUNC('hour', created_at)
ORDER BY hour DESC;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_query_performance;
```

---

## 8. çŸ¥è¯†å›¾è°±ç»´æŠ¤

### 8.1 æ‰¹é‡å¯¼å…¥å‡½æ•°

**æ‰¹é‡å¯¼å…¥å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ‰¹é‡å¯¼å…¥å®ä½“å’Œå…³ç³»
CREATE OR REPLACE FUNCTION batch_import_knowledge(
    p_entities JSONB,  -- [{"name": "...", "type": "...", "properties": {...}}]
    p_relations JSONB  -- [{"from": "...", "to": "...", "type": "...", "properties": {...}}]
)
RETURNS TABLE (
    entities_imported INT,
    relations_imported INT
) AS $$
DECLARE
    entity_record JSONB;
    relation_record JSONB;
    entities_count INT := 0;
    relations_count INT := 0;
BEGIN
    -- å¯¼å…¥å®ä½“
    FOR entity_record IN SELECT * FROM jsonb_array_elements(p_entities)
    LOOP
        PERFORM * FROM cypher('knowledge_graph', $$
            CREATE (n:Concept {
                name: $name,
                type: $type,
                properties: $properties
            })
        $$, jsonb_build_object(
            'name', entity_record->>'name',
            'type', entity_record->>'type',
            'properties', COALESCE(entity_record->'properties', '{}'::jsonb)
        )) AS (v agtype);

        entities_count := entities_count + 1;
    END LOOP;

    -- å¯¼å…¥å…³ç³»
    FOR relation_record IN SELECT * FROM jsonb_array_elements(p_relations)
    LOOP
        PERFORM * FROM cypher('knowledge_graph', $$
            MATCH (from:Concept {name: $from}), (to:Concept {name: $to})
            CREATE (from)-[r:RELATED_TO {
                type: $type,
                properties: $properties
            }]->(to)
        $$, jsonb_build_object(
            'from', relation_record->>'from',
            'to', relation_record->>'to',
            'type', relation_record->>'type',
            'properties', COALESCE(relation_record->'properties', '{}'::jsonb)
        )) AS (e agtype);

        relations_count := relations_count + 1;
    END LOOP;

    RETURN QUERY SELECT entities_count, relations_count;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ‰¹é‡å¯¼å…¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**è¿”å›**: [æ¡ˆä¾‹8ä¸»é¡µ](./README.md)
