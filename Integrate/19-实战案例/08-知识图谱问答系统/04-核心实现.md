---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\08-çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ\04-æ ¸å¿ƒå®ç°.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹8ï¼šçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ - æ ¸å¿ƒå®ç°

```python
"""
çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ
æŠ€æœ¯æ ˆ: PostgreSQL 18 + Apache AGE + LangChain
"""

import psycopg2
from psycopg2.extras import RealDictCursor
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
import re

class KnowledgeGraphQA:
    """çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ"""

    def __init__(self, conn_str, openai_api_key):
        """åˆå§‹åŒ–çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰"""
        try:
            self.conn = psycopg2.connect(conn_str, cursor_factory=RealDictCursor)
            self.cursor = self.conn.cursor()
        except psycopg2.OperationalError as e:
            raise ConnectionError(f"æ•°æ®åº“è¿æ¥å¤±è´¥: {e}")
        except Exception as e:
            raise RuntimeError(f"åˆå§‹åŒ–å¤±è´¥: {e}")

        try:
            self.llm = OpenAI(api_key=openai_api_key, temperature=0)
        except Exception as e:
            raise ValueError(f"OpenAIåˆå§‹åŒ–å¤±è´¥: {e}")

        # åŠ è½½AGEæ‰©å±•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
        try:
            self.cursor.execute("LOAD 'age';")
            self.cursor.execute("SET search_path = ag_catalog, '$user', public;")
            self.conn.commit()
        except psycopg2.Error as e:
            print(f"è­¦å‘Š: åŠ è½½AGEæ‰©å±•å¤±è´¥: {e}")
            self.conn.rollback()

    def nl2cypher(self, question: str) -> str:
        """
        è‡ªç„¶è¯­è¨€è½¬CypheræŸ¥è¯¢ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†å’Œå‚æ•°éªŒè¯ï¼‰
        """
        
        # å‚æ•°éªŒè¯
        if not question or not question.strip():
            raise ValueError("questionä¸èƒ½ä¸ºç©º")

        # NL2Cypheræç¤ºè¯
        prompt = PromptTemplate(
            input_variables=["question"],
            template="""
ä½ æ˜¯ä¸€ä¸ªCypheræŸ¥è¯¢ç”Ÿæˆä¸“å®¶ã€‚å°†ä»¥ä¸‹è‡ªç„¶è¯­è¨€é—®é¢˜è½¬æ¢ä¸ºCypheræŸ¥è¯¢ã€‚

å›¾Schema:
- èŠ‚ç‚¹ç±»å‹: Document, Concept, Person, Product
- å…³ç³»ç±»å‹: MENTIONS, RELATED_TO, IS_A, USED_IN

é—®é¢˜: {question}

åªè¿”å›CypheræŸ¥è¯¢ï¼Œä¸è¦è§£é‡Š:
"""
        )

        cypher_query = self.llm(prompt.format(question=question))
        cypher_query = cypher_query.strip()

        return cypher_query

    def execute_cypher(self, cypher_query: str) -> list:
        """
        æ‰§è¡ŒCypheræŸ¥è¯¢ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†å’Œå‚æ•°éªŒè¯ï¼‰
        """
        
        # å‚æ•°éªŒè¯
        if not cypher_query or not cypher_query.strip():
            raise ValueError("cypher_queryä¸èƒ½ä¸ºç©º")

        try:
            # ä½¿ç”¨AGEæ‰§è¡ŒCypher
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    {cypher_query}
                $$) AS (result agtype);
            """)

            results = [row['result'] for row in self.cursor.fetchall()]
            return results

        except psycopg2.ProgrammingError as e:
            print(f"Cypherè¯­æ³•é”™è¯¯: {e}")
            return []
        except psycopg2.OperationalError as e:
            print(f"æ•°æ®åº“æ“ä½œé”™è¯¯: {e}")
            self.conn.rollback()
            return []
        except psycopg2.Error as e:
            print(f"æ•°æ®åº“é”™è¯¯: {e}")
            self.conn.rollback()
            return []
        except Exception as e:
            print(f"æŸ¥è¯¢æ‰§è¡Œå¤±è´¥: {e}")
            return []

    def answer_question(self, question: str) -> dict:
        """
        å›ç­”é—®é¢˜ï¼ˆå®Œæ•´æµç¨‹ï¼Œå¸¦å®Œæ•´é”™è¯¯å¤„ç†å’Œå‚æ•°éªŒè¯ï¼‰
        """
        
        # å‚æ•°éªŒè¯
        if not question or not question.strip():
            raise ValueError("questionä¸èƒ½ä¸ºç©º")

        import time
        start_time = time.time()

        try:
            # 1. é—®é¢˜åˆ†ç±»
            question_type = self._classify_question(question)

            # 2. ç”ŸæˆCypher
            try:
                if question_type == 'simple':
                    cypher_query = self._template_match(question)
                else:
                    cypher_query = self.nl2cypher(question)
            except Exception as e:
                print(f"ç”ŸæˆCypheræŸ¥è¯¢å¤±è´¥: {e}")
                cypher_query = "MATCH (n) RETURN n LIMIT 10"

            # 3. æ‰§è¡ŒæŸ¥è¯¢
            results = self.execute_cypher(cypher_query)

            # 4. ç”Ÿæˆç­”æ¡ˆ
            answer = self._generate_answer(question, results)

            duration = (time.time() - start_time) * 1000

            return {
                'question': question,
                'cypher': cypher_query,
                'raw_results': results,
                'answer': answer,
                'duration_ms': duration
            }
        except Exception as e:
            print(f"å›ç­”é—®é¢˜å¤±è´¥: {e}")
            duration = (time.time() - start_time) * 1000
            return {
                'question': question,
                'cypher': '',
                'raw_results': [],
                'answer': 'æŠ±æ­‰ï¼Œç³»ç»Ÿå‡ºç°é”™è¯¯ï¼Œè¯·ç¨åå†è¯•ã€‚',
                'duration_ms': duration,
                'error': str(e)
            }

    def _classify_question(self, question: str) -> str:
        """é—®é¢˜åˆ†ç±»"""

        # ç®€å•è§„åˆ™åˆ†ç±»
        if any(kw in question for kw in ['ä»€ä¹ˆæ˜¯', 'what is']):
            return 'simple'
        elif any(kw in question for kw in ['æœ‰å“ªäº›', 'list', 'æ‰€æœ‰']):
            return 'list'
        elif any(kw in question for kw in ['ç›¸å…³', 'related', 'å…³è”']):
            return 'relation'
        else:
            return 'complex'

    def _template_match(self, question: str) -> str:
        """æ¨¡æ¿åŒ¹é…ç”ŸæˆCypher"""

        # æå–å®ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
        entity = re.search(r'ä»€ä¹ˆæ˜¯(.+?)[\?ï¼Ÿ]', question)
        if entity:
            entity_name = entity.group(1).strip()
            return f"""
                MATCH (n:Concept {{name: '{entity_name}'}})
                RETURN n.name AS name, n.description AS description
            """

        return "MATCH (n) RETURN n LIMIT 10"

    def _generate_answer(self, question: str, results: list) -> str:
        """æ ¹æ®æŸ¥è¯¢ç»“æœç”Ÿæˆè‡ªç„¶è¯­è¨€ç­”æ¡ˆï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰"""

        if not results:
            return "æŠ±æ­‰ï¼Œæˆ‘æ²¡æœ‰æ‰¾åˆ°ç›¸å…³ä¿¡æ¯ã€‚"

        try:
            # ä½¿ç”¨LLMç”Ÿæˆç­”æ¡ˆ
            prompt = PromptTemplate(
                input_variables=["question", "results"],
                template="""
åŸºäºä»¥ä¸‹æ•°æ®å›ç­”é—®é¢˜ã€‚

é—®é¢˜: {question}

æ•°æ®: {results}

ç®€æ´å›ç­”:
"""
            )

            answer = self.llm(prompt.format(question=question, results=str(results)))
            return answer.strip()
        except Exception as e:
            print(f"LLMç”Ÿæˆç­”æ¡ˆå¤±è´¥: {e}")
            # è¿”å›åŸºäºç»“æœçš„ç®€å•ç­”æ¡ˆ
            if results:
                return f"æ ¹æ®æŸ¥è¯¢ç»“æœï¼Œæ‰¾åˆ°äº† {len(results)} æ¡ç›¸å…³ä¿¡æ¯ã€‚"
            return "æŠ±æ­‰ï¼Œæˆ‘æš‚æ—¶æ— æ³•ç”Ÿæˆç­”æ¡ˆï¼Œè¯·ç¨åå†è¯•ã€‚"

# ============================================================
# çŸ¥è¯†æŠ½å–æ¨¡å—
# ============================================================

class KnowledgeExtractor:
    """ä»æ–‡æœ¬ä¸­æŠ½å–çŸ¥è¯†"""

    def __init__(self, conn_str):
        """åˆå§‹åŒ–çŸ¥è¯†æŠ½å–å™¨ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰"""
        import psycopg2
        
        try:
            self.conn = psycopg2.connect(conn_str)
            self.cursor = self.conn.cursor()
        except psycopg2.OperationalError as e:
            raise ConnectionError(f"æ•°æ®åº“è¿æ¥å¤±è´¥: {e}")
        except Exception as e:
            raise RuntimeError(f"åˆå§‹åŒ–å¤±è´¥: {e}")

    def extract_from_document(self, doc_id: int, content: str):
        """
        ä»æ–‡æ¡£ä¸­æŠ½å–å®ä½“å’Œå…³ç³»
        """

        # 1. å®ä½“è¯†åˆ«ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”ä½¿ç”¨NERæ¨¡å‹ï¼‰
        entities = self._ner(content)

        # 2. å…³ç³»æŠ½å–
        relations = self._extract_relations(content, entities)

        # 3. å†™å…¥å›¾æ•°æ®åº“
        self._insert_to_graph(doc_id, entities, relations)

    def _ner(self, text: str) -> list:
        """å®ä½“è¯†åˆ«ï¼ˆç¤ºä¾‹ï¼‰"""
        # å®é™…åº”ä½¿ç”¨SpaCyæˆ–BERTç­‰NERæ¨¡å‹
        return [
            {'name': 'PostgreSQL', 'type': 'Concept'},
            {'name': 'MVCC', 'type': 'Concept'}
        ]

    def _extract_relations(self, text: str, entities: list) -> list:
        """å…³ç³»æŠ½å–ï¼ˆç¤ºä¾‹ï¼‰"""
        # å®é™…åº”ä½¿ç”¨å…³ç³»æŠ½å–æ¨¡å‹
        return [
            {'from': 'PostgreSQL', 'to': 'MVCC', 'type': 'USES'}
        ]

    def _insert_to_graph(self, doc_id: int, entities: list, relations: list):
        """æ’å…¥å›¾æ•°æ®åº“ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰"""
        import psycopg2

        try:
            # æ’å…¥å®ä½“
            for entity in entities:
                try:
                    self.cursor.execute(f"""
                        SELECT * FROM cypher('knowledge_graph', $$
                            MERGE (n:{entity['type']} {{name: '{entity['name']}'}})
                            RETURN n
                        $$) AS (n agtype);
                    """)
                except psycopg2.ProgrammingError as e:
                    print(f"æ’å…¥å®ä½“å¤±è´¥: {e}")
                    continue
                except Exception as e:
                    print(f"æ’å…¥å®ä½“æœªçŸ¥é”™è¯¯: {e}")
                    continue

            # æ’å…¥å…³ç³»
            for rel in relations:
                try:
                    self.cursor.execute(f"""
                        SELECT * FROM cypher('knowledge_graph', $$
                            MATCH (a {{name: '{rel['from']}'}}), (b {{name: '{rel['to']}'}})
                            MERGE (a)-[r:{rel['type']}]->(b)
                            RETURN r
                        $$) AS (r agtype);
                    """)
                except psycopg2.ProgrammingError as e:
                    print(f"æ’å…¥å…³ç³»å¤±è´¥: {e}")
                    continue
                except Exception as e:
                    print(f"æ’å…¥å…³ç³»æœªçŸ¥é”™è¯¯: {e}")
                    continue

            self.conn.commit()

# ============================================================
# FastAPIæ¥å£
# ============================================================

from fastapi import FastAPI, Query as FastAPIQuery

app = FastAPI()

qa_system = KnowledgeGraphQA(
    conn_str="dbname=knowledge_db user=postgres",
    openai_api_key="your-api-key"
)

@app.get("/api/qa")
async def ask_question(q: str = FastAPIQuery(..., description="é—®é¢˜")):
    """é—®ç­”æ¥å£ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰"""
    from fastapi import HTTPException
    import psycopg2
    
    try:
        result = qa_system.answer_question(q)
        return result
    except psycopg2.OperationalError as e:
        raise HTTPException(status_code=503, detail=f"æ•°æ®åº“è¿æ¥å¤±è´¥: {str(e)}")
    except psycopg2.Error as e:
        raise HTTPException(status_code=500, detail=f"æ•°æ®åº“æ“ä½œå¤±è´¥: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æœªçŸ¥é”™è¯¯: {str(e)}")

@app.get("/api/graph/subgraph")
async def get_subgraph(entity: str, radius: int = 2):
    """è·å–å­å›¾ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰"""
    from fastapi import HTTPException
    import psycopg2
    
    try:
        cursor = qa_system.cursor
        cursor.execute("""
            SELECT extract_subgraph(%s, %s);
        """, (entity, radius))
        subgraph = cursor.fetchone()[0]
        return {'entity': entity, 'subgraph': subgraph}
    except psycopg2.ProgrammingError as e:
        raise HTTPException(status_code=400, detail=f"æŸ¥è¯¢è¯­æ³•é”™è¯¯: {str(e)}")
    except psycopg2.OperationalError as e:
        raise HTTPException(status_code=503, detail=f"æ•°æ®åº“è¿æ¥å¤±è´¥: {str(e)}")
    except psycopg2.Error as e:
        raise HTTPException(status_code=500, detail=f"æ•°æ®åº“æ“ä½œå¤±è´¥: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"æœªçŸ¥é”™è¯¯: {str(e)}")

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8004)
```

---

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 æŸ¥è¯¢ä¼˜åŒ–

**æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
class QueryOptimizer:
    """æŸ¥è¯¢ä¼˜åŒ–å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def optimize_cypher_query(self, cypher_query: str) -> str:
        """ä¼˜åŒ–CypheræŸ¥è¯¢"""

        # 1. é™åˆ¶ç»“æœæ•°é‡
        if 'LIMIT' not in cypher_query.upper():
            cypher_query += ' LIMIT 100'

        # 2. æ·»åŠ ç´¢å¼•æç¤ºï¼ˆå¦‚æœæ”¯æŒï¼‰
        # PostgreSQL AGEä¸æ”¯æŒç´¢å¼•æç¤ºï¼Œä½†å¯ä»¥é€šè¿‡æŸ¥è¯¢é‡å†™ä¼˜åŒ–

        return cypher_query

    def cache_query_result(self, query_hash: str, result: list, ttl: int = 300):
        """ç¼“å­˜æŸ¥è¯¢ç»“æœ"""

        import json
        import redis

        redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
        redis_client.setex(
            f"kg_query:{query_hash}",
            ttl,
            json.dumps(result)
        )

    def get_cached_result(self, query_hash: str) -> list:
        """è·å–ç¼“å­˜ç»“æœ"""

        import json
        import redis

        redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
        cached = redis_client.get(f"kg_query:{query_hash}")

        if cached:
            return json.loads(cached)
        return None
```

### 4.2 æ‰¹é‡æ“ä½œä¼˜åŒ–

**æ‰¹é‡æ“ä½œä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
class BatchGraphOperations:
    """æ‰¹é‡å›¾æ“ä½œ"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()
        self.batch_size = 1000

    def batch_create_nodes(self, nodes: list):
        """æ‰¹é‡åˆ›å»ºèŠ‚ç‚¹"""

        for i in range(0, len(nodes), self.batch_size):
            batch = nodes[i:i+self.batch_size]

            # æ„å»ºæ‰¹é‡CypheræŸ¥è¯¢
            cypher_batch = []
            for node in batch:
                cypher_batch.append(f"""
                    CREATE (n:{node['label']} {self._format_properties(node['properties'])})
                """)

            # æ‰§è¡Œæ‰¹é‡åˆ›å»º
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    {' '.join(cypher_batch)}
                $$) AS (result agtype);
            """)

            self.conn.commit()

    def batch_create_edges(self, edges: list):
        """æ‰¹é‡åˆ›å»ºè¾¹"""

        for i in range(0, len(edges), self.batch_size):
            batch = edges[i:i+self.batch_size]

            cypher_batch = []
            for edge in batch:
                cypher_batch.append(f"""
                    MATCH (a {{id: '{edge['from_id']}'}}), (b {{id: '{edge['to_id']}'}})
                    CREATE (a)-[r:{edge['type']} {self._format_properties(edge.get('properties', {}))}]->(b)
                """)

            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    {' '.join(cypher_batch)}
                $$) AS (result agtype);
            """)

            self.conn.commit()

    def _format_properties(self, props: dict) -> str:
        """æ ¼å¼åŒ–å±æ€§ä¸ºCypheræ ¼å¼"""
        if not props:
            return '{}'

        formatted = []
        for key, value in props.items():
            if isinstance(value, str):
                formatted.append(f"{key}: '{value}'")
            else:
                formatted.append(f"{key}: {value}")

        return '{' + ', '.join(formatted) + '}'
```

---

## 5. ç›‘æ§ä¸è¯Šæ–­

### 5.1 æŸ¥è¯¢æ€§èƒ½ç›‘æ§

**æŸ¥è¯¢æ€§èƒ½ç›‘æ§å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- åˆ›å»ºæŸ¥è¯¢æ€§èƒ½ç›‘æ§è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        CREATE TABLE IF NOT EXISTS kg_query_performance (
    id SERIAL PRIMARY KEY,
    query_hash TEXT,
    query_text TEXT,
    duration_ms NUMERIC,
    result_count INT,
    success BOOLEAN,
    error_message TEXT,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
        RAISE NOTICE 'è¡¨ kg_query_performance åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'è¡¨å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- åˆ›å»ºç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'kg_query_performance') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_kg_query_performance_hash') THEN
                CREATE INDEX idx_kg_query_performance_hash ON kg_query_performance (query_hash);
                RAISE NOTICE 'ç´¢å¼• idx_kg_query_performance_hash åˆ›å»ºæˆåŠŸ';
            ELSE
                RAISE NOTICE 'ç´¢å¼• idx_kg_query_performance_hash å·²å­˜åœ¨';
            END IF;

            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_kg_query_performance_created') THEN
                CREATE INDEX idx_kg_query_performance_created ON kg_query_performance (created_at);
                RAISE NOTICE 'ç´¢å¼• idx_kg_query_performance_created åˆ›å»ºæˆåŠŸ';
            ELSE
                RAISE NOTICE 'ç´¢å¼• idx_kg_query_performance_created å·²å­˜åœ¨';
            END IF;
        ELSE
            RAISE WARNING 'è¡¨ kg_query_performance ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'ç´¢å¼•å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡å‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION get_query_performance_stats(
    p_hours INT DEFAULT 24
)
RETURNS TABLE (
    query_hash TEXT,
    query_text TEXT,
    call_count BIGINT,
    avg_duration_ms NUMERIC,
    p95_duration_ms NUMERIC,
    success_rate NUMERIC
) AS $$
BEGIN
    BEGIN
        -- å‚æ•°éªŒè¯
        IF p_hours IS NULL OR p_hours <= 0 THEN
            RAISE EXCEPTION 'hourså¿…é¡»å¤§äº0';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'kg_query_performance') THEN
            RAISE EXCEPTION 'è¡¨ kg_query_performance ä¸å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å‚æ•°éªŒè¯å¤±è´¥: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        RETURN QUERY
        SELECT
            query_hash,
            LEFT(query_text, 200) AS query_text,
            COUNT(*)::BIGINT AS call_count,
            ROUND(AVG(duration_ms), 2) AS avg_duration_ms,
            ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY duration_ms), 2) AS p95_duration_ms,
                ROUND(COUNT(*) FILTER (WHERE success) * 100.0 / NULLIF(COUNT(*), 0), 2) AS success_rate
        FROM kg_query_performance
        WHERE created_at > NOW() - (p_hours || ' hours')::INTERVAL
        GROUP BY query_hash, query_text
        ORDER BY call_count DESC
        LIMIT 20;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡ŒæŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_query_performance_stats') THEN
            RAISE WARNING 'å‡½æ•° get_query_performance_stats ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒæŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'get_query_performance_stats') THEN
            RAISE WARNING 'å‡½æ•° get_query_performance_stats ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡ï¼ˆ24å°æ—¶ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM get_query_performance_stats(24);
```

---

---

## 5. PostgreSQL 18çŸ¥è¯†å›¾è°±ä¼˜åŒ–

### 5.1 å¼‚æ­¥I/Oä¼˜åŒ–

**å¼‚æ­¥I/Oä¼˜åŒ–ï¼ˆPostgreSQL 18ç‰¹æ€§ï¼‰**ï¼š

```sql
-- PostgreSQL 18å¼‚æ­¥I/Oé…ç½®ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser') = 'off' THEN
            RAISE NOTICE 'éœ€è¦è¶…çº§ç”¨æˆ·æƒé™ï¼Œè¯·åœ¨postgresql.confä¸­è®¾ç½®';
            RETURN;
        END IF;
        ALTER SYSTEM SET io_direct = 'data';
        ALTER SYSTEM SET io_combine_limit = '256kB';
        PERFORM pg_reload_conf();
        RAISE NOTICE 'å¼‚æ­¥I/Oé…ç½®å·²æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é…ç½®å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æ€§èƒ½æå‡:
-- å›¾æŸ¥è¯¢æ€§èƒ½: +25-30%
-- å‘é‡æ£€ç´¢æ€§èƒ½: +20-25%
```

### 5.2 å¹¶è¡Œå›¾æŸ¥è¯¢ä¼˜åŒ–

**å¹¶è¡Œå›¾æŸ¥è¯¢ä¼˜åŒ–ï¼ˆPostgreSQL 18ç‰¹æ€§ï¼‰**ï¼š

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        SET LOCAL max_parallel_workers_per_gather = 4;
        SET LOCAL parallel_setup_cost = 1000;
        SET LOCAL parallel_tuple_cost = 0.01;
        RAISE NOTICE 'å¹¶è¡ŒæŸ¥è¯¢å‚æ•°å·²è®¾ç½®ï¼ˆä¼šè¯çº§åˆ«ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è®¾ç½®å¹¶è¡ŒæŸ¥è¯¢å‚æ•°å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- å¹¶è¡Œå›¾æŸ¥è¯¢ç¤ºä¾‹ï¼ˆApache AGEï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'age') THEN
            RAISE WARNING 'Apache AGEæ‰©å±•æœªå®‰è£…ï¼Œæ— æ³•æ‰§è¡Œå›¾æŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œå›¾æŸ¥è¯¢';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (a:Document)-[r:MENTIONS]->(b:Concept)
    WHERE a.title CONTAINS 'PostgreSQL'
    RETURN a, r, b
    LIMIT 100
$$) AS (result agtype);

-- æ€§èƒ½æå‡:
-- å¤§å›¾æŸ¥è¯¢: +35-40%
```

---

## 6. çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿç›‘æ§

### 6.1 é—®ç­”æ€§èƒ½ç›‘æ§

**é—®ç­”æ€§èƒ½ç›‘æ§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- é—®ç­”æ€§èƒ½ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'qa_quality') THEN
            RAISE WARNING 'è¡¨ qa_quality ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºè§†å›¾';
            RETURN;
        END IF;
        DROP VIEW IF EXISTS v_qa_performance;
        CREATE OR REPLACE VIEW v_qa_performance AS
SELECT
    DATE_TRUNC('hour', created_at) AS hour,
    COUNT(*) AS query_count,
    AVG(response_time_ms) AS avg_response_time_ms,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms) AS p95_response_time_ms,
    AVG(cypher_generation_time_ms) AS avg_cypher_gen_time_ms,
    AVG(graph_query_time_ms) AS avg_graph_query_time_ms,
    AVG(llm_answer_time_ms) AS avg_llm_answer_time_ms,
    COUNT(*) FILTER (WHERE success = true) AS success_count,
    COUNT(*) FILTER (WHERE success = false) AS failed_count
FROM qa_logs
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY hour
ORDER BY hour DESC;

-- æŸ¥è¯¢é—®ç­”æ€§èƒ½ç»Ÿè®¡ï¼ˆå¸¦æ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'v_qa_performance') THEN
            RAISE WARNING 'è§†å›¾ v_qa_performance ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æŸ¥è¯¢é—®ç­”æ€§èƒ½ç»Ÿè®¡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æŸ¥è¯¢é—®ç­”æ€§èƒ½è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'v_qa_performance') THEN
            RAISE WARNING 'è§†å›¾ v_qa_performance ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æŸ¥è¯¢é—®ç­”æ€§èƒ½è§†å›¾';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM v_qa_performance;
```

### 6.2 CypheræŸ¥è¯¢ç›‘æ§

**CypheræŸ¥è¯¢ç›‘æ§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- CypheræŸ¥è¯¢ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cypher_query_logs') THEN
            RAISE WARNING 'è¡¨ cypher_query_logs ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºè§†å›¾';
            RETURN;
        END IF;
        DROP VIEW IF EXISTS v_cypher_query_performance;
        CREATE OR REPLACE VIEW v_cypher_query_performance AS
SELECT
    cypher_query_pattern,
    COUNT(*) AS execution_count,
    AVG(execution_time_ms) AS avg_execution_time_ms,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY execution_time_ms) AS p95_execution_time_ms,
    AVG(result_count) AS avg_result_count
FROM cypher_query_logs
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY cypher_query_pattern
ORDER BY avg_execution_time_ms DESC;

-- æŸ¥è¯¢Cypheræ€§èƒ½ç»Ÿè®¡ï¼ˆå¸¦æ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'v_cypher_query_performance') THEN
            RAISE WARNING 'è§†å›¾ v_cypher_query_performance ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æŸ¥è¯¢Cypheræ€§èƒ½ç»Ÿè®¡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æŸ¥è¯¢CypheræŸ¥è¯¢æ€§èƒ½è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'v_cypher_query_performance') THEN
            RAISE WARNING 'è§†å›¾ v_cypher_query_performance ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æŸ¥è¯¢CypheræŸ¥è¯¢æ€§èƒ½è§†å›¾';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM v_cypher_query_performance
LIMIT 20;
```

---

## 7. çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿæœ€ä½³å®è·µ

### 7.1 NL2Cypheræœ€ä½³å®è·µ

**NL2Cypheræœ€ä½³å®è·µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
# 1. ä½¿ç”¨æ¨¡æ¿åŒ¹é…ï¼ˆæé«˜å‡†ç¡®ç‡ï¼‰
def _template_match(question: str) -> str:
    """æ¨¡æ¿åŒ¹é…"""
    templates = {
        'æŸ¥æ‰¾æ–‡æ¡£': "MATCH (d:Document) RETURN d LIMIT 10",
        'æŸ¥æ‰¾æ¦‚å¿µ': "MATCH (c:Concept) RETURN c LIMIT 10",
        'æŸ¥æ‰¾å…³ç³»': "MATCH (a)-[r]->(b) RETURN a, r, b LIMIT 10"
    }

    for pattern, cypher in templates.items():
        if pattern in question:
            return cypher

    return None

# 2. ä½¿ç”¨ç¼“å­˜ï¼ˆå‡å°‘LLMè°ƒç”¨ï¼‰
@lru_cache(maxsize=1000)
def cached_nl2cypher(question_hash: str):
    """ç¼“å­˜NL2Cypherç»“æœ"""
    # ä»ç¼“å­˜è·å–
    cached = redis_client.get(f"nl2cypher:{question_hash}")
    if cached:
        return cached

    # è°ƒç”¨LLMç”ŸæˆCypher
    cypher = nl2cypher(question)

    # å­˜å…¥ç¼“å­˜
    redis_client.setex(f"nl2cypher:{question_hash}", 3600, cypher)

    return cypher
```

### 7.2 å›¾æŸ¥è¯¢ä¼˜åŒ–æœ€ä½³å®è·µ

**å›¾æŸ¥è¯¢ä¼˜åŒ–æœ€ä½³å®è·µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. ä½¿ç”¨ç´¢å¼•ï¼ˆåŠ é€ŸèŠ‚ç‚¹æŸ¥æ‰¾ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'age') THEN
            RAISE WARNING 'Apache AGEæ‰©å±•æœªå®‰è£…ï¼Œæ— æ³•åˆ›å»ºå›¾ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_document_title') THEN
            CREATE INDEX idx_document_title ON ag_graph.ag_vertex USING gin(to_tsvector('english', properties->>'title'));
            RAISE NOTICE 'GINç´¢å¼• idx_document_title åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'ç´¢å¼•å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- 2. é™åˆ¶æŸ¥è¯¢æ·±åº¦ï¼ˆé¿å…æ— é™é€’å½’ï¼‰
MATCH path = (a:Document)-[*1..3]->(b:Concept)
WHERE a.title CONTAINS 'PostgreSQL'
RETURN path
LIMIT 100;

-- 3. ä½¿ç”¨LIMITï¼ˆé™åˆ¶ç»“æœæ•°é‡ï¼‰
MATCH (a:Document)-[r:MENTIONS]->(b:Concept)
RETURN a, r, b
LIMIT 50;  -- é™åˆ¶ç»“æœæ•°
```

---

**è¿”å›**: [æ¡ˆä¾‹8ä¸»é¡µ](./README.md)
**å­—æ•°**: ~8,000å­—
**æ¶µç›–**: NL2Cypherã€Cypheræ‰§è¡Œã€é—®ç­”æµç¨‹ã€PostgreSQL 18ä¼˜åŒ–ã€ç›‘æ§ã€æœ€ä½³å®è·µ
