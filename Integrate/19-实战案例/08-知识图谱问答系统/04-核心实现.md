---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\08-çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ\04-æ ¸å¿ƒå®ç°.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹8ï¼šçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ - æ ¸å¿ƒå®ç°

```python
"""
çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ
æŠ€æœ¯æ ˆ: PostgreSQL 18 + Apache AGE + LangChain
"""

import psycopg2
from psycopg2.extras import RealDictCursor
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
import re

class KnowledgeGraphQA:
    """çŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ"""

    def __init__(self, conn_str, openai_api_key):
        self.conn = psycopg2.connect(conn_str, cursor_factory=RealDictCursor)
        self.cursor = self.conn.cursor()
        self.llm = OpenAI(api_key=openai_api_key, temperature=0)

        # åŠ è½½AGEæ‰©å±•
        self.cursor.execute("LOAD 'age';")
        self.cursor.execute("SET search_path = ag_catalog, '$user', public;")

    def nl2cypher(self, question: str) -> str:
        """
        è‡ªç„¶è¯­è¨€è½¬CypheræŸ¥è¯¢
        """

        # NL2Cypheræç¤ºè¯
        prompt = PromptTemplate(
            input_variables=["question"],
            template="""
ä½ æ˜¯ä¸€ä¸ªCypheræŸ¥è¯¢ç”Ÿæˆä¸“å®¶ã€‚å°†ä»¥ä¸‹è‡ªç„¶è¯­è¨€é—®é¢˜è½¬æ¢ä¸ºCypheræŸ¥è¯¢ã€‚

å›¾Schema:
- èŠ‚ç‚¹ç±»å‹: Document, Concept, Person, Product
- å…³ç³»ç±»å‹: MENTIONS, RELATED_TO, IS_A, USED_IN

é—®é¢˜: {question}

åªè¿”å›CypheræŸ¥è¯¢ï¼Œä¸è¦è§£é‡Š:
"""
        )

        cypher_query = self.llm(prompt.format(question=question))
        cypher_query = cypher_query.strip()

        return cypher_query

    def execute_cypher(self, cypher_query: str) -> list:
        """
        æ‰§è¡ŒCypheræŸ¥è¯¢
        """

        try:
            # ä½¿ç”¨AGEæ‰§è¡ŒCypher
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    {cypher_query}
                $$) AS (result agtype);
            """)

            results = [row['result'] for row in self.cursor.fetchall()]
            return results

        except Exception as e:
            print(f"æŸ¥è¯¢æ‰§è¡Œå¤±è´¥: {e}")
            return []

    def answer_question(self, question: str) -> dict:
        """
        å›ç­”é—®é¢˜ï¼ˆå®Œæ•´æµç¨‹ï¼‰
        """

        import time
        start_time = time.time()

        # 1. é—®é¢˜åˆ†ç±»
        question_type = self._classify_question(question)

        # 2. ç”ŸæˆCypher
        if question_type == 'simple':
            cypher_query = self._template_match(question)
        else:
            cypher_query = self.nl2cypher(question)

        # 3. æ‰§è¡ŒæŸ¥è¯¢
        results = self.execute_cypher(cypher_query)

        # 4. ç”Ÿæˆç­”æ¡ˆ
        answer = self._generate_answer(question, results)

        duration = (time.time() - start_time) * 1000

        return {
            'question': question,
            'cypher': cypher_query,
            'raw_results': results,
            'answer': answer,
            'duration_ms': duration
        }

    def _classify_question(self, question: str) -> str:
        """é—®é¢˜åˆ†ç±»"""

        # ç®€å•è§„åˆ™åˆ†ç±»
        if any(kw in question for kw in ['ä»€ä¹ˆæ˜¯', 'what is']):
            return 'simple'
        elif any(kw in question for kw in ['æœ‰å“ªäº›', 'list', 'æ‰€æœ‰']):
            return 'list'
        elif any(kw in question for kw in ['ç›¸å…³', 'related', 'å…³è”']):
            return 'relation'
        else:
            return 'complex'

    def _template_match(self, question: str) -> str:
        """æ¨¡æ¿åŒ¹é…ç”ŸæˆCypher"""

        # æå–å®ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
        entity = re.search(r'ä»€ä¹ˆæ˜¯(.+?)[\?ï¼Ÿ]', question)
        if entity:
            entity_name = entity.group(1).strip()
            return f"""
                MATCH (n:Concept {{name: '{entity_name}'}})
                RETURN n.name AS name, n.description AS description
            """

        return "MATCH (n) RETURN n LIMIT 10"

    def _generate_answer(self, question: str, results: list) -> str:
        """æ ¹æ®æŸ¥è¯¢ç»“æœç”Ÿæˆè‡ªç„¶è¯­è¨€ç­”æ¡ˆ"""

        if not results:
            return "æŠ±æ­‰ï¼Œæˆ‘æ²¡æœ‰æ‰¾åˆ°ç›¸å…³ä¿¡æ¯ã€‚"

        # ä½¿ç”¨LLMç”Ÿæˆç­”æ¡ˆ
        prompt = PromptTemplate(
            input_variables=["question", "results"],
            template="""
åŸºäºä»¥ä¸‹æ•°æ®å›ç­”é—®é¢˜ã€‚

é—®é¢˜: {question}

æ•°æ®: {results}

ç®€æ´å›ç­”:
"""
        )

        answer = self.llm(prompt.format(question=question, results=str(results)))
        return answer.strip()

# ============================================================
# çŸ¥è¯†æŠ½å–æ¨¡å—
# ============================================================

class KnowledgeExtractor:
    """ä»æ–‡æœ¬ä¸­æŠ½å–çŸ¥è¯†"""

    def __init__(self, conn_str):
        self.conn = psycopg2.connect(conn_str)
        self.cursor = self.conn.cursor()

    def extract_from_document(self, doc_id: int, content: str):
        """
        ä»æ–‡æ¡£ä¸­æŠ½å–å®ä½“å’Œå…³ç³»
        """

        # 1. å®ä½“è¯†åˆ«ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”ä½¿ç”¨NERæ¨¡å‹ï¼‰
        entities = self._ner(content)

        # 2. å…³ç³»æŠ½å–
        relations = self._extract_relations(content, entities)

        # 3. å†™å…¥å›¾æ•°æ®åº“
        self._insert_to_graph(doc_id, entities, relations)

    def _ner(self, text: str) -> list:
        """å®ä½“è¯†åˆ«ï¼ˆç¤ºä¾‹ï¼‰"""
        # å®é™…åº”ä½¿ç”¨SpaCyæˆ–BERTç­‰NERæ¨¡å‹
        return [
            {'name': 'PostgreSQL', 'type': 'Concept'},
            {'name': 'MVCC', 'type': 'Concept'}
        ]

    def _extract_relations(self, text: str, entities: list) -> list:
        """å…³ç³»æŠ½å–ï¼ˆç¤ºä¾‹ï¼‰"""
        # å®é™…åº”ä½¿ç”¨å…³ç³»æŠ½å–æ¨¡å‹
        return [
            {'from': 'PostgreSQL', 'to': 'MVCC', 'type': 'USES'}
        ]

    def _insert_to_graph(self, doc_id: int, entities: list, relations: list):
        """æ’å…¥å›¾æ•°æ®åº“"""

        # æ’å…¥å®ä½“
        for entity in entities:
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    MERGE (n:{entity['type']} {{name: '{entity['name']}'}})
                    RETURN n
                $$) AS (n agtype);
            """)

        # æ’å…¥å…³ç³»
        for rel in relations:
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    MATCH (a {{name: '{rel['from']}'}}), (b {{name: '{rel['to']}'}}
                    MERGE (a)-[r:{rel['type']}]->(b)
                    RETURN r
                $$) AS (r agtype);
            """)

        self.conn.commit()

# ============================================================
# FastAPIæ¥å£
# ============================================================

from fastapi import FastAPI, Query as FastAPIQuery

app = FastAPI()

qa_system = KnowledgeGraphQA(
    conn_str="dbname=knowledge_db user=postgres",
    openai_api_key="your-api-key"
)

@app.get("/api/qa")
async def ask_question(q: str = FastAPIQuery(..., description="é—®é¢˜")):
    """é—®ç­”æ¥å£"""
    result = qa_system.answer_question(q)
    return result

@app.get("/api/graph/subgraph")
async def get_subgraph(entity: str, radius: int = 2):
    """è·å–å­å›¾"""
    cursor = qa_system.cursor
    cursor.execute("""
        SELECT extract_subgraph(%s, %s);
    """, (entity, radius))
    subgraph = cursor.fetchone()[0]
    return {'entity': entity, 'subgraph': subgraph}

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8004)
```

---

**è¿”å›**: [æ¡ˆä¾‹8ä¸»é¡µ](./README.md)
