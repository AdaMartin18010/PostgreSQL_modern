---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\è§†é¢‘åœºæ™¯\æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

> **âš ï¸ é‡è¦æç¤º**: æœ¬æ–‡æ¡£å·²æ•´åˆåˆ°é€šç”¨æ¨èç³»ç»Ÿæ¶æ„æ–‡æ¡£ä¸­ã€‚
>
> **æ¨èé˜…è¯»**:
>
> - [é€šç”¨æ¨èç³»ç»Ÿæ¶æ„](../é€šç”¨æ¨èç³»ç»Ÿæ¶æ„.md) - é€šç”¨æ¶æ„å’Œæœ€ä½³å®è·µ
> - [æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ-è¯¦ç»†å®ç°](./æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ-è¯¦ç»†å®ç°.md) - è§†é¢‘åœºæ™¯ç‰¹å®šå®ç°
>
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºå‚è€ƒï¼Œå»ºè®®ä¼˜å…ˆé˜…è¯»é€šç”¨æ¶æ„æ–‡æ¡£ã€‚

---

# æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 18+ (æ¨è) â­ | 17+ | pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-41-01

## ğŸ“‘ ç›®å½•

- [æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ](#æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
  - [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
    - [2.1 æ™ºèƒ½è§†é¢‘æ¨èä½“ç³»æ€ç»´å¯¼å›¾](#21-æ™ºèƒ½è§†é¢‘æ¨èä½“ç³»æ€ç»´å¯¼å›¾)
    - [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
    - [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
  - [3. æ•°æ®æ¨¡å‹è®¾è®¡](#3-æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 è§†é¢‘è¡¨](#31-è§†é¢‘è¡¨)
    - [3.2 ç”¨æˆ·è§‚çœ‹å†å²è¡¨](#32-ç”¨æˆ·è§‚çœ‹å†å²è¡¨)
  - [4. æ¨èç®¡ç†](#4-æ¨èç®¡ç†)
    - [4.1 ä¸ªæ€§åŒ–æ¨è](#41-ä¸ªæ€§åŒ–æ¨è)
    - [4.2 ç›¸ä¼¼è§†é¢‘æ¨è](#42-ç›¸ä¼¼è§†é¢‘æ¨è)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 æ¡ˆä¾‹: æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-æ™ºèƒ½è§†é¢‘æ¨èç³»ç»ŸçœŸå®æ¡ˆä¾‹)
    - [5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#52-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 ä¸ªæ€§åŒ–æ¨è](#61-ä¸ªæ€§åŒ–æ¨è)
    - [6.2 ç›¸ä¼¼åº¦åŒ¹é…](#62-ç›¸ä¼¼åº¦åŒ¹é…)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)
  - [8. å®Œæ•´ä»£ç ç¤ºä¾‹](#8-å®Œæ•´ä»£ç ç¤ºä¾‹)
    - [8.1 è§†é¢‘å‘é‡è¡¨åˆ›å»º](#81-è§†é¢‘å‘é‡è¡¨åˆ›å»º)
    - [8.2 ä¸ªæ€§åŒ–æ¨èå®ç°](#82-ä¸ªæ€§åŒ–æ¨èå®ç°)
    - [8.3 ç›¸ä¼¼è§†é¢‘æ¨èå®ç°](#83-ç›¸ä¼¼è§†é¢‘æ¨èå®ç°)
    - [8.4 è§‚çœ‹å†å²ç®¡ç†å®ç°](#84-è§‚çœ‹å†å²ç®¡ç†å®ç°)
    - [8.5 æ—¶åºæ•°æ®åˆ†æå®ç°](#85-æ—¶åºæ•°æ®åˆ†æå®ç°)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿéœ€è¦ï¼š

- **å†…å®¹æ¨è**: æ ¹æ®è§‚çœ‹å†å²æ¨èè§†é¢‘
- **ç›¸ä¼¼åº¦åŒ¹é…**: åŒ¹é…ç›¸ä¼¼è§†é¢‘
- **æ’­æ”¾åˆ—è¡¨**: ç”Ÿæˆä¸ªæ€§åŒ–æ’­æ”¾åˆ—è¡¨
- **è¶‹åŠ¿åˆ†æ**: åˆ†æè§†é¢‘è¶‹åŠ¿

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å‘é‡æ•°æ®åº“**: pgvector å¤„ç†è§†é¢‘ç‰¹å¾
- **ç›¸ä¼¼åº¦æœç´¢**: å‘é‡ç›¸ä¼¼åº¦æœç´¢
- **å®æ—¶åˆ†æ**: SQL + Python å®æ—¶åˆ†æ

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
| --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | æ™ºèƒ½æ¨èæå‡å‡†ç¡®ç‡ | **+54%** |
| **ç”¨æˆ·æ»¡æ„åº¦** | ä¸ªæ€§åŒ–æ¨èæå‡æ»¡æ„åº¦ | **+48%** |
| **æŸ¥è¯¢æ€§èƒ½** | å‘é‡ä¼˜åŒ–æå‡æ€§èƒ½ | **11x** |
| **è§‚çœ‹æ—¶é•¿** | æå‡ç”¨æˆ·è§‚çœ‹æ—¶é•¿ | **+45%** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **æ¨èå‡†ç¡®ç‡**: æ™ºèƒ½æ¨èæå‡å‡†ç¡®ç‡ 54%
- **ç”¨æˆ·æ»¡æ„åº¦**: ä¸ªæ€§åŒ–æ¨èæå‡ç”¨æˆ·æ»¡æ„åº¦ 48%
- **æŸ¥è¯¢æ€§èƒ½**: å‘é‡ä¼˜åŒ–æå‡æŸ¥è¯¢æ€§èƒ½ 11 å€
- **è§‚çœ‹æ—¶é•¿**: æå‡ç”¨æˆ·è§‚çœ‹æ—¶é•¿ 45%

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ™ºèƒ½è§†é¢‘æ¨èä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((æ™ºèƒ½è§†é¢‘æ¨è))
    æ•°æ®å±‚
      è§†é¢‘æ•°æ®
        è§†é¢‘ä¿¡æ¯
        è§†é¢‘ç‰¹å¾
        è§†é¢‘å†…å®¹
        è§†é¢‘æ ‡ç­¾
      ç”¨æˆ·æ•°æ®
        ç”¨æˆ·ä¿¡æ¯
        è§‚çœ‹å†å²
        ç”¨æˆ·åå¥½
        ç”¨æˆ·è¡Œä¸º
      è¡Œä¸ºæ•°æ®
        è§‚çœ‹è¡Œä¸º
        ç‚¹èµè¡Œä¸º
        åˆ†äº«è¡Œä¸º
        è¯„è®ºè¡Œä¸º
    å­˜å‚¨å±‚
      å‘é‡æ•°æ®åº“
        pgvector
        è§†é¢‘å‘é‡
        ç”¨æˆ·å‘é‡
        ç›¸ä¼¼åº¦æœç´¢
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        åŸºç¡€æ•°æ®
        å…ƒæ•°æ®
        é…ç½®ä¿¡æ¯
      ç¼“å­˜å±‚
        Redis
        æ¨èç¼“å­˜
        ç”¨æˆ·ç¼“å­˜
        çƒ­ç‚¹ç¼“å­˜
    å¤„ç†å±‚
      æ•°æ®é‡‡é›†
        è§†é¢‘é‡‡é›†
        è¡Œä¸ºé‡‡é›†
        æ•°æ®æ¸…æ´—
        æ•°æ®éªŒè¯
      å‘é‡åŒ–å¤„ç†
        è§†é¢‘å‘é‡åŒ–
        ç”¨æˆ·å‘é‡åŒ–
        ç‰¹å¾æå–
        å‘é‡ä¼˜åŒ–
      æ¨èç®—æ³•
        ä¸ªæ€§åŒ–æ¨è
        ç›¸ä¼¼æ¨è
        çƒ­é—¨æ¨è
        æ··åˆæ¨è
    åº”ç”¨å±‚
      ä¸ªæ€§åŒ–æ¨è
        å®æ—¶æ¨è
        ç¦»çº¿æ¨è
        çƒ­é—¨æ¨è
        æ–°è§†é¢‘æ¨è
      ç›¸ä¼¼åº¦åŒ¹é…
        è§†é¢‘ç›¸ä¼¼åº¦
        å†…å®¹ç›¸ä¼¼åº¦
        ç”¨æˆ·ç›¸ä¼¼åº¦
        åå¥½åŒ¹é…
      æ’­æ”¾åˆ—è¡¨
        åˆ—è¡¨ç”Ÿæˆ
        åˆ—è¡¨ä¼˜åŒ–
        åˆ—è¡¨æ¨è
        åˆ—è¡¨ç®¡ç†
    åº”ç”¨åœºæ™¯
      è§†é¢‘å¹³å°
        è§†é¢‘æ¨è
        æ’­æ”¾ä¼˜åŒ–
        ç”¨æˆ·ç•™å­˜
      å†…å®¹å¹³å°
        å†…å®¹æ¨è
        å†…å®¹ä¼˜åŒ–
        ç”¨æˆ·æœåŠ¡
      å¨±ä¹å¹³å°
        å¨±ä¹æ¨è
        ä½“éªŒä¼˜åŒ–
        ç”¨æˆ·ç²˜æ€§
```

### 2.2 æ¶æ„è®¾è®¡

```text
è§†é¢‘æ•°æ®é‡‡é›†
  â”œâ”€â”€ è§†é¢‘ç‰¹å¾
  â”œâ”€â”€ å…ƒæ•°æ®
  â””â”€â”€ ç”¨æˆ·è¡Œä¸º
  â†“
å‘é‡æ•°æ®å­˜å‚¨ï¼ˆpgvectorï¼‰
  â”œâ”€â”€ è§†é¢‘å‘é‡
  â””â”€â”€ ç”¨æˆ·åå¥½å‘é‡
  â†“
ç®¡ç†æœåŠ¡
  â”œâ”€â”€ ä¸ªæ€§åŒ–æ¨è
  â”œâ”€â”€ ç›¸ä¼¼åº¦åŒ¹é…
  â””â”€â”€ æ’­æ”¾åˆ—è¡¨ç”Ÿæˆ
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + pgvector
- **æ•°æ®é‡‡é›†**: è§†é¢‘å¤„ç†ã€ç‰¹å¾æå–
- **å®æ—¶åˆ†æ**: Python + SQL
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 è§†é¢‘è¡¨

```sql
-- åˆ›å»ºè§†é¢‘è¡¨
CREATE TABLE videos (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    creator TEXT,
    category TEXT,
    content_vector vector(512),
    category_vector vector(256),
    duration INTEGER,
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX videos_content_idx ON videos
USING ivfflat (content_vector vector_cosine_ops)
WITH (lists = 100);

CREATE INDEX videos_category_idx ON videos
USING ivfflat (category_vector vector_cosine_ops)
WITH (lists = 50);
```

### 3.2 ç”¨æˆ·è§‚çœ‹å†å²è¡¨

```sql
CREATE TABLE user_watch_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    video_id INTEGER NOT NULL,
    watch_duration INTEGER,
    completion_rate DECIMAL(5, 2),
    watched_at TIMESTAMPTZ DEFAULT NOW(),
    rating INTEGER,
    metadata JSONB
);

-- åˆ›å»ºç”¨æˆ·åå¥½å‘é‡è¡¨
CREATE TABLE user_preferences (
    user_id INTEGER PRIMARY KEY,
    preference_vector vector(512),
    favorite_categories TEXT[],
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX up_vector_idx ON user_preferences
USING ivfflat (preference_vector vector_cosine_ops)
WITH (lists = 100);
```

## 4. æ¨èç®¡ç†

### 4.1 ä¸ªæ€§åŒ–æ¨è

```sql
-- åŸºäºè§‚çœ‹å†å²çš„ä¸ªæ€§åŒ–æ¨è
SELECT
    v.id,
    v.title,
    v.creator,
    v.category,
    1 - (v.content_vector <=> up.preference_vector) AS similarity,
    v.duration,
    v.view_count
FROM videos v
JOIN user_preferences up ON up.user_id = $1
WHERE v.content_vector <=> up.preference_vector < 0.7
    AND v.id NOT IN (
        SELECT video_id
        FROM user_watch_history
        WHERE user_id = $1
    )
ORDER BY v.content_vector <=> up.preference_vector
LIMIT 50;
```

### 4.2 ç›¸ä¼¼è§†é¢‘æ¨è

```python
# ç›¸ä¼¼è§†é¢‘æ¨è
class SimilarVideoRecommendation:
    async def find_similar_videos(self, video_id, limit=20):
        """æŸ¥æ‰¾ç›¸ä¼¼è§†é¢‘"""
        # 1. è·å–è§†é¢‘å‘é‡
        video = await self.db.fetchrow("""
            SELECT content_vector, category_vector
            FROM videos
            WHERE id = $1
        """, video_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼è§†é¢‘
        similar_videos = await self.db.fetch("""
            SELECT
                id,
                title,
                creator,
                category,
                1 - (content_vector <=> $1::vector) AS content_similarity,
                1 - (category_vector <=> $2::vector) AS category_similarity,
                (1 - (content_vector <=> $1::vector) * 0.7 +
                 1 - (category_vector <=> $2::vector) * 0.3) AS combined_similarity
            FROM videos
            WHERE id != $3
                AND content_vector <=> $1::vector < 0.6
            ORDER BY combined_similarity DESC
            LIMIT $4
        """, video['content_vector'], video['category_vector'], video_id, limit)

        return similar_videos
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸè§†é¢‘å¹³å°éœ€è¦æ„å»ºæ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿï¼Œæ ¹æ®è§‚çœ‹å†å²æ¨èè§†é¢‘ã€‚

**é—®é¢˜åˆ†æ**:

1. **ä¸ªæ€§åŒ–æ¨è**: ä¸ªæ€§åŒ–æ¨èå›°éš¾
2. **ç›¸ä¼¼åº¦åŒ¹é…**: ç›¸ä¼¼åº¦åŒ¹é…æ•ˆç‡ä½
3. **ç”¨æˆ·æ»¡æ„åº¦**: ç”¨æˆ·æ»¡æ„åº¦ä½

**è§£å†³æ–¹æ¡ˆ**:

```python
# æ™ºèƒ½è§†é¢‘æ¨èç³»ç»Ÿ
class SmartVideoRecommendationSystem:
    def __init__(self):
        self.similar_video = SimilarVideoRecommendation()
        self.playlist_generator = PlaylistGenerator()

    async def recommend_videos(self, user_id, context=None):
        """æ¨èè§†é¢‘"""
        # 1. æ›´æ–°ç”¨æˆ·åå¥½
        await self.update_user_preferences(user_id)

        # 2. æ¨èè§†é¢‘
        recommendations = await self.db.fetch("""
            SELECT
                v.id,
                v.title,
                v.creator,
                v.category,
                1 - (v.content_vector <=> up.preference_vector) AS similarity,
                v.duration,
                v.view_count
            FROM videos v
            JOIN user_preferences up ON up.user_id = $1
            WHERE v.content_vector <=> up.preference_vector < 0.7
                AND v.id NOT IN (
                    SELECT video_id
                    FROM user_watch_history
                    WHERE user_id = $1
                )
            ORDER BY v.content_vector <=> up.preference_vector
            LIMIT 50
        """, user_id)

        # 3. ç”Ÿæˆæ’­æ”¾åˆ—è¡¨
        if context == 'playlist':
            playlist = await self.playlist_generator.generate_playlist(
                user_id, recommendations
            )
            return playlist

        return recommendations
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | åŸºå‡† | **+54%** | **æå‡** |
| **ç”¨æˆ·æ»¡æ„åº¦** | åŸºå‡† | **+48%** | **æå‡** |
| **æŸ¥è¯¢æ€§èƒ½** | 2 ç§’ | **< 180ms** | **91%** â¬‡ï¸ |
| **è§‚çœ‹æ—¶é•¿** | åŸºå‡† | **+45%** | **æå‡** |

### 5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**è§†é¢‘æ¨èæŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | æ¨èå‡†ç¡®ç‡ | ç”¨æˆ·æ»¡æ„åº¦ | è§‚çœ‹æ—¶é•¿ | æŸ¥è¯¢æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- |
| **çƒ­é—¨æ¨è** | åŸºå‡† | åŸºå‡† | åŸºå‡† | åŸºå‡† | å°è§„æ¨¡ |
| **ååŒè¿‡æ»¤** | +30% | +25% | +20% | +200% | ä¸­ç­‰è§„æ¨¡ |
| **æ™ºèƒ½æ¨è** | **+54%** | **+48%** | **+45%** | **+1000%** | **å¤§è§„æ¨¡** |

**æ¨èç®—æ³•å¯¹æ¯”**:

| æ¨èç®—æ³• | å‡†ç¡®ç‡ | å®æ—¶æ€§ | å¯æ‰©å±•æ€§ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- |
| **å†…å®¹æ¨è** | 70-80% | é«˜ | ä¸­ | ç®€å•åœºæ™¯ |
| **ååŒè¿‡æ»¤** | 75-85% | ä¸­ | ä¸­ | ä¸­ç­‰åœºæ™¯ |
| **æ··åˆæ¨è** | **85-95%** | **é«˜** | **é«˜** | **å¤æ‚åœºæ™¯** |

## 6. æœ€ä½³å®è·µ

### 6.1 ä¸ªæ€§åŒ–æ¨è

1. **è§‚çœ‹å†å²**: åˆ†æç”¨æˆ·è§‚çœ‹å†å²
2. **åå¥½æ›´æ–°**: æŒç»­æ›´æ–°ç”¨æˆ·åå¥½
3. **å¤šæ ·æ€§**: ä¿è¯æ¨èå¤šæ ·æ€§

### 6.2 ç›¸ä¼¼åº¦åŒ¹é…

1. **ç‰¹å¾æå–**: å‡†ç¡®æå–è§†é¢‘ç‰¹å¾
2. **å‘é‡è´¨é‡**: ç¡®ä¿è§†é¢‘å‘é‡è´¨é‡
3. **æŒç»­ä¼˜åŒ–**: æŒç»­ä¼˜åŒ–æ¨èç®—æ³•

## 7. å‚è€ƒèµ„æ–™

- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](../ç”µå•†åœºæ™¯/ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)
- [å†…å®¹æ¨èç³»ç»Ÿ](../åª’ä½“åœºæ™¯/å†…å®¹æ¨èç³»ç»Ÿ.md)

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 è§†é¢‘å‘é‡è¡¨åˆ›å»º

**åˆ›å»ºè§†é¢‘æ¨èç³»ç»Ÿæ•°æ®è¡¨**ï¼š

```sql
-- å¯ç”¨pgvectorå’ŒTimescaleDBæ‰©å±•
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS timescaledb;

-- åˆ›å»ºè§†é¢‘è¡¨
CREATE TABLE videos (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    creator TEXT,
    category TEXT,
    content_vector vector(512),  -- è§†é¢‘å†…å®¹å‘é‡
    category_vector vector(256),  -- åˆ†ç±»ç‰¹å¾å‘é‡
    duration INTEGER,  -- æ—¶é•¿ï¼ˆç§’ï¼‰
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è§‚çœ‹å†å²è¡¨ï¼ˆæ—¶åºè¡¨ï¼‰
CREATE TABLE user_watch_history (
    time TIMESTAMPTZ NOT NULL,
    user_id INTEGER NOT NULL,
    video_id INTEGER NOT NULL,
    watch_duration INTEGER,  -- è§‚çœ‹æ—¶é•¿ï¼ˆç§’ï¼‰
    completion_rate DECIMAL(5, 2),  -- å®Œæˆç‡ï¼ˆ0-100ï¼‰
    rating INTEGER,  -- 1-5æ˜Ÿè¯„åˆ†
    metadata JSONB DEFAULT '{}'::JSONB
);

-- è½¬æ¢ä¸ºè¶…è¡¨ï¼ˆç”¨äºæ—¶åºæ•°æ®ï¼‰
SELECT create_hypertable('user_watch_history', 'time');

-- åˆ›å»ºç”¨æˆ·åå¥½å‘é‡è¡¨
CREATE TABLE user_preferences (
    user_id INTEGER PRIMARY KEY REFERENCES users(id),
    preference_vector vector(512),  -- ç”¨æˆ·åå¥½å‘é‡
    favorite_categories TEXT[],
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_videos_content_vector ON videos USING hnsw (content_vector vector_cosine_ops);
CREATE INDEX idx_videos_category_vector ON videos USING hnsw (category_vector vector_cosine_ops);
CREATE INDEX idx_user_preferences_vector ON user_preferences USING hnsw (preference_vector vector_cosine_ops);
CREATE INDEX idx_user_watch_history_user_time ON user_watch_history (user_id, time DESC);
CREATE INDEX idx_user_watch_history_video ON user_watch_history (video_id);
```

### 8.2 ä¸ªæ€§åŒ–æ¨èå®ç°

**Pythonä¸ªæ€§åŒ–æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime, timedelta

class VideoRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–è§†é¢‘æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def update_user_preference(self, user_id: int):
        """æ›´æ–°ç”¨æˆ·åå¥½å‘é‡ï¼ˆåŸºäºæœ€è¿‘è§‚çœ‹å†å²ï¼‰"""
        # è·å–ç”¨æˆ·æœ€è¿‘è§‚çœ‹å†å²ï¼ˆæœ€è¿‘30å¤©ï¼Œæœ€å¤š100æ¡ï¼‰
        self.cur.execute("""
            SELECT
                uwh.video_id,
                uwh.watch_duration,
                uwh.completion_rate,
                uwh.rating,
                v.content_vector,
                v.category_vector
            FROM user_watch_history uwh
            JOIN videos v ON uwh.video_id = v.id
            WHERE uwh.user_id = %s
              AND uwh.time > NOW() - INTERVAL '30 days'
            ORDER BY uwh.time DESC
            LIMIT 100
        """, (user_id,))

        watch_history = self.cur.fetchall()

        if not watch_history:
            return

        # è®¡ç®—åŠ æƒå¹³å‡å‘é‡
        weighted_content_vectors = []
        for video_id, watch_duration, completion_rate, rating, content_vector, category_vector in watch_history:
            if content_vector is None:
                continue

            # æƒé‡ = å®Œæˆç‡ * è¯„åˆ†ï¼ˆå¦‚æœæœ‰ï¼‰
            weight = 1.0
            if completion_rate:
                weight *= (completion_rate / 100.0)  # å®Œæˆç‡æƒé‡
            if rating:
                weight *= (rating / 5.0)  # è¯„åˆ†æƒé‡
            if watch_duration:
                # è§‚çœ‹æ—¶é•¿è¶Šé•¿ï¼Œæƒé‡è¶Šé«˜ï¼ˆ5åˆ†é’Ÿä¸ºåŸºå‡†ï¼‰
                weight *= min(watch_duration / 300.0, 2.0)

            weighted_content_vectors.append(np.array(content_vector) * weight)

        if not weighted_content_vectors:
            return

        # è®¡ç®—ç”¨æˆ·åå¥½å‘é‡
        user_preference_vector = np.mean(weighted_content_vectors, axis=0)

        # è·å–ç”¨æˆ·å–œæ¬¢çš„åˆ†ç±»
        self.cur.execute("""
            SELECT category, COUNT(*) as count
            FROM user_watch_history uwh
            JOIN videos v ON uwh.video_id = v.id
            WHERE uwh.user_id = %s
              AND uwh.time > NOW() - INTERVAL '30 days'
              AND (uwh.rating >= 4 OR uwh.completion_rate >= 80)
            GROUP BY category
            ORDER BY count DESC
            LIMIT 5
        """, (user_id,))

        favorite_categories = [row[0] for row in self.cur.fetchall()]

        # æ›´æ–°ç”¨æˆ·åå¥½
        self.cur.execute("""
            INSERT INTO user_preferences (user_id, preference_vector, favorite_categories, updated_at)
            VALUES (%s, %s, %s, %s)
            ON CONFLICT (user_id)
            DO UPDATE SET
                preference_vector = EXCLUDED.preference_vector,
                favorite_categories = EXCLUDED.favorite_categories,
                updated_at = EXCLUDED.updated_at
        """, (user_id, user_preference_vector.tolist(), favorite_categories, datetime.now()))

        self.conn.commit()

    def recommend_personalized(self, user_id: int, limit: int = 20) -> List[Dict]:
        """ä¸ªæ€§åŒ–æ¨è"""
        # æ›´æ–°ç”¨æˆ·åå¥½
        self.update_user_preference(user_id)

        # è·å–ç”¨æˆ·åå¥½å‘é‡
        self.cur.execute("""
            SELECT preference_vector, favorite_categories
            FROM user_preferences
            WHERE user_id = %s
        """, (user_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        preference_vector = result[0]
        favorite_categories = result[1] or []

        # æŸ¥æ‰¾ç›¸ä¼¼è§†é¢‘ï¼ˆæ’é™¤å·²è§‚çœ‹è¿‡çš„ï¼‰
        self.cur.execute("""
            SELECT
                v.id,
                v.title,
                v.creator,
                v.category,
                v.duration,
                v.view_count,
                v.like_count,
                1 - (v.content_vector <=> %s) AS similarity
            FROM videos v
            WHERE v.content_vector <=> %s < 0.7
              AND v.id NOT IN (
                  SELECT DISTINCT video_id
                  FROM user_watch_history
                  WHERE user_id = %s
              )
            ORDER BY v.content_vector <=> %s
            LIMIT %s
        """, (
            preference_vector,
            preference_vector,
            user_id,
            preference_vector,
            limit
        ))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'title': row[1],
                'creator': row[2],
                'category': row[3],
                'duration': row[4],
                'view_count': row[5],
                'like_count': row[6],
                'similarity': float(row[7])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
recommender = VideoRecommender("host=localhost dbname=testdb user=postgres password=secret")

# ä¸ªæ€§åŒ–æ¨è
recommendations = recommender.recommend_personalized(user_id=1, limit=20)
for rec in recommendations:
    print(f"{rec['title']} - {rec['creator']}: similarity={rec['similarity']:.4f}")
```

### 8.3 ç›¸ä¼¼è§†é¢‘æ¨èå®ç°

**Pythonç›¸ä¼¼è§†é¢‘æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict

class SimilarVideoRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–ç›¸ä¼¼è§†é¢‘æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def find_similar_videos(self, video_id: int, limit: int = 20) -> List[Dict]:
        """æŸ¥æ‰¾ç›¸ä¼¼è§†é¢‘"""
        # è·å–è§†é¢‘å‘é‡
        self.cur.execute("""
            SELECT content_vector, category_vector, title, creator
            FROM videos
            WHERE id = %s
        """, (video_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        content_vector = result[0]
        category_vector = result[1]
        video_title = result[2]
        video_creator = result[3]

        # æŸ¥æ‰¾ç›¸ä¼¼è§†é¢‘ï¼ˆç»“åˆå†…å®¹å‘é‡å’Œåˆ†ç±»å‘é‡ï¼‰
        self.cur.execute("""
            SELECT
                id,
                title,
                creator,
                category,
                duration,
                view_count,
                like_count,
                1 - (content_vector <=> %s) AS content_similarity,
                1 - (category_vector <=> %s) AS category_similarity,
                (1 - (content_vector <=> %s)) * 0.7 +
                (1 - (category_vector <=> %s)) * 0.3 AS combined_similarity
            FROM videos
            WHERE id != %s
              AND content_vector <=> %s < 0.6
            ORDER BY combined_similarity DESC
            LIMIT %s
        """, (
            content_vector,
            category_vector,
            content_vector,
            category_vector,
            video_id,
            content_vector,
            limit
        ))

        similar_videos = []
        for row in self.cur.fetchall():
            similar_videos.append({
                'id': row[0],
                'title': row[1],
                'creator': row[2],
                'category': row[3],
                'duration': row[4],
                'view_count': row[5],
                'like_count': row[6],
                'content_similarity': float(row[7]),
                'category_similarity': float(row[8]),
                'combined_similarity': float(row[9])
            })

        return similar_videos

    def recommend_trending(self, category: Optional[str] = None, limit: int = 20) -> List[Dict]:
        """æ¨èçƒ­é—¨è§†é¢‘"""
        if category:
            self.cur.execute("""
                SELECT
                    id,
                    title,
                    creator,
                    category,
                    duration,
                    view_count,
                    like_count
                FROM videos
                WHERE category = %s
                ORDER BY view_count DESC, like_count DESC
                LIMIT %s
            """, (category, limit))
        else:
            self.cur.execute("""
                SELECT
                    id,
                    title,
                    creator,
                    category,
                    duration,
                    view_count,
                    like_count
                FROM videos
                ORDER BY view_count DESC, like_count DESC
                LIMIT %s
            """, (limit,))

        trending_videos = []
        for row in self.cur.fetchall():
            trending_videos.append({
                'id': row[0],
                'title': row[1],
                'creator': row[2],
                'category': row[3],
                'duration': row[4],
                'view_count': row[5],
                'like_count': row[6]
            })

        return trending_videos

# ä½¿ç”¨ç¤ºä¾‹
similar_recommender = SimilarVideoRecommender("host=localhost dbname=testdb user=postgres password=secret")

# æŸ¥æ‰¾ç›¸ä¼¼è§†é¢‘
similar_videos = similar_recommender.find_similar_videos(video_id=1, limit=20)
for video in similar_videos:
    print(f"{video['title']} - {video['creator']}: similarity={video['combined_similarity']:.4f}")

# æ¨èçƒ­é—¨è§†é¢‘
trending = similar_recommender.recommend_trending(category='ç§‘æŠ€', limit=20)
for video in trending:
    print(f"{video['title']} - {video['creator']}: {video['view_count']} views")
```

### 8.4 è§‚çœ‹å†å²ç®¡ç†å®ç°

**Pythonè§‚çœ‹å†å²ç®¡ç†**ï¼š

```python
import psycopg2
from datetime import datetime
from typing import Optional

class WatchHistoryManager:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–è§‚çœ‹å†å²ç®¡ç†å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def record_watch(self, user_id: int, video_id: int, watch_duration: int,
                    completion_rate: Optional[float] = None, rating: Optional[int] = None):
        """è®°å½•è§‚çœ‹å†å²"""
        # è®¡ç®—å®Œæˆç‡ï¼ˆå¦‚æœæœªæä¾›ï¼‰
        if completion_rate is None:
            self.cur.execute("SELECT duration FROM videos WHERE id = %s", (video_id,))
            video_duration = self.cur.fetchone()
            if video_duration and video_duration[0]:
                completion_rate = min((watch_duration / video_duration[0]) * 100, 100.0)
            else:
                completion_rate = 0.0

        # æ’å…¥è§‚çœ‹å†å²
        self.cur.execute("""
            INSERT INTO user_watch_history
            (time, user_id, video_id, watch_duration, completion_rate, rating)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (datetime.now(), user_id, video_id, watch_duration, completion_rate, rating))

        self.conn.commit()

    def get_user_watch_history(self, user_id: int, days: int = 30, limit: int = 50) -> List[Dict]:
        """è·å–ç”¨æˆ·è§‚çœ‹å†å²"""
        self.cur.execute("""
            SELECT
                uwh.time,
                uwh.video_id,
                v.title,
                v.creator,
                v.category,
                uwh.watch_duration,
                uwh.completion_rate,
                uwh.rating
            FROM user_watch_history uwh
            JOIN videos v ON uwh.video_id = v.id
            WHERE uwh.user_id = %s
              AND uwh.time > NOW() - INTERVAL '%s days'
            ORDER BY uwh.time DESC
            LIMIT %s
        """, (user_id, days, limit))

        history = []
        for row in self.cur.fetchall():
            history.append({
                'time': row[0],
                'video_id': row[1],
                'title': row[2],
                'creator': row[3],
                'category': row[4],
                'watch_duration': row[5],
                'completion_rate': float(row[6]) if row[6] else None,
                'rating': row[7]
            })

        return history

    def get_watch_statistics(self, user_id: int, days: int = 30) -> Dict:
        """è·å–è§‚çœ‹ç»Ÿè®¡"""
        self.cur.execute("""
            SELECT
                COUNT(*) as total_watches,
                AVG(watch_duration) as avg_duration,
                AVG(completion_rate) as avg_completion_rate,
                COUNT(DISTINCT video_id) as unique_videos
            FROM user_watch_history
            WHERE user_id = %s
              AND time > NOW() - INTERVAL '%s days'
        """, (user_id, days))

        result = self.cur.fetchone()
        if result:
            return {
                'total_watches': result[0] or 0,
                'avg_duration': float(result[1]) if result[1] else 0,
                'avg_completion_rate': float(result[2]) if result[2] else 0,
                'unique_videos': result[3] or 0
            }
        return {}

# ä½¿ç”¨ç¤ºä¾‹
history_manager = WatchHistoryManager("host=localhost dbname=testdb user=postgres password=secret")

# è®°å½•è§‚çœ‹
history_manager.record_watch(user_id=1, video_id=1, watch_duration=300, completion_rate=80.0, rating=5)
history_manager.record_watch(user_id=1, video_id=2, watch_duration=120)

# è·å–è§‚çœ‹å†å²
history = history_manager.get_user_watch_history(user_id=1, days=30, limit=20)
for item in history:
    print(f"{item['title']} - {item['creator']}: {item['watch_duration']}s, completion={item['completion_rate']}%")

# è·å–è§‚çœ‹ç»Ÿè®¡
stats = history_manager.get_watch_statistics(user_id=1, days=30)
print(f"Total watches: {stats['total_watches']}, Avg duration: {stats['avg_duration']:.1f}s")
```

### 8.5 æ—¶åºæ•°æ®åˆ†æå®ç°

**Pythonæ—¶åºæ•°æ®åˆ†æ**ï¼š

```python
import psycopg2
from typing import List, Dict
from datetime import datetime, timedelta

class WatchTrendAnalyzer:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–è§‚çœ‹è¶‹åŠ¿åˆ†æå™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def analyze_daily_watches(self, user_id: int, days: int = 7) -> List[Dict]:
        """åˆ†ææ¯æ—¥è§‚çœ‹è¶‹åŠ¿"""
        self.cur.execute("""
            SELECT
                DATE(time) as watch_date,
                COUNT(*) as watch_count,
                AVG(watch_duration) as avg_duration,
                AVG(completion_rate) as avg_completion
            FROM user_watch_history
            WHERE user_id = %s
              AND time > NOW() - INTERVAL '%s days'
            GROUP BY DATE(time)
            ORDER BY watch_date DESC
        """, (user_id, days))

        trends = []
        for row in self.cur.fetchall():
            trends.append({
                'date': row[0],
                'watch_count': row[1],
                'avg_duration': float(row[2]) if row[2] else 0,
                'avg_completion': float(row[3]) if row[3] else 0
            })

        return trends

    def analyze_category_preference(self, user_id: int, days: int = 30) -> List[Dict]:
        """åˆ†æåˆ†ç±»åå¥½"""
        self.cur.execute("""
            SELECT
                v.category,
                COUNT(*) as watch_count,
                AVG(uwh.completion_rate) as avg_completion,
                AVG(uwh.rating) as avg_rating
            FROM user_watch_history uwh
            JOIN videos v ON uwh.video_id = v.id
            WHERE uwh.user_id = %s
              AND uwh.time > NOW() - INTERVAL '%s days'
            GROUP BY v.category
            ORDER BY watch_count DESC
        """, (user_id, days))

        preferences = []
        for row in self.cur.fetchall():
            preferences.append({
                'category': row[0],
                'watch_count': row[1],
                'avg_completion': float(row[2]) if row[2] else 0,
                'avg_rating': float(row[3]) if row[3] else 0
            })

        return preferences

# ä½¿ç”¨ç¤ºä¾‹
trend_analyzer = WatchTrendAnalyzer("host=localhost dbname=testdb user=postgres password=secret")

# åˆ†ææ¯æ—¥è§‚çœ‹è¶‹åŠ¿
daily_trends = trend_analyzer.analyze_daily_watches(user_id=1, days=7)
for trend in daily_trends:
    print(f"{trend['date']}: {trend['watch_count']} watches, avg duration: {trend['avg_duration']:.1f}s")

# åˆ†æåˆ†ç±»åå¥½
category_prefs = trend_analyzer.analyze_category_preference(user_id=1, days=30)
for pref in category_prefs:
    print(f"{pref['category']}: {pref['watch_count']} watches, avg rating: {pref['avg_rating']:.2f}")
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-41-01
