# PostgreSQL金融行业完整案例

> **PostgreSQL版本**: 18.x
> **行业**: 金融
> **特点**: 高并发、低延迟、强一致性、高可用
> **参考案例**: [05-金融交易系统](./05-金融交易系统/README.md), [10-金融反欺诈系统](./10-金融反欺诈系统/README.md)

---

## 📋 目录

- [PostgreSQL金融行业完整案例](#postgresql金融行业完整案例)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 金融行业特点](#11-金融行业特点)
    - [1.2 核心场景](#12-核心场景)
  - [2. 金融行业核心场景](#2-金融行业核心场景)
    - [2.1 交易系统](#21-交易系统)
    - [2.2 反欺诈系统](#22-反欺诈系统)
  - [3. 技术架构](#3-技术架构)
    - [3.1 高可用架构](#31-高可用架构)
    - [3.2 数据一致性保证](#32-数据一致性保证)
  - [4. 数据库设计](#4-数据库设计)
    - [4.1 账户表设计](#41-账户表设计)
  - [5. 性能优化](#5-性能优化)
    - [5.1 查询优化](#51-查询优化)
    - [5.2 连接池优化](#52-连接池优化)
  - [6. 安全与合规](#6-安全与合规)
    - [6.1 数据加密](#61-数据加密)
    - [6.2 审计日志](#62-审计日志)
    - [6.3 合规性](#63-合规性)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 交易处理](#71-交易处理)
    - [7.2 风控系统](#72-风控系统)
    - [7.3 高可用](#73-高可用)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 金融行业特点

金融行业对数据库的要求：

- ✅ **高并发**: 10万+ QPS
- ✅ **低延迟**: P99 < 10ms
- ✅ **强一致性**: ACID严格保证
- ✅ **高可用**: 99.99%+可用性
- ✅ **数据安全**: 加密、审计、合规

### 1.2 核心场景

- **交易系统**: 实时交易处理
- **反欺诈系统**: 实时风控检测
- **账户系统**: 账户余额管理
- **支付系统**: 支付处理
- **风控系统**: 风险控制

---

## 2. 金融行业核心场景

### 2.1 交易系统

**参考**: [05-金融交易系统](./05-金融交易系统/README.md)

**核心需求**:

- 实时交易处理
- 强一致性保证
- 低延迟响应
- 高并发支持

**技术方案**:

```sql
-- 交易表设计
CREATE TABLE transactions (
    transaction_id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    amount NUMERIC(20,2) NOT NULL,
    transaction_type TEXT NOT NULL,
    status TEXT DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT check_amount CHECK (amount > 0)
);

-- 账户表（强一致性）
CREATE TABLE accounts (
    account_id BIGSERIAL PRIMARY KEY,
    balance NUMERIC(20,2) NOT NULL DEFAULT 0,
    version INT DEFAULT 0,  -- 乐观锁
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 交易处理（使用SERIALIZABLE隔离级别）
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
UPDATE accounts
SET balance = balance - 100,
    version = version + 1,
    updated_at = NOW()
WHERE account_id = 12345 AND balance >= 100;
INSERT INTO transactions (account_id, amount, transaction_type)
VALUES (12345, 100, 'withdraw');
COMMIT;
```

### 2.2 反欺诈系统

**参考**: [10-金融反欺诈系统](./10-金融反欺诈系统/README.md)

**核心需求**:

- 实时风控检测
- 复杂规则引擎
- 图数据库查询
- 机器学习集成

**技术方案**:

```sql
-- 交易记录表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'transaction_records') THEN
            CREATE TABLE transaction_records (
                record_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                amount NUMERIC(20,2),
                merchant_id BIGINT,
                location TEXT,
                device_id TEXT,
                created_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 transaction_records 创建成功';
        ELSE
            RAISE NOTICE '表 transaction_records 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 风控规则表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'risk_rules') THEN
            CREATE TABLE risk_rules (
                rule_id SERIAL PRIMARY KEY,
                rule_name TEXT NOT NULL,
                rule_definition JSONB,
                risk_score INT,
                enabled BOOLEAN DEFAULT true
            );
            RAISE NOTICE '表 risk_rules 创建成功';
        ELSE
            RAISE NOTICE '表 risk_rules 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 实时风控检测（带错误处理）
CREATE OR REPLACE FUNCTION check_risk(
    p_user_id BIGINT,
    p_amount NUMERIC,
    p_merchant_id BIGINT
)
RETURNS TABLE (
    risk_level TEXT,
    risk_score INT,
    reason TEXT
) AS $$
DECLARE
    v_risk_score INT := 0;
    v_reason TEXT := '';
    v_transaction_count INT := 0;
BEGIN
    BEGIN
        -- 检查大额交易
        IF p_amount > 10000 THEN
            v_risk_score := v_risk_score + 30;
            v_reason := v_reason || '大额交易; ';
        END IF;

        -- 检查异常时间
        IF EXTRACT(HOUR FROM NOW()) BETWEEN 2 AND 5 THEN
            v_risk_score := v_risk_score + 20;
            v_reason := v_reason || '异常时间; ';
        END IF;

        -- 检查交易频率
        SELECT COUNT(*) INTO v_transaction_count
        FROM transaction_records
        WHERE user_id = p_user_id
        AND created_at >= NOW() - INTERVAL '1 hour';

        IF v_transaction_count > 10 THEN
            v_risk_score := v_risk_score + 25;
            v_reason := v_reason || '高频交易; ';
        END IF;

        -- 返回风险等级
        RETURN QUERY
        SELECT
            CASE
                WHEN v_risk_score >= 70 THEN 'high'
                WHEN v_risk_score >= 40 THEN 'medium'
                ELSE 'low'
            END,
            v_risk_score,
            v_reason;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '风控检测失败: %', SQLERRM;
            RETURN QUERY SELECT 'error'::TEXT, 100, SQLERRM;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. 技术架构

### 3.1 高可用架构

```text
应用层 (多实例)
    ↓
负载均衡
    ↓
PostgreSQL集群
├── 主库 (读写)
├── 从库1 (只读)
├── 从库2 (只读)
└── 从库3 (只读)
    ↓
存储层 (SSD + 备份)
```

### 3.2 数据一致性保证

```sql
-- 使用SERIALIZABLE隔离级别（带错误处理）
DO $$
DECLARE
    current_version INT;
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'accounts') THEN
            -- 获取当前版本
            SELECT version INTO current_version
            FROM accounts
            WHERE account_id = 12345;

            IF current_version IS NULL THEN
                RAISE EXCEPTION '账户不存在';
            END IF;

            BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;

            -- 使用乐观锁
            UPDATE accounts
            SET balance = balance - 100,
                version = version + 1,
                updated_at = NOW()
            WHERE account_id = 12345
            AND version = current_version
            AND balance >= 100;

            IF NOT FOUND THEN
                ROLLBACK;
                RAISE EXCEPTION '版本冲突或余额不足，请重试';
            END IF;

            COMMIT;
            RAISE NOTICE '交易成功';
        ELSE
            RAISE NOTICE '表 accounts 不存在，跳过交易处理';
        END IF;
    EXCEPTION
        WHEN serialization_failure THEN
            ROLLBACK;
            RAISE WARNING '序列化冲突，请重试';
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '交易处理失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 4. 数据库设计

### 4.1 账户表设计

```sql
-- 账户表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'accounts') THEN
            CREATE TABLE accounts (
                account_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                account_type TEXT NOT NULL,
                balance NUMERIC(20,2) NOT NULL DEFAULT 0,
                frozen_balance NUMERIC(20,2) NOT NULL DEFAULT 0,
                version INT DEFAULT 0,
                status TEXT DEFAULT 'active',
                created_at TIMESTAMPTZ DEFAULT NOW(),
                updated_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 accounts 创建成功';
        ELSE
            RAISE NOTICE '表 accounts 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'accounts') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_accounts_user_id') THEN
                CREATE INDEX idx_accounts_user_id ON accounts(user_id);
                RAISE NOTICE '索引创建成功';
            ELSE
                RAISE NOTICE '索引已存在';
            END IF;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

CREATE INDEX idx_accounts_status ON accounts(status);

```

### 4.2 交易表设计

```sql
-- 交易表（分区）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'transactions') THEN
            CREATE TABLE transactions (
                transaction_id BIGSERIAL,
                account_id BIGINT NOT NULL,
                amount NUMERIC(20,2) NOT NULL,
                transaction_type TEXT NOT NULL,
                status TEXT DEFAULT 'pending',
                created_at TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (transaction_id, created_at)
            ) PARTITION BY RANGE (created_at);
            RAISE NOTICE '分区表 transactions 创建成功';
        ELSE
            RAISE NOTICE '表 transactions 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 按月分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'transactions') THEN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'transactions_2025_01') THEN
                CREATE TABLE transactions_2025_01 PARTITION OF transactions
                FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
                RAISE NOTICE '分区 transactions_2025_01 创建成功';
            ELSE
                RAISE NOTICE '分区 transactions_2025_01 已存在';
            END IF;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. 性能优化

### 5.1 查询优化

```sql
-- 优化账户查询（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'accounts') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_accounts_user_status') THEN
                CREATE INDEX idx_accounts_user_status ON accounts(user_id, status);
                RAISE NOTICE '索引 idx_accounts_user_status 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_accounts_user_status 已存在';
            END IF;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 优化交易查询（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'transactions') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_transactions_account_time') THEN
                CREATE INDEX idx_transactions_account_time ON transactions(account_id, created_at DESC);
                RAISE NOTICE '索引 idx_transactions_account_time 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_transactions_account_time 已存在';
            END IF;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 连接池优化

```ini
# PgBouncer配置
pool_mode = transaction
max_client_conn = 10000
default_pool_size = 25
```

---

## 6. 安全与合规

### 6.1 数据加密

```sql
-- 使用pgcrypto加密敏感数据（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pgcrypto') THEN
            CREATE EXTENSION IF NOT EXISTS pgcrypto;
            RAISE NOTICE '扩展 pgcrypto 创建成功';
        ELSE
            RAISE NOTICE '扩展 pgcrypto 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '扩展已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建扩展失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建敏感数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensitive_data') THEN
            CREATE TABLE sensitive_data (
                id SERIAL PRIMARY KEY,
                encrypted_data BYTEA
            );
            RAISE NOTICE '表 sensitive_data 创建成功';
        ELSE
            RAISE NOTICE '表 sensitive_data 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 加密存储（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensitive_data') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pgcrypto') THEN
            BEGIN
                INSERT INTO sensitive_data (encrypted_data)
                VALUES (pgp_sym_encrypt('sensitive', 'key'));
                RAISE NOTICE '加密数据插入成功';
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE WARNING '加密数据插入失败: %', SQLERRM;
                    RAISE;
            END;
        ELSE
            RAISE NOTICE '表或扩展不存在，跳过加密存储';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '加密存储失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 6.2 审计日志

```sql
-- 启用审计（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pgaudit') THEN
            CREATE EXTENSION IF NOT EXISTS pgaudit;
            RAISE NOTICE '扩展 pgaudit 创建成功';
        ELSE
            RAISE NOTICE '扩展 pgaudit 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '扩展已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建扩展失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 设置审计日志（带错误处理）
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser')::boolean THEN
            ALTER DATABASE current_database() SET pgaudit.log = 'all';
            RAISE NOTICE '审计日志配置成功';
        ELSE
            RAISE NOTICE '需要超级用户权限才能设置审计日志';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法设置审计日志';
        WHEN OTHERS THEN
            RAISE WARNING '设置审计日志失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 6.3 合规性

- **GDPR合规**: 数据主体权利
- **PCI DSS合规**: 支付卡数据保护
- **金融监管**: 交易记录保留

---

## 7. 最佳实践

### 7.1 交易处理

- ✅ **使用SERIALIZABLE隔离级别**: 保证强一致性
- ✅ **乐观锁**: 减少锁竞争
- ✅ **批量处理**: 提高吞吐量
- ✅ **异步处理**: 非关键路径异步化

### 7.2 风控系统

- ✅ **实时检测**: 毫秒级响应
- ✅ **规则引擎**: 灵活配置规则
- ✅ **机器学习**: 集成ML模型
- ✅ **图数据库**: 关系分析

### 7.3 高可用

- ✅ **主从复制**: 实时复制
- ✅ **自动故障转移**: 秒级切换
- ✅ **多区域部署**: 容灾备份
- ✅ **监控告警**: 实时监控

---

## 📚 相关文档

- [05-金融交易系统](./05-金融交易系统/README.md) - 金融交易系统案例
- [10-金融反欺诈系统](./10-金融反欺诈系统/README.md) - 金融反欺诈系统案例
- [32-企业级特性/合规性管理](../32-企业级特性/合规性管理.md) - 合规性管理
- [32-企业级特性/企业级安全深化](../32-企业级特性/企业级安全深化.md) - 企业级安全

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
