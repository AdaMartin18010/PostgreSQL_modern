---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\03-IoTæ—¶åºæ•°æ®ç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# IoTæ—¶åºæ•°æ®ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

> **PostgreSQLç‰ˆæœ¬**: 18.x

---

## ğŸ“‹ ç›®å½•

- [IoTæ—¶åºæ•°æ®ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡](#iotæ—¶åºæ•°æ®ç³»ç»Ÿ---æ•°æ®åº“è®¾è®¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å®Œæ•´Schema](#å®Œæ•´schema)
  - [æ ¸å¿ƒå‡½æ•°](#æ ¸å¿ƒå‡½æ•°)
  - [å†™å…¥ä¼˜åŒ–](#å†™å…¥ä¼˜åŒ–)
  - [æŸ¥è¯¢ä¼˜åŒ–](#æŸ¥è¯¢ä¼˜åŒ–)
  - [5. æ•°æ®è´¨é‡ä¿è¯](#5-æ•°æ®è´¨é‡ä¿è¯)
    - [5.1 æ•°æ®è´¨é‡æ£€æŸ¥](#51-æ•°æ®è´¨é‡æ£€æŸ¥)
    - [5.2 æ•°æ®å®Œæ•´æ€§éªŒè¯](#52-æ•°æ®å®Œæ•´æ€§éªŒè¯)
  - [6. ç›‘æ§ä¸å‘Šè­¦](#6-ç›‘æ§ä¸å‘Šè­¦)
    - [6.1 è®¾å¤‡çŠ¶æ€ç›‘æ§](#61-è®¾å¤‡çŠ¶æ€ç›‘æ§)
    - [6.2 å¼‚å¸¸æ£€æµ‹å‘Šè­¦](#62-å¼‚å¸¸æ£€æµ‹å‘Šè­¦)
  - [7. æ•°æ®å½’æ¡£ç­–ç•¥](#7-æ•°æ®å½’æ¡£ç­–ç•¥)
    - [7.1 æ•°æ®å½’æ¡£å‡½æ•°](#71-æ•°æ®å½’æ¡£å‡½æ•°)

## å®Œæ•´Schema

```sql
-- è®¾å¤‡è¡¨
CREATE TABLE devices (
    device_id SERIAL PRIMARY KEY,
    device_code VARCHAR(50) UNIQUE,
    device_name VARCHAR(200),
    device_type VARCHAR(50),
    location VARCHAR(200),
    install_date TIMESTAMPTZ,
    status VARCHAR(20) DEFAULT 'active'
);

-- æŒ‡æ ‡å®šä¹‰è¡¨
CREATE TABLE metrics (
    metric_id SERIAL PRIMARY KEY,
    metric_code VARCHAR(50) UNIQUE,
    metric_name VARCHAR(100),
    unit VARCHAR(20),
    normal_min DOUBLE PRECISION,
    normal_max DOUBLE PRECISION,
    alert_min DOUBLE PRECISION,
    alert_max DOUBLE PRECISION
);

-- ä¼ æ„Ÿå™¨æ•°æ®è¡¨ï¼ˆæ ¸å¿ƒè¡¨ï¼ŒæŒ‰å¤©åˆ†åŒºï¼‰
CREATE TABLE sensor_data (
    device_id INT NOT NULL,
    metric_id SMALLINT NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value DOUBLE PRECISION NOT NULL,
    quality SMALLINT DEFAULT 100 CHECK (quality BETWEEN 0 AND 100),
    PRIMARY KEY (device_id, timestamp, metric_id)
) PARTITION BY RANGE (timestamp);

-- æ‰¹é‡åˆ›å»º365å¤©åˆ†åŒº
SELECT create_daily_partitions('sensor_data', 365);

-- â­ BRINç´¢å¼•ï¼ˆæ—¶åºä¼˜åŒ–ï¼‰
CREATE INDEX idx_sensor_data_time
ON sensor_data USING BRIN (timestamp)
WITH (pages_per_range = 128);

CREATE INDEX idx_sensor_data_device
ON sensor_data USING BRIN (device_id, timestamp);

-- â­ PostgreSQL 18ï¼šLZ4å‹ç¼©
ALTER TABLE sensor_data
ALTER COLUMN value SET COMPRESSION lz4;

-- 1åˆ†é’Ÿèšåˆè¡¨
CREATE TABLE sensor_data_1min (
    device_id INT,
    metric_id SMALLINT,
    minute TIMESTAMPTZ,
    avg_value DOUBLE PRECISION,
    min_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    stddev_value DOUBLE PRECISION,
    sample_count INT,
    PRIMARY KEY (device_id, metric_id, minute)
) PARTITION BY RANGE (minute);

-- åˆ›å»º7å¤©åˆ†åŒºï¼ˆåªä¿ç•™7å¤©èšåˆæ•°æ®ï¼‰
SELECT create_daily_partitions('sensor_data_1min', 7);

-- 1å°æ—¶èšåˆè¡¨
CREATE TABLE sensor_data_1hour (
    device_id INT,
    metric_id SMALLINT,
    hour TIMESTAMPTZ,
    avg_value DOUBLE PRECISION,
    min_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    PRIMARY KEY (device_id, metric_id, hour)
);

-- 1å¤©èšåˆè¡¨
CREATE TABLE sensor_data_1day (
    device_id INT,
    metric_id SMALLINT,
    day DATE,
    avg_value DOUBLE PRECISION,
    min_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    PRIMARY KEY (device_id, metric_id, day)
);
```

---

## æ ¸å¿ƒå‡½æ•°

```sql
-- è‡ªåŠ¨åˆ›å»ºåˆ†åŒºå‡½æ•°
CREATE OR REPLACE FUNCTION create_daily_partitions(
    table_name TEXT,
    days_ahead INT
) RETURNS void AS $$
DECLARE
    partition_date DATE;
    partition_name TEXT;
BEGIN
    FOR i IN 0..days_ahead-1 LOOP
        partition_date := CURRENT_DATE + i;
        partition_name := table_name || '_' || TO_CHAR(partition_date, 'YYYY_MM_DD');

        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
            EXECUTE FORMAT(
                'CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                partition_name, table_name, partition_date, partition_date + 1
            );
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- æ¸…ç†æ—§åˆ†åŒº
CREATE OR REPLACE FUNCTION cleanup_old_partitions(
    table_name TEXT,
    retention_days INT
) RETURNS void AS $$
DECLARE
    partition_name TEXT;
BEGIN
    FOR partition_name IN
        SELECT tablename FROM pg_tables
        WHERE tablename LIKE table_name || '_%'
        AND tablename < table_name || '_' || TO_CHAR(CURRENT_DATE - retention_days, 'YYYY_MM_DD')
    LOOP
        EXECUTE FORMAT('DROP TABLE IF EXISTS %I', partition_name);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶ä»»åŠ¡
SELECT cron.schedule('create-partitions', '0 1 * * *',
    'SELECT create_daily_partitions(''sensor_data'', 365)');

SELECT cron.schedule('cleanup-partitions', '0 2 * * *',
    'SELECT cleanup_old_partitions(''sensor_data'', 365)');
```

---

## å†™å…¥ä¼˜åŒ–

```sql
-- æ‰¹é‡æ’å…¥ä¼˜åŒ–
INSERT INTO sensor_data
SELECT * FROM unnest($1::int[], $2::smallint[], $3::timestamptz[], $4::double precision[]);

-- â­ PostgreSQL 18ï¼šå¼‚æ­¥I/O
-- ååé‡ï¼š800K â†’ 1.2M points/ç§’ (+50%)
```

---

## æŸ¥è¯¢ä¼˜åŒ–

```sql
-- æ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼ˆæœ€å¸¸è§ï¼‰
PREPARE get_device_data (int, timestamptz, timestamptz) AS
SELECT timestamp, value
FROM sensor_data
WHERE device_id = $1
  AND timestamp BETWEEN $2 AND $3
ORDER BY timestamp;

-- æ‰§è¡Œ
EXECUTE get_device_data(1001, NOW() - INTERVAL '1 hour', NOW());

-- â­ PostgreSQL 18ä¼˜åŒ–ï¼š
-- 1. åˆ†åŒºè£å‰ªï¼šåªæ‰«æ1ä¸ªåˆ†åŒº
-- 2. BRINç´¢å¼•ï¼šå¿«é€Ÿå®šä½
-- 3. è®¡åˆ’ç¼“å­˜ï¼šè§„åˆ’æ—¶é—´<1ms
-- æ‰§è¡Œæ—¶é—´ï¼š<50ms
```

---

---

## 5. æ•°æ®è´¨é‡ä¿è¯

### 5.1 æ•°æ®è´¨é‡æ£€æŸ¥

**æ•°æ®è´¨é‡æ£€æŸ¥å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ•°æ®è´¨é‡æ£€æŸ¥è¡¨
CREATE TABLE IF NOT EXISTS data_quality_checks (
    id SERIAL PRIMARY KEY,
    check_type TEXT,
    device_id INT,
    metric_id SMALLINT,
    check_date DATE DEFAULT CURRENT_DATE,
    check_result JSONB,
    status TEXT,  -- 'pass', 'fail', 'warning'
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ•°æ®è´¨é‡æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_data_quality(
    p_device_id INT DEFAULT NULL,
    p_metric_id SMALLINT DEFAULT NULL,
    p_check_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE (
    check_type TEXT,
    check_result TEXT,
    status TEXT
) AS $$
DECLARE
    null_count BIGINT;
    outlier_count BIGINT;
    duplicate_count BIGINT;
BEGIN
    -- æ£€æŸ¥NULLå€¼
    SELECT COUNT(*) INTO null_count
    FROM sensor_data
    WHERE (p_device_id IS NULL OR device_id = p_device_id)
      AND (p_metric_id IS NULL OR metric_id = p_metric_id)
      AND timestamp::DATE = p_check_date
      AND value IS NULL;

    IF null_count > 0 THEN
        RETURN QUERY SELECT
            'NULLå€¼æ£€æŸ¥'::TEXT,
            format('å‘ç° %s æ¡è®°å½•å­˜åœ¨NULLå€¼', null_count)::TEXT,
            'fail'::TEXT;
    ELSE
        RETURN QUERY SELECT
            'NULLå€¼æ£€æŸ¥'::TEXT,
            'é€šè¿‡'::TEXT,
            'pass'::TEXT;
    END IF;

    -- æ£€æŸ¥å¼‚å¸¸å€¼ï¼ˆè¶…å‡ºæ­£å¸¸èŒƒå›´ï¼‰
    SELECT COUNT(*) INTO outlier_count
    FROM sensor_data sd
    JOIN metrics m ON sd.metric_id = m.metric_id
    WHERE (p_device_id IS NULL OR sd.device_id = p_device_id)
      AND (p_metric_id IS NULL OR sd.metric_id = p_metric_id)
      AND sd.timestamp::DATE = p_check_date
      AND (sd.value < m.alert_min OR sd.value > m.alert_max);

    IF outlier_count > 0 THEN
        RETURN QUERY SELECT
            'å¼‚å¸¸å€¼æ£€æŸ¥'::TEXT,
            format('å‘ç° %s æ¡è®°å½•è¶…å‡ºæ­£å¸¸èŒƒå›´', outlier_count)::TEXT,
            'warning'::TEXT;
    ELSE
        RETURN QUERY SELECT
            'å¼‚å¸¸å€¼æ£€æŸ¥'::TEXT,
            'é€šè¿‡'::TEXT,
            'pass'::TEXT;
    END IF;

    -- æ£€æŸ¥é‡å¤æ•°æ®
    SELECT COUNT(*) - COUNT(DISTINCT (device_id, metric_id, timestamp)) INTO duplicate_count
    FROM sensor_data
    WHERE (p_device_id IS NULL OR device_id = p_device_id)
      AND (p_metric_id IS NULL OR metric_id = p_metric_id)
      AND timestamp::DATE = p_check_date;

    IF duplicate_count > 0 THEN
        RETURN QUERY SELECT
            'é‡å¤æ•°æ®æ£€æŸ¥'::TEXT,
            format('å‘ç° %s æ¡é‡å¤è®°å½•', duplicate_count)::TEXT,
            'warning'::TEXT;
    ELSE
        RETURN QUERY SELECT
            'é‡å¤æ•°æ®æ£€æŸ¥'::TEXT,
            'é€šè¿‡'::TEXT,
            'pass'::TEXT;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ•°æ®è´¨é‡æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 æ•°æ®å®Œæ•´æ€§éªŒè¯

**æ•°æ®å®Œæ•´æ€§éªŒè¯å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ•°æ®å®Œæ•´æ€§éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION verify_data_integrity(
    p_start_date DATE DEFAULT CURRENT_DATE - INTERVAL '7 days',
    p_end_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE (
    check_item TEXT,
    expected_value NUMERIC,
    actual_value NUMERIC,
    difference NUMERIC,
    status TEXT
) AS $$
DECLARE
    expected_points BIGINT;
    actual_points BIGINT;
    expected_devices INT;
    actual_devices INT;
BEGIN
    -- éªŒè¯æ•°æ®ç‚¹æ•°é‡ï¼ˆåŸºäºè®¾å¤‡æ•°å’ŒæŒ‡æ ‡æ•°ï¼‰
    SELECT COUNT(DISTINCT device_id) INTO expected_devices FROM devices WHERE status = 'active';
    SELECT COUNT(DISTINCT metric_id) INTO expected_points FROM metrics;
    expected_points := expected_devices * expected_points * 86400;  -- æ¯å¤©86400ç§’

    SELECT COUNT(*) INTO actual_points
    FROM sensor_data
    WHERE timestamp::DATE BETWEEN p_start_date AND p_end_date;

    RETURN QUERY SELECT
        'æ•°æ®ç‚¹æ•°é‡'::TEXT,
        expected_points::NUMERIC,
        actual_points::NUMERIC,
        ABS(expected_points - actual_points)::NUMERIC,
        CASE
            WHEN ABS(expected_points - actual_points) < expected_points * 0.05 THEN 'æ­£å¸¸'
            WHEN ABS(expected_points - actual_points) < expected_points * 0.1 THEN 'è­¦å‘Š'
            ELSE 'å¼‚å¸¸'
        END;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ•°æ®å®Œæ•´æ€§éªŒè¯å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. ç›‘æ§ä¸å‘Šè­¦

### 6.1 è®¾å¤‡çŠ¶æ€ç›‘æ§

**è®¾å¤‡çŠ¶æ€ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- è®¾å¤‡çŠ¶æ€ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_device_status AS
SELECT
    d.device_id,
    d.device_code,
    d.device_name,
    d.device_type,
    d.location,
    d.status,
    COUNT(DISTINCT sd.metric_id) AS active_metrics,
    MAX(sd.timestamp) AS last_data_time,
    EXTRACT(EPOCH FROM (NOW() - MAX(sd.timestamp))) / 60 AS minutes_since_last_data,
    CASE
        WHEN MAX(sd.timestamp) < NOW() - INTERVAL '1 hour' THEN 'ç¦»çº¿'
        WHEN MAX(sd.timestamp) < NOW() - INTERVAL '10 minutes' THEN 'è­¦å‘Š'
        ELSE 'åœ¨çº¿'
    END AS device_status
FROM devices d
LEFT JOIN sensor_data sd ON d.device_id = sd.device_id
WHERE d.status = 'active'
GROUP BY d.device_id, d.device_code, d.device_name, d.device_type, d.location, d.status;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_device_status
WHERE device_status != 'åœ¨çº¿'
ORDER BY minutes_since_last_data DESC;
```

### 6.2 å¼‚å¸¸æ£€æµ‹å‘Šè­¦

**å¼‚å¸¸æ£€æµ‹å‘Šè­¦å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¼‚å¸¸æ£€æµ‹å‘Šè­¦è¡¨
CREATE TABLE IF NOT EXISTS anomaly_alerts (
    alert_id SERIAL PRIMARY KEY,
    device_id INT NOT NULL REFERENCES devices(device_id),
    metric_id SMALLINT NOT NULL REFERENCES metrics(metric_id),
    alert_type TEXT NOT NULL,  -- 'out_of_range', 'missing_data', 'quality_low'
    alert_value NUMERIC,
    threshold_value NUMERIC,
    alert_message TEXT,
    severity TEXT DEFAULT 'warning',  -- 'info', 'warning', 'critical'
    acknowledged BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å¼‚å¸¸æ£€æµ‹å‘Šè­¦å‡½æ•°
CREATE OR REPLACE FUNCTION detect_anomalies(
    p_check_hours INT DEFAULT 1
)
RETURNS TABLE (
    device_id INT,
    metric_id SMALLINT,
    alert_type TEXT,
    alert_message TEXT,
    severity TEXT
) AS $$
BEGIN
    -- æ£€æµ‹è¶…å‡ºæ­£å¸¸èŒƒå›´çš„æ•°æ®
    RETURN QUERY
    SELECT DISTINCT
        sd.device_id,
        sd.metric_id,
        'out_of_range'::TEXT,
        format('è®¾å¤‡%sæŒ‡æ ‡%så€¼%sè¶…å‡ºæ­£å¸¸èŒƒå›´[%s, %s]',
               d.device_code, m.metric_name, sd.value, m.normal_min, m.normal_max)::TEXT,
        CASE
            WHEN sd.value < m.alert_min OR sd.value > m.alert_max THEN 'critical'
            ELSE 'warning'
        END
    FROM sensor_data sd
    JOIN devices d ON sd.device_id = d.device_id
    JOIN metrics m ON sd.metric_id = m.metric_id
    WHERE sd.timestamp > NOW() - (p_check_hours || ' hours')::INTERVAL
      AND (sd.value < m.normal_min OR sd.value > m.normal_max)
      AND NOT EXISTS (
          SELECT 1 FROM anomaly_alerts aa
          WHERE aa.device_id = sd.device_id
            AND aa.metric_id = sd.metric_id
            AND aa.alert_type = 'out_of_range'
            AND aa.created_at > NOW() - INTERVAL '1 hour'
      );

    -- æ£€æµ‹ç¼ºå¤±æ•°æ®
    RETURN QUERY
    SELECT DISTINCT
        d.device_id,
        m.metric_id,
        'missing_data'::TEXT,
        format('è®¾å¤‡%sæŒ‡æ ‡%såœ¨è¿‡å»%så°æ—¶å†…æ— æ•°æ®',
               d.device_code, m.metric_name, p_check_hours)::TEXT,
        'warning'::TEXT
    FROM devices d
    CROSS JOIN metrics m
    WHERE d.status = 'active'
      AND NOT EXISTS (
          SELECT 1 FROM sensor_data sd
          WHERE sd.device_id = d.device_id
            AND sd.metric_id = m.metric_id
            AND sd.timestamp > NOW() - (p_check_hours || ' hours')::INTERVAL
      )
      AND NOT EXISTS (
          SELECT 1 FROM anomaly_alerts aa
          WHERE aa.device_id = d.device_id
            AND aa.metric_id = m.metric_id
            AND aa.alert_type = 'missing_data'
            AND aa.created_at > NOW() - INTERVAL '1 hour'
      );

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å¼‚å¸¸æ£€æµ‹å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. æ•°æ®å½’æ¡£ç­–ç•¥

### 7.1 æ•°æ®å½’æ¡£å‡½æ•°

**æ•°æ®å½’æ¡£å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ•°æ®å½’æ¡£è¡¨ï¼ˆå†·æ•°æ®ï¼‰
CREATE TABLE IF NOT EXISTS sensor_data_archive (
    LIKE sensor_data INCLUDING ALL
) PARTITION BY RANGE (timestamp);

-- æ•°æ®å½’æ¡£å‡½æ•°
CREATE OR REPLACE FUNCTION archive_old_data(
    p_retention_days INT DEFAULT 365,
    p_archive_days INT DEFAULT 90
)
RETURNS TABLE (
    archived_partitions INT,
    archived_rows BIGINT
) AS $$
DECLARE
    partition_name TEXT;
    archived_count BIGINT := 0;
    partition_count INT := 0;
    cutoff_date DATE;
BEGIN
    cutoff_date := CURRENT_DATE - p_archive_days;

    -- å½’æ¡£æ—§åˆ†åŒºï¼ˆç§»åŠ¨åˆ°å½’æ¡£è¡¨ï¼‰
    FOR partition_name IN
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
          AND tablename LIKE 'sensor_data_%'
          AND tablename < 'sensor_data_' || to_char(cutoff_date, 'YYYY_MM_DD')
    LOOP
        -- åˆ›å»ºå½’æ¡£åˆ†åŒº
        EXECUTE format('
            CREATE TABLE IF NOT EXISTS sensor_data_archive_%s
            PARTITION OF sensor_data_archive
            FOR VALUES FROM (%L) TO (%L)
        ', substring(partition_name from 'sensor_data_(.*)'),
           substring(partition_name from 'sensor_data_(.*)')::DATE,
           substring(partition_name from 'sensor_data_(.*)')::DATE + 1);

        -- ç§»åŠ¨æ•°æ®ï¼ˆå®é™…åº”è¯¥ç”¨ATTACH/DETACHï¼‰
        EXECUTE format('
            INSERT INTO sensor_data_archive
            SELECT * FROM %I
        ', partition_name);

        -- åˆ é™¤åŸåˆ†åŒº
        EXECUTE format('DROP TABLE IF EXISTS %I', partition_name);

        partition_count := partition_count + 1;
    END LOOP;

    RETURN QUERY SELECT partition_count, archived_count;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ•°æ®å½’æ¡£å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**æ–‡æ¡£å®Œæˆ** âœ…
