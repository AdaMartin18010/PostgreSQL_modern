---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\03-IoTæ—¶åºæ•°æ®ç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# IoTæ—¶åºæ•°æ®ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

> **PostgreSQLç‰ˆæœ¬**: 18.x

---

## å®Œæ•´Schema

```sql
-- è®¾å¤‡è¡¨
CREATE TABLE devices (
    device_id SERIAL PRIMARY KEY,
    device_code VARCHAR(50) UNIQUE,
    device_name VARCHAR(200),
    device_type VARCHAR(50),
    location VARCHAR(200),
    install_date TIMESTAMPTZ,
    status VARCHAR(20) DEFAULT 'active'
);

-- æŒ‡æ ‡å®šä¹‰è¡¨
CREATE TABLE metrics (
    metric_id SERIAL PRIMARY KEY,
    metric_code VARCHAR(50) UNIQUE,
    metric_name VARCHAR(100),
    unit VARCHAR(20),
    normal_min DOUBLE PRECISION,
    normal_max DOUBLE PRECISION,
    alert_min DOUBLE PRECISION,
    alert_max DOUBLE PRECISION
);

-- ä¼ æ„Ÿå™¨æ•°æ®è¡¨ï¼ˆæ ¸å¿ƒè¡¨ï¼ŒæŒ‰å¤©åˆ†åŒºï¼‰
CREATE TABLE sensor_data (
    device_id INT NOT NULL,
    metric_id SMALLINT NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value DOUBLE PRECISION NOT NULL,
    quality SMALLINT DEFAULT 100 CHECK (quality BETWEEN 0 AND 100),
    PRIMARY KEY (device_id, timestamp, metric_id)
) PARTITION BY RANGE (timestamp);

-- æ‰¹é‡åˆ›å»º365å¤©åˆ†åŒº
SELECT create_daily_partitions('sensor_data', 365);

-- â­ BRINç´¢å¼•ï¼ˆæ—¶åºä¼˜åŒ–ï¼‰
CREATE INDEX idx_sensor_data_time
ON sensor_data USING BRIN (timestamp)
WITH (pages_per_range = 128);

CREATE INDEX idx_sensor_data_device
ON sensor_data USING BRIN (device_id, timestamp);

-- â­ PostgreSQL 18ï¼šLZ4å‹ç¼©
ALTER TABLE sensor_data
ALTER COLUMN value SET COMPRESSION lz4;

-- 1åˆ†é’Ÿèšåˆè¡¨
CREATE TABLE sensor_data_1min (
    device_id INT,
    metric_id SMALLINT,
    minute TIMESTAMPTZ,
    avg_value DOUBLE PRECISION,
    min_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    stddev_value DOUBLE PRECISION,
    sample_count INT,
    PRIMARY KEY (device_id, metric_id, minute)
) PARTITION BY RANGE (minute);

-- åˆ›å»º7å¤©åˆ†åŒºï¼ˆåªä¿ç•™7å¤©èšåˆæ•°æ®ï¼‰
SELECT create_daily_partitions('sensor_data_1min', 7);

-- 1å°æ—¶èšåˆè¡¨
CREATE TABLE sensor_data_1hour (
    device_id INT,
    metric_id SMALLINT,
    hour TIMESTAMPTZ,
    avg_value DOUBLE PRECISION,
    min_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    PRIMARY KEY (device_id, metric_id, hour)
);

-- 1å¤©èšåˆè¡¨
CREATE TABLE sensor_data_1day (
    device_id INT,
    metric_id SMALLINT,
    day DATE,
    avg_value DOUBLE PRECISION,
    min_value DOUBLE PRECISION,
    max_value DOUBLE PRECISION,
    PRIMARY KEY (device_id, metric_id, day)
);
```

---

## æ ¸å¿ƒå‡½æ•°

```sql
-- è‡ªåŠ¨åˆ›å»ºåˆ†åŒºå‡½æ•°
CREATE OR REPLACE FUNCTION create_daily_partitions(
    table_name TEXT,
    days_ahead INT
) RETURNS void AS $$
DECLARE
    partition_date DATE;
    partition_name TEXT;
BEGIN
    FOR i IN 0..days_ahead-1 LOOP
        partition_date := CURRENT_DATE + i;
        partition_name := table_name || '_' || TO_CHAR(partition_date, 'YYYY_MM_DD');

        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
            EXECUTE FORMAT(
                'CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
                partition_name, table_name, partition_date, partition_date + 1
            );
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- æ¸…ç†æ—§åˆ†åŒº
CREATE OR REPLACE FUNCTION cleanup_old_partitions(
    table_name TEXT,
    retention_days INT
) RETURNS void AS $$
DECLARE
    partition_name TEXT;
BEGIN
    FOR partition_name IN
        SELECT tablename FROM pg_tables
        WHERE tablename LIKE table_name || '_%'
        AND tablename < table_name || '_' || TO_CHAR(CURRENT_DATE - retention_days, 'YYYY_MM_DD')
    LOOP
        EXECUTE FORMAT('DROP TABLE IF EXISTS %I', partition_name);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶ä»»åŠ¡
SELECT cron.schedule('create-partitions', '0 1 * * *',
    'SELECT create_daily_partitions(''sensor_data'', 365)');

SELECT cron.schedule('cleanup-partitions', '0 2 * * *',
    'SELECT cleanup_old_partitions(''sensor_data'', 365)');
```

---

## å†™å…¥ä¼˜åŒ–

```sql
-- æ‰¹é‡æ’å…¥ä¼˜åŒ–
INSERT INTO sensor_data
SELECT * FROM unnest($1::int[], $2::smallint[], $3::timestamptz[], $4::double precision[]);

-- â­ PostgreSQL 18ï¼šå¼‚æ­¥I/O
-- ååé‡ï¼š800K â†’ 1.2M points/ç§’ (+50%)
```

---

## æŸ¥è¯¢ä¼˜åŒ–

```sql
-- æ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼ˆæœ€å¸¸è§ï¼‰
PREPARE get_device_data (int, timestamptz, timestamptz) AS
SELECT timestamp, value
FROM sensor_data
WHERE device_id = $1
  AND timestamp BETWEEN $2 AND $3
ORDER BY timestamp;

-- æ‰§è¡Œ
EXECUTE get_device_data(1001, NOW() - INTERVAL '1 hour', NOW());

-- â­ PostgreSQL 18ä¼˜åŒ–ï¼š
-- 1. åˆ†åŒºè£å‰ªï¼šåªæ‰«æ1ä¸ªåˆ†åŒº
-- 2. BRINç´¢å¼•ï¼šå¿«é€Ÿå®šä½
-- 3. è®¡åˆ’ç¼“å­˜ï¼šè§„åˆ’æ—¶é—´<1ms
-- æ‰§è¡Œæ—¶é—´ï¼š<50ms
```

---

**æ–‡æ¡£å®Œæˆ** âœ…
