---
> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\09-æ™ºèƒ½å®¢æœç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜
---
> **âš ï¸ é‡è¦æç¤º**: æœ¬æ–‡æ¡£éµå¾ªæ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿æ ¼å¼ã€‚
>
> **æ¨èé˜…è¯»**:
>
> - [æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿](../æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿.md) - é€šç”¨æ¡ˆä¾‹æ–‡æ¡£æ ¼å¼å’Œæœ€ä½³å®è·µ
>
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºæ™ºèƒ½å®¢æœç³»ç»Ÿçš„æ•°æ®åº“è®¾è®¡å‚è€ƒã€‚
---

# æ¡ˆä¾‹9ï¼šæ™ºèƒ½å®¢æœç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

## 1. æ ¸å¿ƒè¡¨è®¾è®¡

### 1.1 FAQè¡¨ï¼ˆçŸ¥è¯†åº“ï¼‰

**FAQè¡¨è®¾è®¡ï¼ˆå¸¦å‘é‡ç´¢å¼•å’Œå…¨æ–‡æœç´¢ï¼‰**ï¼š

```sql
-- FAQè¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'faqs') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector') THEN
                RAISE WARNING 'pgvectoræ‰©å±•æœªå®‰è£…ï¼Œå°†åˆ›å»ºè¡¨ä½†ä¸åŒ…å«å‘é‡åˆ—';
            END IF;

            CREATE TABLE faqs (
    faq_id SERIAL PRIMARY KEY,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    category VARCHAR(50),
    tags TEXT[],  -- æ ‡ç­¾æ•°ç»„
    embedding vector(768),  -- pgvectorå‘é‡ï¼ˆç”¨äºè¯­ä¹‰æ£€ç´¢ï¼‰
    search_vector tsvector,  -- å…¨æ–‡æœç´¢å‘é‡
    view_count INT DEFAULT 0,
    helpful_count INT DEFAULT 0,
    not_helpful_count INT DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',  -- active, inactive, archived
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    created_by INT,
                updated_by INT
            );
            RAISE NOTICE 'FAQè¡¨ faqs åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'FAQè¡¨ faqs å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'è¡¨å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- HNSWå‘é‡ç´¢å¼•ï¼ˆPostgreSQL 18 + pgvectorï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'faqs') THEN
            RAISE WARNING 'è¡¨ faqs ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
            RETURN;
        END IF;

        IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_faqs_embedding') THEN
                CREATE INDEX idx_faqs_embedding
                ON faqs USING hnsw (embedding vector_l2_ops)
                WITH (m = 16, ef_construction = 64);
                RAISE NOTICE 'HNSWå‘é‡ç´¢å¼• idx_faqs_embedding åˆ›å»ºæˆåŠŸ';
            END IF;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_faqs_search_vector') THEN
            CREATE INDEX idx_faqs_search_vector
            ON faqs USING gin (search_vector);
            RAISE NOTICE 'GINå…¨æ–‡æœç´¢ç´¢å¼• idx_faqs_search_vector åˆ›å»ºæˆåŠŸ';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_faqs_category') THEN
            CREATE INDEX idx_faqs_category ON faqs (category) WHERE status = 'active';
            RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_faqs_category åˆ›å»ºæˆåŠŸ';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_faqs_updated_at') THEN
            CREATE INDEX idx_faqs_updated_at ON faqs (updated_at DESC);
            RAISE NOTICE 'ç´¢å¼• idx_faqs_updated_at åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'ç´¢å¼•å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- è‡ªåŠ¨æ›´æ–°search_vectorè§¦å‘å™¨ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION update_faq_search_vector()
RETURNS TRIGGER AS $$
BEGIN
    BEGIN
        IF NEW.question IS NULL AND NEW.answer IS NULL THEN
            NEW.search_vector := NULL;
        ELSE
            NEW.search_vector :=
                setweight(to_tsvector('english', COALESCE(NEW.question, '')), 'A') ||
                setweight(to_tsvector('english', COALESCE(NEW.answer, '')), 'B');
        END IF;
        NEW.updated_at := CURRENT_TIMESTAMP;
        RETURN NEW;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ›´æ–°search_vectorå¤±è´¥: %', SQLERRM;
            RETURN NEW;
    END;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'faqs') THEN
            RAISE WARNING 'è¡¨ faqs ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºè§¦å‘å™¨';
            RETURN;
        END IF;

        DROP TRIGGER IF EXISTS trigger_update_faq_search_vector ON faqs;
        CREATE TRIGGER trigger_update_faq_search_vector
        BEFORE INSERT OR UPDATE OF question, answer ON faqs
        FOR EACH ROW
        EXECUTE FUNCTION update_faq_search_vector();

        RAISE NOTICE 'è§¦å‘å™¨ trigger_update_faq_search_vector åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè§¦å‘å™¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

### 1.2 å¯¹è¯è¡¨ï¼ˆä¼šè¯è®°å½•ï¼‰

**å¯¹è¯è¡¨è®¾è®¡ï¼ˆå¸¦åˆ†åŒºå’Œç´¢å¼•ä¼˜åŒ–ï¼‰**ï¼š

```sql
-- å¯¹è¯è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'conversations') THEN
            CREATE TABLE conversations (
    conv_id BIGSERIAL,
    session_id VARCHAR(100) NOT NULL,
    user_id BIGINT,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    intent VARCHAR(50),  -- æ„å›¾è¯†åˆ«ç»“æœ
    confidence FLOAT,  -- ç½®ä¿¡åº¦
    faq_ids INT[],  -- å…³è”çš„FAQ IDåˆ—è¡¨
    response_time_ms INT,  -- å“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    user_rating INT CHECK (user_rating IN (1, 2, 3, 4, 5)),  -- ç”¨æˆ·è¯„åˆ†
    feedback TEXT,  -- ç”¨æˆ·åé¦ˆ
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (conv_id, created_at)
            ) PARTITION BY RANGE (created_at);
            RAISE NOTICE 'åˆ†åŒºè¡¨ conversations åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'åˆ†åŒºè¡¨ conversations å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'è¡¨å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æŒ‰æœˆåˆ†åŒºï¼ˆPostgreSQL 18è‡ªåŠ¨åˆ†åŒºï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    partition_name TEXT := 'conversations_2025_01';
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'conversations') THEN
            RAISE WARNING 'è¡¨ conversations ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºåˆ†åŒº';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = partition_name) THEN
            CREATE TABLE conversations_2025_01 PARTITION OF conversations
            FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
            RAISE NOTICE 'åˆ†åŒº % åˆ›å»ºæˆåŠŸ', partition_name;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'åˆ†åŒºå·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºåˆ†åŒºå¤±è´¥: %', SQLERRM;
    END;
END $$;

CREATE TABLE conversations_2025_02 PARTITION OF conversations
FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- ä¼šè¯ç´¢å¼•
CREATE INDEX idx_conversations_session
ON conversations (session_id, created_at DESC);

-- ç”¨æˆ·ç´¢å¼•
CREATE INDEX idx_conversations_user
ON conversations (user_id, created_at DESC) WHERE user_id IS NOT NULL;

-- æ„å›¾ç´¢å¼•ï¼ˆç”¨äºç»Ÿè®¡åˆ†æï¼‰
CREATE INDEX idx_conversations_intent
ON conversations (intent, created_at) WHERE intent IS NOT NULL;

-- è¯„åˆ†ç´¢å¼•ï¼ˆç”¨äºè´¨é‡åˆ†æï¼‰
CREATE INDEX idx_conversations_rating
ON conversations (user_rating, created_at) WHERE user_rating IS NOT NULL;
```

### 1.3 ä¼šè¯è¡¨ï¼ˆä¼šè¯ç®¡ç†ï¼‰

**ä¼šè¯è¡¨è®¾è®¡ï¼ˆå¸¦çŠ¶æ€ç®¡ç†ï¼‰**ï¼š

```sql
-- ä¼šè¯è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sessions') THEN
            CREATE TABLE sessions (
    session_id VARCHAR(100) PRIMARY KEY,
    user_id BIGINT,
    channel VARCHAR(20) NOT NULL,  -- web, mobile, api, wechat
    status VARCHAR(20) DEFAULT 'active',  -- active, closed, timeout
    metadata JSONB,  -- ä¼šè¯å…ƒæ•°æ®ï¼ˆIPã€User-Agentç­‰ï¼‰
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    closed_at TIMESTAMPTZ,
    last_message_at TIMESTAMPTZ
);

-- ç”¨æˆ·ä¼šè¯ç´¢å¼•
CREATE INDEX idx_sessions_user
ON sessions (user_id, created_at DESC) WHERE user_id IS NOT NULL;

-- çŠ¶æ€ç´¢å¼•
CREATE INDEX idx_sessions_status
ON sessions (status, updated_at) WHERE status = 'active';

-- é€šé“ç´¢å¼•
CREATE INDEX idx_sessions_channel
ON sessions (channel, created_at DESC);

-- è‡ªåŠ¨æ›´æ–°updated_atè§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_sessions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    IF NEW.status = 'closed' AND OLD.status != 'closed' THEN
        NEW.closed_at := CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_sessions_updated_at
BEFORE UPDATE ON sessions
FOR EACH ROW
EXECUTE FUNCTION update_sessions_updated_at();
```

---

## 2. è¾…åŠ©è¡¨è®¾è®¡

### 2.1 æ„å›¾è¯†åˆ«æ—¥å¿—è¡¨

**æ„å›¾è¯†åˆ«æ—¥å¿—è¡¨è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ„å›¾è¯†åˆ«æ—¥å¿—è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'intent_logs') THEN
            CREATE TABLE intent_logs (
    log_id BIGSERIAL PRIMARY KEY,
    question TEXT NOT NULL,
    intent VARCHAR(50),
    confidence FLOAT,
    entities JSONB,  -- å®ä½“è¯†åˆ«ç»“æœ
    model_version VARCHAR(50),  -- æ¨¡å‹ç‰ˆæœ¬
    processing_time_ms INT,  -- å¤„ç†æ—¶é—´
    error_message TEXT,  -- é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- æ„å›¾ç»Ÿè®¡ç´¢å¼•
CREATE INDEX idx_intent_logs_intent
ON intent_logs (intent, created_at) WHERE intent IS NOT NULL;

-- æ—¶é—´ç´¢å¼•
CREATE INDEX idx_intent_logs_created
ON intent_logs (created_at DESC);
```

### 2.2 æŸ¥è¯¢æ—¥å¿—è¡¨ï¼ˆæ€§èƒ½ç›‘æ§ï¼‰

**æŸ¥è¯¢æ—¥å¿—è¡¨è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢æ—¥å¿—è¡¨
CREATE TABLE query_logs (
    log_id BIGSERIAL PRIMARY KEY,
    session_id VARCHAR(100),
    query_type VARCHAR(50),  -- vector_search, fulltext_search, hybrid
    query_text TEXT,
    result_count INT,
    duration_ms FLOAT,
    cache_hit BOOLEAN DEFAULT FALSE,
    success BOOLEAN DEFAULT TRUE,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE query_logs_2025_01 PARTITION OF query_logs
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- æŸ¥è¯¢ç±»å‹ç´¢å¼•
CREATE INDEX idx_query_logs_type
ON query_logs (query_type, created_at);

-- æ€§èƒ½åˆ†æç´¢å¼•
CREATE INDEX idx_query_logs_performance
ON query_logs (duration_ms, created_at) WHERE success = TRUE;
```

### 2.3 å·¥å•è¡¨ï¼ˆå‡çº§å¤„ç†ï¼‰

**å·¥å•è¡¨è®¾è®¡ï¼ˆå¸¦çŠ¶æ€æµè½¬ï¼‰**ï¼š

```sql
-- å·¥å•è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'tickets') THEN
            CREATE TABLE tickets (
    ticket_id SERIAL PRIMARY KEY,
    session_id VARCHAR(100),
    user_id BIGINT,
    title VARCHAR(200) NOT NULL,
    description TEXT NOT NULL,
    category VARCHAR(50),
    priority VARCHAR(20) DEFAULT 'normal',  -- low, normal, high, urgent
    status VARCHAR(20) DEFAULT 'open',  -- open, assigned, in_progress, resolved, closed
    assigned_to INT,  -- åˆ†é…ç»™å“ªä¸ªå®¢æœ
    resolution TEXT,  -- è§£å†³æ–¹æ¡ˆ
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMPTZ,
    closed_at TIMESTAMPTZ
);

-- çŠ¶æ€ç´¢å¼•
CREATE INDEX idx_tickets_status
ON tickets (status, created_at DESC);

-- ä¼˜å…ˆçº§ç´¢å¼•
CREATE INDEX idx_tickets_priority
ON tickets (priority, created_at DESC) WHERE status != 'closed';

-- åˆ†é…ç´¢å¼•
CREATE INDEX idx_tickets_assigned
ON tickets (assigned_to, status) WHERE assigned_to IS NOT NULL;

-- ç”¨æˆ·å·¥å•ç´¢å¼•
CREATE INDEX idx_tickets_user
ON tickets (user_id, created_at DESC) WHERE user_id IS NOT NULL;
```

---

## 3. æ ¸å¿ƒæŸ¥è¯¢å‡½æ•°

### 3.1 å‘é‡æ£€ç´¢FAQå‡½æ•°

**å‘é‡æ£€ç´¢FAQå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å‘é‡æ£€ç´¢FAQå‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION search_faqs_by_vector(
    p_query_vector vector(768),
    p_top_k INT DEFAULT 5,
    p_threshold FLOAT DEFAULT 0.7,
    p_category VARCHAR(50) DEFAULT NULL
)
RETURNS TABLE (
    faq_id INT,
    question TEXT,
    answer TEXT,
    category VARCHAR(50),
    similarity FLOAT
) AS $$
DECLARE
    v_start_time TIMESTAMPTZ;
    v_duration_ms FLOAT;
BEGIN
    v_start_time := clock_timestamp();

    -- å‘é‡æ£€ç´¢
    RETURN QUERY
    SELECT
        f.faq_id,
        f.question,
        f.answer,
        f.category,
        (1 - (f.embedding <=> p_query_vector))::FLOAT AS similarity
    FROM faqs f
    WHERE f.status = 'active'
        AND (1 - (f.embedding <=> p_query_vector)) >= p_threshold
        AND (p_category IS NULL OR f.category = p_category)
    ORDER BY f.embedding <=> p_query_vector
    LIMIT p_top_k;

    -- è®°å½•æŸ¥è¯¢æ—¥å¿—
    v_duration_ms := EXTRACT(EPOCH FROM (clock_timestamp() - v_start_time)) * 1000;

    INSERT INTO query_logs (query_type, result_count, duration_ms, success)
    VALUES ('vector_search', (SELECT COUNT(*) FROM (SELECT * FROM search_faqs_by_vector(p_query_vector, p_top_k, p_threshold, p_category)) t), v_duration_ms, TRUE);

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        -- è®°å½•é”™è¯¯
        INSERT INTO query_logs (query_type, error_message, success)
        VALUES ('vector_search', SQLERRM, FALSE);

        RAISE EXCEPTION 'å‘é‡æ£€ç´¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 å…¨æ–‡æœç´¢FAQå‡½æ•°

**å…¨æ–‡æœç´¢FAQå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å…¨æ–‡æœç´¢FAQå‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION search_faqs_by_text(
    p_query_text TEXT,
    p_top_k INT DEFAULT 5,
    p_category VARCHAR(50) DEFAULT NULL
)
RETURNS TABLE (
    faq_id INT,
    question TEXT,
    answer TEXT,
    category VARCHAR(50),
    rank FLOAT
) AS $$
DECLARE
    v_query_vector tsvector;
    v_start_time TIMESTAMPTZ;
    v_duration_ms FLOAT;
BEGIN
    v_start_time := clock_timestamp();

    -- æ„å»ºæŸ¥è¯¢å‘é‡
    v_query_vector := plainto_tsquery('english', p_query_text)::text::tsvector;

    -- å…¨æ–‡æœç´¢
    RETURN QUERY
    SELECT
        f.faq_id,
        f.question,
        f.answer,
        f.category,
        ts_rank_cd(f.search_vector, plainto_tsquery('english', p_query_text)) AS rank
    FROM faqs f
    WHERE f.status = 'active'
        AND f.search_vector @@ plainto_tsquery('english', p_query_text)
        AND (p_category IS NULL OR f.category = p_category)
    ORDER BY rank DESC
    LIMIT p_top_k;

    -- è®°å½•æŸ¥è¯¢æ—¥å¿—
    v_duration_ms := EXTRACT(EPOCH FROM (clock_timestamp() - v_start_time)) * 1000;

    INSERT INTO query_logs (query_type, query_text, result_count, duration_ms, success)
    VALUES ('fulltext_search', p_query_text, (SELECT COUNT(*) FROM (SELECT * FROM search_faqs_by_text(p_query_text, p_top_k, p_category)) t), v_duration_ms, TRUE);

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        -- è®°å½•é”™è¯¯
        INSERT INTO query_logs (query_type, query_text, error_message, success)
        VALUES ('fulltext_search', p_query_text, SQLERRM, FALSE);

        RAISE EXCEPTION 'å…¨æ–‡æœç´¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 3.3 æ··åˆæ£€ç´¢å‡½æ•°

**æ··åˆæ£€ç´¢å‡½æ•°ï¼ˆå‘é‡+å…¨æ–‡æœç´¢ï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ··åˆæ£€ç´¢å‡½æ•°ï¼ˆå‘é‡+å…¨æ–‡æœç´¢ï¼Œå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION search_faqs_hybrid(
    p_query_vector vector(768),
    p_query_text TEXT,
    p_top_k INT DEFAULT 5,
    p_vector_weight FLOAT DEFAULT 0.6,
    p_text_weight FLOAT DEFAULT 0.4
)
RETURNS TABLE (
    faq_id INT,
    question TEXT,
    answer TEXT,
    category VARCHAR(50),
    combined_score FLOAT
) AS $$
DECLARE
    v_start_time TIMESTAMPTZ;
    v_duration_ms FLOAT;
BEGIN
    v_start_time := clock_timestamp();

    -- æ··åˆæ£€ç´¢ï¼šç»“åˆå‘é‡ç›¸ä¼¼åº¦å’Œå…¨æ–‡æœç´¢æ’å
    RETURN QUERY
    WITH vector_results AS (
        SELECT
            f.faq_id,
            f.question,
            f.answer,
            f.category,
            (1 - (f.embedding <=> p_query_vector))::FLOAT AS vector_score
        FROM faqs f
        WHERE f.status = 'active'
        ORDER BY f.embedding <=> p_query_vector
        LIMIT p_top_k * 2
    ),
    text_results AS (
        SELECT
            f.faq_id,
            ts_rank_cd(f.search_vector, plainto_tsquery('english', p_query_text)) AS text_score
        FROM faqs f
        WHERE f.status = 'active'
            AND f.search_vector @@ plainto_tsquery('english', p_query_text)
        ORDER BY text_score DESC
        LIMIT p_top_k * 2
    )
    SELECT
        COALESCE(v.faq_id, t.faq_id) AS faq_id,
        COALESCE(v.question, f.question) AS question,
        COALESCE(v.answer, f.answer) AS answer,
        COALESCE(v.category, f.category) AS category,
        (COALESCE(v.vector_score, 0) * p_vector_weight +
         COALESCE(t.text_score, 0) * p_text_weight) AS combined_score
    FROM vector_results v
    FULL OUTER JOIN text_results t ON v.faq_id = t.faq_id
    LEFT JOIN faqs f ON COALESCE(v.faq_id, t.faq_id) = f.faq_id
    ORDER BY combined_score DESC
    LIMIT p_top_k;

    -- è®°å½•æŸ¥è¯¢æ—¥å¿—
    v_duration_ms := EXTRACT(EPOCH FROM (clock_timestamp() - v_start_time)) * 1000;

    INSERT INTO query_logs (query_type, query_text, result_count, duration_ms, success)
    VALUES ('hybrid', p_query_text, (SELECT COUNT(*) FROM (SELECT * FROM search_faqs_hybrid(p_query_vector, p_query_text, p_top_k, p_vector_weight, p_text_weight)) t), v_duration_ms, TRUE);

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        -- è®°å½•é”™è¯¯
        INSERT INTO query_logs (query_type, query_text, error_message, success)
        VALUES ('hybrid', p_query_text, SQLERRM, FALSE);

        RAISE EXCEPTION 'æ··åˆæ£€ç´¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. ç»Ÿè®¡è§†å›¾

### 4.1 å¯¹è¯ç»Ÿè®¡è§†å›¾

**å¯¹è¯ç»Ÿè®¡è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¯¹è¯ç»Ÿè®¡è§†å›¾
CREATE OR REPLACE VIEW v_conversation_stats AS
SELECT
    DATE_TRUNC('day', created_at) AS stat_date,
    COUNT(DISTINCT session_id) AS session_count,
    COUNT(*) AS message_count,
    COUNT(*) FILTER (WHERE answer IS NOT NULL) AS answered_count,
    ROUND(
        COUNT(*) FILTER (WHERE answer IS NOT NULL) * 100.0 / NULLIF(COUNT(*), 0),
        2
    ) AS answer_rate,
    ROUND(AVG(LENGTH(question)), 2) AS avg_question_length,
    ROUND(AVG(LENGTH(answer)), 2) AS avg_answer_length,
    ROUND(AVG(response_time_ms), 2) AS avg_response_time_ms,
    ROUND(AVG(user_rating), 2) AS avg_user_rating,
    COUNT(*) FILTER (WHERE user_rating >= 4) AS satisfied_count,
    ROUND(
        COUNT(*) FILTER (WHERE user_rating >= 4) * 100.0 /
        NULLIF(COUNT(*) FILTER (WHERE user_rating IS NOT NULL), 0),
        2
    ) AS satisfaction_rate
FROM conversations
WHERE created_at > NOW() - INTERVAL '30 days'
GROUP BY DATE_TRUNC('day', created_at)
ORDER BY stat_date DESC;

-- æŸ¥è¯¢ç»Ÿè®¡
SELECT * FROM v_conversation_stats LIMIT 30;
```

### 4.2 FAQä½¿ç”¨ç»Ÿè®¡è§†å›¾

**FAQä½¿ç”¨ç»Ÿè®¡è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- FAQä½¿ç”¨ç»Ÿè®¡è§†å›¾
CREATE OR REPLACE VIEW v_faq_usage_stats AS
SELECT
    f.faq_id,
    f.question,
    f.category,
    COUNT(DISTINCT c.session_id) AS session_count,
    COUNT(c.conv_id) AS usage_count,
    ROUND(AVG(c.user_rating), 2) AS avg_rating,
    COUNT(*) FILTER (WHERE c.user_rating >= 4) AS satisfied_count,
    f.view_count,
    f.helpful_count,
    f.not_helpful_count,
    f.updated_at
FROM faqs f
LEFT JOIN conversations c ON f.faq_id = ANY(c.faq_ids)
WHERE f.status = 'active'
GROUP BY f.faq_id, f.question, f.category, f.view_count, f.helpful_count, f.not_helpful_count, f.updated_at
ORDER BY usage_count DESC, avg_rating DESC;

-- æŸ¥è¯¢ä½¿ç”¨ç»Ÿè®¡
SELECT * FROM v_faq_usage_stats LIMIT 20;
```

---

## 5. PostgreSQL 18ç‰¹æ€§åº”ç”¨

### 5.1 å¼‚æ­¥I/Oä¼˜åŒ–

**å¼‚æ­¥I/Oé…ç½®ï¼ˆPostgreSQL 18ï¼‰**ï¼š

```sql
-- PostgreSQL 18å¼‚æ­¥I/Oé…ç½®
ALTER SYSTEM SET io_direct = 'data';
ALTER SYSTEM SET io_combine_limit = '128kB';

-- é‡å¯åç”Ÿæ•ˆ
SELECT pg_reload_conf();
```

### 5.2 å†…ç½®è¿æ¥æ± 

**å†…ç½®è¿æ¥æ± é…ç½®ï¼ˆPostgreSQL 18ï¼‰**ï¼š

```sql
-- PostgreSQL 18å†…ç½®è¿æ¥æ± é…ç½®
ALTER SYSTEM SET pool_mode = 'transaction';
ALTER SYSTEM SET pool_size = 100;
ALTER SYSTEM SET pool_max_wait = 5;

-- é‡å¯åç”Ÿæ•ˆ
SELECT pg_reload_conf();
```

### 5.3 æ”¹è¿›çš„VACUUM

**æ”¹è¿›çš„VACUUMé…ç½®ï¼ˆPostgreSQL 18ï¼‰**ï¼š

```sql
-- PostgreSQL 18æ”¹è¿›çš„VACUUMé…ç½®
ALTER SYSTEM SET vacuum_cost_delay = 0;
ALTER SYSTEM SET vacuum_cost_limit = 10000;

-- è‡ªåŠ¨VACUUMé…ç½®
ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.05;
ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02;
```

---

## 6. æ•°æ®ç»´æŠ¤å‡½æ•°

### 6.1 FAQå‘é‡æ›´æ–°å‡½æ•°

**FAQå‘é‡æ›´æ–°å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ‰¹é‡æ›´æ–°FAQå‘é‡
CREATE OR REPLACE FUNCTION update_faq_embeddings_batch(
    p_batch_size INT DEFAULT 100
)
RETURNS TABLE (
    updated_count INT,
    error_count INT
) AS $$
DECLARE
    v_faq RECORD;
    v_updated INT := 0;
    v_errors INT := 0;
    v_embedding vector(768);
BEGIN
    -- éå†éœ€è¦æ›´æ–°çš„FAQ
    FOR v_faq IN
        SELECT faq_id, question
        FROM faqs
        WHERE embedding IS NULL OR updated_at > created_at
        LIMIT p_batch_size
    LOOP
        BEGIN
            -- è°ƒç”¨AIæœåŠ¡ç”Ÿæˆå‘é‡ï¼ˆç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è°ƒç”¨pg_aiæˆ–å¤–éƒ¨APIï¼‰
            -- v_embedding := ai.embedding_openai('text-embedding-3-small', v_faq.question)::vector(768);

            -- æ›´æ–°å‘é‡
            UPDATE faqs
            SET embedding = v_embedding,
                updated_at = CURRENT_TIMESTAMP
            WHERE faq_id = v_faq.faq_id;

            v_updated := v_updated + 1;

        EXCEPTION
            WHEN OTHERS THEN
                v_errors := v_errors + 1;
                RAISE WARNING 'æ›´æ–°FAQ % å‘é‡å¤±è´¥: %', v_faq.faq_id, SQLERRM;
        END;
    END LOOP;

    RETURN QUERY SELECT v_updated, v_errors;

    RETURN;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 ä¼šè¯æ¸…ç†å‡½æ•°

**ä¼šè¯æ¸…ç†å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ¸…ç†è¿‡æœŸä¼šè¯
CREATE OR REPLACE FUNCTION cleanup_expired_sessions(
    p_timeout_hours INT DEFAULT 24
)
RETURNS TABLE (
    closed_count INT
) AS $$
DECLARE
    v_closed INT := 0;
BEGIN
    -- å…³é—­è¶…æ—¶ä¼šè¯
    UPDATE sessions
    SET status = 'closed',
        closed_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE status = 'active'
        AND last_message_at < NOW() - (p_timeout_hours || ' hours')::INTERVAL;

    GET DIAGNOSTICS v_closed = ROW_COUNT;

    RETURN QUERY SELECT v_closed;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ¸…ç†è¿‡æœŸä¼šè¯å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 7.1 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–å»ºè®®**ï¼š

```sql
-- 1. å®šæœŸé‡å»ºç´¢å¼•
REINDEX INDEX CONCURRENTLY idx_faqs_embedding;
REINDEX INDEX CONCURRENTLY idx_faqs_search_vector;

-- 2. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
ANALYZE faqs;
ANALYZE conversations;
ANALYZE sessions;

-- 3. æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

### 7.2 åˆ†åŒºç»´æŠ¤

**åˆ†åŒºç»´æŠ¤å»ºè®®**ï¼š

```sql
-- 1. åˆ›å»ºæ–°åˆ†åŒºï¼ˆæ¯æœˆæ‰§è¡Œï¼‰
CREATE TABLE conversations_2025_03 PARTITION OF conversations
FOR VALUES FROM ('2025-03-01') TO ('2025-04-01');

-- 2. åˆ é™¤æ—§åˆ†åŒºï¼ˆä¿ç•™12ä¸ªæœˆï¼‰
DROP TABLE IF EXISTS conversations_2024_01;

-- 3. æ£€æŸ¥åˆ†åŒºå¤§å°
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE tablename LIKE 'conversations_%'
ORDER BY tablename;
```

---

**å®Œæˆ**: æ™ºèƒ½å®¢æœç³»ç»Ÿæ•°æ®åº“è®¾è®¡
**å­—æ•°**: ~8,000å­—
**æ¶µç›–**: æ ¸å¿ƒè¡¨è®¾è®¡ã€è¾…åŠ©è¡¨ã€æŸ¥è¯¢å‡½æ•°ã€ç»Ÿè®¡è§†å›¾ã€PostgreSQL 18ç‰¹æ€§ã€æ•°æ®ç»´æŠ¤ã€æ€§èƒ½ä¼˜åŒ–

**è¿”å›**: [æ¡ˆä¾‹9ä¸»é¡µ](./README.md)
