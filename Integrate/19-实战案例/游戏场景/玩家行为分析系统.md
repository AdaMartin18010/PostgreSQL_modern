---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\æ¸¸æˆåœºæ™¯\ç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿ.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# ç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 18+ (æ¨è) â­ | 17+ | TimescaleDB 2.11+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-10-01

## ğŸ“‘ ç›®å½•

- [ç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿ](#ç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
  - [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
    - [2.1 ç©å®¶è¡Œä¸ºåˆ†æä½“ç³»æ€ç»´å¯¼å›¾](#21-ç©å®¶è¡Œä¸ºåˆ†æä½“ç³»æ€ç»´å¯¼å›¾)
    - [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
    - [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
  - [3. æ•°æ®æ¨¡å‹è®¾è®¡](#3-æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.0 æ•°æ®æ¨¡å‹ERå›¾](#30-æ•°æ®æ¨¡å‹erå›¾)
    - [3.1 ç©å®¶è¡Œä¸ºæ—¶åºè¡¨](#31-ç©å®¶è¡Œä¸ºæ—¶åºè¡¨)
    - [3.2 ç©å®¶ç”»åƒè¡¨](#32-ç©å®¶ç”»åƒè¡¨)
    - [3.3 æ¸¸æˆäº‹ä»¶è¡¨](#33-æ¸¸æˆäº‹ä»¶è¡¨)
  - [4. è¡Œä¸ºåˆ†æç®—æ³•](#4-è¡Œä¸ºåˆ†æç®—æ³•)
    - [4.1 ç©å®¶åˆ†ç¾¤](#41-ç©å®¶åˆ†ç¾¤)
    - [4.2 æµå¤±é¢„æµ‹](#42-æµå¤±é¢„æµ‹)
    - [4.3 ä»˜è´¹é¢„æµ‹](#43-ä»˜è´¹é¢„æµ‹)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 æ¡ˆä¾‹: æ‰‹æ¸¸ç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-æ‰‹æ¸¸ç©å®¶è¡Œä¸ºåˆ†æç³»ç»ŸçœŸå®æ¡ˆä¾‹)
    - [5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#52-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 æ•°æ®é‡‡é›†](#61-æ•°æ®é‡‡é›†)
    - [6.2 åˆ†ææ¨¡å‹ä¼˜åŒ–](#62-åˆ†ææ¨¡å‹ä¼˜åŒ–)
    - [6.3 è¿è¥åº”ç”¨](#63-è¿è¥åº”ç”¨)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)
  - [8. å®Œæ•´ä»£ç ç¤ºä¾‹](#8-å®Œæ•´ä»£ç ç¤ºä¾‹)
    - [8.1 ç©å®¶è¡Œä¸ºæ•°æ®è¡¨åˆ›å»º](#81-ç©å®¶è¡Œä¸ºæ•°æ®è¡¨åˆ›å»º)
    - [8.2 ç©å®¶è¡Œä¸ºåˆ†æå®ç°](#82-ç©å®¶è¡Œä¸ºåˆ†æå®ç°)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

æ¸¸æˆç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿéœ€è¦ï¼š

- **è¡Œä¸ºè¿½è¸ª**: è¿½è¸ªç©å®¶æ¸¸æˆè¡Œä¸º
- **ç©å®¶åˆ†ç¾¤**: å¯¹ç©å®¶è¿›è¡Œåˆ†ç¾¤åˆ†æ
- **æµå¤±é¢„æµ‹**: é¢„æµ‹ç©å®¶æµå¤±é£é™©
- **ä»˜è´¹é¢„æµ‹**: é¢„æµ‹ç©å®¶ä»˜è´¹æ„æ„¿

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **æ—¶åºæ•°æ®åº“**: TimescaleDBï¼ˆPostgreSQL æ‰©å±•ï¼‰
- **å‘é‡æœç´¢**: pgvector å‘é‡ç›¸ä¼¼åº¦è®¡ç®—ç©å®¶ç›¸ä¼¼æ€§
- **æœºå™¨å­¦ä¹ **: ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹è¿›è¡Œé¢„æµ‹

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
|--------|------|------|
| **æµå¤±ç‡** | æµå¤±é¢„æµ‹é™ä½æµå¤±ç‡ | **-30%** |
| **ä»˜è´¹è½¬åŒ–ç‡** | ç²¾å‡†è¥é”€æå‡ä»˜è´¹ç‡ | **+25%** |
| **ç©å®¶ç•™å­˜ç‡** | ä¸ªæ€§åŒ–è¿è¥æå‡ç•™å­˜ | **+20%** |
| **æŸ¥è¯¢æ€§èƒ½** | æ—¶åºä¼˜åŒ–æå‡æ€§èƒ½ | **10x** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **æµå¤±ç‡**: æµå¤±é¢„æµ‹å’Œå¹²é¢„é™ä½æµå¤±ç‡ 30%
- **ä»˜è´¹è½¬åŒ–ç‡**: ç²¾å‡†è¥é”€æå‡ä»˜è´¹è½¬åŒ–ç‡ 25%
- **ç©å®¶ç•™å­˜ç‡**: ä¸ªæ€§åŒ–è¿è¥æå‡ç©å®¶ç•™å­˜ç‡ 20%
- **æŸ¥è¯¢æ€§èƒ½**: æ—¶åºä¼˜åŒ–æå‡æŸ¥è¯¢æ€§èƒ½ 10 å€

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 ç©å®¶è¡Œä¸ºåˆ†æä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((ç©å®¶è¡Œä¸ºåˆ†æ))
    æ•°æ®å±‚
      è¡Œä¸ºæ•°æ®
        ç™»å½•è¡Œä¸º
        æ¸¸æˆè¡Œä¸º
        ä»˜è´¹è¡Œä¸º
        ç¤¾äº¤è¡Œä¸º
      ç©å®¶æ•°æ®
        ç©å®¶ä¿¡æ¯
        ç©å®¶ç”»åƒ
        ç©å®¶ç­‰çº§
        ç©å®¶å±æ€§
      æ¸¸æˆæ•°æ®
        æ¸¸æˆäº‹ä»¶
        æ¸¸æˆè¿›åº¦
        æ¸¸æˆæˆå°±
        æ¸¸æˆæ•°æ®
    å­˜å‚¨å±‚
      æ—¶åºæ•°æ®åº“
        TimescaleDB
        è¡Œä¸ºæ—¶åº
        äº‹ä»¶æ—¶åº
        æ•°æ®å‹ç¼©
        è¿ç»­èšåˆ
      å‘é‡æ•°æ®åº“
        pgvector
        ç©å®¶å‘é‡
        è¡Œä¸ºå‘é‡
        ç›¸ä¼¼åº¦æœç´¢
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        åŸºç¡€æ•°æ®
        å…ƒæ•°æ®
        é…ç½®ä¿¡æ¯
    å¤„ç†å±‚
      æ•°æ®é‡‡é›†
        å®æ—¶é‡‡é›†
        æ‰¹é‡é‡‡é›†
        æ•°æ®æ¸…æ´—
        æ•°æ®éªŒè¯
      å‘é‡åŒ–å¤„ç†
        ç©å®¶å‘é‡åŒ–
        è¡Œä¸ºå‘é‡åŒ–
        ç‰¹å¾æå–
        å‘é‡ä¼˜åŒ–
      åˆ†æç®—æ³•
        ç©å®¶åˆ†ç¾¤
        æµå¤±é¢„æµ‹
        ä»˜è´¹é¢„æµ‹
        è¡Œä¸ºåˆ†æ
    åº”ç”¨å±‚
      ç©å®¶åˆ†ç¾¤
        èšç±»åˆ†æ
        åˆ†ç¾¤ç®¡ç†
        åˆ†ç¾¤åº”ç”¨
        åˆ†ç¾¤ä¼˜åŒ–
      æµå¤±é¢„æµ‹
        æµå¤±åˆ†æ
        æµå¤±é¢„è­¦
        æµå¤±å¹²é¢„
        æµå¤±æŒ½å›
      ä»˜è´¹é¢„æµ‹
        ä»˜è´¹åˆ†æ
        ä»˜è´¹é¢„æµ‹
        ç²¾å‡†è¥é”€
        ä»˜è´¹ä¼˜åŒ–
      è¿è¥å†³ç­–
        æ•°æ®æŠ¥è¡¨
        å†³ç­–æ”¯æŒ
        è¿è¥å»ºè®®
        æ•ˆæœè¯„ä¼°
    åº”ç”¨åœºæ™¯
      æ¸¸æˆè¿è¥
        ç©å®¶è¿è¥
        æ´»åŠ¨è¿è¥
        ä»˜è´¹è¿è¥
        ç•™å­˜è¿è¥
      æ¸¸æˆå¼€å‘
        æ¸¸æˆä¼˜åŒ–
        åŠŸèƒ½è®¾è®¡
        å†…å®¹æ¨è
        ä½“éªŒä¼˜åŒ–
      æ•°æ®åˆ†æ
        è¡Œä¸ºåˆ†æ
        è¶‹åŠ¿åˆ†æ
        é¢„æµ‹åˆ†æ
        æ•ˆæœåˆ†æ
```

### 2.2 æ¶æ„è®¾è®¡

```text
æ¸¸æˆäº‹ä»¶é‡‡é›†
  â†“
æ—¶åºæ•°æ®å­˜å‚¨ï¼ˆTimescaleDBï¼‰
  â”œâ”€â”€ ç©å®¶è¡Œä¸ºæ•°æ®
  â””â”€â”€ æ¸¸æˆäº‹ä»¶æ•°æ®
  â†“
å‘é‡åŒ–å¤„ç†
  â†“
å‘é‡æ•°æ®å­˜å‚¨ï¼ˆpgvectorï¼‰
  â†“
è¡Œä¸ºåˆ†æå¼•æ“
  â”œâ”€â”€ ç©å®¶åˆ†ç¾¤
  â”œâ”€â”€ æµå¤±é¢„æµ‹
  â””â”€â”€ ä»˜è´¹é¢„æµ‹
  â†“
è¿è¥å†³ç­–æ”¯æŒ
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + TimescaleDB + pgvector
- **æ•°æ®é‡‡é›†**: æ¸¸æˆ SDKã€äº‹ä»¶è¿½è¸ª
- **åˆ†ææ¨¡å‹**: Python + scikit-learnã€XGBoost
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.0 æ•°æ®æ¨¡å‹ERå›¾

```mermaid
erDiagram
    player_profiles ||--o{ player_behaviors : "generates"
    player_profiles ||--o{ game_events : "triggers"

    player_profiles {
        text player_id PK
        date registration_date
        int total_play_time
        decimal total_spent
        int current_level
        vector embedding
        jsonb profile_data
        timestamptz last_updated
    }

    player_behaviors {
        timestamptz time PK
        text player_id FK
        text event_type
        int game_level
        int duration
        jsonb metadata
    }

    game_events {
        int id PK
        text player_id FK
        text event_type
        jsonb event_data
        timestamptz timestamp
    }
```

**æ•°æ®æ¨¡å‹è¯´æ˜**:

- **player_profiles**: ç©å®¶ç”»åƒè¡¨ï¼Œå­˜å‚¨ç©å®¶ä¿¡æ¯å’Œè¡Œä¸ºå‘é‡
- **player_behaviors**: ç©å®¶è¡Œä¸ºæ—¶åºè¡¨ï¼ˆTimescaleDBï¼‰ï¼Œå­˜å‚¨ç©å®¶è¡Œä¸ºæ•°æ®
- **game_events**: æ¸¸æˆäº‹ä»¶è¡¨ï¼Œå­˜å‚¨æ¸¸æˆäº‹ä»¶æ•°æ®

### 3.1 ç©å®¶è¡Œä¸ºæ—¶åºè¡¨

```sql
-- åˆ›å»ºç©å®¶è¡Œä¸ºæ—¶åºè¡¨
CREATE TABLE player_behaviors (
    time TIMESTAMPTZ NOT NULL,
    player_id TEXT NOT NULL,
    event_type TEXT NOT NULL,  -- 'login', 'play', 'purchase', 'logout'
    game_level INTEGER,
    duration INTEGER,
    metadata JSONB
);

-- è½¬æ¢ä¸ºæ—¶åºè¡¨
SELECT create_hypertable('player_behaviors', 'time');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX player_behaviors_player_time_idx ON player_behaviors (player_id, time DESC);
CREATE INDEX player_behaviors_event_time_idx ON player_behaviors (event_type, time DESC);
```

### 3.2 ç©å®¶ç”»åƒè¡¨

```sql
CREATE TABLE player_profiles (
    player_id TEXT PRIMARY KEY,
    registration_date DATE,
    total_play_time INTEGER,
    total_spent DECIMAL(10, 2),
    current_level INTEGER,
    embedding vector(1536),
    profile_data JSONB,
    last_updated TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX player_profiles_embedding_idx ON player_profiles USING hnsw (embedding vector_cosine_ops);
CREATE INDEX player_profiles_level_idx ON player_profiles (current_level);
```

### 3.3 æ¸¸æˆäº‹ä»¶è¡¨

```sql
CREATE TABLE game_events (
    id SERIAL PRIMARY KEY,
    player_id TEXT NOT NULL,
    event_type TEXT NOT NULL,
    event_data JSONB,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX game_events_player_time_idx ON game_events (player_id, timestamp DESC);
CREATE INDEX game_events_type_time_idx ON game_events (event_type, timestamp DESC);
```

## 4. è¡Œä¸ºåˆ†æç®—æ³•

### 4.1 ç©å®¶åˆ†ç¾¤

```python
# ç©å®¶åˆ†ç¾¤
class PlayerClustering:
    async def cluster_players(self, n_clusters=5):
        """ç©å®¶åˆ†ç¾¤"""
        # 1. è·å–ç©å®¶ç‰¹å¾å‘é‡
        players = await self.db.fetch("""
            SELECT player_id, embedding FROM player_profiles
        """)

        # 2. ä½¿ç”¨ K-means èšç±»
        embeddings = np.array([p['embedding'] for p in players])
        from sklearn.cluster import KMeans
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        clusters = kmeans.fit_predict(embeddings)

        # 3. ä¿å­˜åˆ†ç¾¤ç»“æœ
        for player, cluster_id in zip(players, clusters):
            await self.db.execute("""
                UPDATE player_profiles
                SET profile_data = jsonb_set(
                    COALESCE(profile_data, '{}'::jsonb),
                    '{cluster_id}',
                    $1::text::jsonb
                )
                WHERE player_id = $2
            """, cluster_id, player['player_id'])

        return clusters
```

### 4.2 æµå¤±é¢„æµ‹

```python
# æµå¤±é¢„æµ‹
class ChurnPrediction:
    async def predict_churn(self, player_id, days=7):
        """é¢„æµ‹ç©å®¶æµå¤±é£é™©"""
        # 1. è·å–ç©å®¶æœ€è¿‘è¡Œä¸ºæ•°æ®
        recent_behaviors = await self.db.fetch("""
            SELECT
                time_bucket('1 day', time) AS bucket,
                COUNT(*) AS event_count,
                SUM(CASE WHEN event_type = 'play' THEN duration ELSE 0 END) AS play_duration
            FROM player_behaviors
            WHERE player_id = $1
                AND time > NOW() - INTERVAL '30 days'
            GROUP BY bucket
            ORDER BY bucket DESC
        """, player_id)

        # 2. è®¡ç®—ç‰¹å¾
        features = self.extract_features(recent_behaviors)

        # 3. ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹é¢„æµ‹
        churn_probability = self.churn_model.predict_proba([features])[0][1]

        # 4. åˆ¤æ–­æµå¤±é£é™©
        risk_level = 'high' if churn_probability > 0.7 else 'medium' if churn_probability > 0.4 else 'low'

        return {
            'player_id': player_id,
            'churn_probability': churn_probability,
            'risk_level': risk_level
        }
```

### 4.3 ä»˜è´¹é¢„æµ‹

```python
# ä»˜è´¹é¢„æµ‹
class PaymentPrediction:
    async def predict_payment(self, player_id):
        """é¢„æµ‹ç©å®¶ä»˜è´¹æ„æ„¿"""
        # 1. è·å–ç©å®¶ç”»åƒ
        profile = await self.db.fetchrow("""
            SELECT * FROM player_profiles WHERE player_id = $1
        """, player_id)

        # 2. è·å–ç›¸ä¼¼ä»˜è´¹ç©å®¶
        similar_payers = await self.db.fetch("""
            SELECT
                player_id,
                total_spent,
                1 - (embedding <=> $1::vector) AS similarity
            FROM player_profiles
            WHERE total_spent > 0
                AND player_id != $2
            ORDER BY embedding <=> $1::vector
            LIMIT 10
        """, profile['embedding'], player_id)

        # 3. è®¡ç®—ä»˜è´¹æ¦‚ç‡
        if similar_payers:
            avg_spent = sum(p['total_spent'] for p in similar_payers) / len(similar_payers)
            avg_similarity = sum(p['similarity'] for p in similar_payers) / len(similar_payers)
            payment_probability = avg_similarity * min(avg_spent / 100, 1.0)
        else:
            payment_probability = 0.1

        return {
            'player_id': player_id,
            'payment_probability': payment_probability,
            'recommended_offer': self.recommend_offer(payment_probability)
        }
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: æ‰‹æ¸¸ç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸæ‰‹æ¸¸å…¬å¸éœ€è¦æ„å»ºç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿï¼Œæå‡ç©å®¶ç•™å­˜ç‡å’Œä»˜è´¹è½¬åŒ–ç‡ã€‚

**é—®é¢˜åˆ†æ**:

1. **æµå¤±ç‡é«˜**: ç©å®¶æµå¤±ç‡é«˜ï¼Œç¼ºä¹æœ‰æ•ˆå¹²é¢„
2. **ä»˜è´¹ç‡ä½**: ä»˜è´¹è½¬åŒ–ç‡ä½
3. **è¿è¥æ•ˆç‡ä½**: è¿è¥å†³ç­–ç¼ºä¹æ•°æ®æ”¯æŒ
4. **æŸ¥è¯¢æ€§èƒ½**: è¡Œä¸ºæ•°æ®æŸ¥è¯¢æ€§èƒ½å·®

**è§£å†³æ–¹æ¡ˆ**:

```python
# ç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿ
class PlayerBehaviorAnalysisSystem:
    def __init__(self):
        self.clustering = PlayerClustering()
        self.churn_prediction = ChurnPrediction()
        self.payment_prediction = PaymentPrediction()

    async def daily_analysis(self):
        """æ¯æ—¥åˆ†æ"""
        # 1. ç©å®¶åˆ†ç¾¤
        clusters = await self.clustering.cluster_players()

        # 2. æµå¤±é¢„æµ‹
        players = await self.get_active_players()
        churn_risks = []
        for player in players:
            risk = await self.churn_prediction.predict_churn(player['id'])
            if risk['risk_level'] == 'high':
                churn_risks.append(risk)

        # 3. ä»˜è´¹é¢„æµ‹
        non_payers = await self.get_non_paying_players()
        payment_opportunities = []
        for player in non_payers:
            prediction = await self.payment_prediction.predict_payment(player['id'])
            if prediction['payment_probability'] > 0.5:
                payment_opportunities.append(prediction)

        return {
            'clusters': clusters,
            'churn_risks': churn_risks,
            'payment_opportunities': payment_opportunities
        }
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **æµå¤±ç‡** | åŸºå‡† | **-30%** | **é™ä½** |
| **ä»˜è´¹è½¬åŒ–ç‡** | åŸºå‡† | **+25%** | **æå‡** |
| **ç©å®¶ç•™å­˜ç‡** | åŸºå‡† | **+20%** | **æå‡** |
| **æŸ¥è¯¢æ€§èƒ½** | 5 ç§’ | **< 100ms** | **98%** â¬‡ï¸ |
| **è¿è¥æ•ˆç‡** | åŸºå‡† | **+40%** | **æå‡** |

### 5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**ç©å®¶è¡Œä¸ºåˆ†ææŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | æµå¤±é¢„æµ‹ | ä»˜è´¹é¢„æµ‹ | æŸ¥è¯¢æ€§èƒ½ | æˆæœ¬ | é€‚ç”¨åœºæ™¯ |
|---------|----------|----------|----------|------|----------|
| **ä¼ ç»Ÿåˆ†æ** | åŸºå‡† | åŸºå‡† | åŸºå‡† | ä½ | å°è§„æ¨¡ |
| **ç»Ÿè®¡åˆ†æ** | +15% | +10% | +200% | ä¸­ | ä¸­ç­‰è§„æ¨¡ |
| **æ™ºèƒ½åˆ†æ** | **+30%** | **+25%** | **+900%** | **ä¸­** | **å¤§è§„æ¨¡** |

**é¢„æµ‹ç®—æ³•å¯¹æ¯”**:

| é¢„æµ‹ç®—æ³• | å‡†ç¡®ç‡ | å®æ—¶æ€§ | å¯æ‰©å±•æ€§ | é€‚ç”¨åœºæ™¯ |
|---------|--------|--------|----------|----------|
| **è§„åˆ™é¢„æµ‹** | 60-70% | é«˜ | ä½ | ç®€å•åœºæ™¯ |
| **ç»Ÿè®¡é¢„æµ‹** | 70-80% | ä¸­ | ä¸­ | ä¸­ç­‰åœºæ™¯ |
| **æœºå™¨å­¦ä¹ ** | **80-90%** | **é«˜** | **é«˜** | **å¤æ‚åœºæ™¯** |

## 6. æœ€ä½³å®è·µ

### 6.1 æ•°æ®é‡‡é›†

1. **äº‹ä»¶è®¾è®¡**: è®¾è®¡åˆç†çš„äº‹ä»¶ä½“ç³»
2. **æ•°æ®è´¨é‡**: ç¡®ä¿æ•°æ®è´¨é‡å’Œå®Œæ•´æ€§
3. **å®æ—¶é‡‡é›†**: å®æ—¶é‡‡é›†ç©å®¶è¡Œä¸ºæ•°æ®

### 6.2 åˆ†ææ¨¡å‹ä¼˜åŒ–

1. **ç‰¹å¾å·¥ç¨‹**: æå–æœ‰æ•ˆçš„ç©å®¶ç‰¹å¾
2. **æ¨¡å‹é€‰æ‹©**: æ ¹æ®åœºæ™¯é€‰æ‹©åˆé€‚çš„æ¨¡å‹
3. **æ¨¡å‹æ›´æ–°**: å®šæœŸæ›´æ–°æ¨¡å‹ï¼Œé€‚åº”ç©å®¶è¡Œä¸ºå˜åŒ–

### 6.3 è¿è¥åº”ç”¨

1. **ä¸ªæ€§åŒ–è¿è¥**: åŸºäºåˆ†ç¾¤ç»“æœè¿›è¡Œä¸ªæ€§åŒ–è¿è¥
2. **æµå¤±å¹²é¢„**: å¯¹é«˜é£é™©ç©å®¶è¿›è¡Œæµå¤±å¹²é¢„
3. **ç²¾å‡†è¥é”€**: åŸºäºä»˜è´¹é¢„æµ‹è¿›è¡Œç²¾å‡†è¥é”€

## 7. å‚è€ƒèµ„æ–™

- [IoT æ—¶åºæ•°æ®åˆ†æ](../åˆ¶é€ åœºæ™¯/IoTæ—¶åºæ•°æ®åˆ†æ.md)
- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](../ç”µå•†åœºæ™¯/ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 ç©å®¶è¡Œä¸ºæ•°æ®è¡¨åˆ›å»º

**åˆ›å»ºç©å®¶è¡Œä¸ºåˆ†æç³»ç»Ÿæ•°æ®è¡¨**ï¼š

```sql
-- å¯ç”¨TimescaleDBå’Œpgvectoræ‰©å±•
CREATE EXTENSION IF NOT EXISTS timescaledb;
CREATE EXTENSION IF NOT EXISTS vector;

-- åˆ›å»ºç©å®¶ç”»åƒè¡¨
CREATE TABLE player_profiles (
    player_id TEXT PRIMARY KEY,
    registration_date DATE,
    total_play_time INTEGER DEFAULT 0,  -- æ€»æ¸¸æˆæ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    total_spent DECIMAL(10, 2) DEFAULT 0,  -- æ€»ä»˜è´¹é‡‘é¢
    current_level INTEGER DEFAULT 1,
    embedding vector(512),  -- ç©å®¶ç‰¹å¾å‘é‡
    profile_data JSONB DEFAULT '{}'::JSONB,
    last_updated TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç©å®¶è¡Œä¸ºæ—¶åºè¡¨
CREATE TABLE player_behaviors (
    time TIMESTAMPTZ NOT NULL,
    player_id TEXT NOT NULL,
    event_type TEXT,  -- 'login', 'logout', 'level_up', 'purchase', 'battle', etc.
    game_level INTEGER,
    duration INTEGER,  -- æ¸¸æˆæ—¶é•¿ï¼ˆç§’ï¼‰
    metadata JSONB DEFAULT '{}'::JSONB
);

-- åˆ›å»ºæ¸¸æˆäº‹ä»¶è¡¨
CREATE TABLE game_events (
    id SERIAL PRIMARY KEY,
    event_time TIMESTAMPTZ NOT NULL,
    player_id TEXT NOT NULL,
    event_type TEXT,
    event_data JSONB DEFAULT '{}'::JSONB,
    metadata JSONB DEFAULT '{}'::JSONB
);

-- è½¬æ¢ä¸ºè¶…è¡¨ï¼ˆç”¨äºæ—¶åºæ•°æ®ï¼‰
SELECT create_hypertable('player_behaviors', 'time');
SELECT create_hypertable('game_events', 'event_time');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_player_behaviors_player_time ON player_behaviors (player_id, time DESC);
CREATE INDEX idx_player_profiles_embedding ON player_profiles USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_game_events_player_time ON game_events (player_id, event_time DESC);
```

### 8.2 ç©å®¶è¡Œä¸ºåˆ†æå®ç°

**Pythonç©å®¶è¡Œä¸ºåˆ†æ**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
from datetime import datetime, timedelta
from typing import List, Dict, Optional

class PlayerBehaviorAnalyzer:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–ç©å®¶è¡Œä¸ºåˆ†æå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def record_behavior(self, player_id: str, event_type: str,
                       game_level: Optional[int] = None,
                       duration: Optional[int] = None,
                       metadata: Optional[Dict] = None):
        """è®°å½•ç©å®¶è¡Œä¸º"""
        self.cur.execute("""
            INSERT INTO player_behaviors
            (time, player_id, event_type, game_level, duration, metadata)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (
            datetime.now(), player_id, event_type, game_level, duration,
            str(metadata) if metadata else '{}'
        ))

        self.conn.commit()

    def update_player_profile(self, player_id: str, embedding: List[float],
                             total_play_time: Optional[int] = None,
                             total_spent: Optional[float] = None,
                             current_level: Optional[int] = None):
        """æ›´æ–°ç©å®¶ç”»åƒ"""
        self.cur.execute("""
            INSERT INTO player_profiles
            (player_id, embedding, total_play_time, total_spent, current_level, last_updated)
            VALUES (%s, %s, %s, %s, %s, %s)
            ON CONFLICT (player_id)
            DO UPDATE SET
                embedding = EXCLUDED.embedding,
                total_play_time = COALESCE(EXCLUDED.total_play_time, player_profiles.total_play_time),
                total_spent = COALESCE(EXCLUDED.total_spent, player_profiles.total_spent),
                current_level = COALESCE(EXCLUDED.current_level, player_profiles.current_level),
                last_updated = EXCLUDED.last_updated
        """, (
            player_id, embedding, total_play_time, total_spent, current_level, datetime.now()
        ))

        self.conn.commit()

    def analyze_player_behavior(self, player_id: str, days: int = 7) -> Dict:
        """åˆ†æç©å®¶è¡Œä¸º"""
        self.cur.execute("""
            SELECT
                COUNT(*) AS total_events,
                COUNT(DISTINCT event_type) AS event_types,
                SUM(CASE WHEN event_type = 'login' THEN 1 ELSE 0 END) AS login_count,
                SUM(CASE WHEN event_type = 'purchase' THEN 1 ELSE 0 END) AS purchase_count,
                SUM(duration) AS total_duration,
                MAX(game_level) AS max_level
            FROM player_behaviors
            WHERE player_id = %s
              AND time > NOW() - INTERVAL '%s days'
        """, (player_id, days))

        result = self.cur.fetchone()
        if result:
            return {
                'total_events': result[0],
                'event_types': result[1],
                'login_count': result[2],
                'purchase_count': result[3],
                'total_duration': result[4] if result[4] else 0,
                'max_level': result[5] if result[5] else 1
            }
        return {}

    def find_similar_players(self, player_id: str, limit: int = 10) -> List[Dict]:
        """æŸ¥æ‰¾ç›¸ä¼¼ç©å®¶"""
        # è·å–ç©å®¶å‘é‡
        self.cur.execute("""
            SELECT embedding
            FROM player_profiles
            WHERE player_id = %s
        """, (player_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        player_embedding = result[0]

        # æŸ¥æ‰¾ç›¸ä¼¼ç©å®¶
        self.cur.execute("""
            SELECT
                player_id,
                total_play_time,
                total_spent,
                current_level,
                1 - (embedding <=> %s) AS similarity
            FROM player_profiles
            WHERE player_id != %s
              AND embedding <=> %s < 0.3
            ORDER BY embedding <=> %s
            LIMIT %s
        """, (player_embedding, player_id, player_embedding, player_embedding, limit))

        similar_players = []
        for row in self.cur.fetchall():
            similar_players.append({
                'player_id': row[0],
                'total_play_time': row[1],
                'total_spent': float(row[2]) if row[2] else 0,
                'current_level': row[3],
                'similarity': float(row[4])
            })

        return similar_players

# ä½¿ç”¨ç¤ºä¾‹
analyzer = PlayerBehaviorAnalyzer("host=localhost dbname=testdb user=postgres password=secret")

# è®°å½•ç©å®¶è¡Œä¸º
analyzer.record_behavior(
    player_id='player_001',
    event_type='login',
    game_level=10,
    duration=3600
)

# åˆ†æç©å®¶è¡Œä¸º
behavior = analyzer.analyze_player_behavior('player_001', days=7)
print(f"Player behavior: {behavior}")

# æŸ¥æ‰¾ç›¸ä¼¼ç©å®¶
similar = analyzer.find_similar_players('player_001', limit=10)
for player in similar:
    print(f"Similar player {player['player_id']}: similarity={player['similarity']:.4f}")
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-10-01
