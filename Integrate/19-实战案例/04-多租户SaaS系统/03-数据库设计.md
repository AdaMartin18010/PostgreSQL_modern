---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\04-å¤šç§Ÿæˆ·SaaSç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹4ï¼šå¤šç§Ÿæˆ·SaaSç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

## å…ƒæ•°æ®

- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **éš”ç¦»ç­–ç•¥**: Row Level Security (RLS)
- **ç§Ÿæˆ·æ•°**: 1000+

---

## 1. Schemaè®¾è®¡

```sql
-- 1. ç§Ÿæˆ·è¡¨
CREATE TABLE tenants (
    tenant_id SERIAL PRIMARY KEY,
    tenant_name VARCHAR(100) NOT NULL UNIQUE,
    plan_type VARCHAR(50) NOT NULL,  -- free/pro/enterprise
    storage_quota_gb INT DEFAULT 10,
    connection_quota INT DEFAULT 10,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT true
);

-- 2. ç”¨æˆ·è¡¨ï¼ˆå¤šç§Ÿæˆ·ï¼‰
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    tenant_id INT NOT NULL REFERENCES tenants(tenant_id),
    username VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (tenant_id, email)
);

-- å¯ç”¨RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- RLSç­–ç•¥
CREATE POLICY tenant_isolation_policy ON users
    USING (tenant_id = current_setting('app.current_tenant', true)::integer);

-- ç§Ÿæˆ·IDç´¢å¼•ï¼ˆRLSæ€§èƒ½å…³é”®ï¼‰
CREATE INDEX idx_users_tenant ON users (tenant_id);

-- 3. ä¸šåŠ¡æ•°æ®è¡¨ï¼ˆç¤ºä¾‹ï¼šæ–‡æ¡£è¡¨ï¼‰
CREATE TABLE documents (
    id BIGSERIAL PRIMARY KEY,
    tenant_id INT NOT NULL REFERENCES tenants(tenant_id),
    user_id BIGINT NOT NULL REFERENCES users(id),
    title VARCHAR(255) NOT NULL,
    content TEXT,
    size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- å¯ç”¨RLS
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- RLSç­–ç•¥
CREATE POLICY tenant_isolation_policy ON documents
    USING (tenant_id = current_setting('app.current_tenant', true)::integer);

-- ç´¢å¼•
CREATE INDEX idx_documents_tenant ON documents (tenant_id);
CREATE INDEX idx_documents_user ON documents (user_id);
CREATE INDEX idx_documents_created ON documents (created_at);

-- 4. èµ„æºä½¿ç”¨ç»Ÿè®¡è¡¨
CREATE TABLE tenant_usage_stats (
    id BIGSERIAL PRIMARY KEY,
    tenant_id INT NOT NULL REFERENCES tenants(tenant_id),
    stat_date DATE NOT NULL,
    storage_used_gb NUMERIC(10,2),
    api_calls INT,
    active_users INT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (tenant_id, stat_date)
);
```

---

## 2. èµ„æºé…é¢å®ç°

```sql
-- å­˜å‚¨é…é¢æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_storage_quota()
RETURNS TRIGGER AS $$
DECLARE
    current_usage_gb NUMERIC;
    quota_gb INT;
BEGIN
    -- æŸ¥è¯¢å½“å‰ç§Ÿæˆ·çš„å­˜å‚¨ä½¿ç”¨é‡
    SELECT
        COALESCE(SUM(size_bytes), 0) / 1024.0 / 1024.0 / 1024.0,
        t.storage_quota_gb
    INTO current_usage_gb, quota_gb
    FROM documents d
    JOIN tenants t ON d.tenant_id = t.tenant_id
    WHERE d.tenant_id = NEW.tenant_id
    GROUP BY t.storage_quota_gb;

    -- æ£€æŸ¥æ˜¯å¦è¶…é…é¢
    IF current_usage_gb + (NEW.size_bytes / 1024.0 / 1024.0 / 1024.0) > quota_gb THEN
        RAISE EXCEPTION 'å­˜å‚¨é…é¢å·²æ»¡: å½“å‰%.2fGB, é…é¢%GB', current_usage_gb, quota_gb;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ç»‘å®šè§¦å‘å™¨
CREATE TRIGGER trg_check_storage_quota
    BEFORE INSERT OR UPDATE ON documents
    FOR EACH ROW EXECUTE FUNCTION check_storage_quota();
```

---

## 3. æ€§èƒ½ä¼˜åŒ–

```sql
-- åˆ†åŒºè¡¨ï¼ˆæå‡RLSæ€§èƒ½ï¼‰
CREATE TABLE users_partitioned (
    id BIGSERIAL,
    tenant_id INT NOT NULL,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (tenant_id);

-- åˆ›å»º16ä¸ªåˆ†åŒº
DO $$
BEGIN
    FOR i IN 0..15 LOOP
        EXECUTE format('
            CREATE TABLE users_p%s PARTITION OF users_partitioned
            FOR VALUES WITH (MODULUS 16, REMAINDER %s);
        ', i, i);
    END LOOP;
END $$;

-- æ¯ä¸ªåˆ†åŒºç‹¬ç«‹ç´¢å¼•
-- è‡ªåŠ¨åˆ›å»ºï¼Œæ— éœ€æ‰‹åŠ¨
```

---

---

## 4. RLSç­–ç•¥ä¼˜åŒ–

### 4.1 RLSæ€§èƒ½ä¼˜åŒ–

**RLSæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. ä¼˜åŒ–RLSç­–ç•¥ï¼ˆä½¿ç”¨ç´¢å¼•å‹å¥½çš„è°“è¯ï¼‰
DROP POLICY IF EXISTS tenant_isolation_policy ON users;
CREATE POLICY tenant_isolation_policy ON users
    USING (tenant_id = current_setting('app.current_tenant', true)::integer)
    WITH CHECK (tenant_id = current_setting('app.current_tenant', true)::integer);

-- 2. ç¡®ä¿tenant_idä¸Šæœ‰ç´¢å¼•ï¼ˆå·²åœ¨å‰é¢åˆ›å»ºï¼‰
-- CREATE INDEX idx_users_tenant ON users (tenant_id);

-- 3. ä½¿ç”¨å®‰å…¨å®šä¹‰è€…å‡½æ•°ç»•è¿‡RLSï¼ˆåªè¯»æŠ¥è¡¨ï¼‰
CREATE OR REPLACE FUNCTION get_tenant_stats(p_tenant_id INT)
RETURNS TABLE (
    user_count BIGINT,
    document_count BIGINT,
    storage_used_gb NUMERIC
)
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT
        (SELECT COUNT(*) FROM users WHERE tenant_id = p_tenant_id)::BIGINT,
        (SELECT COUNT(*) FROM documents WHERE tenant_id = p_tenant_id)::BIGINT,
        (SELECT COALESCE(SUM(size_bytes), 0) / 1024.0 / 1024.0 / 1024.0
         FROM documents WHERE tenant_id = p_tenant_id)::NUMERIC;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 è¿æ¥é…é¢ç®¡ç†

**è¿æ¥é…é¢ç®¡ç†å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- è¿æ¥é…é¢æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_connection_quota(
    p_tenant_id INT
)
RETURNS TABLE (
    current_connections INT,
    quota INT,
    available_connections INT,
    status TEXT
) AS $$
DECLARE
    current_conn INT;
    quota_val INT;
BEGIN
    -- è·å–å½“å‰è¿æ¥æ•°ï¼ˆç®€åŒ–å¤„ç†ï¼‰
    SELECT COUNT(*) INTO current_conn
    FROM pg_stat_activity
    WHERE application_name LIKE 'tenant_' || p_tenant_id || '%';

    -- è·å–é…é¢
    SELECT connection_quota INTO quota_val
    FROM tenants
    WHERE tenant_id = p_tenant_id;

    RETURN QUERY SELECT
        current_conn,
        quota_val,
        quota_val - current_conn,
        CASE
            WHEN current_conn >= quota_val THEN 'é…é¢å·²æ»¡'
            WHEN current_conn >= quota_val * 0.8 THEN 'æ¥è¿‘é…é¢'
            ELSE 'æ­£å¸¸'
        END;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ£€æŸ¥è¿æ¥é…é¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. èµ„æºä½¿ç”¨ç»Ÿè®¡

### 5.1 èµ„æºä½¿ç”¨ç»Ÿè®¡å‡½æ•°

**èµ„æºä½¿ç”¨ç»Ÿè®¡å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ›´æ–°èµ„æºä½¿ç”¨ç»Ÿè®¡
CREATE OR REPLACE FUNCTION update_tenant_usage_stats(
    p_tenant_id INT,
    p_stat_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE (
    tenant_id INT,
    storage_used_gb NUMERIC,
    api_calls INT,
    active_users INT
) AS $$
DECLARE
    storage_val NUMERIC;
    api_calls_val INT;
    active_users_val INT;
BEGIN
    -- è®¡ç®—å­˜å‚¨ä½¿ç”¨é‡
    SELECT COALESCE(SUM(size_bytes), 0) / 1024.0 / 1024.0 / 1024.0
    INTO storage_val
    FROM documents
    WHERE tenant_id = p_tenant_id;

    -- è®¡ç®—APIè°ƒç”¨æ•°ï¼ˆç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥ä»APIæ—¥å¿—è¡¨è·å–ï¼‰
    SELECT COALESCE(COUNT(*), 0) INTO api_calls_val
    FROM search_logs
    WHERE created_at::DATE = p_stat_date;

    -- è®¡ç®—æ´»è·ƒç”¨æˆ·æ•°
    SELECT COUNT(DISTINCT user_id) INTO active_users_val
    FROM documents
    WHERE tenant_id = p_tenant_id
      AND updated_at > NOW() - INTERVAL '7 days';

    -- æ’å…¥æˆ–æ›´æ–°ç»Ÿè®¡
    INSERT INTO tenant_usage_stats (
        tenant_id, stat_date, storage_used_gb, api_calls, active_users
    )
    VALUES (
        p_tenant_id, p_stat_date, storage_val, api_calls_val, active_users_val
    )
    ON CONFLICT (tenant_id, stat_date) DO UPDATE
    SET storage_used_gb = EXCLUDED.storage_used_gb,
        api_calls = EXCLUDED.api_calls,
        active_users = EXCLUDED.active_users;

    RETURN QUERY SELECT
        p_tenant_id,
        storage_val,
        api_calls_val,
        active_users_val;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ›´æ–°èµ„æºä½¿ç”¨ç»Ÿè®¡å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶æ›´æ–°ç»Ÿè®¡ï¼ˆä½¿ç”¨pg_cronï¼‰
SELECT cron.schedule(
    'update-tenant-stats',
    '0 1 * * *',  -- æ¯å¤©å‡Œæ™¨1ç‚¹
    'SELECT update_tenant_usage_stats(tenant_id) FROM tenants WHERE is_active = true'
);
```

---

## 6. å¤šç§Ÿæˆ·æ•°æ®éš”ç¦»éªŒè¯

### 6.1 éš”ç¦»æ€§æµ‹è¯•

**éš”ç¦»æ€§æµ‹è¯•å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æµ‹è¯•æ•°æ®éš”ç¦»
CREATE OR REPLACE FUNCTION test_tenant_isolation(
    p_tenant_id_1 INT,
    p_tenant_id_2 INT
)
RETURNS TABLE (
    test_item TEXT,
    tenant_1_count BIGINT,
    tenant_2_count BIGINT,
    isolation_status TEXT
) AS $$
BEGIN
    -- è®¾ç½®ç§Ÿæˆ·1ä¸Šä¸‹æ–‡
    PERFORM set_config('app.current_tenant', p_tenant_id_1::TEXT, false);

    RETURN QUERY
    SELECT
        'ç”¨æˆ·æ•°'::TEXT,
        (SELECT COUNT(*) FROM users)::BIGINT AS tenant_1_count,
        NULL::BIGINT AS tenant_2_count,
        'å¾…æµ‹è¯•'::TEXT;

    -- è®¾ç½®ç§Ÿæˆ·2ä¸Šä¸‹æ–‡
    PERFORM set_config('app.current_tenant', p_tenant_id_2::TEXT, false);

    -- æ›´æ–°ç§Ÿæˆ·2çš„è®¡æ•°
    UPDATE test_tenant_isolation_result
    SET tenant_2_count = (SELECT COUNT(*) FROM users)
    WHERE test_item = 'ç”¨æˆ·æ•°';

    -- éªŒè¯éš”ç¦»æ€§
    RETURN QUERY
    SELECT
        'ç”¨æˆ·æ•°'::TEXT,
        (SELECT tenant_1_count FROM test_tenant_isolation_result WHERE test_item = 'ç”¨æˆ·æ•°'),
        (SELECT tenant_2_count FROM test_tenant_isolation_result WHERE test_item = 'ç”¨æˆ·æ•°'),
        CASE
            WHEN (SELECT tenant_1_count FROM test_tenant_isolation_result WHERE test_item = 'ç”¨æˆ·æ•°') !=
                 (SELECT tenant_2_count FROM test_tenant_isolation_result WHERE test_item = 'ç”¨æˆ·æ•°')
            THEN 'éš”ç¦»æ­£å¸¸'
            ELSE 'éš”ç¦»å¼‚å¸¸'
        END;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'éš”ç¦»æ€§æµ‹è¯•å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**å®Œæˆæ—¥æœŸ**: 2025-12-04
**éš”ç¦»ç­–ç•¥**: RLS + åˆ†åŒºè¡¨
**é…é¢**: å­˜å‚¨ + è¿æ¥ + API

**è¿”å›**: [æ¡ˆä¾‹4ä¸»é¡µ](./README.md)
