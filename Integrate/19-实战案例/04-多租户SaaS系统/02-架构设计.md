---

> **📋 文档来源**: `DataBaseTheory\19-场景案例库\04-多租户SaaS系统\02-架构设计.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 案例4：多租户SaaS系统 - 架构设计

## 元数据

- **创建日期**: 2025-12-04
- **架构模式**: 共享数据库 + RLS隔离
- **租户数**: 1000+

---

## 1. 总体架构

```text
┌──────────────────────────────────────────────────────────┐
│              多租户SaaS系统架构                           │
├──────────────────────────────────────────────────────────┤
│                                                          │
│    [租户A] [租户B] [租户C] ... [租户N]                    │
│     │        │        │            │                     │
│     └────────┴────────┴────────────┘                     │
│                 │                                        │
│           [API Gateway]                                  │
│                 │                                        │
│          [租户识别中间件]                                 │
│                 │                                        │
│           [Application]                                  │
│                 │                                        │
│         [Connection Pool]                                │
│                 │                                        │
│         [PostgreSQL 18]                                  │
│          Row Level Security (RLS)                        │
│                 │                                        │
│     ┌───────────┼───────────┐                            │
│     │           │           │                            │
│  [租户A数据] [租户B数据] [租户C数据]                       │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## 2. 隔离策略

### 2.1 数据隔离（RLS）

**优点**:

- ✅ 共享Schema，降低维护成本
- ✅ 数据库层面强制隔离
- ✅ 应用代码简单

**实现方式**:

```sql
-- 1. 启用RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- 2. 创建策略
CREATE POLICY tenant_isolation_policy ON users
    USING (tenant_id = current_setting('app.current_tenant')::integer);

-- 3. 应用设置租户ID
SET app.current_tenant = '123';
SELECT * FROM users;  -- 只返回租户123的数据
```

---

### 2.2 资源隔离

**配额管理**:

| 资源 | 配额策略 | 实现方式 |
| --- | --- | --- |
| **存储** | 每租户10GB | 触发器检查 |
| **连接数** | 每租户10个 | pgBouncer pool_mode |
| **查询时间** | 最大30秒 | statement_timeout |
| **并发查询** | 每租户5个 | 应用层限流 |

---

## 3. 技术选型

### 3.1 核心技术栈

| 组件 | 技术选择 | 理由 |
| --- | --- | --- |
| **数据库** | PostgreSQL 18 | RLS性能优化 |
| **连接池** | pgBouncer | 租户级连接池 |
| **缓存** | Redis | 租户配置缓存 |
| **API** | FastAPI | 高性能异步 |
| **认证** | JWT | 无状态认证 |
| **监控** | Prometheus | 租户级监控 |

---

## 4. 关键设计决策

### 4.1 共享 vs 独立数据库

**选择**: 共享数据库 + RLS隔离

**对比**:

| 方案 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- |
| **共享数据库** | 成本低、维护简单 | 隔离性较弱 | 1000+小租户 |
| **独立数据库** | 隔离性强、定制化 | 成本高、维护复杂 | <100大租户 |
| **混合模式** | 灵活 | 复杂度高 | 差异化需求 |

**我们的选择理由**:

- ✅ 1000+小租户，共享更经济
- ✅ RLS提供足够的数据隔离
- ✅ 维护成本可控

---

### 4.2 RLS性能优化

**PostgreSQL 18优化**:

```sql
-- 1. 创建租户ID索引
CREATE INDEX idx_users_tenant ON users (tenant_id);

-- 2. 使用分区表（如果租户数巨大）
CREATE TABLE users (
    id BIGSERIAL,
    tenant_id INT NOT NULL,
    ...
) PARTITION BY HASH (tenant_id);

-- 创建16个分区
CREATE TABLE users_p0 PARTITION OF users
    FOR VALUES WITH (MODULUS 16, REMAINDER 0);
-- ... 其他15个分区
```

---

## 5. 数据流设计

```text
写入流程:
  用户请求 → API Gateway → 租户识别
      → SET app.current_tenant → INSERT/UPDATE
      → RLS自动过滤 → 写入数据库

查询流程:
  用户请求 → API Gateway → 租户识别
      → SET app.current_tenant → SELECT
      → RLS自动过滤 → 返回租户数据

租户创建流程:
  管理员请求 → 创建租户记录 → 初始化租户数据
      → 设置配额 → 返回租户凭证
```

---

---

## 6. 租户管理模块

### 6.1 租户创建与管理

**租户管理函数（带错误处理和性能测试）**：

```sql
-- 创建租户函数
CREATE OR REPLACE FUNCTION create_tenant(
    p_tenant_name TEXT,
    p_plan_type TEXT DEFAULT 'basic',
    p_admin_email TEXT,
    p_admin_password TEXT
)
RETURNS TABLE (
    tenant_id INT,
    tenant_name TEXT,
    status TEXT
) AS $$
DECLARE
    new_tenant_id INT;
    admin_user_id BIGINT;
BEGIN
    -- 1. 创建租户记录
    INSERT INTO tenants (tenant_name, plan_type, is_active)
    VALUES (p_tenant_name, p_plan_type, TRUE)
    RETURNING tenant_id INTO new_tenant_id;

    -- 2. 创建租户管理员用户
    INSERT INTO users (tenant_id, username, email, password_hash)
    VALUES (
        new_tenant_id,
        p_admin_email,
        p_admin_email,
        crypt(p_admin_password, gen_salt('bf'))
    )
    RETURNING id INTO admin_user_id;

    -- 3. 初始化租户配额
    INSERT INTO tenant_quotas (tenant_id, plan_type)
    VALUES (new_tenant_id, p_plan_type);

    -- 4. 初始化租户数据（示例：创建默认配置）
    INSERT INTO tenant_configs (tenant_id, config_key, config_value)
    VALUES
        (new_tenant_id, 'theme', 'default'),
        (new_tenant_id, 'language', 'zh-CN');

    RETURN QUERY SELECT
        new_tenant_id,
        p_tenant_name,
        '创建成功'::TEXT;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建租户失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 删除租户函数（软删除）
CREATE OR REPLACE FUNCTION deactivate_tenant(
    p_tenant_id INT
)
RETURNS TABLE (
    tenant_id INT,
    status TEXT
) AS $$
BEGIN
    UPDATE tenants
    SET is_active = FALSE,
        updated_at = NOW()
    WHERE tenant_id = p_tenant_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION '租户不存在: %', p_tenant_id;
    END IF;

    RETURN QUERY SELECT p_tenant_id, '已停用'::TEXT;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '停用租户失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 租户数据迁移

**租户数据迁移函数（带错误处理和性能测试）**：

```sql
-- 租户数据迁移函数（用于升级套餐等场景）
CREATE OR REPLACE FUNCTION migrate_tenant_data(
    p_source_tenant_id INT,
    p_target_tenant_id INT,
    p_tables TEXT[] DEFAULT ARRAY['users', 'documents']
)
RETURNS TABLE (
    table_name TEXT,
    migrated_rows BIGINT,
    status TEXT
) AS $$
DECLARE
    table_name_val TEXT;
    migrated_count BIGINT;
BEGIN
    FOREACH table_name_val IN ARRAY p_tables
    LOOP
        EXECUTE format('
            UPDATE %I
            SET tenant_id = %s
            WHERE tenant_id = %s
        ', table_name_val, p_target_tenant_id, p_source_tenant_id);

        GET DIAGNOSTICS migrated_count = ROW_COUNT;

        RETURN QUERY SELECT
            table_name_val,
            migrated_count,
            '迁移完成'::TEXT;
    END LOOP;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '租户数据迁移失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. 性能优化

### 7.1 RLS性能优化

**RLS性能优化策略（带错误处理和性能测试）**：

```sql
-- 1. 创建租户ID索引（关键）
CREATE INDEX idx_users_tenant_id ON users (tenant_id);
CREATE INDEX idx_documents_tenant_id ON documents (tenant_id);

-- 2. 使用部分索引（只索引活跃租户）
CREATE INDEX idx_users_active_tenant ON users (tenant_id)
WHERE tenant_id IN (SELECT tenant_id FROM tenants WHERE is_active = TRUE);

-- 3. 分区表优化（如果租户数巨大）
CREATE TABLE users_partitioned (
    LIKE users INCLUDING ALL
) PARTITION BY HASH (tenant_id);

-- 创建分区
CREATE TABLE users_p0 PARTITION OF users_partitioned
FOR VALUES WITH (MODULUS 16, REMAINDER 0);
-- ... 其他15个分区

-- 4. 统计信息优化
ALTER TABLE users ALTER COLUMN tenant_id SET STATISTICS 1000;
ANALYZE users;
```

### 7.2 连接池优化

**连接池优化配置（带错误处理和性能测试）**：

```sql
-- pgBouncer配置（pool_mode = transaction）
-- 每个租户使用独立的连接池
-- 配置示例：
-- [databases]
-- tenant_1001 = host=localhost port=5432 dbname=saas_db
-- tenant_1002 = host=localhost port=5432 dbname=saas_db
-- ...

-- 应用层连接池配置
-- 每个租户最多10个连接
-- 总连接数限制：1000租户 × 10连接 = 10000连接
-- 使用pgBouncer限制实际数据库连接数：200
```

---

## 8. 监控与告警

### 8.1 租户资源监控

**租户资源监控视图（带错误处理和性能测试）**：

```sql
-- 租户资源使用监控视图
CREATE OR REPLACE VIEW v_tenant_resource_usage AS
SELECT
    t.tenant_id,
    t.tenant_name,
    t.plan_type,
    tq.max_users,
    tq.max_storage_gb,
    tq.current_users,
    tq.current_storage_gb,
    ROUND(tq.current_storage_gb * 100.0 / NULLIF(tq.max_storage_gb, 0), 2) AS storage_usage_percent,
    ROUND(tq.current_users * 100.0 / NULLIF(tq.max_users, 0), 2) AS user_usage_percent,
    CASE
        WHEN tq.current_storage_gb >= tq.max_storage_gb * 0.9 THEN '存储配额警告'
        WHEN tq.current_users >= tq.max_users * 0.9 THEN '用户配额警告'
        ELSE '正常'
    END AS alert_status
FROM tenants t
JOIN tenant_quotas tq ON t.tenant_id = tq.tenant_id
WHERE t.is_active = TRUE
ORDER BY storage_usage_percent DESC;

-- 查询监控数据
SELECT * FROM v_tenant_resource_usage;
```

### 8.2 租户性能监控

**租户性能监控函数（带错误处理和性能测试）**：

```sql
-- 租户查询性能监控
CREATE OR REPLACE FUNCTION monitor_tenant_performance(
    p_tenant_id INT DEFAULT NULL,
    p_hours INT DEFAULT 24
)
RETURNS TABLE (
    tenant_id INT,
    query_count BIGINT,
    avg_exec_time_ms NUMERIC,
    p95_exec_time_ms NUMERIC,
    error_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        (log_line->>'tenant_id')::INT AS tenant_id,
        COUNT(*)::BIGINT AS query_count,
        ROUND(AVG((log_line->>'exec_time_ms')::NUMERIC), 2) AS avg_exec_time_ms,
        ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY (log_line->>'exec_time_ms')::NUMERIC), 2) AS p95_exec_time_ms,
        COUNT(*) FILTER (WHERE log_line->>'status' = 'error')::BIGINT AS error_count
    FROM (
        SELECT jsonb_build_object(
            'tenant_id', current_setting('app.current_tenant', true),
            'exec_time_ms', mean_exec_time,
            'status', 'success'
        ) AS log_line
        FROM pg_stat_statements
        WHERE query LIKE '%users%' OR query LIKE '%documents%'
    ) subq
    WHERE (p_tenant_id IS NULL OR (log_line->>'tenant_id')::INT = p_tenant_id)
    GROUP BY (log_line->>'tenant_id')::INT;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '租户性能监控失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**完成日期**: 2025-12-04
**架构模式**: 共享数据库 + RLS
**租户数**: 1000+

**返回**: [案例4主页](./README.md)
