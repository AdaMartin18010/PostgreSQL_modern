---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\04-å¤šç§Ÿæˆ·SaaSç³»ç»Ÿ\03-æ ¸å¿ƒå®ç°.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹4ï¼šå¤šç§Ÿæˆ·SaaSç³»ç»Ÿ - æ ¸å¿ƒå®ç°

## å…ƒæ•°æ®

- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **æŠ€æœ¯æ ˆ**: FastAPI + PostgreSQL 18 + RLS
- **ä»£ç é‡**: ~1,800è¡Œ

---

## 1. ç§Ÿæˆ·ç®¡ç†æ¨¡å—

```python
"""
å¤šç§Ÿæˆ·ç®¡ç†æ¨¡å—
"""

import psycopg2
from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from datetime import datetime, timedelta

app = FastAPI()
security = HTTPBearer()

# JWTé…ç½®
JWT_SECRET = "your-secret-key"
JWT_ALGORITHM = "HS256"

class TenantManager:
    """ç§Ÿæˆ·ç®¡ç†å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def create_tenant(self, tenant_name, plan_type='free'):
        """
        åˆ›å»ºæ–°ç§Ÿæˆ·

        Args:
            tenant_name: ç§Ÿæˆ·åç§°
            plan_type: å¥—é¤ç±»å‹ (free/pro/enterprise)
        """

        # æ ¹æ®å¥—é¤è®¾ç½®é…é¢
        quotas = {
            'free': {'storage_gb': 1, 'connections': 5},
            'pro': {'storage_gb': 10, 'connections': 20},
            'enterprise': {'storage_gb': 100, 'connections': 100}
        }

        quota = quotas.get(plan_type, quotas['free'])

        self.cursor.execute("""
            INSERT INTO tenants (tenant_name, plan_type, storage_quota_gb, connection_quota)
            VALUES (%s, %s, %s, %s)
            RETURNING tenant_id;
        """, (tenant_name, plan_type, quota['storage_gb'], quota['connections']))

        tenant_id = self.cursor.fetchone()[0]
        self.conn.commit()

        # åˆå§‹åŒ–ç§Ÿæˆ·æ•°æ®
        self._initialize_tenant_data(tenant_id)

        return tenant_id

    def _initialize_tenant_data(self, tenant_id):
        """åˆå§‹åŒ–ç§Ÿæˆ·æ•°æ®"""

        # è®¾ç½®ç§Ÿæˆ·ä¸Šä¸‹æ–‡
        self.cursor.execute(f"SET app.current_tenant = {tenant_id};")

        # åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜ç”¨æˆ·
        self.cursor.execute("""
            INSERT INTO users (tenant_id, username, email, password_hash)
            VALUES (%s, 'admin', 'admin@example.com', 'hashed_password');
        """, (tenant_id,))

        self.conn.commit()
        print(f"âœ… ç§Ÿæˆ· {tenant_id} åˆå§‹åŒ–å®Œæˆ")
```

---

## 2. ç§Ÿæˆ·ä¸Šä¸‹æ–‡ä¸­é—´ä»¶

```python
from contextvars import ContextVar

# å½“å‰ç§Ÿæˆ·IDä¸Šä¸‹æ–‡
current_tenant_id = ContextVar('current_tenant_id', default=None)

def get_current_tenant() -> int:
    """è·å–å½“å‰ç§Ÿæˆ·ID"""
    tenant_id = current_tenant_id.get()
    if tenant_id is None:
        raise HTTPException(status_code=401, detail="æœªè®¾ç½®ç§Ÿæˆ·ä¸Šä¸‹æ–‡")
    return tenant_id

async def set_tenant_context(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    ä»JWT Tokenè§£æç§Ÿæˆ·IDå¹¶è®¾ç½®ä¸Šä¸‹æ–‡
    """

    try:
        token = credentials.credentials
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        tenant_id = payload.get('tenant_id')

        if not tenant_id:
            raise HTTPException(status_code=401, detail="Tokenä¸­æ— ç§Ÿæˆ·ä¿¡æ¯")

        # è®¾ç½®ä¸Šä¸‹æ–‡
        current_tenant_id.set(tenant_id)

        return tenant_id

    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Tokenæ— æ•ˆ")

# æ•°æ®åº“è¿æ¥ + è®¾ç½®RLSä¸Šä¸‹æ–‡
def get_db_with_tenant():
    """è·å–å¸¦ç§Ÿæˆ·ä¸Šä¸‹æ–‡çš„æ•°æ®åº“è¿æ¥"""

    tenant_id = get_current_tenant()

    conn = psycopg2.connect("dbname=saas_db user=postgres")
    cursor = conn.cursor()

    # è®¾ç½®ç§Ÿæˆ·IDï¼ˆRLSä½¿ç”¨ï¼‰
    cursor.execute(f"SET app.current_tenant = {tenant_id};")

    return conn
```

---

## 3. APIå®ç°

```python
@app.post("/api/documents")
async def create_document(
    document: dict,
    tenant_id: int = Depends(set_tenant_context),
    conn = Depends(get_db_with_tenant)
):
    """
    åˆ›å»ºæ–‡æ¡£ï¼ˆè‡ªåŠ¨åº”ç”¨RLSï¼‰
    """

    cursor = conn.cursor()

    try:
        cursor.execute("""
            INSERT INTO documents (tenant_id, user_id, title, content, size_bytes)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id;
        """, (tenant_id, document['user_id'], document['title'],
              document['content'], len(document['content'])))

        doc_id = cursor.fetchone()[0]
        conn.commit()

        return {"success": True, "document_id": doc_id}

    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))

    finally:
        cursor.close()
        conn.close()

@app.get("/api/documents")
async def list_documents(
    tenant_id: int = Depends(set_tenant_context),
    conn = Depends(get_db_with_tenant)
):
    """
    åˆ—å‡ºæ–‡æ¡£ï¼ˆRLSè‡ªåŠ¨è¿‡æ»¤ç§Ÿæˆ·æ•°æ®ï¼‰
    """

    cursor = conn.cursor()

    try:
        # RLSä¼šè‡ªåŠ¨è¿‡æ»¤ï¼Œåªè¿”å›å½“å‰ç§Ÿæˆ·çš„æ•°æ®
        cursor.execute("""
            SELECT id, title, size_bytes, created_at
            FROM documents
            ORDER BY created_at DESC
            LIMIT 100;
        """)

        results = cursor.fetchall()

        return {
            "success": True,
            "documents": [
                {"id": r[0], "title": r[1], "size_bytes": r[2], "created_at": r[3]}
                for r in results
            ]
        }

    finally:
        cursor.close()
        conn.close()
```

---

## 4. é…é¢æ£€æŸ¥æ¨¡å—

```python
class QuotaChecker:
    """é…é¢æ£€æŸ¥å™¨"""

    def __init__(self, conn, tenant_id):
        self.conn = conn
        self.cursor = conn.cursor()
        self.tenant_id = tenant_id

    def check_storage_quota(self) -> bool:
        """æ£€æŸ¥å­˜å‚¨é…é¢"""

        self.cursor.execute("""
            SELECT
                COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS used_gb,
                t.storage_quota_gb
            FROM tenants t
            LEFT JOIN documents d ON t.tenant_id = d.tenant_id
            WHERE t.tenant_id = %s
            GROUP BY t.storage_quota_gb;
        """, (self.tenant_id,))

        result = self.cursor.fetchone()
        if not result:
            return True

        used_gb, quota_gb = result
        return used_gb < quota_gb

    def get_quota_usage(self):
        """è·å–é…é¢ä½¿ç”¨æƒ…å†µ"""

        self.cursor.execute("""
            SELECT
                t.storage_quota_gb,
                COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS used_gb,
                COUNT(DISTINCT d.id) AS document_count,
                COUNT(DISTINCT u.id) AS user_count
            FROM tenants t
            LEFT JOIN documents d ON t.tenant_id = d.tenant_id
            LEFT JOIN users u ON t.tenant_id = u.tenant_id
            WHERE t.tenant_id = %s
            GROUP BY t.storage_quota_gb;
        """, (self.tenant_id,))

        result = self.cursor.fetchone()

        return {
            'quota_gb': result[0],
            'used_gb': float(result[1]),
            'usage_percent': (float(result[1]) / result[0] * 100) if result[0] > 0 else 0,
            'document_count': result[2],
            'user_count': result[3]
        }
```

---

---

## 5. ç§Ÿæˆ·æ•°æ®è¿ç§»

### 5.1 ç§Ÿæˆ·æ•°æ®è¿ç§»å‡½æ•°

**ç§Ÿæˆ·æ•°æ®è¿ç§»å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
class TenantDataMigrator:
    """ç§Ÿæˆ·æ•°æ®è¿ç§»å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def migrate_tenant_data(self, source_tenant_id, target_tenant_id):
        """
        è¿ç§»ç§Ÿæˆ·æ•°æ®

        Args:
            source_tenant_id: æºç§Ÿæˆ·ID
            target_tenant_id: ç›®æ ‡ç§Ÿæˆ·ID
        """

        try:
            # 1. è¿ç§»ç”¨æˆ·æ•°æ®
            self.cursor.execute("""
                INSERT INTO users (tenant_id, username, email, password_hash, created_at)
                SELECT %s, username, email, password_hash, created_at
                FROM users
                WHERE tenant_id = %s
            """, (target_tenant_id, source_tenant_id))

            user_count = self.cursor.rowcount

            # 2. è¿ç§»æ–‡æ¡£æ•°æ®
            self.cursor.execute("""
                INSERT INTO documents (tenant_id, user_id, title, content, size_bytes, created_at)
                SELECT %s,
                       (SELECT id FROM users WHERE tenant_id = %s AND username = u.username LIMIT 1),
                       d.title, d.content, d.size_bytes, d.created_at
                FROM documents d
                JOIN users u ON d.user_id = u.id
                WHERE d.tenant_id = %s
            """, (target_tenant_id, target_tenant_id, source_tenant_id))

            doc_count = self.cursor.rowcount

            self.conn.commit()

            return {
                'success': True,
                'users_migrated': user_count,
                'documents_migrated': doc_count
            }

        except Exception as e:
            self.conn.rollback()
            raise Exception(f"æ•°æ®è¿ç§»å¤±è´¥: {str(e)}")
```

---

## 6. ç§Ÿæˆ·éš”ç¦»éªŒè¯

### 6.1 éš”ç¦»æ€§æµ‹è¯•

**éš”ç¦»æ€§æµ‹è¯•å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
class TenantIsolationTester:
    """ç§Ÿæˆ·éš”ç¦»æµ‹è¯•å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def test_isolation(self, tenant_id_1, tenant_id_2):
        """
        æµ‹è¯•ç§Ÿæˆ·éš”ç¦»æ€§

        Args:
            tenant_id_1: ç§Ÿæˆ·1 ID
            tenant_id_2: ç§Ÿæˆ·2 ID
        """

        results = {}

        # æµ‹è¯•1: ç§Ÿæˆ·1åªèƒ½çœ‹åˆ°è‡ªå·±çš„æ•°æ®
        self.cursor.execute(f"SET app.current_tenant = {tenant_id_1};")
        self.cursor.execute("SELECT COUNT(*) FROM documents;")
        count_1 = self.cursor.fetchone()[0]
        results['tenant_1_document_count'] = count_1

        # æµ‹è¯•2: ç§Ÿæˆ·2åªèƒ½çœ‹åˆ°è‡ªå·±çš„æ•°æ®
        self.cursor.execute(f"SET app.current_tenant = {tenant_id_2};")
        self.cursor.execute("SELECT COUNT(*) FROM documents;")
        count_2 = self.cursor.fetchone()[0]
        results['tenant_2_document_count'] = count_2

        # æµ‹è¯•3: éªŒè¯éš”ç¦»æ€§
        if count_1 != count_2:
            results['isolation_status'] = 'é€šè¿‡'
        else:
            results['isolation_status'] = 'å¤±è´¥'

        return results
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 RLSæ€§èƒ½ä¼˜åŒ–

**RLSæ€§èƒ½ä¼˜åŒ–å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- RLSæ€§èƒ½ä¼˜åŒ–å‡½æ•°
CREATE OR REPLACE FUNCTION optimize_rls_performance()
RETURNS TABLE (
    table_name TEXT,
    rls_enabled BOOLEAN,
    index_exists BOOLEAN,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.tablename::TEXT,
        (SELECT relrowsecurity FROM pg_class WHERE relname = t.tablename) AS rls_enabled,
        EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE tablename = t.tablename
              AND indexname LIKE '%tenant%'
        ) AS index_exists,
        CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM pg_indexes
                WHERE tablename = t.tablename
                  AND indexname LIKE '%tenant%'
            ) THEN 'å»ºè®®åœ¨tenant_idä¸Šåˆ›å»ºç´¢å¼•'
            ELSE 'ç´¢å¼•å·²å­˜åœ¨'
        END
    FROM pg_tables t
    WHERE schemaname = 'public'
      AND tablename IN ('users', 'documents', 'tenant_usage_stats');

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'RLSæ€§èƒ½ä¼˜åŒ–æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 æŸ¥è¯¢ç¼“å­˜ä¼˜åŒ–

**æŸ¥è¯¢ç¼“å­˜ä¼˜åŒ–å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
from functools import lru_cache
import hashlib

class QueryCache:
    """æŸ¥è¯¢ç¼“å­˜"""

    def __init__(self, maxsize=128):
        self.cache = {}
        self.maxsize = maxsize

    def get_cache_key(self, query, tenant_id, params):
        """ç”Ÿæˆç¼“å­˜é”®"""
        cache_str = f"{query}_{tenant_id}_{str(params)}"
        return hashlib.md5(cache_str.encode()).hexdigest()

    def get(self, query, tenant_id, params):
        """è·å–ç¼“å­˜"""
        cache_key = self.get_cache_key(query, tenant_id, params)
        return self.cache.get(cache_key)

    def set(self, query, tenant_id, params, result):
        """è®¾ç½®ç¼“å­˜"""
        cache_key = self.get_cache_key(query, tenant_id, params)

        # LRUæ·˜æ±°
        if len(self.cache) >= self.maxsize:
            # åˆ é™¤æœ€æ—§çš„é¡¹ï¼ˆç®€åŒ–å¤„ç†ï¼‰
            oldest_key = next(iter(self.cache))
            del self.cache[oldest_key]

        self.cache[cache_key] = result

    def clear_tenant_cache(self, tenant_id):
        """æ¸…é™¤ç§Ÿæˆ·ç¼“å­˜"""
        keys_to_remove = [
            key for key in self.cache.keys()
            if key.startswith(hashlib.md5(str(tenant_id).encode()).hexdigest()[:8])
        ]
        for key in keys_to_remove:
            del self.cache[key]
```

---

## 8. ç›‘æ§ä¸è¯Šæ–­

### 8.1 ç§Ÿæˆ·èµ„æºç›‘æ§

**ç§Ÿæˆ·èµ„æºç›‘æ§å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç§Ÿæˆ·èµ„æºç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_tenant_resource_usage AS
SELECT
    t.tenant_id,
    t.tenant_name,
    t.plan_type,
    t.storage_quota_gb,
    COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS storage_used_gb,
    ROUND(
        COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 * 100.0 / NULLIF(t.storage_quota_gb, 0),
        2
    ) AS storage_usage_percent,
    COUNT(DISTINCT u.id) AS user_count,
    COUNT(DISTINCT d.id) AS document_count,
    t.connection_quota,
    (
        SELECT COUNT(*)
        FROM pg_stat_activity
        WHERE application_name LIKE 'tenant_' || t.tenant_id || '%'
    ) AS current_connections,
    CASE
        WHEN COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 >= t.storage_quota_gb THEN 'é…é¢å·²æ»¡'
        WHEN COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 >= t.storage_quota_gb * 0.8 THEN 'æ¥è¿‘é…é¢'
        ELSE 'æ­£å¸¸'
    END AS quota_status
FROM tenants t
LEFT JOIN users u ON t.tenant_id = u.tenant_id
LEFT JOIN documents d ON t.tenant_id = d.tenant_id
WHERE t.is_active = true
GROUP BY t.tenant_id, t.tenant_name, t.plan_type, t.storage_quota_gb, t.connection_quota;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_tenant_resource_usage
ORDER BY storage_usage_percent DESC;
```

---

**å®Œæˆæ—¥æœŸ**: 2025-12-04
**RLSç­–ç•¥**: tenant_idéš”ç¦»
**é…é¢**: å­˜å‚¨ + è¿æ¥ + API

**è¿”å›**: [æ¡ˆä¾‹4ä¸»é¡µ](./README.md)
