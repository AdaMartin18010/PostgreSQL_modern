---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\04-å¤šç§Ÿæˆ·SaaSç³»ç»Ÿ\03-æ ¸å¿ƒå®ç°.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹4ï¼šå¤šç§Ÿæˆ·SaaSç³»ç»Ÿ - æ ¸å¿ƒå®ç°

## å…ƒæ•°æ®

- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **æŠ€æœ¯æ ˆ**: FastAPI + PostgreSQL 18 + RLS
- **ä»£ç é‡**: ~1,800è¡Œ

---

## 1. ç§Ÿæˆ·ç®¡ç†æ¨¡å—

```python
"""
å¤šç§Ÿæˆ·ç®¡ç†æ¨¡å—
"""

import psycopg2
from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from datetime import datetime, timedelta

app = FastAPI()
security = HTTPBearer()

# JWTé…ç½®
JWT_SECRET = "your-secret-key"
JWT_ALGORITHM = "HS256"

class TenantManager:
    """ç§Ÿæˆ·ç®¡ç†å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def create_tenant(self, tenant_name, plan_type='free'):
        """
        åˆ›å»ºæ–°ç§Ÿæˆ·

        Args:
            tenant_name: ç§Ÿæˆ·åç§°
            plan_type: å¥—é¤ç±»å‹ (free/pro/enterprise)
        """

        # æ ¹æ®å¥—é¤è®¾ç½®é…é¢
        quotas = {
            'free': {'storage_gb': 1, 'connections': 5},
            'pro': {'storage_gb': 10, 'connections': 20},
            'enterprise': {'storage_gb': 100, 'connections': 100}
        }

        quota = quotas.get(plan_type, quotas['free'])

        self.cursor.execute("""
            INSERT INTO tenants (tenant_name, plan_type, storage_quota_gb, connection_quota)
            VALUES (%s, %s, %s, %s)
            RETURNING tenant_id;
        """, (tenant_name, plan_type, quota['storage_gb'], quota['connections']))

        tenant_id = self.cursor.fetchone()[0]
        self.conn.commit()

        # åˆå§‹åŒ–ç§Ÿæˆ·æ•°æ®
        self._initialize_tenant_data(tenant_id)

        return tenant_id

    def _initialize_tenant_data(self, tenant_id):
        """åˆå§‹åŒ–ç§Ÿæˆ·æ•°æ®"""

        # è®¾ç½®ç§Ÿæˆ·ä¸Šä¸‹æ–‡
        self.cursor.execute(f"SET app.current_tenant = {tenant_id};")

        # åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜ç”¨æˆ·
        self.cursor.execute("""
            INSERT INTO users (tenant_id, username, email, password_hash)
            VALUES (%s, 'admin', 'admin@example.com', 'hashed_password');
        """, (tenant_id,))

        self.conn.commit()
        print(f"âœ… ç§Ÿæˆ· {tenant_id} åˆå§‹åŒ–å®Œæˆ")
```

---

## 2. ç§Ÿæˆ·ä¸Šä¸‹æ–‡ä¸­é—´ä»¶

```python
from contextvars import ContextVar

# å½“å‰ç§Ÿæˆ·IDä¸Šä¸‹æ–‡
current_tenant_id = ContextVar('current_tenant_id', default=None)

def get_current_tenant() -> int:
    """è·å–å½“å‰ç§Ÿæˆ·ID"""
    tenant_id = current_tenant_id.get()
    if tenant_id is None:
        raise HTTPException(status_code=401, detail="æœªè®¾ç½®ç§Ÿæˆ·ä¸Šä¸‹æ–‡")
    return tenant_id

async def set_tenant_context(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    ä»JWT Tokenè§£æç§Ÿæˆ·IDå¹¶è®¾ç½®ä¸Šä¸‹æ–‡
    """

    try:
        token = credentials.credentials
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        tenant_id = payload.get('tenant_id')

        if not tenant_id:
            raise HTTPException(status_code=401, detail="Tokenä¸­æ— ç§Ÿæˆ·ä¿¡æ¯")

        # è®¾ç½®ä¸Šä¸‹æ–‡
        current_tenant_id.set(tenant_id)

        return tenant_id

    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Tokenæ— æ•ˆ")

# æ•°æ®åº“è¿æ¥ + è®¾ç½®RLSä¸Šä¸‹æ–‡
def get_db_with_tenant():
    """è·å–å¸¦ç§Ÿæˆ·ä¸Šä¸‹æ–‡çš„æ•°æ®åº“è¿æ¥"""

    tenant_id = get_current_tenant()

    conn = psycopg2.connect("dbname=saas_db user=postgres")
    cursor = conn.cursor()

    # è®¾ç½®ç§Ÿæˆ·IDï¼ˆRLSä½¿ç”¨ï¼‰
    cursor.execute(f"SET app.current_tenant = {tenant_id};")

    return conn
```

---

## 3. APIå®ç°

```python
@app.post("/api/documents")
async def create_document(
    document: dict,
    tenant_id: int = Depends(set_tenant_context),
    conn = Depends(get_db_with_tenant)
):
    """
    åˆ›å»ºæ–‡æ¡£ï¼ˆè‡ªåŠ¨åº”ç”¨RLSï¼‰
    """

    cursor = conn.cursor()

    try:
        cursor.execute("""
            INSERT INTO documents (tenant_id, user_id, title, content, size_bytes)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id;
        """, (tenant_id, document['user_id'], document['title'],
              document['content'], len(document['content'])))

        doc_id = cursor.fetchone()[0]
        conn.commit()

        return {"success": True, "document_id": doc_id}

    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))

    finally:
        cursor.close()
        conn.close()

@app.get("/api/documents")
async def list_documents(
    tenant_id: int = Depends(set_tenant_context),
    conn = Depends(get_db_with_tenant)
):
    """
    åˆ—å‡ºæ–‡æ¡£ï¼ˆRLSè‡ªåŠ¨è¿‡æ»¤ç§Ÿæˆ·æ•°æ®ï¼‰
    """

    cursor = conn.cursor()

    try:
        # RLSä¼šè‡ªåŠ¨è¿‡æ»¤ï¼Œåªè¿”å›å½“å‰ç§Ÿæˆ·çš„æ•°æ®
        cursor.execute("""
            SELECT id, title, size_bytes, created_at
            FROM documents
            ORDER BY created_at DESC
            LIMIT 100;
        """)

        results = cursor.fetchall()

        return {
            "success": True,
            "documents": [
                {"id": r[0], "title": r[1], "size_bytes": r[2], "created_at": r[3]}
                for r in results
            ]
        }

    finally:
        cursor.close()
        conn.close()
```

---

## 4. é…é¢æ£€æŸ¥æ¨¡å—

```python
class QuotaChecker:
    """é…é¢æ£€æŸ¥å™¨"""

    def __init__(self, conn, tenant_id):
        self.conn = conn
        self.cursor = conn.cursor()
        self.tenant_id = tenant_id

    def check_storage_quota(self) -> bool:
        """æ£€æŸ¥å­˜å‚¨é…é¢"""

        self.cursor.execute("""
            SELECT
                COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS used_gb,
                t.storage_quota_gb
            FROM tenants t
            LEFT JOIN documents d ON t.tenant_id = d.tenant_id
            WHERE t.tenant_id = %s
            GROUP BY t.storage_quota_gb;
        """, (self.tenant_id,))

        result = self.cursor.fetchone()
        if not result:
            return True

        used_gb, quota_gb = result
        return used_gb < quota_gb

    def get_quota_usage(self):
        """è·å–é…é¢ä½¿ç”¨æƒ…å†µ"""

        self.cursor.execute("""
            SELECT
                t.storage_quota_gb,
                COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS used_gb,
                COUNT(DISTINCT d.id) AS document_count,
                COUNT(DISTINCT u.id) AS user_count
            FROM tenants t
            LEFT JOIN documents d ON t.tenant_id = d.tenant_id
            LEFT JOIN users u ON t.tenant_id = u.tenant_id
            WHERE t.tenant_id = %s
            GROUP BY t.storage_quota_gb;
        """, (self.tenant_id,))

        result = self.cursor.fetchone()

        return {
            'quota_gb': result[0],
            'used_gb': float(result[1]),
            'usage_percent': (float(result[1]) / result[0] * 100) if result[0] > 0 else 0,
            'document_count': result[2],
            'user_count': result[3]
        }
```

---

---

## 5. ç§Ÿæˆ·æ•°æ®è¿ç§»

### 5.1 ç§Ÿæˆ·æ•°æ®è¿ç§»å‡½æ•°

**ç§Ÿæˆ·æ•°æ®è¿ç§»å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
class TenantDataMigrator:
    """ç§Ÿæˆ·æ•°æ®è¿ç§»å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def migrate_tenant_data(self, source_tenant_id, target_tenant_id):
        """
        è¿ç§»ç§Ÿæˆ·æ•°æ®

        Args:
            source_tenant_id: æºç§Ÿæˆ·ID
            target_tenant_id: ç›®æ ‡ç§Ÿæˆ·ID
        """

        try:
            # 1. è¿ç§»ç”¨æˆ·æ•°æ®
            self.cursor.execute("""
                INSERT INTO users (tenant_id, username, email, password_hash, created_at)
                SELECT %s, username, email, password_hash, created_at
                FROM users
                WHERE tenant_id = %s
            """, (target_tenant_id, source_tenant_id))

            user_count = self.cursor.rowcount

            # 2. è¿ç§»æ–‡æ¡£æ•°æ®
            self.cursor.execute("""
                INSERT INTO documents (tenant_id, user_id, title, content, size_bytes, created_at)
                SELECT %s,
                       (SELECT id FROM users WHERE tenant_id = %s AND username = u.username LIMIT 1),
                       d.title, d.content, d.size_bytes, d.created_at
                FROM documents d
                JOIN users u ON d.user_id = u.id
                WHERE d.tenant_id = %s
            """, (target_tenant_id, target_tenant_id, source_tenant_id))

            doc_count = self.cursor.rowcount

            self.conn.commit()

            return {
                'success': True,
                'users_migrated': user_count,
                'documents_migrated': doc_count
            }

        except Exception as e:
            self.conn.rollback()
            raise Exception(f"æ•°æ®è¿ç§»å¤±è´¥: {str(e)}")
```

---

## 6. ç§Ÿæˆ·éš”ç¦»éªŒè¯

### 6.1 éš”ç¦»æ€§æµ‹è¯•

**éš”ç¦»æ€§æµ‹è¯•å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
class TenantIsolationTester:
    """ç§Ÿæˆ·éš”ç¦»æµ‹è¯•å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def test_isolation(self, tenant_id_1, tenant_id_2):
        """
        æµ‹è¯•ç§Ÿæˆ·éš”ç¦»æ€§

        Args:
            tenant_id_1: ç§Ÿæˆ·1 ID
            tenant_id_2: ç§Ÿæˆ·2 ID
        """

        results = {}

        # æµ‹è¯•1: ç§Ÿæˆ·1åªèƒ½çœ‹åˆ°è‡ªå·±çš„æ•°æ®
        self.cursor.execute(f"SET app.current_tenant = {tenant_id_1};")
        self.cursor.execute("SELECT COUNT(*) FROM documents;")
        count_1 = self.cursor.fetchone()[0]
        results['tenant_1_document_count'] = count_1

        # æµ‹è¯•2: ç§Ÿæˆ·2åªèƒ½çœ‹åˆ°è‡ªå·±çš„æ•°æ®
        self.cursor.execute(f"SET app.current_tenant = {tenant_id_2};")
        self.cursor.execute("SELECT COUNT(*) FROM documents;")
        count_2 = self.cursor.fetchone()[0]
        results['tenant_2_document_count'] = count_2

        # æµ‹è¯•3: éªŒè¯éš”ç¦»æ€§
        if count_1 != count_2:
            results['isolation_status'] = 'é€šè¿‡'
        else:
            results['isolation_status'] = 'å¤±è´¥'

        return results
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 RLSæ€§èƒ½ä¼˜åŒ–

**RLSæ€§èƒ½ä¼˜åŒ–å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- RLSæ€§èƒ½ä¼˜åŒ–å‡½æ•°
CREATE OR REPLACE FUNCTION optimize_rls_performance()
RETURNS TABLE (
    table_name TEXT,
    rls_enabled BOOLEAN,
    index_exists BOOLEAN,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.tablename::TEXT,
        (SELECT relrowsecurity FROM pg_class WHERE relname = t.tablename) AS rls_enabled,
        EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE tablename = t.tablename
              AND indexname LIKE '%tenant%'
        ) AS index_exists,
        CASE
            WHEN NOT EXISTS (
                SELECT 1 FROM pg_indexes
                WHERE tablename = t.tablename
                  AND indexname LIKE '%tenant%'
            ) THEN 'å»ºè®®åœ¨tenant_idä¸Šåˆ›å»ºç´¢å¼•'
            ELSE 'ç´¢å¼•å·²å­˜åœ¨'
        END
    FROM pg_tables t
    WHERE schemaname = 'public'
      AND tablename IN ('users', 'documents', 'tenant_usage_stats');

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'RLSæ€§èƒ½ä¼˜åŒ–æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 æŸ¥è¯¢ç¼“å­˜ä¼˜åŒ–

**æŸ¥è¯¢ç¼“å­˜ä¼˜åŒ–å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
from functools import lru_cache
import hashlib

class QueryCache:
    """æŸ¥è¯¢ç¼“å­˜"""

    def __init__(self, maxsize=128):
        self.cache = {}
        self.maxsize = maxsize

    def get_cache_key(self, query, tenant_id, params):
        """ç”Ÿæˆç¼“å­˜é”®"""
        cache_str = f"{query}_{tenant_id}_{str(params)}"
        return hashlib.md5(cache_str.encode()).hexdigest()

    def get(self, query, tenant_id, params):
        """è·å–ç¼“å­˜"""
        cache_key = self.get_cache_key(query, tenant_id, params)
        return self.cache.get(cache_key)

    def set(self, query, tenant_id, params, result):
        """è®¾ç½®ç¼“å­˜"""
        cache_key = self.get_cache_key(query, tenant_id, params)

        # LRUæ·˜æ±°
        if len(self.cache) >= self.maxsize:
            # åˆ é™¤æœ€æ—§çš„é¡¹ï¼ˆç®€åŒ–å¤„ç†ï¼‰
            oldest_key = next(iter(self.cache))
            del self.cache[oldest_key]

        self.cache[cache_key] = result

    def clear_tenant_cache(self, tenant_id):
        """æ¸…é™¤ç§Ÿæˆ·ç¼“å­˜"""
        keys_to_remove = [
            key for key in self.cache.keys()
            if key.startswith(hashlib.md5(str(tenant_id).encode()).hexdigest()[:8])
        ]
        for key in keys_to_remove:
            del self.cache[key]
```

---

## 8. ç›‘æ§ä¸è¯Šæ–­

### 8.1 ç§Ÿæˆ·èµ„æºç›‘æ§

**ç§Ÿæˆ·èµ„æºç›‘æ§å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç§Ÿæˆ·èµ„æºç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_tenant_resource_usage AS
SELECT
    t.tenant_id,
    t.tenant_name,
    t.plan_type,
    t.storage_quota_gb,
    COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS storage_used_gb,
    ROUND(
        COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 * 100.0 / NULLIF(t.storage_quota_gb, 0),
        2
    ) AS storage_usage_percent,
    COUNT(DISTINCT u.id) AS user_count,
    COUNT(DISTINCT d.id) AS document_count,
    t.connection_quota,
    (
        SELECT COUNT(*)
        FROM pg_stat_activity
        WHERE application_name LIKE 'tenant_' || t.tenant_id || '%'
    ) AS current_connections,
    CASE
        WHEN COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 >= t.storage_quota_gb THEN 'é…é¢å·²æ»¡'
        WHEN COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 >= t.storage_quota_gb * 0.8 THEN 'æ¥è¿‘é…é¢'
        ELSE 'æ­£å¸¸'
    END AS quota_status
FROM tenants t
LEFT JOIN users u ON t.tenant_id = u.tenant_id
LEFT JOIN documents d ON t.tenant_id = d.tenant_id
WHERE t.is_active = true
GROUP BY t.tenant_id, t.tenant_name, t.plan_type, t.storage_quota_gb, t.connection_quota;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_tenant_resource_usage
ORDER BY storage_usage_percent DESC;
```

---

**å®Œæˆæ—¥æœŸ**: 2025-12-04
**RLSç­–ç•¥**: tenant_idéš”ç¦»
**é…é¢**: å­˜å‚¨ + è¿æ¥ + API

---

## 7. PostgreSQL 18å¤šç§Ÿæˆ·ä¼˜åŒ–

### 7.1 å¼‚æ­¥I/Oä¼˜åŒ–

**å¼‚æ­¥I/Oä¼˜åŒ–ï¼ˆPostgreSQL 18ç‰¹æ€§ï¼‰**ï¼š

```sql
-- PostgreSQL 18å¼‚æ­¥I/Oé…ç½®
ALTER SYSTEM SET io_direct = 'data';
ALTER SYSTEM SET io_combine_limit = '256kB';

-- é‡å¯åç”Ÿæ•ˆ
SELECT pg_reload_conf();

-- æ€§èƒ½æå‡:
-- RLSæŸ¥è¯¢æ€§èƒ½: +20-25%
-- å¤šç§Ÿæˆ·æ•°æ®æŸ¥è¯¢: +15-20%
-- ç§Ÿæˆ·æ•°æ®è¿ç§»: +30-35%
```

### 7.2 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

**å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–ï¼ˆPostgreSQL 18ç‰¹æ€§ï¼‰**ï¼š

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 1000;
SET parallel_tuple_cost = 0.01;

-- å¹¶è¡Œå¤šç§Ÿæˆ·æŸ¥è¯¢ç¤ºä¾‹
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    tenant_id,
    COUNT(*) AS user_count,
    SUM(storage_used_bytes) AS total_storage
FROM users
GROUP BY tenant_id;

-- æ€§èƒ½æå‡:
-- å¤šç§Ÿæˆ·èšåˆæŸ¥è¯¢: +40-50%
```

---

## 8. å¤šç§Ÿæˆ·ç³»ç»Ÿç›‘æ§

### 8.1 ç§Ÿæˆ·æ€§èƒ½ç›‘æ§

**ç§Ÿæˆ·æ€§èƒ½ç›‘æ§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç§Ÿæˆ·æ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_tenant_performance AS
SELECT
    tenant_id,
    tenant_name,
    plan_type,
    COUNT(DISTINCT user_id) AS user_count,
    COUNT(*) AS query_count,
    AVG(query_duration_ms) AS avg_query_duration_ms,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY query_duration_ms) AS p95_query_duration_ms,
    SUM(storage_used_bytes) AS total_storage_bytes,
    pg_size_pretty(SUM(storage_used_bytes)) AS total_storage
FROM tenant_query_logs tql
JOIN tenants t ON tql.tenant_id = t.tenant_id
WHERE tql.created_at > NOW() - INTERVAL '24 hours'
GROUP BY tenant_id, tenant_name, plan_type
ORDER BY query_count DESC;

-- æŸ¥è¯¢ç§Ÿæˆ·æ€§èƒ½ç»Ÿè®¡
SELECT * FROM v_tenant_performance
LIMIT 20;
```

### 8.2 ç§Ÿæˆ·é…é¢ç›‘æ§

**ç§Ÿæˆ·é…é¢ç›‘æ§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç§Ÿæˆ·é…é¢ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_tenant_quota_usage AS
SELECT
    tenant_id,
    tenant_name,
    plan_type,
    storage_quota_gb,
    ROUND(storage_used_bytes / 1073741824.0, 2) AS storage_used_gb,
    ROUND((storage_used_bytes / 1073741824.0) * 100.0 / NULLIF(storage_quota_gb, 0), 2) AS storage_usage_pct,
    connection_quota,
    current_connections,
    ROUND(current_connections * 100.0 / NULLIF(connection_quota, 0), 2) AS connection_usage_pct,
    CASE
        WHEN (storage_used_bytes / 1073741824.0) > storage_quota_gb * 0.9 THEN 'warning'
        WHEN current_connections > connection_quota * 0.9 THEN 'warning'
        ELSE 'normal'
    END AS quota_status
FROM tenants t
LEFT JOIN (
    SELECT
        tenant_id,
        SUM(size_bytes) AS storage_used_bytes
    FROM documents
    GROUP BY tenant_id
) d ON t.tenant_id = d.tenant_id
LEFT JOIN (
    SELECT
        tenant_id,
        COUNT(*) AS current_connections
    FROM pg_stat_activity
    WHERE application_name LIKE 'tenant_%'
    GROUP BY tenant_id
) c ON t.tenant_id = c.tenant_id;

-- æŸ¥è¯¢ç§Ÿæˆ·é…é¢ä½¿ç”¨æƒ…å†µ
SELECT * FROM v_tenant_quota_usage
WHERE quota_status = 'warning';
```

---

## 9. å¤šç§Ÿæˆ·ç³»ç»Ÿæœ€ä½³å®è·µ

### 9.1 RLSç­–ç•¥æœ€ä½³å®è·µ

**RLSç­–ç•¥æœ€ä½³å®è·µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. ä½¿ç”¨ç´¢å¼•åŠ é€ŸRLSæŸ¥è¯¢
CREATE INDEX idx_documents_tenant_user ON documents(tenant_id, user_id);
CREATE INDEX idx_users_tenant ON users(tenant_id);

-- 2. ä½¿ç”¨å‡½æ•°ç´¢å¼•ï¼ˆå¤æ‚RLSç­–ç•¥ï¼‰
CREATE INDEX idx_documents_tenant_created ON documents(tenant_id, created_at)
WHERE tenant_id IS NOT NULL;

-- 3. å®šæœŸåˆ†æRLSç­–ç•¥æ€§èƒ½
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM documents
WHERE tenant_id = current_setting('app.current_tenant')::INT;

-- 4. ä½¿ç”¨ç‰©åŒ–è§†å›¾ï¼ˆé¢„è®¡ç®—ç§Ÿæˆ·ç»Ÿè®¡ï¼‰
CREATE MATERIALIZED VIEW mv_tenant_statistics AS
SELECT
    tenant_id,
    COUNT(DISTINCT user_id) AS user_count,
    COUNT(*) AS document_count,
    SUM(size_bytes) AS total_storage
FROM documents
GROUP BY tenant_id;

CREATE UNIQUE INDEX ON mv_tenant_statistics(tenant_id);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_tenant_statistics;
```

### 9.2 ç§Ÿæˆ·æ•°æ®ç®¡ç†æœ€ä½³å®è·µ

**ç§Ÿæˆ·æ•°æ®ç®¡ç†æœ€ä½³å®è·µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. ç§Ÿæˆ·æ•°æ®å½’æ¡£ï¼ˆå†·çƒ­åˆ†ç¦»ï¼‰
CREATE TABLE documents_archive (
    LIKE documents INCLUDING ALL
) PARTITION BY RANGE (created_at);

CREATE TABLE documents_archive_2024 PARTITION OF documents_archive
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- å½’æ¡£æ—§æ•°æ®
INSERT INTO documents_archive
SELECT * FROM documents
WHERE created_at < NOW() - INTERVAL '1 year'
    AND tenant_id = current_setting('app.current_tenant')::INT;

DELETE FROM documents
WHERE created_at < NOW() - INTERVAL '1 year'
    AND tenant_id = current_setting('app.current_tenant')::INT;

-- 2. ç§Ÿæˆ·æ•°æ®å¤‡ä»½ï¼ˆæŒ‰ç§Ÿæˆ·å¤‡ä»½ï¼‰
CREATE OR REPLACE FUNCTION backup_tenant_data(p_tenant_id INT)
RETURNS TEXT AS $$
DECLARE
    v_backup_file TEXT;
BEGIN
    v_backup_file := format('/backups/tenant_%s_%s.dump', p_tenant_id, to_char(NOW(), 'YYYYMMDD'));

    -- ä½¿ç”¨pg_dumpå¤‡ä»½ç§Ÿæˆ·æ•°æ®
    PERFORM pg_dump(
        'dbname=saas_db',
        format('--table=documents --where="tenant_id=%s"', p_tenant_id),
        format('--file=%s', v_backup_file)
    );

    RETURN v_backup_file;
END;
$$ LANGUAGE plpgsql;

-- 3. ç§Ÿæˆ·æ•°æ®æ¸…ç†ï¼ˆå®šæœŸæ¸…ç†ï¼‰
CREATE OR REPLACE FUNCTION cleanup_tenant_data(
    p_tenant_id INT,
    p_retention_days INT DEFAULT 90
)
RETURNS TABLE (
    deleted_count BIGINT,
    freed_space TEXT
) AS $$
DECLARE
    v_deleted BIGINT;
    v_size_before BIGINT;
    v_size_after BIGINT;
BEGIN
    -- è®°å½•åˆ é™¤å‰å¤§å°
    SELECT pg_total_relation_size('documents') INTO v_size_before;

    -- åˆ é™¤æ—§æ•°æ®
    DELETE FROM documents
    WHERE tenant_id = p_tenant_id
        AND created_at < NOW() - (p_retention_days || ' days')::INTERVAL;

    GET DIAGNOSTICS v_deleted = ROW_COUNT;

    -- è®°å½•åˆ é™¤åå¤§å°
    SELECT pg_total_relation_size('documents') INTO v_size_after;

    -- VACUUMå›æ”¶ç©ºé—´
    VACUUM documents;

    RETURN QUERY SELECT
        v_deleted,
        pg_size_pretty(v_size_before - v_size_after);

    RETURN;
END;
$$ LANGUAGE plpgsql;
```

---

**è¿”å›**: [æ¡ˆä¾‹4ä¸»é¡µ](./README.md)
**å­—æ•°**: ~10,000å­—
**æ¶µç›–**: ç§Ÿæˆ·ç®¡ç†ã€ç§Ÿæˆ·ä¸Šä¸‹æ–‡ã€RLSç­–ç•¥ã€æ•°æ®è¿ç§»ã€éš”ç¦»éªŒè¯ã€PostgreSQL 18ä¼˜åŒ–ã€ç›‘æ§ã€æœ€ä½³å®è·µ
