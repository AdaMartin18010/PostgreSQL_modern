---

> **ðŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\07-å®žæ—¶æŽ¨èç³»ç»Ÿ\04-æ ¸å¿ƒå®žçŽ°.md`
> **ðŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŽŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹7ï¼šå®žæ—¶æŽ¨èç³»ç»Ÿ - æ ¸å¿ƒå®žçŽ°

```python
"""
å®žæ—¶æŽ¨èç³»ç»Ÿ
æŠ€æœ¯æ ˆ: PostgreSQL 18 + pgvector + FastAPI
"""

import psycopg2
from psycopg2.extras import RealDictCursor
import numpy as np
from fastapi import FastAPI, Query
from typing import List
import redis
import json
import time

app = FastAPI()

# æ•°æ®åº“é…ç½®
DB_CONFIG = {
    'dbname': 'recommendation_db',
    'user': 'postgres',
    'host': 'localhost'
}

# Redisé…ç½®
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

def get_db():
    return psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)

# ============================================================
# æŽ¨èAPI
# ============================================================

@app.get("/api/recommend/{user_id}")
async def get_recommendations(
    user_id: int,
    limit: int = Query(50, le=100),
    use_cache: bool = True
):
    """
    èŽ·å–ç”¨æˆ·æŽ¨è

    æµç¨‹:
    1. æ£€æŸ¥ç¼“å­˜
    2. å¤šè·¯å¬å›ž (User CF + Item CF + Vector + Popular)
    3. æŽ’åºæ‰“åˆ†
    4. è¿”å›žTop-N
    """

    start_time = time.time()

    # 1. æ£€æŸ¥ç¼“å­˜
    if use_cache:
        cache_key = f"recommend:{user_id}"
        cached = redis_client.get(cache_key)
        if cached:
            result = json.loads(cached)
            result['from_cache'] = True
            result['latency_ms'] = (time.time() - start_time) * 1000
            return result

    # 2. æ•°æ®åº“å¬å›ž
    conn = get_db()
    cursor = conn.cursor()

    try:
        cursor.execute("""
            SELECT item_id, final_score
            FROM recommend_items(%s, %s);
        """, (user_id, limit))

        recommendations = cursor.fetchall()

        # 3. è¡¥å……å•†å“ä¿¡æ¯
        item_ids = [r['item_id'] for r in recommendations]

        cursor.execute("""
            SELECT item_id, title, price, rating, sales_count
            FROM items
            WHERE item_id = ANY(%s);
        """, (item_ids,))

        items_info = {item['item_id']: item for item in cursor.fetchall()}

        # 4. åˆå¹¶ç»“æžœ
        result = []
        for rec in recommendations:
            item = items_info.get(rec['item_id'])
            if item:
                result.append({
                    'item_id': rec['item_id'],
                    'title': item['title'],
                    'price': float(item['price']),
                    'rating': float(item['rating']),
                    'sales': item['sales_count'],
                    'score': float(rec['final_score'])
                })

        response = {
            'user_id': user_id,
            'recommendations': result,
            'count': len(result),
            'from_cache': False,
            'latency_ms': (time.time() - start_time) * 1000
        }

        # 5. å†™å…¥ç¼“å­˜ï¼ˆ5åˆ†é’Ÿï¼‰
        if use_cache:
            redis_client.setex(
                f"recommend:{user_id}",
                300,
                json.dumps(response)
            )

        return response

    finally:
        cursor.close()
        conn.close()

# ============================================================
# è¡Œä¸ºè®°å½•API
# ============================================================

@app.post("/api/behavior")
async def record_behavior(
    user_id: int,
    item_id: int,
    behavior_type: str  # view/click/cart/buy
):
    """
    è®°å½•ç”¨æˆ·è¡Œä¸º
    å¼‚æ­¥å†™å…¥ï¼Œç«‹å³è¿”å›ž
    """

    conn = get_db()
    cursor = conn.cursor()

    try:
        cursor.execute("""
            INSERT INTO user_behavior (user_id, item_id, behavior_type)
            VALUES (%s, %s, %s);
        """, (user_id, item_id, behavior_type))

        conn.commit()

        # æ¸…é™¤ç”¨æˆ·æŽ¨èç¼“å­˜
        redis_client.delete(f"recommend:{user_id}")

        # å¼‚æ­¥æ›´æ–°ç”¨æˆ·ç”»åƒï¼ˆå®žé™…åº”è¯¥ç”¨æ¶ˆæ¯é˜Ÿåˆ—ï¼‰
        if behavior_type == 'buy':
            update_user_profile_async(user_id, item_id)

        return {'success': True}

    finally:
        cursor.close()
        conn.close()

# ============================================================
# ç›¸ä¼¼åº¦è®¡ç®—ï¼ˆç¦»çº¿ä»»åŠ¡ï¼‰
# ============================================================

class SimilarityCalculator:
    """ç›¸ä¼¼åº¦è®¡ç®—å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def calculate_item_similarity(self, min_common_users=5):
        """
        è®¡ç®—å•†å“ç›¸ä¼¼åº¦ï¼ˆItem-Based CFï¼‰
        åŸºäºŽå…±åŒè´­ä¹°ç”¨æˆ·çš„Jaccardç›¸ä¼¼åº¦
        """

        print("å¼€å§‹è®¡ç®—å•†å“ç›¸ä¼¼åº¦...")

        # 1. èŽ·å–çƒ­é—¨å•†å“ï¼ˆè®¡ç®—é‡å¤§ï¼Œåªç®—Topå•†å“ï¼‰
        self.cursor.execute("""
            SELECT item_id FROM items
            WHERE sales_count > 10
            ORDER BY sales_count DESC
            LIMIT 10000;
        """)

        popular_items = [row[0] for row in self.cursor.fetchall()]

        # 2. æ‰¹é‡è®¡ç®—ç›¸ä¼¼åº¦
        batch_size = 100
        for i in range(0, len(popular_items), batch_size):
            batch = popular_items[i:i+batch_size]

            self.cursor.execute("""
                WITH item_users AS (
                    SELECT item_id, array_agg(DISTINCT user_id) AS users
                    FROM user_behavior
                    WHERE item_id = ANY(%s)
                      AND behavior_type IN ('buy', 'cart')
                      AND timestamp > CURRENT_TIMESTAMP - INTERVAL '90 days'
                    GROUP BY item_id
                ),
                pairs AS (
                    SELECT
                        a.item_id AS item_a,
                        b.item_id AS item_b,
                        a.users AS users_a,
                        b.users AS users_b
                    FROM item_users a
                    CROSS JOIN item_users b
                    WHERE a.item_id < b.item_id
                ),
                similarities AS (
                    SELECT
                        item_a,
                        item_b,
                        cardinality(users_a & users_b)::NUMERIC /
                        NULLIF(cardinality(users_a | users_b), 0) AS jaccard_sim
                    FROM pairs
                    WHERE cardinality(users_a & users_b) >= %s
                )
                INSERT INTO item_similarity (item_id, similar_item_id, similarity_score)
                SELECT item_a, item_b, jaccard_sim FROM similarities
                UNION ALL
                SELECT item_b, item_a, jaccard_sim FROM similarities
                ON CONFLICT (item_id, similar_item_id) DO UPDATE
                SET similarity_score = EXCLUDED.similarity_score;
            """, (batch, min_common_users))

            self.conn.commit()
            print(f"å·²å¤„ç† {i+len(batch)}/{len(popular_items)} ä¸ªå•†å“")

        print("âœ… å•†å“ç›¸ä¼¼åº¦è®¡ç®—å®Œæˆ")

    def calculate_user_similarity(self):
        """
        è®¡ç®—ç”¨æˆ·ç›¸ä¼¼åº¦ï¼ˆUser-Based CFï¼‰
        åŸºäºŽä½™å¼¦ç›¸ä¼¼åº¦
        """

        print("å¼€å§‹è®¡ç®—ç”¨æˆ·ç›¸ä¼¼åº¦...")

        # æ´»è·ƒç”¨æˆ·ï¼ˆæœ€è¿‘30å¤©æœ‰è¡Œä¸ºï¼‰
        self.cursor.execute("""
            WITH active_users AS (
                SELECT DISTINCT user_id
                FROM user_behavior
                WHERE timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
                LIMIT 50000
            ),
            user_vectors AS (
                SELECT
                    ub.user_id,
                    array_agg(ub.item_id) AS items
                FROM user_behavior ub
                JOIN active_users au ON ub.user_id = au.user_id
                WHERE ub.behavior_type IN ('buy', 'cart')
                  AND ub.timestamp > CURRENT_TIMESTAMP - INTERVAL '90 days'
                GROUP BY ub.user_id
            ),
            pairs AS (
                SELECT
                    a.user_id AS user_a,
                    b.user_id AS user_b,
                    a.items AS items_a,
                    b.items AS items_b
                FROM user_vectors a
                CROSS JOIN user_vectors b
                WHERE a.user_id < b.user_id
                  AND a.items && b.items  -- æœ‰å…±åŒå•†å“
            ),
            similarities AS (
                SELECT
                    user_a,
                    user_b,
                    cardinality(items_a & items_b)::NUMERIC /
                    SQRT(cardinality(items_a) * cardinality(items_b)) AS cosine_sim
                FROM pairs
                WHERE cardinality(items_a & items_b) >= 3
            )
            INSERT INTO user_similarity (user_id, similar_user_id, similarity_score)
            SELECT user_a, user_b, cosine_sim FROM similarities WHERE cosine_sim > 0.1
            UNION ALL
            SELECT user_b, user_a, cosine_sim FROM similarities WHERE cosine_sim > 0.1
            ON CONFLICT (user_id, similar_user_id) DO UPDATE
            SET similarity_score = EXCLUDED.similarity_score;
        """)

        self.conn.commit()
        print("âœ… ç”¨æˆ·ç›¸ä¼¼åº¦è®¡ç®—å®Œæˆ")

# ============================================================
# ç‰¹å¾å‘é‡æ›´æ–°ï¼ˆç¦»çº¿ä»»åŠ¡ï¼‰
# ============================================================

def update_item_embeddings():
    """
    æ›´æ–°å•†å“å‘é‡
    ä½¿ç”¨å•†å“å±žæ€§å’Œç”¨æˆ·è¡Œä¸ºè®¡ç®—embedding
    """

    conn = get_db()
    cursor = conn.cursor()

    # ç®€åŒ–ç‰ˆï¼šåŸºäºŽå•†å“å±žæ€§ç”Ÿæˆå‘é‡
    cursor.execute("""
        SELECT item_id, category_id, brand_id, price, sales_count
        FROM items;
    """)

    items = cursor.fetchall()

    for item in items:
        # å®žé™…åº”è¯¥ç”¨å¤æ‚çš„embeddingæ¨¡åž‹
        # è¿™é‡Œç®€åŒ–ä¸ºåŸºäºŽå±žæ€§çš„å‘é‡
        embedding = np.random.rand(128).tolist()  # å ä½

        cursor.execute("""
            UPDATE items
            SET embedding = %s::vector
            WHERE item_id = %s;
        """, (embedding, item['item_id']))

    conn.commit()
    cursor.close()
    conn.close()

    print("âœ… å•†å“å‘é‡æ›´æ–°å®Œæˆ")

def update_user_profile_async(user_id, item_id):
    """å¼‚æ­¥æ›´æ–°ç”¨æˆ·ç”»åƒï¼ˆç®€åŒ–ç‰ˆï¼‰"""
    # å®žé™…åº”è¯¥ç”¨æ¶ˆæ¯é˜Ÿåˆ—
    pass

# ============================================================
# æ€§èƒ½ç›‘æŽ§
# ============================================================

@app.get("/api/stats")
async def get_stats():
    """ç³»ç»Ÿç»Ÿè®¡"""

    conn = get_db()
    cursor = conn.cursor()

    cursor.execute("""
        SELECT
            (SELECT COUNT(*) FROM users) AS user_count,
            (SELECT COUNT(*) FROM items) AS item_count,
            (SELECT COUNT(*) FROM user_behavior
             WHERE timestamp > CURRENT_TIMESTAMP - INTERVAL '1 day') AS behavior_24h,
            (SELECT COUNT(*) FROM item_similarity) AS item_sim_pairs,
            (SELECT COUNT(*) FROM user_similarity) AS user_sim_pairs;
    """)

    stats = cursor.fetchone()

    cursor.close()
    conn.close()

    return stats

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8003)
```

---

**è¿”å›ž**: [æ¡ˆä¾‹7ä¸»é¡µ](./README.md)
