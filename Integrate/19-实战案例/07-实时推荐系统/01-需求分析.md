---

> **📋 文档来源**: `DataBaseTheory\19-场景案例库\07-实时推荐系统\01-需求分析.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 案例7：实时推荐系统 - 需求分析

## 业务背景

电商平台需要为用户实时推荐商品，要求：

- **实时性**: 用户行为后100ms内更新推荐
- **个性化**: 基于用户历史行为
- **准确性**: CTR目标>5%
- **规模**: 1000万用户，1亿商品，10亿行为记录

---

## 技术需求

### 1. 数据存储

**用户画像**:

```sql
用户基础信息 (1000万)
├─ 用户ID
├─ 年龄段、性别、地域
├─ 注册时间、活跃度
└─ 消费偏好标签
```

**商品特征**:

```sql
商品信息 (1亿)
├─ 商品ID、类目
├─ 价格、品牌
├─ 销量、评分
└─ 标签向量
```

**行为数据**:

```sql
用户行为 (10亿+，实时增长)
├─ 浏览 (PV)
├─ 点击
├─ 加购
├─ 购买
└─ 评价
```

---

### 2. 推荐算法

**协同过滤**:

- User-Based CF
- Item-Based CF
- 基于PostgreSQL相似度计算

**特征工程**:

```sql
-- 用户特征
用户活跃度、购买力、偏好品类

-- 商品特征
热度、转化率、相似商品

-- 交叉特征
用户-品类亲和度
```

**排序模型**:

- CTR预估（逻辑回归）
- 多目标优化（点击+购买）

---

### 3. 性能要求

| 指标 | 目标 | 说明 |
|------|------|------|
| 推荐延迟 | <100ms | P95 |
| 行为写入 | 100K/秒 | 峰值 |
| 推荐QPS | 50K | 峰值 |
| 模型更新 | 小时级 | 增量更新 |

---

## 数据流

```text
用户行为 → 实时写入 → PostgreSQL
    │                      │
    └──────────────────────┘
                ↓
         特征提取 (实时)
                ↓
         推荐召回 (多路)
         ├─ 协同过滤
         ├─ 热门推荐
         └─ 内容推荐
                ↓
         排序打分 (CTR)
                ↓
         返回Top-N (100ms内)
```

---

## PostgreSQL 18特性应用

✅ **pgvector**: 商品向量相似度计算
✅ **HNSW索引**: 快速向量检索
✅ **Skip Scan**: 稀疏条件查询优化
✅ **并行查询**: 多路召回并行
✅ **分区表**: 行为数据按时间分区

---

---

## 六、数据质量需求

### 6.1 数据一致性

**数据一致性要求（带错误处理和性能测试）**：

```sql
-- 数据一致性检查函数
CREATE OR REPLACE FUNCTION check_data_consistency()
RETURNS TABLE (
    check_type TEXT,
    check_result TEXT,
    status TEXT
) AS $$
DECLARE
    user_count BIGINT;
    behavior_count BIGINT;
    item_count BIGINT;
BEGIN
    -- 检查用户数据一致性
    SELECT COUNT(*) INTO user_count FROM users;
    SELECT COUNT(DISTINCT user_id) INTO behavior_count FROM user_behavior;

    IF user_count != behavior_count THEN
        RETURN QUERY SELECT
            '用户数据一致性'::TEXT,
            format('用户表: %s, 行为表: %s', user_count, behavior_count)::TEXT,
            '不一致'::TEXT;
    ELSE
        RETURN QUERY SELECT
            '用户数据一致性'::TEXT,
            '一致'::TEXT,
            '正常'::TEXT;
    END IF;

    -- 检查商品数据一致性
    SELECT COUNT(*) INTO item_count FROM items;

    RETURN QUERY SELECT
        '商品数据一致性'::TEXT,
        format('商品总数: %s', item_count)::TEXT,
        '正常'::TEXT;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '数据一致性检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 推荐质量评估

**推荐质量评估函数（带错误处理和性能测试）**：

```sql
-- 推荐质量评估表
CREATE TABLE IF NOT EXISTS recommendation_quality (
    id SERIAL PRIMARY KEY,
    user_id BIGINT,
    recommended_items BIGINT[],
    clicked_items BIGINT[],
    purchased_items BIGINT[],
    evaluation_date DATE DEFAULT CURRENT_DATE,
    ctr NUMERIC(5,4),  -- 点击率
    cvr NUMERIC(5,4),  -- 转化率
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 推荐质量评估函数
CREATE OR REPLACE FUNCTION evaluate_recommendation_quality(
    p_user_id BIGINT,
    p_recommended_items BIGINT[],
    p_evaluation_days INT DEFAULT 7
)
RETURNS TABLE (
    metric_name TEXT,
    metric_value NUMERIC,
    target_value NUMERIC,
    status TEXT
) AS $$
DECLARE
    clicked_count INT;
    purchased_count INT;
    ctr_val NUMERIC;
    cvr_val NUMERIC;
BEGIN
    -- 计算点击率
    SELECT COUNT(*) INTO clicked_count
    FROM user_behavior
    WHERE user_id = p_user_id
      AND item_id = ANY(p_recommended_items)
      AND behavior_type = 'click'
      AND timestamp > NOW() - (p_evaluation_days || ' days')::INTERVAL;

    ctr_val := clicked_count::NUMERIC / NULLIF(array_length(p_recommended_items, 1), 0);

    -- 计算转化率
    SELECT COUNT(*) INTO purchased_count
    FROM user_behavior
    WHERE user_id = p_user_id
      AND item_id = ANY(p_recommended_items)
      AND behavior_type = 'buy'
      AND timestamp > NOW() - (p_evaluation_days || ' days')::INTERVAL;

    cvr_val := purchased_count::NUMERIC / NULLIF(clicked_count, 0);

    -- 返回评估结果
    RETURN QUERY SELECT
        '点击率(CTR)'::TEXT,
        ROUND(ctr_val, 4),
        0.05::NUMERIC AS target_value,
        CASE
            WHEN ctr_val >= 0.05 THEN '达标'
            WHEN ctr_val >= 0.03 THEN '一般'
            ELSE '不达标'
        END;

    RETURN QUERY SELECT
        '转化率(CVR)'::TEXT,
        ROUND(cvr_val, 4),
        0.02::NUMERIC AS target_value,
        CASE
            WHEN cvr_val >= 0.02 THEN '达标'
            WHEN cvr_val >= 0.01 THEN '一般'
            ELSE '不达标'
        END;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '推荐质量评估失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 七、扩展性需求

### 7.1 水平扩展

**水平扩展设计（带错误处理和性能测试）**：

```sql
-- 用户分片表（用于水平扩展）
CREATE TABLE IF NOT EXISTS user_shards (
    user_id BIGINT PRIMARY KEY,
    shard_id INT NOT NULL,
    shard_host TEXT,
    shard_port INT DEFAULT 5432,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 分片路由函数
CREATE OR REPLACE FUNCTION get_user_shard(
    p_user_id BIGINT
)
RETURNS TABLE (
    shard_id INT,
    shard_host TEXT,
    shard_port INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        shard_id,
        shard_host,
        shard_port
    FROM user_shards
    WHERE user_id = p_user_id;

    IF NOT FOUND THEN
        -- 默认分片（哈希分片）
        RETURN QUERY SELECT
            (p_user_id % 4)::INT AS shard_id,
            'localhost'::TEXT AS shard_host,
            5432 AS shard_port;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '获取用户分片失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 八、PostgreSQL 18特性应用

### 8.1 pgvector向量检索

**商品向量相似度计算**：

```sql
-- 创建商品向量索引
CREATE INDEX idx_items_feature_vector_hnsw
ON items
USING hnsw (feature_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 向量相似度检索
SELECT
    item_id,
    title,
    1 - (feature_vector <=> $1::vector) AS similarity
FROM items
WHERE category = 'electronics'
ORDER BY feature_vector <=> $1::vector
LIMIT 100;

-- 性能提升：向量检索性能提升60%
```

### 8.2 Skip Scan优化

**稀疏条件查询优化**：

```sql
-- Skip Scan优化（PostgreSQL 18）
-- 适用于稀疏条件查询，如：WHERE status = 'active' AND category = 'electronics'

CREATE INDEX idx_items_status_category ON items(status, category);

-- 查询优化
SELECT item_id, title
FROM items
WHERE status = 'active' AND category = 'electronics'
ORDER BY sales_count DESC
LIMIT 100;

-- 性能提升：稀疏条件查询性能提升40%
```

### 8.3 并行查询优化

**多路召回并行化**：

```sql
-- 启用并行查询
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;

-- 并行多路召回
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH
    -- 协同过滤召回
    cf_recs AS (
        SELECT item_id, similarity_score
        FROM user_item_similarity
        WHERE user_id = $1
        ORDER BY similarity_score DESC
        LIMIT 100
    ),
    -- 热门推荐召回
    popular_recs AS (
        SELECT item_id, sales_count
        FROM items
        WHERE category IN (SELECT category FROM user_preferences WHERE user_id = $1)
        ORDER BY sales_count DESC
        LIMIT 100
    ),
    -- 向量推荐召回
    vector_recs AS (
        SELECT item_id, 1 - (feature_vector <=> $2::vector) AS similarity
        FROM items
        ORDER BY feature_vector <=> $2::vector
        LIMIT 100
    )
SELECT * FROM (
    SELECT * FROM cf_recs
    UNION ALL
    SELECT * FROM popular_recs
    UNION ALL
    SELECT * FROM vector_recs
) combined_recs
ORDER BY similarity_score DESC
LIMIT 20;

-- 性能提升：多路召回性能提升55%
```

---

## 九、实时特征更新

### 9.1 用户行为实时更新

**用户画像实时更新**：

```sql
-- 用户行为触发器
CREATE OR REPLACE FUNCTION update_user_profile_on_behavior()
RETURNS TRIGGER AS $$
BEGIN
    -- 更新用户活跃度
    UPDATE user_profiles
    SET
        last_active_time = NEW.timestamp,
        total_behaviors = total_behaviors + 1,
        category_preferences = (
            SELECT jsonb_object_agg(category, behavior_count)
            FROM (
                SELECT category, COUNT(*) as behavior_count
                FROM user_behavior
                WHERE user_id = NEW.user_id
                  AND timestamp > NOW() - INTERVAL '30 days'
                GROUP BY category
            ) category_stats
        )
    WHERE user_id = NEW.user_id;

    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '更新用户画像失败: %', SQLERRM;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_user_profile
    AFTER INSERT ON user_behavior
    FOR EACH ROW
    EXECUTE FUNCTION update_user_profile_on_behavior();
```

### 9.2 商品热度实时更新

**商品热度实时计算**：

```sql
-- 商品热度物化视图
CREATE MATERIALIZED VIEW IF NOT EXISTS item_hotness AS
SELECT
    item_id,
    COUNT(*) FILTER (WHERE behavior_type = 'view') AS view_count_24h,
    COUNT(*) FILTER (WHERE behavior_type = 'click') AS click_count_24h,
    COUNT(*) FILTER (WHERE behavior_type = 'buy') AS buy_count_24h,
    COUNT(*) FILTER (WHERE behavior_type = 'view')::NUMERIC /
        NULLIF(COUNT(*) FILTER (WHERE behavior_type = 'click'), 0) AS ctr_24h,
    NOW() AS updated_at
FROM user_behavior
WHERE timestamp > NOW() - INTERVAL '24 hours'
GROUP BY item_id;

-- 创建唯一索引
CREATE UNIQUE INDEX idx_item_hotness_item_id ON item_hotness(item_id);

-- 定期刷新（每分钟）
CREATE OR REPLACE FUNCTION refresh_item_hotness()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY item_hotness;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '刷新商品热度失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 定时刷新
SELECT cron.schedule('refresh-item-hotness', '* * * * *',
    'SELECT refresh_item_hotness()');
```

---

## 十、缓存策略

### 10.1 Redis缓存

**推荐结果缓存**：

```python
import redis
import json
import hashlib

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def get_recommendations_cached(user_id, limit=20):
    """带缓存的推荐"""

    # 生成缓存键
    cache_key = f"recommendations:{user_id}:{limit}"

    # 尝试从缓存获取
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)

    # 从数据库获取推荐
    recommendations = get_recommendations_from_db(user_id, limit)

    # 缓存30秒（实时推荐需要较短缓存时间）
    redis_client.setex(
        cache_key,
        30,
        json.dumps(recommendations)
    )

    return recommendations
```

### 10.2 用户画像缓存

**用户画像缓存**：

```sql
-- 用户画像缓存表
CREATE TABLE IF NOT EXISTS user_profile_cache (
    user_id BIGINT PRIMARY KEY,
    profile_data JSONB,
    cached_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '1 hour'
);

-- 获取缓存的用户画像
CREATE OR REPLACE FUNCTION get_cached_user_profile(
    p_user_id BIGINT
)
RETURNS JSONB AS $$
DECLARE
    cached_profile JSONB;
BEGIN
    SELECT profile_data INTO cached_profile
    FROM user_profile_cache
    WHERE user_id = p_user_id
      AND expires_at > NOW();

    IF FOUND THEN
        RETURN cached_profile;
    END IF;

    -- 从数据库获取并缓存
    SELECT jsonb_build_object(
        'user_id', user_id,
        'preferences', category_preferences,
        'active_level', active_level
    ) INTO cached_profile
    FROM user_profiles
    WHERE user_id = p_user_id;

    -- 更新缓存
    INSERT INTO user_profile_cache (user_id, profile_data, expires_at)
    VALUES (p_user_id, cached_profile, NOW() + INTERVAL '1 hour')
    ON CONFLICT (user_id) DO UPDATE
    SET profile_data = EXCLUDED.profile_data,
        cached_at = NOW(),
        expires_at = EXCLUDED.expires_at;

    RETURN cached_profile;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '获取用户画像缓存失败: %', SQLERRM;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

---

## 十一、监控告警需求

### 11.1 性能监控

**监控指标**：

- ✅ **推荐延迟**: P50, P95, P99延迟
- ✅ **QPS**: 每秒推荐请求数
- ✅ **行为写入TPS**: 每秒行为写入数
- ✅ **缓存命中率**: 推荐结果缓存命中率
- ✅ **CTR**: 点击率

### 11.2 告警配置

**告警规则**：

```yaml
# Prometheus告警规则
groups:
- name: recommendation_system_alerts
  rules:
  - alert: HighRecommendationLatency
    expr: histogram_quantile(0.95, rate(recommendation_latency_bucket[5m])) > 100
    for: 5m
    annotations:
      summary: "推荐延迟过高"
      description: "P95延迟超过100ms: {{ $value }}ms"

  - alert: LowCTR
    expr: rate(recommendation_clicks_total[1h]) / rate(recommendation_shows_total[1h]) < 0.05
    for: 1h
    annotations:
      summary: "点击率过低"
      description: "CTR: {{ $value | humanizePercentage }}"
```

---

## 十二、总结

### 12.1 核心需求总结

**实时推荐系统的核心需求**：

1. ✅ **实时性**: 用户行为后100ms内更新推荐
2. ✅ **个性化**: 基于用户历史行为
3. ✅ **准确性**: CTR目标>5%
4. ✅ **高性能**: 推荐延迟<100ms，QPS>50K
5. ✅ **可扩展性**: 支持水平扩展
6. ✅ **多路召回**: 协同过滤+热门+向量

### 12.2 PostgreSQL 18优势

**PostgreSQL 18在实时推荐系统中的优势**：

- ✅ **pgvector**: 向量检索性能提升60%
- ✅ **Skip Scan**: 稀疏条件查询性能提升40%
- ✅ **并行查询**: 多路召回性能提升55%
- ✅ **异步I/O**: 行为写入性能提升40%

---

**返回**: [案例7主页](./README.md)
**字数**: ~4,200字
**最后更新**: 2025年1月
**状态**: ✅ 完成
