---

> **📋 文档来源**: `DataBaseTheory\19-场景案例库\07-实时推荐系统\01-需求分析.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 案例7：实时推荐系统 - 需求分析

## 业务背景

电商平台需要为用户实时推荐商品，要求：

- **实时性**: 用户行为后100ms内更新推荐
- **个性化**: 基于用户历史行为
- **准确性**: CTR目标>5%
- **规模**: 1000万用户，1亿商品，10亿行为记录

---

## 技术需求

### 1. 数据存储

**用户画像**:

```sql
用户基础信息 (1000万)
├─ 用户ID
├─ 年龄段、性别、地域
├─ 注册时间、活跃度
└─ 消费偏好标签
```

**商品特征**:

```sql
商品信息 (1亿)
├─ 商品ID、类目
├─ 价格、品牌
├─ 销量、评分
└─ 标签向量
```

**行为数据**:

```sql
用户行为 (10亿+，实时增长)
├─ 浏览 (PV)
├─ 点击
├─ 加购
├─ 购买
└─ 评价
```

---

### 2. 推荐算法

**协同过滤**:

- User-Based CF
- Item-Based CF
- 基于PostgreSQL相似度计算

**特征工程**:

```sql
-- 用户特征
用户活跃度、购买力、偏好品类

-- 商品特征
热度、转化率、相似商品

-- 交叉特征
用户-品类亲和度
```

**排序模型**:

- CTR预估（逻辑回归）
- 多目标优化（点击+购买）

---

### 3. 性能要求

| 指标 | 目标 | 说明 |
|------|------|------|
| 推荐延迟 | <100ms | P95 |
| 行为写入 | 100K/秒 | 峰值 |
| 推荐QPS | 50K | 峰值 |
| 模型更新 | 小时级 | 增量更新 |

---

## 数据流

```text
用户行为 → 实时写入 → PostgreSQL
    │                      │
    └──────────────────────┘
                ↓
         特征提取 (实时)
                ↓
         推荐召回 (多路)
         ├─ 协同过滤
         ├─ 热门推荐
         └─ 内容推荐
                ↓
         排序打分 (CTR)
                ↓
         返回Top-N (100ms内)
```

---

## PostgreSQL 18特性应用

✅ **pgvector**: 商品向量相似度计算
✅ **HNSW索引**: 快速向量检索
✅ **Skip Scan**: 稀疏条件查询优化
✅ **并行查询**: 多路召回并行
✅ **分区表**: 行为数据按时间分区

---

---

## 六、数据质量需求

### 6.1 数据一致性

**数据一致性要求（带错误处理和性能测试）**：

```sql
-- 数据一致性检查函数
CREATE OR REPLACE FUNCTION check_data_consistency()
RETURNS TABLE (
    check_type TEXT,
    check_result TEXT,
    status TEXT
) AS $$
DECLARE
    user_count BIGINT;
    behavior_count BIGINT;
    item_count BIGINT;
BEGIN
    -- 检查用户数据一致性
    SELECT COUNT(*) INTO user_count FROM users;
    SELECT COUNT(DISTINCT user_id) INTO behavior_count FROM user_behavior;

    IF user_count != behavior_count THEN
        RETURN QUERY SELECT
            '用户数据一致性'::TEXT,
            format('用户表: %s, 行为表: %s', user_count, behavior_count)::TEXT,
            '不一致'::TEXT;
    ELSE
        RETURN QUERY SELECT
            '用户数据一致性'::TEXT,
            '一致'::TEXT,
            '正常'::TEXT;
    END IF;

    -- 检查商品数据一致性
    SELECT COUNT(*) INTO item_count FROM items;

    RETURN QUERY SELECT
        '商品数据一致性'::TEXT,
        format('商品总数: %s', item_count)::TEXT,
        '正常'::TEXT;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '数据一致性检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 推荐质量评估

**推荐质量评估函数（带错误处理和性能测试）**：

```sql
-- 推荐质量评估表
CREATE TABLE IF NOT EXISTS recommendation_quality (
    id SERIAL PRIMARY KEY,
    user_id BIGINT,
    recommended_items BIGINT[],
    clicked_items BIGINT[],
    purchased_items BIGINT[],
    evaluation_date DATE DEFAULT CURRENT_DATE,
    ctr NUMERIC(5,4),  -- 点击率
    cvr NUMERIC(5,4),  -- 转化率
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 推荐质量评估函数
CREATE OR REPLACE FUNCTION evaluate_recommendation_quality(
    p_user_id BIGINT,
    p_recommended_items BIGINT[],
    p_evaluation_days INT DEFAULT 7
)
RETURNS TABLE (
    metric_name TEXT,
    metric_value NUMERIC,
    target_value NUMERIC,
    status TEXT
) AS $$
DECLARE
    clicked_count INT;
    purchased_count INT;
    ctr_val NUMERIC;
    cvr_val NUMERIC;
BEGIN
    -- 计算点击率
    SELECT COUNT(*) INTO clicked_count
    FROM user_behavior
    WHERE user_id = p_user_id
      AND item_id = ANY(p_recommended_items)
      AND behavior_type = 'click'
      AND timestamp > NOW() - (p_evaluation_days || ' days')::INTERVAL;

    ctr_val := clicked_count::NUMERIC / NULLIF(array_length(p_recommended_items, 1), 0);

    -- 计算转化率
    SELECT COUNT(*) INTO purchased_count
    FROM user_behavior
    WHERE user_id = p_user_id
      AND item_id = ANY(p_recommended_items)
      AND behavior_type = 'buy'
      AND timestamp > NOW() - (p_evaluation_days || ' days')::INTERVAL;

    cvr_val := purchased_count::NUMERIC / NULLIF(clicked_count, 0);

    -- 返回评估结果
    RETURN QUERY SELECT
        '点击率(CTR)'::TEXT,
        ROUND(ctr_val, 4),
        0.05::NUMERIC AS target_value,
        CASE
            WHEN ctr_val >= 0.05 THEN '达标'
            WHEN ctr_val >= 0.03 THEN '一般'
            ELSE '不达标'
        END;

    RETURN QUERY SELECT
        '转化率(CVR)'::TEXT,
        ROUND(cvr_val, 4),
        0.02::NUMERIC AS target_value,
        CASE
            WHEN cvr_val >= 0.02 THEN '达标'
            WHEN cvr_val >= 0.01 THEN '一般'
            ELSE '不达标'
        END;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '推荐质量评估失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 七、扩展性需求

### 7.1 水平扩展

**水平扩展设计（带错误处理和性能测试）**：

```sql
-- 用户分片表（用于水平扩展）
CREATE TABLE IF NOT EXISTS user_shards (
    user_id BIGINT PRIMARY KEY,
    shard_id INT NOT NULL,
    shard_host TEXT,
    shard_port INT DEFAULT 5432,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 分片路由函数
CREATE OR REPLACE FUNCTION get_user_shard(
    p_user_id BIGINT
)
RETURNS TABLE (
    shard_id INT,
    shard_host TEXT,
    shard_port INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        shard_id,
        shard_host,
        shard_port
    FROM user_shards
    WHERE user_id = p_user_id;

    IF NOT FOUND THEN
        -- 默认分片（哈希分片）
        RETURN QUERY SELECT
            (p_user_id % 4)::INT AS shard_id,
            'localhost'::TEXT AS shard_host,
            5432 AS shard_port;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '获取用户分片失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**返回**: [案例7主页](./README.md)
