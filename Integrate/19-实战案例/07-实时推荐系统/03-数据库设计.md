---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\07-å®æ—¶æ¨èç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

> **âš ï¸ é‡è¦æç¤º**: æœ¬æ–‡æ¡£éµå¾ªæ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿æ ¼å¼ã€‚
>
> **æ¨èé˜…è¯»**:
>
> - [æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿](../æ¡ˆä¾‹æ–‡æ¡£é€šç”¨æ¨¡æ¿.md) - é€šç”¨æ¡ˆä¾‹æ–‡æ¡£æ ¼å¼å’Œæœ€ä½³å®è·µ
>
> æœ¬æ–‡æ¡£ä¿ç•™ä½œä¸ºå®æ—¶æ¨èç³»ç»Ÿçš„æ•°æ®åº“è®¾è®¡å‚è€ƒã€‚

---

# æ¡ˆä¾‹7ï¼šå®æ—¶æ¨èç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

## Schemaè®¾è®¡

```sql
-- 1. ç”¨æˆ·è¡¨
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    age_group INT,
    gender VARCHAR(10),
    city_level INT,
    register_date DATE,
    active_days INT DEFAULT 0,
    purchase_count INT DEFAULT 0,
    avg_price NUMERIC(10,2),
    preference_vector vector(128),  -- pgvector
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_vector ON users USING hnsw (preference_vector vector_l2_ops);

-- 2. å•†å“è¡¨
CREATE TABLE items (
    item_id BIGSERIAL PRIMARY KEY,
    title VARCHAR(500),
    category_id INT,
    brand_id INT,
    price NUMERIC(10,2),
    sales_count INT DEFAULT 0,
    rating NUMERIC(3,2),
    ctr_7d NUMERIC(5,4),
    cvr_7d NUMERIC(5,4),
    embedding vector(128),  -- å•†å“å‘é‡
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_items_category ON items (category_id);
CREATE INDEX idx_items_embedding ON items USING hnsw (embedding vector_l2_ops);
CREATE INDEX idx_items_sales ON items (sales_count DESC);

-- 3. ç”¨æˆ·è¡Œä¸ºè¡¨ï¼ˆåˆ†åŒºï¼‰
CREATE TABLE user_behavior (
    behavior_id BIGSERIAL,
    user_id BIGINT NOT NULL,
    item_id BIGINT NOT NULL,
    behavior_type VARCHAR(20) NOT NULL,  -- view/click/cart/buy
    timestamp TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (behavior_id, timestamp)
) PARTITION BY RANGE (timestamp);

-- åˆ›å»ºåˆ†åŒºï¼ˆæœ€è¿‘30å¤©ï¼‰
DO $$
DECLARE
    partition_date DATE;
BEGIN
    FOR i IN 0..29 LOOP
        partition_date := CURRENT_DATE - i;
        EXECUTE format('
            CREATE TABLE IF NOT EXISTS user_behavior_%s
            PARTITION OF user_behavior
            FOR VALUES FROM (%L) TO (%L);
        ', to_char(partition_date, 'YYYYMMDD'), partition_date, partition_date + 1);

        EXECUTE format('
            CREATE INDEX IF NOT EXISTS idx_behavior_%s_user
            ON user_behavior_%s (user_id, timestamp);
        ', to_char(partition_date, 'YYYYMMDD'), to_char(partition_date, 'YYYYMMDD'));

        EXECUTE format('
            CREATE INDEX IF NOT EXISTS idx_behavior_%s_item
            ON user_behavior_%s (item_id, timestamp);
        ', to_char(partition_date, 'YYYYMMDD'), to_char(partition_date, 'YYYYMMDD'));
    END LOOP;
END $$;

-- 4. ç”¨æˆ·-å•†å“äº¤äº’ç»Ÿè®¡ï¼ˆç‰©åŒ–è§†å›¾ï¼‰
CREATE MATERIALIZED VIEW user_item_stats AS
SELECT
    user_id,
    item_id,
    COUNT(*) FILTER (WHERE behavior_type = 'view') AS view_count,
    COUNT(*) FILTER (WHERE behavior_type = 'click') AS click_count,
    COUNT(*) FILTER (WHERE behavior_type = 'cart') AS cart_count,
    COUNT(*) FILTER (WHERE behavior_type = 'buy') AS buy_count,
    MAX(timestamp) AS last_interaction
FROM user_behavior
WHERE timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
GROUP BY user_id, item_id;

CREATE INDEX idx_user_item_stats_user ON user_item_stats (user_id);
CREATE INDEX idx_user_item_stats_item ON user_item_stats (item_id);

-- å®šæ—¶åˆ·æ–°ï¼ˆæ¯å°æ—¶ï¼‰
CREATE OR REPLACE FUNCTION refresh_user_item_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_item_stats;
END;
$$ LANGUAGE plpgsql;

-- 5. å•†å“ç›¸ä¼¼åº¦è¡¨
CREATE TABLE item_similarity (
    item_id BIGINT NOT NULL,
    similar_item_id BIGINT NOT NULL,
    similarity_score NUMERIC(5,4),
    PRIMARY KEY (item_id, similar_item_id)
);

CREATE INDEX idx_item_similarity_score ON item_similarity (item_id, similarity_score DESC);

-- 6. ç”¨æˆ·ç›¸ä¼¼åº¦è¡¨
CREATE TABLE user_similarity (
    user_id BIGINT NOT NULL,
    similar_user_id BIGINT NOT NULL,
    similarity_score NUMERIC(5,4),
    PRIMARY KEY (user_id, similar_user_id)
);

CREATE INDEX idx_user_similarity_score ON user_similarity (user_id, similarity_score DESC);

-- 7. æ¨èç»“æœç¼“å­˜è¡¨
CREATE TABLE recommendation_cache (
    user_id BIGINT PRIMARY KEY,
    recommended_items BIGINT[],
    scores NUMERIC[],
    generated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMPTZ
);

CREATE INDEX idx_recommendation_expires ON recommendation_cache (expires_at);
```

---

## æ ¸å¿ƒå‡½æ•°

```sql
-- 1. ååŒè¿‡æ»¤æ¨èï¼ˆUser-Basedï¼‰
CREATE OR REPLACE FUNCTION recommend_user_cf(
    p_user_id BIGINT,
    p_limit INT DEFAULT 200
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH similar_users AS (
        SELECT similar_user_id, similarity_score
        FROM user_similarity
        WHERE user_id = p_user_id
        ORDER BY similarity_score DESC
        LIMIT 50
    ),
    similar_user_items AS (
        SELECT
            ub.item_id,
            SUM(su.similarity_score) AS weighted_score
        FROM similar_users su
        JOIN user_behavior ub ON su.similar_user_id = ub.user_id
        WHERE ub.behavior_type IN ('buy', 'cart')
          AND ub.timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
          AND ub.item_id NOT IN (
              SELECT item_id FROM user_behavior
              WHERE user_id = p_user_id AND behavior_type = 'buy'
          )
        GROUP BY ub.item_id
    )
    SELECT sui.item_id, sui.weighted_score
    FROM similar_user_items sui
    ORDER BY weighted_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 2. ååŒè¿‡æ»¤æ¨èï¼ˆItem-Basedï¼‰
CREATE OR REPLACE FUNCTION recommend_item_cf(
    p_user_id BIGINT,
    p_limit INT DEFAULT 200
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH user_history AS (
        SELECT DISTINCT item_id
        FROM user_behavior
        WHERE user_id = p_user_id
          AND behavior_type IN ('buy', 'cart', 'click')
          AND timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
        LIMIT 20
    ),
    similar_items AS (
        SELECT
            isim.similar_item_id AS item_id,
            AVG(isim.similarity_score) AS avg_score
        FROM user_history uh
        JOIN item_similarity isim ON uh.item_id = isim.item_id
        WHERE isim.similar_item_id NOT IN (
            SELECT item_id FROM user_behavior
            WHERE user_id = p_user_id AND behavior_type = 'buy'
        )
        GROUP BY isim.similar_item_id
    )
    SELECT si.item_id, si.avg_score
    FROM similar_items si
    ORDER BY avg_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 3. å‘é‡å¬å›ï¼ˆpgvectorï¼‰
CREATE OR REPLACE FUNCTION recommend_vector(
    p_user_id BIGINT,
    p_limit INT DEFAULT 200
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
DECLARE
    user_vec vector(128);
BEGIN
    -- è·å–ç”¨æˆ·åå¥½å‘é‡
    SELECT preference_vector INTO user_vec
    FROM users WHERE user_id = p_user_id;

    IF user_vec IS NULL THEN
        RETURN;
    END IF;

    RETURN QUERY
    SELECT
        i.item_id,
        1 - (i.embedding <-> user_vec) AS similarity
    FROM items i
    WHERE i.item_id NOT IN (
        SELECT item_id FROM user_behavior
        WHERE user_id = p_user_id AND behavior_type = 'buy'
    )
    ORDER BY i.embedding <-> user_vec
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 4. çƒ­é—¨æ¨è
CREATE OR REPLACE FUNCTION recommend_popular(
    p_category_id INT DEFAULT NULL,
    p_limit INT DEFAULT 100
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        i.item_id,
        (i.sales_count::NUMERIC / 1000.0 + i.ctr_7d * 10) AS popularity_score
    FROM items i
    WHERE (p_category_id IS NULL OR i.category_id = p_category_id)
      AND i.sales_count > 10
    ORDER BY popularity_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 5. ç»¼åˆæ¨èï¼ˆå¤šè·¯å¬å›ï¼‰
CREATE OR REPLACE FUNCTION recommend_items(
    p_user_id BIGINT,
    p_limit INT DEFAULT 50
) RETURNS TABLE (
    item_id BIGINT,
    final_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH all_candidates AS (
        -- è·¯å¾„1: User-Based CF
        SELECT item_id, score * 0.3 AS weighted_score, 'user_cf' AS source
        FROM recommend_user_cf(p_user_id, 200)

        UNION ALL

        -- è·¯å¾„2: Item-Based CF
        SELECT item_id, score * 0.3 AS weighted_score, 'item_cf' AS source
        FROM recommend_item_cf(p_user_id, 200)

        UNION ALL

        -- è·¯å¾„3: å‘é‡å¬å›
        SELECT item_id, score * 0.25 AS weighted_score, 'vector' AS source
        FROM recommend_vector(p_user_id, 200)

        UNION ALL

        -- è·¯å¾„4: çƒ­é—¨æ¨è
        SELECT item_id, score * 0.15 AS weighted_score, 'popular' AS source
        FROM recommend_popular(NULL, 100)
    ),
    merged AS (
        SELECT
            item_id,
            SUM(weighted_score) AS total_score
        FROM all_candidates
        GROUP BY item_id
    )
    SELECT
        m.item_id,
        m.total_score
    FROM merged m
    JOIN items i ON m.item_id = i.item_id
    WHERE i.sales_count > 0  -- è¿‡æ»¤æ— æ•ˆå•†å“
    ORDER BY total_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

**è¿”å›**: [æ¡ˆä¾‹7ä¸»é¡µ](./README.md)
