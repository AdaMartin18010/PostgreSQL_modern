---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\07-å®æ—¶æ¨èç³»ç»Ÿ\02-æ¶æ„è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹7ï¼šå®æ—¶æ¨èç³»ç»Ÿ - æ¶æ„è®¾è®¡

## æ€»ä½“æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å®æ—¶æ¨èç³»ç»Ÿæ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  [ç”¨æˆ·] â†’ [æ¨èAPI] â†’ [å¬å›å±‚] â†’ [æ’åºå±‚] â†’ [è¿”å›]       â”‚
â”‚                           â”‚          â”‚                 â”‚
â”‚                    [PostgreSQL 18]   â”‚                 â”‚
â”‚                      â”œâ”€ ç”¨æˆ·ç”»åƒ     â”‚                  â”‚
â”‚                      â”œâ”€ å•†å“ç‰¹å¾     â”‚                  â”‚
â”‚                      â”œâ”€ è¡Œä¸ºæ•°æ®     â”‚                  â”‚
â”‚                      â””â”€ å‘é‡ç´¢å¼•     â”‚                  â”‚
â”‚                                      â”‚                 â”‚
â”‚                              [Redisç¼“å­˜]               â”‚
â”‚                                â”œâ”€ çƒ­é—¨å•†å“             â”‚
â”‚                                â””â”€ ç”¨æˆ·æœ€è¿‘è¡Œä¸º          â”‚
â”‚                                                        â”‚
â”‚  [è¡Œä¸ºæµ] â†’ [Kafka] â†’ [å®æ—¶å†™å…¥Worker]                  â”‚
â”‚                              â†“                         â”‚
â”‚                       [PostgreSQL]                     â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å¬å›ç­–ç•¥

### å¤šè·¯å¬å›

```sql
-- è·¯å¾„1: ååŒè¿‡æ»¤ï¼ˆUser-Basedï¼‰
ç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„å•†å“ â†’ 200ä¸ªå€™é€‰

-- è·¯å¾„2: ååŒè¿‡æ»¤ï¼ˆItem-Basedï¼‰
ç”¨æˆ·å†å²å•†å“çš„ç›¸ä¼¼å•†å“ â†’ 200ä¸ªå€™é€‰

-- è·¯å¾„3: å‘é‡å¬å›
ç”¨æˆ·åå¥½å‘é‡ Ã— å•†å“å‘é‡ â†’ 200ä¸ªå€™é€‰

-- è·¯å¾„4: çƒ­é—¨æ¨è
å“ç±»Topå•†å“ â†’ 100ä¸ªå€™é€‰

-- è·¯å¾„5: æ–°å“æ¨è
æœ€æ–°ä¸Šæ¶é«˜è´¨é‡å•†å“ â†’ 50ä¸ªå€™é€‰

æ€»å€™é€‰æ± : ~750ä¸ª
```

### å¬å›å»é‡ä¸åˆå¹¶

```sql
-- å»é‡
DISTINCT ON (item_id)

-- åˆå¹¶åˆ†æ•°
score = w1*cf_score + w2*vector_score + w3*popular_score
```

---

## æ’åºæ¨¡å‹

### ç‰¹å¾å·¥ç¨‹

**ç”¨æˆ·ç‰¹å¾** (15ç»´):

```python
[
    user_age_group,      # å¹´é¾„æ®µ
    user_gender,         # æ€§åˆ«
    user_city_level,     # åŸå¸‚ç­‰çº§
    user_active_days,    # æ´»è·ƒå¤©æ•°
    user_purchase_count, # è´­ä¹°æ¬¡æ•°
    user_avg_price,      # å¹³å‡å®¢å•ä»·
    ...
]
```

**å•†å“ç‰¹å¾** (20ç»´):

```python
[
    item_category,       # ç±»ç›®
    item_price,          # ä»·æ ¼
    item_sales,          # é”€é‡
    item_rating,         # è¯„åˆ†
    item_ctr_7d,         # 7æ—¥CTR
    item_cvr_7d,         # 7æ—¥CVR
    ...
]
```

**äº¤å‰ç‰¹å¾** (10ç»´):

```python
[
    user_category_affinity,  # ç”¨æˆ·-å“ç±»äº²å’Œåº¦
    price_match_score,       # ä»·æ ¼åŒ¹é…åº¦
    ...
]
```

### CTRé¢„ä¼°

```python
# é€»è¾‘å›å½’æ¨¡å‹
P(click) = sigmoid(w^T * x)

# å¤šç›®æ ‡
score = Î±*P(click) + Î²*P(buy)
```

---

## æ•°æ®åº“è®¾è®¡è¦ç‚¹

### 1. åˆ†åŒºç­–ç•¥

```sql
-- è¡Œä¸ºè¡¨æŒ‰æ—¶é—´åˆ†åŒºï¼ˆæ—¥åˆ†åŒºï¼‰
CREATE TABLE user_behavior (
    user_id BIGINT,
    item_id BIGINT,
    behavior_type VARCHAR(20),
    timestamp TIMESTAMPTZ
) PARTITION BY RANGE (timestamp);
```

### 2. ç´¢å¼•ç­–ç•¥

```sql
-- ç”¨æˆ·ç»´åº¦æŸ¥è¯¢
CREATE INDEX ON user_behavior (user_id, timestamp);

-- å•†å“ç»´åº¦æŸ¥è¯¢
CREATE INDEX ON user_behavior (item_id, timestamp);

-- å‘é‡ç›¸ä¼¼åº¦ï¼ˆHNSWï¼‰
CREATE INDEX ON items USING hnsw (embedding vector_l2_ops);
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. ç¼“å­˜åˆ†å±‚

```text
L1: Redis (çƒ­é—¨å•†å“, TTL=5min)
L2: PostgreSQL shared_buffers (ç”¨æˆ·ç”»åƒ)
L3: ç£ç›˜
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

```sql
-- å¹¶è¡Œå¤šè·¯å¬å›
WITH RECURSIVE ...
UNION ALL
-- å„è·¯å¬å›ç»“æœåˆå¹¶
```

### 3. æ‰¹å¤„ç†

```python
# æ‰¹é‡ç”¨æˆ·æ¨èï¼ˆå¤œé—´é¢„è®¡ç®—ï¼‰
for user_batch in users:
    precompute_recommendations(user_batch)
    store_to_cache()
```

---

---

## 4. è¯¦ç»†æ¶æ„è®¾è®¡

### 4.1 å¬å›å±‚è®¾è®¡

**å¬å›å±‚è¯¦ç»†è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¬å›å±‚ç»Ÿä¸€æ¥å£
CREATE OR REPLACE FUNCTION recall_candidates(
    p_user_id BIGINT,
    p_recall_paths TEXT[] DEFAULT ARRAY['user_cf', 'item_cf', 'vector', 'popular'],
    p_candidates_per_path INT DEFAULT 200
)
RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC,
    source TEXT
) AS $$
DECLARE
    recall_path TEXT;
BEGIN
    -- å¹¶è¡Œæ‰§è¡Œå¤šè·¯å¬å›
    FOR recall_path IN SELECT unnest(p_recall_paths)
    LOOP
        CASE recall_path
            WHEN 'user_cf' THEN
                RETURN QUERY
                SELECT item_id, score * 0.3, 'user_cf'::TEXT
                FROM recommend_user_cf(p_user_id, p_candidates_per_path);

            WHEN 'item_cf' THEN
                RETURN QUERY
                SELECT item_id, score * 0.3, 'item_cf'::TEXT
                FROM recommend_item_cf(p_user_id, p_candidates_per_path);

            WHEN 'vector' THEN
                RETURN QUERY
                SELECT item_id, score * 0.25, 'vector'::TEXT
                FROM recommend_vector(p_user_id, p_candidates_per_path);

            WHEN 'popular' THEN
                RETURN QUERY
                SELECT item_id, score * 0.15, 'popular'::TEXT
                FROM recommend_popular(NULL, p_candidates_per_path);
        END CASE;
    END LOOP;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å¬å›å€™é€‰å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 æ’åºå±‚è®¾è®¡

**æ’åºå±‚è¯¦ç»†è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ’åºå±‚å‡½æ•°
CREATE OR REPLACE FUNCTION rank_candidates(
    p_user_id BIGINT,
    p_item_ids BIGINT[],
    p_limit INT DEFAULT 50
)
RETURNS TABLE (
    item_id BIGINT,
    final_score NUMERIC,
    ctr_score NUMERIC,
    diversity_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH candidate_features AS (
        SELECT
            i.item_id,
            i.category_id,
            i.price,
            i.rating,
            i.ctr_7d,
            i.cvr_7d,
            u.age_group,
            u.gender,
            u.avg_price AS user_avg_price
        FROM unnest(p_item_ids) AS item_id
        JOIN items i ON i.item_id = item_id
        JOIN users u ON u.user_id = p_user_id
    ),
    scored AS (
        SELECT
            cf.item_id,
            -- CTRé¢„ä¼°åˆ†æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
            (cf.ctr_7d * 0.4 + cf.rating * 0.3 +
             CASE WHEN ABS(cf.price - cf.user_avg_price) < cf.user_avg_price * 0.2 THEN 0.3 ELSE 0 END) AS ctr_score,
            -- å¤šæ ·æ€§åˆ†æ•°ï¼ˆé¿å…åŒç±»å•†å“è¿‡å¤šï¼‰
            (1.0 / (1.0 + COUNT(*) OVER (PARTITION BY cf.category_id))) AS diversity_score
        FROM candidate_features cf
    )
    SELECT
        s.item_id,
        (s.ctr_score * 0.7 + s.diversity_score * 0.3) AS final_score,
        s.ctr_score,
        s.diversity_score
    FROM scored s
    ORDER BY final_score DESC
    LIMIT p_limit;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ’åºå€™é€‰å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 ç¼“å­˜ç­–ç•¥

**ç¼“å­˜ç­–ç•¥å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ¨èç»“æœç¼“å­˜è¡¨
CREATE TABLE IF NOT EXISTS recommendation_cache (
    user_id BIGINT PRIMARY KEY,
    recommended_items BIGINT[],
    scores NUMERIC[],
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

-- ç¼“å­˜ç®¡ç†å‡½æ•°
CREATE OR REPLACE FUNCTION get_or_generate_recommendations(
    p_user_id BIGINT,
    p_limit INT DEFAULT 50,
    p_cache_ttl_minutes INT DEFAULT 5
)
RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC,
    from_cache BOOLEAN
) AS $$
DECLARE
    cached_items BIGINT[];
    cached_scores NUMERIC[];
    cache_expires TIMESTAMPTZ;
BEGIN
    -- æ£€æŸ¥ç¼“å­˜
    SELECT recommended_items, scores, expires_at
    INTO cached_items, cached_scores, cache_expires
    FROM recommendation_cache
    WHERE user_id = p_user_id
      AND expires_at > NOW();

    IF cached_items IS NOT NULL AND array_length(cached_items, 1) > 0 THEN
        -- è¿”å›ç¼“å­˜ç»“æœ
        RETURN QUERY
        SELECT
            unnest(cached_items) AS item_id,
            unnest(cached_scores) AS score,
            TRUE AS from_cache;
        RETURN;
    END IF;

    -- ç”Ÿæˆæ–°æ¨è
    WITH candidates AS (
        SELECT item_id, final_score
        FROM recommend_items(p_user_id, p_limit * 2)
    ),
    ranked AS (
        SELECT item_id, final_score
        FROM rank_candidates(p_user_id, ARRAY(SELECT item_id FROM candidates), p_limit)
    )
    SELECT item_id, final_score INTO cached_items, cached_scores
    FROM ranked;

    -- æ›´æ–°ç¼“å­˜
    INSERT INTO recommendation_cache (
        user_id, recommended_items, scores, expires_at
    )
    VALUES (
        p_user_id,
        cached_items,
        cached_scores,
        NOW() + (p_cache_ttl_minutes || ' minutes')::INTERVAL
    )
    ON CONFLICT (user_id) DO UPDATE
    SET recommended_items = EXCLUDED.recommended_items,
        scores = EXCLUDED.scores,
        generated_at = NOW(),
        expires_at = EXCLUDED.expires_at;

    -- è¿”å›ç»“æœ
    RETURN QUERY
    SELECT
        unnest(cached_items) AS item_id,
        unnest(cached_scores) AS score,
        FALSE AS from_cache;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'è·å–æ¨èå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. å®æ—¶æ›´æ–°æœºåˆ¶

### 5.1 è¡Œä¸ºå®æ—¶å¤„ç†

**è¡Œä¸ºå®æ—¶å¤„ç†å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- è¡Œä¸ºå¤„ç†è§¦å‘å™¨
CREATE OR REPLACE FUNCTION process_user_behavior()
RETURNS TRIGGER AS $$
BEGIN
    -- 1. æ›´æ–°ç”¨æˆ·ç”»åƒï¼ˆå¼‚æ­¥ï¼Œå®é™…åº”è¯¥ç”¨æ¶ˆæ¯é˜Ÿåˆ—ï¼‰
    -- ç®€åŒ–å¤„ç†ï¼šç›´æ¥æ›´æ–°
    UPDATE users
    SET
        active_days = active_days + CASE WHEN NEW.behavior_type = 'buy' THEN 1 ELSE 0 END,
        purchase_count = purchase_count + CASE WHEN NEW.behavior_type = 'buy' THEN 1 ELSE 0 END,
        updated_at = NOW()
    WHERE user_id = NEW.user_id;

    -- 2. æ¸…é™¤ç”¨æˆ·æ¨èç¼“å­˜
    DELETE FROM recommendation_cache
    WHERE user_id = NEW.user_id;

    -- 3. æ›´æ–°å•†å“ç»Ÿè®¡
    UPDATE items
    SET
        sales_count = sales_count + CASE WHEN NEW.behavior_type = 'buy' THEN 1 ELSE 0 END,
        updated_at = NOW()
    WHERE item_id = NEW.item_id;

    RETURN NEW;

EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'å¤„ç†ç”¨æˆ·è¡Œä¸ºå¤±è´¥: %', SQLERRM;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER trg_process_behavior
    AFTER INSERT ON user_behavior
    FOR EACH ROW
    EXECUTE FUNCTION process_user_behavior();
```

---

## 6. ç›‘æ§ä¸è¯Šæ–­

### 6.1 æ¨èæ€§èƒ½ç›‘æ§

**æ¨èæ€§èƒ½ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ¨èæ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_recommendation_performance AS
SELECT
    date_trunc('hour', generated_at) AS hour,
    COUNT(*) AS recommendation_count,
    ROUND(AVG(array_length(recommended_items, 1)), 2) AS avg_items_per_rec,
    COUNT(*) FILTER (WHERE expires_at > NOW()) AS cache_hit_count,
    COUNT(*) FILTER (WHERE expires_at <= NOW()) AS cache_miss_count,
    ROUND(COUNT(*) FILTER (WHERE expires_at > NOW()) * 100.0 / COUNT(*), 2) AS cache_hit_rate
FROM recommendation_cache
WHERE generated_at > NOW() - INTERVAL '24 hours'
GROUP BY date_trunc('hour', generated_at)
ORDER BY hour DESC;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_recommendation_performance;
```

---

**è¿”å›**: [æ¡ˆä¾‹7ä¸»é¡µ](./README.md)
