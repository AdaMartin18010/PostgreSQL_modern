---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\06-å…¨æ–‡æœç´¢ç³»ç»Ÿ\02-æ¶æ„è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹6ï¼šå…¨æ–‡æœç´¢ç³»ç»Ÿ - æ¶æ„è®¾è®¡

## å…ƒæ•°æ®

- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **æŠ€æœ¯**: PostgreSQL 18 + GINç´¢å¼• + tsvector
- **æ–‡æ¡£é‡**: ç™¾ä¸‡çº§

---

## 1. æ€»ä½“æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            å…¨æ–‡æœç´¢ç³»ç»Ÿæ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                       â”‚
â”‚  [ç”¨æˆ·æœç´¢] â†’ [API] â†’ [æœç´¢æœåŠ¡]                    â”‚
â”‚                           â”‚                          â”‚
â”‚                     [PostgreSQL 18]                  â”‚
â”‚                           â”‚                          â”‚
â”‚                    [GINç´¢å¼• + tsvector]              â”‚
â”‚                           â”‚                          â”‚
â”‚                     [æ–‡æ¡£è¡¨]                         â”‚
â”‚                           â”‚                          â”‚
â”‚                    [æ’åºæ¨¡å—]                        â”‚
â”‚                  (ts_rank_cd + BM25)                 â”‚
â”‚                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¸å¿ƒç»„ä»¶

### 2.1 ç´¢å¼•ç­–ç•¥

**GIN vs GiST**:

| ç´¢å¼•ç±»å‹ | æ„å»ºæ—¶é—´ | æŸ¥è¯¢é€Ÿåº¦ | æ›´æ–°æˆæœ¬ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|---------|---------|
| **GIN** | æ…¢ | å¿« | é«˜ | è¯»å¤šå†™å°‘ |
| **GiST** | å¿« | è¾ƒå¿« | ä½ | å†™å¤šè¯»å°‘ |

**é€‰æ‹©**: GINï¼ˆPostgreSQL 18å¹¶è¡Œæ„å»ºä¼˜åŒ–ï¼‰

---

### 2.2 ä¸­æ–‡åˆ†è¯

**æ–¹æ¡ˆå¯¹æ¯”**:

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‰æ‹© |
|------|------|------|------|
| **zhparser** | å¼€æºã€æˆç†Ÿ | éœ€è¦ç¼–è¯‘å®‰è£… | âœ… |
| **jiebaåˆ†è¯** | çµæ´» | éœ€è¦åº”ç”¨å±‚å¤„ç† | âš ï¸ |
| **å†…ç½®simple** | æ— éœ€å®‰è£… | ä¸æ”¯æŒä¸­æ–‡ | âŒ |

---

## 3. æ’åºç®—æ³•

### 3.1 ç›¸å…³æ€§æ’åº

**PostgreSQLå†…ç½®**:

- `ts_rank`: åŸºäºTF-IDF
- `ts_rank_cd`: è€ƒè™‘è¦†ç›–å¯†åº¦

**BM25å®ç°**:

```sql
CREATE FUNCTION bm25_score(
    doc_length INT,
    avg_doc_length FLOAT,
    term_freq INT,
    doc_freq INT,
    total_docs INT
) RETURNS FLOAT AS $$
    -- BM25è®¡ç®—å…¬å¼
$$ LANGUAGE sql IMMUTABLE;
```

---

---

## 4. è¯¦ç»†æ¶æ„ç»„ä»¶

### 4.1 æœç´¢æœåŠ¡å±‚

**æœç´¢æœåŠ¡å±‚è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
"""
æœç´¢æœåŠ¡å±‚
æŠ€æœ¯æ ˆ: FastAPI + PostgreSQL 18
"""

from fastapi import FastAPI, Query
from typing import Optional, List
import psycopg2
from psycopg2.extras import RealDictCursor

app = FastAPI()

class SearchService:
    """æœç´¢æœåŠ¡"""

    def __init__(self, conn_str):
        self.conn = psycopg2.connect(conn_str, cursor_factory=RealDictCursor)
        self.cursor = self.conn.cursor()

    def search(
        self,
        query: str,
        category: Optional[str] = None,
        tags: Optional[List[str]] = None,
        limit: int = 20,
        offset: int = 0
    ):
        """æ‰§è¡Œæœç´¢"""

        # æ„å»ºæŸ¥è¯¢
        search_query = self._build_query(query, category, tags, limit, offset)

        # æ‰§è¡ŒæŸ¥è¯¢
        self.cursor.execute(search_query['sql'], search_query['params'])
        results = self.cursor.fetchall()

        return {
            'query': query,
            'results': results,
            'total': len(results),
            'limit': limit,
            'offset': offset
        }

    def _build_query(self, query, category, tags, limit, offset):
        """æ„å»ºæœç´¢æŸ¥è¯¢"""

        sql = """
            SELECT
                doc_id,
                title,
                ts_headline('zh_parser', content, query,
                           'MaxWords=50, MinWords=30, StartSel=<mark>, StopSel=</mark>') AS snippet,
                ts_rank_cd(search_vector, query, 32) AS rank,
                category,
                tags,
                created_at
            FROM documents,
                 to_tsquery('zh_parser', %s) query
            WHERE search_vector @@ query
        """
        params = [query]

        if category:
            sql += " AND category = %s"
            params.append(category)

        if tags:
            sql += " AND tags && %s"
            params.append(tags)

        sql += " ORDER BY rank DESC, created_at DESC LIMIT %s OFFSET %s"
        params.extend([limit, offset])

        return {'sql': sql, 'params': params}

# APIæ¥å£
search_service = SearchService("dbname=search_db user=postgres")

@app.get("/api/search")
async def search(
    q: str = Query(..., description="æœç´¢å…³é”®è¯"),
    category: Optional[str] = None,
    tags: Optional[str] = None,
    limit: int = 20,
    offset: int = 0
):
    """æœç´¢æ¥å£"""
    tag_list = tags.split(',') if tags else None
    return search_service.search(q, category, tag_list, limit, offset)
```

### 4.2 ç´¢å¼•ç»´æŠ¤

**ç´¢å¼•ç»´æŠ¤å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç´¢å¼•ç»´æŠ¤å‡½æ•°
CREATE OR REPLACE FUNCTION maintain_search_indexes()
RETURNS TABLE (
    index_name TEXT,
    index_size TEXT,
    index_scans BIGINT,
    last_vacuum TIMESTAMPTZ,
    status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        i.indexrelname::TEXT,
        pg_size_pretty(pg_relation_size(i.indexrelid))::TEXT,
        i.idx_scan::BIGINT,
        i.last_vacuum,
        CASE
            WHEN i.idx_scan = 0 THEN 'æœªä½¿ç”¨'
            WHEN pg_relation_size(i.indexrelid) > 1073741824 THEN 'ç´¢å¼•è¿‡å¤§'  -- >1GB
            ELSE 'æ­£å¸¸'
        END AS status
    FROM pg_stat_user_indexes i
    WHERE i.schemaname = 'public'
      AND i.tablename = 'documents'
    ORDER BY pg_relation_size(i.indexrelid) DESC;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ç´¢å¼•ç»´æŠ¤æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œç´¢å¼•ç»´æŠ¤æ£€æŸ¥
SELECT * FROM maintain_search_indexes();
```

---

## 5. æœç´¢è´¨é‡ä¼˜åŒ–

### 5.1 ç›¸å…³æ€§è°ƒä¼˜

**ç›¸å…³æ€§è°ƒä¼˜å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç›¸å…³æ€§è°ƒä¼˜å‡½æ•°
CREATE OR REPLACE FUNCTION optimize_relevance(
    p_query TEXT,
    p_document_id BIGINT
)
RETURNS TABLE (
    optimization_type TEXT,
    before_score NUMERIC,
    after_score NUMERIC,
    improvement_percent NUMERIC
) AS $$
DECLARE
    before_score_val NUMERIC;
    after_score_val NUMERIC;
BEGIN
    -- è®¡ç®—ä¼˜åŒ–å‰åˆ†æ•°
    SELECT ts_rank_cd(search_vector, to_tsquery('zh_parser', p_query), 32)
    INTO before_score_val
    FROM documents
    WHERE doc_id = p_document_id;

    -- ä¼˜åŒ–ï¼šæå‡æ ‡é¢˜æƒé‡
    SELECT ts_rank_cd(
        setweight(to_tsvector('zh_parser', title), 'A') ||
        setweight(to_tsvector('zh_parser', content), 'B'),
        to_tsquery('zh_parser', p_query),
        32
    )
    INTO after_score_val
    FROM documents
    WHERE doc_id = p_document_id;

    RETURN QUERY SELECT
        'æ ‡é¢˜æƒé‡æå‡'::TEXT,
        before_score_val,
        after_score_val,
        ROUND((after_score_val - before_score_val) / NULLIF(before_score_val, 0) * 100, 2);

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ç›¸å…³æ€§ä¼˜åŒ–å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 6.1 æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

**æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–å‡½æ•°
CREATE OR REPLACE FUNCTION optimize_search_query(
    p_query TEXT,
    p_limit INT DEFAULT 20
)
RETURNS TABLE (
    optimization_suggestion TEXT,
    expected_improvement_percent NUMERIC
) AS $$
DECLARE
    query_plan JSONB;
    execution_time_ms NUMERIC;
BEGIN
    -- åˆ†ææŸ¥è¯¢è®¡åˆ’
    EXECUTE format('EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) %s',
        format('SELECT doc_id FROM documents WHERE search_vector @@ to_tsquery(''zh_parser'', %L) LIMIT %s',
               p_query, p_limit)
    ) INTO query_plan;

    -- æå–æ‰§è¡Œæ—¶é—´
    execution_time_ms := (query_plan->0->>'Execution Time')::NUMERIC;

    -- ç”Ÿæˆä¼˜åŒ–å»ºè®®
    IF execution_time_ms > 100 THEN
        RETURN QUERY SELECT
            'è€ƒè™‘ä½¿ç”¨éƒ¨åˆ†ç´¢å¼•æˆ–åˆ†åŒºè¡¨'::TEXT,
            30.0::NUMERIC;
    END IF;

    IF execution_time_ms > 50 THEN
        RETURN QUERY SELECT
            'è€ƒè™‘å¢åŠ work_memæˆ–ä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢'::TEXT,
            20.0::NUMERIC;
    END IF;

    RETURN QUERY SELECT
        'æŸ¥è¯¢æ€§èƒ½è‰¯å¥½'::TEXT,
        0.0::NUMERIC;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–åˆ†æå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–ç­–ç•¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç´¢å¼•ä¼˜åŒ–å»ºè®®å‡½æ•°
CREATE OR REPLACE FUNCTION suggest_index_optimization()
RETURNS TABLE (
    table_name TEXT,
    current_indexes TEXT[],
    suggested_indexes TEXT[],
    optimization_reason TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'documents'::TEXT AS table_name,
        ARRAY[
            'idx_documents_search_vector',
            'idx_documents_category',
            'idx_documents_created_at'
        ] AS current_indexes,
        ARRAY[
            'idx_documents_search_vector_partial (WHERE category IS NOT NULL)',
            'idx_documents_category_created (category, created_at)'
        ] AS suggested_indexes,
        'éƒ¨åˆ†ç´¢å¼•å¯ä»¥å‡å°‘ç´¢å¼•å¤§å°ï¼Œå¤åˆç´¢å¼•å¯ä»¥ä¼˜åŒ–å¤šæ¡ä»¶æŸ¥è¯¢'::TEXT AS optimization_reason;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ç´¢å¼•ä¼˜åŒ–å»ºè®®å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. ç›‘æ§ä¸è¯Šæ–­

### 7.1 æœç´¢æ€§èƒ½ç›‘æ§

**æœç´¢æ€§èƒ½ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æœç´¢æ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_search_performance AS
SELECT
    date_trunc('hour', created_at) AS hour,
    COUNT(*) AS search_count,
    ROUND(AVG(duration_ms), 2) AS avg_duration_ms,
    ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY duration_ms), 2) AS p95_duration_ms,
    ROUND(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY duration_ms), 2) AS p99_duration_ms,
    COUNT(*) FILTER (WHERE result_count = 0) AS zero_result_count,
    ROUND(AVG(result_count), 2) AS avg_result_count
FROM search_logs
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY date_trunc('hour', created_at)
ORDER BY hour DESC;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_search_performance;
```

### 7.2 æœç´¢è´¨é‡ç›‘æ§

**æœç´¢è´¨é‡ç›‘æ§å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æœç´¢è´¨é‡ç›‘æ§å‡½æ•°
CREATE OR REPLACE FUNCTION monitor_search_quality(
    p_hours INT DEFAULT 24
)
RETURNS TABLE (
    metric_name TEXT,
    metric_value NUMERIC,
    target_value NUMERIC,
    status TEXT
) AS $$
BEGIN
    -- å¹³å‡ç»“æœæ•°
    RETURN QUERY
    SELECT
        'å¹³å‡ç»“æœæ•°'::TEXT,
        ROUND(AVG(result_count), 2)::NUMERIC,
        10.0::NUMERIC AS target_value,
        CASE
            WHEN AVG(result_count) >= 10 THEN 'è‰¯å¥½'
            WHEN AVG(result_count) >= 5 THEN 'ä¸€èˆ¬'
            ELSE 'è¾ƒå·®'
        END AS status
    FROM search_logs
    WHERE created_at > NOW() - (p_hours || ' hours')::INTERVAL;

    -- é›¶ç»“æœç‡
    RETURN QUERY
    SELECT
        'é›¶ç»“æœç‡(%)'::TEXT,
        ROUND(COUNT(*) FILTER (WHERE result_count = 0) * 100.0 / COUNT(*), 2)::NUMERIC,
        5.0::NUMERIC AS target_value,
        CASE
            WHEN COUNT(*) FILTER (WHERE result_count = 0) * 100.0 / COUNT(*) <= 5 THEN 'è‰¯å¥½'
            WHEN COUNT(*) FILTER (WHERE result_count = 0) * 100.0 / COUNT(*) <= 10 THEN 'ä¸€èˆ¬'
            ELSE 'è¾ƒå·®'
        END AS status
    FROM search_logs
    WHERE created_at > NOW() - (p_hours || ' hours')::INTERVAL;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æœç´¢è´¨é‡ç›‘æ§å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. æ‰©å±•æ€§è®¾è®¡

### 8.1 åˆ†ç‰‡ç­–ç•¥

**åˆ†ç‰‡ç­–ç•¥è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ–‡æ¡£åˆ†ç‰‡è¡¨ï¼ˆæŒ‰ç±»åˆ«åˆ†ç‰‡ï¼‰
CREATE TABLE IF NOT EXISTS documents_shard_1 (
    LIKE documents INCLUDING ALL
) PARTITION OF documents
FOR VALUES IN ('æŠ€æœ¯', 'å¼€å‘', 'æ•°æ®åº“');

CREATE TABLE IF NOT EXISTS documents_shard_2 (
    LIKE documents INCLUDING ALL
) PARTITION OF documents
FOR VALUES IN ('äº§å“', 'è®¾è®¡', 'è¿è¥');

-- åˆ†ç‰‡æŸ¥è¯¢å‡½æ•°
CREATE OR REPLACE FUNCTION search_sharded(
    p_query TEXT,
    p_categories TEXT[] DEFAULT NULL
)
RETURNS TABLE (
    doc_id BIGINT,
    title TEXT,
    rank REAL
) AS $$
BEGIN
    IF p_categories IS NULL THEN
        -- å…¨é‡æœç´¢
        RETURN QUERY
        SELECT doc_id, title, ts_rank_cd(search_vector, to_tsquery('zh_parser', p_query), 32) AS rank
        FROM documents
        WHERE search_vector @@ to_tsquery('zh_parser', p_query)
        ORDER BY rank DESC
        LIMIT 100;
    ELSE
        -- æŒ‡å®šç±»åˆ«æœç´¢
        RETURN QUERY
        SELECT doc_id, title, ts_rank_cd(search_vector, to_tsquery('zh_parser', p_query), 32) AS rank
        FROM documents
        WHERE search_vector @@ to_tsquery('zh_parser', p_query)
          AND category = ANY(p_categories)
        ORDER BY rank DESC
        LIMIT 100;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ†ç‰‡æœç´¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**å®Œæˆæ—¥æœŸ**: 2025-12-04
**æœç´¢å¼•æ“**: PostgreSQLå…¨æ–‡æœç´¢
**æ€§èƒ½**: msçº§å“åº”

**è¿”å›**: [æ¡ˆä¾‹6ä¸»é¡µ](./README.md)
