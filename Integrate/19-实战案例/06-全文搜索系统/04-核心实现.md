---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\06-å…¨æ–‡æœç´¢ç³»ç»Ÿ\04-æ ¸å¿ƒå®ç°.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹6ï¼šå…¨æ–‡æœç´¢ç³»ç»Ÿ - æ ¸å¿ƒå®ç°

## å…ƒæ•°æ®

- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **æŠ€æœ¯æ ˆ**: PostgreSQL 18 + Python + FastAPI
- **æ€§èƒ½**: msçº§æœç´¢å“åº”

---

## 1. æœç´¢å¼•æ“æ¨¡å—

```python
"""
å…¨æ–‡æœç´¢å¼•æ“
"""

import psycopg2
from psycopg2.extras import RealDictCursor
from fastapi import FastAPI, Query
import time

app = FastAPI()

DB_CONFIG = {
    'dbname': 'search_db',
    'user': 'postgres',
    'host': 'localhost'
}

def get_connection():
    return psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)

@app.get("/api/search")
async def search(
    q: str = Query(..., description="æœç´¢å…³é”®è¯"),
    category: str = Query(None, description="åˆ†ç±»è¿‡æ»¤"),
    limit: int = Query(20, le=100),
    offset: int = Query(0, ge=0)
):
    """
    å…¨æ–‡æœç´¢API

    æ”¯æŒ:
    - ä¸­æ–‡åˆ†è¯
    - ç›¸å…³æ€§æ’åº
    - é«˜äº®æ˜¾ç¤º
    - åˆ†ç±»è¿‡æ»¤
    """

    start_time = time.time()

    conn = get_connection()
    cursor = conn.cursor()

    try:
        # æ„å»ºæŸ¥è¯¢
        if category:
            query = """
                SELECT
                    doc_id,
                    title,
                    ts_headline('zh_parser', content, query,
                        'MaxWords=50, MinWords=30, StartSel=<b>, StopSel=</b>') AS snippet,
                    ts_rank_cd(search_vector, query) AS rank
                FROM documents,
                     to_tsquery('zh_parser', %s) query
                WHERE search_vector @@ query
                  AND category = %s
                ORDER BY rank DESC, created_at DESC
                LIMIT %s OFFSET %s;
            """
            cursor.execute(query, (q, category, limit, offset))
        else:
            query = """
                SELECT
                    doc_id,
                    title,
                    ts_headline('zh_parser', content, query,
                        'MaxWords=50, MinWords=30, StartSel=<b>, StopSel=</b>') AS snippet,
                    ts_rank_cd(search_vector, query) AS rank
                FROM documents,
                     to_tsquery('zh_parser', %s) query
                WHERE search_vector @@ query
                ORDER BY rank DESC, created_at DESC
                LIMIT %s OFFSET %s;
            """
            cursor.execute(query, (q, limit, offset))

        results = cursor.fetchall()
        duration = (time.time() - start_time) * 1000

        # è®°å½•æœç´¢æ—¥å¿—
        cursor.execute("""
            INSERT INTO search_logs (query_text, result_count, duration_ms)
            VALUES (%s, %s, %s);
        """, (q, len(results), duration))
        conn.commit()

        return {
            'success': True,
            'results': results,
            'count': len(results),
            'duration_ms': duration
        }

    finally:
        cursor.close()
        conn.close()

@app.get("/api/search/suggest")
async def search_suggest(q: str = Query(..., min_length=2)):
    """æœç´¢å»ºè®®"""

    conn = get_connection()
    cursor = conn.cursor()

    try:
        # åŸºäºå†å²æœç´¢çš„å»ºè®®
        cursor.execute("""
            SELECT DISTINCT query_text, COUNT(*) as freq
            FROM search_logs
            WHERE query_text LIKE %s
            GROUP BY query_text
            ORDER BY freq DESC
            LIMIT 10;
        """, (f'{q}%',))

        suggestions = cursor.fetchall()

        return {
            'success': True,
            'suggestions': [s['query_text'] for s in suggestions]
        }

    finally:
        cursor.close()
        conn.close()

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8002)
```

---

## 2. ç´¢å¼•ç®¡ç†æ¨¡å—

```python
class SearchIndexManager:
    """æœç´¢ç´¢å¼•ç®¡ç†å™¨"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def rebuild_search_index(self):
        """é‡å»ºæœç´¢ç´¢å¼•"""

        # 1. åˆ é™¤æ—§ç´¢å¼•
        self.cursor.execute("DROP INDEX IF EXISTS idx_documents_search;")

        # 2. é‡æ–°åˆ›å»ºï¼ˆPostgreSQL 18å¹¶è¡Œæ„å»ºï¼‰
        self.cursor.execute("""
            CREATE INDEX idx_documents_search
            ON documents
            USING GIN (search_vector);
        """)

        self.conn.commit()
        print("âœ… æœç´¢ç´¢å¼•é‡å»ºå®Œæˆ")

    def get_index_stats(self):
        """è·å–ç´¢å¼•ç»Ÿè®¡"""

        self.cursor.execute("""
            SELECT
                pg_size_pretty(pg_relation_size('idx_documents_search')) AS index_size,
                pg_stat_get_numscans('idx_documents_search'::regclass) AS scan_count
        """)

        return self.cursor.fetchone()
```

---

---

## 3. é«˜çº§æœç´¢åŠŸèƒ½

### 3.1 å¤šå­—æ®µæœç´¢

**å¤šå­—æ®µæœç´¢å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
@app.get("/api/search/multi-field")
async def multi_field_search(
    q: str = Query(..., description="æœç´¢å…³é”®è¯"),
    fields: str = Query("title,content", description="æœç´¢å­—æ®µï¼Œé€—å·åˆ†éš”"),
    limit: int = Query(20, le=100)
):
    """å¤šå­—æ®µæœç´¢"""

    start_time = time.time()
    conn = get_connection()
    cursor = conn.cursor()

    try:
        # è§£æå­—æ®µåˆ—è¡¨
        field_list = [f.strip() for f in fields.split(',')]

        # æ„å»ºå¤šå­—æ®µtsvector
        tsvector_expr = " || ".join([
            f"setweight(to_tsvector('zh_parser', COALESCE({field}, '')), 'A')"
            if field == 'title' else
            f"setweight(to_tsvector('zh_parser', COALESCE({field}, '')), 'B')"
            for field in field_list
        ])

        query = f"""
            SELECT
                doc_id,
                title,
                ts_headline('zh_parser', content, query,
                    'MaxWords=50, MinWords=30, StartSel=<mark>, StopSel=</mark>') AS snippet,
                ts_rank_cd(({tsvector_expr}), query) AS rank
            FROM documents,
                 to_tsquery('zh_parser', %s) query
            WHERE ({tsvector_expr}) @@ query
            ORDER BY rank DESC, created_at DESC
            LIMIT %s;
        """

        cursor.execute(query, (q, limit))
        results = cursor.fetchall()
        duration = (time.time() - start_time) * 1000

        return {
            'success': True,
            'results': results,
            'count': len(results),
            'duration_ms': duration
        }

    finally:
        cursor.close()
        conn.close()
```

### 3.2 æ¨¡ç³Šæœç´¢

**æ¨¡ç³Šæœç´¢å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
@app.get("/api/search/fuzzy")
async def fuzzy_search(
    q: str = Query(..., description="æœç´¢å…³é”®è¯"),
    similarity_threshold: float = Query(0.7, ge=0.0, le=1.0),
    limit: int = Query(20, le=100)
):
    """æ¨¡ç³Šæœç´¢ï¼ˆä½¿ç”¨pg_trgmï¼‰"""

    start_time = time.time()
    conn = get_connection()
    cursor = conn.cursor()

    try:
        # ç¡®ä¿pg_trgmæ‰©å±•å·²å®‰è£…
        cursor.execute("CREATE EXTENSION IF NOT EXISTS pg_trgm;")

        query = """
            SELECT
                doc_id,
                title,
                content,
                similarity(title, %s) AS title_sim,
                similarity(content, %s) AS content_sim,
                GREATEST(similarity(title, %s), similarity(content, %s)) AS max_sim
            FROM documents
            WHERE similarity(title, %s) > %s
               OR similarity(content, %s) > %s
            ORDER BY max_sim DESC
            LIMIT %s;
        """

        cursor.execute(query, (q, q, q, q, q, similarity_threshold, q, similarity_threshold, limit))
        results = cursor.fetchall()
        duration = (time.time() - start_time) * 1000

        return {
            'success': True,
            'results': results,
            'count': len(results),
            'duration_ms': duration
        }

    finally:
        cursor.close()
        conn.close()
```

---

## 4. æœç´¢æ—¥å¿—åˆ†æ

### 4.1 æœç´¢æ—¥å¿—ç»Ÿè®¡

**æœç´¢æ—¥å¿—ç»Ÿè®¡å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æœç´¢æ—¥å¿—ç»Ÿè®¡å‡½æ•°
CREATE OR REPLACE FUNCTION get_search_statistics(
    p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '7 days',
    p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
    metric_name TEXT,
    metric_value NUMERIC,
    description TEXT
) AS $$
BEGIN
    -- æ€»æœç´¢æ¬¡æ•°
    RETURN QUERY SELECT
        'æ€»æœç´¢æ¬¡æ•°'::TEXT,
        COUNT(*)::NUMERIC,
        'æ—¶é—´æ®µå†…çš„æ€»æœç´¢æ¬¡æ•°'::TEXT
    FROM search_logs
    WHERE created_at BETWEEN p_start_date AND p_end_date;

    -- å¹³å‡ç»“æœæ•°
    RETURN QUERY SELECT
        'å¹³å‡ç»“æœæ•°'::TEXT,
        ROUND(AVG(result_count), 2)::NUMERIC,
        'å¹³å‡æ¯æ¬¡æœç´¢è¿”å›çš„ç»“æœæ•°'::TEXT
    FROM search_logs
    WHERE created_at BETWEEN p_start_date AND p_end_date;

    -- å¹³å‡å“åº”æ—¶é—´
    RETURN QUERY SELECT
        'å¹³å‡å“åº”æ—¶é—´(ms)'::TEXT,
        ROUND(AVG(duration_ms), 2)::NUMERIC,
        'å¹³å‡æœç´¢å“åº”æ—¶é—´'::TEXT
    FROM search_logs
    WHERE created_at BETWEEN p_start_date AND p_end_date;

    -- é›¶ç»“æœç‡
    RETURN QUERY SELECT
        'é›¶ç»“æœç‡(%)'::TEXT,
        ROUND(COUNT(*) FILTER (WHERE result_count = 0) * 100.0 / COUNT(*), 2)::NUMERIC,
        'æ²¡æœ‰è¿”å›ç»“æœçš„æœç´¢å æ¯”'::TEXT
    FROM search_logs
    WHERE created_at BETWEEN p_start_date AND p_end_date;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æœç´¢ç»Ÿè®¡å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 çƒ­é—¨æœç´¢è¯

**çƒ­é—¨æœç´¢è¯æŸ¥è¯¢å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- çƒ­é—¨æœç´¢è¯å‡½æ•°
CREATE OR REPLACE FUNCTION get_popular_search_terms(
    p_limit INT DEFAULT 20,
    p_days INT DEFAULT 7
)
RETURNS TABLE (
    query_text TEXT,
    search_count BIGINT,
    avg_result_count NUMERIC,
    avg_duration_ms NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        query_text,
        COUNT(*)::BIGINT AS search_count,
        ROUND(AVG(result_count), 2) AS avg_result_count,
        ROUND(AVG(duration_ms), 2) AS avg_duration_ms
    FROM search_logs
    WHERE created_at > NOW() - (p_days || ' days')::INTERVAL
    GROUP BY query_text
    ORDER BY search_count DESC
    LIMIT p_limit;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'è·å–çƒ­é—¨æœç´¢è¯å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. ç´¢å¼•ç»´æŠ¤è‡ªåŠ¨åŒ–

### 5.1 è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤

**è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
class AutoIndexMaintenance:
    """è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def check_index_health(self):
        """æ£€æŸ¥ç´¢å¼•å¥åº·çŠ¶æ€"""

        self.cursor.execute("""
            SELECT
                schemaname,
                tablename,
                indexname,
                pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
                idx_scan AS scan_count,
                idx_tup_read AS tuples_read,
                idx_tup_fetch AS tuples_fetched,
                CASE
                    WHEN idx_scan = 0 THEN 'æœªä½¿ç”¨'
                    WHEN pg_relation_size(indexrelid) > 1073741824 THEN 'ç´¢å¼•è¿‡å¤§'
                    ELSE 'æ­£å¸¸'
                END AS health_status
            FROM pg_stat_user_indexes
            WHERE schemaname = 'public'
              AND tablename = 'documents'
            ORDER BY pg_relation_size(indexrelid) DESC;
        """)

        return self.cursor.fetchall()

    def rebuild_index_if_needed(self, index_name, min_bloat_percent=20):
        """å¦‚æœéœ€è¦åˆ™é‡å»ºç´¢å¼•"""

        # æ£€æŸ¥ç´¢å¼•è†¨èƒ€ç‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
        self.cursor.execute("""
            SELECT pg_size_pretty(pg_relation_size(%s::regclass)) AS index_size
        """, (index_name,))

        index_size = self.cursor.fetchone()[0]

        # å¦‚æœç´¢å¼•è¿‡å¤§ï¼Œé‡å»º
        if self._should_rebuild_index(index_name):
            print(f"é‡å»ºç´¢å¼•: {index_name}")
            self.cursor.execute(f"REINDEX INDEX CONCURRENTLY {index_name};")
            self.conn.commit()
            print(f"âœ… ç´¢å¼•é‡å»ºå®Œæˆ: {index_name}")

    def _should_rebuild_index(self, index_name):
        """åˆ¤æ–­æ˜¯å¦éœ€è¦é‡å»ºç´¢å¼•ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        # å®é™…åº”è¯¥æ£€æŸ¥è†¨èƒ€ç‡ç­‰æŒ‡æ ‡
        return False
```

---

**å®Œæˆæ—¥æœŸ**: 2025-12-04
**æœç´¢å¼•æ“**: PostgreSQLå†…ç½®
**å“åº”æ—¶é—´**: <100ms

**è¿”å›**: [æ¡ˆä¾‹6ä¸»é¡µ](./README.md)
