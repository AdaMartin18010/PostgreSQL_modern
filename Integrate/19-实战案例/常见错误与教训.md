# PostgreSQL常见错误与教训

> **创建日期**: 2025年1月
> **适用场景**: 故障预防、经验总结
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL常见错误与教训](#postgresql常见错误与教训)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 错误分类](#11-错误分类)
    - [1.2 学习价值](#12-学习价值)
  - [2. 配置错误](#2-配置错误)
    - [2.1 内存配置错误](#21-内存配置错误)
      - [错误案例1：shared\_buffers过大](#错误案例1shared_buffers过大)
      - [错误案例2：work\_mem过大](#错误案例2work_mem过大)
  - [3. 查询错误](#3-查询错误)
    - [3.1 缺少索引](#31-缺少索引)
      - [错误案例：全表扫描](#错误案例全表扫描)
    - [3.2 索引过多](#32-索引过多)
      - [错误案例：过度索引](#错误案例过度索引)
  - [4. 索引错误](#4-索引错误)
    - [4.1 索引顺序错误](#41-索引顺序错误)
      - [错误案例：复合索引顺序不当](#错误案例复合索引顺序不当)
    - [4.2 未使用索引](#42-未使用索引)
      - [错误案例：创建了但未使用](#错误案例创建了但未使用)
  - [5. 并发错误](#5-并发错误)
    - [5.1 死锁](#51-死锁)
      - [错误案例：事务顺序不一致](#错误案例事务顺序不一致)
    - [5.2 锁等待超时](#52-锁等待超时)
      - [错误案例：长时间事务](#错误案例长时间事务)
  - [6. 备份恢复错误](#6-备份恢复错误)
    - [6.1 备份失败](#61-备份失败)
      - [错误案例：磁盘空间不足](#错误案例磁盘空间不足)
    - [6.2 恢复失败](#62-恢复失败)
      - [错误案例：版本不兼容](#错误案例版本不兼容)
  - [7. 经验教训总结](#7-经验教训总结)
    - [7.1 配置最佳实践](#71-配置最佳实践)
    - [7.2 查询最佳实践](#72-查询最佳实践)
    - [7.3 并发最佳实践](#73-并发最佳实践)
    - [7.4 备份恢复最佳实践](#74-备份恢复最佳实践)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 错误分类

PostgreSQL常见错误包括：

- ✅ **配置错误**: 参数配置不当
- ✅ **查询错误**: 查询性能问题
- ✅ **索引错误**: 索引设计不当
- ✅ **并发错误**: 并发控制问题
- ✅ **备份恢复错误**: 备份恢复失败

### 1.2 学习价值

- **预防错误**: 了解常见错误，提前预防
- **快速诊断**: 快速识别和解决错误
- **经验积累**: 积累实战经验
- **最佳实践**: 形成最佳实践

---

## 2. 配置错误

### 2.1 内存配置错误

#### 错误案例1：shared_buffers过大

**错误配置**:

```ini
shared_buffers = 8GB  # 系统内存16GB
```

**问题**:

- 导致系统内存不足
- 影响操作系统缓存
- 性能反而下降

**正确配置**:

```ini
shared_buffers = 4GB  # 25%系统内存
effective_cache_size = 12GB  # 75%系统内存
```

**教训**: shared_buffers不应超过系统内存的25%

#### 错误案例2：work_mem过大

**错误配置**:

```ini
work_mem = 1GB
max_connections = 100
```

**问题**:

- 100个连接 × 1GB = 100GB内存需求
- 远超系统内存
- 导致OOM

**正确配置**:

```ini
work_mem = 64MB
max_connections = 100
# 总内存需求: 100 × 64MB = 6.4GB
```

**教训**: work_mem需要考虑max_connections

---

## 3. 查询错误

### 3.1 缺少索引

#### 错误案例：全表扫描

**错误查询**:

```sql
-- 错误查询：没有索引，全表扫描（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'user@example.com' LIMIT 10;
-- 注意：没有索引，全表扫描
```

**问题**:

- 查询时间：10秒（1000万行）
- CPU使用率：100%
- 阻塞其他查询

**解决方案**:

```sql
-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
                CREATE INDEX idx_users_email ON users(email);
                RAISE NOTICE '索引 idx_users_email 创建成功（查询时间：10ms）';
            ELSE
                RAISE NOTICE '索引 idx_users_email 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 users 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'user@example.com' LIMIT 10;
```

**教训**: 经常查询的列必须建立索引

### 3.2 索引过多

#### 错误案例：过度索引

**错误设计**:

```sql
-- 错误设计：过度索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            -- 注意：这是错误示例，实际只需要2个索引
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_name') THEN
                CREATE INDEX idx_users_name ON users(name);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
                CREATE INDEX idx_users_email ON users(email);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_phone') THEN
                CREATE INDEX idx_users_phone ON users(phone);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_name_email') THEN
                CREATE INDEX idx_users_name_email ON users(name, email);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email_phone') THEN
                CREATE INDEX idx_users_email_phone ON users(email, phone);
            END IF;
            RAISE NOTICE '5个索引创建完成（但实际只需要2个）';
        ELSE
            RAISE NOTICE '表 users 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**问题**:

- 插入性能下降50%
- 存储空间增加
- 维护成本高

**正确设计**:

```sql
-- 正确设计：合理的索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
                CREATE INDEX idx_users_email ON users(email);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_name_email') THEN
                CREATE INDEX idx_users_name_email ON users(name, email);
            END IF;
            RAISE NOTICE '2个索引创建完成（足够使用）';
        ELSE
            RAISE NOTICE '表 users 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**教训**: 索引不是越多越好，需要平衡查询和写入性能

---

## 4. 索引错误

### 4.1 索引顺序错误

#### 错误案例：复合索引顺序不当

**错误索引**:

```sql
-- 错误索引：复合索引顺序不当（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_status_date') THEN
                CREATE INDEX idx_orders_status_date ON orders(status, created_at);
                RAISE NOTICE '索引创建成功（但顺序不当）';
            ELSE
                RAISE NOTICE '索引 idx_orders_status_date 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 注意：查询 WHERE created_at > '2025-01-01' 时索引无法使用
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders WHERE created_at > '2025-01-01' LIMIT 10;
```

**正确索引**:

```sql
-- 正确索引：合理的索引顺序（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_date_status') THEN
                CREATE INDEX idx_orders_date_status ON orders(created_at, status);
                RAISE NOTICE '索引 idx_orders_date_status 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_orders_date_status 已存在';
            END IF;

            -- 或者创建单列索引
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_date') THEN
                CREATE INDEX idx_orders_date ON orders(created_at);
                RAISE NOTICE '索引 idx_orders_date 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_orders_date 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders WHERE created_at > '2025-01-01' LIMIT 10;
```

**教训**: 复合索引顺序很重要，应该把等值查询的列放在前面

### 4.2 未使用索引

#### 错误案例：创建了但未使用

**问题**:

```sql
-- 错误索引：创建了但未使用（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_name') THEN
                CREATE INDEX idx_users_name ON users(name);
                RAISE NOTICE '索引 idx_users_name 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_users_name 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 users 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 注意：查询使用 WHERE LOWER(name) = 'john' 时索引无法使用（函数调用）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE LOWER(name) = 'john' LIMIT 10;
```

**解决方案**:

```sql
-- 正确索引：表达式索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_name_lower') THEN
                CREATE INDEX idx_users_name_lower ON users(LOWER(name));
                RAISE NOTICE '表达式索引 idx_users_name_lower 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_users_name_lower 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 users 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE LOWER(name) = 'john' LIMIT 10;
```

**教训**: 索引列不能有函数调用，需要使用表达式索引

---

## 5. 并发错误

### 5.1 死锁

#### 错误案例：事务顺序不一致

**事务1**:

```sql
-- 事务1（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'accounts') THEN
            BEGIN;
            UPDATE accounts SET balance = balance - 100 WHERE id = 1;
            UPDATE accounts SET balance = balance + 100 WHERE id = 2;
            COMMIT;
            RAISE NOTICE '事务1执行成功';
        ELSE
            RAISE NOTICE '表 accounts 不存在，跳过事务执行';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '事务1执行失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**事务2**:

```sql
-- 事务2（带错误处理）- 注意：顺序不一致可能导致死锁
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'accounts') THEN
            BEGIN;
            UPDATE accounts SET balance = balance + 100 WHERE id = 2;
            UPDATE accounts SET balance = balance - 100 WHERE id = 1;
            COMMIT;
            RAISE NOTICE '事务2执行成功';
        ELSE
            RAISE NOTICE '表 accounts 不存在，跳过事务执行';
        END IF;
    EXCEPTION
        WHEN deadlock_detected THEN
            ROLLBACK;
            RAISE WARNING '检测到死锁，事务已回滚';
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '事务2执行失败: %', SQLERRM;
            RAISE;
    END;
END $$;
-- 注意：顺序不一致可能导致死锁！
```

**解决方案**:

```sql
-- 统一事务顺序（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'accounts') THEN
            BEGIN;
            UPDATE accounts SET balance = balance - 100 WHERE id = 1;
            UPDATE accounts SET balance = balance + 100 WHERE id = 2;
            COMMIT;
            RAISE NOTICE '统一顺序事务执行成功';
        ELSE
            RAISE NOTICE '表 accounts 不存在，跳过事务执行';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '事务执行失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**教训**: 多个事务访问相同资源时，必须保持一致的顺序

### 5.2 锁等待超时

#### 错误案例：长时间事务

**错误**:

```sql
-- 长时间事务（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'large_table') THEN
            BEGIN;
            -- 注意：长时间查询会持有锁，阻塞其他事务
            PERFORM * FROM large_table LIMIT 1000;
            COMMIT;
            RAISE NOTICE '长时间查询完成';
        ELSE
            RAISE NOTICE '表 large_table 不存在，跳过查询';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '查询失败: %', SQLERRM;
            RAISE;
    END;
END $$;
-- 注意：其他事务可能等待锁
```

**解决方案**:

```sql
-- 使用READ COMMITTED隔离级别（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'large_table') THEN
            BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
            PERFORM * FROM large_table LIMIT 1000;
            COMMIT;
            RAISE NOTICE 'READ COMMITTED隔离级别查询完成';
        ELSE
            RAISE NOTICE '表 large_table 不存在，跳过查询';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '查询失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**教训**: 长时间事务应该使用较低的隔离级别

---

## 6. 备份恢复错误

### 6.1 备份失败

#### 错误案例：磁盘空间不足

**错误**:

```bash
pg_dump mydb > backup.sql
# 错误: 磁盘空间不足
```

**解决方案**:

```bash
# 检查磁盘空间
df -h

# 使用压缩备份
pg_dump -Fc mydb > backup.dump

# 或直接备份到远程
pg_dump mydb | gzip | ssh user@remote "cat > backup.sql.gz"
```

**教训**: 备份前必须检查磁盘空间

### 6.2 恢复失败

#### 错误案例：版本不兼容

**错误**:

```bash
# PostgreSQL 18备份
pg_dump -Fc mydb > backup.dump

# 在PostgreSQL 16恢复
pg_restore -d mydb backup.dump
# 错误: 版本不兼容
```

**解决方案**:

```bash
# 使用兼容格式
pg_dump --format=plain mydb > backup.sql

# 或升级PostgreSQL版本
```

**教训**: 备份恢复需要考虑版本兼容性

---

## 7. 经验教训总结

### 7.1 配置最佳实践

- ✅ **内存配置**: shared_buffers = 25% RAM, work_mem考虑连接数
- ✅ **连接配置**: 使用连接池，限制max_connections
- ✅ **WAL配置**: 合理设置WAL大小和归档
- ✅ **检查点配置**: 平衡性能和恢复时间

### 7.2 查询最佳实践

- ✅ **索引优化**: 为经常查询的列创建索引
- ✅ **查询优化**: 使用EXPLAIN ANALYZE分析查询
- ✅ **批量操作**: 使用批量操作提高性能
- ✅ **避免全表扫描**: 确保WHERE条件有索引

### 7.3 并发最佳实践

- ✅ **事务顺序**: 多个事务访问相同资源时保持顺序一致
- ✅ **隔离级别**: 根据需求选择合适的隔离级别
- ✅ **锁超时**: 设置合理的锁超时时间
- ✅ **死锁检测**: 启用死锁检测和自动回滚

### 7.4 备份恢复最佳实践

- ✅ **定期备份**: 建立定期备份机制
- ✅ **测试恢复**: 定期测试备份恢复
- ✅ **版本兼容**: 考虑版本兼容性
- ✅ **多重备份**: 使用多种备份方式

---

## 📚 相关文档

- [20-故障诊断案例](../20-故障诊断案例/README.md) - 故障诊断案例
- [21-最佳实践/故障排查](../21-最佳实践/故障排查/) - 故障排查方法
- [12-监控与诊断](../12-监控与诊断/README.md) - 监控和诊断

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
