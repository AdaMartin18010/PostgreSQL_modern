# PostgreSQL常见错误与教训

> **创建日期**: 2025年1月
> **适用场景**: 故障预防、经验总结
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL常见错误与教训](#postgresql常见错误与教训)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 错误分类](#11-错误分类)
    - [1.2 学习价值](#12-学习价值)
  - [2. 配置错误](#2-配置错误)
    - [2.1 内存配置错误](#21-内存配置错误)
      - [错误案例1：shared\_buffers过大](#错误案例1shared_buffers过大)
      - [错误案例2：work\_mem过大](#错误案例2work_mem过大)
  - [3. 查询错误](#3-查询错误)
    - [3.1 缺少索引](#31-缺少索引)
      - [错误案例：全表扫描](#错误案例全表扫描)
    - [3.2 索引过多](#32-索引过多)
      - [错误案例：过度索引](#错误案例过度索引)
  - [4. 索引错误](#4-索引错误)
    - [4.1 索引顺序错误](#41-索引顺序错误)
      - [错误案例：复合索引顺序不当](#错误案例复合索引顺序不当)
    - [4.2 未使用索引](#42-未使用索引)
      - [错误案例：创建了但未使用](#错误案例创建了但未使用)
  - [5. 并发错误](#5-并发错误)
    - [5.1 死锁](#51-死锁)
      - [错误案例：事务顺序不一致](#错误案例事务顺序不一致)
    - [5.2 锁等待超时](#52-锁等待超时)
      - [错误案例：长时间事务](#错误案例长时间事务)
  - [6. 备份恢复错误](#6-备份恢复错误)
    - [6.1 备份失败](#61-备份失败)
      - [错误案例：磁盘空间不足](#错误案例磁盘空间不足)
    - [6.2 恢复失败](#62-恢复失败)
      - [错误案例：版本不兼容](#错误案例版本不兼容)
  - [7. 经验教训总结](#7-经验教训总结)
    - [7.1 配置最佳实践](#71-配置最佳实践)
    - [7.2 查询最佳实践](#72-查询最佳实践)
    - [7.3 并发最佳实践](#73-并发最佳实践)
    - [7.4 备份恢复最佳实践](#74-备份恢复最佳实践)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 错误分类

PostgreSQL常见错误包括：

- ✅ **配置错误**: 参数配置不当
- ✅ **查询错误**: 查询性能问题
- ✅ **索引错误**: 索引设计不当
- ✅ **并发错误**: 并发控制问题
- ✅ **备份恢复错误**: 备份恢复失败

### 1.2 学习价值

- **预防错误**: 了解常见错误，提前预防
- **快速诊断**: 快速识别和解决错误
- **经验积累**: 积累实战经验
- **最佳实践**: 形成最佳实践

---

## 2. 配置错误

### 2.1 内存配置错误

#### 错误案例1：shared_buffers过大

**错误配置**:

```ini
shared_buffers = 8GB  # 系统内存16GB
```

**问题**:

- 导致系统内存不足
- 影响操作系统缓存
- 性能反而下降

**正确配置**:

```ini
shared_buffers = 4GB  # 25%系统内存
effective_cache_size = 12GB  # 75%系统内存
```

**教训**: shared_buffers不应超过系统内存的25%

#### 错误案例2：work_mem过大

**错误配置**:

```ini
work_mem = 1GB
max_connections = 100
```

**问题**:

- 100个连接 × 1GB = 100GB内存需求
- 远超系统内存
- 导致OOM

**正确配置**:

```ini
work_mem = 64MB
max_connections = 100
# 总内存需求: 100 × 64MB = 6.4GB
```

**教训**: work_mem需要考虑max_connections

---

## 3. 查询错误

### 3.1 缺少索引

#### 错误案例：全表扫描

**错误查询**:

```sql
SELECT * FROM users WHERE email = 'user@example.com';
-- 没有索引，全表扫描
```

**问题**:

- 查询时间：10秒（1000万行）
- CPU使用率：100%
- 阻塞其他查询

**解决方案**:

```sql
CREATE INDEX idx_users_email ON users(email);
-- 查询时间：10ms
```

**教训**: 经常查询的列必须建立索引

### 3.2 索引过多

#### 错误案例：过度索引

**错误设计**:

```sql
CREATE INDEX idx_users_name ON users(name);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_name_email ON users(name, email);
CREATE INDEX idx_users_email_phone ON users(email, phone);
-- 5个索引，但实际只需要2个
```

**问题**:

- 插入性能下降50%
- 存储空间增加
- 维护成本高

**正确设计**:

```sql
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_name_email ON users(name, email);
-- 2个索引足够
```

**教训**: 索引不是越多越好，需要平衡查询和写入性能

---

## 4. 索引错误

### 4.1 索引顺序错误

#### 错误案例：复合索引顺序不当

**错误索引**:

```sql
CREATE INDEX idx_orders_status_date ON orders(status, created_at);
-- 查询: WHERE created_at > '2025-01-01'
-- 索引无法使用
```

**正确索引**:

```sql
CREATE INDEX idx_orders_date_status ON orders(created_at, status);
-- 或
CREATE INDEX idx_orders_date ON orders(created_at);
```

**教训**: 复合索引顺序很重要，应该把等值查询的列放在前面

### 4.2 未使用索引

#### 错误案例：创建了但未使用

**问题**:

```sql
CREATE INDEX idx_users_name ON users(name);
-- 但查询使用: WHERE LOWER(name) = 'john'
-- 索引无法使用（函数调用）
```

**解决方案**:

```sql
CREATE INDEX idx_users_name_lower ON users(LOWER(name));
-- 或使用表达式索引
```

**教训**: 索引列不能有函数调用，需要使用表达式索引

---

## 5. 并发错误

### 5.1 死锁

#### 错误案例：事务顺序不一致

**事务1**:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

**事务2**:

```sql
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
-- 死锁！
```

**解决方案**:

```sql
-- 统一事务顺序
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

**教训**: 多个事务访问相同资源时，必须保持一致的顺序

### 5.2 锁等待超时

#### 错误案例：长时间事务

**错误**:

```sql
BEGIN;
SELECT * FROM large_table;  -- 长时间查询
-- 其他事务等待锁
COMMIT;
```

**解决方案**:

```sql
-- 使用READ COMMITTED隔离级别
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM large_table;
COMMIT;
```

**教训**: 长时间事务应该使用较低的隔离级别

---

## 6. 备份恢复错误

### 6.1 备份失败

#### 错误案例：磁盘空间不足

**错误**:

```bash
pg_dump mydb > backup.sql
# 错误: 磁盘空间不足
```

**解决方案**:

```bash
# 检查磁盘空间
df -h

# 使用压缩备份
pg_dump -Fc mydb > backup.dump

# 或直接备份到远程
pg_dump mydb | gzip | ssh user@remote "cat > backup.sql.gz"
```

**教训**: 备份前必须检查磁盘空间

### 6.2 恢复失败

#### 错误案例：版本不兼容

**错误**:

```bash
# PostgreSQL 18备份
pg_dump -Fc mydb > backup.dump

# 在PostgreSQL 16恢复
pg_restore -d mydb backup.dump
# 错误: 版本不兼容
```

**解决方案**:

```bash
# 使用兼容格式
pg_dump --format=plain mydb > backup.sql

# 或升级PostgreSQL版本
```

**教训**: 备份恢复需要考虑版本兼容性

---

## 7. 经验教训总结

### 7.1 配置最佳实践

- ✅ **内存配置**: shared_buffers = 25% RAM, work_mem考虑连接数
- ✅ **连接配置**: 使用连接池，限制max_connections
- ✅ **WAL配置**: 合理设置WAL大小和归档
- ✅ **检查点配置**: 平衡性能和恢复时间

### 7.2 查询最佳实践

- ✅ **索引优化**: 为经常查询的列创建索引
- ✅ **查询优化**: 使用EXPLAIN ANALYZE分析查询
- ✅ **批量操作**: 使用批量操作提高性能
- ✅ **避免全表扫描**: 确保WHERE条件有索引

### 7.3 并发最佳实践

- ✅ **事务顺序**: 多个事务访问相同资源时保持顺序一致
- ✅ **隔离级别**: 根据需求选择合适的隔离级别
- ✅ **锁超时**: 设置合理的锁超时时间
- ✅ **死锁检测**: 启用死锁检测和自动回滚

### 7.4 备份恢复最佳实践

- ✅ **定期备份**: 建立定期备份机制
- ✅ **测试恢复**: 定期测试备份恢复
- ✅ **版本兼容**: 考虑版本兼容性
- ✅ **多重备份**: 使用多种备份方式

---

## 📚 相关文档

- [20-故障诊断案例](../20-故障诊断案例/README.md) - 故障诊断案例
- [21-最佳实践/故障排查](../21-最佳实践/故障排查/) - 故障排查方法
- [12-监控与诊断](../12-监控与诊断/README.md) - 监控和诊断

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
