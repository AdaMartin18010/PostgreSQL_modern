# PostgreSQL千万级用户系统案例

> **PostgreSQL版本**: 18.x
> **用户规模**: 1000万+
> **数据量**: 100TB+
> **特点**: 高并发、大数据量、高可用

---

## 📋 目录

- [PostgreSQL千万级用户系统案例](#postgresql千万级用户系统案例)
  - [📋 目录](#-目录)
  - [1. 系统概述](#1-系统概述)
    - [1.1 业务背景](#11-业务背景)
    - [1.2 技术挑战](#12-技术挑战)
  - [2. 架构设计](#2-架构设计)
    - [2.1 整体架构](#21-整体架构)
    - [2.2 分库分表](#22-分库分表)
  - [3. 数据库设计](#3-数据库设计)
    - [3.1 表设计](#31-表设计)
    - [3.2 索引设计](#32-索引设计)
  - [4. 性能优化](#4-性能优化)
    - [4.1 查询优化](#41-查询优化)
    - [4.2 连接池优化](#42-连接池优化)
    - [4.3 缓存策略](#43-缓存策略)
  - [5. 高可用设计](#5-高可用设计)
    - [5.1 主从复制](#51-主从复制)
    - [5.2 自动故障转移](#52-自动故障转移)
  - [6. 经验总结](#6-经验总结)
    - [6.1 关键成功因素](#61-关键成功因素)
    - [6.2 教训](#62-教训)
  - [📚 相关文档](#-相关文档)

---

## 1. 系统概述

### 1.1 业务背景

**系统类型**: 大型社交平台
**用户规模**: 1000万+注册用户
**日活用户**: 500万+
**数据量**: 100TB+
**QPS**: 10万+

### 1.2 技术挑战

- **高并发**: 10万+ QPS
- **大数据量**: 100TB+数据
- **高可用**: 99.99%可用性要求
- **实时性**: 毫秒级响应要求

---

## 2. 架构设计

### 2.1 整体架构

```text
应用层 (多实例)
    ↓
负载均衡 (Nginx/HAProxy)
    ↓
连接池 (PgBouncer × 10)
    ↓
PostgreSQL集群
├── 主库 (读写)
├── 从库1 (只读)
├── 从库2 (只读)
└── 从库3 (只读)
    ↓
存储层 (SSD + 对象存储)
```

### 2.2 分库分表

```sql
-- 按用户ID分库（带错误处理）
-- 数据库: user_db_0, user_db_1, ..., user_db_99

-- 按用户ID分表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users_0') THEN
            CREATE TABLE users_0 (
                user_id BIGINT PRIMARY KEY,
                username TEXT,
                email TEXT
            ) PARTITION BY HASH (user_id);
            RAISE NOTICE '分区表 users_0 创建成功';
        ELSE
            RAISE NOTICE '分区表 users_0 已存在';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'users_1') THEN
            CREATE TABLE users_1 PARTITION OF users_0
            FOR VALUES WITH (MODULUS 100, REMAINDER 1);
            RAISE NOTICE '分区 users_1 创建成功';
        ELSE
            RAISE NOTICE '分区 users_1 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表或分区已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users_0 WHERE user_id = 123;
```

---

## 3. 数据库设计

### 3.1 表设计

```sql
-- 用户表（分表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            CREATE TABLE users (
                user_id BIGSERIAL PRIMARY KEY,
                username TEXT NOT NULL,
                email TEXT,
                created_at TIMESTAMPTZ DEFAULT NOW()
            ) PARTITION BY HASH (user_id);
            RAISE NOTICE '分区表 users 创建成功';
        ELSE
            RAISE NOTICE '分区表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 内容表（分表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'posts') THEN
            CREATE TABLE posts (
                post_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                content TEXT,
                created_at TIMESTAMPTZ DEFAULT NOW()
            ) PARTITION BY RANGE (created_at);
            RAISE NOTICE '分区表 posts 创建成功';
        ELSE
            RAISE NOTICE '分区表 posts 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 posts 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 关系表（分表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'follows') THEN
            CREATE TABLE follows (
                follower_id BIGINT NOT NULL,
                followee_id BIGINT NOT NULL,
                created_at TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (follower_id, followee_id)
            ) PARTITION BY HASH (follower_id);
            RAISE NOTICE '分区表 follows 创建成功';
        ELSE
            RAISE NOTICE '分区表 follows 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 follows 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = 1;
```

### 3.2 索引设计

```sql
-- 用户表索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
            CREATE INDEX idx_users_email ON users(email);
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_username') THEN
            CREATE INDEX idx_users_username ON users(username);
        END IF;
        RAISE NOTICE '用户表索引创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 内容表索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_posts_user_id') THEN
            CREATE INDEX idx_posts_user_id ON posts(user_id);
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_posts_created_at') THEN
            CREATE INDEX idx_posts_created_at ON posts(created_at);
        END IF;
        RAISE NOTICE '内容表索引创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 关系表索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_follows_follower') THEN
            CREATE INDEX idx_follows_follower ON follows(follower_id);
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_follows_followee') THEN
            CREATE INDEX idx_follows_followee ON follows(followee_id);
        END IF;
        RAISE NOTICE '关系表索引创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'user@example.com';
```

---

## 4. 性能优化

### 4.1 查询优化

```sql
-- 优化前：全表扫描（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'user@example.com';
-- 执行时间：10秒

-- 优化后：使用索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
            CREATE INDEX idx_users_email ON users(email);
            RAISE NOTICE '索引 idx_users_email 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_users_email 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 优化后查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'user@example.com';
-- 执行时间：10ms
```

### 4.2 连接池优化

```ini
# PgBouncer配置
pool_mode = transaction
max_client_conn = 10000
default_pool_size = 25
reserve_pool_size = 5
```

### 4.3 缓存策略

```text
缓存层次:
1. 应用层缓存 (Redis) - 热点数据
2. 连接池缓存 - 连接复用
3. PostgreSQL共享缓冲区 - 数据缓存
```

---

## 5. 高可用设计

### 5.1 主从复制

```sql
-- 主库配置（带错误处理）
-- 注意：这些配置需要在postgresql.conf中设置，不能通过SQL直接修改
DO $$
BEGIN
    BEGIN
        ALTER SYSTEM SET wal_level = replica;
        ALTER SYSTEM SET max_wal_senders = 10;
        PERFORM pg_reload_conf();
        RAISE NOTICE '主库配置设置成功，需要重启PostgreSQL生效';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置主库配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 从库配置（带错误处理）
-- 注意：这些配置需要在postgresql.conf中设置，不能通过SQL直接修改
DO $$
BEGIN
    BEGIN
        ALTER SYSTEM SET hot_standby = on;
        PERFORM pg_reload_conf();
        RAISE NOTICE '从库配置设置成功，需要重启PostgreSQL生效';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置从库配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试（查看当前配置）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    setting,
    source
FROM pg_settings
WHERE name IN ('wal_level', 'max_wal_senders', 'hot_standby');
```

### 5.2 自动故障转移

```yaml
# Patroni配置
scope: postgres-cluster
name: postgres-node-1
restapi:
  listen: 0.0.0.0:8008
etcd:
  hosts: etcd1:2379, etcd2:2379, etcd3:2379
```

---

## 6. 经验总结

### 6.1 关键成功因素

- ✅ **分库分表**: 解决大数据量问题
- ✅ **连接池**: 解决高并发问题
- ✅ **缓存策略**: 提高响应速度
- ✅ **监控告警**: 及时发现问题

### 6.2 教训

- ⚠️ **过早优化**: 不要过早优化，先测量
- ⚠️ **索引过多**: 索引过多影响写入性能
- ⚠️ **连接数过多**: 连接数过多导致资源耗尽

---

## 📚 相关文档

- [19-实战案例/README.md](./README.md) - 实战案例库
- [13-高可用架构](../13-高可用架构/README.md) - 高可用架构
- [30-性能调优](../30-性能调优/README.md) - 性能调优

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
