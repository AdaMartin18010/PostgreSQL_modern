# PostgreSQL千万级用户系统案例

> **PostgreSQL版本**: 18.x
> **用户规模**: 1000万+
> **数据量**: 100TB+
> **特点**: 高并发、大数据量、高可用

---

## 📋 目录

- [PostgreSQL千万级用户系统案例](#postgresql千万级用户系统案例)
  - [📋 目录](#-目录)
  - [1. 系统概述](#1-系统概述)
    - [1.1 业务背景](#11-业务背景)
    - [1.2 技术挑战](#12-技术挑战)
  - [2. 架构设计](#2-架构设计)
    - [2.1 整体架构](#21-整体架构)
    - [2.2 分库分表](#22-分库分表)
  - [3. 数据库设计](#3-数据库设计)
    - [3.1 表设计](#31-表设计)
    - [3.2 索引设计](#32-索引设计)
  - [4. 性能优化](#4-性能优化)
    - [4.1 查询优化](#41-查询优化)
    - [4.2 连接池优化](#42-连接池优化)
    - [4.3 缓存策略](#43-缓存策略)
  - [5. 高可用设计](#5-高可用设计)
    - [5.1 主从复制](#51-主从复制)
    - [5.2 自动故障转移](#52-自动故障转移)
  - [6. 经验总结](#6-经验总结)
    - [6.1 关键成功因素](#61-关键成功因素)
    - [6.2 教训](#62-教训)
  - [📚 相关文档](#-相关文档)

---

## 1. 系统概述

### 1.1 业务背景

**系统类型**: 大型社交平台
**用户规模**: 1000万+注册用户
**日活用户**: 500万+
**数据量**: 100TB+
**QPS**: 10万+

### 1.2 技术挑战

- **高并发**: 10万+ QPS
- **大数据量**: 100TB+数据
- **高可用**: 99.99%可用性要求
- **实时性**: 毫秒级响应要求

---

## 2. 架构设计

### 2.1 整体架构

```text
应用层 (多实例)
    ↓
负载均衡 (Nginx/HAProxy)
    ↓
连接池 (PgBouncer × 10)
    ↓
PostgreSQL集群
├── 主库 (读写)
├── 从库1 (只读)
├── 从库2 (只读)
└── 从库3 (只读)
    ↓
存储层 (SSD + 对象存储)
```

### 2.2 分库分表

```sql
-- 按用户ID分库
-- 数据库: user_db_0, user_db_1, ..., user_db_99

-- 按用户ID分表
CREATE TABLE users_0 (
    user_id BIGINT PRIMARY KEY,
    username TEXT,
    email TEXT
) PARTITION BY HASH (user_id);

CREATE TABLE users_1 PARTITION OF users_0
FOR VALUES WITH (MODULUS 100, REMAINDER 1);
```

---

## 3. 数据库设计

### 3.1 表设计

```sql
-- 用户表（分表）
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username TEXT NOT NULL,
    email TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY HASH (user_id);

-- 内容表（分表）
CREATE TABLE posts (
    post_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    content TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- 关系表（分表）
CREATE TABLE follows (
    follower_id BIGINT NOT NULL,
    followee_id BIGINT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (follower_id, followee_id)
) PARTITION BY HASH (follower_id);
```

### 3.2 索引设计

```sql
-- 用户表索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);

-- 内容表索引
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_created_at ON posts(created_at);

-- 关系表索引
CREATE INDEX idx_follows_follower ON follows(follower_id);
CREATE INDEX idx_follows_followee ON follows(followee_id);
```

---

## 4. 性能优化

### 4.1 查询优化

```sql
-- 优化前：全表扫描
SELECT * FROM users WHERE email = 'user@example.com';
-- 执行时间：10秒

-- 优化后：使用索引
CREATE INDEX idx_users_email ON users(email);
SELECT * FROM users WHERE email = 'user@example.com';
-- 执行时间：10ms
```

### 4.2 连接池优化

```ini
# PgBouncer配置
pool_mode = transaction
max_client_conn = 10000
default_pool_size = 25
reserve_pool_size = 5
```

### 4.3 缓存策略

```text
缓存层次:
1. 应用层缓存 (Redis) - 热点数据
2. 连接池缓存 - 连接复用
3. PostgreSQL共享缓冲区 - 数据缓存
```

---

## 5. 高可用设计

### 5.1 主从复制

```sql
-- 主库配置
wal_level = replica
max_wal_senders = 10

-- 从库配置
hot_standby = on
```

### 5.2 自动故障转移

```yaml
# Patroni配置
scope: postgres-cluster
name: postgres-node-1
restapi:
  listen: 0.0.0.0:8008
etcd:
  hosts: etcd1:2379, etcd2:2379, etcd3:2379
```

---

## 6. 经验总结

### 6.1 关键成功因素

- ✅ **分库分表**: 解决大数据量问题
- ✅ **连接池**: 解决高并发问题
- ✅ **缓存策略**: 提高响应速度
- ✅ **监控告警**: 及时发现问题

### 6.2 教训

- ⚠️ **过早优化**: 不要过早优化，先测量
- ⚠️ **索引过多**: 索引过多影响写入性能
- ⚠️ **连接数过多**: 连接数过多导致资源耗尽

---

## 📚 相关文档

- [19-实战案例/README.md](./README.md) - 实战案例库
- [13-高可用架构](../13-高可用架构/README.md) - 高可用架构
- [30-性能调优](../30-性能调优/README.md) - 性能调优

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
