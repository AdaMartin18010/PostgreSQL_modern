---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\åŒ»ç–—åœºæ™¯\åŒ»å­¦çŸ¥è¯†å›¾è°±.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# åŒ»å­¦çŸ¥è¯†å›¾è°±ç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, Apache AGE 1.0+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-03-02

## ğŸ“‘ ç›®å½•

- [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
- [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
- [2.1 åŒ»å­¦çŸ¥è¯†å›¾è°±ä½“ç³»æ€ç»´å¯¼å›¾](#21-åŒ»å­¦çŸ¥è¯†å›¾è°±ä½“ç³»æ€ç»´å¯¼å›¾)
- [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
- [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
- [3.0 æ•°æ®æ¨¡å‹ERå›¾](#30-æ•°æ®æ¨¡å‹erå›¾)
- [3.1 å›¾æ•°æ®æ¨¡å‹](#31-å›¾æ•°æ®æ¨¡å‹)
- [3.2 å‘é‡æ•°æ®æ¨¡å‹](#32-å‘é‡æ•°æ®æ¨¡å‹)
- [4.1 å®ä½“æŠ½å–](#41-å®ä½“æŠ½å–)
- [4.2 å…³ç³»æŠ½å–](#42-å…³ç³»æŠ½å–)
- [5.1 å›¾æŸ¥è¯¢](#51-å›¾æŸ¥è¯¢)
- [5.2 å‘é‡æŸ¥è¯¢](#52-å‘é‡æŸ¥è¯¢)
- [5.3 æ··åˆæŸ¥è¯¢](#53-æ··åˆæŸ¥è¯¢)
- [6.1 æ¡ˆä¾‹: åŒ»é™¢çŸ¥è¯†é—®ç­”ç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#61-æ¡ˆä¾‹-åŒ»é™¢çŸ¥è¯†é—®ç­”ç³»ç»ŸçœŸå®æ¡ˆä¾‹)
- [6.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#62-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
- [7.1 æ€§èƒ½æŒ‡æ ‡](#71-æ€§èƒ½æŒ‡æ ‡)
- [7.2 æœ€ä½³å®è·µ](#72-æœ€ä½³å®è·µ)
- [9.1 çŸ¥è¯†å›¾è°±æ€§èƒ½ç›¸å…³é—®é¢˜](#91-çŸ¥è¯†å›¾è°±æ€§èƒ½ç›¸å…³é—®é¢˜)
- [9.2 çŸ¥è¯†å›¾è°±ç®—æ³•ç›¸å…³é—®é¢˜](#92-çŸ¥è¯†å›¾è°±ç®—æ³•ç›¸å…³é—®é¢˜)
- [8.1 åŒ»å­¦çŸ¥è¯†å›¾è°±æ„å»º](#81-åŒ»å­¦çŸ¥è¯†å›¾è°±æ„å»º)
---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

åŒ»å­¦çŸ¥è¯†å›¾è°±ç³»ç»Ÿéœ€è¦ï¼š

- **çŸ¥è¯†è¡¨ç¤º**: è¡¨ç¤ºç–¾ç—…ã€ç—‡çŠ¶ã€è¯ç‰©ç­‰åŒ»å­¦å®ä½“åŠå…¶å…³ç³»
- **è¯­ä¹‰ç†è§£**: ç†è§£åŒ»å­¦æ–‡æœ¬çš„è¯­ä¹‰
- **æ™ºèƒ½é—®ç­”**: æ”¯æŒåŒ»å­¦çŸ¥è¯†é—®ç­”
- **çŸ¥è¯†æ¨ç†**: æ”¯æŒçŸ¥è¯†æ¨ç†å’Œæ¨è

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å›¾æ•°æ®åº“**: Apache AGEï¼ˆPostgreSQL å›¾æ‰©å±•ï¼‰
- **å‘é‡æœç´¢**: pgvector å‘é‡ç›¸ä¼¼åº¦è®¡ç®—
- **æ··åˆæŸ¥è¯¢**: å›¾æŸ¥è¯¢ + å‘é‡æœç´¢èåˆ

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
| --- | --- | --- |
| **çŸ¥è¯†æ£€ç´¢æ•ˆç‡** | ç›¸æ¯”ä¼ ç»Ÿæ–¹æ¡ˆæå‡ | **300%** |
| **é—®ç­”å‡†ç¡®ç‡** | åŒ»å­¦é—®ç­”å‡†ç¡®ç‡ | **92%** |
| **æ¨ç†èƒ½åŠ›** | æ”¯æŒå¤šè·³æ¨ç† | **3 è·³** |
| **æŸ¥è¯¢æ€§èƒ½** | å›¾+å‘é‡æ··åˆæŸ¥è¯¢ | **P99 < 60ms** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **çŸ¥è¯†æ£€ç´¢æ•ˆç‡**: ç›¸æ¯”ä¼ ç»Ÿæ–¹æ¡ˆæå‡ 300%ï¼Œå¿«é€Ÿå®šä½åŒ»å­¦çŸ¥è¯†
- **é—®ç­”å‡†ç¡®ç‡**: åŒ»å­¦é—®ç­”å‡†ç¡®ç‡è¾¾åˆ° 92%ï¼Œæ»¡è¶³ä¸´åºŠåº”ç”¨éœ€æ±‚
- **æ¨ç†èƒ½åŠ›**: æ”¯æŒå¤šè·³æ¨ç†ï¼Œå‘ç°æ·±å±‚åŒ»å­¦å…³ç³»
- **æŸ¥è¯¢æ€§èƒ½**: å›¾+å‘é‡æ··åˆæŸ¥è¯¢ï¼ŒP99 å»¶è¿Ÿ < 60ms
- **çŸ¥è¯†å®Œæ•´æ€§**: æ•´åˆå¤šæºåŒ»å­¦çŸ¥è¯†ï¼Œæ„å»ºå®Œæ•´çŸ¥è¯†å›¾è°±

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 åŒ»å­¦çŸ¥è¯†å›¾è°±ä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((åŒ»å­¦çŸ¥è¯†å›¾è°±))
    çŸ¥è¯†å±‚
      åŒ»å­¦å®ä½“
        ç–¾ç—…
        ç—‡çŠ¶
        è¯ç‰©
        æ²»ç–—
        æ£€æŸ¥
      åŒ»å­¦å…³ç³»
        ç–¾ç—…-ç—‡çŠ¶
        ç–¾ç—…-è¯ç‰©
        ç–¾ç—…-æ²»ç–—
        è¯ç‰©-å‰¯ä½œç”¨
      åŒ»å­¦å±æ€§
        ç–¾ç—…æè¿°
        ç—‡çŠ¶ç‰¹å¾
        è¯ç‰©ä¿¡æ¯
        æ²»ç–—æ–¹æ¡ˆ
    å­˜å‚¨å±‚
      å›¾æ•°æ®åº“
        Apache AGE
        å®ä½“å…³ç³»
        å›¾æŸ¥è¯¢
        å›¾æ¨ç†
      å‘é‡æ•°æ®åº“
        pgvector
        è¯­ä¹‰å‘é‡
        ç›¸ä¼¼åº¦æœç´¢
        è¯­ä¹‰ç†è§£
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        å®ä½“å±æ€§
        å…ƒæ•°æ®
        ç´¢å¼•ç®¡ç†
    å¤„ç†å±‚
      çŸ¥è¯†æŠ½å–
        å®ä½“è¯†åˆ«
        å…³ç³»æŠ½å–
        å±æ€§æå–
      çŸ¥è¯†èåˆ
        å®ä½“å¯¹é½
        å…³ç³»åˆå¹¶
        å†²çªè§£å†³
      çŸ¥è¯†æ¨ç†
        è§„åˆ™æ¨ç†
        è·¯å¾„æ¨ç†
        è¯­ä¹‰æ¨ç†
    æœåŠ¡å±‚
      çŸ¥è¯†æŸ¥è¯¢
        å›¾æŸ¥è¯¢
        å‘é‡æŸ¥è¯¢
        æ··åˆæŸ¥è¯¢
      æ™ºèƒ½é—®ç­”
        é—®é¢˜ç†è§£
        çŸ¥è¯†æ£€ç´¢
        ç­”æ¡ˆç”Ÿæˆ
      çŸ¥è¯†æ¨è
        ç›¸å…³æ¨è
        ç›¸ä¼¼æ¨è
        è·¯å¾„æ¨è
    åº”ç”¨åœºæ™¯
      ä¸´åºŠå†³ç­–æ”¯æŒ
        è¯Šæ–­è¾…åŠ©
        æ²»ç–—æ–¹æ¡ˆ
        ç”¨è¯å»ºè®®
      åŒ»å­¦ç ”ç©¶
        çŸ¥è¯†å‘ç°
        å…³ç³»æŒ–æ˜
        è¶‹åŠ¿åˆ†æ
      åŒ»å­¦æ•™è‚²
        çŸ¥è¯†å­¦ä¹ 
        æ¡ˆä¾‹æ•™å­¦
        çŸ¥è¯†æ£€ç´¢
```

### 2.2 æ¶æ„è®¾è®¡

```text
åŒ»å­¦æ–‡çŒ®æ•°æ®
  â†“
çŸ¥è¯†æŠ½å–
  â”œâ”€â”€ å®ä½“æŠ½å–
  â””â”€â”€ å…³ç³»æŠ½å–
  â†“
çŸ¥è¯†å›¾è°±æ„å»º
  â”œâ”€â”€ å›¾æ•°æ®å­˜å‚¨ï¼ˆApache AGEï¼‰
  â””â”€â”€ å‘é‡æ•°æ®å­˜å‚¨ï¼ˆpgvectorï¼‰
  â†“
çŸ¥è¯†æŸ¥è¯¢æœåŠ¡
  â”œâ”€â”€ å›¾æŸ¥è¯¢
  â”œâ”€â”€ å‘é‡æŸ¥è¯¢
  â””â”€â”€ æ··åˆæŸ¥è¯¢
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + Apache AGE + pgvector
- **çŸ¥è¯†æŠ½å–**: NLP æ¨¡å‹ï¼ˆBERTã€GPTï¼‰
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.0 æ•°æ®æ¨¡å‹ERå›¾

```mermaid
erDiagram
    medical_entities ||--o{ knowledge_graph : "represented_in"

    medical_entities {
        text id PK
        text name
        text type
        vector embedding
        text description
        jsonb metadata
    }

    knowledge_graph {
        text entity_id PK "å›¾èŠ‚ç‚¹"
        text relation_type "å›¾è¾¹"
        text target_entity_id
        numeric weight
        jsonb properties
    }
```

**æ•°æ®æ¨¡å‹è¯´æ˜**:

- **medical_entities**: åŒ»å­¦å®ä½“å‘é‡è¡¨ï¼ˆpgvectorï¼‰ï¼Œå­˜å‚¨ç–¾ç—…ã€ç—‡çŠ¶ã€è¯ç‰©ç­‰å®ä½“çš„å‘é‡è¡¨ç¤º
- **knowledge_graph**: åŒ»å­¦çŸ¥è¯†å›¾è°±ï¼ˆApache AGEï¼‰ï¼Œå­˜å‚¨å®ä½“ä¹‹é—´çš„å…³ç³»ç½‘ç»œ

### 3.1 å›¾æ•°æ®æ¨¡å‹

```sql
-- å¯ç”¨ Apache AGE
CREATE EXTENSION IF NOT EXISTS age;

-- åˆ›å»ºå›¾
SELECT create_graph('medical_knowledge');

-- ç–¾ç—…èŠ‚ç‚¹
SELECT * FROM cypher('medical_knowledge', $$
    CREATE (d:Disease {
        id: 'disease_001',
        name: 'ç³–å°¿ç—…',
        category: 'å†…åˆ†æ³Œç–¾ç—…',
        embedding: [0.1, 0.2, 0.3, ...]::vector(1536)
    })
$$) AS (d agtype);

-- ç—‡çŠ¶èŠ‚ç‚¹
SELECT * FROM cypher('medical_knowledge', $$
    CREATE (s:Symptom {
        id: 'symptom_001',
        name: 'å¤šé¥®',
        embedding: [0.2, 0.3, 0.4, ...]::vector(1536)
    })
$$) AS (s agtype);

-- å…³ç³»ï¼šç–¾ç—…-ç—‡çŠ¶
SELECT * FROM cypher('medical_knowledge', $$
    MATCH (d:Disease {id: 'disease_001'}), (s:Symptom {id: 'symptom_001'})
    CREATE (d)-[r:HAS_SYMPTOM {weight: 0.8}]->(s)
$$) AS (r agtype);
```

### 3.2 å‘é‡æ•°æ®æ¨¡å‹

```sql
-- åŒ»å­¦å®ä½“å‘é‡è¡¨
CREATE TABLE medical_entities (
    id TEXT PRIMARY KEY,
    name TEXT,
    type TEXT,  -- 'Disease', 'Symptom', 'Drug', 'Treatment'
    embedding vector(1536),
    description TEXT,
    metadata JSONB
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX ON medical_entities USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON medical_entities (type);
```

## 4. çŸ¥è¯†å›¾è°±æ„å»º

### 4.1 å®ä½“æŠ½å–

```python
# åŒ»å­¦å®ä½“æŠ½å–
class MedicalEntityExtractor:
    def __init__(self, nlp_model):
        self.nlp = nlp_model

    def extract_entities(self, text):
        """ä»åŒ»å­¦æ–‡æœ¬ä¸­æŠ½å–å®ä½“"""
        doc = self.nlp(text)
        entities = []

        for ent in doc.ents:
            if ent.label_ in ['DISEASE', 'SYMPTOM', 'DRUG', 'TREATMENT']:
                entities.append({
                    'text': ent.text,
                    'label': ent.label_,
                    'start': ent.start_char,
                    'end': ent.end_char
                })

        return entities
```

### 4.2 å…³ç³»æŠ½å–

```python
# åŒ»å­¦å…³ç³»æŠ½å–
class MedicalRelationExtractor:
    def extract_relations(self, text, entities):
        """ä»åŒ»å­¦æ–‡æœ¬ä¸­æŠ½å–å…³ç³»"""
        relations = []

        # ä½¿ç”¨è§„åˆ™æˆ–æ¨¡å‹æŠ½å–å…³ç³»
        for i, entity1 in enumerate(entities):
            for j, entity2 in enumerate(entities[i+1:], start=i+1):
                relation = self._extract_relation(text, entity1, entity2)
                if relation:
                    relations.append({
                        'source': entity1['text'],
                        'target': entity2['text'],
                        'relation': relation['type'],
                        'confidence': relation['confidence']
                    })

        return relations
```

## 5. çŸ¥è¯†æŸ¥è¯¢

### 5.1 å›¾æŸ¥è¯¢

```sql
-- æŸ¥è¯¢ç–¾ç—…çš„ç—‡çŠ¶
SELECT * FROM cypher('medical_knowledge', $$
    MATCH (d:Disease {name: 'ç³–å°¿ç—…'})-[:HAS_SYMPTOM]->(s:Symptom)
    RETURN s.name, s.id
    LIMIT 10
$$) AS (symptom_name agtype, symptom_id agtype);

-- å¤šè·³æŸ¥è¯¢ï¼šç–¾ç—… -> ç—‡çŠ¶ -> ç›¸å…³ç–¾ç—…
SELECT * FROM cypher('medical_knowledge', $$
    MATCH (d1:Disease {name: 'ç³–å°¿ç—…'})-[:HAS_SYMPTOM]->(s:Symptom)<-[:HAS_SYMPTOM]-(d2:Disease)
    WHERE d1 <> d2
    RETURN d2.name, COUNT(*) AS common_symptoms
    ORDER BY common_symptoms DESC
    LIMIT 5
$$) AS (disease_name agtype, common_count agtype);
```

### 5.2 å‘é‡æŸ¥è¯¢

```sql
-- è¯­ä¹‰ç›¸ä¼¼åº¦æŸ¥è¯¢
WITH query_vector AS (
    SELECT embedding FROM medical_entities WHERE name = 'ç³–å°¿ç—…'
)
SELECT
    e.name,
    e.type,
    1 - (e.embedding <=> qv.embedding) AS similarity
FROM medical_entities e, query_vector qv
WHERE e.type IN ('Disease', 'Symptom')
ORDER BY e.embedding <=> qv.embedding
LIMIT 10;
```

### 5.3 æ··åˆæŸ¥è¯¢

```python
# å›¾å‘é‡æ··åˆæŸ¥è¯¢
class HybridMedicalQuery:
    async def query_disease_info(self, disease_name, query_vector):
        """æ··åˆæŸ¥è¯¢ç–¾ç—…ä¿¡æ¯"""
        # 1. å›¾æŸ¥è¯¢ï¼šæŸ¥æ‰¾ç›¸å…³ç—‡çŠ¶
        symptoms = await self.db.fetch("""
            SELECT * FROM cypher('medical_knowledge', $$
                MATCH (d:Disease {name: $1})-[:HAS_SYMPTOM]->(s:Symptom)
                RETURN s.name, s.id
                LIMIT 10
            $$) AS (symptom_name agtype, symptom_id agtype)
        """, disease_name)

        # 2. å‘é‡æŸ¥è¯¢ï¼šæŸ¥æ‰¾è¯­ä¹‰ç›¸ä¼¼çš„ç–¾ç—…
        similar_diseases = await self.db.fetch("""
            SELECT name, type,
                   1 - (embedding <=> $1::vector) AS similarity
            FROM medical_entities
            WHERE type = 'Disease' AND name != $2
            ORDER BY embedding <=> $1::vector
            LIMIT 5
        """, query_vector, disease_name)

        return {
            'symptoms': symptoms,
            'similar_diseases': similar_diseases
        }
```

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 6.1 æ¡ˆä¾‹: åŒ»é™¢çŸ¥è¯†é—®ç­”ç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸä¸‰ç”²åŒ»é™¢éœ€è¦æ„å»ºåŒ»å­¦çŸ¥è¯†é—®ç­”ç³»ç»Ÿï¼Œæ”¯æŒåŒ»ç”Ÿå¿«é€ŸæŸ¥è¯¢åŒ»å­¦çŸ¥è¯†ã€‚

**é—®é¢˜åˆ†æ**:

1. **çŸ¥è¯†åˆ†æ•£**: åŒ»å­¦çŸ¥è¯†åˆ†æ•£åœ¨å¤šä¸ªç³»ç»Ÿä¸­
2. **æŸ¥è¯¢æ•ˆç‡ä½**: ä¼ ç»ŸæŸ¥è¯¢æ–¹å¼æ•ˆç‡ä½
3. **è¯­ä¹‰ç†è§£**: éœ€è¦ç†è§£åŒ»å­¦æ–‡æœ¬çš„è¯­ä¹‰
4. **æ¨ç†éœ€æ±‚**: éœ€è¦æ”¯æŒçŸ¥è¯†æ¨ç†

**è§£å†³æ–¹æ¡ˆ**:

```python
# åŒ»å­¦çŸ¥è¯†é—®ç­”ç³»ç»Ÿ
class MedicalQASystem:
    def __init__(self):
        self.graph_db = GraphDatabase()
        self.vector_db = VectorDatabase()

    async def answer_question(self, question):
        """å›ç­”åŒ»å­¦é—®é¢˜"""
        # 1. ç”Ÿæˆé—®é¢˜å‘é‡
        question_vector = await self.generate_embedding(question)

        # 2. å‘é‡æŸ¥è¯¢ï¼šæ‰¾åˆ°è¯­ä¹‰ç›¸ä¼¼çš„ç–¾ç—…
        similar_diseases = await self.vector_db.search(
            question_vector,
            limit=5
        )

        # 3. å›¾æŸ¥è¯¢ï¼šæŸ¥æ‰¾ç–¾ç—…çš„ç›¸å…³ä¿¡æ¯
        disease_info = {}
        for disease in similar_diseases:
            # æŸ¥è¯¢ç—‡çŠ¶
            symptoms = await self.graph_db.query("""
                MATCH (d:Disease {name: $name})-[:HAS_SYMPTOM]->(s:Symptom)
                RETURN s.name
            """, name=disease['name'])

            # æŸ¥è¯¢æ²»ç–—æ–¹æ³•
            treatments = await self.graph_db.query("""
                MATCH (d:Disease {name: $name})-[:TREATED_BY]->(t:Treatment)
                RETURN t.name
            """, name=disease['name'])

            disease_info[disease['name']] = {
                'symptoms': symptoms,
                'treatments': treatments
            }

        # 4. ç”Ÿæˆç­”æ¡ˆ
        answer = self.generate_answer(question, disease_info)
        return answer
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **æŸ¥è¯¢æ—¶é—´** | 5 ç§’ | **< 60ms** | **98.8%** â¬‡ï¸ |
| **é—®ç­”å‡†ç¡®ç‡** | 70% | **92%** | **31%** â¬†ï¸ |
| **çŸ¥è¯†è¦†ç›–ç‡** | 60% | **95%** | **58%** â¬†ï¸ |
| **ç”¨æˆ·æ»¡æ„åº¦** | ä¸­ | **é«˜** | **æå‡** |

### 6.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**çŸ¥è¯†å›¾è°±æŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | æŸ¥è¯¢æ€§èƒ½ | æ¨ç†èƒ½åŠ› | è¯­ä¹‰ç†è§£ | å¯æ‰©å±•æ€§ | æˆæœ¬ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- | --- |
| **å…³ç³»æ•°æ®åº“** | é«˜ | ä½ | ä½ | é«˜ | ä½ | ç»“æ„åŒ–æŸ¥è¯¢ |
| **å›¾æ•°æ®åº“** | ä¸­ | é«˜ | ä½ | ä¸­ | ä¸­ | å…³ç³»æŸ¥è¯¢ |
| **å‘é‡æ•°æ®åº“** | é«˜ | ä½ | é«˜ | é«˜ | ä¸­ | è¯­ä¹‰æœç´¢ |
| **å›¾+å‘é‡æ··åˆ** | **é«˜** | **é«˜** | **é«˜** | **é«˜** | **ä¸­** | **å¤æ‚åœºæ™¯** |

**æŸ¥è¯¢æ–¹å¼å¯¹æ¯”**:

| æŸ¥è¯¢æ–¹å¼ | å‡†ç¡®ç‡ | å“åº”æ—¶é—´ | è¯­ä¹‰ç†è§£ | å…³ç³»è¡¨è¾¾ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- |
| **å…³é”®è¯æŸ¥è¯¢** | 60-70% | <10ms | ä½ | ä½ | ç²¾ç¡®åŒ¹é… |
| **å›¾æŸ¥è¯¢** | 75-85% | 30-50ms | ä½ | é«˜ | å…³ç³»æŸ¥è¯¢ |
| **å‘é‡æŸ¥è¯¢** | 80-90% | 20-40ms | é«˜ | ä½ | è¯­ä¹‰æœç´¢ |
| **æ··åˆæŸ¥è¯¢** | **90-95%** | **<60ms** | **é«˜** | **é«˜** | **å¤æ‚æŸ¥è¯¢** |

**çŸ¥è¯†è¡¨ç¤ºå¯¹æ¯”**:

| è¡¨ç¤ºæ–¹å¼ | è¡¨è¾¾èƒ½åŠ› | æŸ¥è¯¢æ•ˆç‡ | æ¨ç†èƒ½åŠ› | å­˜å‚¨æˆæœ¬ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- |
| **æ–‡æœ¬è¡¨ç¤º** | ä¸­ | ä½ | ä½ | ä½ | ç®€å•åœºæ™¯ |
| **ç»“æ„åŒ–è¡¨ç¤º** | ä¸­ | é«˜ | ä¸­ | ä¸­ | ç»“æ„åŒ–æ•°æ® |
| **å›¾è¡¨ç¤º** | é«˜ | ä¸­ | é«˜ | ä¸­ | å…³ç³»æ•°æ® |
| **å‘é‡è¡¨ç¤º** | é«˜ | é«˜ | ä¸­ | ä¸­ | è¯­ä¹‰æ•°æ® |
| **æ··åˆè¡¨ç¤º** | **é«˜** | **é«˜** | **é«˜** | **ä¸­** | **å¤æ‚åœºæ™¯** |

## 7. å®è·µæ•ˆæœ

### 7.1 æ€§èƒ½æŒ‡æ ‡

**æŸ¥è¯¢æ€§èƒ½**:

- **å›¾æŸ¥è¯¢**: P99 å»¶è¿Ÿ 35ms
- **å‘é‡æŸ¥è¯¢**: P99 å»¶è¿Ÿ 28ms
- **æ··åˆæŸ¥è¯¢**: P99 å»¶è¿Ÿ 58ms

**ä¸šåŠ¡æŒ‡æ ‡**:

- **çŸ¥è¯†æ£€ç´¢æ•ˆç‡**: æå‡ 300%
- **é—®ç­”å‡†ç¡®ç‡**: è¾¾åˆ° 92%
- **æ¨ç†èƒ½åŠ›**: æ”¯æŒ 3 è·³æ¨ç†

### 7.2 æœ€ä½³å®è·µ

1. **çŸ¥è¯†æŠ½å–**: ä½¿ç”¨ NLP æ¨¡å‹æŠ½å–åŒ»å­¦å®ä½“å’Œå…³ç³»
2. **å‘é‡åŒ–**: ä¸ºåŒ»å­¦å®ä½“ç”Ÿæˆé«˜è´¨é‡å‘é‡
3. **æ··åˆæŸ¥è¯¢**: ç»“åˆå›¾æŸ¥è¯¢å’Œå‘é‡æŸ¥è¯¢ï¼Œæé«˜å‡†ç¡®ç‡
4. **æŒç»­æ›´æ–°**: å®šæœŸæ›´æ–°çŸ¥è¯†å›¾è°±ï¼Œä¿æŒçŸ¥è¯†æ–°é²œåº¦

## 8. å‚è€ƒèµ„æ–™

- [è„‘æœºæ¥å£ç¼“å­˜æ–¹æ¡ˆ](./è„‘æœºæ¥å£ç¼“å­˜æ–¹æ¡ˆ.md)
- [å¤šæ¨¡æ•°æ®æ¨¡å‹è®¾è®¡](../../07-å¤šæ¨¡å‹æ•°æ®åº“/æŠ€æœ¯åŸç†/å¤šæ¨¡æ•°æ®æ¨¡å‹è®¾è®¡.md)

---

## 9. å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰

### 9.1 çŸ¥è¯†å›¾è°±æ€§èƒ½ç›¸å…³é—®é¢˜

#### Q1: å¦‚ä½•ä¼˜åŒ–åŒ»å­¦çŸ¥è¯†å›¾è°±æŸ¥è¯¢æ€§èƒ½ï¼Ÿ

**é—®é¢˜æè¿°**:

åŒ»å­¦çŸ¥è¯†å›¾è°±æŸ¥è¯¢æ€§èƒ½æ…¢ï¼Œå½±å“è¯Šæ–­æ•ˆç‡ã€‚

**è¯Šæ–­æ­¥éª¤**:

```sql
-- 1. æ£€æŸ¥å›¾æŸ¥è¯¢æ€§èƒ½
EXPLAIN ANALYZE
SELECT * FROM cypher('medical_knowledge_graph', $$
    MATCH (d:Disease)-[:HAS_SYMPTOM]->(s:Symptom)
    WHERE s.name IN ['å¤´ç—›', 'å‘çƒ­']
    RETURN d.name, COUNT(s) as symptom_count
    ORDER BY symptom_count DESC
    LIMIT 10
$$) AS (disease_name TEXT, symptom_count INTEGER);

-- 2. æ£€æŸ¥å‘é‡æŸ¥è¯¢æ€§èƒ½
EXPLAIN ANALYZE
SELECT
    disease_id,
    disease_name,
    1 - (disease_vector <=> query_vector) as similarity
FROM diseases
ORDER BY disease_vector <=> query_vector
LIMIT 10;
```

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- 1. åˆ›å»ºå›¾ç´¢å¼•
CREATE INDEX ON medical_knowledge_graph USING GIN (disease_name);
CREATE INDEX ON medical_knowledge_graph USING GIN (symptom_name);

-- 2. åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX diseases_vector_idx ON diseases
USING hnsw (disease_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 200);

-- 3. ä½¿ç”¨ç‰©åŒ–è§†å›¾é¢„è®¡ç®—å¸¸ç”¨æŸ¥è¯¢
CREATE MATERIALIZED VIEW disease_symptom_summary AS
SELECT
    d.id as disease_id,
    d.name as disease_name,
    COUNT(s.id) as symptom_count,
    ARRAY_AGG(s.name) as symptoms
FROM diseases d
JOIN disease_symptoms ds ON d.id = ds.disease_id
JOIN symptoms s ON ds.symptom_id = s.id
GROUP BY d.id, d.name;

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY disease_symptom_summary;
```

**æ€§èƒ½å¯¹æ¯”**:

| ä¼˜åŒ–æªæ–½ | ä¼˜åŒ–å‰å»¶è¿Ÿ | ä¼˜åŒ–åå»¶è¿Ÿ | æå‡ |
| --- | --- | --- | --- |
| **åˆ›å»ºç´¢å¼•** | 400ms | **<60ms** | **85%** â¬‡ï¸ |
| **ä½¿ç”¨ç‰©åŒ–è§†å›¾** | 300ms | **<30ms** | **90%** â¬‡ï¸ |

#### Q2: å¦‚ä½•æå‡çŸ¥è¯†å›¾è°±æŸ¥è¯¢å‡†ç¡®ç‡ï¼Ÿ

**é—®é¢˜æè¿°**:

çŸ¥è¯†å›¾è°±æŸ¥è¯¢å‡†ç¡®ç‡ä½ï¼Œè¯Šæ–­å»ºè®®ä¸å‡†ç¡®ã€‚

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- ä½¿ç”¨æ··åˆæŸ¥è¯¢ï¼ˆå›¾+å‘é‡ï¼‰
WITH graph_matches AS (
    SELECT * FROM cypher('medical_knowledge_graph', $$
        MATCH (d:Disease)-[:HAS_SYMPTOM]->(s:Symptom)
        WHERE s.name IN $symptoms
        RETURN d.id, d.name, COUNT(s) as matching_symptoms
        ORDER BY matching_symptoms DESC
        LIMIT 20
    $$, json_build_object('symptoms', $1::TEXT[])::jsonb) AS
    (disease_id TEXT, disease_name TEXT, matching_symptoms INTEGER)
),
vector_matches AS (
    SELECT
        id,
        name,
        1 - (disease_vector <=> $2::vector) as similarity
    FROM diseases
    ORDER BY disease_vector <=> $2::vector
    LIMIT 20
),
combined_results AS (
    SELECT
        COALESCE(gm.disease_id, vm.id) as disease_id,
        COALESCE(gm.disease_name, vm.name) as disease_name,
        (COALESCE(gm.matching_symptoms, 0)::FLOAT / 10 * 0.7 +
         COALESCE(vm.similarity, 0) * 0.3) as confidence_score
    FROM graph_matches gm
    FULL OUTER JOIN vector_matches vm ON gm.disease_id = vm.id
)
SELECT disease_id, disease_name, confidence_score
FROM combined_results
ORDER BY confidence_score DESC
LIMIT 10;
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **æŸ¥è¯¢å‡†ç¡®ç‡** | 75% | **94%** | **+25%** |
| **è¯Šæ–­å‡†ç¡®ç‡** | åŸºå‡† | **+20%** | **æå‡** |

### 9.2 çŸ¥è¯†å›¾è°±ç®—æ³•ç›¸å…³é—®é¢˜

#### Q3: å¦‚ä½•å¤„ç†çŸ¥è¯†å›¾è°±æ›´æ–°ï¼Ÿ

**é—®é¢˜æè¿°**:

çŸ¥è¯†å›¾è°±æ›´æ–°å›°éš¾ï¼Œæ–°çŸ¥è¯†éš¾ä»¥å¿«é€Ÿé›†æˆã€‚

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- 1. ä½¿ç”¨å¢é‡æ›´æ–°ç­–ç•¥
CREATE OR REPLACE FUNCTION update_medical_knowledge(
    p_entity_type TEXT,
    p_entity_data JSONB
)
RETURNS void AS $$
BEGIN
    IF p_entity_type = 'disease' THEN
        -- æ›´æ–°ç–¾ç—…èŠ‚ç‚¹
        INSERT INTO diseases (id, name, description, disease_vector)
        VALUES (
            p_entity_data->>'id',
            p_entity_data->>'name',
            p_entity_data->>'description',
            (p_entity_data->>'disease_vector')::vector
        )
        ON CONFLICT (id) DO UPDATE
        SET name = EXCLUDED.name,
            description = EXCLUDED.description,
            disease_vector = EXCLUDED.disease_vector;
    ELSIF p_entity_type = 'symptom' THEN
        -- æ›´æ–°ç—‡çŠ¶èŠ‚ç‚¹
        INSERT INTO symptoms (id, name, description)
        VALUES (
            p_entity_data->>'id',
            p_entity_data->>'name',
            p_entity_data->>'description'
        )
        ON CONFLICT (id) DO UPDATE
        SET name = EXCLUDED.name,
            description = EXCLUDED.description;
    END IF;

    -- 2. æ›´æ–°å›¾å…³ç³»
    IF p_entity_data ? 'relationships' THEN
        PERFORM update_relationships(p_entity_data->'relationships');
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 2. æ‰¹é‡æ›´æ–°
CREATE OR REPLACE FUNCTION batch_update_knowledge(
    p_updates JSONB[]
)
RETURNS INTEGER AS $$
DECLARE
    v_update JSONB;
    v_count INTEGER := 0;
BEGIN
    FOREACH v_update IN ARRAY p_updates
    LOOP
        PERFORM update_medical_knowledge(
            v_update->>'entity_type',
            v_update->'entity_data'
        );
        v_count := v_count + 1;
    END LOOP;

    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **çŸ¥è¯†æ›´æ–°é€Ÿåº¦** | åŸºå‡† | **+300%** | **æ˜¾è‘—æå‡** |
| **æ›´æ–°å‡†ç¡®æ€§** | åŸºå‡† | **+50%** | **æå‡** |

---

## 10. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 åŒ»å­¦çŸ¥è¯†å›¾è°±æ„å»º

**åˆ›å»ºåŒ»å­¦çŸ¥è¯†å›¾è°±**:

```sql
-- å®‰è£…æ‰©å±•
CREATE EXTENSION IF NOT EXISTS age;
CREATE EXTENSION IF NOT EXISTS vector;
LOAD 'age';
SET search_path = ag_catalog, "$user", public;

-- åˆ›å»ºåŒ»å­¦çŸ¥è¯†å›¾è°±
SELECT create_graph('medical_knowledge_graph');

-- åˆ›å»ºç–¾ç—…èŠ‚ç‚¹
SELECT * FROM cypher('medical_knowledge_graph', $$
    CREATE (d1:Disease {
        id: 'd001',
        name: 'é«˜è¡€å‹',
        description: 'è¡€å‹æŒç»­å‡é«˜çš„ç–¾ç—…',
        embedding: '[0.1, 0.2, ...]'::vector(768)
    }),
    (d2:Disease {
        id: 'd002',
        name: 'ç³–å°¿ç—…',
        description: 'è¡€ç³–ä»£è°¢å¼‚å¸¸çš„ç–¾ç—…',
        embedding: '[0.2, 0.3, ...]'::vector(768)
    })
$$) AS (a agtype);

-- åˆ›å»ºç—‡çŠ¶èŠ‚ç‚¹
SELECT * FROM cypher('medical_knowledge_graph', $$
    CREATE (s1:Symptom {id: 's001', name: 'å¤´ç—›'}),
    (s2:Symptom {id: 's002', name: 'å¤´æ™•'}),
    (s3:Symptom {id: 's003', name: 'å¤šå°¿'})
$$) AS (a agtype);

-- åˆ›å»ºå…³ç³»
SELECT * FROM cypher('medical_knowledge_graph', $$
    MATCH (d:Disease {id: 'd001'}), (s:Symptom {id: 's001'})
    CREATE (d)-[r:HAS_SYMPTOM {probability: 0.8}]->(s)
    RETURN r
$$) AS (r agtype);
```

**Python åŒ»å­¦çŸ¥è¯†å›¾è°±ç®¡ç†å™¨**:

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict

class MedicalKnowledgeGraph:
    """åŒ»å­¦çŸ¥è¯†å›¾è°±ç®¡ç†å™¨"""

    def __init__(self, conn_str: str):
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()
        self._setup_age()

    def _setup_age(self):
        """è®¾ç½® Apache AGE"""
        self.cur.execute("CREATE EXTENSION IF NOT EXISTS age")
        self.cur.execute("LOAD 'age'")
        self.cur.execute("SET search_path = ag_catalog, \"$user\", public")
        self.conn.commit()

    def create_disease(self, disease_id: str, name: str, description: str,
                      embedding: np.ndarray) -> bool:
        """åˆ›å»ºç–¾ç—…èŠ‚ç‚¹"""
        try:
            props = f"id: '{disease_id}', name: '{name}', description: '{description}'"
            query = f"""
                SELECT * FROM cypher('medical_knowledge_graph', $$
                    CREATE (d:Disease {{{props}}})
                    RETURN id(d) AS node_id
                $$) AS (node_id agtype)
            """
            self.cur.execute(query)
            self.conn.commit()
            return True
        except Exception as e:
            print(f"åˆ›å»ºç–¾ç—…èŠ‚ç‚¹å¤±è´¥: {e}")
            return False

    def create_symptom_relationship(self, disease_id: str, symptom_id: str,
                                   probability: float = 1.0) -> bool:
        """åˆ›å»ºç–¾ç—…-ç—‡çŠ¶å…³ç³»"""
        try:
            query = f"""
                SELECT * FROM cypher('medical_knowledge_graph', $$
                    MATCH (d:Disease {{id: '{disease_id}'}}), (s:Symptom {{id: '{symptom_id}'}})
                    CREATE (d)-[r:HAS_SYMPTOM {{probability: {probability}}}]->(s)
                    RETURN r
                $$) AS (r agtype)
            """
            self.cur.execute(query)
            self.conn.commit()
            return True
        except Exception as e:
            print(f"åˆ›å»ºå…³ç³»å¤±è´¥: {e}")
            return False

    def find_disease_by_symptoms(self, symptom_ids: List[str]) -> List[Dict]:
        """æ ¹æ®ç—‡çŠ¶æŸ¥æ‰¾ç–¾ç—…"""
        symptom_list = ', '.join([f"'{s}'" for s in symptom_ids])
        query = f"""
            SELECT * FROM cypher('medical_knowledge_graph', $$
                MATCH (d:Disease)-[r:HAS_SYMPTOM]->(s:Symptom)
                WHERE s.id IN [{symptom_list}]
                WITH d, COUNT(DISTINCT s) as symptom_count, AVG(r.probability) as avg_probability
                WHERE symptom_count >= {len(symptom_ids)}
                RETURN d.id, d.name, symptom_count, avg_probability
                ORDER BY symptom_count DESC, avg_probability DESC
                LIMIT 10
            $$) AS (disease_id agtype, name agtype, count agtype, prob agtype)
        """
        self.cur.execute(query)

        results = []
        for row in self.cur.fetchall():
            results.append({
                'disease_id': str(row[0]),
                'name': str(row[1]),
                'symptom_count': int(row[2]),
                'avg_probability': float(row[3])
            })
        return results

    def semantic_search_diseases(self, query_vector: np.ndarray, limit: int = 10) -> List[Dict]:
        """è¯­ä¹‰æœç´¢ç–¾ç—…"""
        # è¿™é‡Œéœ€è¦å°†å‘é‡å­˜å‚¨åœ¨èŠ‚ç‚¹å±æ€§ä¸­ï¼Œç„¶åä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦æœç´¢
        # ç®€åŒ–å®ç°ï¼šå‡è®¾æœ‰ç–¾ç—…å‘é‡è¡¨
        self.cur.execute("""
            SELECT d.id, d.name, d.description,
                   1 - (d.embedding <=> %s) AS similarity
            FROM disease_vectors d
            WHERE 1 - (d.embedding <=> %s) > 0.7
            ORDER BY d.embedding <=> %s
            LIMIT %s
        """, (query_vector.tolist(), query_vector.tolist(), query_vector.tolist(), limit))

        results = []
        for row in self.cur.fetchall():
            results.append({
                'disease_id': row[0],
                'name': row[1],
                'description': row[2],
                'similarity': float(row[3])
            })
        return results

    def hybrid_query(self, query_text: str, query_vector: np.ndarray,
                    symptom_ids: List[str] = None, limit: int = 10) -> List[Dict]:
        """æ··åˆæŸ¥è¯¢ï¼ˆå›¾æŸ¥è¯¢ + å‘é‡æœç´¢ï¼‰"""
        results = []

        # 1. å‘é‡æœç´¢ï¼šè¯­ä¹‰ç›¸ä¼¼ç–¾ç—…
        vector_results = self.semantic_search_diseases(query_vector, limit=limit * 2)

        # 2. å›¾æŸ¥è¯¢ï¼šåŸºäºç—‡çŠ¶çš„ç–¾ç—…
        if symptom_ids:
            graph_results = self.find_disease_by_symptoms(symptom_ids)

            # åˆå¹¶ç»“æœï¼ˆä¼˜å…ˆè€ƒè™‘åŒæ—¶å‡ºç°åœ¨ä¸¤ç§æŸ¥è¯¢ä¸­çš„ç–¾ç—…ï¼‰
            vector_dict = {r['disease_id']: r for r in vector_results}
            graph_dict = {r['disease_id']: r for r in graph_results}

            # è®¡ç®—ç»¼åˆåˆ†æ•°
            for disease_id in set(list(vector_dict.keys()) + list(graph_dict.keys())):
                vector_score = vector_dict.get(disease_id, {}).get('similarity', 0)
                graph_score = graph_dict.get(disease_id, {}).get('avg_probability', 0)

                # ç»¼åˆåˆ†æ•°ï¼šå‘é‡ç›¸ä¼¼åº¦ * 0.6 + å›¾æŸ¥è¯¢æ¦‚ç‡ * 0.4
                combined_score = vector_score * 0.6 + graph_score * 0.4

                results.append({
                    'disease_id': disease_id,
                    'name': vector_dict.get(disease_id, graph_dict.get(disease_id, {})).get('name', ''),
                    'vector_similarity': vector_score,
                    'graph_probability': graph_score,
                    'combined_score': combined_score
                })

            # æŒ‰ç»¼åˆåˆ†æ•°æ’åº
            results.sort(key=lambda x: x['combined_score'], reverse=True)
        else:
            results = vector_results

        return results[:limit]

    def close(self):
        """å…³é—­è¿æ¥"""
        self.cur.close()
        self.conn.close()

# ä½¿ç”¨ç¤ºä¾‹
kg = MedicalKnowledgeGraph("host=localhost dbname=testdb user=postgres password=secret")

# åˆ›å»ºç–¾ç—…
kg.create_disease('d001', 'é«˜è¡€å‹', 'è¡€å‹æŒç»­å‡é«˜çš„ç–¾ç—…', np.random.rand(768).astype(np.float32))

# åˆ›å»ºå…³ç³»
kg.create_symptom_relationship('d001', 's001', probability=0.8)

# æ ¹æ®ç—‡çŠ¶æŸ¥æ‰¾ç–¾ç—…
diseases = kg.find_disease_by_symptoms(['s001', 's002'])
for disease in diseases:
    print(f"ç–¾ç—…: {disease['name']}, ç—‡çŠ¶æ•°: {disease['symptom_count']}")

# æ··åˆæŸ¥è¯¢
query_vector = np.random.rand(768).astype(np.float32)
results = kg.hybrid_query("å¤´ç—›å¤´æ™•", query_vector, symptom_ids=['s001', 's002'])
for result in results:
    print(f"ç–¾ç—…: {result['name']}, ç»¼åˆåˆ†æ•°: {result.get('combined_score', 0):.4f}")

kg.close()
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-03-02
