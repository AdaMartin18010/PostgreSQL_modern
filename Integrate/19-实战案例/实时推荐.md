---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL\cases\å®æ—¶æ¨è.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹ï¼šå®æ—¶æ¨èï¼ˆå ä½ï¼‰

## æ¶æ„

- æµå¼ ETLï¼ˆKafka/CDCï¼‰â†’ PostgreSQL â†’ ç‰©åŒ–è§†å›¾/å¢é‡èšåˆ

## å…³é”®ç‚¹

- å»é‡ä¸çª—å£èšåˆã€çƒ­ç‚¹å†™å…¥ã€ç‰©åŒ–è§†å›¾åˆ·æ–°ç­–ç•¥

## éªŒè¯

- å»¶è¿Ÿã€ååã€èµ„æºå ç”¨ã€æ¨èå‡†ç¡®åº¦è¿‘ä¼¼æŒ‡æ ‡

## æœ€å°å¯å¤ç°ï¼ˆå ä½ï¼‰

```sql
CREATE TABLE events(user_id bigint, item_id bigint, ts timestamptz, score numeric);
CREATE MATERIALIZED VIEW mv_topk AS
SELECT item_id, count(*) AS cnt
FROM events WHERE ts > now() - interval '5 minutes'
GROUP BY item_id ORDER BY cnt DESC LIMIT 100;
-- åˆ·æ–°ç­–ç•¥ï¼šCONCURRENTLY + å®šæ—¶ä»»åŠ¡ï¼ˆç¤ºæ„ï¼‰
```

---

## 1. ç³»ç»Ÿæ¦‚è¿°

å®æ—¶æ¨èç³»ç»Ÿæ˜¯åŸºäºPostgreSQLæ„å»ºçš„é«˜æ€§èƒ½æ¨èç³»ç»Ÿï¼Œæ”¯æŒå®æ—¶æ•°æ®å¤„ç†å’Œæ¨èè®¡ç®—ã€‚

**ç³»ç»Ÿç‰¹ç‚¹**ï¼š

- **å®æ—¶æ€§** - æ”¯æŒå®æ—¶æ•°æ®å¤„ç†å’Œæ¨èæ›´æ–°
- **é«˜æ€§èƒ½** - åˆ©ç”¨PostgreSQLä¼˜åŒ–å®ç°é«˜ååé‡
- **å¯æ‰©å±•** - æ”¯æŒæ°´å¹³æ‰©å±•å’Œè´Ÿè½½å‡è¡¡
- **å‡†ç¡®æ€§** - åŸºäºå®æ—¶æ•°æ®æä¾›å‡†ç¡®æ¨è

---

## 2. æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```text
å®æ—¶æ¨èç³»ç»Ÿæ¶æ„
â”œâ”€â”€ æ•°æ®é‡‡é›†å±‚
â”‚   â”œâ”€â”€ Kafkaæ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”œâ”€â”€ CDCå˜æ›´æ•è·
â”‚   â””â”€â”€ å®æ—¶æ•°æ®æµ
â”œâ”€â”€ æ•°æ®å¤„ç†å±‚
â”‚   â”œâ”€â”€ PostgreSQLæµå¤„ç†
â”‚   â”œâ”€â”€ çª—å£èšåˆ
â”‚   â””â”€â”€ å»é‡å¤„ç†
â”œâ”€â”€ æ¨èè®¡ç®—å±‚
â”‚   â”œâ”€â”€ ç‰©åŒ–è§†å›¾
â”‚   â”œâ”€â”€ å¢é‡èšåˆ
â”‚   â””â”€â”€ æ¨èç®—æ³•
â””â”€â”€ æœåŠ¡æ¥å£å±‚
    â”œâ”€â”€ RESTful API
    â”œâ”€â”€ GraphQL API
    â””â”€â”€ WebSocketå®æ—¶æ¨é€
```

### 2.2 æ•°æ®æµè®¾è®¡

**æ•°æ®æµå¤„ç†æµç¨‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. åˆ›å»ºäº‹ä»¶è¡¨ï¼ˆå¸¦åˆ†åŒºï¼‰
CREATE TABLE events (
    user_id BIGINT NOT NULL,
    item_id BIGINT NOT NULL,
    ts TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    score NUMERIC,
    event_type TEXT,
    metadata JSONB
) PARTITION BY RANGE (ts);

-- åˆ›å»ºæ—¶é—´åˆ†åŒº
CREATE TABLE events_2024_01 PARTITION OF events
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 2. åˆ›å»ºç‰©åŒ–è§†å›¾ï¼ˆå®æ—¶TopKæ¨èï¼‰
CREATE MATERIALIZED VIEW mv_topk_recommendations AS
SELECT
    item_id,
    COUNT(*) AS interaction_count,
    AVG(score) AS avg_score,
    MAX(ts) AS last_interaction
FROM events
WHERE ts > NOW() - INTERVAL '5 minutes'
GROUP BY item_id
ORDER BY interaction_count DESC, avg_score DESC
LIMIT 100;

-- åˆ›å»ºå”¯ä¸€ç´¢å¼•ï¼ˆæ”¯æŒCONCURRENTåˆ·æ–°ï¼‰
CREATE UNIQUE INDEX mv_topk_recommendations_idx ON mv_topk_recommendations (item_id);

-- 3. è‡ªåŠ¨åˆ·æ–°ç‰©åŒ–è§†å›¾ï¼ˆä½¿ç”¨pg_cronï¼‰
CREATE EXTENSION IF NOT EXISTS pg_cron;

SELECT cron.schedule(
    'refresh-topk-recommendations',
    '*/1 * * * *',  -- æ¯åˆ†é’Ÿåˆ·æ–°
    'REFRESH MATERIALIZED VIEW CONCURRENTLY mv_topk_recommendations;'
);
```

---

## 3. æ ¸å¿ƒå®ç°

### 3.1 æµå¼ETLå¤„ç†

**æµå¼ETLå¤„ç†å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æµå¼äº‹ä»¶å¤„ç†å‡½æ•°
CREATE OR REPLACE FUNCTION process_realtime_event(
    p_user_id BIGINT,
    p_item_id BIGINT,
    p_score NUMERIC,
    p_event_type TEXT DEFAULT 'view'
)
RETURNS TABLE (
    processed BOOLEAN,
    processing_time_ms NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
BEGIN
    start_time := clock_timestamp();

    -- æ’å…¥äº‹ä»¶
    INSERT INTO events (user_id, item_id, score, event_type)
    VALUES (p_user_id, p_item_id, p_score, p_event_type);

    -- è§¦å‘ç‰©åŒ–è§†å›¾å¢é‡æ›´æ–°ï¼ˆå¦‚æœä½¿ç”¨å¢é‡ç‰©åŒ–è§†å›¾ï¼‰
    -- è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥ä½¿ç”¨å¢é‡æ›´æ–°æœºåˆ¶

    end_time := clock_timestamp();

    RETURN QUERY SELECT
        TRUE,
        EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT
            FALSE,
            NULL::NUMERIC;
END;
$$ LANGUAGE plpgsql;

-- æ‰¹é‡å¤„ç†äº‹ä»¶
CREATE OR REPLACE FUNCTION batch_process_events(
    p_events JSONB[]
)
RETURNS TABLE (
    processed_count BIGINT,
    failed_count BIGINT,
    avg_processing_time_ms NUMERIC
) AS $$
DECLARE
    event_record JSONB;
    processed BIGINT := 0;
    failed BIGINT := 0;
    total_time NUMERIC := 0;
    processing_time NUMERIC;
BEGIN
    FOREACH event_record IN ARRAY p_events
    LOOP
        SELECT processing_time_ms INTO processing_time
        FROM process_realtime_event(
            (event_record->>'user_id')::BIGINT,
            (event_record->>'item_id')::BIGINT,
            (event_record->>'score')::NUMERIC,
            event_record->>'event_type'
        );

        IF processing_time IS NOT NULL THEN
            processed := processed + 1;
            total_time := total_time + processing_time;
        ELSE
            failed := failed + 1;
        END IF;
    END LOOP;

    RETURN QUERY SELECT
        processed,
        failed,
        CASE WHEN processed > 0 THEN total_time / processed ELSE 0 END;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ‰¹é‡å¤„ç†äº‹ä»¶å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 å»é‡ä¸çª—å£èšåˆ

**å»é‡å’Œçª—å£èšåˆå®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å»é‡å¤„ç†ï¼ˆåŸºäºç”¨æˆ·-ç‰©å“å¯¹å’Œæ—¶é—´çª—å£ï¼‰
CREATE OR REPLACE FUNCTION deduplicate_events(
    p_window_minutes INT DEFAULT 5
)
RETURNS TABLE (
    removed_count BIGINT
) AS $$
DECLARE
    removed_rows BIGINT;
BEGIN
    -- åˆ é™¤æ—¶é—´çª—å£å†…çš„é‡å¤äº‹ä»¶ï¼ˆä¿ç•™æœ€æ–°çš„ï¼‰
    WITH ranked_events AS (
        SELECT ctid,
               ROW_NUMBER() OVER (
                   PARTITION BY user_id, item_id
                   ORDER BY ts DESC
               ) AS rn
        FROM events
        WHERE ts > NOW() - (p_window_minutes || ' minutes')::INTERVAL
    )
    DELETE FROM events
    WHERE ctid IN (
        SELECT ctid FROM ranked_events WHERE rn > 1
    );

    GET DIAGNOSTICS removed_rows = ROW_COUNT;

    RETURN QUERY SELECT removed_rows;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å»é‡å¤„ç†å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- çª—å£èšåˆï¼ˆæ»‘åŠ¨çª—å£ï¼‰
CREATE OR REPLACE FUNCTION window_aggregation(
    p_window_minutes INT DEFAULT 5
)
RETURNS TABLE (
    item_id BIGINT,
    interaction_count BIGINT,
    avg_score NUMERIC,
    unique_users BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        e.item_id,
        COUNT(*) AS interaction_count,
        AVG(e.score) AS avg_score,
        COUNT(DISTINCT e.user_id) AS unique_users
    FROM events e
    WHERE e.ts > NOW() - (p_window_minutes || ' minutes')::INTERVAL
    GROUP BY e.item_id
    ORDER BY interaction_count DESC, avg_score DESC
    LIMIT 100;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'çª—å£èšåˆå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 çƒ­ç‚¹å†™å…¥ä¼˜åŒ–

**çƒ­ç‚¹å†™å…¥ä¼˜åŒ–ç­–ç•¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. ä½¿ç”¨è¿æ¥æ± å‡å°‘è¿æ¥å¼€é”€
-- é…ç½®PgBounceræˆ–ä½¿ç”¨å†…ç½®è¿æ¥æ± 

-- 2. æ‰¹é‡æ’å…¥ä¼˜åŒ–
CREATE OR REPLACE FUNCTION batch_insert_events(
    p_events JSONB[]
)
RETURNS TABLE (
    inserted_count BIGINT,
    duration_ms NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    inserted_rows BIGINT;
BEGIN
    start_time := clock_timestamp();

    -- ä½¿ç”¨COPYè¿›è¡Œæ‰¹é‡æ’å…¥ï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
    INSERT INTO events (user_id, item_id, score, event_type, ts)
    SELECT
        (e->>'user_id')::BIGINT,
        (e->>'item_id')::BIGINT,
        (e->>'score')::NUMERIC,
        e->>'event_type',
        COALESCE((e->>'ts')::TIMESTAMPTZ, NOW())
    FROM unnest(p_events) AS e;

    GET DIAGNOSTICS inserted_rows = ROW_COUNT;
    end_time := clock_timestamp();

    RETURN QUERY SELECT
        inserted_rows,
        EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ‰¹é‡æ’å…¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 3. ç´¢å¼•ä¼˜åŒ–ï¼ˆé¿å…çƒ­ç‚¹ï¼‰
CREATE INDEX idx_events_ts_item ON events (ts DESC, item_id)
WHERE ts > NOW() - INTERVAL '1 hour';  -- éƒ¨åˆ†ç´¢å¼•

-- 4. åˆ†åŒºä¼˜åŒ–ï¼ˆæŒ‰æ—¶é—´åˆ†åŒºï¼Œå‡å°‘é”ç«äº‰ï¼‰
-- å·²åœ¨è¡¨å®šä¹‰ä¸­å®ç°
```

### 4.2 ç‰©åŒ–è§†å›¾åˆ·æ–°ç­–ç•¥

**ç‰©åŒ–è§†å›¾åˆ·æ–°ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¢é‡åˆ·æ–°ç‰©åŒ–è§†å›¾ï¼ˆPostgreSQL 14+ï¼‰
-- éœ€è¦åˆ›å»ºå”¯ä¸€ç´¢å¼•ï¼ˆå·²åœ¨å‰é¢åˆ›å»ºï¼‰

-- åˆ·æ–°å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
CREATE OR REPLACE FUNCTION refresh_recommendations()
RETURNS TABLE (
    refresh_status TEXT,
    refresh_duration_ms NUMERIC,
    items_count BIGINT
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    items_count_val BIGINT;
BEGIN
    start_time := clock_timestamp();

    -- CONCURRENTåˆ·æ–°ï¼ˆä¸é˜»å¡æŸ¥è¯¢ï¼‰
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_topk_recommendations;

    end_time := clock_timestamp();

    SELECT COUNT(*) INTO items_count_val
    FROM mv_topk_recommendations;

    RETURN QUERY SELECT
        'SUCCESS'::TEXT,
        EXTRACT(EPOCH FROM (end_time - start_time)) * 1000,
        items_count_val;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT
            format('FAILED: %', SQLERRM)::TEXT,
            NULL::NUMERIC,
            NULL::BIGINT;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶åˆ·æ–°ï¼ˆä½¿ç”¨pg_cronï¼‰
SELECT cron.schedule(
    'refresh-recommendations',
    '*/1 * * * *',  -- æ¯åˆ†é’Ÿåˆ·æ–°
    'SELECT * FROM refresh_recommendations();'
);
```

---

## 5. éªŒè¯ä¸æµ‹è¯•

### 5.1 æ€§èƒ½æµ‹è¯•

**æ€§èƒ½æµ‹è¯•è„šæœ¬ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½åˆ†æï¼‰**ï¼š

```sql
-- å»¶è¿Ÿæµ‹è¯•
CREATE OR REPLACE FUNCTION test_recommendation_latency(
    p_iterations INT DEFAULT 100
)
RETURNS TABLE (
    avg_latency_ms NUMERIC,
    p95_latency_ms NUMERIC,
    p99_latency_ms NUMERIC
) AS $$
DECLARE
    latencies NUMERIC[];
    i INT;
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    latency_ms NUMERIC;
BEGIN
    latencies := ARRAY[]::NUMERIC[];

    FOR i IN 1..p_iterations LOOP
        start_time := clock_timestamp();

        -- æ‰§è¡Œæ¨èæŸ¥è¯¢
        PERFORM * FROM mv_topk_recommendations LIMIT 10;

        end_time := clock_timestamp();
        latency_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
        latencies := array_append(latencies, latency_ms);
    END LOOP;

    RETURN QUERY SELECT
        ROUND(AVG(unnest), 2),
        ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY unnest), 2),
        ROUND(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY unnest), 2)
    FROM unnest(latencies) AS unnest;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å»¶è¿Ÿæµ‹è¯•å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- ååé‡æµ‹è¯•
CREATE OR REPLACE FUNCTION test_throughput(
    p_duration_seconds INT DEFAULT 60,
    p_batch_size INT DEFAULT 100
)
RETURNS TABLE (
    total_events BIGINT,
    events_per_second NUMERIC,
    avg_latency_ms NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    total_processed BIGINT := 0;
    batch_data JSONB[];
    i INT;
BEGIN
    start_time := clock_timestamp();
    end_time := start_time + (p_duration_seconds || ' seconds')::INTERVAL;

    -- ç”Ÿæˆæµ‹è¯•æ•°æ®
    batch_data := ARRAY(
        SELECT json_build_object(
            'user_id', (random() * 10000)::INT,
            'item_id', (random() * 1000)::INT,
            'score', random() * 5,
            'event_type', 'view'
        )
        FROM generate_series(1, p_batch_size)
    );

    WHILE clock_timestamp() < end_time LOOP
        PERFORM batch_insert_events(batch_data);
        total_processed := total_processed + p_batch_size;
    END LOOP;

    RETURN QUERY SELECT
        total_processed,
        ROUND(total_processed::NUMERIC / p_duration_seconds, 2),
        NULL::NUMERIC;  -- ç®€åŒ–å¤„ç†

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ååé‡æµ‹è¯•å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 æ¨èå‡†ç¡®åº¦éªŒè¯

**æ¨èå‡†ç¡®åº¦éªŒè¯ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ¨èå‡†ç¡®åº¦è¯„ä¼°
CREATE OR REPLACE FUNCTION evaluate_recommendation_accuracy(
    p_test_users BIGINT[],
    p_top_k INT DEFAULT 10
)
RETURNS TABLE (
    user_id BIGINT,
    precision_at_k NUMERIC,
    recall_at_k NUMERIC,
    f1_score NUMERIC
) AS $$
DECLARE
    user_id_val BIGINT;
    recommended_items BIGINT[];
    actual_items BIGINT[];
    intersection_count INT;
BEGIN
    FOREACH user_id_val IN ARRAY p_test_users
    LOOP
        -- è·å–æ¨èç‰©å“
        SELECT ARRAY_AGG(item_id) INTO recommended_items
        FROM mv_topk_recommendations
        LIMIT p_top_k;

        -- è·å–ç”¨æˆ·å®é™…äº¤äº’ç‰©å“
        SELECT ARRAY_AGG(DISTINCT item_id) INTO actual_items
        FROM events
        WHERE user_id = user_id_val
          AND ts > NOW() - INTERVAL '1 day';

        -- è®¡ç®—äº¤é›†
        SELECT COUNT(*) INTO intersection_count
        FROM unnest(recommended_items) AS item
        WHERE item = ANY(actual_items);

        -- è®¡ç®—æŒ‡æ ‡
        RETURN QUERY SELECT
            user_id_val,
            CASE
                WHEN array_length(recommended_items, 1) > 0
                THEN ROUND(intersection_count::NUMERIC / array_length(recommended_items, 1), 4)
                ELSE 0
            END,
            CASE
                WHEN array_length(actual_items, 1) > 0
                THEN ROUND(intersection_count::NUMERIC / array_length(actual_items, 1), 4)
                ELSE 0
            END,
            CASE
                WHEN array_length(recommended_items, 1) > 0 AND array_length(actual_items, 1) > 0
                THEN ROUND(
                    2.0 * intersection_count /
                    (array_length(recommended_items, 1) + array_length(actual_items, 1)),
                    4
                )
                ELSE 0
            END;
    END LOOP;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ¨èå‡†ç¡®åº¦è¯„ä¼°å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. ç›‘æ§ä¸è¯Šæ–­

### 6.1 æ€§èƒ½ç›‘æ§

**æ€§èƒ½ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- åˆ›å»ºæ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_recommendation_performance AS
SELECT
    'events' AS metric_name,
    COUNT(*) AS current_value,
    COUNT(*) FILTER (WHERE ts > NOW() - INTERVAL '1 minute') AS value_1min,
    COUNT(*) FILTER (WHERE ts > NOW() - INTERVAL '5 minutes') AS value_5min
FROM events
UNION ALL
SELECT
    'recommendations' AS metric_name,
    COUNT(*) AS current_value,
    NULL::BIGINT AS value_1min,
    NULL::BIGINT AS value_5min
FROM mv_topk_recommendations;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_recommendation_performance;
```

### 6.2 èµ„æºä½¿ç”¨ç›‘æ§

**èµ„æºä½¿ç”¨ç›‘æ§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- èµ„æºä½¿ç”¨ç›‘æ§
CREATE OR REPLACE FUNCTION monitor_resource_usage()
RETURNS TABLE (
    table_name TEXT,
    table_size TEXT,
    index_size TEXT,
    total_size TEXT,
    row_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'events'::TEXT,
        pg_size_pretty(pg_relation_size('events'))::TEXT,
        pg_size_pretty(pg_indexes_size('events'))::TEXT,
        pg_size_pretty(pg_total_relation_size('events'))::TEXT,
        (SELECT COUNT(*) FROM events)::BIGINT
    UNION ALL
    SELECT
        'mv_topk_recommendations'::TEXT,
        pg_size_pretty(pg_relation_size('mv_topk_recommendations'))::TEXT,
        pg_size_pretty(pg_indexes_size('mv_topk_recommendations'))::TEXT,
        pg_size_pretty(pg_total_relation_size('mv_topk_recommendations'))::TEXT,
        (SELECT COUNT(*) FROM mv_topk_recommendations)::BIGINT;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'èµ„æºä½¿ç”¨ç›‘æ§å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢èµ„æºä½¿ç”¨
SELECT * FROM monitor_resource_usage();
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [07-å®æ—¶æ¨èç³»ç»Ÿ/](./07-å®æ—¶æ¨èç³»ç»Ÿ/) - å®æ—¶æ¨èç³»ç»Ÿå®Œæ•´æ¡ˆä¾‹
- [08-æµå¤„ç†ä¸æ—¶åº/](../08-æµå¤„ç†ä¸æ—¶åº/README.md) - æµå¤„ç†ä¸æ—¶åºæ•°æ®
- [19-å®æˆ˜æ¡ˆä¾‹/README.md](./README.md) - å®æˆ˜æ¡ˆä¾‹ä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
