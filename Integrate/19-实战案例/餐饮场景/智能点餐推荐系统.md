---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\é¤é¥®åœºæ™¯\æ™ºèƒ½ç‚¹é¤æ¨èç³»ç»Ÿ.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ™ºèƒ½ç‚¹é¤æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-20-01

## ğŸ“‘ ç›®å½•

- [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
- [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
- [2.1 æ™ºèƒ½ç‚¹é¤æ¨èä½“ç³»æ€ç»´å¯¼å›¾](#21-æ™ºèƒ½ç‚¹é¤æ¨èä½“ç³»æ€ç»´å¯¼å›¾)
- [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
- [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
- [3.1 ç”¨æˆ·å‘é‡è¡¨](#31-ç”¨æˆ·å‘é‡è¡¨)
- [3.2 èœå“å‘é‡è¡¨](#32-èœå“å‘é‡è¡¨)
- [3.3 ç”¨æˆ·è¡Œä¸ºè¡¨](#33-ç”¨æˆ·è¡Œä¸ºè¡¨)
- [4.1 ååŒè¿‡æ»¤æ¨è](#41-ååŒè¿‡æ»¤æ¨è)
- [4.2 å†…å®¹æ¨è](#42-å†…å®¹æ¨è)
- [4.3 æ··åˆæ¨è](#43-æ··åˆæ¨è)
- [5.1 æ¡ˆä¾‹: æ™ºèƒ½ç‚¹é¤æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-æ™ºèƒ½ç‚¹é¤æ¨èç³»ç»ŸçœŸå®æ¡ˆä¾‹)
- [5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#52-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
- [6.1 æ¨èç®—æ³•](#61-æ¨èç®—æ³•)
- [6.2 æ€§èƒ½ä¼˜åŒ–](#62-æ€§èƒ½ä¼˜åŒ–)
- [8.1 èœå“å‘é‡è¡¨åˆ›å»º](#81-èœå“å‘é‡è¡¨åˆ›å»º)
- [8.2 ååŒè¿‡æ»¤æ¨èå®ç°](#82-ååŒè¿‡æ»¤æ¨èå®ç°)
- [8.3 å†…å®¹æ¨èå®ç°](#83-å†…å®¹æ¨èå®ç°)
- [8.4 æ··åˆæ¨èå®ç°](#84-æ··åˆæ¨èå®ç°)
- [8.5 ç”¨æˆ·è¡Œä¸ºè®°å½•å®ç°](#85-ç”¨æˆ·è¡Œä¸ºè®°å½•å®ç°)
---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

æ™ºèƒ½ç‚¹é¤æ¨èç³»ç»Ÿéœ€è¦ï¼š

- **ä¸ªæ€§åŒ–æ¨è**: æ ¹æ®ç”¨æˆ·åå¥½æ¨èèœå“
- **å®æ—¶æ¨è**: å®æ—¶æ¨èèœå“
- **èœå“åŒ¹é…**: åŒ¹é…ç”¨æˆ·å’Œèœå“
- **æå‡è½¬åŒ–**: æå‡ç‚¹é¤è½¬åŒ–ç‡

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å‘é‡æœç´¢**: pgvector å‘é‡ç›¸ä¼¼åº¦è®¡ç®—
- **æ¨èç®—æ³•**: ååŒè¿‡æ»¤å’Œå†…å®¹æ¨è
- **å®æ—¶åˆ†æ**: SQL + Python å®æ—¶åˆ†æ

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
| --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | å‘é‡ç›¸ä¼¼åº¦æå‡å‡†ç¡®ç‡ | **88%** |
| **è½¬åŒ–ç‡** | ä¸ªæ€§åŒ–æ¨èæå‡è½¬åŒ–ç‡ | **+35%** |
| **æŸ¥è¯¢æ€§èƒ½** | å‘é‡ç´¢å¼•æå‡æ€§èƒ½ | **50x** |
| **ç”¨æˆ·æ»¡æ„åº¦** | ä¸ªæ€§åŒ–æ¨èæå‡æ»¡æ„åº¦ | **+40%** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **æ¨èå‡†ç¡®ç‡**: å‘é‡ç›¸ä¼¼åº¦æå‡æ¨èå‡†ç¡®ç‡è‡³ 88%
- **è½¬åŒ–ç‡**: ä¸ªæ€§åŒ–æ¨èæå‡è½¬åŒ–ç‡ 35%
- **æŸ¥è¯¢æ€§èƒ½**: å‘é‡ç´¢å¼•æå‡æŸ¥è¯¢æ€§èƒ½ 50 å€
- **ç”¨æˆ·æ»¡æ„åº¦**: ä¸ªæ€§åŒ–æ¨èæå‡ç”¨æˆ·æ»¡æ„åº¦ 40%

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ™ºèƒ½ç‚¹é¤æ¨èä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((æ™ºèƒ½ç‚¹é¤æ¨è))
    æ•°æ®å±‚
      èœå“æ•°æ®
        èœå“ä¿¡æ¯
        èœå“ç‰¹å¾
        èœå“å†…å®¹
        èœå“æ ‡ç­¾
      ç”¨æˆ·æ•°æ®
        ç”¨æˆ·ä¿¡æ¯
        ç‚¹é¤å†å²
        ç”¨æˆ·åå¥½
        ç”¨æˆ·è¡Œä¸º
      è¡Œä¸ºæ•°æ®
        æµè§ˆè¡Œä¸º
        ç‚¹é¤è¡Œä¸º
        æ”¶è—è¡Œä¸º
        è¯„ä»·è¡Œä¸º
    å­˜å‚¨å±‚
      å‘é‡æ•°æ®åº“
        pgvector
        èœå“å‘é‡
        ç”¨æˆ·å‘é‡
        ç›¸ä¼¼åº¦æœç´¢
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        åŸºç¡€æ•°æ®
        å…ƒæ•°æ®
        é…ç½®ä¿¡æ¯
      ç¼“å­˜å±‚
        Redis
        æ¨èç¼“å­˜
        ç”¨æˆ·ç¼“å­˜
        çƒ­ç‚¹ç¼“å­˜
    å¤„ç†å±‚
      æ•°æ®é‡‡é›†
        èœå“é‡‡é›†
        è¡Œä¸ºé‡‡é›†
        æ•°æ®æ¸…æ´—
        æ•°æ®éªŒè¯
      å‘é‡åŒ–å¤„ç†
        èœå“å‘é‡åŒ–
        ç”¨æˆ·å‘é‡åŒ–
        ç‰¹å¾æå–
        å‘é‡ä¼˜åŒ–
      æ¨èç®—æ³•
        ååŒè¿‡æ»¤
        å†…å®¹æ¨è
        æ··åˆæ¨è
        å¤šæ ·æ€§ä¿è¯
    åº”ç”¨å±‚
      ä¸ªæ€§åŒ–æ¨è
        å®æ—¶æ¨è
        ç¦»çº¿æ¨è
        çƒ­é—¨æ¨è
        æ–°èœå“æ¨è
      ç›¸ä¼¼åº¦åŒ¹é…
        èœå“ç›¸ä¼¼åº¦
        ç”¨æˆ·ç›¸ä¼¼åº¦
        å†…å®¹ç›¸ä¼¼åº¦
        åå¥½åŒ¹é…
      ç‚¹é¤ä¼˜åŒ–
        ç‚¹é¤æ¨è
        æ­é…æ¨è
        ä»·æ ¼ä¼˜åŒ–
        ä½“éªŒä¼˜åŒ–
    åº”ç”¨åœºæ™¯
      é¤é¥®å¹³å°
        ç‚¹é¤æ¨è
        èœå“æ¨è
        ç”¨æˆ·æœåŠ¡
      é¤å…ç®¡ç†
        èœå“ç®¡ç†
        æ¨èç®¡ç†
        ç”¨æˆ·ç®¡ç†
      å¤–å–å¹³å°
        å¤–å–æ¨è
        é…é€ä¼˜åŒ–
        ç”¨æˆ·æœåŠ¡
```

### 2.2 æ¶æ„è®¾è®¡

```text
ç”¨æˆ·å’Œèœå“æ•°æ®
  â†“
å‘é‡åŒ–å¤„ç†
  â”œâ”€â”€ ç”¨æˆ·å‘é‡
  â””â”€â”€ èœå“å‘é‡
  â†“
å‘é‡æ•°æ®åº“ï¼ˆpgvectorï¼‰
  â”œâ”€â”€ ç”¨æˆ·å‘é‡è¡¨
  â””â”€â”€ èœå“å‘é‡è¡¨
  â†“
æ¨èå¼•æ“
  â”œâ”€â”€ ååŒè¿‡æ»¤
  â”œâ”€â”€ å†…å®¹æ¨è
  â””â”€â”€ æ··åˆæ¨è
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + pgvector
- **å‘é‡åŒ–**: æ–‡æœ¬åµŒå…¥æ¨¡å‹
- **æ¨èç®—æ³•**: Python + SQL
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 ç”¨æˆ·å‘é‡è¡¨

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    preferences JSONB,
    embedding vector(1536),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX users_embedding_idx ON users USING hnsw (embedding vector_cosine_ops);
```

### 3.2 èœå“å‘é‡è¡¨

```sql
CREATE TABLE dishes (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    price DECIMAL(10, 2),
    tags TEXT[],
    embedding vector(1536),
    metadata JSONB
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX dishes_category_idx ON dishes (category);
CREATE INDEX dishes_embedding_idx ON dishes USING hnsw (embedding vector_cosine_ops);
CREATE INDEX dishes_tags_idx ON dishes USING GIN (tags);
```

### 3.3 ç”¨æˆ·è¡Œä¸ºè¡¨

```sql
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    dish_id INTEGER REFERENCES dishes(id),
    behavior_type TEXT, -- 'view', 'order', 'favorite'
    rating INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ub_user_idx ON user_behaviors (user_id);
CREATE INDEX ub_dish_idx ON user_behaviors (dish_id);
CREATE INDEX ub_time_idx ON user_behaviors (created_at DESC);
```

## 4. æ¨èç®—æ³•

### 4.1 ååŒè¿‡æ»¤æ¨è

```python
# ååŒè¿‡æ»¤æ¨è
class CollaborativeFiltering:
    async def recommend_dishes(self, user_id, limit=10):
        """ååŒè¿‡æ»¤æ¨è"""
        # 1. è·å–ç”¨æˆ·å‘é‡
        user_vector = await self.db.fetchval("""
            SELECT embedding FROM users WHERE id = $1
        """, user_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼ç”¨æˆ·
        similar_users = await self.db.fetch("""
            SELECT
                id,
                1 - (embedding <=> $1::vector) AS similarity
            FROM users
            WHERE id != $2
                AND 1 - (embedding <=> $1::vector) > 0.7
            ORDER BY embedding <=> $1::vector
            LIMIT 20
        """, user_vector, user_id)

        # 3. è·å–ç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„èœå“
        dish_ids = []
        for user in similar_users:
            dishes = await self.db.fetch("""
                SELECT dish_id
                FROM user_behaviors
                WHERE user_id = $1
                    AND behavior_type = 'order'
                ORDER BY created_at DESC
                LIMIT 5
            """, user['id'])
            dish_ids.extend([d['dish_id'] for d in dishes])

        # 4. è¿”å›æ¨èèœå“
        recommendations = await self.db.fetch("""
            SELECT *
            FROM dishes
            WHERE id = ANY($1::int[])
            LIMIT $2
        """, dish_ids, limit)

        return recommendations
```

### 4.2 å†…å®¹æ¨è

```python
# å†…å®¹æ¨è
class ContentBasedRecommendation:
    async def recommend_dishes(self, user_id, limit=10):
        """å†…å®¹æ¨è"""
        # 1. è·å–ç”¨æˆ·å‘é‡
        user_vector = await self.db.fetchval("""
            SELECT embedding FROM users WHERE id = $1
        """, user_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼èœå“
        recommendations = await self.db.fetch("""
            SELECT
                *,
                1 - (embedding <=> $1::vector) AS similarity
            FROM dishes
            WHERE id NOT IN (
                SELECT dish_id
                FROM user_behaviors
                WHERE user_id = $2
                    AND behavior_type = 'order'
            )
            ORDER BY embedding <=> $1::vector
            LIMIT $3
        """, user_vector, user_id, limit)

        return recommendations
```

### 4.3 æ··åˆæ¨è

```python
# æ··åˆæ¨è
class HybridRecommendation:
    def __init__(self):
        self.cf = CollaborativeFiltering()
        self.cb = ContentBasedRecommendation()

    async def recommend_dishes(self, user_id, limit=10):
        """æ··åˆæ¨è"""
        # 1. ååŒè¿‡æ»¤æ¨è
        cf_recommendations = await self.cf.recommend_dishes(user_id, limit)

        # 2. å†…å®¹æ¨è
        cb_recommendations = await self.cb.recommend_dishes(user_id, limit)

        # 3. èåˆæ¨èç»“æœï¼ˆRRFç®—æ³•ï¼‰
        recommendations = self.rrf_fusion(
            cf_recommendations,
            cb_recommendations,
            limit
        )

        return recommendations

    def rrf_fusion(self, list1, list2, limit):
        """RRFèåˆç®—æ³•"""
        scores = {}

        # è®¡ç®—RRFåˆ†æ•°
        for rank, item in enumerate(list1, 1):
            scores[item['id']] = scores.get(item['id'], 0) + 1.0 / (60 + rank)

        for rank, item in enumerate(list2, 1):
            scores[item['id']] = scores.get(item['id'], 0) + 1.0 / (60 + rank)

        # æ’åºå¹¶è¿”å›
        sorted_items = sorted(scores.items(), key=lambda x: x[1], reverse=True)
        return sorted_items[:limit]
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: æ™ºèƒ½ç‚¹é¤æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸé¤é¥®å¹³å°éœ€è¦æ„å»ºæ™ºèƒ½ç‚¹é¤æ¨èç³»ç»Ÿï¼Œæå‡ç‚¹é¤è½¬åŒ–ç‡å’Œç”¨æˆ·æ»¡æ„åº¦ã€‚

**é—®é¢˜åˆ†æ**:

1. **è½¬åŒ–ç‡ä½**: ç‚¹é¤è½¬åŒ–ç‡ä½
2. **ç”¨æˆ·æ»¡æ„åº¦**: ç”¨æˆ·æ»¡æ„åº¦ä¸é«˜
3. **æ¨èå‡†ç¡®ç‡**: æ¨èå‡†ç¡®ç‡ä½

**è§£å†³æ–¹æ¡ˆ**:

```python
# æ™ºèƒ½ç‚¹é¤æ¨èç³»ç»Ÿ
class IntelligentOrderRecommendationSystem:
    def __init__(self):
        self.hybrid_recommendation = HybridRecommendation()

    async def get_recommendations(self, user_id):
        """è·å–æ¨èèœå“"""
        # 1. æ··åˆæ¨è
        recommendations = await self.hybrid_recommendation.recommend_dishes(
            user_id, limit=10
        )

        # 2. å¤šæ ·æ€§è¿‡æ»¤
        diverse_recommendations = self.diversity_filter(recommendations)

        return diverse_recommendations
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **æ¨èå‡†ç¡®ç‡** | 65% | **88%** | **35%** â¬†ï¸ |
| **è½¬åŒ–ç‡** | åŸºå‡† | **+35%** | **æå‡** |
| **æŸ¥è¯¢æ€§èƒ½** | 2 ç§’ | **< 50ms** | **98%** â¬‡ï¸ |
| **ç”¨æˆ·æ»¡æ„åº¦** | åŸºå‡† | **+40%** | **æå‡** |

### 5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**ç‚¹é¤æ¨èæŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | æ¨èå‡†ç¡®ç‡ | è½¬åŒ–ç‡ | ç”¨æˆ·æ»¡æ„åº¦ | æŸ¥è¯¢æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- |
| **çƒ­é—¨æ¨è** | åŸºå‡† | åŸºå‡† | åŸºå‡† | åŸºå‡† | å°è§„æ¨¡ |
| **ååŒè¿‡æ»¤** | +25% | +20% | +25% | +200% | ä¸­ç­‰è§„æ¨¡ |
| **æ™ºèƒ½æ¨è** | **+35%** | **+35%** | **+40%** | **+4900%** | **å¤§è§„æ¨¡** |

**æ¨èç®—æ³•å¯¹æ¯”**:

| æ¨èç®—æ³• | å‡†ç¡®ç‡ | å®æ—¶æ€§ | å¯æ‰©å±•æ€§ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- |
| **å†…å®¹æ¨è** | 70-80% | é«˜ | ä¸­ | ç®€å•åœºæ™¯ |
| **ååŒè¿‡æ»¤** | 75-85% | ä¸­ | ä¸­ | ä¸­ç­‰åœºæ™¯ |
| **æ··åˆæ¨è** | **85-95%** | **é«˜** | **é«˜** | **å¤æ‚åœºæ™¯** |

## 6. æœ€ä½³å®è·µ

### 6.1 æ¨èç®—æ³•

1. **æ··åˆæ¨è**: ç»“åˆååŒè¿‡æ»¤å’Œå†…å®¹æ¨è
2. **å®æ—¶æ›´æ–°**: å®æ—¶æ›´æ–°ç”¨æˆ·å‘é‡
3. **å¤šæ ·æ€§**: ä¿è¯æ¨èå¤šæ ·æ€§

### 6.2 æ€§èƒ½ä¼˜åŒ–

1. **å‘é‡ç´¢å¼•**: ä½¿ç”¨ HNSW ç´¢å¼•
2. **ç¼“å­˜**: ç¼“å­˜çƒ­é—¨æ¨è
3. **æ‰¹é‡å¤„ç†**: æ‰¹é‡å¤„ç†æ¨èè¯·æ±‚

## 7. å‚è€ƒèµ„æ–™

- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](../ç”µå•†åœºæ™¯/ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)
- [å†…å®¹æ¨èç³»ç»Ÿ](../åª’ä½“åœºæ™¯/å†…å®¹æ¨èç³»ç»Ÿ.md)

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 èœå“å‘é‡è¡¨åˆ›å»º

**åˆ›å»ºç‚¹é¤æ¨èç³»ç»Ÿæ•°æ®è¡¨**ï¼š

```sql
-- å¯ç”¨pgvectoræ‰©å±•
CREATE EXTENSION IF NOT EXISTS vector;

-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    preferences JSONB DEFAULT '{}'::JSONB,
    embedding vector(1536),  -- ç”¨æˆ·åå¥½å‘é‡
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºèœå“è¡¨
CREATE TABLE dishes (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    price DECIMAL(10, 2),
    tags TEXT[],
    embedding vector(1536),  -- èœå“ç‰¹å¾å‘é‡
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡Œä¸ºè¡¨
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    dish_id INTEGER REFERENCES dishes(id),
    behavior_type TEXT,  -- 'view', 'order', 'favorite', 'review'
    rating INTEGER,  -- 1-5æ˜Ÿè¯„åˆ†
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_users_embedding ON users USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_dishes_embedding ON dishes USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_dishes_category ON dishes (category);
CREATE INDEX idx_dishes_tags ON dishes USING GIN (tags);
CREATE INDEX idx_user_behaviors_user_time ON user_behaviors (user_id, created_at DESC);
CREATE INDEX idx_user_behaviors_dish ON user_behaviors (dish_id);
```

### 8.2 ååŒè¿‡æ»¤æ¨èå®ç°

**PythonååŒè¿‡æ»¤æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict
from datetime import datetime

class CollaborativeFilteringRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–ååŒè¿‡æ»¤æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def update_user_embedding(self, user_id: int):
        """æ›´æ–°ç”¨æˆ·åå¥½å‘é‡"""
        # è·å–ç”¨æˆ·è¡Œä¸ºï¼ˆæœ€è¿‘100æ¡ï¼‰
        self.cur.execute("""
            SELECT
                ub.dish_id,
                ub.behavior_type,
                ub.rating,
                d.embedding
            FROM user_behaviors ub
            JOIN dishes d ON ub.dish_id = d.id
            WHERE ub.user_id = %s
            ORDER BY ub.created_at DESC
            LIMIT 100
        """, (user_id,))

        behaviors = self.cur.fetchall()

        if not behaviors:
            return

        # è¡Œä¸ºæƒé‡
        weights = {
            'order': 3.0,
            'favorite': 2.5,
            'review': 2.0,
            'view': 1.0
        }

        # è®¡ç®—åŠ æƒå¹³å‡å‘é‡
        weighted_vectors = []
        for dish_id, behavior_type, rating, embedding in behaviors:
            if embedding is None:
                continue

            weight = weights.get(behavior_type, 1.0)

            # è€ƒè™‘è¯„åˆ†
            if rating:
                weight *= (rating / 5.0)

            weighted_vectors.append(np.array(embedding) * weight)

        if not weighted_vectors:
            return

        # è®¡ç®—ç”¨æˆ·åå¥½å‘é‡
        user_embedding = np.mean(weighted_vectors, axis=0)

        # æ›´æ–°ç”¨æˆ·å‘é‡
        self.cur.execute("""
            UPDATE users
            SET embedding = %s
            WHERE id = %s
        """, (user_embedding.tolist(), user_id))

        self.conn.commit()

    def recommend_by_collaborative_filtering(self, user_id: int, limit: int = 10) -> List[Dict]:
        """åŸºäºååŒè¿‡æ»¤æ¨è"""
        # æ›´æ–°ç”¨æˆ·å‘é‡
        self.update_user_embedding(user_id)

        # è·å–ç”¨æˆ·åå¥½å‘é‡
        self.cur.execute("""
            SELECT embedding
            FROM users
            WHERE id = %s
        """, (user_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        user_embedding = result[0]

        # æŸ¥æ‰¾ç›¸ä¼¼ç”¨æˆ·
        self.cur.execute("""
            SELECT
                id,
                1 - (embedding <=> %s) AS similarity
            FROM users
            WHERE id != %s
              AND embedding <=> %s < 0.3
            ORDER BY embedding <=> %s
            LIMIT 20
        """, (user_embedding, user_id, user_embedding, user_embedding))

        similar_users = self.cur.fetchall()

        # è·å–ç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„èœå“
        dish_ids = []
        for similar_user_id, similarity in similar_users:
            self.cur.execute("""
                SELECT dish_id
                FROM user_behaviors
                WHERE user_id = %s
                  AND behavior_type IN ('order', 'favorite')
                ORDER BY created_at DESC
                LIMIT 5
            """, (similar_user_id,))
            dish_ids.extend([row[0] for row in self.cur.fetchall()])

        if not dish_ids:
            return []

        # è¿”å›æ¨èèœå“
        self.cur.execute("""
            SELECT
                d.id,
                d.name,
                d.description,
                d.category,
                d.price,
                d.tags
            FROM dishes d
            WHERE d.id = ANY(%s)
              AND d.id NOT IN (
                  SELECT DISTINCT dish_id
                  FROM user_behaviors
                  WHERE user_id = %s AND behavior_type = 'order'
              )
            LIMIT %s
        """, (dish_ids, user_id, limit))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'name': row[1],
                'description': row[2],
                'category': row[3],
                'price': float(row[4]),
                'tags': row[5]
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
cf_recommender = CollaborativeFilteringRecommender("host=localhost dbname=testdb user=postgres password=secret")

# ååŒè¿‡æ»¤æ¨è
recommendations = cf_recommender.recommend_by_collaborative_filtering(user_id=1, limit=10)
for rec in recommendations:
    print(f"{rec['name']}: {rec['price']}å…ƒ")
```

### 8.3 å†…å®¹æ¨èå®ç°

**Pythonå†…å®¹æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
from typing import List, Dict

class ContentBasedRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–å†…å®¹æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()
        self.cf_recommender = CollaborativeFilteringRecommender(conn_str)

    def recommend_by_content(self, user_id: int, limit: int = 10) -> List[Dict]:
        """åŸºäºå†…å®¹æ¨è"""
        # æ›´æ–°ç”¨æˆ·å‘é‡
        self.cf_recommender.update_user_embedding(user_id)

        # è·å–ç”¨æˆ·åå¥½å‘é‡
        self.cur.execute("""
            SELECT embedding
            FROM users
            WHERE id = %s
        """, (user_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        user_embedding = result[0]

        # æŸ¥æ‰¾ç›¸ä¼¼èœå“
        self.cur.execute("""
            SELECT
                d.id,
                d.name,
                d.description,
                d.category,
                d.price,
                d.tags,
                1 - (d.embedding <=> %s) AS similarity
            FROM dishes d
            WHERE d.id NOT IN (
                SELECT DISTINCT dish_id
                FROM user_behaviors
                WHERE user_id = %s AND behavior_type = 'order'
            )
            ORDER BY d.embedding <=> %s
            LIMIT %s
        """, (user_embedding, user_id, user_embedding, limit))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'name': row[1],
                'description': row[2],
                'category': row[3],
                'price': float(row[4]),
                'tags': row[5],
                'similarity': float(row[6])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
content_recommender = ContentBasedRecommender("host=localhost dbname=testdb user=postgres password=secret")

# å†…å®¹æ¨è
recommendations = content_recommender.recommend_by_content(user_id=1, limit=10)
for rec in recommendations:
    print(f"{rec['name']}: similarity={rec['similarity']:.4f}, price={rec['price']}å…ƒ")
```

### 8.4 æ··åˆæ¨èå®ç°

**Pythonæ··åˆæ¨è**ï¼š

```python
import psycopg2
from typing import List, Dict

class HybridRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–æ··åˆæ¨èå™¨"""
        self.cf_recommender = CollaborativeFilteringRecommender(conn_str)
        self.content_recommender = ContentBasedRecommender(conn_str)

    def rrf_fusion(self, list1: List[Dict], list2: List[Dict], k: int = 60) -> List[Dict]:
        """RRF (Reciprocal Rank Fusion) èåˆç®—æ³•"""
        scores = {}

        # è®¡ç®—ç¬¬ä¸€ä¸ªåˆ—è¡¨çš„RRFåˆ†æ•°
        for rank, item in enumerate(list1, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {
                    'item': item,
                    'score': 0.0
                }
            scores[item_id]['score'] += 1.0 / (k + rank)

        # è®¡ç®—ç¬¬äºŒä¸ªåˆ—è¡¨çš„RRFåˆ†æ•°
        for rank, item in enumerate(list2, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {
                    'item': item,
                    'score': 0.0
                }
            scores[item_id]['score'] += 1.0 / (k + rank)

        # æŒ‰åˆ†æ•°æ’åº
        sorted_results = sorted(
            scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )

        return [r['item'] for r in sorted_results]

    def hybrid_recommend(self, user_id: int, limit: int = 10) -> List[Dict]:
        """æ··åˆæ¨è"""
        # 1. ååŒè¿‡æ»¤æ¨è
        cf_recommendations = self.cf_recommender.recommend_by_collaborative_filtering(
            user_id, limit * 2
        )

        # 2. å†…å®¹æ¨è
        content_recommendations = self.content_recommender.recommend_by_content(
            user_id, limit * 2
        )

        # 3. RRFèåˆ
        fused_recommendations = self.rrf_fusion(
            cf_recommendations,
            content_recommendations,
            k=60
        )

        return fused_recommendations[:limit]

# ä½¿ç”¨ç¤ºä¾‹
hybrid_recommender = HybridRecommender("host=localhost dbname=testdb user=postgres password=secret")

# æ··åˆæ¨è
recommendations = hybrid_recommender.hybrid_recommend(user_id=1, limit=10)
for rec in recommendations:
    print(f"{rec['name']}: {rec.get('price', 'N/A')}å…ƒ")
```

### 8.5 ç”¨æˆ·è¡Œä¸ºè®°å½•å®ç°

**Pythonç”¨æˆ·è¡Œä¸ºè®°å½•**ï¼š

```python
import psycopg2
from datetime import datetime
from typing import Optional

class UserBehaviorRecorder:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–ç”¨æˆ·è¡Œä¸ºè®°å½•å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def record_behavior(self, user_id: int, dish_id: int,
                       behavior_type: str, rating: Optional[int] = None):
        """è®°å½•ç”¨æˆ·è¡Œä¸º"""
        self.cur.execute("""
            INSERT INTO user_behaviors
            (user_id, dish_id, behavior_type, rating, created_at)
            VALUES (%s, %s, %s, %s, %s)
        """, (user_id, dish_id, behavior_type, rating, datetime.now()))

        self.conn.commit()

    def get_user_behaviors(self, user_id: int, limit: int = 50) -> List[Dict]:
        """è·å–ç”¨æˆ·è¡Œä¸º"""
        self.cur.execute("""
            SELECT
                ub.id,
                ub.dish_id,
                d.name,
                d.category,
                ub.behavior_type,
                ub.rating,
                ub.created_at
            FROM user_behaviors ub
            JOIN dishes d ON ub.dish_id = d.id
            WHERE ub.user_id = %s
            ORDER BY ub.created_at DESC
            LIMIT %s
        """, (user_id, limit))

        behaviors = []
        for row in self.cur.fetchall():
            behaviors.append({
                'id': row[0],
                'dish_id': row[1],
                'dish_name': row[2],
                'category': row[3],
                'behavior_type': row[4],
                'rating': row[5],
                'created_at': row[6]
            })

        return behaviors

# ä½¿ç”¨ç¤ºä¾‹
recorder = UserBehaviorRecorder("host=localhost dbname=testdb user=postgres password=secret")

# è®°å½•ç”¨æˆ·è¡Œä¸º
recorder.record_behavior(user_id=1, dish_id=1, behavior_type='view')
recorder.record_behavior(user_id=1, dish_id=1, behavior_type='order')
recorder.record_behavior(user_id=1, dish_id=1, behavior_type='review', rating=5)

# è·å–ç”¨æˆ·è¡Œä¸º
behaviors = recorder.get_user_behaviors(user_id=1, limit=20)
for behavior in behaviors:
    print(f"{behavior['dish_name']}: {behavior['behavior_type']}, rating={behavior['rating']}")
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-20-01
