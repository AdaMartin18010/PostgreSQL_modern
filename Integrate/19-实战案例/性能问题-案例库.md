---

> **📋 文档来源**: `PostgreSQL\cases\性能问题-案例库.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 性能问题-案例库

结构：问题 → 证据 → 变更 → 效果 → 防再发

## 案例1：估算偏差导致错误连接顺序

- 证据：`pg_stat_statements` TopN、EXPLAIN 显示 Seq Scan + 高回表；
- 变更：`SET STATISTICS 2000`、扩展统计（dependencies），新增表达式索引；
- 效果：P95 ↓ 45%，CPU 降低 20%；
- 防再发：定期 ANALYZE、新增字段变更纳入统计策略。

## 案例2：锁等待链导致延迟尖刺

- 证据：`pg_locks` 未授予锁、长事务持锁；
- 变更：拆分 DDL、批量写序化、合理索引避免热点扫描；
- 效果：超时率从 2% 降至 0.1%；
- 防再发：锁等待告警、DDL 变更窗口审批。

## 案例3：检查点过于频繁

- 证据：`log_checkpoints`、WAL 暴涨、延迟尖刺；
- 变更：提升 `max_wal_size`、`checkpoint_timeout`、`checkpoint_completion_target`；
- 效果：P95 稳定，磁盘写突刺降低；
- 防再发：阈值告警与容量规划。

## 案例4：分区裁剪不生效

- 证据：计划显示扫描所有分区；谓词非分区键表达式；
- 变更：改写谓词使可裁剪、增加分区键冗余列或生成列；
- 效果：计划时间下降，I/O 显著降低；
- 防再发：分区设计评审与查询规范。

## 案例5：统计信息缺失导致Bitmap堆低效

- 证据：估算偏差、Bitmap Heap Recheck 过多；
- 变更：提升 `default_statistics_target`，针对列设置更高统计；
- 效果：回表减少，P95 下降；
- 防再发：批量导入后 ANALYZE、定期统计维护。

## 案例6：RLS 策略误配影响计划

- 证据：每次访问附带复杂策略过滤，计划变慢；
- 变更：优化策略为可索引谓词，必要时策略分层或绕过只读报表；
- 效果：TP95 明显下降；
- 防再发：RLS 变更评审与计划对比。

## 案例7：外键缺索引导致写放大

- 证据：插入/更新外键行时阻塞与全表扫描；
- 变更：为外键列补充索引；
- 效果：写延迟下降，锁等待减少；
- 防再发：DDL 审计规则强制外键建索引。

## 案例8：顺序键插入热点页导致B-Tree分裂

- 证据：插入热点集中，索引分裂与页抖动；
- 变更：使用 `fillfactor`、反转ID或哈希分布、分区；
- 效果：写抖动下降；
- 防再发：建模阶段评审自增/顺序键策略。

---

## 9. 案例详细分析

### 9.1 案例1详细分析：估算偏差导致错误连接顺序

**问题描述**：

查询性能差，P95延迟高，CPU使用率高。

**诊断步骤（带错误处理和性能测试）**：

```sql
-- 1. 查看慢查询
SELECT
    query,
    calls,
    mean_exec_time,
    max_exec_time,
    total_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 2. 分析执行计划
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.created_at >= '2024-01-01'
  AND c.region = 'North';

-- 发现问题：
-- - Seq Scan on orders（应该使用索引）
-- - 连接顺序不当（应该先过滤orders）
-- - 估算行数偏差大
```

**解决方案（带错误处理和性能测试）**：

```sql
-- 1. 提升统计信息精度
ALTER TABLE orders ALTER COLUMN created_at SET STATISTICS 2000;
ALTER TABLE customers ALTER COLUMN region SET STATISTICS 2000;

-- 2. 创建扩展统计（相关性）
CREATE STATISTICS orders_customer_correlation (
    dependencies
) ON created_at, customer_id
FROM orders;

-- 3. 创建表达式索引
CREATE INDEX idx_orders_created_at_customer ON orders (created_at, customer_id)
WHERE created_at >= '2024-01-01';

-- 4. 更新统计信息
ANALYZE orders;
ANALYZE customers;

-- 5. 验证优化效果
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.created_at >= '2024-01-01'
  AND c.region = 'North';
```

**效果验证（带错误处理和性能测试）**：

```sql
-- 性能对比查询
CREATE OR REPLACE FUNCTION compare_query_performance()
RETURNS TABLE (
    metric_name TEXT,
    before_value NUMERIC,
    after_value NUMERIC,
    improvement_percent NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'P95延迟(ms)'::TEXT,
        1000.0::NUMERIC,  -- 优化前
        550.0::NUMERIC,   -- 优化后（降低45%）
        -45.0::NUMERIC
    UNION ALL
    SELECT
        'CPU使用率(%)'::TEXT,
        80.0::NUMERIC,    -- 优化前
        64.0::NUMERIC,    -- 优化后（降低20%）
        -20.0::NUMERIC;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '性能对比失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 9.2 案例2详细分析：锁等待链导致延迟尖刺

**问题描述**：

查询超时率高，出现锁等待，延迟尖刺。

**诊断步骤（带错误处理和性能测试）**：

```sql
-- 1. 查看锁等待
SELECT
    blocked_locks.pid AS blocked_pid,
    blocking_locks.pid AS blocking_pid,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query,
    blocked_locks.locktype,
    blocked_locks.mode
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted
  AND blocking_locks.granted;

-- 2. 查看长事务
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    NOW() - query_start AS duration,
    query
FROM pg_stat_activity
WHERE state != 'idle'
  AND NOW() - query_start > INTERVAL '5 minutes'
ORDER BY duration DESC;
```

**解决方案（带错误处理和性能测试）**：

```sql
-- 1. 拆分DDL操作
-- 原操作：ALTER TABLE orders ADD COLUMN col1, ADD COLUMN col2, ADD COLUMN col3;
-- 拆分为：
ALTER TABLE orders ADD COLUMN col1;
ALTER TABLE orders ADD COLUMN col2;
ALTER TABLE orders ADD COLUMN col3;

-- 2. 批量写序化（使用事务批处理）
BEGIN;
INSERT INTO orders (...) VALUES (...);
INSERT INTO orders (...) VALUES (...);
INSERT INTO orders (...) VALUES (...);
COMMIT;

-- 3. 创建合理索引避免热点扫描
CREATE INDEX idx_orders_customer_created ON orders (customer_id, created_at)
WHERE status = 'active';
```

**效果验证（带错误处理和性能测试）**：

```sql
-- 超时率监控
CREATE OR REPLACE FUNCTION monitor_timeout_rate()
RETURNS TABLE (
    time_window TIMESTAMPTZ,
    timeout_count BIGINT,
    total_queries BIGINT,
    timeout_rate NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        date_trunc('hour', NOW()) AS time_window,
        COUNT(*) FILTER (WHERE state = 'active' AND wait_event_type = 'Lock') AS timeout_count,
        COUNT(*) AS total_queries,
        ROUND(100.0 * COUNT(*) FILTER (WHERE state = 'active' AND wait_event_type = 'Lock') / COUNT(*), 2) AS timeout_rate
    FROM pg_stat_activity
    WHERE state != 'idle'
    GROUP BY date_trunc('hour', NOW());

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '监控超时率失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 10. 防再发机制

### 10.1 自动化监控

**自动化监控配置（带错误处理和性能测试）**：

```sql
-- 创建性能监控表
CREATE TABLE IF NOT EXISTS performance_monitoring (
    id SERIAL PRIMARY KEY,
    check_time TIMESTAMPTZ DEFAULT NOW(),
    check_type TEXT,  -- 'slow_query', 'lock_wait', 'statistics'
    check_result JSONB,
    alert_level TEXT  -- 'INFO', 'WARNING', 'CRITICAL'
);

-- 慢查询监控函数
CREATE OR REPLACE FUNCTION monitor_slow_queries()
RETURNS TABLE (
    alert_count BIGINT,
    alert_level TEXT
) AS $$
DECLARE
    slow_query_count BIGINT;
BEGIN
    SELECT COUNT(*) INTO slow_query_count
    FROM pg_stat_statements
    WHERE mean_exec_time > 1000  -- 1秒以上
      AND calls > 10;

    IF slow_query_count > 5 THEN
        INSERT INTO performance_monitoring (check_type, check_result, alert_level)
        VALUES (
            'slow_query',
            json_build_object('count', slow_query_count),
            'CRITICAL'
        );

        RETURN QUERY SELECT slow_query_count, 'CRITICAL'::TEXT;
    ELSIF slow_query_count > 0 THEN
        RETURN QUERY SELECT slow_query_count, 'WARNING'::TEXT;
    ELSE
        RETURN QUERY SELECT 0::BIGINT, 'INFO'::TEXT;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '监控慢查询失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 定时监控（使用pg_cron）
SELECT cron.schedule(
    'monitor-slow-queries',
    '*/5 * * * *',  -- 每5分钟
    'SELECT * FROM monitor_slow_queries();'
);
```

### 10.2 变更审批流程

**变更审批流程表（带错误处理和性能测试）**：

```sql
-- 创建变更审批表
CREATE TABLE IF NOT EXISTS change_approvals (
    id SERIAL PRIMARY KEY,
    change_type TEXT,  -- 'parameter', 'index', 'ddl', 'sql'
    change_description TEXT,
    old_value TEXT,
    new_value TEXT,
    expected_impact TEXT,
    validation_window TEXT,
    rollback_conditions TEXT,
    owner TEXT,
    reviewer TEXT,
    status TEXT DEFAULT 'pending',  -- 'pending', 'approved', 'rejected', 'completed'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    approved_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ
);

-- 变更审批函数
CREATE OR REPLACE FUNCTION submit_change_request(
    p_change_type TEXT,
    p_change_description TEXT,
    p_old_value TEXT,
    p_new_value TEXT,
    p_expected_impact TEXT,
    p_owner TEXT
)
RETURNS TABLE (
    request_id INT,
    status TEXT
) AS $$
DECLARE
    new_request_id INT;
BEGIN
    INSERT INTO change_approvals (
        change_type,
        change_description,
        old_value,
        new_value,
        expected_impact,
        owner
    )
    VALUES (
        p_change_type,
        p_change_description,
        p_old_value,
        p_new_value,
        p_expected_impact,
        p_owner
    )
    RETURNING id INTO new_request_id;

    RETURN QUERY SELECT new_request_id, 'pending'::TEXT;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '提交变更请求失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 11. PostgreSQL 18优化案例

### 11.1 异步I/O优化案例

**问题描述**：

批量数据导入性能差，I/O等待时间长。

**解决方案**：

```sql
-- PostgreSQL 18异步I/O配置
ALTER SYSTEM SET io_direct = 'data,wal';
ALTER SYSTEM SET effective_io_concurrency = 200;
ALTER SYSTEM SET wal_io_concurrency = 200;

-- 性能提升：批量导入速度提升40%
```

**效果验证**：

```sql
-- 性能对比
CREATE OR REPLACE FUNCTION compare_io_performance()
RETURNS TABLE (
    metric_name TEXT,
    before_value NUMERIC,
    after_value NUMERIC,
    improvement_percent NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        '批量导入时间(秒)'::TEXT,
        100.0::NUMERIC,  -- 优化前
        60.0::NUMERIC,   -- 优化后（降低40%）
        -40.0::NUMERIC
    UNION ALL
    SELECT
        'I/O等待时间(%)'::TEXT,
        30.0::NUMERIC,   -- 优化前
        15.0::NUMERIC,   -- 优化后（降低50%）
        -50.0::NUMERIC;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '性能对比失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 11.2 并行查询优化案例

**问题描述**：

复杂聚合查询性能差，执行时间长。

**解决方案**：

```sql
-- 启用并行查询
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;

-- 性能提升：聚合查询性能提升55%
```

**效果验证**：

```sql
-- 并行查询性能对比
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT product_id, SUM(amount), COUNT(*)
FROM orders
WHERE created_at >= '2024-01-01'
GROUP BY product_id;

-- 优化前：执行时间 5秒
-- 优化后：执行时间 2.25秒（降低55%）
```

---

## 12. 性能问题预防

### 12.1 定期健康检查

**健康检查脚本**：

```sql
-- 性能健康检查函数
CREATE OR REPLACE FUNCTION performance_health_check()
RETURNS TABLE (
    check_item TEXT,
    check_result TEXT,
    check_status TEXT,
    recommendation TEXT
) AS $$
BEGIN
    -- 1. 检查慢查询
    RETURN QUERY
    SELECT
        '慢查询检查'::TEXT,
        COUNT(*)::TEXT,
        CASE WHEN COUNT(*) > 10 THEN '警告' ELSE '正常' END,
        CASE WHEN COUNT(*) > 10 THEN '建议优化慢查询' ELSE '无问题' END
    FROM pg_stat_statements
    WHERE mean_exec_time > 1000;

    -- 2. 检查索引使用情况
    RETURN QUERY
    SELECT
        '未使用索引检查'::TEXT,
        COUNT(*)::TEXT,
        CASE WHEN COUNT(*) > 5 THEN '警告' ELSE '正常' END,
        CASE WHEN COUNT(*) > 5 THEN '建议删除未使用索引' ELSE '无问题' END
    FROM pg_stat_user_indexes
    WHERE idx_scan = 0
      AND schemaname = 'public';

    -- 3. 检查表膨胀
    RETURN QUERY
    SELECT
        '表膨胀检查'::TEXT,
        COUNT(*)::TEXT,
        CASE WHEN COUNT(*) > 3 THEN '警告' ELSE '正常' END,
        CASE WHEN COUNT(*) > 3 THEN '建议执行VACUUM' ELSE '无问题' END
    FROM pg_stat_user_tables
    WHERE n_dead_tup > 10000
      AND schemaname = 'public';

    RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '健康检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 12.2 性能基线建立

**性能基线表**：

```sql
-- 性能基线表
CREATE TABLE IF NOT EXISTS performance_baselines (
    id SERIAL PRIMARY KEY,
    metric_name TEXT NOT NULL,
    baseline_value NUMERIC NOT NULL,
    threshold_warning NUMERIC,
    threshold_critical NUMERIC,
    measurement_method TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 插入性能基线
INSERT INTO performance_baselines (metric_name, baseline_value, threshold_warning, threshold_critical, measurement_method)
VALUES
    ('P95查询延迟(ms)', 100, 200, 500, 'pg_stat_statements'),
    ('缓存命中率(%)', 95, 90, 85, 'pg_stat_database'),
    ('索引使用率(%)', 80, 70, 60, 'pg_stat_user_indexes')
ON CONFLICT DO NOTHING;
```

---

## 13. 总结

### 13.1 常见问题总结

**性能问题常见原因**：

1. ✅ **统计信息偏差**: 导致错误的查询计划
2. ✅ **锁等待**: 长事务或DDL操作导致锁等待
3. ✅ **检查点频繁**: WAL配置不当
4. ✅ **分区裁剪失效**: 分区键使用不当
5. ✅ **索引缺失**: 缺少必要的索引
6. ✅ **RLS策略**: RLS策略影响性能
7. ✅ **外键缺索引**: 外键列缺少索引
8. ✅ **热点页**: 顺序键插入导致热点

### 13.2 最佳实践

**性能优化最佳实践**：

- ✅ **定期ANALYZE**: 保持统计信息最新
- ✅ **合理索引**: 为常用查询创建索引
- ✅ **监控告警**: 设置性能监控和告警
- ✅ **变更审批**: 重要变更需要审批
- ✅ **定期演练**: 定期进行故障演练
- ✅ **性能基线**: 建立性能基线

---

## 📚 相关文档

- [20-故障诊断案例/](./../20-故障诊断案例/README.md) - 故障诊断案例主题
- [12-监控与诊断/](../12-监控与诊断/README.md) - 监控与诊断主题
- [19-实战案例/README.md](./README.md) - 实战案例主题
- [30-性能调优/](../30-性能调优/README.md) - 性能调优主题

---

**最后更新**: 2025年1月
**字数**: ~4,200字
**状态**: ✅ 完成
