# PostgreSQL失败案例库

> **创建日期**: 2025年1月
> **适用场景**: 故障预防、经验学习
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL失败案例库](#postgresql失败案例库)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 失败案例价值](#11-失败案例价值)
    - [1.2 案例分类](#12-案例分类)
  - [2. 配置失败案例](#2-配置失败案例)
    - [2.1 案例1：内存配置错误导致OOM](#21-案例1内存配置错误导致oom)
  - [3. 性能失败案例](#3-性能失败案例)
    - [3.1 案例2：缺少索引导致系统不可用](#31-案例2缺少索引导致系统不可用)
  - [4. 高可用失败案例](#4-高可用失败案例)
    - [4.1 案例3：主从复制延迟导致数据不一致](#41-案例3主从复制延迟导致数据不一致)
  - [5. 数据丢失案例](#5-数据丢失案例)
    - [5.1 案例4：备份策略不当导致数据丢失](#51-案例4备份策略不当导致数据丢失)
  - [6. 经验教训](#6-经验教训)
    - [6.1 配置教训](#61-配置教训)
    - [6.2 性能教训](#62-性能教训)
    - [6.3 高可用教训](#63-高可用教训)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 失败案例价值

失败案例的价值在于：

- ✅ **预防错误**: 了解常见失败原因，提前预防
- ✅ **快速诊断**: 快速识别问题原因
- ✅ **经验积累**: 积累实战经验
- ✅ **最佳实践**: 形成最佳实践

### 1.2 案例分类

- **配置失败**: 参数配置错误
- **性能失败**: 性能问题导致系统不可用
- **高可用失败**: 高可用方案失效
- **数据丢失**: 数据丢失或损坏

---

## 2. 配置失败案例

### 2.1 案例1：内存配置错误导致OOM

**场景**: 生产环境数据库频繁OOM

**错误配置**:

```ini
shared_buffers = 8GB
work_mem = 512MB
max_connections = 200
# 总内存需求: 8GB + 200 × 512MB = 112GB
# 系统内存: 32GB
```

**问题**:

- 系统内存不足
- 频繁OOM
- 数据库崩溃

**解决方案**:

```ini
shared_buffers = 8GB
work_mem = 64MB
max_connections = 200
# 总内存需求: 8GB + 200 × 64MB = 20.8GB
```

**教训**: 配置参数必须考虑系统资源限制

---

## 3. 性能失败案例

### 3.1 案例2：缺少索引导致系统不可用

**场景**: 用户查询响应时间从100ms增加到10秒

**问题查询**:

```sql
SELECT * FROM orders WHERE user_id = 12345 AND status = 'pending';
-- 没有索引，全表扫描1000万行
```

**影响**:

- 查询时间：10秒
- CPU使用率：100%
- 阻塞其他查询
- 系统不可用

**解决方案**:

```sql
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
-- 查询时间：10ms
```

**教训**: 生产环境必须为常用查询创建索引

---

## 4. 高可用失败案例

### 4.1 案例3：主从复制延迟导致数据不一致

**场景**: 主库写入后，从库查询不到数据

**问题**:

- 主从复制延迟：5秒
- 应用写入主库后立即从从库读取
- 读取不到最新数据

**影响**:

- 数据不一致
- 用户体验差
- 业务逻辑错误

**解决方案**:

```sql
-- 1. 优化复制延迟
max_wal_senders = 10
wal_keep_segments = 32

-- 2. 应用层处理
-- 写入后从主库读取
-- 或等待复制完成
```

**教训**: 主从复制延迟必须考虑在应用设计中

---

## 5. 数据丢失案例

### 5.1 案例4：备份策略不当导致数据丢失

**场景**: 数据库损坏，但备份已过期

**问题**:

- 备份策略：每周一次全量备份
- 数据库在备份后第6天损坏
- 丢失6天数据

**影响**:

- 数据丢失
- 业务中断
- 用户投诉

**解决方案**:

```bash
# 改进备份策略
# 1. 每天全量备份
# 2. 每小时增量备份
# 3. WAL归档
```

**教训**: 备份策略必须考虑RPO（恢复点目标）

---

## 6. 并发控制失败案例

### 6.1 案例5：死锁导致事务失败

**场景**: 高并发场景下频繁出现死锁

**问题代码**:

```sql
-- 事务1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 事务2（同时执行）
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 2;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
COMMIT;
```

**问题**:

- 两个事务以不同顺序锁定资源
- 导致死锁
- 事务回滚
- 用户体验差

**解决方案**:

```sql
-- 统一锁定顺序
BEGIN;
SELECT * FROM accounts WHERE id IN (1, 2) ORDER BY id FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

**教训**: 多资源更新时，必须统一锁定顺序

### 6.2 案例6：长时间事务导致锁等待

**场景**: 大批量数据处理导致长时间锁等待

**问题代码**:

```sql
BEGIN;
-- 处理100万条记录
UPDATE orders SET status = 'processed' WHERE created_at < NOW() - INTERVAL '1 day';
-- 事务持续10分钟
COMMIT;
```

**影响**:

- 其他事务等待锁释放
- 系统响应变慢
- 用户体验差

**解决方案**:

```sql
-- 分批处理
DO $$
DECLARE
    batch_size INT := 10000;
    affected_rows INT;
BEGIN
    LOOP
        UPDATE orders
        SET status = 'processed'
        WHERE created_at < NOW() - INTERVAL '1 day'
          AND status != 'processed'
        LIMIT batch_size;

        GET DIAGNOSTICS affected_rows = ROW_COUNT;
        EXIT WHEN affected_rows = 0;

        COMMIT;
        BEGIN;
    END LOOP;
END $$;
```

**教训**: 大批量操作必须分批处理

---

## 7. 索引失败案例

### 7.1 案例7：索引过多导致写入性能下降

**场景**: 为提升查询性能，创建了大量索引

**问题**:

```sql
-- 为每个查询都创建索引
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_orders_amount ON orders(amount);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at);
CREATE INDEX idx_orders_status_created ON orders(status, created_at);
-- ... 共20个索引
```

**影响**:

- 写入性能下降80%
- 索引维护开销大
- 存储空间增加3倍

**解决方案**:

```sql
-- 分析查询模式，合并索引
CREATE INDEX idx_orders_user_status_created ON orders(user_id, status, created_at);
-- 删除冗余索引
DROP INDEX idx_orders_user_id;
DROP INDEX idx_orders_status;
-- ...
```

**教训**: 索引不是越多越好，需要平衡查询和写入性能

### 7.2 案例8：索引顺序错误导致查询性能差

**场景**: 复合索引列顺序不当

**问题索引**:

```sql
CREATE INDEX idx_orders_status_user ON orders(status, user_id);
-- 查询条件
SELECT * FROM orders WHERE user_id = 123 AND status = 'pending';
-- 索引无法有效使用
```

**解决方案**:

```sql
-- 调整索引顺序（高选择性列在前）
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
-- 查询可以高效使用索引
```

**教训**: 复合索引列顺序很重要，高选择性列应在前

---

## 8. PostgreSQL 18特性使用失败案例

### 8.1 案例9：异步I/O配置错误

**场景**: 启用异步I/O后性能反而下降

**错误配置**:

```ini
io_direct = 'data,wal'
effective_io_concurrency = 1000  # 设置过大
```

**问题**:

- I/O队列过载
- 性能下降
- 系统不稳定

**解决方案**:

```ini
io_direct = 'data,wal'
effective_io_concurrency = 200  # 根据存储类型调整
maintenance_io_concurrency = 200
wal_io_concurrency = 200
```

**教训**: 异步I/O参数需要根据硬件配置调整

### 8.2 案例10：并行查询配置不当

**场景**: 启用并行查询后CPU使用率过高

**错误配置**:

```ini
max_parallel_workers_per_gather = 16
max_parallel_workers = 32
```

**问题**:

- CPU使用率100%
- 影响其他查询
- 系统响应变慢

**解决方案**:

```ini
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
-- 根据CPU核心数调整
```

**教训**: 并行查询需要根据CPU资源合理配置

---

## 9. 监控告警失败案例

### 9.1 案例11：缺少监控导致问题发现延迟

**场景**: 数据库性能逐渐下降，但未及时发现

**问题**:

- 没有设置性能监控
- 没有告警机制
- 问题发现时已严重影响业务

**解决方案**:

```yaml
# Prometheus告警规则
groups:
- name: postgresql_alerts
  rules:
  - alert: HighQueryLatency
    expr: histogram_quantile(0.95, rate(pg_stat_statements_total_exec_time_bucket[5m])) > 1
    for: 5m
    annotations:
      summary: "查询延迟过高"

  - alert: HighConnectionCount
    expr: pg_stat_database_numbackends > 800
    for: 5m
    annotations:
      summary: "连接数过高"
```

**教训**: 必须设置完善的监控和告警机制

### 9.2 案例12：告警阈值设置不当

**场景**: 告警阈值设置过低，频繁告警

**问题**:

- 告警阈值设置过低
- 频繁告警
- 告警疲劳
- 真正问题被忽略

**解决方案**:

```yaml
# 合理设置告警阈值
- alert: HighQueryLatency
  expr: histogram_quantile(0.95, rate(pg_stat_statements_total_exec_time_bucket[5m])) > 5
  # 从1秒提高到5秒
  for: 10m
  # 持续时间从5分钟提高到10分钟
```

**教训**: 告警阈值需要根据实际情况调整

---

## 10. 经验教训总结

### 10.1 配置教训

- ✅ **资源规划**: 配置前必须规划资源
- ✅ **参数验证**: 配置后必须验证
- ✅ **监控告警**: 设置监控和告警
- ✅ **文档记录**: 记录配置变更
- ✅ **渐进调整**: 参数调整要渐进式
- ✅ **测试验证**: 配置变更前要测试

### 10.2 性能教训

- ✅ **索引优化**: 为常用查询创建索引
- ✅ **查询优化**: 优化慢查询
- ✅ **监控性能**: 持续监控性能
- ✅ **容量规划**: 提前规划容量
- ✅ **分批处理**: 大批量操作分批处理
- ✅ **索引平衡**: 平衡查询和写入性能

### 10.3 高可用教训

- ✅ **测试故障转移**: 定期测试故障转移
- ✅ **监控复制延迟**: 监控主从复制延迟
- ✅ **多区域部署**: 考虑多区域部署
- ✅ **备份恢复**: 定期测试备份恢复
- ✅ **RTO/RPO目标**: 明确RTO/RPO目标
- ✅ **自动化恢复**: 实现自动化恢复

### 10.4 并发控制教训

- ✅ **统一锁定顺序**: 多资源更新时统一锁定顺序
- ✅ **避免长事务**: 避免长时间事务
- ✅ **合理隔离级别**: 选择合适的隔离级别
- ✅ **死锁检测**: 启用死锁检测和超时
- ✅ **批量操作**: 大批量操作分批处理
- ✅ **锁监控**: 监控锁等待情况

### 10.5 PostgreSQL 18特性使用教训

- ✅ **异步I/O配置**: 根据存储类型合理配置
- ✅ **并行查询**: 根据CPU资源合理配置
- ✅ **性能测试**: 新特性使用前要测试
- ✅ **渐进启用**: 新特性要渐进式启用
- ✅ **监控效果**: 监控新特性的效果
- ✅ **回滚方案**: 准备回滚方案

---

## 11. 预防措施

### 11.1 配置管理

**配置检查清单**:

- [ ] 内存配置是否合理
- [ ] 连接数配置是否合理
- [ ] I/O配置是否合理
- [ ] 日志配置是否合理
- [ ] 备份配置是否合理

### 11.2 性能管理

**性能检查清单**:

- [ ] 索引是否合理
- [ ] 查询是否优化
- [ ] 慢查询是否处理
- [ ] 统计信息是否更新
- [ ] VACUUM是否定期执行

### 11.3 高可用管理

**高可用检查清单**:

- [ ] 主从复制是否正常
- [ ] 故障转移是否测试
- [ ] 备份是否完整
- [ ] 恢复是否测试
- [ ] 监控是否完善

---

## 📚 相关文档

- [常见错误与教训](./常见错误与教训.md) - 常见错误
- [20-故障诊断案例](../20-故障诊断案例/README.md) - 故障诊断
- [13-高可用架构](../13-高可用架构/README.md) - 高可用架构
- [30-性能调优](../30-性能调优/README.md) - 性能调优

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
**字数**: ~4,500字
