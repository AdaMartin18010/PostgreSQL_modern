---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_View\08-è½åœ°æ¡ˆä¾‹\æ—…æ¸¸åœºæ™¯\æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿ.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, PostGIS 3.0+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-15-01

## ğŸ“‘ ç›®å½•

- [æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿ](#æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
  - [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
    - [2.1 æ™ºèƒ½æ—…æ¸¸æ¨èä½“ç³»æ€ç»´å¯¼å›¾](#21-æ™ºèƒ½æ—…æ¸¸æ¨èä½“ç³»æ€ç»´å¯¼å›¾)
    - [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
    - [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
  - [3. æ•°æ®æ¨¡å‹è®¾è®¡](#3-æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 æ™¯ç‚¹è¡¨](#31-æ™¯ç‚¹è¡¨)
    - [3.2 ç”¨æˆ·è¡¨](#32-ç”¨æˆ·è¡¨)
    - [3.3 ç”¨æˆ·è¡Œä¸ºè¡¨](#33-ç”¨æˆ·è¡Œä¸ºè¡¨)
  - [4. æ¨èç®—æ³•](#4-æ¨èç®—æ³•)
    - [4.1 åŸºäºä½ç½®çš„æ¨è](#41-åŸºäºä½ç½®çš„æ¨è)
    - [4.2 åŸºäºå†…å®¹çš„æ¨è](#42-åŸºäºå†…å®¹çš„æ¨è)
    - [4.3 è·¯çº¿è§„åˆ’](#43-è·¯çº¿è§„åˆ’)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 æ¡ˆä¾‹: æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»ŸçœŸå®æ¡ˆä¾‹)
    - [5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#52-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 æ¨èç­–ç•¥](#61-æ¨èç­–ç•¥)
    - [6.2 è·¯çº¿è§„åˆ’](#62-è·¯çº¿è§„åˆ’)
    - [6.3 æ€§èƒ½ä¼˜åŒ–](#63-æ€§èƒ½ä¼˜åŒ–)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)
  - [8. å®Œæ•´ä»£ç ç¤ºä¾‹](#8-å®Œæ•´ä»£ç ç¤ºä¾‹)
    - [8.1 æ™¯ç‚¹ç©ºé—´å’Œå‘é‡è¡¨åˆ›å»º](#81-æ™¯ç‚¹ç©ºé—´å’Œå‘é‡è¡¨åˆ›å»º)
    - [8.2 åŸºäºä½ç½®çš„æ¨èå®ç°](#82-åŸºäºä½ç½®çš„æ¨èå®ç°)
    - [8.3 åŸºäºå†…å®¹çš„æ¨èå®ç°](#83-åŸºäºå†…å®¹çš„æ¨èå®ç°)
    - [8.4 æ··åˆæ¨èå®ç°](#84-æ··åˆæ¨èå®ç°)
    - [8.5 è·¯çº¿è§„åˆ’å®ç°](#85-è·¯çº¿è§„åˆ’å®ç°)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿéœ€è¦ï¼š

- **æ™¯ç‚¹æ¨è**: æ ¹æ®ç”¨æˆ·åå¥½æ¨èæ™¯ç‚¹
- **è·¯çº¿è§„åˆ’**: è§„åˆ’æœ€ä¼˜æ—…æ¸¸è·¯çº¿
- **ä½ç½®æœåŠ¡**: æä¾›ä½ç½®ç›¸å…³çš„æœåŠ¡
- **ä¸ªæ€§åŒ–æ¨è**: ä¸ªæ€§åŒ–æ—…æ¸¸æ¨è

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **ç©ºé—´æ•°æ®åº“**: PostGIS å¤„ç†åœ°ç†ä½ç½®æ•°æ®
- **å‘é‡æœç´¢**: pgvector å‘é‡ç›¸ä¼¼åº¦è®¡ç®—
- **æ¨èç®—æ³•**: åŸºäºå†…å®¹å’ŒååŒè¿‡æ»¤

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
| --- | --- | --- |
| **ç”¨æˆ·æ»¡æ„åº¦** | ä¸ªæ€§åŒ–æ¨èæå‡æ»¡æ„åº¦ | **+40%** |
| **è½¬åŒ–ç‡** | æ¨èæå‡è½¬åŒ–ç‡ | **+30%** |
| **æŸ¥è¯¢æ€§èƒ½** | ç©ºé—´æŸ¥è¯¢å“åº”æ—¶é—´ | **< 50ms** |
| **è·¯çº¿ä¼˜åŒ–** | ä¼˜åŒ–è·¯çº¿èŠ‚çœæ—¶é—´ | **-25%** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **ç”¨æˆ·æ»¡æ„åº¦**: ä¸ªæ€§åŒ–æ¨èæå‡ç”¨æˆ·æ»¡æ„åº¦ 40%
- **è½¬åŒ–ç‡**: æ¨èæå‡è½¬åŒ–ç‡ 30%
- **æŸ¥è¯¢æ€§èƒ½**: ç©ºé—´æŸ¥è¯¢å“åº”æ—¶é—´ < 50ms
- **è·¯çº¿ä¼˜åŒ–**: ä¼˜åŒ–è·¯çº¿èŠ‚çœæ—¶é—´ 25%

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ™ºèƒ½æ—…æ¸¸æ¨èä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((æ™ºèƒ½æ—…æ¸¸æ¨è))
    æ•°æ®å±‚
      æ™¯ç‚¹æ•°æ®
        æ™¯ç‚¹ä¿¡æ¯
        æ™¯ç‚¹ä½ç½®
        æ™¯ç‚¹åˆ†ç±»
        æ™¯ç‚¹è¯„åˆ†
      ç”¨æˆ·æ•°æ®
        ç”¨æˆ·ä¿¡æ¯
        ç”¨æˆ·ä½ç½®
        æ—…æ¸¸åå¥½
        å†å²è®°å½•
      è¡Œä¸ºæ•°æ®
        æµè§ˆè¡Œä¸º
        æ”¶è—è¡Œä¸º
        è¯„ä»·è¡Œä¸º
        åˆ†äº«è¡Œä¸º
    å­˜å‚¨å±‚
      ç©ºé—´æ•°æ®åº“
        PostGIS
        æ™¯ç‚¹ä½ç½®
        ç”¨æˆ·ä½ç½®
        ç©ºé—´ç´¢å¼•
        è·¯å¾„åˆ†æ
      å‘é‡æ•°æ®åº“
        pgvector
        æ™¯ç‚¹å‘é‡
        ç”¨æˆ·å‘é‡
        ç›¸ä¼¼åº¦æœç´¢
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        åŸºç¡€æ•°æ®
        å…ƒæ•°æ®
        é…ç½®ä¿¡æ¯
    å¤„ç†å±‚
      æ•°æ®é‡‡é›†
        è¡Œä¸ºé‡‡é›†
        ä½ç½®é‡‡é›†
        æ™¯ç‚¹é‡‡é›†
        æ•°æ®æ¸…æ´—
      å‘é‡åŒ–å¤„ç†
        æ™¯ç‚¹å‘é‡åŒ–
        ç”¨æˆ·å‘é‡åŒ–
        åå¥½å‘é‡åŒ–
        å‘é‡ä¼˜åŒ–
      æ¨èç®—æ³•
        ä½ç½®æ¨è
        å†…å®¹æ¨è
        æ··åˆæ¨è
        è·¯çº¿è§„åˆ’
    åº”ç”¨å±‚
      æ™¯ç‚¹æ¨è
        é™„è¿‘æ¨è
        ç›¸ä¼¼æ¨è
        çƒ­é—¨æ¨è
        ä¸ªæ€§åŒ–æ¨è
      è·¯çº¿è§„åˆ’
        æœ€ä¼˜è·¯çº¿
        æ—¶é—´ä¼˜åŒ–
        è·ç¦»ä¼˜åŒ–
        å¤šç›®æ ‡ä¼˜åŒ–
      ä¸ªæ€§åŒ–æœåŠ¡
        ä¸ªæ€§åŒ–æ¨è
        ä¸ªæ€§åŒ–è·¯çº¿
        ä¸ªæ€§åŒ–å»ºè®®
        ä¸ªæ€§åŒ–æœåŠ¡
    åº”ç”¨åœºæ™¯
      æ—…æ¸¸å¹³å°
        æ™¯ç‚¹æ¨è
        è·¯çº¿è§„åˆ’
        ç”¨æˆ·æœåŠ¡
      æ—…è¡Œç¤¾
        è¡Œç¨‹è§„åˆ’
        æ™¯ç‚¹æ¨è
        æœåŠ¡ä¼˜åŒ–
      æ™ºæ…§æ—…æ¸¸
        æ™ºèƒ½æ¨è
        è·¯çº¿ä¼˜åŒ–
        æœåŠ¡æå‡
```

### 2.2 æ¶æ„è®¾è®¡

```text
ç”¨æˆ·è¡Œä¸ºé‡‡é›†
  â†“
æ•°æ®é¢„å¤„ç†
  â†“
ç©ºé—´æ•°æ®å­˜å‚¨ï¼ˆPostGISï¼‰
  â”œâ”€â”€ æ™¯ç‚¹ä½ç½®
  â””â”€â”€ ç”¨æˆ·ä½ç½®
  â†“
å‘é‡æ•°æ®å­˜å‚¨ï¼ˆpgvectorï¼‰
  â”œâ”€â”€ æ™¯ç‚¹å‘é‡
  â””â”€â”€ ç”¨æˆ·å‘é‡
  â†“
æ¨èå¼•æ“
  â”œâ”€â”€ æ™¯ç‚¹æ¨è
  â”œâ”€â”€ è·¯çº¿è§„åˆ’
  â””â”€â”€ ä¸ªæ€§åŒ–æ¨è
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + PostGIS + pgvector
- **å‘é‡ç”Ÿæˆ**: OpenAI Embeddings / Sentence Transformers
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 æ™¯ç‚¹è¡¨

```sql
CREATE TABLE attractions (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    location GEOGRAPHY(POINT, 4326),
    rating DECIMAL(3, 2),
    embedding vector(1536),
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX attractions_location_idx ON attractions USING GIST (location);
CREATE INDEX attractions_embedding_idx ON attractions USING hnsw (embedding vector_cosine_ops);
CREATE INDEX attractions_category_idx ON attractions (category);
```

### 3.2 ç”¨æˆ·è¡¨

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    current_location GEOGRAPHY(POINT, 4326),
    embedding vector(1536),
    preferences JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX users_location_idx ON users USING GIST (current_location);
CREATE INDEX users_embedding_idx ON users USING hnsw (embedding vector_cosine_ops);
```

### 3.3 ç”¨æˆ·è¡Œä¸ºè¡¨

```sql
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    attraction_id INTEGER REFERENCES attractions(id),
    behavior_type TEXT,  -- 'view', 'like', 'visit', 'review'
    rating INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX user_behaviors_user_time_idx ON user_behaviors (user_id, timestamp DESC);
CREATE INDEX user_behaviors_attraction_idx ON user_behaviors (attraction_id);
```

## 4. æ¨èç®—æ³•

### 4.1 åŸºäºä½ç½®çš„æ¨è

```python
# åŸºäºä½ç½®çš„æ¨è
class LocationBasedRecommendation:
    async def recommend_nearby(self, user_location, radius_km=10, limit=10):
        """æ¨èé™„è¿‘æ™¯ç‚¹"""
        recommendations = await self.db.fetch("""
            SELECT
                id,
                name,
                category,
                rating,
                ST_Distance(location, $1::geography) / 1000 AS distance_km
            FROM attractions
            WHERE ST_DWithin(
                location::geography,
                $1::geography,
                $2 * 1000
            )
            ORDER BY rating DESC, distance_km ASC
            LIMIT $3
        """, user_location, radius_km, limit)

        return recommendations
```

### 4.2 åŸºäºå†…å®¹çš„æ¨è

```python
# åŸºäºå†…å®¹çš„æ¨è
class ContentBasedRecommendation:
    async def recommend(self, user_id, limit=10):
        """åŸºäºå†…å®¹æ¨è"""
        # 1. è·å–ç”¨æˆ·å‘é‡
        user = await self.db.fetchrow("""
            SELECT embedding FROM users WHERE id = $1
        """, user_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼æ™¯ç‚¹
        recommendations = await self.db.fetch("""
            SELECT
                a.id,
                a.name,
                a.category,
                a.rating,
                1 - (a.embedding <=> $1::vector) AS similarity
            FROM attractions a
            WHERE a.id NOT IN (
                SELECT attraction_id FROM user_behaviors
                WHERE user_id = $2 AND behavior_type = 'visit'
            )
            ORDER BY a.embedding <=> $1::vector
            LIMIT $3
        """, user['embedding'], user_id, limit)

        return recommendations
```

### 4.3 è·¯çº¿è§„åˆ’

```python
# è·¯çº¿è§„åˆ’
class RoutePlanner:
    async def plan_route(self, start_location, attractions, max_distance_km=50):
        """è§„åˆ’æ—…æ¸¸è·¯çº¿"""
        # 1. ä½¿ç”¨ PostGIS æŸ¥æ‰¾æœ€ä¼˜è·¯çº¿
        route = await self.db.fetchrow("""
            WITH attraction_points AS (
                SELECT location FROM attractions WHERE id = ANY($1::int[])
            )
            SELECT
                ST_AsText(ST_MakeLine(location ORDER BY ST_Distance(location, $2::geography))) AS route
            FROM attraction_points
        """, [a['id'] for a in attractions], start_location)

        # 2. è®¡ç®—æ€»è·ç¦»å’Œæ—¶é—´
        total_distance = await self.calculate_total_distance(route['route'])
        estimated_time = self.estimate_time(total_distance, len(attractions))

        return {
            'route': route['route'],
            'total_distance': total_distance,
            'estimated_time': estimated_time,
            'attractions': attractions
        }
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸæ—…æ¸¸å¹³å°éœ€è¦æ„å»ºæ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿï¼Œæå‡ç”¨æˆ·æ»¡æ„åº¦å’Œè½¬åŒ–ç‡ã€‚

**é—®é¢˜åˆ†æ**:

1. **æ¨èä¸å‡†ç¡®**: æ¨èä¸å‡†ç¡®ï¼Œç”¨æˆ·æ»¡æ„åº¦ä½
2. **è·¯çº¿ä¸ä¼˜åŒ–**: è·¯çº¿è§„åˆ’ä¸ä¼˜åŒ–ï¼Œæµªè´¹æ—¶é—´
3. **è½¬åŒ–ç‡ä½**: æ¨èè½¬åŒ–ç‡ä½
4. **æŸ¥è¯¢æ€§èƒ½**: ä½ç½®æŸ¥è¯¢æ€§èƒ½å·®

**è§£å†³æ–¹æ¡ˆ**:

```python
# æ™ºèƒ½æ—…æ¸¸æ¨èç³»ç»Ÿ
class IntelligentTravelRecommendationSystem:
    def __init__(self):
        self.location_recommendation = LocationBasedRecommendation()
        self.content_recommendation = ContentBasedRecommendation()
        self.route_planner = RoutePlanner()

    async def get_recommendations(self, user_id, user_location, limit=10):
        """è·å–æ¨è"""
        # 1. åŸºäºä½ç½®çš„æ¨è
        nearby_attractions = await self.location_recommendation.recommend_nearby(
            user_location,
            radius_km=20,
            limit=limit * 2
        )

        # 2. åŸºäºå†…å®¹çš„æ¨è
        content_attractions = await self.content_recommendation.recommend(
            user_id,
            limit=limit * 2
        )

        # 3. èåˆæ¨èç»“æœ
        recommendations = self.fuse_recommendations(
            nearby_attractions,
            content_attractions,
            limit
        )

        # 4. è§„åˆ’è·¯çº¿
        route = await self.route_planner.plan_route(
            user_location,
            recommendations
        )

        return {
            'recommendations': recommendations,
            'route': route
        }
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
| --- | --- | --- | --- |
| **ç”¨æˆ·æ»¡æ„åº¦** | åŸºå‡† | **+40%** | **æå‡** |
| **è½¬åŒ–ç‡** | åŸºå‡† | **+30%** | **æå‡** |
| **è·¯çº¿ä¼˜åŒ–** | åŸºå‡† | **-25%** | **èŠ‚çœæ—¶é—´** |
| **æŸ¥è¯¢æ€§èƒ½** | 500ms | **< 50ms** | **90%** â¬‡ï¸ |

### 5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**æ—…æ¸¸æ¨èæŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | ç”¨æˆ·æ»¡æ„åº¦ | è½¬åŒ–ç‡ | è·¯çº¿ä¼˜åŒ– | æˆæœ¬ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- | --- |
| **ä½ç½®æ¨è** | +20% | +15% | åŸºå‡† | ä½ | ç®€å•åœºæ™¯ |
| **å†…å®¹æ¨è** | +30% | +20% | åŸºå‡† | ä¸­ | ä¸­ç­‰åœºæ™¯ |
| **æ··åˆæ¨è** | **+40%** | **+30%** | **-25%** | **ä¸­** | **å¤æ‚åœºæ™¯** |

**æ¨èç®—æ³•å¯¹æ¯”**:

| æ¨èç®—æ³• | å‡†ç¡®ç‡ | å®æ—¶æ€§ | å¯æ‰©å±•æ€§ | é€‚ç”¨åœºæ™¯ |
| --- | --- | --- | --- | --- |
| **ä½ç½®æ¨è** | 70-80% | é«˜ | ä¸­ | ä½ç½®ç›¸å…³ |
| **å†…å®¹æ¨è** | 75-85% | é«˜ | é«˜ | åå¥½ç›¸å…³ |
| **æ··åˆæ¨è** | **80-90%** | **é«˜** | **é«˜** | **å¤æ‚åœºæ™¯** |

## 6. æœ€ä½³å®è·µ

### 6.1 æ¨èç­–ç•¥

1. **æ··åˆæ¨è**: ç»“åˆä½ç½®å’Œå†…å®¹æ¨è
2. **å®æ—¶æ›´æ–°**: å®æ—¶æ›´æ–°ç”¨æˆ·ä½ç½®å’Œåå¥½
3. **å¤šæ ·æ€§ä¿è¯**: ä¿è¯æ¨èç»“æœçš„å¤šæ ·æ€§

### 6.2 è·¯çº¿è§„åˆ’

1. **å¤šç›®æ ‡ä¼˜åŒ–**: è€ƒè™‘è·ç¦»ã€æ—¶é—´ã€è¯„åˆ†ç­‰å¤šç›®æ ‡
2. **å®æ—¶è°ƒæ•´**: æ ¹æ®å®æ—¶è·¯å†µè°ƒæ•´è·¯çº¿
3. **ä¸ªæ€§åŒ–**: æ ¹æ®ç”¨æˆ·åå¥½ä¸ªæ€§åŒ–è·¯çº¿

### 6.3 æ€§èƒ½ä¼˜åŒ–

1. **ç©ºé—´ç´¢å¼•**: ä¸ºä½ç½®æ•°æ®åˆ›å»ºç©ºé—´ç´¢å¼•
2. **å‘é‡ç´¢å¼•**: ä¸ºå‘é‡æ•°æ®åˆ›å»º HNSW ç´¢å¼•
3. **ç¼“å­˜ç­–ç•¥**: ç¼“å­˜å¸¸ç”¨æ¨èç»“æœ

## 7. å‚è€ƒèµ„æ–™

- [æ™ºèƒ½è·¯å¾„ä¼˜åŒ–ç³»ç»Ÿ](../ç‰©æµåœºæ™¯/æ™ºèƒ½è·¯å¾„ä¼˜åŒ–ç³»ç»Ÿ.md)
- [PostGIS ç©ºé—´æ•°æ®](../../07-å¤šæ¨¡å‹æ•°æ®åº“/PostGISç©ºé—´æ•°æ®å®Œæ•´å®æˆ˜æŒ‡å—.md)

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 æ™¯ç‚¹ç©ºé—´å’Œå‘é‡è¡¨åˆ›å»º

**åˆ›å»ºæ—…æ¸¸æ¨èç³»ç»Ÿæ•°æ®è¡¨**ï¼š

```sql
-- å¯ç”¨pgvectorå’ŒPostGISæ‰©å±•
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS postgis;

-- åˆ›å»ºæ™¯ç‚¹è¡¨
CREATE TABLE attractions (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    location GEOGRAPHY(POINT, 4326),  -- åœ°ç†ä½ç½®ï¼ˆç»çº¬åº¦ï¼‰
    rating DECIMAL(3, 2),
    embedding vector(1536),  -- æ™¯ç‚¹ç‰¹å¾å‘é‡
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    current_location GEOGRAPHY(POINT, 4326),  -- å½“å‰ä½ç½®
    embedding vector(1536),  -- ç”¨æˆ·åå¥½å‘é‡
    preferences JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡Œä¸ºè¡¨
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    attraction_id INTEGER REFERENCES attractions(id),
    behavior_type TEXT,  -- 'view', 'like', 'visit', 'review'
    rating INTEGER,  -- 1-5æ˜Ÿè¯„åˆ†
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç©ºé—´ç´¢å¼•
CREATE INDEX idx_attractions_location ON attractions USING GIST (location);
CREATE INDEX idx_users_location ON users USING GIST (current_location);
-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_attractions_embedding ON attractions USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_users_embedding ON users USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_attractions_category ON attractions (category);
CREATE INDEX idx_user_behaviors_user_time ON user_behaviors (user_id, timestamp DESC);
```

### 8.2 åŸºäºä½ç½®çš„æ¨èå®ç°

**PythonåŸºäºä½ç½®çš„æ¨è**ï¼š

```python
import psycopg2
from typing import List, Dict
from shapely.geometry import Point

class LocationBasedRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–åŸºäºä½ç½®çš„æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def recommend_nearby(self, user_location: Point, radius_km: float = 10,
                        limit: int = 20) -> List[Dict]:
        """æ¨èé™„è¿‘æ™¯ç‚¹"""
        # å°†Pointè½¬æ¢ä¸ºPostGISæ ¼å¼ï¼ˆç»åº¦, çº¬åº¦ï¼‰
        lon, lat = user_location.x, user_location.y

        self.cur.execute("""
            SELECT
                id,
                name,
                description,
                category,
                rating,
                ST_Distance(location::geography, ST_SetSRID(ST_MakePoint(%s, %s), 4326)::geography) / 1000 AS distance_km
            FROM attractions
            WHERE ST_DWithin(
                location::geography,
                ST_SetSRID(ST_MakePoint(%s, %s), 4326)::geography,
                %s * 1000
            )
            ORDER BY rating DESC, distance_km ASC
            LIMIT %s
        """, (lon, lat, lon, lat, radius_km, limit))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'name': row[1],
                'description': row[2],
                'category': row[3],
                'rating': float(row[4]) if row[4] else 0,
                'distance_km': float(row[5])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
from shapely.geometry import Point

location_recommender = LocationBasedRecommender("host=localhost dbname=testdb user=postgres password=secret")

# æ¨èé™„è¿‘æ™¯ç‚¹ï¼ˆä¾‹å¦‚ï¼šåŒ—äº¬å¤©å®‰é—¨é™„è¿‘ï¼‰
user_location = Point(116.3974, 39.9093)  # ç»åº¦, çº¬åº¦
nearby_attractions = location_recommender.recommend_nearby(
    user_location, radius_km=20, limit=20
)
for attr in nearby_attractions:
    print(f"{attr['name']}: {attr['distance_km']:.2f}km, rating={attr['rating']}")
```

### 8.3 åŸºäºå†…å®¹çš„æ¨èå®ç°

**PythonåŸºäºå†…å®¹çš„æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict
from datetime import datetime

class ContentBasedRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–åŸºäºå†…å®¹çš„æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def update_user_preference(self, user_id: int):
        """æ›´æ–°ç”¨æˆ·åå¥½å‘é‡"""
        # è·å–ç”¨æˆ·è¡Œä¸ºï¼ˆæœ€è¿‘100æ¡ï¼‰
        self.cur.execute("""
            SELECT
                ub.attraction_id,
                ub.behavior_type,
                ub.rating,
                a.embedding
            FROM user_behaviors ub
            JOIN attractions a ON ub.attraction_id = a.id
            WHERE ub.user_id = %s
            ORDER BY ub.timestamp DESC
            LIMIT 100
        """, (user_id,))

        behaviors = self.cur.fetchall()

        if not behaviors:
            return

        # è¡Œä¸ºæƒé‡
        weights = {
            'visit': 3.0,
            'review': 2.5,
            'like': 2.0,
            'view': 1.0
        }

        # è®¡ç®—åŠ æƒå¹³å‡å‘é‡
        weighted_vectors = []
        for attraction_id, behavior_type, rating, embedding in behaviors:
            if embedding is None:
                continue

            weight = weights.get(behavior_type, 1.0)
            if rating:
                weight *= (rating / 5.0)

            weighted_vectors.append(np.array(embedding) * weight)

        if not weighted_vectors:
            return

        # è®¡ç®—ç”¨æˆ·åå¥½å‘é‡
        user_embedding = np.mean(weighted_vectors, axis=0)

        # æ›´æ–°ç”¨æˆ·å‘é‡
        self.cur.execute("""
            UPDATE users
            SET embedding = %s
            WHERE id = %s
        """, (user_embedding.tolist(), user_id))

        self.conn.commit()

    def recommend_by_content(self, user_id: int, limit: int = 20) -> List[Dict]:
        """åŸºäºå†…å®¹æ¨è"""
        # æ›´æ–°ç”¨æˆ·åå¥½
        self.update_user_preference(user_id)

        # è·å–ç”¨æˆ·åå¥½å‘é‡
        self.cur.execute("""
            SELECT embedding
            FROM users
            WHERE id = %s
        """, (user_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        user_embedding = result[0]

        # æŸ¥æ‰¾ç›¸ä¼¼æ™¯ç‚¹ï¼ˆæ’é™¤å·²è®¿é—®è¿‡çš„ï¼‰
        self.cur.execute("""
            SELECT
                a.id,
                a.name,
                a.description,
                a.category,
                a.rating,
                1 - (a.embedding <=> %s) AS similarity
            FROM attractions a
            WHERE a.id NOT IN (
                SELECT DISTINCT attraction_id
                FROM user_behaviors
                WHERE user_id = %s AND behavior_type = 'visit'
            )
            ORDER BY a.embedding <=> %s
            LIMIT %s
        """, (user_embedding, user_id, user_embedding, limit))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'name': row[1],
                'description': row[2],
                'category': row[3],
                'rating': float(row[4]) if row[4] else 0,
                'similarity': float(row[5])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
content_recommender = ContentBasedRecommender("host=localhost dbname=testdb user=postgres password=secret")

# åŸºäºå†…å®¹æ¨è
recommendations = content_recommender.recommend_by_content(user_id=1, limit=20)
for rec in recommendations:
    print(f"{rec['name']}: similarity={rec['similarity']:.4f}, rating={rec['rating']}")
```

### 8.4 æ··åˆæ¨èå®ç°

**Pythonæ··åˆæ¨èï¼ˆä½ç½®+å†…å®¹ï¼‰**ï¼š

```python
import psycopg2
from typing import List, Dict
from shapely.geometry import Point

class HybridTravelRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–æ··åˆæ—…æ¸¸æ¨èå™¨"""
        self.location_recommender = LocationBasedRecommender(conn_str)
        self.content_recommender = ContentBasedRecommender(conn_str)

    def rrf_fusion(self, list1: List[Dict], list2: List[Dict], k: int = 60) -> List[Dict]:
        """RRFèåˆç®—æ³•"""
        scores = {}

        # è®¡ç®—ç¬¬ä¸€ä¸ªåˆ—è¡¨çš„RRFåˆ†æ•°
        for rank, item in enumerate(list1, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {
                    'item': item,
                    'score': 0.0
                }
            scores[item_id]['score'] += 1.0 / (k + rank)

        # è®¡ç®—ç¬¬äºŒä¸ªåˆ—è¡¨çš„RRFåˆ†æ•°
        for rank, item in enumerate(list2, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {
                    'item': item,
                    'score': 0.0
                }
            scores[item_id]['score'] += 1.0 / (k + rank)

        # æŒ‰åˆ†æ•°æ’åº
        sorted_results = sorted(
            scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )

        return [r['item'] for r in sorted_results]

    def hybrid_recommend(self, user_id: int, user_location: Point,
                        radius_km: float = 20, limit: int = 20) -> List[Dict]:
        """æ··åˆæ¨èï¼ˆä½ç½®+å†…å®¹ï¼‰"""
        # 1. åŸºäºä½ç½®çš„æ¨è
        location_recommendations = self.location_recommender.recommend_nearby(
            user_location, radius_km, limit * 2
        )

        # 2. åŸºäºå†…å®¹çš„æ¨è
        content_recommendations = self.content_recommender.recommend_by_content(
            user_id, limit * 2
        )

        # 3. RRFèåˆ
        fused_recommendations = self.rrf_fusion(
            location_recommendations,
            content_recommendations,
            k=60
        )

        return fused_recommendations[:limit]

# ä½¿ç”¨ç¤ºä¾‹
from shapely.geometry import Point

hybrid_recommender = HybridTravelRecommender("host=localhost dbname=testdb user=postgres password=secret")

# æ··åˆæ¨è
user_location = Point(116.3974, 39.9093)  # åŒ—äº¬å¤©å®‰é—¨
recommendations = hybrid_recommender.hybrid_recommend(
    user_id=1, user_location=user_location, radius_km=20, limit=20
)
for rec in recommendations:
    print(f"{rec['name']}: distance={rec.get('distance_km', 'N/A')}km, "
          f"similarity={rec.get('similarity', 'N/A')}")
```

### 8.5 è·¯çº¿è§„åˆ’å®ç°

**Pythonè·¯çº¿è§„åˆ’**ï¼š

```python
import psycopg2
from typing import List, Dict
from shapely.geometry import Point

class RoutePlanner:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–è·¯çº¿è§„åˆ’å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def plan_route(self, start_location: Point, attraction_ids: List[int]) -> Dict:
        """è§„åˆ’æ—…æ¸¸è·¯çº¿"""
        if not attraction_ids:
            return {'route': [], 'total_distance': 0, 'estimated_time': 0}

        # è·å–æ™¯ç‚¹ä½ç½®
        placeholders = ','.join(['%s'] * len(attraction_ids))
        self.cur.execute(f"""
            SELECT id, name, location
            FROM attractions
            WHERE id IN ({placeholders})
        """, tuple(attraction_ids))

        attractions = self.cur.fetchall()

        # è®¡ç®—ä»èµ·ç‚¹åˆ°æ¯ä¸ªæ™¯ç‚¹çš„è·ç¦»
        start_lon, start_lat = start_location.x, start_location.y
        distances = []
        for attr_id, name, location in attractions:
            self.cur.execute("""
                SELECT ST_Distance(
                    location::geography,
                    ST_SetSRID(ST_MakePoint(%s, %s), 4326)::geography
                ) / 1000 AS distance_km
            """, (start_lon, start_lat))
            distance = self.cur.fetchone()[0]
            distances.append((attr_id, name, float(distance)))

        # ç®€å•è´ªå¿ƒç®—æ³•ï¼šé€‰æ‹©æœ€è¿‘çš„æœªè®¿é—®æ™¯ç‚¹
        route = []
        current_location = start_location
        remaining = distances.copy()
        total_distance = 0.0

        while remaining:
            # æ‰¾åˆ°æœ€è¿‘çš„æ™¯ç‚¹
            remaining.sort(key=lambda x: x[2])
            next_attr = remaining.pop(0)
            route.append({
                'id': next_attr[0],
                'name': next_attr[1],
                'distance_from_previous': next_attr[2]
            })
            total_distance += next_attr[2]

            # æ›´æ–°å½“å‰ä½ç½®ï¼ˆç®€åŒ–å¤„ç†ï¼Œä½¿ç”¨æ™¯ç‚¹ä½ç½®ï¼‰
            self.cur.execute("""
                SELECT ST_X(location::geometry), ST_Y(location::geometry)
                FROM attractions
                WHERE id = %s
            """, (next_attr[0],))
            lon, lat = self.cur.fetchone()
            current_location = Point(lon, lat)

            # é‡æ–°è®¡ç®—å‰©ä½™æ™¯ç‚¹åˆ°å½“å‰ä½ç½®çš„è·ç¦»
            for i, (attr_id, name, _) in enumerate(remaining):
                self.cur.execute("""
                    SELECT ST_Distance(
                        location::geography,
                        ST_SetSRID(ST_MakePoint(%s, %s), 4326)::geography
                    ) / 1000 AS distance_km
                """, (lon, lat))
                distance = self.cur.fetchone()[0]
                remaining[i] = (attr_id, name, float(distance))

        # ä¼°ç®—æ—¶é—´ï¼ˆå‡è®¾æ¯ä¸ªæ™¯ç‚¹åœç•™1å°æ—¶ï¼Œå¹³å‡é€Ÿåº¦50km/hï¼‰
        estimated_time = len(route) * 1.0 + (total_distance / 50.0)

        return {
            'route': route,
            'total_distance_km': total_distance,
            'estimated_time_hours': estimated_time
        }

# ä½¿ç”¨ç¤ºä¾‹
from shapely.geometry import Point

route_planner = RoutePlanner("host=localhost dbname=testdb user=postgres password=secret")

# è§„åˆ’è·¯çº¿
start_location = Point(116.3974, 39.9093)  # èµ·ç‚¹
attraction_ids = [1, 2, 3, 4, 5]  # è¦è®¿é—®çš„æ™¯ç‚¹ID
route = route_planner.plan_route(start_location, attraction_ids)

print(f"Total distance: {route['total_distance_km']:.2f}km")
print(f"Estimated time: {route['estimated_time_hours']:.2f} hours")
for i, stop in enumerate(route['route'], 1):
    print(f"{i}. {stop['name']}: {stop['distance_from_previous']:.2f}km from previous")
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-15-01
