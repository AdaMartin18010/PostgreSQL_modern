---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\05-é‡‘èäº¤æ˜“ç³»ç»Ÿ\02-æ¶æ„è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹5ï¼šé‡‘èäº¤æ˜“ç³»ç»Ÿ - æ¶æ„è®¾è®¡

## å…ƒæ•°æ®

- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **æ¶æ„æ¨¡å¼**: CQRS + Event Sourcing
- **ACID**: SERIALIZABLEéš”ç¦»çº§åˆ«

---

## 1. æ€»ä½“æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              é‡‘èäº¤æ˜“ç³»ç»Ÿæ¶æ„                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  [äº¤æ˜“è¯·æ±‚]                                               â”‚
â”‚      â”‚                                                     â”‚
â”‚  [API Gateway]                                            â”‚
â”‚      â”‚                                                     â”‚
â”‚  [äº¤æ˜“æœåŠ¡] â”€â”€> [PostgreSQL 18]                          â”‚
â”‚      â”‚            (SERIALIZABLE)                          â”‚
â”‚      â”‚                 â”‚                                   â”‚
â”‚      â”‚                 â”œâ”€> [è´¦æˆ·è¡¨]                       â”‚
â”‚      â”‚                 â”œâ”€> [äº¤æ˜“è¡¨]                       â”‚
â”‚      â”‚                 â”œâ”€> [å®¡è®¡æ—¥å¿—]                     â”‚
â”‚      â”‚                 â””â”€> [äº‹ä»¶è¡¨]                       â”‚
â”‚      â”‚                                                     â”‚
â”‚  [å¯¹è´¦æœåŠ¡] â”€â”€> å®šæ—¶å¯¹è´¦                                  â”‚
â”‚      â”‚                                                     â”‚
â”‚  [å®¡è®¡æœåŠ¡] â”€â”€> å®¡è®¡æ—¥å¿—åˆ†æ                              â”‚
â”‚                                                            â”‚
â”‚  [ç›‘æ§å‘Šè­¦]                                               â”‚
â”‚  â”œâ”€ TPSç›‘æ§                                               â”‚
â”‚  â”œâ”€ å»¶è¿Ÿç›‘æ§                                              â”‚
â”‚  â””â”€ å¼‚å¸¸æ£€æµ‹                                              â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ACIDä¿è¯è®¾è®¡

### 2.1 å¼ºä¸€è‡´æ€§ç­–ç•¥

**éš”ç¦»çº§åˆ«**: SERIALIZABLE

```sql
-- å…¨å±€é…ç½®
ALTER SYSTEM SET default_transaction_isolation = 'serializable';

-- æˆ–å•ä¸ªäº‹åŠ¡
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- äº¤æ˜“æ“ä½œ
COMMIT;
```

**åŸå­æ€§ä¿è¯**:

- âœ… è½¬è´¦æ“ä½œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥
- âœ… ä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§
- âœ… ä¹è§‚é”å¤„ç†å¹¶å‘å†²çª

**æŒä¹…æ€§ä¿è¯**:

- âœ… åŒæ­¥æäº¤WAL
- âœ… ä¸»ä»åŒæ­¥å¤åˆ¶
- âœ… å®šæœŸå¤‡ä»½

---

## 3. æ ¸å¿ƒä¸šåŠ¡æµç¨‹

### 3.1 è½¬è´¦æµç¨‹

```text
è½¬è´¦è¯·æ±‚
  â”‚
  â”œâ”€> å‚æ•°éªŒè¯
  â”‚
  â”œâ”€> BEGIN TRANSACTION (SERIALIZABLE)
  â”‚
  â”œâ”€> æ£€æŸ¥ä½™é¢
  â”‚
  â”œâ”€> æ‰£æ¬¾ï¼ˆä¹è§‚é”ï¼‰
  â”‚
  â”œâ”€> å…¥è´¦
  â”‚
  â”œâ”€> è®°å½•äº¤æ˜“
  â”‚
  â”œâ”€> è®°å½•å®¡è®¡æ—¥å¿—
  â”‚
  â”œâ”€> COMMIT
  â”‚
  â””â”€> è¿”å›æˆåŠŸ
```

---

## 4. é«˜å¯ç”¨è®¾è®¡

```text
ä¸»ä»æ¶æ„:
  [Primary] â”€â”€åŒæ­¥å¤åˆ¶â”€â”€> [Standby 1]
      â”‚
      â””â”€â”€å¼‚æ­¥å¤åˆ¶â”€â”€> [Standby 2]

æ•…éšœè½¬ç§»:
  Primaryæ•…éšœ â†’ Standby 1è‡ªåŠ¨æå‡
  â”œâ”€ RPO: 0ï¼ˆåŒæ­¥å¤åˆ¶ï¼‰
  â””â”€ RTO: <30ç§’ï¼ˆè‡ªåŠ¨æ•…éšœè½¬ç§»ï¼‰
```

---

---

## 5. è¯¦ç»†æ¶æ„ç»„ä»¶

### 5.1 äº¤æ˜“æœåŠ¡å±‚

**äº¤æ˜“æœåŠ¡å±‚è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```python
"""
äº¤æ˜“æœåŠ¡å±‚
æŠ€æœ¯æ ˆ: FastAPI + PostgreSQL 18
"""

from fastapi import FastAPI, HTTPException
from typing import Optional
import psycopg2
from psycopg2.extras import RealDictCursor
from decimal import Decimal

app = FastAPI()

class TransactionService:
    """äº¤æ˜“æœåŠ¡"""

    def __init__(self, conn_str):
        self.conn = psycopg2.connect(conn_str, cursor_factory=RealDictCursor)
        self.cursor = self.conn.cursor()

    def transfer(
        self,
        from_account: str,
        to_account: str,
        amount: Decimal,
        user_id: int,
        request_id: str
    ):
        """è½¬è´¦ï¼ˆå¸¦å¹‚ç­‰æ€§ï¼‰"""

        try:
            # è®¾ç½®éš”ç¦»çº§åˆ«
            self.cursor.execute("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE")
            self.cursor.execute("BEGIN")

            # æ£€æŸ¥å¹‚ç­‰æ€§
            self.cursor.execute("""
                SELECT transaction_id FROM transaction_requests
                WHERE request_id = %s
            """, (request_id,))

            existing = self.cursor.fetchone()
            if existing:
                return {'transaction_id': existing['transaction_id'], 'status': 'duplicate'}

            # è°ƒç”¨æ•°æ®åº“è½¬è´¦å‡½æ•°
            self.cursor.execute("""
                SELECT transfer_money(%s, %s, %s, %s, %s)
            """, (request_id, from_account, to_account, amount, user_id))

            transaction_id = self.cursor.fetchone()[0]
            self.cursor.execute("COMMIT")

            return {
                'transaction_id': transaction_id,
                'status': 'success',
                'from_account': from_account,
                'to_account': to_account,
                'amount': float(amount)
            }

        except psycopg2.Error as e:
            self.cursor.execute("ROLLBACK")
            raise HTTPException(status_code=400, detail=str(e))

    def get_account_balance(self, account_id: str):
        """æŸ¥è¯¢è´¦æˆ·ä½™é¢"""

        self.cursor.execute("""
            SELECT account_id, balance, currency, status
            FROM accounts
            WHERE account_id = %s
        """, (account_id,))

        account = self.cursor.fetchone()
        if not account:
            raise HTTPException(status_code=404, detail="è´¦æˆ·ä¸å­˜åœ¨")

        return dict(account)

# APIæ¥å£
transaction_service = TransactionService("dbname=finance_db user=postgres")

@app.post("/api/transfer")
async def transfer(
    from_account: str,
    to_account: str,
    amount: Decimal,
    user_id: int,
    request_id: str
):
    """è½¬è´¦æ¥å£"""
    return transaction_service.transfer(from_account, to_account, amount, user_id, request_id)

@app.get("/api/account/{account_id}/balance")
async def get_balance(account_id: str):
    """æŸ¥è¯¢ä½™é¢æ¥å£"""
    return transaction_service.get_account_balance(account_id)
```

### 5.2 å¯¹è´¦æœåŠ¡

**å¯¹è´¦æœåŠ¡è®¾è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¯¹è´¦æœåŠ¡å‡½æ•°
CREATE OR REPLACE FUNCTION daily_reconciliation(
    p_reconciliation_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE (
    check_item TEXT,
    expected_value NUMERIC,
    actual_value NUMERIC,
    difference NUMERIC,
    status TEXT
) AS $$
DECLARE
    total_debit NUMERIC;
    total_credit NUMERIC;
    account_sum NUMERIC;
BEGIN
    -- æ£€æŸ¥å€Ÿè´·å¹³è¡¡
    SELECT
        COALESCE(SUM(amount), 0),
        COALESCE(SUM(CASE WHEN type = 'DEBIT' THEN amount ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN type = 'CREDIT' THEN amount ELSE 0 END), 0)
    INTO total_debit, total_debit, total_credit
    FROM transactions
    WHERE DATE(created_at) = p_reconciliation_date;

    -- æ£€æŸ¥è´¦æˆ·ä½™é¢æ€»å’Œ
    SELECT COALESCE(SUM(balance), 0) INTO account_sum
    FROM accounts;

    -- è¿”å›å¯¹è´¦ç»“æœ
    RETURN QUERY SELECT
        'å€Ÿè´·å¹³è¡¡'::TEXT,
        total_debit,
        total_credit,
        ABS(total_debit - total_credit),
        CASE
            WHEN ABS(total_debit - total_credit) < 0.01 THEN 'å¹³è¡¡'
            ELSE 'ä¸å¹³è¡¡'
        END;

    RETURN QUERY SELECT
        'è´¦æˆ·ä½™é¢æ€»å’Œ'::TEXT,
        account_sum,
        account_sum,
        0::NUMERIC,
        'æ­£å¸¸'::TEXT;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å¯¹è´¦å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. ç›‘æ§ä¸å‘Šè­¦

### 6.1 äº¤æ˜“æ€§èƒ½ç›‘æ§

**äº¤æ˜“æ€§èƒ½ç›‘æ§è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- äº¤æ˜“æ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_transaction_performance AS
SELECT
    date_trunc('hour', created_at) AS hour,
    COUNT(*) AS transaction_count,
    COUNT(*) FILTER (WHERE status = 'success') AS success_count,
    COUNT(*) FILTER (WHERE status = 'failed') AS failed_count,
    ROUND(AVG(EXTRACT(EPOCH FROM (updated_at - created_at)) * 1000), 2) AS avg_duration_ms,
    ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (updated_at - created_at)) * 1000), 2) AS p95_duration_ms,
    ROUND(COUNT(*) FILTER (WHERE status = 'success') * 100.0 / COUNT(*), 2) AS success_rate
FROM transactions
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY date_trunc('hour', created_at)
ORDER BY hour DESC;

-- æŸ¥è¯¢ç›‘æ§æ•°æ®
SELECT * FROM v_transaction_performance;
```

### 6.2 å¼‚å¸¸æ£€æµ‹

**å¼‚å¸¸æ£€æµ‹å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¼‚å¸¸æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION detect_anomalies(
    p_hours INT DEFAULT 24
)
RETURNS TABLE (
    anomaly_type TEXT,
    description TEXT,
    severity TEXT,
    detected_at TIMESTAMPTZ
) AS $$
DECLARE
    avg_tps NUMERIC;
    current_tps NUMERIC;
    error_rate NUMERIC;
BEGIN
    -- æ£€æµ‹TPSå¼‚å¸¸
    SELECT AVG(transaction_count) INTO avg_tps
    FROM v_transaction_performance
    WHERE hour > NOW() - INTERVAL '7 days';

    SELECT transaction_count INTO current_tps
    FROM v_transaction_performance
    WHERE hour = date_trunc('hour', NOW())
    LIMIT 1;

    IF current_tps > avg_tps * 2 THEN
        RETURN QUERY SELECT
            'TPSå¼‚å¸¸'::TEXT,
            format('å½“å‰TPS: %s, å¹³å‡TPS: %s', current_tps, avg_tps)::TEXT,
            'è­¦å‘Š'::TEXT,
            NOW();
    END IF;

    -- æ£€æµ‹é”™è¯¯ç‡å¼‚å¸¸
    SELECT AVG(100.0 - success_rate) INTO error_rate
    FROM v_transaction_performance
    WHERE hour > NOW() - (p_hours || ' hours')::INTERVAL;

    IF error_rate > 1.0 THEN
        RETURN QUERY SELECT
            'é”™è¯¯ç‡å¼‚å¸¸'::TEXT,
            format('é”™è¯¯ç‡: %.2f%%', error_rate)::TEXT,
            'ä¸¥é‡'::TEXT,
            NOW();
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å¼‚å¸¸æ£€æµ‹å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. å®‰å…¨è®¾è®¡

### 7.1 å®¡è®¡æ—¥å¿—

**å®¡è®¡æ—¥å¿—é…ç½®ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¯ç”¨å®¡è®¡æ—¥å¿—
ALTER SYSTEM SET log_statement = 'all';
ALTER SYSTEM SET log_connections = on;
ALTER SYSTEM SET log_disconnections = on;
ALTER SYSTEM SET log_duration = on;
SELECT pg_reload_conf();

-- å®¡è®¡æ—¥å¿—æŸ¥è¯¢å‡½æ•°
CREATE OR REPLACE FUNCTION query_audit_logs(
    p_start_time TIMESTAMPTZ DEFAULT NOW() - INTERVAL '1 day',
    p_end_time TIMESTAMPTZ DEFAULT NOW(),
    p_user_id INT DEFAULT NULL
)
RETURNS TABLE (
    log_time TIMESTAMPTZ,
    user_id INT,
    operation TEXT,
    table_name TEXT,
    details JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        created_at AS log_time,
        user_id,
        operation,
        table_name,
        new_values AS details
    FROM audit_logs
    WHERE created_at BETWEEN p_start_time AND p_end_time
      AND (p_user_id IS NULL OR user_id = p_user_id)
    ORDER BY created_at DESC
    LIMIT 1000;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢å®¡è®¡æ—¥å¿—å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**å®Œæˆæ—¥æœŸ**: 2025-12-04
**ACIDçº§åˆ«**: æœ€é«˜
**å¯ç”¨æ€§**: 99.99%

**è¿”å›**: [æ¡ˆä¾‹5ä¸»é¡µ](./README.md)
