# PostgreSQL电商行业完整案例

> **PostgreSQL版本**: 18.x
> **行业**: 电商
> **特点**: 高并发、秒杀、推荐系统、搜索
> **参考案例**: [01-电商秒杀系统](./01-电商秒杀系统/README.md)

---

## 📋 目录

- [PostgreSQL电商行业完整案例](#postgresql电商行业完整案例)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 电商行业特点](#11-电商行业特点)
    - [1.2 核心场景](#12-核心场景)
  - [2. 电商行业核心场景](#2-电商行业核心场景)
    - [2.1 秒杀系统](#21-秒杀系统)
    - [2.2 商品搜索](#22-商品搜索)
    - [2.3 推荐系统](#23-推荐系统)
  - [3. 技术架构](#3-技术架构)
    - [3.1 高并发架构](#31-高并发架构)
    - [3.2 缓存策略](#32-缓存策略)
  - [4. 数据库设计](#4-数据库设计)
    - [4.1 商品表设计](#41-商品表设计)
    - [4.2 订单表设计](#42-订单表设计)
  - [5. 性能优化](#5-性能优化)
    - [5.1 秒杀优化](#51-秒杀优化)
    - [5.2 搜索优化](#52-搜索优化)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 秒杀系统](#61-秒杀系统)
    - [6.2 搜索系统](#62-搜索系统)
    - [6.3 推荐系统](#63-推荐系统)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 电商行业特点

电商行业对数据库的要求：

- ✅ **高并发**: 10万+ QPS（秒杀场景）
- ✅ **低延迟**: P99 < 100ms
- ✅ **高可用**: 99.99%+可用性
- ✅ **推荐系统**: 个性化推荐
- ✅ **搜索系统**: 全文搜索

### 1.2 核心场景

- **秒杀系统**: 高并发秒杀
- **商品搜索**: 全文搜索
- **推荐系统**: 个性化推荐
- **订单系统**: 订单处理
- **库存管理**: 库存扣减

---

## 2. 电商行业核心场景

### 2.1 秒杀系统

**参考**: [01-电商秒杀系统](./01-电商秒杀系统/README.md)

**核心需求**:

- 10万+ QPS
- 零超卖
- 低延迟
- 高可用

**技术方案**:

```sql
-- 商品表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            CREATE TABLE products (
                product_id BIGSERIAL PRIMARY KEY,
                name TEXT NOT NULL,
                stock INT NOT NULL,
                price NUMERIC(10,2) NOT NULL
            );
            RAISE NOTICE '表 products 创建成功';
        ELSE
            RAISE NOTICE '表 products 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 products 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 秒杀订单表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'seckill_orders') THEN
            CREATE TABLE seckill_orders (
                order_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                product_id BIGINT NOT NULL,
                quantity INT NOT NULL DEFAULT 1,
                status TEXT DEFAULT 'pending',
                created_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 seckill_orders 创建成功';
        ELSE
            RAISE NOTICE '表 seckill_orders 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 seckill_orders 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 秒杀扣库存（使用SERIALIZABLE）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') AND
           EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'seckill_orders') THEN
            BEGIN
                SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
                UPDATE products
                SET stock = stock - 1
                WHERE product_id = 12345
                AND stock > 0;

                IF FOUND THEN
                    INSERT INTO seckill_orders (user_id, product_id)
                    VALUES (67890, 12345);
                    COMMIT;
                    RAISE NOTICE '秒杀扣库存成功';
                ELSE
                    ROLLBACK;
                    RAISE NOTICE '库存不足，秒杀失败';
                END IF;
            EXCEPTION
                WHEN serialization_failure THEN
                    ROLLBACK;
                    RAISE WARNING '序列化失败，请重试';
                WHEN OTHERS THEN
                    ROLLBACK;
                    RAISE WARNING '秒杀扣库存失败: %', SQLERRM;
                    RAISE;
            END;
        ELSE
            RAISE NOTICE '表不存在，跳过秒杀扣库存';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 2.2 商品搜索

**核心需求**:

- 全文搜索
- 多条件筛选
- 排序优化
- 搜索建议

**技术方案**:

```sql
-- 商品表（全文搜索）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            CREATE TABLE products (
                product_id BIGSERIAL PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                category_id INT,
                price NUMERIC(10,2),
                search_vector tsvector
            );
            RAISE NOTICE '表 products 创建成功';
        ELSE
            RAISE NOTICE '表 products 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 products 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建全文搜索索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_search') THEN
                CREATE INDEX idx_products_search ON products USING GIN(search_vector);
                RAISE NOTICE '全文搜索索引创建成功';
            ELSE
                RAISE NOTICE '索引 idx_products_search 已存在';
            END IF;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 更新搜索向量（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            DROP TRIGGER IF EXISTS products_search_update ON products;
            CREATE TRIGGER products_search_update
            BEFORE INSERT OR UPDATE ON products
            FOR EACH ROW EXECUTE FUNCTION
            tsvector_update_trigger(search_vector, 'pg_catalog.english', name, description);
            RAISE NOTICE '触发器 products_search_update 创建成功';
        ELSE
            RAISE NOTICE '表 products 不存在，跳过触发器创建';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建触发器失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 全文搜索查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    product_id,
    name,
    price,
    ts_rank(search_vector, query) as rank
FROM products, to_tsquery('english', 'laptop') query
WHERE search_vector @@ query
ORDER BY rank DESC
LIMIT 20;
```

### 2.3 推荐系统

**核心需求**:

- 个性化推荐
- 实时更新
- 向量搜索
- 混合推荐

**技术方案**:

```sql
-- 用户向量表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'user_vectors') THEN
            CREATE TABLE user_vectors (
                user_id BIGINT PRIMARY KEY,
                preference_vector vector(128),
                updated_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 user_vectors 创建成功';
        ELSE
            RAISE NOTICE '表 user_vectors 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 user_vectors 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 商品向量表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'product_vectors') THEN
            CREATE TABLE product_vectors (
                product_id BIGINT PRIMARY KEY,
                embedding vector(128),
                updated_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 product_vectors 创建成功';
        ELSE
            RAISE NOTICE '表 product_vectors 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 product_vectors 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 向量索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'user_vectors') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_user_vectors') THEN
                CREATE INDEX idx_user_vectors ON user_vectors USING hnsw (preference_vector vector_l2_ops);
            END IF;
        END IF;

        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'product_vectors') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_product_vectors') THEN
                CREATE INDEX idx_product_vectors ON product_vectors USING hnsw (embedding vector_l2_ops);
            END IF;
        END IF;
        RAISE NOTICE '向量索引创建完成';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 向量相似度搜索（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    p.product_id,
    p.name,
    p.price,
    1 - (u.preference_vector <=> p.embedding) as similarity
FROM user_vectors u
CROSS JOIN product_vectors p
WHERE u.user_id = 12345
ORDER BY similarity DESC
LIMIT 20;
```

---

## 3. 技术架构

### 3.1 高并发架构

```text
应用层 (多实例)
    ↓
负载均衡
    ↓
连接池 (PgBouncer)
    ↓
PostgreSQL集群
├── 主库 (读写)
├── 从库1 (只读 - 搜索)
├── 从库2 (只读 - 推荐)
└── 从库3 (只读 - 报表)
    ↓
缓存层 (Redis)
```

### 3.2 缓存策略

```text
缓存层次:
1. 应用层缓存 (Redis) - 热点商品
2. 连接池缓存 - 连接复用
3. PostgreSQL共享缓冲区 - 数据缓存
```

---

## 4. 数据库设计

### 4.1 商品表设计

```sql
-- 商品表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            CREATE TABLE products (
                product_id BIGSERIAL PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                category_id INT,
                price NUMERIC(10,2) NOT NULL,
                stock INT NOT NULL DEFAULT 0,
                sales_count INT DEFAULT 0,
                rating NUMERIC(3,2),
                search_vector tsvector,
                embedding vector(128),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                updated_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 products 创建成功';
        ELSE
            RAISE NOTICE '表 products 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 products 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_category') THEN
                CREATE INDEX idx_products_category ON products(category_id);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_search') THEN
                CREATE INDEX idx_products_search ON products USING GIN(search_vector);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_embedding') THEN
                CREATE INDEX idx_products_embedding ON products USING hnsw (embedding vector_l2_ops);
            END IF;
            RAISE NOTICE '索引创建完成';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 订单表设计

```sql
-- 订单表（分区）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            CREATE TABLE orders (
                order_id BIGSERIAL,
                user_id BIGINT NOT NULL,
                product_id BIGINT NOT NULL,
                quantity INT NOT NULL,
                amount NUMERIC(10,2) NOT NULL,
                status TEXT DEFAULT 'pending',
                created_at TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (order_id, created_at)
            ) PARTITION BY RANGE (created_at);
            RAISE NOTICE '表 orders 创建成功';
        ELSE
            RAISE NOTICE '表 orders 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 orders 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 按月分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders_2025_01') THEN
                CREATE TABLE orders_2025_01 PARTITION OF orders
                FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
                RAISE NOTICE '分区 orders_2025_01 创建成功';
            ELSE
                RAISE NOTICE '分区 orders_2025_01 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 orders 不存在，跳过分区创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. 性能优化

### 5.1 秒杀优化

```sql
-- 使用PostgreSQL 18内置连接池（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 注意：ALTER SYSTEM SET 需要超级用户权限
        -- 这些设置会写入postgresql.auto.conf文件
        ALTER SYSTEM SET enable_builtin_connection_pooling = on;
        ALTER SYSTEM SET connection_pool_size = 200;
        RAISE NOTICE '连接池配置已设置（需要重启PostgreSQL或执行SELECT pg_reload_conf()）';
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '需要超级用户权限来设置系统参数';
        WHEN OTHERS THEN
            RAISE WARNING '设置连接池配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用异步I/O（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 注意：ALTER SYSTEM SET 需要超级用户权限
        ALTER SYSTEM SET io_direct = 'data,wal';
        RAISE NOTICE '异步I/O配置已设置（需要重启PostgreSQL或执行SELECT pg_reload_conf()）';
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '需要超级用户权限来设置系统参数';
        WHEN OTHERS THEN
            RAISE WARNING '设置异步I/O配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 重新加载配置（带错误处理）
DO $$
BEGIN
    BEGIN
        PERFORM pg_reload_conf();
        RAISE NOTICE '配置重新加载成功';
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '需要超级用户权限来重新加载配置';
        WHEN OTHERS THEN
            RAISE WARNING '重新加载配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 搜索优化

```sql
-- 优化全文搜索（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_search') THEN
                CREATE INDEX idx_products_search ON products USING GIN(search_vector);
                RAISE NOTICE '全文搜索索引创建成功';
            ELSE
                RAISE NOTICE '索引 idx_products_search 已存在';
            END IF;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用物化视图预聚合（带错误处理）
DO $$
BEGIN
    BEGIN
        DROP MATERIALIZED VIEW IF EXISTS mv_product_stats;
        CREATE MATERIALIZED VIEW mv_product_stats AS
        SELECT
            product_id,
            COUNT(*) as order_count,
            SUM(amount) as total_amount
        FROM orders
        GROUP BY product_id;
        RAISE NOTICE '物化视图 mv_product_stats 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建物化视图失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建唯一索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_matviews WHERE matviewname = 'mv_product_stats') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'mv_product_stats_product_id_idx') THEN
                CREATE UNIQUE INDEX ON mv_product_stats(product_id);
                RAISE NOTICE '唯一索引创建成功';
            ELSE
                RAISE NOTICE '唯一索引已存在';
            END IF;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM mv_product_stats WHERE product_id = 1 LIMIT 10;
```

---

## 6. 最佳实践

### 6.1 秒杀系统

- ✅ **使用SERIALIZABLE隔离级别**: 保证零超卖
- ✅ **连接池**: 减少连接开销
- ✅ **缓存预热**: 预热热点商品
- ✅ **限流**: 防止系统过载

### 6.2 搜索系统

- ✅ **全文搜索索引**: GIN索引
- ✅ **向量搜索**: HNSW索引
- ✅ **混合搜索**: 全文+向量
- ✅ **搜索建议**: 自动补全

### 6.3 推荐系统

- ✅ **向量搜索**: 相似度计算
- ✅ **实时更新**: 实时更新用户向量
- ✅ **混合推荐**: 协同过滤+内容推荐
- ✅ **A/B测试**: 优化推荐效果

---

## 📚 相关文档

- [01-电商秒杀系统](./01-电商秒杀系统/README.md) - 秒杀系统案例
- [02-查询与优化/02.07-全文搜索](../02-查询与优化/02.07-全文搜索/README.md) - 全文搜索
- [10-AI与机器学习](../10-AI与机器学习/README.md) - AI与机器学习

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
