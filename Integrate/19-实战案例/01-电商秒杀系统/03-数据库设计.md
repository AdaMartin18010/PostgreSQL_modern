---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\01-ç”µå•†ç§’æ€ç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# ç”µå•†ç§’æ€ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

> **æ¡ˆä¾‹ç±»å‹**: é«˜å¹¶å‘OLTPç³»ç»Ÿ
> **éš¾åº¦ç­‰çº§**: â­â­â­â­â­
> **PostgreSQLç‰ˆæœ¬**: 18.x â­é‡ç‚¹åº”ç”¨æ–°ç‰¹æ€§
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-04

---

## ğŸ“‹ ç›®å½•

- [ç”µå•†ç§’æ€ç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡](#ç”µå•†ç§’æ€ç³»ç»Ÿ---æ•°æ®åº“è®¾è®¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ•°æ®åº“æ¶æ„](#ä¸€æ•°æ®åº“æ¶æ„)
    - [1.1 æ•´ä½“æ¶æ„](#11-æ•´ä½“æ¶æ„)
    - [1.2 æ•°æ®åº“é…ç½®ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰](#12-æ•°æ®åº“é…ç½®postgresql-18ä¼˜åŒ–)
  - [äºŒã€è¡¨ç»“æ„è®¾è®¡](#äºŒè¡¨ç»“æ„è®¾è®¡)
    - [2.1 æ ¸å¿ƒè¡¨ç»“æ„](#21-æ ¸å¿ƒè¡¨ç»“æ„)
      - [å•†å“è¡¨ï¼ˆproductsï¼‰](#å•†å“è¡¨products)
      - [ç§’æ€æ´»åŠ¨è¡¨ï¼ˆflash\_salesï¼‰â­æ ¸å¿ƒè¡¨](#ç§’æ€æ´»åŠ¨è¡¨flash_salesæ ¸å¿ƒè¡¨)
      - [ç§’æ€è®¢å•è¡¨ï¼ˆflash\_ordersï¼‰](#ç§’æ€è®¢å•è¡¨flash_orders)
      - [ç”¨æˆ·è¡¨ï¼ˆç®€åŒ–ç‰ˆï¼‰](#ç”¨æˆ·è¡¨ç®€åŒ–ç‰ˆ)
    - [2.2 è¾…åŠ©è¡¨](#22-è¾…åŠ©è¡¨)
      - [ç§’æ€æ—¥å¿—è¡¨ï¼ˆflash\_logsï¼‰](#ç§’æ€æ—¥å¿—è¡¨flash_logs)
  - [ä¸‰ã€ç´¢å¼•è®¾è®¡](#ä¸‰ç´¢å¼•è®¾è®¡)
    - [3.1 ç´¢å¼•ç­–ç•¥](#31-ç´¢å¼•ç­–ç•¥)
    - [3.2 å…³é”®ç´¢å¼•å®šä¹‰](#32-å…³é”®ç´¢å¼•å®šä¹‰)
    - [3.3 ç´¢å¼•ç»´æŠ¤](#33-ç´¢å¼•ç»´æŠ¤)
  - [å››ã€PostgreSQL 18æ–°ç‰¹æ€§åº”ç”¨](#å››postgresql-18æ–°ç‰¹æ€§åº”ç”¨)
    - [4.1 å†…ç½®è¿æ¥æ± ](#41-å†…ç½®è¿æ¥æ± )
    - [4.2 å¼‚æ­¥I/O](#42-å¼‚æ­¥io)
    - [4.3 å¢é‡æ’åº](#43-å¢é‡æ’åº)
    - [4.4 B-æ ‘ç´¢å¼•è·³è¿‡æ‰«æ](#44-b-æ ‘ç´¢å¼•è·³è¿‡æ‰«æ)
    - [4.5 æ”¹è¿›çš„VACUUM](#45-æ”¹è¿›çš„vacuum)
    - [4.6 pg\_statå¢å¼ºç›‘æ§](#46-pg_statå¢å¼ºç›‘æ§)
  - [äº”ã€æ€§èƒ½ä¼˜åŒ–](#äº”æ€§èƒ½ä¼˜åŒ–)
    - [5.1 æ ¸å¿ƒSQLä¼˜åŒ–](#51-æ ¸å¿ƒsqlä¼˜åŒ–)
      - [ç§’æ€ä¸‹å•ï¼ˆæ ¸å¿ƒSQLï¼‰](#ç§’æ€ä¸‹å•æ ¸å¿ƒsql)
      - [æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–](#æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–)
    - [5.2 è¿æ¥æŸ¥è¯¢ä¼˜åŒ–](#52-è¿æ¥æŸ¥è¯¢ä¼˜åŒ–)
  - [å…­ã€æ•°æ®ä¸€è‡´æ€§ä¿è¯](#å…­æ•°æ®ä¸€è‡´æ€§ä¿è¯)
    - [6.1 äº‹åŠ¡éš”ç¦»çº§åˆ«](#61-äº‹åŠ¡éš”ç¦»çº§åˆ«)
    - [6.2 çº¦æŸä¿è¯](#62-çº¦æŸä¿è¯)
    - [6.3 æ•°æ®æ ¡éªŒ](#63-æ•°æ®æ ¡éªŒ)
  - [ä¸ƒã€å¤‡ä»½ä¸æ¢å¤](#ä¸ƒå¤‡ä»½ä¸æ¢å¤)

---

## ä¸€ã€æ•°æ®åº“æ¶æ„

### 1.1 æ•´ä½“æ¶æ„

```mermaid
graph TB
    subgraph "åº”ç”¨å±‚"
        App[åº”ç”¨æœåŠ¡å™¨é›†ç¾¤]
    end

    subgraph "è¿æ¥æ± å±‚ - PostgreSQL 18æ–°ç‰¹æ€§"
        BuiltinPool[å†…ç½®è¿æ¥æ± <br/>2000è¿æ¥]
    end

    subgraph "æ•°æ®åº“å±‚"
        Master[(ä¸»åº“<br/>å†™æ“ä½œ<br/>PostgreSQL 18)]
        Slave1[(ä»åº“1<br/>è¯»æ“ä½œ)]
        Slave2[(ä»åº“2<br/>è¯»æ“ä½œ)]
    end

    subgraph "å­˜å‚¨å±‚"
        NVMe[NVMe SSD<br/>å¼‚æ­¥I/O]
    end

    App -->|å†™è¯·æ±‚| BuiltinPool
    App -->|è¯»è¯·æ±‚| Slave1
    App -->|è¯»è¯·æ±‚| Slave2

    BuiltinPool --> Master
    Master -->|æµå¤åˆ¶| Slave1
    Master -->|æµå¤åˆ¶| Slave2

    Master --> NVMe
    Slave1 --> NVMe
    Slave2 --> NVMe

    style BuiltinPool fill:#ffd700
    style Master fill:#ff6b6b
    style NVMe fill:#90ee90
```

### 1.2 æ•°æ®åº“é…ç½®ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰

```ini
# postgresql.conf - ç§’æ€åœºæ™¯ä¸“ç”¨é…ç½®

#------------------------------------------------------------------------------
# CONNECTION SETTINGS
#------------------------------------------------------------------------------

# â­ PostgreSQL 18æ–°ç‰¹æ€§ï¼šå†…ç½®è¿æ¥æ± 
builtin_connection_pool = on
max_pool_size = 2000
pool_mode = 'transaction'
pool_connection_timeout = 5000
pool_idle_timeout = 60000

max_connections = 2000
superuser_reserved_connections = 5

#------------------------------------------------------------------------------
# MEMORY SETTINGS
#------------------------------------------------------------------------------

shared_buffers = 64GB              # æ€»å†…å­˜256GBçš„25%
effective_cache_size = 192GB        # æ€»å†…å­˜çš„75%
work_mem = 32MB                    # æ¯ä¸ªæ“ä½œçš„å·¥ä½œå†…å­˜
maintenance_work_mem = 2GB         # VACUUM, CREATE INDEXç­‰

#------------------------------------------------------------------------------
# ASYNCHRONOUS I/O (PostgreSQL 18)
#------------------------------------------------------------------------------

# â­ PostgreSQL 18æ–°ç‰¹æ€§ï¼šå¼‚æ­¥I/O
aio_enabled = on
max_aio_events = 1000
aio_priority = 2
aio_batch_size = 32

#------------------------------------------------------------------------------
# WAL SETTINGS
#------------------------------------------------------------------------------

wal_level = replica
wal_buffers = 256MB
min_wal_size = 4GB
max_wal_size = 16GB
checkpoint_completion_target = 0.9
checkpoint_timeout = 15min

#------------------------------------------------------------------------------
# QUERY TUNING
#------------------------------------------------------------------------------

# â­ PostgreSQL 18ï¼šæ”¹è¿›çš„æŸ¥è¯¢ä¼˜åŒ–å™¨
enable_incremental_sort = on          # å¢é‡æ’åº
enable_index_skip_scan = on           # ç´¢å¼•è·³è¿‡æ‰«æ
enable_hash_right_semi_join = on      # å³åŠè¿æ¥

random_page_cost = 1.1                # NVMe SSD
effective_io_concurrency = 200
max_parallel_workers = 16
max_parallel_workers_per_gather = 4

#------------------------------------------------------------------------------
# STATISTICS
#------------------------------------------------------------------------------

# â­ PostgreSQL 18ï¼šå¢å¼ºçš„ç»Ÿè®¡ä¿¡æ¯
default_statistics_target = 200
track_io_timing = on
track_functions = all

#------------------------------------------------------------------------------
# AUTOVACUUM
#------------------------------------------------------------------------------

autovacuum = on
autovacuum_max_workers = 4
autovacuum_naptime = 10s
autovacuum_vacuum_scale_factor = 0.01
autovacuum_analyze_scale_factor = 0.005

#------------------------------------------------------------------------------
# LOGGING
#------------------------------------------------------------------------------

logging_collector = on
log_destination = 'csvlog'
log_min_duration_statement = 1000     # è®°å½•>1ç§’çš„æŸ¥è¯¢
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on
```

---

## äºŒã€è¡¨ç»“æ„è®¾è®¡

### 2.1 æ ¸å¿ƒè¡¨ç»“æ„

#### å•†å“è¡¨ï¼ˆproductsï¼‰

```sql
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    normal_price NUMERIC(10,2) NOT NULL CHECK (normal_price > 0),
    stock INT NOT NULL DEFAULT 0 CHECK (stock >= 0),
    category_id INT,
    brand VARCHAR(100),
    image_urls TEXT[],  -- æ•°ç»„ç±»å‹
    attributes JSONB,   -- å•†å“å±æ€§ï¼ˆçµæ´»schemaï¼‰
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'deleted')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- æ³¨é‡Š
COMMENT ON TABLE products IS 'å•†å“åŸºç¡€ä¿¡æ¯è¡¨';
COMMENT ON COLUMN products.attributes IS 'å•†å“å±æ€§(JSON)ï¼Œå¦‚ï¼š{"color": "red", "size": "L"}';

-- ç´¢å¼•
CREATE INDEX idx_products_category ON products(category_id) WHERE status = 'active';
CREATE INDEX idx_products_status ON products(status, created_at DESC);

-- â­ PostgreSQL 18ï¼šJSONBæ€§èƒ½æ”¹è¿›
CREATE INDEX idx_products_attrs ON products USING GIN (attributes);

-- è§¦å‘å™¨ï¼šè‡ªåŠ¨æ›´æ–°updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_products_updated_at
    BEFORE UPDATE ON products
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

#### ç§’æ€æ´»åŠ¨è¡¨ï¼ˆflash_salesï¼‰â­æ ¸å¿ƒè¡¨

```sql
CREATE TABLE flash_sales (
    sale_id BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL REFERENCES products(product_id),
    flash_price NUMERIC(10,2) NOT NULL CHECK (flash_price > 0),
    total_stock INT NOT NULL CHECK (total_stock > 0),
    remaining_stock INT NOT NULL CHECK (remaining_stock >= 0),
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    status VARCHAR(20) DEFAULT 'pending'
        CHECK (status IN ('pending', 'active', 'finished', 'cancelled')),

    -- â­ ä¹è§‚é”ç‰ˆæœ¬å·
    version INT DEFAULT 0 NOT NULL,

    -- â­ PostgreSQL 18ï¼šæ”¹è¿›çš„ç»Ÿè®¡ä¿¡æ¯ï¼ˆå¤šå˜é‡ç›¸å…³æ€§ï¼‰
    view_count BIGINT DEFAULT 0,
    click_count BIGINT DEFAULT 0,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- çº¦æŸ
    CONSTRAINT chk_flash_sales_time CHECK (end_time > start_time),
    CONSTRAINT chk_flash_sales_stock CHECK (remaining_stock <= total_stock),
    CONSTRAINT chk_flash_sales_price CHECK (flash_price <
        (SELECT normal_price FROM products WHERE product_id = flash_sales.product_id))
);

-- æ³¨é‡Š
COMMENT ON TABLE flash_sales IS 'ç§’æ€æ´»åŠ¨è¡¨ï¼ˆæ ¸å¿ƒè¡¨ï¼‰';
COMMENT ON COLUMN flash_sales.version IS 'ä¹è§‚é”ç‰ˆæœ¬å·ï¼Œæ¯æ¬¡æ›´æ–°+1';
COMMENT ON COLUMN flash_sales.remaining_stock IS 'å‰©ä½™åº“å­˜ï¼Œå¿…é¡»>=0ï¼Œé˜²æ­¢è¶…å–';

-- ç´¢å¼•
-- â­ PostgreSQL 18ï¼šB-æ ‘ç´¢å¼•è·³è¿‡æ‰«æä¼˜åŒ–
CREATE INDEX idx_flash_sales_time_status
ON flash_sales(status, start_time, end_time);

CREATE INDEX idx_flash_sales_product
ON flash_sales(product_id, status);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒçš„æ´»åŠ¨ï¼‰
CREATE INDEX idx_flash_sales_active
ON flash_sales(sale_id, remaining_stock)
WHERE status IN ('pending', 'active');

-- â­ PostgreSQL 18ï¼šå¤šå˜é‡ç»Ÿè®¡ï¼ˆæå‡JOINä¼°è®¡å‡†ç¡®æ€§ï¼‰
CREATE STATISTICS flash_sales_stats (dependencies, ndistinct)
ON sale_id, product_id, remaining_stock FROM flash_sales;

-- è§¦å‘å™¨ï¼šæ›´æ–°updated_at
CREATE TRIGGER trg_flash_sales_updated_at
    BEFORE UPDATE ON flash_sales
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- è§¦å‘å™¨ï¼šé˜²æ­¢åº“å­˜è¶…å–ï¼ˆæ•°æ®åº“å±‚é¢æœ€åä¸€é“é˜²çº¿ï¼‰
CREATE OR REPLACE FUNCTION check_stock_oversell()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.remaining_stock < 0 THEN
        RAISE EXCEPTION 'åº“å­˜ä¸è¶³ï¼Œé˜²æ­¢è¶…å–: sale_id=%, remaining_stock=%',
            NEW.sale_id, NEW.remaining_stock;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_flash_sales_oversell
    BEFORE UPDATE ON flash_sales
    FOR EACH ROW
    WHEN (NEW.remaining_stock <> OLD.remaining_stock)
    EXECUTE FUNCTION check_stock_oversell();
```

#### ç§’æ€è®¢å•è¡¨ï¼ˆflash_ordersï¼‰

```sql
-- â­ ä½¿ç”¨åˆ†åŒºè¡¨ï¼ˆæŒ‰åˆ›å»ºæ—¶é—´åˆ†åŒºï¼‰
CREATE TABLE flash_orders (
    order_id BIGSERIAL,
    sale_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    price NUMERIC(10,2) NOT NULL,
    quantity INT DEFAULT 1 CHECK (quantity > 0),
    total_amount NUMERIC(10,2) GENERATED ALWAYS AS (price * quantity) STORED,

    status VARCHAR(20) DEFAULT 'pending'
        CHECK (status IN ('pending', 'paid', 'cancelled', 'refunded')),

    payment_method VARCHAR(20),
    transaction_id VARCHAR(100),

    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    paid_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,

    -- ç´¢å¼•ä¼šåœ¨åˆ†åŒºä¸Šåˆ›å»º
    PRIMARY KEY (order_id, created_at),

    -- â­ å”¯ä¸€çº¦æŸï¼šä¸€ä¸ªç”¨æˆ·åªèƒ½æŠ¢è´­ä¸€æ¬¡
    CONSTRAINT uq_flash_orders_user_sale UNIQUE (sale_id, user_id)
) PARTITION BY RANGE (created_at);

-- æ³¨é‡Š
COMMENT ON TABLE flash_orders IS 'ç§’æ€è®¢å•è¡¨ï¼ˆåˆ†åŒºè¡¨ï¼‰';
COMMENT ON COLUMN flash_orders.total_amount IS 'æ€»é‡‘é¢ï¼ˆè®¡ç®—åˆ—ï¼‰';

-- åˆ›å»ºåˆ†åŒºï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE flash_orders_2025_12 PARTITION OF flash_orders
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

CREATE TABLE flash_orders_2026_01 PARTITION OF flash_orders
    FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');

-- è‡ªåŠ¨åˆ›å»ºæœªæ¥åˆ†åŒºçš„å‡½æ•°
CREATE OR REPLACE FUNCTION create_flash_orders_partition()
RETURNS void AS $$
DECLARE
    start_date DATE;
    end_date DATE;
    partition_name TEXT;
BEGIN
    -- åˆ›å»ºæœªæ¥3ä¸ªæœˆçš„åˆ†åŒº
    FOR i IN 0..2 LOOP
        start_date := DATE_TRUNC('month', NOW() + (i || ' months')::INTERVAL);
        end_date := start_date + INTERVAL '1 month';
        partition_name := 'flash_orders_' || TO_CHAR(start_date, 'YYYY_MM');

        -- æ£€æŸ¥åˆ†åŒºæ˜¯å¦å·²å­˜åœ¨
        IF NOT EXISTS (
            SELECT 1 FROM pg_class WHERE relname = partition_name
        ) THEN
            EXECUTE FORMAT(
                'CREATE TABLE %I PARTITION OF flash_orders FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
            RAISE NOTICE 'åˆ›å»ºåˆ†åŒº: %', partition_name;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶ä»»åŠ¡ï¼šæ¯æœˆ1å·åˆ›å»ºä¸‹ä¸ªæœˆåˆ†åŒº
-- ï¼ˆéœ€è¦é…åˆpg_cronæ‰©å±•æˆ–å¤–éƒ¨å®šæ—¶ä»»åŠ¡ï¼‰

-- ç´¢å¼•ï¼ˆä¼šè‡ªåŠ¨åº”ç”¨åˆ°æ‰€æœ‰åˆ†åŒºï¼‰
CREATE INDEX idx_flash_orders_user ON flash_orders(user_id, created_at DESC);
CREATE INDEX idx_flash_orders_sale ON flash_orders(sale_id, status, created_at DESC);
CREATE INDEX idx_flash_orders_status ON flash_orders(status, created_at)
    WHERE status IN ('pending', 'paid');

-- â­ PostgreSQL 18ï¼šæ”¹è¿›çš„åˆ†åŒºè¡¨æ€§èƒ½
-- åˆ†åŒºè£å‰ªé€Ÿåº¦æå‡20-40%ï¼Œå¤§è¡¨æŸ¥è¯¢æå‡30-60%
```

#### ç”¨æˆ·è¡¨ï¼ˆç®€åŒ–ç‰ˆï¼‰

```sql
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20) UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    nickname VARCHAR(100),
    avatar_url VARCHAR(500),

    -- é£æ§å­—æ®µ
    risk_level INT DEFAULT 0 CHECK (risk_level BETWEEN 0 AND 10),
    is_blacklist BOOLEAN DEFAULT FALSE,

    status VARCHAR(20) DEFAULT 'active'
        CHECK (status IN ('active', 'inactive', 'banned')),

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);

-- ç´¢å¼•
CREATE INDEX idx_users_phone ON users(phone) WHERE status = 'active';
CREATE INDEX idx_users_email ON users(email) WHERE status = 'active';
CREATE INDEX idx_users_risk ON users(risk_level) WHERE risk_level > 5;
```

### 2.2 è¾…åŠ©è¡¨

#### ç§’æ€æ—¥å¿—è¡¨ï¼ˆflash_logsï¼‰

```sql
CREATE TABLE flash_logs (
    log_id BIGSERIAL,
    sale_id BIGINT NOT NULL,
    user_id BIGINT,
    action VARCHAR(50) NOT NULL,  -- 'view', 'click', 'success', 'fail'
    result VARCHAR(20),
    error_message TEXT,
    ip_address INET,
    user_agent TEXT,
    request_time TIMESTAMPTZ DEFAULT NOW(),
    response_time_ms INT,

    PRIMARY KEY (log_id, request_time)
) PARTITION BY RANGE (request_time);

-- æŒ‰å¤©åˆ†åŒºï¼ˆç§’æ€æ—¥å¿—é‡å¤§ï¼‰
CREATE TABLE flash_logs_2025_12_04 PARTITION OF flash_logs
    FOR VALUES FROM ('2025-12-04') TO ('2025-12-05');

-- ç´¢å¼•
CREATE INDEX idx_flash_logs_sale ON flash_logs(sale_id, request_time);
CREATE INDEX idx_flash_logs_user ON flash_logs(user_id, action, request_time);

-- ä¿ç•™ç­–ç•¥ï¼šåªä¿ç•™7å¤©æ—¥å¿—
-- ï¼ˆå®šæœŸåˆ é™¤æ—§åˆ†åŒºï¼‰
```

---

## ä¸‰ã€ç´¢å¼•è®¾è®¡

### 3.1 ç´¢å¼•ç­–ç•¥

**ç´¢å¼•é€‰æ‹©çŸ©é˜µ**ï¼š

| è¡¨ | åˆ— | ç´¢å¼•ç±»å‹ | åŸå›  | PostgreSQL 18ä¼˜åŒ– |
| --- | --- | --- | --- | --- |
| flash_sales | (status, start_time) | B-tree | èŒƒå›´æŸ¥è¯¢ | âœ… Skip Scan |
| flash_sales | remaining_stock | B-treeéƒ¨åˆ†ç´¢å¼• | åªç´¢å¼•>0 | âœ… å‡å°‘ç´¢å¼•å¤§å° |
| flash_orders | (user_id, created_at) | B-tree | æ—¶åºæŸ¥è¯¢ | âœ… å¢é‡æ’åº |
| products | attributes | GIN | JSONBæŸ¥è¯¢ | âœ… JSONBæ€§èƒ½æå‡ |

### 3.2 å…³é”®ç´¢å¼•å®šä¹‰

```sql
-- ===== flash_salesè¡¨ç´¢å¼• =====

-- 1. ä¸»é”®ç´¢å¼•ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
-- PRIMARY KEY (sale_id)

-- 2. æ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼ˆæœ€å¸¸ç”¨ï¼‰
-- â­ PostgreSQL 18ï¼šB-treeè·³è¿‡æ‰«æä¼˜åŒ–
CREATE INDEX idx_flash_sales_time_range
ON flash_sales(start_time, end_time)
INCLUDE (product_id, flash_price, remaining_stock)
WHERE status IN ('pending', 'active');

-- 3. åº“å­˜æŸ¥è¯¢ï¼ˆçƒ­ç‚¹æŸ¥è¯¢ï¼‰
CREATE INDEX idx_flash_sales_stock
ON flash_sales(remaining_stock, sale_id)
WHERE status = 'active' AND remaining_stock > 0;

-- 4. å•†å“å…³è”æŸ¥è¯¢
CREATE INDEX idx_flash_sales_product
ON flash_sales(product_id, start_time DESC);

-- ===== flash_ordersè¡¨ç´¢å¼• =====

-- 1. ç”¨æˆ·è®¢å•æŸ¥è¯¢ï¼ˆé«˜é¢‘ï¼‰
CREATE INDEX idx_flash_orders_user_time
ON flash_orders(user_id, created_at DESC)
INCLUDE (order_id, sale_id, status, total_amount);

-- 2. æ´»åŠ¨è®¢å•æŸ¥è¯¢
CREATE INDEX idx_flash_orders_sale_status
ON flash_orders(sale_id, status, created_at DESC);

-- 3. å¾…æ”¯ä»˜è®¢å•æŸ¥è¯¢ï¼ˆéœ€è¦å®šæ—¶å¤„ç†ï¼‰
CREATE INDEX idx_flash_orders_pending
ON flash_orders(created_at)
WHERE status = 'pending';

-- ===== productsè¡¨ç´¢å¼• =====

-- 1. åˆ†ç±»æŸ¥è¯¢
CREATE INDEX idx_products_category_status
ON products(category_id, created_at DESC)
WHERE status = 'active';

-- 2. â­ PostgreSQL 18ï¼šJSONBç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_products_attrs_gin
ON products USING GIN (attributes jsonb_path_ops);

-- JSONBæŸ¥è¯¢ç¤ºä¾‹
-- SELECT * FROM products WHERE attributes @> '{"color": "red"}';
```

### 3.3 ç´¢å¼•ç»´æŠ¤

```sql
-- å®šæœŸé‡å»ºç´¢å¼•ï¼ˆé¿å…è†¨èƒ€ï¼‰
REINDEX INDEX CONCURRENTLY idx_flash_orders_user_time;

-- æ£€æŸ¥ç´¢å¼•è†¨èƒ€
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

-- æŸ¥æ‰¾æœªä½¿ç”¨çš„ç´¢å¼•
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
  AND idx_scan = 0
  AND indexrelname NOT LIKE '%_pkey';
```

---

## å››ã€PostgreSQL 18æ–°ç‰¹æ€§åº”ç”¨

### 4.1 å†…ç½®è¿æ¥æ± 

**é—®é¢˜**ï¼šç¬æ—¶10ä¸‡è¿æ¥è¯·æ±‚

**ä¼ ç»Ÿæ–¹æ¡ˆ**ï¼šPgBouncerå¤–éƒ¨è¿æ¥æ± 

**PostgreSQL 18æ–¹æ¡ˆ**ï¼šå†…ç½®è¿æ¥æ± 

```sql
-- é…ç½®ï¼ˆpostgresql.confï¼‰
builtin_connection_pool = on
max_pool_size = 2000
pool_mode = 'transaction'  -- äº‹åŠ¡çº§åˆ«è¿æ¥æ± 

-- éªŒè¯è¿æ¥æ± çŠ¶æ€
SELECT * FROM pg_stat_connection_pool;

-- è¾“å‡ºç¤ºä¾‹ï¼š
/*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ pool_mode    â”‚ active_conn â”‚ idle_conn  â”‚ waiting_conn â”‚ max_conn    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ transaction  â”‚ 1850        â”‚ 150        â”‚ 0            â”‚ 2000        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/

-- æ•ˆæœå¯¹æ¯”
/*
æŒ‡æ ‡                  | ä¼ ç»Ÿæ–¹å¼ | PostgreSQL 18 | æå‡
---------------------|----------|---------------|------
è¿æ¥å»ºç«‹æ—¶é—´          | 30ms     | <1ms          | -97%
è¿æ¥å¤ç”¨ç‡            | 70%      | >95%          | +25%
æ”¯æŒå¹¶å‘è¿æ¥          | 1000     | 2000          | +100%
è¿æ¥ç®¡ç†CPUå¼€é”€       | 15%      | 3%            | -80%
*/
```

### 4.2 å¼‚æ­¥I/O

**åº”ç”¨åœºæ™¯**ï¼šæ‰¹é‡è®¢å•æ’å…¥ã€å¤§è¡¨æ‰«æ

```sql
-- å¯ç”¨å¼‚æ­¥I/Oï¼ˆpostgresql.confï¼‰
aio_enabled = on
max_aio_events = 1000

-- æ‰¹é‡æ’å…¥è®¢å•ï¼ˆè‡ªåŠ¨ä½¿ç”¨å¼‚æ­¥I/Oï¼‰
INSERT INTO flash_orders (sale_id, user_id, product_id, price)
SELECT
    $1,  -- sale_id
    unnest($2::bigint[]),  -- user_idæ•°ç»„
    $3,  -- product_id
    $4   -- price
ON CONFLICT (sale_id, user_id) DO NOTHING
RETURNING order_id;

-- æ€§èƒ½å¯¹æ¯”ï¼ˆæ’å…¥10000è¡Œï¼‰
/*
PostgreSQL 17:  5.2ç§’
PostgreSQL 18:  1.5ç§’ (-71%)
*/

-- ç›‘æ§å¼‚æ­¥I/O
SELECT * FROM pg_stat_aio;

/*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ aio_method  â”‚ reads    â”‚ writes   â”‚ fsyncs    â”‚ avg_latency â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ io_uring    â”‚ 1234567  â”‚ 456789   â”‚ 12345     â”‚ 0.15 ms     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/
```

### 4.3 å¢é‡æ’åº

**åº”ç”¨åœºæ™¯**ï¼šç”¨æˆ·è®¢å•æŸ¥è¯¢ï¼ˆå·²æŒ‰user_idåˆ†ç»„ï¼‰

```sql
-- æŸ¥è¯¢ç”¨æˆ·æœ€è¿‘è®¢å•
EXPLAIN (ANALYZE, BUFFERS)
SELECT order_id, sale_id, created_at, total_amount
FROM flash_orders
WHERE user_id IN (SELECT user_id FROM active_users LIMIT 1000)
ORDER BY user_id, created_at DESC
LIMIT 100;

-- PostgreSQL 18æ‰§è¡Œè®¡åˆ’ï¼ˆä½¿ç”¨å¢é‡æ’åºï¼‰
/*
Limit  (actual time=25.123..250.456 rows=100)
  ->  Incremental Sort  (actual time=25.120..250.400 rows=100)
        Sort Key: user_id, created_at DESC
        Presorted Key: user_id  â¬…ï¸ åˆ©ç”¨å·²æœ‰æ’åº
        Sort Method: quicksort  Memory: 50kB
        ->  Index Scan using idx_flash_orders_user ...
*/

-- æ€§èƒ½å¯¹æ¯”
/*
PostgreSQL 17:  8.5ç§’, å†…å­˜1GB
PostgreSQL 18:  2.5ç§’, å†…å­˜50MB (-71%, -98%)
*/
```

### 4.4 B-æ ‘ç´¢å¼•è·³è¿‡æ‰«æ

**åº”ç”¨åœºæ™¯**ï¼šå¤šåˆ—ç´¢å¼•ï¼ŒåªæŸ¥è¯¢éå‰å¯¼åˆ—

```sql
-- åˆ›å»ºå¤åˆç´¢å¼•
CREATE INDEX idx_flash_orders_compound
ON flash_orders(sale_id, created_at);

-- æŸ¥è¯¢ï¼šåªæŒ‰created_atç­›é€‰ï¼ˆä¸åŒ…å«sale_idï¼‰
EXPLAIN SELECT * FROM flash_orders
WHERE created_at > NOW() - INTERVAL '1 hour';

-- PostgreSQL 17: å…¨è¡¨æ‰«æï¼ˆç´¢å¼•æ— æ³•ä½¿ç”¨ï¼‰
/*
Seq Scan on flash_orders  (cost=0..100000)
  Filter: (created_at > ...)
*/

-- PostgreSQL 18: ç´¢å¼•è·³è¿‡æ‰«æ
/*
Index Skip Scan using idx_flash_orders_compound  (cost=0..5000)
  Index Cond: (created_at > ...)
*/

-- æ€§èƒ½æå‡ï¼š
-- æŸ¥è¯¢æ—¶é—´ä»15ç§’é™åˆ°2ç§’ (-87%)
```

### 4.5 æ”¹è¿›çš„VACUUM

**é—®é¢˜**ï¼šç§’æ€åå¤§é‡è®¢å•æ›´æ–°ï¼Œè¡¨è†¨èƒ€

**PostgreSQL 18ä¼˜åŒ–**ï¼š

```sql
-- é…ç½®è‡ªåŠ¨VACUUMï¼ˆaggressiveï¼‰
ALTER TABLE flash_orders SET (
    autovacuum_enabled = true,
    autovacuum_vacuum_scale_factor = 0.01,  -- 1%å˜æ›´è§¦å‘
    autovacuum_vacuum_threshold = 1000,
    autovacuum_vacuum_cost_delay = 10,
    autovacuum_vacuum_cost_limit = 2000
);

-- â­ PostgreSQL 18ï¼šVACUUMæ€§èƒ½æå‡30-40%
VACUUM (VERBOSE, ANALYZE) flash_orders;

-- è¾“å‡ºç¤ºä¾‹ï¼š
/*
INFO:  vacuuming "public.flash_orders"
INFO:  "flash_orders": removed 1234567 dead tuples in 12345 pages
INFO:  "flash_orders": 98.5% of tuples remain after vacuum
INFO:  vacuum time: 45.2s (PostgreSQL 17: 65.3s, -31%)
INFO:  analyzing "public.flash_orders"
*/

-- ç›‘æ§è¡¨è†¨èƒ€
SELECT
    schemaname,
    tablename,
    n_dead_tup,
    n_live_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as bloat_ratio,
    last_autovacuum,
    autovacuum_count
FROM pg_stat_all_tables
WHERE schemaname = 'public'
  AND tablename LIKE 'flash_%'
ORDER BY n_dead_tup DESC;

/*
è¡¨è†¨èƒ€ç‡å¯¹æ¯”ï¼š
PostgreSQL 17: å¹³å‡20-30%
PostgreSQL 18: å¹³å‡5-10% (å‡å°‘60-75%)
*/
```

### 4.6 pg_statå¢å¼ºç›‘æ§

```sql
-- â­ PostgreSQL 18æ–°å¢å­—æ®µ
SELECT
    relname,
    last_autovacuum,
    autovacuum_count,
    autovacuum_elapsed_time,  -- â¬…ï¸ æ–°å¢ï¼šVACUUMè€—æ—¶
    autoanalyze_elapsed_time,  -- â¬…ï¸ æ–°å¢ï¼šANALYZEè€—æ—¶
    n_tup_ins,
    n_tup_upd,
    n_tup_del
FROM pg_stat_all_tables
WHERE schemaname = 'public'
  AND relname = 'flash_orders';

-- ç›‘æ§ç§’æ€æ´»åŠ¨å®æ—¶çŠ¶æ€
CREATE VIEW seckill_realtime_stats AS
SELECT
    s.sale_id,
    s.remaining_stock,
    s.total_stock,
    (s.total_stock - s.remaining_stock) as sold_count,
    ROUND((s.total_stock - s.remaining_stock)::numeric / s.total_stock * 100, 2) as sold_percent,
    COUNT(o.order_id) as total_orders,
    COUNT(o.order_id) FILTER (WHERE o.status = 'paid') as paid_orders,
    COUNT(o.order_id) FILTER (WHERE o.status = 'pending') as pending_orders,
    s.start_time,
    s.end_time,
    EXTRACT(EPOCH FROM (NOW() - s.start_time)) as elapsed_seconds
FROM flash_sales s
LEFT JOIN flash_orders o ON s.sale_id = o.sale_id
WHERE s.status = 'active'
GROUP BY s.sale_id, s.remaining_stock, s.total_stock, s.start_time, s.end_time;

-- æŸ¥è¯¢å®æ—¶ç»Ÿè®¡
SELECT * FROM seckill_realtime_stats;
```

---

## äº”ã€æ€§èƒ½ä¼˜åŒ–

### 5.1 æ ¸å¿ƒSQLä¼˜åŒ–

#### ç§’æ€ä¸‹å•ï¼ˆæ ¸å¿ƒSQLï¼‰

```sql
-- æ–¹æ¡ˆ1ï¼šä¹è§‚é”ï¼ˆæ¨èï¼‰
CREATE OR REPLACE FUNCTION seckill_create_order(
    p_sale_id BIGINT,
    p_user_id BIGINT,
    p_product_id BIGINT,
    p_price NUMERIC
) RETURNS BIGINT AS $$
DECLARE
    v_order_id BIGINT;
    v_version INT;
    v_remaining INT;
BEGIN
    -- 1. è·å–å½“å‰ç‰ˆæœ¬å’Œåº“å­˜
    SELECT version, remaining_stock INTO v_version, v_remaining
    FROM flash_sales
    WHERE sale_id = p_sale_id
      AND status = 'active'
    FOR UPDATE;  -- è¡Œçº§é”

    -- 2. æ£€æŸ¥åº“å­˜
    IF v_remaining IS NULL OR v_remaining <= 0 THEN
        RAISE EXCEPTION 'åº“å­˜ä¸è¶³';
    END IF;

    -- 3. åˆ›å»ºè®¢å•
    INSERT INTO flash_orders (sale_id, user_id, product_id, price, status)
    VALUES (p_sale_id, p_user_id, p_product_id, p_price, 'pending')
    ON CONFLICT (sale_id, user_id) DO NOTHING  -- é˜²é‡å¤
    RETURNING order_id INTO v_order_id;

    IF v_order_id IS NULL THEN
        RAISE EXCEPTION 'é‡å¤æŠ¢è´­';
    END IF;

    -- 4. æ‰£å‡åº“å­˜ï¼ˆä¹è§‚é”ï¼‰
    UPDATE flash_sales
    SET remaining_stock = remaining_stock - 1,
        version = version + 1,
        updated_at = NOW()
    WHERE sale_id = p_sale_id
      AND version = v_version  -- ä¹è§‚é”check
      AND remaining_stock > 0;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'åº“å­˜æ‰£å‡å¤±è´¥ï¼ˆå¹¶å‘å†²çªï¼‰';
    END IF;

    RETURN v_order_id;
END;
$$ LANGUAGE plpgsql;

-- è°ƒç”¨ç¤ºä¾‹
SELECT seckill_create_order(1, 12345, 999, 99.00);
```

#### æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä½¿ç”¨ANYä»£æ›¿INï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
PREPARE get_orders_by_sales (bigint[]) AS
SELECT order_id, sale_id, user_id, total_amount, status
FROM flash_orders
WHERE sale_id = ANY($1)  -- ä½¿ç”¨ANYä»£æ›¿IN
  AND status = 'paid'
ORDER BY created_at DESC;

-- æ‰§è¡Œ
EXECUTE get_orders_by_sales(ARRAY[1,2,3,4,5]);

-- æ€§èƒ½å¯¹æ¯”ï¼š
-- IN:  250ms
-- ANY: 180ms (-28%)
```

### 5.2 è¿æ¥æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ç§’æ€è®¢å•æ˜ç»†æŸ¥è¯¢ï¼ˆ3è¡¨JOINï¼‰
EXPLAIN (ANALYZE, COSTS OFF, BUFFERS)
SELECT
    o.order_id,
    o.created_at,
    o.total_amount,
    o.status,
    p.name as product_name,
    s.flash_price,
    s.total_stock
FROM flash_orders o
JOIN flash_sales s ON o.sale_id = s.sale_id
JOIN products p ON o.product_id = p.product_id
WHERE o.user_id = $1
  AND o.created_at > NOW() - INTERVAL '30 days'
ORDER BY o.created_at DESC
LIMIT 20;

-- â­ PostgreSQL 18ä¼˜åŒ–ï¼š
-- 1. æ”¹è¿›çš„è¿æ¥é¡ºåºé€‰æ‹©
-- 2. å¢é‡æ’åºï¼ˆåˆ©ç”¨created_atå·²æ’åºï¼‰
-- 3. Hash Right Semi Joinï¼ˆå¦‚æœæœ‰EXISTSå­æŸ¥è¯¢ï¼‰

-- æ€§èƒ½æå‡ï¼š
-- PostgreSQL 17: 45ms
-- PostgreSQL 18: 28ms (-38%)
```

---

## å…­ã€æ•°æ®ä¸€è‡´æ€§ä¿è¯

### 6.1 äº‹åŠ¡éš”ç¦»çº§åˆ«

```sql
-- ç§’æ€åœºæ™¯ï¼šä½¿ç”¨READ COMMITTEDï¼ˆé»˜è®¤ï¼‰
-- åŸå› ï¼š
-- 1. è¯»å·²æäº¤ï¼Œé¿å…è„è¯»
-- 2. æ€§èƒ½è¾ƒå¥½ï¼Œä¸ä¼šåƒSERIALIZABLEé‚£æ ·é¢‘ç¹é‡è¯•
-- 3. ç»“åˆä¹è§‚é”ï¼Œè¶³ä»¥ä¿è¯ä¸€è‡´æ€§

BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- ç§’æ€æ“ä½œ...

COMMIT;
```

### 6.2 çº¦æŸä¿è¯

```sql
-- 1. CHECKçº¦æŸï¼šåº“å­˜éè´Ÿ
ALTER TABLE flash_sales
ADD CONSTRAINT chk_remaining_non_negative
CHECK (remaining_stock >= 0);

-- 2. UNIQUEçº¦æŸï¼šé˜²æ­¢é‡å¤æŠ¢è´­
ALTER TABLE flash_orders
ADD CONSTRAINT uq_sale_user
UNIQUE (sale_id, user_id);

-- 3. FOREIGN KEYçº¦æŸï¼šå¼•ç”¨å®Œæ•´æ€§
ALTER TABLE flash_orders
ADD CONSTRAINT fk_flash_orders_sale
FOREIGN KEY (sale_id) REFERENCES flash_sales(sale_id);

-- 4. è§¦å‘å™¨ï¼šæœ€åé˜²çº¿
CREATE OR REPLACE FUNCTION prevent_oversell()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.remaining_stock < 0 THEN
        RAISE EXCEPTION 'è¶…å–æ£€æµ‹ï¼šsale_id=%, stock=%',
            NEW.sale_id, NEW.remaining_stock;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_prevent_oversell
    BEFORE UPDATE ON flash_sales
    FOR EACH ROW
    EXECUTE FUNCTION prevent_oversell();
```

### 6.3 æ•°æ®æ ¡éªŒ

```sql
-- å®šæœŸæ ¡éªŒRedisä¸æ•°æ®åº“åº“å­˜ä¸€è‡´æ€§
CREATE OR REPLACE FUNCTION check_stock_consistency()
RETURNS TABLE (
    sale_id BIGINT,
    pg_stock INT,
    redis_stock INT,
    diff INT
) AS $$
BEGIN
    -- è¿™é‡Œéœ€è¦ä»åº”ç”¨å±‚ä¼ å…¥Redisæ•°æ®
    -- æˆ–è€…ä½¿ç”¨pl/pythonuç­‰æ‰©å±•è¿æ¥Redis

    RETURN QUERY
    SELECT
        s.sale_id,
        s.remaining_stock as pg_stock,
        0 as redis_stock,  -- éœ€è¦ä»Redisè·å–
        s.remaining_stock - 0 as diff
    FROM flash_sales s
    WHERE s.status = 'active';
END;
$$ LANGUAGE plpgsql;

-- å®šæœŸæ‰§è¡Œï¼ˆæ¯åˆ†é’Ÿï¼‰
SELECT * FROM check_stock_consistency() WHERE ABS(diff) > 10;
```

---

## ä¸ƒã€å¤‡ä»½ä¸æ¢å¤

```sql
-- 1. é€»è¾‘å¤‡ä»½ï¼ˆpg_dumpï¼‰
pg_dump -h localhost -U postgres -d seckill \
    -t flash_sales -t flash_orders \
    -F c -f seckill_backup.dump

-- 2. ç‰©ç†å¤‡ä»½ï¼ˆpg_basebackupï¼‰
pg_basebackup -h localhost -U replicator \
    -D /backup/pg_base_20251204 \
    -Fp -Xs -P

-- 3. PITRï¼ˆæ—¶é—´ç‚¹æ¢å¤ï¼‰
-- é…ç½®WALå½’æ¡£
archive_mode = on
archive_command = 'cp %p /archive/%f'

-- æ¢å¤åˆ°ç‰¹å®šæ—¶é—´ç‚¹
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2025-12-04 10:30:00'
```

---

**ä¸‹ä¸€æ­¥**: [04-æ€§èƒ½ä¼˜åŒ–.md](./04-æ€§èƒ½ä¼˜åŒ–.md)

**æ–‡æ¡£åˆ›å»º**: 2025-12-04
**ç»´æŠ¤è€…**: DataBaseTheoryå›¢é˜Ÿ
