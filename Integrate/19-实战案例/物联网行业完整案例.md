# PostgreSQL物联网行业完整案例

> **PostgreSQL版本**: 18.x
> **行业**: 物联网（IoT）
> **特点**: 时序数据、高写入、实时分析
> **参考案例**: [03-IoT时序数据系统](./03-IoT时序数据系统/README.md)

---

## 📋 目录

- [PostgreSQL物联网行业完整案例](#postgresql物联网行业完整案例)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 物联网行业特点](#11-物联网行业特点)
    - [1.2 核心场景](#12-核心场景)
  - [2. 物联网行业核心场景](#2-物联网行业核心场景)
    - [2.1 传感器数据采集](#21-传感器数据采集)
    - [2.2 设备监控](#22-设备监控)
    - [2.3 实时告警](#23-实时告警)
  - [3. 技术架构](#3-技术架构)
    - [3.1 数据采集架构](#31-数据采集架构)
    - [3.2 存储架构](#32-存储架构)
  - [4. 数据库设计](#4-数据库设计)
    - [4.1 传感器数据表](#41-传感器数据表)
    - [4.2 设备表](#42-设备表)
  - [5. 性能优化](#5-性能优化)
    - [5.1 写入优化](#51-写入优化)
    - [5.2 查询优化](#52-查询优化)
    - [5.3 数据压缩](#53-数据压缩)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 数据采集](#61-数据采集)
    - [6.2 数据存储](#62-数据存储)
    - [6.3 数据分析](#63-数据分析)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 物联网行业特点

物联网行业对数据库的要求：

- ✅ **高写入**: 百万+设备，每秒百万+数据点
- ✅ **时序数据**: 时间序列数据存储
- ✅ **实时分析**: 实时数据分析和告警
- ✅ **空间数据**: 地理位置数据
- ✅ **数据压缩**: 长期存储压缩

### 1.2 核心场景

- **传感器数据采集**: 实时数据采集
- **设备监控**: 设备状态监控
- **数据分析**: 时序数据分析
- **告警系统**: 实时告警
- **预测维护**: 预测性维护

---

## 2. 物联网行业核心场景

### 2.1 传感器数据采集

**参考**: [03-IoT时序数据系统](./03-IoT时序数据系统/README.md)

**核心需求**:

- 高写入性能
- 时序数据存储
- 数据压缩
- 实时查询

**技术方案**:

```sql
-- 使用TimescaleDB（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            CREATE EXTENSION IF NOT EXISTS timescaledb;
            RAISE NOTICE '扩展 timescaledb 创建成功';
        ELSE
            RAISE NOTICE '扩展 timescaledb 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '扩展 timescaledb 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建扩展失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 传感器数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            CREATE TABLE sensor_data (
                time TIMESTAMPTZ NOT NULL,
                device_id TEXT NOT NULL,
                sensor_type TEXT NOT NULL,
                value NUMERIC(10,2),
                location GEOGRAPHY(POINT, 4326),
                metadata JSONB
            );
            RAISE NOTICE '表 sensor_data 创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 sensor_data 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 转换为时序表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            PERFORM create_hypertable('sensor_data', 'time');
            RAISE NOTICE 'Hypertable创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在或扩展 timescaledb 未安装，跳过创建hypertable';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建hypertable失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_sensor_device_time') THEN
                CREATE INDEX idx_sensor_device_time ON sensor_data (device_id, time DESC);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_sensor_location') THEN
                CREATE INDEX idx_sensor_location ON sensor_data USING GIST (location);
            END IF;
            RAISE NOTICE '索引创建完成';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 数据压缩（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            PERFORM add_compression_policy('sensor_data', INTERVAL '7 days');
            RAISE NOTICE '数据压缩策略创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在或扩展 timescaledb 未安装，跳过创建压缩策略';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建压缩策略失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 2.2 设备监控

**核心需求**:

- 实时监控
- 状态告警
- 历史查询
- 统计分析

**技术方案**:

```sql
-- 设备状态表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'device_status') THEN
            CREATE TABLE device_status (
                time TIMESTAMPTZ NOT NULL,
                device_id TEXT NOT NULL,
                status TEXT NOT NULL,
                temperature NUMERIC(5,2),
                humidity NUMERIC(5,2),
                battery_level INT,
                location GEOGRAPHY(POINT, 4326)
            );
            RAISE NOTICE '表 device_status 创建成功';
        ELSE
            RAISE NOTICE '表 device_status 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 device_status 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 转换为时序表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'device_status') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            PERFORM create_hypertable('device_status', 'time');
            RAISE NOTICE 'Hypertable创建成功';
        ELSE
            RAISE NOTICE '表 device_status 不存在或扩展 timescaledb 未安装，跳过创建hypertable';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建hypertable失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 实时监控查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    device_id,
    time_bucket('1 minute', time) as bucket,
    AVG(temperature) as avg_temp,
    MAX(temperature) as max_temp,
    MIN(temperature) as min_temp,
    status
FROM device_status
WHERE time >= NOW() - INTERVAL '1 hour'
GROUP BY device_id, bucket, status
ORDER BY bucket DESC
LIMIT 100;
```

### 2.3 实时告警

**核心需求**:

- 实时检测异常
- 告警通知
- 告警历史
- 告警规则配置

**技术方案**:

```sql
-- 告警规则表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'alert_rules') THEN
            CREATE TABLE alert_rules (
                rule_id SERIAL PRIMARY KEY,
                device_id TEXT,
                sensor_type TEXT,
                threshold_value NUMERIC(10,2),
                condition TEXT,  -- '>', '<', '=', '!='
                enabled BOOLEAN DEFAULT true
            );
            RAISE NOTICE '表 alert_rules 创建成功';
        ELSE
            RAISE NOTICE '表 alert_rules 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 alert_rules 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 告警记录表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'alerts') THEN
            CREATE TABLE alerts (
                alert_id BIGSERIAL PRIMARY KEY,
                rule_id INT NOT NULL,
                device_id TEXT NOT NULL,
                sensor_type TEXT,
                actual_value NUMERIC(10,2),
                threshold_value NUMERIC(10,2),
                alert_time TIMESTAMPTZ DEFAULT NOW(),
                status TEXT DEFAULT 'open'
            );
            RAISE NOTICE '表 alerts 创建成功';
        ELSE
            RAISE NOTICE '表 alerts 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 alerts 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 实时告警检测（使用触发器）（带错误处理）
DO $$
BEGIN
    BEGIN
        CREATE OR REPLACE FUNCTION check_alerts()
        RETURNS TRIGGER AS $$
        DECLARE
            v_rule RECORD;
        BEGIN
            -- 检查所有相关规则
            FOR v_rule IN
                SELECT * FROM alert_rules
                WHERE device_id = NEW.device_id
                AND sensor_type = NEW.sensor_type
                AND enabled = true
            LOOP
                -- 检查阈值
                IF (v_rule.condition = '>' AND NEW.value > v_rule.threshold_value) OR
                   (v_rule.condition = '<' AND NEW.value < v_rule.threshold_value) OR
                   (v_rule.condition = '=' AND NEW.value = v_rule.threshold_value) THEN
                    -- 创建告警
                    INSERT INTO alerts (rule_id, device_id, sensor_type, actual_value, threshold_value)
                    VALUES (v_rule.rule_id, NEW.device_id, NEW.sensor_type, NEW.value, v_rule.threshold_value);

                    -- 发送通知
                    PERFORM pg_notify('alert', json_build_object(
                        'device_id', NEW.device_id,
                        'sensor_type', NEW.sensor_type,
                        'value', NEW.value,
                        'threshold', v_rule.threshold_value
                    )::TEXT);
                END IF;
            END LOOP;

            RETURN NEW;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '告警检测失败: %', SQLERRM;
                RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 check_alerts 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建函数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建触发器（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            DROP TRIGGER IF EXISTS sensor_alert_trigger ON sensor_data;
            CREATE TRIGGER sensor_alert_trigger
            AFTER INSERT ON sensor_data
            FOR EACH ROW EXECUTE FUNCTION check_alerts();
            RAISE NOTICE '触发器 sensor_alert_trigger 创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在，跳过触发器创建';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建触发器失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 3. 技术架构

### 3.1 数据采集架构

```text
IoT设备
    ↓
数据采集网关
    ↓
消息队列 (Kafka)
    ↓
数据写入层 (批量写入)
    ↓
PostgreSQL + TimescaleDB
    ↓
数据分析层
    ↓
告警系统
```

### 3.2 存储架构

```text
热数据 (最近7天)
    ↓ TimescaleDB
温数据 (7-30天)
    ↓ 压缩存储
冷数据 (30天+)
    ↓ 对象存储 (S3)
```

---

## 4. 数据库设计

### 4.1 传感器数据表

```sql
-- 传感器数据表（时序表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            CREATE TABLE sensor_data (
                time TIMESTAMPTZ NOT NULL,
                device_id TEXT NOT NULL,
                sensor_type TEXT NOT NULL,
                value NUMERIC(10,2),
                unit TEXT,
                location GEOGRAPHY(POINT, 4326),
                metadata JSONB
            );
            RAISE NOTICE '表 sensor_data 创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 sensor_data 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 转换为时序表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            PERFORM create_hypertable('sensor_data', 'time',
                chunk_time_interval => INTERVAL '1 day');
            RAISE NOTICE 'Hypertable创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在或扩展 timescaledb 未安装，跳过创建hypertable';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建hypertable失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_sensor_device_time') THEN
                CREATE INDEX idx_sensor_device_time ON sensor_data (device_id, time DESC);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_sensor_type_time') THEN
                CREATE INDEX idx_sensor_type_time ON sensor_data (sensor_type, time DESC);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_sensor_location') THEN
                CREATE INDEX idx_sensor_location ON sensor_data USING GIST (location);
            END IF;
            RAISE NOTICE '索引创建完成';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 设备表

```sql
-- 设备表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'devices') THEN
            CREATE TABLE devices (
                device_id TEXT PRIMARY KEY,
                device_name TEXT NOT NULL,
                device_type TEXT NOT NULL,
                location GEOGRAPHY(POINT, 4326),
                status TEXT DEFAULT 'active',
                created_at TIMESTAMPTZ DEFAULT NOW(),
                updated_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 devices 创建成功';
        ELSE
            RAISE NOTICE '表 devices 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 devices 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'devices') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_devices_location') THEN
                CREATE INDEX idx_devices_location ON devices USING GIST (location);
            END IF;
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_devices_type') THEN
                CREATE INDEX idx_devices_type ON devices(device_type);
            END IF;
            RAISE NOTICE '索引创建完成';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. 性能优化

### 5.1 写入优化

```sql
-- 批量写入（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            INSERT INTO sensor_data (time, device_id, sensor_type, value)
            SELECT
                time,
                device_id,
                sensor_type,
                value
            FROM unnest(
                ARRAY['2025-01-01 00:00:00'::TIMESTAMPTZ, '2025-01-01 00:01:00'::TIMESTAMPTZ],
                ARRAY['device1', 'device2'],
                ARRAY['temperature', 'temperature'],
                ARRAY[25.5, 26.0]
            ) AS t(time, device_id, sensor_type, value);
            RAISE NOTICE '批量写入成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在，跳过批量写入';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '批量写入失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用COPY批量导入（注意：需要文件系统访问权限）
-- COPY sensor_data (time, device_id, sensor_type, value)
-- FROM '/path/to/data.csv' WITH CSV;
-- 注意：COPY命令需要超级用户权限或文件系统访问权限
```

### 5.2 查询优化

```sql
-- 使用连续聚合（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            DROP MATERIALIZED VIEW IF EXISTS sensor_data_hourly;
            CREATE MATERIALIZED VIEW sensor_data_hourly
            WITH (timescaledb.continuous) AS
            SELECT
                time_bucket('1 hour', time) as bucket,
                device_id,
                sensor_type,
                AVG(value) as avg_value,
                MAX(value) as max_value,
                MIN(value) as min_value
            FROM sensor_data
            GROUP BY bucket, device_id, sensor_type;
            RAISE NOTICE '连续聚合视图创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在或扩展 timescaledb 未安装，跳过创建连续聚合';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建连续聚合视图失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 自动刷新（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_matviews WHERE matviewname = 'sensor_data_hourly') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            PERFORM add_continuous_aggregate_policy('sensor_data_hourly',
                start_offset => INTERVAL '3 hours',
                end_offset => INTERVAL '1 hour',
                schedule_interval => INTERVAL '1 hour');
            RAISE NOTICE '连续聚合策略创建成功';
        ELSE
            RAISE NOTICE '物化视图不存在或扩展 timescaledb 未安装，跳过创建策略';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建连续聚合策略失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.3 数据压缩

```sql
-- 启用压缩（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            ALTER TABLE sensor_data SET (
                timescaledb.compress,
                timescaledb.compress_segmentby = 'device_id',
                timescaledb.compress_orderby = 'time DESC'
            );
            RAISE NOTICE '压缩设置成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在或扩展 timescaledb 未安装，跳过压缩设置';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置压缩失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 压缩策略（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') AND
           EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            PERFORM add_compression_policy('sensor_data', INTERVAL '7 days');
            RAISE NOTICE '压缩策略创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在或扩展 timescaledb 未安装，跳过创建压缩策略';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建压缩策略失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 6. 最佳实践

### 6.1 数据采集

- ✅ **批量写入**: 减少写入次数
- ✅ **异步写入**: 使用消息队列
- ✅ **数据验证**: 写入前验证数据
- ✅ **错误处理**: 完善的错误处理

### 6.2 数据存储

- ✅ **时序表**: 使用TimescaleDB
- ✅ **分区策略**: 按时间分区
- ✅ **数据压缩**: 压缩历史数据
- ✅ **冷热分离**: 热数据SSD，冷数据对象存储

### 6.3 数据分析

- ✅ **连续聚合**: 预聚合数据
- ✅ **物化视图**: 加速查询
- ✅ **索引优化**: 创建合适索引
- ✅ **查询优化**: 优化慢查询

---

## 📚 相关文档

- [03-IoT时序数据系统](./03-IoT时序数据系统/README.md) - IoT时序数据系统案例
- [08-流处理与时序](../08-流处理与时序/README.md) - 流处理与时序
- [07-多模型数据库/空间数据](../07-多模型数据库/空间数据/README.md) - 空间数据

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
