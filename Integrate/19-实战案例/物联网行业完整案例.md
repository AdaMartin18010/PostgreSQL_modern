# PostgreSQL物联网行业完整案例

> **PostgreSQL版本**: 18.x
> **行业**: 物联网（IoT）
> **特点**: 时序数据、高写入、实时分析
> **参考案例**: [03-IoT时序数据系统](./03-IoT时序数据系统/README.md)

---

## 📋 目录

- [PostgreSQL物联网行业完整案例](#postgresql物联网行业完整案例)
  - [1. 概述](#1-概述)
  - [2. 物联网行业核心场景](#2-物联网行业核心场景)
  - [3. 技术架构](#3-技术架构)
  - [4. 数据库设计](#4-数据库设计)
  - [5. 性能优化](#5-性能优化)
  - [6. 最佳实践](#6-最佳实践)

---

## 1. 概述

### 1.1 物联网行业特点

物联网行业对数据库的要求：

- ✅ **高写入**: 百万+设备，每秒百万+数据点
- ✅ **时序数据**: 时间序列数据存储
- ✅ **实时分析**: 实时数据分析和告警
- ✅ **空间数据**: 地理位置数据
- ✅ **数据压缩**: 长期存储压缩

### 1.2 核心场景

- **传感器数据采集**: 实时数据采集
- **设备监控**: 设备状态监控
- **数据分析**: 时序数据分析
- **告警系统**: 实时告警
- **预测维护**: 预测性维护

---

## 2. 物联网行业核心场景

### 2.1 传感器数据采集

**参考**: [03-IoT时序数据系统](./03-IoT时序数据系统/README.md)

**核心需求**:
- 高写入性能
- 时序数据存储
- 数据压缩
- 实时查询

**技术方案**:
```sql
-- 使用TimescaleDB
CREATE EXTENSION IF NOT EXISTS timescaledb;

-- 传感器数据表
CREATE TABLE sensor_data (
    time TIMESTAMPTZ NOT NULL,
    device_id TEXT NOT NULL,
    sensor_type TEXT NOT NULL,
    value NUMERIC(10,2),
    location GEOGRAPHY(POINT, 4326),
    metadata JSONB
);

-- 转换为时序表
SELECT create_hypertable('sensor_data', 'time');

-- 创建索引
CREATE INDEX idx_sensor_device_time ON sensor_data (device_id, time DESC);
CREATE INDEX idx_sensor_location ON sensor_data USING GIST (location);

-- 数据压缩
SELECT add_compression_policy('sensor_data', INTERVAL '7 days');
```

### 2.2 设备监控

**核心需求**:
- 实时监控
- 状态告警
- 历史查询
- 统计分析

**技术方案**:
```sql
-- 设备状态表
CREATE TABLE device_status (
    time TIMESTAMPTZ NOT NULL,
    device_id TEXT NOT NULL,
    status TEXT NOT NULL,
    temperature NUMERIC(5,2),
    humidity NUMERIC(5,2),
    battery_level INT,
    location GEOGRAPHY(POINT, 4326)
);

-- 转换为时序表
SELECT create_hypertable('device_status', 'time');

-- 实时监控查询
SELECT
    device_id,
    time_bucket('1 minute', time) as bucket,
    AVG(temperature) as avg_temp,
    MAX(temperature) as max_temp,
    MIN(temperature) as min_temp,
    status
FROM device_status
WHERE time >= NOW() - INTERVAL '1 hour'
GROUP BY device_id, bucket, status
ORDER BY bucket DESC;
```

### 2.3 实时告警

**核心需求**:
- 实时检测异常
- 告警通知
- 告警历史
- 告警规则配置

**技术方案**:
```sql
-- 告警规则表
CREATE TABLE alert_rules (
    rule_id SERIAL PRIMARY KEY,
    device_id TEXT,
    sensor_type TEXT,
    threshold_value NUMERIC(10,2),
    condition TEXT,  -- '>', '<', '=', '!='
    enabled BOOLEAN DEFAULT true
);

-- 告警记录表
CREATE TABLE alerts (
    alert_id BIGSERIAL PRIMARY KEY,
    rule_id INT NOT NULL,
    device_id TEXT NOT NULL,
    sensor_type TEXT,
    actual_value NUMERIC(10,2),
    threshold_value NUMERIC(10,2),
    alert_time TIMESTAMPTZ DEFAULT NOW(),
    status TEXT DEFAULT 'open'
);

-- 实时告警检测（使用触发器）
CREATE OR REPLACE FUNCTION check_alerts()
RETURNS TRIGGER AS $$
DECLARE
    v_rule RECORD;
BEGIN
    -- 检查所有相关规则
    FOR v_rule IN
        SELECT * FROM alert_rules
        WHERE device_id = NEW.device_id
        AND sensor_type = NEW.sensor_type
        AND enabled = true
    LOOP
        -- 检查阈值
        IF (v_rule.condition = '>' AND NEW.value > v_rule.threshold_value) OR
           (v_rule.condition = '<' AND NEW.value < v_rule.threshold_value) OR
           (v_rule.condition = '=' AND NEW.value = v_rule.threshold_value) THEN
            -- 创建告警
            INSERT INTO alerts (rule_id, device_id, sensor_type, actual_value, threshold_value)
            VALUES (v_rule.rule_id, NEW.device_id, NEW.sensor_type, NEW.value, v_rule.threshold_value);

            -- 发送通知
            PERFORM pg_notify('alert', json_build_object(
                'device_id', NEW.device_id,
                'sensor_type', NEW.sensor_type,
                'value', NEW.value,
                'threshold', v_rule.threshold_value
            )::TEXT);
        END IF;
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER sensor_alert_trigger
AFTER INSERT ON sensor_data
FOR EACH ROW EXECUTE FUNCTION check_alerts();
```

---

## 3. 技术架构

### 3.1 数据采集架构

```text
IoT设备
    ↓
数据采集网关
    ↓
消息队列 (Kafka)
    ↓
数据写入层 (批量写入)
    ↓
PostgreSQL + TimescaleDB
    ↓
数据分析层
    ↓
告警系统
```

### 3.2 存储架构

```text
热数据 (最近7天)
    ↓ TimescaleDB
温数据 (7-30天)
    ↓ 压缩存储
冷数据 (30天+)
    ↓ 对象存储 (S3)
```

---

## 4. 数据库设计

### 4.1 传感器数据表

```sql
-- 传感器数据表（时序表）
CREATE TABLE sensor_data (
    time TIMESTAMPTZ NOT NULL,
    device_id TEXT NOT NULL,
    sensor_type TEXT NOT NULL,
    value NUMERIC(10,2),
    unit TEXT,
    location GEOGRAPHY(POINT, 4326),
    metadata JSONB
);

-- 转换为时序表
SELECT create_hypertable('sensor_data', 'time',
    chunk_time_interval => INTERVAL '1 day');

-- 索引
CREATE INDEX idx_sensor_device_time ON sensor_data (device_id, time DESC);
CREATE INDEX idx_sensor_type_time ON sensor_data (sensor_type, time DESC);
CREATE INDEX idx_sensor_location ON sensor_data USING GIST (location);
```

### 4.2 设备表

```sql
-- 设备表
CREATE TABLE devices (
    device_id TEXT PRIMARY KEY,
    device_name TEXT NOT NULL,
    device_type TEXT NOT NULL,
    location GEOGRAPHY(POINT, 4326),
    status TEXT DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_devices_location ON devices USING GIST (location);
CREATE INDEX idx_devices_type ON devices(device_type);
```

---

## 5. 性能优化

### 5.1 写入优化

```sql
-- 批量写入
INSERT INTO sensor_data (time, device_id, sensor_type, value)
SELECT
    time,
    device_id,
    sensor_type,
    value
FROM unnest(
    ARRAY['2025-01-01 00:00:00'::TIMESTAMPTZ, ...],
    ARRAY['device1', ...],
    ARRAY['temperature', ...],
    ARRAY[25.5, ...]
) AS t(time, device_id, sensor_type, value);

-- 使用COPY批量导入
COPY sensor_data (time, device_id, sensor_type, value)
FROM '/path/to/data.csv' WITH CSV;
```

### 5.2 查询优化

```sql
-- 使用连续聚合
CREATE MATERIALIZED VIEW sensor_data_hourly
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 hour', time) as bucket,
    device_id,
    sensor_type,
    AVG(value) as avg_value,
    MAX(value) as max_value,
    MIN(value) as min_value
FROM sensor_data
GROUP BY bucket, device_id, sensor_type;

-- 自动刷新
SELECT add_continuous_aggregate_policy('sensor_data_hourly',
    start_offset => INTERVAL '3 hours',
    end_offset => INTERVAL '1 hour',
    schedule_interval => INTERVAL '1 hour');
```

### 5.3 数据压缩

```sql
-- 启用压缩
ALTER TABLE sensor_data SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'device_id',
    timescaledb.compress_orderby = 'time DESC'
);

-- 压缩策略
SELECT add_compression_policy('sensor_data', INTERVAL '7 days');
```

---

## 6. 最佳实践

### 6.1 数据采集

- ✅ **批量写入**: 减少写入次数
- ✅ **异步写入**: 使用消息队列
- ✅ **数据验证**: 写入前验证数据
- ✅ **错误处理**: 完善的错误处理

### 6.2 数据存储

- ✅ **时序表**: 使用TimescaleDB
- ✅ **分区策略**: 按时间分区
- ✅ **数据压缩**: 压缩历史数据
- ✅ **冷热分离**: 热数据SSD，冷数据对象存储

### 6.3 数据分析

- ✅ **连续聚合**: 预聚合数据
- ✅ **物化视图**: 加速查询
- ✅ **索引优化**: 创建合适索引
- ✅ **查询优化**: 优化慢查询

---

## 📚 相关文档

- [03-IoT时序数据系统](./03-IoT时序数据系统/README.md) - IoT时序数据系统案例
- [08-流处理与时序](../08-流处理与时序/README.md) - 流处理与时序
- [07-多模型数据库/空间数据](../07-多模型数据库/空间数据/README.md) - 空间数据

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
