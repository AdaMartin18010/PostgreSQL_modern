---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL\cases\æ—¶åºç›‘æ§.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹ï¼šæ—¶åºç›‘æ§ï¼ˆå ä½ï¼‰

## æ¶æ„

- æŒ‡æ ‡é‡‡é›† â†’ PostgreSQL åˆ†åŒºè¡¨ â†’ BRIN ç´¢å¼•/èšåˆ â†’ æŠ¥è¡¨

## å…³é”®ç‚¹

- åˆ†åŒºç­–ç•¥ã€å‹ç¼©ä¸ä¿ç•™ç­–ç•¥ã€èšåˆç‰©åŒ–ä¸æŸ¥è¯¢è£å‰ª

## éªŒè¯

- æŸ¥è¯¢å»¶è¿Ÿã€å­˜å‚¨æˆæœ¬ã€å†™å…¥ååä¸ä¿ç•™åˆè§„

## æœ€å°å¯å¤ç°ï¼ˆå ä½ï¼‰

```sql
CREATE TABLE metrics(
  ts timestamptz NOT NULL,
  name text NOT NULL,
  value double precision,
  PRIMARY KEY (ts, name)
) PARTITION BY RANGE (ts);
-- åˆ›å»ºæ¯æ—¥åˆ†åŒºï¼ˆç¤ºæ„ï¼‰
-- CREATE TABLE metrics_20250911 PARTITION OF metrics FOR VALUES FROM ('2025-09-11') TO ('2025-09-12');
CREATE INDEX ON metrics USING brin (ts);

-- æŸ¥è¯¢è£å‰ªæ¼”ç¤º
EXPLAIN SELECT avg(value) FROM metrics WHERE ts >= now() - interval '1 day' AND name = 'cpu';
```

---

## 1. ç³»ç»Ÿæ¦‚è¿°

æ—¶åºç›‘æ§ç³»ç»Ÿæ˜¯åŸºäºPostgreSQLæ„å»ºçš„é«˜æ€§èƒ½æ—¶åºæ•°æ®ç›‘æ§ç³»ç»Ÿï¼Œæ”¯æŒå¤§è§„æ¨¡æŒ‡æ ‡é‡‡é›†ã€å­˜å‚¨å’ŒæŸ¥è¯¢ã€‚

**ç³»ç»Ÿç‰¹ç‚¹**ï¼š

- **é«˜æ€§èƒ½** - åˆ©ç”¨åˆ†åŒºå’ŒBRINç´¢å¼•å®ç°é«˜æ€§èƒ½æŸ¥è¯¢
- **ä½æˆæœ¬** - é€šè¿‡å‹ç¼©å’Œä¿ç•™ç­–ç•¥é™ä½å­˜å‚¨æˆæœ¬
- **å¯æ‰©å±•** - æ”¯æŒæ°´å¹³æ‰©å±•å’Œè´Ÿè½½å‡è¡¡
- **å®æ—¶æ€§** - æ”¯æŒå®æ—¶æ•°æ®å†™å…¥å’ŒæŸ¥è¯¢

---

## 2. æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```text
æ—¶åºç›‘æ§ç³»ç»Ÿæ¶æ„
â”œâ”€â”€ æ•°æ®é‡‡é›†å±‚
â”‚   â”œâ”€â”€ Prometheus Exporter
â”‚   â”œâ”€â”€ è‡ªå®šä¹‰é‡‡é›†å™¨
â”‚   â””â”€â”€ æ—¥å¿—é‡‡é›†
â”œâ”€â”€ æ•°æ®å­˜å‚¨å±‚
â”‚   â”œâ”€â”€ PostgreSQLåˆ†åŒºè¡¨
â”‚   â”œâ”€â”€ BRINç´¢å¼•
â”‚   â””â”€â”€ å‹ç¼©ç­–ç•¥
â”œâ”€â”€ æ•°æ®å¤„ç†å±‚
â”‚   â”œâ”€â”€ å®æ—¶èšåˆ
â”‚   â”œâ”€â”€ ç‰©åŒ–è§†å›¾
â”‚   â””â”€â”€ æ•°æ®ä¿ç•™
â””â”€â”€ æŸ¥è¯¢æœåŠ¡å±‚
    â”œâ”€â”€ Grafanaé›†æˆ
    â”œâ”€â”€ RESTful API
    â””â”€â”€ æŠ¥è¡¨ç”Ÿæˆ
```

### 2.2 æ•°æ®æ¨¡å‹è®¾è®¡

**æ•°æ®æ¨¡å‹å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. æŒ‡æ ‡è¡¨ï¼ˆåˆ†åŒºè¡¨ï¼‰
CREATE TABLE metrics (
    ts TIMESTAMPTZ NOT NULL,
    name TEXT NOT NULL,
    value DOUBLE PRECISION,
    tags JSONB,
    PRIMARY KEY (ts, name)
) PARTITION BY RANGE (ts);

-- åˆ›å»ºæ¯æ—¥åˆ†åŒºå‡½æ•°
CREATE OR REPLACE FUNCTION create_daily_partition(
    p_table_name TEXT,
    p_date DATE
)
RETURNS TEXT AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    start_date := p_date;
    end_date := start_date + INTERVAL '1 day';
    partition_name := p_table_name || '_' || to_char(start_date, 'YYYYMMDD');

    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
        partition_name,
        p_table_name,
        start_date,
        end_date
    );

    -- åˆ›å»ºBRINç´¢å¼•
    EXECUTE format(
        'CREATE INDEX IF NOT EXISTS %I ON %I USING BRIN (ts)',
        partition_name || '_ts_idx',
        partition_name
    );

    RETURN partition_name;

EXCEPTION
    WHEN duplicate_table THEN
        RETURN partition_name;
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ›å»ºåˆ†åŒºå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºæœªæ¥7å¤©çš„åˆ†åŒº
DO $$
DECLARE
    i INT;
    partition_date DATE;
BEGIN
    FOR i IN 0..6 LOOP
        partition_date := CURRENT_DATE + (i || ' days')::INTERVAL;
        PERFORM create_daily_partition('metrics', partition_date);
    END LOOP;
END $$;
```

---

## 3. æ ¸å¿ƒå®ç°

### 3.1 æŒ‡æ ‡é‡‡é›†

**æŒ‡æ ‡é‡‡é›†å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ‰¹é‡æ’å…¥æŒ‡æ ‡
CREATE OR REPLACE FUNCTION insert_metrics(
    p_metrics JSONB[]
)
RETURNS TABLE (
    inserted_count BIGINT,
    duration_ms NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    inserted_rows BIGINT;
BEGIN
    start_time := clock_timestamp();

    INSERT INTO metrics (ts, name, value, tags)
    SELECT
        COALESCE((m->>'ts')::TIMESTAMPTZ, NOW()),
        m->>'name',
        (m->>'value')::DOUBLE PRECISION,
        (m->'tags')::JSONB
    FROM unnest(p_metrics) AS m;

    GET DIAGNOSTICS inserted_rows = ROW_COUNT;
    end_time := clock_timestamp();

    RETURN QUERY SELECT
        inserted_rows,
        EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ’å…¥æŒ‡æ ‡å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM insert_metrics(ARRAY[
    '{"ts": "2024-01-01 10:00:00", "name": "cpu", "value": 75.5, "tags": {"host": "server1"}}'::JSONB,
    '{"ts": "2024-01-01 10:00:00", "name": "memory", "value": 60.2, "tags": {"host": "server1"}}'::JSONB
]);
```

### 3.2 å‹ç¼©ä¸ä¿ç•™ç­–ç•¥

**å‹ç¼©å’Œä¿ç•™ç­–ç•¥å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å‹ç¼©ç­–ç•¥è¡¨
CREATE TABLE IF NOT EXISTS compression_policies (
    id SERIAL PRIMARY KEY,
    metric_name TEXT,
    compression_after_days INT DEFAULT 7,
    retention_days INT DEFAULT 30,
    enabled BOOLEAN DEFAULT TRUE
);

-- å‹ç¼©å‡½æ•°ï¼ˆèšåˆåˆ°å°æ—¶çº§åˆ«ï¼‰
CREATE OR REPLACE FUNCTION compress_metrics(
    p_partition_name TEXT,
    p_compression_date DATE
)
RETURNS TABLE (
    compressed_count BIGINT,
    compressed_size_bytes BIGINT
) AS $$
DECLARE
    compressed_rows BIGINT;
    size_before BIGINT;
    size_after BIGINT;
BEGIN
    -- è·å–å‹ç¼©å‰å¤§å°
    SELECT pg_total_relation_size(p_partition_name) INTO size_before;

    -- åˆ›å»ºå‹ç¼©è¡¨
    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I AS
        SELECT
            date_trunc(''hour'', ts) AS ts,
            name,
            AVG(value) AS value,
            tags
        FROM %I
        WHERE ts < %L
        GROUP BY date_trunc(''hour'', ts), name, tags',
        p_partition_name || '_compressed',
        p_partition_name,
        p_compression_date
    );

    -- åˆ é™¤åŸå§‹æ•°æ®
    EXECUTE format(
        'DELETE FROM %I WHERE ts < %L',
        p_partition_name,
        p_compression_date
    );

    GET DIAGNOSTICS compressed_rows = ROW_COUNT;

    -- è·å–å‹ç¼©åå¤§å°
    SELECT pg_total_relation_size(p_partition_name || '_compressed') INTO size_after;

    RETURN QUERY SELECT
        compressed_rows,
        size_before - size_after;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å‹ç¼©æŒ‡æ ‡å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- ä¿ç•™ç­–ç•¥ï¼ˆåˆ é™¤æ—§æ•°æ®ï¼‰
CREATE OR REPLACE FUNCTION apply_retention_policy(
    p_retention_days INT DEFAULT 30
)
RETURNS TABLE (
    dropped_partitions TEXT[],
    freed_space_bytes BIGINT
) AS $$
DECLARE
    partition_rec RECORD;
    dropped_partitions_list TEXT[];
    total_freed_space BIGINT := 0;
    partition_size BIGINT;
BEGIN
    FOR partition_rec IN
        SELECT tablename
        FROM pg_tables
        WHERE tablename LIKE 'metrics_%'
          AND tablename ~ '^\d{8}$'  -- åŒ¹é…YYYYMMDDæ ¼å¼
    LOOP
        -- æå–æ—¥æœŸ
        DECLARE
            partition_date DATE;
        BEGIN
            partition_date := to_date(
                substring(partition_rec.tablename from '\d{8}$'),
                'YYYYMMDD'
            );

            -- æ£€æŸ¥æ˜¯å¦è¶…è¿‡ä¿ç•™æœŸé™
            IF partition_date < CURRENT_DATE - (p_retention_days || ' days')::INTERVAL THEN
                -- è·å–åˆ†åŒºå¤§å°
                SELECT pg_total_relation_size(partition_rec.tablename) INTO partition_size;

                -- åˆ é™¤åˆ†åŒº
                EXECUTE format('DROP TABLE IF EXISTS %I', partition_rec.tablename);

                dropped_partitions_list := array_append(dropped_partitions_list, partition_rec.tablename);
                total_freed_space := total_freed_space + COALESCE(partition_size, 0);
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                CONTINUE;  -- è·³è¿‡æ— æ³•è§£æçš„åˆ†åŒº
        END;
    END LOOP;

    RETURN QUERY SELECT
        dropped_partitions_list,
        total_freed_space;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åº”ç”¨ä¿ç•™ç­–ç•¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. æŸ¥è¯¢ä¼˜åŒ–

### 4.1 åˆ†åŒºè£å‰ª

**åˆ†åŒºè£å‰ªä¼˜åŒ–ï¼ˆå¸¦æ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢ä¼˜åŒ–ï¼šç¡®ä¿åˆ†åŒºè£å‰ª
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT AVG(value)
FROM metrics
WHERE ts >= NOW() - INTERVAL '1 day'
  AND name = 'cpu';

-- é¢„æœŸç»“æœï¼š
-- - åªæ‰«ææœ€è¿‘1å¤©çš„åˆ†åŒº
-- - ä½¿ç”¨BRINç´¢å¼•
-- - æŸ¥è¯¢æ—¶é—´ < 100ms
```

### 4.2 èšåˆç‰©åŒ–è§†å›¾

**èšåˆç‰©åŒ–è§†å›¾ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- åˆ›å»ºå°æ—¶èšåˆç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW mv_metrics_hourly AS
SELECT
    date_trunc('hour', ts) AS hour,
    name,
    AVG(value) AS avg_value,
    MIN(value) AS min_value,
    MAX(value) AS max_value,
    COUNT(*) AS sample_count
FROM metrics
WHERE ts >= date_trunc('day', NOW())
GROUP BY date_trunc('hour', ts), name;

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_mv_metrics_hourly_hour_name ON mv_metrics_hourly (hour, name);

-- å¢é‡åˆ·æ–°å‡½æ•°
CREATE OR REPLACE FUNCTION refresh_hourly_metrics()
RETURNS TABLE (
    refreshed_count BIGINT,
    refresh_duration_ms NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    refreshed_rows BIGINT;
BEGIN
    start_time := clock_timestamp();

    -- åˆ é™¤ä»Šå¤©çš„æ•°æ®
    DELETE FROM mv_metrics_hourly
    WHERE hour >= date_trunc('day', NOW());

    -- é‡æ–°è®¡ç®—ä»Šå¤©çš„æ•°æ®
    INSERT INTO mv_metrics_hourly
    SELECT
        date_trunc('hour', ts) AS hour,
        name,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        COUNT(*) AS sample_count
    FROM metrics
    WHERE ts >= date_trunc('day', NOW())
    GROUP BY date_trunc('hour', ts), name;

    GET DIAGNOSTICS refreshed_rows = ROW_COUNT;
    end_time := clock_timestamp();

    RETURN QUERY SELECT
        refreshed_rows,
        EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ·æ–°å°æ—¶èšåˆå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶åˆ·æ–°ï¼ˆæ¯å°æ—¶ï¼‰
SELECT cron.schedule(
    'refresh-hourly-metrics',
    '0 * * * *',
    'SELECT * FROM refresh_hourly_metrics();'
);
```

---

## 5. éªŒè¯ä¸æµ‹è¯•

### 5.1 æŸ¥è¯¢å»¶è¿Ÿæµ‹è¯•

**æŸ¥è¯¢å»¶è¿Ÿæµ‹è¯•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½åˆ†æï¼‰**ï¼š

```sql
-- æŸ¥è¯¢å»¶è¿Ÿæµ‹è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION test_query_latency(
    p_query_type TEXT DEFAULT 'recent'  -- 'recent', 'historical', 'aggregate'
)
RETURNS TABLE (
    query_type TEXT,
    avg_latency_ms NUMERIC,
    p95_latency_ms NUMERIC,
    p99_latency_ms NUMERIC
) AS $$
DECLARE
    latencies NUMERIC[];
    i INT;
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    latency_ms NUMERIC;
BEGIN
    latencies := ARRAY[]::NUMERIC[];

    FOR i IN 1..100 LOOP
        start_time := clock_timestamp();

        CASE p_query_type
            WHEN 'recent' THEN
                PERFORM AVG(value)
                FROM metrics
                WHERE ts >= NOW() - INTERVAL '1 hour'
                  AND name = 'cpu';
            WHEN 'historical' THEN
                PERFORM AVG(value)
                FROM metrics
                WHERE ts >= NOW() - INTERVAL '7 days'
                  AND name = 'cpu';
            WHEN 'aggregate' THEN
                PERFORM * FROM mv_metrics_hourly
                WHERE hour >= NOW() - INTERVAL '24 hours'
                  AND name = 'cpu';
        END CASE;

        end_time := clock_timestamp();
        latency_ms := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
        latencies := array_append(latencies, latency_ms);
    END LOOP;

    RETURN QUERY SELECT
        p_query_type,
        ROUND(AVG(unnest), 2),
        ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY unnest), 2),
        ROUND(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY unnest), 2)
    FROM unnest(latencies) AS unnest;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢å»¶è¿Ÿæµ‹è¯•å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œæµ‹è¯•
SELECT * FROM test_query_latency('recent');
SELECT * FROM test_query_latency('historical');
SELECT * FROM test_query_latency('aggregate');
```

### 5.2 å­˜å‚¨æˆæœ¬åˆ†æ

**å­˜å‚¨æˆæœ¬åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å­˜å‚¨æˆæœ¬åˆ†æå‡½æ•°
CREATE OR REPLACE FUNCTION analyze_storage_costs()
RETURNS TABLE (
    partition_name TEXT,
    row_count BIGINT,
    table_size TEXT,
    index_size TEXT,
    total_size TEXT,
    compression_ratio NUMERIC
) AS $$
DECLARE
    partition_rec RECORD;
    compressed_size BIGINT;
    original_size BIGINT;
BEGIN
    FOR partition_rec IN
        SELECT tablename
        FROM pg_tables
        WHERE tablename LIKE 'metrics_%'
        ORDER BY tablename DESC
        LIMIT 10
    LOOP
        -- æ£€æŸ¥æ˜¯å¦æœ‰å‹ç¼©è¡¨
        SELECT pg_total_relation_size(partition_rec.tablename || '_compressed') INTO compressed_size;
        SELECT pg_total_relation_size(partition_rec.tablename) INTO original_size;

        RETURN QUERY SELECT
            partition_rec.tablename,
            (SELECT COUNT(*) FROM metrics WHERE ts::DATE = to_date(substring(partition_rec.tablename from '\d{8}$'), 'YYYYMMDD'))::BIGINT,
            pg_size_pretty(pg_relation_size(partition_rec.tablename))::TEXT,
            pg_size_pretty(pg_indexes_size(partition_rec.tablename))::TEXT,
            pg_size_pretty(pg_total_relation_size(partition_rec.tablename))::TEXT,
            CASE
                WHEN compressed_size > 0 AND original_size > 0
                THEN ROUND(compressed_size::NUMERIC / original_size, 2)
                ELSE NULL
            END;
    END LOOP;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å­˜å‚¨æˆæœ¬åˆ†æå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œåˆ†æ
SELECT * FROM analyze_storage_costs();
```

---

## 6. ç›‘æ§ä¸è¯Šæ–­

### 6.1 å†™å…¥ååç›‘æ§

**å†™å…¥ååç›‘æ§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å†™å…¥ååç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_write_throughput AS
SELECT
    date_trunc('minute', ts) AS minute,
    COUNT(*) AS events_per_minute,
    COUNT(*) / 60.0 AS events_per_second
FROM metrics
WHERE ts >= NOW() - INTERVAL '1 hour'
GROUP BY date_trunc('minute', ts)
ORDER BY minute DESC;

-- æŸ¥è¯¢å†™å…¥åå
SELECT * FROM v_write_throughput;
```

### 6.2 ä¿ç•™åˆè§„æ£€æŸ¥

**ä¿ç•™åˆè§„æ£€æŸ¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ä¿ç•™åˆè§„æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_retention_compliance(
    p_retention_days INT DEFAULT 30
)
RETURNS TABLE (
    partition_name TEXT,
    partition_date DATE,
    age_days INT,
    compliance_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.tablename AS partition_name,
        to_date(substring(t.tablename from '\d{8}$'), 'YYYYMMDD') AS partition_date,
        EXTRACT(DAYS FROM (CURRENT_DATE - to_date(substring(t.tablename from '\d{8}$'), 'YYYYMMDD')))::INT AS age_days,
        CASE
            WHEN EXTRACT(DAYS FROM (CURRENT_DATE - to_date(substring(t.tablename from '\d{8}$'), 'YYYYMMDD'))) > p_retention_days
            THEN 'è¶…æœŸ'
            ELSE 'åˆè§„'
        END AS compliance_status
    FROM pg_tables t
    WHERE t.tablename LIKE 'metrics_%'
      AND t.tablename ~ '^\d{8}$'
    ORDER BY partition_date;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ä¿ç•™åˆè§„æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œæ£€æŸ¥
SELECT * FROM check_retention_compliance(30);
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [03-IoTæ—¶åºæ•°æ®ç³»ç»Ÿ/](./03-IoTæ—¶åºæ•°æ®ç³»ç»Ÿ/) - IoTæ—¶åºæ•°æ®ç³»ç»Ÿå®Œæ•´æ¡ˆä¾‹
- [08-æµå¤„ç†ä¸æ—¶åº/](../08-æµå¤„ç†ä¸æ—¶åº/README.md) - æµå¤„ç†ä¸æ—¶åºæ•°æ®
- [19-å®æˆ˜æ¡ˆä¾‹/README.md](./README.md) - å®æˆ˜æ¡ˆä¾‹ä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
