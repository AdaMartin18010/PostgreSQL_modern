---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\02-OLAPåˆ†æç³»ç»Ÿ\04-æŸ¥è¯¢ä¼˜åŒ–.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# OLAPåˆ†æç³»ç»Ÿ - æŸ¥è¯¢ä¼˜åŒ–

> **PostgreSQLç‰ˆæœ¬**: 18.x

---

## ğŸ“‹ ç›®å½•

- [OLAPåˆ†æç³»ç»Ÿ - æŸ¥è¯¢ä¼˜åŒ–](#olapåˆ†æç³»ç»Ÿ---æŸ¥è¯¢ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–](#ä¸€å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–)
  - [äºŒã€ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™](#äºŒç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™)
  - [ä¸‰ã€åˆ†åŒºè£å‰ªéªŒè¯](#ä¸‰åˆ†åŒºè£å‰ªéªŒè¯)
  - [å››ã€ç´¢å¼•ç­–ç•¥](#å››ç´¢å¼•ç­–ç•¥)
  - [äº”ã€æŸ¥è¯¢æ¨¡æ¿](#äº”æŸ¥è¯¢æ¨¡æ¿)
  - [å…­ã€æ€§èƒ½ç›‘æ§](#å…­æ€§èƒ½ç›‘æ§)

## ä¸€ã€å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

```sql
-- é…ç½®
SET max_parallel_workers_per_gather = 8;
SET parallel_tuple_cost = 0.001;

-- å¤§è¡¨èšåˆæŸ¥è¯¢
EXPLAIN (ANALYZE, COSTS OFF)
SELECT
    t.year, t.month,
    p.category_l1,
    SUM(s.amount) as total_sales,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
WHERE t.year = 2025
GROUP BY t.year, t.month, p.category_l1;

-- PostgreSQL 18æ‰§è¡Œè®¡åˆ’
/*
Finalize GroupAggregate (actual time=3200ms)
  ->  Gather Merge
        Workers Planned: 8
        Workers Launched: 8
        ->  Partial GroupAggregate
              ->  Parallel Hash Join
                    ->  Parallel Append
                          ->  Parallel Seq Scan on fact_sales_2025_01
                          ->  Parallel Seq Scan on fact_sales_2025_02
                          ...
                    ->  Parallel Hash (dim_product)

PG 17å¯¹æ¯”ï¼š12.5ç§’
PG 18ï¼š3.2ç§’ (-74%)
*/
```

---

## äºŒã€ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™

```sql
-- æŸ¥è¯¢æ”¹å†™è§„åˆ™
CREATE OR REPLACE FUNCTION rewrite_to_mv(query TEXT)
RETURNS TEXT AS $$
BEGIN
    -- æ£€æµ‹æ˜¯å¦å¯ä»¥ä½¿ç”¨èšåˆè¡¨
    IF query LIKE '%GROUP BY date_key%' THEN
        -- æ”¹å†™ä¸ºä½¿ç”¨agg_sales_daily
        RETURN 'SELECT * FROM agg_sales_daily WHERE ...';
    END IF;
    RETURN query;
END;
$$ LANGUAGE plpgsql;

-- æ€§èƒ½æå‡ï¼š
-- äº‹å®è¡¨æŸ¥è¯¢ï¼š15ç§’
-- èšåˆè¡¨æŸ¥è¯¢ï¼š0.3ç§’ (-98%)
```

---

## ä¸‰ã€åˆ†åŒºè£å‰ªéªŒè¯

```sql
-- æŸ¥è¯¢è®¡åˆ’åˆ†æ
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY)
SELECT * FROM fact_sales
WHERE transaction_time BETWEEN '2025-12-01' AND '2025-12-31';

/*
Append (actual time=0.5ms..150ms)
  ->  Seq Scan on fact_sales_2025_12
Partitions Pruned: 35  â­ åªæ‰«æ1ä¸ªåˆ†åŒºï¼ˆå…±36ä¸ªï¼‰

Execution Time: 150ms

å¯¹æ¯”å…¨è¡¨æ‰«æï¼š
- æ— åˆ†åŒºï¼š2500ms
- æœ‰åˆ†åŒºï¼ˆPG18ï¼‰ï¼š150ms (-94%)
*/
```

---

## å››ã€ç´¢å¼•ç­–ç•¥

```sql
-- è¦†ç›–ç´¢å¼•ï¼ˆé¿å…å›è¡¨ï¼‰
CREATE INDEX idx_fact_sales_coverage
ON fact_sales (date_key, product_key)
INCLUDE (amount, quantity, profit);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æœ€è¿‘æ•°æ®ï¼‰
CREATE INDEX idx_fact_sales_recent
ON fact_sales (customer_key, transaction_time)
WHERE transaction_time > NOW() - INTERVAL '90 days';

-- â­ PostgreSQL 18ï¼šSkip Scanè‡ªåŠ¨ä¼˜åŒ–å¤šåˆ—ç´¢å¼•
```

---

## äº”ã€æŸ¥è¯¢æ¨¡æ¿

```sql
-- é¢„ç¼–è¯‘æŸ¥è¯¢ï¼ˆè®¡åˆ’ç¼“å­˜ï¼‰
PREPARE sales_by_category (int, int) AS
SELECT
    p.category_l1,
    SUM(s.amount) as total
FROM fact_sales s
JOIN dim_product p ON s.product_key = p.product_key
WHERE date_key BETWEEN $1 AND $2
GROUP BY p.category_l1;

-- æ‰§è¡Œï¼ˆä½¿ç”¨ç¼“å­˜è®¡åˆ’ï¼‰
EXECUTE sales_by_category(20250101, 20251231);

-- PostgreSQL 18ï¼š
-- è®¡åˆ’ç¼“å­˜å‘½ä¸­ç‡ï¼š98%
-- è§„åˆ’æ—¶é—´é™ä½ï¼š-90%
```

---

## å…­ã€æ€§èƒ½ç›‘æ§

```sql
CREATE VIEW olap_query_stats AS
SELECT
    queryid,
    left(query, 80) as query_preview,
    calls,
    mean_exec_time,
    total_exec_time,
    rows,
    shared_blks_hit,
    shared_blks_read,
    ROUND(shared_blks_hit * 100.0 /
        NULLIF(shared_blks_hit + shared_blks_read, 0), 2) as cache_hit_ratio
FROM pg_stat_statements
WHERE query LIKE '%fact_sales%'
ORDER BY total_exec_time DESC
LIMIT 20;
```

---

---

## ä¸ƒã€ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–

### 7.1 å¤šå˜é‡ç»Ÿè®¡

**å¤šå˜é‡ç»Ÿè®¡åˆ›å»ºï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- åˆ›å»ºå¤šå˜é‡ç»Ÿè®¡
CREATE STATISTICS fact_sales_multivar (dependencies, ndistinct, mcv)
ON date_key, product_key, customer_key, store_key
FROM fact_sales;

-- åˆ†æç»Ÿè®¡ä¿¡æ¯
ANALYZE fact_sales;

-- æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯
SELECT * FROM pg_statistic_ext WHERE stxname = 'fact_sales_multivar';

-- PostgreSQL 18ï¼šç»Ÿè®¡ä¿¡æ¯è‡ªåŠ¨æ¨è
SELECT * FROM pg_stats_ext_recommendations;
```

### 7.2 ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦æå‡

**ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦æå‡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æé«˜ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦
ALTER TABLE fact_sales ALTER COLUMN amount SET STATISTICS 500;
ALTER TABLE fact_sales ALTER COLUMN customer_key SET STATISTICS 500;

-- é‡æ–°åˆ†æ
ANALYZE VERBOSE fact_sales;

-- éªŒè¯ç»Ÿè®¡ä¿¡æ¯
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation
FROM pg_stats
WHERE tablename = 'fact_sales'
ORDER BY n_distinct DESC;
```

---

## å…«ã€æŸ¥è¯¢ç¼“å­˜ç­–ç•¥

### 8.1 æŸ¥è¯¢ç»“æœç¼“å­˜

**æŸ¥è¯¢ç»“æœç¼“å­˜å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢ç»“æœç¼“å­˜è¡¨
CREATE TABLE IF NOT EXISTS query_cache (
    cache_key TEXT PRIMARY KEY,
    query_text TEXT NOT NULL,
    result_data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,
    hit_count INT DEFAULT 0
);

-- æŸ¥è¯¢ç¼“å­˜å‡½æ•°
CREATE OR REPLACE FUNCTION get_cached_query_result(
    p_query_text TEXT,
    p_cache_ttl_minutes INT DEFAULT 5
)
RETURNS TABLE (
    result_data JSONB,
    from_cache BOOLEAN
) AS $$
DECLARE
    cache_key_val TEXT;
    cached_result JSONB;
    cache_expires TIMESTAMPTZ;
BEGIN
    -- ç”Ÿæˆç¼“å­˜é”®ï¼ˆæŸ¥è¯¢æ–‡æœ¬çš„å“ˆå¸Œï¼‰
    cache_key_val := md5(p_query_text);

    -- æ£€æŸ¥ç¼“å­˜
    SELECT result_data, expires_at
    INTO cached_result, cache_expires
    FROM query_cache
    WHERE cache_key = cache_key_val
      AND expires_at > NOW();

    IF cached_result IS NOT NULL THEN
        -- æ›´æ–°å‘½ä¸­æ¬¡æ•°
        UPDATE query_cache
        SET hit_count = hit_count + 1
        WHERE cache_key = cache_key_val;

        RETURN QUERY SELECT cached_result, TRUE;
        RETURN;
    END IF;

    -- ç¼“å­˜æœªå‘½ä¸­ï¼Œè¿”å›ç©ºç»“æœï¼ˆç”±è°ƒç”¨è€…æ‰§è¡ŒæŸ¥è¯¢å¹¶ç¼“å­˜ï¼‰
    RETURN QUERY SELECT NULL::JSONB, FALSE;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢ç¼“å­˜è·å–å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- è®¾ç½®æŸ¥è¯¢ç¼“å­˜å‡½æ•°
CREATE OR REPLACE FUNCTION set_cached_query_result(
    p_query_text TEXT,
    p_result_data JSONB,
    p_cache_ttl_minutes INT DEFAULT 5
)
RETURNS VOID AS $$
DECLARE
    cache_key_val TEXT;
BEGIN
    cache_key_val := md5(p_query_text);

    INSERT INTO query_cache (
        cache_key, query_text, result_data, expires_at
    )
    VALUES (
        cache_key_val,
        p_query_text,
        p_result_data,
        NOW() + (p_cache_ttl_minutes || ' minutes')::INTERVAL
    )
    ON CONFLICT (cache_key) DO UPDATE
    SET result_data = EXCLUDED.result_data,
        expires_at = EXCLUDED.expires_at,
        created_at = NOW(),
        hit_count = 0;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'è®¾ç½®æŸ¥è¯¢ç¼“å­˜å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## ä¹ã€æŸ¥è¯¢è®¡åˆ’ä¼˜åŒ–

### 9.1 æŸ¥è¯¢è®¡åˆ’åˆ†æ

**æŸ¥è¯¢è®¡åˆ’åˆ†æå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢è®¡åˆ’åˆ†æå‡½æ•°
CREATE OR REPLACE FUNCTION analyze_query_plan(
    p_query_text TEXT
)
RETURNS TABLE (
    plan_node TEXT,
    node_type TEXT,
    cost_start NUMERIC,
    cost_end NUMERIC,
    actual_time_start NUMERIC,
    actual_time_end NUMERIC,
    rows_planned BIGINT,
    rows_actual BIGINT,
    buffers_shared_hit BIGINT,
    buffers_shared_read BIGINT
) AS $$
DECLARE
    plan_json JSONB;
BEGIN
    -- æ‰§è¡ŒEXPLAIN ANALYZE
    EXECUTE format('EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) %s', p_query_text)
    INTO plan_json;

    -- è§£æè®¡åˆ’ï¼ˆç®€åŒ–ç‰ˆï¼‰
    RETURN QUERY
    SELECT
        plan_json->0->'Plan'->>'Node Type' AS plan_node,
        plan_json->0->'Plan'->>'Node Type' AS node_type,
        (plan_json->0->'Plan'->>'Startup Cost')::NUMERIC AS cost_start,
        (plan_json->0->'Plan'->>'Total Cost')::NUMERIC AS cost_end,
        (plan_json->0->'Execution Time')::NUMERIC AS actual_time_start,
        (plan_json->0->'Execution Time')::NUMERIC AS actual_time_end,
        (plan_json->0->'Plan'->>'Plan Rows')::BIGINT AS rows_planned,
        (plan_json->0->'Plan'->>'Actual Rows')::BIGINT AS rows_actual,
        (plan_json->0->'Plan'->'Shared Hit Blocks')::BIGINT AS buffers_shared_hit,
        (plan_json->0->'Plan'->'Shared Read Blocks')::BIGINT AS buffers_shared_read;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢è®¡åˆ’åˆ†æå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## åã€æŸ¥è¯¢æ€§èƒ½åŸºå‡†æµ‹è¯•

### 10.1 æ€§èƒ½åŸºå‡†æµ‹è¯•

**æ€§èƒ½åŸºå‡†æµ‹è¯•å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ€§èƒ½åŸºå‡†æµ‹è¯•è¡¨
CREATE TABLE IF NOT EXISTS query_benchmarks (
    id SERIAL PRIMARY KEY,
    query_name TEXT NOT NULL,
    query_text TEXT NOT NULL,
    execution_time_ms NUMERIC,
    rows_returned BIGINT,
    cache_hit_ratio NUMERIC,
    test_date TIMESTAMPTZ DEFAULT NOW(),
    pg_version TEXT DEFAULT version()
);

-- æ€§èƒ½åŸºå‡†æµ‹è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION benchmark_query(
    p_query_name TEXT,
    p_query_text TEXT,
    p_iterations INT DEFAULT 5
)
RETURNS TABLE (
    query_name TEXT,
    avg_execution_time_ms NUMERIC,
    min_execution_time_ms NUMERIC,
    max_execution_time_ms NUMERIC,
    avg_rows_returned NUMERIC,
    cache_hit_ratio NUMERIC
) AS $$
DECLARE
    i INT;
    exec_time NUMERIC;
    total_time NUMERIC := 0;
    min_time NUMERIC := 999999;
    max_time NUMERIC := 0;
    rows_count BIGINT;
    hit_ratio NUMERIC;
BEGIN
    FOR i IN 1..p_iterations LOOP
        -- æ‰§è¡ŒæŸ¥è¯¢å¹¶è®°å½•æ—¶é—´
        EXECUTE format('EXPLAIN (ANALYZE, BUFFERS) %s', p_query_text);

        -- å®é™…æ‰§è¡ŒæŸ¥è¯¢
        EXECUTE format('SELECT COUNT(*) FROM (%s) AS subq', p_query_text) INTO rows_count;

        -- è·å–æ‰§è¡Œæ—¶é—´ï¼ˆç®€åŒ–å¤„ç†ï¼‰
        SELECT mean_exec_time INTO exec_time
        FROM pg_stat_statements
        WHERE query = p_query_text
        LIMIT 1;

        IF exec_time IS NULL THEN
            exec_time := 0;
        END IF;

        total_time := total_time + exec_time;
        min_time := LEAST(min_time, exec_time);
        max_time := GREATEST(max_time, exec_time);
    END LOOP;

    -- è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
    SELECT
        ROUND(shared_blks_hit * 100.0 / NULLIF(shared_blks_hit + shared_blks_read, 0), 2)
    INTO hit_ratio
    FROM pg_stat_statements
    WHERE query = p_query_text
    LIMIT 1;

    -- è®°å½•åŸºå‡†æµ‹è¯•ç»“æœ
    INSERT INTO query_benchmarks (
        query_name, query_text, execution_time_ms, rows_returned, cache_hit_ratio
    )
    VALUES (
        p_query_name,
        p_query_text,
        total_time / p_iterations,
        rows_count,
        hit_ratio
    );

    RETURN QUERY SELECT
        p_query_name,
        total_time / p_iterations,
        min_time,
        max_time,
        rows_count::NUMERIC,
        hit_ratio;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ€§èƒ½åŸºå‡†æµ‹è¯•å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**æ–‡æ¡£å®Œæˆ** âœ…
