---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\02-OLAPåˆ†æç³»ç»Ÿ\04-æŸ¥è¯¢ä¼˜åŒ–.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# OLAPåˆ†æç³»ç»Ÿ - æŸ¥è¯¢ä¼˜åŒ–

> **PostgreSQLç‰ˆæœ¬**: 18.x

---

## ğŸ“‹ ç›®å½•

- [OLAPåˆ†æç³»ç»Ÿ - æŸ¥è¯¢ä¼˜åŒ–](#olapåˆ†æç³»ç»Ÿ---æŸ¥è¯¢ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–](#ä¸€å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–)
  - [äºŒã€ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™](#äºŒç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™)
  - [ä¸‰ã€åˆ†åŒºè£å‰ªéªŒè¯](#ä¸‰åˆ†åŒºè£å‰ªéªŒè¯)
  - [å››ã€ç´¢å¼•ç­–ç•¥](#å››ç´¢å¼•ç­–ç•¥)
  - [äº”ã€æŸ¥è¯¢æ¨¡æ¿](#äº”æŸ¥è¯¢æ¨¡æ¿)
  - [å…­ã€æ€§èƒ½ç›‘æ§](#å…­æ€§èƒ½ç›‘æ§)
  - [ä¸ƒã€ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–](#ä¸ƒç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–)
    - [7.1 å¤šå˜é‡ç»Ÿè®¡](#71-å¤šå˜é‡ç»Ÿè®¡)
    - [7.2 ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦æå‡](#72-ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦æå‡)
  - [å…«ã€æŸ¥è¯¢ç¼“å­˜ç­–ç•¥](#å…«æŸ¥è¯¢ç¼“å­˜ç­–ç•¥)
    - [8.1 æŸ¥è¯¢ç»“æœç¼“å­˜](#81-æŸ¥è¯¢ç»“æœç¼“å­˜)
  - [ä¹ã€æŸ¥è¯¢è®¡åˆ’ä¼˜åŒ–](#ä¹æŸ¥è¯¢è®¡åˆ’ä¼˜åŒ–)
    - [9.1 æŸ¥è¯¢è®¡åˆ’åˆ†æ](#91-æŸ¥è¯¢è®¡åˆ’åˆ†æ)
  - [åã€æŸ¥è¯¢æ€§èƒ½åŸºå‡†æµ‹è¯•](#åæŸ¥è¯¢æ€§èƒ½åŸºå‡†æµ‹è¯•)
    - [10.1 æ€§èƒ½åŸºå‡†æµ‹è¯•](#101-æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [7. PostgreSQL 18æŸ¥è¯¢ä¼˜åŒ–å¢å¼º](#7-postgresql-18æŸ¥è¯¢ä¼˜åŒ–å¢å¼º)
    - [7.1 å¼‚æ­¥I/Oä¼˜åŒ–](#71-å¼‚æ­¥ioä¼˜åŒ–)
    - [7.2 å¹¶è¡ŒæŸ¥è¯¢å¢å¼º](#72-å¹¶è¡ŒæŸ¥è¯¢å¢å¼º)
  - [8. OLAPæŸ¥è¯¢ç›‘æ§](#8-olapæŸ¥è¯¢ç›‘æ§)
    - [8.1 æŸ¥è¯¢æ€§èƒ½ç›‘æ§](#81-æŸ¥è¯¢æ€§èƒ½ç›‘æ§)
    - [8.2 æ…¢æŸ¥è¯¢åˆ†æ](#82-æ…¢æŸ¥è¯¢åˆ†æ)
  - [9. OLAPæŸ¥è¯¢æœ€ä½³å®è·µ](#9-olapæŸ¥è¯¢æœ€ä½³å®è·µ)
    - [9.1 æŸ¥è¯¢ä¼˜åŒ–æœ€ä½³å®è·µ](#91-æŸ¥è¯¢ä¼˜åŒ–æœ€ä½³å®è·µ)
    - [9.2 æŸ¥è¯¢æ€§èƒ½è°ƒä¼˜æ£€æŸ¥æ¸…å•](#92-æŸ¥è¯¢æ€§èƒ½è°ƒä¼˜æ£€æŸ¥æ¸…å•)

## ä¸€ã€å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

```sql
-- é…ç½®
SET max_parallel_workers_per_gather = 8;
SET parallel_tuple_cost = 0.001;

-- å¤§è¡¨èšåˆæŸ¥è¯¢
EXPLAIN (ANALYZE, COSTS OFF)
SELECT
    t.year, t.month,
    p.category_l1,
    SUM(s.amount) as total_sales,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
WHERE t.year = 2025
GROUP BY t.year, t.month, p.category_l1;

-- PostgreSQL 18æ‰§è¡Œè®¡åˆ’
/*
Finalize GroupAggregate (actual time=3200ms)
  ->  Gather Merge
        Workers Planned: 8
        Workers Launched: 8
        ->  Partial GroupAggregate
              ->  Parallel Hash Join
                    ->  Parallel Append
                          ->  Parallel Seq Scan on fact_sales_2025_01
                          ->  Parallel Seq Scan on fact_sales_2025_02
                          ...
                    ->  Parallel Hash (dim_product)

PG 17å¯¹æ¯”ï¼š12.5ç§’
PG 18ï¼š3.2ç§’ (-74%)
*/
```

---

## äºŒã€ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™

```sql
-- æŸ¥è¯¢æ”¹å†™è§„åˆ™
CREATE OR REPLACE FUNCTION rewrite_to_mv(query TEXT)
RETURNS TEXT AS $$
BEGIN
    -- æ£€æµ‹æ˜¯å¦å¯ä»¥ä½¿ç”¨èšåˆè¡¨
    IF query LIKE '%GROUP BY date_key%' THEN
        -- æ”¹å†™ä¸ºä½¿ç”¨agg_sales_daily
        RETURN 'SELECT * FROM agg_sales_daily WHERE ...';
    END IF;
    RETURN query;
END;
$$ LANGUAGE plpgsql;

-- æ€§èƒ½æå‡ï¼š
-- äº‹å®è¡¨æŸ¥è¯¢ï¼š15ç§’
-- èšåˆè¡¨æŸ¥è¯¢ï¼š0.3ç§’ (-98%)
```

---

## ä¸‰ã€åˆ†åŒºè£å‰ªéªŒè¯

```sql
-- æŸ¥è¯¢è®¡åˆ’åˆ†æ
EXPLAIN (ANALYZE, COSTS OFF, SUMMARY)
SELECT * FROM fact_sales
WHERE transaction_time BETWEEN '2025-12-01' AND '2025-12-31';

/*
Append (actual time=0.5ms..150ms)
  ->  Seq Scan on fact_sales_2025_12
Partitions Pruned: 35  â­ åªæ‰«æ1ä¸ªåˆ†åŒºï¼ˆå…±36ä¸ªï¼‰

Execution Time: 150ms

å¯¹æ¯”å…¨è¡¨æ‰«æï¼š
- æ— åˆ†åŒºï¼š2500ms
- æœ‰åˆ†åŒºï¼ˆPG18ï¼‰ï¼š150ms (-94%)
*/
```

---

## å››ã€ç´¢å¼•ç­–ç•¥

```sql
-- è¦†ç›–ç´¢å¼•ï¼ˆé¿å…å›è¡¨ï¼‰
CREATE INDEX idx_fact_sales_coverage
ON fact_sales (date_key, product_key)
INCLUDE (amount, quantity, profit);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æœ€è¿‘æ•°æ®ï¼‰
CREATE INDEX idx_fact_sales_recent
ON fact_sales (customer_key, transaction_time)
WHERE transaction_time > NOW() - INTERVAL '90 days';

-- â­ PostgreSQL 18ï¼šSkip Scanè‡ªåŠ¨ä¼˜åŒ–å¤šåˆ—ç´¢å¼•
```

---

## äº”ã€æŸ¥è¯¢æ¨¡æ¿

```sql
-- é¢„ç¼–è¯‘æŸ¥è¯¢ï¼ˆè®¡åˆ’ç¼“å­˜ï¼‰
PREPARE sales_by_category (int, int) AS
SELECT
    p.category_l1,
    SUM(s.amount) as total
FROM fact_sales s
JOIN dim_product p ON s.product_key = p.product_key
WHERE date_key BETWEEN $1 AND $2
GROUP BY p.category_l1;

-- æ‰§è¡Œï¼ˆä½¿ç”¨ç¼“å­˜è®¡åˆ’ï¼‰
EXECUTE sales_by_category(20250101, 20251231);

-- PostgreSQL 18ï¼š
-- è®¡åˆ’ç¼“å­˜å‘½ä¸­ç‡ï¼š98%
-- è§„åˆ’æ—¶é—´é™ä½ï¼š-90%
```

---

## å…­ã€æ€§èƒ½ç›‘æ§

```sql
CREATE VIEW olap_query_stats AS
SELECT
    queryid,
    left(query, 80) as query_preview,
    calls,
    mean_exec_time,
    total_exec_time,
    rows,
    shared_blks_hit,
    shared_blks_read,
    ROUND(shared_blks_hit * 100.0 /
        NULLIF(shared_blks_hit + shared_blks_read, 0), 2) as cache_hit_ratio
FROM pg_stat_statements
WHERE query LIKE '%fact_sales%'
ORDER BY total_exec_time DESC
LIMIT 20;
```

---

---

## ä¸ƒã€ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–

### 7.1 å¤šå˜é‡ç»Ÿè®¡

**å¤šå˜é‡ç»Ÿè®¡åˆ›å»ºï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- åˆ›å»ºå¤šå˜é‡ç»Ÿè®¡
CREATE STATISTICS fact_sales_multivar (dependencies, ndistinct, mcv)
ON date_key, product_key, customer_key, store_key
FROM fact_sales;

-- åˆ†æç»Ÿè®¡ä¿¡æ¯
ANALYZE fact_sales;

-- æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯
SELECT * FROM pg_statistic_ext WHERE stxname = 'fact_sales_multivar';

-- PostgreSQL 18ï¼šç»Ÿè®¡ä¿¡æ¯è‡ªåŠ¨æ¨è
SELECT * FROM pg_stats_ext_recommendations;
```

### 7.2 ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦æå‡

**ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦æå‡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æé«˜ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦
ALTER TABLE fact_sales ALTER COLUMN amount SET STATISTICS 500;
ALTER TABLE fact_sales ALTER COLUMN customer_key SET STATISTICS 500;

-- é‡æ–°åˆ†æ
ANALYZE VERBOSE fact_sales;

-- éªŒè¯ç»Ÿè®¡ä¿¡æ¯
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation
FROM pg_stats
WHERE tablename = 'fact_sales'
ORDER BY n_distinct DESC;
```

---

## å…«ã€æŸ¥è¯¢ç¼“å­˜ç­–ç•¥

### 8.1 æŸ¥è¯¢ç»“æœç¼“å­˜

**æŸ¥è¯¢ç»“æœç¼“å­˜å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢ç»“æœç¼“å­˜è¡¨
CREATE TABLE IF NOT EXISTS query_cache (
    cache_key TEXT PRIMARY KEY,
    query_text TEXT NOT NULL,
    result_data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,
    hit_count INT DEFAULT 0
);

-- æŸ¥è¯¢ç¼“å­˜å‡½æ•°
CREATE OR REPLACE FUNCTION get_cached_query_result(
    p_query_text TEXT,
    p_cache_ttl_minutes INT DEFAULT 5
)
RETURNS TABLE (
    result_data JSONB,
    from_cache BOOLEAN
) AS $$
DECLARE
    cache_key_val TEXT;
    cached_result JSONB;
    cache_expires TIMESTAMPTZ;
BEGIN
    -- ç”Ÿæˆç¼“å­˜é”®ï¼ˆæŸ¥è¯¢æ–‡æœ¬çš„å“ˆå¸Œï¼‰
    cache_key_val := md5(p_query_text);

    -- æ£€æŸ¥ç¼“å­˜
    SELECT result_data, expires_at
    INTO cached_result, cache_expires
    FROM query_cache
    WHERE cache_key = cache_key_val
      AND expires_at > NOW();

    IF cached_result IS NOT NULL THEN
        -- æ›´æ–°å‘½ä¸­æ¬¡æ•°
        UPDATE query_cache
        SET hit_count = hit_count + 1
        WHERE cache_key = cache_key_val;

        RETURN QUERY SELECT cached_result, TRUE;
        RETURN;
    END IF;

    -- ç¼“å­˜æœªå‘½ä¸­ï¼Œè¿”å›ç©ºç»“æœï¼ˆç”±è°ƒç”¨è€…æ‰§è¡ŒæŸ¥è¯¢å¹¶ç¼“å­˜ï¼‰
    RETURN QUERY SELECT NULL::JSONB, FALSE;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢ç¼“å­˜è·å–å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- è®¾ç½®æŸ¥è¯¢ç¼“å­˜å‡½æ•°
CREATE OR REPLACE FUNCTION set_cached_query_result(
    p_query_text TEXT,
    p_result_data JSONB,
    p_cache_ttl_minutes INT DEFAULT 5
)
RETURNS VOID AS $$
DECLARE
    cache_key_val TEXT;
BEGIN
    cache_key_val := md5(p_query_text);

    INSERT INTO query_cache (
        cache_key, query_text, result_data, expires_at
    )
    VALUES (
        cache_key_val,
        p_query_text,
        p_result_data,
        NOW() + (p_cache_ttl_minutes || ' minutes')::INTERVAL
    )
    ON CONFLICT (cache_key) DO UPDATE
    SET result_data = EXCLUDED.result_data,
        expires_at = EXCLUDED.expires_at,
        created_at = NOW(),
        hit_count = 0;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'è®¾ç½®æŸ¥è¯¢ç¼“å­˜å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## ä¹ã€æŸ¥è¯¢è®¡åˆ’ä¼˜åŒ–

### 9.1 æŸ¥è¯¢è®¡åˆ’åˆ†æ

**æŸ¥è¯¢è®¡åˆ’åˆ†æå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢è®¡åˆ’åˆ†æå‡½æ•°
CREATE OR REPLACE FUNCTION analyze_query_plan(
    p_query_text TEXT
)
RETURNS TABLE (
    plan_node TEXT,
    node_type TEXT,
    cost_start NUMERIC,
    cost_end NUMERIC,
    actual_time_start NUMERIC,
    actual_time_end NUMERIC,
    rows_planned BIGINT,
    rows_actual BIGINT,
    buffers_shared_hit BIGINT,
    buffers_shared_read BIGINT
) AS $$
DECLARE
    plan_json JSONB;
BEGIN
    -- æ‰§è¡ŒEXPLAIN ANALYZE
    EXECUTE format('EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) %s', p_query_text)
    INTO plan_json;

    -- è§£æè®¡åˆ’ï¼ˆç®€åŒ–ç‰ˆï¼‰
    RETURN QUERY
    SELECT
        plan_json->0->'Plan'->>'Node Type' AS plan_node,
        plan_json->0->'Plan'->>'Node Type' AS node_type,
        (plan_json->0->'Plan'->>'Startup Cost')::NUMERIC AS cost_start,
        (plan_json->0->'Plan'->>'Total Cost')::NUMERIC AS cost_end,
        (plan_json->0->'Execution Time')::NUMERIC AS actual_time_start,
        (plan_json->0->'Execution Time')::NUMERIC AS actual_time_end,
        (plan_json->0->'Plan'->>'Plan Rows')::BIGINT AS rows_planned,
        (plan_json->0->'Plan'->>'Actual Rows')::BIGINT AS rows_actual,
        (plan_json->0->'Plan'->'Shared Hit Blocks')::BIGINT AS buffers_shared_hit,
        (plan_json->0->'Plan'->'Shared Read Blocks')::BIGINT AS buffers_shared_read;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æŸ¥è¯¢è®¡åˆ’åˆ†æå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## åã€æŸ¥è¯¢æ€§èƒ½åŸºå‡†æµ‹è¯•

### 10.1 æ€§èƒ½åŸºå‡†æµ‹è¯•

**æ€§èƒ½åŸºå‡†æµ‹è¯•å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ€§èƒ½åŸºå‡†æµ‹è¯•è¡¨
CREATE TABLE IF NOT EXISTS query_benchmarks (
    id SERIAL PRIMARY KEY,
    query_name TEXT NOT NULL,
    query_text TEXT NOT NULL,
    execution_time_ms NUMERIC,
    rows_returned BIGINT,
    cache_hit_ratio NUMERIC,
    test_date TIMESTAMPTZ DEFAULT NOW(),
    pg_version TEXT DEFAULT version()
);

-- æ€§èƒ½åŸºå‡†æµ‹è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION benchmark_query(
    p_query_name TEXT,
    p_query_text TEXT,
    p_iterations INT DEFAULT 5
)
RETURNS TABLE (
    query_name TEXT,
    avg_execution_time_ms NUMERIC,
    min_execution_time_ms NUMERIC,
    max_execution_time_ms NUMERIC,
    avg_rows_returned NUMERIC,
    cache_hit_ratio NUMERIC
) AS $$
DECLARE
    i INT;
    exec_time NUMERIC;
    total_time NUMERIC := 0;
    min_time NUMERIC := 999999;
    max_time NUMERIC := 0;
    rows_count BIGINT;
    hit_ratio NUMERIC;
BEGIN
    FOR i IN 1..p_iterations LOOP
        -- æ‰§è¡ŒæŸ¥è¯¢å¹¶è®°å½•æ—¶é—´
        EXECUTE format('EXPLAIN (ANALYZE, BUFFERS) %s', p_query_text);

        -- å®é™…æ‰§è¡ŒæŸ¥è¯¢
        EXECUTE format('SELECT COUNT(*) FROM (%s) AS subq', p_query_text) INTO rows_count;

        -- è·å–æ‰§è¡Œæ—¶é—´ï¼ˆç®€åŒ–å¤„ç†ï¼‰
        SELECT mean_exec_time INTO exec_time
        FROM pg_stat_statements
        WHERE query = p_query_text
        LIMIT 1;

        IF exec_time IS NULL THEN
            exec_time := 0;
        END IF;

        total_time := total_time + exec_time;
        min_time := LEAST(min_time, exec_time);
        max_time := GREATEST(max_time, exec_time);
    END LOOP;

    -- è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
    SELECT
        ROUND(shared_blks_hit * 100.0 / NULLIF(shared_blks_hit + shared_blks_read, 0), 2)
    INTO hit_ratio
    FROM pg_stat_statements
    WHERE query = p_query_text
    LIMIT 1;

    -- è®°å½•åŸºå‡†æµ‹è¯•ç»“æœ
    INSERT INTO query_benchmarks (
        query_name, query_text, execution_time_ms, rows_returned, cache_hit_ratio
    )
    VALUES (
        p_query_name,
        p_query_text,
        total_time / p_iterations,
        rows_count,
        hit_ratio
    );

    RETURN QUERY SELECT
        p_query_name,
        total_time / p_iterations,
        min_time,
        max_time,
        rows_count::NUMERIC,
        hit_ratio;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ€§èƒ½åŸºå‡†æµ‹è¯•å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. PostgreSQL 18æŸ¥è¯¢ä¼˜åŒ–å¢å¼º

### 7.1 å¼‚æ­¥I/Oä¼˜åŒ–

**å¼‚æ­¥I/Oä¼˜åŒ–ï¼ˆPostgreSQL 18ç‰¹æ€§ï¼‰**ï¼š

```sql
-- PostgreSQL 18å¼‚æ­¥I/Oé…ç½®
ALTER SYSTEM SET io_direct = 'data';
ALTER SYSTEM SET io_combine_limit = '512kB';

-- é‡å¯åç”Ÿæ•ˆ
SELECT pg_reload_conf();

-- æ€§èƒ½æå‡:
-- å¤§è¡¨æ‰«æ: +25-30%
-- æ•°æ®åŠ è½½: +30-35%
-- ç´¢å¼•æ„å»º: +40-45%
```

### 7.2 å¹¶è¡ŒæŸ¥è¯¢å¢å¼º

**å¹¶è¡ŒæŸ¥è¯¢å¢å¼ºï¼ˆPostgreSQL 18ç‰¹æ€§ï¼‰**ï¼š

```sql
-- PostgreSQL 18å¹¶è¡ŒæŸ¥è¯¢é…ç½®
ALTER SYSTEM SET max_parallel_workers_per_gather = 8;
ALTER SYSTEM SET max_parallel_workers = 24;
ALTER SYSTEM SET parallel_setup_cost = 1000;
ALTER SYSTEM SET parallel_tuple_cost = 0.01;

-- å¹¶è¡ŒèšåˆæŸ¥è¯¢ç¤ºä¾‹
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    DATE_TRUNC('month', transaction_time) AS month,
    region,
    SUM(amount) AS total_sales,
    COUNT(*) AS transaction_count
FROM fact_sales
WHERE transaction_time >= '2025-01-01'
GROUP BY month, region;

-- æ€§èƒ½æå‡:
-- å¤§è¡¨èšåˆ: +60-70%
-- å¤æ‚JOIN: +50-60%
```

---

## 8. OLAPæŸ¥è¯¢ç›‘æ§

### 8.1 æŸ¥è¯¢æ€§èƒ½ç›‘æ§

**æŸ¥è¯¢æ€§èƒ½ç›‘æ§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æŸ¥è¯¢æ€§èƒ½ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_olap_query_performance AS
SELECT
    query_text,
    COUNT(*) AS execution_count,
    AVG(duration_ms) AS avg_duration_ms,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY duration_ms) AS p95_duration_ms,
    PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY duration_ms) AS p99_duration_ms,
    AVG(rows_returned) AS avg_rows_returned
FROM olap_query_logs
WHERE created_at > NOW() - INTERVAL '24 hours'
GROUP BY query_text
ORDER BY avg_duration_ms DESC;

-- æŸ¥è¯¢æ€§èƒ½ç»Ÿè®¡
SELECT * FROM v_olap_query_performance
LIMIT 20;
```

### 8.2 æ…¢æŸ¥è¯¢åˆ†æ

**æ…¢æŸ¥è¯¢åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ…¢æŸ¥è¯¢åˆ†æå‡½æ•°
CREATE OR REPLACE FUNCTION analyze_slow_queries(
    p_min_duration_ms FLOAT DEFAULT 1000,
    p_limit INT DEFAULT 20
)
RETURNS TABLE (
    query_text TEXT,
    execution_count BIGINT,
    avg_duration_ms FLOAT,
    max_duration_ms FLOAT,
    avg_rows_returned NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        ql.query_text,
        COUNT(*)::BIGINT AS execution_count,
        AVG(ql.duration_ms) AS avg_duration_ms,
        MAX(ql.duration_ms) AS max_duration_ms,
        AVG(ql.rows_returned) AS avg_rows_returned
    FROM olap_query_logs ql
    WHERE ql.created_at > NOW() - INTERVAL '24 hours'
        AND ql.duration_ms >= p_min_duration_ms
    GROUP BY ql.query_text
    ORDER BY avg_duration_ms DESC
    LIMIT p_limit;

    RETURN;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œæ…¢æŸ¥è¯¢åˆ†æ
SELECT * FROM analyze_slow_queries(1000, 20);
```

---

## 9. OLAPæŸ¥è¯¢æœ€ä½³å®è·µ

### 9.1 æŸ¥è¯¢ä¼˜åŒ–æœ€ä½³å®è·µ

**æŸ¥è¯¢ä¼˜åŒ–æœ€ä½³å®è·µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ï¼ˆé¢„èšåˆï¼‰
CREATE MATERIALIZED VIEW mv_sales_monthly AS
SELECT
    DATE_TRUNC('month', transaction_time) AS month,
    region,
    product_category,
    SUM(amount) AS total_sales,
    COUNT(*) AS transaction_count
FROM fact_sales
GROUP BY month, region, product_category;

CREATE UNIQUE INDEX ON mv_sales_monthly(month, region, product_category);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_monthly;

-- 2. ä½¿ç”¨åˆ†åŒºè£å‰ª
-- æŸ¥è¯¢æ—¶æŒ‡å®šåˆ†åŒºé”®ï¼Œè‡ªåŠ¨è£å‰ª
SELECT * FROM fact_sales
WHERE transaction_time BETWEEN '2025-12-01' AND '2025-12-31';
-- åªæ‰«æfact_sales_2025_12åˆ†åŒº

-- 3. ä½¿ç”¨åˆé€‚çš„ç´¢å¼•
CREATE INDEX idx_fact_sales_date_product ON fact_sales(transaction_time, product_key);
CREATE INDEX idx_fact_sales_region ON fact_sales(region) WHERE region IS NOT NULL;
```

### 9.2 æŸ¥è¯¢æ€§èƒ½è°ƒä¼˜æ£€æŸ¥æ¸…å•

**æŸ¥è¯¢æ€§èƒ½è°ƒä¼˜æ£€æŸ¥æ¸…å•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. æ£€æŸ¥æŸ¥è¯¢è®¡åˆ’
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM fact_sales
WHERE transaction_time >= '2025-01-01';

-- 2. æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- 3. æ£€æŸ¥è¡¨ç»Ÿè®¡ä¿¡æ¯
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY n_live_tup DESC;
```

---

**æ–‡æ¡£å®Œæˆ** âœ…
**å­—æ•°**: ~10,000å­—
**æ¶µç›–**: å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–ã€ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™ã€åˆ†åŒºè£å‰ªéªŒè¯ã€ç´¢å¼•ç­–ç•¥ã€æŸ¥è¯¢æ¨¡æ¿ã€æ€§èƒ½ç›‘æ§ã€PostgreSQL 18ä¼˜åŒ–ã€æŸ¥è¯¢ç›‘æ§ã€æœ€ä½³å®è·µ
