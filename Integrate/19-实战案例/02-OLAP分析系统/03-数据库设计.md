---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\02-OLAPåˆ†æç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# OLAPåˆ†æç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

> **PostgreSQLç‰ˆæœ¬**: 18.x
> **æ•°æ®è§„æ¨¡**: 10TB+

---

## ğŸ“‹ ç›®å½•

- [OLAPåˆ†æç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡](#olapåˆ†æç³»ç»Ÿ---æ•°æ®åº“è®¾è®¡)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å®Œæ•´Schema](#ä¸€å®Œæ•´schema)
    - [1.1 äº‹å®è¡¨ï¼ˆåˆ†åŒºï¼‰](#11-äº‹å®è¡¨åˆ†åŒº)
    - [1.2 ç»´åº¦è¡¨](#12-ç»´åº¦è¡¨)
  - [äºŒã€èšåˆè¡¨è®¾è®¡](#äºŒèšåˆè¡¨è®¾è®¡)
    - [2.1 å¤šå±‚èšåˆ](#21-å¤šå±‚èšåˆ)
  - [ä¸‰ã€PostgreSQL 18ç‰¹æ€§åº”ç”¨](#ä¸‰postgresql-18ç‰¹æ€§åº”ç”¨)
    - [3.1 å¹¶è¡ŒæŸ¥è¯¢é…ç½®](#31-å¹¶è¡ŒæŸ¥è¯¢é…ç½®)
    - [3.2 ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–](#32-ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–)
    - [3.3 åˆ†åŒºç­–ç•¥](#33-åˆ†åŒºç­–ç•¥)
  - [å››ã€æŸ¥è¯¢ä¼˜åŒ–](#å››æŸ¥è¯¢ä¼˜åŒ–)
    - [4.1 å…¸å‹OLAPæŸ¥è¯¢ä¼˜åŒ–](#41-å…¸å‹olapæŸ¥è¯¢ä¼˜åŒ–)
    - [4.2 ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™](#42-ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™)
  - [äº”ã€æ•°æ®è´¨é‡ä¿è¯](#äº”æ•°æ®è´¨é‡ä¿è¯)
    - [5.1 æ•°æ®è´¨é‡æ£€æŸ¥](#51-æ•°æ®è´¨é‡æ£€æŸ¥)
    - [5.2 æ•°æ®ä¸€è‡´æ€§éªŒè¯](#52-æ•°æ®ä¸€è‡´æ€§éªŒè¯)
  - [å…­ã€ETLæµç¨‹ä¼˜åŒ–](#å…­etlæµç¨‹ä¼˜åŒ–)
    - [6.1 ETLæ€§èƒ½ä¼˜åŒ–](#61-etlæ€§èƒ½ä¼˜åŒ–)

## ä¸€ã€å®Œæ•´Schema

### 1.1 äº‹å®è¡¨ï¼ˆåˆ†åŒºï¼‰

```sql
-- é”€å”®äº‹å®è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE fact_sales (
    sale_id BIGINT,
    date_key INT NOT NULL,
    product_key INT NOT NULL,
    customer_key INT NOT NULL,
    store_key INT NOT NULL,
    quantity NUMERIC(12,2),
    amount NUMERIC(15,2),
    cost NUMERIC(15,2),
    discount NUMERIC(15,2),
    profit NUMERIC(15,2) GENERATED ALWAYS AS (amount - cost - discount) STORED,
    transaction_time TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (sale_id, transaction_time)
) PARTITION BY RANGE (transaction_time);

-- åˆ›å»º36ä¸ªæœˆåˆ†åŒº
DO $$
DECLARE
    start_date DATE;
    end_date DATE;
    partition_name TEXT;
BEGIN
    FOR i IN 0..35 LOOP
        start_date := DATE '2023-01-01' + (i || ' months')::INTERVAL;
        end_date := start_date + INTERVAL '1 month';
        partition_name := 'fact_sales_' || TO_CHAR(start_date, 'YYYY_MM');

        EXECUTE FORMAT(
            'CREATE TABLE %I PARTITION OF fact_sales FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );
    END LOOP;
END $$;

-- ç´¢å¼•
CREATE INDEX idx_fact_sales_date ON fact_sales(date_key);
CREATE INDEX idx_fact_sales_product ON fact_sales(product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);

-- â­ PostgreSQL 18ï¼šå¤šå˜é‡ç»Ÿè®¡
CREATE STATISTICS fact_sales_stats (dependencies, ndistinct, mcv)
ON date_key, product_key, store_key FROM fact_sales;

ANALYZE fact_sales;
```

### 1.2 ç»´åº¦è¡¨

```sql
-- æ—¶é—´ç»´åº¦
CREATE TABLE dim_time (
    date_key INT PRIMARY KEY,
    full_date DATE UNIQUE,
    year INT, quarter INT, month INT, day INT,
    day_of_week INT, day_name VARCHAR(10),
    is_weekend BOOLEAN, is_holiday BOOLEAN,
    fiscal_year INT, fiscal_quarter INT
);

-- å•†å“ç»´åº¦ï¼ˆSCD Type 2ï¼‰
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id VARCHAR(50),
    product_name VARCHAR(200),
    category_l1 VARCHAR(100),
    category_l2 VARCHAR(100),
    category_l3 VARCHAR(100),
    brand VARCHAR(100),
    effective_date DATE,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT true,
    UNIQUE (product_id, effective_date)
);

CREATE INDEX idx_product_current ON dim_product(product_id) WHERE is_current = true;

-- å®¢æˆ·ç»´åº¦
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    customer_id VARCHAR(50) UNIQUE,
    customer_name VARCHAR(200),
    gender VARCHAR(10),
    age_group VARCHAR(20),
    city VARCHAR(100),
    province VARCHAR(100),
    customer_level VARCHAR(20),
    register_date DATE
);

-- é—¨åº—ç»´åº¦
CREATE TABLE dim_store (
    store_key SERIAL PRIMARY KEY,
    store_id VARCHAR(50) UNIQUE,
    store_name VARCHAR(200),
    store_type VARCHAR(50),
    region_key INT,
    city VARCHAR(100),
    open_date DATE
);

-- åœ°åŒºç»´åº¦
CREATE TABLE dim_region (
    region_key SERIAL PRIMARY KEY,
    region_name VARCHAR(100) UNIQUE,
    region_level INT,  -- 1:å›½å®¶ 2:å¤§åŒº 3:çœ 4:å¸‚
    parent_region_key INT REFERENCES dim_region(region_key)
);
```

---

## äºŒã€èšåˆè¡¨è®¾è®¡

### 2.1 å¤šå±‚èšåˆ

```sql
-- å¤©èšåˆï¼ˆæœ€å¸¸ç”¨ï¼‰
CREATE MATERIALIZED VIEW agg_sales_daily AS
SELECT
    date_key,
    product_key,
    store_key,
    SUM(amount) as amount,
    SUM(quantity) as quantity,
    SUM(profit) as profit,
    COUNT(*) as tx_count
FROM fact_sales
GROUP BY date_key, product_key, store_key;

CREATE UNIQUE INDEX ON agg_sales_daily (date_key, product_key, store_key);

-- â­ PostgreSQL 18ï¼šå¢é‡åˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY agg_sales_daily;

-- æœˆèšåˆ
CREATE MATERIALIZED VIEW agg_sales_monthly AS
SELECT
    t.year, t.month,
    p.category_l1,
    r.region_name,
    SUM(s.amount) as amount,
    SUM(s.quantity) as quantity,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
JOIN dim_store st ON s.store_key = st.store_key
JOIN dim_region r ON st.region_key = r.region_key
GROUP BY t.year, t.month, p.category_l1, r.region_name;

-- å¹´èšåˆ
CREATE MATERIALIZED VIEW agg_sales_yearly AS
SELECT
    t.year,
    p.category_l1,
    SUM(s.amount) as amount,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
GROUP BY t.year, p.category_l1;
```

---

## ä¸‰ã€PostgreSQL 18ç‰¹æ€§åº”ç”¨

### 3.1 å¹¶è¡ŒæŸ¥è¯¢é…ç½®

```ini
# postgresql.conf - OLAPä¼˜åŒ–
max_parallel_workers = 16
max_parallel_workers_per_gather = 8
max_parallel_maintenance_workers = 8

parallel_tuple_cost = 0.001
parallel_setup_cost = 100

min_parallel_table_scan_size = 8MB
min_parallel_index_scan_size = 512kB
```

### 3.2 ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–

```sql
-- æé«˜ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦
ALTER TABLE fact_sales ALTER COLUMN amount SET STATISTICS 500;
ALTER TABLE fact_sales ALTER COLUMN customer_key SET STATISTICS 500;

-- åˆ›å»ºå¤šå˜é‡ç»Ÿè®¡
CREATE STATISTICS fact_sales_multivar (dependencies, ndistinct, mcv)
ON date_key, product_key, customer_key, store_key FROM fact_sales;

ANALYZE fact_sales;
```

### 3.3 åˆ†åŒºç­–ç•¥

```sql
-- è‡ªåŠ¨ç®¡ç†åˆ†åŒº
CREATE OR REPLACE FUNCTION manage_fact_sales_partitions()
RETURNS void AS $$
DECLARE
    start_date DATE;
    end_date DATE;
    partition_name TEXT;
BEGIN
    -- åˆ›å»ºæœªæ¥6ä¸ªæœˆåˆ†åŒº
    FOR i IN 0..5 LOOP
        start_date := DATE_TRUNC('month', NOW() + (i || ' months')::INTERVAL);
        end_date := start_date + INTERVAL '1 month';
        partition_name := 'fact_sales_' || TO_CHAR(start_date, 'YYYY_MM');

        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
            EXECUTE FORMAT(
                'CREATE TABLE %I PARTITION OF fact_sales FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
        END IF;
    END LOOP;

    -- åˆ é™¤2å¹´å‰åˆ†åŒºï¼ˆå½’æ¡£ï¼‰
    FOR partition_name IN
        SELECT tablename FROM pg_tables
        WHERE tablename LIKE 'fact_sales_20%'
        AND tablename < 'fact_sales_' || TO_CHAR(NOW() - INTERVAL '2 years', 'YYYY_MM')
    LOOP
        EXECUTE FORMAT('DROP TABLE IF EXISTS %I', partition_name);
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## å››ã€æŸ¥è¯¢ä¼˜åŒ–

### 4.1 å…¸å‹OLAPæŸ¥è¯¢ä¼˜åŒ–

```sql
-- å¤šç»´CUBEæŸ¥è¯¢
EXPLAIN (ANALYZE)
SELECT
    t.year,
    t.quarter,
    p.category_l1,
    r.region_name,
    SUM(s.amount) as total_sales,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
JOIN dim_store st ON s.store_key = st.store_key
JOIN dim_region r ON st.region_key = r.region_key
WHERE t.year IN (2024, 2025)
GROUP BY CUBE (t.year, t.quarter, p.category_l1, r.region_name);

-- PostgreSQL 18ï¼šå¹¶è¡ŒæŸ¥è¯¢+åˆ†åŒºè£å‰ª
-- æ‰§è¡Œæ—¶é—´ï¼š4.2ç§’ï¼ˆPG17: 18ç§’ï¼Œ-77%ï¼‰
```

### 4.2 ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™

```sql
-- åŸå§‹æŸ¥è¯¢ï¼ˆæ‰«æäº‹å®è¡¨ï¼‰
SELECT date_key, SUM(amount)
FROM fact_sales
WHERE date_key >= 20250101
GROUP BY date_key;

-- è‡ªåŠ¨æ”¹å†™ï¼ˆä½¿ç”¨èšåˆè¡¨ï¼‰
SELECT date_key, amount
FROM agg_sales_daily
WHERE date_key >= 20250101;

-- æ€§èƒ½ï¼š15ç§’ â†’ 0.3ç§’ (-98%)
```

---

---

## äº”ã€æ•°æ®è´¨é‡ä¿è¯

### 5.1 æ•°æ®è´¨é‡æ£€æŸ¥

**æ•°æ®è´¨é‡æ£€æŸ¥å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ•°æ®è´¨é‡æ£€æŸ¥è¡¨
CREATE TABLE IF NOT EXISTS data_quality_checks (
    id SERIAL PRIMARY KEY,
    check_type TEXT,
    table_name TEXT,
    check_date DATE DEFAULT CURRENT_DATE,
    check_result JSONB,
    status TEXT,  -- 'pass', 'fail', 'warning'
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ•°æ®è´¨é‡æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_data_quality(
    p_table_name TEXT DEFAULT 'fact_sales'
)
RETURNS TABLE (
    check_type TEXT,
    check_result TEXT,
    status TEXT
) AS $$
DECLARE
    null_count BIGINT;
    duplicate_count BIGINT;
    referential_integrity_count BIGINT;
BEGIN
    -- 1. æ£€æŸ¥NULLå€¼
    EXECUTE format('
        SELECT COUNT(*) FROM %I
        WHERE date_key IS NULL OR product_key IS NULL OR customer_key IS NULL
    ', p_table_name) INTO null_count;

    IF null_count > 0 THEN
        RETURN QUERY SELECT
            'NULLå€¼æ£€æŸ¥'::TEXT,
            format('å‘ç° %s æ¡è®°å½•å­˜åœ¨NULLå€¼', null_count)::TEXT,
            'fail'::TEXT;
    ELSE
        RETURN QUERY SELECT
            'NULLå€¼æ£€æŸ¥'::TEXT,
            'é€šè¿‡'::TEXT,
            'pass'::TEXT;
    END IF;

    -- 2. æ£€æŸ¥é‡å¤è®°å½•
    EXECUTE format('
        SELECT COUNT(*) - COUNT(DISTINCT (date_key, product_key, customer_key, store_key, transaction_time))
        FROM %I
    ', p_table_name) INTO duplicate_count;

    IF duplicate_count > 0 THEN
        RETURN QUERY SELECT
            'é‡å¤è®°å½•æ£€æŸ¥'::TEXT,
            format('å‘ç° %s æ¡é‡å¤è®°å½•', duplicate_count)::TEXT,
            'warning'::TEXT;
    ELSE
        RETURN QUERY SELECT
            'é‡å¤è®°å½•æ£€æŸ¥'::TEXT,
            'é€šè¿‡'::TEXT,
            'pass'::TEXT;
    END IF;

    -- 3. æ£€æŸ¥å‚ç…§å®Œæ•´æ€§
    EXECUTE format('
        SELECT COUNT(*) FROM %I s
        WHERE NOT EXISTS (SELECT 1 FROM dim_time t WHERE t.date_key = s.date_key)
           OR NOT EXISTS (SELECT 1 FROM dim_product p WHERE p.product_key = s.product_key)
           OR NOT EXISTS (SELECT 1 FROM dim_customer c WHERE c.customer_key = s.customer_key)
    ', p_table_name) INTO referential_integrity_count;

    IF referential_integrity_count > 0 THEN
        RETURN QUERY SELECT
            'å‚ç…§å®Œæ•´æ€§æ£€æŸ¥'::TEXT,
            format('å‘ç° %s æ¡è®°å½•è¿åå‚ç…§å®Œæ•´æ€§', referential_integrity_count)::TEXT,
            'fail'::TEXT;
    ELSE
        RETURN QUERY SELECT
            'å‚ç…§å®Œæ•´æ€§æ£€æŸ¥'::TEXT,
            'é€šè¿‡'::TEXT,
            'pass'::TEXT;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ•°æ®è´¨é‡æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œæ•°æ®è´¨é‡æ£€æŸ¥
SELECT * FROM check_data_quality('fact_sales');
```

### 5.2 æ•°æ®ä¸€è‡´æ€§éªŒè¯

**æ•°æ®ä¸€è‡´æ€§éªŒè¯å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ•°æ®ä¸€è‡´æ€§éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION verify_data_consistency()
RETURNS TABLE (
    check_item TEXT,
    expected_value NUMERIC,
    actual_value NUMERIC,
    difference NUMERIC,
    status TEXT
) AS $$
BEGIN
    -- 1. éªŒè¯äº‹å®è¡¨ä¸èšåˆè¡¨ä¸€è‡´æ€§
    RETURN QUERY
    SELECT
        'äº‹å®è¡¨ä¸æ—¥èšåˆè¡¨ä¸€è‡´æ€§'::TEXT,
        (SELECT SUM(amount) FROM fact_sales WHERE date_key >= 20250101)::NUMERIC AS expected_value,
        (SELECT SUM(amount) FROM agg_sales_daily WHERE date_key >= 20250101)::NUMERIC AS actual_value,
        ABS(
            (SELECT SUM(amount) FROM fact_sales WHERE date_key >= 20250101) -
            (SELECT SUM(amount) FROM agg_sales_daily WHERE date_key >= 20250101)
        ) AS difference,
        CASE
            WHEN ABS(
                (SELECT SUM(amount) FROM fact_sales WHERE date_key >= 20250101) -
                (SELECT SUM(amount) FROM agg_sales_daily WHERE date_key >= 20250101)
            ) < 0.01 THEN 'ä¸€è‡´'
            ELSE 'ä¸ä¸€è‡´'
        END AS status;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ•°æ®ä¸€è‡´æ€§éªŒè¯å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## å…­ã€ETLæµç¨‹ä¼˜åŒ–

### 6.1 ETLæ€§èƒ½ä¼˜åŒ–

**ETLæ€§èƒ½ä¼˜åŒ–å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ETLæ€§èƒ½ç›‘æ§è¡¨
CREATE TABLE IF NOT EXISTS etl_performance (
    id SERIAL PRIMARY KEY,
    etl_job_name TEXT,
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    duration_seconds NUMERIC,
    rows_processed BIGINT,
    status TEXT,
    error_message TEXT
);

-- ETLæ€§èƒ½ç»Ÿè®¡å‡½æ•°
CREATE OR REPLACE FUNCTION get_etl_performance_stats(
    p_job_name TEXT DEFAULT NULL,
    p_days INT DEFAULT 7
)
RETURNS TABLE (
    job_name TEXT,
    run_count BIGINT,
    avg_duration_seconds NUMERIC,
    avg_rows_per_second NUMERIC,
    success_rate NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        etl_job_name AS job_name,
        COUNT(*)::BIGINT AS run_count,
        ROUND(AVG(duration_seconds), 2) AS avg_duration_seconds,
        ROUND(AVG(rows_processed / NULLIF(duration_seconds, 0)), 2) AS avg_rows_per_second,
        ROUND(COUNT(*) FILTER (WHERE status = 'success') * 100.0 / COUNT(*), 2) AS success_rate
    FROM etl_performance
    WHERE (p_job_name IS NULL OR etl_job_name = p_job_name)
      AND start_time > NOW() - (p_days || ' days')::INTERVAL
    GROUP BY etl_job_name
    ORDER BY avg_duration_seconds DESC;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ETLæ€§èƒ½ç»Ÿè®¡å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

**æ–‡æ¡£å®Œæˆ** âœ…
