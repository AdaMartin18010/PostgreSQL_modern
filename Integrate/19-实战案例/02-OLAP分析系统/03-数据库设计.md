---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\19-åœºæ™¯æ¡ˆä¾‹åº“\02-OLAPåˆ†æç³»ç»Ÿ\03-æ•°æ®åº“è®¾è®¡.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# OLAPåˆ†æç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

> **PostgreSQLç‰ˆæœ¬**: 18.x
> **æ•°æ®è§„æ¨¡**: 10TB+

---

## ä¸€ã€å®Œæ•´Schema

### 1.1 äº‹å®è¡¨ï¼ˆåˆ†åŒºï¼‰

```sql
-- é”€å”®äº‹å®è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE fact_sales (
    sale_id BIGINT,
    date_key INT NOT NULL,
    product_key INT NOT NULL,
    customer_key INT NOT NULL,
    store_key INT NOT NULL,
    quantity NUMERIC(12,2),
    amount NUMERIC(15,2),
    cost NUMERIC(15,2),
    discount NUMERIC(15,2),
    profit NUMERIC(15,2) GENERATED ALWAYS AS (amount - cost - discount) STORED,
    transaction_time TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (sale_id, transaction_time)
) PARTITION BY RANGE (transaction_time);

-- åˆ›å»º36ä¸ªæœˆåˆ†åŒº
DO $$
DECLARE
    start_date DATE;
    end_date DATE;
    partition_name TEXT;
BEGIN
    FOR i IN 0..35 LOOP
        start_date := DATE '2023-01-01' + (i || ' months')::INTERVAL;
        end_date := start_date + INTERVAL '1 month';
        partition_name := 'fact_sales_' || TO_CHAR(start_date, 'YYYY_MM');

        EXECUTE FORMAT(
            'CREATE TABLE %I PARTITION OF fact_sales FOR VALUES FROM (%L) TO (%L)',
            partition_name, start_date, end_date
        );
    END LOOP;
END $$;

-- ç´¢å¼•
CREATE INDEX idx_fact_sales_date ON fact_sales(date_key);
CREATE INDEX idx_fact_sales_product ON fact_sales(product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);

-- â­ PostgreSQL 18ï¼šå¤šå˜é‡ç»Ÿè®¡
CREATE STATISTICS fact_sales_stats (dependencies, ndistinct, mcv)
ON date_key, product_key, store_key FROM fact_sales;

ANALYZE fact_sales;
```

### 1.2 ç»´åº¦è¡¨

```sql
-- æ—¶é—´ç»´åº¦
CREATE TABLE dim_time (
    date_key INT PRIMARY KEY,
    full_date DATE UNIQUE,
    year INT, quarter INT, month INT, day INT,
    day_of_week INT, day_name VARCHAR(10),
    is_weekend BOOLEAN, is_holiday BOOLEAN,
    fiscal_year INT, fiscal_quarter INT
);

-- å•†å“ç»´åº¦ï¼ˆSCD Type 2ï¼‰
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id VARCHAR(50),
    product_name VARCHAR(200),
    category_l1 VARCHAR(100),
    category_l2 VARCHAR(100),
    category_l3 VARCHAR(100),
    brand VARCHAR(100),
    effective_date DATE,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT true,
    UNIQUE (product_id, effective_date)
);

CREATE INDEX idx_product_current ON dim_product(product_id) WHERE is_current = true;

-- å®¢æˆ·ç»´åº¦
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    customer_id VARCHAR(50) UNIQUE,
    customer_name VARCHAR(200),
    gender VARCHAR(10),
    age_group VARCHAR(20),
    city VARCHAR(100),
    province VARCHAR(100),
    customer_level VARCHAR(20),
    register_date DATE
);

-- é—¨åº—ç»´åº¦
CREATE TABLE dim_store (
    store_key SERIAL PRIMARY KEY,
    store_id VARCHAR(50) UNIQUE,
    store_name VARCHAR(200),
    store_type VARCHAR(50),
    region_key INT,
    city VARCHAR(100),
    open_date DATE
);

-- åœ°åŒºç»´åº¦
CREATE TABLE dim_region (
    region_key SERIAL PRIMARY KEY,
    region_name VARCHAR(100) UNIQUE,
    region_level INT,  -- 1:å›½å®¶ 2:å¤§åŒº 3:çœ 4:å¸‚
    parent_region_key INT REFERENCES dim_region(region_key)
);
```

---

## äºŒã€èšåˆè¡¨è®¾è®¡

### 2.1 å¤šå±‚èšåˆ

```sql
-- å¤©èšåˆï¼ˆæœ€å¸¸ç”¨ï¼‰
CREATE MATERIALIZED VIEW agg_sales_daily AS
SELECT
    date_key,
    product_key,
    store_key,
    SUM(amount) as amount,
    SUM(quantity) as quantity,
    SUM(profit) as profit,
    COUNT(*) as tx_count
FROM fact_sales
GROUP BY date_key, product_key, store_key;

CREATE UNIQUE INDEX ON agg_sales_daily (date_key, product_key, store_key);

-- â­ PostgreSQL 18ï¼šå¢é‡åˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY agg_sales_daily;

-- æœˆèšåˆ
CREATE MATERIALIZED VIEW agg_sales_monthly AS
SELECT
    t.year, t.month,
    p.category_l1,
    r.region_name,
    SUM(s.amount) as amount,
    SUM(s.quantity) as quantity,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
JOIN dim_store st ON s.store_key = st.store_key
JOIN dim_region r ON st.region_key = r.region_key
GROUP BY t.year, t.month, p.category_l1, r.region_name;

-- å¹´èšåˆ
CREATE MATERIALIZED VIEW agg_sales_yearly AS
SELECT
    t.year,
    p.category_l1,
    SUM(s.amount) as amount,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
GROUP BY t.year, p.category_l1;
```

---

## ä¸‰ã€PostgreSQL 18ç‰¹æ€§åº”ç”¨

### 3.1 å¹¶è¡ŒæŸ¥è¯¢é…ç½®

```ini
# postgresql.conf - OLAPä¼˜åŒ–
max_parallel_workers = 16
max_parallel_workers_per_gather = 8
max_parallel_maintenance_workers = 8

parallel_tuple_cost = 0.001
parallel_setup_cost = 100

min_parallel_table_scan_size = 8MB
min_parallel_index_scan_size = 512kB
```

### 3.2 ç»Ÿè®¡ä¿¡æ¯ä¼˜åŒ–

```sql
-- æé«˜ç»Ÿè®¡ä¿¡æ¯ç²¾åº¦
ALTER TABLE fact_sales ALTER COLUMN amount SET STATISTICS 500;
ALTER TABLE fact_sales ALTER COLUMN customer_key SET STATISTICS 500;

-- åˆ›å»ºå¤šå˜é‡ç»Ÿè®¡
CREATE STATISTICS fact_sales_multivar (dependencies, ndistinct, mcv)
ON date_key, product_key, customer_key, store_key FROM fact_sales;

ANALYZE fact_sales;
```

### 3.3 åˆ†åŒºç­–ç•¥

```sql
-- è‡ªåŠ¨ç®¡ç†åˆ†åŒº
CREATE OR REPLACE FUNCTION manage_fact_sales_partitions()
RETURNS void AS $$
DECLARE
    start_date DATE;
    end_date DATE;
    partition_name TEXT;
BEGIN
    -- åˆ›å»ºæœªæ¥6ä¸ªæœˆåˆ†åŒº
    FOR i IN 0..5 LOOP
        start_date := DATE_TRUNC('month', NOW() + (i || ' months')::INTERVAL);
        end_date := start_date + INTERVAL '1 month';
        partition_name := 'fact_sales_' || TO_CHAR(start_date, 'YYYY_MM');

        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
            EXECUTE FORMAT(
                'CREATE TABLE %I PARTITION OF fact_sales FOR VALUES FROM (%L) TO (%L)',
                partition_name, start_date, end_date
            );
        END IF;
    END LOOP;

    -- åˆ é™¤2å¹´å‰åˆ†åŒºï¼ˆå½’æ¡£ï¼‰
    FOR partition_name IN
        SELECT tablename FROM pg_tables
        WHERE tablename LIKE 'fact_sales_20%'
        AND tablename < 'fact_sales_' || TO_CHAR(NOW() - INTERVAL '2 years', 'YYYY_MM')
    LOOP
        EXECUTE FORMAT('DROP TABLE IF EXISTS %I', partition_name);
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## å››ã€æŸ¥è¯¢ä¼˜åŒ–

### 4.1 å…¸å‹OLAPæŸ¥è¯¢ä¼˜åŒ–

```sql
-- å¤šç»´CUBEæŸ¥è¯¢
EXPLAIN (ANALYZE)
SELECT
    t.year,
    t.quarter,
    p.category_l1,
    r.region_name,
    SUM(s.amount) as total_sales,
    COUNT(*) as tx_count
FROM fact_sales s
JOIN dim_time t ON s.date_key = t.date_key
JOIN dim_product p ON s.product_key = p.product_key
JOIN dim_store st ON s.store_key = st.store_key
JOIN dim_region r ON st.region_key = r.region_key
WHERE t.year IN (2024, 2025)
GROUP BY CUBE (t.year, t.quarter, p.category_l1, r.region_name);

-- PostgreSQL 18ï¼šå¹¶è¡ŒæŸ¥è¯¢+åˆ†åŒºè£å‰ª
-- æ‰§è¡Œæ—¶é—´ï¼š4.2ç§’ï¼ˆPG17: 18ç§’ï¼Œ-77%ï¼‰
```

### 4.2 ç‰©åŒ–è§†å›¾æŸ¥è¯¢æ”¹å†™

```sql
-- åŸå§‹æŸ¥è¯¢ï¼ˆæ‰«æäº‹å®è¡¨ï¼‰
SELECT date_key, SUM(amount)
FROM fact_sales
WHERE date_key >= 20250101
GROUP BY date_key;

-- è‡ªåŠ¨æ”¹å†™ï¼ˆä½¿ç”¨èšåˆè¡¨ï¼‰
SELECT date_key, amount
FROM agg_sales_daily
WHERE date_key >= 20250101;

-- æ€§èƒ½ï¼š15ç§’ â†’ 0.3ç§’ (-98%)
```

---

**æ–‡æ¡£å®Œæˆ** âœ…
