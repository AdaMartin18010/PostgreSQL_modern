---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL\cases\é‡‘èè´¦åŠ¡ä¸€è‡´æ€§.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ¡ˆä¾‹ï¼šé‡‘èè´¦åŠ¡ä¸€è‡´æ€§ï¼ˆå ä½ï¼‰

## æ¶æ„

- åˆ†åŒºè´¦åŠ¡è¡¨ã€å®¡è®¡è½¨è¿¹ã€é€»è¾‘å¤åˆ¶åˆ°å®¡è®¡åº“

## å…³é”®ç‚¹

- äº‹åŠ¡è¾¹ç•Œã€å¹‚ç­‰è¡¥å¿ã€å¯¹è´¦ä¸å›æ”¾

## éªŒè¯

- ç«¯åˆ°ç«¯å¯¹è´¦ä¸€è‡´ã€æ¢å¤æ¼”ç»ƒé€šè¿‡ï¼ˆRTO/RPO è®°å½•ï¼‰

## æœ€å°å¯å¤ç°ï¼ˆå ä½ï¼‰

```sql
CREATE TABLE accounts(id bigint primary key, balance numeric);
CREATE TABLE ledger(id bigserial primary key, account_id bigint, delta numeric, ts timestamptz);

-- äº‹åŠ¡è¾¹ç•Œä¿è¯ä¸€è‡´æ€§
BEGIN;
UPDATE accounts SET balance = balance + :delta WHERE id = :account_id;
INSERT INTO ledger(account_id, delta, ts) VALUES(:account_id, :delta, now());
COMMIT;

-- å¯¹è´¦æ£€æŸ¥ï¼ˆç¤ºæ„ï¼‰ï¼š
-- SELECT a.id, a.balance, SUM(l.delta) FROM accounts a JOIN ledger l ON l.account_id=a.id GROUP BY a.id HAVING a.balance <> SUM(l.delta);
```

---

## 1. ç³»ç»Ÿæ¦‚è¿°

é‡‘èè´¦åŠ¡ä¸€è‡´æ€§ç³»ç»Ÿæ˜¯åŸºäºPostgreSQLæ„å»ºçš„é«˜å¯é æ€§é‡‘èç³»ç»Ÿï¼Œç¡®ä¿è´¦åŠ¡æ•°æ®çš„å¼ºä¸€è‡´æ€§å’Œå¯è¿½æº¯æ€§ã€‚

**ç³»ç»Ÿç‰¹ç‚¹**ï¼š

- **å¼ºä¸€è‡´æ€§** - ä½¿ç”¨ACIDäº‹åŠ¡ä¿è¯æ•°æ®ä¸€è‡´æ€§
- **å¯è¿½æº¯æ€§** - å®Œæ•´çš„å®¡è®¡è½¨è¿¹å’Œæ—¥å¿—è®°å½•
- **é«˜å¯é æ€§** - é€»è¾‘å¤åˆ¶å’Œç¾éš¾æ¢å¤æœºåˆ¶
- **åˆè§„æ€§** - æ»¡è¶³é‡‘èè¡Œä¸šåˆè§„è¦æ±‚

---

## 2. æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```text
é‡‘èè´¦åŠ¡ä¸€è‡´æ€§ç³»ç»Ÿæ¶æ„
â”œâ”€â”€ åº”ç”¨å±‚
â”‚   â”œâ”€â”€ äº¤æ˜“æœåŠ¡
â”‚   â”œâ”€â”€ æŸ¥è¯¢æœåŠ¡
â”‚   â””â”€â”€ å¯¹è´¦æœåŠ¡
â”œâ”€â”€ æ•°æ®åº“å±‚
â”‚   â”œâ”€â”€ ä¸»åº“ï¼ˆäº¤æ˜“åº“ï¼‰
â”‚   â”‚   â”œâ”€â”€ è´¦æˆ·è¡¨ï¼ˆåˆ†åŒºï¼‰
â”‚   â”‚   â”œâ”€â”€ è´¦æœ¬è¡¨ï¼ˆå®¡è®¡è½¨è¿¹ï¼‰
â”‚   â”‚   â””â”€â”€ äº¤æ˜“è¡¨
â”‚   â”œâ”€â”€ ä»åº“ï¼ˆæŸ¥è¯¢åº“ï¼‰
â”‚   â”‚   â””â”€â”€ é€»è¾‘å¤åˆ¶
â”‚   â””â”€â”€ å®¡è®¡åº“
â”‚       â””â”€â”€ é€»è¾‘å¤åˆ¶
â””â”€â”€ ç›‘æ§å±‚
    â”œâ”€â”€ ä¸€è‡´æ€§ç›‘æ§
    â”œâ”€â”€ æ€§èƒ½ç›‘æ§
    â””â”€â”€ å‘Šè­¦ç³»ç»Ÿ
```

### 2.2 æ•°æ®æ¨¡å‹è®¾è®¡

**æ•°æ®æ¨¡å‹å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- 1. è´¦æˆ·è¡¨ï¼ˆåˆ†åŒºè¡¨ï¼‰
CREATE TABLE accounts (
    id BIGINT PRIMARY KEY,
    account_number TEXT UNIQUE NOT NULL,
    balance NUMERIC(20, 2) NOT NULL DEFAULT 0,
    account_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
) PARTITION BY HASH (id);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE accounts_p0 PARTITION OF accounts
FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE accounts_p1 PARTITION OF accounts
FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE accounts_p2 PARTITION OF accounts
FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE accounts_p3 PARTITION OF accounts
FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- 2. è´¦æœ¬è¡¨ï¼ˆå®¡è®¡è½¨è¿¹ï¼‰
CREATE TABLE ledger (
    id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    transaction_id BIGINT NOT NULL,
    delta NUMERIC(20, 2) NOT NULL,
    balance_before NUMERIC(20, 2) NOT NULL,
    balance_after NUMERIC(20, 2) NOT NULL,
    transaction_type TEXT NOT NULL,
    description TEXT,
    ts TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    operator_id BIGINT,
    metadata JSONB
) PARTITION BY RANGE (ts);

-- åˆ›å»ºæ—¶é—´åˆ†åŒº
CREATE TABLE ledger_2024_01 PARTITION OF ledger
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 3. äº¤æ˜“è¡¨
CREATE TABLE transactions (
    id BIGSERIAL PRIMARY KEY,
    transaction_type TEXT NOT NULL,
    from_account_id BIGINT,
    to_account_id BIGINT,
    amount NUMERIC(20, 2) NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    metadata JSONB
) PARTITION BY RANGE (created_at);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_ledger_account_id ON ledger (account_id);
CREATE INDEX idx_ledger_transaction_id ON ledger (transaction_id);
CREATE INDEX idx_ledger_ts ON ledger (ts);
CREATE INDEX idx_transactions_status ON transactions (status);
CREATE INDEX idx_transactions_created_at ON transactions (created_at);
```

---

## 3. æ ¸å¿ƒå®ç°

### 3.1 äº‹åŠ¡è¾¹ç•Œä¿è¯ä¸€è‡´æ€§

**è´¦æˆ·æ“ä½œå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- è´¦æˆ·æ“ä½œå‡½æ•°ï¼ˆä¿è¯äº‹åŠ¡ä¸€è‡´æ€§ï¼‰
CREATE OR REPLACE FUNCTION transfer_money(
    p_from_account_id BIGINT,
    p_to_account_id BIGINT,
    p_amount NUMERIC(20, 2),
    p_transaction_type TEXT DEFAULT 'transfer',
    p_description TEXT DEFAULT NULL
)
RETURNS TABLE (
    transaction_id BIGINT,
    success BOOLEAN,
    error_message TEXT
) AS $$
DECLARE
    v_transaction_id BIGINT;
    v_from_balance_before NUMERIC(20, 2);
    v_from_balance_after NUMERIC(20, 2);
    v_to_balance_before NUMERIC(20, 2);
    v_to_balance_after NUMERIC(20, 2);
BEGIN
    -- å¼€å§‹äº‹åŠ¡ï¼ˆå‡½æ•°å†…éƒ¨è‡ªåŠ¨äº‹åŠ¡ï¼‰
    -- 1. åˆ›å»ºäº¤æ˜“è®°å½•
    INSERT INTO transactions (
        transaction_type,
        from_account_id,
        to_account_id,
        amount,
        status
    )
    VALUES (
        p_transaction_type,
        p_from_account_id,
        p_to_account_id,
        p_amount,
        'processing'
    )
    RETURNING id INTO v_transaction_id;

    -- 2. é”å®šè´¦æˆ·å¹¶è·å–ä½™é¢
    SELECT balance INTO v_from_balance_before
    FROM accounts
    WHERE id = p_from_account_id
    FOR UPDATE;

    IF v_from_balance_before IS NULL THEN
        RAISE EXCEPTION 'æºè´¦æˆ·ä¸å­˜åœ¨: %', p_from_account_id;
    END IF;

    IF v_from_balance_before < p_amount THEN
        UPDATE transactions SET status = 'failed' WHERE id = v_transaction_id;
        RETURN QUERY SELECT v_transaction_id, FALSE, 'ä½™é¢ä¸è¶³'::TEXT;
        RETURN;
    END IF;

    SELECT balance INTO v_to_balance_before
    FROM accounts
    WHERE id = p_to_account_id
    FOR UPDATE;

    IF v_to_balance_before IS NULL THEN
        UPDATE transactions SET status = 'failed' WHERE id = v_transaction_id;
        RETURN QUERY SELECT v_transaction_id, FALSE, 'ç›®æ ‡è´¦æˆ·ä¸å­˜åœ¨'::TEXT;
        RETURN;
    END IF;

    -- 3. æ›´æ–°è´¦æˆ·ä½™é¢
    UPDATE accounts
    SET balance = balance - p_amount,
        updated_at = NOW()
    WHERE id = p_from_account_id;

    UPDATE accounts
    SET balance = balance + p_amount,
        updated_at = NOW()
    WHERE id = p_to_account_id;

    -- 4. è·å–æ›´æ–°åä½™é¢
    SELECT balance INTO v_from_balance_after FROM accounts WHERE id = p_from_account_id;
    SELECT balance INTO v_to_balance_after FROM accounts WHERE id = p_to_account_id;

    -- 5. è®°å½•è´¦æœ¬ï¼ˆæºè´¦æˆ·ï¼‰
    INSERT INTO ledger (
        account_id,
        transaction_id,
        delta,
        balance_before,
        balance_after,
        transaction_type,
        description
    )
    VALUES (
        p_from_account_id,
        v_transaction_id,
        -p_amount,
        v_from_balance_before,
        v_from_balance_after,
        p_transaction_type,
        p_description
    );

    -- 6. è®°å½•è´¦æœ¬ï¼ˆç›®æ ‡è´¦æˆ·ï¼‰
    INSERT INTO ledger (
        account_id,
        transaction_id,
        delta,
        balance_before,
        balance_after,
        transaction_type,
        description
    )
    VALUES (
        p_to_account_id,
        v_transaction_id,
        p_amount,
        v_to_balance_before,
        v_to_balance_after,
        p_transaction_type,
        p_description
    );

    -- 7. æ›´æ–°äº¤æ˜“çŠ¶æ€
    UPDATE transactions
    SET status = 'completed',
        completed_at = NOW()
    WHERE id = v_transaction_id;

    RETURN QUERY SELECT v_transaction_id, TRUE, NULL::TEXT;

EXCEPTION
    WHEN OTHERS THEN
        -- å›æ»šäº‹åŠ¡ï¼ˆå‡½æ•°è‡ªåŠ¨å›æ»šï¼‰
        UPDATE transactions SET status = 'failed' WHERE id = v_transaction_id;
        RETURN QUERY SELECT COALESCE(v_transaction_id, 0), FALSE, SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 å¹‚ç­‰è¡¥å¿æœºåˆ¶

**å¹‚ç­‰è¡¥å¿å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¹‚ç­‰æ€§æ£€æŸ¥
CREATE OR REPLACE FUNCTION check_transaction_idempotency(
    p_transaction_id BIGINT,
    p_from_account_id BIGINT,
    p_to_account_id BIGINT,
    p_amount NUMERIC(20, 2)
)
RETURNS BOOLEAN AS $$
DECLARE
    existing_transaction RECORD;
BEGIN
    SELECT * INTO existing_transaction
    FROM transactions
    WHERE id = p_transaction_id;

    IF existing_transaction IS NULL THEN
        RETURN FALSE;  -- äº¤æ˜“ä¸å­˜åœ¨ï¼Œå¯ä»¥æ‰§è¡Œ
    END IF;

    IF existing_transaction.status = 'completed' THEN
        -- æ£€æŸ¥äº¤æ˜“å‚æ•°æ˜¯å¦ä¸€è‡´
        IF existing_transaction.from_account_id = p_from_account_id
           AND existing_transaction.to_account_id = p_to_account_id
           AND existing_transaction.amount = p_amount THEN
            RETURN TRUE;  -- å¹‚ç­‰ï¼Œå·²æ‰§è¡Œè¿‡
        ELSE
            RAISE EXCEPTION 'äº¤æ˜“IDå†²çª: å‚æ•°ä¸ä¸€è‡´';
        END IF;
    END IF;

    RETURN FALSE;  -- äº¤æ˜“æœªå®Œæˆï¼Œå¯ä»¥é‡è¯•

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å¹‚ç­‰æ€§æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- è¡¥å¿äº‹åŠ¡å‡½æ•°
CREATE OR REPLACE FUNCTION compensate_transaction(
    p_transaction_id BIGINT
)
RETURNS TABLE (
    compensated BOOLEAN,
    error_message TEXT
) AS $$
DECLARE
    transaction_record RECORD;
BEGIN
    SELECT * INTO transaction_record
    FROM transactions
    WHERE id = p_transaction_id;

    IF transaction_record IS NULL THEN
        RETURN QUERY SELECT FALSE, 'äº¤æ˜“ä¸å­˜åœ¨'::TEXT;
        RETURN;
    END IF;

    IF transaction_record.status = 'completed' THEN
        -- æ‰§è¡Œåå‘æ“ä½œ
        PERFORM transfer_money(
            transaction_record.to_account_id,
            transaction_record.from_account_id,
            transaction_record.amount,
            'compensation',
            format('è¡¥å¿äº¤æ˜“: %', p_transaction_id)
        );

        -- æ ‡è®°åŸäº¤æ˜“ä¸ºå·²è¡¥å¿
        UPDATE transactions
        SET status = 'compensated',
            metadata = COALESCE(metadata, '{}'::JSONB) || jsonb_build_object('compensated_at', NOW())
        WHERE id = p_transaction_id;

        RETURN QUERY SELECT TRUE, NULL::TEXT;
    ELSE
        RETURN QUERY SELECT FALSE, format('äº¤æ˜“çŠ¶æ€ä¸å…è®¸è¡¥å¿: %', transaction_record.status)::TEXT;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT FALSE, SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. å¯¹è´¦ä¸å›æ”¾

### 4.1 å¯¹è´¦æ£€æŸ¥

**å¯¹è´¦æ£€æŸ¥å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å¯¹è´¦æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION reconcile_accounts()
RETURNS TABLE (
    account_id BIGINT,
    account_balance NUMERIC(20, 2),
    ledger_balance NUMERIC(20, 2),
    difference NUMERIC(20, 2),
    status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.id AS account_id,
        a.balance AS account_balance,
        COALESCE(SUM(l.delta), 0) AS ledger_balance,
        a.balance - COALESCE(SUM(l.delta), 0) AS difference,
        CASE
            WHEN a.balance = COALESCE(SUM(l.delta), 0) THEN 'ä¸€è‡´'
            ELSE 'ä¸ä¸€è‡´'
        END AS status
    FROM accounts a
    LEFT JOIN ledger l ON l.account_id = a.id
    GROUP BY a.id, a.balance
    HAVING a.balance <> COALESCE(SUM(l.delta), 0)
    ORDER BY ABS(a.balance - COALESCE(SUM(l.delta), 0)) DESC;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å¯¹è´¦æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œå¯¹è´¦æ£€æŸ¥
SELECT * FROM reconcile_accounts();
```

### 4.2 è´¦æœ¬å›æ”¾

**è´¦æœ¬å›æ”¾å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- è´¦æœ¬å›æ”¾å‡½æ•°ï¼ˆç”¨äºæ¢å¤å’ŒéªŒè¯ï¼‰
CREATE OR REPLACE FUNCTION replay_ledger(
    p_account_id BIGINT DEFAULT NULL,
    p_start_time TIMESTAMPTZ DEFAULT NULL,
    p_end_time TIMESTAMPTZ DEFAULT NULL
)
RETURNS TABLE (
    account_id BIGINT,
    replayed_balance NUMERIC(20, 2),
    actual_balance NUMERIC(20, 2),
    match_status TEXT
) AS $$
DECLARE
    account_rec RECORD;
    replayed_balance_val NUMERIC(20, 2);
    actual_balance_val NUMERIC(20, 2);
BEGIN
    FOR account_rec IN
        SELECT DISTINCT account_id
        FROM ledger
        WHERE (p_account_id IS NULL OR account_id = p_account_id)
          AND (p_start_time IS NULL OR ts >= p_start_time)
          AND (p_end_time IS NULL OR ts <= p_end_time)
    LOOP
        -- è®¡ç®—å›æ”¾ä½™é¢
        SELECT COALESCE(SUM(delta), 0) INTO replayed_balance_val
        FROM ledger
        WHERE account_id = account_rec.account_id
          AND (p_start_time IS NULL OR ts >= p_start_time)
          AND (p_end_time IS NULL OR ts <= p_end_time);

        -- è·å–å®é™…ä½™é¢
        SELECT balance INTO actual_balance_val
        FROM accounts
        WHERE id = account_rec.account_id;

        RETURN QUERY SELECT
            account_rec.account_id,
            replayed_balance_val,
            actual_balance_val,
            CASE
                WHEN replayed_balance_val = actual_balance_val THEN 'åŒ¹é…'
                ELSE 'ä¸åŒ¹é…'
            END;
    END LOOP;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'è´¦æœ¬å›æ”¾å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œè´¦æœ¬å›æ”¾
SELECT * FROM replay_ledger();
```

---

## 5. é€»è¾‘å¤åˆ¶åˆ°å®¡è®¡åº“

### 5.1 å®¡è®¡åº“é…ç½®

**å®¡è®¡åº“é€»è¾‘å¤åˆ¶é…ç½®ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- åœ¨ä¸»åº“åˆ›å»ºå‘å¸ƒï¼ˆåŒ…å«è´¦æœ¬å’Œäº¤æ˜“è¡¨ï¼‰
CREATE PUBLICATION audit_publication FOR TABLE ledger, transactions;

-- åœ¨å®¡è®¡åº“åˆ›å»ºè®¢é˜…
CREATE SUBSCRIPTION audit_subscription
CONNECTION 'host=primary_host port=5432 dbname=finance_db user=audit_user password=password'
PUBLICATION audit_publication
WITH (
    copy_data = true,
    create_slot = true,
    slot_name = 'audit_slot'
);

-- ç›‘æ§å®¡è®¡å¤åˆ¶çŠ¶æ€
SELECT
    subname,
    subenabled,
    subslotname,
    sublsn
FROM pg_subscription
WHERE subname = 'audit_subscription';
```

### 5.2 å®¡è®¡æŸ¥è¯¢

**å®¡è®¡æŸ¥è¯¢å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- å®¡è®¡æŸ¥è¯¢å‡½æ•°
CREATE OR REPLACE FUNCTION audit_query(
    p_account_id BIGINT DEFAULT NULL,
    p_start_time TIMESTAMPTZ DEFAULT NULL,
    p_end_time TIMESTAMPTZ DEFAULT NULL,
    p_transaction_type TEXT DEFAULT NULL
)
RETURNS TABLE (
    transaction_id BIGINT,
    account_id BIGINT,
    delta NUMERIC(20, 2),
    balance_before NUMERIC(20, 2),
    balance_after NUMERIC(20, 2),
    transaction_type TEXT,
    ts TIMESTAMPTZ,
    operator_id BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        l.transaction_id,
        l.account_id,
        l.delta,
        l.balance_before,
        l.balance_after,
        l.transaction_type,
        l.ts,
        l.operator_id
    FROM ledger l
    WHERE (p_account_id IS NULL OR l.account_id = p_account_id)
      AND (p_start_time IS NULL OR l.ts >= p_start_time)
      AND (p_end_time IS NULL OR l.ts <= p_end_time)
      AND (p_transaction_type IS NULL OR l.transaction_type = p_transaction_type)
    ORDER BY l.ts DESC;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å®¡è®¡æŸ¥è¯¢å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œå®¡è®¡æŸ¥è¯¢
SELECT * FROM audit_query(
    p_account_id => 123,
    p_start_time => '2024-01-01'::TIMESTAMPTZ,
    p_end_time => '2024-12-31'::TIMESTAMPTZ
);
```

---

## 6. éªŒè¯ä¸æµ‹è¯•

### 6.1 ä¸€è‡´æ€§éªŒè¯

**ä¸€è‡´æ€§éªŒè¯å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- ç«¯åˆ°ç«¯ä¸€è‡´æ€§éªŒè¯
CREATE OR REPLACE FUNCTION verify_consistency()
RETURNS TABLE (
    check_type TEXT,
    check_result TEXT,
    error_count BIGINT
) AS $$
DECLARE
    inconsistency_count BIGINT;
BEGIN
    -- æ£€æŸ¥è´¦æˆ·ä½™é¢ä¸è´¦æœ¬ä¸€è‡´æ€§
    SELECT COUNT(*) INTO inconsistency_count
    FROM reconcile_accounts()
    WHERE status = 'ä¸ä¸€è‡´';

    IF inconsistency_count > 0 THEN
        RETURN QUERY SELECT
            'è´¦æˆ·ä½™é¢ä¸€è‡´æ€§'::TEXT,
            'å¤±è´¥'::TEXT,
            inconsistency_count;
    ELSE
        RETURN QUERY SELECT
            'è´¦æˆ·ä½™é¢ä¸€è‡´æ€§'::TEXT,
            'é€šè¿‡'::TEXT,
            0::BIGINT;
    END IF;

    -- æ£€æŸ¥äº¤æ˜“å®Œæ•´æ€§
    SELECT COUNT(*) INTO inconsistency_count
    FROM transactions t
    WHERE t.status = 'completed'
      AND NOT EXISTS (
          SELECT 1 FROM ledger l
          WHERE l.transaction_id = t.id
      );

    IF inconsistency_count > 0 THEN
        RETURN QUERY SELECT
            'äº¤æ˜“å®Œæ•´æ€§'::TEXT,
            'å¤±è´¥'::TEXT,
            inconsistency_count;
    ELSE
        RETURN QUERY SELECT
            'äº¤æ˜“å®Œæ•´æ€§'::TEXT,
            'é€šè¿‡'::TEXT,
            0::BIGINT;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'ä¸€è‡´æ€§éªŒè¯å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œä¸€è‡´æ€§éªŒè¯
SELECT * FROM verify_consistency();
```

### 6.2 æ¢å¤æ¼”ç»ƒ

**æ¢å¤æ¼”ç»ƒå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰**ï¼š

```sql
-- æ¢å¤æ¼”ç»ƒï¼ˆRTO/RPOè®°å½•ï¼‰
CREATE OR REPLACE FUNCTION recovery_drill()
RETURNS TABLE (
    drill_step TEXT,
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    duration_seconds NUMERIC,
    status TEXT
) AS $$
DECLARE
    step_start TIMESTAMPTZ;
    step_end TIMESTAMPTZ;
BEGIN
    -- æ­¥éª¤1ï¼šåœæ­¢ä¸»åº“ï¼ˆæ¨¡æ‹Ÿï¼‰
    step_start := clock_timestamp();
    -- å®é™…åº”è¯¥åœæ­¢PostgreSQLæœåŠ¡
    PERFORM pg_sleep(1);  -- æ¨¡æ‹Ÿåœæ­¢æ—¶é—´
    step_end := clock_timestamp();

    RETURN QUERY SELECT
        'åœæ­¢ä¸»åº“'::TEXT,
        step_start,
        step_end,
        EXTRACT(EPOCH FROM (step_end - step_start)),
        'å®Œæˆ'::TEXT;

    -- æ­¥éª¤2ï¼šåˆ‡æ¢åˆ°ä»åº“
    step_start := clock_timestamp();
    -- å®é™…åº”è¯¥æå‡ä»åº“ä¸ºä¸»åº“
    PERFORM pg_sleep(1);  -- æ¨¡æ‹Ÿåˆ‡æ¢æ—¶é—´
    step_end := clock_timestamp();

    RETURN QUERY SELECT
        'åˆ‡æ¢åˆ°ä»åº“'::TEXT,
        step_start,
        step_end,
        EXTRACT(EPOCH FROM (step_end - step_start)),
        'å®Œæˆ'::TEXT;

    -- æ­¥éª¤3ï¼šéªŒè¯æ•°æ®ä¸€è‡´æ€§
    step_start := clock_timestamp();
    PERFORM verify_consistency();
    step_end := clock_timestamp();

    RETURN QUERY SELECT
        'éªŒè¯æ•°æ®ä¸€è‡´æ€§'::TEXT,
        step_start,
        step_end,
        EXTRACT(EPOCH FROM (step_end - step_start)),
        'å®Œæˆ'::TEXT;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ¢å¤æ¼”ç»ƒå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œæ¢å¤æ¼”ç»ƒ
SELECT * FROM recovery_drill();
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [05-é‡‘èäº¤æ˜“ç³»ç»Ÿ/](./05-é‡‘èäº¤æ˜“ç³»ç»Ÿ/) - é‡‘èäº¤æ˜“ç³»ç»Ÿå®Œæ•´æ¡ˆä¾‹
- [13-é«˜å¯ç”¨æ¶æ„/](../13-é«˜å¯ç”¨æ¶æ„/README.md) - é«˜å¯ç”¨æ¶æ„è®¾è®¡
- [19-å®æˆ˜æ¡ˆä¾‹/README.md](./README.md) - å®æˆ˜æ¡ˆä¾‹ä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
