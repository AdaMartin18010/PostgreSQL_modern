---

> **📋 文档来源**: `PostgreSQL\runbook\故障切换与订阅重建.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# Runbook：故障切换与订阅重建（PostgreSQL 17.x 占位）

## 场景

主库故障，启用从库并平滑恢复逻辑订阅。

## 步骤（示意）

1. 切主：Promote 只读副本；确认复制延迟
2. 更新连接：应用与订阅指向新主
3. 刷新：`ALTER SUBSCRIPTION ... REFRESH PUBLICATION`，校验复制槽
4. 验证：延迟、冲突、缺失表与权限

## 检查清单

- 订阅状态、复制槽状态、冲突与重放、应用可用性
- 复制延迟与缺失对象核对
- 应用连接池刷新与错误率

## 演练频率（建议）

- 月度：只读副本 Promote 与回切
- 双月：订阅刷新/重建演练

---

## 1. 故障切换详细步骤

### 1.1 切主操作

**切主操作脚本（带错误处理和性能测试）**：

```sql
-- 1. 检查从库状态
CREATE OR REPLACE FUNCTION check_replica_status()
RETURNS TABLE (
    is_replica BOOLEAN,
    replay_lag INTERVAL,
    sync_state TEXT,
    last_replay_time TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        pg_is_in_recovery() AS is_replica,
        CASE
            WHEN pg_is_in_recovery() THEN
                (SELECT replay_lag FROM pg_stat_replication LIMIT 1)
            ELSE NULL
        END AS replay_lag,
        (SELECT sync_state FROM pg_stat_replication LIMIT 1) AS sync_state,
        (SELECT write_lag FROM pg_stat_replication LIMIT 1) AS last_replay_time;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查从库状态失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行检查
SELECT * FROM check_replica_status();

-- 2. Promote从库（需要在从库服务器上执行）
-- 创建recovery.signal文件或执行：
-- SELECT pg_promote();
```

### 1.2 更新连接配置

**连接配置更新脚本（带错误处理和性能测试）**：

```sql
-- 更新应用连接配置（示例）
-- 1. 更新连接池配置
-- PgBouncer配置更新：
-- [databases]
-- mydb = host=new_primary_host port=5432 dbname=mydb

-- 2. 重新加载连接池
-- 在PgBouncer服务器上执行：
-- SELECT pg_reload_conf();

-- 3. 验证连接
CREATE OR REPLACE FUNCTION verify_connections()
RETURNS TABLE (
    connection_count BIGINT,
    active_queries BIGINT,
    idle_connections BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*) AS connection_count,
        COUNT(*) FILTER (WHERE state = 'active') AS active_queries,
        COUNT(*) FILTER (WHERE state = 'idle') AS idle_connections
    FROM pg_stat_activity
    WHERE datname = current_database()
      AND pid != pg_backend_pid();

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '验证连接失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 1.3 刷新订阅

**订阅刷新操作（带错误处理和性能测试）**：

```sql
-- 刷新订阅
CREATE OR REPLACE FUNCTION refresh_subscription(
    p_subscription_name TEXT
)
RETURNS TABLE (
    refresh_status TEXT,
    duration_ms NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
BEGIN
    start_time := clock_timestamp();

    -- 刷新订阅
    EXECUTE format('ALTER SUBSCRIPTION %I REFRESH PUBLICATION', p_subscription_name);

    end_time := clock_timestamp();

    RETURN QUERY SELECT
        'SUCCESS'::TEXT,
        EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT
            format('FAILED: %', SQLERRM)::TEXT,
            NULL::NUMERIC;
END;
$$ LANGUAGE plpgsql;

-- 执行刷新
SELECT * FROM refresh_subscription('my_subscription');
```

---

## 2. 验证步骤

### 2.1 延迟验证

**延迟验证函数（带错误处理和性能测试）**：

```sql
-- 验证复制延迟
CREATE OR REPLACE FUNCTION verify_replication_lag()
RETURNS TABLE (
    subscription_name TEXT,
    apply_lag INTERVAL,
    write_lag INTERVAL,
    flush_lag INTERVAL,
    replay_lag INTERVAL,
    status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        subname AS subscription_name,
        apply_lag,
        write_lag,
        flush_lag,
        replay_lag,
        CASE
            WHEN replay_lag < INTERVAL '1 minute' THEN '正常'
            WHEN replay_lag < INTERVAL '5 minutes' THEN '警告'
            ELSE '异常'
        END AS status
    FROM pg_stat_subscription;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '验证复制延迟失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行验证
SELECT * FROM verify_replication_lag();
```

### 2.2 冲突检查

**冲突检查函数（带错误处理和性能测试）**：

```sql
-- 检查复制冲突
CREATE OR REPLACE FUNCTION check_replication_conflicts()
RETURNS TABLE (
    conflict_type TEXT,
    conflict_count BIGINT,
    last_conflict_time TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'data'::TEXT AS conflict_type,
        (SELECT conflicts FROM pg_stat_database_conflicts WHERE datname = current_database()) AS conflict_count,
        (SELECT stats_reset FROM pg_stat_database WHERE datname = current_database()) AS last_conflict_time;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查复制冲突失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行检查
SELECT * FROM check_replication_conflicts();
```

---

## 3. 检查清单

### 3.1 完整检查清单

**检查清单函数（带错误处理和性能测试）**：

```sql
-- 完整检查清单
CREATE OR REPLACE FUNCTION run_failover_checklist()
RETURNS TABLE (
    check_item TEXT,
    check_result TEXT,
    check_status TEXT,
    details TEXT
) AS $$
BEGIN
    -- 1. 订阅状态检查
    RETURN QUERY
    SELECT
        '订阅状态'::TEXT,
        subname::TEXT,
        CASE WHEN subenabled THEN '正常' ELSE '异常' END,
        format('订阅: %, 启用: %', subname, subenabled)::TEXT
    FROM pg_subscription;

    -- 2. 复制槽状态检查
    RETURN QUERY
    SELECT
        '复制槽状态'::TEXT,
        slot_name::TEXT,
        CASE WHEN active THEN '正常' ELSE '异常' END,
        format('槽: %, 活跃: %', slot_name, active)::TEXT
    FROM pg_replication_slots
    WHERE slot_type = 'logical';

    -- 3. 冲突检查
    RETURN QUERY
    SELECT
        '冲突检查'::TEXT,
        COALESCE(conflicts::TEXT, '0')::TEXT,
        CASE WHEN COALESCE(conflicts, 0) = 0 THEN '正常' ELSE '异常' END,
        format('冲突数: %', COALESCE(conflicts, 0))::TEXT
    FROM pg_stat_database_conflicts
    WHERE datname = current_database();

    -- 4. 应用可用性检查
    RETURN QUERY
    SELECT
        '应用可用性'::TEXT,
        COUNT(*)::TEXT,
        CASE WHEN COUNT(*) > 0 THEN '正常' ELSE '异常' END,
        format('活跃连接数: %', COUNT(*))::TEXT
    FROM pg_stat_activity
    WHERE state = 'active'
      AND datname = current_database();

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '执行检查清单失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行检查清单
SELECT * FROM run_failover_checklist();
```

---

## 📚 相关文档

- [13-高可用架构/](../13-高可用架构/README.md) - 高可用架构设计
- [09-逻辑复制/](../09-逻辑复制/README.md) - 逻辑复制主题
- [20-故障诊断案例/README.md](./README.md) - 故障诊断案例主题

---

**最后更新**: 2025年1月
