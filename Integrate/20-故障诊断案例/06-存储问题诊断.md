---

> **📋 文档来源**: `DataBaseTheory\20-故障诊断案例库\06-存储问题诊断.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 存储问题诊断案例

> **PostgreSQL 18**
> **表膨胀、VACUUM、磁盘空间**

---

## 案例1：表膨胀严重

### 症状

```text
表大小持续增长
查询变慢
磁盘空间不足
n_dead_tup比例高（>30%）
```

### 诊断

```sql
-- 检查表膨胀情况（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查表膨胀情况';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE n_dead_tup > 0
ORDER BY n_dead_tup DESC
LIMIT 100;

/*
tablename: orders
total_size: 50GB
table_size: 45GB
n_live_tup: 10,000,000
n_dead_tup: 5,000,000
dead_ratio: 33.33% (严重膨胀！)
last_autovacuum: 2025-12-01 (一周前)
*/

-- 检查索引膨胀（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查索引膨胀';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexrelid) > 1024 * 1024 * 1024  -- >1GB
ORDER BY pg_relation_size(indexrelid) DESC
LIMIT 100;

-- 检查VACUUM进度（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_stat_progress_vacuum') THEN
            RAISE WARNING 'pg_stat_progress_vacuum视图不存在（可能需要PostgreSQL 12+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查VACUUM进度';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    datname,
    usename,
    application_name,
    state,
    query,
    phase,
    heap_blks_total,
    heap_blks_scanned,
    heap_blks_vacuumed,
    index_vacuum_count,
    max_dead_tuples,
    num_dead_tuples
FROM pg_stat_progress_vacuum
LIMIT 100;
```

### 解决

```sql
-- 1. 立即VACUUM（不锁表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            VACUUM ANALYZE orders;
            RAISE NOTICE 'VACUUM ANALYZE orders 执行成功';
        ELSE
            RAISE WARNING '表 orders 不存在，跳过VACUUM';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'VACUUM失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 如果无效，使用VACUUM FULL（锁表，需谨慎）
-- 在业务低峰期执行
-- VACUUM FULL ANALYZE orders;  -- 注意：这会锁表，谨慎使用

-- 3. 重建表（推荐，不锁表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            BEGIN;
            CREATE TABLE orders_new (LIKE orders INCLUDING ALL);
            INSERT INTO orders_new SELECT * FROM orders;
            ALTER TABLE orders RENAME TO orders_old;
            ALTER TABLE orders_new RENAME TO orders;
            -- 重建索引
            CREATE INDEX CONCURRENTLY idx_orders_customer ON orders(customer_id);
            -- ... 其他索引
            COMMIT;
            DROP TABLE orders_old;
            RAISE NOTICE '表重建成功';
        ELSE
            RAISE WARNING '表 orders 不存在，跳过重建';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '重建表失败: %', SQLERRM;
            ROLLBACK;
            RAISE;
    END;
END $$;

-- 4. 调整autovacuum参数（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            ALTER TABLE orders SET (
                autovacuum_vacuum_scale_factor = 0.1,  -- 10%死元组触发
                autovacuum_vacuum_threshold = 1000,
                autovacuum_analyze_scale_factor = 0.05,
                autovacuum_analyze_threshold = 500
            );
            RAISE NOTICE 'autovacuum参数设置成功';
        ELSE
            RAISE WARNING '表 orders 不存在，跳过autovacuum参数设置';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置autovacuum参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 5. 使用fillfactor预留空间（减少未来膨胀）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            ALTER TABLE orders SET (fillfactor = 80);  -- 预留20%空间
            RAISE NOTICE 'fillfactor参数设置成功';
        ELSE
            RAISE WARNING '表 orders 不存在，跳过fillfactor参数设置';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置fillfactor参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例2：磁盘空间不足

### 症状

```text
错误：could not extend file
磁盘使用率>90%
无法写入数据
```

### 诊断

```sql
-- 检查数据库大小（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查数据库大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC
LIMIT 100;

-- 检查表大小（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查表大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;

-- 检查WAL大小（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查WAL大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pg_size_pretty(pg_wal_lsn_diff(
        pg_current_wal_lsn(),
        '0/0'
    )) AS total_wal_size;

-- 检查WAL目录大小（需要系统命令）
-- SELECT pg_ls_waldir();

-- 检查临时文件（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查临时文件';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    temp_files,
    pg_size_pretty(temp_bytes) AS temp_size
FROM pg_stat_database
WHERE temp_bytes > 0
ORDER BY temp_bytes DESC
LIMIT 100;

-- 检查TOAST表大小（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查TOAST表大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(
        (SELECT pg_total_relation_size(oid)
         FROM pg_class
         WHERE relname = tablename || '_toast')
    ) AS toast_size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY toast_size DESC NULLS LAST
LIMIT 10;
```

### 解决

```sql
-- 1. 清理死元组（释放空间）（带错误处理）
DO $$
BEGIN
    BEGIN
        VACUUM FULL;
        RAISE NOTICE 'VACUUM FULL 执行成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'VACUUM FULL失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 清理WAL（如果使用归档）
-- 检查归档配置（带错误处理）
DO $$
DECLARE
    archive_mode_value text;
    archive_command_value text;
BEGIN
    BEGIN
        SHOW archive_mode INTO archive_mode_value;
        SHOW archive_command INTO archive_command_value;
        RAISE NOTICE 'archive_mode: %, archive_command: %', archive_mode_value, archive_command_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取归档配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 如果使用pg_wal_archive，清理旧WAL
-- 注意：确保已归档到备份位置

-- 3. 删除不需要的数据（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法删除数据';
            RETURN;
        END IF;

        RAISE NOTICE '开始删除旧数据（order_date < 2020-01-01）';
        DELETE FROM orders WHERE order_date < '2020-01-01';
        
        RAISE NOTICE '已删除旧数据，开始执行VACUUM FULL';
        -- 注意：VACUUM FULL需要在事务外执行，这里只是提示
        RAISE NOTICE '请在事务外执行: VACUUM FULL orders;';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '删除旧数据失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 4. 使用表分区（管理大表）（带错误处理）
-- 按月分区，删除旧分区
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders_2020_01') THEN
            DROP TABLE orders_2020_01;
            RAISE NOTICE '分区 orders_2020_01 已删除';
        ELSE
            RAISE NOTICE '分区 orders_2020_01 不存在，跳过删除';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '删除分区失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 5. 压缩大对象
-- 检查大对象（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查大对象';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    oid,
    pg_size_pretty(pg_largeobject_length(oid)) AS size
FROM pg_largeobject_metadata
ORDER BY pg_largeobject_length(oid) DESC
LIMIT 10;

-- 6. 扩展磁盘（如果可能）（带错误处理）
-- 添加新的表空间
DO $$
BEGIN
    BEGIN
        -- 检查权限
        IF NOT current_setting('is_superuser')::boolean THEN
            RAISE EXCEPTION '需要超级用户权限才能创建表空间';
        END IF;

        -- 检查表空间是否已存在
        IF NOT EXISTS (SELECT 1 FROM pg_tablespace WHERE spcname = 'new_tablespace') THEN
            CREATE TABLESPACE new_tablespace LOCATION '/new/disk/path';
            RAISE NOTICE '表空间 new_tablespace 创建成功';
        ELSE
            RAISE NOTICE '表空间 new_tablespace 已存在';
        END IF;

        -- 检查表是否存在
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            ALTER TABLE orders SET TABLESPACE new_tablespace;
            RAISE NOTICE '表 orders 已移动到新表空间';
        ELSE
            RAISE WARNING '表 orders 不存在，跳过表空间设置';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法创建表空间';
        WHEN OTHERS THEN
            RAISE WARNING '扩展磁盘操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例3：VACUUM不工作

### 症状

```text
autovacuum未运行
表持续膨胀
last_autovacuum为NULL或很久以前
```

### 诊断

```sql
-- 检查autovacuum状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查autovacuum状态';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    setting,
    unit,
    context
FROM pg_settings
WHERE name LIKE '%autovacuum%'
ORDER BY name
LIMIT 100;

/*
autovacuum = on (应该开启)
autovacuum_max_workers = 3
autovacuum_naptime = 1min
*/

-- 检查autovacuum进程（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查autovacuum进程';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    query_start
FROM pg_stat_activity
WHERE query LIKE '%autovacuum%'
   OR application_name = 'autovacuum launcher'
   OR application_name LIKE 'autovacuum worker%';

-- 检查表级autovacuum设置（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查表级autovacuum设置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    reloptions
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
  AND reloptions IS NOT NULL;

-- 检查autovacuum统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查autovacuum统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    n_dead_tup,
    n_live_tup,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count,
    last_analyze,
    last_autoanalyze,
    analyze_count,
    autoanalyze_count
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;

-- 检查autovacuum日志（需要配置）
-- log_autovacuum_min_duration = 0
-- 查看PostgreSQL日志文件
```

### 解决

```sql
-- 1. 确保autovacuum开启（带错误处理）
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser')::boolean THEN
            ALTER SYSTEM SET autovacuum = on;
            PERFORM pg_reload_conf();
            RAISE NOTICE 'autovacuum已开启，配置已重新加载';
        ELSE
            RAISE EXCEPTION '需要超级用户权限才能修改系统配置';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法修改系统配置';
            RAISE;
        WHEN OTHERS THEN
            RAISE WARNING '设置autovacuum配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 调整autovacuum参数
-- postgresql.conf
-- autovacuum_max_workers = 3  -- 增加worker数
-- autovacuum_naptime = 30s  -- 减少等待时间
-- autovacuum_vacuum_scale_factor = 0.1  -- 10%死元组触发
-- autovacuum_analyze_scale_factor = 0.05  -- 5%变化触发ANALYZE

-- 3. 表级调整（针对大表，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法设置autovacuum参数';
            RETURN;
        END IF;

        ALTER TABLE orders SET (
            autovacuum_vacuum_scale_factor = 0.05,  -- 更频繁
            autovacuum_vacuum_threshold = 5000,
            autovacuum_analyze_scale_factor = 0.02
        );
        RAISE NOTICE '表 orders 的autovacuum参数已设置';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 orders 不存在';
        WHEN OTHERS THEN
            RAISE WARNING '设置autovacuum参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 4. 手动触发VACUUM（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行VACUUM';
            RETURN;
        END IF;

        RAISE NOTICE '开始执行VACUUM ANALYZE orders';
        PERFORM VACUUM ANALYZE orders;
        RAISE NOTICE 'VACUUM ANALYZE orders 完成';
    EXCEPTION
        WHEN lock_not_available THEN
            RAISE WARNING '无法获取锁，表可能被其他事务使用';
        WHEN OTHERS THEN
            RAISE WARNING 'VACUUM操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 5. 检查autovacuum阻塞（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查autovacuum阻塞';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    blocked.pid AS blocked_pid,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query
FROM pg_stat_activity blocked
JOIN pg_locks blocked_lock ON blocked.pid = blocked_lock.pid
JOIN pg_locks blocking_lock ON blocking_lock.locktype = blocked_lock.locktype
    AND blocking_lock.pid != blocked_lock.pid
JOIN pg_stat_activity blocking ON blocking.pid = blocking_lock.pid
WHERE blocked.query LIKE '%autovacuum%'
  AND NOT blocked_lock.granted
  AND blocking_lock.granted;
```

---

## 案例4：索引膨胀

### 症状

```text
索引大小异常大
查询性能下降
索引扫描慢
```

### 诊断

```sql
-- 检查索引大小（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查索引大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    pg_size_pretty(pg_relation_size(indrelid)) AS table_size,
    round(100.0 * pg_relation_size(indexrelid) /
          NULLIF(pg_relation_size(indrelid), 0), 2) AS index_ratio,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexrelid) > 1024 * 1024 * 1024  -- >1GB
ORDER BY pg_relation_size(indexrelid) DESC
LIMIT 20;

/*
indexname: idx_orders_customer
index_size: 15GB
table_size: 10GB
index_ratio: 150% (异常！索引比表还大)
idx_scan: 1000 (使用频率低)
*/

-- 检查索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN '未使用'
        WHEN idx_scan < 100 THEN '使用频率低'
        ELSE '正常使用'
    END AS usage_status
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;

-- 检查重复索引
SELECT
    a.schemaname,
    a.tablename,
    a.indexname AS index1,
    b.indexname AS index2,
    a.indexdef AS def1,
    b.indexdef AS def2
FROM pg_indexes a
JOIN pg_indexes b ON a.schemaname = b.schemaname
    AND a.tablename = b.tablename
    AND a.indexname < b.indexname
WHERE a.indexdef = b.indexdef;  -- 完全相同的索引
```

### 解决

```sql
-- 1. 重建索引（不锁表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE indexname = 'idx_orders_customer'
        ) THEN
            REINDEX INDEX CONCURRENTLY idx_orders_customer;
            RAISE NOTICE '索引重建成功';
        ELSE
            RAISE WARNING '索引 idx_orders_customer 不存在，跳过重建';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '重建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 重建表的所有索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            REINDEX TABLE CONCURRENTLY orders;
            RAISE NOTICE '表的所有索引重建成功';
        ELSE
            RAISE WARNING '表 orders 不存在，跳过索引重建';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '重建表索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 删除未使用的索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE indexname = 'idx_unused_index'
        ) THEN
            DROP INDEX CONCURRENTLY idx_unused_index;
            RAISE NOTICE '未使用的索引已删除';
        ELSE
            RAISE WARNING '索引 idx_unused_index 不存在，跳过删除';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '删除索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 4. 合并重复索引（带错误处理）
-- 如果两个索引功能相同，删除一个
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_customer_old') THEN
            DROP INDEX CONCURRENTLY idx_orders_customer_old;
            RAISE NOTICE '重复索引 idx_orders_customer_old 已删除';
        ELSE
            RAISE NOTICE '索引 idx_orders_customer_old 不存在，跳过删除';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '删除重复索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 5. 优化索引定义（带错误处理）
-- 使用部分索引（如果适用）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_status') THEN
            DROP INDEX idx_orders_status;
            RAISE NOTICE '索引 idx_orders_status 已删除';
        END IF;

        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_status_active') THEN
                CREATE INDEX idx_orders_status_active
                ON orders(status)
                WHERE status = 'active';
                RAISE NOTICE '部分索引 idx_orders_status_active 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_orders_status_active 已存在';
            END IF;
        ELSE
            RAISE WARNING '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建部分索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用覆盖索引（INCLUDE列）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_customer') THEN
            DROP INDEX idx_orders_customer;
            RAISE NOTICE '索引 idx_orders_customer 已删除';
        END IF;

        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_customer') THEN
                CREATE INDEX idx_orders_customer
                ON orders(customer_id)
                INCLUDE (order_date, amount);
                RAISE NOTICE '覆盖索引 idx_orders_customer 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_orders_customer 已存在';
            END IF;
        ELSE
            RAISE WARNING '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建覆盖索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例5：WAL空间占用过大

### 症状

```text
WAL目录占用大量空间
磁盘空间不足
pg_wal目录>50GB
```

### 诊断

```sql
-- 检查WAL使用情况（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查WAL使用情况';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            '0/0'
        )
    ) AS total_wal_size;

-- 检查WAL段数量（需要系统访问）
-- SELECT count(*) FROM pg_ls_waldir();

-- 检查复制槽（可能阻止WAL清理）（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查复制槽';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    slot_name,
    slot_type,
    database,
    active,
    restart_lsn,
    confirmed_flush_lsn,
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            COALESCE(confirmed_flush_lsn, restart_lsn)
        )
    ) AS retained_wal_size
FROM pg_replication_slots;

-- 检查checkpoint配置（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查checkpoint配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    setting,
    unit
FROM pg_settings
WHERE name IN (
    'checkpoint_timeout',
    'max_wal_size',
    'min_wal_size',
    'wal_keep_size'
);
```

### 解决

```sql
-- 1. 调整checkpoint参数（带错误处理）
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser')::boolean THEN
            ALTER SYSTEM SET max_wal_size = '4GB';  -- 限制WAL大小
            ALTER SYSTEM SET checkpoint_timeout = '15min';  -- 更频繁checkpoint
            PERFORM pg_reload_conf();
            RAISE NOTICE 'checkpoint参数已更新，配置已重新加载';
        ELSE
            RAISE EXCEPTION '需要超级用户权限才能修改系统配置';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法修改系统配置';
            RAISE;
        WHEN OTHERS THEN
            RAISE WARNING '设置checkpoint参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 手动checkpoint（带错误处理）
DO $$
BEGIN
    BEGIN
        CHECKPOINT;
        RAISE NOTICE 'CHECKPOINT执行成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'CHECKPOINT失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 清理不活跃的复制槽（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (
            SELECT 1 FROM pg_replication_slots
            WHERE slot_name = 'old_slot_name' AND NOT active
        ) THEN
            PERFORM pg_drop_replication_slot('old_slot_name');
            RAISE NOTICE '复制槽 old_slot_name 已删除';
        ELSE
            RAISE WARNING '复制槽 old_slot_name 不存在或不活跃，跳过删除';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '删除复制槽失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 4. 如果使用归档，确保归档正常
-- 检查归档命令
SHOW archive_command;

-- 5. 监控WAL生成速度（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_views WHERE viewname = 'wal_generation_rate') THEN
            RAISE NOTICE '视图 wal_generation_rate 已存在';
        ELSE
            CREATE VIEW wal_generation_rate AS
            SELECT
                now() AS time,
                pg_current_wal_lsn() AS current_lsn,
                pg_size_pretty(
                    pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            '0/0'
        )
    ) AS total_wal_size;

-- 6. 优化写入模式（如果允许）
-- 批量提交事务
-- 减少不必要的WAL（使用UNLOGGED表，如果允许）
```

---

**文档完成** ✅
