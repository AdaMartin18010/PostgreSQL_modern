---

> **📋 文档来源**: `DataBaseTheory\20-故障诊断案例库\05-复制问题诊断.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 复制问题诊断案例

> **PostgreSQL 18**
> **流复制、逻辑复制、延迟**

---

## 案例1：复制延迟高

### 症状

```text
主从延迟持续增长
从库查询数据滞后
监控显示replay_lag > 1分钟
```

### 诊断

```sql
-- 在主库检查复制状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查复制状态（主库）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    client_addr,
    usename,
    application_name,
    state,
    sync_state,
    write_lag,
    flush_lag,
    replay_lag,
    sync_priority,
    sync_state
FROM pg_stat_replication
LIMIT 100;

/*
replay_lag: 00:05:23.456789 (5分钟延迟！)
state: streaming
*/

-- 检查WAL生成速度（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查WAL生成速度';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pg_size_pretty(pg_wal_lsn_diff(
        pg_current_wal_lsn(),
        '0/0'
    )) AS total_wal_size;

-- 检查从库状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查从库状态';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pg_is_in_recovery() AS is_replica,
    pg_last_wal_receive_lsn() AS receive_lsn,
    pg_last_wal_replay_lsn() AS replay_lsn,
    pg_wal_lsn_diff(
        pg_last_wal_receive_lsn(),
        pg_last_wal_replay_lsn()
    ) AS lag_bytes;

-- 检查从库应用延迟原因（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查从库应用延迟原因';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    application_name,
    state,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE backend_type = 'walreceiver'
   OR backend_type = 'walsender'
LIMIT 100;
```

### 解决

```sql
-- 1. 检查网络带宽（带错误处理和性能测试）
-- 从库执行
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查网络带宽（从库）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT pg_size_pretty(
    pg_wal_lsn_diff(
        pg_last_wal_receive_lsn(),
        pg_last_wal_replay_lsn()
    )
) AS lag_size;

-- 2. 优化从库配置
-- postgresql.conf (从库)
-- max_connections = 200
-- shared_buffers = 8GB
-- wal_receiver_timeout = 60s
-- wal_receiver_status_interval = 10s

-- 3. 检查从库查询负载（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查从库查询负载';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    count(*) AS active_queries,
    sum(EXTRACT(EPOCH FROM (now() - query_start))) AS total_query_time
FROM pg_stat_activity
WHERE state = 'active'
  AND pid != pg_backend_pid();

-- 4. 使用同步复制（如果延迟不可接受）（带错误处理）
-- 主库配置
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser')::boolean THEN
            -- 注意：这些配置需要根据实际情况调整
            -- ALTER SYSTEM SET synchronous_standby_names = 'ANY 1 (standby1, standby2)';
            -- ALTER SYSTEM SET synchronous_commit = on;
            -- PERFORM pg_reload_conf();
            RAISE NOTICE '同步复制配置需要手动在postgresql.conf中设置';
        ELSE
            RAISE NOTICE '需要超级用户权限才能修改系统配置';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法修改系统配置';
        WHEN OTHERS THEN
            RAISE WARNING '设置同步复制配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 5. 优化WAL生成
-- 减少不必要的WAL
-- 使用UNLOGGED表（如果允许）
-- 批量提交事务
```

---

## 案例2：复制中断

### 症状

```text
从库状态：not streaming
主库日志：could not receive data from WAL stream
从库无法接收WAL
```

### 诊断

```sql
-- 主库检查复制连接（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查复制连接（主库）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    sync_state,
    write_lag,
    flush_lag,
    replay_lag
FROM pg_stat_replication
LIMIT 100;

-- 如果查询返回空，说明复制连接断开

-- 检查主库WAL配置（带错误处理）
DO $$
DECLARE
    wal_level_value text;
    max_wal_senders_value text;
BEGIN
    BEGIN
        SHOW wal_level INTO wal_level_value;
        SHOW max_wal_senders INTO max_wal_senders_value;
        RAISE NOTICE 'wal_level: %, max_wal_senders: %', wal_level_value, max_wal_senders_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取WAL配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 从库检查连接状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查连接状态（从库）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    application_name,
    state,
    wait_event_type,
    wait_event
FROM pg_stat_activity
WHERE backend_type = 'walreceiver'
LIMIT 100;

-- 检查从库配置（带错误处理）
DO $$
DECLARE
    primary_conninfo_value text;
    primary_slot_name_value text;
BEGIN
    BEGIN
        SHOW primary_conninfo INTO primary_conninfo_value;
        SHOW primary_slot_name INTO primary_slot_name_value;
        RAISE NOTICE 'primary_conninfo: %, primary_slot_name: %', primary_conninfo_value, primary_slot_name_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取从库配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 解决

```sql
-- 1. 检查网络连通性（带错误处理和性能测试）
-- 从库执行
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查网络连通性（从库）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT pg_is_in_recovery() AS is_replica;  -- 应该返回 true

-- 2. 检查复制槽（如果使用）（带错误处理和性能测试）
-- 主库
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查复制槽（主库）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    slot_name,
    slot_type,
    active,
    restart_lsn,
    confirmed_flush_lsn
FROM pg_replication_slots
LIMIT 100;

-- 如果slot不存在或inactive，重新创建（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM pg_replication_slots WHERE slot_name = 'standby1_slot'
        ) THEN
            PERFORM pg_create_physical_replication_slot('standby1_slot');
            RAISE NOTICE '复制槽 standby1_slot 创建成功';
        ELSE
            RAISE NOTICE '复制槽 standby1_slot 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '复制槽已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建复制槽失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 检查从库recovery配置
-- postgresql.conf (从库)
-- primary_conninfo = 'host=primary_host port=5432 user=replicator password=xxx'
-- primary_slot_name = 'standby1_slot'
-- restore_command = 'cp /path/to/archive/%f %p'

-- 4. 重启从库WAL接收进程（带错误处理）
-- 从库执行
DO $$
BEGIN
    BEGIN
        IF pg_is_in_recovery() THEN
            PERFORM pg_wal_replay_resume();  -- 如果暂停了
            RAISE NOTICE 'WAL重放已恢复';
        ELSE
            RAISE NOTICE '当前不在恢复模式，跳过WAL重放恢复';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '恢复WAL重放失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 5. 重新同步（如果数据不一致）
-- 使用pg_basebackup重新同步（需要在命令行执行）
-- pg_basebackup -h primary_host -D /var/lib/postgresql/data -U replicator -v -P -W
```

---

## 案例3：逻辑复制延迟

### 症状

```text
逻辑复制订阅延迟
pg_stat_subscription显示延迟
数据不同步
```

### 诊断

```sql
-- 检查订阅状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_stat_subscription') THEN
            RAISE WARNING 'pg_stat_subscription视图不存在（可能需要PostgreSQL 10+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查订阅状态';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    subid,
    subname,
    pid,
    relid,
    received_lsn,
    last_msg_send_time,
    last_msg_receipt_time,
    latest_end_lsn,
    latest_end_time
FROM pg_stat_subscription;

-- 检查复制槽状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查复制槽状态';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    slot_name,
    slot_type,
    database,
    active,
    restart_lsn,
    confirmed_flush_lsn,
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            confirmed_flush_lsn
        )
    ) AS lag_size
FROM pg_replication_slots
WHERE slot_type = 'logical';

-- 检查发布端状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_publication') THEN
            RAISE WARNING 'pg_publication视图不存在（可能需要PostgreSQL 10+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查发布端状态';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pubname,
    puballtables,
    pubinsert,
    pubupdate,
    pubdelete,
    pubtruncate
FROM pg_publication;

-- 检查订阅端状态（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_subscription') THEN
            RAISE WARNING 'pg_subscription视图不存在（可能需要PostgreSQL 10+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查订阅端状态';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    subname,
    subenabled,
    subpublications
FROM pg_subscription;
```

### 解决

```sql
-- 1. 检查订阅进程（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查订阅进程';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    application_name,
    state,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE backend_type = 'logical replication worker';

-- 2. 优化逻辑复制配置
-- 发布端
max_replication_slots = 10
max_wal_senders = 10
wal_level = logical

-- 订阅端
max_logical_replication_workers = 4
max_sync_workers_per_subscription = 2

-- 3. 检查表大小（大表可能延迟）（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查表大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- 4. 重新同步特定表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_subscription WHERE subname = 'my_subscription') THEN
            RAISE WARNING '订阅 my_subscription 不存在';
            RETURN;
        END IF;

        ALTER SUBSCRIPTION my_subscription REFRESH PUBLICATION;
        ALTER SUBSCRIPTION my_subscription SET (synchronous_commit = off);
        RAISE NOTICE '订阅 my_subscription 已刷新并设置synchronous_commit=off';
    EXCEPTION
        WHEN undefined_object THEN
            RAISE WARNING '订阅 my_subscription 不存在';
        WHEN OTHERS THEN
            RAISE WARNING '刷新订阅失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 5. 监控复制延迟（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_views WHERE viewname = 'replication_lag') THEN
            RAISE NOTICE '视图 replication_lag 已存在';
        ELSE
            CREATE VIEW replication_lag AS
            SELECT
                slot_name,
                pg_size_pretty(
                    pg_wal_lsn_diff(
                        pg_current_wal_lsn(),
            confirmed_flush_lsn
        )
    ) AS lag_size,
    pg_wal_lsn_diff(
        pg_current_wal_lsn(),
        confirmed_flush_lsn
    ) / 1024 / 1024 AS lag_mb
FROM pg_replication_slots
WHERE slot_type = 'logical';
```

---

## 案例4：复制冲突

### 症状

```text
从库日志：conflict with recovery
查询被取消
数据不一致
```

### 诊断

```sql
-- 检查冲突统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_stat_database_conflicts') THEN
            RAISE WARNING 'pg_stat_database_conflicts视图不存在（可能需要PostgreSQL 9.2+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查冲突统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    confl_tablespace,
    confl_lock,
    confl_snapshot,
    confl_bufferpin,
    confl_deadlock
FROM pg_stat_database_conflicts;

-- 检查从库查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查从库查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    query_start
FROM pg_stat_activity
WHERE datname = current_database()
  AND state = 'active';
```

### 解决

```sql
-- 1. 设置冲突处理策略
-- postgresql.conf (从库)
max_standby_streaming_delay = 30s  -- 允许延迟30秒
hot_standby_feedback = on  -- 向主库反馈查询信息

-- 2. 取消长时间运行的查询（带错误处理）
-- 从库执行
DO $$
DECLARE
    cancelled_count int := 0;
    backend_record RECORD;
BEGIN
    BEGIN
        FOR backend_record IN
            SELECT pid FROM pg_stat_activity
            WHERE state = 'active'
              AND now() - query_start > interval '30 seconds'
        LOOP
            BEGIN
                PERFORM pg_cancel_backend(backend_record.pid);
                cancelled_count := cancelled_count + 1;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE WARNING '取消进程 % 失败: %', backend_record.pid, SQLERRM;
            END;
        END LOOP;
        RAISE NOTICE '已取消 % 个长时间运行的查询', cancelled_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '取消查询失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 使用只读查询（避免冲突，带错误处理）
-- 设置事务为只读
DO $$
BEGIN
    BEGIN
        SET TRANSACTION READ ONLY;
        RAISE NOTICE '事务已设置为只读模式';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置只读事务失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 4. 检查表锁冲突（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'problematic_table') THEN
            RAISE WARNING '表 problematic_table 不存在，无法检查锁冲突';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查表锁冲突';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    l.pid,
    l.mode,
    l.granted,
    a.query,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.relation = 'problematic_table'::regclass;
```

---

**文档完成** ✅
