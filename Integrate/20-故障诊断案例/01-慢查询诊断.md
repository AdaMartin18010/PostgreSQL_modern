---

> **📋 文档来源**: `DataBaseTheory\20-故障诊断案例库\01-慢查询诊断.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

> **⚠️ 重要提示**: 本文档遵循故障诊断通用模板格式。
>
> **推荐阅读**:
>
> - [故障诊断通用模板](./故障诊断通用模板.md) - 通用诊断格式和最佳实践
>
> 本文档保留作为慢查询诊断的详细案例参考。

---

# 慢查询诊断案例

> **PostgreSQL 18**

---

## 案例1：缺失索引

### 症状

```sql
-- 查询慢（15秒）（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders WHERE customer_id = 12345
LIMIT 100;
```

### 诊断

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE customer_id = 12345;

/*
Seq Scan on orders (cost=0.00..150000.00 rows=1250 width=120)
                   (actual time=0.5..15000ms rows=1250 loops=1)
  Filter: (customer_id = 12345)
  Rows Removed by Filter: 9998750
  Buffers: shared hit=75000
*/

-- 问题：全表扫描，扫描1000万行
```

### 解决

```sql
-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_customer') THEN
                CREATE INDEX idx_orders_customer ON orders(customer_id);
                RAISE NOTICE '索引创建成功';
            ELSE
                RAISE NOTICE '索引已存在';
            END IF;
        ELSE
            RAISE WARNING '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询时间：15秒 → 8ms（-99.9%）
```

---

## 案例2：统计信息过期

### 症状

```sql
-- JOIN查询慢（45秒）（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date = '2025-12-04'
LIMIT 100;
```

### 诊断

```sql
EXPLAIN (ANALYZE, BUFFERS, TIMING) ...

/*
Hash Join (cost=... rows=100 width=...)  -- 估计100行
           (actual time=... rows=125000 ...)  -- 实际125000行
  -- 基数估计严重偏离
*/

-- 检查统计信息
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE tablename = 'orders';
```

### 解决

```sql
-- 更新统计信息（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            ANALYZE orders;
            RAISE NOTICE '统计信息更新成功';
        ELSE
            RAISE WARNING '表 orders 不存在，跳过统计信息更新';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '更新统计信息失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ⭐ PostgreSQL 18：创建多变量统计（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (
                SELECT 1 FROM pg_statistic_ext
                WHERE stxname = 'orders_stats'
            ) THEN
                CREATE STATISTICS orders_stats (dependencies, ndistinct)
                ON customer_id, order_date FROM orders;
                RAISE NOTICE '多变量统计创建成功';
            ELSE
                RAISE NOTICE '多变量统计已存在';
            END IF;

            ANALYZE orders;
        ELSE
            RAISE WARNING '表 orders 不存在，跳过多变量统计创建';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '统计已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建多变量统计失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询时间：45秒 → 6秒（-87%）
```

---

## 案例3：N+1查询

### 症状

```python
# 应用代码
for order in orders:
    customer = db.query("SELECT * FROM customers WHERE id = ?", order.customer_id)
    # 执行1000次查询！
```

### 诊断

```sql
-- pg_stat_statements显示（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT query, calls FROM pg_stat_statements
WHERE query LIKE '%customers WHERE id%'
LIMIT 100;

-- calls = 1000（异常高）
```

### 解决

```python
# 使用JOIN一次查询
orders_with_customers = db.query("""
    SELECT o.*, c.*
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
    WHERE o.order_date = '2025-12-04'
""")

# 查询次数：1000 → 1
# 时间：10秒 → 0.5秒（-95%）
```

---

## 案例4：PostgreSQL 18优化案例

### 症状

```sql
-- 复杂聚合查询慢（30秒）（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    product_id,
    SUM(amount) as total_amount,
    COUNT(*) as order_count
FROM orders
WHERE order_date >= '2024-01-01'
GROUP BY product_id
LIMIT 100;
```

### 诊断

```sql
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT product_id, SUM(amount), COUNT(*)
FROM orders
WHERE order_date >= '2024-01-01'
GROUP BY product_id;

/*
Gather (cost=... rows=...)
  Workers Planned: 0  -- 未使用并行！
  -> GroupAggregate
      -> Seq Scan on orders
*/

-- 问题：未启用并行查询
```

### 解决

```sql
-- PostgreSQL 18并行查询优化（带错误处理）
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser')::boolean THEN
            ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
            ALTER SYSTEM SET max_parallel_workers = 8;
            PERFORM pg_reload_conf();
            RAISE NOTICE '并行查询配置已更新，配置已重新加载';
        ELSE
            RAISE EXCEPTION '需要超级用户权限才能修改系统配置';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法修改系统配置';
            RAISE;
        WHEN OTHERS THEN
            RAISE WARNING '设置并行查询配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 重新执行查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT product_id, SUM(amount), COUNT(*)
FROM orders
WHERE order_date >= '2024-01-01'
GROUP BY product_id
LIMIT 100;
```

/*
Gather (cost=... rows=...)
  Workers Planned: 4  -- 使用4个并行worker
  -> Parallel Seq Scan on orders
*/

-- 查询时间：30秒 → 8秒（-73%）
```

---

## 案例5：Skip Scan优化案例

### 症状

```sql
-- 稀疏条件查询慢（5秒）
SELECT * FROM products
WHERE status = 'active' AND category = 'electronics'
ORDER BY sales_count DESC
LIMIT 100;
```

### 诊断

```sql
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM products
WHERE status = 'active' AND category = 'electronics'
ORDER BY sales_count DESC
LIMIT 100;

/*
Index Scan using idx_products_status_category
  Filter: (status = 'active'::text AND category = 'electronics'::text)
  Rows Removed by Filter: 999900  -- 过滤掉99.99%的行
*/

-- 问题：稀疏条件，传统索引扫描效率低
```

### 解决

```sql
-- PostgreSQL 18 Skip Scan优化
-- 自动优化，无需额外配置

-- 查询时间：5秒 → 2秒（-60%）
```

---

## 案例6：统计信息自动更新

### 症状

```sql
-- 查询计划突然变差
SELECT * FROM orders
WHERE customer_id = 12345 AND order_date = '2024-12-04';
```

### 诊断

```sql
-- 检查统计信息更新时间
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze,
    n_mod_since_analyze
FROM pg_stat_user_tables
WHERE tablename = 'orders';

/*
last_analyze: 2024-12-01 10:00:00
n_mod_since_analyze: 5000000  -- 500万行变更未分析
*/

-- 问题：统计信息过期
```

### 解决

```sql
-- PostgreSQL 18自动ANALYZE优化
-- 1. 降低自动ANALYZE阈值
ALTER TABLE orders SET (
    autovacuum_analyze_scale_factor = 0.01,  -- 1%变更即分析
    autovacuum_analyze_threshold = 1000
);

-- 2. 手动触发ANALYZE
ANALYZE orders;

-- 查询计划恢复正常
```

---

## 诊断工具和脚本

### 慢查询分析脚本

**慢查询分析函数**：

```sql
-- 慢查询分析函数
CREATE OR REPLACE FUNCTION analyze_slow_queries(
    p_min_time_ms NUMERIC DEFAULT 1000,
    p_limit INT DEFAULT 20
)
RETURNS TABLE (
    query_id BIGINT,
    query_text TEXT,
    calls BIGINT,
    total_time_ms NUMERIC,
    mean_time_ms NUMERIC,
    max_time_ms NUMERIC,
    stddev_time_ms NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        queryid,
        LEFT(query, 200)::TEXT,
        calls,
        ROUND(total_exec_time, 2),
        ROUND(mean_exec_time, 2),
        ROUND(max_exec_time, 2),
        ROUND(stddev_exec_time, 2)
    FROM pg_stat_statements
    WHERE mean_exec_time > p_min_time_ms
      AND calls > 10
    ORDER BY mean_exec_time DESC
    LIMIT p_limit;

    RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '分析慢查询失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 查询计划对比工具

**查询计划对比函数**：

```sql
-- 查询计划对比函数
CREATE OR REPLACE FUNCTION compare_query_plans(
    p_query TEXT
)
RETURNS TABLE (
    plan_type TEXT,
    execution_time_ms NUMERIC,
    buffer_hits BIGINT,
    buffer_reads BIGINT,
    rows_estimated BIGINT,
    rows_actual BIGINT
) AS $$
DECLARE
    plan_result RECORD;
BEGIN
    -- 执行查询并获取计划
    EXECUTE format('EXPLAIN (ANALYZE, BUFFERS, TIMING) %s', p_query)
    INTO plan_result;

    -- 解析计划结果（简化处理）
    RETURN QUERY SELECT
        'current'::TEXT,
        1000.0::NUMERIC,  -- 示例值
        1000::BIGINT,
        100::BIGINT,
        1000::BIGINT,
        1000::BIGINT;

    RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '对比查询计划失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## PostgreSQL 18优化建议

### 优化建议总结

**PostgreSQL 18慢查询优化建议**：

1. ✅ **并行查询**: 启用并行查询优化聚合和JOIN
2. ✅ **Skip Scan**: 利用Skip Scan优化稀疏条件查询
3. ✅ **统计信息**: 使用扩展统计和多变量统计
4. ✅ **异步I/O**: 启用异步I/O优化批量操作
5. ✅ **索引优化**: 使用并行索引构建

---

**文档完成** ✅
**字数**: ~3,200字
**最后更新**: 2025年1月
**状态**: ✅ 完成
