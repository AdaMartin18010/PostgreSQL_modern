---

> **📋 文档来源**: `DataBaseTheory\20-故障诊断案例库\03-内存溢出诊断.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

> **⚠️ 重要提示**: 本文档遵循故障诊断通用模板格式。
>
> **推荐阅读**:
>
> - [故障诊断通用模板](./故障诊断通用模板.md) - 通用诊断格式和最佳实践
>
> 本文档保留作为内存溢出诊断的详细案例参考。

---

# 内存溢出诊断案例

> **PostgreSQL 18**

---

## 案例1：work_mem溢出

### 症状

```text
系统日志：
temporary file: path "base/pgsql_tmp/pgsql_tmp12345.0", size 8589934592
查询：ORDER BY操作慢
```

### 诊断

```sql
-- 查看临时文件使用（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    temp_files,
    temp_bytes,
    pg_size_pretty(temp_bytes) as temp_size
FROM pg_stat_database
WHERE datname = current_database()
LIMIT 100;

/*
temp_files: 150
temp_bytes: 85899345920 (80GB!)
*/

-- 查看当前work_mem（带错误处理）
DO $$
DECLARE
    work_mem_value text;
BEGIN
    BEGIN
        SHOW work_mem INTO work_mem_value;
        RAISE NOTICE '当前work_mem值: %', work_mem_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取work_mem值失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 解决

```sql
-- 方案1：增加work_mem（会话级）（带错误处理）
DO $$
BEGIN
    BEGIN
        SET work_mem = '256MB';
        RAISE NOTICE 'work_mem参数设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置work_mem参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 方案2：优化查询（带性能测试）
-- 原查询
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders
WHERE order_date > '2025-01-01'
ORDER BY amount DESC
LIMIT 100;

-- 优化：先过滤再排序（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders
WHERE order_date > '2025-01-01'
  AND amount > 1000  -- 增加过滤
ORDER BY amount DESC
LIMIT 1000;  -- 限制结果

-- 方案3：创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (
                SELECT 1 FROM pg_indexes
                WHERE tablename = 'orders' AND indexname = 'idx_orders_amount'
            ) THEN
                CREATE INDEX idx_orders_amount ON orders(amount DESC)
                WHERE order_date > '2025-01-01';
                RAISE NOTICE '索引创建成功';
            ELSE
                RAISE NOTICE '索引已存在';
            END IF;
        ELSE
            RAISE WARNING '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例2：OOM Killer

### 症状

```text
系统日志：
Out of memory: Kill process 12345 (postgres) score 850
数据库进程被杀
连接断开
```

### 诊断

```sql
-- ⭐ PostgreSQL 18：增强的内存诊断（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    type,  -- 新增
    path,  -- 新增
    pg_size_pretty(total_bytes) as total,
    pg_size_pretty(used_bytes) as used,
    pg_size_pretty(free_bytes) as free
FROM pg_backend_memory_contexts
WHERE used_bytes > 100 * 1024 * 1024  -- >100MB
ORDER BY used_bytes DESC
LIMIT 100;

/*
name: ExecutorState
type: AllocSet
used: 15GB (异常大！)
*/

-- 查看查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT pid, query, state, backend_type
FROM pg_stat_activity
WHERE pid = 12345
LIMIT 100;
```

### 解决

```sql
-- 1. 找到问题查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    query,
    state,
    pg_size_pretty(
        (SELECT sum(used_bytes)
         FROM pg_backend_memory_contexts
         WHERE pid = pg_stat_activity.pid)
    ) as mem_used
FROM pg_stat_activity
WHERE pid != pg_backend_pid()
ORDER BY (
    SELECT sum(used_bytes)
    FROM pg_backend_memory_contexts
    WHERE pid = pg_stat_activity.pid
) DESC
LIMIT 100;

-- 2. 杀死问题查询（带错误处理）
DO $$
DECLARE
    target_pid int := 12345;  -- 替换为实际的问题进程ID
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_stat_activity WHERE pid = target_pid) THEN
            PERFORM pg_cancel_backend(target_pid);
            RAISE NOTICE '进程 % 已取消', target_pid;
        ELSE
            RAISE WARNING '进程 % 不存在', target_pid;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '取消进程失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 优化查询
-- 避免：SELECT * FROM huge_table
-- 使用：SELECT id, name FROM huge_table LIMIT 1000

-- 4. 配置限制（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_user') THEN
            ALTER ROLE app_user SET work_mem = '128MB';
            RAISE NOTICE 'app_user的work_mem参数设置成功';
        ELSE
            RAISE WARNING '角色 app_user 不存在，跳过设置';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法设置角色参数';
        WHEN OTHERS THEN
            RAISE WARNING '设置角色参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例3：shared_buffers不足

### 症状

```text
缓存命中率低：70%（应该>95%）
I/O高
查询慢
```

### 诊断

```sql
-- 检查缓存命中率（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sum(heap_blks_hit) * 100.0 /
    NULLIF(sum(heap_blks_hit + heap_blks_read), 0) as cache_hit_ratio
FROM pg_statio_user_tables
LIMIT 100;

-- 70%（太低）

-- 检查shared_buffers（带错误处理）
DO $$
DECLARE
    shared_buffers_value text;
BEGIN
    BEGIN
        SHOW shared_buffers INTO shared_buffers_value;
        RAISE NOTICE '当前shared_buffers值: %', shared_buffers_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取shared_buffers值失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 解决

```ini
# postgresql.conf
# 设置为物理内存的25%
shared_buffers = 32GB

# 重启PostgreSQL
pg_ctl restart
```

---

## 案例4：PostgreSQL 18内存诊断增强

### 症状

```text
数据库内存使用异常高
OOM Killer频繁触发
```

### 诊断

```sql
-- PostgreSQL 18增强的内存诊断（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    type,
    path,
    pg_size_pretty(total_bytes) as total,
    pg_size_pretty(used_bytes) as used,
    pg_size_pretty(free_bytes) as free,
    ROUND(100.0 * used_bytes / NULLIF(total_bytes, 0), 2) as usage_pct
FROM pg_backend_memory_contexts
WHERE used_bytes > 100 * 1024 * 1024  -- >100MB
ORDER BY used_bytes DESC
LIMIT 100;

/*
name: ExecutorState
type: AllocSet
used: 15GB
usage_pct: 95%
*/

-- 问题：执行器状态占用内存过大
```

### 解决

```sql
-- 1. 查找问题查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    LEFT(query, 200) as query_preview,
    state,
    pg_size_pretty(
        (SELECT sum(used_bytes)
         FROM pg_backend_memory_contexts
         WHERE pid = pg_stat_activity.pid)
    ) as mem_used
FROM pg_stat_activity
WHERE pid != pg_backend_pid()
ORDER BY (
    SELECT sum(used_bytes)
    FROM pg_backend_memory_contexts
    WHERE pid = pg_stat_activity.pid
) DESC
LIMIT 10;

-- 2. 优化查询或终止问题查询（带错误处理）
DO $$
DECLARE
    target_pid int := 12345;  -- 替换为实际的问题进程ID
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_stat_activity WHERE pid = target_pid) THEN
            PERFORM pg_terminate_backend(target_pid);
            RAISE NOTICE '进程 % 已终止', target_pid;
        ELSE
            RAISE WARNING '进程 % 不存在', target_pid;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '终止进程失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例5：连接内存溢出

### 症状

```text
max_connections = 200
work_mem = 256MB
总内存需求：200 × 256MB = 51.2GB
系统内存：32GB
OOM！
```

### 诊断

```sql
-- 检查连接数和work_mem
SELECT
    setting::INTEGER as max_connections,
    (SELECT setting FROM pg_settings WHERE name = 'work_mem')::TEXT as work_mem,
    COUNT(*) as current_connections,
    COUNT(*) FILTER (WHERE state = 'active') as active_connections
FROM pg_settings
CROSS JOIN pg_stat_activity
WHERE name = 'max_connections'
GROUP BY setting;

-- 计算内存需求
SELECT
    max_connections * work_mem_bytes / 1024 / 1024 / 1024 as total_mem_gb
FROM (
    SELECT
        (SELECT setting::INTEGER FROM pg_settings WHERE name = 'max_connections') as max_connections,
        (SELECT setting::BIGINT FROM pg_settings WHERE name = 'work_mem') as work_mem_bytes
) settings;
```

### 解决

```sql
-- 1. 降低work_mem
ALTER SYSTEM SET work_mem = '64MB';

-- 2. 降低max_connections（使用连接池）
ALTER SYSTEM SET max_connections = 100;

-- 3. 使用连接池（pgBouncer）
-- 连接池模式：transaction
-- 实际数据库连接：20-50个
```

---

## 案例6：临时表内存溢出

### 症状

```sql
-- 复杂查询使用临时表
CREATE TEMP TABLE temp_results AS
SELECT ... FROM huge_table ...;

-- 临时表过大，内存溢出
```

### 诊断

```sql
-- 查看临时表大小
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname LIKE 'pg_temp%';

-- 查看临时文件使用
SELECT
    datname,
    temp_files,
    temp_bytes,
    pg_size_pretty(temp_bytes) as temp_size
FROM pg_stat_database
WHERE datname = current_database();
```

### 解决

```sql
-- 1. 增加work_mem（会话级）
SET work_mem = '512MB';

-- 2. 优化查询，避免临时表
-- 原查询：使用临时表
CREATE TEMP TABLE temp_results AS SELECT ...;
SELECT * FROM temp_results;

-- 优化：直接查询
SELECT ... FROM huge_table ...;

-- 3. 使用物化视图替代临时表
CREATE MATERIALIZED VIEW results_cache AS
SELECT ... FROM huge_table ...;
```

---

## 诊断工具和脚本

### 内存使用分析脚本

**内存使用分析函数**：

```sql
-- 内存使用分析函数
CREATE OR REPLACE FUNCTION analyze_memory_usage()
RETURNS TABLE (
    context_name TEXT,
    context_type TEXT,
    total_size TEXT,
    used_size TEXT,
    free_size TEXT,
    usage_pct NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        name::TEXT,
        type::TEXT,
        pg_size_pretty(total_bytes)::TEXT,
        pg_size_pretty(used_bytes)::TEXT,
        pg_size_pretty(free_bytes)::TEXT,
        ROUND(100.0 * used_bytes / NULLIF(total_bytes, 0), 2)::NUMERIC
    FROM pg_backend_memory_contexts
    WHERE used_bytes > 10 * 1024 * 1024  -- >10MB
    ORDER BY used_bytes DESC;

    RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '分析内存使用失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### OOM预防脚本

**OOM预防函数**：

```sql
-- OOM预防函数
CREATE OR REPLACE FUNCTION prevent_oom()
RETURNS TABLE (
    check_item TEXT,
    current_value TEXT,
    recommended_value TEXT,
    status TEXT
) AS $$
BEGIN
    -- 1. 检查work_mem配置
    RETURN QUERY
    SELECT
        'work_mem配置'::TEXT,
        (SELECT setting FROM pg_settings WHERE name = 'work_mem')::TEXT,
        '64MB'::TEXT,
        CASE
            WHEN (SELECT setting::BIGINT FROM pg_settings WHERE name = 'work_mem') > 128 * 1024 * 1024
            THEN '警告：work_mem过大'
            ELSE '正常'
        END;

    -- 2. 检查max_connections配置
    RETURN QUERY
    SELECT
        'max_connections配置'::TEXT,
        (SELECT setting FROM pg_settings WHERE name = 'max_connections')::TEXT,
        '100'::TEXT,
        CASE
            WHEN (SELECT setting::INTEGER FROM pg_settings WHERE name = 'max_connections') > 200
            THEN '警告：max_connections过大'
            ELSE '正常'
        END;

    RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'OOM预防检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## PostgreSQL 18优化建议

### 优化建议总结

**PostgreSQL 18内存溢出优化建议**：

1. ✅ **内存诊断**: 使用pg_backend_memory_contexts诊断内存使用
2. ✅ **work_mem优化**: 根据查询复杂度调整work_mem
3. ✅ **连接池**: 使用连接池减少连接数
4. ✅ **临时表优化**: 避免使用大型临时表
5. ✅ **查询优化**: 优化查询减少内存使用

---

**文档完成** ✅
**字数**: ~3,200字
**最后更新**: 2025年1月
**状态**: ✅ 完成
