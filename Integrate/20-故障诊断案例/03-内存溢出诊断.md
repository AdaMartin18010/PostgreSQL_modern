---

> **📋 文档来源**: `DataBaseTheory\20-故障诊断案例库\03-内存溢出诊断.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

> **⚠️ 重要提示**: 本文档遵循故障诊断通用模板格式。
>
> **推荐阅读**:
>
> - [故障诊断通用模板](./故障诊断通用模板.md) - 通用诊断格式和最佳实践
>
> 本文档保留作为内存溢出诊断的详细案例参考。

---

# 内存溢出诊断案例

> **PostgreSQL 18**

---

## 案例1：work_mem溢出

### 症状

```text
系统日志：
temporary file: path "base/pgsql_tmp/pgsql_tmp12345.0", size 8589934592
查询：ORDER BY操作慢
```

### 诊断

```sql
-- 查看临时文件使用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始查看临时文件使用情况';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    temp_files,
    temp_bytes,
    pg_size_pretty(temp_bytes) as temp_size
FROM pg_stat_database
WHERE datname = current_database()
LIMIT 100;

/*
temp_files: 150
temp_bytes: 85899345920 (80GB!)
*/

-- 查看当前work_mem（带错误处理）
DO $$
DECLARE
    work_mem_value text;
BEGIN
    BEGIN
        SHOW work_mem INTO work_mem_value;
        RAISE NOTICE '当前work_mem值: %', work_mem_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取work_mem值失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 解决

```sql
-- 方案1：增加work_mem（会话级）（带错误处理）
DO $$
BEGIN
    BEGIN
        SET work_mem = '256MB';
        RAISE NOTICE 'work_mem参数设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置work_mem参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 方案2：优化查询（带错误处理和性能测试）
-- 原查询
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行原查询（work_mem溢出案例）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

-- 执行原查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders
WHERE order_date > '2025-01-01'
ORDER BY amount DESC
LIMIT 100;

-- 优化：先过滤再排序（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行优化查询（增加过滤条件）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

-- 执行优化查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders
WHERE order_date > '2025-01-01'
  AND amount > 1000  -- 增加过滤
ORDER BY amount DESC
LIMIT 1000;  -- 限制结果

-- 方案3：创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (
                SELECT 1 FROM pg_indexes
                WHERE tablename = 'orders' AND indexname = 'idx_orders_amount'
            ) THEN
                CREATE INDEX idx_orders_amount ON orders(amount DESC)
                WHERE order_date > '2025-01-01';
                RAISE NOTICE '索引创建成功';
            ELSE
                RAISE NOTICE '索引已存在';
            END IF;
        ELSE
            RAISE WARNING '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例2：OOM Killer

### 症状

```text
系统日志：
Out of memory: Kill process 12345 (postgres) score 850
数据库进程被杀
连接断开
```

### 诊断

```sql
-- ⭐ PostgreSQL 18：增强的内存诊断（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_backend_memory_contexts') THEN
            RAISE WARNING 'pg_backend_memory_contexts视图不存在（可能需要PostgreSQL 18+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始查看PostgreSQL 18增强的内存诊断';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

-- 查询内存上下文（带性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_backend_memory_contexts') THEN
            RAISE WARNING 'pg_backend_memory_contexts视图不存在（可能需要PostgreSQL 18+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始查询内存上下文';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    type,  -- 新增
    path,  -- 新增
    pg_size_pretty(total_bytes) as total,
    pg_size_pretty(used_bytes) as used,
    pg_size_pretty(free_bytes) as free
FROM pg_backend_memory_contexts
WHERE used_bytes > 100 * 1024 * 1024  -- >100MB
ORDER BY used_bytes DESC
LIMIT 100;

/*
name: ExecutorState
type: AllocSet
used: 15GB (异常大！)
*/

-- 查看查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始查看查询信息';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

-- 查询进程信息（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT pid, query, state, backend_type
FROM pg_stat_activity
WHERE pid = 12345
LIMIT 100;
```

### 解决

```sql
-- 1. 找到问题查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_backend_memory_contexts') THEN
            RAISE WARNING 'pg_backend_memory_contexts视图不存在（可能需要PostgreSQL 18+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始查找问题查询（内存使用）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    query,
    state,
    pg_size_pretty(
        (SELECT sum(used_bytes)
         FROM pg_backend_memory_contexts
         WHERE pid = pg_stat_activity.pid)
    ) as mem_used
FROM pg_stat_activity
WHERE pid != pg_backend_pid()
ORDER BY (
    SELECT sum(used_bytes)
    FROM pg_backend_memory_contexts
    WHERE pid = pg_stat_activity.pid
) DESC
LIMIT 100;

-- 2. 杀死问题查询（带错误处理）
DO $$
DECLARE
    target_pid int := 12345;  -- 替换为实际的问题进程ID
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_stat_activity WHERE pid = target_pid) THEN
            PERFORM pg_cancel_backend(target_pid);
            RAISE NOTICE '进程 % 已取消', target_pid;
        ELSE
            RAISE WARNING '进程 % 不存在', target_pid;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '取消进程失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 优化查询
-- 避免：SELECT * FROM huge_table
-- 使用：SELECT id, name FROM huge_table LIMIT 1000

-- 4. 配置限制（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_user') THEN
            ALTER ROLE app_user SET work_mem = '128MB';
            RAISE NOTICE 'app_user的work_mem参数设置成功';
        ELSE
            RAISE WARNING '角色 app_user 不存在，跳过设置';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法设置角色参数';
        WHEN OTHERS THEN
            RAISE WARNING '设置角色参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例3：shared_buffers不足

### 症状

```text
缓存命中率低：70%（应该>95%）
I/O高
查询慢
```

### 诊断

```sql
-- 检查缓存命中率（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查缓存命中率';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sum(heap_blks_hit) * 100.0 /
    NULLIF(sum(heap_blks_hit + heap_blks_read), 0) as cache_hit_ratio
FROM pg_statio_user_tables
LIMIT 100;

-- 70%（太低）

-- 检查shared_buffers（带错误处理）
DO $$
DECLARE
    shared_buffers_value text;
BEGIN
    BEGIN
        SHOW shared_buffers INTO shared_buffers_value;
        RAISE NOTICE '当前shared_buffers值: %', shared_buffers_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取shared_buffers值失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 解决

```ini
# postgresql.conf
# 设置为物理内存的25%
shared_buffers = 32GB

# 重启PostgreSQL
pg_ctl restart
```

---

## 案例4：PostgreSQL 18内存诊断增强

### 症状

```text
数据库内存使用异常高
OOM Killer频繁触发
```

### 诊断

```sql
-- PostgreSQL 18增强的内存诊断（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_backend_memory_contexts') THEN
            RAISE WARNING 'pg_backend_memory_contexts视图不存在（可能需要PostgreSQL 18+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始查看PostgreSQL 18增强的内存诊断';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    type,
    path,
    pg_size_pretty(total_bytes) as total,
    pg_size_pretty(used_bytes) as used,
    pg_size_pretty(free_bytes) as free,
    ROUND(100.0 * used_bytes / NULLIF(total_bytes, 0), 2) as usage_pct
FROM pg_backend_memory_contexts
WHERE used_bytes > 100 * 1024 * 1024  -- >100MB
ORDER BY used_bytes DESC
LIMIT 100;

/*
name: ExecutorState
type: AllocSet
used: 15GB
usage_pct: 95%
*/

-- 问题：执行器状态占用内存过大
```

### 解决

```sql
-- 1. 查找问题查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'pg_backend_memory_contexts') THEN
            RAISE WARNING 'pg_backend_memory_contexts视图不存在（可能需要PostgreSQL 18+）';
            RETURN;
        END IF;
        RAISE NOTICE '开始查找问题查询（内存使用）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    LEFT(query, 200) as query_preview,
    state,
    pg_size_pretty(
        (SELECT sum(used_bytes)
         FROM pg_backend_memory_contexts
         WHERE pid = pg_stat_activity.pid)
    ) as mem_used
FROM pg_stat_activity
WHERE pid != pg_backend_pid()
ORDER BY (
    SELECT sum(used_bytes)
    FROM pg_backend_memory_contexts
    WHERE pid = pg_stat_activity.pid
) DESC
LIMIT 10;

-- 2. 优化查询或终止问题查询（带错误处理）
DO $$
DECLARE
    target_pid int := 12345;  -- 替换为实际的问题进程ID
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_stat_activity WHERE pid = target_pid) THEN
            PERFORM pg_terminate_backend(target_pid);
            RAISE NOTICE '进程 % 已终止', target_pid;
        ELSE
            RAISE WARNING '进程 % 不存在', target_pid;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '终止进程失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 案例5：连接内存溢出

### 症状

```text
max_connections = 200
work_mem = 256MB
总内存需求：200 × 256MB = 51.2GB
系统内存：32GB
OOM！
```

### 诊断

```sql
-- 检查连接数和work_mem（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查连接数和work_mem';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    setting::INTEGER as max_connections,
    (SELECT setting FROM pg_settings WHERE name = 'work_mem')::TEXT as work_mem,
    COUNT(*) as current_connections,
    COUNT(*) FILTER (WHERE state = 'active') as active_connections
FROM pg_settings
CROSS JOIN pg_stat_activity
WHERE name = 'max_connections'
GROUP BY setting;

-- 计算内存需求（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始计算内存需求';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    max_connections * work_mem_bytes / 1024 / 1024 / 1024 as total_mem_gb
FROM (
    SELECT
        (SELECT setting::INTEGER FROM pg_settings WHERE name = 'max_connections') as max_connections,
        (SELECT setting::BIGINT FROM pg_settings WHERE name = 'work_mem') as work_mem_bytes
) settings;
```

### 解决

```sql
-- 1. 降低work_mem（带错误处理）
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser')::boolean THEN
            ALTER SYSTEM SET work_mem = '64MB';
            RAISE NOTICE 'work_mem已设置为64MB';
        ELSE
            RAISE NOTICE '需要超级用户权限才能设置系统参数';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法设置系统参数';
        WHEN OTHERS THEN
            RAISE WARNING '设置work_mem失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 降低max_connections（使用连接池，带错误处理）
DO $$
BEGIN
    BEGIN
        IF current_setting('is_superuser')::boolean THEN
            ALTER SYSTEM SET max_connections = 100;
            RAISE NOTICE 'max_connections已设置为100';
        ELSE
            RAISE NOTICE '需要超级用户权限才能设置系统参数';
        END IF;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE WARNING '权限不足，无法设置系统参数';
        WHEN OTHERS THEN
            RAISE WARNING '设置max_connections失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 使用连接池（pgBouncer）
-- 连接池模式：transaction
-- 实际数据库连接：20-50个
```

---

## 案例6：临时表内存溢出

### 症状

```sql
-- 复杂查询使用临时表
CREATE TEMP TABLE temp_results AS
SELECT ... FROM huge_table ...;

-- 临时表过大，内存溢出
```

### 诊断

```sql
-- 查看临时表大小（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始查看临时表大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname LIKE 'pg_temp%';

-- 查看临时文件使用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始查看临时文件使用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    temp_files,
    temp_bytes,
    pg_size_pretty(temp_bytes) as temp_size
FROM pg_stat_database
WHERE datname = current_database();
```

### 解决

```sql
-- 1. 增加work_mem（会话级，带错误处理）
DO $$
BEGIN
    BEGIN
        SET work_mem = '512MB';
        RAISE NOTICE 'work_mem已设置为512MB（会话级）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置work_mem失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 优化查询，避免临时表（带错误处理）
-- 原查询：使用临时表
DO $$
BEGIN
    BEGIN
        RAISE WARNING '不推荐使用临时表，可能导致内存溢出';
        -- CREATE TEMP TABLE temp_results AS SELECT ...;
        -- SELECT * FROM temp_results;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '临时表操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 优化：直接查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'huge_table') THEN
            RAISE WARNING '表 huge_table 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行优化查询（直接查询，避免临时表）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT ... FROM huge_table ...;

-- 3. 使用物化视图替代临时表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'results_cache') THEN
            RAISE NOTICE '物化视图 results_cache 已存在';
        ELSE
            CREATE MATERIALIZED VIEW results_cache AS
            SELECT ... FROM huge_table ...;
            RAISE NOTICE '物化视图 results_cache 创建成功';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '物化视图 results_cache 已存在';
        WHEN undefined_table THEN
            RAISE WARNING '表 huge_table 不存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建物化视图失败: %', SQLERRM;
            RAISE;
    END;
END $$;

---

## 诊断工具和脚本

### 内存使用分析脚本

**内存使用分析函数**：

```sql
-- 内存使用分析函数（带完整错误处理）
CREATE OR REPLACE FUNCTION analyze_memory_usage()
RETURNS TABLE (
    context_name TEXT,
    context_type TEXT,
    total_size TEXT,
    used_size TEXT,
    free_size TEXT,
    usage_pct NUMERIC
) AS $$
BEGIN
    BEGIN
        -- 检查PostgreSQL版本（pg_backend_memory_contexts需要PostgreSQL 13+）
        IF current_setting('server_version_num')::INTEGER < 130000 THEN
            RAISE EXCEPTION 'pg_backend_memory_contexts需要PostgreSQL 13或更高版本';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '版本检查失败: %', SQLERRM;
    END;

    BEGIN
        RETURN QUERY
        SELECT
            name::TEXT,
            type::TEXT,
            pg_size_pretty(total_bytes)::TEXT,
            pg_size_pretty(used_bytes)::TEXT,
            pg_size_pretty(free_bytes)::TEXT,
            ROUND(100.0 * used_bytes / NULLIF(total_bytes, 0), 2)::NUMERIC
        FROM pg_backend_memory_contexts
        WHERE used_bytes > 10 * 1024 * 1024  -- >10MB
        ORDER BY used_bytes DESC;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION 'pg_backend_memory_contexts视图不存在，需要PostgreSQL 13+';
        WHEN OTHERS THEN
            RAISE WARNING '分析内存使用失败: %', SQLERRM;
            RAISE;
    END;

    RETURN;
END;
$$ LANGUAGE plpgsql;
```

### OOM预防脚本

**OOM预防函数**：

```sql
-- OOM预防函数（带完整错误处理）
CREATE OR REPLACE FUNCTION prevent_oom()
RETURNS TABLE (
    check_item TEXT,
    current_value TEXT,
    recommended_value TEXT,
    status TEXT
) AS $$
DECLARE
    work_mem_setting TEXT;
    max_conn_setting TEXT;
BEGIN
    BEGIN
        -- 1. 检查work_mem配置
        BEGIN
            SELECT setting INTO work_mem_setting
            FROM pg_settings
            WHERE name = 'work_mem';

            IF work_mem_setting IS NULL THEN
                RAISE WARNING '无法获取work_mem配置';
            ELSE
                RETURN QUERY
                SELECT
                    'work_mem配置'::TEXT,
                    work_mem_setting,
                    '64MB'::TEXT,
                    CASE
                        WHEN work_mem_setting::BIGINT > 128 * 1024 * 1024
                        THEN '警告：work_mem过大'
                        ELSE '正常'
                    END;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '检查work_mem配置失败: %', SQLERRM;
        END;

        -- 2. 检查max_connections配置
        BEGIN
            SELECT setting INTO max_conn_setting
            FROM pg_settings
            WHERE name = 'max_connections';

            IF max_conn_setting IS NULL THEN
                RAISE WARNING '无法获取max_connections配置';
            ELSE
                RETURN QUERY
                SELECT
                    'max_connections配置'::TEXT,
                    max_conn_setting,
                    '100'::TEXT,
                    CASE
                        WHEN max_conn_setting::INTEGER > 200
                        THEN '警告：max_connections过大'
                        ELSE '正常'
                    END;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '检查max_connections配置失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'OOM预防检查失败: %', SQLERRM;
            RAISE;
    END;

    RETURN;
END;
$$ LANGUAGE plpgsql;
```

---

## PostgreSQL 18优化建议

### 优化建议总结

**PostgreSQL 18内存溢出优化建议**：

1. ✅ **内存诊断**: 使用pg_backend_memory_contexts诊断内存使用
2. ✅ **work_mem优化**: 根据查询复杂度调整work_mem
3. ✅ **连接池**: 使用连接池减少连接数
4. ✅ **临时表优化**: 避免使用大型临时表
5. ✅ **查询优化**: 优化查询减少内存使用

---

**文档完成** ✅
**字数**: ~3,200字
**最后更新**: 2025年1月
**状态**: ✅ 完成
