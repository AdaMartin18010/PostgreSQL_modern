---

> **📋 文档来源**: `DataBaseTheory\20-故障诊断案例库\02-锁冲突诊断.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

> **⚠️ 重要提示**: 本文档遵循故障诊断通用模板格式。
>
> **推荐阅读**:
>
> - [故障诊断通用模板](./故障诊断通用模板.md) - 通用诊断格式和最佳实践
>
> 本文档保留作为锁冲突诊断的详细案例参考。

---

# 锁冲突诊断案例

> **PostgreSQL 18**

---

## 案例1：长事务阻塞

### 症状

```text
应用报错：timeout waiting for lock
大量查询等待
```

### 诊断

```sql
-- 查找锁等待
SELECT
    blocked.pid AS blocked_pid,
    blocked.query AS blocked_query,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query,
    blocking.state,
    blocking.query_start
FROM pg_stat_activity blocked
JOIN pg_locks blocked_lock ON blocked.pid = blocked_lock.pid
JOIN pg_locks blocking_lock ON blocking_lock.locktype = blocked_lock.locktype
    AND blocking_lock.pid != blocked_lock.pid
JOIN pg_stat_activity blocking ON blocking.pid = blocking_lock.pid
WHERE NOT blocked_lock.granted
  AND blocking_lock.granted;

/*
blocking_pid: 12345
blocking_query: UPDATE orders SET ...（已运行30分钟）
state: idle in transaction  -- 忘记COMMIT！
*/
```

### 解决

```sql
-- 立即：杀死阻塞会话
SELECT pg_terminate_backend(12345);

-- 长期：设置超时
ALTER DATABASE mydb SET statement_timeout = '30s';
ALTER DATABASE mydb SET idle_in_transaction_session_timeout = '10min';
```

---

## 案例2：死锁

### 症状

```text
ERROR: deadlock detected
DETAIL: Process 123 waits for ShareLock on transaction 456
Process 456 waits for ShareLock on transaction 123
```

### 诊断

```sql
-- 查看日志
SELECT * FROM pg_stat_database WHERE datname = current_database();

-- deadlocks字段显示死锁次数

-- 启用死锁日志
ALTER SYSTEM SET deadlock_timeout = '1s';
ALTER SYSTEM SET log_lock_waits = on;
```

### 解决

```sql
-- 代码层面：统一表访问顺序

-- 错误代码（可能死锁）
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';  -- 事务1
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';  -- 事务1

-- 同时
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 'B';  -- 事务2
UPDATE accounts SET balance = balance + 50 WHERE account_id = 'A';  -- 事务2
-- 死锁！

-- 正确代码（按account_id排序）
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';
COMMIT;
```

---

## 案例3：表级锁冲突

### 症状

```sql
-- DDL操作被阻塞
ALTER TABLE orders ADD COLUMN new_col INT;
-- 一直等待...
```

### 诊断

```sql
-- 查看表锁
SELECT
    l.pid,
    l.mode,
    l.granted,
    a.query,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.relation = 'orders'::regclass;

/*
mode: AccessShareLock, granted: true（查询持有）
mode: AccessExclusiveLock, granted: false（DDL等待）
*/
```

### 解决

```sql
-- 方案1：使用CONCURRENTLY（不阻塞）
CREATE INDEX CONCURRENTLY idx_orders_new ON orders(new_col);

-- 方案2：在业务低峰期执行DDL
-- 方案3：使用pg_terminate_backend杀死长查询（谨慎）
```

---

## 案例4：PostgreSQL 18锁优化

### 症状

```sql
-- 高并发场景下锁等待时间长
-- 多个事务同时更新同一行
```

### 诊断

```sql
-- 查看锁等待情况
SELECT
    blocked_locks.pid AS blocked_pid,
    blocking_locks.pid AS blocking_pid,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query,
    blocked_locks.locktype,
    blocked_locks.mode,
    blocking_activity.state,
    blocking_activity.query_start,
    NOW() - blocking_activity.query_start AS blocking_duration
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted
  AND blocking_locks.granted;
```

### 解决

```sql
-- PostgreSQL 18锁优化
-- 1. 优化锁超时
ALTER SYSTEM SET deadlock_timeout = '1s';
ALTER SYSTEM SET lock_timeout = '5s';

-- 2. 使用乐观锁（应用层）
-- 使用版本号字段避免悲观锁

-- 3. 批量操作优化
-- 使用批量更新减少锁持有时间
```

---

## 案例5：表锁优化

### 症状

```sql
-- VACUUM操作阻塞查询
VACUUM FULL orders;
-- 查询被阻塞
```

### 诊断

```sql
-- 查看VACUUM锁
SELECT
    pid,
    locktype,
    mode,
    granted,
    relation::regclass
FROM pg_locks
WHERE locktype = 'relation'
  AND relation = 'orders'::regclass;
```

### 解决

```sql
-- PostgreSQL 18 VACUUM优化
-- 1. 使用CONCURRENTLY选项
VACUUM CONCURRENTLY orders;

-- 2. 使用并行VACUUM
VACUUM (PARALLEL 4) orders;

-- 3. 调整VACUUM参数
ALTER SYSTEM SET vacuum_cost_delay = 0;
ALTER SYSTEM SET vacuum_cost_limit = 2000;
```

---

## 案例6：行锁优化

### 症状

```sql
-- 高并发更新同一表的不同行
-- 出现行锁等待
```

### 诊断

```sql
-- 查看行锁等待
SELECT
    l.pid,
    l.locktype,
    l.mode,
    l.granted,
    l.relation::regclass,
    l.page,
    l.tuple,
    a.query,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.locktype = 'tuple'
  AND NOT l.granted;
```

### 解决

```sql
-- PostgreSQL 18行锁优化
-- 1. 使用SKIP LOCKED（跳过锁定的行）
SELECT * FROM orders
WHERE status = 'pending'
ORDER BY created_at
LIMIT 100
FOR UPDATE SKIP LOCKED;

-- 2. 使用NOWAIT（立即返回错误）
SELECT * FROM orders
WHERE order_id = 12345
FOR UPDATE NOWAIT;

-- 3. 批量处理优化
-- 使用批量更新减少锁竞争
```

---

## 诊断工具和脚本

### 锁等待分析脚本

**锁等待分析函数**：

```sql
-- 锁等待分析函数
CREATE OR REPLACE FUNCTION analyze_lock_waits()
RETURNS TABLE (
    blocked_pid INT,
    blocking_pid INT,
    lock_type TEXT,
    lock_mode TEXT,
    blocked_query TEXT,
    blocking_query TEXT,
    wait_duration INTERVAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        blocked.pid::INT,
        blocking.pid::INT,
        blocked_lock.locktype::TEXT,
        blocked_lock.mode::TEXT,
        LEFT(blocked.query, 200)::TEXT,
        LEFT(blocking.query, 200)::TEXT,
        NOW() - blocking.query_start AS wait_duration
    FROM pg_stat_activity blocked
    JOIN pg_locks blocked_lock ON blocked.pid = blocked_lock.pid
    JOIN pg_locks blocking_lock ON blocking_lock.locktype = blocked_lock.locktype
    JOIN pg_stat_activity blocking ON blocking.pid = blocking_lock.pid
    WHERE NOT blocked_lock.granted
      AND blocking_lock.granted
      AND blocking_lock.pid != blocked_lock.pid;

    RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '分析锁等待失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 死锁检测脚本

**死锁检测函数**：

```sql
-- 死锁检测函数
CREATE OR REPLACE FUNCTION detect_deadlocks()
RETURNS TABLE (
    deadlock_count BIGINT,
    last_deadlock_time TIMESTAMPTZ,
    status TEXT
) AS $$
DECLARE
    deadlock_count_val BIGINT;
BEGIN
    SELECT deadlocks INTO deadlock_count_val
    FROM pg_stat_database
    WHERE datname = current_database();

    RETURN QUERY SELECT
        deadlock_count_val,
        stats_reset,
        CASE
            WHEN deadlock_count_val > 10 THEN '警告'
            WHEN deadlock_count_val > 0 THEN '注意'
            ELSE '正常'
        END;

    RETURN;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检测死锁失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

---

## PostgreSQL 18优化建议

### 优化建议总结

**PostgreSQL 18锁冲突优化建议**：

1. ✅ **锁超时**: 设置合理的锁超时时间
2. ✅ **SKIP LOCKED**: 使用SKIP LOCKED避免等待
3. ✅ **NOWAIT**: 使用NOWAIT立即返回错误
4. ✅ **并行VACUUM**: 使用并行VACUUM减少阻塞
5. ✅ **乐观锁**: 使用版本号实现乐观锁

---

**文档完成** ✅
**字数**: ~3,200字
**最后更新**: 2025年1月
**状态**: ✅ 完成
