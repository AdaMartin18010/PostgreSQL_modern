# PostgreSQL集成测试完整指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级
> **适用场景**: 业务流程测试、数据一致性测试、组件协作测试、端到端测试

---

## 📋 目录

- [PostgreSQL集成测试完整指南](#postgresql集成测试完整指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 集成测试的重要性](#11-集成测试的重要性)
    - [1.2 测试范围](#12-测试范围)
    - [1.3 测试策略](#13-测试策略)
  - [2. 业务流程测试](#2-业务流程测试)
    - [2.1 完整流程测试](#21-完整流程测试)
    - [2.2 订单处理流程](#22-订单处理流程)
    - [2.3 用户注册流程](#23-用户注册流程)
    - [2.4 支付流程](#24-支付流程)
  - [3. 数据一致性测试](#3-数据一致性测试)
    - [3.1 外键约束测试](#31-外键约束测试)
    - [3.2 事务一致性测试](#32-事务一致性测试)
    - [3.3 级联操作测试](#33-级联操作测试)
    - [3.4 数据完整性测试](#34-数据完整性测试)
  - [4. 组件协作测试](#4-组件协作测试)
    - [4.1 函数与触发器协作](#41-函数与触发器协作)
    - [4.2 视图与表协作](#42-视图与表协作)
    - [4.3 存储过程协作](#43-存储过程协作)
  - [5. 并发集成测试](#5-并发集成测试)
    - [5.1 并发事务测试](#51-并发事务测试)
    - [5.2 锁竞争测试](#52-锁竞争测试)
    - [5.3 死锁检测测试](#53-死锁检测测试)
  - [6. 错误处理测试](#6-错误处理测试)
    - [6.1 事务回滚测试](#61-事务回滚测试)
    - [6.2 异常传播测试](#62-异常传播测试)
    - [6.3 错误恢复测试](#63-错误恢复测试)
  - [7. 性能集成测试](#7-性能集成测试)
    - [7.1 查询性能测试](#71-查询性能测试)
    - [7.2 写入性能测试](#72-写入性能测试)
    - [7.3 混合负载测试](#73-混合负载测试)
  - [8. 测试环境设置](#8-测试环境设置)
    - [8.1 测试数据库准备](#81-测试数据库准备)
    - [8.2 测试数据准备](#82-测试数据准备)
    - [8.3 测试环境隔离](#83-测试环境隔离)
  - [9. 测试工具](#9-测试工具)
    - [9.1 pgTAP集成测试](#91-pgtap集成测试)
    - [9.2 自定义测试框架](#92-自定义测试框架)
    - [9.3 测试报告生成](#93-测试报告生成)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 推荐做法](#101-推荐做法)
    - [10.2 常见错误](#102-常见错误)
    - [10.3 测试维护](#103-测试维护)
  - [📚 相关文档](#-相关文档)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
  - [📚 相关文档](#-相关文档-1)

---

## 1. 概述

### 1.1 集成测试的重要性

集成测试验证多个组件协同工作的正确性，确保系统作为一个整体能够正常工作。

**集成测试的价值**：

- **发现接口问题**：及早发现组件间的接口问题
- **验证业务流程**：确保业务流程能够正确执行
- **数据一致性**：确保数据在组件间传递时保持一致
- **性能验证**：验证系统在集成环境下的性能表现

**测试金字塔中的位置**：

```text
        /\
       /  \
      /集成\  ← 集成测试
     / 测试 \
    /--------\
   /  单元    \
  /   测试    \
 /------------\
```

### 1.2 测试范围

**测试范围**:

- **业务流程**：完整的业务流程测试
- **数据一致性**：跨表、跨函数的数据一致性
- **组件协作**：函数、触发器、视图等组件的协作
- **性能要求**：集成环境下的性能表现
- **错误处理**：错误在组件间的传播和处理
- **并发处理**：并发场景下的正确性

### 1.3 测试策略

**测试策略**：

1. **自底向上**：从底层组件开始，逐步向上集成
2. **自顶向下**：从顶层业务流程开始，逐步向下细化
3. **大爆炸**：一次性集成所有组件（不推荐）
4. **三明治**：结合自底向上和自顶向下

---

## 2. 业务流程测试

### 2.1 完整流程测试

**电商订单流程测试**：

```sql
-- 准备测试环境
BEGIN;
SELECT plan(8);

-- 1. 创建用户
INSERT INTO users (name, email) VALUES ('Test User', 'test@example.com');
SELECT ok(
    (SELECT COUNT(*) FROM users WHERE email = 'test@example.com') = 1,
    '用户应该被创建'
);

-- 2. 创建商品
INSERT INTO products (name, price, stock) VALUES ('Test Product', 100, 10);
SELECT ok(
    (SELECT COUNT(*) FROM products WHERE name = 'Test Product') = 1,
    '商品应该被创建'
);

-- 3. 创建订单
INSERT INTO orders (user_id, total_amount, status)
SELECT id, 100, 'pending' FROM users WHERE email = 'test@example.com';
SELECT ok(
    (SELECT COUNT(*) FROM orders WHERE user_id =
     (SELECT id FROM users WHERE email = 'test@example.com')) = 1,
    '订单应该被创建'
);

-- 4. 创建订单项
INSERT INTO order_items (order_id, product_id, quantity, price)
SELECT
    o.id,
    p.id,
    1,
    p.price
FROM orders o
CROSS JOIN products p
WHERE o.user_id = (SELECT id FROM users WHERE email = 'test@example.com')
  AND p.name = 'Test Product';
SELECT ok(
    (SELECT COUNT(*) FROM order_items WHERE order_id =
     (SELECT id FROM orders WHERE user_id =
      (SELECT id FROM users WHERE email = 'test@example.com'))) = 1,
    '订单项应该被创建'
);

-- 5. 更新库存
UPDATE products SET stock = stock - 1 WHERE name = 'Test Product';
SELECT is(
    (SELECT stock FROM products WHERE name = 'Test Product'),
    9,
    '库存应该减少1'
);

-- 6. 支付订单
UPDATE orders SET status = 'paid', paid_at = NOW()
WHERE user_id = (SELECT id FROM users WHERE email = 'test@example.com');
SELECT is(
    (SELECT status FROM orders WHERE user_id =
     (SELECT id FROM users WHERE email = 'test@example.com')),
    'paid',
    '订单状态应该更新为已支付'
);

-- 7. 验证数据一致性
SELECT ok(
    EXISTS (
        SELECT 1 FROM orders o
        JOIN users u ON o.user_id = u.id
        JOIN order_items oi ON o.id = oi.order_id
        JOIN products p ON oi.product_id = p.id
        WHERE u.email = 'test@example.com'
          AND o.status = 'paid'
          AND p.stock = 9
    ),
    '数据应该保持一致'
);

-- 8. 清理测试数据
DELETE FROM order_items WHERE order_id IN (
    SELECT id FROM orders WHERE user_id =
    (SELECT id FROM users WHERE email = 'test@example.com')
);
DELETE FROM orders WHERE user_id = (SELECT id FROM users WHERE email = 'test@example.com');
DELETE FROM products WHERE name = 'Test Product';
DELETE FROM users WHERE email = 'test@example.com';
SELECT ok(
    (SELECT COUNT(*) FROM users WHERE email = 'test@example.com') = 0,
    '测试数据应该被清理'
);

SELECT * FROM finish();
ROLLBACK;
```

### 2.2 订单处理流程

**订单处理完整流程**：

```sql
BEGIN;
SELECT plan(6);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'Customer', 'customer@example.com');
INSERT INTO products (id, name, price, stock) VALUES (1, 'Product', 50, 100);

-- 1. 创建订单
SELECT create_order(1, ARRAY[ROW(1, 2)::order_item]) INTO order_id;
SELECT ok(order_id > 0, '订单应该被创建');

-- 2. 验证订单状态
SELECT is(
    (SELECT status FROM orders WHERE id = order_id),
    'pending',
    '订单初始状态应该是pending'
);

-- 3. 验证库存减少
SELECT is(
    (SELECT stock FROM products WHERE id = 1),
    98,
    '库存应该减少2'
);

-- 4. 支付订单
SELECT pay_order(order_id, 'credit_card', '1234567890') INTO payment_result;
SELECT ok(payment_result, '支付应该成功');

-- 5. 验证订单状态更新
SELECT is(
    (SELECT status FROM orders WHERE id = order_id),
    'paid',
    '订单状态应该更新为paid'
);

-- 6. 发货
SELECT ship_order(order_id, 'SF1234567890') INTO ship_result;
SELECT ok(ship_result, '发货应该成功');
SELECT is(
    (SELECT status FROM orders WHERE id = order_id),
    'shipped',
    '订单状态应该更新为shipped'
);

SELECT * FROM finish();
ROLLBACK;
```

### 2.3 用户注册流程

**用户注册完整流程**：

```sql
BEGIN;
SELECT plan(5);

-- 1. 注册新用户
SELECT register_user('New User', 'newuser@example.com', 'password123') INTO user_id;
SELECT ok(user_id > 0, '用户应该被注册');

-- 2. 验证用户创建
SELECT ok(
    EXISTS (SELECT 1 FROM users WHERE email = 'newuser@example.com'),
    '用户应该存在于数据库中'
);

-- 3. 验证密码加密
SELECT ok(
    (SELECT password FROM users WHERE email = 'newuser@example.com') != 'password123',
    '密码应该被加密'
);

-- 4. 验证验证邮件发送
SELECT ok(
    EXISTS (
        SELECT 1 FROM emails
        WHERE recipient = 'newuser@example.com'
          AND subject LIKE '%验证%'
    ),
    '验证邮件应该被发送'
);

-- 5. 验证用户状态
SELECT is(
    (SELECT status FROM users WHERE email = 'newuser@example.com'),
    'pending_verification',
    '用户状态应该是pending_verification'
);

SELECT * FROM finish();
ROLLBACK;
```

### 2.4 支付流程

**支付完整流程**：

```sql
BEGIN;
SELECT plan(6);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'Customer', 'customer@example.com');
INSERT INTO orders (id, user_id, total_amount, status) VALUES (1, 1, 100, 'pending');
INSERT INTO payment_methods (id, user_id, type, details) VALUES
    (1, 1, 'credit_card', '{"card_number": "1234567890", "expiry": "12/25"}');

-- 1. 发起支付
SELECT process_payment(1, 1, 100) INTO payment_id;
SELECT ok(payment_id > 0, '支付应该被创建');

-- 2. 验证支付状态
SELECT is(
    (SELECT status FROM payments WHERE id = payment_id),
    'processing',
    '支付初始状态应该是processing'
);

-- 3. 模拟支付网关响应
SELECT complete_payment(payment_id, 'success', 'transaction_12345') INTO result;
SELECT ok(result, '支付应该完成');

-- 4. 验证支付状态更新
SELECT is(
    (SELECT status FROM payments WHERE id = payment_id),
    'completed',
    '支付状态应该更新为completed'
);

-- 5. 验证订单状态更新
SELECT is(
    (SELECT status FROM orders WHERE id = 1),
    'paid',
    '订单状态应该更新为paid'
);

-- 6. 验证支付记录
SELECT ok(
    EXISTS (
        SELECT 1 FROM payment_logs
        WHERE payment_id = payment_id
          AND action = 'completed'
    ),
    '支付日志应该被记录'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 3. 数据一致性测试

### 3.1 外键约束测试

**外键约束完整性测试**：

```sql
BEGIN;
SELECT plan(4);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'Test User', 'test@example.com');

-- 测试有效外键
SELECT lives_ok(
    'INSERT INTO orders (user_id, total_amount) VALUES (1, 100)',
    '有效外键应该插入成功'
);

-- 测试无效外键
SELECT throws_ok(
    'INSERT INTO orders (user_id, total_amount) VALUES (999, 100)',
    '23503',
    '无效外键应该违反约束'
);

-- 测试外键约束存在
SELECT ok(
    EXISTS (
        SELECT 1 FROM information_schema.table_constraints
        WHERE table_name = 'orders'
          AND constraint_type = 'FOREIGN KEY'
          AND constraint_name LIKE '%user_id%'
    ),
    '应该存在外键约束'
);

-- 测试级联删除
DELETE FROM users WHERE id = 1;
SELECT ok(
    (SELECT COUNT(*) FROM orders WHERE user_id = 1) = 0,
    '级联删除应该删除相关订单'
);

SELECT * FROM finish();
ROLLBACK;
```

### 3.2 事务一致性测试

**事务ACID属性测试**：

```sql
BEGIN;
SELECT plan(5);

-- 测试原子性（Atomicity）
BEGIN;
INSERT INTO users (name, email) VALUES ('User 1', 'user1@example.com');
INSERT INTO orders (user_id, total_amount)
SELECT id, 100 FROM users WHERE email = 'user1@example.com';
ROLLBACK;

SELECT ok(
    (SELECT COUNT(*) FROM users WHERE email = 'user1@example.com') = 0,
    '回滚后数据应该不存在'
);

-- 测试一致性（Consistency）
BEGIN;
INSERT INTO users (id, name, email) VALUES (1, 'User', 'user@example.com');
INSERT INTO orders (user_id, total_amount) VALUES (1, 100);
UPDATE orders SET total_amount = -10 WHERE user_id = 1;
SELECT throws_ok(
    'COMMIT',
    '23514',
    '违反CHECK约束应该回滚'
);
ROLLBACK;

-- 测试隔离性（Isolation）
BEGIN ISOLATION LEVEL SERIALIZABLE;
INSERT INTO users (name, email) VALUES ('Isolated', 'isolated@example.com');
SELECT ok(
    EXISTS (SELECT 1 FROM users WHERE email = 'isolated@example.com'),
    '隔离级别应该生效'
);
COMMIT;

-- 测试持久性（Durability）
INSERT INTO users (name, email) VALUES ('Persistent', 'persistent@example.com');
COMMIT;
SELECT ok(
    EXISTS (SELECT 1 FROM users WHERE email = 'persistent@example.com'),
    '提交后数据应该持久化'
);

SELECT * FROM finish();
ROLLBACK;
```

### 3.3 级联操作测试

**级联更新和删除测试**：

```sql
BEGIN;
SELECT plan(4);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User', 'user@example.com');
INSERT INTO orders (id, user_id, total_amount) VALUES (1, 1, 100);
INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 1, 2);

-- 测试级联删除
DELETE FROM users WHERE id = 1;
SELECT ok(
    (SELECT COUNT(*) FROM orders WHERE user_id = 1) = 0,
    '用户删除应该级联删除订单'
);
SELECT ok(
    (SELECT COUNT(*) FROM order_items WHERE order_id = 1) = 0,
    '订单删除应该级联删除订单项'
);

-- 测试级联更新
INSERT INTO users (id, name, email) VALUES (2, 'User 2', 'user2@example.com');
INSERT INTO orders (id, user_id, total_amount) VALUES (2, 2, 200);
UPDATE users SET id = 3 WHERE id = 2;
SELECT ok(
    EXISTS (SELECT 1 FROM orders WHERE user_id = 3),
    '用户ID更新应该级联更新订单'
);

SELECT * FROM finish();
ROLLBACK;
```

### 3.4 数据完整性测试

**数据完整性约束测试**：

```sql
BEGIN;
SELECT plan(6);

-- 测试NOT NULL约束
SELECT throws_ok(
    'INSERT INTO users (name) VALUES (NULL)',
    '23502',
    'NOT NULL约束应该被强制执行'
);

-- 测试UNIQUE约束
INSERT INTO users (name, email) VALUES ('User 1', 'unique@example.com');
SELECT throws_ok(
    'INSERT INTO users (name, email) VALUES (''User 2'', ''unique@example.com'')',
    '23505',
    'UNIQUE约束应该被强制执行'
);

-- 测试CHECK约束
SELECT throws_ok(
    'INSERT INTO products (name, price) VALUES (''Product'', -10)',
    '23514',
    'CHECK约束应该被强制执行'
);

-- 测试默认值
INSERT INTO users (name, email) VALUES ('User', 'default@example.com');
SELECT ok(
    (SELECT created_at FROM users WHERE email = 'default@example.com') IS NOT NULL,
    '默认值应该被设置'
);

-- 测试触发器维护的数据完整性
INSERT INTO users (name, email) VALUES ('Trigger Test', 'trigger@example.com');
SELECT ok(
    EXISTS (
        SELECT 1 FROM user_audit_log
        WHERE user_id = (SELECT id FROM users WHERE email = 'trigger@example.com')
    ),
    '触发器应该维护审计日志'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 4. 组件协作测试

### 4.1 函数与触发器协作

**函数和触发器集成测试**：

```sql
BEGIN;
SELECT plan(4);

-- 创建测试函数和触发器
CREATE OR REPLACE FUNCTION calculate_order_total(p_order_id INT)
RETURNS NUMERIC AS $$
BEGIN
    RETURN (SELECT SUM(quantity * price) FROM order_items WHERE order_id = p_order_id);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders SET total_amount = calculate_order_total(NEW.order_id)
    WHERE id = NEW.order_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_order_total_trigger
AFTER INSERT OR UPDATE ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_total();

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User', 'user@example.com');
INSERT INTO orders (id, user_id, total_amount) VALUES (1, 1, 0);
INSERT INTO products (id, name, price) VALUES (1, 'Product', 50);

-- 测试触发器调用函数
INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (1, 1, 2, 50);
SELECT is(
    (SELECT total_amount FROM orders WHERE id = 1),
    100,
    '触发器应该调用函数更新订单总额'
);

-- 测试更新触发
UPDATE order_items SET quantity = 3 WHERE order_id = 1 AND product_id = 1;
SELECT is(
    (SELECT total_amount FROM orders WHERE id = 1),
    150,
    '更新应该触发函数重新计算'
);

SELECT * FROM finish();
ROLLBACK;
```

### 4.2 视图与表协作

**视图和表集成测试**：

```sql
BEGIN;
SELECT plan(4);

-- 创建视图
CREATE VIEW user_order_summary AS
SELECT
    u.id as user_id,
    u.name as user_name,
    COUNT(o.id) as order_count,
    COALESCE(SUM(o.total_amount), 0) as total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User', 'user@example.com');
INSERT INTO orders (id, user_id, total_amount) VALUES (1, 1, 100), (2, 1, 200);

-- 测试视图查询
SELECT is(
    (SELECT order_count FROM user_order_summary WHERE user_id = 1),
    2,
    '视图应该正确聚合数据'
);

SELECT is(
    (SELECT total_amount FROM user_order_summary WHERE user_id = 1),
    300,
    '视图应该正确计算总额'
);

-- 测试视图更新（通过INSTEAD OF触发器）
CREATE OR REPLACE FUNCTION insert_user_summary()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO users (name, email) VALUES (NEW.user_name, NEW.user_name || '@example.com');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER insert_user_summary_trigger
INSTEAD OF INSERT ON user_order_summary
FOR EACH ROW
EXECUTE FUNCTION insert_user_summary();

INSERT INTO user_order_summary (user_name) VALUES ('New User');
SELECT ok(
    EXISTS (SELECT 1 FROM users WHERE name = 'New User'),
    '通过视图插入应该成功'
);

SELECT * FROM finish();
ROLLBACK;
```

### 4.3 存储过程协作

**存储过程集成测试**：

```sql
BEGIN;
SELECT plan(5);

-- 创建存储过程
CREATE OR REPLACE PROCEDURE process_order(
    p_user_id INT,
    p_product_id INT,
    p_quantity INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_order_id INT;
    v_price NUMERIC;
BEGIN
    -- 获取商品价格
    SELECT price INTO v_price FROM products WHERE id = p_product_id;

    -- 创建订单
    INSERT INTO orders (user_id, total_amount, status)
    VALUES (p_user_id, v_price * p_quantity, 'pending')
    RETURNING id INTO v_order_id;

    -- 创建订单项
    INSERT INTO order_items (order_id, product_id, quantity, price)
    VALUES (v_order_id, p_product_id, p_quantity, v_price);

    -- 更新库存
    UPDATE products SET stock = stock - p_quantity WHERE id = p_product_id;

    -- 更新订单状态
    UPDATE orders SET status = 'completed' WHERE id = v_order_id;
END;
$$;

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User', 'user@example.com');
INSERT INTO products (id, name, price, stock) VALUES (1, 'Product', 50, 10);

-- 测试存储过程
CALL process_order(1, 1, 2);

-- 验证订单创建
SELECT ok(
    EXISTS (SELECT 1 FROM orders WHERE user_id = 1 AND status = 'completed'),
    '订单应该被创建并完成'
);

-- 验证订单项创建
SELECT ok(
    EXISTS (
        SELECT 1 FROM order_items oi
        JOIN orders o ON oi.order_id = o.id
        WHERE o.user_id = 1 AND oi.product_id = 1 AND oi.quantity = 2
    ),
    '订单项应该被创建'
);

-- 验证库存更新
SELECT is(
    (SELECT stock FROM products WHERE id = 1),
    8,
    '库存应该减少'
);

SELECT * FROM finish();
ROLLBACK;
```

## 5. 并发集成测试

### 5.1 并发事务测试

**并发事务正确性测试**：

```sql
-- 使用pgTAP测试并发事务
BEGIN;
SELECT plan(3);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User', 'user@example.com');
INSERT INTO accounts (user_id, balance) VALUES (1, 1000);

-- 模拟并发转账
-- 注意：实际并发测试需要使用多个连接
DO $$
DECLARE
    i INT;
BEGIN
    FOR i IN 1..10 LOOP
        -- 模拟转账操作
        UPDATE accounts SET balance = balance - 10 WHERE user_id = 1;
        UPDATE accounts SET balance = balance + 10 WHERE user_id = 1;
    END LOOP;
END $$;

-- 验证余额一致性
SELECT is(
    (SELECT balance FROM accounts WHERE user_id = 1),
    1000,
    '并发操作后余额应该保持一致'
);

SELECT * FROM finish();
ROLLBACK;
```

### 5.2 锁竞争测试

**锁竞争场景测试**：

```sql
BEGIN;
SELECT plan(4);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User', 'user@example.com');
INSERT INTO products (id, name, stock) VALUES (1, 'Product', 10);

-- 测试行级锁
BEGIN;
SELECT * FROM products WHERE id = 1 FOR UPDATE;
-- 在另一个事务中尝试更新应该等待
SELECT ok(
    EXISTS (SELECT 1 FROM pg_locks WHERE relation = 'products'::regclass),
    '应该获取行级锁'
);
COMMIT;

-- 测试表级锁
BEGIN;
LOCK TABLE products IN EXCLUSIVE MODE;
SELECT ok(
    EXISTS (
        SELECT 1 FROM pg_locks
        WHERE relation = 'products'::regclass
          AND mode = 'ExclusiveLock'
    ),
    '应该获取表级锁'
);
COMMIT;

SELECT * FROM finish();
ROLLBACK;
```

### 5.3 死锁检测测试

**死锁检测和恢复测试**：

```sql
BEGIN;
SELECT plan(2);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User 1', 'user1@example.com');
INSERT INTO users (id, name, email) VALUES (2, 'User 2', 'user2@example.com');
INSERT INTO accounts (user_id, balance) VALUES (1, 1000), (2, 1000);

-- 测试死锁检测
-- 注意：实际死锁测试需要两个并发事务
-- 事务1: UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
--         UPDATE accounts SET balance = balance + 100 WHERE user_id = 2;
-- 事务2: UPDATE accounts SET balance = balance - 100 WHERE user_id = 2;
--         UPDATE accounts SET balance = balance + 100 WHERE user_id = 1;
-- 应该检测到死锁并回滚其中一个事务

SELECT ok(
    current_setting('deadlock_timeout')::INT > 0,
    '死锁超时应该被配置'
);

SELECT * FROM finish();
ROLLBACK;
```

## 6. 错误处理测试

### 6.1 事务回滚测试

**事务回滚完整性测试**：

```sql
BEGIN;
SELECT plan(4);

-- 测试部分失败导致回滚
BEGIN;
INSERT INTO users (name, email) VALUES ('User', 'user@example.com');
INSERT INTO orders (user_id, total_amount)
SELECT id, 100 FROM users WHERE email = 'user@example.com';
-- 故意触发错误
INSERT INTO orders (user_id, total_amount) VALUES (999, 100);
ROLLBACK;

SELECT ok(
    (SELECT COUNT(*) FROM users WHERE email = 'user@example.com') = 0,
    '回滚后用户应该不存在'
);
SELECT ok(
    (SELECT COUNT(*) FROM orders) = 0,
    '回滚后订单应该不存在'
);

SELECT * FROM finish();
ROLLBACK;
```

### 6.2 异常传播测试

**异常在组件间传播测试**：

```sql
BEGIN;
SELECT plan(3);

-- 创建可能抛出异常的函数
CREATE OR REPLACE FUNCTION risky_operation(p_value INT)
RETURNS INT AS $$
BEGIN
    IF p_value < 0 THEN
        RAISE EXCEPTION '值不能为负数';
    END IF;
    RETURN p_value * 2;
END;
$$ LANGUAGE plpgsql;

-- 测试异常传播
SELECT throws_ok(
    'SELECT risky_operation(-1)',
    'P0001',
    '异常应该被正确抛出'
);

-- 测试异常在事务中传播
BEGIN;
SELECT risky_operation(-1);
EXCEPTION WHEN OTHERS THEN
    SELECT ok(TRUE, '异常应该被捕获');
END;

SELECT * FROM finish();
ROLLBACK;
```

### 6.3 错误恢复测试

**错误恢复机制测试**：

```sql
BEGIN;
SELECT plan(3);

-- 测试重试机制
CREATE OR REPLACE FUNCTION retry_operation(p_max_retries INT DEFAULT 3)
RETURNS BOOLEAN AS $$
DECLARE
    v_retry INT := 0;
    v_success BOOLEAN := FALSE;
BEGIN
    WHILE v_retry < p_max_retries AND NOT v_success LOOP
        BEGIN
            -- 模拟可能失败的操作
            INSERT INTO users (name, email) VALUES ('Retry Test', 'retry@example.com');
            v_success := TRUE;
        EXCEPTION WHEN OTHERS THEN
            v_retry := v_retry + 1;
            IF v_retry >= p_max_retries THEN
                RAISE;
            END IF;
        END;
    END LOOP;
    RETURN v_success;
END;
$$ LANGUAGE plpgsql;

-- 测试重试成功
SELECT ok(
    retry_operation(3),
    '重试机制应该成功'
);

SELECT * FROM finish();
ROLLBACK;
```

## 7. 性能集成测试

### 7.1 查询性能测试

**集成环境查询性能测试**：

```sql
BEGIN;
SELECT plan(3);

-- 准备测试数据
INSERT INTO users SELECT generate_series(1, 1000), 'User' || generate_series(1, 1000),
    'user' || generate_series(1, 1000) || '@example.com';
INSERT INTO orders SELECT generate_series(1, 5000),
    (random() * 1000)::INT + 1, (random() * 1000)::NUMERIC, 'pending';

-- 测试JOIN查询性能
\timing on
SELECT COUNT(*) FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.email LIKE '%@example.com';
\timing off

SELECT ok(TRUE, 'JOIN查询应该完成');

-- 测试聚合查询性能
\timing on
SELECT u.id, COUNT(o.id), SUM(o.total_amount)
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id
HAVING COUNT(o.id) > 5;
\timing off

SELECT ok(TRUE, '聚合查询应该完成');

SELECT * FROM finish();
ROLLBACK;
```

### 7.2 写入性能测试

**集成环境写入性能测试**：

```sql
BEGIN;
SELECT plan(2);

-- 测试批量插入性能
\timing on
INSERT INTO users (name, email)
SELECT 'User' || generate_series(1, 1000),
       'user' || generate_series(1, 1000) || '@example.com';
\timing off

SELECT ok(
    (SELECT COUNT(*) FROM users WHERE email LIKE '%@example.com') >= 1000,
    '批量插入应该成功'
);

-- 测试事务写入性能
\timing on
BEGIN;
INSERT INTO orders (user_id, total_amount)
SELECT id, 100 FROM users LIMIT 100;
COMMIT;
\timing off

SELECT ok(TRUE, '事务写入应该完成');

SELECT * FROM finish();
ROLLBACK;
```

### 7.3 混合负载测试

**读写混合负载测试**：

```sql
BEGIN;
SELECT plan(2);

-- 模拟混合负载
DO $$
DECLARE
    i INT;
BEGIN
    FOR i IN 1..100 LOOP
        -- 读取操作
        PERFORM * FROM users WHERE id = (random() * 1000)::INT;
        -- 写入操作
        INSERT INTO logs (user_id, action) VALUES ((random() * 1000)::INT, 'action');
    END LOOP;
END $$;

SELECT ok(TRUE, '混合负载应该完成');

SELECT * FROM finish();
ROLLBACK;
```

## 8. 测试环境设置

### 8.1 测试数据库准备

**测试数据库配置**：

```sql
-- 创建测试数据库
CREATE DATABASE test_db;

-- 配置测试数据库参数
ALTER DATABASE test_db SET log_statement = 'all';
ALTER DATABASE test_db SET log_min_duration_statement = 0;
ALTER DATABASE test_db SET shared_buffers = '256MB';
ALTER DATABASE test_db SET work_mem = '16MB';
```

### 8.2 测试数据准备

**测试数据生成脚本**：

```sql
-- 生成测试数据的函数
CREATE OR REPLACE FUNCTION generate_test_data(p_user_count INT, p_order_count INT)
RETURNS VOID AS $$
BEGIN
    -- 生成用户
    INSERT INTO users (name, email)
    SELECT 'User' || generate_series(1, p_user_count),
           'user' || generate_series(1, p_user_count) || '@example.com';

    -- 生成订单
    INSERT INTO orders (user_id, total_amount)
    SELECT (random() * p_user_count)::INT + 1,
           (random() * 1000)::NUMERIC
    FROM generate_series(1, p_order_count);
END;
$$ LANGUAGE plpgsql;
```

### 8.3 测试环境隔离

**测试环境隔离策略**：

```sql
-- 使用事务隔离测试
BEGIN;
-- 测试代码
ROLLBACK;

-- 使用临时表隔离
CREATE TEMP TABLE test_users AS SELECT * FROM users LIMIT 0;

-- 使用测试schema隔离
CREATE SCHEMA test_schema;
SET search_path TO test_schema, public;
```

## 9. 测试工具

### 9.1 pgTAP集成测试

**使用pgTAP进行集成测试**：

```sql
-- 集成测试示例
BEGIN;
SELECT plan(10);

-- 测试完整业务流程
-- ... 测试代码 ...

SELECT * FROM finish();
ROLLBACK;
```

### 9.2 自定义测试框架

**自定义测试框架示例**：

```sql
-- 创建测试框架函数
CREATE OR REPLACE FUNCTION run_integration_test(p_test_name TEXT, p_test_sql TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    v_result BOOLEAN;
BEGIN
    BEGIN
        EXECUTE p_test_sql;
        v_result := TRUE;
    EXCEPTION WHEN OTHERS THEN
        RAISE NOTICE 'Test % failed: %', p_test_name, SQLERRM;
        v_result := FALSE;
    END;
    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

### 9.3 测试报告生成

**生成测试报告**：

```sql
-- 创建测试结果表
CREATE TABLE test_results (
    test_name TEXT,
    test_status TEXT,
    test_duration INTERVAL,
    test_message TEXT,
    test_timestamp TIMESTAMP DEFAULT NOW()
);

-- 记录测试结果
INSERT INTO test_results (test_name, test_status, test_message)
VALUES ('integration_test_1', 'PASS', 'All assertions passed');
```

## 10. 最佳实践

### 10.1 推荐做法

**✅ 推荐做法**：

1. **测试完整流程**
   - 覆盖端到端业务流程
   - 测试正常路径和异常路径
   - 验证数据一致性

2. **测试环境隔离**
   - 使用独立的测试数据库
   - 使用事务回滚清理数据
   - 避免影响生产环境

3. **测试数据管理**
   - 使用fixtures准备测试数据
   - 测试后清理数据
   - 使用可重复的测试数据

4. **测试组织**
   - 按业务流程组织测试
   - 使用清晰的测试命名
   - 保持测试独立

### 10.2 常见错误

**❌ 避免做法**：

1. **测试依赖**
   - 避免测试之间相互依赖
   - 避免依赖测试执行顺序
   - 避免依赖外部状态

2. **测试数据污染**
   - 避免使用生产数据
   - 避免测试数据残留
   - 避免硬编码测试数据

3. **测试过于复杂**
   - 避免一个测试测试多个流程
   - 保持测试简单明了
   - 使用辅助函数简化测试

### 10.3 测试维护

**测试维护策略**：

1. **定期审查**
   - 审查测试覆盖率
   - 更新过时的测试
   - 删除冗余测试

2. **测试文档**
   - 记录测试目的
   - 说明测试场景
   - 维护测试数据说明

3. **持续改进**
   - 根据发现的问题改进测试
   - 优化测试执行速度
   - 提高测试可维护性

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [单元测试.md](./单元测试.md) - 单元测试详解
- [性能测试.md](./性能测试.md) - 性能测试详解
- [压力测试.md](./压力测试.md) - 压力测试详解
- [测试自动化.md](./测试自动化.md) - 测试自动化
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**文档版本**: v1.0
**最后更新**: 2025年1月
**维护者**: PostgreSQL开发团队

---

## 5. 最佳实践

### ✅ 推荐做法

1. **测试完整流程** - 覆盖业务流程
2. **数据隔离** - 使用测试数据库
3. **清理数据** - 测试后清理
4. **错误处理** - 测试错误场景

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [单元测试.md](./单元测试.md) - 单元测试详解
- [性能测试.md](./性能测试.md) - 性能测试详解
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**最后更新**: 2025年1月
