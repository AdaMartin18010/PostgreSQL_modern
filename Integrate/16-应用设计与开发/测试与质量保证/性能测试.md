# PostgreSQL性能测试完整指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级
> **适用场景**: 查询性能测试、写入性能测试、并发性能测试、系统性能基准测试

---

## 📋 目录

- [PostgreSQL性能测试完整指南](#postgresql性能测试完整指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 性能测试的重要性](#11-性能测试的重要性)
    - [1.2 性能测试指标](#12-性能测试指标)
    - [1.3 性能测试类型](#13-性能测试类型)
  - [2. pgbench使用](#2-pgbench使用)
    - [2.1 安装和配置](#21-安装和配置)
    - [2.2 初始化测试数据](#22-初始化测试数据)
    - [2.3 运行性能测试](#23-运行性能测试)
    - [2.4 自定义测试脚本](#24-自定义测试脚本)
    - [2.5 测试结果分析](#25-测试结果分析)
  - [3. 查询性能测试](#3-查询性能测试)
    - [3.1 EXPLAIN ANALYZE分析](#31-explain-analyze分析)
    - [3.2 单个查询测试](#32-单个查询测试)
    - [3.3 查询集测试](#33-查询集测试)
    - [3.4 慢查询识别](#34-慢查询识别)
  - [4. 写入性能测试](#4-写入性能测试)
    - [4.1 INSERT性能测试](#41-insert性能测试)
    - [4.2 UPDATE性能测试](#42-update性能测试)
    - [4.3 DELETE性能测试](#43-delete性能测试)
    - [4.4 批量操作测试](#44-批量操作测试)
  - [5. 并发性能测试](#5-并发性能测试)
    - [5.1 并发查询测试](#51-并发查询测试)
    - [5.2 并发写入测试](#52-并发写入测试)
    - [5.3 锁竞争测试](#53-锁竞争测试)
  - [6. 索引性能测试](#6-索引性能测试)
    - [6.1 索引创建性能](#61-索引创建性能)
    - [6.2 索引使用效果](#62-索引使用效果)
    - [6.3 索引维护性能](#63-索引维护性能)
  - [7. 事务性能测试](#7-事务性能测试)
    - [7.1 事务吞吐量测试](#71-事务吞吐量测试)
    - [7.2 事务延迟测试](#72-事务延迟测试)
    - [7.3 长事务测试](#73-长事务测试)
  - [8. 系统资源监控](#8-系统资源监控)
    - [8.1 CPU使用监控](#81-cpu使用监控)
    - [8.2 内存使用监控](#82-内存使用监控)
    - [8.3 I/O性能监控](#83-io性能监控)
  - [9. 性能基准建立](#9-性能基准建立)
    - [9.1 基准指标定义](#91-基准指标定义)
    - [9.2 基准测试执行](#92-基准测试执行)
    - [9.3 基准结果记录](#93-基准结果记录)
  - [10. 性能优化验证](#10-性能优化验证)
    - [10.1 优化前后对比](#101-优化前后对比)
    - [10.2 优化效果评估](#102-优化效果评估)
    - [10.3 回归测试](#103-回归测试)
  - [11. 性能测试工具](#11-性能测试工具)
    - [11.1 pg\_stat\_statements](#111-pg_stat_statements)
    - [11.2 auto\_explain](#112-auto_explain)
    - [11.3 pgBadger](#113-pgbadger)
  - [12. 最佳实践](#12-最佳实践)
    - [12.1 推荐做法](#121-推荐做法)
    - [12.2 常见错误](#122-常见错误)
    - [12.3 性能测试计划](#123-性能测试计划)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 性能测试的重要性

性能测试验证PostgreSQL应用是否满足性能要求，是确保系统在生产环境中稳定运行的关键环节。

**性能测试的价值**：

- **发现性能瓶颈**：及早发现性能问题
- **验证性能目标**：确保系统满足性能要求
- **容量规划**：为系统扩容提供依据
- **优化验证**：验证性能优化的效果

**性能测试时机**：

- 开发阶段：功能开发完成后
- 优化阶段：性能优化前后
- 发布前：生产环境部署前
- 定期测试：定期性能回归测试

### 1.2 性能测试指标

**核心性能指标**:

- **查询响应时间**：单个查询的执行时间
- **吞吐量（TPS）**：每秒处理的事务数
- **并发处理能力**：同时处理的连接数
- **资源使用**：CPU、内存、I/O使用率
- **延迟分布**：P50、P95、P99延迟
- **错误率**：性能测试中的错误比例

**性能指标分类**：

| 指标类型 | 指标名称 | 单位 | 目标值 |
|---------|---------|------|--------|
| **响应时间** | 平均响应时间 | ms | < 100 |
| **响应时间** | P95响应时间 | ms | < 500 |
| **响应时间** | P99响应时间 | ms | < 1000 |
| **吞吐量** | TPS | tps | > 1000 |
| **吞吐量** | QPS | qps | > 5000 |
| **并发** | 最大并发连接 | count | > 100 |
| **资源** | CPU使用率 | % | < 80 |
| **资源** | 内存使用率 | % | < 80 |
| **资源** | I/O等待时间 | ms | < 10 |

### 1.3 性能测试类型

**性能测试类型**：

1. **负载测试**：正常负载下的性能表现
2. **压力测试**：极限负载下的性能表现
3. **容量测试**：确定系统最大容量
4. **稳定性测试**：长时间运行的稳定性
5. **基准测试**：建立性能基准线

---

## 2. pgbench使用

### 2.1 安装和配置

**pgbench简介**：

pgbench是PostgreSQL自带的基准测试工具，模拟TPC-B基准测试。

**安装**：

```bash
# pgbench通常随PostgreSQL一起安装
# 验证安装
pgbench --version

# 如果未安装，可以通过PostgreSQL源码编译
cd postgresql-XX.X/contrib/pgbench
make && sudo make install
```

**基本配置**：

```bash
# 设置环境变量
export PGHOST=localhost
export PGPORT=5432
export PGUSER=postgres
export PGDATABASE=mydb
```

### 2.2 初始化测试数据

**初始化命令**：

```bash
# 基础初始化
pgbench -i mydb

# 指定缩放因子（数据量）
pgbench -i -s 50 mydb  # 50倍标准数据量

# 指定表空间
pgbench -i -s 50 --tablespace=fast_disk mydb

# 初始化时指定填充因子
pgbench -i -s 50 --fillfactor=90 mydb

# 详细输出
pgbench -i -s 50 -v mydb
```

**缩放因子说明**：

- `-s 1`：标准数据量（约100,000行）
- `-s 10`：10倍数据量（约1,000,000行）
- `-s 50`：50倍数据量（约5,000,000行）
- `-s 100`：100倍数据量（约10,000,000行）

**初始化后的表结构**：

- `pgbench_branches`：分支表
- `pgbench_tellers`：出纳表
- `pgbench_accounts`：账户表（主要数据表）
- `pgbench_history`：历史表

### 2.3 运行性能测试

**基本测试命令**：

```bash
# 基础性能测试
pgbench -c 10 -j 2 -T 60 mydb

# 参数说明：
# -c: 客户端数（并发连接数）
# -j: 线程数（通常设置为CPU核心数）
# -T: 运行时间（秒）
# -t: 事务数（替代-T）
```

**测试模式**：

```bash
# 简单模式（默认）
pgbench -c 10 -j 2 -T 60 mydb

# 扩展模式（更详细的统计）
pgbench -c 10 -j 2 -T 60 -r mydb

# 详细模式（显示每个语句的统计）
pgbench -c 10 -j 2 -T 60 -r -d mydb
```

**高级选项**：

```bash
# 指定测试脚本
pgbench -c 10 -j 2 -T 60 -f custom_script.sql mydb

# 只读测试
pgbench -c 10 -j 2 -T 60 -S mydb

# 跳过SELECT（只测试写入）
pgbench -c 10 -j 2 -T 60 -N mydb

# 指定连接建立方式
pgbench -c 10 -j 2 -T 60 --connect mydb  # 每个事务建立新连接
pgbench -c 10 -j 2 -T 60 mydb            # 连接复用（默认）

# 指定报告间隔
pgbench -c 10 -j 2 -T 60 --progress=10 mydb  # 每10秒报告一次
```

### 2.4 自定义测试脚本

**创建自定义测试脚本**：

```sql
-- custom_test.sql
-- 变量定义
\set id random(1, 1000000)
\set amount random(1, 1000)

-- 测试事务
BEGIN;
SELECT * FROM users WHERE id = :id;
UPDATE users SET last_login = NOW() WHERE id = :id;
INSERT INTO logs (user_id, action, amount) VALUES (:id, 'test', :amount);
COMMIT;
```

**使用自定义脚本**：

```bash
# 运行自定义脚本
pgbench -c 10 -j 2 -T 60 -f custom_test.sql mydb

# 指定变量值
pgbench -c 10 -j 2 -T 60 -f custom_test.sql \
  -D id=1000 -D amount=500 mydb

# 使用多个脚本文件
pgbench -c 10 -j 2 -T 60 -f script1.sql -f script2.sql mydb
```

**pgbench内置变量**：

- `:scale`：缩放因子
- `:client_id`：客户端ID
- `:random(1, 1000)`：1到1000的随机数
- `:random_gaussian(1, 1000, 2.0)`：高斯分布随机数
- `:random_exponential(1, 1000, 3.0)`：指数分布随机数

### 2.5 测试结果分析

**标准输出示例**：

```text
transaction type: <builtin: TPC-B (sort of)>
scaling factor: 50
query mode: simple
number of clients: 10
number of threads: 2
duration: 60 s
number of transactions actually processed: 12345
latency average = 48.6 ms
latency stddev = 12.3 ms
initial connection time = 25.4 ms
tps = 205.8 (including connections establishing)
tps = 206.2 (excluding connections establishing)
```

**结果解读**：

- **number of transactions**：实际处理的事务数
- **latency average**：平均延迟
- **latency stddev**：延迟标准差
- **tps**：每秒事务数（TPS）
- **initial connection time**：初始连接时间

**详细统计报告**（使用`-r`选项）：

```text
statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.001  \set bid random(1, 1 * :scale)
        0.001  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.045  BEGIN;
        2.123  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        1.456  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        0.234  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        0.567  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.123  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        0.089  END;
```

**性能指标计算**：

```bash
# 计算QPS（每秒查询数）
QPS = TPS × 平均每个事务的查询数

# 计算平均延迟
平均延迟 = 总时间 / 事务数

# 计算P95延迟（需要详细统计）
# 使用--progress选项获取延迟分布
```

---

## 3. 查询性能测试

### 3.1 EXPLAIN ANALYZE分析

**EXPLAIN ANALYZE使用**：

```sql
-- 基本EXPLAIN ANALYZE
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'test@example.com';

-- 详细输出（包含缓冲区信息）
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM users WHERE email = 'test@example.com';

-- JSON格式输出
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
SELECT * FROM users WHERE email = 'test@example.com';

-- 包含计划时间
EXPLAIN (ANALYZE, BUFFERS, VERBOSE, TIMING)
SELECT * FROM users WHERE email = 'test@example.com';
```

**执行计划解读**：

```sql
-- 示例执行计划
EXPLAIN ANALYZE
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_at > '2025-01-01'
GROUP BY u.id, u.name
HAVING COUNT(o.id) > 10;

-- 关键指标：
-- - Planning Time: 计划时间
-- - Execution Time: 执行时间
-- - Buffers: shared hit/read, temp read/write
-- - I/O Timings: read/write时间
```

**性能问题识别**：

- **Seq Scan**：全表扫描（可能缺少索引）
- **Nested Loop**：嵌套循环（可能性能差）
- **Hash Join**：哈希连接（适合大数据集）
- **Sort**：排序操作（可能影响性能）
- **Index Scan**：索引扫描（通常性能好）

### 3.2 单个查询测试

**测试单个查询性能**：

```sql
-- 方法1：使用\timing
\timing on
SELECT * FROM users WHERE email = 'test@example.com';
\timing off

-- 方法2：使用EXPLAIN ANALYZE
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'test@example.com';

-- 方法3：使用pg_stat_statements
SELECT query, calls, mean_exec_time, max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%users%email%'
ORDER BY mean_exec_time DESC;
```

**多次执行取平均值**：

```sql
-- 创建测试函数
CREATE OR REPLACE FUNCTION test_query_performance(
    p_query TEXT,
    p_iterations INT DEFAULT 10
)
RETURNS TABLE (
    iteration INT,
    execution_time NUMERIC
) AS $$
DECLARE
    i INT;
    start_time TIMESTAMP;
    end_time TIMESTAMP;
BEGIN
    FOR i IN 1..p_iterations LOOP
        start_time := clock_timestamp();
        EXECUTE p_query;
        end_time := clock_timestamp();

        RETURN QUERY SELECT i, EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 使用测试函数
SELECT
    AVG(execution_time) as avg_time,
    MIN(execution_time) as min_time,
    MAX(execution_time) as max_time,
    STDDEV(execution_time) as stddev_time
FROM test_query_performance('SELECT * FROM users WHERE email = ''test@example.com''', 10);
```

### 3.3 查询集测试

**测试查询集性能**：

```sql
-- 测试多个查询
\timing on

-- 查询1：简单查询
SELECT * FROM users WHERE id = 1;

-- 查询2：JOIN查询
SELECT u.name, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.email = 'test@example.com';

-- 查询3：聚合查询
SELECT category, COUNT(*), AVG(price)
FROM products
GROUP BY category;

-- 查询4：子查询
SELECT name, price
FROM products
WHERE category IN (
    SELECT category FROM categories WHERE active = TRUE
);

\timing off
```

**批量查询测试**：

```sql
-- 创建批量查询测试函数
CREATE OR REPLACE FUNCTION test_query_set(
    p_queries TEXT[],
    p_iterations INT DEFAULT 10
)
RETURNS TABLE (
    query_index INT,
    query_text TEXT,
    avg_time NUMERIC,
    min_time NUMERIC,
    max_time NUMERIC
) AS $$
DECLARE
    i INT;
    j INT;
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    times NUMERIC[];
BEGIN
    FOR i IN 1..array_length(p_queries, 1) LOOP
        times := ARRAY[]::NUMERIC[];

        FOR j IN 1..p_iterations LOOP
            start_time := clock_timestamp();
            EXECUTE p_queries[i];
            end_time := clock_timestamp();
            times := array_append(times, EXTRACT(EPOCH FROM (end_time - start_time)) * 1000);
        END LOOP;

        RETURN QUERY SELECT
            i,
            p_queries[i],
            AVG(unnest(times)),
            MIN(unnest(times)),
            MAX(unnest(times));
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 3.4 慢查询识别

**识别慢查询**：

```sql
-- 使用pg_stat_statements查找慢查询
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    stddev_exec_time,
    rows
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- 平均执行时间超过100ms
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 查找执行次数多且慢的查询
SELECT
    query,
    calls,
    mean_exec_time,
    (mean_exec_time * calls) as total_time
FROM pg_stat_statements
WHERE calls > 1000 AND mean_exec_time > 50
ORDER BY total_time DESC;

-- 查找最耗时的查询
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    total_exec_time,
    mean_exec_time,
    (100.0 * total_exec_time / SUM(total_exec_time) OVER ()) as percent_total_time
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

**慢查询日志分析**：

```sql
-- 启用慢查询日志（postgresql.conf）
log_min_duration_statement = 1000  -- 记录超过1秒的查询

-- 查看慢查询日志
SELECT * FROM pg_stat_statements
WHERE mean_exec_time > 1000
ORDER BY mean_exec_time DESC;
```

---

## 4. 写入性能测试

### 4.1 INSERT性能测试

**单条INSERT测试**：

```sql
-- 测试单条INSERT性能
\timing on
INSERT INTO users (name, email) VALUES ('Test', 'test@example.com');
\timing off

-- 批量INSERT测试
\timing on
INSERT INTO users (name, email)
SELECT 'User' || generate_series(1, 1000),
       'user' || generate_series(1, 1000) || '@example.com';
\timing off
```

**使用pgbench测试INSERT**：

```sql
-- insert_test.sql
\set id random(1, 1000000)
\set name 'User' || :id
\set email 'user' || :id || '@example.com'

INSERT INTO users (name, email) VALUES (:name, :email);
```

```bash
pgbench -c 10 -j 2 -T 60 -f insert_test.sql mydb
```

### 4.2 UPDATE性能测试

**UPDATE性能测试**：

```sql
-- 单条UPDATE测试
\timing on
UPDATE users SET last_login = NOW() WHERE id = 1;
\timing off

-- 批量UPDATE测试
\timing on
UPDATE users SET status = 'active'
WHERE created_at > '2025-01-01';
\timing off
```

**使用pgbench测试UPDATE**：

```sql
-- update_test.sql
\set id random(1, 1000000)
UPDATE users SET last_login = NOW() WHERE id = :id;
```

### 4.3 DELETE性能测试

**DELETE性能测试**：

```sql
-- 单条DELETE测试
\timing on
DELETE FROM users WHERE id = 1;
\timing off

-- 批量DELETE测试
\timing on
DELETE FROM users WHERE created_at < '2020-01-01';
\timing off
```

### 4.4 批量操作测试

**批量操作性能对比**：

```sql
-- 方法1：逐条INSERT（慢）
BEGIN;
INSERT INTO users (name, email) VALUES ('User1', 'user1@example.com');
INSERT INTO users (name, email) VALUES ('User2', 'user2@example.com');
-- ... 更多INSERT
COMMIT;

-- 方法2：批量INSERT（快）
INSERT INTO users (name, email) VALUES
    ('User1', 'user1@example.com'),
    ('User2', 'user2@example.com'),
    -- ... 更多值
    ('User100', 'user100@example.com');

-- 方法3：COPY（最快）
COPY users (name, email) FROM STDIN;
User1 user1@example.com
User2 user2@example.com
\.
```

## 5. 并发性能测试

### 5.1 并发查询测试

**并发查询测试**：

```bash
# 使用pgbench测试并发查询
pgbench -c 20 -j 4 -T 60 -S mydb

# -S: 只读模式（SELECT only）
# -c: 20个并发客户端
# -j: 4个线程
```

**自定义并发查询脚本**：

```sql
-- concurrent_read_test.sql
\set id random(1, 1000000)
SELECT * FROM users WHERE id = :id;
SELECT * FROM orders WHERE user_id = :id;
```

### 5.2 并发写入测试

**并发写入测试**：

```bash
# 测试并发写入
pgbench -c 20 -j 4 -T 60 -N mydb

# -N: 跳过SELECT（只测试写入）
```

**自定义并发写入脚本**：

```sql
-- concurrent_write_test.sql
\set id random(1, 1000000)
BEGIN;
UPDATE users SET last_login = NOW() WHERE id = :id;
INSERT INTO logs (user_id, action) VALUES (:id, 'update');
COMMIT;
```

### 5.3 锁竞争测试

**锁竞争场景测试**：

```sql
-- 测试行级锁竞争
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;
-- 在另一个会话中尝试更新同一行
UPDATE users SET name = 'Updated' WHERE id = 1;  -- 会等待
COMMIT;

-- 监控锁等待
SELECT
    blocked_locks.pid AS blocked_pid,
    blocking_locks.pid AS blocking_pid,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted
  AND blocked_locks.pid != blocking_locks.pid;
```

## 6. 索引性能测试

### 6.1 索引创建性能

**索引创建性能测试**：

```sql
-- 测试索引创建时间
\timing on
CREATE INDEX idx_users_email ON users(email);
\timing off

-- 并发创建索引（PostgreSQL 12+）
CREATE INDEX CONCURRENTLY idx_users_email ON users(email);
```

### 6.2 索引使用效果

**索引使用效果测试**：

```sql
-- 测试无索引查询
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'test@example.com';
-- 结果：Seq Scan（全表扫描）

-- 创建索引后测试
CREATE INDEX idx_users_email ON users(email);
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'test@example.com';
-- 结果：Index Scan（索引扫描）
```

### 6.3 索引维护性能

**索引维护性能测试**：

```sql
-- 测试索引大小
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC;

-- 测试索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- 未使用的索引
ORDER BY pg_relation_size(indexrelid) DESC;
```

## 7. 事务性能测试

### 7.1 事务吞吐量测试

**事务吞吐量测试**：

```bash
# 使用pgbench测试事务吞吐量
pgbench -c 10 -j 2 -T 60 mydb

# 结果中的TPS（Transactions Per Second）就是事务吞吐量
```

### 7.2 事务延迟测试

**事务延迟测试**：

```sql
-- 测试事务延迟
BEGIN;
SELECT * FROM users WHERE id = 1;
UPDATE users SET last_login = NOW() WHERE id = 1;
COMMIT;

-- 使用pgbench获取延迟统计
pgbench -c 10 -j 2 -T 60 -r mydb
-- -r选项会显示延迟统计信息
```

### 7.3 长事务测试

**长事务性能测试**：

```sql
-- 测试长事务对性能的影响
BEGIN;
-- 执行多个操作
SELECT * FROM users;
UPDATE users SET status = 'active';
-- ... 更多操作
COMMIT;
```

## 8. 系统资源监控

### 8.1 CPU使用监控

**CPU使用监控**：

```sql
-- 查看CPU使用情况
SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    cpu_time
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY cpu_time DESC;

-- 系统级CPU监控
-- 使用top或htop命令
top -p $(pgrep -f postgres)
```

### 8.2 内存使用监控

**内存使用监控**：

```sql
-- 查看数据库内存使用
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    tup_returned,
    tup_fetched,
    tup_inserted,
    tup_updated,
    tup_deleted
FROM pg_stat_database
WHERE datname = current_database();

-- 查看共享缓冲区命中率
SELECT
    sum(heap_blks_read) as heap_read,
    sum(heap_blks_hit) as heap_hit,
    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio
FROM pg_statio_user_tables;
```

### 8.3 I/O性能监控

**I/O性能监控**：

```sql
-- 查看I/O统计（PostgreSQL 16+）
SELECT
    backend_type,
    object,
    context,
    reads,
    writes,
    extends,
    fsyncs,
    stats_reset
FROM pg_stat_io
ORDER BY reads + writes DESC;

-- 系统级I/O监控
-- 使用iostat命令
iostat -x 1
```

## 9. 性能基准建立

### 9.1 基准指标定义

**定义性能基准指标**：

```sql
-- 创建基准指标表
CREATE TABLE performance_benchmarks (
    id SERIAL PRIMARY KEY,
    test_name TEXT NOT NULL,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    unit TEXT,
    test_date TIMESTAMP DEFAULT NOW(),
    notes TEXT
);

-- 记录基准指标
INSERT INTO performance_benchmarks (test_name, metric_name, metric_value, unit)
VALUES
    ('pgbench_tpcb', 'tps', 1000, 'transactions/sec'),
    ('query_users_by_email', 'avg_time', 10, 'ms'),
    ('insert_users', 'throughput', 5000, 'rows/sec');
```

### 9.2 基准测试执行

**执行基准测试**：

```bash
# 执行基准测试并记录结果
pgbench -c 10 -j 2 -T 60 -r mydb > benchmark_results.txt

# 解析结果并存储
# 可以使用脚本自动解析pgbench输出并插入到基准表中
```

### 9.3 基准结果记录

**记录和比较基准结果**：

```sql
-- 查询基准历史
SELECT
    test_name,
    metric_name,
    metric_value,
    test_date,
    LAG(metric_value) OVER (PARTITION BY test_name, metric_name ORDER BY test_date) as previous_value,
    metric_value - LAG(metric_value) OVER (PARTITION BY test_name, metric_name ORDER BY test_date) as change
FROM performance_benchmarks
ORDER BY test_date DESC;
```

## 10. 性能优化验证

### 10.1 优化前后对比

**优化前后性能对比**：

```sql
-- 优化前测试
-- 记录基准性能
INSERT INTO performance_benchmarks (test_name, metric_name, metric_value, notes)
VALUES ('query_optimization', 'before_avg_time', 100, 'Before index creation');

-- 执行优化（例如创建索引）
CREATE INDEX idx_users_email ON users(email);

-- 优化后测试
-- 记录优化后性能
INSERT INTO performance_benchmarks (test_name, metric_name, metric_value, notes)
VALUES ('query_optimization', 'after_avg_time', 10, 'After index creation');

-- 计算改进百分比
SELECT
    (SELECT metric_value FROM performance_benchmarks WHERE notes = 'Before index creation') as before,
    (SELECT metric_value FROM performance_benchmarks WHERE notes = 'After index creation') as after,
    ((SELECT metric_value FROM performance_benchmarks WHERE notes = 'Before index creation') -
     (SELECT metric_value FROM performance_benchmarks WHERE notes = 'After index creation')) /
    (SELECT metric_value FROM performance_benchmarks WHERE notes = 'Before index creation') * 100 as improvement_percent;
```

### 10.2 优化效果评估

**评估优化效果**：

```sql
-- 创建优化效果评估函数
CREATE OR REPLACE FUNCTION evaluate_optimization(
    p_test_name TEXT,
    p_before_value NUMERIC,
    p_after_value NUMERIC
)
RETURNS TABLE (
    improvement_percent NUMERIC,
    status TEXT
) AS $$
DECLARE
    v_improvement NUMERIC;
BEGIN
    v_improvement := (p_before_value - p_after_value) / p_before_value * 100;

    RETURN QUERY SELECT
        v_improvement,
        CASE
            WHEN v_improvement > 50 THEN 'Excellent'
            WHEN v_improvement > 20 THEN 'Good'
            WHEN v_improvement > 0 THEN 'Moderate'
            ELSE 'No Improvement'
        END;
END;
$$ LANGUAGE plpgsql;
```

### 10.3 回归测试

**性能回归测试**：

```sql
-- 检测性能回归
SELECT
    test_name,
    metric_name,
    current_value,
    baseline_value,
    (current_value - baseline_value) / baseline_value * 100 as regression_percent,
    CASE
        WHEN (current_value - baseline_value) / baseline_value * 100 > 10 THEN 'REGRESSION'
        ELSE 'OK'
    END as status
FROM (
    SELECT
        test_name,
        metric_name,
        metric_value as current_value,
        (SELECT metric_value FROM performance_benchmarks b2
         WHERE b2.test_name = b1.test_name
           AND b2.metric_name = b1.metric_name
           AND b2.test_date = (SELECT MIN(test_date) FROM performance_benchmarks
                                WHERE test_name = b1.test_name
                                  AND metric_name = b1.metric_name)) as baseline_value
    FROM performance_benchmarks b1
    WHERE test_date = (SELECT MAX(test_date) FROM performance_benchmarks)
) subquery;
```

## 11. 性能测试工具

### 11.1 pg_stat_statements

**使用pg_stat_statements分析性能**：

```sql
-- 启用pg_stat_statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 查看慢查询
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 重置统计
SELECT pg_stat_statements_reset();
```

### 11.2 auto_explain

**使用auto_explain自动记录执行计划**：

```sql
-- 启用auto_explain
LOAD 'auto_explain';

-- 配置auto_explain
SET auto_explain.log_min_duration = 1000;  -- 记录超过1秒的查询
SET auto_explain.log_analyze = true;
SET auto_explain.log_buffers = true;
SET auto_explain.log_verbose = true;
```

### 11.3 pgBadger

**使用pgBadger分析日志**：

```bash
# 安装pgBadger
# Ubuntu/Debian
sudo apt-get install pgbadger

# 生成报告
pgbadger /var/log/postgresql/postgresql-*.log -o report.html

# 指定时间范围
pgbadger /var/log/postgresql/postgresql-*.log \
  --start-time "2025-01-01 00:00:00" \
  --end-time "2025-01-31 23:59:59" \
  -o report.html
```

## 12. 最佳实践

### 12.1 推荐做法

**✅ 推荐做法**：

1. **建立性能基准**
   - 在优化前建立基准
   - 定期执行基准测试
   - 记录性能变化趋势

2. **系统化测试**
   - 使用标准化测试工具（pgbench）
   - 保持测试环境一致性
   - 记录测试配置和结果

3. **全面监控**
   - 监控查询性能
   - 监控系统资源
   - 监控数据库指标

4. **持续优化**
   - 定期分析慢查询
   - 优化索引使用
   - 调整配置参数

### 12.2 常见错误

**❌ 避免做法**：

1. **测试环境不一致**
   - 避免在不同环境下比较结果
   - 避免测试数据量差异过大
   - 避免配置参数不一致

2. **测试时间过短**
   - 避免测试时间过短（< 30秒）
   - 避免忽略预热阶段
   - 避免单次测试结果

3. **忽略系统资源**
   - 避免只关注TPS
   - 避免忽略CPU/内存/I/O
   - 避免忽略锁竞争

### 12.3 性能测试计划

**性能测试计划模板**：

```text
1. 测试目标
   - 确定性能目标（TPS、延迟等）
   - 定义成功标准

2. 测试环境
   - 硬件配置
   - 软件版本
   - 数据库配置

3. 测试场景
   - 负载测试场景
   - 压力测试场景
   - 稳定性测试场景

4. 测试执行
   - 测试脚本
   - 测试数据
   - 执行步骤

5. 结果分析
   - 性能指标
   - 瓶颈识别
   - 优化建议

6. 报告生成
   - 测试结果报告
   - 性能趋势分析
   - 优化建议报告
```

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [单元测试.md](./单元测试.md) - 单元测试详解
- [集成测试.md](./集成测试.md) - 集成测试详解
- [压力测试.md](./压力测试.md) - 压力测试详解
- [测试自动化.md](./测试自动化.md) - 测试自动化
- [代码质量检查.md](./代码质量检查.md) - 代码质量检查
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**文档版本**: v1.0
**最后更新**: 2025年1月
**维护者**: PostgreSQL开发团队
