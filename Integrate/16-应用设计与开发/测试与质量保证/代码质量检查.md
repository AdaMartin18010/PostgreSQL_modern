# PostgreSQL代码质量检查完整指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级
> **适用场景**: SQL代码审查、代码规范、性能优化、安全审计

---

## 📋 目录

- [PostgreSQL代码质量检查完整指南](#postgresql代码质量检查完整指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 代码质量的重要性](#11-代码质量的重要性)
    - [1.2 质量检查维度](#12-质量检查维度)
    - [1.3 质量检查流程](#13-质量检查流程)
  - [2. SQL检查工具](#2-sql检查工具)
    - [2.1 sqlfluff](#21-sqlfluff)
    - [2.2 pgFormatter](#22-pgformatter)
    - [2.3 pgTAP](#23-pgtap)
    - [2.4 检查规则配置](#24-检查规则配置)
  - [3. 代码审查](#3-代码审查)
    - [3.1 审查清单](#31-审查清单)
    - [3.2 审查工具](#32-审查工具)
    - [3.3 审查流程](#33-审查流程)
    - [3.4 审查最佳实践](#34-审查最佳实践)
  - [4. 静态分析](#4-静态分析)
    - [4.1 分析工具](#41-分析工具)
    - [4.2 分析指标](#42-分析指标)
    - [4.3 复杂度分析](#43-复杂度分析)
    - [4.4 依赖分析](#44-依赖分析)
  - [5. 性能分析](#5-性能分析)
    - [5.1 EXPLAIN分析](#51-explain分析)
    - [5.2 pg\_stat\_statements](#52-pg_stat_statements)
    - [5.3 慢查询分析](#53-慢查询分析)
    - [5.4 索引使用分析](#54-索引使用分析)
  - [6. 安全审计](#6-安全审计)
    - [6.1 SQL注入检测](#61-sql注入检测)
    - [6.2 权限检查](#62-权限检查)
    - [6.3 敏感数据检查](#63-敏感数据检查)
  - [7. 质量指标](#7-质量指标)
    - [7.1 代码质量指标](#71-代码质量指标)
    - [7.2 性能指标](#72-性能指标)
    - [7.3 安全指标](#73-安全指标)
  - [8. 持续集成](#8-持续集成)
    - [8.1 CI/CD集成](#81-cicd集成)
    - [8.2 自动化检查](#82-自动化检查)
    - [8.3 质量门禁](#83-质量门禁)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 代码规范](#91-代码规范)
    - [9.2 审查流程](#92-审查流程)
    - [9.3 持续改进](#93-持续改进)
  - [📚 相关文档](#-相关文档)
  - [📚 相关文档](#-相关文档-1)

---

## 1. 概述

### 1.1 代码质量的重要性

代码质量检查确保PostgreSQL代码符合规范和最佳实践，提高代码的可维护性、性能和安全性。

**质量检查的价值**：

- **可维护性**：代码规范统一，易于理解和维护
- **性能**：及早发现性能问题，避免生产故障
- **安全性**：防止SQL注入等安全漏洞
- **可靠性**：减少bug，提高系统稳定性

**质量成本**：

| 阶段 | 发现问题的成本 | 修复成本 |
|------|---------------|---------|
| **设计阶段** | 低 | 低 |
| **开发阶段** | 中 | 中 |
| **测试阶段** | 高 | 高 |
| **生产阶段** | 极高 | 极高 |

### 1.2 质量检查维度

**检查内容**：

1. **SQL语法**
   - 语法正确性
   - 关键字使用
   - 数据类型匹配

2. **代码规范**
   - 命名规范
   - 格式规范
   - 注释规范

3. **性能问题**
   - 慢查询
   - 索引缺失
   - 全表扫描

4. **安全问题**
   - SQL注入
   - 权限控制
   - 敏感数据泄露

5. **代码复杂度**
   - 查询复杂度
   - 函数复杂度
   - 依赖关系

### 1.3 质量检查流程

**完整流程**：

```text
1. 代码提交
   ↓
2. 自动化检查（语法、格式、规范）
   ↓
3. 静态分析（复杂度、依赖）
   ↓
4. 代码审查（人工审查）
   ↓
5. 性能分析（EXPLAIN、慢查询）
   ↓
6. 安全审计（SQL注入、权限）
   ↓
7. 质量门禁（通过/拒绝）
   ↓
8. 合并代码
```

---

## 2. SQL检查工具

### 2.1 sqlfluff

**sqlfluff简介**：

sqlfluff是一个SQL代码格式化器和linter，支持PostgreSQL、MySQL、BigQuery等多种数据库。

**安装与使用**：

```bash
# 安装sqlfluff
pip install sqlfluff

# 检查SQL文件
sqlfluff lint queries.sql

# 检查特定规则
sqlfluff lint queries.sql --rules L010,L020

# 自动修复
sqlfluff fix queries.sql

# 检查目录下所有SQL文件
sqlfluff lint --recursive sql/

# 生成报告
sqlfluff lint queries.sql --format json > report.json
```

**配置文件示例**：

```toml
# .sqlfluff
[sqlfluff]
dialect = postgres
templater = raw
output_line_length = 100
exclude_rules = L003, L031

[sqlfluff:rules]
max_line_length = 100
indent_unit = space
capitalisation_policy = upper
comma_style = trailing
allow_scalar = True

[sqlfluff:rules:L010]
capitalisation_policy = upper

[sqlfluff:rules:L014]
capitalisation_policy = lower

[sqlfluff:rules:L030]
capitalisation_policy = upper
```

**CI/CD集成**：

```yaml
# .github/workflows/sql-check.yml
name: SQL Quality Check

on: [push, pull_request]

jobs:
  sqlfluff:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install sqlfluff
        run: pip install sqlfluff
      - name: Run sqlfluff
        run: sqlfluff lint --recursive sql/
```

### 2.2 pgFormatter

**pgFormatter简介**：

pgFormatter是一个PostgreSQL SQL格式化工具，支持多种输出格式。

**安装与使用**：

```bash
# 安装pgFormatter
# macOS
brew install pgformatter

# Linux
wget https://github.com/darold/pgFormatter/releases/download/v5.5/pg_format-5.5.tar.gz
tar -xzf pg_format-5.5.tar.gz
cd pgFormatter-5.5
make && sudo make install

# 格式化SQL文件
pg_format queries.sql > formatted.sql

# 格式化并输出
pg_format --inplace queries.sql

# 自定义选项
pg_format \
  --spaces 2 \
  --keyword-case upper \
  --function-case lower \
  queries.sql
```

**配置选项**：

```bash
# 常用选项
--spaces 2              # 缩进空格数
--keyword-case upper    # 关键字大小写
--function-case lower   # 函数名大小写
--comma-start           # 逗号在行首
--comma-end             # 逗号在行尾
--wrap-after 80         # 换行长度
--no-extra-line         # 不添加额外空行
```

### 2.3 pgTAP

**pgTAP简介**：

pgTAP是PostgreSQL的单元测试框架，可以编写SQL测试用例。

**安装与使用**：

```sql
-- 安装pgTAP扩展
CREATE EXTENSION IF NOT EXISTS pgtap;

-- 编写测试
BEGIN;
SELECT plan(3);

-- 测试1: 表存在
SELECT ok(
    EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_name = 'users'
    ),
    'users表应该存在'
);

-- 测试2: 列存在
SELECT ok(
    EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users' AND column_name = 'email'
    ),
    'users表应该有email列'
);

-- 测试3: 函数返回正确值
SELECT is(
    get_user_count(),
    100,
    'get_user_count()应该返回100'
);

SELECT * FROM finish();
ROLLBACK;
```

**运行测试**：

```bash
# 使用pg_prove运行测试
pg_prove -d mydb tests/users.sql

# 运行所有测试
pg_prove -d mydb tests/

# 详细输出
pg_prove -d mydb -v tests/
```

### 2.4 检查规则配置

**规则分类**：

1. **语法规则**
   - SQL语法正确性
   - 关键字使用
   - 数据类型匹配

2. **格式规则**
   - 缩进规范
   - 换行规范
   - 空格规范

3. **命名规则**
   - 表名规范
   - 列名规范
   - 函数名规范

4. **性能规则**
   - 避免SELECT *
   - 使用索引
   - 避免全表扫描

**规则配置示例**：

```toml
# .sqlfluff
[sqlfluff]
dialect = postgres

[sqlfluff:rules]
# 格式规则
max_line_length = 100
indent_unit = space
tab_space_size = 4

# 命名规则
capitalisation_policy = upper
comma_style = trailing

# 性能规则
forbid_implicit_casts = True
require_where_clause = True

# 安全规则
forbid_dynamic_sql = True
require_parameterized_queries = True
```

---

## 3. 代码审查

### 3.1 审查清单

**完整审查清单**：

**语法与规范**：

- [ ] SQL语法正确
- [ ] 关键字大小写统一
- [ ] 缩进格式一致
- [ ] 注释完整清晰

**性能**：

- [ ] 使用参数化查询
- [ ] 索引使用合理
- [ ] 避免SELECT *
- [ ] 避免全表扫描
- [ ] JOIN条件优化
- [ ] 子查询优化

**安全**：

- [ ] 防止SQL注入
- [ ] 权限控制正确
- [ ] 敏感数据保护
- [ ] 输入验证

**错误处理**：

- [ ] 错误处理完善
- [ ] 异常捕获
- [ ] 日志记录

**可维护性**：

- [ ] 代码结构清晰
- [ ] 函数职责单一
- [ ] 命名规范
- [ ] 文档完整

### 3.2 审查工具

**工具对比**：

| 工具 | 功能 | 适用场景 |
|------|------|---------|
| **sqlfluff** | 语法检查、格式化 | 代码规范检查 |
| **pgFormatter** | SQL格式化 | 代码格式化 |
| **pg_stat_statements** | 性能分析 | 慢查询分析 |
| **EXPLAIN** | 执行计划分析 | 性能优化 |
| **pgTAP** | 单元测试 | 功能测试 |

**使用pg_stat_statements分析**：

```sql
-- 启用pg_stat_statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 查看慢查询
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    stddev_exec_time,
    rows
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 查看查询统计
SELECT
    LEFT(query, 100) AS query_preview,
    calls,
    total_exec_time / 1000 AS total_sec,
    mean_exec_time / 1000 AS mean_sec,
    (total_exec_time / calls) / 1000 AS avg_sec_per_call
FROM pg_stat_statements
WHERE calls > 100
ORDER BY total_exec_time DESC
LIMIT 10;
```

### 3.3 审查流程

**标准审查流程**：

```text
1. 代码提交
   ↓
2. 自动化检查（语法、格式）
   ↓
3. 分配审查者
   ↓
4. 审查者审查（使用清单）
   ↓
5. 提出修改意见
   ↓
6. 开发者修改
   ↓
7. 再次审查
   ↓
8. 通过审查，合并代码
```

**审查时间分配**：

- **小型变更**（<50行）：15-30分钟
- **中型变更**（50-200行）：30-60分钟
- **大型变更**（>200行）：1-2小时

### 3.4 审查最佳实践

**审查原则**：

1. **及时审查**：代码提交后24小时内审查
2. **全面审查**：检查所有维度（语法、性能、安全）
3. **建设性反馈**：提供具体的改进建议
4. **尊重开发者**：保持专业和礼貌

**审查技巧**：

- **先看整体结构**：理解代码意图
- **检查关键路径**：重点关注核心逻辑
- **验证边界条件**：检查异常处理
- **性能考虑**：评估查询性能
- **安全检查**：防止安全漏洞

---

## 4. 静态分析

### 4.1 分析工具

**工具列表**：

1. **pg_prove**：运行pgTAP测试
2. **EXPLAIN**：执行计划分析
3. **pg_stat_statements**：查询统计
4. **pg_qualstats**：WHERE子句统计
5. **pg_buffercache**：缓存分析

**使用pg_prove**：

```bash
# 运行所有测试
pg_prove -d mydb tests/

# 运行特定测试文件
pg_prove -d mydb tests/users.sql

# 详细输出
pg_prove -d mydb -v tests/

# 并行运行
pg_prove -d mydb -j 4 tests/
```

**使用EXPLAIN分析**：

```sql
-- 基本EXPLAIN
EXPLAIN SELECT * FROM users WHERE id = 1;

-- EXPLAIN ANALYZE（实际执行）
EXPLAIN ANALYZE SELECT * FROM users WHERE id = 1;

-- 详细输出
EXPLAIN (ANALYZE, BUFFERS, VERBOSE, FORMAT JSON)
SELECT * FROM users WHERE id = 1;

-- 查看执行计划树
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT u.name, o.total
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.created_at > '2025-01-01';
```

### 4.2 分析指标

**关键指标**：

1. **查询复杂度**
   - JOIN数量
   - 子查询深度
   - 函数调用次数

2. **索引使用**
   - 索引命中率
   - 全表扫描次数
   - 索引选择性

3. **资源使用**
   - CPU使用率
   - 内存使用
   - I/O操作

4. **连接数**
   - 活跃连接
   - 空闲连接
   - 连接池使用

**查询复杂度分析**：

```sql
-- 计算查询复杂度
WITH query_stats AS (
    SELECT
        query,
        calls,
        mean_exec_time,
        (SELECT COUNT(*) FROM regexp_split_to_table(query, '\s+') AS word
         WHERE word ILIKE '%JOIN%') AS join_count,
        (SELECT COUNT(*) FROM regexp_split_to_table(query, '\s+') AS word
         WHERE word ILIKE '%SELECT%') AS select_count
    FROM pg_stat_statements
)
SELECT
    query,
    calls,
    mean_exec_time,
    join_count,
    select_count,
    (join_count + select_count) AS complexity_score
FROM query_stats
ORDER BY complexity_score DESC
LIMIT 20;
```

### 4.3 复杂度分析

**复杂度指标**：

- **圈复杂度**：控制流复杂度
- **认知复杂度**：代码理解难度
- **查询复杂度**：SQL查询复杂度

**复杂度评分**：

```sql
-- 查询复杂度评分函数
CREATE OR REPLACE FUNCTION calculate_query_complexity(query_text TEXT)
RETURNS INTEGER AS $$
DECLARE
    complexity INTEGER := 0;
BEGIN
    -- JOIN数量（每个JOIN +2）
    complexity := complexity + (SELECT COUNT(*) * 2
        FROM regexp_split_to_table(query_text, '\s+') AS word
        WHERE word ILIKE '%JOIN%');

    -- 子查询数量（每个子查询 +3）
    complexity := complexity + (SELECT COUNT(*) * 3
        FROM regexp_split_to_table(query_text, '\s+') AS word
        WHERE word ILIKE '%SELECT%') - 1;

    -- UNION数量（每个UNION +2）
    complexity := complexity + (SELECT COUNT(*) * 2
        FROM regexp_split_to_table(query_text, '\s+') AS word
        WHERE word ILIKE '%UNION%');

    RETURN complexity;
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT
    query,
    calculate_query_complexity(query) AS complexity
FROM pg_stat_statements
ORDER BY complexity DESC
LIMIT 10;
```

### 4.4 依赖分析

**依赖关系分析**：

```sql
-- 查看表依赖关系
SELECT
    dependent_ns.nspname AS dependent_schema,
    dependent_view.relname AS dependent_view,
    source_ns.nspname AS source_schema,
    source_table.relname AS source_table
FROM pg_depend
JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
JOIN pg_class AS dependent_view ON pg_rewrite.ev_class = dependent_view.oid
JOIN pg_class AS source_table ON pg_depend.refobjid = source_table.oid
JOIN pg_namespace dependent_ns ON dependent_view.relnamespace = dependent_ns.oid
JOIN pg_namespace source_ns ON source_table.relnamespace = source_ns.oid
WHERE dependent_ns.nspname = 'public'
ORDER BY dependent_view.relname;

-- 查看函数依赖
SELECT
    p.proname AS function_name,
    pg_get_functiondef(p.oid) AS function_definition
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public'
ORDER BY p.proname;
```

## 5. 性能分析

### 5.1 EXPLAIN分析

**执行计划解读**：

```sql
-- 查看执行计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT u.name, COUNT(o.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_at > '2025-01-01'
GROUP BY u.id, u.name
HAVING COUNT(o.id) > 10;

-- 执行计划关键指标
-- - Planning Time: 计划时间
-- - Execution Time: 执行时间
-- - Buffers: 缓存使用
--   - shared hit: 共享缓存命中
--   - shared read: 共享缓存读取
--   - temp read/write: 临时文件读写
```

**性能问题识别**：

- **Seq Scan**：全表扫描（可能缺少索引）
- **Nested Loop**：嵌套循环（可能性能差）
- **Hash Join**：哈希连接（适合大数据集）
- **Sort**：排序操作（可能影响性能）

### 5.2 pg_stat_statements

**查询统计**：

```sql
-- 重置统计
SELECT pg_stat_statements_reset();

-- 查看Top慢查询
SELECT
    LEFT(query, 100) AS query_preview,
    calls,
    total_exec_time / 1000 AS total_sec,
    mean_exec_time / 1000 AS mean_sec,
    max_exec_time / 1000 AS max_sec,
    stddev_exec_time / 1000 AS stddev_sec,
    rows
FROM pg_stat_statements
WHERE calls > 10
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 查看查询执行时间分布
SELECT
    query,
    calls,
    mean_exec_time,
    stddev_exec_time,
    CASE
        WHEN mean_exec_time < 10 THEN 'fast'
        WHEN mean_exec_time < 100 THEN 'medium'
        WHEN mean_exec_time < 1000 THEN 'slow'
        ELSE 'very_slow'
    END AS performance_category
FROM pg_stat_statements
WHERE calls > 100
ORDER BY mean_exec_time DESC;
```

### 5.3 慢查询分析

**慢查询识别**：

```sql
-- 查找慢查询（>100ms）
SELECT
    query,
    calls,
    mean_exec_time,
    max_exec_time,
    (mean_exec_time * calls) AS total_time
FROM pg_stat_statements
WHERE mean_exec_time > 100
ORDER BY total_time DESC
LIMIT 20;

-- 查找执行次数多但慢的查询
SELECT
    query,
    calls,
    mean_exec_time,
    (mean_exec_time * calls) AS total_time
FROM pg_stat_statements
WHERE calls > 1000 AND mean_exec_time > 50
ORDER BY total_time DESC;
```

### 5.4 索引使用分析

**索引使用统计**：

```sql
-- 查看索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;

-- 查找未使用的索引
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY schemaname, tablename;

-- 查看表扫描统计
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    CASE
        WHEN seq_scan + idx_scan > 0
        THEN round(100.0 * idx_scan / (seq_scan + idx_scan), 2)
        ELSE 0
    END AS index_usage_ratio
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;
```

---

## 6. 安全审计

### 6.1 SQL注入检测

**SQL注入检测**：

```sql
-- 检查动态SQL使用
SELECT
    routine_name,
    routine_definition
FROM information_schema.routines
WHERE routine_definition LIKE '%EXECUTE%'
  AND routine_definition LIKE '%$%';

-- 检查字符串拼接
SELECT
    routine_name,
    routine_definition
FROM information_schema.routines
WHERE routine_definition LIKE '%||%'
  AND routine_definition LIKE '%$%';
```

**安全最佳实践**：

- ✅ 使用参数化查询
- ✅ 使用预编译语句
- ❌ 避免字符串拼接
- ❌ 避免动态SQL

### 6.2 权限检查

**权限审计**：

```sql
-- 检查表权限
SELECT
    grantee,
    table_schema,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE grantee != 'postgres'
ORDER BY grantee, table_name;

-- 检查函数权限
SELECT
    grantee,
    routine_schema,
    routine_name,
    privilege_type
FROM information_schema.routine_privileges
WHERE grantee != 'postgres'
ORDER BY grantee, routine_name;

-- 检查角色权限
SELECT
    rolname,
    rolsuper,
    rolcreaterole,
    rolcreatedb
FROM pg_roles
WHERE rolname NOT IN ('postgres', 'pg_signal_backend')
ORDER BY rolname;
```

### 6.3 敏感数据检查

**敏感数据识别**：

```sql
-- 查找可能包含敏感数据的列
SELECT
    table_schema,
    table_name,
    column_name,
    data_type
FROM information_schema.columns
WHERE column_name ILIKE '%password%'
   OR column_name ILIKE '%secret%'
   OR column_name ILIKE '%token%'
   OR column_name ILIKE '%key%'
   OR column_name ILIKE '%ssn%'
   OR column_name ILIKE '%credit%'
ORDER BY table_schema, table_name, column_name;
```

## 7. 质量指标

### 7.1 代码质量指标

**完整指标矩阵**：

| 指标 | 目标 | 检查方法 | 工具 |
|------|------|---------|------|
| **代码覆盖率** | > 80% | 测试覆盖率 | pgTAP |
| **SQL复杂度** | < 10 | 静态分析 | 自定义函数 |
| **性能** | < 100ms | 性能测试 | EXPLAIN ANALYZE |
| **索引使用率** | > 90% | 索引统计 | pg_stat_user_indexes |
| **慢查询比例** | < 5% | 查询统计 | pg_stat_statements |
| **安全漏洞** | 0 | 安全审计 | 手动检查 |

### 7.2 性能指标

**性能指标**：

```sql
-- 计算性能指标
WITH performance_metrics AS (
    SELECT
        COUNT(*) FILTER (WHERE mean_exec_time < 10) AS fast_queries,
        COUNT(*) FILTER (WHERE mean_exec_time BETWEEN 10 AND 100) AS medium_queries,
        COUNT(*) FILTER (WHERE mean_exec_time > 100) AS slow_queries,
        COUNT(*) AS total_queries
    FROM pg_stat_statements
    WHERE calls > 10
)
SELECT
    total_queries,
    fast_queries,
    medium_queries,
    slow_queries,
    round(100.0 * fast_queries / total_queries, 2) AS fast_percentage,
    round(100.0 * slow_queries / total_queries, 2) AS slow_percentage
FROM performance_metrics;
```

### 7.3 安全指标

**安全指标**：

- **SQL注入风险**：0个高风险查询
- **权限过度授予**：< 5%的表
- **敏感数据加密**：100%加密
- **审计日志**：100%覆盖

## 8. 持续集成

### 8.1 CI/CD集成

**GitHub Actions示例**：

```yaml
name: SQL Quality Check

on: [push, pull_request]

jobs:
  sql-quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Setup PostgreSQL
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Install sqlfluff
        run: pip install sqlfluff

      - name: Run sqlfluff
        run: sqlfluff lint --recursive sql/

      - name: Run pgTAP tests
        run: |
          pg_prove -d ${{ secrets.DB_NAME }} tests/
        env:
          PGHOST: ${{ secrets.DB_HOST }}
          PGUSER: ${{ secrets.DB_USER }}
          PGPASSWORD: ${{ secrets.DB_PASSWORD }}
```

### 8.2 自动化检查

**预提交钩子**：

```bash
#!/bin/bash
# .git/hooks/pre-commit

# 运行sqlfluff
sqlfluff lint --recursive sql/
if [ $? -ne 0 ]; then
    echo "SQL质量检查失败，请修复后重试"
    exit 1
fi

# 运行pgFormatter检查格式
pg_format --check sql/*.sql
if [ $? -ne 0 ]; then
    echo "SQL格式检查失败，请格式化后重试"
    exit 1
fi

exit 0
```

### 8.3 质量门禁

**质量门禁规则**：

- ✅ 所有SQL文件通过sqlfluff检查
- ✅ 代码覆盖率 > 80%
- ✅ 无慢查询（>100ms）
- ✅ 无安全漏洞
- ✅ 通过所有单元测试

## 9. 最佳实践

### 9.1 代码规范

**SQL代码规范**：

1. **命名规范**
   - 表名：小写，下划线分隔（users, order_items）
   - 列名：小写，下划线分隔（user_id, created_at）
   - 函数名：小写，下划线分隔（get_user_count）

2. **格式规范**
   - 关键字大写（SELECT, FROM, WHERE）
   - 缩进4个空格
   - 每行不超过100字符

3. **注释规范**
   - 函数注释说明参数和返回值
   - 复杂查询添加注释
   - 业务逻辑添加注释

### 9.2 审查流程

**标准审查流程**：

1. **提交前**：运行自动化检查
2. **提交后**：分配审查者
3. **审查中**：使用审查清单
4. **审查后**：提出修改意见
5. **修改后**：再次审查
6. **通过后**：合并代码

### 9.3 持续改进

**改进措施**：

1. **定期审查**：每周代码审查会议
2. **质量报告**：每月质量报告
3. **培训**：定期技术培训
4. **工具更新**：及时更新检查工具
5. **规则优化**：根据实际情况调整规则

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [测试自动化.md](./测试自动化.md) - 测试自动化
- [单元测试.md](./单元测试.md) - 单元测试详解
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**文档版本**: v1.0
**最后更新**: 2025年1月
**维护者**: PostgreSQL开发团队

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [测试自动化.md](./测试自动化.md) - 测试自动化
- [单元测试.md](./单元测试.md) - 单元测试详解
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**最后更新**: 2025年1月
