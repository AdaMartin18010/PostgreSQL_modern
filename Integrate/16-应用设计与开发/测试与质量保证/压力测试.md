# PostgreSQL压力测试完整指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐⭐ 高级
> **适用场景**: 极限负载测试、系统容量测试、稳定性测试、故障恢复测试

---

## 📋 目录

- [PostgreSQL压力测试完整指南](#postgresql压力测试完整指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 压力测试的重要性](#11-压力测试的重要性)
    - [1.2 压力测试目标](#12-压力测试目标)
    - [1.3 压力测试类型](#13-压力测试类型)
  - [2. 压力测试工具](#2-压力测试工具)
    - [2.1 pgbench压力测试](#21-pgbench压力测试)
    - [2.2 自定义压力脚本](#22-自定义压力脚本)
    - [2.3 分布式压力测试](#23-分布式压力测试)
  - [3. 测试场景设计](#3-测试场景设计)
    - [3.1 高并发读取场景](#31-高并发读取场景)
    - [3.2 高并发写入场景](#32-高并发写入场景)
    - [3.3 混合负载场景](#33-混合负载场景)
    - [3.4 峰值负载场景](#34-峰值负载场景)
    - [3.5 长时间稳定性场景](#35-长时间稳定性场景)
  - [4. 压力测试执行](#4-压力测试执行)
    - [4.1 测试前准备](#41-测试前准备)
    - [4.2 渐进式压力测试](#42-渐进式压力测试)
    - [4.3 极限压力测试](#43-极限压力测试)
    - [4.4 压力测试监控](#44-压力测试监控)
  - [5. 监控指标](#5-监控指标)
    - [5.1 数据库性能指标](#51-数据库性能指标)
    - [5.2 系统资源指标](#52-系统资源指标)
    - [5.3 应用层指标](#53-应用层指标)
    - [5.4 实时监控工具](#54-实时监控工具)
  - [6. 瓶颈识别](#6-瓶颈识别)
    - [6.1 CPU瓶颈识别](#61-cpu瓶颈识别)
    - [6.2 内存瓶颈识别](#62-内存瓶颈识别)
    - [6.3 I/O瓶颈识别](#63-io瓶颈识别)
    - [6.4 锁竞争识别](#64-锁竞争识别)
    - [6.5 连接数瓶颈识别](#65-连接数瓶颈识别)
  - [7. 结果分析](#7-结果分析)
    - [7.1 性能指标分析](#71-性能指标分析)
    - [7.2 资源使用分析](#72-资源使用分析)
    - [7.3 错误分析](#73-错误分析)
    - [7.4 瓶颈分析报告](#74-瓶颈分析报告)
  - [8. 优化建议](#8-优化建议)
    - [8.1 查询优化](#81-查询优化)
    - [8.2 索引优化](#82-索引优化)
    - [8.3 配置优化](#83-配置优化)
    - [8.4 架构优化](#84-架构优化)
  - [9. 故障场景测试](#9-故障场景测试)
    - [9.1 连接数耗尽测试](#91-连接数耗尽测试)
    - [9.2 磁盘空间耗尽测试](#92-磁盘空间耗尽测试)
    - [9.3 内存耗尽测试](#93-内存耗尽测试)
    - [9.4 网络故障测试](#94-网络故障测试)
  - [10. 压力测试最佳实践](#10-压力测试最佳实践)
    - [10.1 推荐做法](#101-推荐做法)
    - [10.2 常见错误](#102-常见错误)
    - [10.3 压力测试计划](#103-压力测试计划)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 压力测试的重要性

压力测试验证PostgreSQL在极限负载下的表现，是确保系统在生产环境中稳定运行的关键环节。

**压力测试的价值**：

- **发现性能瓶颈**：识别系统在极限负载下的瓶颈点
- **确定系统极限**：了解系统的最大处理能力
- **验证稳定性**：确保系统在高压下不会崩溃
- **容量规划**：为系统扩容提供数据支持
- **故障预防**：提前发现潜在问题

**压力测试与性能测试的区别**：

| 特性 | 性能测试 | 压力测试 |
|------|---------|---------|
| **负载水平** | 正常负载 | 极限负载 |
| **测试目标** | 验证性能指标 | 发现系统极限 |
| **测试时长** | 较短 | 较长 |
| **关注点** | TPS、延迟 | 稳定性、瓶颈 |

### 1.2 压力测试目标

**测试目标**:

- **发现性能瓶颈**：识别CPU、内存、I/O、锁等瓶颈
- **确定系统极限**：找到系统的最大处理能力
- **验证稳定性**：确保系统在高压下稳定运行
- **优化配置**：根据测试结果优化数据库配置
- **容量规划**：为未来扩容提供依据

### 1.3 压力测试类型

**压力测试类型**：

1. **负载测试**：逐步增加负载，观察性能变化
2. **压力测试**：超过正常负载，测试系统极限
3. **峰值测试**：模拟突发峰值负载
4. **容量测试**：确定系统最大容量
5. **稳定性测试**：长时间高负载下的稳定性
6. **故障恢复测试**：测试故障后的恢复能力

---

## 2. 压力测试工具

### 2.1 pgbench压力测试

**基础压力测试**：

```bash
# 高并发压力测试
pgbench -c 100 -j 8 -T 300 mydb

# 参数说明：
# -c: 100个客户端（并发连接数）
# -j: 8个线程（通常设置为CPU核心数）
# -T: 运行5分钟（300秒）
```

**极限压力测试**：

```bash
# 极限并发测试（200个客户端）
pgbench -c 200 -j 16 -T 600 mydb

# 超高并发测试（500个客户端）
pgbench -c 500 -j 32 -T 600 mydb

# 长时间稳定性测试（1小时）
pgbench -c 100 -j 8 -T 3600 mydb
```

**压力测试选项**：

```bash
# 指定报告间隔
pgbench -c 100 -j 8 -T 600 --progress=30 mydb  # 每30秒报告一次

# 详细统计
pgbench -c 100 -j 8 -T 600 -r mydb  # 显示每个语句的统计

# 记录延迟分布
pgbench -c 100 -j 8 -T 600 --latency-limit=100 mydb  # 记录超过100ms的事务

# 指定连接建立方式
pgbench -c 100 -j 8 -T 600 --connect mydb  # 每个事务建立新连接（压力更大）
```

### 2.2 自定义压力脚本

**创建压力测试脚本**：

```sql
-- stress_test.sql
-- 定义变量
\set id random(1, 1000000)
\set amount random(1, 1000)

-- 压力测试事务
BEGIN;
SELECT * FROM users WHERE id = :id;
UPDATE users SET last_login = NOW() WHERE id = :id;
INSERT INTO logs (user_id, action, amount) VALUES (:id, 'stress_test', :amount);
UPDATE accounts SET balance = balance - :amount WHERE user_id = :id;
COMMIT;
```

**运行自定义压力脚本**：

```bash
# 基础运行
pgbench -c 200 -j 16 -T 600 -f stress_test.sql mydb

# 指定变量值
pgbench -c 200 -j 16 -T 600 -f stress_test.sql \
  -D id=1000 -D amount=500 mydb

# 使用多个脚本文件
pgbench -c 200 -j 16 -T 600 \
  -f read_stress.sql \
  -f write_stress.sql \
  -f mixed_stress.sql mydb
```

**复杂压力测试脚本**：

```sql
-- complex_stress_test.sql
\set id random(1, 1000000)
\set amount random(1, 1000)
\set probability random(1, 100)

BEGIN;
-- 90%概率读取，10%概率写入
SELECT CASE
    WHEN :probability <= 90 THEN
        (SELECT * FROM users WHERE id = :id)
    ELSE
        (UPDATE users SET last_login = NOW() WHERE id = :id RETURNING *)
END;
COMMIT;
```

### 2.3 分布式压力测试

**多机压力测试**：

```bash
# 在多个机器上同时运行压力测试
# 机器1
pgbench -c 50 -j 4 -T 600 mydb &

# 机器2
pgbench -c 50 -j 4 -T 600 mydb &

# 机器3
pgbench -c 50 -j 4 -T 600 mydb &

# 等待所有测试完成
wait
```

**使用pgbench的客户端-服务器模式**：

```bash
# 服务器端（数据库服务器）
# 不需要特殊配置

# 客户端1
pgbench -h db-server -c 50 -j 4 -T 600 mydb

# 客户端2
pgbench -h db-server -c 50 -j 4 -T 600 mydb

# 客户端3
pgbench -h db-server -c 50 -j 4 -T 600 mydb
```

---

## 3. 测试场景设计

### 3.1 高并发读取场景

**只读压力测试**：

```bash
# 基础只读压力测试
pgbench -c 200 -j 16 -T 300 -S mydb

# -S: 只读模式（SELECT only）
# 测试场景：大量并发查询
```

**自定义只读压力脚本**：

```sql
-- read_stress.sql
\set id random(1, 1000000)
SELECT * FROM users WHERE id = :id;
SELECT * FROM orders WHERE user_id = :id;
SELECT * FROM products WHERE id = :id;
```

```bash
pgbench -c 200 -j 16 -T 300 -f read_stress.sql mydb
```

**只读压力测试指标**：

- **QPS**：每秒查询数
- **平均延迟**：查询平均响应时间
- **P95/P99延迟**：95%/99%分位延迟
- **缓存命中率**：shared_buffers命中率

### 3.2 高并发写入场景

**写入压力测试**：

```bash
# 基础写入压力测试
pgbench -c 100 -j 8 -T 300 -N mydb

# -N: 跳过SELECT（只测试写入）
```

**自定义写入压力脚本**：

```sql
-- write_stress.sql
\set id random(1, 1000000)
\set amount random(1, 1000)
BEGIN;
INSERT INTO logs (user_id, action, amount) VALUES (:id, 'test', :amount);
UPDATE users SET last_login = NOW() WHERE id = :id;
UPDATE accounts SET balance = balance + :amount WHERE user_id = :id;
COMMIT;
```

```bash
pgbench -c 100 -j 8 -T 300 -f write_stress.sql mydb
```

**写入压力测试指标**：

- **TPS**：每秒事务数
- **写入延迟**：INSERT/UPDATE/DELETE延迟
- **WAL生成速率**：WAL文件生成速度
- **检查点频率**：checkpoint频率

### 3.3 混合负载场景

**混合负载测试**：

```bash
# 基础混合负载测试
pgbench -c 150 -j 12 -T 300 mydb

# 默认TPC-B测试包含读写混合操作
```

**自定义混合负载脚本**：

```sql
-- mixed_stress.sql
\set id random(1, 1000000)
\set amount random(1, 1000)
\set operation random(1, 100)

BEGIN;
-- 70%读取，30%写入
IF :operation <= 70 THEN
    SELECT * FROM users WHERE id = :id;
    SELECT * FROM orders WHERE user_id = :id;
ELSE
    UPDATE users SET last_login = NOW() WHERE id = :id;
    INSERT INTO logs (user_id, action) VALUES (:id, 'update');
END IF;
COMMIT;
```

**混合负载测试指标**：

- **整体TPS**：混合负载下的TPS
- **读写比例**：读取和写入的比例
- **锁等待时间**：锁竞争情况
- **资源使用**：CPU、内存、I/O使用率

### 3.4 峰值负载场景

**峰值负载测试**：

```bash
# 模拟突发峰值负载
# 阶段1：正常负载（1分钟）
pgbench -c 50 -j 4 -T 60 mydb

# 阶段2：峰值负载（30秒）
pgbench -c 500 -j 32 -T 30 mydb

# 阶段3：恢复正常（1分钟）
pgbench -c 50 -j 4 -T 60 mydb
```

**峰值负载脚本**：

```bash
#!/bin/bash
# peak_load_test.sh

# 正常负载
pgbench -c 50 -j 4 -T 60 mydb &
NORMAL_PID=$!

sleep 60

# 峰值负载
pgbench -c 500 -j 32 -T 30 mydb &
PEAK_PID=$!

wait $PEAK_PID

# 恢复正常
pgbench -c 50 -j 4 -T 60 mydb &
RECOVERY_PID=$!

wait $RECOVERY_PID
```

### 3.5 长时间稳定性场景

**长时间稳定性测试**：

```bash
# 24小时稳定性测试
pgbench -c 100 -j 8 -T 86400 mydb

# 7天稳定性测试
pgbench -c 100 -j 8 -T 604800 mydb
```

**长时间稳定性监控**：

```sql
-- 创建监控表
CREATE TABLE stress_test_metrics (
    timestamp TIMESTAMP DEFAULT NOW(),
    tps NUMERIC,
    avg_latency NUMERIC,
    cpu_usage NUMERIC,
    memory_usage NUMERIC,
    io_wait NUMERIC
);

-- 定期记录指标（使用cron或pg_cron）
INSERT INTO stress_test_metrics (tps, avg_latency, cpu_usage, memory_usage, io_wait)
SELECT
    (SELECT tps FROM pg_stat_database WHERE datname = current_database()),
    (SELECT avg(mean_exec_time) FROM pg_stat_statements),
    (SELECT cpu_usage FROM system_metrics),
    (SELECT memory_usage FROM system_metrics),
    (SELECT io_wait FROM system_metrics);
```

---

## 4. 压力测试执行

### 4.1 测试前准备

**测试环境准备**：

```bash
# 1. 备份生产数据（如果使用生产数据）
pg_dump mydb > backup.sql

# 2. 准备测试数据库
createdb stress_test_db
psql stress_test_db < schema.sql

# 3. 初始化测试数据
pgbench -i -s 100 stress_test_db  # 100倍标准数据量

# 4. 创建必要的索引
psql stress_test_db -c "CREATE INDEX idx_users_email ON users(email);"

# 5. 更新统计信息
psql stress_test_db -c "ANALYZE;"
```

**数据库配置优化**：

```sql
-- 压力测试专用配置
ALTER SYSTEM SET max_connections = 500;
ALTER SYSTEM SET shared_buffers = '4GB';
ALTER SYSTEM SET work_mem = '64MB';
ALTER SYSTEM SET maintenance_work_mem = '1GB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;

-- 重启PostgreSQL使配置生效
SELECT pg_reload_conf();
```

### 4.2 渐进式压力测试

**渐进式压力测试策略**：

```bash
#!/bin/bash
# progressive_stress_test.sh

# 阶段1：低负载（10个客户端，1分钟）
echo "阶段1：低负载测试"
pgbench -c 10 -j 2 -T 60 -r mydb > results_stage1.txt

# 阶段2：中等负载（50个客户端，2分钟）
echo "阶段2：中等负载测试"
pgbench -c 50 -j 4 -T 120 -r mydb > results_stage2.txt

# 阶段3：高负载（100个客户端，3分钟）
echo "阶段3：高负载测试"
pgbench -c 100 -j 8 -T 180 -r mydb > results_stage3.txt

# 阶段4：极高负载（200个客户端，5分钟）
echo "阶段4：极高负载测试"
pgbench -c 200 -j 16 -T 300 -r mydb > results_stage4.txt

# 阶段5：极限负载（500个客户端，10分钟）
echo "阶段5：极限负载测试"
pgbench -c 500 -j 32 -T 600 -r mydb > results_stage5.txt
```

### 4.3 极限压力测试

**极限压力测试**：

```bash
# 极限并发测试（接近max_connections）
pgbench -c 450 -j 32 -T 600 mydb

# 极限写入测试
pgbench -c 200 -j 16 -T 600 -N mydb

# 极限读取测试
pgbench -c 500 -j 32 -T 600 -S mydb
```

### 4.4 压力测试监控

**实时监控脚本**：

```bash
#!/bin/bash
# monitor_stress_test.sh

while true; do
    echo "=== $(date) ==="

    # 数据库连接数
    psql -c "SELECT COUNT(*) as connections FROM pg_stat_activity;"

    # 锁等待
    psql -c "SELECT COUNT(*) as lock_waits FROM pg_locks WHERE NOT granted;"

    # 慢查询
    psql -c "SELECT COUNT(*) as slow_queries FROM pg_stat_statements WHERE mean_exec_time > 1000;"

    # 系统资源
    top -bn1 | grep postgres | head -1

    sleep 10
done
```

## 5. 监控指标

### 5.1 数据库性能指标

**关键数据库指标**：

```sql
-- 连接数监控
SELECT
    COUNT(*) as total_connections,
    COUNT(*) FILTER (WHERE state = 'active') as active_connections,
    COUNT(*) FILTER (WHERE state = 'idle') as idle_connections,
    COUNT(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction
FROM pg_stat_activity;

-- 锁等待监控
SELECT
    COUNT(*) as total_locks,
    COUNT(*) FILTER (WHERE NOT granted) as waiting_locks,
    COUNT(*) FILTER (WHERE granted) as granted_locks
FROM pg_locks;

-- 慢查询监控
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 1000
ORDER BY mean_exec_time DESC
LIMIT 10;

-- TPS监控
SELECT
    xact_commit + xact_rollback as total_transactions,
    xact_commit,
    xact_rollback
FROM pg_stat_database
WHERE datname = current_database();
```

### 5.2 系统资源指标

**系统资源监控**：

```bash
# CPU使用监控
top -p $(pgrep -f postgres) -n 1

# 内存使用监控
ps aux | grep postgres | awk '{sum+=$6} END {print sum/1024 " MB"}'

# I/O监控
iostat -x 1

# 磁盘使用监控
df -h

# 网络监控
iftop -i eth0
```

**PostgreSQL资源使用查询**：

```sql
-- 共享缓冲区使用
SELECT
    setting::bigint * 8192 / 1024 / 1024 as shared_buffers_mb,
    (SELECT COUNT(*) * 8192 / 1024 / 1024 FROM pg_buffercache) as used_mb
FROM pg_settings WHERE name = 'shared_buffers';

-- 临时文件使用
SELECT
    datname,
    temp_files,
    temp_bytes
FROM pg_stat_database
WHERE datname = current_database();
```

### 5.3 应用层指标

**应用层监控指标**：

- **请求响应时间**：应用层请求的响应时间
- **错误率**：请求失败的比例
- **吞吐量**：每秒处理的请求数
- **并发用户数**：同时在线用户数

### 5.4 实时监控工具

**使用Prometheus + Grafana监控**：

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'postgres'
    static_configs:
      - targets: ['localhost:9187']
```

**使用pg_stat_statements监控**：

```sql
-- 启用pg_stat_statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 查看实时统计
SELECT * FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;
```

## 6. 瓶颈识别

### 6.1 CPU瓶颈识别

**CPU瓶颈特征**：

- CPU使用率持续 > 80%
- 大量CPU密集型查询（排序、聚合）
- 查询计划中出现大量Sort、Hash操作

**识别CPU瓶颈**：

```sql
-- 查找CPU密集型查询
SELECT
    query,
    calls,
    mean_exec_time,
    (mean_exec_time * calls) as total_time
FROM pg_stat_statements
WHERE query LIKE '%ORDER BY%' OR query LIKE '%GROUP BY%'
ORDER BY total_time DESC
LIMIT 10;
```

### 6.2 内存瓶颈识别

**内存瓶颈特征**：

- 内存使用率 > 90%
- 大量临时文件生成
- work_mem不足导致磁盘排序

**识别内存瓶颈**：

```sql
-- 检查临时文件使用
SELECT
    datname,
    temp_files,
    temp_bytes,
    pg_size_pretty(temp_bytes) as temp_size
FROM pg_stat_database
WHERE temp_files > 0
ORDER BY temp_bytes DESC;

-- 检查work_mem使用
SELECT
    name,
    setting,
    unit,
    context
FROM pg_settings
WHERE name = 'work_mem';
```

### 6.3 I/O瓶颈识别

**I/O瓶颈特征**：

- I/O等待时间 > 10ms
- 大量磁盘读取
- 缓存命中率 < 90%

**识别I/O瓶颈**：

```sql
-- 检查缓存命中率
SELECT
    sum(heap_blks_read) as heap_read,
    sum(heap_blks_hit) as heap_hit,
    round(sum(heap_blks_hit)::numeric / (sum(heap_blks_hit) + sum(heap_blks_read)), 2) as hit_ratio
FROM pg_statio_user_tables;

-- 检查I/O统计（PostgreSQL 16+）
SELECT
    backend_type,
    object,
    reads,
    writes,
    extends
FROM pg_stat_io
ORDER BY reads + writes DESC;
```

### 6.4 锁竞争识别

**锁竞争特征**：

- 大量锁等待
- 事务执行时间异常长
- 死锁频繁发生

**识别锁竞争**：

```sql
-- 查看锁等待
SELECT
    blocked_locks.pid AS blocked_pid,
    blocking_locks.pid AS blocking_pid,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted
  AND blocked_locks.pid != blocking_locks.pid;
```

### 6.5 连接数瓶颈识别

**连接数瓶颈特征**：

- 连接数接近max_connections
- 大量连接等待
- 新连接无法建立

**识别连接数瓶颈**：

```sql
-- 检查连接数使用情况
SELECT
    setting::int as max_connections,
    (SELECT COUNT(*) FROM pg_stat_activity) as current_connections,
    setting::int - (SELECT COUNT(*) FROM pg_stat_activity) as available_connections,
    round((SELECT COUNT(*) FROM pg_stat_activity)::numeric / setting::numeric * 100, 2) as usage_percent
FROM pg_settings
WHERE name = 'max_connections';
```

## 7. 结果分析

### 7.1 性能指标分析

**关键性能指标**：

| 指标 | 正常范围 | 压力测试范围 | 异常处理 |
|------|---------|------------|---------|
| **TPS** | > 1000 | > 500 | 优化查询、索引 |
| **平均延迟** | < 100ms | < 500ms | 优化查询计划 |
| **P95延迟** | < 200ms | < 1000ms | 优化慢查询 |
| **P99延迟** | < 500ms | < 2000ms | 优化索引 |
| **连接数** | < 80% max | < 90% max | 增加连接池 |
| **CPU使用率** | < 70% | < 90% | 优化查询 |
| **内存使用率** | < 80% | < 95% | 增加内存 |
| **I/O等待** | < 5ms | < 20ms | 优化I/O |

### 7.2 资源使用分析

**资源使用趋势分析**：

```sql
-- 创建资源使用记录表
CREATE TABLE stress_test_resource_usage (
    timestamp TIMESTAMP DEFAULT NOW(),
    cpu_usage NUMERIC,
    memory_usage NUMERIC,
    io_wait NUMERIC,
    connections INT,
    tps NUMERIC
);

-- 分析资源使用趋势
SELECT
    date_trunc('minute', timestamp) as minute,
    AVG(cpu_usage) as avg_cpu,
    AVG(memory_usage) as avg_memory,
    AVG(io_wait) as avg_io_wait,
    AVG(tps) as avg_tps
FROM stress_test_resource_usage
GROUP BY minute
ORDER BY minute;
```

### 7.3 错误分析

**错误类型分析**：

```sql
-- 查看错误日志中的错误类型
SELECT
    error_severity,
    COUNT(*) as error_count
FROM pg_stat_database
GROUP BY error_severity;

-- 查看连接错误
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback
FROM pg_stat_database
WHERE xact_rollback > 0;
```

### 7.4 瓶颈分析报告

**生成瓶颈分析报告**：

```sql
-- 创建瓶颈分析视图
CREATE VIEW bottleneck_analysis AS
SELECT
    'CPU' as bottleneck_type,
    COUNT(*) as occurrence_count,
    AVG(mean_exec_time) as avg_time
FROM pg_stat_statements
WHERE mean_exec_time > 1000
  AND query LIKE '%ORDER BY%'
UNION ALL
SELECT
    'I/O' as bottleneck_type,
    COUNT(*) as occurrence_count,
    AVG(mean_exec_time) as avg_time
FROM pg_stat_statements
WHERE mean_exec_time > 1000
  AND query LIKE '%Seq Scan%'
UNION ALL
SELECT
    'Lock' as bottleneck_type,
    COUNT(*) as occurrence_count,
    NULL as avg_time
FROM pg_locks
WHERE NOT granted;
```

## 8. 优化建议

### 8.1 查询优化

**查询优化建议**：

1. **优化慢查询**
   - 使用EXPLAIN (ANALYZE, BUFFERS, TIMING)分析查询计划
   - 添加缺失的索引
   - 重写低效查询

2. **减少全表扫描**
   - 创建合适的索引
   - 优化WHERE条件
   - 使用覆盖索引

3. **优化JOIN操作**
   - 确保JOIN条件有索引
   - 调整JOIN顺序
   - 使用合适的JOIN类型

### 8.2 索引优化

**索引优化建议**：

1. **创建缺失索引**

   ```sql
   -- 查找缺失索引
   SELECT * FROM pg_stat_user_tables
   WHERE seq_scan > idx_scan * 10;
   ```

2. **删除未使用索引**

   ```sql
   -- 查找未使用索引
   SELECT * FROM pg_stat_user_indexes
   WHERE idx_scan = 0;
   ```

3. **优化索引大小**

   ```sql
   -- 使用部分索引
   CREATE INDEX idx_active_users ON users(email) WHERE active = TRUE;
   ```

### 8.3 配置优化

**配置优化建议**：

```sql
-- 根据压力测试结果调整配置
ALTER SYSTEM SET shared_buffers = '4GB';  -- 增加共享缓冲区
ALTER SYSTEM SET work_mem = '64MB';       -- 增加工作内存
ALTER SYSTEM SET maintenance_work_mem = '1GB';  -- 增加维护工作内存
ALTER SYSTEM SET max_connections = 500;   -- 增加最大连接数
ALTER SYSTEM SET checkpoint_completion_target = 0.9;  -- 优化检查点
```

### 8.4 架构优化

**架构优化建议**：

1. **读写分离**
   - 使用主从复制
   - 读请求路由到从库
   - 写请求路由到主库

2. **连接池**
   - 使用PgBouncer或PgPool
   - 减少数据库连接数
   - 提高连接复用率

3. **分区表**
   - 对大表进行分区
   - 提高查询性能
   - 简化数据管理

## 9. 故障场景测试

### 9.1 连接数耗尽测试

**测试连接数耗尽场景**：

```bash
# 创建大量连接直到耗尽
for i in {1..500}; do
    psql -c "SELECT pg_sleep(3600);" &
done
```

**监控连接数**：

```sql
SELECT COUNT(*) FROM pg_stat_activity;
```

### 9.2 磁盘空间耗尽测试

**测试磁盘空间耗尽**：

```sql
-- 创建大量数据
DO $$
DECLARE
    i INT;
BEGIN
    FOR i IN 1..1000000 LOOP
        INSERT INTO test_table VALUES (i, 'test data ' || i);
    END LOOP;
END $$;
```

### 9.3 内存耗尽测试

**测试内存耗尽场景**：

```sql
-- 创建大量临时数据
SELECT * FROM large_table
ORDER BY random()
LIMIT 10000000;
```

### 9.4 网络故障测试

**模拟网络故障**：

```bash
# 使用iptables模拟网络延迟
sudo iptables -A OUTPUT -p tcp --dport 5432 -j DROP

# 恢复网络
sudo iptables -D OUTPUT -p tcp --dport 5432 -j DROP
```

## 10. 压力测试最佳实践

### 10.1 推荐做法

**✅ 推荐做法**：

1. **测试前准备**
   - 备份生产数据
   - 准备独立的测试环境
   - 配置监控工具

2. **渐进式测试**
   - 从低负载开始
   - 逐步增加负载
   - 观察性能变化

3. **全面监控**
   - 监控数据库指标
   - 监控系统资源
   - 监控应用指标

4. **详细记录**
   - 记录测试配置
   - 记录测试结果
   - 记录瓶颈分析

### 10.2 常见错误

**❌ 避免做法**：

1. **测试环境不一致**
   - 避免在生产环境直接测试
   - 避免测试数据量过小
   - 避免配置参数不一致

2. **测试时间过短**
   - 避免测试时间 < 5分钟
   - 避免忽略预热阶段
   - 避免单次测试结果

3. **忽略系统资源**
   - 避免只关注TPS
   - 避免忽略CPU/内存/I/O
   - 避免忽略锁竞争

### 10.3 压力测试计划

**压力测试计划模板**：

```text
1. 测试目标
   - 确定压力测试目标
   - 定义成功标准

2. 测试环境
   - 硬件配置
   - 软件版本
   - 数据库配置

3. 测试场景
   - 高并发读取场景
   - 高并发写入场景
   - 混合负载场景
   - 峰值负载场景

4. 测试执行
   - 渐进式压力测试
   - 极限压力测试
   - 长时间稳定性测试

5. 监控指标
   - 数据库性能指标
   - 系统资源指标
   - 应用层指标

6. 结果分析
   - 性能指标分析
   - 瓶颈识别
   - 优化建议

7. 报告生成
   - 测试结果报告
   - 瓶颈分析报告
   - 优化建议报告
```

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [单元测试.md](./单元测试.md) - 单元测试详解
- [集成测试.md](./集成测试.md) - 集成测试详解
- [性能测试.md](./性能测试.md) - 性能测试详解
- [测试自动化.md](./测试自动化.md) - 测试自动化
- [代码质量检查.md](./代码质量检查.md) - 代码质量检查
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**文档版本**: v1.0
**最后更新**: 2025年1月
**维护者**: PostgreSQL开发团队
