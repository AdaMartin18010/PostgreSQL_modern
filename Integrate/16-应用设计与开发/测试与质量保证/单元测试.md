# PostgreSQL单元测试完整指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级
> **适用场景**: 函数测试、触发器测试、视图测试、约束测试

---

## 📋 目录

- [PostgreSQL单元测试完整指南](#postgresql单元测试完整指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 单元测试的重要性](#11-单元测试的重要性)
    - [1.2 测试对象](#12-测试对象)
    - [1.3 测试原则](#13-测试原则)
  - [2. pgTAP使用](#2-pgtap使用)
    - [2.1 安装pgTAP](#21-安装pgtap)
    - [2.2 基本测试语法](#22-基本测试语法)
    - [2.3 测试函数详解](#23-测试函数详解)
    - [2.4 测试模式](#24-测试模式)
  - [3. 函数测试](#3-函数测试)
    - [3.1 标量函数测试](#31-标量函数测试)
    - [3.2 表函数测试](#32-表函数测试)
    - [3.3 聚合函数测试](#33-聚合函数测试)
    - [3.4 窗口函数测试](#34-窗口函数测试)
    - [3.5 错误处理测试](#35-错误处理测试)
  - [4. 触发器测试](#4-触发器测试)
    - [4.1 BEFORE触发器测试](#41-before触发器测试)
    - [4.2 AFTER触发器测试](#42-after触发器测试)
    - [4.3 INSTEAD OF触发器测试](#43-instead-of触发器测试)
    - [4.4 触发器执行顺序测试](#44-触发器执行顺序测试)
  - [5. 视图测试](#5-视图测试)
    - [5.1 简单视图测试](#51-简单视图测试)
    - [5.2 复杂视图测试](#52-复杂视图测试)
    - [5.3 物化视图测试](#53-物化视图测试)
  - [6. 约束测试](#6-约束测试)
    - [6.1 CHECK约束测试](#61-check约束测试)
    - [6.2 UNIQUE约束测试](#62-unique约束测试)
    - [6.3 FOREIGN KEY约束测试](#63-foreign-key约束测试)
  - [7. 测试数据准备](#7-测试数据准备)
    - [7.1 测试数据生成](#71-测试数据生成)
    - [7.2 测试数据清理](#72-测试数据清理)
    - [7.3 测试数据隔离](#73-测试数据隔离)
  - [8. 测试覆盖率](#8-测试覆盖率)
    - [8.1 覆盖率指标](#81-覆盖率指标)
    - [8.2 覆盖率工具](#82-覆盖率工具)
    - [8.3 覆盖率报告](#83-覆盖率报告)
  - [9. 测试组织](#9-测试组织)
    - [9.1 测试文件结构](#91-测试文件结构)
    - [9.2 测试命名规范](#92-测试命名规范)
    - [9.3 测试运行](#93-测试运行)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 推荐做法](#101-推荐做法)
    - [10.2 常见错误](#102-常见错误)
    - [10.3 性能考虑](#103-性能考虑)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 单元测试的重要性

单元测试验证PostgreSQL函数、触发器等单个组件的正确性，是确保代码质量的关键环节。

**单元测试的价值**：

- **早期发现问题**：在开发阶段发现bug，降低修复成本
- **文档作用**：测试用例本身就是最好的文档
- **重构信心**：有测试保障，重构更安全
- **设计验证**：测试帮助验证设计是否合理

**测试金字塔**：

```text
        /\
       /  \
      /集成\
     / 测试 \
    /--------\
   /  单元    \
  /   测试    \
 /------------\
```

- **单元测试**：数量最多，执行最快，覆盖最广
- **集成测试**：数量中等，验证组件协作
- **端到端测试**：数量最少，验证完整流程

### 1.2 测试对象

**测试对象**:

- **函数**：标量函数、表函数、聚合函数、窗口函数
- **触发器**：BEFORE/AFTER/INSTEAD OF触发器
- **视图**：简单视图、复杂视图、物化视图
- **约束**：CHECK、UNIQUE、FOREIGN KEY约束
- **存储过程**：PL/pgSQL存储过程
- **扩展**：自定义扩展函数

### 1.3 测试原则

**FIRST原则**：

- **Fast**：测试执行要快
- **Independent**：测试之间相互独立
- **Repeatable**：测试结果可重复
- **Self-validating**：测试自动验证结果
- **Timely**：及时编写测试

---

## 2. pgTAP使用

### 2.1 安装pgTAP

**安装方法**：

```bash
# Ubuntu/Debian
sudo apt-get install postgresql-XX-pgtap

# macOS
brew install pgtap

# 从源码编译
git clone https://github.com/theory/pgtap.git
cd pgtap
make && sudo make install
```

**启用扩展**：

```sql
-- 在测试数据库中启用pgTAP
CREATE EXTENSION IF NOT EXISTS pgtap;

-- 验证安装
SELECT * FROM pg_extension WHERE extname = 'pgtap';
```

### 2.2 基本测试语法

**基本测试结构**：

```sql
-- 1. 声明测试计划
BEGIN;
SELECT plan(测试数量);

-- 2. 执行测试
SELECT ok(条件, '测试描述');
SELECT is(实际值, 期望值, '测试描述');
SELECT isnt(实际值, 不期望值, '测试描述');

-- 3. 完成测试
SELECT * FROM finish();
ROLLBACK;
```

**基本测试示例**：

```sql
BEGIN;
SELECT plan(4);

-- 测试1: 表存在
SELECT ok(
    EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema = 'public' AND table_name = 'users'
    ),
    'users表应该存在'
);

-- 测试2: 列存在
SELECT ok(
    EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users' AND column_name = 'email'
    ),
    'users表应该有email列'
);

-- 测试3: 值相等
SELECT is(
    (SELECT COUNT(*) FROM users WHERE email IS NULL),
    0,
    '所有用户都应该有email'
);

-- 测试4: 值不相等
SELECT isnt(
    (SELECT COUNT(*) FROM users),
    0,
    'users表不应该为空'
);

SELECT * FROM finish();
ROLLBACK;
```

### 2.3 测试函数详解

**常用测试函数**：

| 函数 | 用途 | 示例 |
|------|------|------|
| `ok(condition, description)` | 测试条件为真 | `ok(1 = 1, '1应该等于1')` |
| `is(got, expected, description)` | 测试值相等 | `is(2+2, 4, '2+2应该等于4')` |
| `isnt(got, expected, description)` | 测试值不相等 | `isnt(2+2, 5, '2+2不应该等于5')` |
| `matches(got, pattern, description)` | 测试匹配正则 | `matches('hello', '^h', '应该以h开头')` |
| `like(got, pattern, description)` | 测试LIKE匹配 | `like('hello', 'h%', '应该以h开头')` |
| `unlike(got, pattern, description)` | 测试不匹配 | `unlike('hello', 'w%', '不应该以w开头')` |
| `cmp_ok(got, op, expected, desc)` | 比较操作 | `cmp_ok(5, '>', 3, '5应该大于3')` |
| `throws_ok(sql, errcode, description)` | 测试抛出异常 | `throws_ok('SELECT 1/0', '22012', '应该抛出除零错误')` |
| `lives_ok(sql, description)` | 测试不抛出异常 | `lives_ok('SELECT 1', '应该执行成功')` |
| `can_ok(schema, function, description)` | 测试函数存在 | `can_ok('public', 'add_user', 'add_user函数应该存在')` |
| `has_function(schema, function, args, desc)` | 测试函数签名 | `has_function('public', 'add_user', 'text,text', '函数签名应该匹配')` |
| `has_table(schema, table, description)` | 测试表存在 | `has_table('public', 'users', 'users表应该存在')` |
| `has_column(schema, table, column, desc)` | 测试列存在 | `has_column('public', 'users', 'email', 'email列应该存在')` |
| `col_type_is(schema, table, column, type, desc)` | 测试列类型 | `col_type_is('public', 'users', 'id', 'integer', 'id应该是integer类型')` |
| `col_not_null(schema, table, column, desc)` | 测试列非空 | `col_not_null('public', 'users', 'email', 'email应该非空')` |
| `col_is_null(schema, table, column, desc)` | 测试列可空 | `col_is_null('public', 'users', 'deleted_at', 'deleted_at应该可空')` |
| `col_has_default(schema, table, column, desc)` | 测试列有默认值 | `col_has_default('public', 'users', 'created_at', 'created_at应该有默认值')` |
| `col_default_is(schema, table, column, default, desc)` | 测试默认值 | `col_default_is('public', 'users', 'created_at', 'now()', '默认值应该是now()')` |
| `index_is_unique(schema, table, index, desc)` | 测试索引唯一 | `index_is_unique('public', 'users', 'users_email_key', 'email索引应该唯一')` |
| `index_is_primary(schema, table, index, desc)` | 测试主键 | `index_is_primary('public', 'users', 'users_pkey', '应该是主键')` |
| `is_empty(sql, description)` | 测试结果为空 | `is_empty('SELECT * FROM users WHERE id = -1', '应该没有结果')` |
| `isnt_empty(sql, description)` | 测试结果不为空 | `isnt_empty('SELECT * FROM users', '应该有结果')` |
| `row_eq(sql, expected, description)` | 测试行相等 | `row_eq('SELECT 1, 2', ROW(1, 2), '行应该相等')` |
| `results_eq(sql1, sql2, description)` | 测试结果相等 | `results_eq('SELECT 1', 'SELECT 1', '结果应该相等')` |
| `set_eq(sql, array, description)` | 测试集合相等 | `set_eq('SELECT id FROM users', ARRAY[1,2,3], '集合应该相等')` |
| `bag_eq(sql, array, description)` | 测试多重集相等 | `bag_eq('SELECT id FROM users', ARRAY[1,2,2,3], '多重集应该相等')` |
| `set_ne(sql, array, description)` | 测试集合不相等 | `set_ne('SELECT id FROM users', ARRAY[4,5,6], '集合应该不相等')` |
| `set_has(sql, value, description)` | 测试集合包含值 | `set_has('SELECT id FROM users', 1, '集合应该包含1')` |
| `set_hasnt(sql, value, description)` | 测试集合不包含值 | `set_hasnt('SELECT id FROM users', 999, '集合不应该包含999')` |

### 2.4 测试模式

**测试模式**：

1. **Arrange（准备）**：准备测试数据和环境
2. **Act（执行）**：执行被测试的函数
3. **Assert（断言）**：验证结果是否符合预期

**示例**：

```sql
BEGIN;
SELECT plan(3);

-- Arrange: 准备测试数据
INSERT INTO users (name, email) VALUES ('Test', 'test@example.com');
SET LOCAL search_path TO public;

-- Act: 执行被测试的函数
SELECT add_user('New User', 'newuser@example.com') INTO user_id;

-- Assert: 验证结果
SELECT ok(user_id > 0, '应该返回用户ID');
SELECT is(
    (SELECT COUNT(*) FROM users WHERE email = 'newuser@example.com'),
    1,
    '用户应该被创建'
);
SELECT is(
    (SELECT name FROM users WHERE email = 'newuser@example.com'),
    'New User',
    '用户名应该正确'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 3. 函数测试

### 3.1 标量函数测试

**标量函数示例**：

```sql
-- 创建标量函数
CREATE OR REPLACE FUNCTION calculate_discount(price NUMERIC, discount_rate NUMERIC)
RETURNS NUMERIC
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
    IF price IS NULL OR discount_rate IS NULL THEN
        RETURN NULL;
    END IF;

    IF discount_rate < 0 OR discount_rate > 1 THEN
        RAISE EXCEPTION '折扣率必须在0到1之间';
    END IF;

    RETURN price * (1 - discount_rate);
END;
$$;

-- 测试标量函数
BEGIN;
SELECT plan(6);

-- 测试正常情况
SELECT is(
    calculate_discount(100, 0.1),
    90.0,
    '100元打9折应该是90元'
);

-- 测试边界情况
SELECT is(
    calculate_discount(100, 0),
    100.0,
    '折扣率为0应该返回原价'
);

SELECT is(
    calculate_discount(100, 1),
    0.0,
    '折扣率为1应该返回0'
);

-- 测试NULL处理
SELECT is(
    calculate_discount(NULL, 0.1),
    NULL,
    '价格为NULL应该返回NULL'
);

SELECT is(
    calculate_discount(100, NULL),
    NULL,
    '折扣率为NULL应该返回NULL'
);

-- 测试异常情况
SELECT throws_ok(
    'SELECT calculate_discount(100, 1.5)',
    'P0001',
    '折扣率超出范围应该抛出异常'
);

SELECT * FROM finish();
ROLLBACK;
```

### 3.2 表函数测试

**表函数示例**：

```sql
-- 创建表函数
CREATE OR REPLACE FUNCTION get_user_orders(p_user_id INT)
RETURNS TABLE (
    order_id INT,
    order_date DATE,
    total_amount NUMERIC
)
LANGUAGE plpgsql
STABLE
AS $$
BEGIN
    RETURN QUERY
    SELECT o.id, o.order_date, o.total_amount
    FROM orders o
    WHERE o.user_id = p_user_id
    ORDER BY o.order_date DESC;
END;
$$;

-- 测试表函数
BEGIN;
SELECT plan(4);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'Test', 'test@example.com');
INSERT INTO orders (id, user_id, order_date, total_amount) VALUES
    (1, 1, '2025-01-01', 100),
    (2, 1, '2025-01-02', 200),
    (3, 1, '2025-01-03', 300);

-- 测试返回行数
SELECT is(
    (SELECT COUNT(*) FROM get_user_orders(1)),
    3,
    '应该返回3个订单'
);

-- 测试返回顺序
SELECT is(
    (SELECT order_id FROM get_user_orders(1) LIMIT 1),
    3,
    '应该按日期降序排列'
);

-- 测试空结果
SELECT is_empty(
    'SELECT * FROM get_user_orders(999)',
    '不存在的用户应该返回空结果'
);

-- 测试结果内容
SELECT results_eq(
    'SELECT order_id, total_amount FROM get_user_orders(1) ORDER BY order_id',
    'SELECT 1, 100 UNION ALL SELECT 2, 200 UNION ALL SELECT 3, 300',
    '订单数据应该正确'
);

SELECT * FROM finish();
ROLLBACK;
```

### 3.3 聚合函数测试

**聚合函数示例**：

```sql
-- 创建聚合函数
CREATE OR REPLACE FUNCTION array_accum(anyelement)
RETURNS anyarray
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
    -- 这是一个简化的聚合函数示例
    -- 实际实现需要使用C语言或使用内置聚合函数
    RETURN ARRAY[$1];
END;
$$;

-- 测试聚合函数（使用内置聚合函数）
BEGIN;
SELECT plan(3);

-- 准备测试数据
CREATE TEMP TABLE test_sales (
    product_id INT,
    amount NUMERIC
);
INSERT INTO test_sales VALUES
    (1, 100),
    (1, 200),
    (2, 150);

-- 测试SUM聚合
SELECT is(
    (SELECT SUM(amount) FROM test_sales WHERE product_id = 1),
    300,
    'product_id=1的金额总和应该是300'
);

-- 测试COUNT聚合
SELECT is(
    (SELECT COUNT(*) FROM test_sales WHERE product_id = 1),
    2,
    'product_id=1的记录数应该是2'
);

-- 测试AVG聚合
SELECT is(
    (SELECT AVG(amount) FROM test_sales WHERE product_id = 1),
    150,
    'product_id=1的平均金额应该是150'
);

SELECT * FROM finish();
ROLLBACK;
```

### 3.4 窗口函数测试

**窗口函数测试**：

```sql
BEGIN;
SELECT plan(4);

-- 准备测试数据
CREATE TEMP TABLE test_scores (
    student_id INT,
    subject TEXT,
    score INT
);
INSERT INTO test_scores VALUES
    (1, 'Math', 90),
    (1, 'English', 85),
    (2, 'Math', 95),
    (2, 'English', 80);

-- 测试ROW_NUMBER窗口函数
SELECT is(
    (SELECT COUNT(*) FROM (
        SELECT ROW_NUMBER() OVER (PARTITION BY student_id ORDER BY score DESC) as rn
        FROM test_scores
    ) WHERE rn = 1),
    2,
    '每个学生应该有一个排名第一的记录'
);

-- 测试RANK窗口函数
SELECT ok(
    EXISTS (
        SELECT 1 FROM (
            SELECT student_id, RANK() OVER (PARTITION BY student_id ORDER BY score DESC) as rk
            FROM test_scores
        ) WHERE student_id = 1 AND rk = 1 AND score = 90
    ),
    '学生1的最高分应该排名第一'
);

-- 测试SUM窗口函数
SELECT is(
    (SELECT SUM(score) OVER (PARTITION BY student_id) as total
     FROM test_scores WHERE student_id = 1 LIMIT 1),
    175,
    '学生1的总分应该是175'
);

-- 测试AVG窗口函数
SELECT is(
    (SELECT AVG(score) OVER (PARTITION BY student_id) as avg_score
     FROM test_scores WHERE student_id = 1 LIMIT 1),
    87.5,
    '学生1的平均分应该是87.5'
);

SELECT * FROM finish();
ROLLBACK;
```

### 3.5 错误处理测试

**错误处理测试**：

```sql
-- 创建带错误处理的函数
CREATE OR REPLACE FUNCTION divide_numbers(a NUMERIC, b NUMERIC)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
BEGIN
    IF b = 0 THEN
        RAISE EXCEPTION '除数不能为0'
            USING ERRCODE = '22012';
    END IF;

    IF a IS NULL OR b IS NULL THEN
        RAISE EXCEPTION '参数不能为NULL'
            USING ERRCODE = '22000';
    END IF;

    RETURN a / b;
END;
$$;

-- 测试错误处理
BEGIN;
SELECT plan(5);

-- 测试正常情况
SELECT is(
    divide_numbers(10, 2),
    5,
    '10除以2应该等于5'
);

-- 测试除零错误
SELECT throws_ok(
    'SELECT divide_numbers(10, 0)',
    '22012',
    '除零应该抛出错误'
);

-- 测试NULL参数
SELECT throws_ok(
    'SELECT divide_numbers(NULL, 2)',
    '22000',
    'NULL参数应该抛出错误'
);

-- 测试负数
SELECT is(
    divide_numbers(-10, 2),
    -5,
    '负数除法应该正确'
);

-- 测试小数
SELECT is(
    divide_numbers(10, 3),
    3.3333333333333333,
    '小数除法应该正确'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 4. 触发器测试

### 4.1 BEFORE触发器测试

**BEFORE触发器示例**：

```sql
-- 创建BEFORE触发器函数
CREATE OR REPLACE FUNCTION validate_user_email()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF NEW.email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION '邮箱格式无效: %', NEW.email;
    END IF;

    NEW.email := LOWER(TRIM(NEW.email));
    RETURN NEW;
END;
$$;

CREATE TRIGGER validate_user_email_trigger
BEFORE INSERT OR UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION validate_user_email();

-- 测试BEFORE触发器
BEGIN;
SELECT plan(4);

-- 测试正常插入
SELECT lives_ok(
    'INSERT INTO users (name, email) VALUES (''Test'', ''test@example.com'')',
    '有效邮箱应该插入成功'
);

-- 测试无效邮箱
SELECT throws_ok(
    'INSERT INTO users (name, email) VALUES (''Test'', ''invalid-email'')',
    'P0001',
    '无效邮箱应该抛出异常'
);

-- 测试邮箱自动转小写
SELECT is(
    (SELECT email FROM users WHERE name = 'Test'),
    'test@example.com',
    '邮箱应该自动转为小写'
);

-- 测试更新时触发
SELECT throws_ok(
    'UPDATE users SET email = ''invalid'' WHERE name = ''Test''',
    'P0001',
    '更新无效邮箱应该抛出异常'
);

SELECT * FROM finish();
ROLLBACK;
```

### 4.2 AFTER触发器测试

**AFTER触发器示例**：

```sql
-- 创建AFTER触发器函数
CREATE OR REPLACE FUNCTION log_user_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO user_audit_log (user_id, action, changed_at)
    VALUES (NEW.id, TG_OP, NOW());
    RETURN NEW;
END;
$$;

CREATE TRIGGER log_user_changes_trigger
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW
EXECUTE FUNCTION log_user_changes();

-- 测试AFTER触发器
BEGIN;
SELECT plan(3);

-- 创建审计日志表
CREATE TEMP TABLE user_audit_log (
    user_id INT,
    action TEXT,
    changed_at TIMESTAMP
);

-- 测试INSERT触发
INSERT INTO users (name, email) VALUES ('Test', 'test@example.com');
SELECT is(
    (SELECT COUNT(*) FROM user_audit_log WHERE action = 'INSERT'),
    1,
    'INSERT应该记录到审计日志'
);

-- 测试UPDATE触发
UPDATE users SET name = 'Updated' WHERE email = 'test@example.com';
SELECT is(
    (SELECT COUNT(*) FROM user_audit_log WHERE action = 'UPDATE'),
    1,
    'UPDATE应该记录到审计日志'
);

-- 测试DELETE触发
DELETE FROM users WHERE email = 'test@example.com';
SELECT is(
    (SELECT COUNT(*) FROM user_audit_log WHERE action = 'DELETE'),
    1,
    'DELETE应该记录到审计日志'
);

SELECT * FROM finish();
ROLLBACK;
```

### 4.3 INSTEAD OF触发器测试

**INSTEAD OF触发器示例**（用于视图）：

```sql
-- 创建视图
CREATE VIEW user_summary AS
SELECT u.id, u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 创建INSTEAD OF触发器函数
CREATE OR REPLACE FUNCTION insert_user_summary()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO users (name, email)
    VALUES (NEW.name, NEW.name || '@example.com');
    RETURN NEW;
END;
$$;

CREATE TRIGGER insert_user_summary_trigger
INSTEAD OF INSERT ON user_summary
FOR EACH ROW
EXECUTE FUNCTION insert_user_summary();

-- 测试INSTEAD OF触发器
BEGIN;
SELECT plan(2);

-- 测试通过视图插入
INSERT INTO user_summary (name) VALUES ('New User');
SELECT ok(
    EXISTS (SELECT 1 FROM users WHERE name = 'New User'),
    '通过视图插入应该成功'
);

-- 测试视图数据
SELECT is(
    (SELECT COUNT(*) FROM user_summary WHERE name = 'New User'),
    1,
    '视图应该显示新用户'
);

SELECT * FROM finish();
ROLLBACK;
```

### 4.4 触发器执行顺序测试

**触发器执行顺序测试**：

```sql
-- 创建多个触发器函数
CREATE OR REPLACE FUNCTION trigger_1()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    RAISE NOTICE 'Trigger 1 executed';
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION trigger_2()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    RAISE NOTICE 'Trigger 2 executed';
    RETURN NEW;
END;
$$;

-- 创建触发器（指定执行顺序）
CREATE TRIGGER trigger_1_before
BEFORE INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION trigger_1();

CREATE TRIGGER trigger_2_before
BEFORE INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION trigger_2();

-- 测试触发器执行顺序
BEGIN;
SELECT plan(1);

-- 注意：实际测试中需要检查NOTICE消息的顺序
INSERT INTO users (name, email) VALUES ('Test', 'test@example.com');
SELECT ok(
    EXISTS (SELECT 1 FROM users WHERE email = 'test@example.com'),
    '触发器应该按顺序执行'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 5. 视图测试

### 5.1 简单视图测试

**简单视图测试**：

```sql
-- 创建简单视图
CREATE VIEW active_users AS
SELECT id, name, email
FROM users
WHERE deleted_at IS NULL;

-- 测试视图
BEGIN;
SELECT plan(3);

-- 准备测试数据
INSERT INTO users (name, email, deleted_at) VALUES
    ('Active User', 'active@example.com', NULL),
    ('Deleted User', 'deleted@example.com', NOW());

-- 测试视图存在
SELECT has_view('public', 'active_users', 'active_users视图应该存在');

-- 测试视图数据
SELECT is(
    (SELECT COUNT(*) FROM active_users),
    1,
    '视图应该只包含活跃用户'
);

-- 测试视图列
SELECT has_column('public', 'active_users', 'id', '视图应该有id列');
SELECT has_column('public', 'active_users', 'name', '视图应该有name列');
SELECT has_column('public', 'active_users', 'email', '视图应该有email列');

SELECT * FROM finish();
ROLLBACK;
```

### 5.2 复杂视图测试

**复杂视图测试**：

```sql
-- 创建复杂视图
CREATE VIEW user_order_summary AS
SELECT
    u.id as user_id,
    u.name as user_name,
    COUNT(o.id) as order_count,
    COALESCE(SUM(o.total_amount), 0) as total_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 测试复杂视图
BEGIN;
SELECT plan(4);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User 1', 'user1@example.com');
INSERT INTO orders (id, user_id, total_amount) VALUES
    (1, 1, 100),
    (2, 1, 200);

-- 测试视图数据
SELECT is(
    (SELECT order_count FROM user_order_summary WHERE user_id = 1),
    2,
    '订单数量应该正确'
);

SELECT is(
    (SELECT total_amount FROM user_order_summary WHERE user_id = 1),
    300,
    '总金额应该正确'
);

-- 测试无订单用户
INSERT INTO users (id, name, email) VALUES (2, 'User 2', 'user2@example.com');
SELECT is(
    (SELECT total_amount FROM user_order_summary WHERE user_id = 2),
    0,
    '无订单用户总金额应该为0'
);

-- 测试视图可查询
SELECT ok(
    EXISTS (SELECT 1 FROM user_order_summary),
    '视图应该可以查询'
);

SELECT * FROM finish();
ROLLBACK;
```

### 5.3 物化视图测试

**物化视图测试**：

```sql
-- 创建物化视图
CREATE MATERIALIZED VIEW user_statistics AS
SELECT
    u.id,
    u.name,
    COUNT(o.id) as order_count,
    MAX(o.order_date) as last_order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

CREATE UNIQUE INDEX ON user_statistics (id);

-- 测试物化视图
BEGIN;
SELECT plan(3);

-- 准备测试数据
INSERT INTO users (id, name, email) VALUES (1, 'User 1', 'user1@example.com');
INSERT INTO orders (id, user_id, order_date) VALUES
    (1, 1, '2025-01-01'),
    (2, 1, '2025-01-02');

-- 刷新物化视图
REFRESH MATERIALIZED VIEW user_statistics;

-- 测试物化视图数据
SELECT is(
    (SELECT order_count FROM user_statistics WHERE id = 1),
    2,
    '物化视图订单数量应该正确'
);

SELECT is(
    (SELECT last_order_date FROM user_statistics WHERE id = 1),
    '2025-01-02'::DATE,
    '最后订单日期应该正确'
);

-- 测试物化视图索引
SELECT ok(
    EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE tablename = 'user_statistics' AND indexname LIKE '%_pkey'
    ),
    '物化视图应该有主键索引'
);

SELECT * FROM finish();
ROLLBACK;
```

## 6. 约束测试

### 6.1 CHECK约束测试

**CHECK约束测试**：

```sql
-- 创建带CHECK约束的表
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC CHECK (price > 0),
    stock INTEGER CHECK (stock >= 0)
);

-- 测试CHECK约束
BEGIN;
SELECT plan(4);

-- 测试有效数据
SELECT lives_ok(
    'INSERT INTO products (name, price, stock) VALUES (''Product 1'', 100, 10)',
    '有效数据应该插入成功'
);

-- 测试价格约束
SELECT throws_ok(
    'INSERT INTO products (name, price, stock) VALUES (''Product 2'', -10, 10)',
    '23514',
    '负价格应该违反CHECK约束'
);

-- 测试库存约束
SELECT throws_ok(
    'INSERT INTO products (name, price, stock) VALUES (''Product 3'', 100, -1)',
    '23514',
    '负库存应该违反CHECK约束'
);

-- 测试约束存在
SELECT col_has_check('public', 'products', 'price', 'price列应该有CHECK约束');

SELECT * FROM finish();
ROLLBACK;
```

### 6.2 UNIQUE约束测试

**UNIQUE约束测试**：

```sql
-- 创建带UNIQUE约束的表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    username TEXT UNIQUE
);

-- 测试UNIQUE约束
BEGIN;
SELECT plan(4);

-- 测试有效数据
SELECT lives_ok(
    'INSERT INTO users (email, username) VALUES (''user1@example.com'', ''user1'')',
    '有效数据应该插入成功'
);

-- 测试邮箱唯一性
SELECT throws_ok(
    'INSERT INTO users (email, username) VALUES (''user1@example.com'', ''user2'')',
    '23505',
    '重复邮箱应该违反UNIQUE约束'
);

-- 测试用户名唯一性
SELECT throws_ok(
    'INSERT INTO users (email, username) VALUES (''user2@example.com'', ''user1'')',
    '23505',
    '重复用户名应该违反UNIQUE约束'
);

-- 测试唯一索引存在
SELECT index_is_unique('public', 'users', 'users_email_key', 'email应该有唯一索引');

SELECT * FROM finish();
ROLLBACK;
```

### 6.3 FOREIGN KEY约束测试

**FOREIGN KEY约束测试**：

```sql
-- 创建带外键约束的表
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    total_amount NUMERIC
);

-- 测试FOREIGN KEY约束
BEGIN;
SELECT plan(4);

-- 准备测试数据
INSERT INTO users (id, email) VALUES (1, 'user1@example.com');

-- 测试有效外键
SELECT lives_ok(
    'INSERT INTO orders (user_id, total_amount) VALUES (1, 100)',
    '有效外键应该插入成功'
);

-- 测试无效外键
SELECT throws_ok(
    'INSERT INTO orders (user_id, total_amount) VALUES (999, 100)',
    '23503',
    '无效外键应该违反FOREIGN KEY约束'
);

-- 测试级联删除
DELETE FROM users WHERE id = 1;
SELECT is(
    (SELECT COUNT(*) FROM orders WHERE user_id = 1),
    0,
    '级联删除应该删除相关订单'
);

-- 测试外键约束存在
SELECT ok(
    EXISTS (
        SELECT 1 FROM information_schema.table_constraints
        WHERE constraint_name LIKE '%user_id%'
        AND constraint_type = 'FOREIGN KEY'
    ),
    '应该有外键约束'
);

SELECT * FROM finish();
ROLLBACK;
```

## 7. 测试数据准备

### 7.1 测试数据生成

**测试数据生成函数**：

```sql
-- 创建测试数据生成函数
CREATE OR REPLACE FUNCTION generate_test_users(count INT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    i INT;
BEGIN
    FOR i IN 1..count LOOP
        INSERT INTO users (name, email)
        VALUES (
            'User ' || i,
            'user' || i || '@example.com'
        );
    END LOOP;
END;
$$;

-- 使用测试数据生成函数
BEGIN;
SELECT plan(1);

SELECT generate_test_users(10);
SELECT is(
    (SELECT COUNT(*) FROM users WHERE email LIKE 'user%@example.com'),
    10,
    '应该生成10个测试用户'
);

SELECT * FROM finish();
ROLLBACK;
```

### 7.2 测试数据清理

**测试数据清理**：

```sql
-- 创建测试数据清理函数
CREATE OR REPLACE FUNCTION cleanup_test_data()
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    DELETE FROM orders WHERE user_id IN (
        SELECT id FROM users WHERE email LIKE '%@test.example.com'
    );
    DELETE FROM users WHERE email LIKE '%@test.example.com';
END;
$$;

-- 使用测试数据清理
BEGIN;
SELECT plan(1);

-- 插入测试数据
INSERT INTO users (name, email) VALUES ('Test', 'test@test.example.com');

-- 清理测试数据
SELECT cleanup_test_data();

SELECT is(
    (SELECT COUNT(*) FROM users WHERE email LIKE '%@test.example.com'),
    0,
    '测试数据应该被清理'
);

SELECT * FROM finish();
ROLLBACK;
```

### 7.3 测试数据隔离

**使用事务隔离测试数据**：

```sql
-- 测试数据隔离示例
BEGIN;
SELECT plan(2);

-- 在事务中插入测试数据
INSERT INTO users (name, email) VALUES ('Isolated Test', 'isolated@test.com');

-- 测试数据存在
SELECT ok(
    EXISTS (SELECT 1 FROM users WHERE email = 'isolated@test.com'),
    '测试数据应该在事务中存在'
);

-- 回滚事务（数据被清理）
ROLLBACK;

-- 验证数据已清理
BEGIN;
SELECT ok(
    NOT EXISTS (SELECT 1 FROM users WHERE email = 'isolated@test.com'),
    '回滚后测试数据应该不存在'
);
ROLLBACK;
```

## 8. 测试覆盖率

### 8.1 覆盖率指标

**覆盖率类型**：

- **语句覆盖率**：执行的SQL语句百分比
- **分支覆盖率**：执行的代码分支百分比
- **函数覆盖率**：测试的函数百分比
- **条件覆盖率**：测试的条件组合百分比

### 8.2 覆盖率工具

**使用pg_profiler**：

```sql
-- 启用pg_profiler扩展
CREATE EXTENSION IF NOT EXISTS pg_profiler;

-- 开始分析
SELECT profiler.start();

-- 执行测试
SELECT add_user('Test', 'test@example.com');

-- 停止分析并查看覆盖率
SELECT profiler.stop();
SELECT * FROM profiler.get_coverage();
```

### 8.3 覆盖率报告

**生成覆盖率报告**：

```bash
# 使用pg_prove生成覆盖率报告
pg_prove --coverage -d mydb tests/

# 查看覆盖率报告
open coverage/index.html
```

## 9. 测试组织

### 9.1 测试文件结构

**推荐的测试文件结构**：

```text
tests/
├── setup.sql          # 测试环境设置
├── teardown.sql       # 测试环境清理
├── fixtures/          # 测试数据
│   ├── users.sql
│   └── orders.sql
├── functions/         # 函数测试
│   ├── add_user.sql
│   └── calculate_discount.sql
├── triggers/          # 触发器测试
│   └── update_updated_at.sql
├── views/             # 视图测试
│   └── active_users.sql
└── constraints/        # 约束测试
    └── unique_email.sql
```

### 9.2 测试命名规范

**命名规范**：

- **测试文件**：`test_<功能>.sql` 或 `<功能>_test.sql`
- **测试描述**：清晰描述测试内容
- **测试函数**：`test_<功能>_<场景>()`

**示例**：

```sql
-- 文件：test_add_user.sql
BEGIN;
SELECT plan(3);

SELECT ok(
    add_user('Test', 'test@example.com') > 0,
    'add_user应该成功创建用户并返回ID'
);

SELECT is(
    (SELECT COUNT(*) FROM users WHERE email = 'test@example.com'),
    1,
    '用户应该被正确创建'
);

SELECT throws_ok(
    'SELECT add_user(NULL, NULL)',
    'P0001',
    'NULL参数应该抛出异常'
);

SELECT * FROM finish();
ROLLBACK;
```

### 9.3 测试运行

**运行测试**：

```bash
# 运行单个测试文件
pg_prove -d mydb tests/functions/add_user.sql

# 运行所有测试
pg_prove -d mydb tests/

# 并行运行测试
pg_prove -d mydb -j 4 tests/

# 详细输出
pg_prove -d mydb -v tests/

# 生成TAP输出
pg_prove -d mydb --formatter TAP tests/
```

## 10. 最佳实践

### 10.1 推荐做法

**✅ 推荐做法**：

1. **测试隔离**
   - 每个测试独立运行
   - 使用事务回滚
   - 不依赖其他测试

2. **测试数据**
   - 使用测试专用数据
   - 测试后清理数据
   - 使用fixtures准备数据

3. **测试覆盖**
   - 覆盖所有代码路径
   - 测试正常情况和异常情况
   - 测试边界条件

4. **测试命名**
   - 清晰的测试描述
   - 描述测试场景和预期结果
   - 使用一致的命名规范

5. **测试组织**
   - 按功能组织测试文件
   - 使用测试框架（pgTAP）
   - 保持测试文件简洁

### 10.2 常见错误

**❌ 避免做法**：

1. **测试依赖**
   - 避免测试之间相互依赖
   - 避免依赖测试执行顺序
   - 避免依赖外部状态

2. **测试数据污染**
   - 避免使用生产数据
   - 避免测试数据残留
   - 避免硬编码测试数据

3. **测试过于复杂**
   - 避免一个测试测试多个功能
   - 避免测试逻辑过于复杂
   - 保持测试简单明了

4. **缺少断言**
   - 避免只有执行没有断言
   - 避免模糊的断言
   - 使用明确的断言函数

### 10.3 性能考虑

**性能优化**：

1. **测试执行速度**
   - 使用事务回滚而不是DELETE
   - 批量插入测试数据
   - 并行运行独立测试

2. **测试数据量**
   - 使用最小必要的数据集
   - 避免大数据量测试
   - 使用索引优化查询

3. **测试环境**
   - 使用独立的测试数据库
   - 定期清理测试数据
   - 优化测试数据库配置

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [集成测试.md](./集成测试.md) - 集成测试详解
- [测试自动化.md](./测试自动化.md) - 测试自动化
- [代码质量检查.md](./代码质量检查.md) - 代码质量检查
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**文档版本**: v1.0
**最后更新**: 2025年1月
**维护者**: PostgreSQL开发团队
