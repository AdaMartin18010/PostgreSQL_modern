# PostgreSQL单元测试指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL单元测试指南](#postgresql单元测试指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. pgTAP使用](#2-pgtap使用)
    - [2.1 安装pgTAP](#21-安装pgtap)
    - [2.2 基本测试](#22-基本测试)
  - [3. 函数测试](#3-函数测试)
    - [3.1 测试函数](#31-测试函数)
  - [4. 触发器测试](#4-触发器测试)
    - [4.1 测试触发器](#41-测试触发器)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

单元测试验证PostgreSQL函数、触发器等单个组件的正确性。

**测试对象**:

- 函数
- 触发器
- 视图
- 约束

---

## 2. pgTAP使用

### 2.1 安装pgTAP

```sql
CREATE EXTENSION IF NOT EXISTS pgtap;
```

### 2.2 基本测试

```sql
BEGIN;
SELECT plan(2);

SELECT ok(
    (SELECT COUNT(*) FROM users) >= 0,
    'Users table should exist'
);

SELECT is(
    (SELECT COUNT(*) FROM users WHERE email IS NULL),
    0,
    'Users should have email'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 3. 函数测试

### 3.1 测试函数

```sql
-- 创建测试函数
-- 添加用户函数（带完整错误处理）
CREATE OR REPLACE FUNCTION add_user(p_name TEXT, p_email TEXT)
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_id INT;
BEGIN
    -- 参数验证
    IF p_name IS NULL OR TRIM(p_name) = '' THEN
        RAISE EXCEPTION '用户名不能为空';
    END IF;

    IF p_email IS NULL OR TRIM(p_email) = '' THEN
        RAISE EXCEPTION '邮箱不能为空';
    END IF;

    -- 邮箱格式验证
    IF p_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION '邮箱格式无效: %', p_email
            USING HINT = '请输入有效的邮箱地址';
    END IF;

    -- 检查表是否存在
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users') THEN
        RAISE EXCEPTION 'users表不存在';
    END IF;

    -- 插入用户
    BEGIN
        INSERT INTO users (name, email)
        VALUES (TRIM(p_name), LOWER(TRIM(p_email)))
        RETURNING id INTO v_user_id;

        RETURN v_user_id;
    EXCEPTION
        WHEN unique_violation THEN
            RAISE EXCEPTION '邮箱已存在: %', p_email;
        WHEN foreign_key_violation THEN
            RAISE EXCEPTION '违反外键约束';
        WHEN check_violation THEN
            RAISE EXCEPTION '违反检查约束';
        WHEN OTHERS THEN
            RAISE EXCEPTION '添加用户失败: %', SQLERRM;
    END;
END;
$$;

-- 测试函数
BEGIN;
SELECT plan(3);

SELECT ok(
    add_user('Test', 'test@example.com') > 0,
    'add_user should return user id'
);

SELECT is(
    (SELECT COUNT(*) FROM users WHERE email = 'test@example.com'),
    1,
    'User should be created'
);

SELECT throws_ok(
    'SELECT add_user(NULL, NULL)',
    '23502',
    'User name and email are required'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 4. 触发器测试

### 4.1 测试触发器

```sql
-- 更新updated_at触发器函数（带完整错误处理）
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- 检查NEW记录是否存在
    IF NEW IS NULL THEN
        RAISE WARNING 'NEW记录为空，无法更新updated_at';
        RETURN NULL;
    END IF;

    -- 设置updated_at时间戳
    NEW.updated_at := NOW();

    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'update_updated_at触发器函数执行失败: %', SQLERRM;
        RETURN NEW;  -- 即使出错也返回NEW，避免影响主操作
END;
$$;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

-- 测试触发器
BEGIN;
SELECT plan(1);

INSERT INTO users (name, email) VALUES ('Test', 'test@example.com');
UPDATE users SET name = 'Updated' WHERE email = 'test@example.com';

SELECT ok(
    (SELECT updated_at FROM users WHERE email = 'test@example.com') >
    (SELECT created_at FROM users WHERE email = 'test@example.com'),
    'updated_at should be updated'
);

SELECT * FROM finish();
ROLLBACK;
```

---

## 5. 最佳实践

### ✅ 推荐做法

1. **测试隔离** - 每个测试独立
2. **使用事务** - 测试后回滚
3. **测试数据** - 使用测试数据
4. **测试覆盖** - 覆盖所有分支

---

## 📚 相关文档

- [测试完整指南.md](./测试完整指南.md) - 测试完整指南
- [集成测试.md](./集成测试.md) - 集成测试详解
- [测试自动化.md](./测试自动化.md) - 测试自动化
- [16-应用设计与开发/README.md](../README.md) - 应用设计与开发主题

---

**最后更新**: 2025年1月
