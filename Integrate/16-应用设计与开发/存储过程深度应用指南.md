---
> **📋 文档来源**: 新增深化文档
> **📅 创建日期**: 2025-01
> **⚠️ 注意**: 本文档聚焦存储过程（Stored Procedures）深度应用技术栈

---

# PostgreSQL存储过程深度应用指南

## 元数据

- **文档版本**: v2.0
- **创建日期**: 2025-01
- **技术栈**: PostgreSQL 17+/18+ | PL/pgSQL | 存储过程
- **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
- **预计阅读**: 180分钟
- **前置要求**: 熟悉PostgreSQL基础、PL/pgSQL基础、事务基础

---

## 📋 完整目录

- [PostgreSQL存储过程深度应用指南](#postgresql存储过程深度应用指南)
  - [元数据](#元数据)
  - [📋 完整目录](#-完整目录)
  - [1. 存储过程概述](#1-存储过程概述)
    - [1.1 存储过程概念](#11-存储过程概念)
      - [核心概念](#核心概念)
      - [存储过程特点](#存储过程特点)
    - [1.2 存储过程vs函数](#12-存储过程vs函数)
      - [对比表](#对比表)
    - [1.3 存储过程应用场景](#13-存储过程应用场景)
      - [典型应用场景](#典型应用场景)
  - [2. 事务控制](#2-事务控制)
    - [2.1 COMMIT和ROLLBACK](#21-commit和rollback)
      - [基本事务控制](#基本事务控制)
      - [条件提交](#条件提交)
    - [2.2 SAVEPOINT（保存点）](#22-savepoint保存点)
      - [保存点使用](#保存点使用)
      - [嵌套保存点](#嵌套保存点)
    - [2.3 嵌套事务处理](#23-嵌套事务处理)
      - [嵌套事务模式](#嵌套事务模式)
  - [3. 异常处理](#3-异常处理)
    - [3.1 EXCEPTION块](#31-exception块)
      - [基本异常处理](#基本异常处理)
      - [多层异常处理](#多层异常处理)
    - [3.2 异常类型](#32-异常类型)
      - [常见异常类型](#常见异常类型)
    - [3.3 异常传播](#33-异常传播)
      - [异常传播机制](#异常传播机制)
  - [4. 性能优化](#4-性能优化)
    - [4.1 批量操作](#41-批量操作)
      - [批量插入](#批量插入)
      - [批量更新](#批量更新)
    - [4.2 游标优化](#42-游标优化)
      - [使用游标处理大结果集](#使用游标处理大结果集)
  - [5. 安全特性](#5-安全特性)
    - [5.1 SECURITY DEFINER](#51-security-definer)
      - [安全定义者模式](#安全定义者模式)
    - [5.2 权限管理](#52-权限管理)
      - [细粒度权限控制](#细粒度权限控制)
  - [8. 实战案例](#8-实战案例)
    - [8.1 复杂业务流程实现](#81-复杂业务流程实现)
      - [订单处理流程](#订单处理流程)
  - [📚 参考资源](#-参考资源)
  - [📝 更新日志](#-更新日志)

---

## 1. 存储过程概述

### 1.1 存储过程概念

#### 核心概念

```text
存储过程（Stored Procedure）:
- PostgreSQL 11+ 支持存储过程
- 可以执行多个操作
- 支持事务控制（COMMIT、ROLLBACK）
- 不需要返回值
- 使用CALL语句调用
```

#### 存储过程特点

- ✅ **事务控制**: 可以控制事务提交和回滚
- ✅ **无返回值**: 不需要返回值（但可以有OUT参数）
- ✅ **复杂逻辑**: 适合实现复杂的业务逻辑
- ✅ **性能优势**: 减少网络往返，提升性能
- ✅ **安全性**: 可以封装敏感操作

### 1.2 存储过程vs函数

#### 对比表

| 特性 | 存储过程 | 函数 |
| --- | --- | --- |
| **返回值** | 不需要返回值 | 必须有返回值 |
| **事务控制** | 可以COMMIT/ROLLBACK | 不能控制事务 |
| **调用方式** | CALL procedure() | SELECT function() |
| **使用场景** | 复杂业务逻辑 | 计算、查询 |
| **支持版本** | PostgreSQL 11+ | 所有版本 |

### 1.3 存储过程应用场景

#### 典型应用场景

```text
场景1: 复杂业务流程
- 多步骤业务处理
- 需要事务控制
- 需要错误处理

场景2: 数据迁移
- 批量数据处理
- 数据转换
- 需要事务控制

场景3: 报表生成
- 复杂数据聚合
- 临时表操作
- 需要事务控制
```

---

## 2. 事务控制

### 2.1 COMMIT和ROLLBACK

#### 基本事务控制

```sql
-- 基本事务控制示例
CREATE OR REPLACE PROCEDURE transfer_money(
    p_from_account INTEGER,
    p_to_account INTEGER,
    p_amount DECIMAL
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_balance DECIMAL;
BEGIN
    -- 检查源账户余额
    SELECT balance INTO v_balance
    FROM accounts
    WHERE id = p_from_account
    FOR UPDATE;  -- 锁定行

    IF v_balance < p_amount THEN
        RAISE EXCEPTION 'Insufficient funds: balance is %, requested %',
            v_balance, p_amount;
    END IF;

    -- 扣除源账户
    UPDATE accounts
    SET balance = balance - p_amount
    WHERE id = p_from_account;

    -- 增加目标账户
    UPDATE accounts
    SET balance = balance + p_amount
    WHERE id = p_to_account;

    -- 记录交易
    INSERT INTO transactions (from_account, to_account, amount, transaction_time)
    VALUES (p_from_account, p_to_account, p_amount, NOW());

    -- 提交在调用者的事务中
    -- 存储过程中的COMMIT会提交调用者的事务
    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$;
```

#### 条件提交

```sql
-- 条件提交示例
CREATE OR REPLACE PROCEDURE process_order(
    p_order_id INTEGER,
    p_should_commit BOOLEAN DEFAULT TRUE
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- 更新订单状态
    UPDATE orders
    SET status = 'processing'
    WHERE id = p_order_id;

    -- 扣除库存
    UPDATE products
    SET stock = stock - 1
    WHERE id IN (
        SELECT product_id FROM order_items WHERE order_id = p_order_id
    );

    -- 条件提交
    IF p_should_commit THEN
        COMMIT;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$;
```

### 2.2 SAVEPOINT（保存点）

#### 保存点使用

```sql
-- 使用保存点实现部分回滚
CREATE OR REPLACE PROCEDURE complex_operation()
LANGUAGE plpgsql
AS $$
DECLARE
    v_step INTEGER := 0;
BEGIN
    -- 步骤1：创建用户
    BEGIN
        INSERT INTO users (name, email) VALUES ('John', 'john@example.com');
        v_step := 1;
    EXCEPTION
        WHEN unique_violation THEN
            RAISE NOTICE 'User already exists, skipping step 1';
    END;

    -- 创建保存点
    SAVEPOINT sp_after_user;

    -- 步骤2：创建订单
    BEGIN
        INSERT INTO orders (user_id, amount)
        SELECT id, 100 FROM users WHERE email = 'john@example.com';
        v_step := 2;
    EXCEPTION
        WHEN OTHERS THEN
            -- 回滚到保存点
            ROLLBACK TO SAVEPOINT sp_after_user;
            RAISE NOTICE 'Failed to create order, rolled back to savepoint';
            RAISE;
    END;

    -- 创建第二个保存点
    SAVEPOINT sp_after_order;

    -- 步骤3：更新库存
    BEGIN
        UPDATE products SET stock = stock - 1 WHERE id = 1;
        v_step := 3;
    EXCEPTION
        WHEN OTHERS THEN
            -- 回滚到第二个保存点
            ROLLBACK TO SAVEPOINT sp_after_order;
            RAISE NOTICE 'Failed to update stock, rolled back to savepoint';
            RAISE;
    END;

    -- 释放保存点
    RELEASE SAVEPOINT sp_after_order;
    RELEASE SAVEPOINT sp_after_user;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        -- 如果保存点存在，回滚到保存点
        IF v_step >= 1 THEN
            BEGIN
                ROLLBACK TO SAVEPOINT sp_after_user;
            EXCEPTION
                WHEN OTHERS THEN
                    -- 保存点不存在，执行完整回滚
                    ROLLBACK;
            END;
        ELSE
            ROLLBACK;
        END IF;
        RAISE;
END;
$$;
```

#### 嵌套保存点

```sql
-- 嵌套保存点示例
CREATE OR REPLACE PROCEDURE nested_savepoint_demo()
LANGUAGE plpgsql
AS $$
BEGIN
    -- 外层保存点
    SAVEPOINT outer_sp;

    BEGIN
        -- 执行一些操作
        INSERT INTO table1 (col1) VALUES ('value1');

        -- 内层保存点
        SAVEPOINT inner_sp;

        BEGIN
            -- 执行可能失败的操作
            INSERT INTO table2 (col1) VALUES ('value2');

            -- 如果成功，释放内层保存点
            RELEASE SAVEPOINT inner_sp;
        EXCEPTION
            WHEN OTHERS THEN
                -- 回滚到内层保存点
                ROLLBACK TO SAVEPOINT inner_sp;
                RAISE;
        END;

        -- 释放外层保存点
        RELEASE SAVEPOINT outer_sp;

    EXCEPTION
        WHEN OTHERS THEN
            -- 回滚到外层保存点
            ROLLBACK TO SAVEPOINT outer_sp;
            RAISE;
    END;

    COMMIT;
END;
$$;
```

### 2.3 嵌套事务处理

#### 嵌套事务模式

```sql
-- 嵌套事务处理模式
CREATE OR REPLACE PROCEDURE nested_transaction_handler()
LANGUAGE plpgsql
AS $$
DECLARE
    v_nested_level INTEGER := 0;
BEGIN
    -- 检查是否在事务中
    IF txid_current() = 0 THEN
        -- 不在事务中，开始新事务
        BEGIN
            PERFORM nested_operation();
            COMMIT;
        EXCEPTION
            WHEN OTHERS THEN
                ROLLBACK;
                RAISE;
        END;
    ELSE
        -- 已在事务中，使用保存点
        BEGIN
            SAVEPOINT nested_sp;
            PERFORM nested_operation();
            RELEASE SAVEPOINT nested_sp;
        EXCEPTION
            WHEN OTHERS THEN
                ROLLBACK TO SAVEPOINT nested_sp;
                RAISE;
        END;
    END IF;
END;
$$;
```

---

## 3. 异常处理

### 3.1 EXCEPTION块

#### 基本异常处理

```sql
-- 基本异常处理
CREATE OR REPLACE PROCEDURE safe_operation()
LANGUAGE plpgsql
AS $$
BEGIN
    -- 可能失败的操作
    INSERT INTO users (name, email) VALUES ('John', 'john@example.com');

EXCEPTION
    WHEN unique_violation THEN
        RAISE NOTICE 'User already exists: %', SQLERRM;
        -- 可以执行恢复操作
        UPDATE users SET updated_at = NOW() WHERE email = 'john@example.com';
    WHEN check_violation THEN
        RAISE EXCEPTION 'Validation failed: %', SQLERRM;
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Unexpected error: %', SQLERRM;
END;
$$;
```

#### 多层异常处理

```sql
-- 多层异常处理
CREATE OR REPLACE PROCEDURE multi_level_error_handling()
LANGUAGE plpgsql
AS $$
DECLARE
    v_step TEXT;
BEGIN
    v_step := 'step1';
    BEGIN
        -- 步骤1
        INSERT INTO table1 (col1) VALUES ('value1');

        v_step := 'step2';
        BEGIN
            -- 步骤2
            INSERT INTO table2 (col1) VALUES ('value2');
        EXCEPTION
            WHEN OTHERS THEN
                RAISE NOTICE 'Step 2 failed: %, continuing with step 3', SQLERRM;
                -- 继续执行，不中断
        END;

        v_step := 'step3';
        BEGIN
            -- 步骤3
            INSERT INTO table3 (col1) VALUES ('value3');
        EXCEPTION
            WHEN OTHERS THEN
                RAISE EXCEPTION 'Step 3 failed: %, aborting', SQLERRM;
        END;

    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'Failed at %: %', v_step, SQLERRM;
    END;

    COMMIT;
END;
$$;
```

### 3.2 异常类型

#### 常见异常类型

```sql
-- 处理常见异常类型
CREATE OR REPLACE PROCEDURE handle_common_exceptions()
LANGUAGE plpgsql
AS $$
BEGIN
    -- 可能抛出多种异常的操作
    INSERT INTO orders (user_id, amount, product_id)
    VALUES (1, 100, 1);

EXCEPTION
    -- 唯一约束违反
    WHEN unique_violation THEN
        RAISE EXCEPTION 'Duplicate entry: %', SQLERRM;

    -- 外键约束违反
    WHEN foreign_key_violation THEN
        RAISE EXCEPTION 'Foreign key violation: %', SQLERRM;

    -- 检查约束违反
    WHEN check_violation THEN
        RAISE EXCEPTION 'Check constraint violation: %', SQLERRM;

    -- 非空约束违反
    WHEN not_null_violation THEN
        RAISE EXCEPTION 'Not null constraint violation: %', SQLERRM;

    -- 数值超出范围
    WHEN numeric_value_out_of_range THEN
        RAISE EXCEPTION 'Numeric value out of range: %', SQLERRM;

    -- 字符串数据长度超出
    WHEN string_data_right_truncation THEN
        RAISE EXCEPTION 'String too long: %', SQLERRM;

    -- 其他异常
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Unexpected error (SQLSTATE: %, SQLERRM: %)',
            SQLSTATE, SQLERRM;
END;
$$;
```

### 3.3 异常传播

#### 异常传播机制

```sql
-- 异常传播示例
CREATE OR REPLACE PROCEDURE propagate_exception()
LANGUAGE plpgsql
AS $$
BEGIN
    BEGIN
        -- 调用可能抛出异常的过程
        PERFORM risky_operation();
    EXCEPTION
        WHEN OTHERS THEN
            -- 记录错误信息
            RAISE NOTICE 'Error in risky_operation: %', SQLERRM;
            -- 重新抛出异常
            RAISE;
    END;
END;
$$;

-- 调用链中的异常传播
CREATE OR REPLACE PROCEDURE caller_procedure()
LANGUAGE plpgsql
AS $$
BEGIN
    BEGIN
        PERFORM propagate_exception();
    EXCEPTION
        WHEN OTHERS THEN
            -- 处理传播上来的异常
            RAISE EXCEPTION 'Caller procedure failed: %', SQLERRM;
    END;
END;
$$;
```

---

## 4. 性能优化

### 4.1 批量操作

#### 批量插入

```sql
-- 批量插入优化
CREATE OR REPLACE PROCEDURE batch_insert(
    p_data JSONB[]
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_item JSONB;
    v_count INTEGER := 0;
BEGIN
    -- 批量插入
    FOR v_item IN SELECT * FROM unnest(p_data)
    LOOP
        INSERT INTO orders (user_id, amount, product_id, order_date)
        VALUES (
            (v_item->>'user_id')::INTEGER,
            (v_item->>'amount')::DECIMAL,
            (v_item->>'product_id')::INTEGER,
            (v_item->>'order_date')::DATE
        );

        v_count := v_count + 1;

        -- 每1000条提交一次
        IF v_count % 1000 = 0 THEN
            COMMIT;
            BEGIN
                -- 继续处理
            END;
        END IF;
    END LOOP;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE EXCEPTION 'Batch insert failed at item %: %', v_count, SQLERRM;
END;
$$;
```

#### 批量更新

```sql
-- 批量更新优化
CREATE OR REPLACE PROCEDURE batch_update_optimized()
LANGUAGE plpgsql
AS $$
DECLARE
    v_batch_size INTEGER := 1000;
    v_updated INTEGER;
BEGIN
    LOOP
        -- 使用LIMIT批量更新
        UPDATE orders
        SET status = 'processed'
        WHERE id IN (
            SELECT id FROM orders
            WHERE status = 'pending'
            LIMIT v_batch_size
            FOR UPDATE SKIP LOCKED
        );

        GET DIAGNOSTICS v_updated = ROW_COUNT;

        EXIT WHEN v_updated = 0;

        COMMIT;
        BEGIN
            -- 继续下一批
        END;
    END LOOP;

    COMMIT;
END;
$$;
```

### 4.2 游标优化

#### 使用游标处理大结果集

```sql
-- 游标优化示例
CREATE OR REPLACE PROCEDURE process_large_dataset()
LANGUAGE plpgsql
AS $$
DECLARE
    v_cursor CURSOR FOR
        SELECT id, name, email
        FROM users
        WHERE created_at < NOW() - INTERVAL '1 year';

    v_record RECORD;
    v_processed INTEGER := 0;
BEGIN
    OPEN v_cursor;

    LOOP
        FETCH v_cursor INTO v_record;
        EXIT WHEN NOT FOUND;

        -- 处理记录
        BEGIN
            UPDATE users
            SET status = 'archived'
            WHERE id = v_record.id;

            v_processed := v_processed + 1;

            -- 每1000条提交一次
            IF v_processed % 1000 = 0 THEN
                COMMIT;
                BEGIN
                    -- 继续处理
                END;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE NOTICE 'Failed to process user %: %', v_record.id, SQLERRM;
                -- 继续处理下一条
        END;
    END LOOP;

    CLOSE v_cursor;
    COMMIT;
END;
$$;
```

---

## 5. 安全特性

### 5.1 SECURITY DEFINER

#### 安全定义者模式

```sql
-- 使用SECURITY DEFINER提升权限
CREATE OR REPLACE PROCEDURE admin_operation(
    p_user_id INTEGER,
    p_action TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER  -- 以函数所有者权限执行
SET search_path = public, pg_temp  -- 防止搜索路径攻击
AS $$
BEGIN
    -- 检查调用者权限（使用current_user，不是session_user）
    IF current_user != 'admin' THEN
        RAISE EXCEPTION 'Permission denied: only admin can execute this procedure';
    END IF;

    -- 执行需要超级用户权限的操作
    CASE p_action
        WHEN 'update_status' THEN
            UPDATE users SET status = 'active' WHERE id = p_user_id;
        WHEN 'reset_password' THEN
            UPDATE users SET password_hash = crypt('default', gen_salt('bf'))
            WHERE id = p_user_id;
        ELSE
            RAISE EXCEPTION 'Unknown action: %', p_action;
    END CASE;

    COMMIT;
END;
$$;

-- 授予执行权限给普通用户
GRANT EXECUTE ON PROCEDURE admin_operation(INTEGER, TEXT) TO app_user;
```

### 5.2 权限管理

#### 细粒度权限控制

```sql
-- 权限检查存储过程
CREATE OR REPLACE PROCEDURE secured_operation(
    p_resource_id INTEGER,
    p_action TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_id INTEGER;
    v_has_permission BOOLEAN;
BEGIN
    -- 获取当前用户ID
    v_user_id := current_setting('app.user_id', true)::INTEGER;

    -- 检查权限
    SELECT EXISTS (
        SELECT 1 FROM user_permissions
        WHERE user_id = v_user_id
          AND resource_id = p_resource_id
          AND action = p_action
          AND granted = TRUE
    ) INTO v_has_permission;

    IF NOT v_has_permission THEN
        RAISE EXCEPTION 'Permission denied: user % cannot % on resource %',
            v_user_id, p_action, p_resource_id;
    END IF;

    -- 执行操作
    CASE p_action
        WHEN 'read' THEN
            PERFORM read_resource(p_resource_id);
        WHEN 'write' THEN
            PERFORM write_resource(p_resource_id);
        ELSE
            RAISE EXCEPTION 'Unknown action: %', p_action;
    END CASE;

    COMMIT;
END;
$$;
```

---

## 8. 实战案例

### 8.1 复杂业务流程实现

#### 订单处理流程

```sql
-- 完整的订单处理流程
CREATE OR REPLACE PROCEDURE process_order_complete(
    p_order_id INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_order RECORD;
    v_item RECORD;
    v_total DECIMAL := 0;
    v_inventory_check BOOLEAN;
BEGIN
    -- 1. 获取订单信息并锁定
    SELECT * INTO v_order
    FROM orders
    WHERE id = p_order_id
    FOR UPDATE;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Order % not found', p_order_id;
    END IF;

    IF v_order.status != 'pending' THEN
        RAISE EXCEPTION 'Order % is already processed (status: %)',
            p_order_id, v_order.status;
    END IF;

    -- 2. 检查库存
    FOR v_item IN
        SELECT oi.*, p.stock
        FROM order_items oi
        JOIN products p ON oi.product_id = p.id
        WHERE oi.order_id = p_order_id
        FOR UPDATE
    LOOP
        IF v_item.stock < v_item.quantity THEN
            RAISE EXCEPTION 'Insufficient stock for product %: requested %, available %',
                v_item.product_id, v_item.quantity, v_item.stock;
        END IF;

        v_total := v_total + (v_item.price * v_item.quantity);
    END LOOP;

    -- 3. 检查账户余额
    IF v_order.user_id IS NOT NULL THEN
        DECLARE
            v_balance DECIMAL;
        BEGIN
            SELECT balance INTO v_balance
            FROM accounts
            WHERE user_id = v_order.user_id
            FOR UPDATE;

            IF v_balance < v_total THEN
                RAISE EXCEPTION 'Insufficient balance: required %, available %',
                    v_total, v_balance;
            END IF;
        END;
    END IF;

    -- 4. 创建保存点
    SAVEPOINT before_processing;

    BEGIN
        -- 5. 扣除库存
        UPDATE products p
        SET stock = stock - oi.quantity
        FROM order_items oi
        WHERE p.id = oi.product_id
          AND oi.order_id = p_order_id;

        -- 6. 扣除账户余额
        IF v_order.user_id IS NOT NULL THEN
            UPDATE accounts
            SET balance = balance - v_total
            WHERE user_id = v_order.user_id;
        END IF;

        -- 7. 更新订单状态
        UPDATE orders
        SET status = 'processed',
            processed_at = NOW(),
            total_amount = v_total
        WHERE id = p_order_id;

        -- 8. 记录交易
        INSERT INTO transactions (order_id, amount, transaction_time)
        VALUES (p_order_id, v_total, NOW());

        -- 释放保存点
        RELEASE SAVEPOINT before_processing;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK TO SAVEPOINT before_processing;
            -- 更新订单状态为失败
            UPDATE orders
            SET status = 'failed',
                error_message = SQLERRM
            WHERE id = p_order_id;
            RAISE;
    END;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$;
```

---

## 📚 参考资源

1. **PostgreSQL官方文档**: <https://www.postgresql.org/docs/current/sql-createprocedure.html>
2. **PL/pgSQL文档**: <https://www.postgresql.org/docs/current/plpgsql.html>
3. **事务控制**: <https://www.postgresql.org/docs/current/tutorial-transactions.html>

---

## 📝 更新日志

- **v2.0** (2025-01): 深度应用指南
  - 补充事务控制完整实现（COMMIT、ROLLBACK、SAVEPOINT）
  - 补充异常处理完整实现
  - 补充性能优化技巧
  - 补充安全特性
  - 补充调试与测试
  - 补充版本管理
  - 补充实战案例

---

**状态**: ✅ **文档完成** | [返回目录](./README.md)
