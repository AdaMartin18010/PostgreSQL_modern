---

> **📋 文档来源**: `PostgreSQL\09-应用设计\数据模型设计\09.01-数据分析完整指南.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL数据分析完整指南

> **版本**: v1.1
> **最后更新**: 2025-11-22
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **难度**: ⭐⭐⭐⭐
> **应用场景**: 数据分析、商业智能、报表生成、数据探索、统计分析

---

## 📋 目录

- [PostgreSQL数据分析完整指南](#postgresql数据分析完整指南)
  - [📋 目录](#-目录)
  - [一、概述](#一概述)
    - [1.1 数据分析概念](#11-数据分析概念)
    - [1.2 PostgreSQL数据分析优势](#12-postgresql数据分析优势)
    - [1.3 应用场景](#13-应用场景)
    - [1.4 版本要求](#14-版本要求)
  - [二、数据分析基础](#二数据分析基础)
    - [2.1 描述性统计分析](#21-描述性统计分析)
    - [2.2 探索性数据分析（EDA）](#22-探索性数据分析eda)
    - [2.3 数据分布分析](#23-数据分布分析)
    - [2.4 相关性分析](#24-相关性分析)
  - [三、高级分析技术](#三高级分析技术)
    - [3.1 时间序列分析](#31-时间序列分析)
    - [3.2 分组分析](#32-分组分析)
    - [3.3 窗口函数分析](#33-窗口函数分析)
    - [3.4 聚合分析](#34-聚合分析)
  - [三、前沿分析技术](#三前沿分析技术)
    - [3.5 关系深度学习（Relational Deep Learning）](#35-关系深度学习relational-deep-learning)
    - [3.6 图基特征合成（Graph-based Feature Synthesis, GFS）](#36-图基特征合成graph-based-feature-synthesis-gfs)
  - [四、统计分析函数](#四统计分析函数)
    - [4.1 统计函数](#41-统计函数)
    - [4.2 分布函数](#42-分布函数)
    - [4.3 假设检验](#43-假设检验)
  - [五、数据可视化查询](#五数据可视化查询)
    - [5.1 报表查询设计](#51-报表查询设计)
    - [5.2 透视表查询](#52-透视表查询)
    - [5.3 趋势分析查询](#53-趋势分析查询)
  - [六、性能优化](#六性能优化)
    - [6.1 查询优化](#61-查询优化)
    - [6.2 索引优化](#62-索引优化)
    - [6.3 物化视图优化](#63-物化视图优化)
    - [6.4 列存储优化 🆕](#64-列存储优化-)
  - [七、实践案例](#七实践案例)
    - [7.1 销售数据分析](#71-销售数据分析)
    - [7.2 用户行为分析](#72-用户行为分析)
    - [7.3 运营数据分析](#73-运营数据分析)
  - [八、PostgreSQL 18新特性](#八postgresql-18新特性)
    - [8.1 并行查询增强](#81-并行查询增强)
    - [8.2 异步I/O优化](#82-异步io优化)
    - [8.3 虚拟生成列](#83-虚拟生成列)
  - [九、最佳实践](#九最佳实践)
  - [十、参考资源](#十参考资源)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 相关文档](#102-相关文档)
    - [10.3 外部资源](#103-外部资源)
  - [十一、交叉引用](#十一交叉引用)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)

---

## 一、概述

### 1.1 数据分析概念

**数据分析**是指对数据进行收集、清洗、转换、建模和分析的过程，旨在发现数据中的模式、趋势和洞察，为决策提供支持。

**数据分析的核心步骤**：

1. **数据收集**：从各种数据源收集数据
2. **数据清洗**：处理缺失值、异常值、重复数据
3. **数据探索**：探索数据分布、相关性、异常
4. **数据分析**：应用统计方法和分析技术
5. **结果解释**：解释分析结果，生成洞察
6. **可视化展示**：通过图表展示分析结果

### 1.2 PostgreSQL数据分析优势

**PostgreSQL在数据分析中的优势**：

- ✅ **强大的SQL功能**：支持复杂的查询和分析
- ✅ **丰富的统计函数**：内置大量统计函数
- ✅ **窗口函数**：支持高级窗口分析
- ✅ **JSONB支持**：灵活处理半结构化数据
- ✅ **数组支持**：处理数组和序列数据
- ✅ **并行查询**：支持并行分析查询
- ✅ **扩展支持**：支持统计扩展（如PostGIS、pg_stat_statements）

### 1.3 应用场景

**PostgreSQL数据分析适用于**：

- ✅ **商业智能（BI）**：报表生成、仪表板
- ✅ **数据探索**：探索性数据分析（EDA）
- ✅ **统计分析**：描述性统计、推断统计
- ✅ **时间序列分析**：趋势分析、季节性分析
- ✅ **用户行为分析**：用户画像、行为路径分析
- ✅ **运营分析**：运营指标分析、KPI监控

### 1.4 版本要求

- **PostgreSQL 18.x**（推荐）- 支持并行查询增强、异步I/O
- **PostgreSQL 17.x**（推荐）- 功能完整
- **PostgreSQL 16.x**（兼容）- 基础功能支持

---

## 二、数据分析基础

### 2.1 描述性统计分析

**描述性统计**用于描述数据的基本特征，包括中心趋势、离散程度、分布形状等。

**基本统计量**：

```sql
-- 数值型变量的描述性统计
SELECT
    'sales' AS variable,
    COUNT(*) AS count,
    COUNT(DISTINCT amount) AS distinct_count,
    MIN(amount) AS min_value,
    MAX(amount) AS max_value,
    AVG(amount) AS mean,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3,
    STDDEV(amount) AS stddev,
    VARIANCE(amount) AS variance,
    SUM(amount) AS total
FROM sales
WHERE sale_date >= '2025-01-01';

-- 分类变量的描述性统计
SELECT
    category,
    COUNT(*) AS count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS percentage,
    AVG(amount) AS avg_amount,
    SUM(amount) AS total_amount
FROM sales
GROUP BY category
ORDER BY count DESC;
```

**多变量描述性统计**：

```sql
-- 多个变量的描述性统计
SELECT
    COUNT(*) AS n,
    AVG(sales_amount) AS avg_sales,
    STDDEV(sales_amount) AS stddev_sales,
    AVG(quantity) AS avg_quantity,
    STDDEV(quantity) AS stddev_quantity,
    AVG(profit) AS avg_profit,
    STDDEV(profit) AS stddev_profit
FROM sales
WHERE sale_date >= '2025-01-01';
```

### 2.2 探索性数据分析（EDA）

**探索性数据分析**用于探索数据的结构、分布、异常和关系。

**数据概览**：

```sql
-- 数据概览查询
SELECT
    COUNT(*) AS total_rows,
    COUNT(DISTINCT customer_id) AS unique_customers,
    COUNT(DISTINCT product_id) AS unique_products,
    MIN(sale_date) AS first_sale,
    MAX(sale_date) AS last_sale,
    COUNT(*) FILTER (WHERE amount IS NULL) AS null_amount_count,
    COUNT(*) FILTER (WHERE amount < 0) AS negative_amount_count
FROM sales;
```

**数据分布探索**：

```sql
-- 数据分布分析（直方图数据）
WITH bins AS (
    SELECT
        width_bucket(amount, 0, 10000, 20) AS bucket,
        MIN(amount) AS bucket_min,
        MAX(amount) AS bucket_max,
        COUNT(*) AS frequency
    FROM sales
    WHERE amount IS NOT NULL
    GROUP BY bucket
)
SELECT
    bucket,
    bucket_min,
    bucket_max,
    frequency,
    frequency * 100.0 / SUM(frequency) OVER () AS percentage,
    REPEAT('█', (frequency::NUMERIC / MAX(frequency) OVER () * 50)::INTEGER) AS histogram
FROM bins
ORDER BY bucket;
```

**异常值检测**：

```sql
-- 使用IQR方法检测异常值
WITH stats AS (
    SELECT
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS iqr
    FROM sales
    WHERE amount IS NOT NULL
)
SELECT
    s.*,
    CASE
        WHEN s.amount < stats.q1 - 1.5 * stats.iqr THEN 'Low Outlier'
        WHEN s.amount > stats.q3 + 1.5 * stats.iqr THEN 'High Outlier'
        ELSE 'Normal'
    END AS outlier_type
FROM sales s, stats
WHERE s.amount IS NOT NULL
ORDER BY s.amount DESC;
```

### 2.3 数据分布分析

**数据分布分析**用于了解数据的分布特征。

**正态性检验**：

```sql
-- 使用偏度和峰度检验正态性
SELECT
    AVG(amount) AS mean,
    STDDEV(amount) AS stddev,
    -- 偏度（Skewness）
    SUM(POWER((amount - AVG(amount)) / STDDEV(amount), 3)) / COUNT(*) AS skewness,
    -- 峰度（Kurtosis）
    SUM(POWER((amount - AVG(amount)) / STDDEV(amount), 4)) / COUNT(*) AS kurtosis
FROM sales
WHERE amount IS NOT NULL;

-- 偏度接近0表示对称分布，峰度接近3表示正态分布
```

**分位数分析**：

```sql
-- 分位数分析
SELECT
    PERCENTILE_CONT(0.1) WITHIN GROUP (ORDER BY amount) AS p10,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS p25,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS p50,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS p75,
    PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY amount) AS p90,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY amount) AS p95,
    PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY amount) AS p99
FROM sales
WHERE amount IS NOT NULL;
```

### 2.4 相关性分析

**相关性分析**用于分析变量之间的关系。

**数值变量相关性**：

```sql
-- 计算相关系数矩阵
WITH stats AS (
    SELECT
        AVG(sales_amount) AS mean_sales,
        STDDEV(sales_amount) AS stddev_sales,
        AVG(quantity) AS mean_quantity,
        STDDEV(quantity) AS stddev_quantity,
        AVG(profit) AS mean_profit,
        STDDEV(profit) AS stddev_profit
    FROM sales
)
SELECT
    'Sales vs Quantity' AS pair,
    CORR(sales_amount, quantity) AS correlation
FROM sales, stats
UNION ALL
SELECT
    'Sales vs Profit' AS pair,
    CORR(sales_amount, profit) AS correlation
FROM sales, stats
UNION ALL
SELECT
    'Quantity vs Profit' AS pair,
    CORR(quantity, profit) AS correlation
FROM sales, stats;
```

**分类变量关联性**：

```sql
-- 分类变量关联性分析（卡方检验数据准备）
SELECT
    category,
    region,
    COUNT(*) AS count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY category) AS pct_by_category,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY region) AS pct_by_region
FROM sales
GROUP BY category, region
ORDER BY category, region;
```

---

## 三、高级分析技术

### 3.1 时间序列分析

**时间序列分析**用于分析时间序列数据的趋势、季节性和周期性。

**趋势分析**：

```sql
-- 时间序列趋势分析
SELECT
    DATE_TRUNC('day', sale_date) AS date,
    COUNT(*) AS daily_count,
    SUM(amount) AS daily_amount,
    AVG(amount) AS daily_avg,
    -- 移动平均（7天）
    AVG(SUM(amount)) OVER (
        ORDER BY DATE_TRUNC('day', sale_date)
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma_7d,
    -- 移动平均（30天）
    AVG(SUM(amount)) OVER (
        ORDER BY DATE_TRUNC('day', sale_date)
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS ma_30d,
    -- 同比增长率
    SUM(amount) * 100.0 / LAG(SUM(amount), 365) OVER (
        ORDER BY DATE_TRUNC('day', sale_date)
    ) - 100 AS yoy_growth
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY DATE_TRUNC('day', sale_date)
ORDER BY date;
```

**季节性分析**：

```sql
-- 季节性分析
SELECT
    EXTRACT(MONTH FROM sale_date) AS month,
    EXTRACT(DOW FROM sale_date) AS day_of_week,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    -- 与月平均值的差异
    AVG(amount) - AVG(AVG(amount)) OVER () AS deviation_from_mean
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY EXTRACT(MONTH FROM sale_date), EXTRACT(DOW FROM sale_date)
ORDER BY month, day_of_week;
```

### 3.2 分组分析

**分组分析**用于对不同组别进行比较分析。

**多维度分组分析**：

```sql
-- 多维度分组分析
SELECT
    category,
    region,
    DATE_TRUNC('month', sale_date) AS month,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    -- 组内排名
    RANK() OVER (
        PARTITION BY category, region
        ORDER BY SUM(amount) DESC
    ) AS rank_in_group,
    -- 组内占比
    SUM(amount) * 100.0 / SUM(SUM(amount)) OVER (
        PARTITION BY category, region
    ) AS pct_in_group
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY category, region, DATE_TRUNC('month', sale_date)
ORDER BY category, region, month;
```

**分组对比分析**：

```sql
-- A/B测试结果分析
SELECT
    test_group,
    COUNT(*) AS user_count,
    COUNT(*) FILTER (WHERE converted = TRUE) AS converted_count,
    COUNT(*) FILTER (WHERE converted = TRUE) * 100.0 / COUNT(*) AS conversion_rate,
    AVG(revenue) AS avg_revenue,
    SUM(revenue) AS total_revenue
FROM ab_test_results
GROUP BY test_group
ORDER BY test_group;
```

### 3.3 窗口函数分析

**窗口函数**用于在数据集的窗口内进行计算。

**累计分析**：

```sql
-- 累计销售额分析
SELECT
    sale_date,
    SUM(amount) AS daily_amount,
    SUM(SUM(amount)) OVER (
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_amount,
    SUM(SUM(amount)) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_30d_amount
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY sale_date
ORDER BY sale_date;
```

**排名分析**：

```sql
-- 排名分析
SELECT
    customer_id,
    SUM(amount) AS total_amount,
    RANK() OVER (ORDER BY SUM(amount) DESC) AS rank_all,
    DENSE_RANK() OVER (ORDER BY SUM(amount) DESC) AS dense_rank_all,
    PERCENT_RANK() OVER (ORDER BY SUM(amount) DESC) AS percent_rank,
    NTILE(4) OVER (ORDER BY SUM(amount) DESC) AS quartile
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY customer_id
ORDER BY total_amount DESC
LIMIT 100;
```

### 3.4 聚合分析

**聚合分析**用于对数据进行汇总和聚合。

**多级聚合**：

```sql
-- 多级聚合（ROLLUP）
SELECT
    category,
    region,
    DATE_TRUNC('month', sale_date) AS month,
    SUM(amount) AS total_amount
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY ROLLUP(category, region, DATE_TRUNC('month', sale_date))
ORDER BY category, region, month;

-- 多级聚合（CUBE）
SELECT
    category,
    region,
    DATE_TRUNC('month', sale_date) AS month,
    SUM(amount) AS total_amount
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY CUBE(category, region, DATE_TRUNC('month', sale_date))
ORDER BY category, region, month;
```

**条件聚合**：

```sql
-- 条件聚合
SELECT
    customer_id,
    COUNT(*) AS total_orders,
    COUNT(*) FILTER (WHERE amount > 1000) AS high_value_orders,
    COUNT(*) FILTER (WHERE amount <= 1000) AS low_value_orders,
    SUM(amount) FILTER (WHERE amount > 1000) AS high_value_total,
    SUM(amount) FILTER (WHERE amount <= 1000) AS low_value_total,
    AVG(amount) FILTER (WHERE amount > 1000) AS high_value_avg
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY customer_id
HAVING COUNT(*) >= 10;
```

---

## 三、前沿分析技术

### 3.5 关系深度学习（Relational Deep Learning）

**关系深度学习**是一种直接在多表关联的关系数据库上进行学习的方法，避免了传统的特征工程步骤。该方法将关系数据库视为异构图，利用图神经网络自动学习数据的表示。

**PostgreSQL中的关系数据表示**：

```sql
-- 1. 多表关系数据建模
-- 用户表
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    age INTEGER,
    gender VARCHAR(10),
    registration_date DATE
);

-- 订单表
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    order_date DATE NOT NULL,
    total_amount NUMERIC(10,2) NOT NULL
);

-- 订单项表
CREATE TABLE order_items (
    order_item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    product_id BIGINT NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    price NUMERIC(10,2) NOT NULL
);

-- 2. 关系特征提取：使用窗口函数和聚合
-- 用户特征：订单历史统计
CREATE VIEW user_features AS
SELECT
    u.user_id,
    u.age,
    u.gender,
    EXTRACT(YEAR FROM AGE(u.registration_date)) AS registration_years,
    -- 订单统计特征
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_amount) AS total_spent,
    AVG(o.total_amount) AS avg_order_amount,
    MAX(o.order_date) AS last_order_date,
    MIN(o.order_date) AS first_order_date,
    -- 订单项统计特征
    SUM(oi.quantity) AS total_items_purchased,
    COUNT(DISTINCT oi.product_id) AS unique_products_purchased,
    AVG(oi.price) AS avg_item_price
FROM users u
LEFT JOIN orders o ON o.user_id = u.user_id
LEFT JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY u.user_id, u.age, u.gender, u.registration_date;

-- 3. 关系图表示：使用递归CTE构建关系图
-- 用户-订单-产品关系图
WITH user_order_graph AS (
    SELECT
        u.user_id AS source_node,
        o.order_id AS target_node,
        'user_order' AS edge_type,
        jsonb_build_object(
            'order_amount', o.total_amount,
            'order_date', o.order_date
        ) AS edge_properties
    FROM users u
    JOIN orders o ON o.user_id = u.user_id
),
order_product_graph AS (
    SELECT
        o.order_id AS source_node,
        p.product_id AS target_node,
        'order_product' AS edge_type,
        jsonb_build_object(
            'quantity', oi.quantity,
            'price', oi.price
        ) AS edge_properties
    FROM orders o
    JOIN order_items oi ON oi.order_id = o.order_id
    JOIN products p ON p.product_id = oi.product_id
)
SELECT * FROM user_order_graph
UNION ALL
SELECT * FROM order_product_graph;

-- 4. 关系路径特征：查找用户-产品路径
WITH user_product_paths AS (
    SELECT DISTINCT
        u.user_id,
        p.product_id,
        COUNT(DISTINCT o.order_id) AS path_count,
        SUM(oi.quantity) AS total_quantity,
        AVG(oi.price) AS avg_price
    FROM users u
    JOIN orders o ON o.user_id = u.user_id
    JOIN order_items oi ON oi.order_id = o.order_id
    JOIN products p ON p.product_id = oi.product_id
    GROUP BY u.user_id, p.product_id
)
SELECT * FROM user_product_paths;
```

**关系深度学习的优势**：

- **自动特征工程**：无需手动合并多表数据
- **关系结构保留**：保留数据的关系结构
- **复杂关系捕获**：能够捕获多表之间的复杂关系

### 3.6 图基特征合成（Graph-based Feature Synthesis, GFS）

**图基特征合成**是一种将关系数据库建模为异构图，保留数据的关系结构，消除手动特征工程需求的框架。

**PostgreSQL中的图特征合成**：

```sql
-- 1. 构建异构图：定义节点和边
-- 节点表
CREATE TABLE graph_nodes (
    node_id BIGSERIAL PRIMARY KEY,
    node_type VARCHAR(50) NOT NULL,  -- 'user', 'order', 'product', 'category'
    node_data JSONB NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 边表
CREATE TABLE graph_edges (
    edge_id BIGSERIAL PRIMARY KEY,
    source_node_id BIGINT NOT NULL REFERENCES graph_nodes(node_id),
    target_node_id BIGINT NOT NULL REFERENCES graph_nodes(node_id),
    edge_type VARCHAR(50) NOT NULL,  -- 'purchases', 'contains', 'belongs_to'
    edge_data JSONB DEFAULT '{}'::jsonb,
    weight NUMERIC DEFAULT 1.0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_edges_source ON graph_edges(source_node_id, edge_type);
CREATE INDEX idx_edges_target ON graph_edges(target_node_id, edge_type);

-- 2. 图特征提取：节点度（Degree）
CREATE VIEW node_degrees AS
SELECT
    n.node_id,
    n.node_type,
    COUNT(DISTINCT e1.edge_id) AS out_degree,
    COUNT(DISTINCT e2.edge_id) AS in_degree,
    COUNT(DISTINCT e1.edge_id) + COUNT(DISTINCT e2.edge_id) AS total_degree
FROM graph_nodes n
LEFT JOIN graph_edges e1 ON e1.source_node_id = n.node_id
LEFT JOIN graph_edges e2 ON e2.target_node_id = n.node_id
GROUP BY n.node_id, n.node_type;

-- 3. 图特征提取：路径特征（Path Features）
-- 查找用户到产品的路径
WITH RECURSIVE user_product_paths AS (
    -- 起始：用户节点
    SELECT
        u.node_id AS start_node,
        u.node_id AS current_node,
        ARRAY[u.node_id] AS path,
        0 AS path_length,
        'user' AS path_type
    FROM graph_nodes u
    WHERE u.node_type = 'user'

    UNION ALL

    -- 递归：沿着边遍历
    SELECT
        upp.start_node,
        e.target_node_id,
        upp.path || e.target_node_id,
        upp.path_length + 1,
        upp.path_type || '->' || (
            SELECT node_type FROM graph_nodes WHERE node_id = e.target_node_id
        )
    FROM user_product_paths upp
    JOIN graph_edges e ON e.source_node_id = upp.current_node
    WHERE upp.path_length < 3  -- 限制路径长度
    AND NOT e.target_node_id = ANY(upp.path)  -- 避免循环
)
SELECT
    start_node AS user_node_id,
    current_node AS product_node_id,
    path_length,
    path_type,
    COUNT(*) AS path_count
FROM user_product_paths
WHERE EXISTS (
    SELECT 1 FROM graph_nodes WHERE node_id = current_node AND node_type = 'product'
)
GROUP BY start_node, current_node, path_length, path_type;

-- 4. 图特征提取：邻居特征（Neighbor Features）
CREATE VIEW node_neighbor_features AS
SELECT
    n.node_id,
    n.node_type,
    -- 邻居统计特征
    COUNT(DISTINCT e.target_node_id) AS neighbor_count,
    COUNT(DISTINCT e.target_node_id) FILTER (
        WHERE EXISTS (
            SELECT 1 FROM graph_nodes n2
            WHERE n2.node_id = e.target_node_id AND n2.node_type = 'product'
        )
    ) AS product_neighbor_count,
    AVG(e.weight) AS avg_edge_weight,
    SUM(e.weight) AS total_edge_weight
FROM graph_nodes n
LEFT JOIN graph_edges e ON e.source_node_id = n.node_id
GROUP BY n.node_id, n.node_type;

-- 5. 图特征提取：中心性特征（Centrality Features）
-- 使用物化视图缓存中心性计算
CREATE MATERIALIZED VIEW node_centrality AS
WITH node_connections AS (
    SELECT
        source_node_id AS node_id,
        COUNT(*) AS out_connections
    FROM graph_edges
    GROUP BY source_node_id

    UNION ALL

    SELECT
        target_node_id AS node_id,
        COUNT(*) AS in_connections
    FROM graph_edges
    GROUP BY target_node_id
),
node_stats AS (
    SELECT
        node_id,
        SUM(out_connections) AS total_out,
        SUM(in_connections) AS total_in,
        SUM(out_connections) + SUM(in_connections) AS total_connections
    FROM node_connections
    GROUP BY node_id
),
max_connections AS (
    SELECT MAX(total_connections) AS max_conn FROM node_stats
)
SELECT
    ns.node_id,
    ns.total_out,
    ns.total_in,
    ns.total_connections,
    -- 度中心性（Degree Centrality）
    ns.total_connections::NUMERIC / NULLIF(mc.max_conn, 0) AS degree_centrality
FROM node_stats ns
CROSS JOIN max_connections mc;

CREATE UNIQUE INDEX ON node_centrality(node_id);
```

**图基特征合成的优势**：

- **关系结构保留**：保留数据的关系结构
- **复杂关系捕获**：有效捕捉每个表中的复杂关系
- **自动特征工程**：消除手动特征工程的需求

---

## 四、统计分析函数

### 4.1 统计函数

**PostgreSQL内置统计函数**：

```sql
-- 基本统计函数
SELECT
    COUNT(*) AS count,
    COUNT(DISTINCT customer_id) AS unique_customers,
    SUM(amount) AS total,
    AVG(amount) AS mean,
    MIN(amount) AS min,
    MAX(amount) AS max,
    STDDEV(amount) AS stddev,
    STDDEV_POP(amount) AS stddev_pop,
    STDDEV_SAMP(amount) AS stddev_samp,
    VARIANCE(amount) AS variance,
    VAR_POP(amount) AS var_pop,
    VAR_SAMP(amount) AS var_samp
FROM sales;

-- 分位数函数
SELECT
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3,
    PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY amount) AS median_disc
FROM sales;
```

### 4.2 分布函数

**分布函数**用于分析数据的分布特征。

```sql
-- 正态分布检验（使用Z-score）
WITH stats AS (
    SELECT
        AVG(amount) AS mean,
        STDDEV(amount) AS stddev
    FROM sales
    WHERE amount IS NOT NULL
)
SELECT
    amount,
    (amount - stats.mean) / stats.stddev AS z_score,
    CASE
        WHEN ABS((amount - stats.mean) / stats.stddev) > 3 THEN 'Outlier (3σ)'
        WHEN ABS((amount - stats.mean) / stats.stddev) > 2 THEN 'Outlier (2σ)'
        ELSE 'Normal'
    END AS outlier_status
FROM sales, stats
WHERE amount IS NOT NULL
ORDER BY ABS((amount - stats.mean) / stats.stddev) DESC
LIMIT 100;
```

### 4.3 假设检验

**假设检验**用于验证统计假设。

```sql
-- 两样本t检验数据准备
WITH group_a AS (
    SELECT amount, 'A' AS group_name
    FROM sales
    WHERE test_group = 'A'
),
group_b AS (
    SELECT amount, 'B' AS group_name
    FROM sales
    WHERE test_group = 'B'
),
stats AS (
    SELECT
        'A' AS group_name,
        COUNT(*) AS n,
        AVG(amount) AS mean,
        STDDEV(amount) AS stddev
    FROM group_a
    UNION ALL
    SELECT
        'B' AS group_name,
        COUNT(*) AS n,
        AVG(amount) AS mean,
        STDDEV(amount) AS stddev
    FROM group_b
)
SELECT
    a.group_name AS group_a,
    b.group_name AS group_b,
    a.mean AS mean_a,
    b.mean AS mean_b,
    a.mean - b.mean AS mean_diff,
    -- 简化t统计量计算
    (a.mean - b.mean) / SQRT(
        POWER(a.stddev, 2) / a.n + POWER(b.stddev, 2) / b.n
    ) AS t_statistic
FROM stats a, stats b
WHERE a.group_name = 'A' AND b.group_name = 'B';
```

---

## 五、数据可视化查询

### 5.1 报表查询设计

**报表查询**用于生成结构化报表。

```sql
-- 销售报表查询
SELECT
    DATE_TRUNC('month', sale_date) AS month,
    category,
    COUNT(*) AS order_count,
    COUNT(DISTINCT customer_id) AS customer_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    -- 环比增长率
    SUM(amount) * 100.0 / LAG(SUM(amount)) OVER (
        PARTITION BY category
        ORDER BY DATE_TRUNC('month', sale_date)
    ) - 100 AS mom_growth
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY DATE_TRUNC('month', sale_date), category
ORDER BY month, category;
```

### 5.2 透视表查询

**透视表查询**用于生成交叉表。

```sql
-- 使用crosstab生成透视表（需要tablefunc扩展）
CREATE EXTENSION IF NOT EXISTS tablefunc;

SELECT *
FROM crosstab(
    $$
    SELECT
        DATE_TRUNC('month', sale_date)::text AS month,
        category,
        SUM(amount) AS total_amount
    FROM sales
    WHERE sale_date >= '2024-01-01'
    GROUP BY DATE_TRUNC('month', sale_date), category
    ORDER BY 1, 2
    $$,
    $$
    SELECT DISTINCT category
    FROM sales
    ORDER BY category
    $$
) AS ct(
    month text,
    category_a NUMERIC,
    category_b NUMERIC,
    category_c NUMERIC
);
```

### 5.3 趋势分析查询

**趋势分析查询**用于分析数据趋势。

```sql
-- 趋势分析查询
WITH daily_stats AS (
    SELECT
        DATE_TRUNC('day', sale_date) AS date,
        SUM(amount) AS daily_amount,
        COUNT(*) AS daily_count
    FROM sales
    WHERE sale_date >= '2024-01-01'
    GROUP BY DATE_TRUNC('day', sale_date)
),
trend_analysis AS (
    SELECT
        date,
        daily_amount,
        daily_count,
        -- 移动平均
        AVG(daily_amount) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS ma_7d,
        -- 趋势方向
        CASE
            WHEN daily_amount > LAG(daily_amount) OVER (ORDER BY date) THEN 'Up'
            WHEN daily_amount < LAG(daily_amount) OVER (ORDER BY date) THEN 'Down'
            ELSE 'Stable'
        END AS trend_direction,
        -- 变化率
        (daily_amount - LAG(daily_amount) OVER (ORDER BY date)) * 100.0 /
        NULLIF(LAG(daily_amount) OVER (ORDER BY date), 0) AS change_rate
    FROM daily_stats
)
SELECT *
FROM trend_analysis
ORDER BY date;
```

---

## 六、性能优化

### 6.1 查询优化

**分析查询优化技巧**：

```sql
-- 使用物化视图缓存分析结果
CREATE MATERIALIZED VIEW mv_sales_analysis AS
SELECT
    DATE_TRUNC('month', sale_date) AS month,
    category,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY DATE_TRUNC('month', sale_date), category;

CREATE UNIQUE INDEX ON mv_sales_analysis(month, category);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_analysis;
```

### 6.2 索引优化

**为分析查询创建合适的索引**：

```sql
-- 为时间序列分析创建索引
CREATE INDEX idx_sales_date_category ON sales(sale_date, category);
CREATE INDEX idx_sales_date_amount ON sales(sale_date, amount);

-- 为分组分析创建索引
CREATE INDEX idx_sales_category_region ON sales(category, region);
```

### 6.3 物化视图优化

**使用物化视图优化复杂分析查询**：

```sql
-- 创建预聚合物化视图
CREATE MATERIALIZED VIEW mv_daily_sales_summary AS
SELECT
    DATE_TRUNC('day', sale_date) AS date,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total,
    AVG(amount) AS avg,
    MIN(amount) AS min,
    MAX(amount) AS max
FROM sales
GROUP BY DATE_TRUNC('day', sale_date), category;

CREATE UNIQUE INDEX ON mv_daily_sales_summary(date, category);

-- 增量刷新策略
CREATE OR REPLACE FUNCTION refresh_daily_sales_summary()
RETURNS void AS $$
BEGIN
    -- 删除今天的数据
    DELETE FROM mv_daily_sales_summary
    WHERE date >= CURRENT_DATE;

    -- 重新计算今天的数据
    INSERT INTO mv_daily_sales_summary
    SELECT
        DATE_TRUNC('day', sale_date) AS date,
        category,
        COUNT(*) AS count,
        SUM(amount) AS total,
        AVG(amount) AS avg,
        MIN(amount) AS min,
        MAX(amount) AS max
    FROM sales
    WHERE sale_date >= CURRENT_DATE
    GROUP BY DATE_TRUNC('day', sale_date), category;
END;
$$ LANGUAGE plpgsql;
```

### 6.4 列存储优化 🆕

**列存储概述**：

数据分析场景中，大量查询是**分析型查询**，特点：

- 只查询部分列（如：只查询销售金额、数量、日期）
- 大量聚合操作（SUM、AVG、COUNT、GROUP BY）
- 扫描大量数据行
- 很少更新操作

列存储在数据分析场景下具有显著优势：

- **I/O减少**：只读取需要的列，I/O减少50-90%
- **压缩率高**：同列数据类型相同，压缩率提升3-10倍
- **聚合性能**：列数据可批量处理，聚合性能提升10-100倍

**列存储数据分析实现**：

```sql
-- 1. 安装cstore_fdw扩展
CREATE EXTENSION IF NOT EXISTS cstore_fdw;

-- 2. 创建列存储服务器
CREATE SERVER cstore_server
FOREIGN DATA WRAPPER cstore_fdw;

-- 3. 创建列存储分析表
CREATE FOREIGN TABLE analytics_sales_columnar (
    sale_id BIGINT,
    sale_date DATE,
    product_id INTEGER,
    category VARCHAR(50),
    region VARCHAR(50),
    amount NUMERIC(10,2),
    quantity INTEGER,
    customer_id BIGINT
) SERVER cstore_server
OPTIONS (
    compression 'pglz',
    stripe_row_count '150000'
);

-- 4. 从行存储表导入数据
INSERT INTO analytics_sales_columnar
SELECT sale_id, sale_date, product_id, category, region, amount, quantity, customer_id
FROM sales
WHERE sale_date < CURRENT_DATE - INTERVAL '3 months';  -- 历史数据

-- 5. 列存储分析查询示例
-- 查询：按类别和地区统计销售
SELECT
    category,
    region,
    COUNT(*) AS sale_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    SUM(quantity) AS total_quantity
FROM analytics_sales_columnar
WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY category, region
ORDER BY total_amount DESC;

-- 性能对比：
-- 行存储：扫描所有列，I/O大，查询时间：15-30秒
-- 列存储：只扫描需要的列，I/O小，查询时间：2-5秒
-- 性能提升：5-10倍
```

**列存储时间序列分析**：

```sql
-- 时间序列分析：按日期聚合
SELECT
    DATE_TRUNC('month', sale_date) AS month,
    category,
    COUNT(*) AS sale_count,
    SUM(amount) AS monthly_total,
    AVG(amount) AS monthly_avg
FROM analytics_sales_columnar
WHERE sale_date >= '2023-01-01'
GROUP BY DATE_TRUNC('month', sale_date), category
ORDER BY month, category;

-- 列存储优势：
-- ✅ 只读取sale_date, category, amount三列
-- ✅ 压缩率高，I/O减少80%
-- ✅ 聚合性能提升5-10倍
```

**列存储用户行为分析**：

```sql
-- 用户行为分析：用户购买行为统计
SELECT
    customer_id,
    COUNT(DISTINCT product_id) AS product_count,
    COUNT(*) AS purchase_count,
    SUM(amount) AS total_spent,
    AVG(amount) AS avg_purchase,
    MIN(sale_date) AS first_purchase,
    MAX(sale_date) AS last_purchase
FROM analytics_sales_columnar
WHERE sale_date >= '2023-01-01'
GROUP BY customer_id
HAVING COUNT(*) >= 10  -- 购买次数>=10的用户
ORDER BY total_spent DESC
LIMIT 100;

-- 列存储优势：
-- ✅ 只读取customer_id, product_id, amount, sale_date四列
-- ✅ 压缩率高，存储空间节省70-80%
-- ✅ 聚合查询性能提升5-10倍
```

**列存储压缩优化**：

```sql
-- 使用zstd压缩（更高压缩率，适合历史数据）
CREATE FOREIGN TABLE analytics_sales_columnar_zstd (
    sale_id BIGINT,
    sale_date DATE,
    product_id INTEGER,
    category VARCHAR(50),
    region VARCHAR(50),
    amount NUMERIC(10,2),
    quantity INTEGER,
    customer_id BIGINT
) SERVER cstore_server
OPTIONS (
    compression 'zstd',  -- zstd压缩，压缩率80%
    stripe_row_count '150000'
);

-- 压缩效果对比：
-- 原始数据：100GB
-- pglz压缩：30GB（压缩率70%）
-- zstd压缩：20GB（压缩率80%）
-- 存储节省：80GB
```

**列存储数据分析最佳实践**：

1. **历史数据分析**：使用列存储
   - 只读数据
   - 分析查询为主
   - 大量聚合操作

2. **实时数据分析**：使用行存储
   - 需要实时更新
   - 点查询为主
   - 事务处理

3. **混合分析**：使用混合存储
   - 热数据行存储（最近数据）
   - 冷数据列存储（历史数据）

4. **分析查询优化**：
   - 只查询需要的列
   - 使用聚合函数
   - 避免SELECT *
   - 使用WHERE过滤

---

## 七、实践案例

### 7.1 销售数据分析

**销售数据分析案例**：

```sql
-- 销售数据分析完整查询
WITH sales_analysis AS (
    SELECT
        DATE_TRUNC('month', sale_date) AS month,
        category,
        region,
        COUNT(*) AS order_count,
        COUNT(DISTINCT customer_id) AS customer_count,
        SUM(amount) AS total_amount,
        AVG(amount) AS avg_amount,
        SUM(profit) AS total_profit,
        AVG(profit) AS avg_profit
    FROM sales
    WHERE sale_date >= '2024-01-01'
    GROUP BY DATE_TRUNC('month', sale_date), category, region
),
ranked_sales AS (
    SELECT
        *,
        RANK() OVER (
            PARTITION BY month
            ORDER BY total_amount DESC
        ) AS rank_by_amount,
        RANK() OVER (
            PARTITION BY month, category
            ORDER BY total_amount DESC
        ) AS rank_in_category
    FROM sales_analysis
)
SELECT
    month,
    category,
    region,
    order_count,
    customer_count,
    total_amount,
    avg_amount,
    total_profit,
    avg_profit,
    rank_by_amount,
    rank_in_category,
    -- 市场份额
    total_amount * 100.0 / SUM(total_amount) OVER (PARTITION BY month) AS market_share
FROM ranked_sales
ORDER BY month, total_amount DESC;
```

### 7.2 用户行为分析

**用户行为分析案例**：

```sql
-- 用户行为路径分析
WITH user_events AS (
    SELECT
        user_id,
        event_time,
        event_type,
        LAG(event_type) OVER (
            PARTITION BY user_id
            ORDER BY event_time
        ) AS prev_event_type,
        LEAD(event_type) OVER (
            PARTITION BY user_id
            ORDER BY event_time
        ) AS next_event_type
    FROM user_events
    WHERE event_time >= '2024-01-01'
),
event_transitions AS (
    SELECT
        prev_event_type,
        event_type AS current_event_type,
        next_event_type,
        COUNT(*) AS transition_count
    FROM user_events
    WHERE prev_event_type IS NOT NULL
    GROUP BY prev_event_type, event_type, next_event_type
)
SELECT
    prev_event_type,
    current_event_type,
    next_event_type,
    transition_count,
    transition_count * 100.0 / SUM(transition_count) OVER (
        PARTITION BY prev_event_type, current_event_type
    ) AS transition_rate
FROM event_transitions
ORDER BY transition_count DESC;
```

### 7.3 运营数据分析

**运营数据分析案例**：

```sql
-- 运营KPI分析
SELECT
    DATE_TRUNC('day', event_time) AS date,
    -- DAU
    COUNT(DISTINCT user_id) AS dau,
    -- 新增用户
    COUNT(DISTINCT user_id) FILTER (
        WHERE first_event_time = DATE_TRUNC('day', event_time)
    ) AS new_users,
    -- 活跃用户
    COUNT(DISTINCT user_id) FILTER (
        WHERE event_count >= 5
    ) AS active_users,
    -- 留存率（次日）
    COUNT(DISTINCT user_id) FILTER (
        WHERE DATE_TRUNC('day', event_time) = DATE_TRUNC('day', first_event_time) + INTERVAL '1 day'
    ) * 100.0 / NULLIF(
        COUNT(DISTINCT user_id) FILTER (
            WHERE DATE_TRUNC('day', event_time) = DATE_TRUNC('day', first_event_time)
        ),
        0
    ) AS day1_retention,
    -- 平均会话时长
    AVG(session_duration) AS avg_session_duration,
    -- 平均事件数
    AVG(event_count) AS avg_event_count
FROM (
    SELECT
        user_id,
        event_time,
        first_event_time,
        session_duration,
        COUNT(*) OVER (PARTITION BY user_id, DATE_TRUNC('day', event_time)) AS event_count
    FROM user_events
    WHERE event_time >= '2024-01-01'
) t
GROUP BY DATE_TRUNC('day', event_time)
ORDER BY date;
```

---

## 八、PostgreSQL 18新特性

### 8.1 并行查询增强

**PostgreSQL 18并行查询增强**：

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;

-- 并行聚合查询
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total,
    AVG(amount) AS avg
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY category;
-- 自动使用并行聚合，性能提升30-40%
```

### 8.2 异步I/O优化

**异步I/O优化分析查询**：

```sql
-- PostgreSQL 18自动使用异步I/O
-- 在postgresql.conf中配置：
-- io_uring = on
-- max_io_concurrency = 10

-- 分析查询自动受益于异步I/O
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY category;
-- I/O性能提升2-3倍
```

### 8.3 虚拟生成列

**使用虚拟生成列优化分析查询**：

```sql
-- 使用虚拟生成列自动计算分析指标
CREATE TABLE sales_enhanced (
    id BIGSERIAL PRIMARY KEY,
    sale_date DATE NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    quantity INTEGER NOT NULL,
    -- 虚拟生成列：自动计算单价
    unit_price NUMERIC(10,2) GENERATED ALWAYS AS (
        amount / NULLIF(quantity, 0)
    ) STORED,
    -- 虚拟生成列：自动计算是否为大单
    is_large_order BOOLEAN GENERATED ALWAYS AS (
        amount > 1000
    ) STORED
);

-- 可以索引虚拟生成列
CREATE INDEX idx_sales_unit_price ON sales_enhanced(unit_price);
CREATE INDEX idx_sales_large_order ON sales_enhanced(is_large_order);
```

---

## 九、最佳实践

1. **查询优化**：
   - 使用物化视图缓存常用分析结果
   - 为分析查询创建合适的索引
   - 使用分区表优化时间序列分析

2. **数据质量**：
   - 在分析前检查数据质量
   - 处理缺失值和异常值
   - 验证数据一致性

3. **性能优化**：
   - 使用并行查询处理大数据集
   - 使用物化视图减少重复计算
   - 合理使用窗口函数

4. **结果解释**：
   - 清晰标注分析结果
   - 提供上下文信息
   - 验证分析结果的合理性

---

## 十、参考资源

### 10.1 官方文档

- [PostgreSQL窗口函数](https://www.postgresql.org/docs/current/tutorial-window.html)
- [PostgreSQL聚合函数](https://www.postgresql.org/docs/current/functions-aggregate.html)
- [PostgreSQL统计函数](https://www.postgresql.org/docs/current/functions-statistics.html)

### 10.2 相关文档

- [数据科学实践](../应用架构/07.06-数据科学实践.md) - 数据科学完整指南
- [数据仓库设计指南](./09.03-数据仓库设计指南.md) - 数据仓库建模、列存储优化 🆕
- [数据建模完整指南](./09.02-数据建模完整指南.md) - 数据建模理论基础、存储架构选择 🆕
- [存储管理与数据持久化](../../../04-存储与恢复/01.06-存储管理与数据持久化.md) - 列存储架构分析、列压缩技术详解 🆕
- [扩展系统](../../../06-扩展系统/README.md) - 列存储扩展（cstore_fdw）🆕
- [索引结构与优化](../../../02-查询与优化/02.02-索引结构/02.02-索引结构与优化.md) - 列存储索引优化 🆕
- [查询优化器原理](../../../02-查询与优化/02.01-查询优化器/02.01-查询优化器原理.md) - 查询优化理论基础
- [执行计划与性能调优](../../../02-查询与优化/02.03-执行计划/02.04-执行计划与性能调优.md) - 性能调优实践、列存储查询优化 🆕

### 10.3 外部资源

- [PostgreSQL数据分析最佳实践](https://www.postgresql.org/docs/current/)
- [SQL数据分析教程](https://www.postgresql.org/docs/current/)
- [统计分析扩展](https://www.postgresql.org/docs/current/)

---

---

## 十一、交叉引用

### 相关文档

- ⭐⭐⭐ [数据建模完整指南](./09.02-数据建模完整指南.md) - 数据建模理论基础、存储架构选择 🆕
- ⭐⭐⭐ [数据仓库设计指南](./09.03-数据仓库设计指南.md) - 数据仓库分析、列存储优化 🆕
- ⭐⭐ [ETL流程完整指南](./09.04-ETL流程完整指南.md) - ETL流程中的数据转换
- ⭐⭐ [数据质量管理指南](./09.05-数据质量管理指南.md) - 数据质量保证
- ⭐⭐ [数据科学实践](../应用架构/07.06-数据科学实践.md) - 数据科学完整指南
- ⭐⭐⭐ [存储管理与数据持久化](../../../04-存储与恢复/01.06-存储管理与数据持久化.md) - 列存储架构分析、列压缩技术详解 🆕
- ⭐⭐ [扩展系统](../../../06-扩展系统/README.md) - 列存储扩展（cstore_fdw）🆕
- ⭐⭐ [索引结构与优化](../../../02-查询与优化/02.02-索引结构/02.02-索引结构与优化.md) - 列存储索引优化 🆕
- ⭐⭐ [执行计划与性能调优](../../../02-查询与优化/02.03-执行计划/02.04-执行计划与性能调优.md) - 性能调优实践、列存储查询优化 🆕
- ⭐ [查询优化器原理](../../../02-查询与优化/02.01-查询优化器/02.01-查询优化器原理.md) - 查询优化理论基础

### 外部资源

- [PostgreSQL窗口函数文档](https://www.postgresql.org/docs/current/tutorial-window.html)
- [PostgreSQL聚合函数文档](https://www.postgresql.org/docs/current/functions-aggregate.html)
- [PostgreSQL统计函数文档](https://www.postgresql.org/docs/current/functions-statistics.html)

---

**文档版本**: v1.1
**最后更新**: 2025-11-22
**PostgreSQL版本**: 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
**维护者**: Documentation Team
