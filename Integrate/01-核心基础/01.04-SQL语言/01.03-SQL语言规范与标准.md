---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL/01-æ ¸å¿ƒè¯¾ç¨‹/01.03-SQLè¯­è¨€è§„èŒƒä¸æ ‡å‡†.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# PostgreSQL SQLè¯­è¨€è§„èŒƒä¸æ ‡å‡†å®Œæ•´æŒ‡å—

> **ç‰ˆæœ¬**: v3.1
> **æœ€åæ›´æ–°**: 2025-11-22
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­
> **åº”ç”¨åœºæ™¯**: SQLè¯­è¨€å­¦ä¹ ã€æ•°æ®åº“å¼€å‘ã€æŸ¥è¯¢ä¼˜åŒ–ã€æ ‡å‡†è§„èŒƒ
> ğŸ†• **PostgreSQL 18 SQLæ”¹è¿›**: æŸ¥è¯¢æ€§èƒ½æå‡30-40%ã€JSONBå¢å¼º15-20%ã€MERGEè¯­å¥ä¼˜åŒ–20%ã€è™šæ‹Ÿç”Ÿæˆåˆ—æ”¯æŒ

---

## ğŸ“‘ ç›®å½•

- [PostgreSQL SQLè¯­è¨€è§„èŒƒä¸æ ‡å‡†å®Œæ•´æŒ‡å—](#postgresql-sqlè¯­è¨€è§„èŒƒä¸æ ‡å‡†å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ğŸ“Š æ€ç»´å¯¼å›¾](#-æ€ç»´å¯¼å›¾)
  - [ä¸€ã€å®šä¹‰ä¸å½¢å¼åŒ–](#ä¸€å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 ç†è®ºåŸºç¡€](#13-ç†è®ºåŸºç¡€)
      - [1.3.1 å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»](#131-å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»)
      - [1.3.2 SQLå®Œå¤‡æ€§å®šç†](#132-sqlå®Œå¤‡æ€§å®šç†)
  - [ä¸‰ã€æ ¸å¿ƒè¯­æ³•è§„èŒƒ](#ä¸‰æ ¸å¿ƒè¯­æ³•è§„èŒƒ)
    - [3.1 æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰](#31-æ•°æ®å®šä¹‰è¯­è¨€ddl)
      - [2.1.1 è¡¨å®šä¹‰](#211-è¡¨å®šä¹‰)
      - [2.1.2 è§†å›¾å®šä¹‰](#212-è§†å›¾å®šä¹‰)
    - [3.2 æ•°æ®æ“ä½œè¯­è¨€ï¼ˆDMLï¼‰](#32-æ•°æ®æ“ä½œè¯­è¨€dml)
      - [2.2.1 æ’å…¥æ“ä½œ](#221-æ’å…¥æ“ä½œ)
      - [2.2.2 æ›´æ–°æ“ä½œ](#222-æ›´æ–°æ“ä½œ)
      - [2.2.3 åˆ é™¤æ“ä½œ](#223-åˆ é™¤æ“ä½œ)
      - [2.2.4 MERGEè¯­å¥ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰ğŸ†•](#224-mergeè¯­å¥postgresql-18ä¼˜åŒ–)
    - [3.3 æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆDQLï¼‰](#33-æ•°æ®æŸ¥è¯¢è¯­è¨€dql)
      - [2.3.1 åŸºæœ¬æŸ¥è¯¢](#231-åŸºæœ¬æŸ¥è¯¢)
      - [2.3.2 è¿æ¥æŸ¥è¯¢](#232-è¿æ¥æŸ¥è¯¢)
      - [2.3.3 å­æŸ¥è¯¢](#233-å­æŸ¥è¯¢)
    - [3.4 é«˜çº§æŸ¥è¯¢ç‰¹æ€§](#34-é«˜çº§æŸ¥è¯¢ç‰¹æ€§)
      - [2.4.1 çª—å£å‡½æ•°](#241-çª—å£å‡½æ•°)
      - [2.4.2 é€’å½’æŸ¥è¯¢](#242-é€’å½’æŸ¥è¯¢)
      - [2.4.3 å…¬å…±è¡¨è¡¨è¾¾å¼ï¼ˆCTEï¼‰](#243-å…¬å…±è¡¨è¡¨è¾¾å¼cte)
      - [2.4.4 çª—å£å‡½æ•°æ·±å…¥åº”ç”¨](#244-çª—å£å‡½æ•°æ·±å…¥åº”ç”¨)
      - [2.4.5 é€’å½’æŸ¥è¯¢æ·±å…¥åº”ç”¨](#245-é€’å½’æŸ¥è¯¢æ·±å…¥åº”ç”¨)
      - [2.4.6 CTEæ·±å…¥åº”ç”¨](#246-cteæ·±å…¥åº”ç”¨)
      - [2.4.7 é«˜çº§SQLç‰¹æ€§ç»„åˆåº”ç”¨](#247-é«˜çº§sqlç‰¹æ€§ç»„åˆåº”ç”¨)
    - [3.5 äº‹åŠ¡æ§åˆ¶è¯­è¨€ï¼ˆTCLï¼‰](#35-äº‹åŠ¡æ§åˆ¶è¯­è¨€tcl)
      - [2.5.1 äº‹åŠ¡ç®¡ç†](#251-äº‹åŠ¡ç®¡ç†)
    - [3.6 æ•°æ®æ§åˆ¶è¯­è¨€ï¼ˆDCLï¼‰](#36-æ•°æ®æ§åˆ¶è¯­è¨€dcl)
      - [2.6.1 æƒé™ç®¡ç†](#261-æƒé™ç®¡ç†)
  - [å››ã€PostgreSQLæ‰©å±•ç‰¹æ€§](#å››postgresqlæ‰©å±•ç‰¹æ€§)
    - [4.1 æ•°æ®ç±»å‹æ‰©å±•](#41-æ•°æ®ç±»å‹æ‰©å±•)
    - [4.2 å‡½æ•°å’Œæ“ä½œç¬¦](#42-å‡½æ•°å’Œæ“ä½œç¬¦)
    - [4.3 ç´¢å¼•ç±»å‹](#43-ç´¢å¼•ç±»å‹)
  - [äº”ã€æ€§èƒ½ä¼˜åŒ–](#äº”æ€§èƒ½ä¼˜åŒ–)
    - [5.1 æŸ¥è¯¢ä¼˜åŒ–](#51-æŸ¥è¯¢ä¼˜åŒ–)
    - [5.2 ç´¢å¼•ä¼˜åŒ–](#52-ç´¢å¼•ä¼˜åŒ–)
  - [å…­ã€ç›¸å…³æ¦‚å¿µ](#å…­ç›¸å…³æ¦‚å¿µ)
    - [6.1 ä¸Šä½æ¦‚å¿µ](#61-ä¸Šä½æ¦‚å¿µ)
    - [6.2 ä¸‹ä½æ¦‚å¿µ](#62-ä¸‹ä½æ¦‚å¿µ)
    - [6.3 å¹³è¡Œæ¦‚å¿µ](#63-å¹³è¡Œæ¦‚å¿µ)
  - [ä¸ƒã€å‚è€ƒèµ„æº](#ä¸ƒå‚è€ƒèµ„æº)
    - [7.1 ç›¸å…³æ–‡æ¡£](#71-ç›¸å…³æ–‡æ¡£)
    - [7.2 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹](#72-å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹)
    - [7.3 å‚è€ƒæ–‡çŒ®](#73-å‚è€ƒæ–‡çŒ®)
    - [7.4 Wikidataå¯¹é½](#74-wikidataå¯¹é½)
  - [å…«ã€äº¤å‰å¼•ç”¨](#å…«äº¤å‰å¼•ç”¨)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ğŸ“Š æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((SQLè¯­è¨€))
    è¯­è¨€ç±»å‹
      DDL
      DML
      DQL
      DCL
      TCL
    æ ¸å¿ƒè¯­æ³•
      è¡¨å®šä¹‰
      æ•°æ®æ“ä½œ
      æŸ¥è¯¢è¯­å¥
      é«˜çº§ç‰¹æ€§
    PostgreSQLæ‰©å±•
      æ•°æ®ç±»å‹
      å‡½æ•°æ“ä½œç¬¦
      ç´¢å¼•ç±»å‹
    æ€§èƒ½ä¼˜åŒ–
      æŸ¥è¯¢ä¼˜åŒ–
      ç´¢å¼•ä¼˜åŒ–
    æ ‡å‡†è§„èŒƒ
      SQLæ ‡å‡†
      ç‰ˆæœ¬å¯¹æ¯”
      å…¼å®¹æ€§
```

---

## ä¸€ã€å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: SQLï¼ˆStructured Query Languageï¼‰æ˜¯ä¸€ç§å£°æ˜å¼çš„å…³ç³»æ•°æ®åº“æŸ¥è¯¢è¯­è¨€ï¼Œæ”¯æŒæ•°æ®å®šä¹‰ã€æ“ä½œã€æŸ¥è¯¢å’Œæ§åˆ¶åŠŸèƒ½ï¼Œæ˜¯å…³ç³»æ•°æ®åº“çš„æ ‡å‡†è¯­è¨€ã€‚PostgreSQLå®ç°äº†å®Œæ•´çš„SQL:2023æ ‡å‡†ï¼Œå¹¶æä¾›äº†ä¸°å¯Œçš„æ‰©å±•åŠŸèƒ½ã€‚

**English Definition**: SQL (Structured Query Language) is a declarative relational database query language that supports data definition, manipulation, query, and control functions, serving as the standard language for relational databases. PostgreSQL implements the complete SQL:2023 standard and provides rich extension capabilities.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\sql}{\mathcal{SQL}}
\newcommand{\rel}{\mathcal{R}}
\newcommand{\attr}{\mathcal{A}}
\newcommand{\tuple}{\mathcal{T}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\result}{\mathcal{Result}}
\newcommand{\db}{\mathcal{D}}
\newcommand{\schema}{\mathcal{S}}

% SQLè¯­è¨€çš„å½¢å¼åŒ–å®šä¹‰
\sql = (DDL, DML, DQL, DCL, TCL)

å…¶ä¸­ï¼š
DDL = \{CREATE, ALTER, DROP, TRUNCATE\} \text{ æ•°æ®å®šä¹‰è¯­è¨€}
DML = \{INSERT, UPDATE, DELETE, MERGE\} \text{ æ•°æ®æ“ä½œè¯­è¨€}
DQL = \{SELECT\} \text{ æ•°æ®æŸ¥è¯¢è¯­è¨€}
DCL = \{GRANT, REVOKE, DENY\} \text{ æ•°æ®æ§åˆ¶è¯­è¨€}
TCL = \{BEGIN, COMMIT, ROLLBACK, SAVEPOINT\} \text{ äº‹åŠ¡æ§åˆ¶è¯­è¨€}
```

### 1.3 ç†è®ºåŸºç¡€

#### 1.3.1 å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»

```latex
\begin{theorem}[SQLä¸å…³ç³»ä»£æ•°ç­‰ä»·æ€§]
SQLè¯­è¨€åœ¨è¡¨è¾¾èƒ½åŠ›ä¸Šç­‰ä»·äºå…³ç³»ä»£æ•°ï¼Œå³ï¼š
\forall q \in \query, \exists \sigma, \pi, \bowtie, \cup, \cap, - \text{ ä½¿å¾— }
\result(q) = f(\sigma, \pi, \bowtie, \cup, \cap, -)
\end{theorem}

\begin{proof}
1. SELECTå¯¹åº”æŠ•å½±æ“ä½œ \pi
2. WHEREå¯¹åº”é€‰æ‹©æ“ä½œ \sigma
3. JOINå¯¹åº”è¿æ¥æ“ä½œ \bowtie
4. UNIONå¯¹åº”å¹¶é›†æ“ä½œ \cup
5. INTERSECTå¯¹åº”äº¤é›†æ“ä½œ \cap
6. EXCEPTå¯¹åº”å·®é›†æ“ä½œ -

å› æ­¤ï¼ŒSQLçš„æ¯ä¸ªæ“ä½œéƒ½å¯ä»¥ç”¨å…³ç³»ä»£æ•°è¡¨ç¤ºï¼Œåä¹‹äº¦ç„¶ã€‚
\end{proof}
```

#### 1.3.2 SQLå®Œå¤‡æ€§å®šç†

```latex
\begin{theorem}[SQLå®Œå¤‡æ€§]
SQLè¯­è¨€æ˜¯å…³ç³»å®Œå¤‡çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
1. æ”¯æŒå…³ç³»ä»£æ•°çš„æ‰€æœ‰åŸºæœ¬æ“ä½œ
2. æ”¯æŒé€’å½’æŸ¥è¯¢ï¼ˆWITH RECURSIVEï¼‰
3. æ”¯æŒèšåˆå‡½æ•°å’Œåˆ†ç»„æ“ä½œ
4. æ”¯æŒå­æŸ¥è¯¢å’ŒåµŒå¥—æŸ¥è¯¢
5. æ”¯æŒçª—å£å‡½æ•°å’ŒOLAPåŠŸèƒ½
\end{theorem}

\begin{proof}
åŸºäºCoddå®šç†ï¼Œå…³ç³»å®Œå¤‡æ€§è¦æ±‚ï¼š
- èƒ½å¤Ÿè¡¨è¾¾å…³ç³»ä»£æ•°çš„æ‰€æœ‰æ“ä½œ
- èƒ½å¤Ÿå¤„ç†é€’å½’å…³ç³»
- èƒ½å¤Ÿè¿›è¡Œå¤æ‚çš„æ•°æ®æ“ä½œ
- èƒ½å¤Ÿæ”¯æŒåˆ†ææŸ¥è¯¢

PostgreSQLçš„SQLå®ç°æ»¡è¶³ä»¥ä¸Šæ‰€æœ‰æ¡ä»¶ï¼Œå› æ­¤æ˜¯å…³ç³»å®Œå¤‡çš„ã€‚
\end{proof}
```

## ä¸‰ã€æ ¸å¿ƒè¯­æ³•è§„èŒƒ

### 3.1 æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰

#### 2.1.1 è¡¨å®šä¹‰

```sql
-- æ ‡å‡†è¡¨å®šä¹‰ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE NOTICE 'è¡¨ employees å·²å­˜åœ¨';
        ELSE
            CREATE TABLE employees (
                emp_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                name VARCHAR(50) NOT NULL,
                email VARCHAR(100) UNIQUE,
                dept_id INTEGER REFERENCES departments(dept_id),
                salary DECIMAL(10,2) CHECK (salary > 0),
                hire_date DATE DEFAULT CURRENT_DATE,
                manager_id INTEGER REFERENCES employees(emp_id),
                CONSTRAINT emp_salary_check CHECK (salary >= 0 AND salary <= 1000000)
            );
            RAISE NOTICE 'è¡¨ employees åˆ›å»ºæˆåŠŸ';
        END IF;

        -- åˆ›å»ºç´¢å¼•ï¼ˆå¦‚æœè¡¨å­˜åœ¨ï¼‰
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept') THEN
                    CREATE INDEX idx_emp_dept ON employees(dept_id);
                    RAISE NOTICE 'ç´¢å¼• idx_emp_dept åˆ›å»ºæˆåŠŸ';
                END IF;

                IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_email') THEN
                    CREATE UNIQUE INDEX idx_emp_email ON employees(email);
                    RAISE NOTICE 'ç´¢å¼• idx_emp_email åˆ›å»ºæˆåŠŸ';
                END IF;

                IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_salary') THEN
                    CREATE INDEX idx_emp_salary ON employees(salary) WHERE salary > 50000;
                    RAISE NOTICE 'ç´¢å¼• idx_emp_salary åˆ›å»ºæˆåŠŸ';
                END IF;
            EXCEPTION
                WHEN duplicate_table THEN
                    RAISE WARNING 'éƒ¨åˆ†ç´¢å¼•å·²å­˜åœ¨';
                WHEN OTHERS THEN
                    RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
            END;
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ employees å·²å­˜åœ¨';
        WHEN undefined_table THEN
            RAISE WARNING 'å¼•ç”¨çš„è¡¨ departments ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 2.1.2 è§†å›¾å®šä¹‰

```sql
-- ç®€å•è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'emp_summary') THEN
            RAISE NOTICE 'è§†å›¾ emp_summary å·²å­˜åœ¨';
        ELSE
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºè§†å›¾ emp_summary';
                RETURN;
            END IF;

            CREATE VIEW emp_summary AS
            SELECT
                dept_id,
                COUNT(*) as emp_count,
                AVG(salary) as avg_salary,
                MAX(salary) as max_salary
            FROM employees
            GROUP BY dept_id;
            RAISE NOTICE 'è§†å›¾ emp_summary åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE WARNING 'è§†å›¾ emp_summary å·²å­˜åœ¨';
        WHEN undefined_table THEN
            RAISE WARNING 'åŸºç¡€è¡¨ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè§†å›¾å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¯æ›´æ–°è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'emp_public') THEN
            RAISE NOTICE 'è§†å›¾ emp_public å·²å­˜åœ¨';
        ELSE
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºè§†å›¾ emp_public';
                RETURN;
            END IF;

            -- æ³¨æ„ï¼šå‡è®¾employeesè¡¨æœ‰activeåˆ—
            CREATE VIEW emp_public AS
            SELECT emp_id, name, dept_id
            FROM employees
            WHERE active = true;
            RAISE NOTICE 'è§†å›¾ emp_public åˆ›å»ºæˆåŠŸï¼ˆå¯æ›´æ–°è§†å›¾ï¼‰';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE WARNING 'è§†å›¾ emp_public å·²å­˜åœ¨';
        WHEN undefined_column THEN
            RAISE WARNING 'è¡¨ employees ç¼ºå°‘ active åˆ—';
        WHEN undefined_table THEN
            RAISE WARNING 'åŸºç¡€è¡¨ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè§†å›¾å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç‰©åŒ–è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'emp_stats') THEN
            RAISE NOTICE 'ç‰©åŒ–è§†å›¾ emp_stats å·²å­˜åœ¨';
        ELSE
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç‰©åŒ–è§†å›¾ emp_stats';
                RETURN;
            END IF;

            CREATE MATERIALIZED VIEW emp_stats AS
            SELECT
                dept_id,
                COUNT(*) as emp_count,
                AVG(salary) as avg_salary
            FROM employees
            GROUP BY dept_id;
            RAISE NOTICE 'ç‰©åŒ–è§†å›¾ emp_stats åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'ç‰©åŒ–è§†å›¾ emp_stats å·²å­˜åœ¨';
        WHEN undefined_table THEN
            RAISE WARNING 'åŸºç¡€è¡¨ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºç‰©åŒ–è§†å›¾å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 3.2 æ•°æ®æ“ä½œè¯­è¨€ï¼ˆDMLï¼‰

#### 2.2.1 æ’å…¥æ“ä½œ

```sql
-- å•è¡Œæ’å…¥ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ’å…¥æ“ä½œ';
            RETURN;
        END IF;

        INSERT INTO employees (emp_id, name, dept_id, salary)
        VALUES (1001, 'å¼ ä¸‰', 1, 50000);
        RAISE NOTICE 'å•è¡Œæ’å…¥æˆåŠŸ';
    EXCEPTION
        WHEN unique_violation THEN
            RAISE WARNING 'è¿åå”¯ä¸€çº¦æŸï¼Œemp_id 1001 å¯èƒ½å·²å­˜åœ¨';
        WHEN foreign_key_violation THEN
            RAISE WARNING 'è¿åå¤–é”®çº¦æŸï¼Œdept_id 1 å¯èƒ½ä¸å­˜åœ¨';
        WHEN check_violation THEN
            RAISE WARNING 'è¿åæ£€æŸ¥çº¦æŸï¼Œsalary å¯èƒ½ä¸ç¬¦åˆè¦æ±‚';
        WHEN OTHERS THEN
            RAISE WARNING 'æ’å…¥å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¤šè¡Œæ’å…¥ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ’å…¥æ“ä½œ';
            RETURN;
        END IF;

        INSERT INTO employees (emp_id, name, dept_id, salary) VALUES
            (1002, 'æå››', 1, 55000),
            (1003, 'ç‹äº”', 2, 60000);
        RAISE NOTICE 'å¤šè¡Œæ’å…¥æˆåŠŸ';
    EXCEPTION
        WHEN unique_violation THEN
            RAISE WARNING 'è¿åå”¯ä¸€çº¦æŸï¼Œéƒ¨åˆ†emp_idå¯èƒ½å·²å­˜åœ¨';
        WHEN foreign_key_violation THEN
            RAISE WARNING 'è¿åå¤–é”®çº¦æŸï¼Œéƒ¨åˆ†dept_idå¯èƒ½ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'æ’å…¥å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨RETURNINGå­å¥ï¼ˆPostgreSQLç‰¹æ€§ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    inserted_id INTEGER;
    inserted_name VARCHAR(50);
    inserted_salary DECIMAL(10,2);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ’å…¥æ“ä½œ';
            RETURN;
        END IF;

        INSERT INTO employees (name, dept_id, salary)
        VALUES ('æ–°å‘˜å·¥', 1, 45000)
        RETURNING emp_id, name, salary INTO inserted_id, inserted_name, inserted_salary;

        RAISE NOTICE 'æ’å…¥æˆåŠŸ: emp_id=%, name=%, salary=%', inserted_id, inserted_name, inserted_salary;
    EXCEPTION
        WHEN foreign_key_violation THEN
            RAISE WARNING 'è¿åå¤–é”®çº¦æŸï¼Œdept_id 1 å¯èƒ½ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'æ’å…¥å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä»æŸ¥è¯¢ç»“æœæ’å…¥ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    inserted_count INT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ’å…¥æ“ä½œ';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'temp_employees') THEN
            RAISE WARNING 'è¡¨ temp_employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ’å…¥æ“ä½œ';
            RETURN;
        END IF;

        INSERT INTO employees (name, dept_id, salary)
        SELECT name, dept_id, salary * 1.1
        FROM temp_employees
        WHERE salary < 50000;

        GET DIAGNOSTICS inserted_count = ROW_COUNT;
        RAISE NOTICE 'ä»æŸ¥è¯¢ç»“æœæ’å…¥æˆåŠŸï¼Œæ’å…¥äº† % è¡Œ', inserted_count;
    EXCEPTION
        WHEN foreign_key_violation THEN
            RAISE WARNING 'è¿åå¤–é”®çº¦æŸï¼Œéƒ¨åˆ†dept_idå¯èƒ½ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'æ’å…¥å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 2.2.2 æ›´æ–°æ“ä½œ

```sql
-- ç®€å•æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    updated_count INT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ›´æ–°æ“ä½œ';
            RETURN;
        END IF;

        UPDATE employees
        SET salary = salary * 1.05
        WHERE dept_id = 1;

        GET DIAGNOSTICS updated_count = ROW_COUNT;
        RAISE NOTICE 'æ›´æ–°æˆåŠŸï¼Œæ›´æ–°äº† % è¡Œ', updated_count;
    EXCEPTION
        WHEN check_violation THEN
            RAISE WARNING 'è¿åæ£€æŸ¥çº¦æŸï¼Œæ›´æ–°åçš„salaryå¯èƒ½ä¸ç¬¦åˆè¦æ±‚';
        WHEN OTHERS THEN
            RAISE WARNING 'æ›´æ–°å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
UPDATE employees
SET salary = salary * 1.05
WHERE dept_id = 1;

-- ä½¿ç”¨å­æŸ¥è¯¢æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    updated_count INT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ›´æ–°æ“ä½œ';
            RETURN;
        END IF;

        UPDATE employees
        SET salary = (
            SELECT AVG(salary)
            FROM employees e2
            WHERE e2.dept_id = employees.dept_id
        )
        WHERE salary < (
            SELECT AVG(salary)
            FROM employees e3
            WHERE e3.dept_id = employees.dept_id
        );

        GET DIAGNOSTICS updated_count = ROW_COUNT;
        RAISE NOTICE 'ä½¿ç”¨å­æŸ¥è¯¢æ›´æ–°æˆåŠŸï¼Œæ›´æ–°äº† % è¡Œ', updated_count;
    EXCEPTION
        WHEN check_violation THEN
            RAISE WARNING 'è¿åæ£€æŸ¥çº¦æŸï¼Œæ›´æ–°åçš„salaryå¯èƒ½ä¸ç¬¦åˆè¦æ±‚';
        WHEN OTHERS THEN
            RAISE WARNING 'æ›´æ–°å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
UPDATE employees
SET salary = (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.dept_id = employees.dept_id
)
WHERE salary < (
    SELECT AVG(salary)
    FROM employees e3
    WHERE e3.dept_id = employees.dept_id
);

-- ä½¿ç”¨RETURNINGå­å¥ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    updated_record RECORD;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ›´æ–°æ“ä½œ';
            RETURN;
        END IF;

        FOR updated_record IN
            UPDATE employees
            SET salary = salary * 1.1
            WHERE dept_id = 2
            RETURNING emp_id, name, salary
        LOOP
            RAISE NOTICE 'æ›´æ–°: emp_id=%, name=%, salary=%',
                updated_record.emp_id, updated_record.name, updated_record.salary;
        END LOOP;
    EXCEPTION
        WHEN check_violation THEN
            RAISE WARNING 'è¿åæ£€æŸ¥çº¦æŸï¼Œæ›´æ–°åçš„salaryå¯èƒ½ä¸ç¬¦åˆè¦æ±‚';
        WHEN OTHERS THEN
            RAISE WARNING 'æ›´æ–°å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 2.2.3 åˆ é™¤æ“ä½œ

```sql
-- ç®€å•åˆ é™¤ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    deleted_count INT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œåˆ é™¤æ“ä½œ';
            RETURN;
        END IF;

        DELETE FROM employees
        WHERE emp_id = 1001;

        GET DIAGNOSTICS deleted_count = ROW_COUNT;
        IF deleted_count > 0 THEN
            RAISE NOTICE 'åˆ é™¤æˆåŠŸï¼Œåˆ é™¤äº† % è¡Œ', deleted_count;
        ELSE
            RAISE NOTICE 'æœªæ‰¾åˆ°åŒ¹é…çš„è®°å½•ï¼ˆemp_id = 1001ï¼‰';
        END IF;
    EXCEPTION
        WHEN foreign_key_violation THEN
            RAISE WARNING 'è¿åå¤–é”®çº¦æŸï¼Œå¯èƒ½å­˜åœ¨å…¶ä»–è¡¨å¼•ç”¨æ­¤è®°å½•';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ é™¤å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨å­æŸ¥è¯¢åˆ é™¤ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    deleted_count INT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œåˆ é™¤æ“ä½œ';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'departments') THEN
            RAISE WARNING 'è¡¨ departments ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œåˆ é™¤æ“ä½œ';
            RETURN;
        END IF;

        DELETE FROM employees
        WHERE dept_id IN (
            SELECT dept_id
            FROM departments
            WHERE status = 'inactive'
        );

        GET DIAGNOSTICS deleted_count = ROW_COUNT;
        RAISE NOTICE 'ä½¿ç”¨å­æŸ¥è¯¢åˆ é™¤æˆåŠŸï¼Œåˆ é™¤äº† % è¡Œ', deleted_count;
    EXCEPTION
        WHEN foreign_key_violation THEN
            RAISE WARNING 'è¿åå¤–é”®çº¦æŸï¼Œå¯èƒ½å­˜åœ¨å…¶ä»–è¡¨å¼•ç”¨è¢«åˆ é™¤çš„è®°å½•';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ é™¤å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨RETURNINGå­å¥ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    deleted_record RECORD;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œåˆ é™¤æ“ä½œ';
            RETURN;
        END IF;

        FOR deleted_record IN
            DELETE FROM employees
            WHERE hire_date < '2020-01-01'
            RETURNING emp_id, name, hire_date
        LOOP
            RAISE NOTICE 'åˆ é™¤: emp_id=%, name=%, hire_date=%',
                deleted_record.emp_id, deleted_record.name, deleted_record.hire_date;
        END LOOP;
    EXCEPTION
        WHEN foreign_key_violation THEN
            RAISE WARNING 'è¿åå¤–é”®çº¦æŸï¼Œå¯èƒ½å­˜åœ¨å…¶ä»–è¡¨å¼•ç”¨è¢«åˆ é™¤çš„è®°å½•';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ é™¤å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 2.2.4 MERGEè¯­å¥ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰ğŸ†•

PostgreSQL 18å¯¹MERGEè¯­å¥è¿›è¡Œäº†æ€§èƒ½ä¼˜åŒ–ï¼Œæå‡çº¦20%çš„æ‰§è¡Œæ•ˆç‡ã€‚

**è¯­æ³•**:

```sql
-- MERGEè¯­å¥ï¼šæ ¹æ®æ¡ä»¶æ’å…¥æˆ–æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼ŒPostgreSQL 15+ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'target_table') THEN
            RAISE WARNING 'è¡¨ target_table ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒMERGEæ“ä½œ';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'source_table') THEN
            RAISE WARNING 'è¡¨ source_table ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒMERGEæ“ä½œ';
            RETURN;
        END IF;

        -- æ£€æŸ¥PostgreSQLç‰ˆæœ¬æ˜¯å¦æ”¯æŒMERGEï¼ˆPostgreSQL 15+ï¼‰
        IF (SELECT current_setting('server_version_num')::INT) < 150000 THEN
            RAISE WARNING 'MERGEè¯­å¥ä»…åœ¨PostgreSQL 15+ä¸­æ”¯æŒï¼Œå½“å‰ç‰ˆæœ¬å¯èƒ½ä¸æ”¯æŒ';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'MERGEæ“ä½œå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

MERGE INTO target_table AS t
USING source_table AS s
ON t.id = s.id
WHEN MATCHED THEN
    UPDATE SET
        name = s.name,
        updated_at = CURRENT_TIMESTAMP
WHEN NOT MATCHED THEN
    INSERT (id, name, created_at)
    VALUES (s.id, s.name, CURRENT_TIMESTAMP);
```

**PostgreSQL 18ä¼˜åŒ–**:

1. **æŸ¥è¯¢è®¡åˆ’ä¼˜åŒ–**: æ”¹è¿›MERGEè¯­å¥çš„æŸ¥è¯¢è®¡åˆ’ç”Ÿæˆï¼Œå‡å°‘ä¸å¿…è¦çš„æ‰«æ
2. **æ‰¹é‡å¤„ç†**: ä¼˜åŒ–æ‰¹é‡MERGEæ“ä½œçš„æ€§èƒ½
3. **ç´¢å¼•åˆ©ç”¨**: æ›´å¥½åœ°åˆ©ç”¨ç´¢å¼•åŠ é€ŸMERGEæ“ä½œ

**ä½¿ç”¨åœºæ™¯**:

1. **æ•°æ®åŒæ­¥**

   ```sql
   -- ä»å¤–éƒ¨æ•°æ®æºåŒæ­¥æ•°æ®
   MERGE INTO products AS p
   USING external_products AS e
   ON p.product_id = e.product_id
   WHEN MATCHED AND p.price != e.price THEN
       UPDATE SET price = e.price, updated_at = NOW()
   WHEN NOT MATCHED THEN
       INSERT (product_id, name, price, created_at)
       VALUES (e.product_id, e.name, e.price, NOW());
   ```

2. **å¢é‡æ›´æ–°**

   ```sql
   -- å¢é‡æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
   MERGE INTO user_stats AS us
   USING daily_stats AS ds
   ON us.user_id = ds.user_id AND us.stat_date = ds.stat_date
   WHEN MATCHED THEN
       UPDATE SET
           view_count = us.view_count + ds.view_count,
           last_updated = NOW()
   WHEN NOT MATCHED THEN
       INSERT (user_id, stat_date, view_count, last_updated)
       VALUES (ds.user_id, ds.stat_date, ds.view_count, NOW());
   ```

**æ€§èƒ½å¯¹æ¯”**:

- PostgreSQL 17: MERGEæ“ä½œè€—æ—¶åŸºå‡†
- PostgreSQL 18: MERGEæ“ä½œæ€§èƒ½æå‡çº¦20%
- ä¼˜åŒ–æ•ˆæœï¼šæ‰¹é‡æ“ä½œæ—¶æ›´æ˜æ˜¾ï¼Œå¯æå‡30-40%

### 3.3 æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆDQLï¼‰

#### 2.3.1 åŸºæœ¬æŸ¥è¯¢

```sql
-- åŸºæœ¬SELECTï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT emp_id, name, salary
FROM employees
WHERE dept_id = 1
ORDER BY salary DESC;

-- èšåˆæŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary
FROM employees
GROUP BY dept_id
HAVING COUNT(*) > 5
ORDER BY avg_salary DESC;
```

#### 2.3.2 è¿æ¥æŸ¥è¯¢

```sql
-- å†…è¿æ¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'departments') THEN
            RAISE WARNING 'è¡¨ employees æˆ– departments ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè¿æ¥æŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT e.name, d.dept_name, e.salary
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- å·¦å¤–è¿æ¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'departments') THEN
            RAISE WARNING 'è¡¨ employees æˆ– departments ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè¿æ¥æŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT e.name, d.dept_name, e.salary
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

-- è‡ªè¿æ¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè‡ªè¿æ¥æŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT e1.name as employee, e2.name as manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.emp_id;
```

#### 2.3.3 å­æŸ¥è¯¢

```sql
-- æ ‡é‡å­æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT name, salary,
    (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id) as dept_avg
FROM employees e1;

-- å­˜åœ¨æ€§æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'departments') THEN
            RAISE WARNING 'è¡¨ employees æˆ– departments ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT name, salary
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d
    WHERE d.dept_id = e.dept_id AND d.status = 'active'
);

-- INå­æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'departments') THEN
            RAISE WARNING 'è¡¨ employees æˆ– departments ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT name, salary
FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments WHERE budget > 1000000
);
```

### 3.4 é«˜çº§æŸ¥è¯¢ç‰¹æ€§

#### 2.4.1 çª—å£å‡½æ•°

```sql
-- æ’åå‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as salary_rank,
    RANK() OVER (ORDER BY salary DESC) as rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank
FROM employees;

-- åˆ†åŒºçª—å£å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    dept_id,
    salary,
    AVG(salary) OVER (PARTITION BY dept_id) as dept_avg,
    salary - AVG(salary) OVER (PARTITION BY dept_id) as diff_from_avg
FROM employees;
```

#### 2.4.2 é€’å½’æŸ¥è¯¢

```sql
-- é€’å½’CTEï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œé€’å½’æŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH RECURSIVE emp_hierarchy AS (
    -- åŸºç¡€æƒ…å†µï¼šé¡¶çº§ç®¡ç†è€…
    SELECT emp_id, name, manager_id, 1 as level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- é€’å½’æƒ…å†µï¼šä¸‹å±å‘˜å·¥
    SELECT e.emp_id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    INNER JOIN emp_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT * FROM emp_hierarchy ORDER BY level, name;
```

#### 2.4.3 å…¬å…±è¡¨è¡¨è¾¾å¼ï¼ˆCTEï¼‰

```sql
-- ç®€å•CTEï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒCTEæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH high_earners AS (
    SELECT emp_id, name, salary
    FROM employees
    WHERE salary > 80000
),
dept_stats AS (
    SELECT dept_id, COUNT(*) as emp_count
    FROM employees
    GROUP BY dept_id
)
SELECT h.name, h.salary, d.emp_count
FROM high_earners h
JOIN employees e ON h.emp_id = e.emp_id
JOIN dept_stats d ON e.dept_id = d.dept_id;
```

#### 2.4.4 çª—å£å‡½æ•°æ·±å…¥åº”ç”¨

**çª—å£å‡½æ•°ç±»å‹**:

1. **æ’åå‡½æ•°**: ROW_NUMBER(), RANK(), DENSE_RANK(), PERCENT_RANK(), CUME_DIST()
2. **èšåˆå‡½æ•°**: SUM(), AVG(), COUNT(), MAX(), MIN()
3. **å€¼å‡½æ•°**: LAG(), LEAD(), FIRST_VALUE(), LAST_VALUE(), NTH_VALUE()

**é«˜çº§çª—å£å‡½æ•°ç¤ºä¾‹**:

```sql
-- ç§»åŠ¨å¹³å‡ï¼ˆMoving Averageï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    order_date,
    amount,
    AVG(amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as moving_avg_3days
FROM orders
ORDER BY order_date;

-- ç´¯è®¡æ±‚å’Œï¼ˆCumulative Sumï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    order_date,
    amount,
    SUM(amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as cumulative_sum
FROM orders
ORDER BY order_date;

-- å‰åå€¼æ¯”è¾ƒï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    order_date,
    amount,
    LAG(amount, 1) OVER (ORDER BY order_date) as prev_amount,
    LEAD(amount, 1) OVER (ORDER BY order_date) as next_amount,
    amount - LAG(amount, 1) OVER (ORDER BY order_date) as day_over_day_change
FROM orders
ORDER BY order_date;

-- åˆ†åŒºæ’åï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    dept_id,
    name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as dept_rank,
    RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) as dept_rank_with_ties,
    PERCENT_RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) as salary_percentile
FROM employees;

-- çª—å£æ¡†æ¶ï¼ˆWindow Frameï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŸ¥è¯¢';
            RETURN;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥è¡¨å­˜åœ¨æ€§å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    order_date,
    amount,
    -- å½“å‰è¡ŒåŠå‰åå„2è¡Œ
    AVG(amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING
    ) as centered_avg,
    -- å½“å‰åˆ†åŒºçš„å‰10%
    AVG(amount) OVER (
        ORDER BY order_date
        RANGE BETWEEN UNBOUNDED PRECEDING AND '10 days' PRECEDING
    ) as trailing_avg_10days
FROM orders
ORDER BY order_date;
```

**çª—å£å‡½æ•°æ€§èƒ½ä¼˜åŒ–**:

```sql
-- ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–çª—å£å‡½æ•°
CREATE INDEX idx_orders_date ON orders(order_date);
CREATE INDEX idx_employees_dept_salary ON employees(dept_id, salary DESC);

-- é¿å…åœ¨çª—å£å‡½æ•°ä¸­ä½¿ç”¨å¤æ‚è¡¨è¾¾å¼
-- ä¸æ¨è
SELECT
    name,
    AVG(EXTRACT(YEAR FROM hire_date)) OVER (PARTITION BY dept_id) as avg_hire_year
FROM employees;

-- æ¨èï¼šå…ˆè®¡ç®—å†ä½¿ç”¨çª—å£å‡½æ•°
WITH emp_years AS (
    SELECT
        name,
        dept_id,
        EXTRACT(YEAR FROM hire_date) as hire_year
    FROM employees
)
SELECT
    name,
    AVG(hire_year) OVER (PARTITION BY dept_id) as avg_hire_year
FROM emp_years;
```

#### 2.4.5 é€’å½’æŸ¥è¯¢æ·±å…¥åº”ç”¨

**é€’å½’æŸ¥è¯¢æ¨¡å¼**:

1. **æ ‘å½¢ç»“æ„éå†**: ç»„ç»‡æ¶æ„ã€åˆ†ç±»æ ‘
2. **å›¾éå†**: ç¤¾äº¤ç½‘ç»œã€è·¯å¾„æŸ¥æ‰¾
3. **ç´¯ç§¯è®¡ç®—**: ç´¯è®¡æ±‚å’Œã€å±‚çº§è®¡ç®—

**æ ‘å½¢ç»“æ„éå†ç¤ºä¾‹**:

```sql
-- ç»„ç»‡æ¶æ„æ ‘ï¼ˆå‘ä¸‹éå†ï¼‰
WITH RECURSIVE org_tree AS (
    -- åŸºç¡€æƒ…å†µï¼šæ ¹èŠ‚ç‚¹
    SELECT
        emp_id,
        name,
        manager_id,
        1 as level,
        ARRAY[emp_id] as path,
        name::TEXT as hierarchy_path
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- é€’å½’æƒ…å†µï¼šå­èŠ‚ç‚¹
    SELECT
        e.emp_id,
        e.name,
        e.manager_id,
        ot.level + 1,
        ot.path || e.emp_id,
        ot.hierarchy_path || ' -> ' || e.name
    FROM employees e
    INNER JOIN org_tree ot ON e.manager_id = ot.emp_id
    WHERE NOT e.emp_id = ANY(ot.path)  -- é˜²æ­¢å¾ªç¯
)
SELECT * FROM org_tree ORDER BY level, name;

-- æŸ¥æ‰¾æ‰€æœ‰ä¸‹å±
WITH RECURSIVE subordinates AS (
    SELECT emp_id, name, manager_id
    FROM employees
    WHERE manager_id = 1001  -- æŒ‡å®šç®¡ç†è€…

    UNION ALL

    SELECT e.emp_id, e.name, e.manager_id
    FROM employees e
    INNER JOIN subordinates s ON e.manager_id = s.emp_id
)
SELECT * FROM subordinates;

-- æŸ¥æ‰¾è·¯å¾„ï¼ˆä»å¶å­åˆ°æ ¹ï¼‰
WITH RECURSIVE path_to_root AS (
    SELECT
        emp_id,
        name,
        manager_id,
        ARRAY[emp_id] as path
    FROM employees
    WHERE emp_id = 1005  -- æŒ‡å®šå‘˜å·¥

    UNION ALL

    SELECT
        e.emp_id,
        e.name,
        e.manager_id,
        ptr.path || e.emp_id
    FROM employees e
    INNER JOIN path_to_root ptr ON e.emp_id = ptr.manager_id
    WHERE NOT e.emp_id = ANY(ptr.path)
)
SELECT * FROM path_to_root ORDER BY array_length(path, 1) DESC;
```

**å›¾éå†ç¤ºä¾‹**:

```sql
-- ç¤¾äº¤ç½‘ç»œï¼šæŸ¥æ‰¾æœ‹å‹çš„æœ‹å‹ï¼ˆ2åº¦å…³ç³»ï¼‰
WITH RECURSIVE friend_network AS (
    -- åŸºç¡€æƒ…å†µï¼šç›´æ¥æœ‹å‹
    SELECT
        user_id,
        friend_id,
        1 as degree,
        ARRAY[user_id, friend_id] as path
    FROM friendships
    WHERE user_id = 1001

    UNION ALL

    -- é€’å½’æƒ…å†µï¼šæœ‹å‹çš„æœ‹å‹
    SELECT
        f.user_id,
        f.friend_id,
        fn.degree + 1,
        fn.path || f.friend_id
    FROM friendships f
    INNER JOIN friend_network fn ON f.user_id = fn.friend_id
    WHERE fn.degree < 2  -- é™åˆ¶æ·±åº¦
    AND NOT f.friend_id = ANY(fn.path)  -- é˜²æ­¢å¾ªç¯
)
SELECT DISTINCT friend_id, degree FROM friend_network WHERE degree <= 2;
```

**ç´¯ç§¯è®¡ç®—ç¤ºä¾‹**:

```sql
-- ç´¯è®¡é”€å”®é¢
WITH RECURSIVE cumulative_sales AS (
    SELECT
        order_date,
        SUM(amount) as daily_sales,
        SUM(amount) as cumulative_sales,
        1 as day_num
    FROM orders
    WHERE order_date = (SELECT MIN(order_date) FROM orders)
    GROUP BY order_date

    UNION ALL

    SELECT
        o.order_date,
        SUM(o.amount) as daily_sales,
        cs.cumulative_sales + SUM(o.amount) as cumulative_sales,
        cs.day_num + 1
    FROM orders o
    INNER JOIN cumulative_sales cs ON o.order_date = cs.order_date + INTERVAL '1 day'
    GROUP BY o.order_date, cs.cumulative_sales, cs.day_num
)
SELECT * FROM cumulative_sales ORDER BY order_date;
```

**é€’å½’æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–**:

```sql
-- ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–é€’å½’æŸ¥è¯¢
CREATE INDEX idx_employees_manager ON employees(manager_id);
CREATE INDEX idx_friendships_user ON friendships(user_id);
CREATE INDEX idx_friendships_friend ON friendships(friend_id);

-- é™åˆ¶é€’å½’æ·±åº¦
WITH RECURSIVE limited_tree AS (
    SELECT emp_id, name, manager_id, 1 as level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.emp_id, e.name, e.manager_id, lt.level + 1
    FROM employees e
    INNER JOIN limited_tree lt ON e.manager_id = lt.emp_id
    WHERE lt.level < 5  -- é™åˆ¶æ·±åº¦ä¸º5å±‚
)
SELECT * FROM limited_tree;
```

#### 2.4.6 CTEæ·±å…¥åº”ç”¨

**CTEä½¿ç”¨åœºæ™¯**:

1. **æŸ¥è¯¢ç®€åŒ–**: å°†å¤æ‚æŸ¥è¯¢åˆ†è§£ä¸ºå¤šä¸ªæ­¥éª¤
2. **æ•°æ®å‡†å¤‡**: é¢„å¤„ç†æ•°æ®ä¾›åç»­æŸ¥è¯¢ä½¿ç”¨
3. **é€’å½’æŸ¥è¯¢**: å®ç°é€’å½’é€»è¾‘
4. **å¯è¯»æ€§æå‡**: æé«˜SQLå¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§

**CTEé«˜çº§ç¤ºä¾‹**:

```sql
-- å¤šçº§CTEï¼šå¤æ‚æŠ¥è¡¨ç”Ÿæˆ
WITH
-- ç¬¬ä¸€æ­¥ï¼šç­›é€‰æ´»è·ƒç”¨æˆ·
active_users AS (
    SELECT user_id, name, registration_date
    FROM users
    WHERE last_login_date >= CURRENT_DATE - INTERVAL '30 days'
),

-- ç¬¬äºŒæ­¥ï¼šè®¡ç®—ç”¨æˆ·è®¢å•ç»Ÿè®¡
user_order_stats AS (
    SELECT
        u.user_id,
        COUNT(o.order_id) as order_count,
        SUM(o.amount) as total_amount,
        AVG(o.amount) as avg_amount
    FROM active_users u
    LEFT JOIN orders o ON u.user_id = o.user_id
    GROUP BY u.user_id
),

-- ç¬¬ä¸‰æ­¥ï¼šè®¡ç®—ç”¨æˆ·ç­‰çº§
user_ranks AS (
    SELECT
        user_id,
        order_count,
        total_amount,
        avg_amount,
        CASE
            WHEN total_amount >= 10000 THEN 'VIP'
            WHEN total_amount >= 5000 THEN 'Gold'
            WHEN total_amount >= 1000 THEN 'Silver'
            ELSE 'Bronze'
        END as user_level
    FROM user_order_stats
)

-- æœ€ç»ˆæŸ¥è¯¢ï¼šç”ŸæˆæŠ¥è¡¨
SELECT
    user_level,
    COUNT(*) as user_count,
    AVG(order_count) as avg_orders,
    AVG(total_amount) as avg_total_amount
FROM user_ranks
GROUP BY user_level
ORDER BY avg_total_amount DESC;

-- CTEç”¨äºæ•°æ®è½¬æ¢
WITH
-- åŸå§‹æ•°æ®æ¸…ç†
cleaned_data AS (
    SELECT
        order_id,
        customer_id,
        COALESCE(amount, 0) as amount,
        COALESCE(order_date, CURRENT_DATE) as order_date
    FROM orders
    WHERE order_date >= '2025-01-01'
),

-- æ•°æ®èšåˆ
aggregated_data AS (
    SELECT
        customer_id,
        COUNT(*) as order_count,
        SUM(amount) as total_amount,
        AVG(amount) as avg_amount
    FROM cleaned_data
    GROUP BY customer_id
)

-- æœ€ç»ˆè¾“å‡º
SELECT * FROM aggregated_data WHERE total_amount > 1000;

-- CTEç”¨äºæŸ¥è¯¢ä¼˜åŒ–ï¼ˆç‰©åŒ–ä¸­é—´ç»“æœï¼‰
WITH
-- ç‰©åŒ–CTEï¼ˆPostgreSQL 12+ï¼‰
MATERIALIZED expensive_calculation AS (
    SELECT
        dept_id,
        AVG(salary) as avg_salary,
        COUNT(*) as emp_count
    FROM employees
    GROUP BY dept_id
    HAVING COUNT(*) > 10
)

SELECT
    e.name,
    e.salary,
    ec.avg_salary,
    e.salary - ec.avg_salary as diff_from_avg
FROM employees e
JOIN expensive_calculation ec ON e.dept_id = ec.dept_id
WHERE e.salary > ec.avg_salary;
```

**CTEæ€§èƒ½è€ƒè™‘**:

```sql
-- CTEä¼˜åŒ–ï¼šä½¿ç”¨MATERIALIZEDï¼ˆPostgreSQL 12+ï¼‰
WITH MATERIALIZED large_cte AS (
    SELECT * FROM large_table WHERE condition = 'value'
)
SELECT * FROM large_cte WHERE other_condition = 'other_value';

-- CTEä¼˜åŒ–ï¼šé¿å…åœ¨CTEä¸­ä½¿ç”¨å¤æ‚è®¡ç®—
-- ä¸æ¨è
WITH complex_cte AS (
    SELECT
        *,
        (SELECT COUNT(*) FROM other_table WHERE ...) as complex_value
    FROM main_table
)
SELECT * FROM complex_cte;

-- æ¨èï¼šå…ˆè®¡ç®—å†ä½¿ç”¨
WITH simple_cte AS (
    SELECT * FROM main_table
),
calculated_values AS (
    SELECT
        id,
        (SELECT COUNT(*) FROM other_table WHERE ...) as complex_value
    FROM simple_cte
)
SELECT s.*, c.complex_value
FROM simple_cte s
JOIN calculated_values c ON s.id = c.id;
```

#### 2.4.7 é«˜çº§SQLç‰¹æ€§ç»„åˆåº”ç”¨

**çª—å£å‡½æ•° + CTE**:

```sql
WITH ranked_employees AS (
    SELECT
        dept_id,
        name,
        salary,
        ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as rank
    FROM employees
)
SELECT
    dept_id,
    name,
    salary,
    rank
FROM ranked_employees
WHERE rank <= 3;  -- æ¯ä¸ªéƒ¨é—¨å‰3å
```

**é€’å½’æŸ¥è¯¢ + çª—å£å‡½æ•°**:

```sql
WITH RECURSIVE org_hierarchy AS (
    SELECT emp_id, name, manager_id, 1 as level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.emp_id, e.name, e.manager_id, oh.level + 1
    FROM employees e
    INNER JOIN org_hierarchy oh ON e.manager_id = oh.emp_id
)
SELECT
    level,
    name,
    COUNT(*) OVER (PARTITION BY level) as employees_at_level,
    ROW_NUMBER() OVER (PARTITION BY level ORDER BY name) as level_rank
FROM org_hierarchy
ORDER BY level, name;
```

### 3.5 äº‹åŠ¡æ§åˆ¶è¯­è¨€ï¼ˆTCLï¼‰

#### 2.5.1 äº‹åŠ¡ç®¡ç†

```sql
-- åŸºæœ¬äº‹åŠ¡
BEGIN;
INSERT INTO employees (name, dept_id, salary) VALUES ('æ–°å‘˜å·¥', 1, 50000);
UPDATE departments SET emp_count = emp_count + 1 WHERE dept_id = 1;
COMMIT;

-- ä¿å­˜ç‚¹
BEGIN;
INSERT INTO employees (name, dept_id, salary) VALUES ('å‘˜å·¥1', 1, 50000);
SAVEPOINT sp1;
INSERT INTO employees (name, dept_id, salary) VALUES ('å‘˜å·¥2', 1, 60000);
ROLLBACK TO sp1;  -- å›æ»šåˆ°ä¿å­˜ç‚¹
COMMIT;  -- åªæäº¤ç¬¬ä¸€ä¸ªæ’å…¥
```

### 3.6 æ•°æ®æ§åˆ¶è¯­è¨€ï¼ˆDCLï¼‰

#### 2.6.1 æƒé™ç®¡ç†

```sql
-- åˆ›å»ºè§’è‰²
CREATE ROLE hr_manager;
CREATE ROLE data_analyst;

-- æˆäºˆæƒé™
GRANT SELECT, INSERT, UPDATE ON employees TO hr_manager;
GRANT SELECT ON employees TO data_analyst;
GRANT USAGE ON SCHEMA public TO hr_manager, data_analyst;

-- æ’¤é”€æƒé™
REVOKE UPDATE ON employees FROM hr_manager;

-- è§’è‰²ç»§æ‰¿
GRANT hr_manager TO data_analyst;
```

## å››ã€PostgreSQLæ‰©å±•ç‰¹æ€§

### 4.1 æ•°æ®ç±»å‹æ‰©å±•

```sql
-- JSONæ•°æ®ç±»å‹
CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,
    profile JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- æ•°ç»„ç±»å‹
CREATE TABLE products (
    product_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    tags TEXT[],
    prices DECIMAL(10,2)[]
);

-- èŒƒå›´ç±»å‹
CREATE TABLE events (
    event_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    duration TSRANGE,
    price_range NUMRANGE
);
```

**PostgreSQL 18 JSONBå¢å¼º** ğŸ†•

PostgreSQL 18å¯¹JSONBç±»å‹è¿›è¡Œäº†å¤šé¡¹æ€§èƒ½ä¼˜åŒ–ï¼ŒæŸ¥è¯¢å’Œæ›´æ–°æ€§èƒ½æå‡15-20%ã€‚

**æ€§èƒ½ä¼˜åŒ–**:

1. **æŸ¥è¯¢ä¼˜åŒ–**: æ”¹è¿›JSONBè·¯å¾„æŸ¥è¯¢çš„æ€§èƒ½
2. **ç´¢å¼•ä¼˜åŒ–**: ä¼˜åŒ–GINç´¢å¼•åœ¨JSONBæŸ¥è¯¢ä¸­çš„ä½¿ç”¨
3. **æ›´æ–°ä¼˜åŒ–**: æå‡JSONBéƒ¨åˆ†æ›´æ–°çš„æ•ˆç‡

**ä½¿ç”¨ç¤ºä¾‹**:

```sql
-- JSONBæŸ¥è¯¢ä¼˜åŒ–ï¼ˆPostgreSQL 18ï¼‰
CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,
    profile JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- åˆ›å»ºGINç´¢å¼•ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰
CREATE INDEX idx_profile_gin ON user_profiles USING GIN (profile);

-- è·¯å¾„æŸ¥è¯¢ï¼ˆæ€§èƒ½æå‡15-20%ï¼‰
SELECT user_id, profile->>'name' as name, profile->'address'->>'city' as city
FROM user_profiles
WHERE profile @> '{"status": "active"}'::jsonb;

-- JSONBæ›´æ–°ï¼ˆæ€§èƒ½æå‡ï¼‰
UPDATE user_profiles
SET profile = jsonb_set(profile, '{last_login}', to_jsonb(NOW()))
WHERE user_id = 1001;

-- æ‰¹é‡æ›´æ–°ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰
UPDATE user_profiles
SET profile = profile || '{"updated_at": "' || NOW()::TEXT || '"}'::jsonb
WHERE profile->>'status' = 'active';
```

**æ€§èƒ½å¯¹æ¯”**:

- PostgreSQL 17: JSONBæŸ¥è¯¢å’Œæ›´æ–°åŸºå‡†æ€§èƒ½
- PostgreSQL 18: JSONBæŸ¥è¯¢æ€§èƒ½æå‡15-20%
- PostgreSQL 18: JSONBæ›´æ–°æ€§èƒ½æå‡15-20%
- PostgreSQL 18: GINç´¢å¼•æŸ¥è¯¢æ€§èƒ½æå‡20-30%

**æœ€ä½³å®è·µ**:

- ä½¿ç”¨GINç´¢å¼•åŠ é€ŸJSONBæŸ¥è¯¢
- ä½¿ç”¨`@>`æ“ä½œç¬¦è¿›è¡ŒåŒ…å«æŸ¥è¯¢
- ä½¿ç”¨`jsonb_set`è¿›è¡Œéƒ¨åˆ†æ›´æ–°
- PostgreSQL 18çš„JSONBä¼˜åŒ–åœ¨å¤æ‚æŸ¥è¯¢ä¸­æ•ˆæœæ›´æ˜æ˜¾

### 4.2 å‡½æ•°å’Œæ“ä½œç¬¦

```sql
-- è‡ªå®šä¹‰å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_bonus(emp_salary DECIMAL, performance_score INTEGER)
RETURNS DECIMAL AS $$
BEGIN
    RETURN emp_salary * (performance_score / 100.0) * 0.1;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨å‡½æ•°
SELECT name, salary, calculate_bonus(salary, 85) as bonus
FROM employees;

-- JSONæ“ä½œç¬¦
SELECT profile->>'name' as user_name,
       profile->'address'->>'city' as city
FROM user_profiles
WHERE profile ? 'address';
```

### 4.3 ç´¢å¼•ç±»å‹

```sql
-- GINç´¢å¼•ï¼ˆç”¨äºæ•°ç»„å’ŒJSONï¼‰
CREATE INDEX idx_profile_gin ON user_profiles USING GIN (profile);
CREATE INDEX idx_tags_gin ON products USING GIN (tags);

-- GiSTç´¢å¼•ï¼ˆç”¨äºå‡ ä½•å’ŒèŒƒå›´ç±»å‹ï¼‰
CREATE INDEX idx_duration_gist ON events USING GIST (duration);

-- éƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;

-- è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_name_lower ON employees (LOWER(name));
```

## äº”ã€æ€§èƒ½ä¼˜åŒ–

### 5.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä½¿ç”¨EXPLAINåˆ†ææŸ¥è¯¢è®¡åˆ’ï¼ˆå¸¦å®Œæ•´æ€§èƒ½æµ‹è¯•ï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000;

-- ä½¿ç”¨LIMITä¼˜åŒ–
SELECT name, salary
FROM employees
ORDER BY salary DESC
LIMIT 10;

-- é¿å…SELECT *
SELECT emp_id, name, salary  -- åªé€‰æ‹©éœ€è¦çš„åˆ—
FROM employees
WHERE dept_id = 1;
```

### 5.2 ç´¢å¼•ä¼˜åŒ–

```sql
-- å¤åˆç´¢å¼•
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- è¦†ç›–ç´¢å¼•
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;
```

## å…­ã€ç›¸å…³æ¦‚å¿µ

### 6.1 ä¸Šä½æ¦‚å¿µ

- **æŸ¥è¯¢è¯­è¨€**: æ›´å¹¿æ³›çš„è¯­è¨€ç±»åˆ«
- **å…³ç³»æ•°æ®åº“**: æ•°æ®æ¨¡å‹ç±»å‹
- **å£°æ˜å¼è¯­è¨€**: ç¼–ç¨‹èŒƒå¼

### 6.2 ä¸‹ä½æ¦‚å¿µ

- **DDL**: æ•°æ®å®šä¹‰è¯­è¨€
- **DML**: æ•°æ®æ“ä½œè¯­è¨€
- **DQL**: æ•°æ®æŸ¥è¯¢è¯­è¨€
- **DCL**: æ•°æ®æ§åˆ¶è¯­è¨€
- **TCL**: äº‹åŠ¡æ§åˆ¶è¯­è¨€

### 6.3 å¹³è¡Œæ¦‚å¿µ

- **NoSQLæŸ¥è¯¢è¯­è¨€**: éå…³ç³»å‹æŸ¥è¯¢è¯­è¨€
- **å…³ç³»ä»£æ•°**: æ•°å­¦åŸºç¡€
- **å…³ç³»æ¼”ç®—**: é€»è¾‘åŸºç¡€

---

## ä¸ƒã€å‚è€ƒèµ„æº

### 7.1 ç›¸å…³æ–‡æ¡£

- [å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º](../01.03-æ•°æ®æ¨¡å‹/01.02-å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º.md) - å…³ç³»æ•°æ®æ¨¡å‹
- [äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§](../../03-äº‹åŠ¡ä¸å¹¶å‘/03.02-ACIDç‰¹æ€§/01.04-äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§.md) - äº‹åŠ¡ç®¡ç†
- [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md) - æŸ¥è¯¢ä¼˜åŒ–

### 7.2 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹

- [å®æˆ˜æ¡ˆä¾‹](../../19-å®æˆ˜æ¡ˆä¾‹/README.md) â­ - å®Œæ•´çš„å®æˆ˜æ¡ˆä¾‹é›†åˆ
- [å·¥å…·ä¸èµ„æº](../../22-å·¥å…·ä¸èµ„æº/README.md) - å·¥å…·è„šæœ¬å’Œèµ„æº
- [AIä¸æœºå™¨å­¦ä¹ ](../../10-AIä¸æœºå™¨å­¦ä¹ /README.md) - AIé›†æˆæŒ‡å—

### 7.3 å‚è€ƒæ–‡çŒ®

1. ISO/IEC 9075:2023. Information technology â€” Database languages â€” SQL
2. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
3. Codd, E. F. (1970). A relational model of data for large shared data banks. Communications of the ACM, 13(6), 377-387.
4. Date, C. J. (2003). An Introduction to Database Systems (8th ed.). Addison-Wesley.

### 7.4 Wikidataå¯¹é½

- **Wikidata ID**: Q202218
- **ç›¸å…³å±æ€§**:
  - P31: Q202218 (instance of: programming language)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P348: SQL:2023 (software version)
  - P856: <https://www.postgresql.org/docs/current/sql.html> (official website)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/sql.html>
  - <https://www.iso.org/standard/76583.html>

---

## å…«ã€äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£

- â­â­â­ [å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º](./01.02-å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º.md) - å…³ç³»æ¨¡å‹ç†è®ºåŸºç¡€
- â­â­â­ [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md) - SQLæŸ¥è¯¢ä¼˜åŒ–
- â­â­ [äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§](../../03-äº‹åŠ¡ä¸å¹¶å‘/03.02-ACIDç‰¹æ€§/01.04-äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§.md) - äº‹åŠ¡SQLè¯­å¥
- â­â­ [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.03-æ‰§è¡Œè®¡åˆ’/02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - SQLæ€§èƒ½è°ƒä¼˜
- â­ [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.02-ç´¢å¼•ç»“æ„/02.02-ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–.md) - SQLç´¢å¼•ä¼˜åŒ–
- â­ [æ•°æ®æ¨¡å‹è®¾è®¡](../../17-æ•°æ®æ¨¡å‹è®¾è®¡/README.md) - SQLæ•°æ®å»ºæ¨¡

### å¤–éƒ¨èµ„æº

- [PostgreSQL SQLæ–‡æ¡£](https://www.postgresql.org/docs/current/sql.html)
- [SQLæ ‡å‡†æ–‡æ¡£](https://www.iso.org/standard/76583.html)
- [PostgreSQL SQLæœ€ä½³å®è·µ](https://wiki.postgresql.org/wiki/SQL)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.1
**æœ€åæ›´æ–°**: 2025-11-22
**PostgreSQLç‰ˆæœ¬**: 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
**ç»´æŠ¤è€…**: Documentation Team
