---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL_AI\04-åº”ç”¨åœºæ™¯\æ™ºèƒ½å®¢æœç³»ç»Ÿ.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ™ºèƒ½å®¢æœç³»ç»Ÿ

> **æ–‡æ¡£ç¼–å·**: AI-04-05
> **æœ€åæ›´æ–°**: 2025å¹´1æœˆ
> **ä¸»é¢˜**: 04-åº”ç”¨åœºæ™¯
> **å­ä¸»é¢˜**: 05-æ™ºèƒ½å®¢æœç³»ç»Ÿ

## ğŸ“‘ ç›®å½•

- [æ™ºèƒ½å®¢æœç³»ç»Ÿ](#æ™ºèƒ½å®¢æœç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ™ºèƒ½å®¢æœç³»ç»Ÿæ¦‚è¿°](#1-æ™ºèƒ½å®¢æœç³»ç»Ÿæ¦‚è¿°)
    - [1.1 æ™ºèƒ½å®¢æœç³»ç»Ÿæ€ç»´å¯¼å›¾](#11-æ™ºèƒ½å®¢æœç³»ç»Ÿæ€ç»´å¯¼å›¾)
    - [1.2 ç³»ç»Ÿä»·å€¼](#12-ç³»ç»Ÿä»·å€¼)
  - [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
    - [2.1 ç³»ç»Ÿæ¶æ„](#21-ç³»ç»Ÿæ¶æ„)
    - [2.2 æ•°æ®æµ](#22-æ•°æ®æµ)
  - [3. æ•°æ®åº“è®¾è®¡](#3-æ•°æ®åº“è®¾è®¡)
    - [3.1 çŸ¥è¯†åº“è¡¨](#31-çŸ¥è¯†åº“è¡¨)
    - [3.2 å¯¹è¯è®°å½•è¡¨](#32-å¯¹è¯è®°å½•è¡¨)
    - [3.3 ç”¨æˆ·åé¦ˆè¡¨](#33-ç”¨æˆ·åé¦ˆè¡¨)
  - [4. æ ¸å¿ƒåŠŸèƒ½å®ç°](#4-æ ¸å¿ƒåŠŸèƒ½å®ç°)
    - [4.1 çŸ¥è¯†åº“æ„å»º](#41-çŸ¥è¯†åº“æ„å»º)
    - [4.2 è¯­ä¹‰æ£€ç´¢](#42-è¯­ä¹‰æ£€ç´¢)
    - [4.3 å¯¹è¯ç®¡ç†](#43-å¯¹è¯ç®¡ç†)
    - [4.4 å¤šè½®å¯¹è¯æ”¯æŒ](#44-å¤šè½®å¯¹è¯æ”¯æŒ)
  - [5. AIé›†æˆ](#5-aié›†æˆ)
    - [5.1 ä½¿ç”¨pg\_aiè°ƒç”¨LLM](#51-ä½¿ç”¨pg_aiè°ƒç”¨llm)
    - [5.2 RAGå¢å¼ºç”Ÿæˆ](#52-ragå¢å¼ºç”Ÿæˆ)
    - [5.3 ä¸Šä¸‹æ–‡ç®¡ç†](#53-ä¸Šä¸‹æ–‡ç®¡ç†)
  - [6. æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)
    - [6.1 æ£€ç´¢ä¼˜åŒ–](#61-æ£€ç´¢ä¼˜åŒ–)
    - [6.2 ç¼“å­˜ç­–ç•¥](#62-ç¼“å­˜ç­–ç•¥)
    - [6.3 å¹¶å‘å¤„ç†](#63-å¹¶å‘å¤„ç†)
  - [7. è¯„ä¼°ä¸ä¼˜åŒ–](#7-è¯„ä¼°ä¸ä¼˜åŒ–)
    - [7.1 å‡†ç¡®ç‡è¯„ä¼°](#71-å‡†ç¡®ç‡è¯„ä¼°)
    - [7.2 ç”¨æˆ·æ»¡æ„åº¦](#72-ç”¨æˆ·æ»¡æ„åº¦)
    - [7.3 æˆæœ¬åˆ†æ](#73-æˆæœ¬åˆ†æ)

---

## 1. æ™ºèƒ½å®¢æœç³»ç»Ÿæ¦‚è¿°

### 1.1 æ™ºèƒ½å®¢æœç³»ç»Ÿæ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((æ™ºèƒ½å®¢æœç³»ç»Ÿ))
    æ ¸å¿ƒåŠŸèƒ½
      çŸ¥è¯†åº“æ£€ç´¢
        è¯­ä¹‰æœç´¢
        å…¨æ–‡æœç´¢
        æ··åˆæ£€ç´¢
      å¯¹è¯ç®¡ç†
        å¤šè½®å¯¹è¯
        ä¸Šä¸‹æ–‡ç†è§£
        ä¼šè¯çŠ¶æ€
      æ™ºèƒ½ç”Ÿæˆ
        RAGå¢å¼º
        LLMè°ƒç”¨
        ç­”æ¡ˆç”Ÿæˆ
    æŠ€æœ¯å®ç°
      PostgreSQL
        pgvectorå‘é‡æœç´¢
        pg_ai LLMè°ƒç”¨
        JSONBå¯¹è¯å­˜å‚¨
      RAGæ¡†æ¶
        LangChain
        LlamaIndex
    åº”ç”¨åœºæ™¯
      åœ¨çº¿å®¢æœ
      æ™ºèƒ½é—®ç­”
      çŸ¥è¯†åº“æŸ¥è¯¢
```

### 1.2 ç³»ç»Ÿä»·å€¼

**æ ¸å¿ƒä¼˜åŠ¿**ï¼š

- âœ… **24/7æœåŠ¡**ï¼šå…¨å¤©å€™è‡ªåŠ¨å“åº”
- âœ… **å¿«é€Ÿå“åº”**ï¼šç§’çº§å›ç­”ç”¨æˆ·é—®é¢˜
- âœ… **çŸ¥è¯†å‡†ç¡®**ï¼šåŸºäºä¼ä¸šçŸ¥è¯†åº“ï¼Œå‡å°‘å¹»è§‰
- âœ… **æˆæœ¬é™ä½**ï¼šå‡å°‘äººå·¥å®¢æœæˆæœ¬70%+

---

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 ç³»ç»Ÿæ¶æ„

**æ™ºèƒ½å®¢æœç³»ç»Ÿæ¶æ„**ï¼š

```mermaid
graph TB
    subgraph "ç”¨æˆ·å±‚"
        User[ç”¨æˆ·]
        Web[Webç•Œé¢]
        App[ç§»åŠ¨åº”ç”¨]
    end

    subgraph "åº”ç”¨å±‚"
        API[å®¢æœAPI]
        Chat[å¯¹è¯ç®¡ç†]
        RAG[RAGå¼•æ“]
    end

    subgraph "æ•°æ®å±‚"
        KB[(çŸ¥è¯†åº“<br/>PostgreSQL)]
        Vec[å‘é‡ç´¢å¼•<br/>pgvector]
        History[(å¯¹è¯å†å²)]
    end

    subgraph "AIå±‚"
        Embed[å‘é‡åŒ–<br/>pg_ai]
        LLM[LLMç”Ÿæˆ<br/>pg_ai]
    end

    User --> Web
    User --> App
    Web --> API
    App --> API
    API --> Chat
    Chat --> RAG
    RAG --> KB
    RAG --> Vec
    RAG --> LLM
    KB --> Embed
    Chat --> History

    style KB fill:#4a90e2,color:#fff
    style Vec fill:#50c878,color:#fff
```

### 2.2 æ•°æ®æµ

**æ™ºèƒ½å®¢æœæ•°æ®æµ**ï¼š

```text
1. ç”¨æˆ·æé—® â†’ APIæ¥æ”¶
2. é—®é¢˜å‘é‡åŒ– â†’ pg_ai.embedding()
3. çŸ¥è¯†åº“æ£€ç´¢ â†’ pgvectorç›¸ä¼¼åº¦æœç´¢
4. ä¸Šä¸‹æ–‡æ„å»º â†’ æ£€ç´¢ç»“æœ+å¯¹è¯å†å²
5. LLMç”Ÿæˆç­”æ¡ˆ â†’ pg_ai.chat_complete()
6. ç­”æ¡ˆè¿”å›ç”¨æˆ·
7. å¯¹è¯è®°å½•å­˜å‚¨ â†’ PostgreSQL
```

---

## 3. æ•°æ®åº“è®¾è®¡

### 3.1 çŸ¥è¯†åº“è¡¨

**çŸ¥è¯†åº“è¡¨ç»“æ„**ï¼š

```sql
-- 1. çŸ¥è¯†åº“æ–‡æ¡£è¡¨
CREATE TABLE knowledge_base (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    category TEXT,
    embedding vector(1536),  -- æ–‡æ¡£å‘é‡
    metadata JSONB,  -- å…ƒæ•°æ®
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. çŸ¥è¯†åº“åˆ†å—è¡¨ï¼ˆç”¨äºRAGï¼‰
CREATE TABLE knowledge_chunks (
    id SERIAL PRIMARY KEY,
    document_id INT REFERENCES knowledge_base(id) ON DELETE CASCADE,
    chunk_text TEXT NOT NULL,
    chunk_index INT,
    embedding vector(1536),  -- å—å‘é‡
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX ON knowledge_chunks
USING hnsw(embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 4. å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX ON knowledge_chunks
USING GIN(to_tsvector('english', chunk_text));
```

### 3.2 å¯¹è¯è®°å½•è¡¨

**å¯¹è¯è®°å½•è¡¨ç»“æ„**ï¼š

```sql
-- 1. å¯¹è¯ä¼šè¯è¡¨
CREATE TABLE conversations (
    id SERIAL PRIMARY KEY,
    user_id TEXT,
    session_id TEXT UNIQUE NOT NULL,
    status TEXT DEFAULT 'active',  -- active, closed
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. å¯¹è¯æ¶ˆæ¯è¡¨
CREATE TABLE conversation_messages (
    id SERIAL PRIMARY KEY,
    conversation_id INT REFERENCES conversations(id) ON DELETE CASCADE,
    role TEXT NOT NULL,  -- user, assistant, system
    content TEXT NOT NULL,
    embedding vector(1536),  -- ç”¨æˆ·é—®é¢˜å‘é‡
    retrieved_chunks INT[],  -- æ£€ç´¢åˆ°çš„çŸ¥è¯†å—IDs
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. å¯¹è¯ä¸Šä¸‹æ–‡ç´¢å¼•
CREATE INDEX ON conversation_messages (conversation_id, created_at DESC);
CREATE INDEX ON conversation_messages USING GIN(embedding vector_cosine_ops);
```

### 3.3 ç”¨æˆ·åé¦ˆè¡¨

**ç”¨æˆ·åé¦ˆè¡¨ç»“æ„**ï¼š

```sql
-- ç”¨æˆ·åé¦ˆè¡¨
CREATE TABLE user_feedback (
    id SERIAL PRIMARY KEY,
    conversation_id INT REFERENCES conversations(id),
    message_id INT REFERENCES conversation_messages(id),
    rating INT,  -- 1-5è¯„åˆ†
    feedback_text TEXT,
    helpful BOOLEAN,  -- æ˜¯å¦æœ‰å¸®åŠ©
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åé¦ˆç»Ÿè®¡
CREATE INDEX ON user_feedback (conversation_id, rating);
```

---

## 4. æ ¸å¿ƒåŠŸèƒ½å®ç°

### 4.1 çŸ¥è¯†åº“æ„å»º

**çŸ¥è¯†åº“å¯¼å…¥**ï¼š

```sql
-- 1. æ‰¹é‡å¯¼å…¥çŸ¥è¯†åº“æ–‡æ¡£
COPY knowledge_base(title, content, category)
FROM '/path/to/knowledge.csv'
WITH (FORMAT csv, HEADER true);

-- 2. è‡ªåŠ¨ç”Ÿæˆå‘é‡
UPDATE knowledge_base
SET embedding = ai.embedding_openai(
    'text-embedding-3-small',
    title || ' ' || content
)
WHERE embedding IS NULL;

-- 3. æ–‡æ¡£åˆ†å—ï¼ˆä½¿ç”¨pg_aiï¼‰
SELECT ai.create_vectorizer(
    'knowledge_base'::regclass,
    destination => 'knowledge_chunks',
    embedding => ai.embedding_openai('text-embedding-3-small', 'content'),
    chunking => ai.chunking_recursive_character_text_splitter(
        'content',
        chunk_size => 500,
        chunk_overlap => 100
    )
);
```

### 4.2 è¯­ä¹‰æ£€ç´¢

**RAGæ£€ç´¢å®ç°**ï¼š

```sql
-- 1. ç”¨æˆ·é—®é¢˜å‘é‡åŒ–
WITH query_vec AS (
    SELECT ai.embedding_openai(
        'text-embedding-3-small',
        'How to reset password?'
    ) AS vec
),
-- 2. æ£€ç´¢ç›¸å…³çŸ¥è¯†å—
retrieved_chunks AS (
    SELECT
        kc.id,
        kc.chunk_text,
        kb.title,
        kb.category,
        1 - (kc.embedding <=> qv.vec) AS similarity
    FROM knowledge_chunks kc
    JOIN knowledge_base kb ON kb.id = kc.document_id,
         query_vec qv
    WHERE 1 - (kc.embedding <=> qv.vec) > 0.7
    ORDER BY kc.embedding <=> qv.vec
    LIMIT 5
)
-- 3. æ„å»ºä¸Šä¸‹æ–‡
SELECT
    string_agg(chunk_text, '\n\n') AS context,
    string_agg(title, ', ') AS sources
FROM retrieved_chunks;

-- æ€§èƒ½æµ‹è¯•ï¼šRAGè¯­ä¹‰æ£€ç´¢æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH query_vec AS (
    SELECT ai.embedding_openai(
        'text-embedding-3-small',
        'How to reset password?'
    ) AS vec
),
retrieved_chunks AS (
    SELECT
        kc.id,
        kc.chunk_text,
        kb.title,
        kb.category,
        1 - (kc.embedding <=> qv.vec) AS similarity
    FROM knowledge_chunks kc
    JOIN knowledge_base kb ON kb.id = kc.document_id,
         query_vec qv
    WHERE 1 - (kc.embedding <=> qv.vec) > 0.7
    ORDER BY kc.embedding <=> qv.vec
    LIMIT 5
)
SELECT
    string_agg(chunk_text, '\n\n') AS context,
    string_agg(title, ', ') AS sources
FROM retrieved_chunks;
```

### 4.3 å¯¹è¯ç®¡ç†

**å¯¹è¯ä¸Šä¸‹æ–‡ç®¡ç†**ï¼š

```sql
-- 1. åˆ›å»ºæ–°å¯¹è¯
INSERT INTO conversations (user_id, session_id)
VALUES ('user123', 'session_' || gen_random_uuid()::text)
RETURNING id, session_id;

-- 2. ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
INSERT INTO conversation_messages (conversation_id, role, content, embedding)
VALUES (
    1,
    'user',
    'How to reset password?',
    ai.embedding_openai('text-embedding-3-small', 'How to reset password?')
);

-- 3. è·å–å¯¹è¯å†å²
SELECT
    role,
    content,
    created_at
FROM conversation_messages
WHERE conversation_id = 1
ORDER BY created_at DESC
LIMIT 10;  -- æœ€è¿‘10æ¡æ¶ˆæ¯
```

### 4.4 å¤šè½®å¯¹è¯æ”¯æŒ

**å¤šè½®å¯¹è¯ä¸Šä¸‹æ–‡æ„å»º**ï¼š

```sql
-- ç»“åˆå†å²å¯¹è¯å’ŒçŸ¥è¯†åº“æ£€ç´¢
WITH conversation_history AS (
    SELECT
        role,
        content,
        created_at
    FROM conversation_messages
    WHERE conversation_id = $1
    ORDER BY created_at DESC
    LIMIT 5  -- æœ€è¿‘5è½®å¯¹è¯
),
current_query AS (
    SELECT ai.embedding_openai('text-embedding-3-small', $2) AS vec
),
retrieved_knowledge AS (
    SELECT chunk_text
    FROM knowledge_chunks kc, current_query cq
    WHERE 1 - (kc.embedding <=> cq.vec) > 0.7
    ORDER BY kc.embedding <=> cq.vec
    LIMIT 3
)
SELECT
    string_agg(
        CASE role
            WHEN 'user' THEN 'User: ' || content
            WHEN 'assistant' THEN 'Assistant: ' || content
        END,
        '\n'
    ) AS history_context,
    string_agg(chunk_text, '\n\n') AS knowledge_context
FROM conversation_history, retrieved_knowledge;
```

---

## 5. AIé›†æˆ

### 5.1 ä½¿ç”¨pg_aiè°ƒç”¨LLM

**SQLå†…LLMè°ƒç”¨**ï¼š

```sql
-- 1. æ£€ç´¢ç›¸å…³çŸ¥è¯†
WITH query_vec AS (
    SELECT ai.embedding_openai('text-embedding-3-small', $1) AS vec
),
retrieved AS (
    SELECT chunk_text
    FROM knowledge_chunks kc, query_vec qv
    WHERE 1 - (kc.embedding <=> qv.vec) > 0.7
    ORDER BY kc.embedding <=> qv.vec
    LIMIT 3
),
context AS (
    SELECT string_agg(chunk_text, '\n\n') AS text FROM retrieved
)
-- 2. ç”Ÿæˆç­”æ¡ˆ
SELECT ai.chat_complete(
    'gpt-4',
    'Based on the following knowledge base, answer the user question: ' || $1 ||
    '\n\nKnowledge Base:\n' || context.text ||
    '\n\nAnswer in a helpful and concise way.'
) AS answer
FROM context;
```

### 5.2 RAGå¢å¼ºç”Ÿæˆ

**å®Œæ•´RAGæµç¨‹**ï¼š

```sql
CREATE OR REPLACE FUNCTION generate_answer(
    p_conversation_id INT,
    p_user_question TEXT
)
RETURNS TEXT AS $$
DECLARE
    v_query_vec vector(1536);
    v_context TEXT;
    v_history TEXT;
    v_answer TEXT;
BEGIN
    -- 1. å‘é‡åŒ–ç”¨æˆ·é—®é¢˜
    SELECT ai.embedding_openai('text-embedding-3-small', p_user_question)
    INTO v_query_vec;

    -- 2. æ£€ç´¢ç›¸å…³çŸ¥è¯†
    SELECT string_agg(chunk_text, '\n\n')
    INTO v_context
    FROM (
        SELECT chunk_text
        FROM knowledge_chunks
        WHERE 1 - (embedding <=> v_query_vec) > 0.7
        ORDER BY embedding <=> v_query_vec
        LIMIT 3
    ) AS retrieved;

    -- 3. è·å–å¯¹è¯å†å²
    SELECT string_agg(
        CASE role
            WHEN 'user' THEN 'User: ' || content
            WHEN 'assistant' THEN 'Assistant: ' || content
        END,
        '\n'
    )
    INTO v_history
    FROM conversation_messages
    WHERE conversation_id = p_conversation_id
    ORDER BY created_at DESC
    LIMIT 5;

    -- 4. ç”Ÿæˆç­”æ¡ˆ
    SELECT ai.chat_complete(
        'gpt-4',
        'Context:\n' || COALESCE(v_context, '') ||
        '\n\nConversation History:\n' || COALESCE(v_history, '') ||
        '\n\nUser Question: ' || p_user_question ||
        '\n\nAnswer:'
    )
    INTO v_answer;

    -- 5. ä¿å­˜å¯¹è¯
    INSERT INTO conversation_messages (conversation_id, role, content, embedding)
    VALUES (p_conversation_id, 'user', p_user_question, v_query_vec);

    INSERT INTO conversation_messages (conversation_id, role, content)
    VALUES (p_conversation_id, 'assistant', v_answer);

    RETURN v_answer;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 ä¸Šä¸‹æ–‡ç®¡ç†

**ä¸Šä¸‹æ–‡å‹ç¼©**ï¼š

```sql
-- 1. å¯¹è¯æ‘˜è¦ï¼ˆå‹ç¼©å†å²ï¼‰
CREATE OR REPLACE FUNCTION summarize_conversation(p_conversation_id INT)
RETURNS TEXT AS $$
DECLARE
    v_history TEXT;
    v_summary TEXT;
BEGIN
    -- è·å–å®Œæ•´å¯¹è¯å†å²
    SELECT string_agg(
        role || ': ' || content,
        '\n'
    )
    INTO v_history
    FROM conversation_messages
    WHERE conversation_id = p_conversation_id
    ORDER BY created_at;

    -- ä½¿ç”¨LLMç”Ÿæˆæ‘˜è¦
    SELECT ai.chat_complete(
        'gpt-4',
        'Summarize the following conversation:\n' || v_history
    )
    INTO v_summary;

    RETURN v_summary;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 æ£€ç´¢ä¼˜åŒ–

**æ£€ç´¢ä¼˜åŒ–ç­–ç•¥**ï¼š

```sql
-- 1. ä½¿ç”¨HNSWç´¢å¼•æå‡å¬å›ç‡
SET hnsw.ef_search = 100;  -- æå‡å¬å›ç‡

-- 2. è®¾ç½®ç›¸ä¼¼åº¦é˜ˆå€¼æå‰è¿‡æ»¤
WHERE embedding <=> query_vec < 0.3  -- æå‰è¿‡æ»¤

-- 3. ä½¿ç”¨LIMITé™åˆ¶ç»“æœæ•°
LIMIT 5;  -- åªè¿”å›Top 5
```

### 6.2 ç¼“å­˜ç­–ç•¥

**æŸ¥è¯¢ç»“æœç¼“å­˜**ï¼š

```sql
-- 1. åˆ›å»ºç¼“å­˜è¡¨
CREATE TABLE answer_cache (
    question_hash TEXT PRIMARY KEY,
    question_text TEXT,
    answer TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

-- 2. ç¼“å­˜å¸¸ç”¨é—®é¢˜ç­”æ¡ˆ
CREATE OR REPLACE FUNCTION get_cached_answer(p_question TEXT)
RETURNS TEXT AS $$
DECLARE
    v_hash TEXT;
    v_answer TEXT;
BEGIN
    v_hash = md5(p_question);

    SELECT answer INTO v_answer
    FROM answer_cache
    WHERE question_hash = v_hash
      AND expires_at > NOW();

    IF v_answer IS NOT NULL THEN
        RETURN v_answer;
    END IF;

    -- ç”Ÿæˆæ–°ç­”æ¡ˆï¼ˆè°ƒç”¨generate_answerï¼‰
    -- ...

    -- ç¼“å­˜ç­”æ¡ˆ
    INSERT INTO answer_cache (question_hash, question_text, answer, expires_at)
    VALUES (v_hash, p_question, v_answer, NOW() + INTERVAL '1 day')
    ON CONFLICT (question_hash) DO UPDATE
    SET answer = EXCLUDED.answer, expires_at = EXCLUDED.expires_at;

    RETURN v_answer;
END;
$$ LANGUAGE plpgsql;
```

### 6.3 å¹¶å‘å¤„ç†

**å¹¶å‘ä¼˜åŒ–**ï¼š

```sql
-- 1. ä½¿ç”¨è¿æ¥æ± ï¼ˆPgBouncerï¼‰
-- 2. å¼‚æ­¥å¤„ç†ï¼ˆä½¿ç”¨pg_cronï¼‰
-- 3. æ‰¹é‡å¤„ç†å‘é‡åŒ–
UPDATE knowledge_base
SET embedding = ai.embedding_openai('text-embedding-3-small', content)
WHERE embedding IS NULL
LIMIT 100;  -- æ‰¹é‡å¤„ç†
```

---

## 7. è¯„ä¼°ä¸ä¼˜åŒ–

### 7.1 å‡†ç¡®ç‡è¯„ä¼°

**ç­”æ¡ˆè´¨é‡è¯„ä¼°**ï¼š

```sql
-- 1. è®¡ç®—ç­”æ¡ˆå‡†ç¡®ç‡
SELECT
    COUNT(*) FILTER (WHERE rating >= 4)::float /
    COUNT(*) AS accuracy_rate
FROM user_feedback
WHERE created_at > NOW() - INTERVAL '7 days';

-- 2. åˆ†æå¸¸è§é—®é¢˜
SELECT
    cm.content AS question,
    COUNT(*) AS frequency,
    AVG(uf.rating) AS avg_rating
FROM conversation_messages cm
JOIN user_feedback uf ON uf.message_id = cm.id
WHERE cm.role = 'user'
GROUP BY cm.content
ORDER BY frequency DESC
LIMIT 10;
```

### 7.2 ç”¨æˆ·æ»¡æ„åº¦

**æ»¡æ„åº¦ç›‘æ§**ï¼š

```sql
-- 1. ç”¨æˆ·æ»¡æ„åº¦ç»Ÿè®¡
SELECT
    DATE(created_at) AS date,
    COUNT(*) AS total_feedback,
    AVG(rating) AS avg_rating,
    COUNT(*) FILTER (WHERE helpful = true) AS helpful_count
FROM user_feedback
WHERE created_at > NOW() - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY date DESC;
```

### 7.3 æˆæœ¬åˆ†æ

**æˆæœ¬ä¼˜åŒ–**ï¼š

```sql
-- 1. ç»Ÿè®¡LLMè°ƒç”¨æ¬¡æ•°
SELECT
    DATE(created_at) AS date,
    COUNT(*) AS llm_calls,
    COUNT(DISTINCT conversation_id) AS unique_conversations
FROM conversation_messages
WHERE role = 'assistant'
  AND created_at > NOW() - INTERVAL '7 days'
GROUP BY DATE(created_at);

-- 2. ç¼“å­˜å‘½ä¸­ç‡
SELECT
    COUNT(*) FILTER (WHERE cached = true)::float /
    COUNT(*) AS cache_hit_rate
FROM conversation_messages
WHERE created_at > NOW() - INTERVAL '1 day';
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: AI-04-05
