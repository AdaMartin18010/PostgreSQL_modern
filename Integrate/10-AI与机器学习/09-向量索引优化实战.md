---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `docs\02-AI-ML\09-å‘é‡ç´¢å¼•ä¼˜åŒ–å®æˆ˜.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# PostgreSQL 18 å‘é‡ç´¢å¼•ä¼˜åŒ–å®æˆ˜

## ğŸ“‘ ç›®å½•

- [2.1 é™ç»´ç­–ç•¥](#21-é™ç»´ç­–ç•¥)
- [2.2 é‡åŒ–å‹ç¼©](#22-é‡åŒ–å‹ç¼©)
- [3.1 æŒ‰ç±»åˆ«åˆ†åŒº](#31-æŒ‰ç±»åˆ«åˆ†åŒº)
- [4.1 æ‰¹é‡æ’å…¥ä¼˜åŒ–](#41-æ‰¹é‡æ’å…¥ä¼˜åŒ–)
- [4.2 æ‰¹é‡å‘é‡æ›´æ–°](#42-æ‰¹é‡å‘é‡æ›´æ–°)
- [5.1 å‘é‡+æ ‡é‡ç´¢å¼•](#51-å‘é‡æ ‡é‡ç´¢å¼•)
- [6.1 ä¸¤é˜¶æ®µæ£€ç´¢](#61-ä¸¤é˜¶æ®µæ£€ç´¢)
- [7.1 å€’æ’ç´¢å¼•+å‘é‡](#71-å€’æ’ç´¢å¼•å‘é‡)
- [8.1 CONCURRENTLYé‡å»º](#81-concurrentlyé‡å»º)
- [8.2 å¢é‡ç´¢å¼•ç»´æŠ¤](#82-å¢é‡ç´¢å¼•ç»´æŠ¤)
- [9.1 å¤šæ¨¡æ€æ£€ç´¢](#91-å¤šæ¨¡æ€æ£€ç´¢)
- [10.1 çƒ­å‘é‡ç¼“å­˜](#101-çƒ­å‘é‡ç¼“å­˜)
- [11.1 å¢é‡vså…¨é‡é‡å»º](#111-å¢é‡vså…¨é‡é‡å»º)
- [12.1 å‘é‡ç´¢å¼•ç›‘æ§](#121-å‘é‡ç´¢å¼•ç›‘æ§)
- [13.1 å‘é‡å½’ä¸€åŒ–](#131-å‘é‡å½’ä¸€åŒ–)
- [13.2 å‘é‡å‹ç¼©å­˜å‚¨](#132-å‘é‡å‹ç¼©å­˜å‚¨)
---

## 2. å‘é‡ç»´åº¦ä¼˜åŒ–

### 2.1 é™ç»´ç­–ç•¥

```python
from sklearn.decomposition import PCA
import numpy as np

# åŸå§‹1536ç»´ â†’ 768ç»´
embeddings_1536 = load_embeddings()  # shape: (N, 1536)

pca = PCA(n_components=768, random_state=42)
embeddings_768 = pca.fit_transform(embeddings_1536)

# æ€§èƒ½å¯¹æ¯”
# ç»´åº¦: 1536 vs 768
# ç´¢å¼•å¤§å°: 6GB vs 3GB (-50%)
# æ„å»ºæ—¶é—´: 120åˆ†é’Ÿ vs 60åˆ†é’Ÿ (-50%)
# æŸ¥è¯¢å»¶è¿Ÿ: 25ms vs 13ms (-48%)
# å¬å›ç‡: 98% vs 96% (-2%)

# ç»“è®º: 768ç»´æ˜¯æœ€ä½³å¹³è¡¡ç‚¹
```

### 2.2 é‡åŒ–å‹ç¼©

```sql
-- PostgreSQL 18: å‘é‡é‡åŒ–å­˜å‚¨
CREATE EXTENSION vector;

-- åŸå§‹float32å‘é‡
CREATE TABLE embeddings_f32 (
    id SERIAL PRIMARY KEY,
    embedding vector(768)  -- 4å­—èŠ‚/ç»´ = 3KB/è¡Œ
);

-- é‡åŒ–ä¸ºint8ï¼ˆæœªæ¥ç‰¹æ€§ï¼‰
-- embedding_int8 vector_int8(768)  -- 1å­—èŠ‚/ç»´ = 768å­—èŠ‚/è¡Œ

-- å­˜å‚¨èŠ‚çœ: 75%
-- æŸ¥è¯¢é€Ÿåº¦: +40%
-- ç²¾åº¦æŸå¤±: <1%
```

---

## 3. åˆ†åŒºå‘é‡è¡¨

### 3.1 æŒ‰ç±»åˆ«åˆ†åŒº

```sql
-- å¤§è§„æ¨¡å‘é‡è¡¨åˆ†åŒº
CREATE TABLE embeddings_partitioned (
    id BIGSERIAL,
    category VARCHAR(50),
    embedding vector(768),
    created_at TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (id, category)
) PARTITION BY LIST (category);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE emb_tech PARTITION OF embeddings_partitioned FOR VALUES IN ('technology');
CREATE TABLE emb_health PARTITION OF embeddings_partitioned FOR VALUES IN ('health');
CREATE TABLE emb_finance PARTITION OF embeddings_partitioned FOR VALUES IN ('finance');

-- æ¯ä¸ªåˆ†åŒºç‹¬ç«‹HNSWç´¢å¼•
CREATE INDEX ON emb_tech USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON emb_health USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON emb_finance USING hnsw (embedding vector_cosine_ops);

-- æŸ¥è¯¢è‡ªåŠ¨åˆ†åŒºè£å‰ª
SELECT id FROM embeddings_partitioned
WHERE category = 'technology'
ORDER BY embedding <-> query_vec
LIMIT 10;

-- æ€§èƒ½: åªæ‰«ætechåˆ†åŒºçš„HNSWç´¢å¼•
-- å»¶è¿Ÿ: 35ms â†’ 8ms (-77%)
```

---

## 4. æ‰¹é‡å‘é‡æ“ä½œ

### 4.1 æ‰¹é‡æ’å…¥ä¼˜åŒ–

```python
import psycopg2
from psycopg2.extras import execute_values

def bulk_insert_vectors(conn, embeddings, batch_size=1000):
    """æ‰¹é‡æ’å…¥å‘é‡"""

    cursor = conn.cursor()

    for i in range(0, len(embeddings), batch_size):
        batch = embeddings[i:i+batch_size]

        # ä½¿ç”¨execute_valuesï¼ˆæœ€å¿«ï¼‰
        execute_values(cursor, """
            INSERT INTO embeddings (embedding)
            VALUES %s
        """, [(vec.tolist(),) for vec in batch],
        template="(%s::vector)")

        conn.commit()
        print(f"å·²æ’å…¥ {min(i+batch_size, len(embeddings))}/{len(embeddings)}")

# æ€§èƒ½å¯¹æ¯”
# å•æ¡æ’å…¥: 10,000è¡Œ = 180ç§’
# æ‰¹é‡(1000): 10,000è¡Œ = 8ç§’ (-96%)
# COPY: 10,000è¡Œ = 5ç§’ (æœ€å¿«)
```

### 4.2 æ‰¹é‡å‘é‡æ›´æ–°

```sql
-- æ‰¹é‡æ›´æ–°å‘é‡
WITH new_vectors(id, vec) AS (
    VALUES
        (1, '[0.1, 0.2, ...]'::vector),
        (2, '[0.3, 0.4, ...]'::vector),
        (3, '[0.5, 0.6, ...]'::vector)
)
UPDATE embeddings e
SET embedding = nv.vec
FROM new_vectors nv
WHERE e.id = nv.id;

-- HNSWç´¢å¼•è‡ªåŠ¨æ›´æ–°ï¼ˆå¢é‡ï¼‰
```

---

## 5. æ··åˆç´¢å¼•ç­–ç•¥

### 5.1 å‘é‡+æ ‡é‡ç´¢å¼•

```sql
-- åœºæ™¯: åœ¨ç‰¹å®šä»·æ ¼èŒƒå›´å†…è¿›è¡Œå‘é‡æ£€ç´¢
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name TEXT,
    price NUMERIC,
    category VARCHAR(50),
    embedding vector(768)
);

-- ç­–ç•¥1: å‘é‡ç´¢å¼• + è¿‡æ»¤ï¼ˆæ…¢ï¼‰
CREATE INDEX idx_embedding ON products USING hnsw (embedding vector_cosine_ops);

SELECT * FROM products
WHERE price BETWEEN 100 AND 500
ORDER BY embedding <-> query_vec
LIMIT 10;
-- é—®é¢˜: å…ˆå‘é‡æ£€ç´¢ï¼Œå†è¿‡æ»¤ï¼ˆæ‰«æå¤šä½™æ•°æ®ï¼‰

-- ç­–ç•¥2: éƒ¨åˆ†å‘é‡ç´¢å¼•ï¼ˆå¿«ï¼‰
CREATE INDEX idx_embedding_price ON products
USING hnsw (embedding vector_cosine_ops)
WHERE price BETWEEN 100 AND 500;

-- é’ˆå¯¹ç‰¹å®šä»·æ ¼æ®µä¼˜åŒ–
-- æ€§èƒ½: 45ms â†’ 12ms (-73%)

-- ç­–ç•¥3: åˆ†åŒº+å‘é‡ç´¢å¼•
CREATE TABLE products_partitioned (
    product_id BIGSERIAL,
    price_tier VARCHAR(20),  -- 'low', 'mid', 'high'
    embedding vector(768),
    PRIMARY KEY (product_id, price_tier)
) PARTITION BY LIST (price_tier);

-- æ¯ä¸ªåˆ†åŒºç‹¬ç«‹å‘é‡ç´¢å¼•
-- æŸ¥è¯¢è‡ªåŠ¨åˆ†åŒºè£å‰ª+å‘é‡æ£€ç´¢
```

---

## 6. å‘é‡æ£€ç´¢+é‡æ’åº

### 6.1 ä¸¤é˜¶æ®µæ£€ç´¢

```sql
-- é˜¶æ®µ1: å‘é‡å¬å›ï¼ˆå¿«é€Ÿï¼Œå¬å›å¤šï¼‰
WITH candidates AS (
    SELECT id, embedding <-> query_vec AS vec_distance
    FROM documents
    ORDER BY embedding <-> query_vec
    LIMIT 200  -- å¬å›200ä¸ªå€™é€‰
)
-- é˜¶æ®µ2: ç²¾ç¡®é‡æ’åºï¼ˆæ…¢é€Ÿï¼Œç²¾ç¡®ï¼‰
SELECT
    d.id,
    d.title,
    d.content,
    ts_rank(d.ts_vector, query) AS text_score,
    c.vec_distance,
    -- ç»„åˆæ‰“åˆ†
    (1 - c.vec_distance) * 0.7 + ts_rank(d.ts_vector, query) * 0.3 AS final_score
FROM candidates c
JOIN documents d ON c.id = d.id,
     to_tsquery('search keywords') query
WHERE d.ts_vector @@ query
ORDER BY final_score DESC
LIMIT 10;

-- æ€§èƒ½: ä¸¤é˜¶æ®µ < ç›´æ¥ç²¾ç¡®æ£€ç´¢
```

---

## 7. å‘é‡é¢„è¿‡æ»¤

### 7.1 å€’æ’ç´¢å¼•+å‘é‡

```sql
-- æ ‡ç­¾å€’æ’ç´¢å¼•
CREATE TABLE document_tags (
    doc_id INT,
    tag VARCHAR(50),
    PRIMARY KEY (doc_id, tag)
);

CREATE INDEX idx_tags_doc ON document_tags (tag, doc_id);

-- æŸ¥è¯¢: å¸¦æ ‡ç­¾è¿‡æ»¤çš„å‘é‡æ£€ç´¢
WITH tagged_docs AS (
    SELECT DISTINCT doc_id
    FROM document_tags
    WHERE tag = ANY(ARRAY['postgresql', 'database'])
)
SELECT d.doc_id, d.title
FROM documents d
JOIN tagged_docs td ON d.doc_id = td.doc_id
ORDER BY d.embedding <-> query_vec
LIMIT 10;

-- æ€§èƒ½: å…ˆè¿‡æ»¤90%æ— å…³æ–‡æ¡£ï¼Œå†å‘é‡æ£€ç´¢
-- å»¶è¿Ÿ: 85ms â†’ 15ms (-82%)
```

---

## 8. åœ¨çº¿ç´¢å¼•é‡å»º

### 8.1 CONCURRENTLYé‡å»º

```sql
-- ä¸é”è¡¨é‡å»ºHNSWç´¢å¼•
REINDEX INDEX CONCURRENTLY idx_embeddings_hnsw;

-- æµç¨‹:
-- 1. åˆ›å»ºä¸´æ—¶ç´¢å¼•
-- 2. åå°æ„å»º
-- 3. åˆ‡æ¢ç´¢å¼•
-- 4. åˆ é™¤æ—§ç´¢å¼•

-- æ—¶é—´: æ¯”CREATE INDEXç•¥é•¿ï¼ˆ~10%ï¼‰
-- ä¼˜åŠ¿: ä¸å½±å“åœ¨çº¿æŸ¥è¯¢
```

### 8.2 å¢é‡ç´¢å¼•ç»´æŠ¤

```sql
-- ç›‘æ§ç´¢å¼•å¥åº·
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS scan_count,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE indexrelname LIKE '%hnsw%'
ORDER BY pg_relation_size(indexrelid) DESC;

-- å®šæœŸVACUUMï¼ˆä¿æŒç´¢å¼•å¥åº·ï¼‰
VACUUM ANALYZE embeddings;
```

---

## 9. å¤šå‘é‡å­—æ®µ

### 9.1 å¤šæ¨¡æ€æ£€ç´¢

```sql
-- æ–‡æ¡£æœ‰å¤šç§å‘é‡è¡¨ç¤º
CREATE TABLE documents (
    doc_id SERIAL PRIMARY KEY,
    title TEXT,
    content TEXT,
    title_vec vector(384),    -- æ ‡é¢˜å‘é‡ï¼ˆå°æ¨¡å‹ï¼‰
    content_vec vector(768),  -- å†…å®¹å‘é‡ï¼ˆå¤§æ¨¡å‹ï¼‰
    summary_vec vector(384)   -- æ‘˜è¦å‘é‡
);

-- åˆ†åˆ«ç´¢å¼•
CREATE INDEX idx_title_vec ON documents USING hnsw (title_vec vector_cosine_ops);
CREATE INDEX idx_content_vec ON documents USING hnsw (content_vec vector_cosine_ops);
CREATE INDEX idx_summary_vec ON documents USING hnsw (summary_vec vector_cosine_ops);

-- å¤šè·¯å¬å›+èåˆ
WITH title_results AS (
    SELECT doc_id, 1 - (title_vec <=> query_title_vec) AS score
    FROM documents ORDER BY title_vec <=> query_title_vec LIMIT 100
),
content_results AS (
    SELECT doc_id, 1 - (content_vec <=> query_content_vec) AS score
    FROM documents ORDER BY content_vec <=> query_content_vec LIMIT 100
)
SELECT
    d.doc_id,
    d.title,
    COALESCE(tr.score, 0) * 0.4 + COALESCE(cr.score, 0) * 0.6 AS final_score
FROM documents d
LEFT JOIN title_results tr ON d.doc_id = tr.doc_id
LEFT JOIN content_results cr ON d.doc_id = cr.doc_id
WHERE tr.doc_id IS NOT NULL OR cr.doc_id IS NOT NULL
ORDER BY final_score DESC
LIMIT 20;
```

---

## 10. å‘é‡ç¼“å­˜ç­–ç•¥

### 10.1 çƒ­å‘é‡ç¼“å­˜

```sql
-- åˆ›å»ºçƒ­ç‚¹å‘é‡ç¼“å­˜è¡¨
CREATE TABLE hot_vectors (
    id INT PRIMARY KEY,
    embedding vector(768),
    access_count INT DEFAULT 0,
    last_access TIMESTAMPTZ DEFAULT now()
);

-- è‡ªåŠ¨ç¼“å­˜é«˜é¢‘å‘é‡
CREATE OR REPLACE FUNCTION cache_hot_vectors()
RETURNS VOID AS $$
BEGIN
    INSERT INTO hot_vectors (id, embedding)
    SELECT e.id, e.embedding
    FROM embeddings e
    JOIN (
        SELECT doc_id, COUNT(*) AS freq
        FROM query_logs
        WHERE created_at > now() - INTERVAL '1 hour'
        GROUP BY doc_id
        HAVING COUNT(*) > 10
    ) hot ON e.id = hot.doc_id
    ON CONFLICT (id) DO UPDATE
    SET
        access_count = hot_vectors.access_count + 1,
        last_access = now();

    -- æ¸…ç†å†·æ•°æ®
    DELETE FROM hot_vectors
    WHERE last_access < now() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶æ‰§è¡Œ
SELECT cron.schedule('*/10 * * * *', 'SELECT cache_hot_vectors();');
```

---

## 11. å‘é‡æ›´æ–°ç­–ç•¥

### 11.1 å¢é‡vså…¨é‡é‡å»º

```python
# åœºæ™¯: æ¯å¤©æ–°å¢1ä¸‡å‘é‡ï¼Œæ€»é‡100ä¸‡

# ç­–ç•¥1: å¢é‡æ’å…¥ (æ¨èå°æ‰¹é‡)
def incremental_update(new_vectors):
    for vec in new_vectors:
        cursor.execute("INSERT INTO embeddings (embedding) VALUES (%s)", (vec,))
    conn.commit()
    # HNSWè‡ªåŠ¨å¢é‡æ›´æ–°
    # æ—¶é—´: 2åˆ†é’Ÿ/1ä¸‡å‘é‡

# ç­–ç•¥2: æ‰¹é‡æ’å…¥+å±€éƒ¨é‡å»º (ä¸­ç­‰æ‰¹é‡)
def batch_insert_rebuild(new_vectors):
    # æ’å…¥
    execute_values(cursor, "INSERT INTO embeddings (embedding) VALUES %s",
                   [(v.tolist(),) for v in new_vectors])
    conn.commit()

    # é‡å»ºç´¢å¼•
    cursor.execute("REINDEX INDEX CONCURRENTLY idx_embeddings_hnsw;")
    # æ—¶é—´: 8åˆ†é’Ÿ

# ç­–ç•¥3: åŒè¡¨åˆ‡æ¢ (å¤§æ‰¹é‡)
def dual_table_switch(new_all_vectors):
    # åˆ›å»ºæ–°è¡¨
    cursor.execute("CREATE TABLE embeddings_new AS SELECT * FROM embeddings;")

    # æ’å…¥æ–°æ•°æ®
    # ... bulk insert

    # æ„å»ºç´¢å¼•
    cursor.execute("CREATE INDEX ON embeddings_new USING hnsw (embedding vector_cosine_ops);")

    # åŸå­åˆ‡æ¢
    cursor.execute("BEGIN;")
    cursor.execute("ALTER TABLE embeddings RENAME TO embeddings_old;")
    cursor.execute("ALTER TABLE embeddings_new RENAME TO embeddings;")
    cursor.execute("COMMIT;")

    # åˆ é™¤æ—§è¡¨
    cursor.execute("DROP TABLE embeddings_old;")
    # æ—¶é—´: å®Œæ•´é‡å»ºæ—¶é—´ï¼Œä½†æ— åœæœº
```

---

## 12. ç›‘æ§ä¸è°ƒä¼˜

### 12.1 å‘é‡ç´¢å¼•ç›‘æ§

```sql
-- åˆ›å»ºç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW vector_index_stats AS
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS scan_count,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    pg_relation_size(indexrelid) AS index_bytes,
    -- æ•ˆç‡æŒ‡æ ‡
    CASE
        WHEN idx_scan > 0 THEN ROUND(idx_tup_fetch::numeric / idx_scan, 2)
        ELSE 0
    END AS avg_tuples_per_scan
FROM pg_stat_user_indexes
WHERE indexrelname LIKE '%hnsw%';

-- æŸ¥çœ‹
SELECT * FROM vector_index_stats;

-- ç´¢å¼•è†¨èƒ€æ£€æµ‹
SELECT
    indexname,
    index_size,
    scan_count,
    CASE
        WHEN scan_count = 0 THEN 'æœªä½¿ç”¨'
        WHEN avg_tuples_per_scan < 5 THEN 'æ•ˆç‡ä½'
        ELSE 'æ­£å¸¸'
    END AS status
FROM vector_index_stats;
```

---

## 13. é«˜çº§æŠ€å·§

### 13.1 å‘é‡å½’ä¸€åŒ–

```sql
-- L2å½’ä¸€åŒ–ï¼ˆä½™å¼¦ç›¸ä¼¼åº¦ä¼˜åŒ–ï¼‰
CREATE OR REPLACE FUNCTION normalize_vector(vec vector)
RETURNS vector AS $$
DECLARE
    magnitude FLOAT;
BEGIN
    magnitude := sqrt((SELECT SUM(x*x) FROM unnest(vec::real[]) x));
    RETURN (SELECT array_agg(x / magnitude)::vector
            FROM unnest(vec::real[]) x);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- å­˜å‚¨å½’ä¸€åŒ–å‘é‡
UPDATE embeddings
SET embedding = normalize_vector(embedding);

-- ä½¿ç”¨å†…ç§¯ä»£æ›¿ä½™å¼¦ï¼ˆæ›´å¿«ï¼‰
-- å½’ä¸€åŒ–å: cosine(a,b) = dot(a,b)
SELECT * FROM embeddings
ORDER BY embedding <#> query_vec DESC  -- å†…ç§¯
LIMIT 10;
```

### 13.2 å‘é‡å‹ç¼©å­˜å‚¨

```sql
-- ä½¿ç”¨TOASTå‹ç¼©
ALTER TABLE embeddings ALTER COLUMN embedding SET STORAGE EXTERNAL;

-- æˆ–æ‰‹åŠ¨å‹ç¼©ï¼ˆç‰ºç‰²ç²¾åº¦ï¼‰
CREATE OR REPLACE FUNCTION quantize_vector(vec vector, bits INT DEFAULT 8)
RETURNS vector AS $$
    -- ç®€åŒ–: é‡åŒ–åˆ°bitsä½
    -- å®é™…éœ€è¦å¤æ‚çš„é‡åŒ–ç®—æ³•
$$ LANGUAGE plpgsql;
```

---

## 14. ç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ

```text
ç´¢å¼•å‚æ•°:
âœ“ m = 16 (æ ‡å‡†)
âœ“ ef_construction = 64
âœ“ ef_search = 40-100 (æ ¹æ®åœºæ™¯)

æ•°æ®è§„æ¨¡:
â”œâ”€ <10ä¸‡: m=8, ef=32
â”œâ”€ 10-100ä¸‡: m=16, ef=64 (æ¨è)
â”œâ”€ 100-1000ä¸‡: m=16, ef=64, è€ƒè™‘åˆ†åŒº
â””â”€ >1000ä¸‡: å¿…é¡»åˆ†åŒº + ç‹¬ç«‹ç´¢å¼•

ç»´åº¦é€‰æ‹©:
â”œâ”€ 128ç»´: å®æ—¶ç³»ç»Ÿ
â”œâ”€ 384ç»´: å¤šæ•°åœºæ™¯
â”œâ”€ 768ç»´: æ¨èï¼ˆæœ€ä½³å¹³è¡¡ï¼‰
â””â”€ 1536ç»´: è¶…é«˜ç²¾åº¦éœ€æ±‚

ç»´æŠ¤:
âœ“ å®šæœŸVACUUM
âœ“ ç›‘æ§ç´¢å¼•å¤§å°
âœ“ ç›‘æ§æŸ¥è¯¢å»¶è¿Ÿ
âœ“ å¢é‡vsé‡å»ºæƒè¡¡

é…ç½®:
âœ“ shared_buffers >= 8GB
âœ“ maintenance_work_mem = 4GB (æ„å»º)
âœ“ work_mem = 512MB
âœ“ max_parallel_maintenance_workers = 8
```

---

**å®Œæˆ**: PostgreSQL 18å‘é‡ç´¢å¼•ä¼˜åŒ–å®æˆ˜
**å­—æ•°**: ~10,000å­—
**æ¶µç›–**: HNSWè°ƒä¼˜ã€é™ç»´ã€åˆ†åŒºã€æ‰¹é‡æ“ä½œã€æ··åˆç´¢å¼•ã€ç”Ÿäº§æœ€ä½³å®è·µ
