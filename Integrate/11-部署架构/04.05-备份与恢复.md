---

> **📋 文档来源**: `PostgreSQL\04-部署运维\04.05-备份与恢复.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL备份与恢复完整指南

> **版本**: v3.0
> **最后更新**: 2025-01-15
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **难度**: ⭐⭐⭐⭐
> **应用场景**: 生产环境备份、灾难恢复、数据迁移、合规要求
> 🆕 **PostgreSQL 18 新特性**
>
> PostgreSQL 18引入了**增量备份**功能，可显著减少备份时间（最多95%）和存储空间（最多99%），这是生产环境的重大改进！

---

## 📑 目录

- [PostgreSQL备份与恢复完整指南](#postgresql备份与恢复完整指南)
  - [📑 目录](#-目录)
  - [一、概述](#一概述)
    - [1.1 备份的重要性](#11-备份的重要性)
    - [1.2 备份策略总览](#12-备份策略总览)
    - [1.3 RPO与RTO](#13-rpo与rto)
  - [二、备份策略选择](#二备份策略选择)
    - [2.1 备份类型对比](#21-备份类型对比)
    - [2.2 策略选择指南](#22-策略选择指南)
    - [1.1 备份策略选择](#11-备份策略选择)
  - [三、逻辑备份](#三逻辑备份)
    - [3.1 pg\_dump使用](#31-pg_dump使用)
    - [3.2 pg\_restore使用](#32-pg_restore使用)
    - [3.3 逻辑备份最佳实践](#33-逻辑备份最佳实践)
  - [四、物理备份与WAL归档](#四物理备份与wal归档)
    - [4.1 物理备份基础](#41-物理备份基础)
    - [4.2 WAL归档配置](#42-wal归档配置)
    - [4.3 pg\_basebackup使用](#43-pg_basebackup使用)
  - [五、增量备份（PostgreSQL 18新特性）](#五增量备份postgresql-18新特性)
    - [5.1 功能说明](#51-功能说明)
    - [5.2 基本使用](#52-基本使用)
    - [5.3 生产环境备份策略](#53-生产环境备份策略)
      - [策略A：周全量 + 日增量](#策略a周全量--日增量)
      - [策略B：月全量 + 日增量](#策略b月全量--日增量)
    - [5.4 性能对比](#54-性能对比)
    - [5.5 恢复流程](#55-恢复流程)
    - [5.6 监控与告警](#56-监控与告警)
    - [5.7 最佳实践](#57-最佳实践)
      - [✅ DO - 推荐做法](#-do---推荐做法)
      - [❌ DON'T - 避免做法](#-dont---避免做法)
    - [5.8 故障排查](#58-故障排查)
      - [问题1: 增量备份失败](#问题1-增量备份失败)
      - [问题2: 恢复时缺少中间备份](#问题2-恢复时缺少中间备份)
      - [问题3: 存储空间不足](#问题3-存储空间不足)
    - [5.9 生产案例](#59-生产案例)
      - [案例：电商平台（5TB数据库）](#案例电商平台5tb数据库)
  - [六、时间点恢复（PITR）](#六时间点恢复pitr)
    - [6.1 PITR原理](#61-pitr原理)
    - [6.2 PITR配置](#62-pitr配置)
    - [6.3 PITR恢复流程](#63-pitr恢复流程)
  - [七、灾备与演练](#七灾备与演练)
    - [7.1 灾备架构](#71-灾备架构)
    - [7.2 演练SOP](#72-演练sop)
  - [八、知识矩阵对比](#八知识矩阵对比)
    - [8.1 备份方案对比](#81-备份方案对比)
    - [8.2 恢复时间对比](#82-恢复时间对比)
  - [九、合规与安全](#九合规与安全)
    - [9.1 备份加密](#91-备份加密)
    - [9.2 访问控制](#92-访问控制)
    - [9.3 审计与合规](#93-审计与合规)
  - [十、实践案例](#十实践案例)
    - [10.1 案例1：小型数据库备份](#101-案例1小型数据库备份)
    - [10.2 案例2：大型数据库备份](#102-案例2大型数据库备份)
    - [10.3 案例3：跨版本迁移](#103-案例3跨版本迁移)
  - [十一、最佳实践](#十一最佳实践)
    - [11.1 备份最佳实践](#111-备份最佳实践)
    - [11.2 恢复最佳实践](#112-恢复最佳实践)
  - [十二、参考资源](#十二参考资源)
    - [12.1 官方文档](#121-官方文档)
    - [12.2 相关文档](#122-相关文档)
  - [十三、参考文献](#十三参考文献)

---

## 一、概述

### 1.1 备份的重要性

**备份是数据安全的最后一道防线**：

- **数据保护**：防止数据丢失
- **灾难恢复**：快速恢复业务
- **合规要求**：满足法规要求
- **版本迁移**：支持数据库升级

### 1.2 备份策略总览

**主要备份类型**：

- **逻辑备份**：`pg_dump/pg_restore`，适合结构迁移与小中规模数据
- **物理备份**：`pg_basebackup` + WAL 归档，适合大规模与PITR
- **增量备份** (⭐ PostgreSQL 18新增)：仅备份变更数据，大幅减少备份时间和存储

### 1.3 RPO与RTO

**恢复目标**：

- **RPO（Recovery Point Objective）**：可接受的数据丢失时间窗口
- **RTO（Recovery Time Objective）**：系统恢复所需的时间

**典型SLA**：

| 业务类型 | RPO | RTO | 备份策略 |
|---------|-----|-----|---------|
| 关键业务 | <1小时 | <4小时 | 增量备份 + WAL归档 |
| 一般业务 | <24小时 | <8小时 | 日全量 + WAL归档 |
| 非关键业务 | <7天 | <24小时 | 周全量备份 |

## 二、备份策略选择

### 2.1 备份类型对比

| 备份类型 | 适用场景 | 备份时间 | 恢复时间 | 存储空间 | PostgreSQL版本 |
|---------|---------|---------|---------|---------|--------------|
| 逻辑备份 | 小型数据库(<100GB) | 中等 | 慢 | 中等 | 所有版本 |
| 物理全量备份 | 中大型数据库 | 长 | 快 | 大 | 所有版本 |
| **增量备份** | **大型数据库(>500GB)** | **极快** ⭐ | **快** | **极小** ⭐ | **18+** |
| WAL归档 | PITR需求 | 持续 | 快 | 持续增长 | 所有版本 |

### 2.2 策略选择指南

**选择逻辑**：

1. **数据库大小**：<100GB用逻辑备份，>100GB用物理备份
2. **RPO要求**：<1小时需要WAL归档
3. **存储成本**：考虑增量备份节省空间
4. **恢复速度**：物理备份恢复更快

### 1.1 备份策略选择

| 备份类型 | 适用场景 | 备份时间 | 恢复时间 | 存储空间 | PostgreSQL版本 |
|---------|---------|---------|---------|---------|--------------|
| 逻辑备份 | 小型数据库(<100GB) | 中等 | 慢 | 中等 | 所有版本 |
| 物理全量备份 | 中大型数据库 | 长 | 快 | 大 | 所有版本 |
| **增量备份** | **大型数据库(>500GB)** | **极快** ⭐ | **快** | **极小** ⭐ | **18+** |
| WAL归档 | PITR需求 | 持续 | 快 | 持续增长 | 所有版本 |

## 三、逻辑备份

### 3.1 pg_dump使用

**基本用法**：

```bash
# 单库逻辑备份（自定义格式，支持并行）
pg_dump -h <host> -U <user> -F c -j 4 -d mydb -f mydb_$(date +%F).dump

# 全库备份
pg_dumpall -h <host> -U <user> -f all_databases_$(date +%F).sql

# 仅备份结构
pg_dump -h <host> -U <user> -F c -s -d mydb -f mydb_schema.dump

# 仅备份数据
pg_dump -h <host> -U <user> -F c -a -d mydb -f mydb_data.dump

# 压缩备份
pg_dump -h <host> -U <user> -F c -Z 9 -d mydb -f mydb_$(date +%F).dump
```

**高级选项**：

```bash
# 排除特定表
pg_dump -h <host> -U <user> -F c -d mydb \
  --exclude-table=temp_table \
  --exclude-table=log_table \
  -f mydb_filtered.dump

# 仅备份特定表
pg_dump -h <host> -U <user> -F c -d mydb \
  -t users -t orders \
  -f mydb_tables.dump
```

### 3.2 pg_restore使用

**基本用法**：

```bash
# 还原到新数据库
pg_restore -h <host> -U <user> -j 4 -d mydb_restored mydb_2025-09-11.dump

# 仅还原结构
pg_restore -h <host> -U <user> -s -d mydb_restored mydb.dump

# 仅还原数据
pg_restore -h <host> -U <user> -a -d mydb_restored mydb.dump

# 列出备份内容
pg_restore -l mydb.dump > backup_list.txt
```

### 3.3 逻辑备份最佳实践

**推荐做法**：

1. **使用自定义格式**：支持并行、压缩、选择性恢复
2. **并行备份**：使用`-j`参数提高备份速度
3. **压缩备份**：使用`-Z`参数减少存储空间
4. **定期验证**：定期测试恢复流程

## 四、物理备份与WAL归档

### 4.1 物理备份基础

**物理备份特点**：

- 备份速度快（文件级复制）
- 恢复速度快
- 支持PITR
- 备份文件大

### 4.2 WAL归档配置

**postgresql.conf配置**：

```text
# 启用归档
archive_mode = on
archive_command = 'test ! -f /arch/%f && cp %p /arch/%f'

# WAL级别
wal_level = replica

# 最大WAL发送进程
max_wal_senders = 10

# WAL保留时间
wal_keep_size = 1GB
```

**归档脚本示例**：

```bash
#!/bin/bash
# archive_command.sh

ARCHIVE_DIR="/archive"
WAL_FILE=$1
WAL_NAME=$2

# 复制WAL文件
cp "$WAL_FILE" "$ARCHIVE_DIR/$WAL_NAME"

# 压缩旧WAL文件（可选）
find "$ARCHIVE_DIR" -name "*.wal" -mtime +7 -exec gzip {} \;

# 清理旧归档（保留30天）
find "$ARCHIVE_DIR" -name "*.gz" -mtime +30 -delete
```

### 4.3 pg_basebackup使用

**基本用法**：

```bash
# 基础备份（在线）
pg_basebackup -h <primary> -U repl -D /data/basebackup -X stream -P -R

# 压缩备份
pg_basebackup -h <primary> -U repl -D /data/basebackup \
  -F tar -z -P -R

# 快速检查点
pg_basebackup -h <primary> -U repl -D /data/basebackup \
  --checkpoint=fast -P -R
```

**参数说明**：

- `-X stream`：同时备份WAL文件
- `-P`：显示进度
- `-R`：创建recovery配置
- `-F tar`：tar格式输出
- `-z`：压缩输出

## 五、增量备份（PostgreSQL 18新特性）

⭐⭐⭐ **PostgreSQL 18最重要的生产特性之一**

### 5.1 功能说明

增量备份允许仅备份自上次备份以来更改的数据块，而不是整个数据库。这显著减少：

- ✅ 备份时间：从45分钟降至2-5分钟（90%+提升）
- ✅ 存储空间：节省90-99%的备份存储
- ✅ 网络传输：减少95%+的网络带宽
- ✅ I/O压力：降低对生产系统的影响

### 5.2 基本使用

```bash
# PostgreSQL 17+

# ============================================================
# 步骤1: 创建全量备份
# ============================================================
pg_basebackup -D /backup/base/2025-10-30-full \
  -F tar \
  -z \
  -P \
  --checkpoint=fast

# 备份时间（示例）：1TB数据库约45分钟
# 存储空间：~1TB（压缩后约600GB）

# ============================================================
# 步骤2: 创建第一个增量备份（周一）
# ============================================================
pg_basebackup -D /backup/incremental/2025-10-31-inc1 \
  --incremental=/backup/base/2025-10-30-full/backup_manifest \
  -F tar \
  -z \
  -P

# 备份时间：约2-5分钟 ⭐
# 存储空间：约10-50GB（仅变更部分）⭐

# ============================================================
# 步骤3: 创建第二个增量备份（周二）
# ============================================================
pg_basebackup -D /backup/incremental/2025-11-01-inc2 \
  --incremental=/backup/incremental/2025-10-31-inc1/backup_manifest \
  -F tar \
  -z \
  -P

# 可以基于任何已有备份创建增量

# ============================================================
# 步骤4: 恢复（需要全量+所有增量）
# ============================================================

# 4.1 合并备份
pg_combinebackup \
  /backup/base/2025-10-30-full \
  /backup/incremental/2025-10-31-inc1 \
  /backup/incremental/2025-11-01-inc2 \
  -o /restore/combined

# 4.2 启动恢复
pg_ctl -D /restore/combined start

# 或直接解压到数据目录
cd $PGDATA
tar -xzf /restore/combined/*.tar.gz
pg_ctl start
```

### 5.3 生产环境备份策略

#### 策略A：周全量 + 日增量

```bash
#!/bin/bash
# backup_strategy_weekly.sh

BACKUP_ROOT="/backup/postgresql"
TODAY=$(date +%Y-%m-%d)
DAY_OF_WEEK=$(date +%u)  # 1=Monday, 7=Sunday

if [ "$DAY_OF_WEEK" -eq 7 ]; then
    # Sunday: 全量备份
    echo "Performing full backup..."
    pg_basebackup -D "$BACKUP_ROOT/full/$TODAY" \
      -F tar -z -P --checkpoint=fast

    echo "$BACKUP_ROOT/full/$TODAY" > "$BACKUP_ROOT/latest_full.txt"
else
    # Monday-Saturday: 增量备份
    echo "Performing incremental backup..."
    LATEST_FULL=$(cat "$BACKUP_ROOT/latest_full.txt")

    # 找到最近的备份（全量或增量）
    LATEST_BACKUP=$(ls -td "$BACKUP_ROOT"/*/* | head -1)

    pg_basebackup -D "$BACKUP_ROOT/incremental/$TODAY" \
      --incremental="$LATEST_BACKUP/backup_manifest" \
      -F tar -z -P
fi

# 清理超过30天的备份
find "$BACKUP_ROOT" -type d -mtime +30 -exec rm -rf {} \;
```

**效果**：

- 周日全量：45分钟
- 周一-六增量：每次2-5分钟
- **每周总备份时间**：从315分钟（7×45）降至75分钟 ⭐
- **节省时间**：76% ⭐⭐⭐

#### 策略B：月全量 + 日增量

```text
1号: 全量备份（45分钟）
2-31号: 增量备份（每次2-5分钟）

每月总备份时间: 45 + 30×5 = 195分钟
vs 传统全量: 31×45 = 1395分钟

节省时间: 86% ⭐⭐⭐
存储节省: 90% ⭐⭐⭐
```

### 5.4 性能对比

| 场景 | 数据库大小 | 每日变更 | 全量备份 | 增量备份 | 时间节省 | 空间节省 |
|------|-----------|---------|---------|---------|---------|---------|
| 小型OLTP | 100GB | 1% | 5分钟 | 30秒 | 90% ⭐ | 99% ⭐ |
| 中型应用 | 500GB | 2% | 25分钟 | 2分钟 | 92% ⭐ | 98% ⭐ |
| 大型系统 | 1TB | 1% | 45分钟 | 2分钟 | 95% ⭐⭐⭐ | 99% ⭐⭐⭐ |
| 超大系统 | 5TB | 0.5% | 240分钟 | 5分钟 | 98% ⭐⭐⭐ | 99.5% ⭐⭐⭐ |

### 5.5 恢复流程

```bash
# ============================================================
# 场景：需要恢复到最新状态
# 备份链：Full → Inc1 → Inc2 → Inc3
# ============================================================

# 步骤1: 合并所有备份
pg_combinebackup \
  /backup/full/2025-10-27-full \
  /backup/inc/2025-10-28-inc1 \
  /backup/inc/2025-10-29-inc2 \
  /backup/inc/2025-10-30-inc3 \
  -o /restore/combined \
  --progress

# 步骤2: 停止当前实例（如果运行中）
pg_ctl -D $PGDATA stop -m fast

# 步骤3: 备份当前数据目录（可选但推荐）
mv $PGDATA $PGDATA.old

# 步骤4: 解压合并的备份
mkdir $PGDATA
cd $PGDATA
for tarfile in /restore/combined/*.tar.gz; do
    tar -xzf "$tarfile"
done

# 步骤5: 设置权限
chmod 700 $PGDATA

# 步骤6: 配置recovery（如需PITR）
cat >> postgresql.conf << EOF
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2025-10-30 14:30:00+00'
EOF

# 步骤7: 启动并验证
pg_ctl -D $PGDATA start

# 验证
psql -c "SELECT pg_last_wal_replay_lsn(), now();"
psql -c "SELECT count(*) FROM critical_table;"
```

### 5.6 监控与告警

```sql
-- 创建备份监控视图

CREATE OR REPLACE VIEW backup_status AS
SELECT
    'full' AS backup_type,
    pg_stat_file('/backup/base/latest/backup_manifest').modification AS last_backup,
    EXTRACT(EPOCH FROM (now() - pg_stat_file('/backup/base/latest/backup_manifest').modification)) / 3600 AS hours_since_backup
UNION ALL
SELECT
    'incremental' AS backup_type,
    pg_stat_file('/backup/inc/latest/backup_manifest').modification AS last_backup,
    EXTRACT(EPOCH FROM (now() - pg_stat_file('/backup/inc/latest/backup_manifest').modification)) / 3600 AS hours_since_backup;

-- 告警查询（备份超过24小时）
SELECT * FROM backup_status WHERE hours_since_backup > 24;
```

```bash
# 监控脚本
#!/bin/bash
# monitor_backups.sh

BACKUP_ROOT="/backup/postgresql"

# 检查最近的增量备份
LAST_INC=$(find "$BACKUP_ROOT/incremental" -type f -name "backup_manifest" -mtime 0 | wc -l)

if [ "$LAST_INC" -eq 0 ]; then
    echo "CRITICAL: No incremental backup in last 24 hours"
    # 发送告警
    exit 2
fi

# 检查备份链完整性
FULL=$(cat "$BACKUP_ROOT/latest_full.txt")
if [ ! -f "$FULL/backup_manifest" ]; then
    echo "CRITICAL: Full backup manifest missing"
    exit 2
fi

echo "OK: Backup status normal"
exit 0
```

### 5.7 最佳实践

#### ✅ DO - 推荐做法

1. **定期全量备份**

   ```bash
   # 每周或每月创建新的全量备份
   # 避免增量链过长
   ```

2. **验证备份**

   ```bash
   # 定期测试恢复流程
   pg_combinebackup --check-only <backups>
   ```

3. **监控备份链**

   ```bash
   # 确保所有backup_manifest文件存在且有效
   find /backup -name "backup_manifest" -exec pg_verifybackup {} \;
   ```

4. **异地存储**

   ```bash
   # 将备份同步到另一个位置
   rsync -avz /backup/ remote:/backup-mirror/
   ```

#### ❌ DON'T - 避免做法

1. ❌ 不要删除中间的增量备份（会破坏备份链）
2. ❌ 不要让增量链超过7-10层（恢复时间会增加）
3. ❌ 不要在没有验证的情况下依赖单一备份链
4. ❌ 不要忽略backup_manifest文件（恢复必需）

### 5.8 故障排查

#### 问题1: 增量备份失败

```bash
# 错误: could not open file "backup_manifest": No such file
# 原因: 基础备份的manifest文件不存在

# 解决方法1: 检查文件是否存在
ls -l /backup/base/*/backup_manifest

# 解决方法2: 重新创建全量备份
pg_basebackup -D /backup/base/$(date +%F) -F tar -z
```

#### 问题2: 恢复时缺少中间备份

```bash
# 错误: incremental backup depends on missing backup
# 原因: 备份链不完整

# 解决方法: 使用完整的备份链
# Full → Inc1 → Inc2 → Inc3
# 不能跳过Inc1和Inc2直接恢复Inc3
```

#### 问题3: 存储空间不足

```bash
# 错误: No space left on device
# 原因: 备份目录空间不足

# 解决方法: 清理旧备份
find /backup -type d -mtime +30 -exec rm -rf {} \;

# 或使用更高效的压缩
pg_basebackup -D /backup/inc/$(date +%F) \
  --incremental=... \
  -F tar -z --compress=9  # 最高压缩率
```

### 5.9 生产案例

#### 案例：电商平台（5TB数据库）

**背景**：

- 数据库大小：5TB
- 每日数据变更：约1%（50GB）
- 传统全量备份：4小时
- 备份窗口：凌晨2-6点

**传统方案（PostgreSQL 16）**：

```text
每日全量备份: 4小时
每周总时间: 7 × 4 = 28小时
存储空间: 7 × 5TB = 35TB
```

**增量方案（PostgreSQL 17）**：

```text
周日全量: 4小时
周一-六增量: 每次10分钟

每周总时间: 4 + 6×0.167 = 5小时
存储空间: 5TB + 6×50GB = 5.3TB

时间节省: 82% ⭐⭐⭐
空间节省: 85% ⭐⭐⭐
```

**实际效果**：

- ✅ 每日备份在10分钟内完成，不影响业务
- ✅ 存储成本降低80%
- ✅ 备份成功率从92%提升到99.8%（因为时间窗口充足）
- ✅ 恢复测试时间缩短（备份更频繁更新鲜）

---

## 六、时间点恢复（PITR）

### 6.1 PITR原理

**PITR（Point-In-Time Recovery）**允许恢复到任意时间点：

1. 从基础备份恢复
2. 应用WAL归档文件
3. 恢复到指定时间点

### 6.2 PITR配置

**恢复配置**：

```bash
# 停库并准备恢复环境
rm -rf $PGDATA/*
cp -a /data/basebackup/* $PGDATA/

# recovery 配置（PostgreSQL 12+）在 postgresql.conf 中：
restore_command = 'cp /arch/%f %p'
recovery_target_time = '2025-09-11 10:15:00+00'
recovery_target_action = 'promote'

# 启动并回放到目标时间后自动提升
pg_ctl -D $PGDATA start
```

**恢复目标选项**：

- `recovery_target_time`：恢复到指定时间
- `recovery_target_lsn`：恢复到指定LSN
- `recovery_target_name`：恢复到指定恢复点
- `recovery_target_xid`：恢复到指定事务ID

### 6.3 PITR恢复流程

**步骤**：

1. 准备基础备份
2. 配置恢复参数
3. 启动数据库
4. 验证数据一致性
5. 清理恢复参数

**验证**：

```sql
-- 检查恢复状态
SELECT pg_last_wal_replay_lsn(), now();

-- 验证数据
SELECT count(*) FROM critical_table;
```

## 七、灾备与演练

### 7.1 灾备架构

**级联复制**：

```text
Primary → Standby1 → Standby2
```

**配置示例**：

```text
# Standby1配置
primary_conninfo = 'host=primary port=5432 user=repl'
primary_slot_name = 'standby1_slot'

# Standby2配置
primary_conninfo = 'host=standby1 port=5432 user=repl'
primary_slot_name = 'standby2_slot'
```

### 7.2 演练SOP

**演练步骤**：

1. 选择近一次基线备份 + WAL
2. 搭建恢复环境并执行PITR
3. 校验一致性与完整性
4. 评估RTO/RPO，记录偏差并改进配置

**演练脚本**：

```bash
#!/bin/bash
# disaster_recovery_drill.sh

BACKUP_DIR="/backup/postgresql"
RESTORE_DIR="/restore/test"

# 选择最新备份
LATEST_BACKUP=$(ls -td "$BACKUP_DIR"/* | head -1)

# 恢复备份
pg_combinebackup "$LATEST_BACKUP" -o "$RESTORE_DIR"

# 配置恢复
cp "$RESTORE_DIR"/* $PGDATA/

# 启动数据库
pg_ctl -D $PGDATA start

# 验证
psql -c "SELECT count(*) FROM critical_table;"
```

## 八、知识矩阵对比

### 8.1 备份方案对比

| 方案 | 备份时间 | 恢复时间 | 存储空间 | RPO | RTO | 适用场景 |
|------|---------|---------|---------|-----|-----|---------|
| 逻辑备份 | 中 | 慢 | 中 | 24小时 | 4-8小时 | 小型数据库 |
| 物理全量 | 长 | 快 | 大 | 1小时 | 1-2小时 | 中大型数据库 |
| 增量备份 | 极快 | 快 | 极小 | 1小时 | 1-2小时 | 大型数据库 |
| WAL归档 | 持续 | 快 | 持续增长 | <1小时 | <1小时 | 关键业务 |

### 8.2 恢复时间对比

| 数据库大小 | 逻辑备份恢复 | 物理备份恢复 | 增量备份恢复 |
|-----------|------------|------------|------------|
| 100GB | 2-4小时 | 30-60分钟 | 30-60分钟 |
| 500GB | 8-12小时 | 1-2小时 | 1-2小时 |
| 1TB | 16-24小时 | 2-4小时 | 2-4小时 |
| 5TB | 不可行 | 8-12小时 | 8-12小时 |

## 九、合规与安全

### 9.1 备份加密

**传输加密**：

```bash
# 使用SSL连接
pg_dump -h <host> -U <user> -d mydb \
  "sslmode=require" \
  -f mydb.dump
```

**静态加密**：

```bash
# 备份后加密
pg_dump -h <host> -U <user> -d mydb -f - | \
  gpg --encrypt --recipient backup@example.com > mydb.dump.gpg

# 恢复时解密
gpg --decrypt mydb.dump.gpg | \
  pg_restore -h <host> -U <user> -d mydb
```

### 9.2 访问控制

**备份文件权限**：

```bash
# 设置备份文件权限
chmod 600 /backup/postgresql/*
chown postgres:postgres /backup/postgresql/*
```

### 9.3 审计与合规

**备份审计**：

```sql
-- 记录备份操作
CREATE TABLE backup_audit (
    id SERIAL PRIMARY KEY,
    backup_type VARCHAR(50),
    backup_path TEXT,
    backup_size BIGINT,
    backup_time TIMESTAMPTZ DEFAULT NOW(),
    operator VARCHAR(100)
);
```

## 十、实践案例

### 10.1 案例1：小型数据库备份

**场景**：100GB数据库，每日备份

**方案**：逻辑备份

```bash
# 每日备份脚本
pg_dump -h localhost -U postgres -F c -Z 9 \
  -d mydb -f /backup/mydb_$(date +%F).dump

# 清理30天前的备份
find /backup -name "*.dump" -mtime +30 -delete
```

### 10.2 案例2：大型数据库备份

**场景**：5TB数据库，需要快速备份

**方案**：增量备份

```bash
# 周日全量备份
pg_basebackup -D /backup/full/$(date +%F) \
  -F tar -z -P --checkpoint=fast

# 每日增量备份
pg_basebackup -D /backup/inc/$(date +%F) \
  --incremental=/backup/latest/backup_manifest \
  -F tar -z -P
```

### 10.3 案例3：跨版本迁移

**场景**：从PostgreSQL 14升级到18

**方案**：逻辑备份 + pg_upgrade

```bash
# 逻辑备份
pg_dumpall -h old_host -U postgres -f backup.sql

# 在新版本恢复
psql -h new_host -U postgres -f backup.sql
```

## 十一、最佳实践

### 11.1 备份最佳实践

1. **3-2-1规则**：3份备份，2种介质，1份异地
2. **定期验证**：定期测试恢复流程
3. **自动化备份**：使用cron或调度系统
4. **监控告警**：监控备份状态和存储空间
5. **文档记录**：记录备份策略和恢复流程

### 11.2 恢复最佳实践

1. **准备恢复环境**：提前准备恢复环境
2. **测试恢复流程**：定期演练恢复流程
3. **验证数据完整性**：恢复后验证数据
4. **记录恢复过程**：记录恢复时间和问题
5. **持续改进**：根据演练结果改进流程

## 十二、参考资源

### 12.1 官方文档

- [PostgreSQL 18 Backup Documentation](https://www.postgresql.org/docs/18/backup.html)
- [pg_basebackup Documentation](https://www.postgresql.org/docs/18/app-pgbasebackup.html)
- [pg_combinebackup Documentation](https://www.postgresql.org/docs/18/app-pgcombinebackup.html)
- [pg_dump Documentation](https://www.postgresql.org/docs/18/app-pgdump.html)

### 12.2 相关文档

- [PostgreSQL 18新特性](../18-版本特性/02.01-PostgreSQL-18-新特性.md) - 增量备份详解
- [存储管理与数据持久化](../04-存储与恢复/01.06-存储管理与数据持久化.md) - WAL机制
- [单机部署与配置](./04.01-单机部署与配置.md) - 初始配置
- [监控与诊断](./04.04-监控与诊断.md) - 备份监控
- [集群部署与高可用](./04.02-集群部署与高可用.md) - 复制与备用库

---

## 十三、参考文献

1. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
2. PostgreSQL官方文档 - [备份与恢复](https://www.postgresql.org/docs/current/backup.html)
3. PostgreSQL官方文档 - [pg_basebackup](https://www.postgresql.org/docs/current/app-pgbasebackup.html)
4. PostgreSQL官方文档 - [pg_combinebackup](https://www.postgresql.org/docs/current/app-pgcombinebackup.html)

---

**最后更新**: 2025-01-15
**维护者**: Data Science Team
