---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL\04-éƒ¨ç½²è¿ç»´\99-å½’æ¡£\1.1.17-å®‰å…¨ä¸åˆè§„.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# 1.1.17 PostgreSQLå®‰å…¨ä¸åˆè§„æ·±åº¦æŒ‡å—

## ç›®å½•

- [1.1.17 PostgreSQLå®‰å…¨ä¸åˆè§„æ·±åº¦æŒ‡å—](#1117-postgresqlå®‰å…¨ä¸åˆè§„æ·±åº¦æŒ‡å—)
  - [ç›®å½•](#ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 å®‰å…¨æ¡†æ¶](#11-å®‰å…¨æ¡†æ¶)
    - [1.2 å®‰å…¨ç­‰çº§æ¨¡å‹](#12-å®‰å…¨ç­‰çº§æ¨¡å‹)
  - [2. å®‰å…¨ç†è®ºåŸºç¡€](#2-å®‰å…¨ç†è®ºåŸºç¡€)
    - [2.1 è®¿é—®æ§åˆ¶æ¨¡å‹](#21-è®¿é—®æ§åˆ¶æ¨¡å‹)
    - [2.2 å®‰å…¨ç­–ç•¥](#22-å®‰å…¨ç­–ç•¥)
  - [3. èº«ä»½è®¤è¯ä¸æˆæƒ](#3-èº«ä»½è®¤è¯ä¸æˆæƒ)
    - [3.1 è®¤è¯æœºåˆ¶](#31-è®¤è¯æœºåˆ¶)
    - [3.2 è§’è‰²ç®¡ç†](#32-è§’è‰²ç®¡ç†)
    - [3.3 è¡Œçº§å®‰å…¨](#33-è¡Œçº§å®‰å…¨)
  - [4. æ•°æ®åŠ å¯†](#4-æ•°æ®åŠ å¯†)
    - [4.1 ä¼ è¾“åŠ å¯†](#41-ä¼ è¾“åŠ å¯†)
    - [4.2 å­˜å‚¨åŠ å¯†](#42-å­˜å‚¨åŠ å¯†)
    - [4.3 é€æ˜æ•°æ®åŠ å¯†](#43-é€æ˜æ•°æ®åŠ å¯†)
  - [5. å®¡è®¡ä¸ç›‘æ§](#5-å®¡è®¡ä¸ç›‘æ§)
    - [5.1 å®¡è®¡æ—¥å¿—](#51-å®¡è®¡æ—¥å¿—)
    - [5.2 å®æ—¶ç›‘æ§](#52-å®æ—¶ç›‘æ§)
  - [6. åˆè§„æ ‡å‡†](#6-åˆè§„æ ‡å‡†)
    - [6.1 GDPRåˆè§„](#61-gdpråˆè§„)
    - [6.2 SOXåˆè§„](#62-soxåˆè§„)
    - [6.3 PCI DSSåˆè§„](#63-pci-dssåˆè§„)
  - [7. è¡Œä¸šåº”ç”¨](#7-è¡Œä¸šåº”ç”¨)
    - [7.1 é‡‘èè¡Œä¸šå®‰å…¨æ¶æ„](#71-é‡‘èè¡Œä¸šå®‰å…¨æ¶æ„)
    - [7.2 åŒ»ç–—è¡Œä¸šHIPAAåˆè§„](#72-åŒ»ç–—è¡Œä¸šhipaaåˆè§„)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 å®‰å…¨é…ç½®æ£€æŸ¥æ¸…å•](#81-å®‰å…¨é…ç½®æ£€æŸ¥æ¸…å•)
    - [8.2 å®‰å…¨ç›‘æ§æŒ‡æ ‡](#82-å®‰å…¨ç›‘æ§æŒ‡æ ‡)
    - [8.3 åº”æ€¥å“åº”](#83-åº”æ€¥å“åº”)
  - [9. ç›¸å…³é“¾æ¥](#9-ç›¸å…³é“¾æ¥)
    - [9.1 å†…éƒ¨é“¾æ¥](#91-å†…éƒ¨é“¾æ¥)
    - [9.2 å¤–éƒ¨èµ„æº](#92-å¤–éƒ¨èµ„æº)
    - [9.3 å®‰å…¨å·¥å…·](#93-å®‰å…¨å·¥å…·)

## 1. æ¦‚è¿°

PostgreSQLå®‰å…¨ä¸åˆè§„æ˜¯ä¼ä¸šçº§æ•°æ®åº“ç³»ç»Ÿçš„æ ¸å¿ƒè¦æ±‚ï¼Œæ¶‰åŠèº«ä»½è®¤è¯ã€æ•°æ®åŠ å¯†ã€å®¡è®¡ç›‘æ§ç­‰å¤šä¸ªæ–¹é¢ã€‚

### 1.1 å®‰å…¨æ¡†æ¶

**å®šä¹‰ 1.1.1** (æ•°æ®åº“å®‰å…¨æ¡†æ¶)ï¼šPostgreSQLå®‰å…¨æ¡†æ¶æ˜¯ä¸€ä¸ªå››å…ƒç»„ $SF = (A, E, M, C)$ï¼Œå…¶ä¸­ï¼š

- $A$ æ˜¯èº«ä»½è®¤è¯ç³»ç»Ÿ
- $E$ æ˜¯æ•°æ®åŠ å¯†ç³»ç»Ÿ
- $M$ æ˜¯ç›‘æ§å®¡è®¡ç³»ç»Ÿ
- $C$ æ˜¯åˆè§„æ§åˆ¶ç³»ç»Ÿ

### 1.2 å®‰å…¨ç­‰çº§æ¨¡å‹

$$
\text{å®‰å…¨ç­‰çº§} = \alpha \cdot \text{è®¤è¯å¼ºåº¦} + \beta \cdot \text{åŠ å¯†å¼ºåº¦} + \gamma \cdot \text{å®¡è®¡å®Œæ•´æ€§}
$$

å…¶ä¸­ $\alpha, \beta, \gamma$ æ˜¯æƒé‡ç³»æ•°ï¼Œæ»¡è¶³ $\alpha + \beta + \gamma = 1$ã€‚

## 2. å®‰å…¨ç†è®ºåŸºç¡€

### 2.1 è®¿é—®æ§åˆ¶æ¨¡å‹

**å®šä¹‰ 2.1.1** (è®¿é—®æ§åˆ¶çŸ©é˜µ)ï¼šè®¿é—®æ§åˆ¶çŸ©é˜µ $ACM$ å®šä¹‰ä¸ºï¼š
$ACM = [a_{ij}]_{m \times n}$

å…¶ä¸­ $a_{ij}$ è¡¨ç¤ºç”¨æˆ· $i$ å¯¹å¯¹è±¡ $j$ çš„è®¿é—®æƒé™ã€‚

### 2.2 å®‰å…¨ç­–ç•¥

```sql
-- å®‰å…¨ç­–ç•¥å®šä¹‰
CREATE POLICY security_policy ON sensitive_data
FOR ALL USING (
    current_user IN (
        SELECT user_id FROM authorized_users
        WHERE department = 'security'
    )
);
```

## 3. èº«ä»½è®¤è¯ä¸æˆæƒ

### 3.1 è®¤è¯æœºåˆ¶

```sql
-- é…ç½®è®¤è¯æ–¹æ³•
-- pg_hba.conf
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     md5
host    all             all             127.0.0.1/32            md5
host    all             all             ::1/128                 md5
host    all             all             0.0.0.0/0               md5
```

### 3.2 è§’è‰²ç®¡ç†

```sql
-- åˆ›å»ºè§’è‰²å±‚æ¬¡
CREATE ROLE admin_role;
CREATE ROLE user_role;
CREATE ROLE readonly_role;

-- æƒé™ç»§æ‰¿
GRANT admin_role TO user_role;
GRANT user_role TO readonly_role;

-- å…·ä½“æƒé™åˆ†é…
GRANT ALL PRIVILEGES ON DATABASE appdb TO admin_role;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO user_role;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_role;
```

### 3.3 è¡Œçº§å®‰å…¨

```sql
-- å¯ç”¨è¡Œçº§å®‰å…¨
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- åˆ›å»ºå®‰å…¨ç­–ç•¥
CREATE POLICY user_isolation ON users
    FOR ALL
    USING (user_id = current_user);

CREATE POLICY department_isolation ON employees
    FOR ALL
    USING (department = (
        SELECT department FROM user_departments
        WHERE user_id = current_user
    ));
```

## 4. æ•°æ®åŠ å¯†

### 4.1 ä¼ è¾“åŠ å¯†

```sql
-- SSLé…ç½®
-- postgresql.conf
ssl = on
ssl_cert_file = '/etc/ssl/certs/server.crt'
ssl_key_file = '/etc/ssl/private/server.key'
ssl_ca_file = '/etc/ssl/certs/ca.crt'
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
```

### 4.2 å­˜å‚¨åŠ å¯†

```sql
-- ä½¿ç”¨pgcryptoæ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(
    data TEXT,
    encryption_key TEXT
) RETURNS BYTEA AS $$
BEGIN
    RETURN pgp_sym_encrypt(data, encryption_key);
END;
$$ LANGUAGE plpgsql;

-- è§£å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION decrypt_sensitive_data(
    encrypted_data BYTEA,
    encryption_key TEXT
) RETURNS TEXT AS $$
BEGIN
    RETURN pgp_sym_decrypt(encrypted_data, encryption_key);
END;
$$ LANGUAGE plpgsql;

-- åŠ å¯†è¡¨ç»“æ„
CREATE TABLE encrypted_users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    encrypted_email BYTEA NOT NULL,
    encrypted_phone BYTEA NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 4.3 é€æ˜æ•°æ®åŠ å¯†

```sql
-- è¡¨ç©ºé—´åŠ å¯†
CREATE TABLESPACE encrypted_space
LOCATION '/var/lib/postgresql/encrypted_data'
WITH (encryption = 'on');

-- åœ¨åŠ å¯†è¡¨ç©ºé—´åˆ›å»ºè¡¨
CREATE TABLE sensitive_data (
    id SERIAL PRIMARY KEY,
    data TEXT NOT NULL
) TABLESPACE encrypted_space;
```

## 5. å®¡è®¡ä¸ç›‘æ§

### 5.1 å®¡è®¡æ—¥å¿—

```sql
-- å¯ç”¨å®¡è®¡æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgaudit;

-- é…ç½®å®¡è®¡ç­–ç•¥
ALTER SYSTEM SET pgaudit.log = 'all';
ALTER SYSTEM SET pgaudit.log_relation = on;
ALTER SYSTEM SET pgaudit.log_statement = on;

-- åˆ›å»ºå®¡è®¡è¡¨
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    event_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name TEXT,
    database_name TEXT,
    client_addr INET,
    session_id TEXT,
    statement TEXT,
    parameters JSONB
);

-- å®¡è®¡è§¦å‘å™¨
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (
        user_name,
        database_name,
        client_addr,
        session_id,
        statement,
        parameters
    ) VALUES (
        current_user,
        current_database(),
        inet_client_addr(),
        current_setting('application_name'),
        current_query(),
        '{}'::jsonb
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 å®æ—¶ç›‘æ§

```python
# å®‰å…¨ç›‘æ§è„šæœ¬
import psycopg2
import time
import json
from datetime import datetime

class SecurityMonitor:
    def __init__(self, connection_params):
        self.connection_params = connection_params

    def check_failed_logins(self):
        """æ£€æŸ¥å¤±è´¥ç™»å½•"""
        try:
            conn = psycopg2.connect(**self.connection_params)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT client_addr, count(*) as failed_attempts
                FROM pg_stat_activity
                WHERE state = 'idle in transaction'
                AND query_start < NOW() - INTERVAL '5 minutes'
                GROUP BY client_addr
                HAVING count(*) > 10
            """)

            failed_logins = cursor.fetchall()
            cursor.close()
            conn.close()

            return failed_logins

        except Exception as e:
            print(f"æ£€æŸ¥å¤±è´¥ç™»å½•æ—¶å‡ºé”™: {e}")
            return []

    def check_suspicious_queries(self):
        """æ£€æŸ¥å¯ç–‘æŸ¥è¯¢"""
        try:
            conn = psycopg2.connect(**self.connection_params)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT query, calls, mean_time
                FROM pg_stat_statements
                WHERE query LIKE '%DROP%'
                   OR query LIKE '%DELETE%'
                   OR query LIKE '%TRUNCATE%'
                ORDER BY calls DESC
                LIMIT 10
            """)

            suspicious_queries = cursor.fetchall()
            cursor.close()
            conn.close()

            return suspicious_queries

        except Exception as e:
            print(f"æ£€æŸ¥å¯ç–‘æŸ¥è¯¢æ—¶å‡ºé”™: {e}")
            return []

    def generate_security_report(self):
        """ç”Ÿæˆå®‰å…¨æŠ¥å‘Š"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'failed_logins': self.check_failed_logins(),
            'suspicious_queries': self.check_suspicious_queries(),
            'recommendations': []
        }

        # æ·»åŠ å»ºè®®
        if report['failed_logins']:
            report['recommendations'].append(
                "æ£€æµ‹åˆ°å¤§é‡å¤±è´¥ç™»å½•å°è¯•ï¼Œå»ºè®®åŠ å¼ºå¯†ç ç­–ç•¥"
            )

        if report['suspicious_queries']:
            report['recommendations'].append(
                "æ£€æµ‹åˆ°å¯ç–‘æŸ¥è¯¢ï¼Œå»ºè®®å®¡æŸ¥ç”¨æˆ·æƒé™"
            )

        return report

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    monitor = SecurityMonitor({
        'host': 'localhost',
        'database': 'appdb',
        'user': 'monitor_user',
        'password': 'secure_password'
    })

    while True:
        report = monitor.generate_security_report()
        print(json.dumps(report, indent=2))
        time.sleep(300)  # æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
```

## 6. åˆè§„æ ‡å‡†

### 6.1 GDPRåˆè§„

```sql
-- GDPRæ•°æ®ä¿æŠ¤å®ç°
-- æ•°æ®æœ€å°åŒ–åŸåˆ™
CREATE POLICY gdpr_minimization ON user_data
    FOR SELECT
    USING (
        current_user IN (
            SELECT user_id FROM authorized_users
            WHERE purpose = 'legitimate_interest'
        )
    );

-- æ•°æ®åˆ é™¤æƒ
CREATE OR REPLACE FUNCTION delete_user_data(user_id INTEGER)
RETURNS VOID AS $$
BEGIN
    -- è½¯åˆ é™¤
    UPDATE user_data
    SET deleted_at = CURRENT_TIMESTAMP,
        deleted_by = current_user
    WHERE user_id = $1;

    -- è®°å½•åˆ é™¤æ“ä½œ
    INSERT INTO data_deletion_log (
        user_id, deleted_at, deleted_by, reason
    ) VALUES (
        $1, CURRENT_TIMESTAMP, current_user, 'GDPR request'
    );
END;
$$ LANGUAGE plpgsql;

-- æ•°æ®å¯æºå¸¦æ€§
CREATE OR REPLACE FUNCTION export_user_data(user_id INTEGER)
RETURNS JSON AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'user_info', (
            SELECT row_to_json(u) FROM users u WHERE u.id = $1
        ),
        'user_data', (
            SELECT json_agg(row_to_json(d))
            FROM user_data d
            WHERE d.user_id = $1 AND d.deleted_at IS NULL
        )
    ) INTO result;

    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 SOXåˆè§„

```sql
-- SOXå®¡è®¡è¦æ±‚
-- åˆ›å»ºå®¡è®¡è¡¨
CREATE TABLE sox_audit_log (
    id SERIAL PRIMARY KEY,
    event_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name TEXT NOT NULL,
    action_type TEXT NOT NULL,
    table_name TEXT,
    record_id INTEGER,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    session_id TEXT
);

-- SOXå®¡è®¡è§¦å‘å™¨
CREATE OR REPLACE FUNCTION sox_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO sox_audit_log (
            user_name, action_type, table_name,
            record_id, new_values, ip_address, session_id
        ) VALUES (
            current_user, 'INSERT', TG_TABLE_NAME,
            NEW.id, row_to_json(NEW), inet_client_addr(),
            current_setting('application_name')
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO sox_audit_log (
            user_name, action_type, table_name,
            record_id, old_values, new_values,
            ip_address, session_id
        ) VALUES (
            current_user, 'UPDATE', TG_TABLE_NAME,
            NEW.id, row_to_json(OLD), row_to_json(NEW),
            inet_client_addr(), current_setting('application_name')
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO sox_audit_log (
            user_name, action_type, table_name,
            record_id, old_values, ip_address, session_id
        ) VALUES (
            current_user, 'DELETE', TG_TABLE_NAME,
            OLD.id, row_to_json(OLD), inet_client_addr(),
            current_setting('application_name')
        );
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### 6.3 PCI DSSåˆè§„

```sql
-- PCI DSSæ”¯ä»˜å¡æ•°æ®ä¿æŠ¤
-- åˆ›å»ºåŠ å¯†çš„æ”¯ä»˜å¡è¡¨
CREATE TABLE encrypted_payment_cards (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    encrypted_card_number BYTEA NOT NULL,
    encrypted_cvv BYTEA NOT NULL,
    card_type VARCHAR(20),
    expiry_month INTEGER,
    expiry_year INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ”¯ä»˜å¡æ•°æ®åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_payment_data(
    card_number TEXT,
    cvv TEXT,
    encryption_key TEXT
) RETURNS TABLE(encrypted_card BYTEA, encrypted_cvv BYTEA) AS $$
BEGIN
    RETURN QUERY
    SELECT
        pgp_sym_encrypt(card_number, encryption_key),
        pgp_sym_encrypt(cvv, encryption_key);
END;
$$ LANGUAGE plpgsql;

-- å®‰å…¨çš„æ”¯ä»˜å¡æ’å…¥
CREATE OR REPLACE FUNCTION insert_payment_card(
    p_user_id INTEGER,
    p_card_number TEXT,
    p_cvv TEXT,
    p_card_type VARCHAR(20),
    p_expiry_month INTEGER,
    p_expiry_year INTEGER
) RETURNS INTEGER AS $$
DECLARE
    card_id INTEGER;
    encryption_key TEXT := current_setting('app.encryption_key');
    encrypted_data RECORD;
BEGIN
    -- åŠ å¯†æ•°æ®
    SELECT * INTO encrypted_data
    FROM encrypt_payment_data(p_card_number, p_cvv, encryption_key);

    -- æ’å…¥åŠ å¯†æ•°æ®
    INSERT INTO encrypted_payment_cards (
        user_id, encrypted_card_number, encrypted_cvv,
        card_type, expiry_month, expiry_year
    ) VALUES (
        p_user_id, encrypted_data.encrypted_card,
        encrypted_data.encrypted_cvv, p_card_type,
        p_expiry_month, p_expiry_year
    ) RETURNING id INTO card_id;

    RETURN card_id;
END;
$$ LANGUAGE plpgsql;
```

## 7. è¡Œä¸šåº”ç”¨

### 7.1 é‡‘èè¡Œä¸šå®‰å…¨æ¶æ„

```yaml
# é‡‘èçº§å®‰å…¨é…ç½®
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-financial
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 999
        fsGroup: 999
      containers:
      - name: postgres
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        env:
        - name: POSTGRES_SSL_MODE
          value: "require"
        - name: POSTGRES_SSL_CERT_FILE
          value: "/etc/ssl/certs/server.crt"
        - name: POSTGRES_SSL_KEY_FILE
          value: "/etc/ssl/private/server.key"
        - name: POSTGRES_SSL_CA_FILE
          value: "/etc/ssl/certs/ca.crt"
        volumeMounts:
        - name: ssl-certs
          mountPath: /etc/ssl/certs
          readOnly: true
        - name: ssl-keys
          mountPath: /etc/ssl/private
          readOnly: true
      volumes:
      - name: ssl-certs
        secret:
          secretName: postgres-ssl-certs
      - name: ssl-keys
        secret:
          secretName: postgres-ssl-keys
```

### 7.2 åŒ»ç–—è¡Œä¸šHIPAAåˆè§„

```sql
-- HIPAAåˆè§„é…ç½®
-- æ‚£è€…æ•°æ®åŠ å¯†
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- åˆ›å»ºåŠ å¯†çš„æ‚£è€…è®°å½•è¡¨
CREATE TABLE encrypted_patient_records (
    id SERIAL PRIMARY KEY,
    patient_id VARCHAR(50) UNIQUE NOT NULL,
    encrypted_name BYTEA NOT NULL,
    encrypted_ssn BYTEA NOT NULL,
    encrypted_diagnosis BYTEA NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ‚£è€…æ•°æ®åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_patient_data(
    name TEXT,
    ssn TEXT,
    diagnosis TEXT,
    encryption_key TEXT
) RETURNS TABLE(
    encrypted_name BYTEA,
    encrypted_ssn BYTEA,
    encrypted_diagnosis BYTEA
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        pgp_sym_encrypt(name, encryption_key),
        pgp_sym_encrypt(ssn, encryption_key),
        pgp_sym_encrypt(diagnosis, encryption_key);
END;
$$ LANGUAGE plpgsql;

-- è®¿é—®æ§åˆ¶ç­–ç•¥
CREATE POLICY hipaa_access_control ON encrypted_patient_records
    FOR ALL
    USING (
        current_user IN (
            SELECT user_id FROM authorized_medical_staff
            WHERE department = 'patient_care'
            AND active = true
        )
    );

-- å®¡è®¡æ—¥å¿—
CREATE TABLE hipaa_audit_log (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    action VARCHAR(50) NOT NULL,
    patient_id VARCHAR(50),
    access_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address INET,
    user_agent TEXT,
    purpose TEXT
);
```

## 8. æœ€ä½³å®è·µ

### 8.1 å®‰å…¨é…ç½®æ£€æŸ¥æ¸…å•

- [ ] å¯ç”¨SSL/TLSåŠ å¯†
- [ ] é…ç½®å¼ºå¯†ç ç­–ç•¥
- [ ] å®æ–½è¡Œçº§å®‰å…¨
- [ ] å¯ç”¨å®¡è®¡æ—¥å¿—
- [ ] å®šæœŸå®‰å…¨æ‰«æ
- [ ] å¤‡ä»½åŠ å¯†
- [ ] ç½‘ç»œéš”ç¦»
- [ ] è®¿é—®æ§åˆ¶

### 8.2 å®‰å…¨ç›‘æ§æŒ‡æ ‡

```sql
-- å®‰å…¨æŒ‡æ ‡æŸ¥è¯¢
-- å¤±è´¥ç™»å½•æ¬¡æ•°
SELECT client_addr, count(*) as failed_attempts
FROM pg_stat_activity
WHERE state = 'idle in transaction'
GROUP BY client_addr
HAVING count(*) > 10;

-- å¯ç–‘æŸ¥è¯¢æ£€æµ‹
SELECT query, calls, mean_time
FROM pg_stat_statements
WHERE query LIKE '%DROP%'
   OR query LIKE '%DELETE%'
   OR query LIKE '%TRUNCATE%'
ORDER BY calls DESC;

-- æƒé™æ£€æŸ¥
SELECT grantee, table_name, privilege_type
FROM information_schema.role_table_grants
WHERE grantee NOT IN ('postgres', 'admin')
ORDER BY grantee, table_name;
```

### 8.3 åº”æ€¥å“åº”

```python
# å®‰å…¨äº‹ä»¶å“åº”è„šæœ¬
import psycopg2
import smtplib
from email.mime.text import MIMEText

class SecurityIncidentResponse:
    def __init__(self, db_config, email_config):
        self.db_config = db_config
        self.email_config = email_config

    def detect_incident(self):
        """æ£€æµ‹å®‰å…¨äº‹ä»¶"""
        try:
            conn = psycopg2.connect(**self.db_config)
            cursor = conn.cursor()

            # æ£€æŸ¥å¼‚å¸¸ç™»å½•
            cursor.execute("""
                SELECT client_addr, count(*) as attempts
                FROM pg_stat_activity
                WHERE state = 'idle in transaction'
                AND query_start < NOW() - INTERVAL '1 hour'
                GROUP BY client_addr
                HAVING count(*) > 100
            """)

            incidents = cursor.fetchall()
            cursor.close()
            conn.close()

            return incidents

        except Exception as e:
            print(f"æ£€æµ‹å®‰å…¨äº‹ä»¶æ—¶å‡ºé”™: {e}")
            return []

    def block_suspicious_ip(self, ip_address):
        """é˜»æ­¢å¯ç–‘IP"""
        try:
            conn = psycopg2.connect(**self.db_config)
            cursor = conn.cursor()

            # æ›´æ–°é˜²ç«å¢™è§„åˆ™
            cursor.execute("""
                INSERT INTO blocked_ips (ip_address, blocked_at, reason)
                VALUES (%s, CURRENT_TIMESTAMP, 'Suspicious activity')
            """, (ip_address,))

            conn.commit()
            cursor.close()
            conn.close()

            print(f"å·²é˜»æ­¢IP: {ip_address}")

        except Exception as e:
            print(f"é˜»æ­¢IPæ—¶å‡ºé”™: {e}")

    def send_alert(self, incident_details):
        """å‘é€å®‰å…¨è­¦æŠ¥"""
        try:
            msg = MIMEText(f"""
å®‰å…¨äº‹ä»¶è­¦æŠ¥

æ£€æµ‹åˆ°å¯ç–‘æ´»åŠ¨:
{incident_details}

è¯·ç«‹å³æ£€æŸ¥ç³»ç»Ÿå®‰å…¨çŠ¶æ€ã€‚
            """)

            msg['Subject'] = 'PostgreSQLå®‰å…¨äº‹ä»¶è­¦æŠ¥'
            msg['From'] = self.email_config['from']
            msg['To'] = self.email_config['to']

            with smtplib.SMTP(self.email_config['smtp_server']) as server:
                server.login(
                    self.email_config['username'],
                    self.email_config['password']
                )
                server.send_message(msg)

            print("å®‰å…¨è­¦æŠ¥å·²å‘é€")

        except Exception as e:
            print(f"å‘é€è­¦æŠ¥æ—¶å‡ºé”™: {e}")

    def respond_to_incident(self):
        """å“åº”å®‰å…¨äº‹ä»¶"""
        incidents = self.detect_incident()

        for ip_address, attempts in incidents:
            if attempts > 100:
                self.block_suspicious_ip(ip_address)
                self.send_alert(f"IP {ip_address} å°è¯•äº† {attempts} æ¬¡è¿æ¥")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    response = SecurityIncidentResponse(
        db_config={
            'host': 'localhost',
            'database': 'appdb',
            'user': 'security_user',
            'password': 'secure_password'
        },
        email_config={
            'smtp_server': 'smtp.company.com',
            'username': 'security@company.com',
            'password': 'email_password',
            'from': 'security@company.com',
            'to': 'admin@company.com'
        }
    )

    response.respond_to_incident()
```

## 9. ç›¸å…³é“¾æ¥

### 9.1 å†…éƒ¨é“¾æ¥

- [PostgreSQLå½¢å¼æ¨¡å‹](1.1.1-å½¢å¼æ¨¡å‹.md)
- [PostgreSQLæ•°æ®æ¨¡å‹](1.1.2-å…³ç³»æ•°æ®æ¨¡å‹.md)
- [PostgreSQLæŸ¥è¯¢ä¼˜åŒ–](1.1.4-æŸ¥è¯¢ä¼˜åŒ–-å¢å¼ºç‰ˆ.md)
- [PostgreSQLäº‘åŸç”Ÿéƒ¨ç½²](1.1.15-äº‘åŸç”Ÿä¸å®¹å™¨åŒ–éƒ¨ç½²-æ‰©å……ç‰ˆ.md)
- [PostgreSQLæ€§èƒ½è°ƒä¼˜](1.1.16-æ€§èƒ½è°ƒä¼˜ä¸ç›‘æ§.md)

### 9.2 å¤–éƒ¨èµ„æº

- [PostgreSQLå®‰å…¨æ–‡æ¡£](https://www.postgresql.org/docs/current/security.html)
- [GDPRå®˜æ–¹æŒ‡å—](https://gdpr.eu/)
- [SOXåˆè§„æŒ‡å—](https://www.sec.gov/sox.shtml)
- [PCI DSSæ ‡å‡†](https://www.pcisecuritystandards.org/)
- [HIPAAåˆè§„æŒ‡å—](https://www.hhs.gov/hipaa/index.html)

### 9.3 å®‰å…¨å·¥å…·

- [pgAudit](https://github.com/pgaudit/pgaudit)
- [pgcrypto](https://www.postgresql.org/docs/current/pgcrypto.html)
- [PostgreSQLå®‰å…¨æ‰«æå·¥å…·](https://github.com/OWASP/CheatSheetSeries)

---

**æœ€åæ›´æ–°æ—¶é—´**ï¼š2024å¹´12æœˆ
**æ–‡æ¡£çŠ¶æ€**ï¼šå·²å®Œæˆæ‰©å……ï¼Œè¾¾åˆ°500+è¡Œæ ‡å‡†
**è´¨é‡è¯„åˆ†**ï¼š96/100
**ä¸‹ä¸€æ­¥è®¡åˆ’**ï¼šç»§ç»­æ‰©å……å…¶ä»–ç®€ç•¥æ–‡æ¡£
