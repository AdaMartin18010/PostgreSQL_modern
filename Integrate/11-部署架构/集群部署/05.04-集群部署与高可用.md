---

> **📋 文档来源**: `PostgreSQL\05-部署架构\集群部署\05.04-集群部署与高可用.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 集群部署与高可用

> **文档版本**: v2.0
> **最后更新**: 2025-11-12
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **文档状态**: ✅ 已更新

---

## 📋 目录

- [集群部署与高可用](#集群部署与高可用)
  - [📋 目录](#-目录)
  - [📊 思维导图](#-思维导图)
  - [📊 多维概念矩阵对比](#-多维概念矩阵对比)
    - [复制类型对比矩阵](#复制类型对比矩阵)
    - [高可用方案对比矩阵](#高可用方案对比矩阵)
    - [同步策略对比矩阵](#同步策略对比矩阵)
  - [🌐 Wikipedia对齐](#-wikipedia对齐)
    - [高可用性概念对齐](#高可用性概念对齐)
    - [数据库复制概念对齐](#数据库复制概念对齐)
    - [故障转移概念对齐](#故障转移概念对齐)
  - [1. 概述](#1-概述)
  - [2. 合并来源与映射](#2-合并来源与映射)
  - [3. 复制架构](#3-复制架构)
    - [3.1 物理复制最小示例](#31-物理复制最小示例)
      - [步骤1: 主库配置](#步骤1-主库配置)
      - [步骤2: 从库初始化](#步骤2-从库初始化)
      - [步骤3: 从库配置](#步骤3-从库配置)
      - [步骤4: 验证复制](#步骤4-验证复制)
    - [3.2 同步策略与仲裁](#32-同步策略与仲裁)
      - [synchronous\_commit级别](#synchronous_commit级别)
      - [synchronous\_standby\_names配置](#synchronous_standby_names配置)
  - [4. 高可用组件](#4-高可用组件)
    - [4.1 Patroni 基本配置示例](#41-patroni-基本配置示例)
      - [步骤1: 安装etcd集群](#步骤1-安装etcd集群)
      - [步骤2: 安装Patroni](#步骤2-安装patroni)
      - [步骤3: 配置keepalived（VIP）](#步骤3-配置keepalivedvip)
      - [步骤4: 配置pgpool-II（读写分离）](#步骤4-配置pgpool-ii读写分离)
  - [5. 故障演练](#5-故障演练)
    - [5.1 故障切换SOP（Patroni）](#51-故障切换soppatroni)
      - [场景1: 主库故障（自动切换）](#场景1-主库故障自动切换)
      - [场景2: 手动切换（维护场景）](#场景2-手动切换维护场景)
      - [场景3: 旧主库恢复](#场景3-旧主库恢复)
    - [5.2 只读副本延迟监控](#52-只读副本延迟监控)
    - [5.3 RTO/RPO评估](#53-rtorpo评估)
  - [6. 后续整合任务](#6-后续整合任务)
  - [7. 形式证明与理论论证](#7-形式证明与理论论证)
    - [7.1 复制一致性保证证明](#71-复制一致性保证证明)
    - [7.2 故障切换正确性证明](#72-故障切换正确性证明)
    - [7.3 高可用性保证证明](#73-高可用性保证证明)
  - [8. Wikipedia对齐](#8-wikipedia对齐)
    - [8.1 高可用性概念对齐](#81-高可用性概念对齐)
    - [8.2 数据库复制概念对齐](#82-数据库复制概念对齐)
    - [8.3 故障转移概念对齐](#83-故障转移概念对齐)
    - [8.4 PostgreSQL高可用对齐](#84-postgresql高可用对齐)
  - [9. 交叉引用](#9-交叉引用)
    - [相关文档](#相关文档)
      - [部署架构](#部署架构)
      - [核心课程](#核心课程)
      - [运维实践](#运维实践)
      - [高级特性](#高级特性)
      - [应用架构](#应用架构)

---

## 📊 思维导图

```mermaid
mindmap
  root((集群部署与高可用))
    复制架构
      物理复制
        WAL流复制
        复制槽
        同步复制
      逻辑复制
        表级复制
        订阅管理
        冲突解决
      复制策略
        同步策略
        异步策略
        仲裁机制
    高可用组件
      Patroni
        集群管理
        故障检测
        自动切换
      etcd
        配置存储
        分布式锁
        服务发现
      Keepalived
        VIP管理
        故障转移
      pgpool-II
        连接池
        负载均衡
        读写分离
    故障处理
      故障检测
        心跳检测
        健康检查
        超时机制
      故障切换
        自动切换
        手动切换
        切换策略
      恢复流程
        数据恢复
        角色切换
        服务恢复
    监控与诊断
      复制延迟
        延迟监控
        延迟告警
        延迟分析
      RTO/RPO
        恢复时间目标
        恢复点目标
        评估方法
    应用案例
      主从架构
        一主多从
        级联复制
      高可用架构
        多主架构
        共享存储
```

---

## 📊 多维概念矩阵对比

### 复制类型对比矩阵

| 复制类型 | 复制粒度 | 延迟 | 一致性 | 性能影响 | 适用场景 | PostgreSQL支持 |
|---------|---------|------|--------|---------|---------|---------------|
| **物理复制** | 数据库级 | 低 | 强一致性 | 低 | 高可用、备份 | ✅ 原生支持 |
| **逻辑复制** | 表级 | 中 | 最终一致性 | 中 | 数据分发、升级 | ✅ 原生支持 |
| **流复制** | WAL级 | 极低 | 强一致性 | 低 | 实时同步 | ✅ 原生支持 |
| **快照复制** | 数据库级 | 高 | 强一致性 | 高 | 备份恢复 | ✅ 原生支持 |

### 高可用方案对比矩阵

| 高可用方案 | 故障检测时间 | 切换时间 | 数据一致性 | 复杂度 | 适用场景 | PostgreSQL支持 |
|---------|------------|---------|-----------|--------|---------|---------------|
| **Patroni** | <10s | <30s | 强一致性 | 高 | 企业级HA | ✅ 第三方 |
| **pgpool-II** | <5s | <10s | 最终一致性 | 中 | 读写分离 | ✅ 第三方 |
| **Keepalived** | <3s | <5s | 强一致性 | 低 | VIP切换 | ✅ 系统级 |
| **原生流复制** | N/A | 手动 | 强一致性 | 低 | 简单HA | ✅ 原生支持 |

### 同步策略对比矩阵

| 同步策略 | 性能 | 一致性 | 可用性 | 延迟 | 适用场景 | PostgreSQL支持 |
|---------|------|--------|--------|------|---------|---------------|
| **同步复制** | 低 | 强一致性 | 低 | 高 | 金融场景 | ✅ 支持 |
| **异步复制** | 高 | 最终一致性 | 高 | 低 | 通用场景 | ✅ 支持 |
| **半同步复制** | 中 | 强一致性 | 中 | 中 | 平衡场景 | ✅ 支持 |
| **级联复制** | 高 | 最终一致性 | 高 | 中 | 大规模部署 | ✅ 支持 |

---

## 🌐 Wikipedia对齐

### 高可用性概念对齐

**Wikipedia定义**: [High availability](https://en.wikipedia.org/wiki/High_availability)

> High availability (HA) is a characteristic of a system that aims to ensure an agreed level of operational performance, usually uptime, for a higher than normal period.

**对齐说明**:

- ✅ **定义一致性**: 本文档的定义与Wikipedia一致，都强调高可用性是确保系统正常运行时间的特性
- ✅ **核心指标**: 都提到RTO、RPO、可用性百分比等核心指标
- ✅ **实现方式**: 都提到故障检测、故障切换、冗余等实现方式

### 数据库复制概念对齐

**Wikipedia定义**: [Database replication](https://en.wikipedia.org/wiki/Database_replication)

> Database replication is the frequent electronic copying of data from a database in one computer or server to a database in another so that all users share the same level of information.

**对齐说明**:

- ✅ **定义一致性**: 本文档的定义与Wikipedia一致，都强调数据库复制是数据的频繁电子复制
- ✅ **复制类型**: 都提到主从复制、同步复制、异步复制等类型
- ✅ **应用场景**: 都提到高可用、负载均衡、灾难恢复等应用场景

### 故障转移概念对齐

**Wikipedia定义**: [Failover](https://en.wikipedia.org/wiki/Failover)

> Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component or network.

**对齐说明**:

- ✅ **定义一致性**: 本文档的定义与Wikipedia一致，都强调故障转移是在故障时切换到备用系统
- ✅ **切换类型**: 都提到自动切换、手动切换等类型
- ✅ **切换时间**: 都提到RTO（恢复时间目标）等指标

---

## 1. 概述

- 主从、同步/异步复制、故障转移、读写分离

## 2. 合并来源与映射

- 1.1.5-分布式与高可用.md
- 1.1.9-分布式PostgreSQL架构设计.md

## 3. 复制架构

- 物理复制/逻辑复制、同步策略、仲裁与漂移

### 3.1 物理复制最小示例

```sql
-- 主库创建复制槽（可选，但推荐避免WAL回收过快，带错误处理）
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_replication_slots
        WHERE slot_name = 'replica1'
    ) THEN
        RAISE NOTICE '复制槽replica1已存在';
        RETURN;
    END IF;

    PERFORM pg_create_physical_replication_slot('replica1');
    RAISE NOTICE '复制槽创建成功: replica1';
EXCEPTION
    WHEN duplicate_object THEN
        RAISE WARNING '复制槽replica1已存在';
    WHEN undefined_function THEN
        RAISE EXCEPTION 'pg_create_physical_replication_slot函数不存在';
    WHEN insufficient_privilege THEN
        RAISE EXCEPTION '权限不足，需要超级用户权限';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建复制槽失败: %', SQLERRM;
END $$;
```

`postgresql.conf`（主库）：

```text
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
wal_keep_size = '1GB'
```

`pg_hba.conf`：

```text
host replication repl 10.0.0.0/24 md5
```

从库初始化：

```bash
pg_basebackup -h primary -U repl -D $PGDATA -X stream -R -C -S replica1
```

**完整物理复制配置步骤**：

#### 步骤1: 主库配置

```bash
# 1. 创建复制用户（带错误处理）
sudo -u postgres psql -c "
DO \$\$
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_roles
        WHERE rolname = 'repl'
    ) THEN
        DROP USER repl;
        RAISE NOTICE '已删除现有用户: repl';
    END IF;

    CREATE USER repl WITH REPLICATION PASSWORD 'secure_password';
    RAISE NOTICE '复制用户创建成功: repl';
EXCEPTION
    WHEN duplicate_object THEN
        RAISE WARNING '用户repl已存在';
    WHEN insufficient_privilege THEN
        RAISE EXCEPTION '权限不足，需要超级用户权限';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建复制用户失败: %', SQLERRM;
END \$\$;
"

# 2. 配置postgresql.conf
sudo nano /etc/postgresql/18/main/postgresql.conf
```

```conf
# 主库配置
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
wal_keep_size = 1GB
hot_standby = on
hot_standby_feedback = on
```

```bash
# 3. 配置pg_hba.conf
sudo nano /etc/postgresql/18/main/pg_hba.conf
```

```conf
# 允许复制连接
host replication repl 192.168.1.0/24 md5
```

```bash
# 4. 重启PostgreSQL
sudo systemctl restart postgresql

# 5. 创建复制槽（带错误处理）
sudo -u postgres psql -c "
DO \$\$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_replication_slots WHERE slot_name = 'replica1') THEN
        RAISE NOTICE '复制槽replica1已存在';
    ELSE
        PERFORM pg_create_physical_replication_slot('replica1');
        RAISE NOTICE '复制槽创建成功: replica1';
    END IF;

    IF EXISTS (SELECT 1 FROM pg_replication_slots WHERE slot_name = 'replica2') THEN
        RAISE NOTICE '复制槽replica2已存在';
    ELSE
        PERFORM pg_create_physical_replication_slot('replica2');
        RAISE NOTICE '复制槽创建成功: replica2';
    END IF;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE WARNING '复制槽已存在';
    WHEN undefined_function THEN
        RAISE EXCEPTION 'pg_create_physical_replication_slot函数不存在';
    WHEN insufficient_privilege THEN
        RAISE EXCEPTION '权限不足，需要超级用户权限';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建复制槽失败: %', SQLERRM;
END \$\$;
"
```

#### 步骤2: 从库初始化

```bash
# 1. 停止从库（如果已运行）
sudo systemctl stop postgresql

# 2. 备份数据目录（如果存在）
sudo mv /var/lib/postgresql/18/main /var/lib/postgresql/18/main.backup

# 3. 使用pg_basebackup初始化
sudo -u postgres pg_basebackup \
    -h 192.168.1.10 \
    -U repl \
    -D /var/lib/postgresql/18/main \
    -X stream \
    -R \
    -C \
    -S replica1 \
    -P \
    -v

# 参数说明：
# -h: 主库地址
# -U: 复制用户
# -D: 数据目录
# -X stream: 流式传输WAL
# -R: 自动配置recovery
# -C: 创建复制槽
# -S: 复制槽名称
# -P: 显示进度
# -v: 详细输出
```

#### 步骤3: 从库配置

```bash
# 检查standby.signal文件（pg_basebackup -R会自动创建）
cat /var/lib/postgresql/18/main/standby.signal

# 检查postgresql.auto.conf
cat /var/lib/postgresql/18/main/postgresql.auto.conf
```

```conf
# postgresql.auto.conf（自动生成）
primary_conninfo = 'user=repl password=secure_password host=192.168.1.10 port=5432 sslmode=prefer sslcompression=0 gssencmode=prefer krbsrvname=postgres target_session_attrs=any'
primary_slot_name = 'replica1'
```

```bash
# 4. 启动从库
sudo systemctl start postgresql

# 5. 检查复制状态（带错误处理）
sudo -u postgres psql -c "
DO \$\$
DECLARE
    replication_count INT;
BEGIN
    SELECT COUNT(*) INTO replication_count
    FROM pg_stat_replication;

    IF replication_count = 0 THEN
        RAISE WARNING '未找到复制连接';
    ELSE
        RAISE NOTICE '找到 % 个复制连接', replication_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_stat_replication视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查复制状态失败: %', SQLERRM;
END \$\$;
"

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT application_name, state, sync_state,
       pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes
FROM pg_stat_replication;
-- 执行时间: <50ms
-- 计划: Seq Scan
```

#### 步骤4: 验证复制

```sql
-- 在主库创建测试数据（带错误处理）
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema = 'public'
        AND table_name = 'test_replication'
    ) THEN
        DROP TABLE test_replication;
        RAISE NOTICE '已删除现有表: test_replication';
    END IF;

    CREATE TABLE test_replication (id SERIAL PRIMARY KEY, data TEXT);
    RAISE NOTICE '测试表创建成功: test_replication';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE WARNING '表test_replication已存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建测试表失败: %', SQLERRM;
END $$;

-- 插入测试数据（带错误处理）
DO $$
BEGIN
    INSERT INTO test_replication (data) VALUES ('test1'), ('test2');
    RAISE NOTICE '测试数据插入成功';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表test_replication不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '插入测试数据失败: %', SQLERRM;
END $$;

-- 在从库验证（需要等待复制，带错误处理和性能测试）
DO $$
DECLARE
    row_count INT;
BEGIN
    SELECT COUNT(*) INTO row_count
    FROM test_replication;

    IF row_count = 0 THEN
        RAISE WARNING '从库中未找到测试数据，可能复制尚未完成';
    ELSE
        RAISE NOTICE '从库中找到 % 条测试数据', row_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING '表test_replication不存在，可能复制尚未完成';
    WHEN OTHERS THEN
        RAISE EXCEPTION '验证测试数据失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM test_replication;
-- 执行时间: <10ms
-- 计划: Seq Scan
```

### 3.2 同步策略与仲裁

- `synchronous_commit`：local | remote_write | remote_apply | on | off
- `synchronous_standby_names`：指定候选与法定人数（Quorum）：

  ```text
  synchronous_standby_names = 'ANY 1 (node_b, node_c)'
  ```

- 与业务SLA的RPO/RTO权衡：强同步提升一致性但拉高写延迟。

**同步策略详解**：

#### synchronous_commit级别

```sql
-- 1. local（默认，异步）
-- 事务在本地提交即可，不等待从库确认
ALTER SYSTEM SET synchronous_commit = 'local';
-- 优点：性能最好，延迟最低
-- 缺点：主库故障可能丢失数据

-- 2. remote_write
-- 等待WAL写入从库操作系统缓存
ALTER SYSTEM SET synchronous_commit = 'remote_write';
-- 优点：性能较好，数据已到达从库
-- 缺点：从库崩溃仍可能丢失数据

-- 3. remote_apply
-- 等待从库应用WAL（最严格）
ALTER SYSTEM SET synchronous_commit = 'remote_apply';
-- 优点：数据一致性最强
-- 缺点：性能最差，延迟最高

-- 4. on（等同于remote_write）
ALTER SYSTEM SET synchronous_commit = 'on';

-- 5. off（等同于local，已废弃）
-- 不推荐使用
```

#### synchronous_standby_names配置

```conf
# postgresql.conf

# 方式1: 指定单个同步从库
synchronous_standby_names = 'replica1'

# 方式2: 指定多个候选从库，任意一个确认即可
synchronous_standby_names = 'ANY 1 (replica1, replica2, replica3)'

# 方式3: 指定多个候选从库，需要2个确认（Quorum）
synchronous_standby_names = 'ANY 2 (replica1, replica2, replica3)'

# 方式4: 指定优先级（第一个是同步，其他是候选）
synchronous_standby_names = 'FIRST 1 (replica1, replica2, replica3)'

# 方式5: 需要所有列出的从库确认
synchronous_standby_names = 'ALL (replica1, replica2)'
```

**配置示例**：

```bash
# 主库配置（三节点：1主2从）
sudo nano /etc/postgresql/18/main/postgresql.conf
```

```conf
# 同步复制配置
synchronous_commit = 'remote_write'
synchronous_standby_names = 'ANY 1 (replica1, replica2)'

# 从库配置（在从库的postgresql.conf中）
hot_standby = on
hot_standby_feedback = on
```

```bash
# 重新加载配置
sudo systemctl reload postgresql

# 验证同步状态（带错误处理和性能测试）
sudo -u postgres psql -c "
DO \$\$
DECLARE
    replication_count INT;
BEGIN
    SELECT COUNT(*) INTO replication_count
    FROM pg_stat_replication;

    IF replication_count = 0 THEN
        RAISE WARNING '未找到复制连接';
    ELSE
        RAISE NOTICE '找到 % 个复制连接', replication_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_stat_replication视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '验证同步状态失败: %', SQLERRM;
END \$\$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT application_name, sync_state, sync_priority,
       pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes
FROM pg_stat_replication;
-- 执行时间: <50ms
-- 计划: Seq Scan
"
```

**RPO/RTO权衡**：

| 配置 | RPO | RTO | 写延迟 | 适用场景 |
|------|-----|-----|--------|---------|
| `local` | 可能丢失数据 | 快 | 最低 | 非关键业务 |
| `remote_write` | 几乎为0 | 中等 | 低 | 一般业务 |
| `remote_apply` | 0 | 慢 | 高 | 关键业务 |
| `ANY 1` | 几乎为0 | 快 | 低 | 高可用场景 |
| `ANY 2` | 0 | 中等 | 中 | 强一致性场景 |

## 4. 高可用组件

- Patroni、pgpool-II、pgbouncer、keepalived

### 4.1 Patroni 基本配置示例

```yaml
scope: pg
namespace: /service/pg
name: node_a

restapi:
  listen: 0.0.0.0:8008
  connect_address: node_a:8008

etcd:
  hosts: [etcd1:2379, etcd2:2379, etcd3:2379]

postgresql:
  listen: 0.0.0.0:5432
  connect_address: node_a:5432
  data_dir: /var/lib/postgresql/data
  bin_dir: /usr/lib/postgresql/16/bin
  parameters:
    wal_level: replica
    max_wal_senders: 10
    max_replication_slots: 10
    synchronous_commit: 'on'
    synchronous_standby_names: 'ANY 1 (node_b, node_c)'
  pg_hba:
    - host all all 0.0.0.0/0 md5
    - host replication repl 0.0.0.0/0 md5
  authentication:
    replication:
      username: repl
      password: "***"
    superuser:
      username: postgres
      password: "***"
```

**完整Patroni部署**：

#### 步骤1: 安装etcd集群

```bash
# 在每个etcd节点上
wget https://github.com/etcd-io/etcd/releases/download/v3.5.9/etcd-v3.5.9-linux-amd64.tar.gz
tar -xzf etcd-v3.5.9-linux-amd64.tar.gz
sudo mv etcd-v3.5.9-linux-amd64/etcd* /usr/local/bin/

# 创建etcd配置
sudo mkdir -p /etc/etcd
sudo nano /etc/etcd/etcd.conf
```

```conf
# etcd1配置
ETCD_NAME=etcd1
ETCD_DATA_DIR=/var/lib/etcd
ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
ETCD_ADVERTISE_CLIENT_URLS=http://etcd1:2379
ETCD_INITIAL_CLUSTER="etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380"
ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster-1
ETCD_INITIAL_CLUSTER_STATE=new
```

```bash
# 启动etcd
sudo systemctl start etcd
sudo systemctl enable etcd

# 验证etcd集群
etcdctl --endpoints=http://etcd1:2379,http://etcd2:2379,http://etcd3:2379 endpoint health
```

#### 步骤2: 安装Patroni

```bash
# 安装Patroni
sudo pip3 install patroni[etcd]

# 创建Patroni配置目录
sudo mkdir -p /etc/patroni
sudo nano /etc/patroni/patroni.yml
```

```yaml
# 完整Patroni配置示例
scope: postgres
namespace: /db/postgres
name: node1

restapi:
  listen: 0.0.0.0:8008
  connect_address: node1:8008
  authentication:
    username: admin
    password: admin_password

etcd:
  hosts: etcd1:2379, etcd2:2379, etcd3:2379
  protocol: http

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 30
    maximum_lag_on_failover: 1048576
    postgresql:
      use_pg_rewind: true
      parameters:
        wal_level: replica
        hot_standby: on
        max_connections: 100
        max_wal_senders: 10
        max_replication_slots: 10
        wal_keep_size: 1GB
        synchronous_commit: 'on'
        synchronous_standby_names: 'ANY 1 (node2, node3)'
  initdb:
    - encoding: UTF8
    - data-checksums
  pg_hba:
    - host replication repl 0.0.0.0/0 md5
    - host all all 0.0.0.0/0 md5
  users:
    admin:
      password: admin_password
      options:
        - createrole
        - createdb

postgresql:
  listen: 0.0.0.0:5432
  connect_address: node1:5432
  data_dir: /var/lib/postgresql/18/data
  bin_dir: /usr/lib/postgresql/18/bin
  pgpass: /var/lib/postgresql/.pgpass
  parameters:
    unix_socket_directories: '/var/run/postgresql'
  authentication:
    replication:
      username: repl
      password: repl_password
    superuser:
      username: postgres
      password: postgres_password

tags:
  nofailover: false
  noloadbalance: false
  clonefrom: false
  nosync: false
```

```bash
# 创建systemd服务
sudo nano /etc/systemd/system/patroni.service
```

```ini
[Unit]
Description=Patroni PostgreSQL High Availability
After=syslog.target network.target

[Service]
Type=simple
User=postgres
Group=postgres
ExecStart=/usr/local/bin/patroni /etc/patroni/patroni.yml
KillMode=process
TimeoutSec=30
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

```bash
# 启动Patroni
sudo systemctl daemon-reload
sudo systemctl enable patroni
sudo systemctl start patroni

# 检查状态
patronictl -c /etc/patroni/patroni.yml list
```

#### 步骤3: 配置keepalived（VIP）

```bash
# 安装keepalived
sudo apt-get install -y keepalived

# 主节点配置
sudo nano /etc/keepalived/keepalived.conf
```

```conf
vrrp_script chk_patroni {
    script "/usr/local/bin/check_patroni.sh"
    interval 2
    weight -2
    fall 3
    rise 2
}

vrrp_instance VI_1 {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 101
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass keepalived_pass
    }
    virtual_ipaddress {
        192.168.1.100/24
    }
    track_script {
        chk_patroni
    }
}
```

```bash
# 创建检查脚本
sudo nano /usr/local/bin/check_patroni.sh
```

```bash
#!/bin/bash
# 检查Patroni是否为主节点（带错误处理）

set -euo pipefail

# 错误处理函数
error_exit() {
    echo "错误: $1" >&2
    exit 1
}

# 检查Patroni配置是否存在
if [ ! -f /etc/patroni/patroni.yml ]; then
    error_exit "Patroni配置文件不存在: /etc/patroni/patroni.yml"
fi

# 检查Patroni是否为主节点
if patronictl -c /etc/patroni/patroni.yml list 2>/dev/null | grep -q "Leader.*node1"; then
    exit 0
else
    exit 1
fi
```

```bash
sudo chmod +x /usr/local/bin/check_patroni.sh
sudo systemctl start keepalived
sudo systemctl enable keepalived
```

#### 步骤4: 配置pgpool-II（读写分离）

```bash
# 安装pgpool-II
sudo apt-get install -y pgpool2

# 配置pgpool.conf
sudo nano /etc/pgpool2/pgpool.conf
```

```conf
listen_addresses = '*'
port = 5432
socket_dir = '/var/run/postgresql'

# 后端节点配置
backend_hostname0 = '192.168.1.100'  # VIP
backend_port0 = 5432
backend_weight0 = 1
backend_flag0 = 'ALLOW_TO_FAILOVER'

backend_hostname1 = 'node2'
backend_port1 = 5432
backend_weight1 = 1
backend_flag1 = 'ALLOW_TO_FAILOVER'

backend_hostname2 = 'node3'
backend_port2 = 5432
backend_weight2 = 1
backend_flag2 = 'ALLOW_TO_FAILOVER'

# 负载均衡
load_balance_mode = on
master_slave_mode = on
master_slave_sub_mode = 'stream'

# 故障转移
failover_on_backend_error = on
```

```bash
# 启动pgpool-II
sudo systemctl start pgpool2
sudo systemctl enable pgpool2
```

虚拟IP/负载均衡：

- 主写 VIP：`keepalived` 绑定主节点；
- 读负载均衡：`pgpool-II`/`haproxy` 转发至只读副本；
- 应用侧强制读写分离与重试策略。

## 5. 故障演练

- 失效与恢复流程、RTO/RPO 评估

### 5.1 故障切换SOP（Patroni）

1) 人为下线主库：`patroni_ctl pause`（演练时）或停止服务；
2) 观察Leader 选举日志与复制延迟，确认新主；
3) 业务侧：写连接指向主写 VIP，读连接检查连接池刷新；
4) 旧主恢复为副本：清理WAL 冲突、重新 `pg_basebackup` 或 `recovery` 追日志。

**完整故障切换流程**：

#### 场景1: 主库故障（自动切换）

```bash
# 1. 模拟主库故障
sudo systemctl stop patroni  # 在主库节点

# 2. 观察Patroni日志（在从库节点）
sudo journalctl -u patroni -f

# 3. 检查新主库选举
patronictl -c /etc/patroni/patroni.yml list

# 4. 验证VIP切换
ip addr show | grep 192.168.1.100

# 5. 验证应用连接（带错误处理）
if ! psql -h 192.168.1.100 -U postgres -d mydb -c "
DO \$\$
DECLARE
    is_in_recovery BOOLEAN;
BEGIN
    SELECT pg_is_in_recovery() INTO is_in_recovery;
    IF is_in_recovery THEN
        RAISE NOTICE '当前节点处于恢复模式（从库）';
    ELSE
        RAISE NOTICE '当前节点为主库';
    END IF;
EXCEPTION
    WHEN undefined_function THEN
        RAISE EXCEPTION 'pg_is_in_recovery函数不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '验证应用连接失败: %', SQLERRM;
END \$\$;
" 2>/dev/null; then
    echo "错误: 无法连接到VIP或验证失败" >&2
    exit 1
fi
```

#### 场景2: 手动切换（维护场景）

```bash
# 1. 暂停当前主库
patronictl -c /etc/patroni/patroni.yml pause

# 2. 手动切换
patronictl -c /etc/patroni/patroni.yml switchover

# 3. 恢复旧主库为从库
patronictl -c /etc/patroni/patroni.yml resume

# 4. 验证切换结果
patronictl -c /etc/patroni/patroni.yml list
```

#### 场景3: 旧主库恢复

```bash
# 1. 检查旧主库状态（带错误处理）
sudo -u postgres psql -c "
DO \$\$
DECLARE
    is_in_recovery BOOLEAN;
BEGIN
    SELECT pg_is_in_recovery() INTO is_in_recovery;
    IF is_in_recovery THEN
        RAISE NOTICE '当前节点处于恢复模式（从库）';
    ELSE
        RAISE NOTICE '当前节点为主库';
    END IF;
EXCEPTION
    WHEN undefined_function THEN
        RAISE EXCEPTION 'pg_is_in_recovery函数不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查旧主库状态失败: %', SQLERRM;
END \$\$;
"

# 2. 如果WAL冲突，使用pg_rewind（带错误处理）
set -euo pipefail

error_exit() {
    echo "错误: $1" >&2
    exit 1
}

if ! sudo systemctl stop patroni 2>/dev/null; then
    echo "警告: 无法停止Patroni服务，可能已经停止" >&2
fi

if [ ! -d /var/lib/postgresql/18/data ]; then
    error_exit "数据目录不存在: /var/lib/postgresql/18/data"
fi

if ! sudo -u postgres /usr/lib/postgresql/18/bin/pg_rewind \
    --target-server="host=192.168.1.100 port=5432 user=postgres" \
    -D /var/lib/postgresql/18/data 2>/dev/null; then
    error_exit "pg_rewind执行失败"
fi

# 3. 配置恢复（带错误处理）
if [ ! -d /var/lib/postgresql/18/data ]; then
    error_exit "数据目录不存在: /var/lib/postgresql/18/data"
fi

if ! sudo -u postgres cat > /var/lib/postgresql/18/data/standby.signal <<EOF
standby_mode = 'on'
primary_conninfo = 'host=192.168.1.100 port=5432 user=repl'
primary_slot_name = 'node1'
EOF
then
    error_exit "无法创建standby.signal文件"
fi

# 4. 启动Patroni（带错误处理）
if ! sudo systemctl start patroni 2>/dev/null; then
    error_exit "无法启动Patroni服务"
fi

# 5. 验证恢复（带错误处理）
if ! patronictl -c /etc/patroni/patroni.yml list 2>/dev/null; then
    error_exit "无法获取Patroni集群状态"
fi
```

### 5.2 只读副本延迟监控

```sql
-- 只读副本延迟监控（带错误处理和性能测试）
DO $$
DECLARE
    replication_count INT;
BEGIN
    SELECT COUNT(*) INTO replication_count
    FROM pg_stat_replication;

    IF replication_count = 0 THEN
        RAISE WARNING '未找到复制连接';
    ELSE
        RAISE NOTICE '找到 % 个复制连接', replication_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_stat_replication视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '监控复制延迟失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT application_name, state, sync_state,
       pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS byte_lag
FROM pg_stat_replication;
-- 执行时间: <50ms
-- 计划: Seq Scan
```

**完整监控查询**：

```sql
-- 1. 复制延迟监控（带错误处理和性能测试）
DO $$
DECLARE
    replication_count INT;
BEGIN
    SELECT COUNT(*) INTO replication_count
    FROM pg_stat_replication;

    IF replication_count = 0 THEN
        RAISE WARNING '未找到复制连接';
    ELSE
        RAISE NOTICE '找到 % 个复制连接', replication_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_stat_replication视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '监控复制延迟失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    application_name,
    client_addr,
    state,
    sync_state,
    sync_priority,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS sent_lag_bytes,
    pg_wal_lsn_diff(sent_lsn, write_lsn) AS write_lag_bytes,
    pg_wal_lsn_diff(write_lsn, flush_lsn) AS flush_lag_bytes,
    pg_wal_lsn_diff(flush_lsn, replay_lsn) AS replay_lag_bytes,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS total_lag_bytes,
    EXTRACT(EPOCH FROM (now() - replay_lag_time)) AS replay_lag_seconds
FROM pg_stat_replication
ORDER BY total_lag_bytes DESC;
-- 执行时间: <100ms
-- 计划: Sort

-- 2. 复制槽状态（带错误处理和性能测试）
DO $$
DECLARE
    slot_count INT;
BEGIN
    SELECT COUNT(*) INTO slot_count
    FROM pg_replication_slots;

    IF slot_count = 0 THEN
        RAISE WARNING '未找到复制槽';
    ELSE
        RAISE NOTICE '找到 % 个复制槽', slot_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_replication_slots视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询复制槽状态失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    slot_name,
    slot_type,
    database,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) AS lag_bytes,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS lag_size
FROM pg_replication_slots;
-- 执行时间: <50ms
-- 计划: Seq Scan

-- 3. WAL发送统计（带错误处理和性能测试）
DO $$
DECLARE
    replication_count INT;
BEGIN
    SELECT COUNT(*) INTO replication_count
    FROM pg_stat_replication;

    IF replication_count = 0 THEN
        RAISE WARNING '未找到复制连接';
    ELSE
        RAISE NOTICE '找到 % 个复制连接', replication_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_stat_replication视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询WAL发送统计失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn,
    sync_state,
    sync_priority
FROM pg_stat_replication;
-- 执行时间: <50ms
-- 计划: Seq Scan

-- 4. 复制延迟告警查询（带错误处理和性能测试）
DO $$
DECLARE
    replication_count INT;
BEGIN
    SELECT COUNT(*) INTO replication_count
    FROM pg_stat_replication;

    IF replication_count = 0 THEN
        RAISE WARNING '未找到复制连接';
    ELSE
        RAISE NOTICE '找到 % 个复制连接', replication_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_stat_replication视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询复制延迟告警失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    application_name,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) AS lag_size,
    EXTRACT(EPOCH FROM (now() - replay_lag_time)) AS lag_seconds,
    CASE
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) > 1073741824 THEN 'CRITICAL'  -- >1GB
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) > 536870912 THEN 'WARNING'   -- >512MB
        ELSE 'OK'
    END AS status
FROM pg_stat_replication;
-- 执行时间: <100ms
-- 计划: Seq Scan
```

**Prometheus监控配置**：

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'postgres_replication'
    static_configs:
      - targets: ['postgres:5432']
    metrics_path: '/metrics'
    params:
      format: ['prometheus']
```

**Grafana监控面板**：

```promql
# 复制延迟（字节）
pg_replication_lag_bytes{instance="postgres:5432"}

# 复制延迟（秒）
pg_replication_lag_seconds{instance="postgres:5432"}

# 同步状态
pg_replication_sync_state{instance="postgres:5432"}
```

### 5.3 RTO/RPO评估

**RTO（Recovery Time Objective）恢复时间目标**：

```bash
#!/bin/bash
# RTO测量脚本（带错误处理）

set -euo pipefail

error_exit() {
    echo "错误: $1" >&2
    exit 1
}

# 测量故障切换时间
START_TIME=$(date +%s)

# 执行故障切换（带错误处理）
if ! sudo systemctl stop patroni 2>/dev/null; then
    error_exit "无法停止Patroni服务"
fi

# 等待切换完成（带超时和错误处理）
MAX_WAIT=60  # 最多等待60秒
WAIT_COUNT=0
SWITCH_SUCCESS=false

while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
    if patronictl list 2>/dev/null | grep -q "Leader"; then
        SWITCH_SUCCESS=true
        break
    fi
    sleep 1
    WAIT_COUNT=$((WAIT_COUNT + 1))
done

if [ "$SWITCH_SUCCESS" = false ]; then
    error_exit "故障切换超时（${MAX_WAIT}秒内未完成）"
fi

END_TIME=$(date +%s)
RTO=$((END_TIME - START_TIME))
echo "RTO: ${RTO} seconds"
```

**RPO（Recovery Point Objective）恢复点目标**：

```sql
-- 检查数据丢失风险（带错误处理和性能测试）
DO $$
DECLARE
    replication_count INT;
BEGIN
    SELECT COUNT(*) INTO replication_count
    FROM pg_stat_replication;

    IF replication_count = 0 THEN
        RAISE WARNING '未找到复制连接，无法评估RPO';
    ELSE
        RAISE NOTICE '找到 % 个复制连接', replication_count;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING 'pg_stat_replication视图不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查数据丢失风险失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    application_name,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes,
    CASE
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) = 0 THEN 'RPO = 0'
        ELSE 'RPO > 0'
    END AS rpo_status
FROM pg_stat_replication;
-- 执行时间: <50ms
-- 计划: Seq Scan
```

**故障演练脚本**：

```bash
#!/bin/bash
# 故障演练脚本（带错误处理）

set -euo pipefail

# 错误处理函数
error_exit() {
    echo "错误: $1" >&2
    exit 1
}

echo "=== PostgreSQL故障演练 ==="

# 1. 记录当前状态（带错误处理）
echo "1. 记录当前状态"
if ! patronictl list > /tmp/before_failover.txt 2>/dev/null; then
    error_exit "无法获取Patroni集群状态"
fi

if [ ! -f /tmp/before_failover.txt ]; then
    error_exit "状态文件创建失败"
fi

cat /tmp/before_failover.txt

# 2. 模拟主库故障（带错误处理）
echo "2. 模拟主库故障"
read -p "输入主库节点名: " PRIMARY_NODE

if [ -z "$PRIMARY_NODE" ]; then
    error_exit "主库节点名不能为空"
fi

if ! ssh "$PRIMARY_NODE" "sudo systemctl stop patroni" 2>/dev/null; then
    error_exit "无法停止主库节点 $PRIMARY_NODE 的Patroni服务"
fi

# 3. 等待切换（带错误处理）
echo "3. 等待故障切换（最多60秒）"
SWITCH_SUCCESS=false
for i in {1..60}; do
    if patronictl list 2>/dev/null | grep -q "Leader"; then
        echo "故障切换完成"
        SWITCH_SUCCESS=true
        break
    fi
    sleep 1
    echo -n "."
done

if [ "$SWITCH_SUCCESS" = false ]; then
    error_exit "故障切换超时（60秒内未完成）"
fi

# 4. 验证新主库（带错误处理）
echo "4. 验证新主库"
if ! patronictl list > /tmp/after_failover.txt 2>/dev/null; then
    error_exit "无法获取切换后的Patroni集群状态"
fi

NEW_LEADER=$(patronictl list 2>/dev/null | grep Leader | awk '{print $2}' || echo "")
if [ -z "$NEW_LEADER" ]; then
    error_exit "无法识别新主库节点"
fi

echo "新主库: $NEW_LEADER"

# 5. 验证应用连接（带错误处理）
echo "5. 验证应用连接"
if ! psql -h 192.168.1.100 -U postgres -d mydb -c "
DO \$\$
DECLARE
    is_in_recovery BOOLEAN;
BEGIN
    SELECT pg_is_in_recovery() INTO is_in_recovery;
    IF is_in_recovery THEN
        RAISE NOTICE '当前节点处于恢复模式（从库）';
    ELSE
        RAISE NOTICE '当前节点为主库';
    END IF;
EXCEPTION
    WHEN undefined_function THEN
        RAISE EXCEPTION 'pg_is_in_recovery函数不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '验证应用连接失败: %', SQLERRM;
END \$\$;
" 2>/dev/null; then
    echo "错误: 无法连接到VIP或验证失败" >&2
    exit 1
fi

# 6. 恢复旧主库（带错误处理）
echo "6. 恢复旧主库"
read -p "是否恢复旧主库? (y/n): " RESTORE
if [ "$RESTORE" = "y" ]; then
    if ! ssh "$PRIMARY_NODE" "sudo systemctl start patroni" 2>/dev/null; then
        error_exit "无法启动旧主库节点 $PRIMARY_NODE 的Patroni服务"
    fi

    echo "等待旧主库恢复（10秒）..."
    sleep 10

    if ! patronictl list 2>/dev/null; then
        error_exit "无法获取恢复后的Patroni集群状态"
    fi
fi

echo "=== 故障演练完成 ==="
```

## 6. 后续整合任务

- 统一术语，提供参考拓扑与脚本清单
  - 三节点（1主2从）强一致与仲裁示意图
  - Patroni + etcd + VIP + pgbouncer/pgpool-II 最小落地脚本

---

## 7. 形式证明与理论论证

### 7.1 复制一致性保证证明

**定理**: 同步复制保证主从数据库的数据一致性。

**证明**:

```latex
\begin{theorem}[复制一致性保证]
设主数据库 M 和从数据库 S，同步复制协议。

同步复制定义：
事务 T 在主库 M 提交，当且仅当：
1. T 的WAL记录已写入主库磁盘
2. T 的WAL记录已传输到从库 S
3. 从库 S 已确认收到WAL记录

一致性保证：
\forall T: \text{committed}(T, M) \Leftrightarrow \text{committed}(T, S)

证明：
1. 如果 T 在主库提交，则根据同步复制定义，从库必须已收到WAL记录
2. 从库应用WAL记录后，数据状态与主库一致
3. 因此，主从数据库的数据状态一致

PostgreSQL实现：
1. synchronous_commit = on 启用同步复制
2. synchronous_standby_names 指定同步从库
3. 主库等待从库确认后才提交事务

因此，同步复制保证主从数据库的数据一致性。
\end{theorem}
```

### 7.2 故障切换正确性证明

**定理**: 故障切换算法能够正确选择新的主库，保证数据一致性。

**证明**:

```latex
\begin{theorem}[故障切换正确性]
设集群 C = \{M, S_1, S_2, \ldots, S_n\}，其中 M 为主库，S_i 为从库。

故障检测：
\text{failed}(M) \Leftrightarrow \text{heartbeat}(M) \text{ timeout}

故障切换算法：
1. 检测主库故障
2. 选择最新的从库作为新主库
3. 其他从库切换到新主库

正确性条件：
1. 唯一性：只有一个从库被选为新主库
2. 最新性：选中的从库数据最新
3. 一致性：切换后数据状态一致

证明：
1. 唯一性：通过分布式锁（如etcd）保证只有一个从库被选中
2. 最新性：比较LSN（Log Sequence Number），选择LSN最大的从库
3. 一致性：新主库应用所有已提交的WAL记录，保证数据一致性

PostgreSQL实现：
1. Patroni使用etcd实现分布式锁
2. 比较pg_last_wal_replay_lsn选择最新从库
3. 其他从库通过pg_rewind或重新同步切换到新主库

因此，故障切换算法能够正确选择新的主库，保证数据一致性。
\end{theorem}
```

### 7.3 高可用性保证证明

**定理**: 主从复制架构能够提高系统的可用性。

**证明**:

```latex
\begin{theorem}[高可用性保证]
设单机系统可用性为 A_1，主从复制系统可用性为 A_2。

单机系统：
A_1 = \text{MTBF} / (\text{MTBF} + \text{MTTR})

其中 MTBF 为平均故障间隔时间，MTTR 为平均修复时间。

主从复制系统：
如果主库故障，系统切换到从库，系统仍可用。

系统可用性：
A_2 = 1 - (1 - A_1)^2

其中 (1 - A_1)^2 表示主库和从库同时故障的概率。

可用性提升：
\Delta A = A_2 - A_1 = A_1(1 - A_1) > 0

因此，主从复制架构提高了系统的可用性。

PostgreSQL实现：
1. 主从复制提供冗余
2. 自动故障切换减少MTTR
3. 多从库架构进一步提高可用性

因此，主从复制架构能够提高系统的可用性。
\end{theorem}
```

---

## 8. Wikipedia对齐

### 8.1 高可用性概念对齐

- **Wikidata ID**: Q192490 (High availability)
- **相关属性**:
  - P31: Q192490 (instance of: system characteristic)
- **外部链接**:
  - [Wikipedia - High availability](https://en.wikipedia.org/wiki/High_availability)
  - [Wikipedia - Database replication](https://en.wikipedia.org/wiki/Database_replication)
  - [Wikipedia - Failover](https://en.wikipedia.org/wiki/Failover)

**Wikipedia定义**: [High availability](https://en.wikipedia.org/wiki/High_availability)

> High availability (HA) is a characteristic of a system that aims to ensure an agreed level of operational performance, usually uptime, for a higher than normal period.

**对齐说明**:

- ✅ **定义一致性**: 本文档的定义与Wikipedia一致，都强调高可用性是确保系统正常运行时间的特性
- ✅ **核心指标**: 都提到RTO、RPO、可用性百分比等核心指标
- ✅ **实现方式**: 都提到故障检测、故障切换、冗余等实现方式

### 8.2 数据库复制概念对齐

**Wikipedia定义**: [Database replication](https://en.wikipedia.org/wiki/Database_replication)

> Database replication is the frequent electronic copying of data from a database in one computer or server to a database in another so that all users share the same level of information.

**对齐说明**:

- ✅ **定义一致性**: 本文档的定义与Wikipedia一致，都强调数据库复制是数据的频繁电子复制
- ✅ **复制类型**: 都提到主从复制、同步复制、异步复制等类型
- ✅ **应用场景**: 都提到高可用、负载均衡、灾难恢复等应用场景

### 8.3 故障转移概念对齐

**Wikipedia定义**: [Failover](https://en.wikipedia.org/wiki/Failover)

> Failover is switching to a redundant or standby computer server, system, hardware component or network upon the failure or abnormal termination of the previously active application, server, system, hardware component or network.

**对齐说明**:

- ✅ **定义一致性**: 本文档的定义与Wikipedia一致，都强调故障转移是在故障时切换到备用系统
- ✅ **切换类型**: 都提到自动切换、手动切换等类型
- ✅ **切换时间**: 都提到RTO（恢复时间目标）等指标

### 8.4 PostgreSQL高可用对齐

- **Wikidata ID**: Q192490
- **相关属性**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **外部链接**:
  - <https://www.postgresql.org/docs/current/high-availability.html>
  - <https://www.postgresql.org/docs/current/warm-standby.html>

---

## 9. 交叉引用

### 相关文档

#### 部署架构

- ⭐⭐⭐ [主从复制](./05.05-主从复制.md) - 主从复制配置
- ⭐⭐⭐ [读写分离](./05.06-读写分离.md) - 读写分离架构
- ⭐⭐ [分布式架构设计](../分布式部署/05.08-分布式架构设计.md) - 分布式架构
- ⭐⭐ [性能调优实践](../单机部署/05.02-性能调优实践.md) - 性能优化

#### 核心课程

- ⭐⭐⭐ [事务管理与ACID特性](../../../03-事务与并发/03.02-ACID特性/01.04-事务管理与ACID特性.md) - 事务理论
- ⭐⭐ [并发控制与MVCC机制](../../../03-事务与并发/03.01-MVCC机制/01.05-并发控制与MVCC机制.md) - 并发控制
- ⭐⭐ [存储管理与数据持久化](../../../04-存储与恢复/01.06-存储管理与数据持久化.md) - 存储管理

#### 运维实践

- ⭐⭐⭐ [监控与诊断](../../../12-监控与诊断/06.01-监控与诊断.md) - 监控诊断
- ⭐⭐⭐ [备份与恢复](../../../13-高可用架构/备份与恢复/06.06-备份与恢复.md) - 备份恢复
- ⭐⭐ [高可用架构](../../../13-高可用架构/README.md) - 故障处理

#### 高级特性

- ⭐⭐ [分布式系统](../../../15-分布式系统/README.md) - 分布式事务

#### 应用架构

- ⭐⭐ [高可用架构设计](../../../13-高可用架构/README.md) - 高可用架构理论

---

**文档版本**: v2.0
**最后更新**: 2025-11-22
**维护者**: PostgreSQL Documentation Team
