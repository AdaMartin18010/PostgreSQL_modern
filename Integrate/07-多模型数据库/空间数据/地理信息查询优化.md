# 地理信息查询优化

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 18+, PostGIS 3.4+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [地理信息查询优化](#地理信息查询优化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 空间索引优化](#2-空间索引优化)
    - [2.1 GIST索引](#21-gist索引)
    - [2.2 索引维护](#22-索引维护)
  - [3. 查询优化技巧](#3-查询优化技巧)
    - [3.1 使用边界框预过滤](#31-使用边界框预过滤)
    - [3.2 几何简化](#32-几何简化)
    - [3.3 使用LIMIT](#33-使用limit)
  - [4. 性能监控](#4-性能监控)
    - [4.1 查看索引使用情况](#41-查看索引使用情况)
    - [4.2 分析查询计划](#42-分析查询计划)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

地理信息查询优化是PostGIS应用性能的关键。主要优化方向包括：

- **空间索引优化** - GIST索引调优
- **查询优化** - 查询语句优化
- **几何简化** - 减少几何复杂度
- **边界框预过滤** - 使用&&操作符

---

## 2. 空间索引优化

### 2.1 GIST索引

```sql
-- 创建GIST索引（默认，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE EXCEPTION '表places不存在，请先创建';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_extension
        WHERE extname = 'postgis'
    ) THEN
        RAISE EXCEPTION 'PostGIS扩展未安装，请先安装';
    END IF;

    -- 创建GIST索引（默认）
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx'
    ) THEN
        CREATE INDEX places_geom_idx ON places USING GIST (location);
        RAISE NOTICE '索引创建成功: places_geom_idx';
    END IF;

    -- 使用填充因子（fillfactor）
    -- 对于只读或很少更新的表，可以设置更高的填充因子
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx_fillfactor'
    ) THEN
        CREATE INDEX places_geom_idx_fillfactor ON places
        USING GIST (location) WITH (fillfactor=100);
        RAISE NOTICE '索引创建成功: places_geom_idx_fillfactor (fillfactor=100)';
    END IF;

    -- 部分索引（只索引特定条件的数据）
    IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'places'
        AND column_name = 'status'
    ) THEN
        IF NOT EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE schemaname = 'public'
            AND tablename = 'places'
            AND indexname = 'places_active_geom_idx'
        ) THEN
            CREATE INDEX places_active_geom_idx ON places
            USING GIST (location)
            WHERE status = 'active';
            RAISE NOTICE '部分索引创建成功: places_active_geom_idx';
        END IF;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表places不存在';
    WHEN undefined_object THEN
        RAISE EXCEPTION 'GIST索引方法或PostGIS扩展不存在';
    WHEN duplicate_table THEN
        RAISE WARNING '索引已存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建索引失败: %', SQLERRM;
END $$;
```

### 2.2 索引维护

```sql
-- 定期VACUUM维护索引（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE WARNING '表places不存在';
        RETURN;
    END IF;

    -- 注意：VACUUM不能在事务块中使用，需要单独执行
    RAISE NOTICE '请单独执行: VACUUM ANALYZE places;';
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查失败: %', SQLERRM;
END $$;

-- 注意：VACUUM不能在DO块中使用，需要单独执行
-- VACUUM ANALYZE places;

-- 重建索引（如果索引膨胀，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND indexname = 'places_geom_idx'
    ) THEN
        RAISE WARNING '索引places_geom_idx不存在';
    ELSE
        -- 注意：REINDEX不能在事务块中使用，需要单独执行
        RAISE NOTICE '请单独执行: REINDEX INDEX places_geom_idx;';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查失败: %', SQLERRM;
END $$;

-- 注意：REINDEX不能在DO块中使用，需要单独执行
-- REINDEX INDEX places_geom_idx;
```

---

## 3. 查询优化技巧

### 3.1 使用边界框预过滤

```sql
-- ✅ 推荐：先使用&&进行边界框过滤，再精确计算（带性能测试和错误处理）
DO $$
DECLARE
    result_count INT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE WARNING '表places不存在';
        RETURN;
    END IF;

    SELECT COUNT(*) INTO result_count
    FROM places
    WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326);

    RAISE NOTICE '找到 % 条在边界框内的记录', result_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING '表places不存在';
    WHEN undefined_function THEN
        RAISE EXCEPTION 'PostGIS函数不存在，请检查PostGIS扩展安装';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询准备失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326)  -- 使用索引
  AND ST_DWithin(location::geography,
                 ST_SetSRID(ST_MakePoint(116.4, 39.95), 4326)::geography,
                 1000);  -- 精确过滤
-- 执行时间: <50ms（使用GIST索引）
-- 计划: Index Scan using places_geom_idx

-- ❌ 不推荐：直接使用距离计算（无法使用索引，带性能测试）
DO $$
DECLARE
    result_count INT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE WARNING '表places不存在';
        RETURN;
    END IF;

    RAISE NOTICE '警告：此查询无法使用索引，性能较差';
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING '表places不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询准备失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM places
WHERE ST_Distance(location::geography,
                  ST_SetSRID(ST_MakePoint(116.4, 39.95), 4326)::geography) < 1000;
-- 执行时间: >500ms（全表扫描）
-- 计划: Seq Scan on places
```

### 3.2 几何简化

```sql
-- 对于复杂几何，使用简化版本进行查询（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'regions') THEN
        RAISE EXCEPTION '表regions不存在，请先创建';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'regions'
        AND column_name = 'boundary_simplified'
    ) THEN
        ALTER TABLE regions ADD COLUMN boundary_simplified GEOMETRY(POLYGON, 4326);
        RAISE NOTICE '列添加成功: boundary_simplified';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'regions'
        AND column_name = 'boundary'
    ) THEN
        RAISE EXCEPTION '表regions没有boundary列';
    END IF;

    UPDATE regions
    SET boundary_simplified = ST_Simplify(boundary, 0.001)
    WHERE boundary IS NOT NULL;

    RAISE NOTICE '简化几何更新完成';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表regions不存在';
    WHEN undefined_function THEN
        RAISE EXCEPTION 'ST_Simplify函数不存在，请检查PostGIS扩展安装';
    WHEN OTHERS THEN
        RAISE EXCEPTION '更新失败: %', SQLERRM;
END $$;

CREATE INDEX regions_boundary_simplified_idx
ON regions USING GIST (boundary_simplified);

-- 查询时使用简化几何
SELECT * FROM regions
WHERE boundary_simplified && query_bbox  -- 快速过滤
  AND ST_Intersects(boundary, query_geom);  -- 精确判断

```

### 3.3 使用LIMIT

```sql
-- 使用LIMIT限制结果数量
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326)
ORDER BY ST_Distance(location::geography, query_point::geography)
LIMIT 10;
```

---

## 4. 性能监控

### 4.1 查看索引使用情况

```sql
-- 查看索引使用统计
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'places'
ORDER BY idx_scan DESC;
```

### 4.2 分析查询计划

```sql
-- 使用EXPLAIN分析查询计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326)
  AND ST_DWithin(location::geography, query_point::geography, 1000);
```

---

## 5. 最佳实践

### ✅ 推荐做法

1. **使用GIST索引** - 所有空间列都应该有索引
2. **边界框预过滤** - 先使用&&，再精确计算
3. **几何简化** - 对于复杂几何使用简化版本
4. **合理使用LIMIT** - 限制结果数量
5. **定期维护索引** - VACUUM和REINDEX

### ❌ 避免做法

1. **不使用空间索引** - 空间查询性能会极差
2. **直接距离计算** - 应该先使用边界框过滤
3. **忽略索引维护** - 索引膨胀会影响性能
4. **过度复杂的几何** - 简化几何可以提升性能

---

## 📚 相关文档

- [PostGIS完整深化指南.md](./PostGIS完整深化指南.md) - PostGIS完整指南
- [空间数据建模指南.md](./空间数据建模指南.md) - 空间数据建模
- [02-查询与优化/02.06-性能调优/](../../02-查询与优化/02.06-性能调优/README.md) - 性能调优指南

---

**最后更新**: 2025年1月
