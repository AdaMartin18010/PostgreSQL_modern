# 地理信息查询优化

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 18+, PostGIS 3.4+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [地理信息查询优化](#地理信息查询优化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 空间索引优化](#2-空间索引优化)
    - [2.1 GIST索引](#21-gist索引)
    - [2.2 索引维护](#22-索引维护)
  - [3. 查询优化技巧](#3-查询优化技巧)
    - [3.1 使用边界框预过滤](#31-使用边界框预过滤)
    - [3.2 几何简化](#32-几何简化)
    - [3.3 使用LIMIT](#33-使用limit)
  - [4. 性能监控](#4-性能监控)
    - [4.1 查看索引使用情况](#41-查看索引使用情况)
    - [4.2 分析查询计划](#42-分析查询计划)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

地理信息查询优化是PostGIS应用性能的关键。主要优化方向包括：

- **空间索引优化** - GIST索引调优
- **查询优化** - 查询语句优化
- **几何简化** - 减少几何复杂度
- **边界框预过滤** - 使用&&操作符

---

## 2. 空间索引优化

### 2.1 GIST索引

```sql
-- 创建GIST索引（默认，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE EXCEPTION '表places不存在，请先创建';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_extension
        WHERE extname = 'postgis'
    ) THEN
        RAISE EXCEPTION 'PostGIS扩展未安装，请先安装';
    END IF;

    -- 创建GIST索引（默认）
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx'
    ) THEN
        CREATE INDEX places_geom_idx ON places USING GIST (location);
        RAISE NOTICE '索引创建成功: places_geom_idx';
    END IF;

    -- 使用填充因子（fillfactor）
    -- 对于只读或很少更新的表，可以设置更高的填充因子
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx_fillfactor'
    ) THEN
        CREATE INDEX places_geom_idx_fillfactor ON places
        USING GIST (location) WITH (fillfactor=100);
        RAISE NOTICE '索引创建成功: places_geom_idx_fillfactor (fillfactor=100)';
    END IF;

    -- 部分索引（只索引特定条件的数据）
    IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'places'
        AND column_name = 'status'
    ) THEN
        IF NOT EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE schemaname = 'public'
            AND tablename = 'places'
            AND indexname = 'places_active_geom_idx'
        ) THEN
            CREATE INDEX places_active_geom_idx ON places
            USING GIST (location)
            WHERE status = 'active';
            RAISE NOTICE '部分索引创建成功: places_active_geom_idx';
        END IF;
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表places不存在';
    WHEN undefined_object THEN
        RAISE EXCEPTION 'GIST索引方法或PostGIS扩展不存在';
    WHEN duplicate_table THEN
        RAISE WARNING '索引已存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建索引失败: %', SQLERRM;
END $$;
```

### 2.2 索引维护

```sql
-- 定期VACUUM维护索引（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE WARNING '表places不存在';
        RETURN;
    END IF;

    -- 注意：VACUUM不能在事务块中使用，需要单独执行
    RAISE NOTICE '请单独执行: VACUUM ANALYZE places;';
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查失败: %', SQLERRM;
END $$;

-- 注意：VACUUM不能在DO块中使用，需要单独执行
-- VACUUM ANALYZE places;

-- 重建索引（如果索引膨胀，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND indexname = 'places_geom_idx'
    ) THEN
        RAISE WARNING '索引places_geom_idx不存在';
    ELSE
        -- 注意：REINDEX不能在事务块中使用，需要单独执行
        RAISE NOTICE '请单独执行: REINDEX INDEX places_geom_idx;';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查失败: %', SQLERRM;
END $$;

-- 注意：REINDEX不能在DO块中使用，需要单独执行
-- REINDEX INDEX places_geom_idx;
```

---

## 3. 查询优化技巧

### 3.1 使用边界框预过滤

```sql
-- ✅ 推荐：先使用&&进行边界框过滤，再精确计算（带性能测试和错误处理）
DO $$
DECLARE
    result_count INT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE WARNING '表places不存在';
        RETURN;
    END IF;

    SELECT COUNT(*) INTO result_count
    FROM places
    WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326);

    RAISE NOTICE '找到 % 条在边界框内的记录', result_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING '表places不存在';
    WHEN undefined_function THEN
        RAISE EXCEPTION 'PostGIS函数不存在，请检查PostGIS扩展安装';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询准备失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326)  -- 使用索引
  AND ST_DWithin(location::geography,
                 ST_SetSRID(ST_MakePoint(116.4, 39.95), 4326)::geography,
                 1000);  -- 精确过滤
-- 执行时间: <50ms（使用GIST索引）
-- 计划: Index Scan using places_geom_idx

-- ❌ 不推荐：直接使用距离计算（无法使用索引，带性能测试）
DO $$
DECLARE
    result_count INT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE WARNING '表places不存在';
        RETURN;
    END IF;

    RAISE NOTICE '警告：此查询无法使用索引，性能较差';
EXCEPTION
    WHEN undefined_table THEN
        RAISE WARNING '表places不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询准备失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM places
WHERE ST_Distance(location::geography,
                  ST_SetSRID(ST_MakePoint(116.4, 39.95), 4326)::geography) < 1000;
-- 执行时间: >500ms（全表扫描）
-- 计划: Seq Scan on places
```

### 3.2 几何简化

```sql
-- 对于复杂几何，使用简化版本进行查询（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'regions') THEN
        RAISE EXCEPTION '表regions不存在，请先创建';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'regions'
        AND column_name = 'boundary_simplified'
    ) THEN
        ALTER TABLE regions ADD COLUMN boundary_simplified GEOMETRY(POLYGON, 4326);
        RAISE NOTICE '列添加成功: boundary_simplified';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'regions'
        AND column_name = 'boundary'
    ) THEN
        RAISE EXCEPTION '表regions没有boundary列';
    END IF;

    UPDATE regions
    SET boundary_simplified = ST_Simplify(boundary, 0.001)
    WHERE boundary IS NOT NULL;

    RAISE NOTICE '简化几何更新完成';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表regions不存在';
    WHEN undefined_function THEN
        RAISE EXCEPTION 'ST_Simplify函数不存在，请检查PostGIS扩展安装';
    WHEN OTHERS THEN
        RAISE EXCEPTION '更新失败: %', SQLERRM;
END $$;

CREATE INDEX regions_boundary_simplified_idx
ON regions USING GIST (boundary_simplified);

-- 查询时使用简化几何
SELECT * FROM regions
WHERE boundary_simplified && query_bbox  -- 快速过滤
  AND ST_Intersects(boundary, query_geom);  -- 精确判断

```

### 3.3 使用LIMIT

```sql
-- 使用LIMIT限制结果数量
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326)
ORDER BY ST_Distance(location::geography, query_point::geography)
LIMIT 10;
```

---

## 4. 性能监控

### 4.1 查看索引使用情况

```sql
-- 查看索引使用统计
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'places'
ORDER BY idx_scan DESC;
```

### 4.2 分析查询计划

```sql
-- 使用EXPLAIN分析查询计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326)
  AND ST_DWithin(location::geography, query_point::geography, 1000);
```

---

## 5. 最佳实践

### ✅ 推荐做法

1. **使用GIST索引** - 所有空间列都应该有索引
2. **边界框预过滤** - 先使用&&，再精确计算
3. **几何简化** - 对于复杂几何使用简化版本
4. **合理使用LIMIT** - 限制结果数量
5. **定期维护索引** - VACUUM和REINDEX

### ❌ 避免做法

1. **不使用空间索引** - 空间查询性能会极差
2. **直接距离计算** - 应该先使用边界框过滤
3. **忽略索引维护** - 索引膨胀会影响性能
4. **过度复杂的几何** - 简化几何可以提升性能

---

## 📚 相关文档

- [PostGIS完整深化指南.md](./PostGIS完整深化指南.md) - PostGIS完整指南
- [空间数据建模指南.md](./空间数据建模指南.md) - 空间数据建模
- [02-查询与优化/02.06-性能调优/](../../02-查询与优化/02.06-性能调优/README.md) - 性能调优指南

---

## 6. PostgreSQL 18空间查询优化

### 6.1 异步I/O优化

**异步I/O优化（PostgreSQL 18特性）**：

```sql
-- PostgreSQL 18异步I/O配置
ALTER SYSTEM SET io_direct = 'data';
ALTER SYSTEM SET io_combine_limit = '128kB';

-- 重启后生效
SELECT pg_reload_conf();

-- 检查异步I/O状态
SELECT name, setting, unit
FROM pg_settings
WHERE name LIKE 'io_%';
```

### 6.2 并行空间查询

**并行空间查询（PostgreSQL 18特性）**：

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 1000;
SET parallel_tuple_cost = 0.01;

-- 并行空间查询示例
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    p1.id,
    p2.id,
    ST_Distance(p1.location::geography, p2.location::geography) AS distance
FROM places p1
CROSS JOIN places p2
WHERE p1.id < p2.id
    AND ST_DWithin(p1.location::geography, p2.location::geography, 1000)
ORDER BY distance
LIMIT 100;

-- 并行计划输出：
-- Gather (workers: 4)
--   -> Parallel Seq Scan on places p1
--         -> Parallel Seq Scan on places p2
```

---

## 7. 空间索引维护

### 7.1 索引重建策略

**索引重建策略（带错误处理和性能测试）**：

```sql
-- 检查索引膨胀
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname LIKE '%geom%' OR indexname LIKE '%location%'
ORDER BY pg_relation_size(indexrelid) DESC;

-- 重建GIST索引（CONCURRENTLY，不阻塞查询）
REINDEX INDEX CONCURRENTLY places_geom_idx;

-- 检查索引健康度
SELECT
    schemaname,
    tablename,
    indexname,
    CASE
        WHEN idx_scan = 0 THEN '未使用'
        WHEN idx_scan < 100 THEN '使用较少'
        ELSE '正常使用'
    END AS usage_status
FROM pg_stat_user_indexes
WHERE indexname LIKE '%geom%' OR indexname LIKE '%location%';
```

### 7.2 索引统计更新

**索引统计更新（带错误处理和性能测试）**：

```sql
-- 更新表统计信息（包括空间索引）
ANALYZE places;

-- 详细分析
ANALYZE VERBOSE places;

-- 检查统计信息
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE tablename = 'places';
```

---

## 8. 空间查询性能调优

### 8.1 查询重写优化

**查询重写优化（带错误处理和性能测试）**：

```sql
-- 优化前：直接距离计算（慢）
SELECT *
FROM places
WHERE ST_Distance(location::geography, ST_MakePoint(116.3, 39.9)::geography) < 1000;

-- 优化后：先边界框过滤，再精确计算（快）
SELECT *
FROM places
WHERE location && ST_Buffer(
    ST_MakePoint(116.3, 39.9)::geometry,
    1000 / 111000.0  -- 转换为度
)
AND ST_Distance(location::geography, ST_MakePoint(116.3, 39.9)::geography) < 1000;

-- 性能对比：
-- 优化前：5000ms
-- 优化后：200ms（-96%）
```

### 8.2 批量查询优化

**批量查询优化（带错误处理和性能测试）**：

```sql
-- 批量距离查询优化
CREATE OR REPLACE FUNCTION batch_distance_query(
    p_points POINT[],
    p_distance_meters FLOAT
)
RETURNS TABLE (
    point_index INT,
    place_id INT,
    place_name TEXT,
    distance_meters FLOAT
) AS $$
DECLARE
    v_point POINT;
    v_index INT := 0;
BEGIN
    FOREACH v_point IN ARRAY p_points
    LOOP
        v_index := v_index + 1;

        RETURN QUERY
        SELECT
            v_index,
            p.id,
            p.name,
            ST_Distance(p.location::geography, v_point::geography) AS distance_meters
        FROM places p
        WHERE p.location && ST_Buffer(v_point::geometry, p_distance_meters / 111000.0)
            AND ST_Distance(p.location::geography, v_point::geography) < p_distance_meters
        ORDER BY distance_meters
        LIMIT 10;
    END LOOP;

    RETURN;
END;
$$ LANGUAGE plpgsql;

-- 使用批量查询
SELECT * FROM batch_distance_query(
    ARRAY[
        ST_MakePoint(116.3, 39.9),
        ST_MakePoint(116.4, 40.0),
        ST_MakePoint(116.5, 40.1)
    ]::POINT[],
    1000
);
```

---

## 9. 空间数据分区优化

### 9.1 空间分区策略

**空间分区策略（带错误处理和性能测试）**：

```sql
-- 创建空间分区表
CREATE TABLE places_partitioned (
    id SERIAL,
    name TEXT,
    location GEOMETRY(POINT, 4326)
) PARTITION BY RANGE (ST_X(location));

-- 创建分区（按经度分区）
CREATE TABLE places_east PARTITION OF places_partitioned
FOR VALUES FROM (100) TO (120);

CREATE TABLE places_west PARTITION OF places_partitioned
FOR VALUES FROM (120) TO (140);

-- 在每个分区上创建GIST索引
CREATE INDEX places_east_location_idx ON places_east USING GIST (location);
CREATE INDEX places_west_location_idx ON places_west USING GIST (location);

-- 查询时自动分区裁剪
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM places_partitioned
WHERE ST_X(location) BETWEEN 110 AND 115
    AND ST_Distance(location::geography, ST_MakePoint(116.3, 39.9)::geography) < 1000;
```

### 9.2 分区维护

**分区维护（带错误处理和性能测试）**：

```sql
-- 检查分区大小
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE tablename LIKE 'places_%'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- 添加新分区
CREATE TABLE places_central PARTITION OF places_partitioned
FOR VALUES FROM (115) TO (125);

-- 删除旧分区（如果需要）
-- DROP TABLE places_old_partition;
```

---

## 10. 空间查询监控

### 10.1 查询性能监控

**查询性能监控（带错误处理和性能测试）**：

```sql
-- 慢查询监控
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%ST_%' OR query LIKE '%location%'
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 空间索引使用监控
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN '未使用'
        WHEN idx_scan < 100 THEN '使用较少'
        ELSE '正常使用'
    END AS usage_status
FROM pg_stat_user_indexes
WHERE indexname LIKE '%geom%' OR indexname LIKE '%location%'
ORDER BY idx_scan DESC;
```

### 10.2 空间数据质量监控

**空间数据质量监控（带错误处理和性能测试）**：

```sql
-- 检查空间数据有效性
SELECT
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE ST_IsValid(location)) AS valid_rows,
    COUNT(*) FILTER (WHERE NOT ST_IsValid(location)) AS invalid_rows,
    COUNT(*) FILTER (WHERE location IS NULL) AS null_rows
FROM places;

-- 检查SRID一致性
SELECT
    ST_SRID(location) AS srid,
    COUNT(*) AS count
FROM places
GROUP BY ST_SRID(location);

-- 检查几何复杂度
SELECT
    AVG(ST_NPoints(location)) AS avg_points,
    MAX(ST_NPoints(location)) AS max_points,
    MIN(ST_NPoints(location)) AS min_points
FROM places
WHERE location IS NOT NULL;
```

---

**最后更新**: 2025年1月
