# 空间索引优化

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 18+, PostGIS 3.4+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [空间索引优化](#空间索引优化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. GIST索引优化](#2-gist索引优化)
    - [2.1 基础索引创建](#21-基础索引创建)
    - [2.2 索引参数优化](#22-索引参数优化)
    - [2.3 部分索引](#23-部分索引)
  - [3. 索引参数调优](#3-索引参数调优)
    - [3.1 填充因子（fillfactor）](#31-填充因子fillfactor)
    - [3.2 并发创建索引](#32-并发创建索引)
  - [4. 索引维护](#4-索引维护)
    - [4.1 索引重建](#41-索引重建)
    - [4.2 索引分析](#42-索引分析)
    - [4.3 索引膨胀检测](#43-索引膨胀检测)
  - [5. 索引监控](#5-索引监控)
    - [5.1 索引使用统计](#51-索引使用统计)
    - [5.2 未使用索引检测](#52-未使用索引检测)
    - [5.3 查询计划分析](#53-查询计划分析)
  - [6. 最佳实践](#6-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

空间索引是PostGIS性能的关键。合理的索引优化可以：

- 提升查询性能（10-1000倍）
- 减少索引大小
- 提高索引维护效率
- 优化并发性能

---

## 2. GIST索引优化

### 2.1 基础索引创建

```sql
-- 标准GIST索引（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE EXCEPTION '表places不存在，请先创建';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM pg_extension
        WHERE extname = 'postgis'
    ) THEN
        RAISE EXCEPTION 'PostGIS扩展未安装，请先安装';
    END IF;

    -- 标准GIST索引
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx'
    ) THEN
        CREATE INDEX places_geom_idx ON places USING GIST (location);
        RAISE NOTICE '索引创建成功: places_geom_idx';
    END IF;

    -- 对于GEOMETRY类型
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geometry_idx'
    ) THEN
        CREATE INDEX places_geometry_idx ON places USING GIST (geom);
        RAISE NOTICE '索引创建成功: places_geometry_idx';
    END IF;

    -- 对于GEOGRAPHY类型
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geography_idx'
    ) THEN
        CREATE INDEX places_geography_idx ON places USING GIST (location);
        RAISE NOTICE '索引创建成功: places_geography_idx';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表places不存在';
    WHEN undefined_object THEN
        RAISE EXCEPTION 'GIST索引方法或PostGIS扩展不存在';
    WHEN duplicate_table THEN
        RAISE WARNING '索引已存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建索引失败: %', SQLERRM;
END $$;
```

### 2.2 索引参数优化

```sql
-- 使用填充因子（fillfactor，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE EXCEPTION '表places不存在，请先创建';
    END IF;

    -- 对于只读或很少更新的表
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx_readonly'
    ) THEN
        CREATE INDEX places_geom_idx_readonly ON places
        USING GIST (location) WITH (fillfactor=100);
        RAISE NOTICE '索引创建成功: places_geom_idx_readonly (fillfactor=100)';
    END IF;

    -- 对于频繁更新的表
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx_frequent'
    ) THEN
        CREATE INDEX places_geom_idx_frequent ON places
        USING GIST (location) WITH (fillfactor=90);
        RAISE NOTICE '索引创建成功: places_geom_idx_frequent (fillfactor=90)';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表places不存在';
    WHEN duplicate_table THEN
        RAISE WARNING '索引已存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建索引失败: %', SQLERRM;
END $$;
```

### 2.3 部分索引

```sql
-- 只索引活跃数据（部分索引，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE EXCEPTION '表places不存在，请先创建';
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = 'places'
        AND column_name = 'status'
    ) THEN
        RAISE WARNING '表places没有status列，跳过部分索引创建';
    ELSE
        IF NOT EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE schemaname = 'public'
            AND tablename = 'places'
            AND indexname = 'places_active_geom_idx'
        ) THEN
            CREATE INDEX places_active_geom_idx ON places
            USING GIST (location)
            WHERE status = 'active';
            RAISE NOTICE '部分索引创建成功: places_active_geom_idx';
        END IF;
    END IF;

    -- 只索引特定区域
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_beijing_geom_idx'
    ) THEN
        CREATE INDEX places_beijing_geom_idx ON places
        USING GIST (location)
        WHERE ST_Within(location, ST_MakeEnvelope(116.0, 39.7, 116.7, 40.2, 4326));
        RAISE NOTICE '部分索引创建成功: places_beijing_geom_idx';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表places不存在';
    WHEN undefined_function THEN
        RAISE EXCEPTION 'PostGIS函数不存在，请检查PostGIS扩展安装';
    WHEN duplicate_table THEN
        RAISE WARNING '索引已存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建部分索引失败: %', SQLERRM;
END $$;
```

---

## 3. 索引参数调优

### 3.1 填充因子（fillfactor）

```sql
-- fillfactor参数说明
-- 100: 索引页完全填充（只读表）
-- 90: 预留10%空间（频繁更新）
-- 75: 预留25%空间（大量更新）

-- 根据更新频率选择
CREATE INDEX places_geom_idx ON places
USING GIST (location) WITH (fillfactor=90);
```

### 3.2 并发创建索引

```sql
-- PostgreSQL 12+支持并发创建索引（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'places') THEN
        RAISE EXCEPTION '表places不存在，请先创建';
    END IF;

    IF EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename = 'places'
        AND indexname = 'places_geom_idx_concurrent'
    ) THEN
        RAISE WARNING '索引places_geom_idx_concurrent已存在';
    ELSE
        -- 注意：CONCURRENTLY不能在事务块中使用，需要单独执行
        RAISE NOTICE '请单独执行: CREATE INDEX CONCURRENTLY places_geom_idx_concurrent ON places USING GIST (location);';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表places不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查失败: %', SQLERRM;
END $$;

-- 优点：不阻塞写入
-- 注意：CONCURRENTLY不能在DO块中使用，需要单独执行
-- CREATE INDEX CONCURRENTLY places_geom_idx_concurrent ON places USING GIST (location);
-- 缺点：创建时间更长，需要更多资源
```

---

## 4. 索引维护

### 4.1 索引重建

```sql
-- 重建索引（如果索引膨胀，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes
        WHERE schemaname = 'public'
        AND indexname = 'places_geom_idx'
    ) THEN
        RAISE WARNING '索引places_geom_idx不存在';
    ELSE
        -- 注意：REINDEX不能在事务块中使用，需要单独执行
        RAISE NOTICE '请单独执行: REINDEX INDEX places_geom_idx;';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查失败: %', SQLERRM;
END $$;

-- 注意：REINDEX不能在DO块中使用，需要单独执行
-- REINDEX INDEX places_geom_idx;

-- 重建表的所有索引
REINDEX TABLE places;

-- 并发重建（PostgreSQL 12+）
REINDEX INDEX CONCURRENTLY places_geom_idx;
```

### 4.2 索引分析

```sql
-- 更新索引统计信息
ANALYZE places;

-- 查看索引大小
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE tablename = 'places';
```

### 4.3 索引膨胀检测

```sql
-- 检查索引膨胀
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'places'
ORDER BY pg_relation_size(indexrelid) DESC;
```

---

## 5. 索引监控

### 5.1 索引使用统计

```sql
-- 查看索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE tablename = 'places'
ORDER BY idx_scan DESC;
```

### 5.2 未使用索引检测

```sql
-- 查找未使用的索引
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
```

### 5.3 查询计划分析

```sql
-- 分析查询是否使用索引
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326);

-- 检查是否出现：
-- - Index Scan using places_geom_idx
-- - 如果没有，检查查询条件
```

---

## 6. 最佳实践

### ✅ 推荐做法

1. **为所有空间列创建GIST索引** - 空间查询必需
2. **使用合适的填充因子** - 根据更新频率选择
3. **定期维护索引** - VACUUM和REINDEX
4. **监控索引使用** - 删除未使用的索引
5. **使用部分索引** - 只索引需要的数据

### ❌ 避免做法

1. **不使用空间索引** - 空间查询性能会极差
2. **忽略索引维护** - 索引膨胀会影响性能
3. **创建过多索引** - 影响写入性能
4. **不监控索引** - 不知道索引是否有效

---

## 📚 相关文档

- [PostGIS完整深化指南.md](./PostGIS完整深化指南.md) - PostGIS完整指南
- [地理信息查询优化.md](./地理信息查询优化.md) - 查询优化指南
- [空间数据建模指南.md](./空间数据建模指南.md) - 数据建模指南

---

**最后更新**: 2025年1月
