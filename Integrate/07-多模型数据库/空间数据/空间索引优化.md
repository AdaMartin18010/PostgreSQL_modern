# 空间索引优化

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 18+, PostGIS 3.4+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [空间索引优化](#空间索引优化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. GIST索引优化](#2-gist索引优化)
    - [2.1 基础索引创建](#21-基础索引创建)
    - [2.2 索引参数优化](#22-索引参数优化)
    - [2.3 部分索引](#23-部分索引)
  - [3. 索引参数调优](#3-索引参数调优)
    - [3.1 填充因子（fillfactor）](#31-填充因子fillfactor)
    - [3.2 并发创建索引](#32-并发创建索引)
  - [4. 索引维护](#4-索引维护)
    - [4.1 索引重建](#41-索引重建)
    - [4.2 索引分析](#42-索引分析)
    - [4.3 索引膨胀检测](#43-索引膨胀检测)
  - [5. 索引监控](#5-索引监控)
    - [5.1 索引使用统计](#51-索引使用统计)
    - [5.2 未使用索引检测](#52-未使用索引检测)
    - [5.3 查询计划分析](#53-查询计划分析)
  - [6. 最佳实践](#6-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

空间索引是PostGIS性能的关键。合理的索引优化可以：

- 提升查询性能（10-1000倍）
- 减少索引大小
- 提高索引维护效率
- 优化并发性能

---

## 2. GIST索引优化

### 2.1 基础索引创建

```sql
-- 标准GIST索引
CREATE INDEX places_geom_idx ON places USING GIST (location);

-- 对于GEOMETRY类型
CREATE INDEX places_geometry_idx ON places USING GIST (geom);

-- 对于GEOGRAPHY类型
CREATE INDEX places_geography_idx ON places USING GIST (location);
```

### 2.2 索引参数优化

```sql
-- 使用填充因子（fillfactor）
-- 对于只读或很少更新的表
CREATE INDEX places_geom_idx ON places
USING GIST (location) WITH (fillfactor=100);

-- 对于频繁更新的表
CREATE INDEX places_geom_idx ON places
USING GIST (location) WITH (fillfactor=90);
```

### 2.3 部分索引

```sql
-- 只索引活跃数据
CREATE INDEX places_active_geom_idx ON places
USING GIST (location)
WHERE status = 'active';

-- 只索引特定区域
CREATE INDEX places_beijing_geom_idx ON places
USING GIST (location)
WHERE ST_Within(location, ST_MakeEnvelope(116.0, 39.7, 116.7, 40.2, 4326));
```

---

## 3. 索引参数调优

### 3.1 填充因子（fillfactor）

```sql
-- fillfactor参数说明
-- 100: 索引页完全填充（只读表）
-- 90: 预留10%空间（频繁更新）
-- 75: 预留25%空间（大量更新）

-- 根据更新频率选择
CREATE INDEX places_geom_idx ON places
USING GIST (location) WITH (fillfactor=90);
```

### 3.2 并发创建索引

```sql
-- PostgreSQL 12+支持并发创建索引
CREATE INDEX CONCURRENTLY places_geom_idx ON places
USING GIST (location);

-- 优点：不阻塞写入
-- 缺点：创建时间更长，需要更多资源
```

---

## 4. 索引维护

### 4.1 索引重建

```sql
-- 重建索引（如果索引膨胀）
REINDEX INDEX places_geom_idx;

-- 重建表的所有索引
REINDEX TABLE places;

-- 并发重建（PostgreSQL 12+）
REINDEX INDEX CONCURRENTLY places_geom_idx;
```

### 4.2 索引分析

```sql
-- 更新索引统计信息
ANALYZE places;

-- 查看索引大小
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE tablename = 'places';
```

### 4.3 索引膨胀检测

```sql
-- 检查索引膨胀
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'places'
ORDER BY pg_relation_size(indexrelid) DESC;
```

---

## 5. 索引监控

### 5.1 索引使用统计

```sql
-- 查看索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE tablename = 'places'
ORDER BY idx_scan DESC;
```

### 5.2 未使用索引检测

```sql
-- 查找未使用的索引
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
```

### 5.3 查询计划分析

```sql
-- 分析查询是否使用索引
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM places
WHERE location && ST_MakeEnvelope(116.3, 39.9, 116.5, 40.0, 4326);

-- 检查是否出现：
-- - Index Scan using places_geom_idx
-- - 如果没有，检查查询条件
```

---

## 6. 最佳实践

### ✅ 推荐做法

1. **为所有空间列创建GIST索引** - 空间查询必需
2. **使用合适的填充因子** - 根据更新频率选择
3. **定期维护索引** - VACUUM和REINDEX
4. **监控索引使用** - 删除未使用的索引
5. **使用部分索引** - 只索引需要的数据

### ❌ 避免做法

1. **不使用空间索引** - 空间查询性能会极差
2. **忽略索引维护** - 索引膨胀会影响性能
3. **创建过多索引** - 影响写入性能
4. **不监控索引** - 不知道索引是否有效

---

## 📚 相关文档

- [PostGIS完整深化指南.md](./PostGIS完整深化指南.md) - PostGIS完整指南
- [地理信息查询优化.md](./地理信息查询优化.md) - 查询优化指南
- [空间数据建模指南.md](./空间数据建模指南.md) - 数据建模指南

---

**最后更新**: 2025年1月
