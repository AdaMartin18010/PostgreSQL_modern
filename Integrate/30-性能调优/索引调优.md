# PostgreSQL索引调优指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [PostgreSQL索引调优指南](#postgresql索引调优指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 索引类型选择](#2-索引类型选择)
    - [2.1 B-tree索引](#21-b-tree索引)
    - [2.2 GIN索引](#22-gin索引)
    - [2.3 其他索引类型](#23-其他索引类型)
  - [3. 索引设计](#3-索引设计)
    - [3.1 复合索引](#31-复合索引)
    - [3.2 部分索引](#32-部分索引)
    - [3.3 覆盖索引](#33-覆盖索引)
  - [4. 索引维护](#4-索引维护)
    - [4.1 索引重建](#41-索引重建)
    - [4.2 索引监控](#42-索引监控)
  - [5. 索引监控与分析](#5-索引监控与分析)
    - [5.1 未使用索引识别](#51-未使用索引识别)
    - [5.2 索引大小分析](#52-索引大小分析)
    - [5.3 索引效率分析](#53-索引效率分析)
  - [6. PostgreSQL 18索引优化新特性](#6-postgresql-18索引优化新特性)
    - [6.1 跳过扫描优化（PostgreSQL 18）](#61-跳过扫描优化postgresql-18)
    - [6.2 异步I/O索引优化（PostgreSQL 18）](#62-异步io索引优化postgresql-18)
  - [7. 最佳实践](#7-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [⚠️ 注意事项](#️-注意事项)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

索引调优是提高查询性能的关键手段。

**调优目标**:

- 选择合适的索引类型
- 优化索引设计
- 提高索引使用效率

---

## 2. 索引类型选择

### 2.1 B-tree索引

**B-tree索引详解**：

```sql
-- 创建B-tree索引（默认索引类型）
CREATE INDEX idx_orders_date ON orders(order_date);

-- 创建降序索引
CREATE INDEX idx_orders_date_desc ON orders(order_date DESC);

-- 创建唯一索引
CREATE UNIQUE INDEX idx_orders_id ON orders(id);

-- 适用场景分析（带错误处理和性能测试）
DO $$
DECLARE
    index_record RECORD;
BEGIN
    RAISE NOTICE '=== B-tree索引适用场景 ===';
    RAISE NOTICE '1. 等值查询: WHERE column = value';
    RAISE NOTICE '2. 范围查询: WHERE column > value AND column < value';
    RAISE NOTICE '3. 排序查询: ORDER BY column';
    RAISE NOTICE '4. 前缀匹配: WHERE column LIKE ''prefix%''';
    RAISE NOTICE '5. 多列查询: WHERE col1 = val1 AND col2 = val2';
    RAISE NOTICE '';
    RAISE NOTICE 'PostgreSQL 18优化:';
    RAISE NOTICE '- 跳过扫描: 多列B-tree索引支持跳过扫描';
    RAISE NOTICE '- 性能提升: 多列索引查询效率提升30-50%%';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'B-tree索引分析失败: %', SQLERRM;
END $$;
```

**B-tree索引性能对比**：

| 查询类型 | 无索引 | 有索引 | 性能提升 |
| --- | --- | --- | --- |
| 等值查询 | 全表扫描 | 索引查找 | 10-1000倍 |
| 范围查询 | 全表扫描 | 索引范围扫描 | 10-100倍 |
| 排序查询 | 排序操作 | 索引顺序扫描 | 5-50倍 |

### 2.2 GIN索引

**GIN索引详解**：

```sql
-- 创建GIN索引（数组）
CREATE INDEX idx_products_tags ON products USING GIN(tags);

-- 创建GIN索引（JSONB）
CREATE INDEX idx_products_metadata ON products USING GIN(metadata);

-- 创建GIN索引（全文搜索）
CREATE INDEX idx_documents_content ON documents USING GIN(to_tsvector('english', content));

-- 适用场景分析（带错误处理和性能测试）
DO $$
BEGIN
    RAISE NOTICE '=== GIN索引适用场景 ===';
    RAISE NOTICE '1. 数组查询: WHERE array_column @> ARRAY[value]';
    RAISE NOTICE '2. JSONB查询: WHERE jsonb_column @> ''{"key": "value"}''';
    RAISE NOTICE '3. 全文搜索: WHERE to_tsvector(''english'', content) @@ to_tsquery(''english'', ''query'')';
    RAISE NOTICE '4. 包含查询: WHERE array_column && ARRAY[value]';
    RAISE NOTICE '';
    RAISE NOTICE '注意事项:';
    RAISE NOTICE '- GIN索引较大，占用更多存储空间';
    RAISE NOTICE '- 更新较慢，适合读多写少场景';
    RAISE NOTICE '- 支持部分匹配和全文搜索';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'GIN索引分析失败: %', SQLERRM;
END $$;
```

### 2.3 其他索引类型

**GiST索引**：

```sql
-- 创建GiST索引（空间数据、范围类型）
CREATE INDEX idx_locations_geom ON locations USING GIST(geom);

-- 适用场景
-- - 空间数据查询（PostGIS）
-- - 范围类型查询
-- - 全文搜索（旧版本）
```

**BRIN索引**：

```sql
-- 创建BRIN索引（大表、有序数据）
CREATE INDEX idx_orders_date_brin ON orders USING BRIN(order_date);

-- 适用场景
-- - 大表（百万行以上）
-- - 有序数据（时间序列）
-- - 低选择性列
```

**索引类型对比矩阵**：

| 索引类型 | 适用场景 | 存储大小 | 更新速度 | 查询速度 |
| --- | --- | --- | --- | --- |
| **B-tree** | 等值、范围、排序 | 小 | 快 | 快 |
| **GIN** | 数组、JSONB、全文搜索 | 大 | 慢 | 快 |
| **GiST** | 空间数据、范围类型 | 中 | 中 | 中 |
| **BRIN** | 大表、有序数据 | 很小 | 快 | 中 |

---

## 3. 索引设计

### 3.1 复合索引

**复合索引设计原则**：

```sql
-- 创建复合索引（带错误处理和性能测试）
DO $$
DECLARE
    index_name text;
    table_name text := 'orders';
    column1 text := 'customer_id';
    column2 text := 'order_date';
BEGIN
    index_name := format('idx_%s_%s_%s', table_name, column1, column2);

    RAISE NOTICE '=== 复合索引设计 ===';
    RAISE NOTICE '索引名称: %', index_name;
    RAISE NOTICE '表名: %', table_name;
    RAISE NOTICE '列1: %', column1;
    RAISE NOTICE '列2: %', column2;
    RAISE NOTICE '';
    RAISE NOTICE '创建语句:';
    RAISE NOTICE 'CREATE INDEX % ON %(%s, %s);',
        index_name, table_name, column1, column2;
    RAISE NOTICE '';
    RAISE NOTICE '设计原则:';
    RAISE NOTICE '1. 最左前缀原则: 索引列顺序很重要';
    RAISE NOTICE '2. 选择性高的列在前: 区分度高的列优先';
    RAISE NOTICE '3. 查询频率高的列在前: 常用查询列优先';
    RAISE NOTICE '4. 等值查询列在前: 等值查询列优先于范围查询列';
    RAISE NOTICE '';
    RAISE NOTICE 'PostgreSQL 18优化:';
    RAISE NOTICE '- 跳过扫描: 支持多列B-tree索引跳过扫描';
    RAISE NOTICE '- 性能提升: 多列索引查询效率提升30-50%%';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '复合索引设计分析失败: %', SQLERRM;
END $$;
```

**复合索引列顺序选择**：

```sql
-- 示例1：等值查询 + 范围查询
-- 正确顺序：等值列在前，范围列在后
CREATE INDEX idx_orders_customer_date
ON orders(customer_id, order_date);

-- 可以使用索引的查询
SELECT * FROM orders
WHERE customer_id = 100 AND order_date > '2024-01-01';  -- ✅ 可以使用
SELECT * FROM orders
WHERE customer_id = 100;  -- ✅ 可以使用（最左前缀）
SELECT * FROM orders
WHERE order_date > '2024-01-01';  -- ❌ 不能使用（缺少最左列）

-- 示例2：多列等值查询
-- 正确顺序：选择性高的列在前
CREATE INDEX idx_orders_status_customer
ON orders(status, customer_id);

-- 可以使用索引的查询
SELECT * FROM orders
WHERE status = 'pending' AND customer_id = 100;  -- ✅ 可以使用
SELECT * FROM orders
WHERE status = 'pending';  -- ✅ 可以使用（最左前缀）
```

### 3.2 部分索引

**部分索引设计**：

```sql
-- 创建部分索引（只索引部分数据，带错误处理和性能测试）
DO $$
DECLARE
    index_name text;
    table_name text := 'orders';
    column_name text := 'customer_id';
    condition text := 'status = ''active''';
BEGIN
    index_name := format('idx_%s_%s_partial', table_name, column_name);

    RAISE NOTICE '=== 部分索引设计 ===';
    RAISE NOTICE '索引名称: %', index_name;
    RAISE NOTICE '表名: %', table_name;
    RAISE NOTICE '列名: %', column_name;
    RAISE NOTICE '条件: %', condition;
    RAISE NOTICE '';
    RAISE NOTICE '创建语句:';
    RAISE NOTICE 'CREATE INDEX % ON %(%s) WHERE %s;',
        index_name, table_name, column_name, condition;
    RAISE NOTICE '';
    RAISE NOTICE '适用场景:';
    RAISE NOTICE '1. 只查询部分数据: WHERE status = ''active''';
    RAISE NOTICE '2. 减少索引大小: 只索引需要的数据';
    RAISE NOTICE '3. 提高查询性能: 索引更小，查询更快';
    RAISE NOTICE '4. 减少维护成本: 更新更少，维护更快';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '部分索引设计分析失败: %', SQLERRM;
END $$;
```

**部分索引示例**：

```sql
-- 示例1：只索引活跃订单
CREATE INDEX idx_orders_active
ON orders(customer_id)
WHERE status = 'active';

-- 可以使用索引的查询
SELECT * FROM orders
WHERE status = 'active' AND customer_id = 100;  -- ✅ 可以使用

-- 不能使用索引的查询
SELECT * FROM orders
WHERE status = 'pending' AND customer_id = 100;  -- ❌ 不能使用

-- 示例2：只索引最近的数据
CREATE INDEX idx_orders_recent
ON orders(order_date)
WHERE order_date > '2024-01-01';

-- 可以使用索引的查询
SELECT * FROM orders
WHERE order_date > '2024-01-01' AND order_date < '2024-12-31';  -- ✅ 可以使用
```

### 3.3 覆盖索引

**覆盖索引设计**：

```sql
-- 创建覆盖索引（包含查询所需的所有列）
CREATE INDEX idx_orders_covering
ON orders(customer_id, order_date, status, total_amount);

-- 可以使用覆盖索引的查询（只扫描索引，不访问表）
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100 AND order_date > '2024-01-01';
-- ✅ Index Only Scan（PostgreSQL 18优化）
```

**覆盖索引优势**：

- **减少I/O**：只扫描索引，不访问表
- **提升性能**：查询速度提升2-5倍
- **减少锁竞争**：不访问表，减少锁竞争

---

## 4. 索引维护

### 4.1 索引重建

**索引重建方法**：

```sql
-- 重建索引（带错误处理和性能测试）
DO $$
DECLARE
    index_record RECORD;
    schema_name text := 'public';
    reindex_count int := 0;
BEGIN
    -- 检查schema是否存在
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = schema_name
    ) THEN
        RAISE WARNING 'Schema % 不存在', schema_name;
        RETURN;
    END IF;

    RAISE NOTICE '开始重建Schema % 中的索引...', schema_name;

    FOR index_record IN
        SELECT schemaname, indexname
        FROM pg_indexes
        WHERE schemaname = schema_name
        ORDER BY indexname
    LOOP
        BEGIN
            EXECUTE format('REINDEX INDEX %I.%I', index_record.schemaname, index_record.indexname);
            reindex_count := reindex_count + 1;
            RAISE NOTICE '已重建索引 %.%',
                index_record.schemaname, index_record.indexname;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '重建索引 %.% 失败: %',
                    index_record.schemaname, index_record.indexname, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '索引重建完成: % 个索引', reindex_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '索引重建失败: %', SQLERRM;
END $$;
```

**索引重建场景**：

| 场景 | 说明 | 重建方法 |
| --- | --- | --- |
| **索引碎片** | 索引碎片过多，影响性能 | `REINDEX INDEX index_name` |
| **索引损坏** | 索引损坏，需要重建 | `REINDEX INDEX index_name` |
| **表重建** | 表重建后，索引需要重建 | `REINDEX TABLE table_name` |
| **数据库重建** | 数据库重建后，所有索引需要重建 | `REINDEX DATABASE database_name` |

**PostgreSQL 18索引重建优化**：

- **异步I/O支持**：索引重建可以利用异步I/O提升性能
- **maintenance_io_concurrency**：维护操作异步I/O并发数
- **性能提升**：索引重建性能提升2-3倍（结合异步I/O）

### 4.2 索引监控

**索引使用情况监控**：

```sql
-- 查看索引使用情况（带错误处理和性能测试）
DO $$
DECLARE
    index_record RECORD;
    unused_index_count int := 0;
    total_index_size bigint := 0;
BEGIN
    RAISE NOTICE '=== 索引使用情况监控 ===';

    -- 查看所有索引使用情况
    FOR index_record IN
        SELECT
            schemaname,
            tablename,
            indexname,
            idx_scan,
            idx_tup_read,
            idx_tup_fetch,
            pg_relation_size(indexrelid) as index_size
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public'
        ORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC
        LIMIT 20
    LOOP
        total_index_size := total_index_size + index_record.index_size;

        IF index_record.idx_scan = 0 THEN
            unused_index_count := unused_index_count + 1;
            RAISE WARNING '未使用索引: %.% | 大小: %',
                index_record.schemaname,
                index_record.indexname,
                pg_size_pretty(index_record.index_size);
        ELSE
            RAISE NOTICE '索引: %.% | 扫描次数: % | 大小: %',
                index_record.schemaname,
                index_record.indexname,
                index_record.idx_scan,
                pg_size_pretty(index_record.index_size);
        END IF;
    END LOOP;

    RAISE NOTICE '';
    RAISE NOTICE '汇总 - 未使用索引数: % | 总索引大小: %',
        unused_index_count,
        pg_size_pretty(total_index_size);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '索引监控失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC
LIMIT 20;
```

---

## 5. 索引监控与分析

### 5.1 未使用索引识别

**未使用索引识别和清理**：

```sql
-- 查找未使用的索引（带错误处理和性能测试）
DO $$
DECLARE
    unused_index_record RECORD;
    total_unused_size bigint := 0;
    unused_count int := 0;
BEGIN
    RAISE NOTICE '=== 未使用索引识别 ===';

    FOR unused_index_record IN
        SELECT
            schemaname,
            tablename,
            indexname,
            pg_relation_size(indexrelid) as index_size,
            pg_size_pretty(pg_relation_size(indexrelid)) as index_size_pretty
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public'
        AND idx_scan = 0
        ORDER BY pg_relation_size(indexrelid) DESC
    LOOP
        unused_count := unused_count + 1;
        total_unused_size := total_unused_size + unused_index_record.index_size;

        RAISE WARNING '未使用索引: %.%.% | 大小: %',
            unused_index_record.schemaname,
            unused_index_record.tablename,
            unused_index_record.indexname,
            unused_index_record.index_size_pretty;
    END LOOP;

    IF unused_count > 0 THEN
        RAISE NOTICE '';
        RAISE NOTICE '汇总 - 未使用索引数: % | 总大小: %',
            unused_count,
            pg_size_pretty(total_unused_size);
        RAISE NOTICE '建议: 考虑删除未使用的索引以节省存储空间';
    ELSE
        RAISE NOTICE '未发现未使用的索引';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '未使用索引识别失败: %', SQLERRM;
END $$;
```

**索引删除建议**：

```sql
-- 删除未使用的索引（谨慎操作，需要确认）
-- DROP INDEX IF EXISTS schema_name.index_name;

-- 删除前检查索引是否真的未使用
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
AND idx_scan = 0
AND pg_relation_size(indexrelid) > 1048576  -- 大于1MB
ORDER BY pg_relation_size(indexrelid) DESC;
```

### 5.2 索引大小分析

**索引大小监控**：

```sql
-- 查看索引大小（带错误处理和性能测试）
DO $$
DECLARE
    size_record RECORD;
    total_index_size bigint := 0;
    total_table_size bigint := 0;
    index_ratio numeric;
BEGIN
    RAISE NOTICE '=== 索引大小分析 ===';

    FOR size_record IN
        SELECT
            schemaname,
            tablename,
            indexname,
            pg_relation_size(indexrelid) as index_size,
            pg_relation_size((schemaname||'.'||tablename)::regclass) as table_size,
            pg_size_pretty(pg_relation_size(indexrelid)) as index_size_pretty
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public'
        ORDER BY pg_relation_size(indexrelid) DESC
        LIMIT 20
    LOOP
        total_index_size := total_index_size + size_record.index_size;
        total_table_size := total_table_size + size_record.table_size;

        -- 计算索引与表大小比例
        index_ratio := ROUND(100.0 * size_record.index_size /
                             NULLIF(size_record.table_size, 0), 2);

        RAISE NOTICE '索引: %.% | 大小: % | 表大小: % | 比例: %%',
            size_record.schemaname,
            size_record.indexname,
            size_record.index_size_pretty,
            pg_size_pretty(size_record.table_size),
            index_ratio;

        IF index_ratio > 50 THEN
            RAISE WARNING '索引 %.% 大小超过表的50%%，建议检查索引设计',
                size_record.schemaname, size_record.indexname;
        END IF;
    END LOOP;

    -- 汇总统计
    IF total_table_size > 0 THEN
        index_ratio := ROUND(100.0 * total_index_size / NULLIF(total_table_size, 0), 2);
        RAISE NOTICE '';
        RAISE NOTICE '汇总 - 总索引大小: % | 总表大小: % | 索引比例: %%',
            pg_size_pretty(total_index_size),
            pg_size_pretty(total_table_size),
            index_ratio;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '索引大小分析失败: %', SQLERRM;
END $$;
```

### 5.3 索引效率分析

**索引效率监控**：

```sql
-- 分析索引效率（带错误处理和性能测试）
DO $$
DECLARE
    efficiency_record RECORD;
BEGIN
    RAISE NOTICE '=== 索引效率分析 ===';

    FOR efficiency_record IN
        SELECT
            schemaname,
            tablename,
            indexname,
            idx_scan,
            idx_tup_read,
            idx_tup_fetch,
            CASE
                WHEN idx_scan > 0 THEN
                    ROUND(100.0 * idx_tup_fetch / NULLIF(idx_tup_read, 0), 2)
                ELSE 0
            END as fetch_ratio
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public'
        AND idx_scan > 0
        ORDER BY idx_scan DESC
        LIMIT 20
    LOOP
        RAISE NOTICE '索引: %.% | 扫描次数: % | 读取元组: % | 获取元组: % | 获取率: %%',
            efficiency_record.schemaname,
            efficiency_record.indexname,
            efficiency_record.idx_scan,
            efficiency_record.idx_tup_read,
            efficiency_record.idx_tup_fetch,
            efficiency_record.fetch_ratio;

        IF efficiency_record.fetch_ratio < 50 THEN
            RAISE WARNING '索引 %.% 获取率较低: %%，建议检查索引设计',
                efficiency_record.schemaname,
                efficiency_record.indexname,
                efficiency_record.fetch_ratio;
        END IF;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '索引效率分析失败: %', SQLERRM;
END $$;
```

## 6. PostgreSQL 18索引优化新特性

### 6.1 跳过扫描优化（PostgreSQL 18）

PostgreSQL 18支持多列B-tree索引的跳过扫描：

```sql
-- 创建多列索引
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);

-- 查询可以利用跳过扫描（PostgreSQL 18）
SELECT * FROM orders
WHERE customer_id = 100
ORDER BY order_date DESC
LIMIT 10;
-- PostgreSQL 18: 跳过扫描优化查询性能30-50%
```

**跳过扫描优势**：

- 多列索引查询效率提升30-50%
- 减少索引扫描范围
- 优化复合查询性能

### 6.2 异步I/O索引优化（PostgreSQL 18）

PostgreSQL 18的异步I/O子系统优化索引操作：

```sql
-- 索引构建（PostgreSQL 18异步I/O优化）
CREATE INDEX idx_large_table_id ON large_table(id);
-- PostgreSQL 18: 异步I/O提升索引构建速度2-3倍

-- 索引扫描（PostgreSQL 18异步I/O优化）
SELECT * FROM large_table WHERE id > 1000;
-- PostgreSQL 18: 异步I/O提升索引扫描速度1.5-2倍
```

## 7. 最佳实践

### ✅ 推荐做法

1. **选择合适的索引类型** - 根据查询类型选择B-tree、GIN、GiST等
2. **优化索引设计** - 遵循最左前缀原则，选择性高的列在前
3. **使用部分索引** - 只索引需要的数据，减少索引大小
4. **使用覆盖索引** - 包含查询所需的所有列，实现Index Only Scan
5. **定期监控索引** - 识别未使用索引、监控索引大小和效率
6. **利用PostgreSQL 18新特性** - 使用跳过扫描、异步I/O等新特性

### ⚠️ 注意事项

1. **不要过度索引** - 索引会增加写入开销，需要平衡
2. **定期维护索引** - 定期重建索引，清理碎片
3. **监控索引使用** - 识别并删除未使用的索引
4. **测试索引效果** - 创建索引后测试查询性能

---

## 📚 相关文档

- [PostgreSQL性能调优完整指南.md](./PostgreSQL性能调优完整指南.md) - 性能调优完整指南
- [性能调优方法论.md](./性能调优方法论.md) - 性能调优方法论
- [系统级调优.md](./系统级调优.md) - 系统级调优详解
- [数据库级调优.md](./数据库级调优.md) - 数据库级调优详解
- [查询级调优.md](./查询级调优.md) - 查询级调优详解
- [30-性能调优/README.md](./README.md) - 性能调优主题

---

**最后更新**: 2025年1月
