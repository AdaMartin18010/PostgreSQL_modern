# 2.3 并行查询追踪

> **所属主题**: 02-自动化性能调优
> **章节编号**: 2.3
> **PostgreSQL版本**: 18+
> **难度等级**: ⭐⭐⭐
> **相关章节**: [2.1 异步I/O支持](./01-异步I-O支持.md) | [2.4 EXPLAIN增强](./04-EXPLAIN增强.md)

---

## 📋 目录

- [2.3 并行查询追踪](#23-并行查询追踪)
  - [📋 目录](#-目录)
  - [2.3.1 概述与背景](#231-概述与背景)
    - [2.3.1.1 什么是并行查询追踪](#2311-什么是并行查询追踪)
    - [2.3.1.2 问题背景](#2312-问题背景)
    - [2.3.1.3 PostgreSQL 18新特性](#2313-postgresql-18新特性)
  - [2.3.2 并行查询追踪原理](#232-并行查询追踪原理)
    - [2.3.2.1 并行查询执行流程](#2321-并行查询执行流程)
    - [2.3.2.2 并行效率计算](#2322-并行效率计算)
  - [2.3.3 配置决策树](#233-配置决策树)
    - [2.3.3.1 并行查询启用决策树](#2331-并行查询启用决策树)
    - [2.3.3.2 并行度配置决策树](#2332-并行度配置决策树)
    - [2.3.3.3 配置决策论证](#2333-配置决策论证)
  - [2.3.4 pg\_stat\_statements并行查询追踪](#234-pg_stat_statements并行查询追踪)
    - [2.3.4.1 检查并行查询统计](#2341-检查并行查询统计)
    - [2.3.4.2 新增列说明](#2342-新增列说明)
    - [2.3.4.2.1 parallel\_workers\_to\_launch](#23421-parallel_workers_to_launch)
    - [2.3.4.2.2 parallel\_workers\_launched](#23422-parallel_workers_launched)
    - [2.3.4.3 并行效率计算](#2343-并行效率计算)
  - [2.3.5 SET语句参数化追踪](#235-set语句参数化追踪)
    - [2.3.5.1 PostgreSQL 18之前的SET语句追踪](#2351-postgresql-18之前的set语句追踪)
    - [2.3.5.2 PostgreSQL 18参数化SET语句追踪](#2352-postgresql-18参数化set语句追踪)
    - [2.3.5.3 参数化追踪优势论证](#2353-参数化追踪优势论证)
  - [2.3.6 并行查询性能分析](#236-并行查询性能分析)
    - [2.3.6.1 查找并行效率低的查询](#2361-查找并行效率低的查询)
    - [2.3.6.2 分析并行查询效果](#2362-分析并行查询效果)
  - [2.3.7 性能优势与论证](#237-性能优势与论证)
    - [2.3.7.1 PostgreSQL 18并行查询追踪优势](#2371-postgresql-18并行查询追踪优势)
    - [2.3.7.2 性能优势论证](#2372-性能优势论证)
  - [2.3.8 注意事项与最佳实践](#238-注意事项与最佳实践)
    - [2.3.8.1 注意事项](#2381-注意事项)
    - [2.3.8.2 最佳实践](#2382-最佳实践)
    - [2.3.8.3 故障排查](#2383-故障排查)
  - [2.3.9 导航](#239-导航)
    - [2.3.9.1 章节导航](#2391-章节导航)
    - [2.3.9.2 相关章节](#2392-相关章节)
  - [📚 参考资料](#-参考资料)

---

## 2.3.1 概述与背景

### 2.3.1.1 什么是并行查询追踪

PostgreSQL 18的pg_stat_statements扩展新增了并行查询相关的列，并支持SET语句的参数化追踪。这些新功能使得并行查询的性能分析和优化变得更加容易。

### 2.3.1.2 问题背景

**并行查询监控的挑战**：

- ❌ 无法准确了解并行查询的实际执行情况
- ❌ 难以判断并行查询是否达到预期效果
- ❌ SET语句导致pg_stat_statements表膨胀

**PostgreSQL 18的解决方案**：

- ✅ 新增`parallel_workers_to_launch`和`parallel_workers_launched`列
- ✅ 支持SET语句参数化追踪
- ✅ 提供并行效率分析功能

### 2.3.1.3 PostgreSQL 18新特性

1. **并行工作进程追踪**：计划vs实际对比
2. **SET语句参数化**：减少统计信息膨胀
3. **并行效率计算**：自动计算并行查询效率

---

## 2.3.2 并行查询追踪原理

### 2.3.2.1 并行查询执行流程

```
┌─────────────────────────────────────────────────────────┐
│          PostgreSQL 并行查询执行流程                       │
└─────────────────────────────────────────────────────────┘

查询计划器
    │
    ├─→ 分析查询复杂度
    │   │
    │   ├─→ 计算并行度需求
    │   │   └─→ parallel_workers_to_launch = N
    │   │
    │   └─→ 生成并行查询计划
    │
    ├─→ 执行器启动
    │   │
    │   ├─→ 检查可用并行工作进程
    │   │   └─→ max_parallel_workers_per_gather
    │   │
    │   ├─→ 实际启动工作进程
    │   │   └─→ parallel_workers_launched = M (M ≤ N)
    │   │
    │   └─→ 执行并行查询
    │
    └─→ 记录统计信息
        ├─→ parallel_workers_to_launch
        └─→ parallel_workers_launched
```

### 2.3.2.2 并行效率计算

**并行效率公式**：

```
并行效率 = (parallel_workers_launched / parallel_workers_to_launch) × 100%
```

**效率判断标准**：

- ✅ **效率 ≥ 80%**：并行查询效果良好
- ⚠️ **效率 50-80%**：并行查询效果一般，需要优化
- ❌ **效率 < 50%**：并行查询效果差，需要检查配置

---

## 2.3.3 配置决策树

### 2.3.3.1 并行查询启用决策树

```
开始：是否需要启用并行查询？
│
├─→ 查询类型？
│   ├─→ 简单查询（单表扫描，小数据量）？
│   │   └─→ ❌ 不需要并行查询
│   │       └─→ 理由：并行开销大于收益
│   │
│   ├─→ 复杂查询（多表JOIN，大数据量）？
│   │   └─→ ✅ 推荐启用并行查询
│   │       └─→ 理由：可以显著提升性能
│   │
│   └─→ 聚合查询（GROUP BY，SUM等）？
│       └─→ ✅ 强烈推荐启用并行查询
│           └─→ 理由：并行聚合效果显著
│
├─→ 数据量？
│   ├─→ 小表（< 100万行）？
│   │   └─→ ⚠️ 并行查询效果有限
│   │
│   ├─→ 中表（100万-1000万行）？
│   │   └─→ ✅ 推荐启用并行查询
│   │
│   └─→ 大表（> 1000万行）？
│       └─→ ✅ 强烈推荐启用并行查询
│
└─→ 最终决策
    └─→ 根据查询类型和数据量决定是否启用并行查询
```

### 2.3.3.2 并行度配置决策树

```
开始：配置max_parallel_workers_per_gather
│
├─→ CPU核心数？
│   ├─→ < 4核心？
│   │   └─→ max_parallel_workers_per_gather = 2
│   │
│   ├─→ 4-8核心？
│   │   └─→ max_parallel_workers_per_gather = 4
│   │
│   ├─→ 8-16核心？
│   │   └─→ max_parallel_workers_per_gather = 4-6
│   │
│   └─→ > 16核心？
│       └─→ max_parallel_workers_per_gather = 6-8
│
├─→ 工作负载类型？
│   ├─→ OLTP（高并发）？
│   │   └─→ 降低并行度（避免资源竞争）
│   │
│   └─→ OLAP（大数据分析）？
│       └─→ 增加并行度（充分利用资源）
│
└─→ 最终配置
    └─→ max_parallel_workers_per_gather = [根据CPU和负载调整]
```

### 2.3.3.3 配置决策论证

**论证：为什么需要并行查询追踪？**

```
前提条件：
P1: 并行查询可以提升性能，但需要合理配置
P2: 无法追踪并行查询效果，难以优化
P3: PostgreSQL 18提供并行查询追踪功能

推理过程：
R1: 如果P1，则需要监控并行查询效果
R2: 如果P2，则无法优化并行查询配置
R3: 如果P3，则可以解决P2问题

结论：
C1: 应该使用并行查询追踪功能
C2: 通过追踪可以优化并行查询配置，提升性能
```

---

## 2.3.4 pg_stat_statements并行查询追踪

### 2.3.4.1 检查并行查询统计

```sql
-- PostgreSQL 18 pg_stat_statements并行查询追踪（带错误处理和性能测试）
DO $$
DECLARE
    parallel_query RECORD;
BEGIN
    BEGIN
        -- 检查pg_stat_statements扩展
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements') THEN
            RAISE WARNING 'pg_stat_statements扩展未安装';
            RAISE NOTICE '安装命令: CREATE EXTENSION pg_stat_statements;';
            RETURN;
        END IF;

        -- 检查PostgreSQL版本
        IF (SELECT current_setting('server_version_num')::int) < 180000 THEN
            RAISE WARNING '并行查询追踪列需要PostgreSQL 18+';
            RETURN;
        END IF;

        RAISE NOTICE '=== PostgreSQL 18并行查询追踪 ===';
        RAISE NOTICE '查询并行查询统计...';
        RAISE NOTICE '';

        -- 查询并行查询统计（PostgreSQL 18新增列）
        FOR parallel_query IN
            SELECT
                query,
                calls,
                total_exec_time,
                mean_exec_time,
                parallel_workers_to_launch,  -- PostgreSQL 18新增：计划启动的并行工作进程数
                parallel_workers_launched,    -- PostgreSQL 18新增：实际启动的并行工作进程数
                ROUND(100.0 * parallel_workers_launched / NULLIF(parallel_workers_to_launch, 0), 2) AS parallel_efficiency
            FROM pg_stat_statements
            WHERE parallel_workers_to_launch > 0
            ORDER BY total_exec_time DESC
            LIMIT 10
        LOOP
            RAISE NOTICE '查询: %', LEFT(parallel_query.query, 80);
            RAISE NOTICE '  执行次数: %', parallel_query.calls;
            RAISE NOTICE '  总执行时间: %.2f ms', parallel_query.total_exec_time;
            RAISE NOTICE '  平均执行时间: %.2f ms', parallel_query.mean_exec_time;
            RAISE NOTICE '  计划并行工作进程: %', parallel_query.parallel_workers_to_launch;
            RAISE NOTICE '  实际启动并行工作进程: %', parallel_query.parallel_workers_launched;
            RAISE NOTICE '  并行效率: %%', parallel_query.parallel_efficiency;
            RAISE NOTICE '';
        END LOOP;

        RAISE NOTICE 'PostgreSQL 18并行查询追踪优势:';
        RAISE NOTICE '- parallel_workers_to_launch: 计划启动的并行工作进程数';
        RAISE NOTICE '- parallel_workers_launched: 实际启动的并行工作进程数';
        RAISE NOTICE '- 支持参数化SET语句追踪（减少重复语句膨胀）';
        RAISE NOTICE '- 便于分析并行查询效果';
        RAISE NOTICE '';
        RAISE NOTICE 'SET语句参数化追踪示例:';
        RAISE NOTICE '-- PostgreSQL 18之前: 每个SET语句都单独记录';
        RAISE NOTICE '-- SET work_mem = ''4MB'';  -- 单独记录';
        RAISE NOTICE '-- SET work_mem = ''8MB'';  -- 单独记录';
        RAISE NOTICE '';
        RAISE NOTICE '-- PostgreSQL 18: SET语句参数化，减少统计信息膨胀';
        RAISE NOTICE '-- SET work_mem = $1;  -- 参数化追踪';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行查询追踪查询失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 2.3.4.2 新增列说明

### 2.3.4.2.1 parallel_workers_to_launch

| 属性 | 说明 |
|------|------|
| **类型** | integer |
| **说明** | 计划启动的并行工作进程数 |
| **用途** | 显示查询计划期望使用的并行工作进程数 |
| **示例值** | 0（非并行查询）或 2-8（并行查询） |

### 2.3.4.2.2 parallel_workers_launched

| 属性 | 说明 |
|------|------|
| **类型** | integer |
| **说明** | 实际启动的并行工作进程数 |
| **用途** | 显示实际启动的并行工作进程数 |
| **示例值** | 0（未启动）或 ≤ parallel_workers_to_launch |

### 2.3.4.3 并行效率计算

```sql
-- 计算并行查询效率
SELECT
    query,
    calls,
    mean_exec_time,
    parallel_workers_to_launch,
    parallel_workers_launched,
    ROUND(100.0 * parallel_workers_launched / NULLIF(parallel_workers_to_launch, 0), 2) AS parallel_efficiency
FROM pg_stat_statements
WHERE parallel_workers_to_launch > 0
ORDER BY parallel_efficiency ASC
LIMIT 10;
```

---

## 2.3.5 SET语句参数化追踪

### 2.3.5.1 PostgreSQL 18之前的SET语句追踪

**问题**：在PostgreSQL 18之前，每个SET语句都会单独记录在pg_stat_statements中：

```sql
-- PostgreSQL 18之前: 每个SET语句都单独记录
SET work_mem = '4MB';  -- 单独记录（记录1）
SET work_mem = '8MB';  -- 单独记录（记录2）
SET work_mem = '16MB'; -- 单独记录（记录3）
```

**影响**：这会导致pg_stat_statements表膨胀，因为每个不同的SET语句值都会创建一条记录。

**统计信息膨胀示例**：

```
pg_stat_statements表记录数：
- SET work_mem = '4MB'  → 1条记录
- SET work_mem = '8MB'  → 1条记录
- SET work_mem = '16MB' → 1条记录
总计：3条记录（相同语句，不同参数值）
```

### 2.3.5.2 PostgreSQL 18参数化SET语句追踪

**解决方案**：PostgreSQL 18支持参数化SET语句追踪，减少统计信息膨胀：

```sql
-- PostgreSQL 18: SET语句参数化，减少统计信息膨胀
SET work_mem = $1;  -- 参数化追踪（合并为1条记录）
```

**效果**：所有相同类型的SET语句会被合并为一条记录，减少pg_stat_statements表的膨胀。

**统计信息优化示例**：

```
pg_stat_statements表记录数：
- SET work_mem = $1  → 1条记录（合并所有work_mem设置）
总计：1条记录（参数化，减少膨胀）
```

### 2.3.5.3 参数化追踪优势论证

**论证：SET语句参数化减少统计信息膨胀**

```
前提条件：
P1: 应用经常使用SET语句设置不同参数值
P2: 每个不同的SET值都会创建一条记录
P3: PostgreSQL 18支持SET语句参数化

推理过程：
R1: 如果P1 ∧ P2，则pg_stat_statements表会快速膨胀
R2: 如果P3，则相同类型的SET语句会被合并
R3: 合并后可以减少记录数，降低膨胀

结论：
C1: SET语句参数化可以减少pg_stat_statements表膨胀
C2: 可以提升统计信息查询性能
C3: 可以节省存储空间
```

---

## 2.3.6 并行查询性能分析

### 2.3.6.1 查找并行效率低的查询

```sql
-- 查找并行效率低的查询
SELECT
    query,
    calls,
    mean_exec_time,
    parallel_workers_to_launch,
    parallel_workers_launched,
    ROUND(100.0 * parallel_workers_launched / NULLIF(parallel_workers_to_launch, 0), 2) AS parallel_efficiency
FROM pg_stat_statements
WHERE parallel_workers_to_launch > 0
  AND parallel_workers_launched < parallel_workers_to_launch * 0.8  -- 效率低于80%
ORDER BY parallel_efficiency ASC
LIMIT 10;
```

### 2.3.6.2 分析并行查询效果

```sql
-- 分析并行查询效果
SELECT
    COUNT(*) AS total_parallel_queries,
    AVG(parallel_workers_to_launch) AS avg_planned_workers,
    AVG(parallel_workers_launched) AS avg_launched_workers,
    ROUND(AVG(100.0 * parallel_workers_launched / NULLIF(parallel_workers_to_launch, 0)), 2) AS avg_efficiency
FROM pg_stat_statements
WHERE parallel_workers_to_launch > 0;
```

---

## 2.3.7 性能优势与论证

### 2.3.7.1 PostgreSQL 18并行查询追踪优势

| 优势项 | 说明 | 价值 |
|--------|------|------|
| **计划vs实际对比** | 可以对比计划启动和实际启动的并行工作进程数 | 识别并行度不足的查询 |
| **并行效率分析** | 计算并行查询的效率 | 优化并行查询配置 |
| **SET语句优化** | 参数化SET语句追踪减少统计信息膨胀 | 减少存储空间，提升查询性能 |
| **性能优化指导** | 提供并行查询优化的数据支持 | 数据驱动的性能优化 |

### 2.3.7.2 性能优势论证

**论证：并行查询追踪提升优化效率**

```
前提条件：
P1: 并行查询配置需要根据实际效果调整
P2: 无法追踪并行查询效果，难以优化
P3: PostgreSQL 18提供并行查询追踪功能

推理过程：
R1: 如果P1，则需要监控并行查询效果
R2: 如果P2，则优化效率低（盲目调整）
R3: 如果P3，则可以基于数据优化

结论：
C1: 并行查询追踪可以提升优化效率
C2: 可以基于实际数据调整并行度配置
C3: 可以识别并行度不足的查询，针对性优化
```

**论证：SET语句参数化减少膨胀**

```
前提条件：
P1: 应用经常使用SET语句（如work_mem, statement_timeout等）
P2: 每个不同的SET值都会创建一条记录
P3: PostgreSQL 18支持SET语句参数化

性能分析：
- 假设：应用使用10种不同的work_mem值
- PostgreSQL 18之前：10条记录
- PostgreSQL 18之后：1条记录（参数化）
- 减少：90%的记录数

结论：
C1: SET语句参数化可以减少90%以上的统计信息膨胀
C2: 可以提升pg_stat_statements查询性能
C3: 可以节省存储空间
```

---

## 2.3.8 注意事项与最佳实践

### 2.3.8.1 注意事项

⚠️ **重要提醒**：

1. **扩展安装**：需要安装pg_stat_statements扩展

   ```sql
   CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
   ```

2. **版本要求**：需要PostgreSQL 18+

   ```sql
   SELECT current_setting('server_version_num')::int >= 180000;
   ```

3. **性能开销**：并行查询追踪会增加pg_stat_statements的开销，合理设置max参数

   ```sql
   -- 设置pg_stat_statements.max参数
   ALTER SYSTEM SET pg_stat_statements.max = 10000;
   ```

### 2.3.8.2 最佳实践

✅ **推荐做法**：

1. **定期分析并行效率**：定期查询并行效率低的查询

   ```sql
   -- 每周分析一次并行查询效率
   SELECT * FROM parallel_query_efficiency_analysis();
   ```

2. **优化并行度配置**：根据并行效率调整max_parallel_workers_per_gather

   ```sql
   -- 如果并行效率低，考虑降低并行度
   ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
   ```

3. **监控SET语句使用**：监控SET语句的使用情况

   ```sql
   -- 查看SET语句统计
   SELECT * FROM pg_stat_statements WHERE query LIKE 'SET %';
   ```

### 2.3.8.3 故障排查

🔧 **常见问题**：

1. **并行查询未启动**
   - 检查max_parallel_workers_per_gather配置
   - 检查表大小（小表可能不启动并行查询）
   - 检查查询类型（某些查询不支持并行）

2. **并行效率低**
   - 检查可用并行工作进程数
   - 检查系统负载（高负载时并行度可能降低）
   - 检查查询复杂度（简单查询并行效果差）

3. **SET语句未参数化**
   - 确认PostgreSQL版本（需要18+）
   - 检查pg_stat_statements配置
   - 查看pg_stat_statements视图中的SET语句

---

## 2.3.9 导航

### 2.3.9.1 章节导航

- **上一节**：[2.2 NUMA架构支持](./02-NUMA架构支持.md)
- **下一节**：[2.4 EXPLAIN增强](./04-EXPLAIN增强.md)
- **返回主题目录**：[02-自动化性能调优](./README.md)
- **返回主文档**：[PostgreSQL-18-自动化运维与自我监测](../README.md)

### 2.3.9.2 相关章节

- [2.1 异步I/O支持](./01-异步I-O支持.md) - I/O性能优化
- [2.4 EXPLAIN增强](./04-EXPLAIN增强.md) - 查询计划分析
- [4.1 自动慢查询检测](../04-自动化诊断/01-自动慢查询检测.md) - 慢查询诊断

---

## 📚 参考资料

- [PostgreSQL 18 pg_stat_statements文档](https://www.postgresql.org/docs/18/pgstatstatements.html)
- [PostgreSQL 18 并行查询文档](https://www.postgresql.org/docs/18/parallel-query.html)
- [PostgreSQL性能调优指南](../PostgreSQL性能调优完整指南.md)

---

**最后更新**: 2025年1月
**文档版本**: v2.0（已添加决策树、推理论证、完整目录）
