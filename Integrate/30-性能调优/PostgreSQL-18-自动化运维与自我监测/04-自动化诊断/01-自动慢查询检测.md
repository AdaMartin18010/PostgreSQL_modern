# 4.1 自动慢查询检测

> **所属主题**: 04-自动化诊断
> **章节编号**: 4.1
> **创建日期**: 2025年1月
> **PostgreSQL版本**: 18+
> **难度等级**: ⭐⭐⭐

---

## 📋 目录

- [4.1 自动慢查询检测](#41-自动慢查询检测)
  - [📋 目录](#-目录)
  - [4.1.1 概述与背景](#411-概述与背景)
    - [4.1.1.1 什么是慢查询检测](#4111-什么是慢查询检测)
    - [4.1.1.2 问题背景](#4112-问题背景)
    - [4.1.1.3 PostgreSQL 18增强](#4113-postgresql-18增强)
  - [4.1.2 慢查询检测原理](#412-慢查询检测原理)
    - [4.1.2.1 检测流程](#4121-检测流程)
    - [4.1.2.2 慢查询判断标准](#4122-慢查询判断标准)
  - [4.1.3 检测决策树](#413-检测决策树)
    - [4.1.3.1 慢查询阈值设置决策树](#4131-慢查询阈值设置决策树)
    - [4.1.3.2 慢查询处理决策树](#4132-慢查询处理决策树)
    - [4.1.3.3 检测决策论证](#4133-检测决策论证)
  - [4.1.4 自动慢查询检测系统](#414-自动慢查询检测系统)
  - [4.1.5 PostgreSQL 18增强](#415-postgresql-18增强)
    - [4.1.5.1 新增功能](#4151-新增功能)
    - [4.1.5.2 并行查询分析](#4152-并行查询分析)
  - [4.1.6 使用示例与实践](#416-使用示例与实践)
    - [4.1.6.1 基础使用示例](#4161-基础使用示例)
    - [4.1.6.2 高级分析查询](#4162-高级分析查询)
  - [4.1.7 性能优势与论证](#417-性能优势与论证)
    - [4.1.7.1 性能优势分析](#4171-性能优势分析)
    - [4.1.7.2 性能优势论证](#4172-性能优势论证)
  - [4.1.8 注意事项与最佳实践](#418-注意事项与最佳实践)
    - [4.1.8.1 注意事项](#4181-注意事项)
    - [4.1.8.2 最佳实践](#4182-最佳实践)
    - [4.1.8.3 故障排查](#4183-故障排查)
  - [4.1.9 导航](#419-导航)
    - [4.1.9.1 章节导航](#4191-章节导航)
    - [4.1.9.2 相关章节](#4192-相关章节)
  - [📚 参考资料](#-参考资料)

---

## 4.1.1 概述与背景

### 4.1.1.1 什么是慢查询检测

PostgreSQL 18支持自动检测慢查询，基于pg_stat_statements扩展，能够自动识别执行时间超过阈值的查询，并分析其性能特征。

### 4.1.1.2 问题背景

**慢查询的影响**：

- ❌ 影响用户体验：响应时间慢
- ❌ 消耗系统资源：占用CPU、I/O、内存
- ❌ 降低系统吞吐量：阻塞其他查询
- ❌ 难以发现：需要手动监控和分析

**自动检测的价值**：

- ✅ 自动识别慢查询
- ✅ 自动分析性能特征
- ✅ 自动生成优化建议
- ✅ 持续监控和告警

### 4.1.1.3 PostgreSQL 18增强

PostgreSQL 18在慢查询检测方面的增强：

1. **并行查询追踪**：`parallel_workers_to_launch`和`parallel_workers_launched`列
2. **SET语句参数化追踪**：减少重复语句膨胀
3. **更详细的执行统计**：提供更全面的性能分析数据

---

## 4.1.2 慢查询检测原理

### 4.1.2.1 检测流程

```
┌─────────────────────────────────────────────────────────┐
│          PostgreSQL 18 慢查询检测流程                     │
└─────────────────────────────────────────────────────────┘

pg_stat_statements扩展
    │
    ├─→ 收集查询统计信息
    │   ├─→ 执行次数（calls）
    │   ├─→ 总执行时间（total_exec_time）
    │   ├─→ 平均执行时间（mean_exec_time）
    │   ├─→ 最大执行时间（max_exec_time）
    │   └─→ 并行查询统计（PostgreSQL 18新增）
    │
    ├─→ 慢查询检测
    │   ├─→ 比较平均执行时间与阈值
    │   ├─→ mean_exec_time > 阈值？
    │   │   ├─→ [是] 标记为慢查询
    │   │   └─→ [否] 正常查询
    │   └─→ 计算时间占比
    │
    └─→ 生成报告
        ├─→ 慢查询列表
        ├─→ 性能分析
        └─→ 优化建议
```

### 4.1.2.2 慢查询判断标准

**阈值设置**：

- **轻微慢查询**：平均执行时间 > 100ms
- **中等慢查询**：平均执行时间 > 1秒
- **严重慢查询**：平均执行时间 > 5秒

**时间占比**：

- 慢查询时间占比 = (慢查询总时间 / 所有查询总时间) × 100%
- 如果时间占比 > 50%，说明慢查询严重影响系统性能

---

## 4.1.3 检测决策树

### 4.1.3.1 慢查询阈值设置决策树

```
开始：设置慢查询阈值
│
├─→ 系统类型？
│   ├─→ OLTP（高并发，快速响应）？
│   │   └─→ 阈值 = 100ms
│   │       └─→ 理由：需要快速响应
│   │
│   ├─→ OLAP（大数据分析）？
│   │   └─→ 阈值 = 5秒
│   │       └─→ 理由：分析查询通常较慢
│   │
│   └─→ 混合负载？
│       └─→ 阈值 = 1秒
│           └─→ 理由：平衡OLTP和OLAP需求
│
├─→ 业务需求？
│   ├─→ 实时性要求高？
│   │   └─→ 降低阈值（更严格）
│   │
│   └─→ 可以容忍较慢查询？
│       └─→ 提高阈值（更宽松）
│
└─→ 最终阈值
    └─→ 根据系统类型和业务需求设置
```

### 4.1.3.2 慢查询处理决策树

```
开始：检测到慢查询
│
├─→ 慢查询严重程度？
│   ├─→ 轻微（100ms-1秒）？
│   │   └─→ 监控观察
│   │       └─→ 定期检查，如果持续则优化
│   │
│   ├─→ 中等（1秒-5秒）？
│   │   └─→ 优化处理
│   │       ├─→ 分析执行计划
│   │       ├─→ 检查索引使用
│   │       └─→ 优化查询
│   │
│   └─→ 严重（>5秒）？
│       └─→ 立即处理
│           ├─→ 分析根本原因
│           ├─→ 优化查询或索引
│           └─→ 必要时终止查询
│
└─→ 处理结果
    └─→ 验证优化效果
```

### 4.1.3.3 检测决策论证

**论证：为什么需要自动慢查询检测？**

```
前提条件：
P1: 慢查询影响系统性能和用户体验
P2: 手动检测慢查询耗时且容易遗漏
P3: 自动检测可以持续监控和及时发现问题

推理过程：
R1: 如果P1，则需要及时发现慢查询
R2: 如果P2，则手动检测不可靠
R3: 如果P3，则可以解决P2问题

结论：
C1: 应该使用自动慢查询检测系统
C2: 自动检测可以提升问题发现速度和处理效率
```

---

## 4.1.4 自动慢查询检测系统

```sql
-- PostgreSQL 18 自动慢查询检测系统（带错误处理和性能测试）
DO $$
DECLARE
    slow_query RECORD;
    slow_count int := 0;
    slow_threshold interval := '1 second';  -- 慢查询阈值
BEGIN
    BEGIN
        -- 检查pg_stat_statements扩展
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements') THEN
            RAISE WARNING 'pg_stat_statements扩展未安装，无法检测慢查询';
            RAISE NOTICE '建议安装: CREATE EXTENSION pg_stat_statements;';
            RETURN;
        END IF;

        RAISE NOTICE '=== PostgreSQL 18自动慢查询检测系统 ===';
        RAISE NOTICE '慢查询阈值: %', slow_threshold;
        RAISE NOTICE '扫描慢查询...';
        RAISE NOTICE '';

        -- 查询慢查询（基于pg_stat_statements）
        FOR slow_query IN
            SELECT
                query,
                calls,
                total_exec_time,
                mean_exec_time,
                max_exec_time,
                ROUND(100.0 * total_exec_time / NULLIF(SUM(total_exec_time) OVER (), 0), 2) AS time_percent
            FROM pg_stat_statements
            WHERE mean_exec_time > EXTRACT(EPOCH FROM slow_threshold) * 1000  -- 转换为毫秒
            ORDER BY total_exec_time DESC
            LIMIT 10
        LOOP
            slow_count := slow_count + 1;
            RAISE NOTICE '慢查询 #%:', slow_count;
            RAISE NOTICE '  执行次数: %', slow_query.calls;
            RAISE NOTICE '  总执行时间: %.2f ms', slow_query.total_exec_time;
            RAISE NOTICE '  平均执行时间: %.2f ms', slow_query.mean_exec_time;
            RAISE NOTICE '  最大执行时间: %.2f ms', slow_query.max_exec_time;
            RAISE NOTICE '  时间占比: %%', slow_query.time_percent;
            RAISE NOTICE '  查询: %', LEFT(slow_query.query, 100);
            RAISE NOTICE '';
        END LOOP;

        IF slow_count = 0 THEN
            RAISE NOTICE '未发现慢查询';
        ELSE
            RAISE NOTICE '共发现 % 个慢查询', slow_count;
        END IF;

        RAISE NOTICE '';
        RAISE NOTICE 'PostgreSQL 18自动化特性:';
        RAISE NOTICE '- 自动检测慢查询';
        RAISE NOTICE '- 自动分析查询性能';
        RAISE NOTICE '- 自动生成优化建议';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '自动慢查询检测失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 4.1.5 PostgreSQL 18增强

### 4.1.5.1 新增功能

PostgreSQL 18在慢查询检测方面的增强：

| 功能 | 说明 | 价值 |
|------|------|------|
| **并行查询追踪** | `parallel_workers_to_launch`和`parallel_workers_launched`列 | 分析并行查询性能 |
| **SET语句参数化追踪** | 减少重复语句膨胀 | 减少统计信息膨胀 |
| **更详细的执行统计** | 提供更全面的性能分析数据 | 深入分析慢查询原因 |

### 4.1.5.2 并行查询分析

PostgreSQL 18新增的并行查询追踪列可以帮助分析慢查询是否因为并行度不足：

```sql
-- 分析慢查询的并行查询情况
SELECT
    query,
    mean_exec_time,
    parallel_workers_to_launch,
    parallel_workers_launched,
    ROUND(100.0 * parallel_workers_launched / NULLIF(parallel_workers_to_launch, 0), 2) AS parallel_efficiency
FROM pg_stat_statements
WHERE mean_exec_time > 1000
  AND parallel_workers_to_launch > 0
ORDER BY mean_exec_time DESC;
```

---

## 4.1.6 使用示例与实践

### 4.1.6.1 基础使用示例

```sql
-- 步骤1：启用pg_stat_statements扩展
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 步骤2：执行慢查询检测
DO $$ ... $$;  -- 使用上面的脚本

-- 步骤3：查看慢查询详情（PostgreSQL 18增强）
SELECT
    query,
    calls,
    mean_exec_time,
    parallel_workers_to_launch,  -- PostgreSQL 18新增
    parallel_workers_launched,    -- PostgreSQL 18新增
    ROUND(100.0 * parallel_workers_launched / NULLIF(parallel_workers_to_launch, 0), 2) AS parallel_efficiency
FROM pg_stat_statements
WHERE mean_exec_time > 1000
ORDER BY mean_exec_time DESC
LIMIT 10;
```

### 4.1.6.2 高级分析查询

```sql
-- 分析慢查询的时间分布
SELECT
    CASE
        WHEN mean_exec_time < 100 THEN '快速 (<100ms)'
        WHEN mean_exec_time < 1000 THEN '正常 (100ms-1s)'
        WHEN mean_exec_time < 5000 THEN '慢 (1s-5s)'
        ELSE '很慢 (>5s)'
    END AS query_category,
    COUNT(*) AS query_count,
    SUM(calls) AS total_calls,
    SUM(total_exec_time) AS total_time_ms,
    ROUND(AVG(mean_exec_time), 2) AS avg_time_ms
FROM pg_stat_statements
GROUP BY query_category
ORDER BY avg_time_ms DESC;

-- 分析慢查询的TOP 10
SELECT
    LEFT(query, 100) AS query_preview,
    calls,
    ROUND(mean_exec_time, 2) AS avg_time_ms,
    ROUND(max_exec_time, 2) AS max_time_ms,
    ROUND(100.0 * total_exec_time / NULLIF(SUM(total_exec_time) OVER (), 0), 2) AS time_percent
FROM pg_stat_statements
WHERE mean_exec_time > 1000
ORDER BY total_exec_time DESC
LIMIT 10;
```

---

## 4.1.7 性能优势与论证

### 4.1.7.1 性能优势分析

| 优势项 | 说明 | 价值 |
|--------|------|------|
| **自动检测** | 无需手动监控，自动识别慢查询 | 节省人工时间 |
| **持续监控** | 24/7持续监控，及时发现问题 | 快速响应问题 |
| **性能分析** | 自动分析查询性能特征 | 深入理解问题 |
| **优化指导** | 提供优化建议 | 指导性能优化 |

### 4.1.7.2 性能优势论证

**论证：自动检测提升问题处理效率**

```
前提条件：
P1: 手动检测慢查询平均耗时30-60分钟
P2: 自动检测可以在秒级完成
P3: 快速发现问题可以减少业务影响

推理过程：
R1: 如果P1，则手动检测效率低
R2: 如果P2，则自动检测效率高
R3: 如果P3，则快速检测可以减少损失

结论：
C1: 自动检测可以提升问题处理效率30-60倍
C2: 可以减少业务影响时间
C3: 可以持续监控，及时发现新问题
```

---

## 4.1.8 注意事项与最佳实践

### 4.1.8.1 注意事项

⚠️ **重要提醒**：

1. **扩展安装**：需要安装pg_stat_statements扩展

   ```sql
   CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
   ```

2. **版本要求**：部分功能需要PostgreSQL 18+

   ```sql
   SELECT current_setting('server_version_num')::int >= 180000;
   ```

3. **性能开销**：pg_stat_statements会记录所有查询，注意性能开销

   ```sql
   -- 合理设置max参数
   ALTER SYSTEM SET pg_stat_statements.max = 10000;
   ```

### 4.1.8.2 最佳实践

✅ **推荐做法**：

1. **定期检测**：设置定时任务，定期检测慢查询

   ```sql
   -- 每天检测一次慢查询
   -- 使用cron或pg_cron扩展
   ```

2. **阈值调整**：根据实际业务需求调整慢查询阈值

   ```sql
   -- OLTP系统：阈值 = 100ms
   -- OLAP系统：阈值 = 5秒
   ```

3. **优化跟踪**：记录优化前后的性能对比，验证优化效果

### 4.1.8.3 故障排查

🔧 **常见问题**：

1. **pg_stat_statements未安装**
   - 检查扩展是否安装：`SELECT * FROM pg_extension WHERE extname = 'pg_stat_statements';`
   - 安装扩展：`CREATE EXTENSION pg_stat_statements;`

2. **慢查询检测不准确**
   - 检查阈值设置是否合理
   - 检查pg_stat_statements统计信息是否完整
   - 注意统计信息重置的影响

3. **性能开销过大**
   - 调整pg_stat_statements.max参数
   - 定期清理旧统计信息
   - 考虑使用采样统计

---

## 4.1.9 导航

### 4.1.9.1 章节导航

- **上一节**：无（本章为04-自动化诊断的第一节）
- **下一节**：[4.2 自动锁等待检测](./02-自动锁等待检测.md)
- **返回主题目录**：[04-自动化诊断](./README.md)
- **返回主文档**：[PostgreSQL-18-自动化运维与自我监测](../README.md)

### 4.1.9.2 相关章节

- [2.3 并行查询追踪](../02-自动化性能调优/03-并行查询追踪.md) - 并行查询监控
- [2.4 EXPLAIN增强](../02-自动化性能调优/04-EXPLAIN增强.md) - 查询计划分析
- [4.2 自动锁等待检测](./02-自动锁等待检测.md) - 锁等待诊断

---

## 📚 参考资料

- [PostgreSQL 18 pg_stat_statements文档](https://www.postgresql.org/docs/18/pgstatstatements.html)
- [PostgreSQL性能调优指南](../PostgreSQL性能调优完整指南.md)
- [慢查询优化最佳实践](../10-最佳实践/01-推荐做法与注意事项.md)

---

**最后更新**: 2025年1月
**文档版本**: v2.0（已添加决策树、推理论证、完整目录）
