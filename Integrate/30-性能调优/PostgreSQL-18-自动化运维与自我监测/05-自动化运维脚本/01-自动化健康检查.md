# 5.1 自动化健康检查

> **所属主题**: 05-自动化运维脚本
> **章节编号**: 5.1
> **创建日期**: 2025年1月
> **PostgreSQL版本**: 18+
> **难度等级**: ⭐⭐⭐
> **相关章节**: [4.3 自动资源瓶颈检测](../04-自动化诊断/03-自动资源瓶颈检测.md) | [5.2 自动化性能报告](./02-自动化性能报告.md)

---

## 📋 目录

- [5.1 自动化健康检查](#51-自动化健康检查)
  - [📋 目录](#-目录)
  - [5.1.1 概述与背景](#511-概述与背景)
  - [5.1.2 自动化健康检查系统](#512-自动化健康检查系统)
    - [5.1.2.1 完整健康检查脚本](#5121-完整健康检查脚本)
  - [5.1.3 健康检查项说明](#513-健康检查项说明)
    - [5.1.3.1 数据库连接检查](#5131-数据库连接检查)
    - [5.1.3.2 锁等待检查](#5132-锁等待检查)
    - [5.1.3.3 死元组检查](#5133-死元组检查)
    - [5.1.3.4 统计信息检查](#5134-统计信息检查)
    - [5.1.3.5 I/O性能检查（PostgreSQL 18）](#5135-io性能检查postgresql-18)
  - [5.1.4 创建健康检查函数](#514-创建健康检查函数)
    - [5.1.4.1 可重用函数版本](#5141-可重用函数版本)
  - [5.1.5 定时执行健康检查](#515-定时执行健康检查)
    - [5.1.5.1 使用pg\_cron定时执行](#5151-使用pg_cron定时执行)
  - [5.1.6 PostgreSQL 18自动化特性](#516-postgresql-18自动化特性)
  - [5.1.7 注意事项与最佳实践](#517-注意事项与最佳实践)
    - [5.1.7.1 注意事项](#5171-注意事项)
    - [5.1.7.2 最佳实践](#5172-最佳实践)
  - [5.1.8 导航](#518-导航)
    - [5.1.8.1 章节导航](#5181-章节导航)
    - [5.1.8.2 相关章节](#5182-相关章节)
  - [📚 相关资源](#-相关资源)

---

## 5.1.1 概述与背景

PostgreSQL 18自动化健康检查系统可以自动检查数据库的健康状态，包括连接状态、锁等待、死元组、统计信息、I/O性能等关键指标。

---

## 5.1.2 自动化健康检查系统

### 5.1.2.1 完整健康检查脚本

```sql
-- PostgreSQL 18 自动化健康检查系统（带错误处理和性能测试）
DO $$
DECLARE
    health_status text := '健康';
    health_issues text[] := ARRAY[]::text[];
    check_result RECORD;
BEGIN
    BEGIN
        RAISE NOTICE '=== PostgreSQL 18自动化健康检查系统 ===';
        RAISE NOTICE '开始健康检查...';
        RAISE NOTICE '';

        -- 检查1: 数据库连接
        SELECT COUNT(*) INTO check_result
        FROM pg_stat_activity
        WHERE datname = current_database();

        IF check_result.count = 0 THEN
            health_issues := array_append(health_issues, '数据库连接异常');
        ELSE
            RAISE NOTICE '✓ 数据库连接正常: % 个连接', check_result.count;
        END IF;

        -- 检查2: 锁等待
        SELECT COUNT(*) INTO check_result
        FROM pg_catalog.pg_locks blocked_locks
        JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
        WHERE NOT blocked_locks.granted;

        IF check_result.count > 5 THEN
            health_issues := array_append(health_issues, format('锁等待过多: % 个', check_result.count));
        ELSE
            RAISE NOTICE '✓ 锁状态正常: % 个等待', check_result.count;
        END IF;

        -- 检查3: 死元组（PostgreSQL 18）
        SELECT
            SUM(n_dead_tup) AS total_dead_tuples,
            SUM(n_live_tup) AS total_live_tuples
        INTO check_result
        FROM pg_stat_user_tables;

        IF check_result.total_dead_tuples > 0 THEN
            DECLARE
                dead_ratio numeric;
            BEGIN
                dead_ratio := 100.0 * check_result.total_dead_tuples /
                              NULLIF(check_result.total_dead_tuples + check_result.total_live_tuples, 0);
                IF dead_ratio > 10 THEN
                    health_issues := array_append(health_issues,
                        format('死元组比例过高: %.2f%%', dead_ratio));
                ELSE
                    RAISE NOTICE '✓ 死元组比例正常: %.2f%%', dead_ratio;
                END IF;
            END;
        ELSE
            RAISE NOTICE '✓ 无死元组';
        END IF;

        -- 检查4: 统计信息（PostgreSQL 18）
        SELECT COUNT(*) INTO check_result
        FROM pg_stat_user_tables
        WHERE last_autoanalyze IS NULL
           OR last_autoanalyze < NOW() - INTERVAL '7 days';

        IF check_result.count > 10 THEN
            health_issues := array_append(health_issues,
                format('统计信息过期表过多: % 个', check_result.count));
        ELSE
            RAISE NOTICE '✓ 统计信息正常: % 个表需要更新', check_result.count;
        END IF;

        -- 检查5: I/O性能（PostgreSQL 18）
        IF (SELECT current_setting('server_version_num')::int) >= 180000 THEN
            SELECT
                SUM(reads + writes) AS total_io,
                SUM(read_bytes + write_bytes) AS total_bytes
            INTO check_result
            FROM pg_stat_io;

            IF check_result.total_io > 0 THEN
                RAISE NOTICE '✓ I/O统计正常: % 次操作, %.2f MB',
                    check_result.total_io,
                    ROUND(check_result.total_bytes::numeric / 1024 / 1024, 2);
            END IF;
        END IF;

        -- 汇总健康状态
        RAISE NOTICE '';
        IF array_length(health_issues, 1) > 0 THEN
            health_status := '警告';
            RAISE WARNING '健康状态: %', health_status;
            RAISE NOTICE '发现的问题:';
            FOREACH check_result.count IN ARRAY health_issues
            LOOP
                RAISE NOTICE '  - %', check_result.count;
            END LOOP;
        ELSE
            RAISE NOTICE '健康状态: %', health_status;
            RAISE NOTICE '所有检查项均正常';
        END IF;

        RAISE NOTICE '';
        RAISE NOTICE 'PostgreSQL 18自动化特性:';
        RAISE NOTICE '- 自动健康检查';
        RAISE NOTICE '- 自动问题识别';
        RAISE NOTICE '- 自动生成报告';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '自动化健康检查失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5.1.3 健康检查项说明

### 5.1.3.1 数据库连接检查

检查当前数据库的连接数，确保数据库可以正常连接。

**检查标准**：

- 连接数 > 0：正常
- 连接数 = 0：异常

### 5.1.3.2 锁等待检查

检查当前锁等待的数量，识别可能的锁竞争问题。

**检查标准**：

- 锁等待数 ≤ 5：正常
- 锁等待数 > 5：警告

### 5.1.3.3 死元组检查

检查死元组比例，识别表膨胀问题。

**检查标准**：

- 死元组比例 ≤ 10%：正常
- 死元组比例 > 10%：警告

### 5.1.3.4 统计信息检查

检查统计信息的时效性，确保查询优化器有准确的统计信息。

**检查标准**：

- 过期表数 ≤ 10：正常
- 过期表数 > 10：警告

### 5.1.3.5 I/O性能检查（PostgreSQL 18）

检查I/O统计信息，识别I/O性能问题。

**检查标准**：

- I/O操作数 > 0：正常（有I/O活动）

---

## 5.1.4 创建健康检查函数

### 5.1.4.1 可重用函数版本

```sql
-- 创建自动化健康检查函数
CREATE OR REPLACE FUNCTION pg18_health_check()
RETURNS TABLE(
    check_item TEXT,
    check_status TEXT,
    check_message TEXT,
    check_time TIMESTAMP
) AS $$
DECLARE
    check_item TEXT;
    check_status TEXT;
    check_message TEXT;
    check_time TIMESTAMP := NOW();
    check_result RECORD;
BEGIN
    -- 检查1: 数据库连接
    SELECT COUNT(*) INTO check_result
    FROM pg_stat_activity
    WHERE datname = current_database();

    check_item := '数据库连接';
    IF check_result.count = 0 THEN
        check_status := '异常';
        check_message := '数据库连接数为0';
    ELSE
        check_status := '正常';
        check_message := format('连接数: %', check_result.count);
    END IF;
    RETURN QUERY SELECT check_item, check_status, check_message, check_time;

    -- 检查2: 锁等待
    SELECT COUNT(*) INTO check_result
    FROM pg_catalog.pg_locks blocked_locks
    JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
    WHERE NOT blocked_locks.granted;

    check_item := '锁等待';
    IF check_result.count > 5 THEN
        check_status := '警告';
        check_message := format('锁等待数: %', check_result.count);
    ELSE
        check_status := '正常';
        check_message := format('锁等待数: %', check_result.count);
    END IF;
    RETURN QUERY SELECT check_item, check_status, check_message, check_time;

    -- 检查3: 死元组
    SELECT
        SUM(n_dead_tup) AS total_dead_tuples,
        SUM(n_live_tup) AS total_live_tuples
    INTO check_result
    FROM pg_stat_user_tables;

    check_item := '死元组';
    IF check_result.total_dead_tuples > 0 THEN
        DECLARE
            dead_ratio numeric;
        BEGIN
            dead_ratio := 100.0 * check_result.total_dead_tuples /
                          NULLIF(check_result.total_dead_tuples + check_result.total_live_tuples, 0);
            IF dead_ratio > 10 THEN
                check_status := '警告';
                check_message := format('死元组比例: %.2f%%', dead_ratio);
            ELSE
                check_status := '正常';
                check_message := format('死元组比例: %.2f%%', dead_ratio);
            END IF;
        END;
    ELSE
        check_status := '正常';
        check_message := '无死元组';
    END IF;
    RETURN QUERY SELECT check_item, check_status, check_message, check_time;

    -- 检查4: 统计信息
    SELECT COUNT(*) INTO check_result
    FROM pg_stat_user_tables
    WHERE last_autoanalyze IS NULL
       OR last_autoanalyze < NOW() - INTERVAL '7 days';

    check_item := '统计信息';
    IF check_result.count > 10 THEN
        check_status := '警告';
        check_message := format('过期表数: %', check_result.count);
    ELSE
        check_status := '正常';
        check_message := format('过期表数: %', check_result.count);
    END IF;
    RETURN QUERY SELECT check_item, check_status, check_message, check_time;
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT * FROM pg18_health_check();
```

---

## 5.1.5 定时执行健康检查

### 5.1.5.1 使用pg_cron定时执行

```sql
-- 安装pg_cron扩展（如果未安装）
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 每小时执行健康检查
SELECT cron.schedule(
    'health-check-hourly',
    '0 * * * *',
    $$SELECT * FROM pg18_health_check()$$
);
```

---

## 5.1.6 PostgreSQL 18自动化特性

PostgreSQL 18自动化健康检查系统的核心特性：

1. **自动健康检查**：自动检查数据库健康状态
2. **自动问题识别**：自动识别潜在问题
3. **自动生成报告**：自动生成健康检查报告
4. **I/O性能监测**：使用PostgreSQL 18的I/O统计增强（pg_stat_io）
5. **实时监控**：基于实时统计信息，准确反映当前状态

---

## 5.1.7 注意事项与最佳实践

### 5.1.7.1 注意事项

⚠️ **重要提醒**：

1. **检查频率**：根据实际情况设置检查频率，建议每小时或每30分钟
2. **阈值调整**：根据实际情况调整检查阈值，避免误报
3. **性能影响**：健康检查本身会有轻微性能影响，注意资源使用

### 5.1.7.2 最佳实践

✅ **推荐做法**：

1. **定期执行**：使用pg_cron定时执行健康检查
2. **阈值优化**：根据业务特点优化检查阈值
3. **告警配置**：配置健康检查结果告警机制
4. **历史记录**：记录健康检查历史，便于趋势分析

---

## 5.1.8 导航

### 5.1.8.1 章节导航

- **上一节**：无（本章为05-自动化运维脚本的第一节）
- **下一节**：[5.2 自动化性能报告](./02-自动化性能报告.md)
- **返回主题目录**：[05-自动化运维脚本](./README.md)
- **返回主文档**：[PostgreSQL-18-自动化运维与自我监测](../README.md)

### 5.1.8.2 相关章节

- [5.2 自动化性能报告](./02-自动化性能报告.md) - 性能报告生成
- [5.3 自动化告警系统](./03-自动化告警系统.md) - 告警系统
- [4.3 自动资源瓶颈检测](../04-自动化诊断/03-自动资源瓶颈检测.md) - 资源瓶颈检测
- [6.1 自动化运维架构](../06-综合方案/01-自动化运维架构.md) - 自动化运维架构

---

## 📚 相关资源

- [PostgreSQL 18 pg_stat_activity文档](https://www.postgresql.org/docs/18/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW)
- [pg_locks文档](https://www.postgresql.org/docs/18/view-pg-locks.html)
- [pg_cron文档](https://github.com/citusdata/pg_cron)
- [PostgreSQL自动化运维最佳实践](../10-最佳实践/01-推荐做法与注意事项.md)

---

**最后更新**: 2025年1月
**文档版本**: v2.0（已添加完整目录、章节编号、详细内容）
