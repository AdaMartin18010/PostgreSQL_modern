# 6.5 故障自动恢复机制

> **所属主题**: 06-综合方案
> **章节编号**: 6.5
> **创建日期**: 2025年1月
> **PostgreSQL版本**: 18+
> **难度等级**: ⭐⭐⭐⭐⭐
> **相关章节**: [6.4 应用场景案例](./04-应用场景案例.md) | [6.1 自动化运维架构](./01-自动化运维架构.md)

---

## 📋 目录

- [6.5 故障自动恢复机制](#65-故障自动恢复机制)
  - [📋 目录](#-目录)
  - [6.5.1 概述与背景](#651-概述与背景)
  - [6.5.2 故障自动检测与恢复系统](#652-故障自动检测与恢复系统)
    - [故障自动恢复函数](#故障自动恢复函数)
  - [6.5.3 故障恢复类型](#653-故障恢复类型)
    - [1. 死锁恢复](#1-死锁恢复)
    - [2. 连接清理](#2-连接清理)
    - [3. 表膨胀恢复](#3-表膨胀恢复)
    - [4. 统计信息更新](#4-统计信息更新)
  - [6.5.4 自动恢复执行](#654-自动恢复执行)
    - [6.5.4.1 启用自动执行（谨慎使用）](#6541-启用自动执行谨慎使用)
    - [6.5.4.2 定时执行故障恢复检查](#6542-定时执行故障恢复检查)
  - [6.5.5 恢复状态说明](#655-恢复状态说明)
    - [6.5.5.1 恢复状态类型](#6551-恢复状态类型)
    - [6.5.5.2 恢复操作建议](#6552-恢复操作建议)
  - [6.5.6 注意事项与最佳实践](#656-注意事项与最佳实践)
    - [PostgreSQL 18优势](#postgresql-18优势)
    - [注意事项](#注意事项)
    - [最佳实践](#最佳实践)
  - [6.5.7 导航](#657-导航)
    - [6.5.7.1 章节导航](#6571-章节导航)
    - [6.5.7.2 相关章节](#6572-相关章节)
  - [📚 相关资源](#-相关资源)

---

## 6.5.1 概述与背景

PostgreSQL 18故障自动检测与恢复系统可以自动检测各种故障情况，包括死锁、连接数告警、表膨胀、统计信息过期等，并提供自动恢复建议或执行自动恢复操作。

---

## 6.5.2 故障自动检测与恢复系统

### 故障自动恢复函数

```sql
-- PostgreSQL 18 故障自动检测与恢复系统（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION pg18_auto_recovery()
RETURNS TABLE(
    recovery_action TEXT,
    recovery_status TEXT,
    recovery_details TEXT,
    recovery_time TIMESTAMP
) AS $$
DECLARE
    recovery_action TEXT;
    recovery_status TEXT;
    recovery_details TEXT;
    recovery_time TIMESTAMP := NOW();
    pg_version int;
BEGIN
    SELECT current_setting('server_version_num')::int INTO pg_version;

    IF pg_version < 180000 THEN
        RAISE WARNING 'PostgreSQL 18故障自动恢复需要PostgreSQL 18+';
        RETURN;
    END IF;

    -- 恢复1: 死锁自动检测与恢复
    BEGIN
        DECLARE
            deadlock_count bigint;
            blocked_pid int;
        BEGIN
            SELECT deadlocks INTO deadlock_count
            FROM pg_stat_database
            WHERE datname = current_database();

            IF deadlock_count > 10 THEN
                -- 查找长时间阻塞的查询
                SELECT blocked_locks.pid INTO blocked_pid
                FROM pg_catalog.pg_locks blocked_locks
                JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
                WHERE NOT blocked_locks.granted
                AND EXTRACT(EPOCH FROM (NOW() - blocked_activity.query_start)) > 300  -- 阻塞超过5分钟
                LIMIT 1;

                IF blocked_pid IS NOT NULL THEN
                    -- 终止阻塞查询（谨慎使用）
                    -- PERFORM pg_terminate_backend(blocked_pid);

                    recovery_action := '死锁恢复';
                    recovery_status := '已检测';
                    recovery_details := format('检测到死锁，阻塞进程: %s（未自动终止，需人工确认）', blocked_pid);
                    RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
                END IF;
            END IF;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '死锁恢复';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;

    -- 恢复2: 连接数告警与自动清理
    BEGIN
        DECLARE
            current_connections int;
            max_connections int;
            idle_in_transaction_count int;
        BEGIN
            SELECT COUNT(*) INTO current_connections FROM pg_stat_activity WHERE datname = current_database();
            SELECT setting::int INTO max_connections FROM pg_settings WHERE name = 'max_connections';
            SELECT COUNT(*) INTO idle_in_transaction_count FROM pg_stat_activity
            WHERE datname = current_database() AND state = 'idle in transaction';

            IF current_connections > max_connections * 0.9 THEN
                -- 清理长时间空闲的事务
                IF idle_in_transaction_count > 10 THEN
                    recovery_action := '连接清理';
                    recovery_status := '建议执行';
                    recovery_details := format('连接数: %s/%s，建议清理 %s 个空闲事务',
                        current_connections, max_connections, idle_in_transaction_count);
                    RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
                END IF;
            END IF;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '连接清理';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;

    -- 恢复3: 表膨胀自动VACUUM（PostgreSQL 18优化）
    BEGIN
        DECLARE
            table_record RECORD;
        BEGIN
            FOR table_record IN
                SELECT
                    schemaname,
                    tablename,
                    n_dead_tup,
                    n_live_tup,
                    ROUND(100.0 * n_dead_tup / NULLIF(n_dead_tup + n_live_tup, 0), 2) AS dead_ratio
                FROM pg_stat_user_tables
                WHERE n_dead_tup > 10000
                AND ROUND(100.0 * n_dead_tup / NULLIF(n_dead_tup + n_live_tup, 0), 2) > 20
                ORDER BY dead_ratio DESC
                LIMIT 5
            LOOP
                -- 自动执行VACUUM（PostgreSQL 18异步I/O支持）
                -- EXECUTE format('VACUUM ANALYZE %I.%I', table_record.schemaname, table_record.tablename);

                recovery_action := '表膨胀恢复';
                recovery_status := '建议执行';
                recovery_details := format('表 %s.%s 死元组比例: %s%%，建议执行VACUUM',
                    table_record.schemaname, table_record.tablename, table_record.dead_ratio);
                RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
            END LOOP;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '表膨胀恢复';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;

    -- 恢复4: 统计信息过期自动更新
    BEGIN
        DECLARE
            table_record RECORD;
        BEGIN
            FOR table_record IN
                SELECT schemaname, tablename, last_autoanalyze
                FROM pg_stat_user_tables
                WHERE last_autoanalyze IS NULL
                   OR last_autoanalyze < NOW() - INTERVAL '7 days'
                ORDER BY last_autoanalyze NULLS FIRST
                LIMIT 5
            LOOP
                -- 自动执行ANALYZE
                -- EXECUTE format('ANALYZE %I.%I', table_record.schemaname, table_record.tablename);

                recovery_action := '统计信息更新';
                recovery_status := '建议执行';
                recovery_details := format('表 %s.%s 统计信息过期，最后分析: %s',
                    table_record.schemaname,
                    table_record.tablename,
                    COALESCE(table_record.last_autoanalyze::text, '从未'));
                RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
            END LOOP;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '统计信息更新';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT * FROM pg18_auto_recovery();
```

---

## 6.5.3 故障恢复类型

### 1. 死锁恢复

**检测条件**：

- 死锁次数 > 10
- 阻塞查询时间 > 5分钟

**恢复操作**：

- 检测阻塞进程
- 提供终止建议（需人工确认）

### 2. 连接清理

**检测条件**：

- 连接数 > max_connections * 0.9
- 空闲事务数 > 10

**恢复操作**：

- 识别空闲事务
- 提供清理建议

### 3. 表膨胀恢复

**检测条件**：

- 死元组数 > 10000
- 死元组比例 > 20%

**恢复操作**：

- 识别需要VACUUM的表
- 提供VACUUM建议（可自动执行）

### 4. 统计信息更新

**检测条件**：

- 统计信息过期（>7天）
- 或从未分析

**恢复操作**：

- 识别需要ANALYZE的表
- 提供ANALYZE建议（可自动执行）

---

## 6.5.4 自动恢复执行

### 6.5.4.1 启用自动执行（谨慎使用）

```sql
-- 修改函数以启用自动执行（需要谨慎）
-- 取消注释以下行以启用自动执行：

-- 死锁恢复：PERFORM pg_terminate_backend(blocked_pid);
-- 表膨胀恢复：EXECUTE format('VACUUM ANALYZE %I.%I', ...);
-- 统计信息更新：EXECUTE format('ANALYZE %I.%I', ...);
```

### 6.5.4.2 定时执行故障恢复检查

```sql
-- 每15分钟执行故障恢复检查
SELECT cron.schedule(
    'auto-recovery-check',
    '*/15 * * * *',
    $$SELECT * FROM pg18_auto_recovery()$$
);
```

---

## 6.5.5 恢复状态说明

### 6.5.5.1 恢复状态类型

- **已检测**：已检测到问题，需要人工确认
- **建议执行**：建议执行恢复操作
- **自动执行**：已自动执行恢复操作
- **错误**：恢复检查过程中发生错误

### 6.5.5.2 恢复操作建议

1. **死锁恢复**：通常需要人工确认，谨慎终止进程
2. **连接清理**：可以自动清理空闲事务
3. **表膨胀恢复**：可以自动执行VACUUM（PostgreSQL 18支持异步I/O）
4. **统计信息更新**：可以自动执行ANALYZE

---

## 6.5.6 注意事项与最佳实践

### PostgreSQL 18优势

1. **异步I/O支持**：VACUUM操作更高效
2. **更详细的统计**：更准确的故障检测
3. **并行VACUUM**：支持并行VACUUM操作

### 注意事项

⚠️ **重要提醒**：

1. **谨慎使用**：自动恢复操作需要谨慎使用，避免误操作
2. **人工确认**：重要操作建议人工确认后再执行
3. **监控**：持续监控恢复操作效果，确保恢复成功
4. **测试**：在生产环境前充分测试，验证恢复逻辑

### 最佳实践

✅ **推荐做法**：

1. **分级恢复**：设置分级恢复策略，简单问题自动恢复，复杂问题人工处理
2. **恢复记录**：记录所有恢复操作和结果，便于后续分析
3. **回滚机制**：为重要恢复操作提供回滚机制
4. **定期测试**：定期测试自动恢复功能，确保正常工作

---

## 6.5.7 导航

### 6.5.7.1 章节导航

- **上一节**：[6.4 应用场景案例](./04-应用场景案例.md)
- **下一节**：无（本章为06-综合方案的最后一节）
- **返回主题目录**：[06-综合方案](./README.md)
- **返回主文档**：[PostgreSQL-18-自动化运维与自我监测](../README.md)

### 6.5.7.2 相关章节

- [6.1 自动化运维架构](./01-自动化运维架构.md) - 自动化运维架构
- [9.1 故障排查流程与脚本](../09-故障排查/01-故障排查流程与脚本.md) - 故障排查
- [5.3 自动化告警系统](../05-自动化运维脚本/03-自动化告警系统.md) - 告警系统

---

## 📚 相关资源

- [PostgreSQL 18 VACUUM文档](https://www.postgresql.org/docs/18/sql-vacuum.html)
- [ANALYZE文档](https://www.postgresql.org/docs/18/sql-analyze.html)
- [故障排查文档](https://www.postgresql.org/docs/18/runtime-config-logging.html)
- [PostgreSQL故障排查最佳实践](../10-最佳实践/01-推荐做法与注意事项.md)

---

**最后更新**: 2025年1月
**文档版本**: v2.0（已添加完整目录、章节编号、详细内容）
