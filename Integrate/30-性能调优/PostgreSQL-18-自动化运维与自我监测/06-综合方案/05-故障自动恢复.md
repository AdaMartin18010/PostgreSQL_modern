# 故障自动恢复机制

> **PostgreSQL版本**: 18+
> **难度等级**: ⭐⭐⭐⭐⭐
> **相关章节**: [应用场景案例](./04-应用场景案例.md) | [自动化运维架构](./01-自动化运维架构.md)

---

## 概述

PostgreSQL 18故障自动检测与恢复系统可以自动检测各种故障情况，包括死锁、连接数告警、表膨胀、统计信息过期等，并提供自动恢复建议或执行自动恢复操作。

---

## 故障自动检测与恢复系统

### 故障自动恢复函数

```sql
-- PostgreSQL 18 故障自动检测与恢复系统（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION pg18_auto_recovery()
RETURNS TABLE(
    recovery_action TEXT,
    recovery_status TEXT,
    recovery_details TEXT,
    recovery_time TIMESTAMP
) AS $$
DECLARE
    recovery_action TEXT;
    recovery_status TEXT;
    recovery_details TEXT;
    recovery_time TIMESTAMP := NOW();
    pg_version int;
BEGIN
    SELECT current_setting('server_version_num')::int INTO pg_version;

    IF pg_version < 180000 THEN
        RAISE WARNING 'PostgreSQL 18故障自动恢复需要PostgreSQL 18+';
        RETURN;
    END IF;

    -- 恢复1: 死锁自动检测与恢复
    BEGIN
        DECLARE
            deadlock_count bigint;
            blocked_pid int;
        BEGIN
            SELECT deadlocks INTO deadlock_count
            FROM pg_stat_database
            WHERE datname = current_database();

            IF deadlock_count > 10 THEN
                -- 查找长时间阻塞的查询
                SELECT blocked_locks.pid INTO blocked_pid
                FROM pg_catalog.pg_locks blocked_locks
                JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
                WHERE NOT blocked_locks.granted
                AND EXTRACT(EPOCH FROM (NOW() - blocked_activity.query_start)) > 300  -- 阻塞超过5分钟
                LIMIT 1;

                IF blocked_pid IS NOT NULL THEN
                    -- 终止阻塞查询（谨慎使用）
                    -- PERFORM pg_terminate_backend(blocked_pid);

                    recovery_action := '死锁恢复';
                    recovery_status := '已检测';
                    recovery_details := format('检测到死锁，阻塞进程: %s（未自动终止，需人工确认）', blocked_pid);
                    RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
                END IF;
            END IF;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '死锁恢复';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;

    -- 恢复2: 连接数告警与自动清理
    BEGIN
        DECLARE
            current_connections int;
            max_connections int;
            idle_in_transaction_count int;
        BEGIN
            SELECT COUNT(*) INTO current_connections FROM pg_stat_activity WHERE datname = current_database();
            SELECT setting::int INTO max_connections FROM pg_settings WHERE name = 'max_connections';
            SELECT COUNT(*) INTO idle_in_transaction_count FROM pg_stat_activity
            WHERE datname = current_database() AND state = 'idle in transaction';

            IF current_connections > max_connections * 0.9 THEN
                -- 清理长时间空闲的事务
                IF idle_in_transaction_count > 10 THEN
                    recovery_action := '连接清理';
                    recovery_status := '建议执行';
                    recovery_details := format('连接数: %s/%s，建议清理 %s 个空闲事务',
                        current_connections, max_connections, idle_in_transaction_count);
                    RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
                END IF;
            END IF;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '连接清理';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;

    -- 恢复3: 表膨胀自动VACUUM（PostgreSQL 18优化）
    BEGIN
        DECLARE
            table_record RECORD;
        BEGIN
            FOR table_record IN
                SELECT
                    schemaname,
                    tablename,
                    n_dead_tup,
                    n_live_tup,
                    ROUND(100.0 * n_dead_tup / NULLIF(n_dead_tup + n_live_tup, 0), 2) AS dead_ratio
                FROM pg_stat_user_tables
                WHERE n_dead_tup > 10000
                AND ROUND(100.0 * n_dead_tup / NULLIF(n_dead_tup + n_live_tup, 0), 2) > 20
                ORDER BY dead_ratio DESC
                LIMIT 5
            LOOP
                -- 自动执行VACUUM（PostgreSQL 18异步I/O支持）
                -- EXECUTE format('VACUUM ANALYZE %I.%I', table_record.schemaname, table_record.tablename);

                recovery_action := '表膨胀恢复';
                recovery_status := '建议执行';
                recovery_details := format('表 %s.%s 死元组比例: %s%%，建议执行VACUUM',
                    table_record.schemaname, table_record.tablename, table_record.dead_ratio);
                RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
            END LOOP;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '表膨胀恢复';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;

    -- 恢复4: 统计信息过期自动更新
    BEGIN
        DECLARE
            table_record RECORD;
        BEGIN
            FOR table_record IN
                SELECT schemaname, tablename, last_autoanalyze
                FROM pg_stat_user_tables
                WHERE last_autoanalyze IS NULL
                   OR last_autoanalyze < NOW() - INTERVAL '7 days'
                ORDER BY last_autoanalyze NULLS FIRST
                LIMIT 5
            LOOP
                -- 自动执行ANALYZE
                -- EXECUTE format('ANALYZE %I.%I', table_record.schemaname, table_record.tablename);

                recovery_action := '统计信息更新';
                recovery_status := '建议执行';
                recovery_details := format('表 %s.%s 统计信息过期，最后分析: %s',
                    table_record.schemaname,
                    table_record.tablename,
                    COALESCE(table_record.last_autoanalyze::text, '从未'));
                RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
            END LOOP;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            recovery_action := '统计信息更新';
            recovery_status := '错误';
            recovery_details := SQLERRM;
            RETURN QUERY SELECT recovery_action, recovery_status, recovery_details, recovery_time;
    END;
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT * FROM pg18_auto_recovery();
```

---

## 故障恢复类型

### 1. 死锁恢复

**检测条件**：

- 死锁次数 > 10
- 阻塞查询时间 > 5分钟

**恢复操作**：

- 检测阻塞进程
- 提供终止建议（需人工确认）

### 2. 连接清理

**检测条件**：

- 连接数 > max_connections * 0.9
- 空闲事务数 > 10

**恢复操作**：

- 识别空闲事务
- 提供清理建议

### 3. 表膨胀恢复

**检测条件**：

- 死元组数 > 10000
- 死元组比例 > 20%

**恢复操作**：

- 识别需要VACUUM的表
- 提供VACUUM建议（可自动执行）

### 4. 统计信息更新

**检测条件**：

- 统计信息过期（>7天）
- 或从未分析

**恢复操作**：

- 识别需要ANALYZE的表
- 提供ANALYZE建议（可自动执行）

---

## 自动恢复执行

### 启用自动执行（谨慎使用）

```sql
-- 修改函数以启用自动执行（需要谨慎）
-- 取消注释以下行以启用自动执行：

-- 死锁恢复：PERFORM pg_terminate_backend(blocked_pid);
-- 表膨胀恢复：EXECUTE format('VACUUM ANALYZE %I.%I', ...);
-- 统计信息更新：EXECUTE format('ANALYZE %I.%I', ...);
```

### 定时执行故障恢复检查

```sql
-- 每15分钟执行故障恢复检查
SELECT cron.schedule(
    'auto-recovery-check',
    '*/15 * * * *',
    $$SELECT * FROM pg18_auto_recovery()$$
);
```

---

## 恢复状态说明

### 恢复状态类型

- **已检测**：已检测到问题，需要人工确认
- **建议执行**：建议执行恢复操作
- **错误**：恢复检查过程中发生错误

### 恢复操作建议

1. **死锁恢复**：通常需要人工确认，谨慎终止进程
2. **连接清理**：可以自动清理空闲事务
3. **表膨胀恢复**：可以自动执行VACUUM
4. **统计信息更新**：可以自动执行ANALYZE

---

## PostgreSQL 18优势

1. **异步I/O支持**：VACUUM操作更高效
2. **更详细的统计**：更准确的故障检测
3. **并行VACUUM**：支持并行VACUUM操作

---

## 注意事项

1. **谨慎使用**：自动恢复操作需要谨慎使用
2. **人工确认**：重要操作建议人工确认
3. **监控**：持续监控恢复操作效果
4. **测试**：在生产环境前充分测试

---

## 相关资源

- [VACUUM文档](https://www.postgresql.org/docs/18/sql-vacuum.html)
- [ANALYZE文档](https://www.postgresql.org/docs/18/sql-analyze.html)
- [故障排查文档](https://www.postgresql.org/docs/18/runtime-config-logging.html)

---

**上一节**: [应用场景案例](./04-应用场景案例.md)
**返回**: [综合方案目录](./README.md)
