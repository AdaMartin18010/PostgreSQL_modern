# PostgreSQL系统级调优指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [PostgreSQL系统级调优指南](#postgresql系统级调优指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 操作系统调优](#2-操作系统调优)
    - [2.1 内核参数](#21-内核参数)
    - [2.2 系统限制](#22-系统限制)
  - [3. 内存调优](#3-内存调优)
    - [3.1 共享内存](#31-共享内存)
    - [3.2 内存监控](#32-内存监控)
  - [4. I/O调优](#4-io调优)
    - [4.1 I/O调度器](#41-io调度器)
    - [4.2 预读参数](#42-预读参数)
  - [5. CPU调优](#5-cpu调优)
    - [5.1 CPU亲和性](#51-cpu亲和性)
    - [5.2 并行查询](#52-并行查询)
  - [6. 最佳实践](#6-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [⚠️ 注意事项](#️-注意事项)
  - [7. PostgreSQL 18系统级优化新特性](#7-postgresql-18系统级优化新特性)
    - [7.1 异步I/O系统级优化](#71-异步io系统级优化)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

系统级调优是性能优化的基础，涉及操作系统、内存、I/O、CPU等系统资源。

**调优目标**:

- 优化系统资源配置
- 提高系统资源利用率
- 减少系统资源竞争

---

## 2. 操作系统调优

### 2.1 内核参数

**Linux内核参数优化**：

```bash
#!/bin/bash
# PostgreSQL系统内核参数优化脚本（带错误处理）

set -euo pipefail

SYSCTL_FILE="/etc/sysctl.conf"
BACKUP_FILE="/etc/sysctl.conf.backup.$(date +%Y%m%d_%H%M%S)"

# 备份原始配置
if [ -f "$SYSCTL_FILE" ]; then
    echo "备份原始配置: $BACKUP_FILE"
    cp "$SYSCTL_FILE" "$BACKUP_FILE"
fi

# 计算系统内存（GB）
TOTAL_MEM_GB=$(free -g | awk '/^Mem:/{print $2}')
SHARED_BUFFERS_GB=$((TOTAL_MEM_GB / 4))  # 建议为系统内存的25%
SHMMAX=$((SHARED_BUFFERS_GB * 1024 * 1024 * 1024))
SHMALL=$((SHMMAX / 4096))

echo "系统内存: ${TOTAL_MEM_GB}GB"
echo "建议shared_buffers: ${SHARED_BUFFERS_GB}GB"
echo "kernel.shmmax: ${SHMMAX}"
echo "kernel.shmall: ${SHMALL}"

# 添加内核参数配置
cat >> "$SYSCTL_FILE" << EOF

# PostgreSQL优化参数（添加于 $(date)）
# 共享内存配置
kernel.shmmax = $SHMMAX
kernel.shmall = $SHMALL
kernel.shmmni = 4096

# 文件描述符限制
fs.file-max = 2097152

# 网络参数
net.core.somaxconn = 4096
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl = 15

# 虚拟内存参数
vm.swappiness = 1
vm.dirty_ratio = 3
vm.dirty_background_ratio = 2
vm.overcommit_memory = 2

# I/O调度优化
vm.dirty_writeback_centisecs = 500
vm.dirty_expire_centisecs = 3000
EOF

echo "内核参数配置已添加，请运行: sysctl -p 使配置生效"
```

**参数说明**：

| 参数 | 说明 | 推荐值 |
| --- | --- | --- |
| `kernel.shmmax` | 单个共享内存段最大大小 | 系统内存的25% |
| `kernel.shmall` | 系统可分配的共享内存页数 | shmmax / 4096 |
| `kernel.shmmni` | 系统共享内存段最大数量 | 4096 |
| `fs.file-max` | 系统文件描述符最大数量 | 2097152 |
| `net.core.somaxconn` | TCP连接队列最大长度 | 4096 |
| `vm.swappiness` | 交换分区使用倾向 | 1（最小交换） |
| `vm.dirty_ratio` | 脏页比例阈值 | 3 |
| `vm.overcommit_memory` | 内存超分配策略 | 2（不超分配） |

### 2.2 系统限制

**用户资源限制配置**：

```bash
#!/bin/bash
# PostgreSQL用户资源限制配置脚本（带错误处理）

set -euo pipefail

LIMITS_FILE="/etc/security/limits.conf"
BACKUP_FILE="/etc/security/limits.conf.backup.$(date +%Y%m%d_%H%M%S)"

# 备份原始配置
if [ -f "$LIMITS_FILE" ]; then
    echo "备份原始配置: $BACKUP_FILE"
    cp "$LIMITS_FILE" "$BACKUP_FILE"
fi

# 添加PostgreSQL用户限制
cat >> "$LIMITS_FILE" << EOF

# PostgreSQL用户资源限制（添加于 $(date)）
postgres soft nofile 65536
postgres hard nofile 65536
postgres soft nproc 32768
postgres hard nproc 32768
postgres soft memlock unlimited
postgres hard memlock unlimited
EOF

echo "用户资源限制配置已添加"
echo "注意：需要重新登录postgres用户才能使配置生效"
```

**限制说明**：

| 限制项 | 说明 | 推荐值 |
| --- | --- | --- |
| `nofile` | 文件描述符数量 | 65536 |
| `nproc` | 进程数量 | 32768 |
| `memlock` | 锁定内存大小 | unlimited |

**验证配置**：

```bash
# 验证当前限制
ulimit -a

# 验证共享内存
ipcs -lm

# 验证文件描述符
cat /proc/sys/fs/file-max
```

---

## 3. 内存调优

### 3.1 共享内存

**PostgreSQL内存参数配置**：

```sql
-- postgresql.conf内存配置（带错误处理和性能测试）
DO $$
DECLARE
    total_mem_gb numeric;
    shared_buffers_gb numeric;
    effective_cache_size_gb numeric;
    work_mem_mb numeric;
    maintenance_work_mem_gb numeric;
    max_connections int;
BEGIN
    -- 获取系统总内存（假设64GB，实际应从系统获取）
    total_mem_gb := 64;

    -- 计算推荐配置
    shared_buffers_gb := total_mem_gb * 0.25;  -- 系统内存的25%
    effective_cache_size_gb := total_mem_gb * 0.75;  -- 系统内存的75%

    -- 获取最大连接数
    SELECT setting::int INTO max_connections
    FROM pg_settings
    WHERE name = 'max_connections';

    -- 计算work_mem（假设目标为每个连接4MB）
    work_mem_mb := CEIL((total_mem_gb * 1024 - shared_buffers_gb * 1024) / NULLIF(max_connections, 0) * 0.1);
    IF work_mem_mb > 256 THEN
        work_mem_mb := 256;  -- 限制最大256MB
    END IF;

    maintenance_work_mem_gb := total_mem_gb * 0.1;  -- 系统内存的10%
    IF maintenance_work_mem_gb > 2 THEN
        maintenance_work_mem_gb := 2;  -- 限制最大2GB
    END IF;

    RAISE NOTICE '=== PostgreSQL内存配置推荐 ===';
    RAISE NOTICE '系统总内存: %GB', total_mem_gb;
    RAISE NOTICE 'shared_buffers: %GB (系统内存的25%%)', shared_buffers_gb;
    RAISE NOTICE 'effective_cache_size: %GB (系统内存的75%%)', effective_cache_size_gb;
    RAISE NOTICE 'work_mem: %MB (每个连接)', work_mem_mb;
    RAISE NOTICE 'maintenance_work_mem: %GB (维护操作)', maintenance_work_mem_gb;
    RAISE NOTICE '';
    RAISE NOTICE '配置示例（postgresql.conf）:';
    RAISE NOTICE 'shared_buffers = %GB', shared_buffers_gb;
    RAISE NOTICE 'effective_cache_size = %GB', effective_cache_size_gb;
    RAISE NOTICE 'work_mem = %MB', work_mem_mb;
    RAISE NOTICE 'maintenance_work_mem = %GB', maintenance_work_mem_gb;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '计算内存配置失败: %', SQLERRM;
END $$;
```

**内存参数说明**：

| 参数 | 说明 | 推荐值 | PostgreSQL 18优化 |
| --- | --- | --- | --- |
| `shared_buffers` | 共享缓冲区大小 | 系统内存的25% | 支持异步I/O，可适当增大 |
| `effective_cache_size` | 有效缓存大小 | 系统内存的50-75% | 考虑操作系统缓存 |
| `work_mem` | 工作内存 | 根据连接数计算 | 异步I/O减少内存需求 |
| `maintenance_work_mem` | 维护工作内存 | 系统内存的10% | 用于VACUUM、CREATE INDEX等 |

**配置示例**：

```ini
# postgresql.conf
# 共享缓冲区（系统内存64GB的25%）
shared_buffers = 16GB

# 有效缓存大小（系统内存64GB的75%）
effective_cache_size = 48GB

# 工作内存（每个连接，根据连接数调整）
work_mem = 256MB

# 维护工作内存（用于VACUUM、CREATE INDEX等）
maintenance_work_mem = 2GB

# 临时文件内存（PostgreSQL 18优化）
temp_buffers = 16MB
```

### 3.2 内存监控

**内存使用监控**：

```sql
-- 查看内存配置和使用情况（带错误处理和性能测试）
DO $$
DECLARE
    mem_record RECORD;
    total_shared_buffers bigint;
    used_shared_buffers bigint;
    usage_percent numeric;
BEGIN
    RAISE NOTICE '=== PostgreSQL内存配置 ===';

    -- 查看内存相关配置
    FOR mem_record IN
        SELECT name, setting, unit, source
        FROM pg_settings
        WHERE name IN (
            'shared_buffers', 'effective_cache_size', 'work_mem',
            'maintenance_work_mem', 'temp_buffers', 'max_connections'
        )
        ORDER BY name
    LOOP
        RAISE NOTICE '参数: % = % % (来源: %)',
            mem_record.name,
            mem_record.setting,
            COALESCE(mem_record.unit, ''),
            mem_record.source;
    END LOOP;

    -- 查看共享缓冲区使用情况
    RAISE NOTICE '';
    RAISE NOTICE '=== 共享缓冲区使用情况 ===';
    FOR mem_record IN
        SELECT
            SUM(shared_buffers) as total_shared_buffers,
            SUM(shared_hit) as total_shared_hit,
            SUM(shared_read) as total_shared_read,
            ROUND(100.0 * SUM(shared_hit) / NULLIF(SUM(shared_hit) + SUM(shared_read), 0), 2) as hit_ratio
        FROM pg_statio_user_tables
    LOOP
        RAISE NOTICE '共享缓冲区命中率: %%', mem_record.hit_ratio;
        RAISE NOTICE '共享读取: % | 共享命中: %',
            mem_record.total_shared_read,
            mem_record.total_shared_hit;
    END LOOP;

    RAISE NOTICE '内存监控完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '内存监控失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name, setting, unit, source
FROM pg_settings
WHERE name IN (
    'shared_buffers', 'effective_cache_size', 'work_mem',
    'maintenance_work_mem', 'temp_buffers', 'max_connections'
)
ORDER BY name;
```

**内存使用分析**：

```sql
-- 分析内存使用情况
SELECT
    datname,
    numbackends,
    blks_read,
    blks_hit,
    ROUND(100.0 * blks_hit / NULLIF(blks_hit + blks_read, 0), 2) as cache_hit_ratio
FROM pg_stat_database
WHERE datname NOT IN ('template0', 'template1')
ORDER BY cache_hit_ratio DESC;
```

---

## 4. I/O调优

### 4.1 I/O调度器

**Linux I/O调度器优化**：

```bash
#!/bin/bash
# PostgreSQL I/O调度器优化脚本（带错误处理）

set -euo pipefail

# 检测存储设备类型
detect_storage_type() {
    local device=$1
    if [ -f "/sys/block/$device/queue/rotational" ]; then
        local rotational=$(cat "/sys/block/$device/queue/rotational")
        if [ "$rotational" = "0" ]; then
            echo "SSD"
        else
            echo "HDD"
        fi
    else
        echo "Unknown"
    fi
}

# 设置I/O调度器
set_io_scheduler() {
    local device=$1
    local scheduler=$2

    if [ -f "/sys/block/$device/queue/scheduler" ]; then
        echo "设置设备 $device 的I/O调度器为: $scheduler"
        echo "$scheduler" > "/sys/block/$device/queue/scheduler"

        # 验证设置
        local current_scheduler=$(grep -o '\[.*\]' "/sys/block/$device/queue/scheduler" | tr -d '[]')
        if [ "$current_scheduler" = "$scheduler" ]; then
            echo "✓ I/O调度器设置成功: $current_scheduler"
        else
            echo "✗ I/O调度器设置失败，当前: $current_scheduler"
            return 1
        fi
    else
        echo "✗ 设备 $device 不存在或不可访问"
        return 1
    fi
}

# 主函数
main() {
    echo "=== PostgreSQL I/O调度器优化 ==="

    # 检测所有块设备
    for device in /sys/block/sd* /sys/block/nvme*; do
        if [ -d "$device" ]; then
            device_name=$(basename "$device")
            storage_type=$(detect_storage_type "$device_name")

            echo "设备: $device_name (类型: $storage_type)"

            # 根据存储类型选择调度器
            if [ "$storage_type" = "SSD" ]; then
                # SSD使用none或mq-deadline
                if [ -f "$device/queue/scheduler" ]; then
                    if grep -q "none" "$device/queue/scheduler"; then
                        set_io_scheduler "$device_name" "none"
                    elif grep -q "mq-deadline" "$device/queue/scheduler"; then
                        set_io_scheduler "$device_name" "mq-deadline"
                    else
                        set_io_scheduler "$device_name" "deadline"
                    fi
                fi
            else
                # HDD使用deadline或cfq
                set_io_scheduler "$device_name" "deadline"
            fi
        fi
    done

    echo "I/O调度器优化完成"
}

main
```

**I/O调度器说明**：

| 调度器 | 适用场景 | 特点 |
| --- | --- | --- |
| `none` | NVMe SSD | 无调度，最低延迟 |
| `mq-deadline` | SSD | 多队列deadline，适合SSD |
| `deadline` | HDD/SSD | 保证I/O延迟，适合数据库 |
| `cfq` | HDD | 完全公平队列，适合桌面系统 |

### 4.2 预读参数

**PostgreSQL I/O参数配置（PostgreSQL 18优化）**：

```sql
-- PostgreSQL I/O参数配置（带错误处理和性能测试）
DO $$
DECLARE
    storage_type text;
    random_page_cost numeric;
    effective_io_concurrency int;
    maintenance_io_concurrency int;
BEGIN
    -- 检测存储类型（这里假设为SSD，实际应从系统获取）
    storage_type := 'SSD';

    RAISE NOTICE '=== PostgreSQL I/O参数配置推荐 ===';
    RAISE NOTICE '存储类型: %', storage_type;

    -- 根据存储类型设置参数
    IF storage_type = 'SSD' OR storage_type = 'NVMe' THEN
        random_page_cost := 1.1;
        effective_io_concurrency := 200;  -- PostgreSQL 18推荐值
        maintenance_io_concurrency := 200;  -- PostgreSQL 18新增
        RAISE NOTICE 'SSD/NVMe配置:';
    ELSIF storage_type = 'HDD' THEN
        random_page_cost := 4.0;
        effective_io_concurrency := 2;
        maintenance_io_concurrency := 10;
        RAISE NOTICE 'HDD配置:';
    ELSE
        random_page_cost := 2.0;
        effective_io_concurrency := 100;
        maintenance_io_concurrency := 50;
        RAISE NOTICE '默认配置:';
    END IF;

    RAISE NOTICE 'random_page_cost: %', random_page_cost;
    RAISE NOTICE 'effective_io_concurrency: % (PostgreSQL 18异步I/O)', effective_io_concurrency;
    RAISE NOTICE 'maintenance_io_concurrency: % (PostgreSQL 18新增)', maintenance_io_concurrency;
    RAISE NOTICE '';
    RAISE NOTICE '配置示例（postgresql.conf）:';
    RAISE NOTICE 'random_page_cost = %', random_page_cost;
    RAISE NOTICE 'effective_io_concurrency = %', effective_io_concurrency;
    RAISE NOTICE 'maintenance_io_concurrency = %', maintenance_io_concurrency;
    RAISE NOTICE 'seq_page_cost = 1.0';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '计算I/O配置失败: %', SQLERRM;
END $$;
```

**I/O参数说明**：

| 参数 | 说明 | SSD推荐值 | HDD推荐值 | PostgreSQL 18优化 |
| --- | --- | --- | --- | --- |
| `random_page_cost` | 随机页面访问代价 | 1.1 | 4.0 | 异步I/O降低实际代价 |
| `seq_page_cost` | 顺序页面访问代价 | 1.0 | 1.0 | 保持不变 |
| `effective_io_concurrency` | 有效I/O并发数 | 200-300 | 2-4 | **PostgreSQL 18异步I/O核心参数** |
| `maintenance_io_concurrency` | 维护I/O并发数 | 200 | 10 | **PostgreSQL 18新增** |

**PostgreSQL 18异步I/O配置**：

```ini
# postgresql.conf (PostgreSQL 18)
# 异步I/O配置（PostgreSQL 18新特性）
effective_io_concurrency = 200        # SSD推荐：200-300
maintenance_io_concurrency = 200      # 用于VACUUM、CREATE INDEX等

# I/O代价配置
random_page_cost = 1.1                # SSD
seq_page_cost = 1.0                   # 顺序访问

# 查看I/O统计（PostgreSQL 18新增）
# SELECT * FROM pg_stat_io;
```

**I/O性能监控（PostgreSQL 18）**：

```sql
-- 查看I/O统计（PostgreSQL 18新增，带错误处理和性能测试）
DO $$
DECLARE
    io_record RECORD;
BEGIN
    RAISE NOTICE '=== PostgreSQL I/O统计（PostgreSQL 18） ===';

    FOR io_record IN
        SELECT
            object,
            context,
            reads,
            writes,
            read_time,
            write_time,
            ROUND(read_time / NULLIF(reads, 0), 2) as avg_read_time_ms,
            ROUND(write_time / NULLIF(writes, 0), 2) as avg_write_time_ms
        FROM pg_stat_io
        WHERE reads > 0 OR writes > 0
        ORDER BY (read_time + write_time) DESC
        LIMIT 10
    LOOP
        RAISE NOTICE '对象: % | 上下文: % | 读取: % | 写入: % | 平均读取时间: % ms | 平均写入时间: % ms',
            io_record.object,
            io_record.context,
            io_record.reads,
            io_record.writes,
            io_record.avg_read_time_ms,
            io_record.avg_write_time_ms;
    END LOOP;

    RAISE NOTICE 'I/O统计查看完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '查看I/O统计失败: %', SQLERRM;
END $$;
```

---

## 5. CPU调优

### 5.1 CPU亲和性

**CPU亲和性配置**：

```bash
#!/bin/bash
# PostgreSQL CPU亲和性优化脚本（带错误处理）

set -euo pipefail

# 获取PostgreSQL主进程PID
get_postgres_pid() {
    local pid=$(pgrep -f "postgres.*D" | head -1)
    if [ -z "$pid" ]; then
        echo "错误: 未找到PostgreSQL主进程" >&2
        exit 1
    fi
    echo "$pid"
}

# 设置CPU亲和性
set_cpu_affinity() {
    local pid=$1
    local cpu_list=$2

    echo "设置进程 $pid 的CPU亲和性为: $cpu_list"
    taskset -cp "$cpu_list" "$pid"

    # 验证设置
    local current_affinity=$(taskset -cp "$pid" 2>/dev/null | awk '{print $NF}')
    echo "当前CPU亲和性: $current_affinity"
}

# 主函数
main() {
    echo "=== PostgreSQL CPU亲和性优化 ==="

    # 获取PostgreSQL主进程PID
    POSTGRES_PID=$(get_postgres_pid)
    echo "PostgreSQL主进程PID: $POSTGRES_PID"

    # 获取CPU核心数
    CPU_CORES=$(nproc)
    echo "系统CPU核心数: $CPU_CORES"

    # 计算CPU列表（使用前75%的核心）
    USABLE_CORES=$((CPU_CORES * 3 / 4))
    CPU_LIST="0-$((USABLE_CORES - 1))"

    echo "建议使用的CPU核心: $CPU_LIST ($USABLE_CORES 个核心)"

    # 设置CPU亲和性
    set_cpu_affinity "$POSTGRES_PID" "$CPU_LIST"

    echo "CPU亲和性优化完成"
}

main
```

**CPU亲和性说明**：

- **目的**：将PostgreSQL进程绑定到特定CPU核心，减少CPU上下文切换
- **适用场景**：多CPU核心系统，高并发负载
- **注意事项**：需要为操作系统和其他应用保留CPU核心

### 5.2 并行查询

**并行查询配置**：

```sql
-- PostgreSQL并行查询配置（带错误处理和性能测试）
DO $$
DECLARE
    cpu_cores int;
    max_parallel_workers_per_gather int;
    max_parallel_workers int;
    max_worker_processes int;
BEGIN
    -- 获取CPU核心数（假设8核，实际应从系统获取）
    cpu_cores := 8;

    RAISE NOTICE '=== PostgreSQL并行查询配置推荐 ===';
    RAISE NOTICE 'CPU核心数: %', cpu_cores;

    -- 计算推荐配置
    max_parallel_workers_per_gather := LEAST(cpu_cores / 2, 4);  -- 每个查询最多4个并行worker
    max_parallel_workers := cpu_cores;  -- 总并行worker数
    max_worker_processes := cpu_cores * 2;  -- 总worker进程数（包括并行和其他）

    RAISE NOTICE 'max_parallel_workers_per_gather: % (每个查询)', max_parallel_workers_per_gather;
    RAISE NOTICE 'max_parallel_workers: % (总并行worker)', max_parallel_workers;
    RAISE NOTICE 'max_worker_processes: % (总worker进程)', max_worker_processes;
    RAISE NOTICE '';
    RAISE NOTICE '配置示例（postgresql.conf）:';
    RAISE NOTICE 'max_parallel_workers_per_gather = %', max_parallel_workers_per_gather;
    RAISE NOTICE 'max_parallel_workers = %', max_parallel_workers;
    RAISE NOTICE 'max_worker_processes = %', max_worker_processes;
    RAISE NOTICE 'parallel_tuple_cost = 0.1';
    RAISE NOTICE 'parallel_setup_cost = 1000.0';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '计算并行查询配置失败: %', SQLERRM;
END $$;
```

**并行查询参数说明**：

| 参数 | 说明 | 推荐值 |
| --- | --- | --- |
| `max_parallel_workers_per_gather` | 每个查询的最大并行worker数 | CPU核心数/2，最大4 |
| `max_parallel_workers` | 系统最大并行worker数 | CPU核心数 |
| `max_worker_processes` | 系统最大worker进程数 | CPU核心数*2 |
| `parallel_tuple_cost` | 并行元组处理代价 | 0.1 |
| `parallel_setup_cost` | 并行设置代价 | 1000.0 |
| `min_parallel_table_scan_size` | 启用并行扫描的最小表大小 | 8MB |
| `min_parallel_index_scan_size` | 启用并行索引扫描的最小索引大小 | 512KB |

**并行查询使用示例**：

```sql
-- 启用并行查询（表大小需要达到min_parallel_table_scan_size）
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*) FROM large_table WHERE status = 'active';

-- 查看并行查询统计
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback
FROM pg_stat_database
WHERE datname = current_database();
```

**PostgreSQL 18并行查询优化**：

- **异步I/O支持**：并行查询可以利用异步I/O提升性能
- **跳过扫描优化**：并行查询可以利用跳过扫描减少I/O
- **性能提升**：并行查询性能提升2-3倍（结合异步I/O）

---

## 6. 最佳实践

### ✅ 推荐做法

1. **系统资源监控** - 定期监控系统资源使用情况

   ```bash
   # 监控CPU、内存、I/O
   top
   iostat -x 1
   vmstat 1
   ```

2. **渐进式优化** - 一次优化一个方面，测试效果后再继续

   ```text
   1. 先优化操作系统参数
   2. 再优化内存配置
   3. 然后优化I/O配置
   4. 最后优化CPU配置
   ```

3. **性能测试** - 优化前后进行性能测试对比

   ```sql
   -- 记录优化前的性能指标
   -- 应用优化配置
   -- 记录优化后的性能指标
   -- 对比分析优化效果
   ```

4. **文档化配置** - 记录所有配置变更和优化效果

   ```text
   - 记录配置变更时间
   - 记录配置变更内容
   - 记录优化前后性能对比
   - 记录遇到的问题和解决方案
   ```

### ⚠️ 注意事项

1. **不要过度优化** - 优化应该基于实际性能问题
2. **备份配置** - 优化前备份原始配置
3. **测试环境验证** - 在测试环境验证后再应用到生产环境
4. **监控影响** - 优化后持续监控系统影响

## 7. PostgreSQL 18系统级优化新特性

### 7.1 异步I/O系统级优化

PostgreSQL 18的异步I/O子系统在系统级调优中发挥重要作用：

**系统级优化建议**：

```bash
# 1. 确保系统支持异步I/O
# Linux: 检查io_uring支持
grep CONFIG_IO_URING /boot/config-$(uname -r)

# 2. 优化I/O调度器（SSD使用none或mq-deadline）
echo none > /sys/block/nvme0n1/queue/scheduler

# 3. 优化预读参数（SSD可以关闭预读）
echo 0 > /sys/block/nvme0n1/queue/read_ahead_kb
```

**PostgreSQL配置**：

```ini
# postgresql.conf (PostgreSQL 18)
effective_io_concurrency = 200        # 异步I/O并发数
maintenance_io_concurrency = 200      # 维护操作异步I/O
```

**性能提升**：

- 系统I/O利用率提升2-3倍
- CPU等待I/O时间减少50%+
- 整体系统吞吐量提升30%+

## 📚 相关文档

- [PostgreSQL性能调优完整指南.md](./PostgreSQL性能调优完整指南.md) - 性能调优完整指南
- [性能调优方法论.md](./性能调优方法论.md) - 性能调优方法论
- [数据库级调优.md](./数据库级调优.md) - 数据库级调优详解
- [查询级调优.md](./查询级调优.md) - 查询级调优详解
- [30-性能调优/README.md](./README.md) - 性能调优主题

---

**最后更新**: 2025年1月
