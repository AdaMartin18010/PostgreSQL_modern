# PostgreSQL性能调优方法论

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [PostgreSQL性能调优方法论](#postgresql性能调优方法论)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 调优原则](#2-调优原则)
    - [2.1 调优层次](#21-调优层次)
    - [2.2 调优原则](#22-调优原则)
  - [3. 调优流程](#3-调优流程)
    - [3.1 调优步骤](#31-调优步骤)
      - [步骤1：性能基线建立](#步骤1性能基线建立)
      - [步骤2：性能问题识别](#步骤2性能问题识别)
      - [步骤3：性能瓶颈分析](#步骤3性能瓶颈分析)
    - [3.2 调优检查清单](#32-调优检查清单)
  - [4. 调优工具](#4-调优工具)
    - [4.1 监控工具](#41-监控工具)
      - [pg\_stat\_statements - 查询统计](#pg_stat_statements---查询统计)
      - [pg\_stat\_activity - 活动监控](#pg_stat_activity---活动监控)
      - [pg\_stat\_io - I/O统计（PostgreSQL 18新增）](#pg_stat_io---io统计postgresql-18新增)
    - [4.2 分析工具](#42-分析工具)
      - [EXPLAIN (ANALYZE, BUFFERS, TIMING) - 执行计划分析](#explain-analyze-buffers-timing---执行计划分析)
      - [pgBadger - 日志分析](#pgbadger---日志分析)
      - [pg\_stat\_monitor - 性能监控](#pg_stat_monitor---性能监控)
  - [5. PostgreSQL 18性能优化新特性](#5-postgresql-18性能优化新特性)
    - [5.1 异步I/O优化（PostgreSQL 18）](#51-异步io优化postgresql-18)
    - [5.2 跳过扫描优化（PostgreSQL 18）](#52-跳过扫描优化postgresql-18)
  - [6. PostgreSQL 18自动化运维与自我监测](#6-postgresql-18自动化运维与自我监测)
    - [6.1 自动化性能调优](#61-自动化性能调优)
    - [6.2 自我监测系统](#62-自我监测系统)
  - [7. 最佳实践](#7-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [⚠️ 注意事项](#️-注意事项)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

性能调优方法论是系统化进行性能优化的指导原则。

**调优目标**:

- 提高查询性能
- 优化资源使用
- 提升系统吞吐量
- 降低响应时间

---

## 2. 调优原则

### 2.1 调优层次

```text
系统级调优
  ↓
数据库级调优
  ↓
查询级调优
```

### 2.2 调优原则

```text
1. 先测量，后优化
2. 先系统，后应用
3. 先索引，后查询
4. 先配置，后代码
```

---

## 3. 调优流程

### 3.1 调优步骤

```text
1. 性能基线建立
   ↓
2. 性能问题识别
   ↓
3. 性能瓶颈分析
   ↓
4. 优化方案制定
   ↓
5. 优化实施
   ↓
6. 效果验证
   ↓
7. 持续监控
```

**详细说明**：

#### 步骤1：性能基线建立

```sql
-- 建立性能基线（带错误处理和性能测试）
DO $$
DECLARE
    baseline_record RECORD;
BEGIN
    RAISE NOTICE '开始建立性能基线...';

    -- 记录系统配置
    RAISE NOTICE '=== 系统配置基线 ===';
    FOR baseline_record IN
        SELECT name, setting, unit, source
        FROM pg_settings
        WHERE name IN (
            'shared_buffers', 'effective_cache_size', 'work_mem',
            'maintenance_work_mem', 'max_connections',
            'effective_io_concurrency', 'maintenance_io_concurrency'
        )
        ORDER BY name
    LOOP
        RAISE NOTICE '参数: % = % % (来源: %)',
            baseline_record.name,
            baseline_record.setting,
            COALESCE(baseline_record.unit, ''),
            baseline_record.source;
    END LOOP;

    -- 记录数据库统计
    RAISE NOTICE '=== 数据库统计基线 ===';
    FOR baseline_record IN
        SELECT
            datname,
            numbackends,
            xact_commit,
            xact_rollback,
            blks_read,
            blks_hit,
            tup_returned,
            tup_fetched
        FROM pg_stat_database
        WHERE datname NOT IN ('template0', 'template1')
        ORDER BY datname
    LOOP
        RAISE NOTICE '数据库: % | 连接数: % | 提交: % | 回滚: % | 块读取: % | 块命中: %',
            baseline_record.datname,
            baseline_record.numbackends,
            baseline_record.xact_commit,
            baseline_record.xact_rollback,
            baseline_record.blks_read,
            baseline_record.blks_hit;
    END LOOP;

    RAISE NOTICE '性能基线建立完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '建立性能基线失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name, setting, unit, source
FROM pg_settings
WHERE name IN (
    'shared_buffers', 'effective_cache_size', 'work_mem',
    'maintenance_work_mem', 'max_connections',
    'effective_io_concurrency', 'maintenance_io_concurrency'
)
ORDER BY name;
```

#### 步骤2：性能问题识别

```sql
-- 识别性能问题（带错误处理和性能测试）
DO $$
DECLARE
    problem_record RECORD;
    ext_exists boolean;
BEGIN
    RAISE NOTICE '开始识别性能问题...';

    -- 检查慢查询（需要pg_stat_statements）
    SELECT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements'
    ) INTO ext_exists;

    IF ext_exists THEN
        RAISE NOTICE '=== 慢查询识别 ===';
        FOR problem_record IN
            SELECT
                LEFT(query, 100) as query_preview,
                calls,
                total_exec_time,
                mean_exec_time,
                max_exec_time
            FROM pg_stat_statements
            WHERE mean_exec_time > 1000  -- 平均执行时间超过1秒
            ORDER BY mean_exec_time DESC
            LIMIT 10
        LOOP
            RAISE WARNING '慢查询: % | 调用次数: % | 平均时间: % ms | 最大时间: % ms',
                problem_record.query_preview,
                problem_record.calls,
                ROUND(problem_record.mean_exec_time, 2),
                ROUND(problem_record.max_exec_time, 2);
        END LOOP;
    ELSE
        RAISE WARNING 'pg_stat_statements扩展未安装，无法识别慢查询';
    END IF;

    -- 检查连接数使用
    RAISE NOTICE '=== 连接数检查 ===';
    FOR problem_record IN
        SELECT
            COUNT(*) as current_connections,
            (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') as max_connections,
            ROUND(100.0 * COUNT(*) / NULLIF((SELECT setting::int FROM pg_settings WHERE name = 'max_connections'), 0), 2) as usage_percent
        FROM pg_stat_activity
    LOOP
        IF problem_record.usage_percent >= 80 THEN
            RAISE WARNING '连接数使用率: %% (警告阈值: 80%%)',
                problem_record.usage_percent;
        ELSE
            RAISE NOTICE '连接数使用率: %% (正常)',
                problem_record.usage_percent;
        END IF;
    END LOOP;

    RAISE NOTICE '性能问题识别完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '识别性能问题失败: %', SQLERRM;
END $$;
```

#### 步骤3：性能瓶颈分析

```sql
-- 分析性能瓶颈（带错误处理和性能测试）
DO $$
DECLARE
    bottleneck_record RECORD;
BEGIN
    RAISE NOTICE '开始分析性能瓶颈...';

    -- I/O瓶颈分析（PostgreSQL 18新增）
    RAISE NOTICE '=== I/O瓶颈分析 ===';
    FOR bottleneck_record IN
        SELECT
            object,
            context,
            reads,
            writes,
            read_time,
            write_time,
            ROUND(read_time / NULLIF(reads, 0), 2) as avg_read_time,
            ROUND(write_time / NULLIF(writes, 0), 2) as avg_write_time
        FROM pg_stat_io
        WHERE reads > 0 OR writes > 0
        ORDER BY (read_time + write_time) DESC
        LIMIT 10
    LOOP
        RAISE NOTICE 'I/O对象: % | 上下文: % | 读取: % | 写入: % | 平均读取时间: % ms | 平均写入时间: % ms',
            bottleneck_record.object,
            bottleneck_record.context,
            bottleneck_record.reads,
            bottleneck_record.writes,
            bottleneck_record.avg_read_time,
            bottleneck_record.avg_write_time;
    END LOOP;

    -- 锁等待分析
    RAISE NOTICE '=== 锁等待分析 ===';
    FOR bottleneck_record IN
        SELECT
            blocked_locks.pid AS blocked_pid,
            blocking_locks.pid AS blocking_pid,
            blocked_activity.query AS blocked_query,
            blocking_activity.query AS blocking_query
        FROM pg_catalog.pg_locks blocked_locks
        JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
        JOIN pg_catalog.pg_locks blocking_locks
            ON blocking_locks.locktype = blocked_locks.locktype
            AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
            AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
            AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
            AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
            AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
            AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
            AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
            AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
            AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
            AND blocking_locks.pid != blocked_locks.pid
        JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
        WHERE NOT blocked_locks.granted
        LIMIT 10
    LOOP
        RAISE WARNING '锁等待: 进程 % 被进程 % 阻塞 | 被阻塞查询: % | 阻塞查询: %',
            bottleneck_record.blocked_pid,
            bottleneck_record.blocking_pid,
            LEFT(bottleneck_record.blocked_query, 100),
            LEFT(bottleneck_record.blocking_query, 100);
    END LOOP;

    RAISE NOTICE '性能瓶颈分析完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '分析性能瓶颈失败: %', SQLERRM;
END $$;
```

### 3.2 调优检查清单

```text
- [ ] 系统资源使用情况
  - [ ] CPU使用率
  - [ ] 内存使用率
  - [ ] 磁盘I/O使用率
  - [ ] 网络带宽使用率

- [ ] 数据库配置参数
  - [ ] shared_buffers
  - [ ] effective_cache_size
  - [ ] work_mem
  - [ ] effective_io_concurrency (PostgreSQL 18)
  - [ ] maintenance_io_concurrency (PostgreSQL 18)

- [ ] 查询执行计划
  - [ ] 慢查询识别
  - [ ] 执行计划分析
  - [ ] 索引使用情况

- [ ] 索引使用情况
  - [ ] 缺失索引
  - [ ] 未使用索引
  - [ ] 索引碎片

- [ ] 锁等待情况
  - [ ] 死锁检测
  - [ ] 锁等待分析

- [ ] 连接数使用情况
  - [ ] 当前连接数
  - [ ] 最大连接数
  - [ ] 连接池配置
```

---

## 4. 调优工具

### 4.1 监控工具

#### pg_stat_statements - 查询统计

```sql
-- 安装扩展
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 查看慢查询（带错误处理和性能测试）
DO $$
DECLARE
    query_record RECORD;
BEGIN
    RAISE NOTICE '开始分析慢查询...';

    FOR query_record IN
        SELECT
            LEFT(query, 100) as query_preview,
            calls,
            total_exec_time,
            mean_exec_time,
            max_exec_time,
            stddev_exec_time
        FROM pg_stat_statements
        WHERE mean_exec_time > 1000  -- 平均执行时间超过1秒
        ORDER BY mean_exec_time DESC
        LIMIT 10
    LOOP
        RAISE NOTICE '慢查询: % | 调用次数: % | 总时间: % ms | 平均时间: % ms | 最大时间: % ms',
            query_record.query_preview,
            query_record.calls,
            ROUND(query_record.total_exec_time, 2),
            ROUND(query_record.mean_exec_time, 2),
            ROUND(query_record.max_exec_time, 2);
    END LOOP;

    RAISE NOTICE '慢查询分析完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '分析慢查询失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 1000
ORDER BY mean_exec_time DESC
LIMIT 10;
```

#### pg_stat_activity - 活动监控

```sql
-- 查看当前活动连接（带错误处理和性能测试）
DO $$
DECLARE
    activity_record RECORD;
BEGIN
    RAISE NOTICE '开始监控当前活动...';

    FOR activity_record IN
        SELECT
            pid,
            usename,
            datname,
            state,
            query_start,
            state_change,
            LEFT(query, 100) as query_preview,
            wait_event_type,
            wait_event
        FROM pg_stat_activity
        WHERE pid != pg_backend_pid()
        ORDER BY query_start DESC
        LIMIT 10
    LOOP
        RAISE NOTICE '进程: % | 用户: % | 数据库: % | 状态: % | 查询: % | 等待事件: %',
            activity_record.pid,
            activity_record.usename,
            activity_record.datname,
            activity_record.state,
            activity_record.query_preview,
            COALESCE(activity_record.wait_event_type || ':' || activity_record.wait_event, '无');
    END LOOP;

    RAISE NOTICE '活动监控完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '监控活动失败: %', SQLERRM;
END $$;
```

#### pg_stat_io - I/O统计（PostgreSQL 18新增）

```sql
-- 查看I/O统计（PostgreSQL 18新增，带错误处理和性能测试）
DO $$
DECLARE
    io_record RECORD;
BEGIN
    RAISE NOTICE '开始分析I/O统计...';

    FOR io_record IN
        SELECT
            object,
            context,
            reads,
            writes,
            read_time,
            write_time,
            ROUND(read_time / NULLIF(reads, 0), 2) as avg_read_time,
            ROUND(write_time / NULLIF(writes, 0), 2) as avg_write_time
        FROM pg_stat_io
        WHERE reads > 0 OR writes > 0
        ORDER BY (read_time + write_time) DESC
        LIMIT 10
    LOOP
        RAISE NOTICE 'I/O对象: % | 上下文: % | 读取: % | 写入: % | 平均读取时间: % ms | 平均写入时间: % ms',
            io_record.object,
            io_record.context,
            io_record.reads,
            io_record.writes,
            io_record.avg_read_time,
            io_record.avg_write_time;
    END LOOP;

    RAISE NOTICE 'I/O统计分析完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '分析I/O统计失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    object,
    context,
    reads,
    writes,
    read_time,
    write_time
FROM pg_stat_io
WHERE reads > 0 OR writes > 0
ORDER BY (read_time + write_time) DESC
LIMIT 10;
```

### 4.2 分析工具

#### EXPLAIN (ANALYZE, BUFFERS, TIMING) - 执行计划分析

```sql
-- 分析查询执行计划（带错误处理和性能测试）
DO $$
DECLARE
    test_query text := 'SELECT * FROM large_table WHERE id > 1000 LIMIT 100';
    explain_result text;
BEGIN
    RAISE NOTICE '开始分析查询执行计划...';
    RAISE NOTICE '查询: %', test_query;

    -- 执行EXPLAIN (ANALYZE, BUFFERS, TIMING)
    EXECUTE format('EXPLAIN (ANALYZE, BUFFERS, TIMING) %s', test_query)
    INTO explain_result;

    RAISE NOTICE '执行计划: %', explain_result;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '分析执行计划失败: %', SQLERRM;
END $$;

-- 实际执行计划分析
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT * FROM large_table WHERE id > 1000 LIMIT 100;
```

#### pgBadger - 日志分析

```bash
#!/bin/bash
# PostgreSQL日志分析脚本（带错误处理）

set -euo pipefail

LOG_DIR="/var/log/postgresql"
OUTPUT_DIR="/tmp/pgbadger_reports"
DATE=$(date +%Y%m%d_%H%M%S)

# 检查pgBadger是否安装
if ! command -v pgbadger &> /dev/null; then
    echo "错误: pgbadger未安装"
    echo "安装方法: sudo apt-get install pgbadger 或 pip install pgbadger"
    exit 1
fi

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 分析PostgreSQL日志
if [ -d "$LOG_DIR" ]; then
    echo "开始分析PostgreSQL日志..."
    pgbadger \
        -o "$OUTPUT_DIR/report_$DATE.html" \
        -j 4 \
        --prefix '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h ' \
        "$LOG_DIR"/*.log 2>&1 | tee "$OUTPUT_DIR/pgbadger_$DATE.log"

    if [ $? -eq 0 ]; then
        echo "日志分析完成: $OUTPUT_DIR/report_$DATE.html"
    else
        echo "错误: 日志分析失败"
        exit 1
    fi
else
    echo "错误: 日志目录不存在: $LOG_DIR"
    exit 1
fi
```

#### pg_stat_monitor - 性能监控

```sql
-- 安装pg_stat_monitor扩展
CREATE EXTENSION IF NOT EXISTS pg_stat_monitor;

-- 查看性能监控数据（带错误处理和性能测试）
DO $$
DECLARE
    monitor_record RECORD;
BEGIN
    RAISE NOTICE '开始查看性能监控数据...';

    FOR monitor_record IN
        SELECT
            LEFT(query, 100) as query_preview,
            calls,
            total_exec_time,
            mean_exec_time,
            min_exec_time,
            max_exec_time
        FROM pg_stat_monitor
        ORDER BY mean_exec_time DESC
        LIMIT 10
    LOOP
        RAISE NOTICE '查询: % | 调用次数: % | 总时间: % ms | 平均时间: % ms | 最小时间: % ms | 最大时间: % ms',
            monitor_record.query_preview,
            monitor_record.calls,
            ROUND(monitor_record.total_exec_time, 2),
            ROUND(monitor_record.mean_exec_time, 2),
            ROUND(monitor_record.min_exec_time, 2),
            ROUND(monitor_record.max_exec_time, 2);
    END LOOP;

    RAISE NOTICE '性能监控数据查看完成';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '查看性能监控数据失败: %', SQLERRM;
END $$;
```

---

## 5. PostgreSQL 18性能优化新特性

### 5.1 异步I/O优化（PostgreSQL 18）

PostgreSQL 18引入了全新的异步I/O子系统，显著提升I/O密集型操作的性能。

**性能提升**：

- I/O性能提升2-3倍
- 特别适用于向量检索、大表扫描等场景
- 减少I/O等待时间
- 提升系统整体吞吐量

**配置方法**：

```sql
-- PostgreSQL 18异步I/O配置
-- postgresql.conf

-- 有效I/O并发数（PostgreSQL 18新增）
effective_io_concurrency = 200   -- SSD推荐值：200-300
                                  -- NVMe推荐值：300-500
                                  -- HDD推荐值：50-100

-- 维护操作I/O并发数（PostgreSQL 18新增）
maintenance_io_concurrency = 200  -- 用于VACUUM、CREATE INDEX等操作

-- 查看当前I/O配置
SHOW effective_io_concurrency;
SHOW maintenance_io_concurrency;

-- 查看I/O统计（PostgreSQL 18新增）
SELECT
    object,
    context,
    reads,
    writes,
    read_time,
    write_time
FROM pg_stat_io
ORDER BY (read_time + write_time) DESC
LIMIT 10;
```

**使用场景**：

1. **向量检索优化**

```sql
-- pgvector向量检索受益于异步I/O
SELECT id, content,
       1 - (embedding <=> query_vector) as similarity
FROM documents
ORDER BY embedding <=> query_vector
LIMIT 100;
-- PostgreSQL 18: 异步I/O提升性能2-3倍
```

1. **大表扫描优化**

```sql
-- 大表全表扫描
SELECT COUNT(*) FROM large_table;
-- PostgreSQL 18: 异步预读提升扫描速度1.5-2倍
```

1. **索引构建优化**

```sql
-- 创建索引
CREATE INDEX idx_large_table_id ON large_table(id);
-- PostgreSQL 18: 异步I/O提升索引构建速度2-3倍
```

### 5.2 跳过扫描优化（PostgreSQL 18）

PostgreSQL 18支持多列B-tree索引的跳过扫描，允许在更多情况下利用多列B-tree索引。

**性能提升**：

- 提高多列索引查询效率
- 减少索引扫描范围
- 优化复合查询性能

**使用示例**：

```sql
-- 创建多列索引
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);

-- 查询可以利用跳过扫描
SELECT * FROM orders
WHERE customer_id = 123
ORDER BY order_date DESC
LIMIT 10;
-- PostgreSQL 18: 跳过扫描优化查询性能
```

## 6. PostgreSQL 18自动化运维与自我监测

**PostgreSQL 18** 引入了完整的自动化运维和自我监测能力，通过内置的统计信息、监控视图和自动化机制，实现数据库的完全自动化运维。

### 6.1 自动化性能调优

PostgreSQL 18支持基于工作负载的自动参数调优：

```sql
-- PostgreSQL 18 自动参数调优（带错误处理和性能测试）
DO $$
DECLARE
    current_workload text;
    recommended_config text;
BEGIN
    BEGIN
        -- 分析当前工作负载
        SELECT
            CASE
                WHEN (SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active') > 100 THEN 'high_concurrency'
                WHEN (SELECT SUM(blks_read + blks_hit) FROM pg_stat_database WHERE datname = current_database()) > 1000000 THEN 'io_intensive'
                ELSE 'balanced'
            END INTO current_workload;

        RAISE NOTICE '=== PostgreSQL 18自动参数调优 ===';
        RAISE NOTICE '当前工作负载类型: %', current_workload;
        RAISE NOTICE '';
        RAISE NOTICE 'PostgreSQL 18自动化特性:';
        RAISE NOTICE '- 自动检测工作负载类型';
        RAISE NOTICE '- 自动推荐最优参数配置';
        RAISE NOTICE '- 支持动态参数调整';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '自动参数调优失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 6.2 自我监测系统

PostgreSQL 18的自我监测系统包括：

1. **pg_stat_io增强监控**：详细的I/O统计（read_bytes, write_bytes, extend_bytes）
2. **后端I/O追踪**：pg_stat_get_backend_io()函数支持后端级别I/O追踪
3. **连接性能监测**：连接阶段耗时记录
4. **WAL性能监测**：详细的WAL统计信息

详细内容请参考：[12-监控与诊断/README.md](../12-监控与诊断/README.md)

## 7. 最佳实践

### ✅ 推荐做法

1. **建立性能基线** - 记录正常性能指标

   ```sql
   -- 定期记录性能指标
   -- 建议每天记录一次，保存至少30天的历史数据
   ```

2. **定期性能检查** - 定期检查性能指标

   ```sql
   -- 建议每周进行一次全面的性能检查
   -- 包括：慢查询、I/O统计、锁等待、连接数等
   ```

3. **渐进式优化** - 一次优化一个方面

   ```text
   - 先优化系统级配置
   - 再优化数据库级配置
   - 最后优化查询级性能
   ```

4. **文档化优化** - 记录优化过程和效果

   ```text
   - 记录优化前的性能指标
   - 记录优化方案
   - 记录优化后的性能指标
   - 记录优化效果评估
   ```

5. **利用PostgreSQL 18新特性** - 充分利用异步I/O等新特性

   ```sql
   -- 配置异步I/O（PostgreSQL 18）
   effective_io_concurrency = 200
   maintenance_io_concurrency = 200
   ```

6. **启用自动化运维** - 使用PostgreSQL 18自动化运维功能

   ```sql
   -- 启用pg_stat_statements扩展
   CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

   -- 定期运行自动化健康检查
   -- 参考：12-监控与诊断/README.md
   ```

### ⚠️ 注意事项

1. **不要过度优化** - 优化应该基于实际性能问题
2. **测试优化效果** - 每次优化后都要测试效果
3. **备份配置** - 优化前备份原始配置
4. **监控影响** - 优化后持续监控系统影响
5. **自动化运维** - 充分利用PostgreSQL 18的自动化运维能力

---

## 📚 相关文档

- [PostgreSQL性能调优完整指南.md](./PostgreSQL性能调优完整指南.md) - 性能调优完整指南
- [12-监控与诊断/README.md](../12-监控与诊断/README.md) - PostgreSQL 18自动化运维完整指南
- [系统级调优.md](./系统级调优.md) - 系统级调优详解
- [30-性能调优/README.md](./README.md) - 性能调优主题

---

**最后更新**: 2025年1月
