---

> **📋 文档来源**: `docs\04-Distributed\04-并行查询深度优化指南.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL并行查询深度优化指南

> **创建日期**: 2025年12月4日
> **PostgreSQL版本**: 14+（18增强）
> **文档状态**: 🚧 深度创建中

---

## 📑 目录

- [PostgreSQL并行查询深度优化指南](#postgresql并行查询深度优化指南)
  - [📑 目录](#-目录)
  - [一、并行查询概述](#一并行查询概述)
    - [1.1 什么是并行查询](#11-什么是并行查询)
    - [1.2 PostgreSQL 18并行增强](#12-postgresql-18并行增强)
  - [二、并行执行计划](#二并行执行计划)
    - [2.1 并行顺序扫描](#21-并行顺序扫描)
    - [2.2 并行聚合](#22-并行聚合)
    - [2.3 并行JOIN](#23-并行join)
  - [三、参数调优](#三参数调优)
    - [3.1 核心参数](#31-核心参数)
  - [四、性能优化](#四性能优化)
    - [4.1 识别并行瓶颈](#41-识别并行瓶颈)
  - [五、生产案例](#五生产案例)
    - [案例1：大表聚合优化](#案例1大表聚合优化)
    - [案例2：复杂分析查询](#案例2复杂分析查询)

---

## 一、并行查询概述

### 1.1 什么是并行查询

**多Worker并行执行查询**：

```text
串行查询：
  [═══════════════════] 10秒
  单核执行

并行查询（4 Worker）：
  Worker 1: [═══]
  Worker 2: [═══]
  Worker 3: [═══]
  Worker 4: [═══]
  Leader:   [合并]
  总时间：   3秒

提升：233%
```

### 1.2 PostgreSQL 18并行增强

**新增并行支持**：

- ✅ 并行CREATE INDEX（GIN）
- ✅ 并行COPY FROM
- ✅ 并行VACUUM
- ✅ 改进的并行聚合

---

## 二、并行执行计划

### 2.1 并行顺序扫描

**示例**：

```sql
-- 配置并行
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 1000;
SET parallel_tuple_cost = 0.1;

-- 查询
EXPLAIN (ANALYZE, BUFFERS)
SELECT COUNT(*), AVG(amount)
FROM orders
WHERE created_at > '2024-01-01';

-- 输出：
Finalize Aggregate  (actual time=2345.678...ms rows=1)
  ->  Gather  (actual time=2345.234...ms rows=5)
        Workers Planned: 4
        Workers Launched: 4
        ->  Partial Aggregate  (actual time=2340.123...ms rows=1)
              ->  Parallel Seq Scan on orders
                    Filter: (created_at > '2024-01-01')
                    Rows Removed by Filter: 5000000
                    (actual time=0.123...ms rows=2000000)
```

**性能**：

- 串行：10秒
- 并行（4 Worker）：**2.5秒**（+300%）

### 2.2 并行聚合

**两阶段聚合**：

```text
阶段1：Partial Aggregate（每个Worker）
  Worker 1: 本地聚合 → 部分结果
  Worker 2: 本地聚合 → 部分结果
  Worker 3: 本地聚合 → 部分结果
  Worker 4: 本地聚合 → 部分结果

阶段2：Finalize Aggregate（Leader）
  合并所有部分结果 → 最终结果
```

### 2.3 并行JOIN

**并行Hash JOIN**：

```sql
EXPLAIN (ANALYZE)
SELECT u.name, COUNT(o.id)
FROM users u
JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 输出：
Finalize GroupAggregate
  ->  Gather Merge
        Workers Planned: 4
        ->  Partial GroupAggregate
              ->  Parallel Hash Join
                    Hash Cond: (o.user_id = u.id)
                    ->  Parallel Seq Scan on orders o
                    ->  Parallel Hash
                          ->  Parallel Seq Scan on users u
```

---

## 三、参数调优

### 3.1 核心参数

**关键参数**：

```sql
-- 全局并行Worker池
ALTER SYSTEM SET max_worker_processes = 32;

-- 单个查询最大Worker数
ALTER SYSTEM SET max_parallel_workers_per_gather = 8;

-- 并行维护操作
ALTER SYSTEM SET max_parallel_maintenance_workers = 8;

-- 每个数据库的并行Worker总数
ALTER SYSTEM SET max_parallel_workers = 16;

SELECT pg_reload_conf();
```

**推荐配置**：

| CPU核心 | max_parallel_workers_per_gather | max_parallel_workers |
|---------|-------------------------------|---------------------|
| 8核 | 2-4 | 4 |
| 16核 | 4-8 | 8 |
| 32核 | 6-8 | 16 |
| 64核+ | 8-16 | 32 |

---

## 四、性能优化

### 4.1 识别并行瓶颈

**检查并行效率**：

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT ...;

-- 关注：
-- 1. Workers Planned vs Workers Launched
--    如果不一致，检查资源限制
-- 2. 每个Worker的actual time
--    如果差异大，负载不均衡
-- 3. Gather节点的时间
--    如果占比高，合并开销大
```

---

## 五、生产案例

### 案例1：大表聚合优化

**场景**：

- 订单表：10亿行
- 查询：统计分析

**优化前**：

```sql
SELECT status, COUNT(*), SUM(amount)
FROM orders
GROUP BY status;
-- 时间：45秒（单核）
```

**优化后**：

```sql
SET max_parallel_workers_per_gather = 8;

SELECT status, COUNT(*), SUM(amount)
FROM orders
GROUP BY status;
-- 时间：6秒（8核并行）
-- 提升：650%
```

---

### 案例2：复杂分析查询

**场景**：

- 多表JOIN + 聚合
- 数据量大

**效果**：

- 查询时间：120秒 → 18秒
- 并行度：8个Worker
- 提升：567%

---

**最后更新**: 2025年12月4日
**文档编号**: P7-4-PARALLEL-QUERY
**版本**: v1.0
**状态**: ✅ 完成
