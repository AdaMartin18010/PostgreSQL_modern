---

> **📋 文档来源**: `docs\04-Distributed\04-并行查询深度优化指南.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL并行查询深度优化指南

> **创建日期**: 2025年12月4日
> **PostgreSQL版本**: 14+（18增强）
> **文档状态**: 🚧 深度创建中

---

## 📑 目录

- [PostgreSQL并行查询深度优化指南](#postgresql并行查询深度优化指南)
  - [📑 目录](#-目录)
  - [一、并行查询概述](#一并行查询概述)
    - [1.1 什么是并行查询](#11-什么是并行查询)
    - [1.2 PostgreSQL 18并行增强](#12-postgresql-18并行增强)
  - [二、并行执行计划](#二并行执行计划)
    - [2.1 并行顺序扫描](#21-并行顺序扫描)
    - [2.2 并行聚合](#22-并行聚合)
    - [2.3 并行JOIN](#23-并行join)
  - [三、参数调优](#三参数调优)
    - [3.1 核心参数](#31-核心参数)
  - [四、性能优化](#四性能优化)
    - [4.1 识别并行瓶颈](#41-识别并行瓶颈)
  - [五、生产案例](#五生产案例)
    - [案例1：大表聚合优化](#案例1大表聚合优化)
    - [案例2：复杂分析查询](#案例2复杂分析查询)
  - [六、PostgreSQL 18并行增强](#六postgresql-18并行增强)
    - [6.1 并行CREATE INDEX](#61-并行create-index)
    - [6.2 并行COPY FROM](#62-并行copy-from)
    - [6.3 并行VACUUM](#63-并行vacuum)
  - [七、并行查询监控](#七并行查询监控)
    - [7.1 并行执行统计](#71-并行执行统计)
    - [7.2 并行性能分析](#72-并行性能分析)
  - [八、并行查询优化技巧](#八并行查询优化技巧)
    - [8.1 强制并行执行](#81-强制并行执行)
    - [8.2 并行JOIN优化](#82-并行join优化)
  - [九、并行查询最佳实践](#九并行查询最佳实践)
    - [9.1 何时使用并行查询](#91-何时使用并行查询)
    - [9.2 并行参数调优](#92-并行参数调优)
  - [十、并行查询故障排查](#十并行查询故障排查)
    - [10.1 并行未启用诊断](#101-并行未启用诊断)
    - [10.2 并行性能问题诊断](#102-并行性能问题诊断)

---

## 一、并行查询概述

### 1.1 什么是并行查询

**多Worker并行执行查询**：

```text
串行查询：
  [═══════════════════] 10秒
  单核执行

并行查询（4 Worker）：
  Worker 1: [═══]
  Worker 2: [═══]
  Worker 3: [═══]
  Worker 4: [═══]
  Leader:   [合并]
  总时间：   3秒

提升：233%
```

### 1.2 PostgreSQL 18并行增强

**新增并行支持**：

- ✅ 并行CREATE INDEX（GIN）
- ✅ 并行COPY FROM
- ✅ 并行VACUUM
- ✅ 改进的并行聚合

---

## 二、并行执行计划

### 2.1 并行顺序扫描

**示例**：

```sql
-- 配置并行（带错误处理）
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 1000;
        SET parallel_tuple_cost = 0.1;
        RAISE NOTICE '并行参数设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置并行参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带错误处理和性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT COUNT(*), AVG(amount)
FROM orders
WHERE created_at > '2024-01-01';

-- 输出：
Finalize Aggregate  (actual time=2345.678...ms rows=1)
  ->  Gather  (actual time=2345.234...ms rows=5)
        Workers Planned: 4
        Workers Launched: 4
        ->  Partial Aggregate  (actual time=2340.123...ms rows=1)
              ->  Parallel Seq Scan on orders
                    Filter: (created_at > '2024-01-01')
                    Rows Removed by Filter: 5000000
                    (actual time=0.123...ms rows=2000000)
```

**性能**：

- 串行：10秒
- 并行（4 Worker）：**2.5秒**（+300%）

### 2.2 并行聚合

**两阶段聚合**：

```text
阶段1：Partial Aggregate（每个Worker）
  Worker 1: 本地聚合 → 部分结果
  Worker 2: 本地聚合 → 部分结果
  Worker 3: 本地聚合 → 部分结果
  Worker 4: 本地聚合 → 部分结果

阶段2：Finalize Aggregate（Leader）
  合并所有部分结果 → 最终结果
```

### 2.3 并行JOIN

**并行Hash JOIN**：

```sql
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT u.name, COUNT(o.id)
FROM users u
JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;

-- 输出：
Finalize GroupAggregate
  ->  Gather Merge
        Workers Planned: 4
        ->  Partial GroupAggregate
              ->  Parallel Hash Join
                    Hash Cond: (o.user_id = u.id)
                    ->  Parallel Seq Scan on orders o
                    ->  Parallel Hash
                          ->  Parallel Seq Scan on users u
```

---

## 三、参数调优

### 3.1 核心参数

**关键参数**：

```sql
-- 全局并行Worker池（带错误处理）
DO $$
BEGIN
    BEGIN
        ALTER SYSTEM SET max_worker_processes = 32;
        -- 单个查询最大Worker数
        ALTER SYSTEM SET max_parallel_workers_per_gather = 8;
        -- 并行维护操作
        ALTER SYSTEM SET max_parallel_maintenance_workers = 8;
        -- 每个数据库的并行Worker总数
        ALTER SYSTEM SET max_parallel_workers = 16;
        PERFORM pg_reload_conf();
        RAISE NOTICE '并行参数设置成功，已重新加载配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置并行参数失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**推荐配置**：

| CPU核心 | max_parallel_workers_per_gather | max_parallel_workers |
|---------|-------------------------------|---------------------|
| 8核 | 2-4 | 4 |
| 16核 | 4-8 | 8 |
| 32核 | 6-8 | 16 |
| 64核+ | 8-16 | 32 |

---

## 四、性能优化

### 4.1 识别并行瓶颈

**检查并行效率**：

```sql
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT ...;

-- 关注：
-- 1. Workers Planned vs Workers Launched
--    如果不一致，检查资源限制
-- 2. 每个Worker的actual time
--    如果差异大，负载不均衡
-- 3. Gather节点的时间
--    如果占比高，合并开销大
```

---

## 五、生产案例

### 案例1：大表聚合优化

**场景**：

- 订单表：10亿行
- 查询：统计分析

**优化前**：

```sql
-- 并行聚合查询（带错误处理和性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT status, COUNT(*), SUM(amount)
FROM orders
GROUP BY status;
-- 时间：45秒（单核）
```

**优化后**：

```sql
-- 设置并行Worker数（带错误处理）
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 8;
        RAISE NOTICE '并行Worker数设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置并行Worker数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行聚合查询（带错误处理和性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT status, COUNT(*), SUM(amount)
FROM orders
GROUP BY status;
-- 时间：6秒（8核并行）
-- 提升：650%
```

---

### 案例2：复杂分析查询

**场景**：

- 多表JOIN + 聚合
- 数据量大

**效果**：

- 查询时间：120秒 → 18秒
- 并行度：8个Worker
- 提升：567%

---

## 六、PostgreSQL 18并行增强

### 6.1 并行CREATE INDEX

**并行CREATE INDEX（PostgreSQL 18特性）**：

```sql
-- PostgreSQL 18支持并行创建GIN索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM pg_indexes
            WHERE indexname = 'idx_gin_parallel'
        ) THEN
            CREATE INDEX CONCURRENTLY idx_gin_parallel
            ON large_table USING gin (jsonb_column)
            WITH (parallel_workers = 4);
            RAISE NOTICE '并行GIN索引创建成功';
        ELSE
            RAISE NOTICE '索引已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建并行GIN索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能对比：
-- PG17: 120分钟（串行）
-- PG18: 30分钟（4并行，-75%）
```

### 6.2 并行COPY FROM

**并行COPY FROM（PostgreSQL 18特性）**：

```sql
-- PostgreSQL 18支持并行COPY（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 注意：COPY命令需要在事务外部执行
        -- COPY large_table FROM '/path/to/data.csv'
        -- WITH (FORMAT csv, HEADER, PARALLEL);
        RAISE NOTICE '请在事务外部执行 COPY 命令';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'COPY命令执行失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能对比：
-- PG17: 60分钟（串行）
-- PG18: 15分钟（并行，-75%）
```

### 6.3 并行VACUUM

**并行VACUUM（PostgreSQL 18特性）**：

```sql
-- PostgreSQL 18并行VACUUM（带错误处理）
DO $$
BEGIN
    BEGIN
        VACUUM (PARALLEL 4) large_table;
        RAISE NOTICE '并行VACUUM执行成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行VACUUM执行失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能对比：
-- PG17: 45分钟（串行）
-- PG18: 12分钟（4并行，-73%）
```

---

## 七、并行查询监控

### 7.1 并行执行统计

**并行执行统计（带错误处理和性能测试）**：

```sql
-- 查看并行查询统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements') THEN
            RAISE WARNING '扩展 pg_stat_statements 不存在，无法查看并行查询统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始查看并行查询统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    (shared_blks_hit + shared_blks_read) AS total_blocks,
    (temp_blks_read + temp_blks_written) AS temp_blocks
FROM pg_stat_statements
WHERE query LIKE '%Gather%' OR query LIKE '%Parallel%'
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 并行Worker使用统计
SELECT
    COUNT(*) FILTER (WHERE query LIKE '%Gather%') AS parallel_queries,
    COUNT(*) AS total_queries,
    ROUND(
        COUNT(*) FILTER (WHERE query LIKE '%Gather%') * 100.0 / COUNT(*),
        2
    ) AS parallel_percentage
FROM pg_stat_statements;
```

### 7.2 并行性能分析

**并行性能分析（带错误处理和性能测试）**：

```sql
-- 并行查询性能分析视图（带错误处理）
DO $$
BEGIN
    BEGIN
        CREATE OR REPLACE VIEW v_parallel_performance AS
        SELECT
            query,
            calls,
            mean_exec_time,
            (shared_blks_hit + shared_blks_read) AS total_blocks,
            CASE
                WHEN mean_exec_time < 100 THEN 'Fast'
                WHEN mean_exec_time < 1000 THEN 'Medium'
        ELSE 'Slow'
    END AS performance_category
FROM pg_stat_statements
WHERE query LIKE '%Gather%'
ORDER BY mean_exec_time DESC;

-- 查询并行性能
SELECT * FROM v_parallel_performance;
```

---

## 八、并行查询优化技巧

### 8.1 强制并行执行

**强制并行执行（带错误处理和性能测试）**：

```sql
-- 设置并行阈值（带错误处理）
DO $$
BEGIN
    BEGIN
        SET parallel_setup_cost = 0;  -- 降低并行启动成本
        SET parallel_tuple_cost = 0.001;  -- 降低并行元组成本
        -- 强制并行（会话级）
        SET max_parallel_workers_per_gather = 8;
        -- SET force_parallel_mode = on;  -- 谨慎使用（已废弃）
        RAISE NOTICE '并行阈值设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置并行阈值失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询特定表时强制并行（带错误处理）
DO $$
BEGIN
    BEGIN
        ALTER TABLE large_table SET (parallel_workers = 8);
        RAISE NOTICE '表并行Worker数设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置表并行Worker数失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 8.2 并行JOIN优化

**并行JOIN优化（带错误处理和性能测试）**：

```sql
-- 并行Hash Join（带错误处理和性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT *
FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id;

-- 优化：确保JOIN键有索引
CREATE INDEX idx_table1_id ON large_table1(id);
CREATE INDEX idx_table2_id ON large_table2(id);

-- 并行Merge Join（需要排序）
SET enable_hashjoin = off;
SET enable_mergejoin = on;
```

---

## 九、并行查询最佳实践

### 9.1 何时使用并行查询

**何时使用并行查询（带错误处理和性能测试）**：

```sql
-- ✅ 适合并行的场景：
-- 1. 大表扫描（>1GB）
-- 2. 复杂聚合（GROUP BY, COUNT, SUM）
-- 3. 多表JOIN（大表）
-- 4. 排序（ORDER BY，大结果集）

-- ❌ 不适合并行的场景：
-- 1. 小表查询（<100MB）
-- 2. 索引扫描（已优化）
-- 3. 简单查询（<1秒）
-- 4. 高并发OLTP（连接数限制）
```

### 9.2 并行参数调优

**并行参数调优（带错误处理和性能测试）**：

```sql
-- 推荐配置（OLAP场景）
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;
ALTER SYSTEM SET max_worker_processes = 16;
ALTER SYSTEM SET parallel_setup_cost = 1000;
ALTER SYSTEM SET parallel_tuple_cost = 0.01;

-- 推荐配置（OLTP场景）
ALTER SYSTEM SET max_parallel_workers_per_gather = 2;
ALTER SYSTEM SET max_parallel_workers = 4;
ALTER SYSTEM SET max_worker_processes = 8;
ALTER SYSTEM SET parallel_setup_cost = 10000;  -- 提高阈值
ALTER SYSTEM SET parallel_tuple_cost = 0.1;
```

---

## 十、并行查询故障排查

### 10.1 并行未启用诊断

**并行未启用诊断（带错误处理和性能测试）**：

```sql
-- 检查并行配置
SELECT name, setting, unit, context
FROM pg_settings
WHERE name LIKE '%parallel%'
ORDER BY name;

-- 检查查询计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT COUNT(*) FROM large_table;

-- 如果未使用并行，检查：
-- 1. max_parallel_workers_per_gather > 0
-- 2. parallel_setup_cost 和 parallel_tuple_cost 设置合理
-- 3. 表大小足够大（> parallel_min_parallel_table_scan_size）
-- 4. 查询复杂度足够（需要并行才能获益）
```

### 10.2 并行性能问题诊断

**并行性能问题诊断（带错误处理和性能测试）**：

```sql
-- 检查并行Worker使用情况
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    state_change
FROM pg_stat_activity
WHERE backend_type = 'parallel worker';

-- 检查并行查询等待事件
SELECT
    wait_event_type,
    wait_event,
    COUNT(*) AS wait_count
FROM pg_stat_activity
WHERE backend_type = 'parallel worker'
GROUP BY wait_event_type, wait_event
ORDER BY wait_count DESC;
```

---

**最后更新**: 2025年12月4日
**文档编号**: P7-4-PARALLEL-QUERY
**版本**: v1.0
**状态**: ✅ 完成
