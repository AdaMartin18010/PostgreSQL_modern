---
> **ğŸ“‹ æ–‡æ¡£æ¥æº**: æ–°å¢å®è·µæ·±åŒ–æ–‡æ¡£
> **ğŸ“… åˆ›å»ºæ—¥æœŸ**: 2025-01
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£èšç„¦PostgreSQLä¸åŒºå—é“¾çš„é›†æˆå®è·µ

---

# PostgreSQLåŒºå—é“¾é›†æˆå®Œæ•´æŒ‡å—

## å…ƒæ•°æ®

- **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
- **åˆ›å»ºæ—¥æœŸ**: 2025-01
- **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | Ethereum | Hyperledger | Web3.py | pg_notify
- **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
- **é¢„è®¡é˜…è¯»**: 120åˆ†é’Ÿ
- **å‰ç½®è¦æ±‚**: ç†Ÿæ‚‰PostgreSQLåŸºç¡€ã€åŒºå—é“¾åŸºç¡€ã€æ™ºèƒ½åˆçº¦åŸºç¡€

---

## ğŸ“‹ å®Œæ•´ç›®å½•

- [PostgreSQLåŒºå—é“¾é›†æˆå®Œæ•´æŒ‡å—](#postgresqlåŒºå—é“¾é›†æˆå®Œæ•´æŒ‡å—)
  - [å…ƒæ•°æ®](#å…ƒæ•°æ®)
  - [ğŸ“‹ å®Œæ•´ç›®å½•](#-å®Œæ•´ç›®å½•)
  - [1. åŒºå—é“¾é›†æˆæ¦‚è¿°](#1-åŒºå—é“¾é›†æˆæ¦‚è¿°)
    - [1.1 é›†æˆåœºæ™¯](#11-é›†æˆåœºæ™¯)
      - [å…¸å‹åº”ç”¨åœºæ™¯](#å…¸å‹åº”ç”¨åœºæ™¯)
    - [1.2 é›†æˆæ¶æ„](#12-é›†æˆæ¶æ„)
      - [æ¶æ„æ¨¡å¼](#æ¶æ„æ¨¡å¼)
    - [1.3 æŠ€æœ¯é€‰å‹](#13-æŠ€æœ¯é€‰å‹)
      - [åŒºå—é“¾å¹³å°é€‰æ‹©](#åŒºå—é“¾å¹³å°é€‰æ‹©)
  - [2. åŒºå—é“¾æ•°æ®å­˜å‚¨è®¾è®¡](#2-åŒºå—é“¾æ•°æ®å­˜å‚¨è®¾è®¡)
    - [2.1 åŒºå—æ•°æ®æ¨¡å‹](#21-åŒºå—æ•°æ®æ¨¡å‹)
      - [åŒºå—è¡¨è®¾è®¡](#åŒºå—è¡¨è®¾è®¡)
    - [2.2 äº¤æ˜“æ•°æ®æ¨¡å‹](#22-äº¤æ˜“æ•°æ®æ¨¡å‹)
      - [äº¤æ˜“è¡¨è®¾è®¡](#äº¤æ˜“è¡¨è®¾è®¡)
    - [2.3 çŠ¶æ€æ•°æ®æ¨¡å‹](#23-çŠ¶æ€æ•°æ®æ¨¡å‹)
      - [è´¦æˆ·çŠ¶æ€è¡¨](#è´¦æˆ·çŠ¶æ€è¡¨)
    - [2.4 ç´¢å¼•è®¾è®¡](#24-ç´¢å¼•è®¾è®¡)
      - [å¤åˆç´¢å¼•ä¼˜åŒ–](#å¤åˆç´¢å¼•ä¼˜åŒ–)
  - [3. æ™ºèƒ½åˆçº¦æ•°æ®åŒæ­¥](#3-æ™ºèƒ½åˆçº¦æ•°æ®åŒæ­¥)
    - [3.1 äº‹ä»¶ç›‘å¬æœºåˆ¶](#31-äº‹ä»¶ç›‘å¬æœºåˆ¶)
      - [Ethereumäº‹ä»¶ç›‘å¬](#ethereumäº‹ä»¶ç›‘å¬)
    - [3.2 æ‰¹é‡åŒæ­¥ç­–ç•¥](#32-æ‰¹é‡åŒæ­¥ç­–ç•¥)
      - [æ‰¹é‡åŒæ­¥ä¼˜åŒ–](#æ‰¹é‡åŒæ­¥ä¼˜åŒ–)
    - [3.3 å®æ—¶åŒæ­¥å®ç°](#33-å®æ—¶åŒæ­¥å®ç°)
      - [WebSocketå®æ—¶åŒæ­¥](#websocketå®æ—¶åŒæ­¥)
    - [3.4 åŒæ­¥é”™è¯¯å¤„ç†](#34-åŒæ­¥é”™è¯¯å¤„ç†)
      - [é”™è¯¯å¤„ç†ä¸é‡è¯•](#é”™è¯¯å¤„ç†ä¸é‡è¯•)
  - [4. åŒºå—é“¾æŸ¥è¯¢ä¼˜åŒ–](#4-åŒºå—é“¾æŸ¥è¯¢ä¼˜åŒ–)
    - [4.1 æŸ¥è¯¢æ¨¡å¼åˆ†æ](#41-æŸ¥è¯¢æ¨¡å¼åˆ†æ)
      - [å¸¸è§æŸ¥è¯¢æ¨¡å¼](#å¸¸è§æŸ¥è¯¢æ¨¡å¼)
    - [4.2 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥](#42-ç´¢å¼•ä¼˜åŒ–ç­–ç•¥)
      - [åˆ†åŒºè¡¨ + ç´¢å¼•](#åˆ†åŒºè¡¨--ç´¢å¼•)
    - [4.3 ç‰©åŒ–è§†å›¾ä¼˜åŒ–](#43-ç‰©åŒ–è§†å›¾ä¼˜åŒ–)
      - [ç‰©åŒ–è§†å›¾](#ç‰©åŒ–è§†å›¾)
  - [5. å»ä¸­å¿ƒåŒ–æ•°æ®åº“æ¶æ„](#5-å»ä¸­å¿ƒåŒ–æ•°æ®åº“æ¶æ„)
    - [5.1 æ¶æ„è®¾è®¡](#51-æ¶æ„è®¾è®¡)
      - [æ··åˆæ¶æ„](#æ··åˆæ¶æ„)
    - [5.2 æ•°æ®ä¸€è‡´æ€§](#52-æ•°æ®ä¸€è‡´æ€§)
      - [ä¸€è‡´æ€§ä¿è¯](#ä¸€è‡´æ€§ä¿è¯)
  - [6. å®è·µæ¡ˆä¾‹](#6-å®è·µæ¡ˆä¾‹)
    - [6.1 ä¾›åº”é“¾æº¯æºç³»ç»Ÿ](#61-ä¾›åº”é“¾æº¯æºç³»ç»Ÿ)
      - [æ•°æ®æ¨¡å‹](#æ•°æ®æ¨¡å‹)
    - [6.2 æ•°å­—èµ„äº§äº¤æ˜“ç³»ç»Ÿ](#62-æ•°å­—èµ„äº§äº¤æ˜“ç³»ç»Ÿ)
      - [ERC-20ä»£å¸äº¤æ˜“è¿½è¸ª](#erc-20ä»£å¸äº¤æ˜“è¿½è¸ª)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“ æ›´æ–°æ—¥å¿—](#-æ›´æ–°æ—¥å¿—)

---

## 1. åŒºå—é“¾é›†æˆæ¦‚è¿°

### 1.1 é›†æˆåœºæ™¯

#### å…¸å‹åº”ç”¨åœºæ™¯

```text
åœºæ™¯1: åŒºå—é“¾æ•°æ®ç´¢å¼•ä¸æŸ¥è¯¢
- éœ€æ±‚: å¯¹åŒºå—é“¾æ•°æ®è¿›è¡Œå¤æ‚SQLæŸ¥è¯¢
- æ–¹æ¡ˆ: åŒæ­¥åŒºå—é“¾æ•°æ®åˆ°PostgreSQLï¼Œæä¾›SQLæŸ¥è¯¢èƒ½åŠ›

åœºæ™¯2: æ™ºèƒ½åˆçº¦äº‹ä»¶å¤„ç†
- éœ€æ±‚: ç›‘å¬æ™ºèƒ½åˆçº¦äº‹ä»¶ï¼Œè§¦å‘ä¸šåŠ¡æµç¨‹
- æ–¹æ¡ˆ: åŒæ­¥äº‹ä»¶åˆ°PostgreSQLï¼Œä½¿ç”¨è§¦å‘å™¨æˆ–åº”ç”¨é€»è¾‘å¤„ç†

åœºæ™¯3: é“¾ä¸Šé“¾ä¸‹æ•°æ®å…³è”
- éœ€æ±‚: å…³è”åŒºå—é“¾æ•°æ®å’Œä¼ ç»Ÿä¸šåŠ¡æ•°æ®
- æ–¹æ¡ˆ: PostgreSQLå­˜å‚¨å…³è”æ•°æ®ï¼Œæä¾›ç»Ÿä¸€æŸ¥è¯¢æ¥å£

åœºæ™¯4: åŒºå—é“¾æ•°æ®åˆ†æ
- éœ€æ±‚: å¯¹åŒºå—é“¾æ•°æ®è¿›è¡Œç»Ÿè®¡åˆ†æ
- æ–¹æ¡ˆ: æ‰¹é‡åŒæ­¥æ•°æ®åˆ°PostgreSQLï¼Œä½¿ç”¨SQLè¿›è¡Œæ•°æ®åˆ†æ

åœºæ™¯5: å»ä¸­å¿ƒåŒ–åº”ç”¨åç«¯
- éœ€æ±‚: dAppéœ€è¦æŸ¥è¯¢å’Œå­˜å‚¨æ•°æ®
- æ–¹æ¡ˆ: PostgreSQLä½œä¸ºé“¾ä¸‹æ•°æ®å­˜å‚¨ï¼ŒåŒºå—é“¾å­˜å‚¨å…³é”®æ•°æ®
```

### 1.2 é›†æˆæ¶æ„

#### æ¶æ„æ¨¡å¼

```text
æ¨¡å¼1: é“¾ä¸Šå­˜å‚¨ + é“¾ä¸‹ç´¢å¼•ï¼ˆæ¨èï¼‰
åŒºå—é“¾
  â†“ (åŒæ­¥)
PostgreSQL (ç´¢å¼•ã€æŸ¥è¯¢ã€åˆ†æ)
  â†‘
åº”ç”¨å±‚

æ¨¡å¼2: æ··åˆå­˜å‚¨
å…³é”®æ•°æ® â†’ åŒºå—é“¾ (ä¸å¯ç¯¡æ”¹)
ä¸šåŠ¡æ•°æ® â†’ PostgreSQL (é«˜æ•ˆæŸ¥è¯¢)
å…³è”å…³ç³» â†’ PostgreSQL (å…³è”æŸ¥è¯¢)

æ¨¡å¼3: åªè¯»é•œåƒ
åŒºå—é“¾ â†’ PostgreSQL (åªè¯»åŒæ­¥)
åº”ç”¨ â†’ PostgreSQL (æŸ¥è¯¢)
```

### 1.3 æŠ€æœ¯é€‰å‹

#### åŒºå—é“¾å¹³å°é€‰æ‹©

| å¹³å° | ç±»å‹ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **Ethereum** | å…¬é“¾ | ç”Ÿæ€ä¸°å¯Œã€æ™ºèƒ½åˆçº¦ | dAppã€DeFi |
| **Hyperledger Fabric** | è”ç›Ÿé“¾ | æƒé™æ§åˆ¶ã€é«˜æ€§èƒ½ | ä¼ä¸šåº”ç”¨ |
| **Polygon** | ä¾§é“¾ | ä½æˆæœ¬ã€å¿«é€Ÿäº¤æ˜“ | é«˜é¢‘äº¤æ˜“ |
| **Binance Smart Chain** | å…¬é“¾ | ä½Gasè´¹ã€é«˜æ€§èƒ½ | DeFiåº”ç”¨ |

---

## 2. åŒºå—é“¾æ•°æ®å­˜å‚¨è®¾è®¡

### 2.1 åŒºå—æ•°æ®æ¨¡å‹

#### åŒºå—è¡¨è®¾è®¡

```sql
-- åŒºå—è¡¨
CREATE TABLE blocks (
    block_number BIGINT PRIMARY KEY,
    block_hash VARCHAR(66) NOT NULL UNIQUE,
    parent_hash VARCHAR(66) NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    gas_limit NUMERIC(30,0) NOT NULL,
    gas_used NUMERIC(30,0) NOT NULL,
    miner VARCHAR(42),  -- çŸ¿å·¥åœ°å€
    difficulty NUMERIC(30,0),
    total_difficulty NUMERIC(30,0),
    transaction_count INTEGER NOT NULL DEFAULT 0,
    size_bytes INTEGER,
    extra_data BYTEA,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_blocks_hash ON blocks(block_hash);
CREATE INDEX idx_blocks_timestamp ON blocks(timestamp);
CREATE INDEX idx_blocks_miner ON blocks(miner);
```

### 2.2 äº¤æ˜“æ•°æ®æ¨¡å‹

#### äº¤æ˜“è¡¨è®¾è®¡

```sql
-- äº¤æ˜“è¡¨
CREATE TABLE transactions (
    tx_hash VARCHAR(66) PRIMARY KEY,
    block_number BIGINT NOT NULL REFERENCES blocks(block_number),
    block_index INTEGER NOT NULL,  -- äº¤æ˜“åœ¨åŒºå—ä¸­çš„ç´¢å¼•
    from_address VARCHAR(42) NOT NULL,
    to_address VARCHAR(42),
    value NUMERIC(30,0) NOT NULL DEFAULT 0,  -- Wei
    gas_limit NUMERIC(30,0),
    gas_price NUMERIC(30,0),
    gas_used NUMERIC(30,0),
    nonce BIGINT NOT NULL,
    input_data TEXT,  -- åˆçº¦è°ƒç”¨æ•°æ®
    status INTEGER,  -- 0=failed, 1=success
    transaction_index INTEGER,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    UNIQUE(block_number, block_index)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_transactions_block ON transactions(block_number);
CREATE INDEX idx_transactions_from ON transactions(from_address);
CREATE INDEX idx_transactions_to ON transactions(to_address);
CREATE INDEX idx_transactions_status ON transactions(status);
CREATE INDEX idx_transactions_timestamp ON transactions(created_at);
```

### 2.3 çŠ¶æ€æ•°æ®æ¨¡å‹

#### è´¦æˆ·çŠ¶æ€è¡¨

```sql
-- è´¦æˆ·çŠ¶æ€è¡¨
CREATE TABLE account_states (
    address VARCHAR(42) PRIMARY KEY,
    balance NUMERIC(30,0) NOT NULL DEFAULT 0,  -- Wei
    nonce BIGINT NOT NULL DEFAULT 0,
    code_hash VARCHAR(66),  -- åˆçº¦ä»£ç å“ˆå¸Œ
    is_contract BOOLEAN NOT NULL DEFAULT FALSE,
    block_number BIGINT NOT NULL,  -- æœ€åæ›´æ–°åŒºå—
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- è´¦æˆ·çŠ¶æ€å†å²è¡¨ï¼ˆç”¨äºè¿½è¸ªçŠ¶æ€å˜åŒ–ï¼‰
CREATE TABLE account_state_history (
    id BIGSERIAL PRIMARY KEY,
    address VARCHAR(42) NOT NULL,
    block_number BIGINT NOT NULL,
    balance_before NUMERIC(30,0),
    balance_after NUMERIC(30,0),
    nonce_before BIGINT,
    nonce_after BIGINT,
    change_type TEXT,  -- 'transfer_in', 'transfer_out', 'contract_call'
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_account_history_address ON account_state_history(address, block_number);
CREATE INDEX idx_account_history_block ON account_state_history(block_number);
```

### 2.4 ç´¢å¼•è®¾è®¡

#### å¤åˆç´¢å¼•ä¼˜åŒ–

```sql
-- æŸ¥è¯¢ä¼˜åŒ–ï¼šæŒ‰åœ°å€å’Œæ—¶é—´æŸ¥è¯¢äº¤æ˜“
CREATE INDEX idx_transactions_from_time ON transactions(from_address, created_at DESC);
CREATE INDEX idx_transactions_to_time ON transactions(to_address, created_at DESC);

-- æŸ¥è¯¢ä¼˜åŒ–ï¼šæŒ‰åŒºå—å’Œæ—¶é—´èŒƒå›´æŸ¥è¯¢
CREATE INDEX idx_transactions_block_time ON transactions(block_number, created_at);

-- éƒ¨åˆ†ç´¢å¼•ï¼šåªç´¢å¼•æˆåŠŸäº¤æ˜“
CREATE INDEX idx_transactions_success ON transactions(tx_hash, block_number)
WHERE status = 1;

-- è¡¨è¾¾å¼ç´¢å¼•ï¼šå¤§å°å†™ä¸æ•æ„Ÿåœ°å€æŸ¥è¯¢
CREATE INDEX idx_accounts_address_lower ON account_states(LOWER(address));
```

---

## 3. æ™ºèƒ½åˆçº¦æ•°æ®åŒæ­¥

### 3.1 äº‹ä»¶ç›‘å¬æœºåˆ¶

#### Ethereumäº‹ä»¶ç›‘å¬

```python
from web3 import Web3
from web3.middleware import geth_poa_middleware
import psycopg2
from psycopg2.extras import execute_batch

class BlockchainSyncService:
    """åŒºå—é“¾æ•°æ®åŒæ­¥æœåŠ¡"""

    def __init__(self, rpc_url: str, db_config: dict):
        self.w3 = Web3(Web3.HTTPProvider(rpc_url))

        # æ”¯æŒPoAé“¾ï¼ˆå¦‚BSCï¼‰
        if 'poa' in rpc_url.lower() or 'bsc' in rpc_url.lower():
            self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)

        self.conn = psycopg2.connect(**db_config)
        self.cursor = self.conn.cursor()

    def sync_blocks(self, from_block: int, to_block: int = None):
        """
        åŒæ­¥åŒºå—æ•°æ®

        Args:
            from_block: èµ·å§‹åŒºå—å·
            to_block: ç»“æŸåŒºå—å·ï¼ˆNoneè¡¨ç¤ºæœ€æ–°ï¼‰
        """
        if to_block is None:
            to_block = self.w3.eth.block_number

        for block_num in range(from_block, to_block + 1):
            try:
                block = self.w3.eth.get_block(block_num, full_transactions=True)
                self._save_block(block)

                # åŒæ­¥äº¤æ˜“
                for tx in block.transactions:
                    self._save_transaction(tx, block)

                # æäº¤æ¯ä¸ªåŒºå—
                self.conn.commit()

            except Exception as e:
                print(f"Error syncing block {block_num}: {e}")
                self.conn.rollback()
                raise

    def _save_block(self, block: dict):
        """ä¿å­˜åŒºå—æ•°æ®"""
        self.cursor.execute("""
            INSERT INTO blocks (
                block_number, block_hash, parent_hash, timestamp,
                gas_limit, gas_used, miner, difficulty, total_difficulty,
                transaction_count, size_bytes
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (block_number) DO UPDATE SET
                block_hash = EXCLUDED.block_hash,
                gas_used = EXCLUDED.gas_used,
                transaction_count = EXCLUDED.transaction_count,
                updated_at = NOW()
        """, (
            block['number'],
            block['hash'].hex(),
            block['parentHash'].hex(),
            datetime.fromtimestamp(block['timestamp']),
            block['gasLimit'],
            block['gasUsed'],
            block.get('miner', ''),
            block.get('difficulty', 0),
            block.get('totalDifficulty', 0),
            len(block['transactions']),
            block.get('size', 0)
        ))

    def _save_transaction(self, tx: dict, block: dict):
        """ä¿å­˜äº¤æ˜“æ•°æ®"""
        # è·å–äº¤æ˜“å›æ‰§ä»¥è·å–çŠ¶æ€å’Œgas_used
        try:
            receipt = self.w3.eth.get_transaction_receipt(tx['hash'])
            status = receipt['status']
            gas_used = receipt['gasUsed']
        except:
            status = None
            gas_used = None

        self.cursor.execute("""
            INSERT INTO transactions (
                tx_hash, block_number, block_index,
                from_address, to_address, value,
                gas_limit, gas_price, gas_used,
                nonce, input_data, status, transaction_index
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (tx_hash) DO NOTHING
        """, (
            tx['hash'].hex(),
            block['number'],
            tx['transactionIndex'],
            tx['from'],
            tx.get('to'),
            tx['value'],
            tx['gas'],
            tx['gasPrice'],
            gas_used,
            tx['nonce'],
            tx['input'].hex() if tx['input'] else None,
            status,
            tx['transactionIndex']
        ))
```

### 3.2 æ‰¹é‡åŒæ­¥ç­–ç•¥

#### æ‰¹é‡åŒæ­¥ä¼˜åŒ–

```python
class BatchSyncService(BlockchainSyncService):
    """æ‰¹é‡åŒæ­¥æœåŠ¡ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰"""

    def sync_blocks_batch(self, from_block: int, to_block: int, batch_size: int = 100):
        """æ‰¹é‡åŒæ­¥åŒºå—ï¼ˆæå‡æ€§èƒ½ï¼‰"""
        blocks_to_sync = []
        transactions_to_sync = []

        for block_num in range(from_block, to_block + 1):
            try:
                block = self.w3.eth.get_block(block_num, full_transactions=True)
                blocks_to_sync.append(block)

                # æ”¶é›†äº¤æ˜“
                for tx in block.transactions:
                    receipt = self.w3.eth.get_transaction_receipt(tx['hash'])
                    transactions_to_sync.append({
                        'tx': tx,
                        'block': block,
                        'receipt': receipt
                    })

                # æ‰¹é‡æ’å…¥
                if len(blocks_to_sync) >= batch_size:
                    self._batch_save_blocks(blocks_to_sync)
                    self._batch_save_transactions(transactions_to_sync)
                    blocks_to_sync = []
                    transactions_to_sync = []
                    self.conn.commit()

            except Exception as e:
                print(f"Error syncing block {block_num}: {e}")
                self.conn.rollback()

        # å¤„ç†å‰©ä½™çš„
        if blocks_to_sync:
            self._batch_save_blocks(blocks_to_sync)
            self._batch_save_transactions(transactions_to_sync)
            self.conn.commit()

    def _batch_save_blocks(self, blocks: list):
        """æ‰¹é‡ä¿å­˜åŒºå—"""
        values = []
        for block in blocks:
            values.append((
                block['number'],
                block['hash'].hex(),
                block['parentHash'].hex(),
                datetime.fromtimestamp(block['timestamp']),
                block['gasLimit'],
                block['gasUsed'],
                block.get('miner', ''),
                len(block['transactions'])
            ))

        execute_batch(
            self.cursor,
            """
            INSERT INTO blocks (
                block_number, block_hash, parent_hash, timestamp,
                gas_limit, gas_used, miner, transaction_count
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (block_number) DO UPDATE SET
                gas_used = EXCLUDED.gas_used,
                transaction_count = EXCLUDED.transaction_count
            """,
            values
        )
```

### 3.3 å®æ—¶åŒæ­¥å®ç°

#### WebSocketå®æ—¶åŒæ­¥

```python
from web3 import Web3
from websocket import create_connection
import json

class RealTimeSyncService:
    """å®æ—¶åŒæ­¥æœåŠ¡ï¼ˆä½¿ç”¨WebSocketï¼‰"""

    def __init__(self, ws_url: str, db_config: dict):
        self.ws_url = ws_url
        self.conn = psycopg2.connect(**db_config)
        self.cursor = self.conn.cursor()
        self.ws = None

    def start_sync(self):
        """å¯åŠ¨å®æ—¶åŒæ­¥"""
        self.ws = create_connection(self.ws_url)

        # è®¢é˜…æ–°åŒºå—
        subscribe_request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "eth_subscribe",
            "params": ["newHeads"]
        }
        self.ws.send(json.dumps(subscribe_request))
        response = json.loads(self.ws.recv())
        subscription_id = response['result']

        print(f"Subscribed to new blocks: {subscription_id}")

        # ç›‘å¬æ–°åŒºå—
        while True:
            try:
                message = json.loads(self.ws.recv())

                if 'params' in message:
                    block_hash = message['params']['result']['hash']
                    block_number = int(message['params']['result']['number'], 16)

                    # åŒæ­¥æ–°åŒºå—
                    self._sync_new_block(block_number)

            except Exception as e:
                print(f"Error in real-time sync: {e}")
                # é‡è¿
                self._reconnect()

    def _sync_new_block(self, block_number: int):
        """åŒæ­¥æ–°åŒºå—"""
        w3 = Web3(Web3.HTTPProvider(self.ws_url.replace('ws://', 'http://').replace('wss://', 'https://')))
        block = w3.eth.get_block(block_number, full_transactions=True)

        # ä¿å­˜åŒºå—å’Œäº¤æ˜“ï¼ˆä½¿ç”¨ä¹‹å‰çš„åŒæ­¥é€»è¾‘ï¼‰
        sync_service = BlockchainSyncService(None, None)
        sync_service.conn = self.conn
        sync_service.cursor = self.cursor
        sync_service._save_block(block)

        for tx in block.transactions:
            sync_service._save_transaction(tx, block)

        self.conn.commit()
        print(f"Synced block {block_number}")
```

### 3.4 åŒæ­¥é”™è¯¯å¤„ç†

#### é”™è¯¯å¤„ç†ä¸é‡è¯•

```python
import time
from functools import wraps

def retry_on_error(max_retries=3, delay=1, backoff=2):
    """é‡è¯•è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    retries += 1
                    if retries >= max_retries:
                        raise
                    wait_time = delay * (backoff ** (retries - 1))
                    print(f"Error in {func.__name__}: {e}. Retrying in {wait_time}s...")
                    time.sleep(wait_time)
        return wrapper
    return decorator

class RobustSyncService(BlockchainSyncService):
    """å¥å£®çš„åŒæ­¥æœåŠ¡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰"""

    @retry_on_error(max_retries=5, delay=2)
    def sync_blocks(self, from_block: int, to_block: int = None):
        """åŒæ­¥åŒºå—ï¼ˆå¸¦é‡è¯•ï¼‰"""
        try:
            super().sync_blocks(from_block, to_block)
        except Exception as e:
            # è®°å½•åŒæ­¥å¤±è´¥
            self._log_sync_error(from_block, to_block, str(e))
            raise

    def _log_sync_error(self, from_block: int, to_block: int, error: str):
        """è®°å½•åŒæ­¥é”™è¯¯"""
        self.cursor.execute("""
            INSERT INTO sync_errors (
                from_block, to_block, error_message, occurred_at
            ) VALUES (%s, %s, %s, NOW())
        """, (from_block, to_block, error))
        self.conn.commit()
```

---

## 4. åŒºå—é“¾æŸ¥è¯¢ä¼˜åŒ–

### 4.1 æŸ¥è¯¢æ¨¡å¼åˆ†æ

#### å¸¸è§æŸ¥è¯¢æ¨¡å¼

```sql
-- æŸ¥è¯¢æ¨¡å¼1: æŒ‰åœ°å€æŸ¥è¯¢äº¤æ˜“å†å²
SELECT * FROM transactions
WHERE from_address = '0x...' OR to_address = '0x...'
ORDER BY created_at DESC
LIMIT 100;

-- æŸ¥è¯¢æ¨¡å¼2: æŒ‰æ—¶é—´èŒƒå›´æŸ¥è¯¢
SELECT * FROM transactions
WHERE created_at BETWEEN '2025-01-01' AND '2025-01-31'
ORDER BY created_at DESC;

-- æŸ¥è¯¢æ¨¡å¼3: ç»Ÿè®¡æŸ¥è¯¢
SELECT
    DATE(created_at) AS date,
    COUNT(*) AS tx_count,
    SUM(value) AS total_value
FROM transactions
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- æŸ¥è¯¢æ¨¡å¼4: è´¦æˆ·ä½™é¢æŸ¥è¯¢
SELECT balance FROM account_states
WHERE address = '0x...';
```

### 4.2 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

#### åˆ†åŒºè¡¨ + ç´¢å¼•

```sql
-- æŒ‰æ—¶é—´åˆ†åŒºäº¤æ˜“è¡¨
CREATE TABLE transactions (
    -- ... å­—æ®µå®šä¹‰ ...
) PARTITION BY RANGE (created_at);

-- åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE transactions_2025_01 PARTITION OF transactions
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE transactions_2025_02 PARTITION OF transactions
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- ä¸ºæ¯ä¸ªåˆ†åŒºåˆ›å»ºç´¢å¼•
CREATE INDEX idx_transactions_2025_01_from ON transactions_2025_01(from_address);
CREATE INDEX idx_transactions_2025_01_to ON transactions_2025_01(to_address);
```

### 4.3 ç‰©åŒ–è§†å›¾ä¼˜åŒ–

#### ç‰©åŒ–è§†å›¾

```sql
-- è´¦æˆ·ä½™é¢æ±‡æ€»è§†å›¾
CREATE MATERIALIZED VIEW account_balance_summary AS
SELECT
    address,
    balance,
    (
        SELECT COUNT(*) FROM transactions
        WHERE from_address = account_states.address
           OR to_address = account_states.address
    ) AS transaction_count,
    (
        SELECT MAX(created_at) FROM transactions
        WHERE from_address = account_states.address
           OR to_address = account_states.address
    ) AS last_transaction_time
FROM account_states
WHERE balance > 0;

CREATE INDEX idx_balance_summary_address ON account_balance_summary(address);
CREATE INDEX idx_balance_summary_balance ON account_balance_summary(balance DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY account_balance_summary;
```

---

## 5. å»ä¸­å¿ƒåŒ–æ•°æ®åº“æ¶æ„

### 5.1 æ¶æ„è®¾è®¡

#### æ··åˆæ¶æ„

```text
åŒºå—é“¾å±‚ï¼ˆä¸å¯ç¯¡æ”¹ï¼‰
  â”œâ”€ å…³é”®æ•°æ®å“ˆå¸Œ
  â”œâ”€ æ™ºèƒ½åˆçº¦çŠ¶æ€
  â””â”€ äº¤æ˜“è®°å½•

PostgreSQLå±‚ï¼ˆé«˜æ•ˆæŸ¥è¯¢ï¼‰
  â”œâ”€ å®Œæ•´æ•°æ®å‰¯æœ¬
  â”œâ”€ ç´¢å¼•å’Œç‰©åŒ–è§†å›¾
  â”œâ”€ å…³è”ä¸šåŠ¡æ•°æ®
  â””â”€ åˆ†ææ•°æ®

åº”ç”¨å±‚
  â”œâ”€ è¯»æ“ä½œ â†’ PostgreSQL
  â”œâ”€ å†™æ“ä½œ â†’ åŒºå—é“¾ + PostgreSQL
  â””â”€ éªŒè¯ â†’ åŒºå—é“¾
```

### 5.2 æ•°æ®ä¸€è‡´æ€§

#### ä¸€è‡´æ€§ä¿è¯

```python
class ConsistencyChecker:
    """æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥å™¨"""

    def verify_blockchain_data(self, block_number: int) -> bool:
        """éªŒè¯PostgreSQLæ•°æ®ä¸åŒºå—é“¾æ•°æ®ä¸€è‡´"""
        # ä»åŒºå—é“¾è·å–åŒºå—
        blockchain_block = self.w3.eth.get_block(block_number)

        # ä»PostgreSQLè·å–åŒºå—
        self.cursor.execute("""
            SELECT * FROM blocks WHERE block_number = %s
        """, (block_number,))
        db_block = self.cursor.fetchone()

        # éªŒè¯å“ˆå¸Œä¸€è‡´
        if db_block['block_hash'] != blockchain_block['hash'].hex():
            return False

        # éªŒè¯äº¤æ˜“æ•°é‡
        self.cursor.execute("""
            SELECT COUNT(*) FROM transactions WHERE block_number = %s
        """, (block_number,))
        db_tx_count = self.cursor.fetchone()[0]

        if db_tx_count != len(blockchain_block['transactions']):
            return False

        return True
```

---

## 6. å®è·µæ¡ˆä¾‹

### 6.1 ä¾›åº”é“¾æº¯æºç³»ç»Ÿ

#### æ•°æ®æ¨¡å‹

```sql
-- äº§å“è¡¨
CREATE TABLE products (
    product_id VARCHAR(100) PRIMARY KEY,
    blockchain_hash VARCHAR(66) UNIQUE,  -- åŒºå—é“¾äº¤æ˜“å“ˆå¸Œ
    name TEXT NOT NULL,
    manufacturer VARCHAR(42),  -- åˆ¶é€ å•†åœ°å€
    created_at TIMESTAMPTZ NOT NULL
);

-- æµè½¬è®°å½•è¡¨
CREATE TABLE product_transfers (
    transfer_id BIGSERIAL PRIMARY KEY,
    product_id VARCHAR(100) REFERENCES products(product_id),
    from_address VARCHAR(42),
    to_address VARCHAR(42),
    blockchain_tx_hash VARCHAR(66),
    block_number BIGINT,
    timestamp TIMESTAMPTZ NOT NULL
);

-- æŸ¥è¯¢äº§å“æµè½¬å†å²
-- è·å–äº§å“å†å²è®°å½•å‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION get_product_history(p_product_id VARCHAR)
RETURNS TABLE (
    transfer_id BIGINT,
    from_address VARCHAR(42),
    to_address VARCHAR(42),
    blockchain_tx_hash VARCHAR(66),
    timestamp TIMESTAMPTZ
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- å‚æ•°éªŒè¯
    IF p_product_id IS NULL OR TRIM(p_product_id) = '' THEN
        RAISE EXCEPTION 'äº§å“IDä¸èƒ½ä¸ºç©º';
    END IF;

    -- æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'product_transfers') THEN
        RAISE EXCEPTION 'product_transfersè¡¨ä¸å­˜åœ¨';
    END IF;

    -- æŸ¥è¯¢äº§å“å†å²è®°å½•
    BEGIN
        RETURN QUERY
        SELECT
            pt.transfer_id,
            pt.from_address,
            pt.to_address,
            pt.blockchain_tx_hash,
            pt.timestamp
        FROM product_transfers pt
        WHERE pt.product_id = p_product_id
          AND pt.product_id IS NOT NULL
        ORDER BY COALESCE(pt.timestamp, '1970-01-01'::TIMESTAMPTZ) ASC;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'æŸ¥è¯¢äº§å“å†å²è®°å½•å¤±è´¥: %', SQLERRM;
    END;
END;
$$;
```

### 6.2 æ•°å­—èµ„äº§äº¤æ˜“ç³»ç»Ÿ

#### ERC-20ä»£å¸äº¤æ˜“è¿½è¸ª

```sql
-- ERC-20è½¬è´¦äº‹ä»¶è¡¨
CREATE TABLE erc20_transfers (
    id BIGSERIAL PRIMARY KEY,
    token_address VARCHAR(42) NOT NULL,
    from_address VARCHAR(42) NOT NULL,
    to_address VARCHAR(42) NOT NULL,
    value NUMERIC(30,0) NOT NULL,
    tx_hash VARCHAR(66) NOT NULL,
    block_number BIGINT NOT NULL,
    log_index INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    UNIQUE(tx_hash, log_index)
);

CREATE INDEX idx_erc20_token_from ON erc20_transfers(token_address, from_address);
CREATE INDEX idx_erc20_token_to ON erc20_transfers(token_address, to_address);

-- æŸ¥è¯¢ä»£å¸ä½™é¢å‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION get_token_balance(
    p_token_address VARCHAR(42),
    p_user_address VARCHAR(42)
)
RETURNS NUMERIC(30,0)
LANGUAGE plpgsql
AS $$
DECLARE
    v_credit_balance NUMERIC(30,0) := 0;
    v_debit_balance NUMERIC(30,0) := 0;
    v_balance NUMERIC(30,0) := 0;
BEGIN
    -- å‚æ•°éªŒè¯
    IF p_token_address IS NULL OR TRIM(p_token_address) = '' THEN
        RAISE EXCEPTION 'ä»£å¸åœ°å€ä¸èƒ½ä¸ºç©º';
    END IF;

    IF p_user_address IS NULL OR TRIM(p_user_address) = '' THEN
        RAISE EXCEPTION 'ç”¨æˆ·åœ°å€ä¸èƒ½ä¸ºç©º';
    END IF;

    -- æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'erc20_transfers') THEN
        RAISE EXCEPTION 'erc20_transfersè¡¨ä¸å­˜åœ¨';
    END IF;

    -- è®¡ç®—è½¬å…¥
    BEGIN
        SELECT COALESCE(SUM(value), 0) INTO v_credit_balance
        FROM erc20_transfers
        WHERE token_address = p_token_address
          AND to_address = p_user_address
          AND value IS NOT NULL
          AND value > 0;
    EXCEPTION
        WHEN numeric_value_out_of_range THEN
            RAISE EXCEPTION 'è½¬å…¥ä½™é¢è®¡ç®—æº¢å‡º';
        WHEN OTHERS THEN
            RAISE WARNING 'è®¡ç®—è½¬å…¥ä½™é¢å¤±è´¥: %', SQLERRM;
    END;

    -- è®¡ç®—è½¬å‡º
    BEGIN
        SELECT COALESCE(SUM(value), 0) INTO v_debit_balance
        FROM erc20_transfers
        WHERE token_address = p_token_address
          AND from_address = p_user_address
          AND value IS NOT NULL
          AND value > 0;
    EXCEPTION
        WHEN numeric_value_out_of_range THEN
            RAISE EXCEPTION 'è½¬å‡ºä½™é¢è®¡ç®—æº¢å‡º';
        WHEN OTHERS THEN
            RAISE WARNING 'è®¡ç®—è½¬å‡ºä½™é¢å¤±è´¥: %', SQLERRM;
    END;

    -- è®¡ç®—æ€»ä½™é¢
    BEGIN
        v_balance := v_credit_balance - v_debit_balance;

        -- ç¡®ä¿ä½™é¢ä¸ä¸ºè´Ÿæ•°ï¼ˆæ ¹æ®ä¸šåŠ¡éœ€æ±‚å†³å®šï¼‰
        IF v_balance < 0 THEN
            RAISE WARNING 'ä»£å¸ä½™é¢ä¸ºè´Ÿæ•°: token=%, user=%, balance=%', p_token_address, p_user_address, v_balance;
            v_balance := 0;
        END IF;

        RETURN v_balance;
    EXCEPTION
        WHEN numeric_value_out_of_range THEN
            RAISE EXCEPTION 'ä½™é¢è®¡ç®—æº¢å‡º';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'è®¡ç®—ä»£å¸ä½™é¢å¤±è´¥: %', SQLERRM;
    END;
END;
$$;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Web3.pyæ–‡æ¡£**: <https://web3py.readthedocs.io/>
2. **Ethereum JSON-RPC**: <https://ethereum.org/en/developers/docs/apis/json-rpc/>
3. **PostgreSQLåŒºå—é“¾é›†æˆ**: <https://www.postgresql.org/docs/current/>

---

## ğŸ“ æ›´æ–°æ—¥å¿—

- **v1.0** (2025-01): åˆå§‹ç‰ˆæœ¬
  - åŒºå—é“¾é›†æˆæ¦‚è¿°
  - åŒºå—é“¾æ•°æ®å­˜å‚¨è®¾è®¡
  - æ™ºèƒ½åˆçº¦æ•°æ®åŒæ­¥
  - åŒºå—é“¾æŸ¥è¯¢ä¼˜åŒ–
  - å»ä¸­å¿ƒåŒ–æ•°æ®åº“æ¶æ„
  - å®è·µæ¡ˆä¾‹

---

**çŠ¶æ€**: âœ… **æ–‡æ¡£å®Œæˆ** | [è¿”å›ç›®å½•](./README.md)
