# PostgreSQL扩展开发完整指南

> **PostgreSQL版本**: 17+/18+
> **适用场景**: 自定义功能扩展、插件开发
> **难度等级**: ⭐⭐⭐⭐⭐ 专家级

---

## 📋 目录

- [PostgreSQL扩展开发完整指南](#postgresql扩展开发完整指南)
  - [1. 概述](#1-概述)
  - [2. 扩展开发基础](#2-扩展开发基础)
  - [3. 扩展开发实践](#3-扩展开发实践)
  - [4. 扩展测试与调试](#4-扩展测试与调试)
  - [5. 扩展发布与分发](#5-扩展发布与分发)
  - [6. 最佳实践](#6-最佳实践)

---

## 1. 概述

### 1.1 什么是PostgreSQL扩展？

PostgreSQL扩展（Extension）是一种机制，允许在不修改PostgreSQL核心代码的情况下添加新功能。

**扩展类型**:
- ✅ **SQL扩展**: 纯SQL实现的扩展
- ✅ **C扩展**: 使用C语言编写的扩展
- ✅ **混合扩展**: SQL + C混合实现

### 1.2 扩展的优势

- **模块化**: 按需加载功能
- **可维护性**: 独立开发和维护
- **灵活性**: 易于安装和卸载
- **社区贡献**: 丰富的社区扩展生态

---

## 2. 扩展开发基础

### 2.1 SQL扩展开发

#### 2.1.1 创建SQL扩展

```sql
-- 1. 创建扩展目录结构
-- my_extension/
--   ├── my_extension.control
--   ├── my_extension--1.0.sql
--   └── Makefile

-- 2. 创建控制文件 (my_extension.control)
-- default_version = '1.0'
-- comment = 'My custom extension'
-- requires = 'plpgsql'

-- 3. 创建SQL文件 (my_extension--1.0.sql)
CREATE EXTENSION IF NOT EXISTS plpgsql;

-- 创建函数
CREATE OR REPLACE FUNCTION my_function()
RETURNS TEXT AS $$
BEGIN
    RETURN 'Hello from my extension!';
END;
$$ LANGUAGE plpgsql;

-- 创建类型
CREATE TYPE my_type AS (
    id INT,
    name TEXT
);

-- 创建表
CREATE TABLE my_table (
    id SERIAL PRIMARY KEY,
    data TEXT
);
```

#### 2.1.2 扩展版本管理

```sql
-- 创建升级脚本 (my_extension--1.0--1.1.sql)
ALTER EXTENSION my_extension UPDATE TO '1.1';

-- 添加新函数
CREATE OR REPLACE FUNCTION my_new_function()
RETURNS TEXT AS $$
BEGIN
    RETURN 'New function in version 1.1';
END;
$$ LANGUAGE plpgsql;
```

### 2.2 C扩展开发

#### 2.2.1 扩展结构

```c
// my_extension.c
#include "postgres.h"
#include "fmgr.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

// 函数定义
PG_FUNCTION_INFO_V1(my_c_function);

Datum
my_c_function(PG_FUNCTION_ARGS)
{
    text *result;
    result = cstring_to_text("Hello from C extension!");
    PG_RETURN_TEXT_P(result);
}
```

#### 2.2.2 Makefile配置

```makefile
# Makefile
MODULES = my_extension
EXTENSION = my_extension
DATA = my_extension--1.0.sql
PGFILEDESC = "My custom extension"

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
```

---

## 3. 扩展开发实践

### 3.1 函数扩展

```sql
-- 创建实用函数扩展
CREATE OR REPLACE FUNCTION format_bytes(bytes BIGINT)
RETURNS TEXT AS $$
BEGIN
    CASE
        WHEN bytes < 1024 THEN
            RETURN bytes || ' B';
        WHEN bytes < 1024 * 1024 THEN
            RETURN ROUND(bytes / 1024.0, 2) || ' KB';
        WHEN bytes < 1024 * 1024 * 1024 THEN
            RETURN ROUND(bytes / (1024.0 * 1024.0), 2) || ' MB';
        ELSE
            RETURN ROUND(bytes / (1024.0 * 1024.0 * 1024.0), 2) || ' GB';
    END CASE;
END;
$$ LANGUAGE plpgsql;

-- 使用
SELECT format_bytes(1073741824);  -- 返回 '1.00 GB'
```

### 3.2 数据类型扩展

```sql
-- 创建自定义数据类型
CREATE TYPE email_address AS (
    local_part TEXT,
    domain TEXT
);

-- 创建输入/输出函数
CREATE OR REPLACE FUNCTION email_address_in(cstring)
RETURNS email_address AS $$
DECLARE
    result email_address;
    parts TEXT[];
BEGIN
    parts := string_to_array($1, '@');
    IF array_length(parts, 1) != 2 THEN
        RAISE EXCEPTION 'Invalid email format';
    END IF;
    result.local_part := parts[1];
    result.domain := parts[2];
    RETURN result;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION email_address_out(email_address)
RETURNS cstring AS $$
BEGIN
    RETURN $1.local_part || '@' || $1.domain;
END;
$$ LANGUAGE plpgsql;

-- 注册类型
CREATE TYPE email_address (
    INPUT = email_address_in,
    OUTPUT = email_address_out
);
```

### 3.3 操作符扩展

```sql
-- 创建自定义操作符
CREATE OPERATOR = (
    LEFTARG = email_address,
    RIGHTARG = email_address,
    PROCEDURE = email_address_eq,
    COMMUTATOR = =
);

-- 创建比较函数
CREATE OR REPLACE FUNCTION email_address_eq(
    email_address,
    email_address
)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN $1.local_part = $2.local_part
        AND $1.domain = $2.domain;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. 扩展测试与调试

### 4.1 单元测试

```sql
-- 创建测试函数
CREATE OR REPLACE FUNCTION test_my_extension()
RETURNS TABLE (
    test_name TEXT,
    result TEXT
) AS $$
BEGIN
    -- 测试1: 函数返回值
    RETURN QUERY
    SELECT
        'function_return'::TEXT,
        CASE
            WHEN my_function() = 'Hello from my extension!' THEN 'PASS'
            ELSE 'FAIL'
        END;

    -- 测试2: 类型转换
    RETURN QUERY
    SELECT
        'type_conversion'::TEXT,
        CASE
            WHEN 'test@example.com'::email_address IS NOT NULL THEN 'PASS'
            ELSE 'FAIL'
        END;
END;
$$ LANGUAGE plpgsql;

-- 运行测试
SELECT * FROM test_my_extension();
```

### 4.2 调试技巧

```sql
-- 使用RAISE NOTICE调试
CREATE OR REPLACE FUNCTION debug_function()
RETURNS void AS $$
DECLARE
    v_value INT := 100;
BEGIN
    RAISE NOTICE 'Debug: v_value = %', v_value;
    -- 业务逻辑
    v_value := v_value * 2;
    RAISE NOTICE 'Debug: v_value after calculation = %', v_value;
END;
$$ LANGUAGE plpgsql;

-- 启用详细日志
SET client_min_messages TO 'debug1';
SELECT debug_function();
```

---

## 5. 扩展发布与分发

### 5.1 打包扩展

```bash
# 创建扩展包
tar -czf my_extension-1.0.tar.gz \
    my_extension.control \
    my_extension--1.0.sql \
    Makefile \
    my_extension.c
```

### 5.2 安装扩展

```sql
-- 从源码安装
CREATE EXTENSION my_extension;

-- 从包安装
-- 1. 解压到contrib目录
-- 2. make install
-- 3. CREATE EXTENSION my_extension;
```

### 5.3 版本升级

```sql
-- 检查当前版本
SELECT extversion FROM pg_extension WHERE extname = 'my_extension';

-- 升级扩展
ALTER EXTENSION my_extension UPDATE TO '1.1';

-- 查看升级历史
SELECT * FROM pg_extension_update_paths('my_extension');
```

---

## 6. 最佳实践

### 6.1 开发规范

- ✅ **命名规范**: 使用清晰的命名约定
- ✅ **文档完善**: 提供完整的文档
- ✅ **错误处理**: 完善的错误处理机制
- ✅ **性能优化**: 考虑性能影响

### 6.2 测试策略

- ✅ **单元测试**: 为每个函数编写测试
- ✅ **集成测试**: 测试扩展与PostgreSQL的集成
- ✅ **性能测试**: 测试扩展的性能影响
- ✅ **兼容性测试**: 测试不同PostgreSQL版本

### 6.3 发布流程

- ✅ **版本管理**: 使用语义化版本
- ✅ **变更日志**: 维护详细的变更日志
- ✅ **许可证**: 明确许可证信息
- ✅ **社区支持**: 提供社区支持渠道

---

## 📚 相关文档

- [06-扩展系统/README.md](./README.md) - 扩展系统主题
- [29-社区生态/扩展生态全景图](../29-社区生态/扩展生态全景图.md) - 扩展生态
- [PostgreSQL官方扩展文档](https://www.postgresql.org/docs/current/extend.html) - 官方文档

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
