# PostgreSQL扩展开发完整指南

> **PostgreSQL版本**: 17+/18+
> **适用场景**: 自定义功能扩展、插件开发
> **难度等级**: ⭐⭐⭐⭐⭐ 专家级

---

## 📋 目录

- [PostgreSQL扩展开发完整指南](#postgresql扩展开发完整指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 什么是PostgreSQL扩展？](#11-什么是postgresql扩展)
    - [1.2 扩展的优势](#12-扩展的优势)
  - [2. 扩展开发基础](#2-扩展开发基础)
    - [2.1 SQL扩展开发](#21-sql扩展开发)
      - [2.1.1 创建SQL扩展](#211-创建sql扩展)
      - [2.1.2 扩展版本管理](#212-扩展版本管理)
    - [2.2 C扩展开发](#22-c扩展开发)
      - [2.2.1 扩展结构](#221-扩展结构)
      - [2.2.2 Makefile配置](#222-makefile配置)
  - [3. 扩展开发实践](#3-扩展开发实践)
    - [3.1 函数扩展](#31-函数扩展)
    - [3.2 数据类型扩展](#32-数据类型扩展)
    - [3.3 操作符扩展](#33-操作符扩展)
  - [4. 扩展测试与调试](#4-扩展测试与调试)
    - [4.1 单元测试](#41-单元测试)
    - [4.2 调试技巧](#42-调试技巧)
  - [5. 扩展发布与分发](#5-扩展发布与分发)
    - [5.1 打包扩展](#51-打包扩展)
    - [5.2 安装扩展](#52-安装扩展)
    - [5.3 版本升级](#53-版本升级)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 开发规范](#61-开发规范)
    - [6.2 测试策略](#62-测试策略)
    - [6.3 发布流程](#63-发布流程)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

### 1.1 什么是PostgreSQL扩展？

PostgreSQL扩展（Extension）是一种机制，允许在不修改PostgreSQL核心代码的情况下添加新功能。

**扩展类型**:

- ✅ **SQL扩展**: 纯SQL实现的扩展
- ✅ **C扩展**: 使用C语言编写的扩展
- ✅ **混合扩展**: SQL + C混合实现

### 1.2 扩展的优势

- **模块化**: 按需加载功能
- **可维护性**: 独立开发和维护
- **灵活性**: 易于安装和卸载
- **社区贡献**: 丰富的社区扩展生态

---

## 2. 扩展开发基础

### 2.1 SQL扩展开发

#### 2.1.1 创建SQL扩展

```sql
-- 1. 创建扩展目录结构
-- my_extension/
--   ├── my_extension.control
--   ├── my_extension--1.0.sql
--   └── Makefile

-- 2. 创建控制文件 (my_extension.control)
-- default_version = '1.0'
-- comment = 'My custom extension'
-- requires = 'plpgsql'

-- 3. 创建SQL文件 (my_extension--1.0.sql)
CREATE EXTENSION IF NOT EXISTS plpgsql;

-- 创建函数
CREATE OR REPLACE FUNCTION my_function()
RETURNS TEXT AS $$
BEGIN
    RETURN 'Hello from my extension!';
END;
$$ LANGUAGE plpgsql;

-- 创建类型
CREATE TYPE my_type AS (
    id INT,
    name TEXT
);

-- 创建表
CREATE TABLE my_table (
    id SERIAL PRIMARY KEY,
    data TEXT
);
```

#### 2.1.2 扩展版本管理

```sql
-- 创建升级脚本 (my_extension--1.0--1.1.sql)
ALTER EXTENSION my_extension UPDATE TO '1.1';

-- 添加新函数
CREATE OR REPLACE FUNCTION my_new_function()
RETURNS TEXT AS $$
BEGIN
    RETURN 'New function in version 1.1';
END;
$$ LANGUAGE plpgsql;
```

### 2.2 C扩展开发

#### 2.2.1 扩展结构

```c
// my_extension.c
#include "postgres.h"
#include "fmgr.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

// 函数定义
PG_FUNCTION_INFO_V1(my_c_function);

Datum
my_c_function(PG_FUNCTION_ARGS)
{
    text *result;
    result = cstring_to_text("Hello from C extension!");
    PG_RETURN_TEXT_P(result);
}
```

#### 2.2.2 Makefile配置

```makefile
# Makefile
MODULES = my_extension
EXTENSION = my_extension
DATA = my_extension--1.0.sql
PGFILEDESC = "My custom extension"

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
```

---

## 3. 扩展开发实践

### 3.1 函数扩展

```sql
-- 创建实用函数扩展（带错误处理）
CREATE OR REPLACE FUNCTION format_bytes(bytes BIGINT)
RETURNS TEXT AS $$
BEGIN
    -- 错误处理：检查NULL输入
    IF bytes IS NULL THEN
        RAISE EXCEPTION '输入参数不能为NULL';
    END IF;

    -- 错误处理：检查负数
    IF bytes < 0 THEN
        RAISE EXCEPTION '字节数不能为负数: %', bytes;
    END IF;

        CASE
            WHEN bytes < 1024 THEN
                RETURN bytes || ' B';
            WHEN bytes < 1024 * 1024 THEN
                RETURN ROUND(bytes / 1024.0, 2) || ' KB';
            WHEN bytes < 1024 * 1024 * 1024 THEN
                RETURN ROUND(bytes / (1024.0 * 1024.0), 2) || ' MB';
            ELSE
                RETURN ROUND(bytes / (1024.0 * 1024.0 * 1024.0), 2) || ' GB';
        END CASE;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '格式化字节数时出错: %', SQLERRM;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 使用（带性能测试）
EXPLAIN ANALYZE
SELECT format_bytes(1073741824);  -- 返回 '1.00 GB'
```

### 3.2 数据类型扩展

```sql
-- 创建自定义数据类型
CREATE TYPE email_address AS (
    local_part TEXT,
    domain TEXT
);

-- 创建输入/输出函数（带错误处理）
CREATE OR REPLACE FUNCTION email_address_in(cstring)
RETURNS email_address AS $$
DECLARE
    result email_address;
    parts TEXT[];
BEGIN
    -- 错误处理：检查NULL输入
    IF $1 IS NULL THEN
        RAISE EXCEPTION '输入字符串不能为NULL';
    END IF;

    BEGIN
        parts := string_to_array($1, '@');
        IF array_length(parts, 1) != 2 THEN
            RAISE EXCEPTION '无效的邮箱格式: "%"。期望格式: local@domain', $1;
        END IF;

        -- 错误处理：验证邮箱部分不为空
        IF parts[1] IS NULL OR parts[1] = '' OR parts[2] IS NULL OR parts[2] = '' THEN
            RAISE EXCEPTION '邮箱的本地部分或域名不能为空';
        END IF;

        result.local_part := parts[1];
        result.domain := parts[2];
        RETURN result;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION email_address_out(email_address)
RETURNS cstring AS $$
BEGIN
    -- 错误处理：检查NULL输入
    IF $1 IS NULL THEN
        RAISE EXCEPTION '邮箱地址对象不能为NULL';
    END IF;

    BEGIN
        RETURN $1.local_part || '@' || $1.domain;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '格式化邮箱地址时出错: %', SQLERRM;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

-- 注册类型
CREATE TYPE email_address (
    INPUT = email_address_in,
    OUTPUT = email_address_out
);
```

### 3.3 操作符扩展

```sql
-- 创建自定义操作符
CREATE OPERATOR = (
    LEFTARG = email_address,
    RIGHTARG = email_address,
    PROCEDURE = email_address_eq,
    COMMUTATOR = =
);

-- 创建比较函数（带错误处理）
CREATE OR REPLACE FUNCTION email_address_eq(
    email_address,
    email_address
)
RETURNS BOOLEAN AS $$
BEGIN
    -- 错误处理：检查NULL参数
    IF $1 IS NULL OR $2 IS NULL THEN
        RETURN NULL;
    END IF;

    BEGIN
        RETURN $1.local_part = $2.local_part
            AND $1.domain = $2.domain;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '比较邮箱地址时出错: %', SQLERRM;
            RETURN NULL;
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## 4. 扩展测试与调试

### 4.1 单元测试

```sql
-- 创建测试函数（带错误处理）
CREATE OR REPLACE FUNCTION test_my_extension()
RETURNS TABLE (
    test_name TEXT,
    result TEXT
) AS $$
BEGIN
    BEGIN
        -- 测试1: 函数返回值
        RETURN QUERY
        SELECT
            'function_return'::TEXT,
            CASE
                WHEN my_function() = 'Hello from my extension!' THEN 'PASS'
                ELSE 'FAIL'
            END;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN QUERY SELECT 'function_return'::TEXT, 'ERROR: ' || SQLERRM;
    END;

    BEGIN
        -- 测试2: 类型转换
        RETURN QUERY
        SELECT
            'type_conversion'::TEXT,
            CASE
                WHEN 'test@example.com'::email_address IS NOT NULL THEN 'PASS'
                ELSE 'FAIL'
            END;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN QUERY SELECT 'type_conversion'::TEXT, 'ERROR: ' || SQLERRM;
    END;
END;
$$ LANGUAGE plpgsql;

-- 运行测试（带性能测试）
EXPLAIN ANALYZE
SELECT * FROM test_my_extension();
```

### 4.2 调试技巧

```sql
-- 使用RAISE NOTICE调试（带错误处理）
CREATE OR REPLACE FUNCTION debug_function()
RETURNS void AS $$
DECLARE
    v_value INT := 100;
BEGIN
    BEGIN
        RAISE NOTICE 'Debug: v_value = %', v_value;
        -- 业务逻辑
        v_value := v_value * 2;
        RAISE NOTICE 'Debug: v_value after calculation = %', v_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '调试函数执行出错: %', SQLERRM;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql;

-- 启用详细日志（带错误处理）
DO $$
BEGIN
    SET client_min_messages TO 'debug1';
    PERFORM debug_function();
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '执行调试函数时出错: %', SQLERRM;
END $$;
```

---

## 5. 扩展发布与分发

### 5.1 打包扩展

```bash
# 创建扩展包
tar -czf my_extension-1.0.tar.gz \
    my_extension.control \
    my_extension--1.0.sql \
    Makefile \
    my_extension.c
```

### 5.2 安装扩展

```sql
-- 从源码安装（带错误处理）
DO $$
BEGIN
    CREATE EXTENSION IF NOT EXISTS my_extension;
    RAISE NOTICE '扩展 my_extension 安装成功';
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '扩展 my_extension 已存在';
    WHEN OTHERS THEN
        RAISE WARNING '安装扩展失败: %', SQLERRM;
        RAISE;
END $$;

-- 从包安装（带错误处理）
-- 1. 解压到contrib目录
-- 2. make install
-- 3. 使用上面的CREATE EXTENSION命令（带错误处理）
```

### 5.3 版本升级

```sql
-- 检查当前版本（带错误处理和性能测试）
DO $$
DECLARE
    ext_version text;
BEGIN
    SELECT extversion INTO ext_version
    FROM pg_extension
    WHERE extname = 'my_extension';

    IF FOUND THEN
        RAISE NOTICE '当前扩展版本: %', ext_version;
    ELSE
        RAISE NOTICE '扩展 my_extension 未安装';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '检查版本时出错: %', SQLERRM;
END $$;

-- 升级扩展（带错误处理）
DO $$
BEGIN
    ALTER EXTENSION my_extension UPDATE TO '1.1';
    RAISE NOTICE '扩展升级成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '升级扩展失败: %', SQLERRM;
        RAISE;
END $$;

-- 查看升级历史（带性能测试）
EXPLAIN ANALYZE
SELECT * FROM pg_extension_update_paths('my_extension');
```

---

## 6. 最佳实践

### 6.1 开发规范

- ✅ **命名规范**: 使用清晰的命名约定
- ✅ **文档完善**: 提供完整的文档
- ✅ **错误处理**: 完善的错误处理机制
- ✅ **性能优化**: 考虑性能影响

### 6.2 测试策略

- ✅ **单元测试**: 为每个函数编写测试
- ✅ **集成测试**: 测试扩展与PostgreSQL的集成
- ✅ **性能测试**: 测试扩展的性能影响
- ✅ **兼容性测试**: 测试不同PostgreSQL版本

### 6.3 发布流程

- ✅ **版本管理**: 使用语义化版本
- ✅ **变更日志**: 维护详细的变更日志
- ✅ **许可证**: 明确许可证信息
- ✅ **社区支持**: 提供社区支持渠道

---

## 📚 相关文档

- [06-扩展系统/README.md](./README.md) - 扩展系统主题
- [29-社区生态/扩展生态全景图](../29-社区生态/扩展生态全景图.md) - 扩展生态
- [PostgreSQL官方扩展文档](https://www.postgresql.org/docs/current/extend.html) - 官方文档

---

**最后更新**: 2025年1月
**状态**: ✅ 完成
