---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL/03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.02-ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–

> **ç‰ˆæœ¬**: v3.1
> **æœ€åæ›´æ–°**: 2025-11-22
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­â­
> **åº”ç”¨åœºæ™¯**: ç´¢å¼•è®¾è®¡ã€æŸ¥è¯¢ä¼˜åŒ–ã€æ€§èƒ½è°ƒä¼˜
> ğŸ†• **PostgreSQL 18ç´¢å¼•ä¼˜åŒ–**: B-treeå»é‡ä¼˜åŒ–ï¼ˆç´¢å¼•å¤§å°å‡å°‘18%ï¼‰ã€BRINæ€§èƒ½æå‡15-20%ã€æ›´é«˜æ•ˆçš„ç´¢å¼•ç»´æŠ¤ã€å¼‚æ­¥I/Oæå‡ç´¢å¼•æ„å»ºé€Ÿåº¦40%+

---

## ğŸ“‹ ç›®å½•

- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](#ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ğŸ“Š æ€ç»´å¯¼å›¾](#-æ€ç»´å¯¼å›¾)
  - [ğŸ“Š å¤šç»´æ¦‚å¿µçŸ©é˜µå¯¹æ¯”](#-å¤šç»´æ¦‚å¿µçŸ©é˜µå¯¹æ¯”)
    - [ç´¢å¼•ç±»å‹å¯¹æ¯”çŸ©é˜µ](#ç´¢å¼•ç±»å‹å¯¹æ¯”çŸ©é˜µ)
    - [ç´¢å¼•ä¼˜åŒ–ç­–ç•¥å¯¹æ¯”çŸ©é˜µ](#ç´¢å¼•ä¼˜åŒ–ç­–ç•¥å¯¹æ¯”çŸ©é˜µ)
    - [ç´¢å¼•æ‰«æç±»å‹å¯¹æ¯”çŸ©é˜µ](#ç´¢å¼•æ‰«æç±»å‹å¯¹æ¯”çŸ©é˜µ)
  - [ğŸŒ Wikipediaå¯¹é½](#-wikipediaå¯¹é½)
    - [ç´¢å¼•ï¼ˆæ•°æ®åº“ï¼‰æ¦‚å¿µå¯¹é½](#ç´¢å¼•æ•°æ®åº“æ¦‚å¿µå¯¹é½)
    - [B+æ ‘æ¦‚å¿µå¯¹é½](#bæ ‘æ¦‚å¿µå¯¹é½)
    - [å“ˆå¸Œè¡¨æ¦‚å¿µå¯¹é½](#å“ˆå¸Œè¡¨æ¦‚å¿µå¯¹é½)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 æ ¸å¿ƒå±æ€§](#13-æ ¸å¿ƒå±æ€§)
  - [2. ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 B+æ ‘ç†è®º](#21-bæ ‘ç†è®º)
    - [2.2 å“ˆå¸Œç´¢å¼•ç†è®º](#22-å“ˆå¸Œç´¢å¼•ç†è®º)
    - [2.3 ç´¢å¼•é€‰æ‹©ç†è®º](#23-ç´¢å¼•é€‰æ‹©ç†è®º)
  - [3. PostgreSQLç´¢å¼•ç±»å‹](#3-postgresqlç´¢å¼•ç±»å‹)
    - [3.1 B+æ ‘ç´¢å¼•](#31-bæ ‘ç´¢å¼•)
    - [3.2 å“ˆå¸Œç´¢å¼•](#32-å“ˆå¸Œç´¢å¼•)
    - [4.3 è¡¨è¾¾å¼ç´¢å¼•](#43-è¡¨è¾¾å¼ç´¢å¼•)
      - [4.3.1 è¡¨è¾¾å¼ç´¢å¼•è¯¦è§£](#431-è¡¨è¾¾å¼ç´¢å¼•è¯¦è§£)
    - [4.4 è¦†ç›–ç´¢å¼•](#44-è¦†ç›–ç´¢å¼•)
      - [4.4.1 è¦†ç›–ç´¢å¼•è¯¦è§£](#441-è¦†ç›–ç´¢å¼•è¯¦è§£)
  - [5. ç´¢å¼•ç»´æŠ¤](#5-ç´¢å¼•ç»´æŠ¤)
    - [5.1 ç´¢å¼•é‡å»º](#51-ç´¢å¼•é‡å»º)
    - [5.2 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯](#52-ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯)
    - [5.3 ç´¢å¼•ç›‘æ§](#53-ç´¢å¼•ç›‘æ§)
      - [5.3.1 ç´¢å¼•ç›‘æ§è¯¦è§£](#531-ç´¢å¼•ç›‘æ§è¯¦è§£)
  - [6. ç´¢å¼•æ€§èƒ½åˆ†æ](#6-ç´¢å¼•æ€§èƒ½åˆ†æ)
    - [6.1 ç´¢å¼•é€‰æ‹©åˆ†æ](#61-ç´¢å¼•é€‰æ‹©åˆ†æ)
    - [6.2 ç´¢å¼•æ•ˆç‡åˆ†æ](#62-ç´¢å¼•æ•ˆç‡åˆ†æ)
    - [6.3 ç´¢å¼•å¤§å°åˆ†æ](#63-ç´¢å¼•å¤§å°åˆ†æ)
  - [7. é«˜çº§ç´¢å¼•æŠ€æœ¯](#7-é«˜çº§ç´¢å¼•æŠ€æœ¯)
    - [7.1 ä½å›¾ç´¢å¼•æ‰«æ](#71-ä½å›¾ç´¢å¼•æ‰«æ)
    - [7.2 ç´¢å¼•è·³è·ƒæ‰«æ](#72-ç´¢å¼•è·³è·ƒæ‰«æ)
    - [7.3 ç´¢å¼•åˆå¹¶](#73-ç´¢å¼•åˆå¹¶)
  - [8. PostgreSQL 18ç´¢å¼•ä¼˜åŒ–æ–°ç‰¹æ€§](#8-postgresql-18ç´¢å¼•ä¼˜åŒ–æ–°ç‰¹æ€§)
    - [8.1 B-treeå»é‡ä¼˜åŒ–](#81-b-treeå»é‡ä¼˜åŒ–)
    - [8.2 BRINæ€§èƒ½æå‡](#82-brinæ€§èƒ½æå‡)
    - [8.3 å¼‚æ­¥I/Oæå‡ç´¢å¼•æ„å»ºé€Ÿåº¦](#83-å¼‚æ­¥ioæå‡ç´¢å¼•æ„å»ºé€Ÿåº¦)
    - [8.4 æ›´é«˜æ•ˆçš„ç´¢å¼•ç»´æŠ¤](#84-æ›´é«˜æ•ˆçš„ç´¢å¼•ç»´æŠ¤)
    - [8.5 è™šæ‹Ÿç”Ÿæˆåˆ—ç´¢å¼•æ”¯æŒ](#85-è™šæ‹Ÿç”Ÿæˆåˆ—ç´¢å¼•æ”¯æŒ)
    - [8.6 PostgreSQL 18ç´¢å¼•ä¼˜åŒ–æœ€ä½³å®è·µ](#86-postgresql-18ç´¢å¼•ä¼˜åŒ–æœ€ä½³å®è·µ)
  - [9. ç´¢å¼•ä¼˜åŒ–å®è·µ](#9-ç´¢å¼•ä¼˜åŒ–å®è·µ)
    - [9.1 æŸ¥è¯¢ä¼˜åŒ–](#91-æŸ¥è¯¢ä¼˜åŒ–)
    - [9.2 æ‰¹é‡æ“ä½œä¼˜åŒ–](#92-æ‰¹é‡æ“ä½œä¼˜åŒ–)
    - [9.3 ç´¢å¼•ç»´æŠ¤ç­–ç•¥](#93-ç´¢å¼•ç»´æŠ¤ç­–ç•¥)
  - [10. å®é™…åº”ç”¨æ¡ˆä¾‹](#10-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [10.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡](#101-ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡)
      - [9.1.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ](#911-ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ)
    - [9.2 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡](#92-æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡)
      - [9.2.1 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ](#921-æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ)
  - [11. ç›¸å…³æ¦‚å¿µ](#11-ç›¸å…³æ¦‚å¿µ)
    - [11.1 ä¸Šä½æ¦‚å¿µ](#111-ä¸Šä½æ¦‚å¿µ)
    - [11.2 ä¸‹ä½æ¦‚å¿µ](#112-ä¸‹ä½æ¦‚å¿µ)
    - [11.3 å¹³è¡Œæ¦‚å¿µ](#113-å¹³è¡Œæ¦‚å¿µ)
  - [12. ç›¸å…³æ–‡æ¡£](#12-ç›¸å…³æ–‡æ¡£)
    - [11.1 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹](#111-å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹)
  - [13. å‚è€ƒæ–‡çŒ®](#13-å‚è€ƒæ–‡çŒ®)
  - [14. äº¤å‰å¼•ç”¨](#14-äº¤å‰å¼•ç”¨)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)
  - [15. Wikidataå¯¹é½](#15-wikidataå¯¹é½)
    - [14.1 ç´¢å¼•æ¦‚å¿µå¯¹é½](#141-ç´¢å¼•æ¦‚å¿µå¯¹é½)
    - [14.2 PostgreSQLç´¢å¼•å¯¹é½](#142-postgresqlç´¢å¼•å¯¹é½)
  - [16. å½¢å¼è¯æ˜ä¸ç†è®ºè®ºè¯](#16-å½¢å¼è¯æ˜ä¸ç†è®ºè®ºè¯)
    - [15.1 B+æ ‘æŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦è¯æ˜](#151-bæ ‘æŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦è¯æ˜)
    - [15.2 ç´¢å¼•é€‰æ‹©æœ€ä¼˜æ€§è¯æ˜](#152-ç´¢å¼•é€‰æ‹©æœ€ä¼˜æ€§è¯æ˜)
    - [15.3 å¤åˆç´¢å¼•åˆ—é¡ºåºä¼˜åŒ–å®šç†](#153-å¤åˆç´¢å¼•åˆ—é¡ºåºä¼˜åŒ–å®šç†)

---

## ğŸ“Š æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–))
    ç´¢å¼•ç±»å‹
      B+æ ‘ç´¢å¼•
        å¹³è¡¡æ ‘ç»“æ„
        èŒƒå›´æŸ¥è¯¢ä¼˜åŒ–
        æ’åºæ”¯æŒ
      å“ˆå¸Œç´¢å¼•
        ç­‰å€¼æŸ¥è¯¢
        O(1)æŸ¥æ‰¾
        å†…å­˜æ•ˆç‡
      GiSTç´¢å¼•
        é€šç”¨æœç´¢æ ‘
        ç©ºé—´æ•°æ®
        å…¨æ–‡æœç´¢
      GINç´¢å¼•
        å€’æ’ç´¢å¼•
        æ•°ç»„æŸ¥è¯¢
        å…¨æ–‡æœç´¢
      BRINç´¢å¼•
        å—èŒƒå›´ç´¢å¼•
        å¤§è¡¨ä¼˜åŒ–
        é¡ºåºæ•°æ®
    ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
      å¤åˆç´¢å¼•
        å¤šåˆ—ç´¢å¼•
        åˆ—é¡ºåºä¼˜åŒ–
        è¦†ç›–ç´¢å¼•
      éƒ¨åˆ†ç´¢å¼•
        æ¡ä»¶ç´¢å¼•
        ç©ºé—´ä¼˜åŒ–
        æ€§èƒ½æå‡
      è¡¨è¾¾å¼ç´¢å¼•
        å‡½æ•°ç´¢å¼•
        è®¡ç®—åˆ—ç´¢å¼•
        å¤æ‚æŸ¥è¯¢ä¼˜åŒ–
      è¦†ç›–ç´¢å¼•
        ç´¢å¼•åŒ…å«åˆ—
        é¿å…å›è¡¨
        æŸ¥è¯¢åŠ é€Ÿ
    ç´¢å¼•ç»´æŠ¤
      ç´¢å¼•é‡å»º
        REINDEX
        VACUUM
        ç¢ç‰‡æ•´ç†
      ç»Ÿè®¡ä¿¡æ¯
        ANALYZE
        æŸ¥è¯¢è®¡åˆ’
        ä»£ä»·ä¼°ç®—
      ç›‘æ§è¯Šæ–­
        ä½¿ç”¨ç‡åˆ†æ
        å¤§å°ç›‘æ§
        æ€§èƒ½åˆ†æ
    æ€§èƒ½åˆ†æ
      æŸ¥è¯¢ä¼˜åŒ–
        ç´¢å¼•é€‰æ‹©
        æ‰«æç±»å‹
        è¿æ¥ä¼˜åŒ–
      æ‰¹é‡æ“ä½œ
        æ‰¹é‡æ’å…¥
        æ‰¹é‡æ›´æ–°
        ç´¢å¼•ç»´æŠ¤
    é«˜çº§æŠ€æœ¯
      ä½å›¾æ‰«æ
        å¤šç´¢å¼•åˆå¹¶
        ORæ¡ä»¶ä¼˜åŒ–
      ç´¢å¼•è·³è·ƒ
        éƒ¨åˆ†ç´¢å¼•ä½¿ç”¨
        èŒƒå›´æŸ¥è¯¢
      ç´¢å¼•åˆå¹¶
        å¤šç´¢å¼•ç»„åˆ
        æŸ¥è¯¢é‡å†™
```

---

## ğŸ“Š å¤šç»´æ¦‚å¿µçŸ©é˜µå¯¹æ¯”

### ç´¢å¼•ç±»å‹å¯¹æ¯”çŸ©é˜µ

| ç´¢å¼•ç±»å‹ | æ•°æ®ç»“æ„ | æŸ¥è¯¢ç±»å‹ | æ’å…¥æ€§èƒ½ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | PostgreSQLæ”¯æŒ |
|---------|---------|---------|---------|-----------|---------|---------------|
| **B+æ ‘ç´¢å¼•** | å¹³è¡¡æ ‘ | ç­‰å€¼ã€èŒƒå›´ã€æ’åº | O(log n) | O(n) | é€šç”¨åœºæ™¯ | âœ… é»˜è®¤ |
| **å“ˆå¸Œç´¢å¼•** | å“ˆå¸Œè¡¨ | ç­‰å€¼æŸ¥è¯¢ | O(1) | O(n) | ç­‰å€¼æŸ¥è¯¢ | âœ… æ”¯æŒ |
| **GiSTç´¢å¼•** | é€šç”¨æœç´¢æ ‘ | ç©ºé—´ã€å…¨æ–‡ã€è‡ªå®šä¹‰ | O(log n) | O(n) | ç©ºé—´æ•°æ®ã€å…¨æ–‡æœç´¢ | âœ… æ‰©å±• |
| **GINç´¢å¼•** | å€’æ’ç´¢å¼• | å…¨æ–‡ã€æ•°ç»„ã€JSONB | O(log n) | O(n) | å…¨æ–‡æœç´¢ã€æ•°ç»„æŸ¥è¯¢ | âœ… æ‰©å±• |
| **BRINç´¢å¼•** | å—èŒƒå›´ç´¢å¼• | èŒƒå›´æŸ¥è¯¢ | O(1) | O(1) | å¤§è¡¨ã€é¡ºåºæ•°æ® | âœ… æ”¯æŒ |
| **SP-GiSTç´¢å¼•** | ç©ºé—´åˆ†åŒºæ ‘ | ç©ºé—´ã€æ–‡æœ¬ | O(log n) | O(n) | éå¹³è¡¡æ•°æ® | âœ… æ‰©å±• |

### ç´¢å¼•ä¼˜åŒ–ç­–ç•¥å¯¹æ¯”çŸ©é˜µ

| ä¼˜åŒ–ç­–ç•¥ | ç©ºé—´å¼€é”€ | æŸ¥è¯¢æ€§èƒ½ | ç»´æŠ¤æˆæœ¬ | é€‚ç”¨åœºæ™¯ | PostgreSQLç‰¹æ€§ |
| --- | --- | --- | --- | --- | --- |
| **æ ‡å‡†ç´¢å¼•** | ä¸­ç­‰ | é«˜ | ä½ | é€šç”¨åœºæ™¯ | âœ… é»˜è®¤ |
| **å¤åˆç´¢å¼•** | é«˜ | å¾ˆé«˜ | ä¸­ | å¤šåˆ—æŸ¥è¯¢ | âœ… æ”¯æŒ |
| **éƒ¨åˆ†ç´¢å¼•** | ä½ | é«˜ | ä½ | æ¡ä»¶æŸ¥è¯¢ | âœ… æ”¯æŒ |
| **è¡¨è¾¾å¼ç´¢å¼•** | ä¸­ç­‰ | é«˜ | ä¸­ | å‡½æ•°æŸ¥è¯¢ | âœ… æ”¯æŒ |
| **è¦†ç›–ç´¢å¼•** | é«˜ | æé«˜ | ä¸­ | åªè¯»æŸ¥è¯¢ | âœ… INCLUDEåˆ— |
| **å”¯ä¸€ç´¢å¼•** | ä¸­ç­‰ | é«˜ | ä½ | å”¯ä¸€çº¦æŸ | âœ… æ”¯æŒ |

### ç´¢å¼•æ‰«æç±»å‹å¯¹æ¯”çŸ©é˜µ

| æ‰«æç±»å‹ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜åŒ–å™¨é€‰æ‹© |
| --- | --- | --- | --- | --- |
| **Index Scan** | O(log n) | O(1) | å•å€¼æŸ¥è¯¢ | ç­‰å€¼æŸ¥è¯¢ |
| **Index Only Scan** | O(log n) | O(1) | è¦†ç›–ç´¢å¼• | åŒ…å«æ‰€æœ‰åˆ— |
| **Bitmap Index Scan** | O(log n) | O(n) | å¤šæ¡ä»¶OR | ORæ¡ä»¶ |
| **Sequential Scan** | O(n) | O(1) | å…¨è¡¨æ‰«æ | å°è¡¨æˆ–æ— æ¡ä»¶ |

---

## ğŸŒ Wikipediaå¯¹é½

### ç´¢å¼•ï¼ˆæ•°æ®åº“ï¼‰æ¦‚å¿µå¯¹é½

**Wikipediaå®šä¹‰**: [Database index](https://en.wikipedia.org/wiki/Database_index)

> A database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure.

**å¯¹é½è¯´æ˜**:

- âœ… **å®šä¹‰ä¸€è‡´æ€§**: æœ¬æ–‡æ¡£çš„å®šä¹‰ä¸Wikipediaä¸€è‡´ï¼Œéƒ½å¼ºè°ƒç´¢å¼•æ˜¯ç”¨äºåŠ é€Ÿæ•°æ®æ£€ç´¢çš„æ•°æ®ç»“æ„
- âœ… **æ ¸å¿ƒå±æ€§**: éƒ½æåˆ°ç´¢å¼•çš„æƒè¡¡ï¼ˆç©ºé—´æ¢æ—¶é—´ï¼‰
- âœ… **å®ç°æ–¹å¼**: PostgreSQLçš„B+æ ‘ç´¢å¼•å®ç°ç¬¦åˆWikipediaæè¿°çš„ç´¢å¼•ç»“æ„

### B+æ ‘æ¦‚å¿µå¯¹é½

**Wikipediaå®šä¹‰**: [B+ tree](https://en.wikipedia.org/wiki/B%2B_tree)

> A B+ tree is an m-ary tree with a variable but often large number of children per node. A B+ tree consists of a root, internal nodes and leaves. The root may be either a leaf or a node with two or more children.

**å¯¹é½è¯´æ˜**:

- âœ… **ç»“æ„å®šä¹‰**: PostgreSQLçš„B+æ ‘å®ç°ç¬¦åˆWikipediaçš„B+æ ‘å®šä¹‰
- âœ… **èŠ‚ç‚¹ç±»å‹**: éƒ½åŒ…å«æ ¹èŠ‚ç‚¹ã€å†…éƒ¨èŠ‚ç‚¹å’Œå¶å­èŠ‚ç‚¹
- âœ… **å¹³è¡¡æ€§**: éƒ½å¼ºè°ƒB+æ ‘çš„å¹³è¡¡ç‰¹æ€§

### å“ˆå¸Œè¡¨æ¦‚å¿µå¯¹é½

**Wikipediaå®šä¹‰**: [Hash table](https://en.wikipedia.org/wiki/Hash_table)

> A hash table is a data structure that implements an associative array abstract data type, a structure that can map keys to values.

**å¯¹é½è¯´æ˜**:

- âœ… **æ˜ å°„å…³ç³»**: PostgreSQLçš„å“ˆå¸Œç´¢å¼•å®ç°äº†é”®å€¼æ˜ å°„
- âœ… **æŸ¥æ‰¾æ€§èƒ½**: O(1)å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸Wikipediaæè¿°ä¸€è‡´

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: ç´¢å¼•ç»“æ„æ˜¯æ•°æ®åº“ç³»ç»Ÿä¸­ç”¨äºåŠ é€Ÿæ•°æ®è®¿é—®çš„æ•°æ®ç»“æ„ï¼Œé€šè¿‡å»ºç«‹é”®å€¼åˆ°æ•°æ®ä½ç½®çš„æ˜ å°„å…³ç³»æé«˜æŸ¥è¯¢æ€§èƒ½ã€‚PostgreSQLæ”¯æŒå¤šç§ç´¢å¼•ç±»å‹ï¼ŒåŒ…æ‹¬B+æ ‘ã€å“ˆå¸Œã€GiSTã€GINç­‰ã€‚

**English Definition**: Index structures are data structures in database systems used to accelerate data access by establishing mapping relationships between keys and data locations to improve query performance. PostgreSQL supports multiple index types including B+tree, Hash, GiST, GIN, etc.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\index}{\mathcal{I}}
\newcommand{\key}{\mathcal{K}}
\newcommand{\pointer}{\mathcal{P}}
\newcommand{\tuple}{\mathcal{T}}

% ç´¢å¼•çš„å½¢å¼åŒ–å®šä¹‰
\index = \{(k_1, p_1), (k_2, p_2), \ldots, (k_n, p_n)\}

å…¶ä¸­ï¼š
k_i \in \key: ç´¢å¼•é”®å€¼
p_i \in \pointer: æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆ
\forall i \neq j: k_i \neq k_j \text{ (å”¯ä¸€æ€§çº¦æŸ)}
```

### 1.3 æ ¸å¿ƒå±æ€§

- **å¿«é€ŸæŸ¥æ‰¾**: O(log n) æ—¶é—´å¤æ‚åº¦
- **ç©ºé—´æ•ˆç‡**: åˆç†çš„å­˜å‚¨å¼€é”€
- **åŠ¨æ€æ›´æ–°**: æ”¯æŒæ’å…¥ã€åˆ é™¤ã€æ›´æ–°
- **å¹¶å‘å®‰å…¨**: æ”¯æŒå¹¶å‘è®¿é—®

## 2. ç†è®ºåŸºç¡€

### 2.1 B+æ ‘ç†è®º

```latex
\begin{theorem}[B+æ ‘æ€§è´¨]
B+æ ‘æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š
1. æ‰€æœ‰å¶å­èŠ‚ç‚¹åœ¨åŒä¸€å±‚
2. éå¶å­èŠ‚ç‚¹åªå­˜å‚¨é”®å€¼
3. å¶å­èŠ‚ç‚¹åŒ…å«æ‰€æœ‰æ•°æ®
4. æ”¯æŒèŒƒå›´æŸ¥è¯¢å’Œé¡ºåºè®¿é—®
5. æ ‘é«˜ä¸º O(\log n)
\end{theorem}

\begin{proof}
åŸºäºB+æ ‘çš„å¹³è¡¡æ€§è´¨å’ŒèŠ‚ç‚¹åˆ†è£‚åˆå¹¶è§„åˆ™ï¼Œå¯ä»¥è¯æ˜B+æ ‘çš„æ­£ç¡®æ€§ã€‚
\end{proof}
```

### 2.2 å“ˆå¸Œç´¢å¼•ç†è®º

```latex
\begin{theorem}[å“ˆå¸Œç´¢å¼•]
å“ˆå¸Œç´¢å¼•é€šè¿‡å“ˆå¸Œå‡½æ•°å®ç°ï¼š
1. å¹³å‡æŸ¥æ‰¾æ—¶é—´ï¼šO(1)
2. ä¸æ”¯æŒèŒƒå›´æŸ¥è¯¢
3. å“ˆå¸Œå†²çªå¤„ç†ï¼šé“¾å¼æ³•æˆ–å¼€æ”¾åœ°å€æ³•
4. è´Ÿè½½å› å­å½±å“æ€§èƒ½
\end{theorem}
```

### 2.3 ç´¢å¼•é€‰æ‹©ç†è®º

```latex
\begin{theorem}[ç´¢å¼•é€‰æ‹©æ€§]
ç´¢å¼•Iå¯¹æŸ¥è¯¢Qçš„é€‰æ‹©æ€§ä¸ºï¼š
\text{Selectivity}(I, Q) = \frac{|\sigma_p(R)|}{|R|}

å…¶ä¸­pæ˜¯Qçš„è°“è¯æ¡ä»¶ï¼Œé€‰æ‹©æ€§è¶Šé«˜ï¼Œç´¢å¼•æ•ˆæœè¶Šå¥½ã€‚
\end{theorem}
```

## 3. PostgreSQLç´¢å¼•ç±»å‹

### 3.1 B+æ ‘ç´¢å¼•

```sql
-- åˆ›å»ºB+æ ‘ç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_salary') THEN
            CREATE INDEX idx_emp_salary ON employees (salary);
            RAISE NOTICE 'ç´¢å¼• idx_emp_salary åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_emp_salary å·²å­˜åœ¨';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept_salary') THEN
            CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
            RAISE NOTICE 'ç´¢å¼• idx_emp_dept_salary åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_emp_dept_salary å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'éƒ¨åˆ†ç´¢å¼•å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æŸ¥çœ‹ç´¢å¼•ä¿¡æ¯ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    index_count INT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æŸ¥çœ‹ç´¢å¼•ä¿¡æ¯';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO index_count
        FROM pg_indexes
        WHERE tablename = 'employees';

        IF index_count > 0 THEN
            RAISE NOTICE 'æ‰¾åˆ° % ä¸ªç´¢å¼•', index_count;
        ELSE
            RAISE WARNING 'è¡¨ employees æ²¡æœ‰ç´¢å¼•';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥çœ‹ç´¢å¼•ä¿¡æ¯å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN ANALYZE
SELECT
    indexname,
    indexdef,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as size
FROM pg_indexes
WHERE tablename = 'employees';

-- ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    stat_count INT;
BEGIN
    BEGIN
        SELECT COUNT(*) INTO stat_count
        FROM pg_stat_user_indexes
        WHERE schemaname = 'public' AND tablename = 'employees';

        IF stat_count > 0 THEN
            RAISE NOTICE 'æ‰¾åˆ° % ä¸ªç´¢å¼•çš„ç»Ÿè®¡ä¿¡æ¯', stat_count;
        ELSE
            RAISE WARNING 'æœªæ‰¾åˆ°ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥çœ‹ç´¢å¼•ç»Ÿè®¡å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN ANALYZE
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'employees'
ORDER BY idx_scan DESC;
```

### 3.2 å“ˆå¸Œç´¢å¼•

```sql
-- åˆ›å»ºå“ˆå¸Œç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºå“ˆå¸Œç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_id_hash') THEN
            CREATE INDEX idx_emp_id_hash ON employees USING HASH (emp_id);
            RAISE NOTICE 'å“ˆå¸Œç´¢å¼• idx_emp_id_hash åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_emp_id_hash å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_emp_id_hash å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºå“ˆå¸Œç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å“ˆå¸Œç´¢å¼•ä½¿ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•ä½¿ç”¨å“ˆå¸Œç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_id_hash') THEN
            RAISE WARNING 'ç´¢å¼• idx_emp_id_hash ä¸å­˜åœ¨ï¼ŒæŸ¥è¯¢å¯èƒ½è¾ƒæ…¢';
        END IF;
        RAISE NOTICE 'å¼€å§‹æµ‹è¯•å“ˆå¸Œç´¢å¼•æŸ¥è¯¢æ€§èƒ½';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å“ˆå¸Œç´¢å¼•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE emp_id = 1001;

### 3.3 GiSTç´¢å¼•

```sql
-- åˆ›å»ºGiSTç´¢å¼•ï¼ˆå‡ ä½•æ•°æ®ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'spatial_data') THEN
            RAISE NOTICE 'è¡¨ spatial_data å·²å­˜åœ¨';
        ELSE
            CREATE TABLE spatial_data (
                id SERIAL PRIMARY KEY,
                name VARCHAR(100),
                location POINT
            );
            RAISE NOTICE 'è¡¨ spatial_data åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ spatial_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'spatial_data' AND indexname = 'idx_spatial_location') THEN
            CREATE INDEX idx_spatial_location ON spatial_data USING GIST (location);
            RAISE NOTICE 'GiSTç´¢å¼• idx_spatial_location åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_spatial_location å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ spatial_data ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_spatial_location å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºGiSTç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç©ºé—´æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'spatial_data') THEN
            RAISE WARNING 'è¡¨ spatial_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç©ºé—´æŸ¥è¯¢';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'spatial_data' AND indexname = 'idx_spatial_location') THEN
            RAISE WARNING 'GiSTç´¢å¼• idx_spatial_location ä¸å­˜åœ¨ï¼ŒæŸ¥è¯¢å¯èƒ½è¾ƒæ…¢';
        END IF;
        RAISE NOTICE 'å¼€å§‹æµ‹è¯•ç©ºé—´æŸ¥è¯¢æ€§èƒ½';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•ç©ºé—´æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM spatial_data
WHERE location <@ box '((0,0),(100,100))';

### 3.4 GINç´¢å¼•

```sql
-- åˆ›å»ºGINç´¢å¼•ï¼ˆæ•°ç»„æ•°æ®ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE NOTICE 'è¡¨ documents å·²å­˜åœ¨';
        ELSE
            CREATE TABLE documents (
                id SERIAL PRIMARY KEY,
                title VARCHAR(200),
                tags TEXT[]
            );
            RAISE NOTICE 'è¡¨ documents åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ documents å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'documents' AND indexname = 'idx_doc_tags') THEN
            CREATE INDEX idx_doc_tags ON documents USING GIN (tags);
            RAISE NOTICE 'GINç´¢å¼• idx_doc_tags åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_doc_tags å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ documents ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_doc_tags å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºGINç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ•°ç»„æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING 'è¡¨ documents ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ•°ç»„æŸ¥è¯¢';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'documents' AND indexname = 'idx_doc_tags') THEN
            RAISE WARNING 'GINç´¢å¼• idx_doc_tags ä¸å­˜åœ¨ï¼ŒæŸ¥è¯¢å¯èƒ½è¾ƒæ…¢';
        END IF;
        RAISE NOTICE 'å¼€å§‹æµ‹è¯•æ•°ç»„æŸ¥è¯¢æ€§èƒ½';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•æ•°ç»„æŸ¥è¯¢å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM documents WHERE tags @> ARRAY['postgresql', 'database'];

## 4. ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

### 4.1 å¤åˆç´¢å¼•è®¾è®¡

```sql
-- å¤åˆç´¢å¼•è®¾è®¡åŸåˆ™ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºå¤åˆç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_optimized') THEN
            CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);
            RAISE NOTICE 'å¤åˆç´¢å¼• idx_emp_optimized åˆ›å»ºæˆåŠŸ';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_emp_optimized å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_emp_optimized å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºå¤åˆç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æœ€å·¦å‰ç¼€åŸåˆ™ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æµ‹è¯•æœ€å·¦å‰ç¼€åŸåˆ™';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æµ‹è¯•æœ€å·¦å‰ç¼€åŸåˆ™ï¼ˆä½¿ç”¨ç´¢å¼•ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1;  -- ä½¿ç”¨ç´¢å¼•

-- ä¸ä½¿ç”¨ç´¢å¼•çš„æƒ…å†µï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            RETURN;
        END IF;
        RAISE NOTICE 'æµ‹è¯•ä¸ä½¿ç”¨ç´¢å¼•çš„æƒ…å†µï¼ˆsalary > 50000ï¼Œä¸ç¬¦åˆæœ€å·¦å‰ç¼€ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000;  -- ä¸ä½¿ç”¨ç´¢å¼•

-- ä½¿ç”¨ç´¢å¼•çš„æƒ…å†µï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            RETURN;
        END IF;
        RAISE NOTICE 'æµ‹è¯•ä½¿ç”¨ç´¢å¼•çš„æƒ…å†µï¼ˆdept_id + salaryï¼Œç¬¦åˆæœ€å·¦å‰ç¼€ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;  -- ä½¿ç”¨ç´¢å¼•

#### 4.1.1 å¤åˆç´¢å¼•è®¾è®¡åŸåˆ™è¯¦è§£

**åˆ—é¡ºåºé€‰æ‹©åŸåˆ™**:

1. **é€‰æ‹©æ€§åŸåˆ™**: é€‰æ‹©æ€§é«˜çš„åˆ—æ”¾åœ¨å‰é¢
   - é€‰æ‹©æ€§ = ä¸åŒå€¼æ•°é‡ / æ€»è¡Œæ•°
   - é€‰æ‹©æ€§è¶Šé«˜ï¼Œè¿‡æ»¤æ•ˆæœè¶Šå¥½

    ```sql
    -- åˆ†æåˆ—é€‰æ‹©æ€§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
    DO $$
    DECLARE
        stats_count INT;
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ†æåˆ—é€‰æ‹©æ€§';
                RETURN;
            END IF;

            SELECT COUNT(*) INTO stats_count
            FROM pg_stats
            WHERE schemaname = 'public'
            AND tablename = 'employees'
            AND attname IN ('dept_id', 'salary', 'hire_date');

            IF stats_count > 0 THEN
                RAISE NOTICE 'æ‰¾åˆ° % ä¸ªåˆ—çš„ç»Ÿè®¡ä¿¡æ¯', stats_count;
            ELSE
                RAISE WARNING 'åˆ—ç»Ÿè®¡ä¿¡æ¯ä¸å­˜åœ¨ï¼Œå¯èƒ½éœ€è¦è¿è¡ŒANALYZE';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ†æåˆ—é€‰æ‹©æ€§å‡†å¤‡å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;

    EXPLAIN ANALYZE
    SELECT
        attname,
        n_distinct,
        round(100.0 * n_distinct / NULLIF(n_live_tup, 0), 2) as selectivity_pct,
        correlation
    FROM pg_stats
    WHERE schemaname = 'public'
    AND tablename = 'employees'
    AND attname IN ('dept_id', 'salary', 'hire_date')
    ORDER BY n_distinct DESC;

    -- æ ¹æ®é€‰æ‹©æ€§åˆ›å»ºç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
                RETURN;
            END IF;

            -- dept_idé€‰æ‹©æ€§é«˜ï¼ˆå‡è®¾æœ‰100ä¸ªéƒ¨é—¨ï¼‰ï¼Œæ”¾åœ¨å‰é¢
            -- salaryé€‰æ‹©æ€§ä¸­ç­‰ï¼Œæ”¾åœ¨ä¸­é—´
            -- hire_dateé€‰æ‹©æ€§ä½ï¼ˆæ—¥æœŸèŒƒå›´ï¼‰ï¼Œæ”¾åœ¨åé¢
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept_salary_date') THEN
                CREATE INDEX idx_emp_dept_salary_date ON employees (dept_id, salary, hire_date);
                RAISE NOTICE 'å¤åˆç´¢å¼• idx_emp_dept_salary_date åˆ›å»ºæˆåŠŸï¼ˆæŒ‰é€‰æ‹©æ€§æ’åºï¼‰';
            ELSE
                RAISE NOTICE 'ç´¢å¼• idx_emp_dept_salary_date å·²å­˜åœ¨';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'ç´¢å¼• idx_emp_dept_salary_date å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;
    ```

2. **æŸ¥è¯¢é¢‘ç‡åŸåˆ™**: ç»å¸¸ä¸€èµ·æŸ¥è¯¢çš„åˆ—ç»„åˆåœ¨ä¸€èµ·

    ```sql
    -- åˆ†ææŸ¥è¯¢æ¨¡å¼ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
    DO $$
    DECLARE
        stats_count INT;
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ†ææŸ¥è¯¢æ¨¡å¼';
                RETURN;
            END IF;

            SELECT COUNT(*) INTO stats_count
            FROM pg_stats
            WHERE schemaname = 'public'
            AND tablename = 'employees';

            IF stats_count > 0 THEN
                RAISE NOTICE 'æ‰¾åˆ° % ä¸ªåˆ—çš„ç»Ÿè®¡ä¿¡æ¯ç”¨äºæŸ¥è¯¢æ¨¡å¼åˆ†æ', stats_count;
            ELSE
                RAISE WARNING 'åˆ—ç»Ÿè®¡ä¿¡æ¯ä¸å­˜åœ¨ï¼Œå¯èƒ½éœ€è¦è¿è¡ŒANALYZE';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ†ææŸ¥è¯¢æ¨¡å¼å‡†å¤‡å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;

    EXPLAIN ANALYZE
    SELECT
        schemaname,
        tablename,
        attname,
        n_distinct,
        most_common_vals,
        most_common_freqs
    FROM pg_stats
    WHERE schemaname = 'public'
    AND tablename = 'employees';

    -- æ ¹æ®æŸ¥è¯¢æ¨¡å¼åˆ›å»ºç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
                RETURN;
            END IF;

            -- å¦‚æœç»å¸¸æŸ¥è¯¢ dept_id + salaryï¼Œåˆ›å»ºå¤åˆç´¢å¼•
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept_salary') THEN
                CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
                RAISE NOTICE 'å¤åˆç´¢å¼• idx_emp_dept_salary åˆ›å»ºæˆåŠŸ';
            ELSE
                RAISE NOTICE 'ç´¢å¼• idx_emp_dept_salary å·²å­˜åœ¨';
            END IF;

            -- å¦‚æœç»å¸¸å•ç‹¬æŸ¥è¯¢ dept_idï¼Œä¹Ÿå¯ä»¥å•ç‹¬åˆ›å»ºç´¢å¼•
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept') THEN
                CREATE INDEX idx_emp_dept ON employees (dept_id);
                RAISE NOTICE 'å•åˆ—ç´¢å¼• idx_emp_dept åˆ›å»ºæˆåŠŸ';
            ELSE
                RAISE NOTICE 'ç´¢å¼• idx_emp_dept å·²å­˜åœ¨';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'éƒ¨åˆ†ç´¢å¼•å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;
    ```

3. **ç­‰å€¼æŸ¥è¯¢ä¼˜å…ˆåŸåˆ™**: ç­‰å€¼æŸ¥è¯¢çš„åˆ—æ”¾åœ¨èŒƒå›´æŸ¥è¯¢åˆ—ä¹‹å‰

    ```sql
    -- æ­£ç¡®ï¼šç­‰å€¼åˆ—åœ¨å‰ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
                RETURN;
            END IF;

            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept_salary') THEN
                CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
                RAISE NOTICE 'ç´¢å¼• idx_emp_dept_salary åˆ›å»ºæˆåŠŸï¼ˆç­‰å€¼åˆ—åœ¨å‰ï¼Œæ­£ç¡®ç¤ºä¾‹ï¼‰';
            ELSE
                RAISE NOTICE 'ç´¢å¼• idx_emp_dept_salary å·²å­˜åœ¨';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'ç´¢å¼• idx_emp_dept_salary å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;
    -- æŸ¥è¯¢ï¼šWHERE dept_id = 1 AND salary > 50000 âœ“ å¯ä»¥ä½¿ç”¨ç´¢å¼•

    -- é”™è¯¯ï¼šèŒƒå›´åˆ—åœ¨å‰ï¼ˆä¸æ¨èï¼Œä»…ä½œå¯¹æ¯”ç¤ºä¾‹ï¼‰
    -- CREATE INDEX idx_emp_salary_dept ON employees (salary, dept_id);
    -- æŸ¥è¯¢ï¼šWHERE dept_id = 1 AND salary > 50000 âœ— åªèƒ½éƒ¨åˆ†ä½¿ç”¨ç´¢å¼•
    ```

    **å¤åˆç´¢å¼•ä½¿ç”¨åœºæ™¯**:

    ```sql
    -- åœºæ™¯1: å¤šåˆ—ç­‰å€¼æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
                RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
                RETURN;
            END IF;

            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'orders' AND indexname = 'idx_orders_customer_status') THEN
                CREATE INDEX idx_orders_customer_status ON orders (customer_id, status);
                RAISE NOTICE 'ç´¢å¼• idx_orders_customer_status åˆ›å»ºæˆåŠŸï¼ˆå¤šåˆ—ç­‰å€¼æŸ¥è¯¢ï¼‰';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'ç´¢å¼• idx_orders_customer_status å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;
    -- æŸ¥è¯¢ï¼šWHERE customer_id = 100 AND status = 'pending'

    -- åœºæ™¯2: ç­‰å€¼ + èŒƒå›´æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
                RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
                RETURN;
            END IF;

            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'orders' AND indexname = 'idx_orders_customer_date') THEN
                CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);
                RAISE NOTICE 'ç´¢å¼• idx_orders_customer_date åˆ›å»ºæˆåŠŸï¼ˆç­‰å€¼+èŒƒå›´æŸ¥è¯¢ï¼‰';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'ç´¢å¼• idx_orders_customer_date å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;
    -- æŸ¥è¯¢ï¼šWHERE customer_id = 100 AND order_date >= '2024-01-01'

    -- åœºæ™¯3: ç­‰å€¼ + æ’åºï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
                RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
                RETURN;
            END IF;

            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'orders' AND indexname = 'idx_orders_customer_date_desc') THEN
                CREATE INDEX idx_orders_customer_date_desc ON orders (customer_id, order_date DESC);
                RAISE NOTICE 'ç´¢å¼• idx_orders_customer_date_desc åˆ›å»ºæˆåŠŸï¼ˆç­‰å€¼+æ’åºï¼‰';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'ç´¢å¼• idx_orders_customer_date_desc å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;
    -- æŸ¥è¯¢ï¼šWHERE customer_id = 100 ORDER BY order_date DESC

    -- åœºæ™¯4: å¤šåˆ—æ’åºï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
                RAISE WARNING 'è¡¨ products ä¸å­˜åœ¨';
                RETURN;
            END IF;

            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'products' AND indexname = 'idx_products_category_price') THEN
                CREATE INDEX idx_products_category_price ON products (category_id, price, created_at);
                RAISE NOTICE 'ç´¢å¼• idx_products_category_price åˆ›å»ºæˆåŠŸï¼ˆå¤šåˆ—æ’åºï¼‰';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ products ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'ç´¢å¼• idx_products_category_price å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;
    -- æŸ¥è¯¢ï¼šWHERE category_id = 1 ORDER BY price, created_at
    ```

    **å¤åˆç´¢å¼•æ€§èƒ½å¯¹æ¯”**:

    ```sql
    -- æµ‹è¯•å•åˆ—ç´¢å¼• vs å¤åˆç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
                RETURN;
            END IF;

            -- å•åˆ—ç´¢å¼•æ–¹æ¡ˆ
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept') THEN
                CREATE INDEX idx_emp_dept ON employees (dept_id);
                RAISE NOTICE 'å•åˆ—ç´¢å¼• idx_emp_dept åˆ›å»ºæˆåŠŸ';
            END IF;

            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_salary') THEN
                CREATE INDEX idx_emp_salary ON employees (salary);
                RAISE NOTICE 'å•åˆ—ç´¢å¼• idx_emp_salary åˆ›å»ºæˆåŠŸ';
            END IF;

            -- å¤åˆç´¢å¼•æ–¹æ¡ˆ
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_emp_dept_salary') THEN
                CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);
                RAISE NOTICE 'å¤åˆç´¢å¼• idx_emp_dept_salary åˆ›å»ºæˆåŠŸ';
            END IF;
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            WHEN duplicate_table THEN
                RAISE WARNING 'éƒ¨åˆ†ç´¢å¼•å·²å­˜åœ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;

    -- æŸ¥è¯¢1: åªä½¿ç”¨dept_idï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
                RETURN;
            END IF;
            RAISE NOTICE 'æµ‹è¯•æŸ¥è¯¢1ï¼šåªä½¿ç”¨dept_idï¼ˆå•åˆ—ç´¢å¼•ï¼šIndex Scanï¼Œå¤åˆç´¢å¼•ï¼šåŒæ ·é«˜æ•ˆï¼‰';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;

    EXPLAIN (ANALYZE, BUFFERS)
    SELECT * FROM employees WHERE dept_id = 1;
    -- å•åˆ—ç´¢å¼•ï¼šIndex Scan using idx_emp_dept
    -- å¤åˆç´¢å¼•ï¼šIndex Scan using idx_emp_dept_salaryï¼ˆåŒæ ·é«˜æ•ˆï¼‰

    -- æŸ¥è¯¢2: ä½¿ç”¨dept_idå’Œsalaryï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
    DO $$
    BEGIN
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
                RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
                RETURN;
            END IF;
            RAISE NOTICE 'æµ‹è¯•æŸ¥è¯¢2ï¼šä½¿ç”¨dept_idå’Œsalaryï¼ˆå•åˆ—ç´¢å¼•ï¼šBitmap Index Scanï¼Œå¤åˆç´¢å¼•ï¼šæ›´é«˜æ•ˆï¼‰';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
                RAISE;
        END;
    END $$;

    EXPLAIN (ANALYZE, BUFFERS)
    SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;
    -- å•åˆ—ç´¢å¼•ï¼šBitmap Index Scanï¼ˆéœ€è¦åˆå¹¶ä¸¤ä¸ªç´¢å¼•ï¼‰
    -- å¤åˆç´¢å¼•ï¼šIndex Scan using idx_emp_dept_salaryï¼ˆæ›´é«˜æ•ˆï¼‰

    -- æŸ¥è¯¢3: åªä½¿ç”¨salary
    EXPLAIN (ANALYZE, BUFFERS)
    SELECT * FROM employees WHERE salary > 50000;
    -- å•åˆ—ç´¢å¼•ï¼šIndex Scan using idx_emp_salary
    -- å¤åˆç´¢å¼•ï¼šSeq Scanï¼ˆæ— æ³•ä½¿ç”¨å¤åˆç´¢å¼•ï¼‰
    ```

### 4.2 éƒ¨åˆ†ç´¢å¼•

```sql
-- åˆ›å»ºéƒ¨åˆ†ç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºéƒ¨åˆ†ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_high_salary') THEN
            CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;
            RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_high_salary åˆ›å»ºæˆåŠŸï¼ˆåªç´¢å¼•salary > 100000çš„è¡Œï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_high_salary å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_high_salary å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºéƒ¨åˆ†ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- éƒ¨åˆ†ç´¢å¼•ä½¿ç”¨ï¼ˆä½¿ç”¨ç´¢å¼•çš„æƒ…å†µï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_high_salary') THEN
            RAISE WARNING 'éƒ¨åˆ†ç´¢å¼• idx_high_salary ä¸å­˜åœ¨';
        END IF;
        RAISE NOTICE 'æµ‹è¯•éƒ¨åˆ†ç´¢å¼•ä½¿ç”¨ï¼ˆsalary > 150000ï¼Œåº”è¯¥ä½¿ç”¨ç´¢å¼•ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 150000;  -- ä½¿ç”¨ç´¢å¼•

-- ä¸ä½¿ç”¨ç´¢å¼•çš„æƒ…å†µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            RETURN;
        END IF;
        RAISE NOTICE 'æµ‹è¯•éƒ¨åˆ†ç´¢å¼•ä¸ä½¿ç”¨çš„æƒ…å†µï¼ˆsalary < 50000ï¼Œä¸ä½¿ç”¨ç´¢å¼•ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary < 50000;  -- ä¸ä½¿ç”¨ç´¢å¼•

#### 4.2.1 éƒ¨åˆ†ç´¢å¼•è¯¦è§£

**éƒ¨åˆ†ç´¢å¼•çš„ä¼˜åŠ¿**:

1. **å‡å°‘ç´¢å¼•å¤§å°**: åªç´¢å¼•æ»¡è¶³æ¡ä»¶çš„è¡Œ
2. **æå‡ç»´æŠ¤æ€§èƒ½**: æ’å…¥/æ›´æ–°ä¸æ»¡è¶³æ¡ä»¶çš„è¡Œæ—¶ä¸éœ€è¦æ›´æ–°ç´¢å¼•
3. **æé«˜æŸ¥è¯¢æ€§èƒ½**: ç´¢å¼•æ›´å°ï¼Œæ‰«ææ›´å¿«

**ä½¿ç”¨åœºæ™¯**:

```sql
-- åœºæ™¯1: æ´»è·ƒæ•°æ®ç´¢å¼•ï¼ˆåªç´¢å¼•æœªåˆ é™¤çš„è®°å½•ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºéƒ¨åˆ†ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'orders' AND indexname = 'idx_orders_active') THEN
            CREATE INDEX idx_orders_active ON orders (customer_id, order_date)
            WHERE status != 'deleted';
            RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_orders_active åˆ›å»ºæˆåŠŸï¼ˆåªç´¢å¼•æœªåˆ é™¤çš„è®°å½•ï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_orders_active å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_orders_active å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºéƒ¨åˆ†ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
-- æŸ¥è¯¢æ´»è·ƒè®¢å•æ—¶ä½¿ç”¨ç´¢å¼•ï¼ŒæŸ¥è¯¢å·²åˆ é™¤è®¢å•æ—¶ä¸ä½¿ç”¨ç´¢å¼•

-- åœºæ™¯2: çƒ­ç‚¹æ•°æ®ç´¢å¼•ï¼ˆåªç´¢å¼•é«˜é¢‘æŸ¥è¯¢çš„æ•°æ®ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING 'è¡¨ products ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºéƒ¨åˆ†ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'products' AND indexname = 'idx_products_in_stock') THEN
            CREATE INDEX idx_products_in_stock ON products (category_id, price)
            WHERE stock_quantity > 0;
            RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_products_in_stock åˆ›å»ºæˆåŠŸï¼ˆåªç´¢å¼•æœ‰åº“å­˜çš„å•†å“ï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_products_in_stock å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ products ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_products_in_stock å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºéƒ¨åˆ†ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
-- åªç´¢å¼•æœ‰åº“å­˜çš„å•†å“ï¼Œå‡å°‘ç´¢å¼•å¤§å°

-- åœºæ™¯3: æ—¶é—´èŒƒå›´ç´¢å¼•ï¼ˆåªç´¢å¼•æœ€è¿‘çš„æ•°æ®ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'log_entries') THEN
            RAISE WARNING 'è¡¨ log_entries ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºéƒ¨åˆ†ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'log_entries' AND indexname = 'idx_logs_recent') THEN
            CREATE INDEX idx_logs_recent ON log_entries (level, log_time)
            WHERE log_time >= CURRENT_DATE - interval '30 days';
            RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_logs_recent åˆ›å»ºæˆåŠŸï¼ˆåªç´¢å¼•æœ€è¿‘30å¤©çš„æ—¥å¿—ï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_logs_recent å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ log_entries ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_logs_recent å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºéƒ¨åˆ†ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
-- åªç´¢å¼•æœ€è¿‘30å¤©çš„æ—¥å¿—ï¼Œå®šæœŸé‡å»ºç´¢å¼•

-- åœºæ™¯4: çŠ¶æ€ç´¢å¼•ï¼ˆåªç´¢å¼•ç‰¹å®šçŠ¶æ€ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºéƒ¨åˆ†ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'orders' AND indexname = 'idx_orders_pending') THEN
            CREATE INDEX idx_orders_pending ON orders (customer_id, created_at)
            WHERE status = 'pending';
            RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_orders_pending åˆ›å»ºæˆåŠŸï¼ˆåªç´¢å¼•å¾…å¤„ç†è®¢å•ï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_orders_pending å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_orders_pending å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºéƒ¨åˆ†ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
-- åªç´¢å¼•å¾…å¤„ç†è®¢å•ï¼Œå¿«é€ŸæŸ¥è¯¢å¾…å¤„ç†è®¢å•
```

**éƒ¨åˆ†ç´¢å¼•æ€§èƒ½å¯¹æ¯”**:

```sql
-- å…¨ç´¢å¼• vs éƒ¨åˆ†ç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
-- å‡è®¾è¡¨æœ‰1000ä¸‡è¡Œï¼Œä½†åªæœ‰10ä¸‡è¡Œæ»¡è¶³æ¡ä»¶

-- å…¨ç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'orders' AND indexname = 'idx_orders_full') THEN
            CREATE INDEX idx_orders_full ON orders (customer_id, order_date);
            RAISE NOTICE 'å…¨ç´¢å¼• idx_orders_full åˆ›å»ºæˆåŠŸï¼ˆç´¢å¼•å¤§å°çº¦500MBï¼Œç»´æŠ¤æˆæœ¬é«˜ï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_orders_full å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_orders_full å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºå…¨ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºéƒ¨åˆ†ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'orders' AND indexname = 'idx_orders_partial') THEN
            CREATE INDEX idx_orders_partial ON orders (customer_id, order_date)
            WHERE status != 'deleted';
            RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_orders_partial åˆ›å»ºæˆåŠŸï¼ˆç´¢å¼•å¤§å°çº¦50MBï¼Œç»´æŠ¤æˆæœ¬ä½ï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_orders_partial å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'ç´¢å¼• idx_orders_partial å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºéƒ¨åˆ†ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æŸ¥è¯¢æ€§èƒ½å¯¹æ¯”ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•æµ‹è¯•æŸ¥è¯¢æ€§èƒ½';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æµ‹è¯•æŸ¥è¯¢æ€§èƒ½ï¼ˆå…¨ç´¢å¼•ï¼šæ‰«æ500MBç´¢å¼•ï¼Œéƒ¨åˆ†ç´¢å¼•ï¼šæ‰«æ50MBç´¢å¼•ï¼Œ10å€æ€§èƒ½æå‡ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE customer_id = 100 AND status != 'deleted';
-- å…¨ç´¢å¼•ï¼šIndex Scanï¼Œæ‰«æ500MBç´¢å¼•
-- éƒ¨åˆ†ç´¢å¼•ï¼šIndex Scanï¼Œæ‰«æ50MBç´¢å¼•ï¼ˆ10å€æ€§èƒ½æå‡ï¼‰

-- æ’å…¥æ€§èƒ½å¯¹æ¯”ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•æµ‹è¯•æ’å…¥æ€§èƒ½';
            RETURN;
        END IF;
        RAISE NOTICE 'æµ‹è¯•æ’å…¥æ€§èƒ½ï¼ˆå…¨ç´¢å¼•ï¼šéœ€è¦æ›´æ–°ç´¢å¼•ï¼Œéƒ¨åˆ†ç´¢å¼•ï¼šä¸éœ€è¦æ›´æ–°ç´¢å¼•ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

INSERT INTO orders (customer_id, order_date, status) VALUES (100, NOW(), 'deleted');
-- å…¨ç´¢å¼•ï¼šéœ€è¦æ›´æ–°ç´¢å¼•
-- éƒ¨åˆ†ç´¢å¼•ï¼šä¸éœ€è¦æ›´æ–°ç´¢å¼•ï¼ˆå› ä¸ºstatus='deleted'ä¸æ»¡è¶³æ¡ä»¶ï¼‰
```

**éƒ¨åˆ†ç´¢å¼•ç»´æŠ¤**:

```sql
-- å®šæœŸé‡å»ºéƒ¨åˆ†ç´¢å¼•ï¼ˆå¦‚æœæ¡ä»¶èŒƒå›´å˜åŒ–ï¼Œå¸¦é”™è¯¯å¤„ç†ï¼‰
-- ä¾‹å¦‚ï¼šæ—¶é—´èŒƒå›´ç´¢å¼•éœ€è¦å®šæœŸæ›´æ–°
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'log_entries') THEN
            RAISE WARNING 'è¡¨ log_entries ä¸å­˜åœ¨ï¼Œæ— æ³•é‡å»ºéƒ¨åˆ†ç´¢å¼•';
            RETURN;
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'log_entries' AND indexname = 'idx_logs_recent') THEN
            DROP INDEX IF EXISTS idx_logs_recent;
            RAISE NOTICE 'æ—§ç´¢å¼• idx_logs_recent å·²åˆ é™¤';
        END IF;

        CREATE INDEX idx_logs_recent ON log_entries (level, log_time)
        WHERE log_time >= CURRENT_DATE - interval '30 days';
        RAISE NOTICE 'éƒ¨åˆ†ç´¢å¼• idx_logs_recent é‡å»ºæˆåŠŸï¼ˆæ›´æ–°ä¸ºæœ€è¿‘30å¤©ï¼‰';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ log_entries ä¸å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'é‡å»ºéƒ¨åˆ†ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨å‡½æ•°è‡ªåŠ¨ç»´æŠ¤ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'rebuild_recent_logs_index') THEN
            RAISE NOTICE 'å‡½æ•° rebuild_recent_logs_index å·²å­˜åœ¨';
        ELSE
            CREATE OR REPLACE FUNCTION rebuild_recent_logs_index()
            RETURNS void AS $$
            BEGIN
                BEGIN
                    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'log_entries') THEN
                        RAISE EXCEPTION 'è¡¨ log_entries ä¸å­˜åœ¨';
                    END IF;

                    IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'log_entries' AND indexname = 'idx_logs_recent') THEN
                        DROP INDEX IF EXISTS idx_logs_recent;
                    END IF;

                    EXECUTE format(
                        'CREATE INDEX idx_logs_recent ON log_entries (level, log_time) '
                        'WHERE log_time >= %L',
                        CURRENT_DATE - interval '30 days'
                    );
                EXCEPTION
                    WHEN OTHERS THEN
                        RAISE EXCEPTION 'é‡å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
                END;
            END;
            $$ LANGUAGE plpgsql;
            RAISE NOTICE 'å‡½æ•° rebuild_recent_logs_index åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN duplicate_function THEN
            RAISE WARNING 'å‡½æ•° rebuild_recent_logs_index å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºå‡½æ•°å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- é€šè¿‡cronå®šæœŸæ‰§è¡Œï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'pg_cron') THEN
            RAISE WARNING 'æ‰©å±• pg_cron æœªå®‰è£…ï¼Œæ— æ³•è°ƒåº¦ä»»åŠ¡';
            RETURN;
        END IF;

        -- æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å·²å­˜åœ¨
        IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'rebuild-logs-index') THEN
            RAISE NOTICE 'å®šæ—¶ä»»åŠ¡ rebuild-logs-index å·²å­˜åœ¨';
        ELSE
            -- SELECT cron.schedule('rebuild-logs-index', '0 2 * * *', 'SELECT rebuild_recent_logs_index();');
            RAISE NOTICE 'æç¤ºï¼šä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ›å»ºå®šæ—¶ä»»åŠ¡ï¼ˆæ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œï¼‰';
            RAISE NOTICE 'SELECT cron.schedule(''rebuild-logs-index'', ''0 2 * * *'', ''SELECT rebuild_recent_logs_index();'');';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ cron.job ä¸å­˜åœ¨ï¼Œpg_cronæ‰©å±•å¯èƒ½æœªå®‰è£…';
        WHEN OTHERS THEN
            RAISE WARNING 'æ£€æŸ¥å®šæ—¶ä»»åŠ¡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.3 è¡¨è¾¾å¼ç´¢å¼•

```sql
-- åˆ›å»ºè¡¨è¾¾å¼ç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ›å»ºè¡¨è¾¾å¼ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_name_lower') THEN
            CREATE INDEX idx_name_lower ON employees (LOWER(name));
            RAISE NOTICE 'è¡¨è¾¾å¼ç´¢å¼• idx_name_lower åˆ›å»ºæˆåŠŸï¼ˆLOWER(name)ï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_name_lower å·²å­˜åœ¨';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_salary_rounded') THEN
            CREATE INDEX idx_salary_rounded ON employees ((salary::INTEGER));
            RAISE NOTICE 'è¡¨è¾¾å¼ç´¢å¼• idx_salary_rounded åˆ›å»ºæˆåŠŸï¼ˆsalary::INTEGERï¼‰';
        ELSE
            RAISE NOTICE 'ç´¢å¼• idx_salary_rounded å·²å­˜åœ¨';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
        WHEN duplicate_table THEN
            RAISE WARNING 'éƒ¨åˆ†ç´¢å¼•å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºè¡¨è¾¾å¼ç´¢å¼•å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è¡¨è¾¾å¼ç´¢å¼•ä½¿ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨ï¼Œæ— æ³•æµ‹è¯•è¡¨è¾¾å¼ç´¢å¼•';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_name_lower') THEN
            RAISE WARNING 'è¡¨è¾¾å¼ç´¢å¼• idx_name_lower ä¸å­˜åœ¨ï¼ŒæŸ¥è¯¢å¯èƒ½è¾ƒæ…¢';
        END IF;
        RAISE NOTICE 'å¼€å§‹æµ‹è¯•è¡¨è¾¾å¼ç´¢å¼•ï¼ˆLOWER(name)ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';

-- æµ‹è¯•ç±»å‹è½¬æ¢è¡¨è¾¾å¼ç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING 'è¡¨ employees ä¸å­˜åœ¨';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'employees' AND indexname = 'idx_salary_rounded') THEN
            RAISE WARNING 'è¡¨è¾¾å¼ç´¢å¼• idx_salary_rounded ä¸å­˜åœ¨ï¼ŒæŸ¥è¯¢å¯èƒ½è¾ƒæ…¢';
        END IF;
        RAISE NOTICE 'å¼€å§‹æµ‹è¯•è¡¨è¾¾å¼ç´¢å¼•ï¼ˆsalary::INTEGERï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµ‹è¯•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE (salary::INTEGER) = 50000;

#### 4.3.1 è¡¨è¾¾å¼ç´¢å¼•è¯¦è§£

**è¡¨è¾¾å¼ç´¢å¼•çš„ä½¿ç”¨åœºæ™¯**:

1. **å‡½æ•°è°ƒç”¨**: å¯¹åˆ—åº”ç”¨å‡½æ•°åæŸ¥è¯¢

    ```sql
    -- åœºæ™¯1: å¤§å°å†™ä¸æ•æ„ŸæŸ¥è¯¢
    CREATE INDEX idx_users_email_lower ON users (LOWER(email));
    -- æŸ¥è¯¢ï¼šWHERE LOWER(email) = 'user@example.com'

    -- åœºæ™¯2: æ—¥æœŸå‡½æ•°
    CREATE INDEX idx_orders_year ON orders (EXTRACT(YEAR FROM order_date));
    -- æŸ¥è¯¢ï¼šWHERE EXTRACT(YEAR FROM order_date) = 2024

    -- åœºæ™¯3: å­—ç¬¦ä¸²å‡½æ•°
    CREATE INDEX idx_products_name_prefix ON products (LEFT(name, 10));
    -- æŸ¥è¯¢ï¼šWHERE LEFT(name, 10) = 'Product A'
    ```

2. **ç±»å‹è½¬æ¢**: æŸ¥è¯¢æ—¶è¿›è¡Œç±»å‹è½¬æ¢

    ```sql
    -- åœºæ™¯1: æ•°å€¼ç±»å‹è½¬æ¢
    CREATE INDEX idx_sales_amount_int ON sales ((amount::INTEGER));
    -- æŸ¥è¯¢ï¼šWHERE (amount::INTEGER) = 1000

    -- åœºæ™¯2: æ—¥æœŸç±»å‹è½¬æ¢
    CREATE INDEX idx_events_date_trunc ON events (DATE_TRUNC('day', event_time));
    -- æŸ¥è¯¢ï¼šWHERE DATE_TRUNC('day', event_time) = '2024-01-01'
    ```

3. **JSON/JSONBå­—æ®µ**: ç´¢å¼•JSONå­—æ®µçš„ç‰¹å®šè·¯å¾„

```sql
-- åœºæ™¯1: JSONBå­—æ®µç´¢å¼•
CREATE INDEX idx_products_metadata_category ON products ((metadata->>'category'));
-- æŸ¥è¯¢ï¼šWHERE metadata->>'category' = 'electronics'

-- åœºæ™¯2: JSONBæ•°ç»„ç´¢å¼•
CREATE INDEX idx_documents_tags ON documents USING GIN ((tags::jsonb));
-- æŸ¥è¯¢ï¼šWHERE tags @> '["postgresql"]'::jsonb
```

**è¡¨è¾¾å¼ç´¢å¼•çš„æ³¨æ„äº‹é¡¹**:

```sql
-- 1. æŸ¥è¯¢å¿…é¡»å®Œå…¨åŒ¹é…è¡¨è¾¾å¼
-- ç´¢å¼•ï¼šCREATE INDEX idx_name_lower ON employees (LOWER(name));
-- å¯ä»¥ä½¿ç”¨ï¼šWHERE LOWER(name) = 'john'
-- ä¸èƒ½ä½¿ç”¨ï¼šWHERE name = 'John'ï¼ˆä¸åŒ¹é…è¡¨è¾¾å¼ï¼‰

-- 2. è¡¨è¾¾å¼ç´¢å¼•ç»´æŠ¤æˆæœ¬è¾ƒé«˜
-- æ¯æ¬¡æ’å…¥/æ›´æ–°éƒ½éœ€è¦è®¡ç®—è¡¨è¾¾å¼
-- å¯¹äºå¤æ‚è¡¨è¾¾å¼ï¼Œè€ƒè™‘ä½¿ç”¨å‡½æ•°ç´¢å¼•

-- 3. ä½¿ç”¨IMMUTABLEå‡½æ•°
-- åªæœ‰IMMUTABLEå‡½æ•°å¯ä»¥ç”¨äºè¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_products_created_month ON products (DATE_TRUNC('month', created_at));
-- DATE_TRUNCæ˜¯IMMUTABLEå‡½æ•°

-- 4. éƒ¨åˆ†è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_high_salary_rounded ON employees ((salary::INTEGER))
WHERE (salary::INTEGER) > 100000;
-- ç»“åˆéƒ¨åˆ†ç´¢å¼•ï¼Œå‡å°‘ç´¢å¼•å¤§å°
```

**è¡¨è¾¾å¼ç´¢å¼•æ€§èƒ½å¯¹æ¯”**:

```sql
-- æ— ç´¢å¼•ï¼šå…¨è¡¨æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';
-- Seq Scanï¼Œæ‰«ææ‰€æœ‰è¡Œ

-- æœ‰è¡¨è¾¾å¼ç´¢å¼•ï¼šç´¢å¼•æ‰«æ
CREATE INDEX idx_name_lower ON employees (LOWER(name));
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE LOWER(name) = 'john doe';
-- Index Scan using idx_name_lowerï¼ˆæ€§èƒ½æå‡æ˜¾è‘—ï¼‰

-- ç»´æŠ¤æˆæœ¬å¯¹æ¯”
-- æ’å…¥100ä¸‡è¡Œ
INSERT INTO employees (name, salary)
SELECT 'Employee' || generate_series(1, 1000000), random() * 100000;
-- æ— è¡¨è¾¾å¼ç´¢å¼•ï¼šæ’å…¥æ—¶é—´åŸºå‡†
-- æœ‰è¡¨è¾¾å¼ç´¢å¼•ï¼šæ’å…¥æ—¶é—´å¢åŠ 10-20%ï¼ˆéœ€è¦è®¡ç®—LOWER(name)ï¼‰
```

### 4.4 è¦†ç›–ç´¢å¼•

```sql
-- åˆ›å»ºè¦†ç›–ç´¢å¼•
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- è¦†ç›–ç´¢å¼•ä½¿ç”¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT dept_id, name, salary FROM employees WHERE dept_id = 1;
```

#### 4.4.1 è¦†ç›–ç´¢å¼•è¯¦è§£

**è¦†ç›–ç´¢å¼•åŸç†**:

è¦†ç›–ç´¢å¼•ï¼ˆCovering Indexï¼‰åŒ…å«æŸ¥è¯¢æ‰€éœ€çš„æ‰€æœ‰åˆ—ï¼ŒæŸ¥è¯¢å¯ä»¥ç›´æ¥ä»ç´¢å¼•è·å–æ•°æ®ï¼Œæ— éœ€å›è¡¨è®¿é—®å †è¡¨ï¼Œå¤§å¹…æå‡æŸ¥è¯¢æ€§èƒ½ã€‚

**INCLUDEåˆ—çš„ä½¿ç”¨**:

```sql
-- PostgreSQL 11+æ”¯æŒINCLUDEåˆ—
-- INCLUDEåˆ—ä¸å‚ä¸ç´¢å¼•æ’åºï¼Œä½†å­˜å‚¨åœ¨ç´¢å¼•ä¸­
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- æŸ¥è¯¢å¯ä»¥ç›´æ¥ä»ç´¢å¼•è·å–æ‰€æœ‰æ•°æ®
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100 AND order_date >= '2024-01-01';
-- Index Only Scanï¼ˆä¸éœ€è¦è®¿é—®å †è¡¨ï¼‰
```

**è¦†ç›–ç´¢å¼• vs æ™®é€šç´¢å¼•**:

```sql
-- æ™®é€šç´¢å¼•
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date);

-- æŸ¥è¯¢éœ€è¦å›è¡¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- Index Scan -> Heap Fetchï¼ˆéœ€è¦è®¿é—®å †è¡¨è·å–statuså’Œtotal_amountï¼‰

-- è¦†ç›–ç´¢å¼•
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- æŸ¥è¯¢ä¸éœ€è¦å›è¡¨
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- Index Only Scanï¼ˆç›´æ¥ä»ç´¢å¼•è·å–æ‰€æœ‰æ•°æ®ï¼‰

-- æ€§èƒ½å¯¹æ¯”
-- æ™®é€šç´¢å¼•ï¼š1000æ¬¡ç´¢å¼•æ‰«æ + 1000æ¬¡å †è¡¨è®¿é—®
-- è¦†ç›–ç´¢å¼•ï¼š1000æ¬¡ç´¢å¼•æ‰«æï¼ˆæ— å †è¡¨è®¿é—®ï¼‰
-- æ€§èƒ½æå‡ï¼š2-3å€ï¼ˆå–å†³äºå †è¡¨è®¿é—®æˆæœ¬ï¼‰
```

**è¦†ç›–ç´¢å¼•è®¾è®¡åŸåˆ™**:

```sql
-- 1. åˆ†ææŸ¥è¯¢æ¨¡å¼
-- è¯†åˆ«ç»å¸¸ä¸€èµ·æŸ¥è¯¢çš„åˆ—ç»„åˆ
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'orders';

-- 2. åˆ›å»ºè¦†ç›–ç´¢å¼•
-- å°†WHEREå­å¥çš„åˆ—æ”¾åœ¨ç´¢å¼•é”®ä¸­
-- å°†SELECTå­å¥çš„å…¶ä»–åˆ—æ”¾åœ¨INCLUDEä¸­
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount, shipping_address);

-- 3. é¿å…è¿‡åº¦ä½¿ç”¨INCLUDE
-- INCLUDEåˆ—ä¼šå¢åŠ ç´¢å¼•å¤§å°
-- åªåŒ…å«ç»å¸¸æŸ¥è¯¢çš„åˆ—
CREATE INDEX idx_orders_minimal ON orders (customer_id)
INCLUDE (order_date, status);  -- åªåŒ…å«å¿…è¦åˆ—

-- 4. ç»“åˆéƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_orders_active_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount)
WHERE status != 'cancelled';
-- åªç´¢å¼•æ´»è·ƒè®¢å•ï¼Œå‡å°‘ç´¢å¼•å¤§å°
```

**è¦†ç›–ç´¢å¼•ä½¿ç”¨åœºæ™¯**:

```sql
-- åœºæ™¯1: æŠ¥è¡¨æŸ¥è¯¢ï¼ˆåªæŸ¥è¯¢ç‰¹å®šåˆ—ï¼‰
CREATE INDEX idx_sales_covering ON sales (sale_date, region)
INCLUDE (product_id, quantity, amount);
-- æŸ¥è¯¢ï¼šSELECT sale_date, region, product_id, quantity, amount FROM sales WHERE ...

-- åœºæ™¯2: APIæŸ¥è¯¢ï¼ˆè¿”å›å›ºå®šå­—æ®µï¼‰
CREATE INDEX idx_users_api_covering ON users (user_id)
INCLUDE (name, email, created_at, status);
-- æŸ¥è¯¢ï¼šSELECT user_id, name, email, created_at, status FROM users WHERE user_id = ?

-- åœºæ™¯3: èšåˆæŸ¥è¯¢ï¼ˆé¢„è®¡ç®—åˆ—ï¼‰
CREATE INDEX idx_orders_stats_covering ON orders (customer_id, order_date)
INCLUDE (total_amount);
-- æŸ¥è¯¢ï¼šSELECT customer_id, SUM(total_amount) FROM orders WHERE ... GROUP BY customer_id
```

**è¦†ç›–ç´¢å¼•æ€§èƒ½ç›‘æ§**:

```sql
-- æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname LIKE '%covering%';

-- æ£€æŸ¥Index Only Scanä½¿ç”¨æƒ…å†µ
EXPLAIN (ANALYZE, BUFFERS)
SELECT customer_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100;
-- æŸ¥çœ‹æ˜¯å¦ä½¿ç”¨Index Only Scan

-- ç›‘æ§ç´¢å¼•å¤§å°
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE indexname LIKE '%covering%';
```

## 5. ç´¢å¼•ç»´æŠ¤

### 5.1 ç´¢å¼•é‡å»º

```sql
-- é‡å»ºç´¢å¼•
REINDEX INDEX idx_emp_salary;
REINDEX TABLE employees;

-- å¹¶å‘é‡å»ºç´¢å¼•
REINDEX INDEX CONCURRENTLY idx_emp_salary;

-- æŸ¥çœ‹ç´¢å¼•è†¨èƒ€
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size
FROM pg_indexes
WHERE tablename = 'employees';
```

### 5.2 ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯

```sql
-- æ›´æ–°ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯
ANALYZE employees;

-- æŸ¥çœ‹ç´¢å¼•ç»Ÿè®¡
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    idx_blks_read,
    idx_blks_hit
FROM pg_statio_user_indexes
WHERE tablename = 'employees';
```

### 5.3 ç´¢å¼•ç›‘æ§

```sql
-- ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / idx_scan > 1000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as status
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

#### 5.3.1 ç´¢å¼•ç›‘æ§è¯¦è§£

**ç´¢å¼•ä½¿ç”¨æƒ…å†µç›‘æ§**:

```sql
-- 1. è¯†åˆ«æœªä½¿ç”¨çš„ç´¢å¼•
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0
AND pg_relation_size(indexname::regclass) > 1000000  -- å¤§äº1MB
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 2. è¯†åˆ«ä½æ•ˆç´¢å¼•
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    round(1.0 * idx_tup_read / NULLIF(idx_scan, 0), 2) as avg_tuples_per_scan,
    CASE
        WHEN idx_scan = 0 THEN 'UNUSED'
        WHEN idx_tup_read / NULLIF(idx_scan, 0) > 10000 THEN 'INEFFICIENT'
        ELSE 'EFFICIENT'
    END as efficiency
FROM pg_stat_user_indexes
WHERE idx_scan > 0
ORDER BY idx_tup_read / NULLIF(idx_scan, 0) DESC;

-- 3. ç´¢å¼•å‘½ä¸­ç‡ç›‘æ§
SELECT
    schemaname,
    tablename,
    indexname,
    idx_blks_hit,
    idx_blks_read,
    round(100.0 * idx_blks_hit / NULLIF(idx_blks_hit + idx_blks_read, 0), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

**ç´¢å¼•è†¨èƒ€ç›‘æ§**:

```sql
-- 1. æ£€æŸ¥ç´¢å¼•è†¨èƒ€
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) /
          NULLIF(pg_relation_size(tablename::regclass), 0), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 2. ä½¿ç”¨pgstattupleæ‰©å±•æ£€æŸ¥ç´¢å¼•è†¨èƒ€ï¼ˆéœ€è¦å®‰è£…æ‰©å±•ï¼‰
CREATE EXTENSION IF NOT EXISTS pgstattuple;
SELECT * FROM pgstatindex('idx_emp_salary');
-- è¿”å›ç´¢å¼•ç»Ÿè®¡ä¿¡æ¯ï¼ŒåŒ…æ‹¬è†¨èƒ€ç‡

-- 3. è¯†åˆ«éœ€è¦é‡å»ºçš„ç´¢å¼•
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    idx_scan,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexname::regclass) > 100000000  -- å¤§äº100MB
AND (last_vacuum IS NULL OR last_vacuum < NOW() - interval '7 days')
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

**ç´¢å¼•ç»´æŠ¤è‡ªåŠ¨åŒ–**:

```sql
-- è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤å‡½æ•°
CREATE OR REPLACE FUNCTION maintain_indexes(
    min_size_mb integer DEFAULT 100,
    unused_days integer DEFAULT 30
)
RETURNS TABLE(
    action text,
    schemaname text,
    tablename text,
    indexname text,
    reason text
) AS $$
DECLARE
    r RECORD;
BEGIN
    -- 1. è¯†åˆ«æœªä½¿ç”¨çš„ç´¢å¼•
    FOR r IN
        SELECT
            i.schemaname,
            i.tablename,
            i.indexname,
            pg_relation_size(i.indexname::regclass) as index_size,
            s.idx_scan,
            s.last_vacuum,
            s.last_autovacuum
        FROM pg_indexes i
        LEFT JOIN pg_stat_user_indexes s
            ON s.schemaname = i.schemaname
            AND s.tablename = i.tablename
            AND s.indexname = i.indexname
        WHERE i.schemaname = 'public'
        AND pg_relation_size(i.indexname::regclass) > min_size_mb * 1024 * 1024
    LOOP
        -- æ£€æŸ¥æ˜¯å¦æœªä½¿ç”¨
        IF r.idx_scan = 0 OR r.idx_scan IS NULL THEN
            RETURN QUERY SELECT
                'DROP'::text,
                r.schemaname,
                r.tablename,
                r.indexname,
                format('Unused index, size: %s', pg_size_pretty(r.index_size))::text;
        END IF;

        -- æ£€æŸ¥æ˜¯å¦éœ€è¦é‡å»º
        IF (r.last_vacuum IS NULL AND r.last_autovacuum IS NULL)
           OR (r.last_vacuum < NOW() - (unused_days || ' days')::interval
               AND r.last_autovacuum < NOW() - (unused_days || ' days')::interval) THEN
            RETURN QUERY SELECT
                'REINDEX'::text,
                r.schemaname,
                r.tablename,
                r.indexname,
                format('Index not vacuumed in %s days', unused_days)::text;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM maintain_indexes(100, 30);
-- è¿”å›éœ€è¦ç»´æŠ¤çš„ç´¢å¼•åˆ—è¡¨
```

## 6. ç´¢å¼•æ€§èƒ½åˆ†æ

### 6.1 ç´¢å¼•é€‰æ‹©åˆ†æ

```sql
-- åˆ†æç´¢å¼•é€‰æ‹©
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE emp_id = 1001;

-- åˆ†æå¤åˆç´¢å¼•
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- åˆ†æèŒƒå›´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;
```

### 6.2 ç´¢å¼•æ•ˆç‡åˆ†æ

```sql
-- ç´¢å¼•æ•ˆç‡åˆ†æ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    round(100.0 * idx_blks_hit / (idx_blks_hit + idx_blks_read), 2) as hit_ratio
FROM pg_statio_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio ASC;
```

### 6.3 ç´¢å¼•å¤§å°åˆ†æ

```sql
-- ç´¢å¼•å¤§å°åˆ†æ
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size,
    pg_size_pretty(pg_relation_size(tablename::regclass)) as table_size,
    round(100.0 * pg_relation_size(indexname::regclass) / pg_relation_size(tablename::regclass), 2) as size_ratio
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexname::regclass) DESC;
```

## 7. é«˜çº§ç´¢å¼•æŠ€æœ¯

### 7.1 ä½å›¾ç´¢å¼•æ‰«æ

```sql
-- ä½å›¾ç´¢å¼•æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 AND salary > 50000;

-- ä½å›¾å †æ‰«æ
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id IN (1, 2, 3) AND salary > 50000;
```

### 7.2 ç´¢å¼•è·³è·ƒæ‰«æ

```sql
-- ç´¢å¼•è·³è·ƒæ‰«æ
CREATE INDEX idx_emp_skip ON employees (dept_id, salary, hire_date);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE salary > 50000 ORDER BY dept_id, salary;
```

### 7.3 ç´¢å¼•åˆå¹¶

```sql
-- ç´¢å¼•åˆå¹¶
CREATE INDEX idx_emp_dept ON employees (dept_id);
CREATE INDEX idx_emp_salary ON employees (salary);

EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees WHERE dept_id = 1 OR salary > 50000;
```

## 8. PostgreSQL 18ç´¢å¼•ä¼˜åŒ–æ–°ç‰¹æ€§

### 8.1 B-treeå»é‡ä¼˜åŒ–

PostgreSQL 18å¯¹B-treeç´¢å¼•è¿›è¡Œäº†å»é‡ä¼˜åŒ–ï¼Œæ˜¾è‘—å‡å°‘äº†ç´¢å¼•å¤§å°ã€‚

**B-treeå»é‡ä¼˜åŒ–**ï¼š

```sql
-- åˆ›å»ºåŒ…å«é‡å¤å€¼çš„è¡¨
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date DATE,
    status VARCHAR(20)
);

-- æ’å…¥å¤§é‡é‡å¤æ•°æ®
INSERT INTO orders (customer_id, order_date, status)
SELECT
    (random() * 1000)::INTEGER,
    CURRENT_DATE - (random() * 365)::INTEGER,
    CASE (random() * 3)::INTEGER
        WHEN 0 THEN 'pending'
        WHEN 1 THEN 'processing'
        ELSE 'completed'
    END
FROM generate_series(1, 1000000);

-- åˆ›å»ºB-treeç´¢å¼•ï¼ˆPostgreSQL 18è‡ªåŠ¨å»é‡ï¼‰
CREATE INDEX idx_orders_customer_status ON orders (customer_id, status);

-- æŸ¥çœ‹ç´¢å¼•å¤§å°å¯¹æ¯”
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_indexes
WHERE tablename = 'orders';

-- PostgreSQL 18: ç´¢å¼•å¤§å°å‡å°‘çº¦18%ï¼ˆå»é‡ä¼˜åŒ–ï¼‰
```

**ä¼˜åŠ¿**ï¼š

- ç´¢å¼•å¤§å°å‡å°‘çº¦18%
- å‡å°‘I/Oæ“ä½œ
- æé«˜ç´¢å¼•æ‰«ææ€§èƒ½

### 8.2 BRINæ€§èƒ½æå‡

PostgreSQL 18å¯¹BRINç´¢å¼•è¿›è¡Œäº†æ€§èƒ½ä¼˜åŒ–ï¼Œæå‡äº†15-20%çš„æŸ¥è¯¢æ€§èƒ½ã€‚

**BRINæ€§èƒ½æå‡**ï¼š

```sql
-- åˆ›å»ºå¤§è¡¨
CREATE TABLE sensor_data (
    id BIGSERIAL,
    sensor_id INTEGER,
    timestamp TIMESTAMP,
    value DECIMAL(10,2)
);

-- åˆ›å»ºBRINç´¢å¼•ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰
CREATE INDEX idx_sensor_timestamp_brin ON sensor_data USING BRIN (timestamp)
WITH (pages_per_range = 128);

-- æ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼ˆPostgreSQL 18æ€§èƒ½æå‡15-20%ï¼‰
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM sensor_data
WHERE timestamp >= '2024-01-01'
AND timestamp < '2024-02-01';

-- PostgreSQL 18æ”¹è¿›ï¼š
-- 1. æ›´é«˜æ•ˆçš„BRINç´¢å¼•æ‰«æ
-- 2. æ”¹è¿›çš„é¡µé¢èŒƒå›´è¿‡æ»¤
-- 3. æ›´å¥½çš„å¹¶è¡ŒBRINæ‰«ææ”¯æŒ
```

**æ€§èƒ½æå‡**ï¼š

- æŸ¥è¯¢æ€§èƒ½æå‡15-20%
- æ›´é«˜æ•ˆçš„BRINç´¢å¼•æ‰«æ
- æ”¹è¿›çš„é¡µé¢èŒƒå›´è¿‡æ»¤

### 8.3 å¼‚æ­¥I/Oæå‡ç´¢å¼•æ„å»ºé€Ÿåº¦

PostgreSQL 18çš„å¼‚æ­¥I/Oå­ç³»ç»Ÿæ˜¾è‘—æå‡äº†ç´¢å¼•æ„å»ºé€Ÿåº¦ã€‚

**å¼‚æ­¥I/Oåœ¨ç´¢å¼•æ„å»ºä¸­çš„åº”ç”¨**ï¼š

```sql
-- é…ç½®å¼‚æ­¥I/Oï¼ˆPostgreSQL 18ï¼‰
-- åœ¨postgresql.confä¸­é…ç½®
-- maintenance_io_workers = 4  -- ç»´æŠ¤æ“ä½œçš„I/Oå·¥ä½œè¿›ç¨‹æ•°

-- å¤§è¡¨ç´¢å¼•æ„å»ºæ€§èƒ½å¯¹æ¯”
-- ä¼ ç»ŸåŒæ­¥I/O
\timing on
CREATE INDEX CONCURRENTLY idx_large_table_sync ON large_table (column1);
-- å‡è®¾éœ€è¦120ç§’

-- å¼‚æ­¥I/Oï¼ˆPostgreSQL 18ï¼‰
-- é…ç½®å¼‚æ­¥I/Oå
CREATE INDEX CONCURRENTLY idx_large_table_async ON large_table (column1);
-- å¯èƒ½åªéœ€è¦70-80ç§’ï¼ˆæ€§èƒ½æå‡40%+ï¼‰

-- ç›‘æ§ç´¢å¼•æ„å»ºè¿›åº¦
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    query
FROM pg_stat_activity
WHERE query LIKE '%CREATE INDEX%'
AND state = 'active';
```

**æ€§èƒ½æå‡**ï¼š

- ç´¢å¼•æ„å»ºé€Ÿåº¦æå‡40%+
- å‡å°‘ç´¢å¼•æ„å»ºå¯¹æ­£å¸¸æŸ¥è¯¢çš„å½±å“
- æ”¯æŒå¹¶è¡Œç´¢å¼•æ„å»º

### 8.4 æ›´é«˜æ•ˆçš„ç´¢å¼•ç»´æŠ¤

PostgreSQL 18æ”¹è¿›äº†ç´¢å¼•ç»´æŠ¤æ“ä½œï¼Œæé«˜äº†VACUUMå’ŒREINDEXçš„æ•ˆç‡ã€‚

**ç´¢å¼•ç»´æŠ¤æ”¹è¿›**ï¼š

```sql
-- VACUUMç´¢å¼•ç»´æŠ¤ï¼ˆPostgreSQL 18ä¼˜åŒ–ï¼‰
VACUUM (ANALYZE, VERBOSE) employees;

-- REINDEXæ€§èƒ½æå‡ï¼ˆPostgreSQL 18ï¼‰
REINDEX TABLE CONCURRENTLY employees;

-- ç›‘æ§ç´¢å¼•ç»´æŠ¤æ€§èƒ½
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

**æ”¹è¿›ç‚¹**ï¼š

- VACUUMç´¢å¼•ç»´æŠ¤æ•ˆç‡æå‡
- REINDEXæ€§èƒ½ä¼˜åŒ–
- æ›´æ™ºèƒ½çš„ç´¢å¼•ç»´æŠ¤ç­–ç•¥

### 8.5 è™šæ‹Ÿç”Ÿæˆåˆ—ç´¢å¼•æ”¯æŒ

PostgreSQL 18æ”¯æŒåœ¨è™šæ‹Ÿç”Ÿæˆåˆ—ä¸Šåˆ›å»ºç´¢å¼•ï¼Œè¿›ä¸€æ­¥æ‰©å±•äº†ç´¢å¼•çš„åº”ç”¨åœºæ™¯ã€‚

**è™šæ‹Ÿç”Ÿæˆåˆ—ç´¢å¼•**ï¼š

```sql
-- åˆ›å»ºå¸¦è™šæ‹Ÿç”Ÿæˆåˆ—çš„è¡¨
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    discount DECIMAL(5,2),
    final_price DECIMAL(10,2) GENERATED ALWAYS AS (price * (1 - discount/100)) VIRTUAL
);

-- åœ¨è™šæ‹Ÿç”Ÿæˆåˆ—ä¸Šåˆ›å»ºç´¢å¼•ï¼ˆPostgreSQL 18æ”¯æŒï¼‰
CREATE INDEX idx_products_final_price ON products (final_price);

-- ä½¿ç”¨è™šæ‹Ÿç”Ÿæˆåˆ—ç´¢å¼•è¿›è¡ŒæŸ¥è¯¢ä¼˜åŒ–
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products
WHERE final_price BETWEEN 50 AND 100;
-- PostgreSQL 18: å¯ä»¥ä½¿ç”¨final_priceä¸Šçš„ç´¢å¼•
```

**ä¼˜åŠ¿**ï¼š

- æ”¯æŒåœ¨è™šæ‹Ÿç”Ÿæˆåˆ—ä¸Šåˆ›å»ºç´¢å¼•
- æ‰©å±•äº†ç´¢å¼•çš„åº”ç”¨åœºæ™¯
- æé«˜åŸºäºè®¡ç®—åˆ—çš„æŸ¥è¯¢æ€§èƒ½

### 8.6 PostgreSQL 18ç´¢å¼•ä¼˜åŒ–æœ€ä½³å®è·µ

**æœ€ä½³å®è·µæ€»ç»“**ï¼š

```sql
-- 1. åˆ©ç”¨B-treeå»é‡ä¼˜åŒ–
-- PostgreSQL 18è‡ªåŠ¨ä¼˜åŒ–ï¼Œæ— éœ€é¢å¤–é…ç½®

-- 2. ä½¿ç”¨BRINç´¢å¼•ä¼˜åŒ–å¤§è¡¨æŸ¥è¯¢
CREATE INDEX idx_sensor_timestamp_brin ON sensor_data USING BRIN (timestamp)
WITH (pages_per_range = 128);

-- 3. é…ç½®å¼‚æ­¥I/Oæå‡ç´¢å¼•æ„å»ºæ€§èƒ½
-- åœ¨postgresql.confä¸­é…ç½®
-- maintenance_io_workers = 4

-- 4. åœ¨è™šæ‹Ÿç”Ÿæˆåˆ—ä¸Šåˆ›å»ºç´¢å¼•ï¼ˆPostgreSQL 18ï¼‰
CREATE TABLE products (
    price DECIMAL(10,2),
    discount DECIMAL(5,2),
    final_price DECIMAL(10,2) GENERATED ALWAYS AS (price * (1 - discount/100)) VIRTUAL
);
CREATE INDEX idx_products_final_price ON products (final_price);

-- 5. å®šæœŸç»´æŠ¤ç´¢å¼•
VACUUM ANALYZE employees;
REINDEX TABLE CONCURRENTLY employees;
```

## 9. ç´¢å¼•ä¼˜åŒ–å®è·µ

### 9.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä¼˜åŒ–å‰
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';

-- åˆ›å»ºä¼˜åŒ–ç´¢å¼•
CREATE INDEX idx_emp_optimized ON employees (dept_id, salary, hire_date);

-- ä¼˜åŒ–å
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM employees
WHERE dept_id = 1 AND salary > 50000 AND hire_date > '2020-01-01';
```

### 9.2 æ‰¹é‡æ“ä½œä¼˜åŒ–

```sql
-- æ‰¹é‡æ’å…¥ä¼˜åŒ–
BEGIN;
-- ä¸´æ—¶ç¦ç”¨ç´¢å¼•
DROP INDEX CONCURRENTLY idx_emp_salary;
-- æ‰¹é‡æ’å…¥
INSERT INTO employees (name, dept_id, salary)
SELECT 'Employee' || generate_series(1, 100000),
       (random() * 10)::INTEGER + 1,
       (random() * 100000)::INTEGER + 30000;
-- é‡å»ºç´¢å¼•
CREATE INDEX CONCURRENTLY idx_emp_salary ON employees (salary);
COMMIT;
```

### 9.3 ç´¢å¼•ç»´æŠ¤ç­–ç•¥

```sql
-- è‡ªåŠ¨ç´¢å¼•ç»´æŠ¤
CREATE OR REPLACE FUNCTION maintain_indexes()
RETURNS void AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT schemaname, tablename, indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
    LOOP
        -- æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
        IF (SELECT idx_scan FROM pg_stat_user_indexes
            WHERE schemaname = r.schemaname
            AND tablename = r.tablename
            AND indexname = r.indexname) = 0 THEN

            RAISE NOTICE 'Unused index: %.%', r.tablename, r.indexname;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## 10. å®é™…åº”ç”¨æ¡ˆä¾‹

### 10.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡

```sql
-- å•†å“è¡¨ç´¢å¼•
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    category_id INTEGER,
    price DECIMAL(10,2),
    stock_quantity INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_products_category_price ON products (category_id, price);
CREATE INDEX idx_products_stock ON products (stock_quantity) WHERE stock_quantity > 0;

-- è®¢å•è¡¨ç´¢å¼•
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20),
    total_amount DECIMAL(10,2)
);

-- æ—¶é—´èŒƒå›´ç´¢å¼•
CREATE INDEX idx_orders_date_status ON orders (order_date, status);
CREATE INDEX idx_orders_customer ON orders (customer_id, order_date);
```

#### 9.1.1 ç”µå•†ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ

**ä¸šåŠ¡åœºæ™¯åˆ†æ**:

1. **å•†å“æŸ¥è¯¢**: æŒ‰åˆ†ç±»ã€ä»·æ ¼èŒƒå›´ã€åº“å­˜çŠ¶æ€æŸ¥è¯¢
2. **è®¢å•æŸ¥è¯¢**: æŒ‰å®¢æˆ·ã€æ—¶é—´èŒƒå›´ã€çŠ¶æ€æŸ¥è¯¢
3. **æœç´¢åŠŸèƒ½**: å•†å“åç§°å…¨æ–‡æœç´¢
4. **æŠ¥è¡¨æŸ¥è¯¢**: æŒ‰æ—¶é—´ã€åˆ†ç±»èšåˆç»Ÿè®¡

**å®Œæ•´ç´¢å¼•è®¾è®¡æ–¹æ¡ˆ**:

```sql
-- 1. å•†å“è¡¨ç´¢å¼•è®¾è®¡
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    category_id INTEGER NOT NULL,
    brand_id INTEGER,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- ä¸»é”®ç´¢å¼•ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
-- PRIMARY KEY (product_id)

-- åˆ†ç±»+ä»·æ ¼å¤åˆç´¢å¼•ï¼ˆæ”¯æŒåˆ†ç±»æµè§ˆå’Œä»·æ ¼æ’åºï¼‰
CREATE INDEX idx_products_category_price ON products (category_id, price);

-- å“ç‰Œ+ä»·æ ¼ç´¢å¼•ï¼ˆæ”¯æŒå“ç‰Œç­›é€‰ï¼‰
CREATE INDEX idx_products_brand_price ON products (brand_id, price)
WHERE brand_id IS NOT NULL;

-- æœ‰åº“å­˜å•†å“ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•æœ‰åº“å­˜çš„å•†å“ï¼‰
CREATE INDEX idx_products_in_stock ON products (category_id, price)
WHERE stock_quantity > 0 AND status = 'active';

-- å•†å“åç§°å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_products_name_gin ON products USING GIN (to_tsvector('english', name));

-- æ›´æ–°æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæœ€è¿‘æ›´æ–°å•†å“æŸ¥è¯¢ï¼‰
CREATE INDEX idx_products_updated ON products (updated_at DESC)
WHERE status = 'active';

-- 2. è®¢å•è¡¨ç´¢å¼•è®¾è®¡
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date TIMESTAMP NOT NULL DEFAULT NOW(),
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    shipping_address TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- å®¢æˆ·+æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒå®¢æˆ·è®¢å•å†å²æŸ¥è¯¢ï¼‰
CREATE INDEX idx_orders_customer_date ON orders (customer_id, order_date DESC);

-- çŠ¶æ€+æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæŒ‰çŠ¶æ€æŸ¥è¯¢è®¢å•ï¼‰
CREATE INDEX idx_orders_status_date ON orders (status, order_date DESC);

-- å¾…å¤„ç†è®¢å•ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•å¾…å¤„ç†è®¢å•ï¼‰
CREATE INDEX idx_orders_pending ON orders (order_date)
WHERE status IN ('pending', 'processing');

-- è¦†ç›–ç´¢å¼•ï¼ˆæ”¯æŒè®¢å•åˆ—è¡¨æŸ¥è¯¢ï¼ŒåŒ…å«å¸¸ç”¨å­—æ®µï¼‰
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date)
INCLUDE (status, total_amount);

-- 3. è®¢å•é¡¹è¡¨ç´¢å¼•è®¾è®¡
CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(order_id),
    product_id INTEGER NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2) NOT NULL
);

-- è®¢å•+äº§å“ç´¢å¼•ï¼ˆæ”¯æŒè®¢å•è¯¦æƒ…æŸ¥è¯¢ï¼‰
CREATE INDEX idx_order_items_order ON order_items (order_id, product_id);

-- äº§å“ç´¢å¼•ï¼ˆæ”¯æŒäº§å“é”€å”®ç»Ÿè®¡ï¼‰
CREATE INDEX idx_order_items_product ON order_items (product_id, order_id);

-- 4. æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
-- æŸ¥è¯¢1: æŒ‰åˆ†ç±»å’Œä»·æ ¼èŒƒå›´æŸ¥è¯¢å•†å“
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products
WHERE category_id = 1 AND price BETWEEN 100 AND 500
ORDER BY price;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_products_category_price

-- æŸ¥è¯¢2: å®¢æˆ·è®¢å•å†å²
EXPLAIN (ANALYZE, BUFFERS)
SELECT order_id, order_date, status, total_amount
FROM orders
WHERE customer_id = 100
ORDER BY order_date DESC
LIMIT 20;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_orders_customer_dateï¼ˆè¦†ç›–ç´¢å¼•ï¼‰

-- æŸ¥è¯¢3: å¾…å¤„ç†è®¢å•
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE status = 'pending'
ORDER BY order_date;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_orders_pendingï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼‰

-- æŸ¥è¯¢4: å•†å“åç§°æœç´¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products
WHERE to_tsvector('english', name) @@ to_tsquery('english', 'laptop');
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_products_name_ginï¼ˆGINç´¢å¼•ï¼‰
```

**ç´¢å¼•ç»´æŠ¤ç­–ç•¥**:

```sql
-- 1. å®šæœŸé‡å»ºéƒ¨åˆ†ç´¢å¼•ï¼ˆæ—¶é—´èŒƒå›´å˜åŒ–ï¼‰
DROP INDEX IF EXISTS idx_products_updated;
CREATE INDEX idx_products_updated ON products (updated_at DESC)
WHERE status = 'active' AND updated_at >= CURRENT_DATE - interval '30 days';

-- 2. ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
AND tablename IN ('products', 'orders', 'order_items')
ORDER BY idx_scan DESC;

-- 3. è¯†åˆ«æœªä½¿ç”¨çš„ç´¢å¼•
SELECT
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
AND idx_scan = 0
AND pg_relation_size(indexname::regclass) > 10000000;  -- å¤§äº10MB
```

### 9.2 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡

```sql
-- æ—¥å¿—è¡¨ç´¢å¼•
CREATE TABLE log_entries (
    id BIGSERIAL PRIMARY KEY,
    log_time TIMESTAMP,
    level VARCHAR(10),
    source VARCHAR(100),
    message TEXT
);

-- æ—¶é—´åˆ†åŒºç´¢å¼•
CREATE INDEX idx_log_time ON log_entries (log_time);
CREATE INDEX idx_log_level_time ON log_entries (level, log_time);
CREATE INDEX idx_log_source_time ON log_entries (source, log_time);

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));
```

#### 9.2.1 æ—¥å¿—ç³»ç»Ÿç´¢å¼•è®¾è®¡å®Œæ•´æ–¹æ¡ˆ

**ä¸šåŠ¡åœºæ™¯åˆ†æ**:

1. **æ—¶é—´èŒƒå›´æŸ¥è¯¢**: æŸ¥è¯¢ç‰¹å®šæ—¶é—´æ®µçš„æ—¥å¿—
2. **çº§åˆ«ç­›é€‰**: æŒ‰æ—¥å¿—çº§åˆ«ï¼ˆERRORã€WARNç­‰ï¼‰æŸ¥è¯¢
3. **æ¥æºç­›é€‰**: æŒ‰æ¥æºï¼ˆåº”ç”¨ã€æ¨¡å—ï¼‰æŸ¥è¯¢
4. **å…¨æ–‡æœç´¢**: åœ¨æ—¥å¿—æ¶ˆæ¯ä¸­æœç´¢å…³é”®è¯
5. **æ•°æ®é‡å¤§**: æ¯å¤©æ•°ç™¾ä¸‡æ¡æ—¥å¿—ï¼Œéœ€è¦åˆ†åŒº

**å®Œæ•´ç´¢å¼•è®¾è®¡æ–¹æ¡ˆ**:

```sql
-- 1. æ—¥å¿—è¡¨ç»“æ„ï¼ˆåˆ†åŒºè¡¨ï¼‰
CREATE TABLE log_entries (
    id BIGSERIAL,
    log_time TIMESTAMP NOT NULL,
    level VARCHAR(10) NOT NULL,
    source VARCHAR(100),
    module VARCHAR(50),
    message TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW()
) PARTITION BY RANGE (log_time);

-- æŒ‰æœˆåˆ›å»ºåˆ†åŒº
CREATE TABLE log_entries_2024_01 PARTITION OF log_entries
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 2. æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_time ON log_entries (log_time);
-- è‡ªåŠ¨åœ¨æ‰€æœ‰åˆ†åŒºä¸Šåˆ›å»º

-- 3. çº§åˆ«+æ—¶é—´å¤åˆç´¢å¼•ï¼ˆæ”¯æŒæŒ‰çº§åˆ«æŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_level_time ON log_entries (level, log_time DESC);

-- 4. æ¥æº+æ—¶é—´ç´¢å¼•ï¼ˆæ”¯æŒæŒ‰æ¥æºæŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_source_time ON log_entries (source, log_time DESC)
WHERE source IS NOT NULL;

-- 5. é”™è¯¯æ—¥å¿—ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•ERRORçº§åˆ«ï¼‰
CREATE INDEX idx_log_errors ON log_entries (log_time DESC, source)
WHERE level = 'ERROR';

-- 6. å…¨æ–‡æœç´¢ç´¢å¼•ï¼ˆæ”¯æŒæ¶ˆæ¯æœç´¢ï¼‰
CREATE INDEX idx_log_message_gin ON log_entries USING GIN (to_tsvector('english', message));

-- 7. JSONBå…ƒæ•°æ®ç´¢å¼•ï¼ˆæ”¯æŒå…ƒæ•°æ®æŸ¥è¯¢ï¼‰
CREATE INDEX idx_log_metadata_gin ON log_entries USING GIN (metadata);

-- 8. æœ€è¿‘æ—¥å¿—ç´¢å¼•ï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•æœ€è¿‘30å¤©ï¼‰
CREATE INDEX idx_log_recent ON log_entries (level, log_time DESC)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- 9. æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
-- æŸ¥è¯¢1: æ—¶é—´èŒƒå›´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE log_time >= '2024-01-15' AND log_time < '2024-01-16'
ORDER BY log_time DESC;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_timeï¼Œåˆ†åŒºè£å‰ª

-- æŸ¥è¯¢2: é”™è¯¯æ—¥å¿—æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE level = 'ERROR'
AND log_time >= CURRENT_DATE - interval '7 days'
ORDER BY log_time DESC;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_errorsï¼ˆéƒ¨åˆ†ç´¢å¼•ï¼‰

-- æŸ¥è¯¢3: æ¥æº+æ—¶é—´æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE source = 'payment-service'
AND log_time >= CURRENT_DATE - interval '1 day'
ORDER BY log_time DESC;
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_source_time

-- æŸ¥è¯¢4: å…¨æ–‡æœç´¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE to_tsvector('english', message) @@ to_tsquery('english', 'error & database')
AND log_time >= CURRENT_DATE - interval '7 days';
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_message_gin

-- æŸ¥è¯¢5: JSONBå…ƒæ•°æ®æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM log_entries
WHERE metadata @> '{"user_id": 12345}'::jsonb
AND log_time >= CURRENT_DATE - interval '1 day';
-- ä½¿ç”¨ç´¢å¼•ï¼šidx_log_metadata_gin
```

**ç´¢å¼•ç»´æŠ¤ç­–ç•¥**:

```sql
-- 1. å®šæœŸé‡å»ºæœ€è¿‘æ—¥å¿—ç´¢å¼•
DROP INDEX IF EXISTS idx_log_recent;
CREATE INDEX idx_log_recent ON log_entries (level, log_time DESC)
WHERE log_time >= CURRENT_DATE - interval '30 days';

-- 2. è‡ªåŠ¨æ¸…ç†æ—§åˆ†åŒºç´¢å¼•ï¼ˆå¦‚æœåˆ†åŒºè¢«åˆ é™¤ï¼‰
-- åˆ†åŒºåˆ é™¤æ—¶ï¼Œç´¢å¼•è‡ªåŠ¨åˆ é™¤

-- 3. ç›‘æ§ç´¢å¼•å¤§å°
SELECT
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexname::regclass)) as index_size
FROM pg_indexes
WHERE tablename LIKE 'log_entries_%'
ORDER BY pg_relation_size(indexname::regclass) DESC;

-- 4. åˆ†æç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    round(1.0 * idx_tup_read / NULLIF(idx_scan, 0), 2) as avg_tuples
FROM pg_stat_user_indexes
WHERE tablename LIKE 'log_entries_%'
ORDER BY idx_scan DESC;
```

## 11. ç›¸å…³æ¦‚å¿µ

### 11.1 ä¸Šä½æ¦‚å¿µ

- **æ•°æ®ç»“æ„**: æ›´å¹¿æ³›çš„æ•°æ®ç»„ç»‡æ–¹å¼
- **æŸ¥è¯¢ä¼˜åŒ–**: æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
- **å­˜å‚¨ç®¡ç†**: æ•°æ®å­˜å‚¨æœºåˆ¶

### 11.2 ä¸‹ä½æ¦‚å¿µ

- **B+æ ‘**: å¹³è¡¡æ ‘ç»“æ„
- **å“ˆå¸Œè¡¨**: å“ˆå¸Œæ•°æ®ç»“æ„
- **ä½å›¾**: ä½å‘é‡ç»“æ„
- **å€’æ’ç´¢å¼•**: åå‘ç´¢å¼•ç»“æ„

### 11.3 å¹³è¡Œæ¦‚å¿µ

- **ç¼“å­˜**: å†…å­˜ç¼“å­˜æœºåˆ¶
- **åˆ†åŒº**: æ•°æ®åˆ†åŒºç­–ç•¥
- **å‹ç¼©**: æ•°æ®å‹ç¼©æŠ€æœ¯

## 12. ç›¸å…³æ–‡æ¡£

### 11.1 å®æˆ˜æ¡ˆä¾‹ä¸ç¤ºä¾‹

- [å®æˆ˜æ¡ˆä¾‹](../../19-å®æˆ˜æ¡ˆä¾‹/README.md) â­ - å®Œæ•´çš„å®æˆ˜æ¡ˆä¾‹é›†åˆ
- [å‘é‡æœç´¢](../../07-å¤šæ¨¡å‹æ•°æ®åº“/README.md) - å‘é‡ç´¢å¼•å®è·µ
- [æ€§èƒ½è°ƒä¼˜å®è·µ](../../11-éƒ¨ç½²æ¶æ„/å•æœºéƒ¨ç½²/05.02-æ€§èƒ½è°ƒä¼˜å®è·µ.md) - ç´¢å¼•ä¼˜åŒ–æ¡ˆä¾‹

## 13. å‚è€ƒæ–‡çŒ®

1. Comer, D. (1979). The ubiquitous B-tree. ACM Computing Surveys, 11(2), 121-137.
2. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
3. Zobel, J., & Moffat, A. (2006). Inverted files for text search engines. ACM Computing Surveys, 38(2), 6.
4. Graefe, G. (2011). Modern B-tree techniques. Foundations and Trends in Databases, 3(4), 203-402.
5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

## 14. äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£

- â­â­â­ [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](./02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md) - æŸ¥è¯¢ä¼˜åŒ–ç†è®ºåŸºç¡€
- â­â­â­ [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](./02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - æ‰§è¡Œè®¡åˆ’åˆ†æå®è·µ
- â­â­ [ç»Ÿè®¡ä¿¡æ¯ä¸ä»£ä»·æ¨¡å‹](./02.03-ç»Ÿè®¡ä¿¡æ¯ä¸ä»£ä»·æ¨¡å‹.md) - ç»Ÿè®¡ä¿¡æ¯å¯¹ç´¢å¼•é€‰æ‹©çš„å½±å“
- â­â­ [æ•°æ®æ¨¡å‹è®¾è®¡](../../17-æ•°æ®æ¨¡å‹è®¾è®¡/README.md) - ç´¢å¼•è®¾è®¡å®è·µ
- â­â­ [æ€§èƒ½è°ƒä¼˜å®è·µ](../../11-éƒ¨ç½²æ¶æ„/å•æœºéƒ¨ç½²/05.02-æ€§èƒ½è°ƒä¼˜å®è·µ.md) - æ€§èƒ½è°ƒä¼˜è¯¦ç»†æŒ‡å—
- â­ [å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–](../../04-å­˜å‚¨ä¸æ¢å¤/01.06-å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–.md) - å­˜å‚¨ç®¡ç†
- â­ [ç›‘æ§ä¸è¯Šæ–­](../../12-ç›‘æ§ä¸è¯Šæ–­/README.md) - ç´¢å¼•ç›‘æ§

### å¤–éƒ¨èµ„æº

- [PostgreSQLç´¢å¼•æ–‡æ¡£](https://www.postgresql.org/docs/current/indexes.html)
- [PostgreSQLç´¢å¼•ç±»å‹æ–‡æ¡£](https://www.postgresql.org/docs/current/indexes-types.html)
- [PostgreSQLç´¢å¼•ä¼˜åŒ–æœ€ä½³å®è·µ](https://wiki.postgresql.org/wiki/Index_Maintenance)

---

## 15. Wikidataå¯¹é½

### 14.1 ç´¢å¼•æ¦‚å¿µå¯¹é½

- **Wikidata ID**: Q192490 (Database index)
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system component)
  - P361: Q192490 (part of: database management system)
  - P1382: Q192490 (partially coincident with: data structure)
- **å¤–éƒ¨é“¾æ¥**:
  - [Wikipedia - Database index](https://en.wikipedia.org/wiki/Database_index)
  - [Wikipedia - B+ tree](https://en.wikipedia.org/wiki/B%2B_tree)
  - [Wikipedia - Hash table](https://en.wikipedia.org/wiki/Hash_table)

### 14.2 PostgreSQLç´¢å¼•å¯¹é½

- **Wikidata ID**: Q192490
- **ç›¸å…³å±æ€§**:
  - P31: Q176165 (instance of: database management system)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P277: Q193321 (programmed in: C)
  - P348: 18.0 (software version)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/indexes.html>
  - <https://www.postgresql.org/docs/current/indexes-types.html>

---

## 16. å½¢å¼è¯æ˜ä¸ç†è®ºè®ºè¯

### 15.1 B+æ ‘æŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦è¯æ˜

**å®šç†**: B+æ ‘æŸ¥æ‰¾æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º O(log n)ï¼Œå…¶ä¸­ n ä¸ºç´¢å¼•ä¸­çš„é”®å€¼æ•°é‡ã€‚

**è¯æ˜**:

```latex
\begin{theorem}[B+æ ‘æŸ¥æ‰¾å¤æ‚åº¦]
è®¾ B+æ ‘çš„é«˜åº¦ä¸º hï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§å­èŠ‚ç‚¹æ•°ä¸º mï¼Œç´¢å¼•ä¸­çš„é”®å€¼æ€»æ•°ä¸º nã€‚

å¯¹äºé«˜åº¦ä¸º h çš„ B+æ ‘ï¼Œæœ‰ï¼š
n \leq m^h

å› æ­¤ï¼š
h \geq \log_m n

ç”±äºæŸ¥æ‰¾æ“ä½œéœ€è¦ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹éå†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(h) = O(\log_m n)ã€‚

å¯¹äºå›ºå®šçš„ mï¼ˆé€šå¸¸ m \geq 2ï¼‰ï¼Œæœ‰ï¼š
O(\log_m n) = O(\log n)

å› æ­¤ï¼ŒB+æ ‘æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦ä¸º O(\log n)ã€‚
\end{theorem}
```

### 15.2 ç´¢å¼•é€‰æ‹©æœ€ä¼˜æ€§è¯æ˜

**å®šç†**: å¯¹äºç­‰å€¼æŸ¥è¯¢ï¼Œå¦‚æœå­˜åœ¨å”¯ä¸€ç´¢å¼•ï¼Œåˆ™ç´¢å¼•æ‰«ææ˜¯æœ€ä¼˜é€‰æ‹©ã€‚

**è¯æ˜**:

```latex
\begin{theorem}[ç´¢å¼•é€‰æ‹©æœ€ä¼˜æ€§]
è®¾æŸ¥è¯¢ä¸º \sigma_{A=a}(R)ï¼Œå…¶ä¸­ A ä¸ºå±æ€§ï¼Œa ä¸ºå¸¸é‡å€¼ã€‚

æƒ…å†µ1ï¼šå­˜åœ¨å”¯ä¸€ç´¢å¼• I_A
- ç´¢å¼•æŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦ï¼šO(\log n)
- ç»“æœé›†å¤§å°ï¼š|R| \leq 1ï¼ˆå”¯ä¸€æ€§ä¿è¯ï¼‰
- æ€»ä»£ä»·ï¼šO(\log n)

æƒ…å†µ2ï¼šå…¨è¡¨æ‰«æ
- æ‰«ææ—¶é—´å¤æ‚åº¦ï¼šO(n)
- ç»“æœé›†å¤§å°ï¼š|R| \leq 1
- æ€»ä»£ä»·ï¼šO(n)

ç”±äº O(\log n) < O(n)ï¼ˆå½“ n > 1ï¼‰ï¼Œç´¢å¼•æ‰«ææ˜¯æœ€ä¼˜é€‰æ‹©ã€‚
\end{theorem}
```

### 15.3 å¤åˆç´¢å¼•åˆ—é¡ºåºä¼˜åŒ–å®šç†

**å®šç†**: å¯¹äºå¤åˆç´¢å¼• (A, B)ï¼Œå¦‚æœæŸ¥è¯¢æ¡ä»¶ä¸º A=a AND B=bï¼Œåˆ™åˆ—é¡ºåº (A, B) å’Œ (B, A) çš„æŸ¥è¯¢æ€§èƒ½ç›¸åŒï¼›ä½†å¦‚æœæŸ¥è¯¢æ¡ä»¶ä»…ä¸º A=aï¼Œåˆ™ (A, B) é¡ºåºæ›´ä¼˜ã€‚

**è¯æ˜**:

```latex
\begin{theorem}[å¤åˆç´¢å¼•åˆ—é¡ºåº]
è®¾å¤åˆç´¢å¼•ä¸º I_{(A,B)}ï¼ŒæŸ¥è¯¢æ¡ä»¶ä¸º \sigma_{A=a}(R)ã€‚

æƒ…å†µ1ï¼šç´¢å¼•é¡ºåºä¸º (A, B)
- å¯ä»¥ä½¿ç”¨ç´¢å¼•çš„å‰ç¼€éƒ¨åˆ†
- æŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦ï¼šO(\log n)
- ç´¢å¼•é€‰æ‹©æ€§ï¼šåŸºäº A çš„é€‰æ‹©æ€§

æƒ…å†µ2ï¼šç´¢å¼•é¡ºåºä¸º (B, A)
- æ— æ³•ä½¿ç”¨ç´¢å¼•ï¼ˆä¸æ»¡è¶³æœ€å·¦å‰ç¼€åŸåˆ™ï¼‰
- éœ€è¦å…¨è¡¨æ‰«æ
- æ—¶é—´å¤æ‚åº¦ï¼šO(n)

å› æ­¤ï¼Œå¯¹äºæŸ¥è¯¢ \sigma_{A=a}(R)ï¼Œç´¢å¼•é¡ºåº (A, B) æ›´ä¼˜ã€‚
\end{theorem}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.1
**æœ€åæ›´æ–°**: 2025-11-22
**PostgreSQLç‰ˆæœ¬**: 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
**ç»´æŠ¤è€…**: Documentation Team
