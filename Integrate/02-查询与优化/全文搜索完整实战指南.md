---
> **📋 文档来源**: 新增深化文档
> **📅 创建日期**: 2025-01
> **⚠️ 注意**: 本文档为深度补充，系统化全文搜索技术栈

---

# PostgreSQL全文搜索完整实战指南

## 元数据

- **文档版本**: v2.0
- **创建日期**: 2025-01
- **技术栈**: PostgreSQL 17+/18+ | zhparser | pgvector | Elasticsearch对比
- **难度级别**: ⭐⭐⭐⭐ (高级)
- **预计阅读**: 150分钟
- **前置要求**: 熟悉PostgreSQL基础、文本处理基础

---

## 📋 完整目录

- [PostgreSQL全文搜索完整实战指南](#postgresql全文搜索完整实战指南)
  - [元数据](#元数据)
  - [📋 完整目录](#-完整目录)
  - [1. 全文搜索基础](#1-全文搜索基础)
    - [1.1 tsvector与tsquery](#11-tsvector与tsquery)
      - [tsvector（文本向量）](#tsvector文本向量)
      - [tsquery（查询向量）](#tsquery查询向量)
    - [1.2 基础搜索语法](#12-基础搜索语法)
      - [操作符](#操作符)
    - [1.3 文本搜索配置](#13-文本搜索配置)
      - [内置配置](#内置配置)
  - [2. 中文全文搜索](#2-中文全文搜索)
    - [2.1 zhparser安装与配置](#21-zhparser安装与配置)
      - [安装zhparser](#安装zhparser)
      - [验证安装](#验证安装)
    - [2.2 中文分词配置](#22-中文分词配置)
      - [创建中文文本搜索配置](#创建中文文本搜索配置)
      - [自定义词典](#自定义词典)
    - [2.3 中文搜索实践](#23-中文搜索实践)
      - [创建中文搜索表](#创建中文搜索表)
      - [中文搜索查询](#中文搜索查询)
    - [2.4 中文搜索优化](#24-中文搜索优化)
      - [处理同义词](#处理同义词)
      - [处理停用词](#处理停用词)
  - [3. 多语言全文搜索](#3-多语言全文搜索)
    - [3.1 语言检测](#31-语言检测)
      - [简单语言检测函数](#简单语言检测函数)
    - [3.2 多语言配置](#32-多语言配置)
      - [存储语言信息](#存储语言信息)
    - [3.3 混合语言搜索](#33-混合语言搜索)
      - [多语言搜索查询](#多语言搜索查询)
      - [跨语言搜索](#跨语言搜索)
  - [4. 全文搜索性能优化](#4-全文搜索性能优化)
    - [4.1 GIN vs GiST索引](#41-gin-vs-gist索引)
      - [对比分析](#对比分析)
      - [选择建议](#选择建议)
    - [4.2 索引优化策略](#42-索引优化策略)
      - [GIN索引优化](#gin索引优化)
      - [部分索引](#部分索引)
    - [4.3 查询优化技巧](#43-查询优化技巧)
      - [使用LIMIT限制结果](#使用limit限制结果)
      - [避免在WHERE中使用函数](#避免在where中使用函数)
  - [5. 全文搜索与向量搜索结合](#5-全文搜索与向量搜索结合)
    - [5.1 混合搜索架构](#51-混合搜索架构)
    - [5.2 实现方案](#52-实现方案)
      - [创建混合搜索表](#创建混合搜索表)
    - [5.3 相关性融合](#53-相关性融合)
      - [RRF (Reciprocal Rank Fusion)](#rrf-reciprocal-rank-fusion)
  - [7. 全文搜索与RAG集成](#7-全文搜索与rag集成)
    - [7.1 RAG中的检索策略](#71-rag中的检索策略)
      - [混合检索RAG](#混合检索rag)
  - [8. 与Elasticsearch对比](#8-与elasticsearch对比)
    - [8.1 功能对比](#81-功能对比)
    - [8.2 性能对比](#82-性能对比)
    - [8.3 选择建议](#83-选择建议)
  - [9. 实战案例](#9-实战案例)
    - [9.1 博客搜索系统](#91-博客搜索系统)
      - [数据模型](#数据模型)

---

## 1. 全文搜索基础

### 1.1 tsvector与tsquery

#### tsvector（文本向量）

```sql
-- tsvector是文档的向量表示，包含词元和位置信息（带错误处理）
DO $$
DECLARE
    result_vector tsvector;
BEGIN
    BEGIN
        result_vector := to_tsvector('english', 'PostgreSQL is a powerful open source database');
        RAISE NOTICE 'tsvector生成成功: %', result_vector;
        -- 结果: 'databas':7 'open':5 'postgresql':1 'power':4 'sourc':6
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '生成tsvector失败: %', SQLERRM;
    END;
END $$;

-- 查看详细信息（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始测试ts_debug';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '测试准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT ts_debug('english', 'PostgreSQL is a powerful database');
```

#### tsquery（查询向量）

```sql
-- tsquery是查询的向量表示（带错误处理）
DO $$
DECLARE
    result_query tsquery;
BEGIN
    BEGIN
        result_query := to_tsquery('english', 'postgresql & database');
        RAISE NOTICE 'tsquery生成成功: %', result_query;
        -- 结果: 'postgresql' & 'databas'
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '生成tsquery失败: %', SQLERRM;
    END;
END $$;

-- 使用tsquery搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行全文搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '搜索准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', 'postgresql & database');
-- 注意：此查询无法使用索引，因为tsvector在WHERE中动态生成
-- 推荐：使用预计算的tsvector列
```

### 1.2 基础搜索语法

#### 操作符

```sql
-- & (AND) - 必须同时包含（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'english') THEN
            RAISE WARNING '文本搜索配置不存在: english';
        END IF;
        RAISE NOTICE '开始测试AND查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'AND查询测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsquery('english', 'postgresql & database');

-- | (OR) - 包含任一即可（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'english') THEN
            RAISE WARNING '文本搜索配置不存在: english';
        END IF;
        RAISE NOTICE '开始测试OR查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'OR查询测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsquery('english', 'postgresql | mysql');

-- ! (NOT) - 不包含（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'english') THEN
            RAISE WARNING '文本搜索配置不存在: english';
        END IF;
        RAISE NOTICE '开始测试NOT查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'NOT查询测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsquery('english', 'postgresql & !mysql');

-- 组合使用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'english') THEN
            RAISE WARNING '文本搜索配置不存在: english';
        END IF;
        RAISE NOTICE '开始测试组合查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '组合查询测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsquery('english', '(postgresql | mysql) & database & !oracle');

-- <-> (FOLLOWED BY) - 相邻（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'english') THEN
            RAISE WARNING '文本搜索配置不存在: english';
        END IF;
        RAISE NOTICE '开始测试FOLLOWED BY查询（"postgresql database"相邻）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'FOLLOWED BY查询测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsquery('english', 'postgresql <-> database');

-- <N> (距离N) - 距离N个词（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'english') THEN
            RAISE WARNING '文本搜索配置不存在: english';
        END IF;
        RAISE NOTICE '开始测试距离查询（距离2个词以内）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '距离查询测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsquery('english', 'postgresql <2> database');
```

### 1.3 文本搜索配置

#### 内置配置

```sql
-- 查看可用的文本搜索配置（带错误处理和性能测试）
DO $$
DECLARE
    config_count INT;
BEGIN
    BEGIN
        SELECT COUNT(*) INTO config_count FROM pg_ts_config;
        RAISE NOTICE '找到 % 个文本搜索配置', config_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询文本搜索配置失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT cfgname FROM pg_ts_config;

-- 常用配置
-- 'english' - 英语
-- 'simple' - 简单配置（不分词）
-- 'chinese' - 中文（需要安装zhparser）
-- 'japanese' - 日语
-- 'korean' - 韩语

-- 使用不同配置（带错误处理和性能测试）
DO $$
DECLARE
    result_vector tsvector;
BEGIN
    BEGIN
        result_vector := to_tsvector('english', 'running databases');
        RAISE NOTICE 'english配置测试成功: %', result_vector;
        -- 结果: 'databas':2 'run':1  (running被词干化为run)
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'english配置测试失败: %', SQLERRM;
    END;

    BEGIN
        result_vector := to_tsvector('simple', 'running databases');
        RAISE NOTICE 'simple配置测试成功: %', result_vector;
        -- 结果: 'databases':2 'running':1  (simple配置不分词)
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'simple配置测试失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsvector('english', 'running databases');

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsvector('simple', 'running databases');
```

---

## 2. 中文全文搜索

### 2.1 zhparser安装与配置

#### 安装zhparser

```bash
# Ubuntu/Debian
sudo apt-get install postgresql-17-zhparser

# 或从源码编译
git clone https://github.com/amutu/zhparser.git
cd zhparser
make && sudo make install

# 在数据库中创建扩展
psql -d mydb -c "CREATE EXTENSION zhparser;"
```

#### 验证安装

```sql
-- 检查扩展（带错误处理和性能测试）
DO $$
DECLARE
    ext_count INT;
BEGIN
    BEGIN
        SELECT COUNT(*) INTO ext_count
        FROM pg_extension WHERE extname = 'zhparser';

        IF ext_count = 0 THEN
            RAISE WARNING 'zhparser扩展未安装，请先安装zhparser扩展';
        ELSE
            RAISE NOTICE 'zhparser扩展已安装';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '检查zhparser扩展失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM pg_extension WHERE extname = 'zhparser';

-- 测试中文分词（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'zhparser') THEN
            RAISE WARNING 'zhparser扩展未安装，无法测试中文分词';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'zhparser') THEN
            RAISE WARNING 'zhparser文本搜索配置不存在，请先创建配置';
            RETURN;
        END IF;
        RAISE NOTICE '开始测试中文分词';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '中文分词测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsvector('zhparser', 'PostgreSQL是一个强大的开源数据库');
-- 结果会显示分词结果
```

### 2.2 中文分词配置

#### 创建中文文本搜索配置

```sql
-- 创建中文文本搜索配置（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'zhparser') THEN
            RAISE EXCEPTION 'zhparser扩展未安装，请先安装zhparser扩展';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese_zhparser') THEN
            RAISE WARNING '文本搜索配置 chinese_zhparser 已存在';
        ELSE
            CREATE TEXT SEARCH CONFIGURATION chinese_zhparser (PARSER = zhparser);
            RAISE NOTICE '文本搜索配置 chinese_zhparser 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_object THEN
            RAISE EXCEPTION 'zhparser解析器不存在，请先安装zhparser扩展';
        WHEN duplicate_object THEN
            RAISE WARNING '文本搜索配置 chinese_zhparser 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建文本搜索配置失败: %', SQLERRM;
    END;
END $$;

-- 添加token映射（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese_zhparser') THEN
            RAISE EXCEPTION '文本搜索配置 chinese_zhparser 不存在，请先创建配置';
        END IF;

        ALTER TEXT SEARCH CONFIGURATION chinese_zhparser
    ADD MAPPING FOR n,v,a,i,e,l WITH simple;

-- 测试配置（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese_zhparser') THEN
            RAISE WARNING '文本搜索配置 chinese_zhparser 不存在，请先创建配置';
            RETURN;
        END IF;
        RAISE NOTICE '开始测试中文文本搜索配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '配置测试准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsvector('chinese_zhparser', 'PostgreSQL是一个强大的开源数据库');

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT to_tsquery('chinese_zhparser', '数据库');
```

#### 自定义词典

```sql
-- zhparser使用jieba词典，可以添加自定义词典
-- 在postgresql.conf中配置
-- zhparser.multi_short = true  # 启用短词识别
-- zhparser.dict_in_memory = false  # 词典不加载到内存（节省内存）

-- 或者使用pg_jieba（另一个jieba扩展）
CREATE EXTENSION pg_jieba;

SELECT jieba_cut('PostgreSQL是一个强大的开源数据库');
```

### 2.3 中文搜索实践

#### 创建中文搜索表

```sql
-- 创建文章表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 已存在';
        ELSE
            CREATE TABLE articles (
                id SERIAL PRIMARY KEY,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at TIMESTAMPTZ DEFAULT NOW(),
                -- 预计算tsvector
                tsv tsvector
            );
            RAISE NOTICE '表 articles 创建成功';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 articles 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表 articles 失败: %', SQLERRM;
    END;
END $$;

-- 创建触发器自动更新tsvector（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_article_tsv') THEN
            DROP FUNCTION update_article_tsv() CASCADE;
            RAISE NOTICE '函数 update_article_tsv 已存在，先删除';
        END IF;

        CREATE OR REPLACE FUNCTION update_article_tsv()
        RETURNS TRIGGER AS $$
        BEGIN
            BEGIN
                NEW.tsv :=
                    setweight(to_tsvector('chinese_zhparser', COALESCE(NEW.title, '')), 'A') ||
                    setweight(to_tsvector('chinese_zhparser', COALESCE(NEW.content, '')), 'B');
                RETURN NEW;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE EXCEPTION '更新tsvector失败: %', SQLERRM;
            END;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 update_article_tsv 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建函数 update_article_tsv 失败: %', SQLERRM;
    END;

    BEGIN
        IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_article_tsv_trigger') THEN
            DROP TRIGGER update_article_tsv_trigger ON articles;
            RAISE NOTICE '触发器 update_article_tsv_trigger 已存在，先删除';
        END IF;

        CREATE TRIGGER update_article_tsv_trigger
        BEFORE INSERT OR UPDATE ON articles
        FOR EACH ROW
        EXECUTE FUNCTION update_article_tsv();
        RAISE NOTICE '触发器 update_article_tsv_trigger 创建成功';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在，无法创建触发器';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建触发器失败: %', SQLERRM;
    END;
END $$;

-- 创建GIN索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE EXCEPTION '表 articles 不存在，无法创建索引';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'idx_articles_tsv') THEN
            RAISE WARNING '索引 idx_articles_tsv 已存在';
        ELSE
            CREATE INDEX idx_articles_tsv ON articles USING GIN (tsv);
            RAISE NOTICE 'GIN索引 idx_articles_tsv 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_articles_tsv 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建GIN索引失败: %', SQLERRM;
    END;
END $$;
```

#### 中文搜索查询

```sql
-- 基础搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行搜索';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'idx_articles_tsv') THEN
            RAISE WARNING 'GIN索引 idx_articles_tsv 不存在，查询可能较慢';
        END IF;
        RAISE NOTICE '开始执行基础搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '搜索准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, title, content
FROM articles
WHERE tsv @@ to_tsquery('chinese_zhparser', '数据库');

-- 相关性排序（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行相关性排序';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行相关性排序搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '搜索准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    ts_rank(tsv, query) AS rank
FROM articles, to_tsquery('chinese_zhparser', 'PostgreSQL & 数据库') query
WHERE tsv @@ query
ORDER BY rank DESC
LIMIT 10;

-- 加权搜索（标题权重更高）
SELECT
    id,
    title,
    content,
    ts_rank_cd(
        '{0.1, 0.2, 0.4, 1.0}',  -- 权重向量
        tsv,
        query
    ) AS rank
FROM articles, to_tsquery('chinese_zhparser', 'PostgreSQL & 数据库') query
WHERE tsv @@ query
ORDER BY rank DESC;
```

### 2.4 中文搜索优化

#### 处理同义词

```sql
-- 创建同义词词典（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 注意：synonym模板需要系统文件支持
        -- 创建同义词文件（需要系统文件）
        -- 格式: 源词 => 目标词
        -- 例如: 数据库 => database
        --       资料库 => database

        IF EXISTS (SELECT 1 FROM pg_ts_dict WHERE dictname = 'chinese_synonym') THEN
            RAISE WARNING '同义词词典 chinese_synonym 已存在';
        ELSE
            CREATE TEXT SEARCH DICTIONARY chinese_synonym (
                TEMPLATE = synonym,
                SYNONYMS = chinese_synonym
            );
            RAISE NOTICE '同义词词典 chinese_synonym 创建成功（需要系统文件支持）';
        END IF;
    EXCEPTION
        WHEN undefined_file THEN
            RAISE EXCEPTION '同义词文件未找到（需要创建系统文件）';
        WHEN duplicate_object THEN
            RAISE WARNING '同义词词典 chinese_synonym 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建同义词词典失败: %', SQLERRM;
    END;

    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese_zhparser') THEN
            RAISE EXCEPTION '文本搜索配置 chinese_zhparser 不存在';
        END IF;

        ALTER TEXT SEARCH CONFIGURATION chinese_zhparser
            ALTER MAPPING FOR n,v,a,i,e,l
            WITH chinese_synonym, simple;
        RAISE NOTICE '同义词词典已添加到配置中';
    EXCEPTION
        WHEN undefined_object THEN
            RAISE EXCEPTION '文本搜索配置 chinese_zhparser 不存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '更新配置失败: %', SQLERRM;
    END;
END $$;
```

#### 处理停用词

```sql
-- 创建停用词词典（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 注意：停用词词典需要系统文件支持
        -- 创建停用词文件（需要系统文件）

        IF EXISTS (SELECT 1 FROM pg_ts_dict WHERE dictname = 'chinese_stopwords') THEN
            RAISE WARNING '停用词词典 chinese_stopwords 已存在';
        ELSE
            CREATE TEXT SEARCH DICTIONARY chinese_stopwords (
                TEMPLATE = pg_catalog.simple,
                STOPWORDS = chinese_stopwords
            );
            RAISE NOTICE '停用词词典 chinese_stopwords 创建成功（需要系统文件支持）';
        END IF;
    EXCEPTION
        WHEN undefined_file THEN
            RAISE EXCEPTION '停用词文件未找到（需要创建系统文件）';
        WHEN duplicate_object THEN
            RAISE WARNING '停用词词典 chinese_stopwords 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建停用词词典失败: %', SQLERRM;
    END;

    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese_zhparser') THEN
            RAISE EXCEPTION '文本搜索配置 chinese_zhparser 不存在';
        END IF;

        ALTER TEXT SEARCH CONFIGURATION chinese_zhparser
            ALTER MAPPING FOR n,v,a,i,e,l
            WITH chinese_stopwords, simple;
        RAISE NOTICE '停用词词典已添加到配置中';
    EXCEPTION
        WHEN undefined_object THEN
            RAISE EXCEPTION '文本搜索配置 chinese_zhparser 不存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '更新配置失败: %', SQLERRM;
    END;
END $$;
```

---

## 3. 多语言全文搜索

### 3.1 语言检测

#### 简单语言检测函数

```sql
-- 创建语言检测函数（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'detect_language') THEN
            DROP FUNCTION detect_language(TEXT) CASCADE;
            RAISE NOTICE '函数 detect_language 已存在，先删除';
        END IF;

        CREATE OR REPLACE FUNCTION detect_language(text TEXT)
        RETURNS regconfig AS $$
        BEGIN
            -- 参数验证
            IF text IS NULL OR TRIM(text) = '' THEN
                RAISE EXCEPTION '输入文本不能为空';
            END IF;

            BEGIN
                -- 检测中文字符
                IF text ~ '[\u4e00-\u9fa5]' THEN
                    RETURN 'chinese_zhparser'::regconfig;
                -- 检测日文字符
                ELSIF text ~ '[\u3040-\u309F\u30A0-\u30FF]' THEN
                    RETURN 'japanese'::regconfig;
                -- 检测韩文字符
                ELSIF text ~ '[\uAC00-\uD7A3]' THEN
                    RETURN 'korean'::regconfig;
                -- 默认英语
                ELSE
                    RETURN 'english'::regconfig;
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE EXCEPTION '语言检测失败: %', SQLERRM;
            END;
        END;
        $$ LANGUAGE plpgsql IMMUTABLE;
        RAISE NOTICE '函数 detect_language 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建函数 detect_language 失败: %', SQLERRM;
    END;
END $$;

-- 使用函数（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT detect_language('PostgreSQL是一个强大的数据库');
-- 返回: chinese_zhparser
```

### 3.2 多语言配置

#### 存储语言信息

```sql
-- 创建多语言文章表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
            RAISE WARNING '表 multilingual_articles 已存在';
        ELSE
            CREATE TABLE multilingual_articles (
                id SERIAL PRIMARY KEY,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                language TEXT NOT NULL,  -- 'chinese', 'english', 'japanese', etc.
                tsv tsvector,
                created_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 multilingual_articles 创建成功';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 multilingual_articles 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表 multilingual_articles 失败: %', SQLERRM;
    END;
END $$;

-- 根据语言自动生成tsvector（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_multilingual_tsv') THEN
            DROP FUNCTION update_multilingual_tsv() CASCADE;
            RAISE NOTICE '函数 update_multilingual_tsv 已存在，先删除';
        END IF;

        CREATE OR REPLACE FUNCTION update_multilingual_tsv()
        RETURNS TRIGGER AS $$
        DECLARE
            config_name regconfig;
        BEGIN
            -- 参数验证
            IF NEW.language IS NULL OR TRIM(NEW.language) = '' THEN
                RAISE EXCEPTION 'language字段不能为空';
            END IF;

            BEGIN
                -- 根据language选择配置
                CASE NEW.language
                    WHEN 'chinese' THEN config_name := 'chinese_zhparser';
                    WHEN 'japanese' THEN config_name := 'japanese';
                    WHEN 'korean' THEN config_name := 'korean';
                    WHEN 'english' THEN config_name := 'english';
                    ELSE config_name := 'simple';
                END CASE;

                NEW.tsv :=
                    setweight(to_tsvector(config_name, COALESCE(NEW.title, '')), 'A') ||
                    setweight(to_tsvector(config_name, COALESCE(NEW.content, '')), 'B');

                RETURN NEW;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE EXCEPTION '更新多语言tsvector失败: %', SQLERRM;
            END;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 update_multilingual_tsv 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建函数 update_multilingual_tsv 失败: %', SQLERRM;
    END;

    BEGIN
        IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_multilingual_tsv_trigger') THEN
            DROP TRIGGER update_multilingual_tsv_trigger ON multilingual_articles;
            RAISE NOTICE '触发器 update_multilingual_tsv_trigger 已存在，先删除';
        END IF;

        CREATE TRIGGER update_multilingual_tsv_trigger
        BEFORE INSERT OR UPDATE ON multilingual_articles
        FOR EACH ROW
        EXECUTE FUNCTION update_multilingual_tsv();
        RAISE NOTICE '触发器 update_multilingual_tsv_trigger 创建成功';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 multilingual_articles 不存在，无法创建触发器';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建触发器失败: %', SQLERRM;
    END;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
            RAISE EXCEPTION '表 multilingual_articles 不存在，无法创建索引';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'multilingual_articles' AND indexname = 'idx_multilingual_articles_tsv') THEN
            RAISE WARNING '索引 idx_multilingual_articles_tsv 已存在';
        ELSE
            CREATE INDEX idx_multilingual_articles_tsv ON multilingual_articles USING GIN (tsv);
            RAISE NOTICE 'GIN索引 idx_multilingual_articles_tsv 创建成功';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'multilingual_articles' AND indexname = 'idx_multilingual_articles_language') THEN
            RAISE WARNING '索引 idx_multilingual_articles_language 已存在';
        ELSE
            CREATE INDEX idx_multilingual_articles_language ON multilingual_articles (language);
            RAISE NOTICE '索引 idx_multilingual_articles_language 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 multilingual_articles 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '部分索引已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建索引失败: %', SQLERRM;
    END;
END $$;
```

### 3.3 混合语言搜索

#### 多语言搜索查询

```sql
-- 搜索多种语言
WITH queries AS (
    SELECT
        'chinese' AS lang,
        to_tsquery('chinese_zhparser', '数据库') AS query
    UNION ALL
    SELECT
        'english' AS lang,
        to_tsquery('english', 'database') AS query
)
SELECT
    a.id,
    a.title,
    a.content,
    a.language,
    ts_rank(a.tsv, q.query) AS rank
FROM multilingual_articles a
JOIN queries q ON a.language = q.lang
WHERE a.tsv @@ q.query
ORDER BY rank DESC
LIMIT 20;
```

#### 跨语言搜索

```sql
-- 跨语言搜索（将查询转换为多种语言，带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'multilingual_search') THEN
            DROP FUNCTION multilingual_search(TEXT) CASCADE;
            RAISE NOTICE '函数 multilingual_search 已存在，先删除';
        END IF;

        CREATE OR REPLACE FUNCTION multilingual_search(search_text TEXT)
        RETURNS TABLE (
            id INTEGER,
            title TEXT,
            content TEXT,
            language TEXT,
            rank REAL
        ) AS $$
        BEGIN
            -- 参数验证
            IF search_text IS NULL OR TRIM(search_text) = '' THEN
                RAISE EXCEPTION '搜索文本不能为空';
            END IF;

            -- 检查表是否存在
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
                RAISE EXCEPTION '表 multilingual_articles 不存在';
            END IF;

            BEGIN
                RETURN QUERY
                SELECT
                    a.id,
                    a.title,
                    a.content,
                    a.language,
                    CASE a.language
                        WHEN 'chinese' THEN ts_rank(a.tsv, to_tsquery('chinese_zhparser', search_text))
                        WHEN 'english' THEN ts_rank(a.tsv, to_tsquery('english', search_text))
                        ELSE 0
                    END AS rank
                FROM multilingual_articles a
                WHERE
                    (a.language = 'chinese' AND a.tsv @@ to_tsquery('chinese_zhparser', search_text))
                    OR
                    (a.language = 'english' AND a.tsv @@ to_tsquery('english', search_text))
                ORDER BY rank DESC;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE EXCEPTION '跨语言搜索执行失败: %', SQLERRM;
            END;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 multilingual_search 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建函数 multilingual_search 失败: %', SQLERRM;
    END;
END $$;

-- 使用函数（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM multilingual_search('数据库 | database');
```

---

## 4. 全文搜索性能优化

### 4.1 GIN vs GiST索引

#### 对比分析

| 特性 | GIN索引 | GiST索引 |
|------|---------|----------|
| **查询速度** | 快 | 较慢 |
| **索引大小** | 大 | 小 |
| **更新速度** | 慢 | 快 |
| **适用场景** | 读多写少 | 写多读少 |
| **支持操作** | @@, @@@ | @@ |

#### 选择建议

```sql
-- ✅ 推荐使用GIN索引（大多数场景，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE EXCEPTION '表 articles 不存在，无法创建索引';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'idx_articles_tsv_gin') THEN
            RAISE WARNING '索引 idx_articles_tsv_gin 已存在';
        ELSE
            CREATE INDEX idx_articles_tsv_gin ON articles USING GIN (tsv);
            RAISE NOTICE 'GIN索引 idx_articles_tsv_gin 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_articles_tsv_gin 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建GIN索引失败: %', SQLERRM;
    END;
END $$;

-- ✅ 写密集型场景使用GiST索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE EXCEPTION '表 articles 不存在，无法创建索引';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'idx_articles_tsv_gist') THEN
            RAISE WARNING '索引 idx_articles_tsv_gist 已存在';
        ELSE
            CREATE INDEX idx_articles_tsv_gist ON articles USING GIST (tsv);
            RAISE NOTICE 'GiST索引 idx_articles_tsv_gist 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_articles_tsv_gist 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建GiST索引失败: %', SQLERRM;
    END;
END $$;

-- 注意：GIN不支持组合索引，需要分别创建空间索引和全文搜索索引
```

### 4.2 索引优化策略

#### GIN索引优化

```sql
-- 使用fastupdate参数（延迟更新，提升写入性能，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE EXCEPTION '表 articles 不存在，无法创建索引';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'idx_articles_tsv') THEN
            RAISE WARNING '索引 idx_articles_tsv 已存在，如需重新创建请先删除';
        ELSE
            CREATE INDEX idx_articles_tsv ON articles
            USING GIN (tsv) WITH (fastupdate = on);
            RAISE NOTICE 'GIN索引 idx_articles_tsv 创建成功（fastupdate=on）';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_articles_tsv 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建GIN索引失败: %', SQLERRM;
    END;
END $$;

-- 定期清理待处理的更新（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE EXCEPTION '表 articles 不存在，无法执行VACUUM';
        END IF;

        -- GIN索引会积累待处理的更新，需要定期清理
        VACUUM articles;
        RAISE NOTICE 'VACUUM执行成功: articles';

        -- 或者手动清理（带统计信息更新）
        VACUUM ANALYZE articles;
        RAISE NOTICE 'VACUUM ANALYZE执行成功: articles';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'VACUUM执行失败: %', SQLERRM;
    END;
END $$;
```

#### 部分索引

```sql
-- 只为活跃文章创建索引（节省空间，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE EXCEPTION '表 articles 不存在，无法创建索引';
        END IF;

        -- 检查列是否存在
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'articles' AND column_name = 'status'
        ) THEN
            RAISE EXCEPTION '列 status 不存在';
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'articles' AND column_name = 'created_at'
        ) THEN
            RAISE EXCEPTION '列 created_at 不存在';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'idx_articles_active_tsv') THEN
            RAISE WARNING '索引 idx_articles_active_tsv 已存在';
        ELSE
            CREATE INDEX idx_articles_active_tsv ON articles
            USING GIN (tsv)
            WHERE status = 'published' AND created_at > NOW() - INTERVAL '1 year';
            RAISE NOTICE '部分索引 idx_articles_active_tsv 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在';
        WHEN undefined_column THEN
            RAISE EXCEPTION '列不存在（请检查status和created_at列）';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_articles_active_tsv 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建部分索引失败: %', SQLERRM;
    END;
END $$;
```

### 4.3 查询优化技巧

#### 使用LIMIT限制结果

```sql
-- ✅ 推荐：使用LIMIT限制结果数量（带错误处理和性能测试）
DO $$
DECLARE
    query_text tsquery;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行搜索';
            RETURN;
        END IF;

        query_text := to_tsquery('chinese_zhparser', '数据库');
        RAISE NOTICE '开始执行LIMIT搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '搜索准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('chinese_zhparser', '数据库')
ORDER BY ts_rank(tsv, to_tsquery('chinese_zhparser', '数据库')) DESC
LIMIT 20;
```

#### 避免在WHERE中使用函数

```sql
-- ❌ 不推荐：函数在WHERE中，无法使用索引（带性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行搜索';
            RETURN;
        END IF;
        RAISE NOTICE '测试不推荐方式（函数在WHERE中）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '搜索准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE to_tsvector('chinese_zhparser', title || ' ' || content)
      @@ to_tsquery('chinese_zhparser', '数据库');
-- 执行时间: 慢（无法使用索引，需要动态生成tsvector）

-- ✅ 推荐：使用预计算的tsvector列（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行搜索';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'articles' AND column_name = 'tsv'
        ) THEN
            RAISE WARNING '列 tsv 不存在，请先创建tsvector列';
            RETURN;
        END IF;
        RAISE NOTICE '测试推荐方式（使用预计算的tsvector列）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '搜索准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('chinese_zhparser', '数据库');
-- 执行时间: 快（可以使用GIN索引）
```

---

## 5. 全文搜索与向量搜索结合

### 5.1 混合搜索架构

```text
用户查询
    ↓
查询理解
    ├─ 全文搜索查询（关键词匹配）
    └─ 向量搜索查询（语义匹配）
    ↓
并行检索
    ├─ 全文搜索结果（精确匹配）
    └─ 向量搜索结果（语义相似）
    ↓
结果融合（RRF、加权融合）
    ↓
排序结果
```

### 5.2 实现方案

#### 创建混合搜索表

```sql
-- 创建包含全文搜索和向量搜索的表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 已存在';
        ELSE
            -- 检查pgvector扩展
            IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector') THEN
                RAISE EXCEPTION 'pgvector扩展未安装，请先执行: CREATE EXTENSION vector;';
            END IF;

            CREATE TABLE documents (
                id SERIAL PRIMARY KEY,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                -- 全文搜索
                tsv tsvector,
                -- 向量搜索（使用pgvector）
                embedding vector(384)  -- 使用sentence-transformers模型
            );
            RAISE NOTICE '表 documents 创建成功';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 documents 已存在';
        WHEN undefined_object THEN
            RAISE EXCEPTION 'pgvector扩展未安装';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表 documents 失败: %', SQLERRM;
    END;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE EXCEPTION '表 documents 不存在，无法创建索引';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'documents' AND indexname = 'idx_documents_tsv') THEN
            RAISE WARNING '索引 idx_documents_tsv 已存在';
        ELSE
            CREATE INDEX idx_documents_tsv ON documents USING GIN (tsv);
            RAISE NOTICE 'GIN索引 idx_documents_tsv 创建成功';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'documents' AND indexname = 'idx_documents_embedding') THEN
            RAISE WARNING '索引 idx_documents_embedding 已存在';
        ELSE
            -- 检查pgvector扩展
            IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector') THEN
                RAISE EXCEPTION 'pgvector扩展未安装，无法创建向量索引';
            END IF;

            CREATE INDEX idx_documents_embedding ON documents USING ivfflat (embedding vector_cosine_ops);
            RAISE NOTICE 'IVFFlat索引 idx_documents_embedding 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 documents 不存在';
        WHEN undefined_object THEN
            RAISE EXCEPTION 'pgvector扩展未安装';
        WHEN duplicate_table THEN
            RAISE WARNING '部分索引已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建索引失败: %', SQLERRM;
    END;
END $$;
```

```

#### 混合检索函数

```sql
-- 创建混合检索函数（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'hybrid_search') THEN
            DROP FUNCTION hybrid_search(TEXT, REAL, REAL, INTEGER) CASCADE;
            RAISE NOTICE '函数 hybrid_search 已存在，先删除';
        END IF;

        CREATE OR REPLACE FUNCTION hybrid_search(
            search_text TEXT,
            text_weight REAL DEFAULT 0.5,
            vector_weight REAL DEFAULT 0.5,
            limit_count INTEGER DEFAULT 20
        )
        RETURNS TABLE (
            id INTEGER,
            title TEXT,
            content TEXT,
            text_score REAL,
            vector_score REAL,
            combined_score REAL
        ) AS $$
        DECLARE
            query_embedding vector(384);
            search_query tsquery;
        BEGIN
            -- 参数验证
            IF search_text IS NULL OR TRIM(search_text) = '' THEN
                RAISE EXCEPTION '搜索文本不能为空';
            END IF;

            IF text_weight < 0 OR text_weight > 1 OR vector_weight < 0 OR vector_weight > 1 THEN
                RAISE EXCEPTION '权重必须在0-1之间: text_weight=%, vector_weight=%', text_weight, vector_weight;
            END IF;

            IF limit_count IS NULL OR limit_count < 1 OR limit_count > 1000 THEN
                RAISE EXCEPTION 'limit_count必须在1-1000之间: %', limit_count;
            END IF;

            -- 检查表是否存在
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
                RAISE EXCEPTION '表 documents 不存在';
            END IF;

            BEGIN
                -- 生成查询向量（这里简化，实际需要调用嵌入模型）
                -- query_embedding := generate_embedding(search_text);
                -- 临时使用零向量（实际应用中需要调用嵌入模型）
                query_embedding := (SELECT embedding FROM documents LIMIT 1);
                IF query_embedding IS NULL THEN
                    RAISE EXCEPTION '无法生成查询向量（表documents为空或embedding列不存在）';
                END IF;

                -- 生成全文搜索查询
                search_query := to_tsquery('chinese_zhparser', search_text);

                RETURN QUERY
                WITH text_results AS (
                    SELECT
                        d.id,
                        d.title,
                        d.content,
                        ts_rank(d.tsv, search_query) AS score
                    FROM documents d
                    WHERE d.tsv @@ search_query
                    ORDER BY score DESC
                    LIMIT limit_count * 2  -- 获取更多候选结果
                ),
                vector_results AS (
                    SELECT
                        d.id,
                        d.title,
                        d.content,
                        1 - (d.embedding <=> query_embedding) AS score  -- 余弦相似度
                    FROM documents d
                    ORDER BY d.embedding <=> query_embedding
                    LIMIT limit_count * 2
                ),
                combined AS (
                    SELECT
                        COALESCE(t.id, v.id) AS id,
                        COALESCE(t.title, v.title) AS title,
                        COALESCE(t.content, v.content) AS content,
                        COALESCE(t.score, 0) AS text_score,
                        COALESCE(v.score, 0) AS vector_score,
                        COALESCE(t.score, 0) * text_weight + COALESCE(v.score, 0) * vector_weight AS combined_score
                    FROM text_results t
                    FULL OUTER JOIN vector_results v ON t.id = v.id
                )
                SELECT
                    c.id,
                    c.title,
                    c.content,
                    c.text_score,
                    c.vector_score,
                    c.combined_score
                FROM combined c
                ORDER BY c.combined_score DESC
                LIMIT limit_count;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE EXCEPTION '混合检索执行失败: %', SQLERRM;
            END;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 hybrid_search 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建函数 hybrid_search 失败: %', SQLERRM;
    END;
END $$;
```

### 5.3 相关性融合

#### RRF (Reciprocal Rank Fusion)

```sql
-- RRF融合算法
CREATE OR REPLACE FUNCTION rrf_fusion(
    text_ranks INTEGER[],
    vector_ranks INTEGER[],
    k INTEGER DEFAULT 60
)
RETURNS REAL AS $$
DECLARE
    text_score REAL := 0;
    vector_score REAL := 0;
    i INTEGER;
BEGIN
    -- 计算文本搜索RRF分数
    FOREACH i IN ARRAY text_ranks
    LOOP
        text_score := text_score + 1.0 / (k + i);
    END LOOP;

    -- 计算向量搜索RRF分数
    FOREACH i IN ARRAY vector_ranks
    LOOP
        vector_score := vector_score + 1.0 / (k + i);
    END LOOP;

    RETURN text_score + vector_score;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## 7. 全文搜索与RAG集成

### 7.1 RAG中的检索策略

#### 混合检索RAG

```python
# Python示例：混合检索RAG
import psycopg2
from sentence_transformers import SentenceTransformer
import numpy as np

class HybridRetrievalRAG:
    """混合检索RAG系统"""

    def __init__(self, db_config, embedding_model_name='paraphrase-multilingual-MiniLM-L12-v2'):
        self.conn = psycopg2.connect(**db_config)
        self.cursor = self.conn.cursor()
        self.embedding_model = SentenceTransformer(embedding_model_name)

    def retrieve(self, query: str, top_k: int = 5, text_weight: float = 0.4, vector_weight: float = 0.6):
        """混合检索"""
        # 生成查询向量
        query_embedding = self.embedding_model.encode(query).tolist()

        # 全文搜索 + 向量搜索
        self.cursor.execute("""
            WITH text_results AS (
                SELECT
                    id,
                    content,
                    ts_rank(tsv, to_tsquery('chinese_zhparser', %s)) AS text_score
                FROM documents
                WHERE tsv @@ to_tsquery('chinese_zhparser', %s)
                ORDER BY text_score DESC
                LIMIT %s
            ),
            vector_results AS (
                SELECT
                    id,
                    content,
                    1 - (embedding <=> %s::vector) AS vector_score
                FROM documents
                ORDER BY embedding <=> %s::vector
                LIMIT %s
            ),
            combined AS (
                SELECT
                    COALESCE(t.id, v.id) AS id,
                    COALESCE(t.content, v.content) AS content,
                    COALESCE(t.text_score, 0) * %s + COALESCE(v.vector_score, 0) * %s AS combined_score
                FROM text_results t
                FULL OUTER JOIN vector_results v ON t.id = v.id
            )
            SELECT id, content, combined_score
            FROM combined
            ORDER BY combined_score DESC
            LIMIT %s
        """, (
            query, query, top_k * 2,
            query_embedding, query_embedding, top_k * 2,
            text_weight, vector_weight,
            top_k
        ))

        return self.cursor.fetchall()
```

---

## 8. 与Elasticsearch对比

### 8.1 功能对比

| 特性 | PostgreSQL全文搜索 | Elasticsearch |
| --- | --- | --- |
| **安装部署** | 内置，无需额外组件 | 需要独立部署 |
| **中文支持** | 需要zhparser扩展 | 内置IK分词器 |
| **实时性** | 实时（事务内） | 近实时（1秒） |
| **一致性** | 强一致性（ACID） | 最终一致性 |
| **复杂查询** | SQL丰富 | DSL灵活 |
| **扩展性** | 垂直扩展 | 水平扩展 |
| **学习成本** | 低（SQL） | 中（DSL） |

### 8.2 性能对比

```text
小规模数据（<100万文档）:
- PostgreSQL: 性能相当或更好
- Elasticsearch: 开销较大

中等规模数据（100万-1亿文档）:
- PostgreSQL: 性能良好，需要优化
- Elasticsearch: 性能优秀，横向扩展

大规模数据（>1亿文档）:
- PostgreSQL: 需要分片和优化
- Elasticsearch: 天然支持分布式
```

### 8.3 选择建议

```text
选择PostgreSQL全文搜索:
✅ 数据量 < 1亿文档
✅ 需要强一致性
✅ 需要复杂SQL查询
✅ 希望减少系统复杂度
✅ 数据已在PostgreSQL中

选择Elasticsearch:
✅ 数据量 > 1亿文档
✅ 需要水平扩展
✅ 需要复杂的聚合分析
✅ 需要日志分析场景
✅ 可以接受最终一致性
```

---

## 9. 实战案例

### 9.1 博客搜索系统

#### 数据模型

```sql
-- 博客文章表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'blog_posts') THEN
            RAISE WARNING '表 blog_posts 已存在';
        ELSE
            CREATE TABLE blog_posts (
                id SERIAL PRIMARY KEY,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                author_id INTEGER,
                category_id INTEGER,
                published_at TIMESTAMPTZ,
                status TEXT DEFAULT 'draft',  -- 'draft', 'published', 'archived'
                tsv tsvector,
                view_count INTEGER DEFAULT 0
            );
            RAISE NOTICE '表 blog_posts 创建成功';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 blog_posts 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表 blog_posts 失败: %', SQLERRM;
    END;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'blog_posts') THEN
            RAISE EXCEPTION '表 blog_posts 不存在，无法创建索引';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'blog_posts' AND indexname = 'idx_blog_posts_tsv') THEN
            RAISE WARNING '索引 idx_blog_posts_tsv 已存在';
        ELSE
            CREATE INDEX idx_blog_posts_tsv ON blog_posts USING GIN (tsv);
            RAISE NOTICE 'GIN索引 idx_blog_posts_tsv 创建成功';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'blog_posts' AND indexname = 'idx_blog_posts_status') THEN
            RAISE WARNING '索引 idx_blog_posts_status 已存在';
        ELSE
            CREATE INDEX idx_blog_posts_status ON blog_posts (status) WHERE status = 'published';
            RAISE NOTICE '部分索引 idx_blog_posts_status 创建成功';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'blog_posts' AND indexname = 'idx_blog_posts_published') THEN
            RAISE WARNING '索引 idx_blog_posts_published 已存在';
        ELSE
            CREATE INDEX idx_blog_posts_published ON blog_posts (published_at DESC) WHERE status = 'published';
            RAISE NOTICE '部分索引 idx_blog_posts_published 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 blog_posts 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '部分索引已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建索引失败: %', SQLERRM;
    END;
END $$;

#### 搜索API

```sql
-- 搜索博客文章（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'search_blog_posts') THEN
            DROP FUNCTION search_blog_posts(TEXT, INTEGER, INTEGER) CASCADE;
            RAISE NOTICE '函数 search_blog_posts 已存在，先删除';
        END IF;

        CREATE OR REPLACE FUNCTION search_blog_posts(
            search_text TEXT,
            category_id INTEGER DEFAULT NULL,
            limit_count INTEGER DEFAULT 20
        )
        RETURNS TABLE (
            id INTEGER,
            title TEXT,
            content_preview TEXT,
            author_id INTEGER,
            published_at TIMESTAMPTZ,
            rank REAL
        ) AS $$
        DECLARE
            search_query tsquery;
        BEGIN
            -- 参数验证
            IF search_text IS NULL OR TRIM(search_text) = '' THEN
                RAISE EXCEPTION '搜索文本不能为空';
            END IF;

            IF limit_count IS NULL OR limit_count < 1 OR limit_count > 1000 THEN
                RAISE EXCEPTION 'limit_count必须在1-1000之间: %', limit_count;
            END IF;

            -- 检查表是否存在
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'blog_posts') THEN
                RAISE EXCEPTION '表 blog_posts 不存在';
            END IF;

            BEGIN
                -- 生成全文搜索查询
                search_query := to_tsquery('chinese_zhparser', search_text);

                RETURN QUERY
                SELECT
                    p.id,
                    p.title,
                    LEFT(p.content, 200) AS content_preview,
                    p.author_id,
                    p.published_at,
                    ts_rank(p.tsv, search_query) AS rank
                FROM blog_posts p
                WHERE p.status = 'published'
                  AND p.tsv @@ search_query
                  AND (category_id IS NULL OR p.category_id = category_id)
                ORDER BY rank DESC, p.published_at DESC
                LIMIT limit_count;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE EXCEPTION '搜索执行失败: %', SQLERRM;
            END;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 search_blog_posts 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建函数 search_blog_posts 失败: %', SQLERRM;
    END;
END $$;

---

## 📚 参考资源

1. **PostgreSQL全文搜索文档**: <https://www.postgresql.org/docs/current/textsearch.html>
2. **zhparser GitHub**: <https://github.com/amutu/zhparser>
3. **pg_jieba GitHub**: <https://github.com/jaiminpan/pg_jieba>
4. **Elasticsearch对比**: <https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html>

---

## 📝 更新日志

- **v2.0** (2025-01): 完整实战指南
  - 整合全文搜索基础
  - 补充中文全文搜索完整方案
  - 添加多语言全文搜索
  - 补充性能优化策略
  - 添加全文搜索与向量搜索结合
  - 补充高级搜索功能
  - 添加全文搜索与RAG集成
  - 补充Elasticsearch对比
  - 添加实战案例

---

**状态**: ✅ **文档完成** | [返回目录](./README.md)
```
