---
> **ğŸ“‹ æ–‡æ¡£æ¥æº**: æ–°å¢æ·±åŒ–æ–‡æ¡£
> **ğŸ“… åˆ›å»ºæ—¥æœŸ**: 2025-01
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºæ·±åº¦è¡¥å……ï¼Œç³»ç»ŸåŒ–å…¨æ–‡æœç´¢æŠ€æœ¯æ ˆ

---

# PostgreSQLå…¨æ–‡æœç´¢å®Œæ•´å®æˆ˜æŒ‡å—

## å…ƒæ•°æ®

- **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
- **åˆ›å»ºæ—¥æœŸ**: 2025-01
- **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | zhparser | pgvector | Elasticsearchå¯¹æ¯”
- **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
- **é¢„è®¡é˜…è¯»**: 150åˆ†é’Ÿ
- **å‰ç½®è¦æ±‚**: ç†Ÿæ‚‰PostgreSQLåŸºç¡€ã€æ–‡æœ¬å¤„ç†åŸºç¡€

---

## ğŸ“‹ å®Œæ•´ç›®å½•

- [PostgreSQLå…¨æ–‡æœç´¢å®Œæ•´å®æˆ˜æŒ‡å—](#postgresqlå…¨æ–‡æœç´¢å®Œæ•´å®æˆ˜æŒ‡å—)
  - [å…ƒæ•°æ®](#å…ƒæ•°æ®)
  - [ğŸ“‹ å®Œæ•´ç›®å½•](#-å®Œæ•´ç›®å½•)
  - [1. å…¨æ–‡æœç´¢åŸºç¡€](#1-å…¨æ–‡æœç´¢åŸºç¡€)
    - [1.1 tsvectorä¸tsquery](#11-tsvectorä¸tsquery)
    - [1.2 åŸºç¡€æœç´¢è¯­æ³•](#12-åŸºç¡€æœç´¢è¯­æ³•)
    - [1.3 æ–‡æœ¬æœç´¢é…ç½®](#13-æ–‡æœ¬æœç´¢é…ç½®)
  - [2. ä¸­æ–‡å…¨æ–‡æœç´¢](#2-ä¸­æ–‡å…¨æ–‡æœç´¢)
    - [2.1 zhparserå®‰è£…ä¸é…ç½®](#21-zhparserå®‰è£…ä¸é…ç½®)
    - [2.2 ä¸­æ–‡åˆ†è¯é…ç½®](#22-ä¸­æ–‡åˆ†è¯é…ç½®)
    - [2.3 ä¸­æ–‡æœç´¢å®è·µ](#23-ä¸­æ–‡æœç´¢å®è·µ)
    - [2.4 ä¸­æ–‡æœç´¢ä¼˜åŒ–](#24-ä¸­æ–‡æœç´¢ä¼˜åŒ–)
  - [3. å¤šè¯­è¨€å…¨æ–‡æœç´¢](#3-å¤šè¯­è¨€å…¨æ–‡æœç´¢)
    - [3.1 è¯­è¨€æ£€æµ‹](#31-è¯­è¨€æ£€æµ‹)
    - [3.2 å¤šè¯­è¨€é…ç½®](#32-å¤šè¯­è¨€é…ç½®)
    - [3.3 æ··åˆè¯­è¨€æœç´¢](#33-æ··åˆè¯­è¨€æœç´¢)
    - [3.4 å¤šè¯­è¨€æœ€ä½³å®è·µ](#34-å¤šè¯­è¨€æœ€ä½³å®è·µ)
  - [4. å…¨æ–‡æœç´¢æ€§èƒ½ä¼˜åŒ–](#4-å…¨æ–‡æœç´¢æ€§èƒ½ä¼˜åŒ–)
    - [4.1 GIN vs GiSTç´¢å¼•](#41-gin-vs-gistç´¢å¼•)
    - [4.2 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥](#42-ç´¢å¼•ä¼˜åŒ–ç­–ç•¥)
    - [4.3 æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§](#43-æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§)
    - [4.4 åˆ†åŒºè¡¨ä¼˜åŒ–](#44-åˆ†åŒºè¡¨ä¼˜åŒ–)
  - [5. å…¨æ–‡æœç´¢ä¸å‘é‡æœç´¢ç»“åˆ](#5-å…¨æ–‡æœç´¢ä¸å‘é‡æœç´¢ç»“åˆ)
    - [5.1 æ··åˆæœç´¢æ¶æ„](#51-æ··åˆæœç´¢æ¶æ„)
    - [5.2 å®ç°æ–¹æ¡ˆ](#52-å®ç°æ–¹æ¡ˆ)
    - [5.3 ç›¸å…³æ€§èåˆ](#53-ç›¸å…³æ€§èåˆ)
    - [5.4 æ€§èƒ½ä¼˜åŒ–](#54-æ€§èƒ½ä¼˜åŒ–)
  - [6. é«˜çº§æœç´¢åŠŸèƒ½](#6-é«˜çº§æœç´¢åŠŸèƒ½)
    - [6.1 åŠ æƒæœç´¢](#61-åŠ æƒæœç´¢)
    - [6.2 ç›¸å…³æ€§æ’åº](#62-ç›¸å…³æ€§æ’åº)
    - [6.3 é«˜äº®æ˜¾ç¤º](#63-é«˜äº®æ˜¾ç¤º)
    - [6.4 è‡ªåŠ¨è¡¥å…¨](#64-è‡ªåŠ¨è¡¥å…¨)
  - [7. å…¨æ–‡æœç´¢ä¸RAGé›†æˆ](#7-å…¨æ–‡æœç´¢ä¸ragé›†æˆ)
    - [7.1 RAGä¸­çš„æ£€ç´¢ç­–ç•¥](#71-ragä¸­çš„æ£€ç´¢ç­–ç•¥)
    - [7.2 æ··åˆæ£€ç´¢å®ç°](#72-æ··åˆæ£€ç´¢å®ç°)
    - [7.3 ä¼˜åŒ–å®è·µ](#73-ä¼˜åŒ–å®è·µ)
  - [8. ä¸Elasticsearchå¯¹æ¯”](#8-ä¸elasticsearchå¯¹æ¯”)
    - [8.1 åŠŸèƒ½å¯¹æ¯”](#81-åŠŸèƒ½å¯¹æ¯”)
    - [8.2 æ€§èƒ½å¯¹æ¯”](#82-æ€§èƒ½å¯¹æ¯”)
    - [8.3 é€‰æ‹©å»ºè®®](#83-é€‰æ‹©å»ºè®®)
  - [9. å®æˆ˜æ¡ˆä¾‹](#9-å®æˆ˜æ¡ˆä¾‹)
    - [9.1 åšå®¢æœç´¢ç³»ç»Ÿ](#91-åšå®¢æœç´¢ç³»ç»Ÿ)
    - [9.2 ç”µå•†äº§å“æœç´¢](#92-ç”µå•†äº§å“æœç´¢)
    - [9.3 æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ](#93-æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“ æ›´æ–°æ—¥å¿—](#-æ›´æ–°æ—¥å¿—)

---

## 1. å…¨æ–‡æœç´¢åŸºç¡€

### 1.1 tsvectorä¸tsquery

#### tsvectorï¼ˆæ–‡æœ¬å‘é‡ï¼‰

```sql
-- tsvectoræ˜¯æ–‡æ¡£çš„å‘é‡è¡¨ç¤ºï¼ŒåŒ…å«è¯å…ƒå’Œä½ç½®ä¿¡æ¯
SELECT to_tsvector('english', 'PostgreSQL is a powerful open source database');
-- ç»“æœ: 'databas':7 'open':5 'postgresql':1 'power':4 'sourc':6

-- æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯
SELECT ts_debug('english', 'PostgreSQL is a powerful database');
```

#### tsqueryï¼ˆæŸ¥è¯¢å‘é‡ï¼‰

```sql
-- tsqueryæ˜¯æŸ¥è¯¢çš„å‘é‡è¡¨ç¤º
SELECT to_tsquery('english', 'postgresql & database');
-- ç»“æœ: 'postgresql' & 'databas'

-- ä½¿ç”¨tsqueryæœç´¢
SELECT * FROM articles
WHERE to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', 'postgresql & database');
```

### 1.2 åŸºç¡€æœç´¢è¯­æ³•

#### æ“ä½œç¬¦

```sql
-- & (AND) - å¿…é¡»åŒæ—¶åŒ…å«
SELECT to_tsquery('english', 'postgresql & database');

-- | (OR) - åŒ…å«ä»»ä¸€å³å¯
SELECT to_tsquery('english', 'postgresql | mysql');

-- ! (NOT) - ä¸åŒ…å«
SELECT to_tsquery('english', 'postgresql & !mysql');

-- ç»„åˆä½¿ç”¨
SELECT to_tsquery('english', '(postgresql | mysql) & database & !oracle');

-- <-> (FOLLOWED BY) - ç›¸é‚»
SELECT to_tsquery('english', 'postgresql <-> database');  -- "postgresql database"ç›¸é‚»

-- <N> (è·ç¦»N) - è·ç¦»Nä¸ªè¯
SELECT to_tsquery('english', 'postgresql <2> database');  -- è·ç¦»2ä¸ªè¯ä»¥å†…
```

### 1.3 æ–‡æœ¬æœç´¢é…ç½®

#### å†…ç½®é…ç½®

```sql
-- æŸ¥çœ‹å¯ç”¨çš„æ–‡æœ¬æœç´¢é…ç½®
SELECT cfgname FROM pg_ts_config;

-- å¸¸ç”¨é…ç½®
-- 'english' - è‹±è¯­
-- 'simple' - ç®€å•é…ç½®ï¼ˆä¸åˆ†è¯ï¼‰
-- 'chinese' - ä¸­æ–‡ï¼ˆéœ€è¦å®‰è£…zhparserï¼‰
-- 'japanese' - æ—¥è¯­
-- 'korean' - éŸ©è¯­

-- ä½¿ç”¨ä¸åŒé…ç½®
SELECT to_tsvector('english', 'running databases');
-- ç»“æœ: 'databas':2 'run':1  (runningè¢«è¯å¹²åŒ–ä¸ºrun)

SELECT to_tsvector('simple', 'running databases');
-- ç»“æœ: 'databases':2 'running':1  (simpleé…ç½®ä¸åˆ†è¯)
```

---

## 2. ä¸­æ–‡å…¨æ–‡æœç´¢

### 2.1 zhparserå®‰è£…ä¸é…ç½®

#### å®‰è£…zhparser

```bash
# Ubuntu/Debian
sudo apt-get install postgresql-17-zhparser

# æˆ–ä»æºç ç¼–è¯‘
git clone https://github.com/amutu/zhparser.git
cd zhparser
make && sudo make install

# åœ¨æ•°æ®åº“ä¸­åˆ›å»ºæ‰©å±•
psql -d mydb -c "CREATE EXTENSION zhparser;"
```

#### éªŒè¯å®‰è£…

```sql
-- æ£€æŸ¥æ‰©å±•
SELECT * FROM pg_extension WHERE extname = 'zhparser';

-- æµ‹è¯•ä¸­æ–‡åˆ†è¯
SELECT to_tsvector('zhparser', 'PostgreSQLæ˜¯ä¸€ä¸ªå¼ºå¤§çš„å¼€æºæ•°æ®åº“');
-- ç»“æœä¼šæ˜¾ç¤ºåˆ†è¯ç»“æœ
```

### 2.2 ä¸­æ–‡åˆ†è¯é…ç½®

#### åˆ›å»ºä¸­æ–‡æ–‡æœ¬æœç´¢é…ç½®

```sql
-- åˆ›å»ºä¸­æ–‡æ–‡æœ¬æœç´¢é…ç½®
CREATE TEXT SEARCH CONFIGURATION chinese_zhparser (PARSER = zhparser);

-- æ·»åŠ tokenæ˜ å°„
ALTER TEXT SEARCH CONFIGURATION chinese_zhparser
    ADD MAPPING FOR n,v,a,i,e,l WITH simple;

-- æµ‹è¯•é…ç½®
SELECT to_tsvector('chinese_zhparser', 'PostgreSQLæ˜¯ä¸€ä¸ªå¼ºå¤§çš„å¼€æºæ•°æ®åº“');
SELECT to_tsquery('chinese_zhparser', 'æ•°æ®åº“');
```

#### è‡ªå®šä¹‰è¯å…¸

```sql
-- zhparserä½¿ç”¨jiebaè¯å…¸ï¼Œå¯ä»¥æ·»åŠ è‡ªå®šä¹‰è¯å…¸
-- åœ¨postgresql.confä¸­é…ç½®
-- zhparser.multi_short = true  # å¯ç”¨çŸ­è¯è¯†åˆ«
-- zhparser.dict_in_memory = false  # è¯å…¸ä¸åŠ è½½åˆ°å†…å­˜ï¼ˆèŠ‚çœå†…å­˜ï¼‰

-- æˆ–è€…ä½¿ç”¨pg_jiebaï¼ˆå¦ä¸€ä¸ªjiebaæ‰©å±•ï¼‰
CREATE EXTENSION pg_jieba;

SELECT jieba_cut('PostgreSQLæ˜¯ä¸€ä¸ªå¼ºå¤§çš„å¼€æºæ•°æ®åº“');
```

### 2.3 ä¸­æ–‡æœç´¢å®è·µ

#### åˆ›å»ºä¸­æ–‡æœç´¢è¡¨

```sql
-- åˆ›å»ºæ–‡ç« è¡¨
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- é¢„è®¡ç®—tsvector
    tsv tsvector
);

-- åˆ›å»ºè§¦å‘å™¨è‡ªåŠ¨æ›´æ–°tsvector
CREATE OR REPLACE FUNCTION update_article_tsv()
RETURNS TRIGGER AS $$
BEGIN
    NEW.tsv :=
        setweight(to_tsvector('chinese_zhparser', COALESCE(NEW.title, '')), 'A') ||
        setweight(to_tsvector('chinese_zhparser', COALESCE(NEW.content, '')), 'B');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_article_tsv_trigger
BEFORE INSERT OR UPDATE ON articles
FOR EACH ROW
EXECUTE FUNCTION update_article_tsv();

-- åˆ›å»ºGINç´¢å¼•
CREATE INDEX idx_articles_tsv ON articles USING GIN (tsv);
```

#### ä¸­æ–‡æœç´¢æŸ¥è¯¢

```sql
-- åŸºç¡€æœç´¢
SELECT id, title, content
FROM articles
WHERE tsv @@ to_tsquery('chinese_zhparser', 'æ•°æ®åº“');

-- ç›¸å…³æ€§æ’åº
SELECT
    id,
    title,
    content,
    ts_rank(tsv, query) AS rank
FROM articles, to_tsquery('chinese_zhparser', 'PostgreSQL & æ•°æ®åº“') query
WHERE tsv @@ query
ORDER BY rank DESC
LIMIT 10;

-- åŠ æƒæœç´¢ï¼ˆæ ‡é¢˜æƒé‡æ›´é«˜ï¼‰
SELECT
    id,
    title,
    content,
    ts_rank_cd(
        '{0.1, 0.2, 0.4, 1.0}',  -- æƒé‡å‘é‡
        tsv,
        query
    ) AS rank
FROM articles, to_tsquery('chinese_zhparser', 'PostgreSQL & æ•°æ®åº“') query
WHERE tsv @@ query
ORDER BY rank DESC;
```

### 2.4 ä¸­æ–‡æœç´¢ä¼˜åŒ–

#### å¤„ç†åŒä¹‰è¯

```sql
-- åˆ›å»ºåŒä¹‰è¯è¯å…¸
CREATE TEXT SEARCH DICTIONARY chinese_synonym (
    TEMPLATE = synonym,
    SYNONYMS = chinese_synonym
);

-- åˆ›å»ºåŒä¹‰è¯æ–‡ä»¶ï¼ˆéœ€è¦ç³»ç»Ÿæ–‡ä»¶ï¼‰
-- æ ¼å¼: æºè¯ => ç›®æ ‡è¯
-- ä¾‹å¦‚: æ•°æ®åº“ => database
--       èµ„æ–™åº“ => database

-- åœ¨é…ç½®ä¸­ä½¿ç”¨åŒä¹‰è¯è¯å…¸
ALTER TEXT SEARCH CONFIGURATION chinese_zhparser
    ALTER MAPPING FOR n,v,a,i,e,l
    WITH chinese_synonym, simple;
```

#### å¤„ç†åœç”¨è¯

```sql
-- åˆ›å»ºåœç”¨è¯è¯å…¸
CREATE TEXT SEARCH DICTIONARY chinese_stopwords (
    TEMPLATE = pg_catalog.simple,
    STOPWORDS = chinese_stopwords
);

-- åœ¨é…ç½®ä¸­ä½¿ç”¨åœç”¨è¯è¯å…¸
ALTER TEXT SEARCH CONFIGURATION chinese_zhparser
    ALTER MAPPING FOR n,v,a,i,e,l
    WITH chinese_stopwords, simple;
```

---

## 3. å¤šè¯­è¨€å…¨æ–‡æœç´¢

### 3.1 è¯­è¨€æ£€æµ‹

#### ç®€å•è¯­è¨€æ£€æµ‹å‡½æ•°

```sql
-- åˆ›å»ºè¯­è¨€æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION detect_language(text TEXT)
RETURNS regconfig AS $$
BEGIN
    -- æ£€æµ‹ä¸­æ–‡å­—ç¬¦
    IF text ~ '[\u4e00-\u9fa5]' THEN
        RETURN 'chinese_zhparser'::regconfig;
    -- æ£€æµ‹æ—¥æ–‡å­—ç¬¦
    ELSIF text ~ '[\u3040-\u309F\u30A0-\u30FF]' THEN
        RETURN 'japanese'::regconfig;
    -- æ£€æµ‹éŸ©æ–‡å­—ç¬¦
    ELSIF text ~ '[\uAC00-\uD7A3]' THEN
        RETURN 'korean'::regconfig;
    -- é»˜è®¤è‹±è¯­
    ELSE
        RETURN 'english'::regconfig;
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ä½¿ç”¨å‡½æ•°
SELECT detect_language('PostgreSQLæ˜¯ä¸€ä¸ªå¼ºå¤§çš„æ•°æ®åº“');
-- è¿”å›: chinese_zhparser
```

### 3.2 å¤šè¯­è¨€é…ç½®

#### å­˜å‚¨è¯­è¨€ä¿¡æ¯

```sql
-- åˆ›å»ºå¤šè¯­è¨€æ–‡ç« è¡¨
CREATE TABLE multilingual_articles (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    language TEXT NOT NULL,  -- 'chinese', 'english', 'japanese', etc.
    tsv tsvector,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ ¹æ®è¯­è¨€è‡ªåŠ¨ç”Ÿæˆtsvector
CREATE OR REPLACE FUNCTION update_multilingual_tsv()
RETURNS TRIGGER AS $$
DECLARE
    config_name regconfig;
BEGIN
    -- æ ¹æ®languageé€‰æ‹©é…ç½®
    CASE NEW.language
        WHEN 'chinese' THEN config_name := 'chinese_zhparser';
        WHEN 'japanese' THEN config_name := 'japanese';
        WHEN 'korean' THEN config_name := 'korean';
        WHEN 'english' THEN config_name := 'english';
        ELSE config_name := 'simple';
    END CASE;

    NEW.tsv :=
        setweight(to_tsvector(config_name, COALESCE(NEW.title, '')), 'A') ||
        setweight(to_tsvector(config_name, COALESCE(NEW.content, '')), 'B');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_multilingual_tsv_trigger
BEFORE INSERT OR UPDATE ON multilingual_articles
FOR EACH ROW
EXECUTE FUNCTION update_multilingual_tsv();

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_multilingual_articles_tsv ON multilingual_articles USING GIN (tsv);
CREATE INDEX idx_multilingual_articles_language ON multilingual_articles (language);
```

### 3.3 æ··åˆè¯­è¨€æœç´¢

#### å¤šè¯­è¨€æœç´¢æŸ¥è¯¢

```sql
-- æœç´¢å¤šç§è¯­è¨€
WITH queries AS (
    SELECT
        'chinese' AS lang,
        to_tsquery('chinese_zhparser', 'æ•°æ®åº“') AS query
    UNION ALL
    SELECT
        'english' AS lang,
        to_tsquery('english', 'database') AS query
)
SELECT
    a.id,
    a.title,
    a.content,
    a.language,
    ts_rank(a.tsv, q.query) AS rank
FROM multilingual_articles a
JOIN queries q ON a.language = q.lang
WHERE a.tsv @@ q.query
ORDER BY rank DESC
LIMIT 20;
```

#### è·¨è¯­è¨€æœç´¢

```sql
-- è·¨è¯­è¨€æœç´¢ï¼ˆå°†æŸ¥è¯¢è½¬æ¢ä¸ºå¤šç§è¯­è¨€ï¼‰
CREATE OR REPLACE FUNCTION multilingual_search(search_text TEXT)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    content TEXT,
    language TEXT,
    rank REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.id,
        a.title,
        a.content,
        a.language,
        CASE a.language
            WHEN 'chinese' THEN ts_rank(a.tsv, to_tsquery('chinese_zhparser', search_text))
            WHEN 'english' THEN ts_rank(a.tsv, to_tsquery('english', search_text))
            ELSE 0
        END AS rank
    FROM multilingual_articles a
    WHERE
        (a.language = 'chinese' AND a.tsv @@ to_tsquery('chinese_zhparser', search_text))
        OR
        (a.language = 'english' AND a.tsv @@ to_tsquery('english', search_text))
    ORDER BY rank DESC;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨å‡½æ•°
SELECT * FROM multilingual_search('æ•°æ®åº“ | database');
```

---

## 4. å…¨æ–‡æœç´¢æ€§èƒ½ä¼˜åŒ–

### 4.1 GIN vs GiSTç´¢å¼•

#### å¯¹æ¯”åˆ†æ

| ç‰¹æ€§ | GINç´¢å¼• | GiSTç´¢å¼• |
|------|---------|----------|
| **æŸ¥è¯¢é€Ÿåº¦** | å¿« | è¾ƒæ…¢ |
| **ç´¢å¼•å¤§å°** | å¤§ | å° |
| **æ›´æ–°é€Ÿåº¦** | æ…¢ | å¿« |
| **é€‚ç”¨åœºæ™¯** | è¯»å¤šå†™å°‘ | å†™å¤šè¯»å°‘ |
| **æ”¯æŒæ“ä½œ** | @@, @@@ | @@ |

#### é€‰æ‹©å»ºè®®

```sql
-- âœ… æ¨èä½¿ç”¨GINç´¢å¼•ï¼ˆå¤§å¤šæ•°åœºæ™¯ï¼‰
CREATE INDEX idx_articles_tsv_gin ON articles USING GIN (tsv);

-- âœ… å†™å¯†é›†å‹åœºæ™¯ä½¿ç”¨GiSTç´¢å¼•
CREATE INDEX idx_articles_tsv_gist ON articles USING GIST (tsv);

-- âœ… ç»„åˆç´¢å¼•ï¼ˆç©ºé—´+å…¨æ–‡æœç´¢ï¼‰
CREATE INDEX idx_articles_location_tsv ON articles
USING GIN (location, tsv);  -- æ³¨æ„ï¼šGINä¸æ”¯æŒç»„åˆç´¢å¼•ï¼Œéœ€è¦åˆ†åˆ«åˆ›å»º
```

### 4.2 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

#### GINç´¢å¼•ä¼˜åŒ–

```sql
-- ä½¿ç”¨fastupdateå‚æ•°ï¼ˆå»¶è¿Ÿæ›´æ–°ï¼Œæå‡å†™å…¥æ€§èƒ½ï¼‰
CREATE INDEX idx_articles_tsv ON articles
USING GIN (tsv) WITH (fastupdate = on);

-- å®šæœŸæ¸…ç†å¾…å¤„ç†çš„æ›´æ–°
-- GINç´¢å¼•ä¼šç§¯ç´¯å¾…å¤„ç†çš„æ›´æ–°ï¼Œéœ€è¦å®šæœŸæ¸…ç†
VACUUM articles;

-- æˆ–è€…æ‰‹åŠ¨æ¸…ç†
VACUUM ANALYZE articles;
```

#### éƒ¨åˆ†ç´¢å¼•

```sql
-- åªä¸ºæ´»è·ƒæ–‡ç« åˆ›å»ºç´¢å¼•ï¼ˆèŠ‚çœç©ºé—´ï¼‰
CREATE INDEX idx_articles_active_tsv ON articles
USING GIN (tsv)
WHERE status = 'published' AND created_at > NOW() - INTERVAL '1 year';
```

### 4.3 æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§

#### ä½¿ç”¨LIMITé™åˆ¶ç»“æœ

```sql
-- âœ… æ¨èï¼šä½¿ç”¨LIMITé™åˆ¶ç»“æœæ•°é‡
SELECT * FROM articles
WHERE tsv @@ to_tsquery('chinese_zhparser', 'æ•°æ®åº“')
ORDER BY ts_rank(tsv, to_tsquery('chinese_zhparser', 'æ•°æ®åº“')) DESC
LIMIT 20;
```

#### é¿å…åœ¨WHEREä¸­ä½¿ç”¨å‡½æ•°

```sql
-- âŒ ä¸æ¨èï¼šå‡½æ•°åœ¨WHEREä¸­ï¼Œæ— æ³•ä½¿ç”¨ç´¢å¼•
SELECT * FROM articles
WHERE to_tsvector('chinese_zhparser', title || ' ' || content)
      @@ to_tsquery('chinese_zhparser', 'æ•°æ®åº“');

-- âœ… æ¨èï¼šä½¿ç”¨é¢„è®¡ç®—çš„tsvectoråˆ—
SELECT * FROM articles
WHERE tsv @@ to_tsquery('chinese_zhparser', 'æ•°æ®åº“');
```

---

## 5. å…¨æ–‡æœç´¢ä¸å‘é‡æœç´¢ç»“åˆ

### 5.1 æ··åˆæœç´¢æ¶æ„

```text
ç”¨æˆ·æŸ¥è¯¢
    â†“
æŸ¥è¯¢ç†è§£
    â”œâ”€ å…¨æ–‡æœç´¢æŸ¥è¯¢ï¼ˆå…³é”®è¯åŒ¹é…ï¼‰
    â””â”€ å‘é‡æœç´¢æŸ¥è¯¢ï¼ˆè¯­ä¹‰åŒ¹é…ï¼‰
    â†“
å¹¶è¡Œæ£€ç´¢
    â”œâ”€ å…¨æ–‡æœç´¢ç»“æœï¼ˆç²¾ç¡®åŒ¹é…ï¼‰
    â””â”€ å‘é‡æœç´¢ç»“æœï¼ˆè¯­ä¹‰ç›¸ä¼¼ï¼‰
    â†“
ç»“æœèåˆï¼ˆRRFã€åŠ æƒèåˆï¼‰
    â†“
æ’åºç»“æœ
```

### 5.2 å®ç°æ–¹æ¡ˆ

#### åˆ›å»ºæ··åˆæœç´¢è¡¨

```sql
-- åˆ›å»ºåŒ…å«å…¨æ–‡æœç´¢å’Œå‘é‡æœç´¢çš„è¡¨
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    -- å…¨æ–‡æœç´¢
    tsv tsvector,
    -- å‘é‡æœç´¢ï¼ˆä½¿ç”¨pgvectorï¼‰
    embedding vector(384)  -- ä½¿ç”¨sentence-transformersæ¨¡å‹
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_documents_tsv ON documents USING GIN (tsv);
CREATE INDEX idx_documents_embedding ON documents USING ivfflat (embedding vector_cosine_ops);
```

#### æ··åˆæ£€ç´¢å‡½æ•°

```sql
-- åˆ›å»ºæ··åˆæ£€ç´¢å‡½æ•°
CREATE OR REPLACE FUNCTION hybrid_search(
    search_text TEXT,
    text_weight REAL DEFAULT 0.5,
    vector_weight REAL DEFAULT 0.5,
    limit_count INTEGER DEFAULT 20
)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    content TEXT,
    text_score REAL,
    vector_score REAL,
    combined_score REAL
) AS $$
DECLARE
    query_embedding vector(384);
    search_query tsquery;
BEGIN
    -- ç”ŸæˆæŸ¥è¯¢å‘é‡ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…éœ€è¦è°ƒç”¨åµŒå…¥æ¨¡å‹ï¼‰
    -- query_embedding := generate_embedding(search_text);

    -- ç”Ÿæˆå…¨æ–‡æœç´¢æŸ¥è¯¢
    search_query := to_tsquery('chinese_zhparser', search_text);

    RETURN QUERY
    WITH text_results AS (
        SELECT
            d.id,
            d.title,
            d.content,
            ts_rank(d.tsv, search_query) AS score
        FROM documents d
        WHERE d.tsv @@ search_query
        ORDER BY score DESC
        LIMIT limit_count * 2  -- è·å–æ›´å¤šå€™é€‰ç»“æœ
    ),
    vector_results AS (
        SELECT
            d.id,
            d.title,
            d.content,
            1 - (d.embedding <=> query_embedding) AS score  -- ä½™å¼¦ç›¸ä¼¼åº¦
        FROM documents d
        ORDER BY d.embedding <=> query_embedding
        LIMIT limit_count * 2
    ),
    combined AS (
        SELECT
            COALESCE(t.id, v.id) AS id,
            COALESCE(t.title, v.title) AS title,
            COALESCE(t.content, v.content) AS content,
            COALESCE(t.score, 0) AS text_score,
            COALESCE(v.score, 0) AS vector_score,
            COALESCE(t.score, 0) * text_weight + COALESCE(v.score, 0) * vector_weight AS combined_score
        FROM text_results t
        FULL OUTER JOIN vector_results v ON t.id = v.id
    )
    SELECT
        c.id,
        c.title,
        c.content,
        c.text_score,
        c.vector_score,
        c.combined_score
    FROM combined c
    ORDER BY c.combined_score DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 ç›¸å…³æ€§èåˆ

#### RRF (Reciprocal Rank Fusion)

```sql
-- RRFèåˆç®—æ³•
CREATE OR REPLACE FUNCTION rrf_fusion(
    text_ranks INTEGER[],
    vector_ranks INTEGER[],
    k INTEGER DEFAULT 60
)
RETURNS REAL AS $$
DECLARE
    text_score REAL := 0;
    vector_score REAL := 0;
    i INTEGER;
BEGIN
    -- è®¡ç®—æ–‡æœ¬æœç´¢RRFåˆ†æ•°
    FOREACH i IN ARRAY text_ranks
    LOOP
        text_score := text_score + 1.0 / (k + i);
    END LOOP;

    -- è®¡ç®—å‘é‡æœç´¢RRFåˆ†æ•°
    FOREACH i IN ARRAY vector_ranks
    LOOP
        vector_score := vector_score + 1.0 / (k + i);
    END LOOP;

    RETURN text_score + vector_score;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## 7. å…¨æ–‡æœç´¢ä¸RAGé›†æˆ

### 7.1 RAGä¸­çš„æ£€ç´¢ç­–ç•¥

#### æ··åˆæ£€ç´¢RAG

```python
# Pythonç¤ºä¾‹ï¼šæ··åˆæ£€ç´¢RAG
import psycopg2
from sentence_transformers import SentenceTransformer
import numpy as np

class HybridRetrievalRAG:
    """æ··åˆæ£€ç´¢RAGç³»ç»Ÿ"""

    def __init__(self, db_config, embedding_model_name='paraphrase-multilingual-MiniLM-L12-v2'):
        self.conn = psycopg2.connect(**db_config)
        self.cursor = self.conn.cursor()
        self.embedding_model = SentenceTransformer(embedding_model_name)

    def retrieve(self, query: str, top_k: int = 5, text_weight: float = 0.4, vector_weight: float = 0.6):
        """æ··åˆæ£€ç´¢"""
        # ç”ŸæˆæŸ¥è¯¢å‘é‡
        query_embedding = self.embedding_model.encode(query).tolist()

        # å…¨æ–‡æœç´¢ + å‘é‡æœç´¢
        self.cursor.execute("""
            WITH text_results AS (
                SELECT
                    id,
                    content,
                    ts_rank(tsv, to_tsquery('chinese_zhparser', %s)) AS text_score
                FROM documents
                WHERE tsv @@ to_tsquery('chinese_zhparser', %s)
                ORDER BY text_score DESC
                LIMIT %s
            ),
            vector_results AS (
                SELECT
                    id,
                    content,
                    1 - (embedding <=> %s::vector) AS vector_score
                FROM documents
                ORDER BY embedding <=> %s::vector
                LIMIT %s
            ),
            combined AS (
                SELECT
                    COALESCE(t.id, v.id) AS id,
                    COALESCE(t.content, v.content) AS content,
                    COALESCE(t.text_score, 0) * %s + COALESCE(v.vector_score, 0) * %s AS combined_score
                FROM text_results t
                FULL OUTER JOIN vector_results v ON t.id = v.id
            )
            SELECT id, content, combined_score
            FROM combined
            ORDER BY combined_score DESC
            LIMIT %s
        """, (
            query, query, top_k * 2,
            query_embedding, query_embedding, top_k * 2,
            text_weight, vector_weight,
            top_k
        ))

        return self.cursor.fetchall()
```

---

## 8. ä¸Elasticsearchå¯¹æ¯”

### 8.1 åŠŸèƒ½å¯¹æ¯”

| ç‰¹æ€§ | PostgreSQLå…¨æ–‡æœç´¢ | Elasticsearch |
| --- | --- | --- |
| **å®‰è£…éƒ¨ç½²** | å†…ç½®ï¼Œæ— éœ€é¢å¤–ç»„ä»¶ | éœ€è¦ç‹¬ç«‹éƒ¨ç½² |
| **ä¸­æ–‡æ”¯æŒ** | éœ€è¦zhparseræ‰©å±• | å†…ç½®IKåˆ†è¯å™¨ |
| **å®æ—¶æ€§** | å®æ—¶ï¼ˆäº‹åŠ¡å†…ï¼‰ | è¿‘å®æ—¶ï¼ˆ1ç§’ï¼‰ |
| **ä¸€è‡´æ€§** | å¼ºä¸€è‡´æ€§ï¼ˆACIDï¼‰ | æœ€ç»ˆä¸€è‡´æ€§ |
| **å¤æ‚æŸ¥è¯¢** | SQLä¸°å¯Œ | DSLçµæ´» |
| **æ‰©å±•æ€§** | å‚ç›´æ‰©å±• | æ°´å¹³æ‰©å±• |
| **å­¦ä¹ æˆæœ¬** | ä½ï¼ˆSQLï¼‰ | ä¸­ï¼ˆDSLï¼‰ |

### 8.2 æ€§èƒ½å¯¹æ¯”

```text
å°è§„æ¨¡æ•°æ®ï¼ˆ<100ä¸‡æ–‡æ¡£ï¼‰:
- PostgreSQL: æ€§èƒ½ç›¸å½“æˆ–æ›´å¥½
- Elasticsearch: å¼€é”€è¾ƒå¤§

ä¸­ç­‰è§„æ¨¡æ•°æ®ï¼ˆ100ä¸‡-1äº¿æ–‡æ¡£ï¼‰:
- PostgreSQL: æ€§èƒ½è‰¯å¥½ï¼Œéœ€è¦ä¼˜åŒ–
- Elasticsearch: æ€§èƒ½ä¼˜ç§€ï¼Œæ¨ªå‘æ‰©å±•

å¤§è§„æ¨¡æ•°æ®ï¼ˆ>1äº¿æ–‡æ¡£ï¼‰:
- PostgreSQL: éœ€è¦åˆ†ç‰‡å’Œä¼˜åŒ–
- Elasticsearch: å¤©ç„¶æ”¯æŒåˆ†å¸ƒå¼
```

### 8.3 é€‰æ‹©å»ºè®®

```text
é€‰æ‹©PostgreSQLå…¨æ–‡æœç´¢:
âœ… æ•°æ®é‡ < 1äº¿æ–‡æ¡£
âœ… éœ€è¦å¼ºä¸€è‡´æ€§
âœ… éœ€è¦å¤æ‚SQLæŸ¥è¯¢
âœ… å¸Œæœ›å‡å°‘ç³»ç»Ÿå¤æ‚åº¦
âœ… æ•°æ®å·²åœ¨PostgreSQLä¸­

é€‰æ‹©Elasticsearch:
âœ… æ•°æ®é‡ > 1äº¿æ–‡æ¡£
âœ… éœ€è¦æ°´å¹³æ‰©å±•
âœ… éœ€è¦å¤æ‚çš„èšåˆåˆ†æ
âœ… éœ€è¦æ—¥å¿—åˆ†æåœºæ™¯
âœ… å¯ä»¥æ¥å—æœ€ç»ˆä¸€è‡´æ€§
```

---

## 9. å®æˆ˜æ¡ˆä¾‹

### 9.1 åšå®¢æœç´¢ç³»ç»Ÿ

#### æ•°æ®æ¨¡å‹

```sql
-- åšå®¢æ–‡ç« è¡¨
CREATE TABLE blog_posts (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    author_id INTEGER,
    category_id INTEGER,
    published_at TIMESTAMPTZ,
    status TEXT DEFAULT 'draft',  -- 'draft', 'published', 'archived'
    tsv tsvector,
    view_count INTEGER DEFAULT 0
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_blog_posts_tsv ON blog_posts USING GIN (tsv);
CREATE INDEX idx_blog_posts_status ON blog_posts (status) WHERE status = 'published';
CREATE INDEX idx_blog_posts_published ON blog_posts (published_at DESC) WHERE status = 'published';
```

#### æœç´¢API

```sql
-- æœç´¢åšå®¢æ–‡ç« 
CREATE OR REPLACE FUNCTION search_blog_posts(
    search_text TEXT,
    category_id INTEGER DEFAULT NULL,
    limit_count INTEGER DEFAULT 20
)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    content_preview TEXT,
    author_id INTEGER,
    published_at TIMESTAMPTZ,
    rank REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.title,
        LEFT(p.content, 200) AS content_preview,
        p.author_id,
        p.published_at,
        ts_rank(p.tsv, to_tsquery('chinese_zhparser', search_text)) AS rank
    FROM blog_posts p
    WHERE p.status = 'published'
      AND p.tsv @@ to_tsquery('chinese_zhparser', search_text)
      AND (category_id IS NULL OR p.category_id = category_id)
    ORDER BY rank DESC, p.published_at DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **PostgreSQLå…¨æ–‡æœç´¢æ–‡æ¡£**: <https://www.postgresql.org/docs/current/textsearch.html>
2. **zhparser GitHub**: <https://github.com/amutu/zhparser>
3. **pg_jieba GitHub**: <https://github.com/jaiminpan/pg_jieba>
4. **Elasticsearchå¯¹æ¯”**: <https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html>

---

## ğŸ“ æ›´æ–°æ—¥å¿—

- **v2.0** (2025-01): å®Œæ•´å®æˆ˜æŒ‡å—
  - æ•´åˆå…¨æ–‡æœç´¢åŸºç¡€
  - è¡¥å……ä¸­æ–‡å…¨æ–‡æœç´¢å®Œæ•´æ–¹æ¡ˆ
  - æ·»åŠ å¤šè¯­è¨€å…¨æ–‡æœç´¢
  - è¡¥å……æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
  - æ·»åŠ å…¨æ–‡æœç´¢ä¸å‘é‡æœç´¢ç»“åˆ
  - è¡¥å……é«˜çº§æœç´¢åŠŸèƒ½
  - æ·»åŠ å…¨æ–‡æœç´¢ä¸RAGé›†æˆ
  - è¡¥å……Elasticsearchå¯¹æ¯”
  - æ·»åŠ å®æˆ˜æ¡ˆä¾‹

---

**çŠ¶æ€**: âœ… **æ–‡æ¡£å®Œæˆ** | [è¿”å›ç›®å½•](./README.md)
