# PostgreSQL联邦查询性能优化指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐⭐ 高级

---

## 📋 目录

- [PostgreSQL联邦查询性能优化指南](#postgresql联邦查询性能优化指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 查询下推优化](#2-查询下推优化)
    - [2.1 启用查询下推](#21-启用查询下推)
    - [2.2 下推优化](#22-下推优化)
  - [3. 批量操作优化](#3-批量操作优化)
    - [3.1 批量导入](#31-批量导入)
    - [3.2 批量更新](#32-批量更新)
  - [4. 连接优化](#4-连接优化)
    - [4.1 连接池](#41-连接池)
    - [4.2 连接管理](#42-连接管理)
  - [5. 缓存策略](#5-缓存策略)
    - [5.1 物化视图](#51-物化视图)
    - [5.2 本地缓存](#52-本地缓存)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

联邦查询性能优化是提高跨数据源查询效率的关键。

**优化策略**:

- 查询下推
- 批量操作
- 连接优化
- 缓存策略

---

## 2. 查询下推优化

### 2.1 启用查询下推

```sql
-- 启用远程估算（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'foreign_table'
        ) THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        END IF;

        ALTER FOREIGN TABLE foreign_table
        OPTIONS (ADD use_remote_estimate 'true');
        RAISE NOTICE '远程估算已启用: foreign_table';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        WHEN OTHERS THEN
            RAISE EXCEPTION '启用远程估算失败: %', SQLERRM;
    END;
END $$;

-- 启用WHERE下推（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'foreign_table'
        ) THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        END IF;

        ALTER FOREIGN TABLE foreign_table
        OPTIONS (ADD fetch_size '100');
        RAISE NOTICE 'WHERE下推已启用: foreign_table (fetch_size=100)';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        WHEN OTHERS THEN
            RAISE EXCEPTION '启用WHERE下推失败: %', SQLERRM;
    END;
END $$;
```

### 2.2 下推优化

```sql
-- 优化前：全表传输（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'foreign_table'
        ) THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        END IF;
        RAISE NOTICE '开始执行优化前查询（全表传输）';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        WHEN OTHERS THEN
            RAISE EXCEPTION '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM foreign_table;
-- 执行时间: 慢（传输所有数据）
-- 计划: Foreign Scan（全表扫描）

-- 优化后：WHERE下推（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'foreign_table'
        ) THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        END IF;
        RAISE NOTICE '开始执行优化后查询（WHERE下推）';
        RAISE NOTICE '查询在远程执行，只返回结果';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '外部表不存在: foreign_table';
        WHEN OTHERS THEN
            RAISE EXCEPTION '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM foreign_table WHERE id > 1000;
-- 执行时间: 快（只返回匹配结果）
-- 计划: Foreign Scan（WHERE条件下推到远程）
```

---

## 3. 批量操作优化

### 3.1 批量导入

**批量导入优化（带完整错误处理和性能测试）**:

```sql
-- 批量导入（带错误处理）
DO $$
DECLARE
    inserted_count BIGINT;
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    duration INTERVAL;
BEGIN
    -- 检查表是否存在
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'local_table') THEN
        RAISE EXCEPTION '本地表不存在: local_table';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'foreign_table') THEN
        RAISE EXCEPTION '外部表不存在: foreign_table';
    END IF;

    -- 记录开始时间
    start_time := clock_timestamp();

    -- 执行批量导入
    INSERT INTO local_table
    SELECT * FROM foreign_table
    WHERE created_at > CURRENT_DATE - INTERVAL '7 days';

    GET DIAGNOSTICS inserted_count = ROW_COUNT;
    end_time := clock_timestamp();
    duration := end_time - start_time;

    RAISE NOTICE '批量导入成功: 插入了 % 行数据，耗时 %', inserted_count, duration;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在（请检查local_table和foreign_table）';
    WHEN OTHERS THEN
        RAISE EXCEPTION '批量导入失败: %', SQLERRM;
END $$;

-- 性能测试：批量导入
EXPLAIN (ANALYZE, BUFFERS, TIMING)
INSERT INTO local_table
SELECT * FROM foreign_table
WHERE created_at > CURRENT_DATE - INTERVAL '7 days';
-- 执行时间: 取决于网络延迟和数据量
-- 计划: Insert on local_table -> Foreign Scan

-- 使用COPY加速（带错误处理）
DO $$
DECLARE
    row_count BIGINT;
BEGIN
    -- 导出外部表数据到CSV
    BEGIN
        COPY (SELECT * FROM foreign_table) TO '/tmp/data.csv' WITH CSV HEADER;
        RAISE NOTICE '数据导出成功: /tmp/data.csv';
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE EXCEPTION '权限不足，无法写入文件: /tmp/data.csv（需要超级用户权限）';
        WHEN OTHERS THEN
            RAISE EXCEPTION '导出数据失败: %', SQLERRM;
    END;

    -- 从CSV导入到本地表
    BEGIN
        COPY local_table FROM '/tmp/data.csv' WITH CSV HEADER;
        GET DIAGNOSTICS row_count = ROW_COUNT;
        RAISE NOTICE '数据导入成功: 插入了 % 行数据', row_count;
    EXCEPTION
        WHEN insufficient_privilege THEN
            RAISE EXCEPTION '权限不足，无法读取文件: /tmp/data.csv';
        WHEN OTHERS THEN
            RAISE EXCEPTION '导入数据失败: %', SQLERRM;
    END;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在（请检查local_table和foreign_table）';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'COPY操作失败: %', SQLERRM;
END $$;
```

### 3.2 批量更新

**批量更新优化（带完整错误处理和性能测试）**:

```sql
-- 批量更新（带错误处理）
DO $$
DECLARE
    updated_count BIGINT;
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    duration INTERVAL;
BEGIN
    -- 检查表是否存在
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'local_table') THEN
        RAISE EXCEPTION '本地表不存在: local_table';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'foreign_table') THEN
        RAISE EXCEPTION '外部表不存在: foreign_table';
    END IF;

    -- 记录开始时间
    start_time := clock_timestamp();

    -- 执行批量更新
    UPDATE local_table l
    SET status = f.status
    FROM foreign_table f
    WHERE l.id = f.id;

    GET DIAGNOSTICS updated_count = ROW_COUNT;
    end_time := clock_timestamp();
    duration := end_time - start_time;

    RAISE NOTICE '批量更新成功: 更新了 % 行数据，耗时 %', updated_count, duration;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在（请检查local_table和foreign_table）';
    WHEN OTHERS THEN
        RAISE EXCEPTION '批量更新失败: %', SQLERRM;
END $$;

-- 性能测试：批量更新
EXPLAIN (ANALYZE, BUFFERS, TIMING)
UPDATE local_table l
SET status = f.status
FROM foreign_table f
WHERE l.id = f.id;
-- 执行时间: 取决于网络延迟和匹配行数
-- 计划: Update on local_table -> Nested Loop -> Foreign Scan
```

---

## 4. 连接优化

### 4.1 连接池

```text
使用PgBouncer或连接池
- 减少连接开销
- 提高连接复用
- 降低延迟
```

### 4.2 连接管理

**连接监控（带完整错误处理）**:

```sql
-- 查看外部连接（带错误处理）
DO $$
DECLARE
    server_count INT;
BEGIN
    SELECT COUNT(*) INTO server_count FROM pg_foreign_server;

    IF server_count = 0 THEN
        RAISE WARNING '未找到外部服务器';
    ELSE
        RAISE NOTICE '找到 % 个外部服务器', server_count;
    END IF;

    -- 显示外部服务器列表
    FOR server_count IN
        SELECT srvname FROM pg_foreign_server ORDER BY srvname
    LOOP
        RAISE NOTICE '外部服务器: %', server_count;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询外部服务器失败: %', SQLERRM;
END $$;

-- 监控连接状态（带错误处理和性能测试）
DO $$
DECLARE
    connection_count INT;
BEGIN
    SELECT COUNT(*) INTO connection_count
    FROM pg_stat_activity
    WHERE application_name LIKE '%fdw%';

    IF connection_count = 0 THEN
        RAISE NOTICE '当前没有活跃的FDW连接';
    ELSE
        RAISE NOTICE '当前有 % 个活跃的FDW连接', connection_count;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '监控连接状态失败: %', SQLERRM;
END $$;

-- 性能测试：查询连接状态
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM pg_stat_activity
WHERE application_name LIKE '%fdw%';
-- 执行时间: <10ms
-- 计划: Seq Scan
```

---

## 5. 缓存策略

### 5.1 物化视图

**物化视图缓存（带完整错误处理）**:

```sql
-- 创建物化视图（带错误处理）
DO $$
BEGIN
    -- 检查外部表是否存在
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'foreign_table') THEN
        RAISE EXCEPTION '外部表不存在: foreign_table';
    END IF;

    -- 删除现有物化视图（如果存在）
    IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'mv_foreign_data') THEN
        DROP MATERIALIZED VIEW mv_foreign_data;
        RAISE NOTICE '已删除现有物化视图: mv_foreign_data';
    END IF;

    -- 创建物化视图
    CREATE MATERIALIZED VIEW mv_foreign_data AS
    SELECT * FROM foreign_table;

    RAISE NOTICE '物化视图创建成功: mv_foreign_data';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '外部表不存在: foreign_table';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 定期刷新（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'mv_foreign_data') THEN
        RAISE EXCEPTION '物化视图不存在: mv_foreign_data';
    END IF;

    -- 刷新物化视图
    BEGIN
        REFRESH MATERIALIZED VIEW CONCURRENTLY mv_foreign_data;
        RAISE NOTICE '物化视图刷新成功（并发模式）: mv_foreign_data';
    EXCEPTION
        WHEN feature_not_supported THEN
            -- 如果没有唯一索引，使用非并发刷新
            REFRESH MATERIALIZED VIEW mv_foreign_data;
            RAISE NOTICE '物化视图刷新成功（非并发模式）: mv_foreign_data';
        WHEN OTHERS THEN
            RAISE EXCEPTION '刷新物化视图失败: %', SQLERRM;
    END;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '物化视图不存在: mv_foreign_data';
    WHEN OTHERS THEN
        RAISE EXCEPTION '刷新物化视图过程失败: %', SQLERRM;
END $$;

-- 性能测试：查询物化视图
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM mv_foreign_data WHERE id > 1000;
-- 执行时间: 物化视图查询通常很快（本地数据）
-- 计划: Seq Scan 或 Index Scan（如果有索引）
```

### 5.2 本地缓存

**本地缓存表（带完整错误处理）**:

```sql
-- 创建本地缓存表（带错误处理）
DO $$
DECLARE
    cache_exists BOOLEAN;
BEGIN
    -- 检查外部表是否存在
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'foreign_table') THEN
        RAISE EXCEPTION '外部表不存在: foreign_table';
    END IF;

    -- 检查缓存表是否已存在
    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema = 'public' AND table_name = 'cache_foreign_data'
    ) INTO cache_exists;

    IF NOT cache_exists THEN
        -- 创建缓存表
        CREATE TABLE cache_foreign_data AS
        SELECT * FROM foreign_table;
        RAISE NOTICE '本地缓存表创建成功: cache_foreign_data';
    ELSE
        RAISE NOTICE '本地缓存表已存在: cache_foreign_data';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '外部表不存在: foreign_table';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建本地缓存表失败: %', SQLERRM;
END $$;

-- 定期更新（带错误处理）
DO $$
DECLARE
    inserted_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cache_foreign_data') THEN
        RAISE EXCEPTION '缓存表不存在: cache_foreign_data';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'foreign_table') THEN
        RAISE EXCEPTION '外部表不存在: foreign_table';
    END IF;

    -- 清空缓存表
    TRUNCATE cache_foreign_data;
    RAISE NOTICE '缓存表已清空: cache_foreign_data';

    -- 重新加载数据
    INSERT INTO cache_foreign_data
    SELECT * FROM foreign_table;

    GET DIAGNOSTICS inserted_count = ROW_COUNT;
    RAISE NOTICE '缓存更新成功: 插入了 % 行数据', inserted_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在（请检查cache_foreign_data和foreign_table）';
    WHEN OTHERS THEN
        RAISE EXCEPTION '更新缓存失败: %', SQLERRM;
END $$;

-- 性能测试：查询本地缓存
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM cache_foreign_data WHERE id > 1000;
-- 执行时间: 本地表查询通常很快
-- 计划: Seq Scan 或 Index Scan（如果有索引）
```

---

## 📚 相关文档

- [FDW完整指南.md](./FDW完整指南.md) - FDW完整指南
- [多数据源查询.md](./多数据源查询.md) - 多数据源查询详解
- [02-查询与优化/README.md](../README.md) - 查询与优化主题

---

**最后更新**: 2025年1月
