# PostgreSQL多数据源查询指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [PostgreSQL多数据源查询指南](#postgresql多数据源查询指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 数据源配置](#2-数据源配置)
    - [2.1 PostgreSQL数据源](#21-postgresql数据源)
    - [2.2 MySQL数据源](#22-mysql数据源)
  - [3. 跨数据源查询](#3-跨数据源查询)
    - [3.1 JOIN查询](#31-join查询)
    - [3.2 UNION查询](#32-union查询)
  - [4. 数据源统一](#4-数据源统一)
    - [4.1 统一视图](#41-统一视图)
    - [4.2 物化视图](#42-物化视图)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

多数据源查询允许在PostgreSQL中查询来自不同数据源的数据。

**应用场景**:

- 数据集成
- 跨数据库分析
- 数据迁移
- 数据同步

---

## 2. 数据源配置

### 2.1 PostgreSQL数据源

```sql
-- 创建PostgreSQL数据源服务器（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_foreign_server WHERE srvname = 'pg_remote') THEN
            RAISE WARNING '外部服务器已存在: pg_remote';
        ELSE
            CREATE SERVER pg_remote
            FOREIGN DATA WRAPPER postgres_fdw
            OPTIONS (host '192.168.1.100', port '5432', dbname 'remote_db');
            RAISE NOTICE 'PostgreSQL数据源服务器创建成功: pg_remote';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE WARNING '外部服务器已存在: pg_remote';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建PostgreSQL数据源服务器失败: %', SQLERRM;
    END;
END $$;

-- 创建用户映射（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_foreign_server WHERE srvname = 'pg_remote') THEN
            RAISE EXCEPTION '外部服务器不存在: pg_remote';
        END IF;

        IF EXISTS (
            SELECT 1 FROM pg_user_mappings
            WHERE srvname = 'pg_remote' AND usename = current_user::text
        ) THEN
            RAISE WARNING '用户映射已存在: % -> pg_remote', current_user;
        ELSE
            CREATE USER MAPPING FOR current_user
            SERVER pg_remote
            OPTIONS (user 'remote_user', password 'password');
            RAISE NOTICE '用户映射创建成功: % -> pg_remote', current_user;
        END IF;
    EXCEPTION
        WHEN undefined_object THEN
            RAISE EXCEPTION '外部服务器不存在: pg_remote';
        WHEN duplicate_object THEN
            RAISE WARNING '用户映射已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建用户映射失败: %', SQLERRM;
    END;
END $$;
```

### 2.2 MySQL数据源

```sql
-- 创建MySQL数据源服务器（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'mysql_fdw') THEN
            RAISE EXCEPTION 'mysql_fdw扩展未安装，请先安装扩展';
        END IF;

        IF EXISTS (SELECT 1 FROM pg_foreign_server WHERE srvname = 'mysql_remote') THEN
            RAISE WARNING '外部服务器已存在: mysql_remote';
        ELSE
            CREATE SERVER mysql_remote
            FOREIGN DATA WRAPPER mysql_fdw
            OPTIONS (host '192.168.1.101', port '3306', database 'mysql_db');
            RAISE NOTICE 'MySQL数据源服务器创建成功: mysql_remote';
        END IF;
    EXCEPTION
        WHEN undefined_file THEN
            RAISE EXCEPTION 'mysql_fdw扩展文件未找到（请先安装mysql_fdw扩展）';
        WHEN duplicate_object THEN
            RAISE WARNING '外部服务器已存在: mysql_remote';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建MySQL数据源服务器失败: %', SQLERRM;
    END;
END $$;

-- 创建用户映射（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_foreign_server WHERE srvname = 'mysql_remote') THEN
            RAISE EXCEPTION '外部服务器不存在: mysql_remote';
        END IF;

        IF EXISTS (
            SELECT 1 FROM pg_user_mappings
            WHERE srvname = 'mysql_remote' AND usename = current_user::text
        ) THEN
            RAISE WARNING '用户映射已存在: % -> mysql_remote', current_user;
        ELSE
            CREATE USER MAPPING FOR current_user
            SERVER mysql_remote
            OPTIONS (username 'mysql_user', password 'password');
            RAISE NOTICE '用户映射创建成功: % -> mysql_remote', current_user;
        END IF;
    EXCEPTION
        WHEN undefined_object THEN
            RAISE EXCEPTION '外部服务器不存在: mysql_remote';
        WHEN duplicate_object THEN
            RAISE WARNING '用户映射已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建用户映射失败: %', SQLERRM;
    END;
END $$;
```

---

## 3. 跨数据源查询

### 3.1 JOIN查询

```sql
-- PostgreSQL表 JOIN MySQL表（带错误处理和性能测试）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'pg_foreign_table'
        ) THEN
            RAISE EXCEPTION 'PostgreSQL外部表不存在: pg_foreign_table';
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'mysql_foreign_table'
        ) THEN
            RAISE EXCEPTION 'MySQL外部表不存在: mysql_foreign_table';
        END IF;

        SELECT COUNT(*) INTO result_count
        FROM pg_foreign_table pg
        JOIN mysql_foreign_table mysql ON pg.id = mysql.id;

        RAISE NOTICE '跨数据源JOIN查询成功: 找到 % 条结果', result_count;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '外部表不存在（请检查pg_foreign_table和mysql_foreign_table表）';
        WHEN OTHERS THEN
            RAISE EXCEPTION '跨数据源JOIN查询失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pg.id,
    pg.name,
    mysql.description
FROM pg_foreign_table pg
JOIN mysql_foreign_table mysql ON pg.id = mysql.id;
-- 执行时间: 取决于网络延迟和数据量
-- 计划: Foreign Scan -> Hash Join -> Foreign Scan
```

### 3.2 UNION查询

```sql
-- 合并多个数据源（带错误处理和性能测试）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'pg_foreign_table'
        ) THEN
            RAISE EXCEPTION 'PostgreSQL外部表不存在: pg_foreign_table';
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'mysql_foreign_table'
        ) THEN
            RAISE EXCEPTION 'MySQL外部表不存在: mysql_foreign_table';
        END IF;

        SELECT COUNT(*) INTO result_count
        FROM (
            SELECT 'postgres' AS source, * FROM pg_foreign_table
            UNION ALL
            SELECT 'mysql' AS source, * FROM mysql_foreign_table
        ) combined;

        RAISE NOTICE '跨数据源UNION查询成功: 找到 % 条结果', result_count;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '外部表不存在（请检查pg_foreign_table和mysql_foreign_table表）';
        WHEN OTHERS THEN
            RAISE EXCEPTION '跨数据源UNION查询失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT 'postgres' AS source, * FROM pg_foreign_table
UNION ALL
SELECT 'mysql' AS source, * FROM mysql_foreign_table;
-- 执行时间: 取决于网络延迟和数据量
-- 计划: Append -> Foreign Scan -> Foreign Scan
```

---

## 4. 数据源统一

### 4.1 统一视图

```sql
-- 创建统一视图（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'pg_customers'
        ) THEN
            RAISE EXCEPTION 'PostgreSQL外部表不存在: pg_customers';
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.tables
            WHERE table_schema = 'public' AND table_name = 'mysql_customers'
        ) THEN
            RAISE EXCEPTION 'MySQL外部表不存在: mysql_customers';
        END IF;

        IF EXISTS (
            SELECT 1 FROM information_schema.views
            WHERE table_schema = 'public' AND table_name = 'unified_customers'
        ) THEN
            DROP VIEW unified_customers;
            RAISE NOTICE '已删除现有视图: unified_customers';
        END IF;

        CREATE VIEW unified_customers AS
        SELECT
            'postgres' AS source,
            id,
            name,
            email
        FROM pg_customers
        UNION ALL
        SELECT
            'mysql' AS source,
            id,
            name,
            email
        FROM mysql_customers;

        RAISE NOTICE '统一视图创建成功: unified_customers';
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '外部表不存在（请检查pg_customers和mysql_customers表）';
        WHEN duplicate_table THEN
            RAISE WARNING '视图已存在: unified_customers';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建统一视图失败: %', SQLERRM;
    END;
END $$;

-- 查询统一视图（带错误处理和性能测试）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.views
            WHERE table_schema = 'public' AND table_name = 'unified_customers'
        ) THEN
            RAISE EXCEPTION '统一视图不存在: unified_customers';
        END IF;

        SELECT COUNT(*) INTO result_count FROM unified_customers;
        RAISE NOTICE '统一视图查询成功: 找到 % 条结果', result_count;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '统一视图不存在: unified_customers';
        WHEN OTHERS THEN
            RAISE EXCEPTION '查询统一视图失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM unified_customers WHERE source = 'postgres';
-- 执行时间: 取决于网络延迟和数据量
-- 计划: Append -> Foreign Scan -> Foreign Scan
```

### 4.2 物化视图

**创建物化视图（带完整错误处理）**:

```sql
-- 创建物化视图缓存数据（带错误处理）
DO $$
BEGIN
    -- 检查源视图是否存在
    IF NOT EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'unified_view') THEN
        RAISE EXCEPTION '源视图不存在: unified_view';
    END IF;

    -- 删除现有物化视图（如果存在）
    IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'mv_unified_data') THEN
        DROP MATERIALIZED VIEW mv_unified_data;
        RAISE NOTICE '已删除现有物化视图: mv_unified_data';
    END IF;

    -- 创建物化视图
    CREATE MATERIALIZED VIEW mv_unified_data AS
    SELECT * FROM unified_view;

    RAISE NOTICE '物化视图创建成功: mv_unified_data';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '源视图不存在: unified_view';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 定期刷新（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'mv_unified_data') THEN
        RAISE EXCEPTION '物化视图不存在: mv_unified_data';
    END IF;

    -- 刷新物化视图（需要唯一索引才能使用CONCURRENTLY）
    BEGIN
        REFRESH MATERIALIZED VIEW CONCURRENTLY mv_unified_data;
        RAISE NOTICE '物化视图刷新成功: mv_unified_data';
    EXCEPTION
        WHEN feature_not_supported THEN
            -- 如果没有唯一索引，使用非并发刷新
            REFRESH MATERIALIZED VIEW mv_unified_data;
            RAISE NOTICE '物化视图刷新成功（非并发模式）: mv_unified_data';
        WHEN OTHERS THEN
            RAISE EXCEPTION '刷新物化视图失败: %', SQLERRM;
    END;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '物化视图不存在: mv_unified_data';
    WHEN OTHERS THEN
        RAISE EXCEPTION '刷新物化视图过程失败: %', SQLERRM;
END $$;

-- 性能测试：查询物化视图
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM mv_unified_data WHERE source = 'postgres';
-- 执行时间: 物化视图查询通常很快（本地数据）
-- 计划: Seq Scan 或 Index Scan（如果有索引）
```

---

## 5. 最佳实践

### ✅ 推荐做法

1. **使用连接池** - 减少连接开销
2. **查询下推** - 在远程执行查询
3. **批量操作** - 减少网络往返
4. **缓存数据** - 使用物化视图

### ❌ 避免做法

1. **频繁小查询** - 合并为批量查询
2. **全表扫描** - 使用WHERE过滤
3. **忽略索引** - 确保远程表有索引

---

## 📚 相关文档

- [FDW完整指南.md](./FDW完整指南.md) - FDW完整指南
- [联邦查询性能优化.md](./联邦查询性能优化.md) - 性能优化详解
- [02-查询与优化/README.md](../README.md) - 查询与优化主题

---

**最后更新**: 2025年1月
