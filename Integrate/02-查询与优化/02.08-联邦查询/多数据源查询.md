# PostgreSQL多数据源查询指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [PostgreSQL多数据源查询指南](#postgresql多数据源查询指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 数据源配置](#2-数据源配置)
    - [2.1 PostgreSQL数据源](#21-postgresql数据源)
    - [2.2 MySQL数据源](#22-mysql数据源)
  - [3. 跨数据源查询](#3-跨数据源查询)
    - [3.1 JOIN查询](#31-join查询)
    - [3.2 UNION查询](#32-union查询)
  - [4. 数据源统一](#4-数据源统一)
    - [4.1 统一视图](#41-统一视图)
    - [4.2 物化视图](#42-物化视图)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

多数据源查询允许在PostgreSQL中查询来自不同数据源的数据。

**应用场景**:

- 数据集成
- 跨数据库分析
- 数据迁移
- 数据同步

---

## 2. 数据源配置

### 2.1 PostgreSQL数据源

```sql
CREATE SERVER pg_remote
FOREIGN DATA WRAPPER postgres_fdw
OPTIONS (host '192.168.1.100', port '5432', dbname 'remote_db');

CREATE USER MAPPING FOR current_user
SERVER pg_remote
OPTIONS (user 'remote_user', password 'password');
```

### 2.2 MySQL数据源

```sql
CREATE SERVER mysql_remote
FOREIGN DATA WRAPPER mysql_fdw
OPTIONS (host '192.168.1.101', port '3306', database 'mysql_db');

CREATE USER MAPPING FOR current_user
SERVER mysql_remote
OPTIONS (username 'mysql_user', password 'password');
```

---

## 3. 跨数据源查询

### 3.1 JOIN查询

```sql
-- PostgreSQL表 JOIN MySQL表
SELECT
    pg.id,
    pg.name,
    mysql.description
FROM pg_foreign_table pg
JOIN mysql_foreign_table mysql ON pg.id = mysql.id;
```

### 3.2 UNION查询

```sql
-- 合并多个数据源
SELECT 'postgres' AS source, * FROM pg_foreign_table
UNION ALL
SELECT 'mysql' AS source, * FROM mysql_foreign_table;
```

---

## 4. 数据源统一

### 4.1 统一视图

```sql
CREATE VIEW unified_customers AS
SELECT
    'postgres' AS source,
    id,
    name,
    email
FROM pg_customers
UNION ALL
SELECT
    'mysql' AS source,
    id,
    name,
    email
FROM mysql_customers;
```

### 4.2 物化视图

**创建物化视图（带完整错误处理）**:

```sql
-- 创建物化视图缓存数据（带错误处理）
DO $$
BEGIN
    -- 检查源视图是否存在
    IF NOT EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = 'public' AND table_name = 'unified_view') THEN
        RAISE EXCEPTION '源视图不存在: unified_view';
    END IF;

    -- 删除现有物化视图（如果存在）
    IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'mv_unified_data') THEN
        DROP MATERIALIZED VIEW mv_unified_data;
        RAISE NOTICE '已删除现有物化视图: mv_unified_data';
    END IF;

    -- 创建物化视图
    CREATE MATERIALIZED VIEW mv_unified_data AS
    SELECT * FROM unified_view;

    RAISE NOTICE '物化视图创建成功: mv_unified_data';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '源视图不存在: unified_view';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 定期刷新（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'mv_unified_data') THEN
        RAISE EXCEPTION '物化视图不存在: mv_unified_data';
    END IF;

    -- 刷新物化视图（需要唯一索引才能使用CONCURRENTLY）
    BEGIN
        REFRESH MATERIALIZED VIEW CONCURRENTLY mv_unified_data;
        RAISE NOTICE '物化视图刷新成功: mv_unified_data';
    EXCEPTION
        WHEN feature_not_supported THEN
            -- 如果没有唯一索引，使用非并发刷新
            REFRESH MATERIALIZED VIEW mv_unified_data;
            RAISE NOTICE '物化视图刷新成功（非并发模式）: mv_unified_data';
        WHEN OTHERS THEN
            RAISE EXCEPTION '刷新物化视图失败: %', SQLERRM;
    END;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '物化视图不存在: mv_unified_data';
    WHEN OTHERS THEN
        RAISE EXCEPTION '刷新物化视图过程失败: %', SQLERRM;
END $$;

-- 性能测试：查询物化视图
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM mv_unified_data WHERE source = 'postgres';
-- 执行时间: 物化视图查询通常很快（本地数据）
-- 计划: Seq Scan 或 Index Scan（如果有索引）
```

---

## 5. 最佳实践

### ✅ 推荐做法

1. **使用连接池** - 减少连接开销
2. **查询下推** - 在远程执行查询
3. **批量操作** - 减少网络往返
4. **缓存数据** - 使用物化视图

### ❌ 避免做法

1. **频繁小查询** - 合并为批量查询
2. **全表扫描** - 使用WHERE过滤
3. **忽略索引** - 确保远程表有索引

---

## 📚 相关文档

- [FDW完整指南.md](./FDW完整指南.md) - FDW完整指南
- [联邦查询性能优化.md](./联邦查询性能优化.md) - 性能优化详解
- [02-查询与优化/README.md](../README.md) - 查询与优化主题

---

**最后更新**: 2025年1月
