# 多语言全文搜索

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [多语言全文搜索](#多语言全文搜索)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 语言检测](#2-语言检测)
    - [2.1 简单语言检测](#21-简单语言检测)
    - [2.2 使用语言检测](#22-使用语言检测)
  - [3. 多语言配置](#3-多语言配置)
    - [3.1 创建多语言配置](#31-创建多语言配置)
    - [3.2 存储语言信息](#32-存储语言信息)
  - [4. 混合语言搜索](#4-混合语言搜索)
    - [4.1 多语言搜索](#41-多语言搜索)
    - [4.2 按语言过滤搜索](#42-按语言过滤搜索)
    - [4.3 组合搜索](#43-组合搜索)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

多语言全文搜索支持在同一个系统中搜索多种语言的文档。PostgreSQL支持：

- **内置语言** - 英语、中文、日语、韩语等
- **自定义配置** - 创建自定义文本搜索配置
- **语言检测** - 自动检测文档语言
- **混合搜索** - 同时搜索多种语言

---

## 2. 语言检测

### 2.1 简单语言检测

**语言检测函数（带完整错误处理）**:

```sql
-- 检测是否包含中文字符（带完整错误处理）
CREATE OR REPLACE FUNCTION detect_language(text TEXT)
RETURNS regconfig AS $$
BEGIN
    -- 参数验证
    IF text IS NULL THEN
        RAISE EXCEPTION '输入文本不能为NULL';
    END IF;

    -- 检测中文
    IF text ~ '[\u4e00-\u9fa5]' THEN
        -- 检查中文配置是否存在
        IF EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese') THEN
            RETURN 'chinese'::regconfig;
        ELSE
            RAISE WARNING '中文配置不存在，使用默认配置';
            RETURN 'english'::regconfig;
        END IF;
    -- 检测日文
    ELSIF text ~ '[\u3040-\u309F\u30A0-\u30FF]' THEN
        IF EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'japanese') THEN
            RETURN 'japanese'::regconfig;
        ELSE
            RAISE WARNING '日文配置不存在，使用默认配置';
            RETURN 'english'::regconfig;
        END IF;
    -- 检测韩文
    ELSIF text ~ '[\uAC00-\uD7A3]' THEN
        IF EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'korean') THEN
            RETURN 'korean'::regconfig;
        ELSE
            RAISE WARNING '韩文配置不存在，使用默认配置';
            RETURN 'english'::regconfig;
        END IF;
    -- 默认英语
    ELSE
        RETURN 'english'::regconfig;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '语言检测失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

### 2.2 使用语言检测

**创建多语言表（带完整错误处理）**:

```sql
-- 创建表（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
        RAISE WARNING '表已存在: multilingual_articles';
    ELSE
        CREATE TABLE multilingual_articles (
            id SERIAL PRIMARY KEY,
            title TEXT,
            content TEXT,
            tsv TSVECTOR
        );
        RAISE NOTICE '表创建成功: multilingual_articles';
    END IF;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE WARNING '表已存在: multilingual_articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表失败: %', SQLERRM;
END $$;

-- 自动检测语言并生成tsvector（带完整错误处理）
CREATE OR REPLACE FUNCTION multilingual_tsv_trigger()
RETURNS TRIGGER AS $$
DECLARE
    detected_config regconfig;
BEGIN
    -- 检查语言检测函数是否存在
    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'detect_language') THEN
        RAISE EXCEPTION '语言检测函数不存在: detect_language';
    END IF;

    -- 检测语言
    detected_config := detect_language(coalesce(NEW.title, '') || ' ' || coalesce(NEW.content, ''));

    -- 生成tsvector
    NEW.tsv := to_tsvector(
        detected_config,
        coalesce(NEW.title, '') || ' ' || coalesce(NEW.content, '')
    );

    RETURN NEW;
EXCEPTION
    WHEN undefined_function THEN
        RAISE EXCEPTION '语言检测函数不存在: detect_language';
    WHEN undefined_object THEN
        RAISE EXCEPTION '文本搜索配置不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '生成tsvector失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'multilingual_tsv_trigger') THEN
        RAISE EXCEPTION '触发器函数不存在: multilingual_tsv_trigger';
    END IF;

    -- 删除现有触发器（如果存在）
    IF EXISTS (
        SELECT 1 FROM pg_trigger WHERE tgname = 'multilingual_tsv_update'
    ) THEN
        DROP TRIGGER multilingual_tsv_update ON multilingual_articles;
        RAISE NOTICE '已删除现有触发器: multilingual_tsv_update';
    END IF;

    -- 创建触发器
    CREATE TRIGGER multilingual_tsv_update
    BEFORE INSERT OR UPDATE ON multilingual_articles
    FOR EACH ROW
    EXECUTE FUNCTION multilingual_tsv_trigger();

    RAISE NOTICE '触发器创建成功: multilingual_tsv_update';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    WHEN undefined_function THEN
        RAISE EXCEPTION '触发器函数不存在: multilingual_tsv_trigger';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建触发器失败: %', SQLERRM;
END $$;
```

---

## 3. 多语言配置

### 3.1 创建多语言配置

**创建多语言配置（带完整错误处理）**:

```sql
-- 安装中文分词扩展（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'zhparser') THEN
        CREATE EXTENSION zhparser;
        RAISE NOTICE 'zhparser扩展已创建';
    ELSE
        RAISE NOTICE 'zhparser扩展已存在';
    END IF;
EXCEPTION
    WHEN undefined_file THEN
        RAISE EXCEPTION 'zhparser扩展文件未找到（需要单独安装zhparser扩展）';
    WHEN OTHERS THEN
        RAISE EXCEPTION '安装zhparser扩展失败: %', SQLERRM;
END $$;

-- 创建中文配置（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'zhparser') THEN
        RAISE EXCEPTION 'zhparser扩展未安装';
    END IF;

    IF EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese') THEN
        RAISE WARNING '文本搜索配置已存在: chinese';
    ELSE
        CREATE TEXT SEARCH CONFIGURATION chinese (PARSER = zhparser);
        RAISE NOTICE '文本搜索配置创建成功: chinese';
    END IF;

    -- 添加词典映射
    ALTER TEXT SEARCH CONFIGURATION chinese
        ADD MAPPING FOR n,v,a,i,e,l WITH simple;
    RAISE NOTICE '中文词典映射添加成功';
EXCEPTION
    WHEN undefined_object THEN
        RAISE EXCEPTION 'zhparser解析器不存在';
    WHEN duplicate_object THEN
        RAISE WARNING '文本搜索配置已存在: chinese';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建中文配置失败: %', SQLERRM;
END $$;

-- 创建日文配置（如果可用，带错误处理）
DO $$
BEGIN
    -- 检查日文解析器是否可用
    IF NOT EXISTS (SELECT 1 FROM pg_ts_parser WHERE prsname = 'japanese_parser') THEN
        RAISE NOTICE '日文解析器不可用，跳过日文配置创建';
        RETURN;
    END IF;

    IF EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'japanese') THEN
        RAISE WARNING '文本搜索配置已存在: japanese';
    ELSE
        CREATE TEXT SEARCH CONFIGURATION japanese (PARSER = japanese_parser);
        RAISE NOTICE '文本搜索配置创建成功: japanese';
    END IF;
EXCEPTION
    WHEN undefined_object THEN
        RAISE NOTICE '日文解析器不可用';
    WHEN duplicate_object THEN
        RAISE WARNING '文本搜索配置已存在: japanese';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建日文配置失败: %', SQLERRM;
END $$;

-- 创建韩文配置（如果可用，带错误处理）
DO $$
BEGIN
    -- 检查韩文解析器是否可用
    IF NOT EXISTS (SELECT 1 FROM pg_ts_parser WHERE prsname = 'korean_parser') THEN
        RAISE NOTICE '韩文解析器不可用，跳过韩文配置创建';
        RETURN;
    END IF;

    IF EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'korean') THEN
        RAISE WARNING '文本搜索配置已存在: korean';
    ELSE
        CREATE TEXT SEARCH CONFIGURATION korean (PARSER = korean_parser);
        RAISE NOTICE '文本搜索配置创建成功: korean';
    END IF;
EXCEPTION
    WHEN undefined_object THEN
        RAISE NOTICE '韩文解析器不可用';
    WHEN duplicate_object THEN
        RAISE WARNING '文本搜索配置已存在: korean';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建韩文配置失败: %', SQLERRM;
END $$;
```

### 3.2 存储语言信息

**存储语言信息（带完整错误处理）**:

```sql
-- 添加语言列（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    END IF;

    IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public' AND table_name = 'multilingual_articles' AND column_name = 'language'
    ) THEN
        RAISE WARNING '列已存在: language';
    ELSE
        ALTER TABLE multilingual_articles
        ADD COLUMN language TEXT DEFAULT 'auto';
        RAISE NOTICE '语言列添加成功: language';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    WHEN duplicate_column THEN
        RAISE WARNING '列已存在: language';
    WHEN OTHERS THEN
        RAISE EXCEPTION '添加语言列失败: %', SQLERRM;
END $$;

-- 自动检测并存储语言（带完整错误处理）
CREATE OR REPLACE FUNCTION detect_and_store_language()
RETURNS TRIGGER AS $$
BEGIN
    -- 参数验证
    IF NEW.content IS NULL AND NEW.title IS NULL THEN
        RAISE WARNING '标题和内容均为NULL，无法检测语言';
        NEW.language := 'english';
        RETURN NEW;
    END IF;

    IF NEW.language = 'auto' OR NEW.language IS NULL THEN
        IF NEW.content ~ '[\u4e00-\u9fa5]' OR NEW.title ~ '[\u4e00-\u9fa5]' THEN
            NEW.language := 'chinese';
        ELSIF NEW.content ~ '[\u3040-\u309F\u30A0-\u30FF]' OR NEW.title ~ '[\u3040-\u309F\u30A0-\u30FF]' THEN
            NEW.language := 'japanese';
        ELSIF NEW.content ~ '[\uAC00-\uD7A3]' OR NEW.title ~ '[\uAC00-\uD7A3]' THEN
            NEW.language := 'korean';
        ELSE
            NEW.language := 'english';
        END IF;
    END IF;

    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '语言检测失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'detect_and_store_language') THEN
        RAISE EXCEPTION '触发器函数不存在: detect_and_store_language';
    END IF;

    -- 删除现有触发器（如果存在）
    IF EXISTS (
        SELECT 1 FROM pg_trigger WHERE tgname = 'detect_language_trigger'
    ) THEN
        DROP TRIGGER detect_language_trigger ON multilingual_articles;
        RAISE NOTICE '已删除现有触发器: detect_language_trigger';
    END IF;

    -- 创建触发器
    CREATE TRIGGER detect_language_trigger
    BEFORE INSERT OR UPDATE ON multilingual_articles
    FOR EACH ROW
    EXECUTE FUNCTION detect_and_store_language();

    RAISE NOTICE '触发器创建成功: detect_language_trigger';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    WHEN undefined_function THEN
        RAISE EXCEPTION '触发器函数不存在: detect_and_store_language';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建触发器失败: %', SQLERRM;
END $$;
```

---

## 4. 混合语言搜索

### 4.1 多语言搜索

**多语言搜索（带完整错误处理和性能测试）**:

```sql
-- 搜索多种语言（带错误处理）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    END IF;

    SELECT COUNT(*) INTO result_count
    FROM multilingual_articles,
         to_tsquery('english', 'database | 数据库 | データベース') query
    WHERE tsv @@ query;

    RAISE NOTICE '多语言搜索成功: 找到 % 条结果', result_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    WHEN undefined_object THEN
        RAISE EXCEPTION '文本搜索配置不存在: english';
    WHEN OTHERS THEN
        RAISE EXCEPTION '多语言搜索失败: %', SQLERRM;
END $$;

-- 性能测试：多语言搜索
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    language,
    ts_rank(tsv, query) AS rank
FROM multilingual_articles,
     to_tsquery('english', 'database | 数据库 | データベース') query
WHERE tsv @@ query
ORDER BY rank DESC;
-- 执行时间: 取决于表大小和索引
-- 计划: Sort -> Bitmap Heap Scan -> Bitmap Index Scan
```

### 4.2 按语言过滤搜索

**按语言过滤搜索（带完整错误处理和性能测试）**:

```sql
-- 只搜索特定语言（带错误处理）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    END IF;

    -- 检查语言列是否存在
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_schema = 'public' AND table_name = 'multilingual_articles' AND column_name = 'language'
    ) THEN
        RAISE EXCEPTION '语言列不存在: language';
    END IF;

    SELECT COUNT(*) INTO result_count
    FROM multilingual_articles
    WHERE language = 'chinese'
      AND tsv @@ to_tsquery('chinese', '数据库');

    RAISE NOTICE '按语言过滤搜索成功: 找到 % 条中文结果', result_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    WHEN undefined_column THEN
        RAISE EXCEPTION '语言列不存在: language';
    WHEN undefined_object THEN
        RAISE EXCEPTION '文本搜索配置不存在: chinese';
    WHEN OTHERS THEN
        RAISE EXCEPTION '按语言过滤搜索失败: %', SQLERRM;
END $$;

-- 性能测试：按语言过滤搜索
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content
FROM multilingual_articles
WHERE language = 'chinese'
  AND tsv @@ to_tsquery('chinese', '数据库');
-- 执行时间: 取决于表大小和索引
-- 计划: Bitmap Heap Scan -> Bitmap Index Scan（可能使用language列的索引）
```

### 4.3 组合搜索

**组合搜索（带完整错误处理和性能测试）**:

```sql
-- 组合多种语言的查询（带错误处理）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multilingual_articles') THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    END IF;

    -- 检查文本搜索配置是否存在
    IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'english') THEN
        RAISE EXCEPTION '文本搜索配置不存在: english';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_ts_config WHERE cfgname = 'chinese') THEN
        RAISE EXCEPTION '文本搜索配置不存在: chinese';
    END IF;

    WITH english_query AS (
        SELECT to_tsquery('english', 'database') AS q
    ),
    chinese_query AS (
        SELECT to_tsquery('chinese', '数据库') AS q
    )
    SELECT COUNT(*) INTO result_count
    FROM multilingual_articles
    WHERE (language = 'english' AND tsv @@ (SELECT q FROM english_query))
       OR (language = 'chinese' AND tsv @@ (SELECT q FROM chinese_query));

    RAISE NOTICE '组合搜索成功: 找到 % 条结果', result_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: multilingual_articles';
    WHEN undefined_object THEN
        RAISE EXCEPTION '文本搜索配置不存在（请检查english和chinese配置）';
    WHEN OTHERS THEN
        RAISE EXCEPTION '组合搜索失败: %', SQLERRM;
END $$;

-- 性能测试：组合搜索
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH english_query AS (
    SELECT to_tsquery('english', 'database') AS q
),
chinese_query AS (
    SELECT to_tsquery('chinese', '数据库') AS q
)
SELECT
    id,
    title,
    content,
    language,
    CASE
        WHEN language = 'english' THEN ts_rank(tsv, (SELECT q FROM english_query))
        WHEN language = 'chinese' THEN ts_rank(tsv, (SELECT q FROM chinese_query))
        ELSE 0
    END AS rank
FROM multilingual_articles
WHERE (language = 'english' AND tsv @@ (SELECT q FROM english_query))
   OR (language = 'chinese' AND tsv @@ (SELECT q FROM chinese_query))
ORDER BY rank DESC;
-- 执行时间: 取决于表大小和索引
-- 计划: Sort -> Bitmap Heap Scan -> Bitmap Index Scan（可能使用多个索引）
```

---

## 5. 最佳实践

### ✅ 推荐做法

1. **自动检测语言** - 使用语言检测函数
2. **存储语言信息** - 便于按语言过滤
3. **使用合适的配置** - 为每种语言使用专门的配置
4. **优化索引** - 为多语言数据创建合适的索引
5. **提供语言选择** - 允许用户选择搜索语言

### ❌ 避免做法

1. **忽略语言差异** - 不同语言需要不同处理
2. **不存储语言信息** - 影响搜索性能
3. **使用错误的配置** - 影响搜索准确性
4. **不优化查询** - 多语言搜索可能较慢

---

## 📚 相关文档

- [PostgreSQL18-全文搜索深度实战.md](./PostgreSQL18-全文搜索深度实战.md) - 全文搜索完整指南
- [中文全文搜索指南.md](./中文全文搜索指南.md) - 中文全文搜索指南
- [全文搜索性能优化.md](./全文搜索性能优化.md) - 性能优化指南

---

**最后更新**: 2025年1月
