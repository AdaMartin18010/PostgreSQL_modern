# 全文搜索性能优化

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [全文搜索性能优化](#全文搜索性能优化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. GIN vs GiST索引](#2-gin-vs-gist索引)
    - [2.1 索引对比](#21-索引对比)
    - [2.2 选择建议](#22-选择建议)
  - [3. GIN索引优化](#3-gin索引优化)
    - [3.1 索引参数](#31-索引参数)
    - [3.2 索引维护](#32-索引维护)
  - [4. 分区表优化](#4-分区表优化)
    - [4.1 分区策略](#41-分区策略)
    - [4.2 分区裁剪](#42-分区裁剪)
  - [5. 查询优化](#5-查询优化)
    - [5.1 预计算tsvector](#51-预计算tsvector)
    - [5.2 使用LIMIT](#52-使用limit)
    - [5.3 避免复杂查询](#53-避免复杂查询)
  - [6. 最佳实践](#6-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

全文搜索性能优化是提升搜索查询性能的关键。主要优化方向包括：

- **索引选择** - GIN vs GiST
- **索引优化** - 索引参数调优
- **查询优化** - 查询语句优化
- **分区优化** - 大表分区策略

---

## 2. GIN vs GiST索引

### 2.1 索引对比

| 特性 | GIN索引 | GiST索引 |
| --- | --- | --- |
| **查询速度** | 快 | 中等 |
| **索引大小** | 大 | 小 |
| **更新速度** | 慢 | 快 |
| **适用场景** | 查询频繁、更新少 | 更新频繁、查询中等 |

### 2.2 选择建议

- **GIN索引** - 推荐用于大多数全文搜索场景
  - 查询性能优秀
  - 适合读多写少的场景
  - 索引构建较慢但查询快

- **GiST索引** - 适合更新频繁的场景
  - 索引构建快
  - 更新性能好
  - 查询性能中等

---

## 3. GIN索引优化

### 3.1 索引参数

**索引参数优化（带完整错误处理）**:

```sql
-- 创建GIN索引（默认参数，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '表不存在: articles';
    END IF;

    IF EXISTS (
        SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'articles_tsv_idx'
    ) THEN
        RAISE WARNING '索引已存在: articles_tsv_idx';
    ELSE
        CREATE INDEX articles_tsv_idx ON articles USING GIN (tsv);
        RAISE NOTICE 'GIN索引创建成功: articles_tsv_idx（默认参数）';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: articles';
    WHEN duplicate_table THEN
        RAISE WARNING '索引已存在: articles_tsv_idx';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建索引失败: %', SQLERRM;
END $$;

-- 使用fastupdate参数（PostgreSQL 9.5+，带错误处理）
-- fastupdate=off: 立即更新索引（查询快，更新慢）
-- fastupdate=on: 延迟更新索引（更新快，查询可能稍慢）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '表不存在: articles';
    END IF;

    -- 删除现有索引（如果存在）
    IF EXISTS (
        SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'articles_tsv_idx'
    ) THEN
        DROP INDEX articles_tsv_idx;
        RAISE NOTICE '已删除现有索引: articles_tsv_idx';
    END IF;

    CREATE INDEX articles_tsv_idx ON articles
    USING GIN (tsv) WITH (fastupdate=on);

    RAISE NOTICE 'GIN索引创建成功: articles_tsv_idx（fastupdate=on）';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建索引失败: %', SQLERRM;
END $$;

-- 使用gin_pending_list_limit参数（带错误处理）
-- 控制pending list的大小
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '表不存在: articles';
    END IF;

    -- 删除现有索引（如果存在）
    IF EXISTS (
        SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'articles_tsv_idx'
    ) THEN
        DROP INDEX articles_tsv_idx;
        RAISE NOTICE '已删除现有索引: articles_tsv_idx';
    END IF;

    CREATE INDEX articles_tsv_idx ON articles
    USING GIN (tsv) WITH (
        fastupdate=on,
        gin_pending_list_limit=4096
    );

    RAISE NOTICE 'GIN索引创建成功: articles_tsv_idx（fastupdate=on, gin_pending_list_limit=4096）';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建索引失败: %', SQLERRM;
END $$;

-- 性能测试：索引使用情况
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'postgresql');
-- 执行时间: 取决于表大小和索引参数
-- 计划: Bitmap Heap Scan -> Bitmap Index Scan
```

### 3.2 索引维护

**索引维护（带完整错误处理）**:

```sql
-- 定期维护GIN索引（带错误处理）
-- 合并pending list到主索引
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '表不存在: articles';
    END IF;

    -- 执行VACUUM
    VACUUM articles;
    RAISE NOTICE 'VACUUM执行成功: articles（pending list已合并）';
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'VACUUM执行失败: %', SQLERRM;
END $$;

-- 重建索引（如果索引膨胀严重，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'articles_tsv_idx'
    ) THEN
        RAISE EXCEPTION '索引不存在: articles_tsv_idx';
    END IF;

    -- 重建索引
    REINDEX INDEX articles_tsv_idx;
    RAISE NOTICE '索引重建成功: articles_tsv_idx';
EXCEPTION
    WHEN undefined_object THEN
        RAISE EXCEPTION '索引不存在: articles_tsv_idx';
    WHEN OTHERS THEN
        RAISE EXCEPTION '重建索引失败: %', SQLERRM;
END $$;

-- 性能测试：维护前后对比
-- 维护前
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'postgresql');
-- 执行时间: 可能较慢（pending list未合并）

-- 维护后
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'postgresql');
-- 执行时间: 更快（pending list已合并）
```

---

## 4. 分区表优化

### 4.1 分区策略

**分区表创建（带完整错误处理）**:

```sql
-- 按时间分区（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE WARNING '表已存在: articles（如需重新创建，请先删除）';
    ELSE
        CREATE TABLE articles (
            id BIGSERIAL,
            title TEXT,
            content TEXT,
            tsv TSVECTOR,
            created_at TIMESTAMPTZ
        ) PARTITION BY RANGE (created_at);
        RAISE NOTICE '分区表创建成功: articles';
    END IF;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE WARNING '表已存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表失败: %', SQLERRM;
END $$;

-- 创建分区（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '分区表不存在: articles';
    END IF;

    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles_2024') THEN
        RAISE WARNING '分区已存在: articles_2024';
    ELSE
        CREATE TABLE articles_2024 PARTITION OF articles
            FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
        RAISE NOTICE '分区创建成功: articles_2024';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '分区表不存在: articles';
    WHEN duplicate_table THEN
        RAISE WARNING '分区已存在: articles_2024';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区失败: %', SQLERRM;
END $$;

-- 在每个分区上创建索引（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles_2024') THEN
        RAISE EXCEPTION '分区不存在: articles_2024';
    END IF;

    IF EXISTS (
        SELECT 1 FROM pg_indexes WHERE tablename = 'articles_2024' AND indexname = 'articles_2024_tsv_idx'
    ) THEN
        RAISE WARNING '索引已存在: articles_2024_tsv_idx';
    ELSE
        CREATE INDEX articles_2024_tsv_idx ON articles_2024 USING GIN (tsv);
        RAISE NOTICE '分区索引创建成功: articles_2024_tsv_idx';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '分区不存在: articles_2024';
    WHEN duplicate_table THEN
        RAISE WARNING '索引已存在: articles_2024_tsv_idx';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区索引失败: %', SQLERRM;
END $$;
```

### 4.2 分区裁剪

**分区裁剪验证（带完整错误处理和性能测试）**:

```sql
-- 查询时自动进行分区裁剪（带错误处理）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '分区表不存在: articles';
    END IF;

    SELECT COUNT(*) INTO result_count
    FROM articles
    WHERE tsv @@ to_tsquery('english', 'postgresql')
      AND created_at >= '2024-01-01'
      AND created_at < '2025-01-01';

    RAISE NOTICE '分区裁剪查询成功: 找到 % 条结果', result_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '分区表不存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION '分区裁剪查询失败: %', SQLERRM;
END $$;

-- 性能测试：分区裁剪
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'postgresql')
  AND created_at >= '2024-01-01'
  AND created_at < '2025-01-01';
-- 执行时间: 只扫描articles_2024分区，性能好
-- 计划: Append -> Bitmap Heap Scan -> Bitmap Index Scan（只扫描匹配的分区）
```

---

## 5. 查询优化

### 5.1 预计算tsvector

**预计算tsvector对比（带性能测试）**:

```sql
-- ❌ 不推荐：查询时计算（性能差）
-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE to_tsvector('english', content) @@ to_tsquery('english', 'postgresql');
-- 执行时间: 慢（需要为每行计算tsvector）
-- 计划: Seq Scan（无法使用索引）

-- ✅ 推荐：使用预计算的tsvector（性能好）
-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'postgresql');
-- 执行时间: 快（使用GIN索引）
-- 计划: Bitmap Heap Scan -> Bitmap Index Scan

-- 性能对比验证（带错误处理）
DO $$
DECLARE
    slow_count BIGINT;
    fast_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '表不存在: articles';
    END IF;

    -- 慢查询（不推荐）
    SELECT COUNT(*) INTO slow_count
    FROM articles
    WHERE to_tsvector('english', content) @@ to_tsquery('english', 'postgresql');

    -- 快查询（推荐）
    SELECT COUNT(*) INTO fast_count
    FROM articles
    WHERE tsv @@ to_tsquery('english', 'postgresql');

    RAISE NOTICE '慢查询结果数: %, 快查询结果数: %', slow_count, fast_count;

    IF slow_count != fast_count THEN
        RAISE WARNING '查询结果不一致（可能有问题）';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION '性能对比验证失败: %', SQLERRM;
END $$;
```

### 5.2 使用LIMIT

**使用LIMIT优化（带完整错误处理和性能测试）**:

```sql
-- 使用LIMIT限制结果数量（带错误处理）
DO $$
DECLARE
    result_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '表不存在: articles';
    END IF;

    SELECT COUNT(*) INTO result_count
    FROM (
        SELECT * FROM articles
        WHERE tsv @@ to_tsquery('english', 'postgresql')
        ORDER BY ts_rank(tsv, to_tsquery('english', 'postgresql')) DESC
        LIMIT 20
    ) subquery;

    RAISE NOTICE 'LIMIT查询成功: 返回 % 条结果', result_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'LIMIT查询失败: %', SQLERRM;
END $$;

-- 性能测试：使用LIMIT
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'postgresql')
ORDER BY ts_rank(tsv, to_tsquery('english', 'postgresql')) DESC
LIMIT 20;
-- 执行时间: 快（只返回前20条结果）
-- 计划: Limit -> Sort -> Bitmap Heap Scan -> Bitmap Index Scan
```

### 5.3 避免复杂查询

**查询复杂度对比（带性能测试）**:

```sql
-- ❌ 避免：过于复杂的查询表达式（性能差）
-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'a & b & c & d & e & f');
-- 执行时间: 慢（查询表达式过于复杂）
-- 计划: Bitmap Heap Scan（可能很慢）

-- ✅ 推荐：简化查询表达式（性能好）
-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'a & b & c');
-- 执行时间: 快（查询表达式简化）
-- 计划: Bitmap Heap Scan -> Bitmap Index Scan

-- 查询复杂度验证（带错误处理）
DO $$
DECLARE
    complex_count BIGINT;
    simple_count BIGINT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
        RAISE EXCEPTION '表不存在: articles';
    END IF;

    -- 复杂查询（不推荐）
    BEGIN
        SELECT COUNT(*) INTO complex_count
        FROM articles
        WHERE tsv @@ to_tsquery('english', 'a & b & c & d & e & f');
        RAISE NOTICE '复杂查询结果数: %', complex_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '复杂查询失败: %', SQLERRM;
            complex_count := NULL;
    END;

    -- 简单查询（推荐）
    BEGIN
        SELECT COUNT(*) INTO simple_count
        FROM articles
        WHERE tsv @@ to_tsquery('english', 'a & b & c');
        RAISE NOTICE '简单查询结果数: %', simple_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '简单查询失败: %', SQLERRM;
            simple_count := NULL;
    END;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '表不存在: articles';
    WHEN OTHERS THEN
        RAISE EXCEPTION '查询复杂度验证失败: %', SQLERRM;
END $$;
```

---

## 6. 最佳实践

### ✅ 推荐做法

1. **使用GIN索引** - 大多数场景下性能最好
2. **预计算tsvector** - 避免查询时计算
3. **合理使用fastupdate** - 根据更新频率选择
4. **定期维护索引** - VACUUM和REINDEX
5. **使用分区表** - 对于大表考虑分区

### ❌ 避免做法

1. **查询时计算tsvector** - 性能差
2. **忽略索引维护** - 索引膨胀影响性能
3. **过度复杂的查询** - 影响查询性能
4. **不使用LIMIT** - 返回过多结果影响性能

---

## 📚 相关文档

- [PostgreSQL18-全文搜索深度实战.md](./PostgreSQL18-全文搜索深度实战.md) - 全文搜索完整指南
- [02-查询与优化/02.06-性能调优/](../02.06-性能调优/README.md) - 性能调优指南

---

**最后更新**: 2025年1月
