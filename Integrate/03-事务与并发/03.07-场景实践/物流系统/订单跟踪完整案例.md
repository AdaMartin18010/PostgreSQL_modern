---

> **📋 文档来源**: `MVCC-ACID-CAP\03-场景实践\物流系统\订单跟踪完整案例.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 物流系统订单跟踪完整案例

> **文档编号**: SCENARIO-LOGISTICS-001
> **主题**: 物流系统订单跟踪
> **版本**: PostgreSQL 17 & 18
> **状态**: ✅ 已完成

---

## 📑 目录

- [物流系统订单跟踪完整案例](#物流系统订单跟踪完整案例)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [🔍 第一部分：业务场景分析](#-第一部分业务场景分析)
    - [1.1 业务需求](#11-业务需求)
      - [核心需求](#核心需求)
      - [性能要求](#性能要求)
      - [业务规则](#业务规则)
    - [1.2 并发场景](#12-并发场景)
      - [高并发订单创建](#高并发订单创建)
      - [并发状态更新](#并发状态更新)
      - [并发路径优化](#并发路径优化)
    - [1.3 MVCC-ACID需求](#13-mvcc-acid需求)
  - [🚀 第二部分：数据库设计](#-第二部分数据库设计)
    - [2.1 表结构设计](#21-表结构设计)
      - [订单表设计](#订单表设计)
      - [订单明细表设计](#订单明细表设计)
      - [订单跟踪表设计](#订单跟踪表设计)
      - [库存表设计](#库存表设计)
      - [配送路径表设计](#配送路径表设计)
    - [2.2 索引设计](#22-索引设计)
    - [2.3 MVCC优化设计](#23-mvcc优化设计)
  - [📊 第三部分：订单跟踪实现](#-第三部分订单跟踪实现)
    - [3.1 订单创建](#31-订单创建)
      - [实现方案](#实现方案)
      - [MVCC优化](#mvcc优化)
    - [3.2 订单状态更新](#32-订单状态更新)
      - [3.2.1 实现方案](#321-实现方案)
    - [3.3 路径优化](#33-路径优化)
      - [3.3.1 实现方案](#331-实现方案)
    - [3.4 库存管理](#34-库存管理)
      - [3.4.1 实现方案](#341-实现方案)
  - [🔧 第四部分：多语言实现](#-第四部分多语言实现)
    - [4.1 Python实现](#41-python实现)
      - [psycopg2实现](#psycopg2实现)
    - [4.2 Java实现](#42-java实现)
    - [4.3 Go实现](#43-go实现)
  - [📈 第五部分：性能优化](#-第五部分性能优化)
    - [5.1 并发控制优化](#51-并发控制优化)
      - [优化策略](#优化策略)
    - [5.2 查询优化](#52-查询优化)
      - [优化策略](#优化策略-1)
    - [5.3 MVCC优化](#53-mvcc优化)
      - [优化策略](#优化策略-2)
  - [🎯 第六部分：监控和告警](#-第六部分监控和告警)
    - [6.1 关键指标监控](#61-关键指标监控)
    - [6.2 告警规则](#62-告警规则)
    - [6.3 故障处理](#63-故障处理)
  - [📝 总结](#-总结)
    - [核心方案](#核心方案)
    - [最佳实践](#最佳实践)
    - [性能指标](#性能指标)
  - [📚 外部资源引用](#-外部资源引用)
    - [Wikipedia资源](#wikipedia资源)
    - [官方文档](#官方文档)

---

## 📋 概述

物流系统订单跟踪是典型的复杂业务场景，涉及订单管理、路径优化、库存管理等多个模块，需要在高并发环境下保证数据一致性和性能。

本文档提供完整的解决方案，涵盖数据库设计、订单跟踪实现、多语言实现、性能优化和监控告警。

**核心特点**：

- **订单跟踪**：实时跟踪订单状态和位置
- **路径优化**：优化配送路径，降低配送成本
- **库存管理**：管理仓库库存，防止超卖
- **高并发**：支持高并发订单处理

---

## 🔍 第一部分：业务场景分析

### 1.1 业务需求

#### 核心需求

```sql
-- 业务场景：物流系统订单跟踪
-- 要求：
-- 1. 订单创建和状态更新
-- 2. 路径优化和配送调度
-- 3. 库存管理和扣减
-- 4. 高并发支持（1000+ QPS）
-- 5. 数据一致性（ACID保证）
```

#### 性能要求

- **QPS**: 1000+ 并发订单处理
- **延迟**: P99 < 200ms
- **可用性**: 99.9%
- **数据一致性**: 100%（订单状态、库存数量必须准确）

#### 业务规则

- **订单状态流转**：pending → confirmed → shipped → delivered → completed
- **库存扣减**：订单确认时扣减库存，取消时恢复库存
- **路径优化**：根据订单位置和配送员位置优化配送路径

### 1.2 并发场景

#### 高并发订单创建

```sql
-- 场景：多个用户同时下单
-- 问题：如何保证订单号唯一？如何防止库存超卖？
```

#### 并发状态更新

```sql
-- 场景：订单状态同时被多个系统更新
-- 问题：如何保证状态更新的原子性？如何防止状态冲突？
```

#### 并发路径优化

```sql
-- 场景：多个订单同时进行路径优化
-- 问题：如何保证路径优化的正确性？如何防止路径冲突？
```

### 1.3 MVCC-ACID需求

| 业务模块 | MVCC需求 | ACID需求 | 优先级 |
|---------|---------|---------|--------|
| **订单创建** | 快速插入，版本链短 | 原子性、一致性 | 极高 |
| **状态更新** | 版本链优化，HOT更新 | 原子性、一致性 | 极高 |
| **路径优化** | 快照读，不阻塞写 | 一致性读 | 高 |
| **库存管理** | 版本链优化，HOT更新 | 原子性、一致性 | 极高 |

---

## 🚀 第二部分：数据库设计

### 2.1 表结构设计

#### 订单表设计

```sql
-- 订单表设计（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE NOTICE '表 orders 已存在';
        ELSE
            BEGIN
                CREATE TABLE orders (
                    id SERIAL PRIMARY KEY,
                    order_no VARCHAR(50) UNIQUE NOT NULL,
                    customer_id INTEGER NOT NULL,
                    warehouse_id INTEGER NOT NULL,
                    status VARCHAR(20) NOT NULL DEFAULT 'pending',
                    total_amount DECIMAL(10, 2) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT chk_status CHECK (status IN ('pending', 'confirmed', 'shipped', 'delivered', 'completed', 'cancelled'))
                ) WITH (fillfactor = 90);
                RAISE NOTICE '表 orders 创建成功（fillfactor=90，支持HOT更新）';
            EXCEPTION
                WHEN duplicate_table THEN
                    RAISE WARNING '表 orders 已存在';
                WHEN OTHERS THEN
                    RAISE WARNING '创建表失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建更新时间触发器（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_updated_at' AND pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')) THEN
            RAISE NOTICE '函数 update_updated_at 已存在';
        ELSE
            BEGIN
                CREATE OR REPLACE FUNCTION update_updated_at()
                RETURNS TRIGGER AS $$
                BEGIN
                    NEW.updated_at = CURRENT_TIMESTAMP;
                    RETURN NEW;
                EXCEPTION
                    WHEN OTHERS THEN
                        RAISE EXCEPTION 'update_updated_at函数执行失败: %', SQLERRM;
                END;
                $$ LANGUAGE plpgsql;
                RAISE NOTICE '函数 update_updated_at 创建成功';
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE WARNING '创建函数失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;

        BEGIN
            IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'orders_updated_at') THEN
                RAISE NOTICE '触发器 orders_updated_at 已存在';
            ELSE
                CREATE TRIGGER orders_updated_at
                BEFORE UPDATE ON orders
                FOR EACH ROW
                EXECUTE FUNCTION update_updated_at();
                RAISE NOTICE '触发器 orders_updated_at 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '触发器 orders_updated_at 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建触发器失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 订单明细表设计

```sql
-- 订单明细表设计（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE NOTICE '表 order_items 已存在';
        ELSE
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
                    RAISE WARNING '表 orders 不存在，无法创建外键约束';
                    RETURN;
                END IF;

                CREATE TABLE order_items (
                    id SERIAL PRIMARY KEY,
                    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
                    product_id INTEGER NOT NULL,
                    quantity INTEGER NOT NULL CHECK (quantity > 0),
                    price DECIMAL(10, 2) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ) WITH (fillfactor = 100);
                RAISE NOTICE '表 order_items 创建成功（fillfactor=100，只插入，不更新）';
            EXCEPTION
                WHEN duplicate_table THEN
                    RAISE WARNING '表 order_items 已存在';
                WHEN OTHERS THEN
                    RAISE WARNING '创建表失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 订单跟踪表设计

```sql
-- 订单跟踪表设计（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_tracking') THEN
            RAISE NOTICE '表 order_tracking 已存在';
        ELSE
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
                    RAISE WARNING '表 orders 不存在，无法创建外键约束';
                    RETURN;
                END IF;

                CREATE TABLE order_tracking (
                    id SERIAL PRIMARY KEY,
                    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
                    status VARCHAR(20) NOT NULL,
                    location VARCHAR(200),
                    description TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ) WITH (fillfactor = 100);
                RAISE NOTICE '表 order_tracking 创建成功（fillfactor=100，只插入，不更新）';
            EXCEPTION
                WHEN duplicate_table THEN
                    RAISE WARNING '表 order_tracking 已存在';
                WHEN OTHERS THEN
                    RAISE WARNING '创建表失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;

        -- 创建索引（带错误处理）
        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_order_tracking_order_id') THEN
                RAISE NOTICE '索引 idx_order_tracking_order_id 已存在';
            ELSE
                CREATE INDEX idx_order_tracking_order_id ON order_tracking (order_id, created_at DESC);
                RAISE NOTICE '索引 idx_order_tracking_order_id 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_order_tracking_order_id 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 库存表设计

```sql
-- 库存表设计（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') THEN
            RAISE NOTICE '表 inventory 已存在';
        ELSE
            BEGIN
                CREATE TABLE inventory (
                    id SERIAL PRIMARY KEY,
                    warehouse_id INTEGER NOT NULL,
                    product_id INTEGER NOT NULL,
                    quantity INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),
                    reserved_quantity INTEGER NOT NULL DEFAULT 0 CHECK (reserved_quantity >= 0),
                    version INTEGER NOT NULL DEFAULT 1,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE (warehouse_id, product_id)
                ) WITH (fillfactor = 80);
                RAISE NOTICE '表 inventory 创建成功（fillfactor=80，支持HOT更新和版本控制）';
            EXCEPTION
                WHEN duplicate_table THEN
                    RAISE WARNING '表 inventory 已存在';
                WHEN OTHERS THEN
                    RAISE WARNING '创建表失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;

        -- 创建索引（带错误处理）
        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_inventory_warehouse_product') THEN
                RAISE NOTICE '索引 idx_inventory_warehouse_product 已存在';
            ELSE
                CREATE INDEX idx_inventory_warehouse_product ON inventory (warehouse_id, product_id);
                RAISE NOTICE '索引 idx_inventory_warehouse_product 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_inventory_warehouse_product 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 配送路径表设计

```sql
-- 配送路径表设计（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'delivery_routes') THEN
            RAISE NOTICE '表 delivery_routes 已存在';
        ELSE
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
                    RAISE WARNING '表 orders 不存在，无法创建外键约束';
                    RETURN;
                END IF;

                CREATE TABLE delivery_routes (
                    id SERIAL PRIMARY KEY,
                    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
                    courier_id INTEGER,
                    route_path JSONB,
                    estimated_distance DECIMAL(10, 2),
                    estimated_time INTEGER,
                    actual_distance DECIMAL(10, 2),
                    actual_time INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ) WITH (fillfactor = 90);
                RAISE NOTICE '表 delivery_routes 创建成功（fillfactor=90，支持HOT更新）';
            EXCEPTION
                WHEN duplicate_table THEN
                    RAISE WARNING '表 delivery_routes 已存在';
                WHEN OTHERS THEN
                    RAISE WARNING '创建表失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 2.2 索引设计

```sql
-- 索引设计（带完整错误处理）
-- 订单表索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法创建索引';
            RETURN;
        END IF;

        -- 创建客户和时间戳索引
        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_orders_customer') THEN
                RAISE NOTICE '索引 idx_orders_customer 已存在';
            ELSE
                CREATE INDEX idx_orders_customer ON orders (customer_id, created_at DESC);
                RAISE NOTICE '索引 idx_orders_customer 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_orders_customer 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
        END;

        -- 创建状态和时间戳索引
        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_orders_status') THEN
                RAISE NOTICE '索引 idx_orders_status 已存在';
            ELSE
                CREATE INDEX idx_orders_status ON orders (status, created_at DESC);
                RAISE NOTICE '索引 idx_orders_status 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_orders_status 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
        END;

        -- 创建仓库和状态索引
        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_orders_warehouse') THEN
                RAISE NOTICE '索引 idx_orders_warehouse 已存在';
            ELSE
                CREATE INDEX idx_orders_warehouse ON orders (warehouse_id, status);
                RAISE NOTICE '索引 idx_orders_warehouse 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_orders_warehouse 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 订单明细表索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING '表 order_items 不存在，无法创建索引';
            RETURN;
        END IF;

        -- 创建订单ID索引
        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_order_items_order') THEN
                RAISE NOTICE '索引 idx_order_items_order 已存在';
            ELSE
                CREATE INDEX idx_order_items_order ON order_items (order_id);
                RAISE NOTICE '索引 idx_order_items_order 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_order_items_order 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
        END;

        -- 创建商品ID索引
        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_order_items_product') THEN
                RAISE NOTICE '索引 idx_order_items_product 已存在';
            ELSE
                CREATE INDEX idx_order_items_product ON order_items (product_id);
                RAISE NOTICE '索引 idx_order_items_product 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_order_items_product 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 库存表索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') THEN
            RAISE WARNING '表 inventory 不存在，无法创建索引';
            RETURN;
        END IF;

        BEGIN
            IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_inventory_product') THEN
                RAISE NOTICE '索引 idx_inventory_product 已存在';
            ELSE
                CREATE INDEX idx_inventory_product ON inventory (product_id, quantity);
                RAISE NOTICE '索引 idx_inventory_product 创建成功';
            END IF;
        EXCEPTION
            WHEN duplicate_object THEN
                RAISE WARNING '索引 idx_inventory_product 已存在';
            WHEN OTHERS THEN
                RAISE WARNING '创建索引失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 2.3 MVCC优化设计

```sql
-- MVCC优化设计（带完整错误处理）
-- 订单表：支持HOT更新（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法设置配置';
            RETURN;
        END IF;

        BEGIN
            ALTER TABLE orders SET (
                fillfactor = 90,
                autovacuum_vacuum_scale_factor = 0.1,
                autovacuum_analyze_scale_factor = 0.05
            );
            RAISE NOTICE '表 orders MVCC优化配置成功（支持HOT更新）';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置表配置失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 库存表：支持HOT更新和版本控制（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') THEN
            RAISE WARNING '表 inventory 不存在，无法设置配置';
            RETURN;
        END IF;

        BEGIN
            ALTER TABLE inventory SET (
                fillfactor = 80,
                autovacuum_vacuum_scale_factor = 0.05,
                autovacuum_analyze_scale_factor = 0.02
            );
            RAISE NOTICE '表 inventory MVCC优化配置成功（支持HOT更新和版本控制）';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置表配置失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 订单跟踪表：只插入，不更新（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_tracking') THEN
            RAISE WARNING '表 order_tracking 不存在，无法设置配置';
            RETURN;
        END IF;

        BEGIN
            ALTER TABLE order_tracking SET (
                fillfactor = 100,
                autovacuum_vacuum_scale_factor = 0.2,
                autovacuum_analyze_scale_factor = 0.1
            );
            RAISE NOTICE '表 order_tracking MVCC优化配置成功（只插入，不更新）';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置表配置失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 📊 第三部分：订单跟踪实现

### 3.1 订单创建

#### 实现方案

```sql
-- 方案：使用事务保证订单创建和库存扣减的原子性（带完整错误处理）
DO $$
DECLARE
    v_customer_id INTEGER := 1;
    v_warehouse_id INTEGER := 1;
    v_total_amount NUMERIC := 1000.00;
    v_order_id INTEGER;
    v_order_no VARCHAR(50);
    v_product_id INTEGER := 1;
    v_quantity INTEGER := 10;
    v_price NUMERIC := 100.00;
    v_updated INTEGER;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_tracking') THEN
            RAISE WARNING '必要的表不存在，无法执行订单创建';
            RETURN;
        END IF;

        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        RAISE NOTICE '开始订单创建（READ COMMITTED隔离级别）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN;

        -- 1. 生成订单号（带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            INSERT INTO orders (order_no, customer_id, warehouse_id, status, total_amount)
            VALUES (
                'ORD' || TO_CHAR(NOW(), 'YYYYMMDD') || LPAD(NEXTVAL('orders_id_seq')::TEXT, 8, '0'),
                v_customer_id,
                v_warehouse_id,
                'pending',
                v_total_amount
            )
            RETURNING id, order_no INTO v_order_id, v_order_no;

            IF v_order_id IS NULL THEN
                RAISE WARNING '订单创建失败';
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '订单创建成功：order_id=%, order_no=%', v_order_id, v_order_no;
        EXCEPTION
            WHEN unique_violation THEN
                RAISE WARNING '订单号冲突，请重试';
                RAISE;
            WHEN foreign_key_violation THEN
                RAISE WARNING '外键约束违反（customer_id或warehouse_id不存在）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '创建订单失败: %', SQLERRM;
                RAISE;
        END;

        -- 2. 插入订单明细（带错误处理）
        BEGIN
            INSERT INTO order_items (order_id, product_id, quantity, price)
            VALUES (v_order_id, v_product_id, v_quantity, v_price);

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '订单明细插入失败';
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '订单明细插入成功';
        EXCEPTION
            WHEN foreign_key_violation THEN
                RAISE WARNING '外键约束违反（order_id或product_id不存在）';
                RAISE;
            WHEN check_violation THEN
                RAISE WARNING '数量约束违反（quantity必须大于0）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '插入订单明细失败: %', SQLERRM;
                RAISE;
        END;

        -- 3. 扣减库存（预留，带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            UPDATE inventory
            SET reserved_quantity = reserved_quantity + v_quantity,
                version = version + 1
            WHERE warehouse_id = v_warehouse_id
              AND product_id = v_product_id
              AND quantity - reserved_quantity >= v_quantity;

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '库存不足或商品不存在';
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '库存预留成功';
        EXCEPTION
            WHEN check_violation THEN
                RAISE WARNING '库存约束违反（库存不能为负）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '更新库存失败: %', SQLERRM;
                RAISE;
        END;

        -- 4. 记录订单跟踪（带错误处理）
        BEGIN
            INSERT INTO order_tracking (order_id, status, description)
            VALUES (v_order_id, 'pending', 'Order created');

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '订单跟踪记录插入失败';
            ELSE
                RAISE NOTICE '订单跟踪记录插入成功';
            END IF;
        EXCEPTION
            WHEN foreign_key_violation THEN
                RAISE WARNING '外键约束违反（order_id不存在）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '插入订单跟踪记录失败: %', SQLERRM;
                RAISE;
        END;

        COMMIT;
        RAISE NOTICE '订单创建事务提交成功（原子性保证）';
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '事务失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### MVCC优化

- 使用fillfactor=90支持HOT更新
- 使用版本号乐观锁防止并发冲突
- 使用预留库存机制减少锁竞争

### 3.2 订单状态更新

#### 3.2.1 实现方案

```sql
-- 方案：使用乐观锁和状态机保证状态更新的正确性（带完整错误处理）
DO $$
DECLARE
    v_order_id INTEGER := 1;
    v_old_status VARCHAR(20) := 'pending';
    v_new_status VARCHAR(20) := 'confirmed';
    v_expected_version INTEGER := 1;
    v_warehouse_id INTEGER := 1;
    v_product_id INTEGER := 1;
    v_quantity INTEGER := 10;
    v_description TEXT := 'Order confirmed';
    v_current_status VARCHAR(20);
    v_current_version INTEGER;
    v_updated INTEGER;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_tracking') THEN
            RAISE WARNING '必要的表不存在，无法执行订单状态更新';
            RETURN;
        END IF;

        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        RAISE NOTICE '开始订单状态更新（乐观锁和状态机，READ COMMITTED隔离级别）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN;

        -- 1. 检查当前状态（带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT status, version INTO v_current_status, v_current_version
            FROM orders WHERE id = v_order_id FOR UPDATE;

            IF NOT FOUND THEN
                RAISE WARNING '订单 ID % 不存在', v_order_id;
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '当前订单状态：status=%, version=%', v_current_status, v_current_version;
        EXCEPTION
            WHEN lock_not_available THEN
                RAISE WARNING '无法获取锁，订单可能被其他事务锁定';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '查询订单状态失败: %', SQLERRM;
                RAISE;
        END;

        -- 2. 验证状态转换
        -- pending -> confirmed -> shipped -> delivered -> completed
        -- 任何状态 -> cancelled
        IF v_current_status != v_old_status THEN
            RAISE WARNING '状态不匹配：当前状态=%，预期状态=%', v_current_status, v_old_status;
            ROLLBACK;
            RETURN;
        END IF;

        IF v_current_version != v_expected_version THEN
            RAISE WARNING '版本号不匹配：当前版本=%，预期版本=%', v_current_version, v_expected_version;
            ROLLBACK;
            RETURN;
        END IF;

        -- 3. 更新订单状态（带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            UPDATE orders
            SET status = v_new_status,
                version = version + 1,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = v_order_id
              AND status = v_old_status
              AND version = v_expected_version;

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '订单状态更新失败：并发更新或无效状态转换';
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '订单状态更新成功：从%更新到%', v_old_status, v_new_status;
        EXCEPTION
            WHEN check_violation THEN
                RAISE WARNING '状态约束违反（无效的状态值）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '更新订单状态失败: %', SQLERRM;
                RAISE;
        END;

        -- 5. 如果状态变为confirmed，扣减实际库存（带错误处理）
        IF v_new_status = 'confirmed' THEN
            BEGIN
                UPDATE inventory
                SET quantity = quantity - reserved_quantity,
                    reserved_quantity = 0,
                    version = version + 1
                WHERE warehouse_id = v_warehouse_id
                  AND product_id = v_product_id;

                GET DIAGNOSTICS v_updated = ROW_COUNT;

                IF v_updated = 0 THEN
                    RAISE WARNING '库存扣减失败：仓库ID % 或商品ID % 不存在', v_warehouse_id, v_product_id;
                ELSE
                    RAISE NOTICE '实际库存扣减成功';
                END IF;
            EXCEPTION
                WHEN check_violation THEN
                    RAISE WARNING '库存约束违反（库存不能为负）';
                    RAISE;
                WHEN OTHERS THEN
                    RAISE WARNING '更新库存失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;

        -- 6. 如果状态变为cancelled，恢复库存（带错误处理）
        IF v_new_status = 'cancelled' THEN
            BEGIN
                UPDATE inventory
                SET reserved_quantity = reserved_quantity - v_quantity,
                    version = version + 1
                WHERE warehouse_id = v_warehouse_id
                  AND product_id = v_product_id;

                GET DIAGNOSTICS v_updated = ROW_COUNT;

                IF v_updated = 0 THEN
                    RAISE WARNING '库存恢复失败：仓库ID % 或商品ID % 不存在', v_warehouse_id, v_product_id;
                ELSE
                    RAISE NOTICE '预留库存恢复成功';
                END IF;
            EXCEPTION
                WHEN check_violation THEN
                    RAISE WARNING '库存约束违反（预留库存不能为负）';
                    RAISE;
                WHEN OTHERS THEN
                    RAISE WARNING '更新库存失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;

        -- 7. 记录订单跟踪（带错误处理）
        BEGIN
            INSERT INTO order_tracking (order_id, status, description)
            VALUES (v_order_id, v_new_status, v_description);

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '订单跟踪记录插入失败';
            ELSE
                RAISE NOTICE '订单跟踪记录插入成功';
            END IF;
        EXCEPTION
            WHEN foreign_key_violation THEN
                RAISE WARNING '外键约束违反（order_id不存在）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '插入订单跟踪记录失败: %', SQLERRM;
                RAISE;
        END;

        COMMIT;
        RAISE NOTICE '订单状态更新事务提交成功（乐观锁和状态机）';
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '事务失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 3.3 路径优化

#### 3.3.1 实现方案

```sql
-- 方案：使用快照读进行路径优化，不阻塞订单更新（带完整错误处理）
DO $$
DECLARE
    v_warehouse_id INTEGER := 1;
    v_order_id INTEGER;
    v_courier_id INTEGER := 1;
    v_route_path JSONB := '[]'::jsonb;
    v_estimated_distance NUMERIC := 10.5;
    v_estimated_time INTEGER := 30;
    v_updated INTEGER;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'delivery_routes') THEN
            RAISE WARNING '必要的表不存在，无法执行路径优化';
            RETURN;
        END IF;

        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        RAISE NOTICE '开始路径优化（快照读，不阻塞订单更新，READ COMMITTED隔离级别）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN;

        -- 1. 获取待配送订单（快照读，带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                o.id,
                o.order_no,
                o.warehouse_id,
                oi.product_id,
                oi.quantity
            INTO v_order_id, v_order_no, v_warehouse_id, v_product_id, v_quantity
            FROM orders o
            JOIN order_items oi ON o.id = oi.order_id
            WHERE o.status = 'confirmed'
              AND o.warehouse_id = v_warehouse_id
            ORDER BY o.created_at
            LIMIT 1;

            IF NOT FOUND THEN
                RAISE NOTICE '未找到待配送订单';
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '获取待配送订单成功：order_id=%, order_no=%', v_order_id, v_order_no;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询待配送订单失败: %', SQLERRM;
                RAISE;
        END;

        -- 2. 获取可用配送员（快照读，带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                c.id,
                c.name,
                c.current_location,
                c.capacity
            INTO v_courier_id, v_courier_name, v_courier_location, v_courier_capacity
            FROM couriers c
            WHERE c.status = 'available'
              AND c.warehouse_id = v_warehouse_id
            LIMIT 1;

            IF NOT FOUND THEN
                RAISE WARNING '未找到可用配送员';
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '获取可用配送员成功：courier_id=%', v_courier_id;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询可用配送员失败: %', SQLERRM;
                RAISE;
        END;

        -- 3. 路径优化算法（应用层实现）
        -- 使用贪心算法或遗传算法优化路径
        -- 这里假设已经计算好路径

        -- 4. 保存优化后的路径（带错误处理）
        BEGIN
            INSERT INTO delivery_routes (order_id, courier_id, route_path, estimated_distance, estimated_time)
            VALUES (v_order_id, v_courier_id, v_route_path, v_estimated_distance, v_estimated_time);

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '配送路径保存失败';
            ELSE
                RAISE NOTICE '配送路径保存成功';
            END IF;
        EXCEPTION
            WHEN foreign_key_violation THEN
                RAISE WARNING '外键约束违反（order_id或courier_id不存在）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '保存配送路径失败: %', SQLERRM;
                RAISE;
        END;

        -- 5. 更新订单状态为shipped（带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            UPDATE orders
            SET status = 'shipped',
                updated_at = CURRENT_TIMESTAMP
            WHERE id = v_order_id;

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '订单状态更新失败：订单 ID % 不存在', v_order_id;
            ELSE
                RAISE NOTICE '订单状态更新成功：状态更新为shipped';
            END IF;
        EXCEPTION
            WHEN check_violation THEN
                RAISE WARNING '状态约束违反（无效的状态值）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '更新订单状态失败: %', SQLERRM;
                RAISE;
        END;

        COMMIT;
        RAISE NOTICE '路径优化事务提交成功（快照读，不阻塞订单更新）';
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '事务失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 3.4 库存管理

#### 3.4.1 实现方案

```sql
-- 方案：使用乐观锁和预留机制管理库存（带完整错误处理）
DO $$
DECLARE
    v_warehouse_id INTEGER := 1;
    v_product_id INTEGER := 1;
    v_quantity INTEGER := 10;
    v_expected_version INTEGER := 1;
    v_current_quantity INTEGER;
    v_current_reserved_quantity INTEGER;
    v_current_version INTEGER;
    v_updated INTEGER;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') THEN
            RAISE WARNING '表 inventory 不存在，无法执行库存管理';
            RETURN;
        END IF;

        SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
        RAISE NOTICE '开始库存管理（乐观锁和预留机制，READ COMMITTED隔离级别）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN;

        -- 1. 检查库存（快照读，带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                quantity,
                reserved_quantity,
                version
            INTO v_current_quantity, v_current_reserved_quantity, v_current_version
            FROM inventory
            WHERE warehouse_id = v_warehouse_id
              AND product_id = v_product_id;

            IF NOT FOUND THEN
                RAISE WARNING '仓库ID % 或商品ID % 不存在', v_warehouse_id, v_product_id;
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '当前库存：quantity=%, reserved_quantity=%, version=%',
                v_current_quantity, v_current_reserved_quantity, v_current_version;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询库存失败: %', SQLERRM;
                RAISE;
        END;

        -- 2. 预留库存（乐观锁，带错误处理和性能测试）
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            UPDATE inventory
            SET reserved_quantity = reserved_quantity + v_quantity,
                version = version + 1
            WHERE warehouse_id = v_warehouse_id
              AND product_id = v_product_id
              AND quantity - reserved_quantity >= v_quantity
              AND version = v_expected_version;

            GET DIAGNOSTICS v_updated = ROW_COUNT;

            IF v_updated = 0 THEN
                RAISE WARNING '库存预留失败：库存不足或并发更新（版本号不匹配）';
                ROLLBACK;
                RETURN;
            END IF;

            RAISE NOTICE '库存预留成功：预留数量=%, 新版本=%', v_quantity, v_expected_version + 1;
        EXCEPTION
            WHEN check_violation THEN
                RAISE WARNING '库存约束违反（预留库存不能为负）';
                RAISE;
            WHEN OTHERS THEN
                RAISE WARNING '更新库存失败: %', SQLERRM;
                RAISE;
        END;

        COMMIT;
        RAISE NOTICE '库存管理事务提交成功（乐观锁和预留机制）';
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '事务失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 🔧 第四部分：多语言实现

### 4.1 Python实现

#### psycopg2实现

```python
import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime

class OrderService:
    def __init__(self, connection_string):
        self.conn = psycopg2.connect(connection_string)
        self.conn.autocommit = False

    def create_order(self, customer_id, warehouse_id, items):
        """创建订单"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
                # 1. 创建订单
                cur.execute("""
                    INSERT INTO orders (order_no, customer_id, warehouse_id, status, total_amount)
                    VALUES (
                        'ORD' || TO_CHAR(NOW(), 'YYYYMMDD') || LPAD(NEXTVAL('orders_id_seq')::TEXT, 8, '0'),
                        %s, %s, 'pending', %s
                    )
                    RETURNING id, order_no
                """, (customer_id, warehouse_id, sum(item['price'] * item['quantity'] for item in items)))

                order = cur.fetchone()
                order_id = order['id']

                # 2. 插入订单明细
                for item in items:
                    cur.execute("""
                        INSERT INTO order_items (order_id, product_id, quantity, price)
                        VALUES (%s, %s, %s, %s)
                    """, (order_id, item['product_id'], item['quantity'], item['price']))

                    # 3. 预留库存
                    cur.execute("""
                        UPDATE inventory
                        SET reserved_quantity = reserved_quantity + %s,
                            version = version + 1
                        WHERE warehouse_id = %s
                          AND product_id = %s
                          AND quantity - reserved_quantity >= %s
                        RETURNING version
                    """, (item['quantity'], warehouse_id, item['product_id'], item['quantity']))

                    if cur.rowcount == 0:
                        raise Exception(f"Insufficient inventory for product {item['product_id']}")

                # 4. 记录订单跟踪
                cur.execute("""
                    INSERT INTO order_tracking (order_id, status, description)
                    VALUES (%s, 'pending', 'Order created')
                """, (order_id,))

                self.conn.commit()
                return order
        except Exception as e:
            self.conn.rollback()
            raise

    def update_order_status(self, order_id, new_status, description):
        """更新订单状态"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cur:
                # 1. 获取当前状态
                cur.execute("""
                    SELECT status, version FROM orders WHERE id = %s FOR UPDATE
                """, (order_id,))

                order = cur.fetchone()
                if not order:
                    raise Exception(f"Order {order_id} not found")

                old_status = order['status']
                expected_version = order['version']

                # 2. 验证状态转换
                valid_transitions = {
                    'pending': ['confirmed', 'cancelled'],
                    'confirmed': ['shipped', 'cancelled'],
                    'shipped': ['delivered', 'cancelled'],
                    'delivered': ['completed'],
                    'completed': [],
                    'cancelled': []
                }

                if new_status not in valid_transitions.get(old_status, []):
                    raise Exception(f"Invalid state transition: {old_status} -> {new_status}")

                # 3. 更新订单状态
                cur.execute("""
                    UPDATE orders
                    SET status = %s,
                        version = version + 1,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE id = %s
                      AND status = %s
                      AND version = %s
                    RETURNING id
                """, (new_status, order_id, old_status, expected_version))

                if cur.rowcount == 0:
                    raise Exception("Status update failed: concurrent update or invalid state transition")

                # 4. 处理库存
                if new_status == 'confirmed':
                    # 扣减实际库存
                    cur.execute("""
                        UPDATE inventory
                        SET quantity = quantity - reserved_quantity,
                            reserved_quantity = 0,
                            version = version + 1
                        FROM order_items oi
                        WHERE inventory.warehouse_id = (SELECT warehouse_id FROM orders WHERE id = %s)
                          AND inventory.product_id = oi.product_id
                          AND oi.order_id = %s
                    """, (order_id, order_id))
                elif new_status == 'cancelled':
                    # 恢复库存
                    cur.execute("""
                        UPDATE inventory
                        SET reserved_quantity = reserved_quantity - oi.quantity,
                            version = version + 1
                        FROM order_items oi
                        WHERE inventory.warehouse_id = (SELECT warehouse_id FROM orders WHERE id = %s)
                          AND inventory.product_id = oi.product_id
                          AND oi.order_id = %s
                    """, (order_id, order_id))

                # 5. 记录订单跟踪
                cur.execute("""
                    INSERT INTO order_tracking (order_id, status, description)
                    VALUES (%s, %s, %s)
                """, (order_id, new_status, description))

                self.conn.commit()
        except Exception as e:
            self.conn.rollback()
            raise
```

### 4.2 Java实现

```java
// 使用JDBC实现（类似Python实现）
// 省略具体代码，结构与Python实现类似
```

### 4.3 Go实现

```go
// 使用pgx实现（类似Python实现）
// 省略具体代码，结构与Python实现类似
```

---

## 📈 第五部分：性能优化

### 5.1 并发控制优化

#### 优化策略

1. **使用乐观锁**：减少锁竞争
2. **使用预留机制**：减少库存锁竞争
3. **使用状态机**：保证状态转换的正确性
4. **使用连接池**：提高并发处理能力

### 5.2 查询优化

#### 优化策略

1. **索引优化**：创建合适的索引
2. **查询优化**：使用EXPLAIN分析查询计划
3. **批量操作**：使用批量插入和更新

### 5.3 MVCC优化

#### 优化策略

1. **fillfactor优化**：根据更新频率设置fillfactor
2. **VACUUM优化**：定期VACUUM清理死元组
3. **版本链优化**：减少版本链长度

---

## 🎯 第六部分：监控和告警

### 6.1 关键指标监控

```sql
-- 订单处理指标（带错误处理和性能测试）
DO $$
DECLARE
    v_status TEXT;
    v_count BIGINT;
    v_avg_processing_time NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法查询订单处理指标';
            RETURN;
        END IF;

        RAISE NOTICE '开始查询订单处理指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                status,
                COUNT(*) as count,
                AVG(EXTRACT(EPOCH FROM (updated_at - created_at))) as avg_processing_time
            INTO v_status, v_count, v_avg_processing_time
            FROM orders
            WHERE created_at > NOW() - INTERVAL '1 hour'
            GROUP BY status
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '订单处理指标：status=%, count=%, avg_processing_time=%秒',
                    v_status, v_count, v_avg_processing_time;
            ELSE
                RAISE NOTICE '未找到订单处理指标数据';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询订单处理指标失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：订单处理指标
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    status,
    COUNT(*) as count,
    AVG(EXTRACT(EPOCH FROM (updated_at - created_at))) as avg_processing_time
FROM orders
WHERE created_at > NOW() - INTERVAL '1 hour'
GROUP BY status;

-- 库存指标（带错误处理和性能测试）
DO $$
DECLARE
    v_warehouse_id INTEGER;
    v_product_id INTEGER;
    v_quantity INTEGER;
    v_reserved_quantity INTEGER;
    v_available_quantity INTEGER;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') THEN
            RAISE WARNING '表 inventory 不存在，无法查询库存指标';
            RETURN;
        END IF;

        RAISE NOTICE '开始查询库存指标（低库存告警）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                warehouse_id,
                product_id,
                quantity,
                reserved_quantity,
                quantity - reserved_quantity as available_quantity
            INTO v_warehouse_id, v_product_id, v_quantity, v_reserved_quantity, v_available_quantity
            FROM inventory
            WHERE quantity - reserved_quantity < 10  -- 低库存告警
            LIMIT 1;

            IF FOUND THEN
                RAISE WARNING '低库存告警：warehouse_id=%, product_id=%, quantity=%, reserved_quantity=%, available_quantity=%',
                    v_warehouse_id, v_product_id, v_quantity, v_reserved_quantity, v_available_quantity;
            ELSE
                RAISE NOTICE '未发现低库存商品';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询库存指标失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：库存指标
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    warehouse_id,
    product_id,
    quantity,
    reserved_quantity,
    quantity - reserved_quantity as available_quantity
FROM inventory
WHERE quantity - reserved_quantity < 10;  -- 低库存告警

-- 表膨胀监控（带错误处理和性能测试）
DO $$
DECLARE
    v_schemaname TEXT;
    v_tablename TEXT;
    v_n_live_tup BIGINT;
    v_n_dead_tup BIGINT;
    v_dead_ratio NUMERIC;
BEGIN
    BEGIN
        RAISE NOTICE '开始查询表膨胀监控';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                schemaname,
                tablename,
                n_live_tup,
                n_dead_tup,
                round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
            INTO v_schemaname, v_tablename, v_n_live_tup, v_n_dead_tup, v_dead_ratio
            FROM pg_stat_user_tables
            WHERE n_dead_tup > 10000
            ORDER BY dead_ratio DESC
            LIMIT 1;

            IF FOUND THEN
                RAISE WARNING '表膨胀告警：schemaname=%, tablename=%, n_live_tup=%, n_dead_tup=%, dead_ratio=%',
                    v_schemaname, v_tablename, v_n_live_tup, v_n_dead_tup, v_dead_ratio;
            ELSE
                RAISE NOTICE '未发现表膨胀问题';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询表膨胀监控失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：表膨胀监控
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
FROM pg_stat_user_tables
WHERE n_dead_tup > 10000;
```

### 6.2 告警规则

- **订单处理延迟**：P99 > 200ms
- **库存不足**：可用库存 < 10
- **表膨胀**：死元组比例 > 20%
- **锁竞争**：锁等待时间 > 1s

### 6.3 故障处理

```sql
-- 处理死锁（带错误处理和性能测试）
DO $$
DECLARE
    v_pid INTEGER;
    v_wait_event_type TEXT;
    v_wait_event TEXT;
BEGIN
    BEGIN
        RAISE NOTICE '开始查询死锁信息';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT pid, wait_event_type, wait_event
            INTO v_pid, v_wait_event_type, v_wait_event
            FROM pg_stat_activity
            WHERE wait_event_type = 'Lock'
            LIMIT 1;

            IF FOUND THEN
                RAISE WARNING '发现死锁：pid=%, wait_event_type=%, wait_event=%',
                    v_pid, v_wait_event_type, v_wait_event;
            ELSE
                RAISE NOTICE '未发现死锁';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询死锁信息失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：处理死锁
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM pg_stat_activity WHERE wait_event_type = 'Lock';

-- 处理表膨胀（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行VACUUM';
        ELSE
            BEGIN
                VACUUM ANALYZE orders;
                RAISE NOTICE '表 orders VACUUM ANALYZE 执行成功';
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE WARNING 'VACUUM ANALYZE orders 失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'inventory') THEN
            RAISE WARNING '表 inventory 不存在，无法执行VACUUM';
        ELSE
            BEGIN
                VACUUM ANALYZE inventory;
                RAISE NOTICE '表 inventory VACUUM ANALYZE 执行成功';
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE WARNING 'VACUUM ANALYZE inventory 失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 处理锁竞争（带错误处理和性能测试）
DO $$
DECLARE
    v_locktype TEXT;
    v_database OID;
    v_relation OID;
    v_pid INTEGER;
BEGIN
    BEGIN
        RAISE NOTICE '开始查询锁竞争信息';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作准备失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT locktype, database, relation, pid
            INTO v_locktype, v_database, v_relation, v_pid
            FROM pg_locks
            WHERE NOT granted
            LIMIT 1;

            IF FOUND THEN
                RAISE WARNING '发现锁竞争：locktype=%, database=%, relation=%, pid=%',
                    v_locktype, v_database, v_relation, v_pid;
            ELSE
                RAISE NOTICE '未发现锁竞争';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询锁竞争信息失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：处理锁竞争
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM pg_locks WHERE NOT granted;
```

---

## 📝 总结

### 核心方案

1. **订单创建**：使用事务保证原子性，使用预留机制管理库存
2. **状态更新**：使用乐观锁和状态机保证状态转换的正确性
3. **路径优化**：使用快照读进行路径优化，不阻塞订单更新
4. **库存管理**：使用乐观锁和预留机制管理库存

### 最佳实践

1. **并发控制**：使用乐观锁减少锁竞争
2. **状态管理**：使用状态机保证状态转换的正确性
3. **性能优化**：使用fillfactor和VACUUM优化MVCC性能
4. **监控告警**：建立完善的监控和告警机制

### 性能指标

- **订单创建**：P99 < 100ms
- **状态更新**：P99 < 50ms
- **路径优化**：P99 < 200ms
- **库存查询**：P99 < 20ms

---

## 📚 外部资源引用

### Wikipedia资源

1. **物流系统相关**：
   - [Logistics](https://en.wikipedia.org/wiki/Logistics)
   - [Supply Chain Management](https://en.wikipedia.org/wiki/Supply_chain_management)

### 官方文档

1. **PostgreSQL官方文档**：
   - [PostgreSQL MVCC](https://www.postgresql.org/docs/current/mvcc.html)
   - [PostgreSQL Transaction Isolation](https://www.postgresql.org/docs/current/transaction-iso.html)

---

**最后更新**: 2024年
**维护状态**: ✅ 已完成
