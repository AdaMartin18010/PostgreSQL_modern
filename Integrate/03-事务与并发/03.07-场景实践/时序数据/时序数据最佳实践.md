---

> **📋 文档来源**: `MVCC-ACID-CAP\03-场景实践\时序数据\时序数据最佳实践.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL时序数据最佳实践

> **文档编号**: SCENARIO-TIMESERIES-BESTPRACTICES-001
> **主题**: 时序数据最佳实践
> **版本**: PostgreSQL 17 & 18

---

## 📑 目录

- [PostgreSQL时序数据最佳实践](#postgresql时序数据最佳实践)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [🔍 第一部分：设计模式](#-第一部分设计模式)
    - [1.1 表设计](#11-表设计)
    - [1.2 分区设计](#12-分区设计)
    - [1.3 索引设计](#13-索引设计)
  - [🚀 第二部分：性能优化](#-第二部分性能优化)
    - [2.1 写入优化](#21-写入优化)
    - [2.2 查询优化](#22-查询优化)
    - [2.3 维护优化](#23-维护优化)
  - [📊 第三部分：MVCC优化](#-第三部分mvcc优化)
    - [3.1 版本链优化](#31-版本链优化)
    - [3.2 VACUUM优化](#32-vacuum优化)
    - [3.3 快照优化](#33-快照优化)
  - [📝 总结](#-总结)
    - [核心原则](#核心原则)
    - [最佳实践](#最佳实践)

---

## 📋 概述

本文档总结PostgreSQL时序数据场景的最佳实践，包括设计模式、性能优化和MVCC优化，为时序数据系统设计提供完整指导。

---

## 🔍 第一部分：设计模式

### 1.1 表设计

```sql
-- 时序数据表设计最佳实践（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE NOTICE '表 metrics 已存在';
        ELSE
            CREATE TABLE metrics (
                time TIMESTAMP NOT NULL,           -- 时间戳（必需，NOT NULL）
                device_id INTEGER NOT NULL,        -- 设备ID（必需，NOT NULL）
                value DOUBLE PRECISION,            -- 值（根据需求）
                tags JSONB,                        -- 标签（可选）
                metadata JSONB                      -- 元数据（可选）
            ) PARTITION BY RANGE (time);
            RAISE NOTICE '表 metrics 创建成功（时序数据表设计最佳实践）';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 metrics 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 设计原则：
-- 1. 时间戳NOT NULL
-- 2. 列顺序优化（常用列在前）
-- 3. 使用合适的数据类型
-- 4. 避免大字段（使用TOAST）

-- MVCC影响：
-- 表设计影响存储
-- 影响TOAST使用
-- 影响查询性能
```

### 1.2 分区设计

```sql
-- 分区设计最佳实践（带错误处理）
-- 1. 时间范围分区（推荐，带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE NOTICE '表 metrics 已存在';
        ELSE
            CREATE TABLE metrics (
                time TIMESTAMP NOT NULL,
                device_id INTEGER NOT NULL,
                value DOUBLE PRECISION
            ) PARTITION BY RANGE (time);
            RAISE NOTICE '表 metrics 创建成功（时间范围分区）';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 metrics 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 月分区（推荐粒度，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法创建分区';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE schemaname = 'public' AND tablename = 'metrics_2024_01') THEN
            CREATE TABLE metrics_2024_01 PARTITION OF metrics
            FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
            RAISE NOTICE '月分区 metrics_2024_01 创建成功';
        ELSE
            RAISE NOTICE '月分区 metrics_2024_01 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '分区已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 自动分区管理
-- 使用pg_partman或自定义脚本

-- MVCC影响：
-- 分区设计减少单分区数据量
-- 提高VACUUM效率
-- 提高查询性能
```

### 1.3 索引设计

```sql
-- 索引设计最佳实践（带错误处理）
-- 1. 时间索引（必需，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法创建时间索引';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'metrics' AND indexname = 'idx_metrics_time') THEN
            CREATE INDEX idx_metrics_time ON metrics (time);
            RAISE NOTICE '时间索引 idx_metrics_time 创建成功';
        ELSE
            RAISE NOTICE '时间索引 idx_metrics_time 已存在';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 metrics 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_metrics_time 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 复合索引（根据查询模式，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法创建复合索引';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'metrics' AND indexname = 'idx_metrics_device_time') THEN
            CREATE INDEX idx_metrics_device_time ON metrics (device_id, time DESC);
            RAISE NOTICE '复合索引 idx_metrics_device_time 创建成功';
        ELSE
            RAISE NOTICE '复合索引 idx_metrics_device_time 已存在';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 metrics 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_metrics_device_time 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 部分索引（优化热点数据，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法创建部分索引';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND tablename = 'metrics' AND indexname = 'idx_metrics_recent') THEN
            CREATE INDEX idx_metrics_recent ON metrics (time)
            WHERE time > NOW() - INTERVAL '7 days';
            RAISE NOTICE '部分索引 idx_metrics_recent 创建成功（仅索引最近7天的数据）';
        ELSE
            RAISE NOTICE '部分索引 idx_metrics_recent 已存在';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 metrics 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_metrics_recent 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建部分索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- MVCC影响：
-- 索引设计影响写入性能
-- 影响查询性能
-- 需要平衡
```

---

## 🚀 第二部分：性能优化

### 2.1 写入优化

```sql
-- 写入优化最佳实践（带错误处理和性能测试）
-- 1. 批量INSERT（推荐，带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行批量INSERT';
            RETURN;
        END IF;
        RAISE NOTICE '开始批量INSERT测试';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '批量INSERT准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
INSERT INTO metrics (time, device_id, value)
VALUES
    (NOW(), 1, 100.0),
    (NOW(), 2, 200.0),
    (NOW(), 3, 300.0);

-- 2. COPY（最高性能，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行COPY';
            RETURN;
        END IF;
        RAISE NOTICE 'COPY命令需要从STDIN或文件读取数据';
        RAISE NOTICE '示例: COPY metrics (time, device_id, value) FROM STDIN;';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'COPY准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- COPY metrics (time, device_id, value) FROM STDIN;
-- 2024-01-01 00:00:00,1,100.0
-- 2024-01-01 00:00:01,2,200.0
-- \.

-- 3. fillfactor优化（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法设置fillfactor';
        ELSE
            ALTER TABLE metrics SET (fillfactor = 90);
            RAISE NOTICE '表 metrics 的fillfactor设置为 90';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 metrics 不存在';
        WHEN OTHERS THEN
            RAISE WARNING '设置fillfactor失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- MVCC影响：
-- 批量写入减少事务开销
-- fillfactor提高HOT更新率
-- 提高写入性能
```

### 2.2 查询优化

```sql
-- 查询优化最佳实践（带错误处理和性能测试）
-- 1. 时间范围查询（利用分区裁剪，带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行时间范围查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始时间范围查询（利用分区裁剪）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM metrics
WHERE time BETWEEN '2024-01-01' AND '2024-01-02';

-- 2. 使用索引（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行索引查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始使用索引查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM metrics
WHERE device_id = 1
AND time BETWEEN '2024-01-01' AND '2024-01-02';

-- 3. 避免SELECT *（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始查询（避免SELECT *）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT time, device_id, value FROM metrics
WHERE time BETWEEN '2024-01-01' AND '2024-01-02';

-- MVCC影响：
-- 查询优化减少扫描数据量
-- 减少MVCC开销
-- 提高查询性能
```

### 2.3 维护优化

```sql
-- 维护优化最佳实践（带错误处理）
-- 1. 定期VACUUM（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行VACUUM';
            RETURN;
        END IF;
        RAISE NOTICE '开始对表 metrics 执行VACUUM ANALYZE';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'VACUUM准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

VACUUM ANALYZE metrics;

-- 2. 分区级VACUUM（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics_2024_01') THEN
            RAISE WARNING '分区 metrics_2024_01 不存在，无法执行VACUUM';
            RETURN;
        END IF;
        RAISE NOTICE '开始对分区 metrics_2024_01 执行VACUUM ANALYZE';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'VACUUM准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

VACUUM ANALYZE metrics_2024_01;

-- 3. 自动归档（带错误处理）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '自动归档：归档3个月前的数据';
        RAISE NOTICE '需要实现归档函数或使用外部脚本';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '归档准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- MVCC影响：
-- 维护优化减少数据量
-- 提高VACUUM效率
-- 提高性能
```

---

## 📊 第三部分：MVCC优化

### 3.1 版本链优化

```sql
-- 版本链优化最佳实践（带错误处理和性能测试）
-- 1. 减少UPDATE/DELETE（带错误处理）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '时序数据很少UPDATE/DELETE';
        RAISE NOTICE '使用归档代替DELETE';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. HOT更新优化（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法设置fillfactor';
        ELSE
            ALTER TABLE metrics SET (fillfactor = 90);
            RAISE NOTICE '表 metrics 的fillfactor设置为 90（HOT更新优化）';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 metrics 不存在';
        WHEN OTHERS THEN
            RAISE WARNING '设置fillfactor失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 监控版本链长度（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始监控版本链长度';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
FROM pg_stat_user_tables
WHERE relname LIKE 'metrics_%';

-- MVCC影响：
-- 版本链优化减少版本链长度
-- 提高VACUUM效率
-- 提高查询性能
```

### 3.2 VACUUM优化

```sql
-- VACUUM优化最佳实践（带错误处理）
-- 1. 分区级VACUUM（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics_2024_01') THEN
            RAISE WARNING '分区 metrics_2024_01 不存在，无法执行VACUUM';
            RETURN;
        END IF;
        RAISE NOTICE '开始对分区 metrics_2024_01 执行VACUUM ANALYZE';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'VACUUM准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

VACUUM ANALYZE metrics_2024_01;

-- 2. 自动VACUUM配置（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics_2024_01') THEN
            RAISE WARNING '分区 metrics_2024_01 不存在，无法配置VACUUM';
        ELSE
            ALTER TABLE metrics_2024_01 SET (
                autovacuum_vacuum_scale_factor = 0.05,
                autovacuum_analyze_scale_factor = 0.02
            );
            RAISE NOTICE '分区 metrics_2024_01 的自动VACUUM配置完成';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '分区 metrics_2024_01 不存在';
        WHEN OTHERS THEN
            RAISE WARNING '配置VACUUM失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 定期归档（带错误处理）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '定期归档：归档旧数据，减少VACUUM需求';
        RAISE NOTICE '需要实现归档函数或使用外部脚本';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '归档准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- MVCC影响：
-- VACUUM优化减少死亡元组
-- 提高VACUUM效率
-- 提高性能
```

### 3.3 快照优化

```text
快照优化最佳实践：

1. 减少事务长度：
   - 短事务
   - 快速提交
   - 减少快照开销

2. 减少活跃事务数：
   - 连接池
   - 事务管理
   - 减少快照开销

3. MVCC影响：
   - 快照优化减少快照开销
   - 提高查询性能
   - 性能提升
```

---

## 📝 总结

### 核心原则

1. **设计模式**: 表设计、分区设计、索引设计
2. **性能优化**: 写入优化、查询优化、维护优化
3. **MVCC优化**: 版本链优化、VACUUM优化、快照优化

### 最佳实践

1. **表设计**: 时间戳NOT NULL、列顺序优化、合适的数据类型
2. **分区设计**: 时间范围分区、月分区、自动分区管理
3. **索引设计**: 时间索引、复合索引、部分索引
4. **写入优化**: 批量INSERT、COPY、fillfactor优化
5. **查询优化**: 时间范围查询、使用索引、避免SELECT *
6. **维护优化**: 定期VACUUM、分区级VACUUM、自动归档
7. **MVCC优化**: 版本链优化、VACUUM优化、快照优化

时序数据最佳实践通过合理的设计和优化，可以在保证数据一致性的同时获得优异的性能，是时序数据场景的核心指导原则。
