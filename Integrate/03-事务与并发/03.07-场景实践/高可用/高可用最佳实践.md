---

> **📋 文档来源**: `MVCC-ACID-CAP\03-场景实践\高可用\高可用最佳实践.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL高可用最佳实践

> **文档编号**: SCENARIO-HA-BESTPRACTICES-001
> **主题**: 高可用最佳实践
> **版本**: PostgreSQL 17 & 18

---

## 📑 目录

- [PostgreSQL高可用最佳实践](#postgresql高可用最佳实践)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [🔍 第一部分：架构设计](#-第一部分架构设计)
    - [1.1 主从架构](#11-主从架构)
      - [流复制架构](#流复制架构)
      - [逻辑复制架构](#逻辑复制架构)
      - [混合架构](#混合架构)
    - [1.2 多节点架构](#12-多节点架构)
      - [一主多从](#一主多从)
      - [级联复制](#级联复制)
      - [多主架构](#多主架构)
    - [1.3 架构选择](#13-架构选择)
      - [选择原则](#选择原则)
      - [架构对比](#架构对比)
      - [适用场景](#适用场景)
  - [🚀 第二部分：配置优化](#-第二部分配置优化)
    - [2.1 流复制配置](#21-流复制配置)
      - [同步模式配置](#同步模式配置)
      - [复制槽配置](#复制槽配置)
      - [2.1.3 性能优化配置](#213-性能优化配置)
    - [2.2 逻辑复制配置](#22-逻辑复制配置)
      - [发布订阅配置](#发布订阅配置)
      - [冲突处理配置](#冲突处理配置)
      - [2.2.3 性能优化配置](#223-性能优化配置)
    - [2.3 MVCC优化配置](#23-mvcc优化配置)
      - [VACUUM配置](#vacuum配置)
      - [快照配置](#快照配置)
      - [版本链优化](#版本链优化)
  - [📊 第三部分：监控告警](#-第三部分监控告警)
    - [3.1 复制监控](#31-复制监控)
      - [延迟监控](#延迟监控)
      - [状态监控](#状态监控)
      - [性能监控](#性能监控)
    - [3.2 MVCC监控](#32-mvcc监控)
      - [快照监控](#快照监控)
      - [版本链监控](#版本链监控)
      - [VACUUM监控](#vacuum监控)
    - [3.3 告警规则](#33-告警规则)
      - [复制告警](#复制告警)
      - [MVCC告警](#mvcc告警)
      - [性能告警](#性能告警)
  - [🔧 第四部分：故障处理](#-第四部分故障处理)
    - [4.1 故障预防](#41-故障预防)
      - [预防措施](#预防措施)
      - [健康检查](#健康检查)
      - [容量规划](#容量规划)
    - [4.2 故障响应](#42-故障响应)
      - [故障检测](#故障检测)
      - [故障转移](#故障转移)
      - [故障恢复](#故障恢复)
    - [4.3 故障复盘](#43-故障复盘)
      - [故障分析](#故障分析)
      - [改进措施](#改进措施)
      - [4.3.3 预防措施](#433-预防措施)
  - [📝 总结](#-总结)
    - [核心原则](#核心原则)
    - [最佳实践](#最佳实践)

---

## 📋 概述

本文档总结PostgreSQL高可用最佳实践，包括架构设计、配置优化、监控告警和故障处理，为高可用系统设计提供完整指导。

---

## 🔍 第一部分：架构设计

### 1.1 主从架构

#### 流复制架构

```text
流复制架构设计：

1. 一主一从：
   - 主节点：写操作
   - 从节点：读操作 + 故障转移
   - 同步模式：根据需求选择

2. 一主多从：
   - 主节点：写操作
   - 多个从节点：读操作 + 故障转移
   - 负载均衡：读操作分散

3. MVCC影响：
   - 主节点：强一致性
   - 从节点：最终一致性（异步）或强一致性（同步）
   - 版本链：通过WAL同步
```

#### 逻辑复制架构

```text
逻辑复制架构设计：

1. 发布订阅：
   - 发布端：写操作
   - 订阅端：读操作 + 故障转移
   - 跨版本复制：支持

2. 多订阅：
   - 一个发布端，多个订阅端
   - 负载均衡：读操作分散
   - 故障转移：多个候选

3. MVCC影响：
   - 发布端：强一致性
   - 订阅端：最终一致性
   - 版本链：独立管理
```

#### 混合架构

```text
混合架构设计：

1. 流复制 + 逻辑复制：
   - 流复制：高可用
   - 逻辑复制：跨版本/跨数据库
   - 混合使用：灵活架构

2. 架构优势：
   - 高可用：流复制保证
   - 灵活性：逻辑复制支持
   - 性能：读写分离

3. MVCC影响：
   - 流复制：版本链同步
   - 逻辑复制：版本链独立
   - 混合：需要协调
```

### 1.2 多节点架构

#### 一主多从

```text
一主多从架构：

1. 架构设计：
   - 1个主节点：写操作
   - N个从节点：读操作
   - 故障转移：从节点提升

2. 优势：
   - 高可用：多个候选
   - 负载均衡：读操作分散
   - 性能：读写分离

3. MVCC影响：
   - 主节点：强一致性
   - 从节点：最终一致性
   - 版本链：通过WAL同步
```

#### 级联复制

```text
级联复制架构：

1. 架构设计：
   - 主节点 → 中间节点 → 从节点
   - 减少主节点负载
   - 提高扩展性

2. 优势：
   - 减少主节点负载
   - 提高扩展性
   - 灵活架构

3. MVCC影响：
   - 主节点：强一致性
   - 中间节点：最终一致性
   - 从节点：最终一致性
   - 版本链：级联同步
```

#### 多主架构

```text
多主架构设计：

1. 架构设计：
   - 多个主节点：双向复制
   - 冲突解决：应用层处理
   - 最终一致性：保证

2. 优势：
   - 高可用：无单点故障
   - 负载均衡：写操作分散
   - 地理分布：支持

3. MVCC影响：
   - 本地：强一致性
   - 跨节点：最终一致性
   - 版本链：独立管理
```

### 1.3 架构选择

#### 选择原则

```text
架构选择原则：

1. 可用性要求：
   - 高可用：一主多从
   - 极高可用：多主架构
   - 一般可用：一主一从

2. 一致性要求：
   - 强一致性：同步复制
   - 最终一致性：异步复制
   - 根据需求选择

3. 性能要求：
   - 高性能：异步复制
   - 平衡：同步复制
   - 根据需求选择
```

#### 架构对比

| 架构 | 可用性 | 一致性 | 性能 | 复杂度 |
| :--- | :----- | :----- | :--- | :----- |
| 一主一从 | 中 | 高（同步） | 中 | 低 |
| 一主多从 | 高 | 高（同步） | 高 | 中 |
| 级联复制 | 高 | 中 | 高 | 中 |
| 多主架构 | 极高 | 低 | 高 | 高 |

#### 适用场景

```text
架构适用场景：

1. 一主一从：
   - 小型系统
   - 低可用性要求
   - 简单架构

2. 一主多从：
   - 中型系统
   - 高可用性要求
   - 读写分离

3. 多主架构：
   - 大型系统
   - 极高可用性要求
   - 地理分布
```

---

## 🚀 第二部分：配置优化

### 2.1 流复制配置

#### 同步模式配置

```sql
-- 同步模式配置优化
-- 平衡一致性和性能

-- 方案1：强一致性（金融系统）
synchronous_standby_names = 'standby1,standby2';
synchronous_commit = remote_apply;
-- 特点：强一致性，性能较低

-- 方案2：平衡（电商系统）
synchronous_standby_names = 'standby1';
synchronous_commit = remote_write;
-- 特点：平衡一致性和性能

-- 方案3：高性能（日志系统）
synchronous_commit = off;
-- 特点：高性能，最终一致性

-- MVCC影响：
-- 同步模式影响事务提交延迟
-- 影响MVCC快照可见性
```

#### 复制槽配置

```sql
-- 复制槽配置优化（带完整错误处理）
-- 防止WAL被删除

-- 1. 创建复制槽（带错误处理）
DO $$
DECLARE
    v_slot_name TEXT := 'replica_slot';
    v_slot_exists BOOLEAN;
BEGIN
    BEGIN
        -- 检查复制槽是否已存在
        SELECT EXISTS (
            SELECT 1 FROM pg_replication_slots WHERE slot_name = v_slot_name
        ) INTO v_slot_exists;

        IF v_slot_exists THEN
            RAISE NOTICE '复制槽 % 已存在', v_slot_name;
        ELSE
            BEGIN
                PERFORM pg_create_physical_replication_slot(v_slot_name);
                RAISE NOTICE '复制槽 % 创建成功', v_slot_name;
            EXCEPTION
                WHEN duplicate_object THEN
                    RAISE WARNING '复制槽 % 已存在', v_slot_name;
                WHEN OTHERS THEN
                    RAISE WARNING '创建复制槽失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 配置WAL保留（PostgreSQL 17+，这是配置文件设置，不是SQL语句）
-- max_slot_wal_keep_size = '10GB';  -- 最大WAL保留

-- 或者使用ALTER SYSTEM设置（带错误处理）
DO $$
BEGIN
    BEGIN
        BEGIN
            ALTER SYSTEM SET max_slot_wal_keep_size = '10GB';
            RAISE NOTICE 'WAL保留大小已设置为10GB';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置WAL保留大小失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 监控复制槽（带错误处理和性能测试）
DO $$
DECLARE
    v_slot_name TEXT;
    v_active BOOLEAN;
    v_wal_retained TEXT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                slot_name,
                active,
                pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS wal_retained
            INTO v_slot_name, v_active, v_wal_retained
            FROM pg_replication_slots
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '复制槽监控：slot_name=%, active=%, wal_retained=%',
                    v_slot_name, v_active, v_wal_retained;
            ELSE
                RAISE NOTICE '未找到复制槽';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询复制槽信息失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：监控复制槽
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    slot_name,
    active,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS wal_retained
FROM pg_replication_slots;

-- MVCC影响：
-- 复制槽保留WAL，影响WAL空间
-- 影响VACUUM和MVCC清理
```

#### 2.1.3 性能优化配置

```sql
-- 流复制性能优化配置（带完整错误处理）
-- 注意：这些配置需要在postgresql.conf中设置，或使用ALTER SYSTEM命令
-- 1. WAL优化（带错误处理）
DO $$
BEGIN
    BEGIN
        BEGIN
            ALTER SYSTEM SET wal_level = replica;
            RAISE NOTICE 'wal_level已设置为replica';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置wal_level失败: %', SQLERRM;
        END;

        BEGIN
            ALTER SYSTEM SET wal_compression = on;  -- WAL压缩
            RAISE NOTICE 'wal_compression已启用';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置wal_compression失败: %', SQLERRM;
        END;

        BEGIN
            ALTER SYSTEM SET wal_buffers = '16MB';  -- WAL缓冲区
            RAISE NOTICE 'wal_buffers已设置为16MB';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置wal_buffers失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 复制优化（带错误处理）
DO $$
BEGIN
    BEGIN
        BEGIN
            ALTER SYSTEM SET max_wal_senders = 10;  -- 最大WAL发送者
            RAISE NOTICE 'max_wal_senders已设置为10';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置max_wal_senders失败: %', SQLERRM;
        END;

        BEGIN
            ALTER SYSTEM SET wal_sender_timeout = '60s';  -- WAL发送超时
            RAISE NOTICE 'wal_sender_timeout已设置为60s';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置wal_sender_timeout失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3. 从节点优化（带错误处理）
DO $$
BEGIN
    BEGIN
        BEGIN
            ALTER SYSTEM SET hot_standby = on;  -- 热备
            RAISE NOTICE 'hot_standby已启用';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置hot_standby失败: %', SQLERRM;
        END;

        BEGIN
            ALTER SYSTEM SET max_standby_streaming_delay = '30s';  -- 最大延迟
            RAISE NOTICE 'max_standby_streaming_delay已设置为30s';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置max_standby_streaming_delay失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 注意：ALTER SYSTEM命令需要重新加载配置才能生效
-- SELECT pg_reload_conf();  -- 重新加载配置

-- MVCC影响：
-- WAL优化不影响MVCC机制
-- 但影响复制延迟和性能
```

### 2.2 逻辑复制配置

#### 发布订阅配置

```sql
-- 发布订阅配置优化（带完整错误处理）
-- 1. 发布配置（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'accounts') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 accounts 或 orders 不存在，无法创建发布';
            RETURN;
        END IF;

        IF EXISTS (SELECT 1 FROM pg_publication WHERE pubname = 'my_publication') THEN
            RAISE NOTICE '发布 my_publication 已存在';
        ELSE
            BEGIN
                CREATE PUBLICATION my_publication
                FOR TABLE accounts, orders
                WITH (publish = 'insert,update,delete');
                RAISE NOTICE '发布 my_publication 创建成功（包含accounts和orders表）';
            EXCEPTION
                WHEN duplicate_object THEN
                    RAISE WARNING '发布 my_publication 已存在';
                WHEN undefined_table THEN
                    RAISE WARNING '表 accounts 或 orders 不存在，无法创建发布';
                WHEN OTHERS THEN
                    RAISE WARNING '创建发布失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 订阅配置（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_subscription WHERE subname = 'my_subscription') THEN
            RAISE NOTICE '订阅 my_subscription 已存在';
        ELSE
            BEGIN
                CREATE SUBSCRIPTION my_subscription
                CONNECTION 'host=primary dbname=postgres'
                PUBLICATION my_publication
                WITH (
                    copy_data = true,
                    create_slot = true,
                    enabled = true
                );
                RAISE NOTICE '订阅 my_subscription 创建成功';
            EXCEPTION
                WHEN duplicate_object THEN
                    RAISE WARNING '订阅 my_subscription 已存在';
                WHEN sqlclient_unable_to_establish_sqlconnection THEN
                    RAISE WARNING '无法连接到主库，请检查连接字符串';
                WHEN OTHERS THEN
                    RAISE WARNING '创建订阅失败: %', SQLERRM;
                    RAISE;
            END;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- MVCC影响：
-- 发布订阅不影响MVCC机制
-- 但影响WAL生成和保留
```

#### 冲突处理配置

```sql
-- 冲突处理配置优化（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_subscription WHERE subname = 'my_subscription') THEN
            RAISE WARNING '订阅 my_subscription 不存在，无法设置冲突处理配置';
            RETURN;
        END IF;

        BEGIN
            ALTER SUBSCRIPTION my_subscription SET (
                conflict_resolution = 'error'  -- 冲突处理策略
            );
            RAISE NOTICE '订阅 my_subscription 冲突处理策略已设置为 error（报错）';
        EXCEPTION
            WHEN undefined_object THEN
                RAISE WARNING '订阅 my_subscription 不存在';
            WHEN OTHERS THEN
                RAISE WARNING '设置冲突处理配置失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 冲突处理策略：
-- 1. error：报错（默认）
-- 2. apply_remote：应用远程变更
-- 3. keep_local：保留本地变更

-- MVCC影响：
-- 冲突处理不影响MVCC机制
-- 但影响数据一致性
```

#### 2.2.3 性能优化配置

```sql
-- 逻辑复制性能优化配置（带完整错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_subscription WHERE subname = 'my_subscription') THEN
            RAISE WARNING '订阅 my_subscription 不存在，无法设置性能优化配置';
            RETURN;
        END IF;

        BEGIN
            ALTER SUBSCRIPTION my_subscription SET (
                batch_size = 1000,  -- 批量大小
                batch_interval = '1s'  -- 批量间隔
            );
            RAISE NOTICE '订阅 my_subscription 性能优化配置已设置（batch_size=1000, batch_interval=1s）';
        EXCEPTION
            WHEN undefined_object THEN
                RAISE WARNING '订阅 my_subscription 不存在';
            WHEN OTHERS THEN
                RAISE WARNING '设置性能优化配置失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能优化效果：
-- 1. 减少网络往返
-- 2. 提高吞吐量
-- 3. 降低延迟

-- MVCC影响：
-- 批量处理不影响MVCC机制
-- 但影响复制延迟
```

### 2.3 MVCC优化配置

#### VACUUM配置

```sql
-- VACUUM配置优化（带完整错误处理）
-- 1. 全局配置（这些是配置文件设置，不是SQL语句）
-- autovacuum = on;
-- autovacuum_max_workers = 3;
-- autovacuum_naptime = '1min';

-- 或者使用ALTER SYSTEM设置（带错误处理）
DO $$
BEGIN
    BEGIN
        BEGIN
            ALTER SYSTEM SET autovacuum = on;
            RAISE NOTICE 'autovacuum已启用';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置autovacuum失败: %', SQLERRM;
        END;

        BEGIN
            ALTER SYSTEM SET autovacuum_max_workers = 3;
            RAISE NOTICE 'autovacuum_max_workers已设置为3';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置autovacuum_max_workers失败: %', SQLERRM;
        END;

        BEGIN
            ALTER SYSTEM SET autovacuum_naptime = '1min';
            RAISE NOTICE 'autovacuum_naptime已设置为1min';
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '设置autovacuum_naptime失败: %', SQLERRM;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 表级配置（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法设置VACUUM配置';
            RETURN;
        END IF;

        BEGIN
            ALTER TABLE orders SET (
                autovacuum_vacuum_scale_factor = 0.05,
                autovacuum_analyze_scale_factor = 0.02
            );
            RAISE NOTICE '表 orders VACUUM配置优化成功（更频繁的autovacuum）';
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING '表 orders 不存在';
            WHEN OTHERS THEN
                RAISE WARNING '设置表VACUUM配置失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- MVCC影响：
-- VACUUM清理死亡元组
-- 减少版本链长度
-- 提高性能
```

#### 快照配置

```text
快照配置优化：

1. 快照管理：
   - 减少活跃事务数
   - 优化事务长度
   - 减少快照开销

2. 快照缓存：
   - 使用快照缓存
   - 减少快照创建开销
   - 提高性能

3. MVCC影响：
   - 快照优化不影响MVCC机制
   - 但影响快照创建性能
```

#### 版本链优化

```sql
-- 版本链优化配置（带完整错误处理）
-- 1. fillfactor优化（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法设置fillfactor';
            RETURN;
        END IF;

        BEGIN
            ALTER TABLE orders SET (fillfactor = 80);  -- 提高HOT更新率
            RAISE NOTICE '表 orders fillfactor已设置为80（提高HOT更新率）';
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING '表 orders 不存在';
            WHEN OTHERS THEN
                RAISE WARNING '设置fillfactor失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. VACUUM优化（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法设置VACUUM配置';
            RETURN;
        END IF;

        BEGIN
            ALTER TABLE orders SET (
                autovacuum_vacuum_scale_factor = 0.05  -- 频繁VACUUM
            );
            RAISE NOTICE '表 orders VACUUM配置优化成功（频繁VACUUM）';
        EXCEPTION
            WHEN undefined_table THEN
                RAISE WARNING '表 orders 不存在';
            WHEN OTHERS THEN
                RAISE WARNING '设置VACUUM配置失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- MVCC影响：
-- fillfactor提高HOT更新率
-- VACUUM减少版本链长度
-- 提高性能
```

---

## 📊 第三部分：监控告警

### 3.1 复制监控

#### 延迟监控

```sql
-- 流复制延迟监控（带错误处理和性能测试）
DO $$
DECLARE
    v_client_addr INET;
    v_state TEXT;
    v_sync_state TEXT;
    v_sent_lag_bytes BIGINT;
    v_replay_lag_bytes BIGINT;
    v_replay_lag_seconds NUMERIC;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                client_addr,
                state,
                sync_state,
                pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS sent_lag_bytes,
                pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS replay_lag_bytes,
                EXTRACT(EPOCH FROM (now() - replay_lag_time)) AS replay_lag_seconds
            INTO v_client_addr, v_state, v_sync_state, v_sent_lag_bytes, v_replay_lag_bytes, v_replay_lag_seconds
            FROM pg_stat_replication
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '流复制延迟监控：client_addr=%, state=%, sync_state=%, sent_lag_bytes=%, replay_lag_bytes=%, replay_lag_seconds=%',
                    v_client_addr, v_state, v_sync_state, v_sent_lag_bytes, v_replay_lag_bytes, v_replay_lag_seconds;
            ELSE
                RAISE NOTICE '未找到流复制连接';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询流复制延迟失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：流复制延迟监控
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS sent_lag_bytes,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS replay_lag_bytes,
    EXTRACT(EPOCH FROM (now() - replay_lag_time)) AS replay_lag_seconds
FROM pg_stat_replication;

-- 逻辑复制延迟监控（带错误处理和性能测试）
DO $$
DECLARE
    v_subname TEXT;
    v_received_lsn TEXT;
    v_latest_end_lsn TEXT;
    v_lag_bytes BIGINT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                subname,
                received_lsn,
                latest_end_lsn,
                pg_wal_lsn_diff(pg_current_wal_lsn(), received_lsn) AS lag_bytes
            INTO v_subname, v_received_lsn, v_latest_end_lsn, v_lag_bytes
            FROM pg_stat_subscription
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '逻辑复制延迟监控：subname=%, received_lsn=%, latest_end_lsn=%, lag_bytes=%',
                    v_subname, v_received_lsn, v_latest_end_lsn, v_lag_bytes;
            ELSE
                RAISE NOTICE '未找到逻辑复制订阅';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询逻辑复制延迟失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：逻辑复制延迟监控
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    subname,
    received_lsn,
    latest_end_lsn,
    pg_wal_lsn_diff(pg_current_wal_lsn(), received_lsn) AS lag_bytes
FROM pg_stat_subscription;

-- 告警阈值：
-- sent_lag_bytes > 1GB：警告
-- replay_lag_seconds > 60s：警告
```

#### 状态监控

```sql
-- 复制状态监控（带完整错误处理和性能测试）
-- 1. 流复制状态（带错误处理和性能测试）
DO $$
DECLARE
    v_client_addr INET;
    v_state TEXT;
    v_sync_state TEXT;
    v_sync_priority INTEGER;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                client_addr,
                state,
                sync_state,
                sync_priority
            INTO v_client_addr, v_state, v_sync_state, v_sync_priority
            FROM pg_stat_replication
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '流复制状态：client_addr=%, state=%, sync_state=%, sync_priority=%',
                    v_client_addr, v_state, v_sync_state, v_sync_priority;

                IF v_state != 'streaming' THEN
                    RAISE WARNING '流复制状态异常：state=%', v_state;
                END IF;
            ELSE
                RAISE NOTICE '未找到流复制连接';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询流复制状态失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：流复制状态
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    client_addr,
    state,
    sync_state,
    sync_priority
FROM pg_stat_replication;

-- 2. 逻辑复制状态（带错误处理和性能测试）
DO $$
DECLARE
    v_subname TEXT;
    v_pid INTEGER;
    v_relid OID;
    v_received_lsn TEXT;
    v_latest_end_lsn TEXT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                subname,
                pid,
                relid,
                received_lsn,
                latest_end_lsn
            INTO v_subname, v_pid, v_relid, v_received_lsn, v_latest_end_lsn
            FROM pg_stat_subscription_stats
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '逻辑复制状态：subname=%, pid=%, relid=%, received_lsn=%, latest_end_lsn=%',
                    v_subname, v_pid, v_relid, v_received_lsn, v_latest_end_lsn;
            ELSE
                RAISE NOTICE '未找到逻辑复制订阅统计';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询逻辑复制状态失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：逻辑复制状态
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    subname,
    pid,
    relid,
    received_lsn,
    latest_end_lsn
FROM pg_stat_subscription_stats;

-- 3. 复制槽状态（带错误处理和性能测试）
DO $$
DECLARE
    v_slot_name TEXT;
    v_slot_type TEXT;
    v_active BOOLEAN;
    v_restart_lsn TEXT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                slot_name,
                slot_type,
                active,
                restart_lsn::text
            INTO v_slot_name, v_slot_type, v_active, v_restart_lsn
            FROM pg_replication_slots
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '复制槽状态：slot_name=%, slot_type=%, active=%, restart_lsn=%',
                    v_slot_name, v_slot_type, v_active, v_restart_lsn;

                IF NOT v_active THEN
                    RAISE WARNING '复制槽不活跃：slot_name=%', v_slot_name;
                END IF;
            ELSE
                RAISE NOTICE '未找到复制槽';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询复制槽状态失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：复制槽状态
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    slot_name,
    slot_type,
    active,
    restart_lsn
FROM pg_replication_slots;

-- 告警规则：
-- state != 'streaming'：告警
-- active = false：告警
```

#### 性能监控

```sql
-- 复制性能监控（带完整错误处理和性能测试）
-- 1. 复制吞吐量（带错误处理和性能测试）
DO $$
DECLARE
    v_client_addr INET;
    v_sent_lsn TEXT;
    v_write_lsn TEXT;
    v_flush_lsn TEXT;
    v_replay_lsn TEXT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                client_addr,
                sent_lsn::text,
                write_lsn::text,
                flush_lsn::text,
                replay_lsn::text
            INTO v_client_addr, v_sent_lsn, v_write_lsn, v_flush_lsn, v_replay_lsn
            FROM pg_stat_replication
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '复制吞吐量：client_addr=%, sent_lsn=%, write_lsn=%, flush_lsn=%, replay_lsn=%',
                    v_client_addr, v_sent_lsn, v_write_lsn, v_flush_lsn, v_replay_lsn;
            ELSE
                RAISE NOTICE '未找到流复制连接';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询复制吞吐量失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：复制吞吐量
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    client_addr,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn
FROM pg_stat_replication;

-- 2. WAL生成速率（带错误处理和性能测试）
DO $$
DECLARE
    v_total_wal TEXT;
    v_current_wal TEXT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')) AS total_wal,
                pg_size_pretty(
                    pg_wal_lsn_diff(
                        pg_current_wal_lsn(),
                        '0/0'  -- 简化计算
                    )
                ) AS current_wal
            INTO v_total_wal, v_current_wal;

            IF FOUND THEN
                RAISE NOTICE 'WAL生成速率：total_wal=%, current_wal=%', v_total_wal, v_current_wal;
            ELSE
                RAISE NOTICE '未找到WAL信息';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询WAL生成速率失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：WAL生成速率
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')) AS total_wal;

-- MVCC影响：
-- 复制性能影响MVCC可见性
-- 需要监控和优化
```

### 3.2 MVCC监控

#### 快照监控

```sql
-- 快照监控（带完整错误处理和性能测试）
-- 1. 活跃事务数（带错误处理和性能测试）
DO $$
DECLARE
    v_active_count BIGINT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT COUNT(*) INTO v_active_count
            FROM pg_stat_activity WHERE state = 'active';

            RAISE NOTICE '活跃事务数：%', v_active_count;

            IF v_active_count > 100 THEN
                RAISE WARNING '活跃事务数过多：%（超过100）', v_active_count;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询活跃事务数失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：活跃事务数
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active';

-- 2. 长事务（带错误处理和性能测试）
DO $$
DECLARE
    v_pid INTEGER;
    v_usename TEXT;
    v_datname TEXT;
    v_state TEXT;
    v_transaction_duration INTERVAL;
    v_query TEXT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                pid,
                usename,
                datname,
                state,
                now() - xact_start AS transaction_duration,
                LEFT(query, 100) AS query  -- 限制查询长度
            INTO v_pid, v_usename, v_datname, v_state, v_transaction_duration, v_query
            FROM pg_stat_activity
            WHERE state = 'active'
              AND now() - xact_start > interval '5 minutes'
            LIMIT 1;

            IF FOUND THEN
                RAISE WARNING '发现长事务：pid=%, usename=%, datname=%, state=%, transaction_duration=%, query=%',
                    v_pid, v_usename, v_datname, v_state, v_transaction_duration, v_query;
            ELSE
                RAISE NOTICE '未发现长事务（>5分钟）';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询长事务失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：长事务
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pid,
    usename,
    datname,
    state,
    now() - xact_start AS transaction_duration,
    query
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - xact_start > interval '5 minutes';

-- 3. 快照统计（带错误处理和性能测试）
DO $$
DECLARE
    v_datname TEXT;
    v_numbackends INTEGER;
    v_xact_commit BIGINT;
    v_xact_rollback BIGINT;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                datname,
                numbackends,
                xact_commit,
                xact_rollback
            INTO v_datname, v_numbackends, v_xact_commit, v_xact_rollback
            FROM pg_stat_database
            WHERE datname = current_database();

            IF FOUND THEN
                RAISE NOTICE '快照统计：datname=%, numbackends=%, xact_commit=%, xact_rollback=%',
                    v_datname, v_numbackends, v_xact_commit, v_xact_rollback;
            ELSE
                RAISE NOTICE '未找到数据库统计信息';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询快照统计失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：快照统计
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback
FROM pg_stat_database
WHERE datname = current_database();

-- 告警规则：
-- 活跃事务数 > 100：警告
-- 长事务 > 10分钟：警告
```

#### 版本链监控

```sql
-- 版本链监控（带完整错误处理和性能测试）
DO $$
DECLARE
    v_schemaname TEXT;
    v_relname TEXT;
    v_n_live_tup BIGINT;
    v_n_dead_tup BIGINT;
    v_dead_ratio NUMERIC;
    v_last_vacuum TIMESTAMP;
    v_last_autovacuum TIMESTAMP;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                schemaname,
                relname,
                n_live_tup,
                n_dead_tup,
                round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio,
                last_vacuum,
                last_autovacuum
            INTO v_schemaname, v_relname, v_n_live_tup, v_n_dead_tup, v_dead_ratio, v_last_vacuum, v_last_autovacuum
            FROM pg_stat_user_tables
            WHERE n_dead_tup > 1000
            ORDER BY dead_ratio DESC
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE '版本链监控：schemaname=%, relname=%, n_live_tup=%, n_dead_tup=%, dead_ratio=%, last_vacuum=%, last_autovacuum=%',
                    v_schemaname, v_relname, v_n_live_tup, v_n_dead_tup, v_dead_ratio, v_last_vacuum, v_last_autovacuum;

                IF v_dead_ratio > 50 THEN
                    RAISE WARNING '严重告警：表 %.% 死元组比例过高（dead_ratio=%）', v_schemaname, v_relname, v_dead_ratio;
                ELSIF v_dead_ratio > 20 THEN
                    RAISE WARNING '警告：表 %.% 死元组比例较高（dead_ratio=%）', v_schemaname, v_relname, v_dead_ratio;
                END IF;
            ELSE
                RAISE NOTICE '未发现死元组过多的表（>1000）';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询版本链监控失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：版本链监控
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    relname,
    n_live_tup,
    n_dead_tup,
    round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY dead_ratio DESC;

-- 告警规则：
-- dead_ratio > 20%：警告
-- dead_ratio > 50%：严重告警
```

#### VACUUM监控

```sql
-- VACUUM监控（带完整错误处理和性能测试）
DO $$
DECLARE
    v_schemaname TEXT;
    v_relname TEXT;
    v_last_vacuum TIMESTAMP;
    v_last_autovacuum TIMESTAMP;
    v_vacuum_count BIGINT;
    v_autovacuum_count BIGINT;
    v_n_dead_tup BIGINT;
    v_days_since_vacuum INTEGER;
BEGIN
    BEGIN
        BEGIN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT
                schemaname,
                relname,
                last_vacuum,
                last_autovacuum,
                vacuum_count,
                autovacuum_count,
                n_dead_tup,
                COALESCE(
                    EXTRACT(DAY FROM (now() - COALESCE(last_autovacuum, last_vacuum, '1970-01-01'::timestamp))),
                    0
                )::INTEGER AS days_since_vacuum
            INTO v_schemaname, v_relname, v_last_vacuum, v_last_autovacuum, v_vacuum_count, v_autovacuum_count, v_n_dead_tup, v_days_since_vacuum
            FROM pg_stat_user_tables
            WHERE n_dead_tup > 1000
            ORDER BY n_dead_tup DESC
            LIMIT 1;

            IF FOUND THEN
                RAISE NOTICE 'VACUUM监控：schemaname=%, relname=%, last_vacuum=%, last_autovacuum=%, vacuum_count=%, autovacuum_count=%, n_dead_tup=%, days_since_vacuum=%',
                    v_schemaname, v_relname, v_last_vacuum, v_last_autovacuum, v_vacuum_count, v_autovacuum_count, v_n_dead_tup, v_days_since_vacuum;

                IF v_days_since_vacuum > 7 THEN
                    RAISE WARNING '警告：表 %.% 超过7天未VACUUM（days_since_vacuum=%）', v_schemaname, v_relname, v_days_since_vacuum;
                END IF;

                IF v_n_dead_tup > 1000000 THEN
                    RAISE WARNING '警告：表 %.% 死元组数量过多（n_dead_tup=%）', v_schemaname, v_relname, v_n_dead_tup;
                END IF;
            ELSE
                RAISE NOTICE '未发现需要VACUUM的表（n_dead_tup>1000）';
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询VACUUM监控失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：VACUUM监控
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    relname,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count,
    n_dead_tup
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000;

-- 告警规则：
-- 超过7天未VACUUM：警告
-- dead_tup > 100万：警告
```

### 3.3 告警规则

#### 复制告警

```text
复制告警规则：

1. 复制延迟告警：
   - 流复制延迟 > 1GB：警告
   - 流复制延迟 > 10GB：严重告警
   - 逻辑复制延迟 > 1GB：警告

2. 复制状态告警：
   - 复制状态 != 'streaming'：告警
   - 复制槽不活跃：告警
   - 从节点断开：严重告警

3. 复制性能告警：
   - WAL生成速率异常：警告
   - 复制吞吐量异常：警告
```

#### MVCC告警

```text
MVCC告警规则：

1. 版本链告警：
   - dead_ratio > 20%：警告
   - dead_ratio > 50%：严重告警
   - 版本链长度 > 100：警告

2. VACUUM告警：
   - 超过7天未VACUUM：警告
   - dead_tup > 100万：警告
   - VACUUM失败：严重告警

3. 快照告警：
   - 活跃事务数 > 100：警告
   - 长事务 > 10分钟：警告
   - XID年龄 > 1亿：警告
```

#### 性能告警

```text
性能告警规则：

1. 查询性能告警：
   - 慢查询 > 1秒：警告
   - 慢查询 > 10秒：严重告警
   - 查询超时：严重告警

2. 资源告警：
   - CPU使用率 > 80%：警告
   - 内存使用率 > 90%：警告
   - 磁盘使用率 > 85%：警告

3. 连接告警：
   - 连接数 > 80%：警告
   - 连接数 > 95%：严重告警
```

---

## 🔧 第四部分：故障处理

### 4.1 故障预防

#### 预防措施

```text
故障预防措施：

1. 定期维护：
   - 定期VACUUM
   - 定期ANALYZE
   - 定期检查

2. 容量规划：
   - 监控磁盘使用
   - 监控WAL使用
   - 提前扩容

3. 健康检查：
   - 定期健康检查
   - 检查复制状态
   - 检查MVCC状态
```

#### 健康检查

```sql
-- 健康检查脚本（带完整错误处理和性能测试）
-- 1. 检查复制状态（带错误处理和性能测试）
DO $$
DECLARE
    v_replication_status TEXT;
    v_replication_count BIGINT;
    v_streaming_count BIGINT;
BEGIN
    BEGIN
        BEGIN
            SELECT COUNT(*) INTO v_replication_count FROM pg_stat_replication;
            SELECT COUNT(*) FILTER (WHERE state = 'streaming') INTO v_streaming_count FROM pg_stat_replication;

            IF v_replication_count = 0 THEN
                v_replication_status := 'ERROR: No replication';
                RAISE WARNING '复制状态：%', v_replication_status;
            ELSIF v_streaming_count = v_replication_count THEN
                v_replication_status := 'OK';
                RAISE NOTICE '复制状态：%', v_replication_status;
            ELSE
                v_replication_status := 'WARNING: Some replication issues';
                RAISE WARNING '复制状态：%', v_replication_status;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '检查复制状态失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：检查复制状态
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    CASE
        WHEN COUNT(*) = 0 THEN 'ERROR: No replication'
        WHEN COUNT(*) FILTER (WHERE state = 'streaming') = COUNT(*) THEN 'OK'
        ELSE 'WARNING: Some replication issues'
    END AS replication_status
FROM pg_stat_replication;

-- 2. 检查MVCC状态（带错误处理和性能测试）
DO $$
DECLARE
    v_mvcc_status TEXT;
    v_max_dead_ratio NUMERIC;
BEGIN
    BEGIN
        BEGIN
            SELECT MAX(round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2)) INTO v_max_dead_ratio
            FROM pg_stat_user_tables;

            IF v_max_dead_ratio IS NULL THEN
                v_mvcc_status := 'OK';
                RAISE NOTICE 'MVCC状态：%（未找到表统计信息）', v_mvcc_status;
            ELSIF v_max_dead_ratio > 50 THEN
                v_mvcc_status := 'WARNING: High dead tuple ratio';
                RAISE WARNING 'MVCC状态：%（最大dead_ratio=%）', v_mvcc_status, v_max_dead_ratio;
            ELSIF v_max_dead_ratio > 20 THEN
                v_mvcc_status := 'CAUTION: Moderate dead tuple ratio';
                RAISE WARNING 'MVCC状态：%（最大dead_ratio=%）', v_mvcc_status, v_max_dead_ratio;
            ELSE
                v_mvcc_status := 'OK';
                RAISE NOTICE 'MVCC状态：%（最大dead_ratio=%）', v_mvcc_status, v_max_dead_ratio;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '检查MVCC状态失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：检查MVCC状态
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    CASE
        WHEN MAX(dead_ratio) > 50 THEN 'WARNING: High dead tuple ratio'
        WHEN MAX(dead_ratio) > 20 THEN 'CAUTION: Moderate dead tuple ratio'
        ELSE 'OK'
    END AS mvcc_status
FROM (
    SELECT
        round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio
    FROM pg_stat_user_tables
) t;

-- 3. 检查XID年龄（带错误处理和性能测试）
DO $$
DECLARE
    v_xid_status TEXT;
    v_xid_age BIGINT;
BEGIN
    BEGIN
        BEGIN
            SELECT age(datfrozenxid) INTO v_xid_age
            FROM pg_database
            WHERE datname = current_database();

            IF v_xid_age IS NULL THEN
                RAISE WARNING '无法获取XID年龄';
            ELSIF v_xid_age > 2000000000 THEN
                v_xid_status := 'CRITICAL: XID wraparound risk';
                RAISE WARNING 'XID状态：%（XID年龄=%）', v_xid_status, v_xid_age;
            ELSIF v_xid_age > 1000000000 THEN
                v_xid_status := 'WARNING: High XID age';
                RAISE WARNING 'XID状态：%（XID年龄=%）', v_xid_status, v_xid_age;
            ELSE
                v_xid_status := 'OK';
                RAISE NOTICE 'XID状态：%（XID年龄=%）', v_xid_status, v_xid_age;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '检查XID年龄失败: %', SQLERRM;
                RAISE;
        END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '操作失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：检查XID年龄
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    CASE
        WHEN age(datfrozenxid) > 2000000000 THEN 'CRITICAL: XID wraparound risk'
        WHEN age(datfrozenxid) > 1000000000 THEN 'WARNING: High XID age'
        ELSE 'OK'
    END AS xid_status
FROM pg_database
WHERE datname = current_database();
```

#### 容量规划

```text
容量规划策略：

1. 磁盘容量：
   - 监控磁盘使用
   - 预留20-30%空间
   - 提前扩容

2. WAL容量：
   - 监控WAL使用
   - 配置WAL保留
   - 定期清理

3. 连接容量：
   - 监控连接数
   - 配置最大连接数
   - 使用连接池
```

### 4.2 故障响应

#### 故障检测

```text
故障检测流程：

1. 自动检测：
   - 监控系统自动检测
   - 触发告警
   - 通知运维

2. 手动检测：
   - 定期检查
   - 故障排查
   - 问题定位

3. 故障确认：
   - 确认故障类型
   - 评估影响范围
   - 制定处理方案
```

#### 故障转移

```text
故障转移流程：

1. 故障检测：
   - 检测主节点故障
   - 确认故障
   - 触发故障转移

2. 从节点提升：
   - 停止复制
   - 提升为主节点
   - 恢复服务

3. 验证恢复：
   - 验证数据一致性
   - 验证服务正常
   - 监控系统状态

4. MVCC处理：
   - MVCC状态正常
   - 版本链正常
   - 事务一致性保证
```

#### 故障恢复

```text
故障恢复流程：

1. 问题修复：
   - 修复故障原因
   - 恢复主节点
   - 验证修复

2. 重新同步：
   - 重新配置复制
   - 同步数据
   - 恢复正常

3. 切换回主：
   - 计划内切换
   - 验证数据一致性
   - 恢复正常架构

4. MVCC恢复：
   - MVCC状态恢复
   - 版本链同步
   - 事务一致性保证
```

### 4.3 故障复盘

#### 故障分析

```text
故障分析流程：

1. 故障记录：
   - 记录故障时间
   - 记录故障现象
   - 记录处理过程

2. 根因分析：
   - 分析故障原因
   - 分析影响范围
   - 分析处理效果

3. 改进措施：
   - 制定改进措施
   - 实施改进
   - 验证效果
```

#### 改进措施

```text
改进措施：

1. 预防措施：
   - 加强监控
   - 优化配置
   - 定期维护

2. 响应措施：
   - 优化故障检测
   - 优化故障转移
   - 优化恢复流程

3. MVCC优化：
   - 优化MVCC配置
   - 优化VACUUM策略
   - 优化版本链管理
```

#### 4.3.3 预防措施

```text
预防措施：

1. 监控加强：
   - 完善监控体系
   - 设置告警规则
   - 定期检查

2. 配置优化：
   - 优化复制配置
   - 优化MVCC配置
   - 优化性能配置

3. 演练测试：
   - 定期故障演练
   - 测试故障转移
   - 验证恢复流程
```

---

## 📝 总结

### 核心原则

1. **架构设计**: 根据需求选择合适的架构
2. **配置优化**: 优化复制和MVCC配置
3. **监控告警**: 完善的监控和告警体系
4. **故障处理**: 快速故障检测、转移和恢复

### 最佳实践

1. **架构设计**: 一主多从、同步模式、负载均衡
2. **配置优化**: 同步模式、复制槽、VACUUM优化
3. **监控告警**: 复制监控、MVCC监控、性能监控
4. **故障处理**: 故障预防、快速响应、持续改进

PostgreSQL高可用最佳实践提供了完整的指导，通过合理的设计和优化，可以在保证高可用的同时获得可接受的性能和一致性。
