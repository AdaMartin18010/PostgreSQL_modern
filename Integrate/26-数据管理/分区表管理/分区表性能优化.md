# 分区表性能优化

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [分区表性能优化](#分区表性能优化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 分区裁剪优化](#2-分区裁剪优化)
    - [2.1 确保分区裁剪](#21-确保分区裁剪)
    - [2.2 使用常量表达式](#22-使用常量表达式)
    - [2.3 检查分区裁剪](#23-检查分区裁剪)
  - [3. 索引优化](#3-索引优化)
    - [3.1 分区索引](#31-分区索引)
    - [3.2 部分索引](#32-部分索引)
    - [3.3 索引维护](#33-索引维护)
  - [4. 并行查询优化](#4-并行查询优化)
    - [4.1 启用并行查询](#41-启用并行查询)
    - [4.2 并行度调优](#42-并行度调优)
  - [5. 统计信息优化](#5-统计信息优化)
    - [5.1 更新统计信息](#51-更新统计信息)
    - [5.2 统计信息配置](#52-统计信息配置)
  - [6. 最佳实践](#6-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

分区表性能优化是提升分区表查询性能的关键。主要优化方向包括：

- **分区裁剪** - 减少扫描的分区数量
- **索引优化** - 为每个分区创建合适的索引
- **并行查询** - 利用并行查询提升性能
- **统计信息** - 保持统计信息最新

---

## 2. 分区裁剪优化

### 2.1 确保分区裁剪

```sql
-- ✅ 推荐：查询条件包含分区键
SELECT * FROM orders
WHERE order_date >= '2024-01-01'
  AND order_date < '2024-02-01';
-- 只扫描orders_2024_01分区

-- ❌ 避免：查询条件不包含分区键
SELECT * FROM orders
WHERE customer_id = 123;
-- 扫描所有分区
```

### 2.2 使用常量表达式

```sql
-- ✅ 推荐：使用常量
SELECT * FROM orders
WHERE order_date = '2024-06-15';

-- ❌ 避免：使用函数
SELECT * FROM orders
WHERE extract(year from order_date) = 2024;
-- 分区裁剪失效
```

### 2.3 检查分区裁剪

```sql
-- 使用EXPLAIN检查分区裁剪
EXPLAIN (ANALYZE, VERBOSE)
SELECT * FROM orders
WHERE order_date >= '2024-01-01'
  AND order_date < '2024-02-01';

-- 查看是否出现：
-- - Append
-- - Seq Scan on orders_2024_01
-- 如果扫描多个分区，说明裁剪不完整
```

---

## 3. 索引优化

### 3.1 分区索引

```sql
-- 在主表上创建索引（自动应用到所有分区）
CREATE INDEX orders_customer_id_idx ON orders (customer_id);

-- 或在每个分区上单独创建索引
CREATE INDEX orders_2024_01_customer_id_idx ON orders_2024_01 (customer_id);
```

### 3.2 部分索引

```sql
-- 为每个分区创建部分索引
CREATE INDEX orders_2024_01_active_idx ON orders_2024_01 (customer_id)
WHERE status = 'active';
```

### 3.3 索引维护

```sql
-- 定期维护索引
VACUUM ANALYZE orders;

-- 重建索引（如果索引膨胀）
REINDEX TABLE orders;
```

---

## 4. 并行查询优化

### 4.1 启用并行查询

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;

-- 分区表支持并行查询
EXPLAIN (ANALYZE)
SELECT customer_id, SUM(amount)
FROM orders
WHERE order_date >= '2024-01-01'
GROUP BY customer_id;
```

### 4.2 并行度调优

```sql
-- 根据数据量调整并行度
ALTER TABLE orders SET (parallel_workers = 4);
```

---

## 5. 统计信息优化

### 5.1 更新统计信息

```sql
-- 定期更新统计信息
ANALYZE orders;

-- 或使用自动分析
ALTER TABLE orders SET (autovacuum_analyze_scale_factor = 0.1);
```

### 5.2 统计信息配置

```sql
-- 增加统计信息样本
ALTER TABLE orders ALTER COLUMN order_date SET STATISTICS 1000;
```

---

## 6. 最佳实践

### ✅ 推荐做法

1. **确保分区裁剪** - 查询条件必须包含分区键
2. **创建合适索引** - 为每个分区创建索引
3. **使用并行查询** - 利用并行查询提升性能
4. **保持统计信息最新** - 定期ANALYZE
5. **监控性能** - 使用EXPLAIN分析查询计划

### ❌ 避免做法

1. **查询条件不包含分区键** - 导致全分区扫描
2. **不使用索引** - 影响查询性能
3. **忽略统计信息** - 影响查询优化
4. **不监控性能** - 无法发现性能问题

---

## 📚 相关文档

- [分区表完整指南.md](./分区表完整指南.md) - 分区表完整指南
- [分区策略选择.md](./分区策略选择.md) - 分区策略选择
- [分区表维护.md](./分区表维护.md) - 分区表维护
- [26-数据管理/README.md](../README.md) - 数据管理主题

---

**最后更新**: 2025年1月
