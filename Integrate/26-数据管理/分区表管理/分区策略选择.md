# 分区策略选择

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [分区策略选择](#分区策略选择)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 范围分区（RANGE）](#2-范围分区range)
    - [2.1 适用场景](#21-适用场景)
    - [2.2 示例](#22-示例)
    - [2.3 优势](#23-优势)
    - [2.4 劣势](#24-劣势)
  - [3. 列表分区（LIST）](#3-列表分区list)
    - [3.1 适用场景](#31-适用场景)
    - [3.2 示例](#32-示例)
    - [3.3 优势](#33-优势)
    - [3.4 劣势](#34-劣势)
  - [4. 哈希分区（HASH）](#4-哈希分区hash)
    - [4.1 适用场景](#41-适用场景)
    - [4.2 示例](#42-示例)
    - [4.3 优势](#43-优势)
    - [4.4 劣势](#44-劣势)
  - [5. 策略选择指南](#5-策略选择指南)
    - [5.1 选择矩阵](#51-选择矩阵)
    - [5.2 决策流程](#52-决策流程)
  - [6. 最佳实践](#6-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

PostgreSQL支持三种分区策略：

- **范围分区（RANGE）** - 按范围值分区
- **列表分区（LIST）** - 按列表值分区
- **哈希分区（HASH）** - 按哈希值分区

选择合适的策略对性能至关重要。

---

## 2. 范围分区（RANGE）

### 2.1 适用场景

- **时序数据** - 按时间分区（日期、时间戳）
- **数值范围** - 按ID范围分区
- **有序数据** - 数据有自然顺序

### 2.2 示例

```sql
-- 按日期范围分区
CREATE TABLE orders (
    id BIGSERIAL,
    order_date DATE NOT NULL,
    customer_id INT,
    amount NUMERIC
) PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024_q1 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE orders_2024_q2 PARTITION OF orders
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');
```

### 2.3 优势

- 分区裁剪效果好
- 查询性能优秀
- 易于管理（添加/删除分区）

### 2.4 劣势

- 可能出现数据倾斜
- 需要管理默认分区

---

## 3. 列表分区（LIST）

### 3.1 适用场景

- **地区数据** - 按地区分区
- **类别数据** - 按类别分区
- **状态数据** - 按状态分区

### 3.2 示例

```sql
-- 按地区列表分区
CREATE TABLE sales (
    id BIGSERIAL,
    region TEXT NOT NULL,
    product_id INT,
    amount NUMERIC
) PARTITION BY LIST (region);

CREATE TABLE sales_us PARTITION OF sales
    FOR VALUES IN ('US', 'CA', 'MX');

CREATE TABLE sales_eu PARTITION OF sales
    FOR VALUES IN ('UK', 'DE', 'FR', 'IT', 'ES');

CREATE TABLE sales_asia PARTITION OF sales
    FOR VALUES IN ('CN', 'JP', 'KR', 'IN');
```

### 3.3 优势

- 分区明确
- 查询简单
- 易于理解

### 3.4 劣势

- 分区数量可能较多
- 新增值需要创建新分区

---

## 4. 哈希分区（HASH）

### 4.1 适用场景

- **负载均衡** - 均匀分布数据
- **无自然顺序** - 数据没有明显分区键
- **并发写入** - 减少锁竞争

### 4.2 示例

```sql
-- 按ID哈希分区
CREATE TABLE users (
    id BIGSERIAL,
    username TEXT,
    email TEXT
) PARTITION BY HASH (id);

CREATE TABLE users_0 PARTITION OF users
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE users_1 PARTITION OF users
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE users_2 PARTITION OF users
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE users_3 PARTITION OF users
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

### 4.3 优势

- 数据均匀分布
- 负载均衡
- 减少热点

### 4.4 劣势

- 分区裁剪困难
- 查询可能扫描多个分区

---

## 5. 策略选择指南

### 5.1 选择矩阵

| 场景 | 推荐策略 | 原因 |
|------|---------|------|
| 时序数据 | RANGE | 按时间查询，裁剪效果好 |
| 地区数据 | LIST | 按地区查询，分区明确 |
| 用户数据 | HASH | 负载均衡，减少热点 |
| 日志数据 | RANGE | 按时间查询和管理 |
| 订单数据 | RANGE | 按时间查询和归档 |

### 5.2 决策流程

```
1. 数据是否有时间属性？
   → 是：考虑RANGE分区
   → 否：继续

2. 数据是否有明确的分类？
   → 是：考虑LIST分区
   → 否：继续

3. 需要负载均衡？
   → 是：考虑HASH分区
   → 否：重新评估
```

---

## 6. 最佳实践

### ✅ 推荐做法

1. **根据查询模式选择** - 选择匹配查询的分区策略
2. **考虑数据分布** - 避免数据倾斜
3. **测试性能** - 测试不同策略的性能
4. **考虑维护** - 选择易于维护的策略
5. **文档化决策** - 记录选择原因

### ❌ 避免做法

1. **盲目选择** - 需要分析数据特征
2. **忽略查询模式** - 分区策略应该匹配查询
3. **不测试** - 需要测试性能
4. **过度分区** - 分区过多影响性能

---

## 📚 相关文档

- [分区表完整指南.md](./分区表完整指南.md) - 分区表完整指南
- [分区表管理基础.md](./分区表管理基础.md) - 分区表基础
- [PostgreSQL分区表高级优化指南.md](./PostgreSQL分区表高级优化指南.md) - 高级优化指南
- [26-数据管理/README.md](../README.md) - 数据管理主题

---

**最后更新**: 2025年1月
