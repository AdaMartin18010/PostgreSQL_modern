# 分区表维护

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [分区表维护](#分区表维护)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 添加分区](#2-添加分区)
    - [2.1 手动添加分区](#21-手动添加分区)
    - [2.2 自动创建分区函数](#22-自动创建分区函数)
  - [3. 删除分区](#3-删除分区)
    - [3.1 删除分区（删除数据）](#31-删除分区删除数据)
    - [3.2 分离分区（保留数据）](#32-分离分区保留数据)
    - [3.3 自动删除旧分区](#33-自动删除旧分区)
  - [4. 分区归档](#4-分区归档)
    - [4.1 归档到独立表](#41-归档到独立表)
    - [4.2 导出归档](#42-导出归档)
  - [5. 自动维护](#5-自动维护)
    - [5.1 使用pg\_partman](#51-使用pg_partman)
    - [5.2 使用pg\_cron](#52-使用pg_cron)
  - [6. 最佳实践](#6-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [7. 分区维护监控](#7-分区维护监控)
    - [7.1 维护日志](#71-维护日志)
    - [7.2 维护统计](#72-维护统计)
  - [8. 分区维护自动化](#8-分区维护自动化)
    - [8.1 完整自动化函数](#81-完整自动化函数)
    - [8.2 维护告警](#82-维护告警)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

分区表维护是分区表管理的重要组成部分。包括：

- **添加分区** - 创建新分区
- **删除分区** - 删除旧分区
- **分区归档** - 归档历史分区
- **自动维护** - 自动化维护任务

---

## 2. 添加分区

### 2.1 手动添加分区

```sql
-- 添加新分区
CREATE TABLE orders_2024_12 PARTITION OF orders
    FOR VALUES FROM ('2024-12-01') TO ('2025-01-01');
```

### 2.2 自动创建分区函数

```sql
-- 创建自动创建分区的函数
CREATE OR REPLACE FUNCTION create_monthly_partition(
    table_name TEXT,
    partition_date DATE
)
RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    start_date := date_trunc('month', partition_date);
    end_date := start_date + INTERVAL '1 month';
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');

    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
        partition_name, table_name, start_date, end_date
    );
END;
$$ LANGUAGE plpgsql;

-- 使用
SELECT create_monthly_partition('orders', '2024-12-15');
```

---

## 3. 删除分区

### 3.1 删除分区（删除数据）

```sql
-- 删除分区（数据也会删除）
DROP TABLE orders_2024_01;
```

### 3.2 分离分区（保留数据）

```sql
-- 分离分区（保留数据）
ALTER TABLE orders DETACH PARTITION orders_2024_01;

-- 分离后的表可以独立管理
-- 可以重命名、移动、删除等
```

### 3.3 自动删除旧分区

```sql
-- 创建自动删除旧分区的函数
CREATE OR REPLACE FUNCTION drop_old_partitions(
    table_name TEXT,
    retention_months INT DEFAULT 12
)
RETURNS VOID AS $$
DECLARE
    partition_record RECORD;
    cutoff_date DATE;
BEGIN
    cutoff_date := CURRENT_DATE - (retention_months || ' months')::INTERVAL;

    FOR partition_record IN
        SELECT tablename
        FROM pg_tables
        WHERE tablename LIKE table_name || '_%'
          AND tablename ~ '^\d{4}_\d{2}$'  -- 匹配YYYY_MM格式
    LOOP
        -- 提取日期并检查
        IF to_date(substring(partition_record.tablename from '\d{4}_\d{2}'), 'YYYY_MM') < cutoff_date THEN
            EXECUTE format('DROP TABLE IF EXISTS %I', partition_record.tablename);
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 使用
SELECT drop_old_partitions('orders', 12);  -- 保留12个月
```

---

## 4. 分区归档

### 4.1 归档到独立表

```sql
-- 分离分区
ALTER TABLE orders DETACH PARTITION orders_2024_01;

-- 重命名归档
ALTER TABLE orders_2024_01 RENAME TO orders_archive_2024_01;

-- 移动到归档schema
ALTER TABLE orders_archive_2024_01 SET SCHEMA archive;
```

### 4.2 导出归档

```bash
# 导出分区数据
pg_dump -t orders_2024_01 mydb > orders_2024_01.dump

# 删除分区
DROP TABLE orders_2024_01;
```

---

## 5. 自动维护

### 5.1 使用pg_partman

```sql
-- 安装pg_partman
CREATE EXTENSION pg_partman;

-- 配置自动分区
SELECT partman.create_parent(
    p_parent_table => 'public.orders',
    p_control => 'order_date',
    p_type => 'range',
    p_interval => 'monthly',
    p_premake => 3
);

-- 自动创建未来3个月的分区
-- 自动删除旧分区（根据配置）
```

### 5.2 使用pg_cron

```sql
-- 安装pg_cron
CREATE EXTENSION pg_cron;

-- 定期创建新分区（每月1号）
SELECT cron.schedule(
    'create_monthly_partition',
    '0 0 1 * *',
    $$SELECT create_monthly_partition('orders', CURRENT_DATE)$$
);

-- 定期删除旧分区（每月1号）
SELECT cron.schedule(
    'drop_old_partitions',
    '0 1 1 * *',
    $$SELECT drop_old_partitions('orders', 12)$$
);
```

---

## 6. 最佳实践

### ✅ 推荐做法

1. **自动化维护** - 使用pg_partman或自定义函数
2. **提前创建分区** - 提前创建未来分区
3. **定期清理** - 定期删除或归档旧分区
4. **监控分区** - 监控分区数量和大小
5. **备份重要数据** - 删除前备份重要数据

### ❌ 避免做法

1. **手动维护** - 容易遗漏和出错
2. **不清理旧分区** - 导致分区过多
3. **不备份** - 删除前不备份
4. **不监控** - 无法及时发现问题

---

## 7. 分区维护监控

### 7.1 维护日志

```sql
-- 创建分区维护日志表
CREATE TABLE IF NOT EXISTS partition_maintenance_log (
    id SERIAL PRIMARY KEY,
    operation_type TEXT,  -- 'CREATE', 'DROP', 'DETACH', 'ARCHIVE'
    partition_name TEXT,
    parent_table TEXT,
    operation_status TEXT,  -- 'SUCCESS', 'FAILED'
    error_message TEXT,
    operation_time TIMESTAMPTZ DEFAULT NOW(),
    duration INTERVAL
);

-- 维护日志记录函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION log_partition_maintenance(
    p_operation_type TEXT,
    p_partition_name TEXT,
    p_parent_table TEXT,
    p_status TEXT,
    p_error_message TEXT DEFAULT NULL,
    p_duration INTERVAL DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO partition_maintenance_log (
        operation_type,
        partition_name,
        parent_table,
        operation_status,
        error_message,
        duration
    )
    VALUES (
        p_operation_type,
        p_partition_name,
        p_parent_table,
        p_status,
        p_error_message,
        p_duration
    );

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '记录维护日志失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 维护统计

```sql
-- 分区维护统计视图
CREATE OR REPLACE VIEW v_partition_maintenance_stats AS
SELECT
    operation_type,
    operation_status,
    COUNT(*) AS operation_count,
    AVG(duration) AS avg_duration,
    MAX(operation_time) AS last_operation_time
FROM partition_maintenance_log
WHERE operation_time > NOW() - INTERVAL '30 days'
GROUP BY operation_type, operation_status
ORDER BY operation_type, operation_status;

-- 查询维护统计
SELECT * FROM v_partition_maintenance_stats;
```

---

## 8. 分区维护自动化

### 8.1 完整自动化函数

```sql
-- 完整的分区维护自动化函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION auto_maintain_partitions(
    p_table_name TEXT,
    p_partition_column TEXT,
    p_interval_type TEXT DEFAULT 'monthly',  -- 'daily', 'weekly', 'monthly'
    p_premake_count INT DEFAULT 3,
    p_retention_months INT DEFAULT 12
)
RETURNS TABLE (
    operation TEXT,
    partition_name TEXT,
    status TEXT,
    duration INTERVAL
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    operation_duration INTERVAL;
    partition_date DATE;
    partition_name TEXT;
    i INT;
BEGIN
    -- 1. 创建未来分区
    FOR i IN 1..p_premake_count LOOP
        start_time := clock_timestamp();

        CASE p_interval_type
            WHEN 'daily' THEN
                partition_date := CURRENT_DATE + (i || ' days')::INTERVAL;
            WHEN 'weekly' THEN
                partition_date := date_trunc('week', CURRENT_DATE) + (i || ' weeks')::INTERVAL;
            WHEN 'monthly' THEN
                partition_date := date_trunc('month', CURRENT_DATE) + (i || ' months')::INTERVAL;
            ELSE
                RAISE EXCEPTION '不支持的间隔类型: %', p_interval_type;
        END CASE;

        BEGIN
            PERFORM create_monthly_partition(p_table_name, partition_date);
            end_time := clock_timestamp();
            operation_duration := end_time - start_time;

            RETURN QUERY SELECT
                'CREATE'::TEXT,
                partition_name,
                'SUCCESS'::TEXT,
                operation_duration;

            PERFORM log_partition_maintenance(
                'CREATE',
                partition_name,
                p_table_name,
                'SUCCESS',
                NULL,
                operation_duration
            );

        EXCEPTION
            WHEN duplicate_table THEN
                RETURN QUERY SELECT
                    'CREATE'::TEXT,
                    partition_name,
                    'SKIPPED'::TEXT,
                    NULL::INTERVAL;
            WHEN OTHERS THEN
                RETURN QUERY SELECT
                    'CREATE'::TEXT,
                    partition_name,
                    'FAILED'::TEXT,
                    NULL::INTERVAL;

                PERFORM log_partition_maintenance(
                    'CREATE',
                    partition_name,
                    p_table_name,
                    'FAILED',
                    SQLERRM,
                    NULL
                );
        END;
    END LOOP;

    -- 2. 删除旧分区
    start_time := clock_timestamp();
    BEGIN
        PERFORM drop_old_partitions(p_table_name, p_retention_months);
        end_time := clock_timestamp();
        operation_duration := end_time - start_time;

        RETURN QUERY SELECT
            'DROP_OLD'::TEXT,
            NULL::TEXT,
            'SUCCESS'::TEXT,
            operation_duration;

    EXCEPTION
        WHEN OTHERS THEN
            RETURN QUERY SELECT
                'DROP_OLD'::TEXT,
                NULL::TEXT,
                'FAILED'::TEXT,
                NULL::INTERVAL;

            PERFORM log_partition_maintenance(
                'DROP',
                NULL,
                p_table_name,
                'FAILED',
                SQLERRM,
                NULL
            );
    END;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '自动维护分区失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行自动维护
SELECT * FROM auto_maintain_partitions('orders', 'order_date', 'monthly', 3, 12);
```

### 8.2 维护告警

```sql
-- 分区维护告警函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION check_partition_maintenance_alerts()
RETURNS TABLE (
    alert_type TEXT,
    alert_message TEXT,
    alert_level TEXT
) AS $$
DECLARE
    failed_ops_count BIGINT;
    missing_partitions_count INT;
    partition_count INT;
BEGIN
    -- 检查失败的维护操作
    SELECT COUNT(*) INTO failed_ops_count
    FROM partition_maintenance_log
    WHERE operation_status = 'FAILED'
      AND operation_time > NOW() - INTERVAL '24 hours';

    IF failed_ops_count > 0 THEN
        RETURN QUERY SELECT
            'MAINTENANCE_FAILURE'::TEXT,
            format('过去24小时有 % 次维护操作失败', failed_ops_count)::TEXT,
            'CRITICAL'::TEXT;
    END IF;

    -- 检查分区数量（示例：orders表）
    SELECT COUNT(*) INTO partition_count
    FROM pg_tables
    WHERE tablename LIKE 'orders_%';

    IF partition_count > 100 THEN
        RETURN QUERY SELECT
            'TOO_MANY_PARTITIONS'::TEXT,
            format('分区数量过多: %', partition_count)::TEXT,
            'WARNING'::TEXT;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查维护告警失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 查询告警
SELECT * FROM check_partition_maintenance_alerts();
```

---

## 📚 相关文档

- [分区表完整指南.md](./分区表完整指南.md) - 分区表完整指南
- [分区表监控.md](./分区表监控.md) - 分区表监控
- [PostgreSQL分区表高级优化指南.md](./PostgreSQL分区表高级优化指南.md) - 高级优化指南
- [26-数据管理/README.md](../README.md) - 数据管理主题

---

**最后更新**: 2025年1月
