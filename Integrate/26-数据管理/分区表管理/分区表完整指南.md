# PostgreSQL分区表完整指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [PostgreSQL分区表完整指南](#postgresql分区表完整指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 分区策略选择](#2-分区策略选择)
    - [2.1 范围分区（RANGE）](#21-范围分区range)
    - [2.2 列表分区（LIST）](#22-列表分区list)
    - [2.3 哈希分区（HASH）](#23-哈希分区hash)
  - [3. 分区表创建](#3-分区表创建)
    - [3.1 创建分区表](#31-创建分区表)
    - [3.2 创建索引](#32-创建索引)
  - [4. 分区管理](#4-分区管理)
    - [4.1 添加分区](#41-添加分区)
    - [4.2 删除分区](#42-删除分区)
    - [4.3 分区维护](#43-分区维护)
  - [5. 分区表性能优化](#5-分区表性能优化)
    - [5.1 分区裁剪](#51-分区裁剪)
    - [5.2 并行查询](#52-并行查询)
    - [5.3 索引优化](#53-索引优化)
  - [6. 分区表监控](#6-分区表监控)
    - [6.1 查看分区信息](#61-查看分区信息)
    - [6.2 监控分区使用](#62-监控分区使用)
  - [7. 最佳实践](#7-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

分区表是将一个大表分割成多个较小的物理表（分区）的技术。PostgreSQL支持：

- **范围分区（RANGE）** - 按范围值分区
- **列表分区（LIST）** - 按列表值分区
- **哈希分区（HASH）** - 按哈希值分区
- **复合分区** - 多级分区

---

## 2. 分区策略选择

### 2.1 范围分区（RANGE）

**适用场景**：

- 时序数据（按时间分区）
- 数值范围数据（按ID范围分区）

**示例**：

```sql
CREATE TABLE orders (
    id BIGSERIAL,
    order_date DATE NOT NULL,
    customer_id INT,
    amount NUMERIC
) PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

### 2.2 列表分区（LIST）

**适用场景**：

- 按地区分区
- 按类别分区
- 按状态分区

**示例**：

```sql
CREATE TABLE logs (
    id BIGSERIAL,
    log_level TEXT NOT NULL,
    message TEXT
) PARTITION BY LIST (log_level);

CREATE TABLE logs_error PARTITION OF logs
    FOR VALUES IN ('ERROR', 'FATAL');
```

### 2.3 哈希分区（HASH）

**适用场景**：

- 负载均衡
- 数据均匀分布

**示例**：

```sql
CREATE TABLE users (
    id BIGSERIAL,
    username TEXT,
    email TEXT
) PARTITION BY HASH (id);

CREATE TABLE users_0 PARTITION OF users
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
```

---

## 3. 分区表创建

### 3.1 创建分区表

```sql
-- 1. 创建主表
CREATE TABLE sales (
    id BIGSERIAL,
    sale_date DATE NOT NULL,
    product_id INT,
    amount NUMERIC,
    PRIMARY KEY (id, sale_date)
) PARTITION BY RANGE (sale_date);

-- 2. 创建分区
CREATE TABLE sales_2024_q1 PARTITION OF sales
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE sales_2024_q2 PARTITION OF sales
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');

-- 3. 创建默认分区（可选）
CREATE TABLE sales_default PARTITION OF sales DEFAULT;
```

### 3.2 创建索引

```sql
-- 在主表上创建索引（会自动应用到所有分区）
CREATE INDEX sales_sale_date_idx ON sales (sale_date);
CREATE INDEX sales_product_id_idx ON sales (product_id);

-- 或者在每个分区上单独创建索引
CREATE INDEX sales_2024_q1_sale_date_idx ON sales_2024_q1 (sale_date);
```

---

## 4. 分区管理

### 4.1 添加分区

```sql
-- 添加新分区
CREATE TABLE sales_2024_q3 PARTITION OF sales
    FOR VALUES FROM ('2024-07-01') TO ('2024-10-01');
```

### 4.2 删除分区

```sql
-- 删除分区（数据也会删除）
DROP TABLE sales_2024_q1;

-- 或者分离分区（保留数据）
ALTER TABLE sales DETACH PARTITION sales_2024_q1;
```

### 4.3 分区维护

```sql
-- 自动创建分区函数
CREATE OR REPLACE FUNCTION create_monthly_partition(
    table_name TEXT,
    partition_date DATE
)
RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    start_date := date_trunc('month', partition_date);
    end_date := start_date + INTERVAL '1 month';
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');

    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
        partition_name, table_name, start_date, end_date
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 5. 分区表性能优化

### 5.1 分区裁剪

```sql
-- 查询时自动进行分区裁剪
EXPLAIN (ANALYZE)
SELECT * FROM sales
WHERE sale_date BETWEEN '2024-06-01' AND '2024-06-30';
-- 只扫描sales_2024_q2分区
```

### 5.2 并行查询

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;

-- 分区表支持并行查询
EXPLAIN (ANALYZE)
SELECT product_id, SUM(amount)
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY product_id;
```

### 5.3 索引优化

```sql
-- 在每个分区上创建局部索引
CREATE INDEX sales_2024_q1_product_idx ON sales_2024_q1 (product_id)
WHERE product_id IS NOT NULL;
```

---

## 6. 分区表监控

### 6.1 查看分区信息

```sql
-- 查看所有分区
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE tablename LIKE 'sales_%'
ORDER BY tablename;
```

### 6.2 监控分区使用

```sql
-- 查看分区统计信息
SELECT
    schemaname,
    tablename,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_live_tup,
    n_dead_tup
FROM pg_stat_user_tables
WHERE tablename LIKE 'sales_%';
```

---

## 7. 最佳实践

### ✅ 推荐做法

1. **合理选择分区键** - 选择查询常用的列
2. **使用分区裁剪** - 确保查询条件包含分区键
3. **定期维护分区** - 删除旧分区，添加新分区
4. **监控分区大小** - 避免单个分区过大
5. **使用默认分区** - 处理边界情况

### ❌ 避免做法

1. **分区过多** - 过多分区会影响性能
2. **忽略分区裁剪** - 查询条件必须包含分区键
3. **不使用索引** - 每个分区都应该有适当的索引
4. **忽略维护** - 定期维护分区表

---

## 📚 相关文档

- [分区表管理基础.md](./分区表管理基础.md) - 分区表管理基础
- [PostgreSQL分区表高级优化指南.md](./PostgreSQL分区表高级优化指南.md) - 分区表高级优化
- [26-数据管理/README.md](../README.md) - 数据管理主题
- [02-查询与优化/05.06-表分区与分区裁剪-语义与等价.md](../../02-查询与优化/05.06-表分区与分区裁剪-语义与等价.md) - 分区裁剪理论

---

**最后更新**: 2025年1月
