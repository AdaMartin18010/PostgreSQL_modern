---
> **ğŸ“‹ æ–‡æ¡£æ¥æº**: ç½‘ç»œå¯¹æ ‡æ–°å¢æ–‡æ¡£
> **ğŸ“… åˆ›å»ºæ—¥æœŸ**: 2025-01
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£èšç„¦æ•°æ®æ²»ç†ä¸æ•°æ®è´¨é‡å®Œæ•´æŒ‡å—ï¼Œå¯¹æ ‡ç½‘ç»œæœ€æ–°å®è·µ

---

# PostgreSQLæ•°æ®æ²»ç†ä¸æ•°æ®è´¨é‡å®Œæ•´æŒ‡å—

## å…ƒæ•°æ®

- **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
- **åˆ›å»ºæ—¥æœŸ**: 2025-01
- **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ•°æ®æ²»ç† | æ•°æ®è´¨é‡ | æ•°æ®è¡€ç¼˜ | åˆè§„æ€§
- **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
- **é¢„è®¡é˜…è¯»**: 180åˆ†é’Ÿ
- **å‰ç½®è¦æ±‚**: ç†Ÿæ‚‰PostgreSQLåŸºç¡€ã€æ•°æ®ç®¡ç†åŸºç¡€

---

## ğŸ“‹ å®Œæ•´ç›®å½•

- [PostgreSQLæ•°æ®æ²»ç†ä¸æ•°æ®è´¨é‡å®Œæ•´æŒ‡å—](#postgresqlæ•°æ®æ²»ç†ä¸æ•°æ®è´¨é‡å®Œæ•´æŒ‡å—)
  - [å…ƒæ•°æ®](#å…ƒæ•°æ®)
  - [ğŸ“‹ å®Œæ•´ç›®å½•](#-å®Œæ•´ç›®å½•)
  - [1. æ•°æ®æ²»ç†æ¦‚è¿°](#1-æ•°æ®æ²»ç†æ¦‚è¿°)
    - [1.1 æ•°æ®æ²»ç†æ¡†æ¶](#11-æ•°æ®æ²»ç†æ¡†æ¶)
    - [1.2 æ•°æ®æ²»ç†å†³ç­–æµç¨‹å›¾](#12-æ•°æ®æ²»ç†å†³ç­–æµç¨‹å›¾)
  - [2. æ•°æ®è´¨é‡è¯„ä¼°æ–¹æ³•](#2-æ•°æ®è´¨é‡è¯„ä¼°æ–¹æ³•)
    - [2.1 æ•°æ®è´¨é‡ç»´åº¦](#21-æ•°æ®è´¨é‡ç»´åº¦)
    - [2.2 æ•°æ®è´¨é‡è¯„ä¼°å®ç°](#22-æ•°æ®è´¨é‡è¯„ä¼°å®ç°)
  - [3. æ•°æ®è´¨é‡ç›‘æ§](#3-æ•°æ®è´¨é‡ç›‘æ§)
    - [3.1 å®æ—¶ç›‘æ§åœºæ™¯](#31-å®æ—¶ç›‘æ§åœºæ™¯)
    - [3.2 è‡ªåŠ¨åŒ–ç›‘æ§å®ç°](#32-è‡ªåŠ¨åŒ–ç›‘æ§å®ç°)
  - [4. æ•°æ®è¡€ç¼˜åˆ†æ](#4-æ•°æ®è¡€ç¼˜åˆ†æ)
    - [4.1 æ•°æ®è¡€ç¼˜è¿½è¸ª](#41-æ•°æ®è¡€ç¼˜è¿½è¸ª)
  - [5. æ•°æ®ç›®å½•ç®¡ç†](#5-æ•°æ®ç›®å½•ç®¡ç†)
    - [5.1 å…ƒæ•°æ®ç®¡ç†](#51-å…ƒæ•°æ®ç®¡ç†)
  - [6. æ•°æ®åˆè§„æ€§ç®¡ç†](#6-æ•°æ®åˆè§„æ€§ç®¡ç†)
    - [6.1 GDPRåˆè§„åœºæ™¯](#61-gdpråˆè§„åœºæ™¯)
    - [6.2 åˆè§„æ€§æ£€æŸ¥å®ç°](#62-åˆè§„æ€§æ£€æŸ¥å®ç°)
  - [7. ç»¼åˆé€‰å‹æ¡ˆä¾‹](#7-ç»¼åˆé€‰å‹æ¡ˆä¾‹)
    - [7.1 æ¡ˆä¾‹1ï¼šä¼ä¸šçº§æ•°æ®æ²»ç†ç³»ç»Ÿ](#71-æ¡ˆä¾‹1ä¼ä¸šçº§æ•°æ®æ²»ç†ç³»ç»Ÿ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
  - [ğŸ“ æ›´æ–°æ—¥å¿—](#-æ›´æ–°æ—¥å¿—)

---

## 1. æ•°æ®æ²»ç†æ¦‚è¿°

### 1.1 æ•°æ®æ²»ç†æ¡†æ¶

æ•°æ®æ²»ç†æ˜¯ç¡®ä¿æ•°æ®èµ„äº§å¾—åˆ°æœ‰æ•ˆç®¡ç†å’Œä½¿ç”¨çš„æ¡†æ¶å’Œæµç¨‹ã€‚

**æ ¸å¿ƒç»„ä»¶**:

```mermaid
mindmap
  root((æ•°æ®æ²»ç†))
    æ•°æ®è´¨é‡
      å®Œæ•´æ€§
      å‡†ç¡®æ€§
      ä¸€è‡´æ€§
      åŠæ—¶æ€§
    æ•°æ®å®‰å…¨
      è®¿é—®æ§åˆ¶
      æ•°æ®åŠ å¯†
      å®¡è®¡æ—¥å¿—
    æ•°æ®åˆè§„
      GDPR
      HIPAA
      SOC2
    æ•°æ®è¡€ç¼˜
      æ•°æ®æº¯æº
      å½±å“åˆ†æ
      å˜æ›´è¿½è¸ª
    å…ƒæ•°æ®ç®¡ç†
      æ•°æ®ç›®å½•
      æ•°æ®å­—å…¸
      ä¸šåŠ¡æœ¯è¯­
```

### 1.2 æ•°æ®æ²»ç†å†³ç­–æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹ï¼šè¯„ä¼°æ•°æ®æ²»ç†éœ€æ±‚] --> B{æ•°æ®æ•æ„Ÿåº¦?}
    B -->|é«˜æ•æ„Ÿæ•°æ®| C[å®Œæ•´æ•°æ®æ²»ç†æ¡†æ¶]
    B -->|ä¸­æ•æ„Ÿæ•°æ®| D[æ ¸å¿ƒæ•°æ®æ²»ç†]
    B -->|ä½æ•æ„Ÿæ•°æ®| E[åŸºç¡€æ•°æ®æ²»ç†]

    C --> C1[æ•°æ®è´¨é‡ + æ•°æ®å®‰å…¨ + æ•°æ®åˆè§„ + æ•°æ®è¡€ç¼˜]
    D --> D1[æ•°æ®è´¨é‡ + æ•°æ®å®‰å…¨]
    E --> E1[æ•°æ®è´¨é‡]

    C1 --> F[é€‰æ‹©æ²»ç†å·¥å…·]
    D1 --> F
    E1 --> F

    F --> G[å®æ–½æ•°æ®æ²»ç†]
    G --> H[æŒç»­ç›‘æ§ä¸ä¼˜åŒ–]
```

---

## 2. æ•°æ®è´¨é‡è¯„ä¼°æ–¹æ³•

### 2.1 æ•°æ®è´¨é‡ç»´åº¦

**æ•°æ®è´¨é‡å…­å¤§ç»´åº¦**:

1. **å®Œæ•´æ€§ï¼ˆCompletenessï¼‰**: æ•°æ®æ˜¯å¦å®Œæ•´
2. **å‡†ç¡®æ€§ï¼ˆAccuracyï¼‰**: æ•°æ®æ˜¯å¦å‡†ç¡®
3. **ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰**: æ•°æ®æ˜¯å¦ä¸€è‡´
4. **åŠæ—¶æ€§ï¼ˆTimelinessï¼‰**: æ•°æ®æ˜¯å¦åŠæ—¶
5. **æœ‰æ•ˆæ€§ï¼ˆValidityï¼‰**: æ•°æ®æ˜¯å¦ç¬¦åˆè§„åˆ™
6. **å”¯ä¸€æ€§ï¼ˆUniquenessï¼‰**: æ•°æ®æ˜¯å¦å”¯ä¸€

### 2.2 æ•°æ®è´¨é‡è¯„ä¼°å®ç°

**å®Œæ•´æ€§è¯„ä¼°**:

```sql
-- åˆ›å»ºæ•°æ®è´¨é‡è¯„ä¼°å‡½æ•°
CREATE OR REPLACE FUNCTION assess_data_quality(
    p_table_name TEXT,
    p_schema_name TEXT DEFAULT 'public'
)
RETURNS TABLE (
    dimension TEXT,
    score NUMERIC,
    issues_count BIGINT,
    total_records BIGINT
) AS $$
BEGIN
    RETURN QUERY
    WITH quality_metrics AS (
        SELECT
            'completeness' AS dimension,
            COUNT(*) FILTER (WHERE required_field IS NOT NULL) * 100.0 / COUNT(*) AS score,
            COUNT(*) FILTER (WHERE required_field IS NULL) AS issues_count,
            COUNT(*) AS total_records
        FROM information_schema.tables t
        JOIN information_schema.columns c ON t.table_name = c.table_name
        WHERE t.table_schema = p_schema_name
          AND t.table_name = p_table_name
    )
    SELECT * FROM quality_metrics;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. æ•°æ®è´¨é‡ç›‘æ§

### 3.1 å®æ—¶ç›‘æ§åœºæ™¯

**ä¸šåŠ¡éœ€æ±‚**:

```text
åœºæ™¯ï¼šå®æ—¶æ•°æ®è´¨é‡ç›‘æ§
éœ€æ±‚ï¼š
1. å®æ—¶ç›‘æ§æ•°æ®è´¨é‡
2. è‡ªåŠ¨å‘Šè­¦
3. è´¨é‡æŠ¥å‘Š
4. è¶‹åŠ¿åˆ†æ
```

### 3.2 è‡ªåŠ¨åŒ–ç›‘æ§å®ç°

**ç›‘æ§é…ç½®**:

```sql
-- åˆ›å»ºæ•°æ®è´¨é‡ç›‘æ§è¡¨
CREATE TABLE data_quality_monitoring (
    id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    dimension TEXT NOT NULL,
    score NUMERIC NOT NULL,
    threshold NUMERIC DEFAULT 95.0,
    status TEXT CHECK (status IN ('PASS', 'WARN', 'FAIL')),
    checked_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç›‘æ§å‡½æ•°
CREATE OR REPLACE FUNCTION monitor_data_quality()
RETURNS void AS $$
DECLARE
    rec RECORD;
    quality_score NUMERIC;
BEGIN
    FOR rec IN SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'
    LOOP
        SELECT score INTO quality_score
        FROM assess_data_quality(rec.table_name);

        INSERT INTO data_quality_monitoring (table_name, dimension, score, status)
        VALUES (
            rec.table_name,
            'overall',
            quality_score,
            CASE
                WHEN quality_score >= 95 THEN 'PASS'
                WHEN quality_score >= 80 THEN 'WARN'
                ELSE 'FAIL'
            END
        );
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. æ•°æ®è¡€ç¼˜åˆ†æ

### 4.1 æ•°æ®è¡€ç¼˜è¿½è¸ª

**è¡€ç¼˜è¿½è¸ªå®ç°**:

```sql
-- åˆ›å»ºæ•°æ®è¡€ç¼˜è¡¨
CREATE TABLE data_lineage (
    id BIGSERIAL PRIMARY KEY,
    source_table TEXT NOT NULL,
    source_column TEXT,
    target_table TEXT NOT NULL,
    target_column TEXT,
    transformation TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è¡€ç¼˜æŸ¥è¯¢å‡½æ•°
CREATE OR REPLACE FUNCTION get_lineage(
    p_table_name TEXT,
    p_direction TEXT DEFAULT 'downstream'  -- 'upstream' or 'downstream'
)
RETURNS TABLE (
    level INT,
    table_name TEXT,
    column_name TEXT,
    transformation TEXT
) AS $$
BEGIN
    IF p_direction = 'downstream' THEN
        RETURN QUERY
        WITH RECURSIVE lineage AS (
            SELECT 0 AS level, p_table_name AS table_name, NULL::TEXT AS column_name, NULL::TEXT AS transformation
            UNION ALL
            SELECT l.level + 1, dl.target_table, dl.target_column, dl.transformation
            FROM data_lineage dl
            JOIN lineage l ON dl.source_table = l.table_name
        )
        SELECT * FROM lineage;
    ELSE
        RETURN QUERY
        WITH RECURSIVE lineage AS (
            SELECT 0 AS level, p_table_name AS table_name, NULL::TEXT AS column_name, NULL::TEXT AS transformation
            UNION ALL
            SELECT l.level + 1, dl.source_table, dl.source_column, dl.transformation
            FROM data_lineage dl
            JOIN lineage l ON dl.target_table = l.table_name
        )
        SELECT * FROM lineage;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. æ•°æ®ç›®å½•ç®¡ç†

### 5.1 å…ƒæ•°æ®ç®¡ç†

**å…ƒæ•°æ®ç›®å½•å®ç°**:

```sql
-- åˆ›å»ºæ•°æ®ç›®å½•è¡¨
CREATE TABLE data_catalog (
    id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    column_name TEXT,
    data_type TEXT,
    description TEXT,
    business_owner TEXT,
    technical_owner TEXT,
    classification TEXT,  -- 'PUBLIC', 'INTERNAL', 'CONFIDENTIAL', 'RESTRICTED'
    tags TEXT[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- è‡ªåŠ¨åŒæ­¥å…ƒæ•°æ®
CREATE OR REPLACE FUNCTION sync_metadata()
RETURNS void AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN
        SELECT
            t.table_name,
            c.column_name,
            c.data_type
        FROM information_schema.tables t
        JOIN information_schema.columns c ON t.table_name = c.table_name
        WHERE t.table_schema = 'public'
    LOOP
        INSERT INTO data_catalog (table_name, column_name, data_type)
        VALUES (rec.table_name, rec.column_name, rec.data_type)
        ON CONFLICT (table_name, column_name) DO UPDATE
        SET data_type = EXCLUDED.data_type,
            updated_at = NOW();
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. æ•°æ®åˆè§„æ€§ç®¡ç†

### 6.1 GDPRåˆè§„åœºæ™¯

**ä¸šåŠ¡éœ€æ±‚**:

```text
åœºæ™¯ï¼šGDPRåˆè§„ç®¡ç†
éœ€æ±‚ï¼š
1. æ•°æ®åˆ†ç±»
2. è®¿é—®æ§åˆ¶
3. æ•°æ®åˆ é™¤ï¼ˆè¢«é—å¿˜æƒï¼‰
4. æ•°æ®å¯¼å‡º
5. å®¡è®¡æ—¥å¿—
```

### 6.2 åˆè§„æ€§æ£€æŸ¥å®ç°

**GDPRåˆè§„æ£€æŸ¥**:

```sql
-- åˆ›å»ºåˆè§„æ€§æ£€æŸ¥è¡¨
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    check_type TEXT NOT NULL,  -- 'GDPR', 'HIPAA', 'SOC2'
    table_name TEXT NOT NULL,
    check_result TEXT,  -- 'PASS', 'FAIL', 'WARN'
    issues TEXT[],
    checked_at TIMESTAMPTZ DEFAULT NOW()
);

-- GDPRåˆè§„æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION check_gdpr_compliance()
RETURNS TABLE (
    table_name TEXT,
    compliance_status TEXT,
    issues TEXT[]
) AS $$
DECLARE
    issues_list TEXT[];
BEGIN
    RETURN QUERY
    SELECT
        dc.table_name,
        CASE
            WHEN dc.classification IS NULL THEN 'FAIL'
            WHEN dc.business_owner IS NULL THEN 'WARN'
            ELSE 'PASS'
        END AS compliance_status,
        ARRAY_AGG(
            CASE
                WHEN dc.classification IS NULL THEN 'Missing data classification'
                WHEN dc.business_owner IS NULL THEN 'Missing business owner'
            END
        ) FILTER (WHERE dc.classification IS NULL OR dc.business_owner IS NULL) AS issues
    FROM data_catalog dc
    GROUP BY dc.table_name, dc.classification, dc.business_owner;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. ç»¼åˆé€‰å‹æ¡ˆä¾‹

### 7.1 æ¡ˆä¾‹1ï¼šä¼ä¸šçº§æ•°æ®æ²»ç†ç³»ç»Ÿ

**ä¸šåŠ¡èƒŒæ™¯**:

- å¤§å‹ä¼ä¸šæ•°æ®æ²»ç†
- å¤šæ•°æ®æº
- ä¸¥æ ¼åˆè§„è¦æ±‚

**å®ç°æ–¹æ¡ˆ**:

```text
æ¶æ„è®¾è®¡ï¼š
1. æ•°æ®è´¨é‡ç›‘æ§ï¼ˆå®æ—¶ç›‘æ§ + å®šæœŸè¯„ä¼°ï¼‰
2. æ•°æ®è¡€ç¼˜è¿½è¸ªï¼ˆè‡ªåŠ¨è¿½è¸ª + æ‰‹åŠ¨è¡¥å……ï¼‰
3. æ•°æ®ç›®å½•ç®¡ç†ï¼ˆè‡ªåŠ¨åŒæ­¥ + ä¸šåŠ¡è¡¥å……ï¼‰
4. åˆè§„æ€§ç®¡ç†ï¼ˆGDPR + HIPAA + SOC2ï¼‰

å·¥å…·é€‰å‹ï¼š
- æ•°æ®è´¨é‡ï¼šPostgreSQLå†…ç½® + è‡ªå®šä¹‰å‡½æ•°
- æ•°æ®è¡€ç¼˜ï¼šProvSQLæ‰©å±•
- æ•°æ®ç›®å½•ï¼šPostgreSQLè¡¨ + å‰ç«¯ç•Œé¢
- åˆè§„æ€§ï¼šPostgreSQL RLS + å®¡è®¡æ—¥å¿—
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£

- [PostgreSQLæ•°æ®è´¨é‡æ–‡æ¡£](https://www.postgresql.org/docs/)
- [ProvSQLæ•°æ®æº¯æºæ‰©å±•](https://github.com/PierreSenellart/provsql)

### ç›¸å…³æ–‡æ¡£

- [æ•°æ®è´¨é‡ç®¡ç†æŒ‡å—](../17-æ•°æ®æ¨¡å‹è®¾è®¡/09.05-æ•°æ®è´¨é‡ç®¡ç†æŒ‡å—.md)
- [æ•°æ®æº¯æºä¸è¡€ç¼˜åˆ†æå®Œæ•´æŒ‡å—](../05-å®‰å…¨ä¸åˆè§„/ã€æ·±å…¥ã€‘æ•°æ®æº¯æºä¸è¡€ç¼˜åˆ†æå®Œæ•´æŒ‡å—.md)
- [æ•°æ®æ²»ç†æ¨¡å‹](../26-æ•°æ®ç®¡ç†/README.md)

---

## ğŸ“ æ›´æ–°æ—¥å¿—

- **2025-01**: åˆå§‹ç‰ˆæœ¬åˆ›å»º
  - å®Œæˆæ•°æ®æ²»ç†æ¡†æ¶
  - å®Œæˆæ•°æ®è´¨é‡è¯„ä¼°æ–¹æ³•
  - å®Œæˆæ•°æ®è´¨é‡ç›‘æ§
  - å®Œæˆæ•°æ®è¡€ç¼˜åˆ†æ
  - å®Œæˆæ•°æ®ç›®å½•ç®¡ç†
  - å®Œæˆæ•°æ®åˆè§„æ€§ç®¡ç†

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
