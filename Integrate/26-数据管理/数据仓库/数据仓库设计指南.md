# 数据仓库设计指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐ 高级

---

## 📋 目录

- [数据仓库设计指南](#数据仓库设计指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 数据仓库架构](#2-数据仓库架构)
    - [2.1 三层架构](#21-三层架构)
    - [2.2 数据流](#22-数据流)
  - [3. 星型模式设计](#3-星型模式设计)
    - [3.1 星型模式结构](#31-星型模式结构)
    - [3.2 星型模式优势](#32-星型模式优势)
  - [4. 雪花型模式设计](#4-雪花型模式设计)
    - [4.1 雪花型模式结构](#41-雪花型模式结构)
    - [4.2 雪花型模式优势](#42-雪花型模式优势)
    - [4.3 雪花型模式劣势](#43-雪花型模式劣势)
  - [5. 事实表设计](#5-事实表设计)
    - [5.1 事实表类型](#51-事实表类型)
    - [5.2 事实表设计原则](#52-事实表设计原则)
  - [6. 维度表设计](#6-维度表设计)
    - [6.1 维度表设计原则](#61-维度表设计原则)
    - [6.2 缓慢变化维度（SCD）](#62-缓慢变化维度scd)
  - [7. 最佳实践](#7-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [❌ 避免做法](#-避免做法)
  - [8. 数据仓库实施步骤](#8-数据仓库实施步骤)
    - [8.1 需求分析](#81-需求分析)
    - [8.2 数据模型设计](#82-数据模型设计)
    - [8.3 维度表实施](#83-维度表实施)
  - [9. 数据仓库性能优化](#9-数据仓库性能优化)
    - [9.1 分区策略](#91-分区策略)
    - [9.2 物化视图优化](#92-物化视图优化)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

数据仓库设计是构建高效分析系统的基础。PostgreSQL支持完整的数据仓库功能，包括：

- **多维数据模型** - 星型模式和雪花型模式
- **OLAP查询** - GROUP BY ROLLUP、CUBE、GROUPING SETS
- **物化视图** - 预计算聚合结果
- **分区策略** - 按时间或维度分区

---

## 2. 数据仓库架构

### 2.1 三层架构

```text
数据源层
  ↓
ETL层（提取、转换、加载）
  ↓
数据仓库层（星型/雪花型模式）
  ↓
OLAP层（查询和分析）
```

### 2.2 数据流

```text
源系统 → ETL → 数据仓库 → OLAP查询 → 报表/分析
```

---

## 3. 星型模式设计

### 3.1 星型模式结构

```sql
-- 事实表（中心）
CREATE TABLE fact_sales (
    time_id INT NOT NULL,
    product_id INT NOT NULL,
    customer_id INT NOT NULL,
    -- 度量
    sales_amount NUMERIC(12,2),
    quantity INT,
    profit_amount NUMERIC(12,2)
);

-- 维度表（围绕事实表）
CREATE TABLE dim_time (
    time_id INT PRIMARY KEY,
    date DATE,
    year INT,
    quarter INT,
    month INT,
    week INT,
    day_of_week INT
);

CREATE TABLE dim_product (
    product_id INT PRIMARY KEY,
    product_name TEXT,
    category_name TEXT,
    brand_name TEXT
);

CREATE TABLE dim_customer (
    customer_id INT PRIMARY KEY,
    customer_name TEXT,
    region_name TEXT,
    country_name TEXT
);
```

### 3.2 星型模式优势

- 查询性能好（JOIN少）
- 设计简单
- 易于理解
- 适合大多数场景

---

## 4. 雪花型模式设计

### 4.1 雪花型模式结构

```sql
-- 维度表进一步规范化
CREATE TABLE dim_product (
    product_id INT PRIMARY KEY,
    product_name TEXT,
    category_id INT REFERENCES dim_category(category_id)
);

CREATE TABLE dim_category (
    category_id INT PRIMARY KEY,
    category_name TEXT,
    department_id INT REFERENCES dim_department(department_id)
);

CREATE TABLE dim_department (
    department_id INT PRIMARY KEY,
    department_name TEXT
);
```

### 4.2 雪花型模式优势

- 数据规范化
- 存储空间节省
- 适合复杂维度

### 4.3 雪花型模式劣势

- JOIN多，查询较慢
- 设计复杂
- 维护成本高

---

## 5. 事实表设计

### 5.1 事实表类型

| 类型 | 说明 | 示例 |
| --- | --- | --- |
| **事务事实表** | 记录每个事务 | 销售订单 |
| **快照事实表** | 定期快照 | 库存快照 |
| **累积事实表** | 累积度量 | 账户余额 |

### 5.2 事实表设计原则

```sql
-- 1. 选择合适的事实表类型
-- 2. 确定粒度（最细粒度）
-- 3. 选择度量（可加性、半可加性、不可加性）
-- 4. 添加退化维度（如订单号）
-- 5. 使用代理键

CREATE TABLE fact_sales (
    -- 代理键
    sales_key BIGSERIAL PRIMARY KEY,
    -- 时间维度键
    time_id INT NOT NULL,
    -- 产品维度键
    product_id INT NOT NULL,
    -- 客户维度键
    customer_id INT NOT NULL,
    -- 度量（可加性）
    sales_amount NUMERIC(12,2) NOT NULL,
    quantity INT NOT NULL,
    -- 度量（半可加性）
    inventory_level INT,
    -- 退化维度
    order_number TEXT
);
```

---

## 6. 维度表设计

### 6.1 维度表设计原则

```sql
-- 1. 使用代理键
-- 2. 包含自然键（业务键）
-- 3. 添加缓慢变化维度处理
-- 4. 包含层次结构

CREATE TABLE dim_customer (
    -- 代理键
    customer_key INT PRIMARY KEY,
    -- 自然键
    customer_id INT UNIQUE NOT NULL,
    -- 属性
    customer_name TEXT,
    -- 层次结构
    region_name TEXT,
    country_name TEXT,
    -- SCD处理
    effective_date DATE,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT TRUE
);
```

### 6.2 缓慢变化维度（SCD）

- **SCD Type 1** - 覆盖历史值
- **SCD Type 2** - 保留历史版本
- **SCD Type 3** - 保留有限历史

---

## 7. 最佳实践

### ✅ 推荐做法

1. **选择合适的模式** - 大多数场景使用星型模式
2. **确定正确粒度** - 选择最细粒度
3. **使用代理键** - 提高性能和维护性
4. **合理分区** - 按时间分区事实表
5. **使用物化视图** - 预计算常用聚合

### ❌ 避免做法

1. **过度规范化** - 避免过度使用雪花型模式
2. **粒度不当** - 粒度太粗或太细都不好
3. **不使用索引** - 维度表必须有索引
4. **忽略SCD** - 需要处理维度变化

---

## 8. 数据仓库实施步骤

### 8.1 需求分析

```sql
-- 需求分析步骤：
-- 1. 识别业务需求
-- 2. 确定数据源
-- 3. 定义度量（KPI）
-- 4. 确定维度
-- 5. 确定粒度

-- 示例：销售数据仓库需求
-- 度量：销售额、数量、利润
-- 维度：时间、产品、客户、地区
-- 粒度：每个订单行
```

### 8.2 数据模型设计

```sql
-- 数据模型设计步骤：
-- 1. 设计事实表结构
-- 2. 设计维度表结构
-- 3. 确定关系
-- 4. 设计索引
-- 5. 设计分区策略

-- 创建事实表（带错误处理和性能测试）
CREATE TABLE IF NOT EXISTS fact_sales (
    sales_key BIGSERIAL PRIMARY KEY,
    time_id INT NOT NULL REFERENCES dim_time(time_id),
    product_id INT NOT NULL REFERENCES dim_product(product_id),
    customer_id INT NOT NULL REFERENCES dim_customer(customer_id),
    store_id INT NOT NULL REFERENCES dim_store(store_id),
    sales_amount NUMERIC(12,2) NOT NULL,
    quantity INT NOT NULL,
    profit_amount NUMERIC(12,2),
    discount_amount NUMERIC(12,2),
    order_number TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (time_id);

-- 创建索引
CREATE INDEX idx_fact_sales_time ON fact_sales (time_id);
CREATE INDEX idx_fact_sales_product ON fact_sales (product_id);
CREATE INDEX idx_fact_sales_customer ON fact_sales (customer_id);
CREATE INDEX idx_fact_sales_store ON fact_sales (store_id);
```

### 8.3 维度表实施

```sql
-- 时间维度表（带错误处理和性能测试）
CREATE TABLE IF NOT EXISTS dim_time (
    time_id INT PRIMARY KEY,
    date DATE NOT NULL UNIQUE,
    year INT NOT NULL,
    quarter INT NOT NULL,
    month INT NOT NULL,
    week INT NOT NULL,
    day_of_week INT NOT NULL,
    day_of_month INT NOT NULL,
    is_weekend BOOLEAN NOT NULL,
    is_holiday BOOLEAN DEFAULT FALSE,
    fiscal_year INT,
    fiscal_quarter INT
);

-- 创建索引
CREATE INDEX idx_dim_time_date ON dim_time (date);
CREATE INDEX idx_dim_time_year_month ON dim_time (year, month);

-- 填充时间维度（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION populate_time_dimension(
    p_start_date DATE,
    p_end_date DATE
)
RETURNS TABLE (
    inserted_count BIGINT
) AS $$
DECLARE
    current_date DATE;
    inserted_rows BIGINT;
BEGIN
    current_date := p_start_date;

    WHILE current_date <= p_end_date LOOP
        INSERT INTO dim_time (
            time_id,
            date,
            year,
            quarter,
            month,
            week,
            day_of_week,
            day_of_month,
            is_weekend,
            fiscal_year,
            fiscal_quarter
        )
        VALUES (
            to_char(current_date, 'YYYYMMDD')::INT,
            current_date,
            EXTRACT(YEAR FROM current_date),
            EXTRACT(QUARTER FROM current_date),
            EXTRACT(MONTH FROM current_date),
            EXTRACT(WEEK FROM current_date),
            EXTRACT(DOW FROM current_date),
            EXTRACT(DAY FROM current_date),
            EXTRACT(DOW FROM current_date) IN (0, 6),
            EXTRACT(YEAR FROM current_date),
            EXTRACT(QUARTER FROM current_date)
        )
        ON CONFLICT (date) DO NOTHING;

        current_date := current_date + INTERVAL '1 day';
    END LOOP;

    GET DIAGNOSTICS inserted_rows = ROW_COUNT;

    RETURN QUERY SELECT inserted_rows;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '填充时间维度失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行填充
SELECT * FROM populate_time_dimension('2020-01-01', '2030-12-31');
```

---

## 9. 数据仓库性能优化

### 9.1 分区策略

```sql
-- 按时间分区事实表（带错误处理和性能测试）
CREATE TABLE fact_sales_2024_01 PARTITION OF fact_sales
FOR VALUES FROM (20240101) TO (20240201);

CREATE TABLE fact_sales_2024_02 PARTITION OF fact_sales
FOR VALUES FROM (20240201) TO (20240301);

-- 自动创建分区函数
CREATE OR REPLACE FUNCTION create_fact_partitions(
    p_start_month DATE,
    p_month_count INT DEFAULT 12
)
RETURNS TABLE (
    partition_name TEXT,
    status TEXT
) AS $$
DECLARE
    i INT;
    partition_date DATE;
    partition_name TEXT;
    start_id INT;
    end_id INT;
BEGIN
    FOR i IN 0..p_month_count - 1 LOOP
        partition_date := date_trunc('month', p_start_month) + (i || ' months')::INTERVAL;
        partition_name := 'fact_sales_' || to_char(partition_date, 'YYYY_MM');
        start_id := to_char(partition_date, 'YYYYMMDD')::INT;
        end_id := to_char(partition_date + INTERVAL '1 month', 'YYYYMMDD')::INT;

        BEGIN
            EXECUTE format(
                'CREATE TABLE IF NOT EXISTS %I PARTITION OF fact_sales FOR VALUES FROM (%s) TO (%s)',
                partition_name,
                start_id,
                end_id
            );

            RETURN QUERY SELECT partition_name, 'CREATED'::TEXT;

        EXCEPTION
            WHEN duplicate_table THEN
                RETURN QUERY SELECT partition_name, 'EXISTS'::TEXT;
            WHEN OTHERS THEN
                RETURN QUERY SELECT partition_name, format('FAILED: %', SQLERRM)::TEXT;
        END;
    END LOOP;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行创建分区
SELECT * FROM create_fact_partitions('2024-01-01', 12);
```

### 9.2 物化视图优化

```sql
-- 创建物化视图（带错误处理和性能测试）
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_sales_summary AS
SELECT
    t.year,
    t.quarter,
    t.month,
    p.category_name,
    c.region_name,
    SUM(f.sales_amount) AS total_sales,
    SUM(f.quantity) AS total_quantity,
    SUM(f.profit_amount) AS total_profit,
    COUNT(*) AS transaction_count
FROM fact_sales f
JOIN dim_time t ON f.time_id = t.time_id
JOIN dim_product p ON f.product_id = p.product_id
JOIN dim_customer c ON f.customer_id = c.customer_id
GROUP BY t.year, t.quarter, t.month, p.category_name, c.region_name;

-- 创建唯一索引（支持CONCURRENT刷新）
CREATE UNIQUE INDEX IF NOT EXISTS mv_sales_summary_idx ON mv_sales_summary
(year, quarter, month, category_name, region_name);

-- 刷新物化视图函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION refresh_sales_summary()
RETURNS TABLE (
    refresh_status TEXT,
    refresh_duration INTERVAL
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
BEGIN
    start_time := clock_timestamp();

    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary;

    end_time := clock_timestamp();

    RETURN QUERY SELECT
        'SUCCESS'::TEXT,
        end_time - start_time;

EXCEPTION
    WHEN OTHERS THEN
        RETURN QUERY SELECT
            format('FAILED: %', SQLERRM)::TEXT,
            NULL::INTERVAL;
END;
$$ LANGUAGE plpgsql;

-- 执行刷新
SELECT * FROM refresh_sales_summary();
```

---

## 📚 相关文档

- [数据库数据仓库模型-OLAP查询与多维分析的形式化.md](./数据库数据仓库模型-OLAP查询与多维分析的形式化.md) - 数据仓库模型理论
- [数据库数据集成模型-ETL流程与数据转换的形式化.md](./数据库数据集成模型-ETL流程与数据转换的形式化.md) - ETL流程理论
- [26-数据管理/README.md](../README.md) - 数据管理主题

---

**最后更新**: 2025年1月
