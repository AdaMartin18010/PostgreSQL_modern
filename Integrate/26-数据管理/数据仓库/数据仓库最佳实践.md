# 数据仓库最佳实践

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [数据仓库最佳实践](#数据仓库最佳实践)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 设计最佳实践](#2-设计最佳实践)
    - [2.1 模式选择](#21-模式选择)
    - [2.2 粒度设计](#22-粒度设计)
    - [2.3 维度设计](#23-维度设计)
  - [3. 性能最佳实践](#3-性能最佳实践)
    - [3.1 索引策略](#31-索引策略)
    - [3.2 物化视图](#32-物化视图)
    - [3.3 分区策略](#33-分区策略)
  - [4. 维护最佳实践](#4-维护最佳实践)
    - [4.1 数据质量](#41-数据质量)
    - [4.2 性能监控](#42-性能监控)
    - [4.3 定期维护](#43-定期维护)
  - [5. 安全最佳实践](#5-安全最佳实践)
    - [5.1 访问控制](#51-访问控制)
    - [5.2 数据脱敏](#52-数据脱敏)
    - [5.3 审计日志](#53-审计日志)
  - [6. 数据质量最佳实践](#6-数据质量最佳实践)
    - [6.1 数据质量检查](#61-数据质量检查)
    - [6.2 数据质量监控](#62-数据质量监控)
    - [6.3 数据质量告警](#63-数据质量告警)
  - [7. 性能优化最佳实践](#7-性能优化最佳实践)
    - [7.1 查询优化](#71-查询优化)
    - [7.2 并行查询优化](#72-并行查询优化)
    - [7.3 统计信息优化](#73-统计信息优化)
  - [8. 容量规划最佳实践](#8-容量规划最佳实践)
    - [8.1 存储容量规划](#81-存储容量规划)
    - [8.2 增长预测](#82-增长预测)
  - [9. 备份恢复最佳实践](#9-备份恢复最佳实践)
    - [9.1 备份策略](#91-备份策略)
    - [9.2 恢复测试](#92-恢复测试)
  - [10. 监控告警最佳实践](#10-监控告警最佳实践)
    - [10.1 性能监控](#101-性能监控)
    - [10.2 告警配置](#102-告警配置)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

数据仓库最佳实践是构建高效、可靠数据仓库的关键。本文档总结PostgreSQL数据仓库的最佳实践。

---

## 2. 设计最佳实践

### 2.1 模式选择

- ✅ **优先使用星型模式** - 大多数场景性能更好
- ✅ **合理使用雪花型模式** - 只在维度层次很深时使用
- ✅ **混合模式** - 部分维度星型，部分维度雪花型

### 2.2 粒度设计

- ✅ **选择最细粒度** - 支持所有分析需求
- ✅ **避免过度聚合** - 保留原始数据
- ✅ **考虑未来需求** - 粒度要足够细

### 2.3 维度设计

- ✅ **使用代理键** - 提高性能和可维护性
- ✅ **处理SCD** - 根据需求选择SCD类型
- ✅ **层次结构清晰** - 便于OLAP操作

---

## 3. 性能最佳实践

### 3.1 索引策略

```sql
-- 为所有维度键创建索引
CREATE INDEX idx_fact_sales_time ON fact_sales (time_id);
CREATE INDEX idx_fact_sales_product ON fact_sales (product_id);
CREATE INDEX idx_fact_sales_customer ON fact_sales (customer_id);

-- 为常用查询组合创建复合索引
CREATE INDEX idx_fact_sales_time_product ON fact_sales (time_id, product_id);
```

### 3.2 物化视图

```sql
-- 为常用查询创建物化视图
CREATE MATERIALIZED VIEW mv_sales_summary AS
SELECT
    t.year,
    t.quarter,
    p.category_name,
    SUM(f.sales_amount) AS total_sales
FROM fact_sales f
JOIN dim_time t ON f.time_id = t.time_id
JOIN dim_product p ON f.product_id = p.product_id
GROUP BY t.year, t.quarter, p.category_name;

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary;
```

### 3.3 分区策略

```sql
-- 按时间分区事实表
CREATE TABLE fact_sales (
    time_id INT NOT NULL,
    ...
) PARTITION BY RANGE (time_id);

-- 按月分区
CREATE TABLE fact_sales_2024_01 PARTITION OF fact_sales
    FOR VALUES FROM (20240101) TO (20240201);
```

---

## 4. 维护最佳实践

### 4.1 数据质量

- ✅ **数据验证** - 在ETL阶段验证数据
- ✅ **数据清洗** - 处理NULL、重复、异常值
- ✅ **数据监控** - 监控数据质量指标

### 4.2 性能监控

```sql
-- 监控查询性能
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time
FROM pg_stat_statements
WHERE query LIKE '%fact_sales%'
ORDER BY mean_exec_time DESC;
```

### 4.3 定期维护

```sql
-- 定期VACUUM
VACUUM ANALYZE fact_sales;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary;

-- 更新统计信息
ANALYZE fact_sales;
```

---

## 5. 安全最佳实践

### 5.1 访问控制

```sql
-- 创建只读用户
CREATE USER dw_readonly WITH PASSWORD 'strong_password';
GRANT SELECT ON ALL TABLES IN SCHEMA dw TO dw_readonly;
```

### 5.2 数据脱敏

```sql
-- 对敏感数据进行脱敏
CREATE VIEW v_sales_masked AS
SELECT
    time_id,
    product_id,
    CASE
        WHEN customer_id IS NOT NULL THEN '***'
        ELSE NULL
    END AS customer_id,
    sales_amount
FROM fact_sales;
```

### 5.3 审计日志

```sql
-- 创建审计日志表
CREATE TABLE dw_audit_log (
    log_id SERIAL PRIMARY KEY,
    user_name TEXT,
    action_type TEXT,
    table_name TEXT,
    query_text TEXT,
    execution_time INTERVAL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建审计触发器函数
CREATE OR REPLACE FUNCTION audit_dw_access()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO dw_audit_log (user_name, action_type, table_name, query_text)
    VALUES (
        current_user,
        TG_OP,
        TG_TABLE_NAME,
        current_query()
    );
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 为关键表创建审计触发器
CREATE TRIGGER audit_fact_sales
AFTER INSERT OR UPDATE OR DELETE ON fact_sales
FOR EACH STATEMENT
EXECUTE FUNCTION audit_dw_access();
```

---

## 6. 数据质量最佳实践

### 6.1 数据质量检查

```sql
-- 创建数据质量检查表
CREATE TABLE dw_data_quality (
    check_id SERIAL PRIMARY KEY,
    table_name TEXT,
    check_type TEXT,
    check_rule TEXT,
    check_result TEXT,
    error_count INT,
    check_time TIMESTAMPTZ DEFAULT NOW()
);

-- 数据质量检查函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION check_data_quality(
    p_table_name TEXT,
    p_check_type TEXT
)
RETURNS TABLE (
    check_result TEXT,
    error_count BIGINT
) AS $$
DECLARE
    v_sql TEXT;
    v_error_count BIGINT;
BEGIN
    CASE p_check_type
        WHEN 'null_check' THEN
            -- 检查NULL值
            EXECUTE format(
                'SELECT COUNT(*) FROM %I WHERE %I IS NULL',
                p_table_name,
                'customer_id'  -- 示例字段
            ) INTO v_error_count;

        WHEN 'duplicate_check' THEN
            -- 检查重复值
            EXECUTE format(
                'SELECT COUNT(*) - COUNT(DISTINCT %I) FROM %I',
                'business_key',  -- 示例字段
                p_table_name
            ) INTO v_error_count;

        WHEN 'range_check' THEN
            -- 检查范围值
            EXECUTE format(
                'SELECT COUNT(*) FROM %I WHERE sales_amount < 0 OR sales_amount > 1000000',
                p_table_name
            ) INTO v_error_count;

        ELSE
            RAISE EXCEPTION '未知的检查类型: %', p_check_type;
    END CASE;

    RETURN QUERY SELECT
        CASE
            WHEN v_error_count = 0 THEN 'PASS'
            ELSE 'FAIL'
        END,
        v_error_count;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '数据质量检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 执行数据质量检查
SELECT * FROM check_data_quality('fact_sales', 'null_check');
SELECT * FROM check_data_quality('fact_sales', 'duplicate_check');
SELECT * FROM check_data_quality('fact_sales', 'range_check');
```

### 6.2 数据质量监控

```sql
-- 创建数据质量监控视图
CREATE OR REPLACE VIEW v_data_quality_summary AS
SELECT
    table_name,
    check_type,
    COUNT(*) AS check_count,
    SUM(CASE WHEN check_result = 'FAIL' THEN 1 ELSE 0 END) AS fail_count,
    ROUND(100.0 * SUM(CASE WHEN check_result = 'FAIL' THEN 1 ELSE 0 END) / COUNT(*), 2) AS fail_rate,
    MAX(check_time) AS last_check_time
FROM dw_data_quality
WHERE check_time > NOW() - INTERVAL '7 days'
GROUP BY table_name, check_type
ORDER BY fail_rate DESC;

-- 查询数据质量摘要
SELECT * FROM v_data_quality_summary;
```

### 6.3 数据质量告警

```sql
-- 数据质量告警函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION check_data_quality_alerts()
RETURNS TABLE (
    table_name TEXT,
    check_type TEXT,
    fail_rate NUMERIC,
    alert_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        dq.table_name,
        dq.check_type,
        ROUND(100.0 * SUM(CASE WHEN dq.check_result = 'FAIL' THEN 1 ELSE 0 END) / COUNT(*), 2) AS fail_rate,
        CASE
            WHEN ROUND(100.0 * SUM(CASE WHEN dq.check_result = 'FAIL' THEN 1 ELSE 0 END) / COUNT(*), 2) > 10 THEN 'CRITICAL'
            WHEN ROUND(100.0 * SUM(CASE WHEN dq.check_result = 'FAIL' THEN 1 ELSE 0 END) / COUNT(*), 2) > 5 THEN 'WARNING'
            ELSE 'INFO'
        END AS alert_level
    FROM dw_data_quality dq
    WHERE dq.check_time > NOW() - INTERVAL '24 hours'
    GROUP BY dq.table_name, dq.check_type
    HAVING ROUND(100.0 * SUM(CASE WHEN dq.check_result = 'FAIL' THEN 1 ELSE 0 END) / COUNT(*), 2) > 1
    ORDER BY fail_rate DESC;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '数据质量告警检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 查询数据质量告警
SELECT * FROM check_data_quality_alerts();
```

---

## 7. 性能优化最佳实践

### 7.1 查询优化

```sql
-- 查询优化：使用EXPLAIN ANALYZE分析查询计划
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    t.year,
    t.quarter,
    p.category_name,
    SUM(f.sales_amount) AS total_sales
FROM fact_sales f
JOIN dim_time t ON f.time_id = t.time_id
JOIN dim_product p ON f.product_id = p.product_id
WHERE t.year = 2024
GROUP BY t.year, t.quarter, p.category_name;

-- 优化建议：
-- 1. 确保所有JOIN字段都有索引
-- 2. 使用分区裁剪减少扫描数据量
-- 3. 考虑使用物化视图预计算聚合
```

### 7.2 并行查询优化

```sql
-- 启用并行查询
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET parallel_workers = 4;

-- 设置并行查询阈值
ALTER SYSTEM SET min_parallel_table_scan_size = '8MB';
ALTER SYSTEM SET min_parallel_index_scan_size = '512KB';

-- 验证并行查询配置
SELECT name, setting, unit
FROM pg_settings
WHERE name LIKE '%parallel%'
ORDER BY name;
```

### 7.3 统计信息优化

```sql
-- 更新统计信息（带错误处理和性能测试）
DO $$
DECLARE
    table_rec RECORD;
    analyze_count INT := 0;
BEGIN
    FOR table_rec IN
        SELECT schemaname, tablename
        FROM pg_tables
        WHERE schemaname = 'dw'
          AND tablename LIKE 'fact_%'
    LOOP
        BEGIN
            EXECUTE format('ANALYZE %I.%I', table_rec.schemaname, table_rec.tablename);
            analyze_count := analyze_count + 1;
            RAISE NOTICE '已分析表: %.%', table_rec.schemaname, table_rec.tablename;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '分析表 %.% 失败: %', table_rec.schemaname, table_rec.tablename, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '共分析了 % 个表', analyze_count;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '更新统计信息失败: %', SQLERRM;
END $$;
```

---

## 8. 容量规划最佳实践

### 8.1 存储容量规划

```sql
-- 监控表大小（带错误处理和性能测试）
DO $$
DECLARE
    table_rec RECORD;
    total_size BIGINT := 0;
BEGIN
    RAISE NOTICE '数据仓库表大小统计:';
    RAISE NOTICE '========================================';

    FOR table_rec IN
        SELECT
            schemaname,
            tablename,
            pg_size_pretty(pg_total_relation_size(schemaname || '.' || tablename)) AS size,
            pg_total_relation_size(schemaname || '.' || tablename) AS size_bytes
        FROM pg_tables
        WHERE schemaname = 'dw'
        ORDER BY pg_total_relation_size(schemaname || '.' || tablename) DESC
    LOOP
        RAISE NOTICE '表: %.% | 大小: %', table_rec.schemaname, table_rec.tablename, table_rec.size;
        total_size := total_size + table_rec.size_bytes;
    END LOOP;

    RAISE NOTICE '========================================';
    RAISE NOTICE '总大小: %', pg_size_pretty(total_size);

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '监控表大小失败: %', SQLERRM;
END $$;
```

### 8.2 增长预测

```sql
-- 创建表增长历史记录表
CREATE TABLE IF NOT EXISTS dw_table_growth_history (
    record_id SERIAL PRIMARY KEY,
    table_name TEXT,
    table_size BIGINT,
    record_time TIMESTAMPTZ DEFAULT NOW()
);

-- 记录表大小增长
INSERT INTO dw_table_growth_history (table_name, table_size)
SELECT
    tablename,
    pg_total_relation_size('dw.' || tablename)
FROM pg_tables
WHERE schemaname = 'dw';

-- 分析表增长趋势
SELECT
    table_name,
    record_time,
    pg_size_pretty(table_size) AS size,
    table_size - LAG(table_size) OVER (PARTITION BY table_name ORDER BY record_time) AS growth_bytes,
    pg_size_pretty(table_size - LAG(table_size) OVER (PARTITION BY table_name ORDER BY record_time)) AS growth_size
FROM dw_table_growth_history
WHERE record_time > NOW() - INTERVAL '30 days'
ORDER BY table_name, record_time DESC;
```

---

## 9. 备份恢复最佳实践

### 9.1 备份策略

```sql
-- 数据仓库备份策略
-- 1. 全量备份：每周一次
-- 2. 增量备份：每天一次
-- 3. 关键表备份：每天多次

-- 备份脚本示例（使用pg_dump）
-- pg_dump -Fc -f dw_backup_$(date +%Y%m%d).dump -n dw database_name
```

### 9.2 恢复测试

```sql
-- 恢复测试检查清单
-- 1. 定期测试备份恢复流程
-- 2. 验证数据完整性
-- 3. 测试恢复时间（RTO）
-- 4. 测试数据丢失容忍度（RPO）
```

---

## 10. 监控告警最佳实践

### 10.1 性能监控

```sql
-- 创建性能监控视图
CREATE OR REPLACE VIEW v_dw_performance_monitoring AS
SELECT
    datname,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    ROUND(100.0 * blks_hit / NULLIF(blks_hit + blks_read, 0), 2) AS cache_hit_ratio,
    temp_files,
    temp_bytes,
    deadlocks,
    conflicts
FROM pg_stat_database
WHERE datname = current_database();

-- 查询性能监控数据
SELECT * FROM v_dw_performance_monitoring;
```

### 10.2 告警配置

```sql
-- 性能告警函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION check_dw_alerts()
RETURNS TABLE (
    alert_type TEXT,
    alert_message TEXT,
    alert_level TEXT
) AS $$
DECLARE
    cache_hit_ratio NUMERIC;
    deadlock_count BIGINT;
    conflict_count BIGINT;
BEGIN
    -- 检查缓存命中率
    SELECT
        ROUND(100.0 * blks_hit / NULLIF(blks_hit + blks_read, 0), 2)
    INTO cache_hit_ratio
    FROM pg_stat_database
    WHERE datname = current_database();

    IF cache_hit_ratio < 90 THEN
        RETURN QUERY SELECT
            'cache_hit_ratio'::TEXT,
            format('缓存命中率过低: %%', cache_hit_ratio)::TEXT,
            'WARNING'::TEXT;
    END IF;

    -- 检查死锁
    SELECT deadlocks INTO deadlock_count
    FROM pg_stat_database
    WHERE datname = current_database();

    IF deadlock_count > 10 THEN
        RETURN QUERY SELECT
            'deadlock'::TEXT,
            format('死锁次数过多: %', deadlock_count)::TEXT,
            'CRITICAL'::TEXT;
    END IF;

    -- 检查冲突
    SELECT conflicts INTO conflict_count
    FROM pg_stat_database
    WHERE datname = current_database();

    IF conflict_count > 100 THEN
        RETURN QUERY SELECT
            'conflict'::TEXT,
            format('冲突次数过多: %', conflict_count)::TEXT,
            'WARNING'::TEXT;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '告警检查失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 查询告警
SELECT * FROM check_dw_alerts();
```

---

## 📚 相关文档

- [数据仓库设计指南.md](./数据仓库设计指南.md) - 数据仓库设计
- [OLAP查询优化.md](./OLAP查询优化.md) - OLAP查询优化
- [星型雪花模型.md](./星型雪花模型.md) - 模型设计
- [ETL流程设计.md](./ETL流程设计.md) - ETL流程设计
- [26-数据管理/README.md](../README.md) - 数据管理主题

---

**最后更新**: 2025年1月
