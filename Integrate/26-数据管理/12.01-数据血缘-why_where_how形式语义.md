---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\12-æ•°æ®ç®¡ç†æ¨¡å‹\12.01-æ•°æ®è¡€ç¼˜-why_where_howå½¢å¼è¯­ä¹‰.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ•°æ®è¡€ç¼˜-why_where_howå½¢å¼è¯­ä¹‰

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®è¡€ç¼˜-why\_where\_howå½¢å¼è¯­ä¹‰](#æ•°æ®è¡€ç¼˜-why_where_howå½¢å¼è¯­ä¹‰)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 æ•°æ®è¡€ç¼˜å·¥ä½œåŸç†æ¦‚è¿°](#10-æ•°æ®è¡€ç¼˜å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 WHEREè¯­ä¹‰](#21-whereè¯­ä¹‰)
    - [2.2 WHYè¯­ä¹‰](#22-whyè¯­ä¹‰)
    - [2.3 HOWè¯­ä¹‰](#23-howè¯­ä¹‰)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 è¡€ç¼˜è¯­ä¹‰å½¢å¼åŒ–](#31-è¡€ç¼˜è¯­ä¹‰å½¢å¼åŒ–)
  - [4. å®šç†ä¸è¯æ˜](#4-å®šç†ä¸è¯æ˜)
    - [4.1 è¡€ç¼˜å®Œæ•´æ€§å®šç†](#41-è¡€ç¼˜å®Œæ•´æ€§å®šç†)
    - [4.2 è¡€ç¼˜ä¼ é€’æ€§å®šç†](#42-è¡€ç¼˜ä¼ é€’æ€§å®šç†)
  - [5. å®é™…åº”ç”¨](#5-å®é™…åº”ç”¨)
    - [5.1 PostgreSQL 18æ•°æ®è¡€ç¼˜å®ç°](#51-postgresql-18æ•°æ®è¡€ç¼˜å®ç°)
      - [5.1.1 å®Œæ•´è¡€ç¼˜æ¨¡å‹å®ç°](#511-å®Œæ•´è¡€ç¼˜æ¨¡å‹å®ç°)
      - [5.1.2 è¡€ç¼˜æŸ¥è¯¢å‡½æ•°](#512-è¡€ç¼˜æŸ¥è¯¢å‡½æ•°)
      - [5.1.3 å®Œæ•´è¡€ç¼˜æŸ¥è¯¢](#513-å®Œæ•´è¡€ç¼˜æŸ¥è¯¢)
    - [5.2 å®é™…åº”ç”¨åœºæ™¯](#52-å®é™…åº”ç”¨åœºæ™¯)
      - [åœºæ™¯1ï¼šæ•°æ®ä»“åº“è¡€ç¼˜è¿½è¸ª](#åœºæ™¯1æ•°æ®ä»“åº“è¡€ç¼˜è¿½è¸ª)
      - [åœºæ™¯2ï¼šETLæµç¨‹è¡€ç¼˜è¿½è¸ª](#åœºæ™¯2etlæµç¨‹è¡€ç¼˜è¿½è¸ª)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)
    - [6.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#61-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [7.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#71-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [7.2 PostgreSQLå®ç°ç›¸å…³](#72-postgresqlå®ç°ç›¸å…³)
    - [7.3 ç›¸å…³æ–‡æ¡£](#73-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 æ•°æ®è¡€ç¼˜å·¥ä½œåŸç†æ¦‚è¿°

**æ•°æ®è¡€ç¼˜**ï¼š

æ•°æ®è¡€ç¼˜ï¼ˆData Lineageï¼‰æ˜¯æ•°æ®æ²»ç†çš„æ ¸å¿ƒæ¦‚å¿µï¼Œé€šè¿‡è¿½è¸ªæ•°æ®çš„æ¥æºï¼ˆWHEREï¼‰ã€åŸå› ï¼ˆWHYï¼‰å’Œè½¬æ¢æ–¹å¼ï¼ˆHOWï¼‰æ¥å»ºç«‹å®Œæ•´çš„æ•°æ®æº¯æºä½“ç³»ã€‚å®ƒå¸®åŠ©å›ç­”ä¸‰ä¸ªå…³é”®é—®é¢˜ï¼š

1. **WHERE**ï¼šæ•°æ®æ¥è‡ªå“ªé‡Œï¼Ÿï¼ˆæ•°æ®æ¥æºï¼‰
2. **WHY**ï¼šä¸ºä»€ä¹ˆéœ€è¦è¿™äº›æ•°æ®ï¼Ÿï¼ˆä¸šåŠ¡åŸå› å’Œä¾èµ–å…³ç³»ï¼‰
3. **HOW**ï¼šæ•°æ®æ˜¯å¦‚ä½•è½¬æ¢çš„ï¼Ÿï¼ˆè½¬æ¢é€»è¾‘å’Œå¤„ç†æ­¥éª¤ï¼‰

**æ ¸å¿ƒå·¥ä½œåŸç†**ï¼š

1. **WHEREè¯­ä¹‰**ï¼šè®°å½•æ•°æ®çš„ç‰©ç†æ¥æºï¼ŒåŒ…æ‹¬æºç³»ç»Ÿã€æºè¡¨ã€æºå­—æ®µç­‰
2. **WHYè¯­ä¹‰**ï¼šè®°å½•æ•°æ®çš„ä¸šåŠ¡åŸå› ï¼ŒåŒ…æ‹¬ä¾èµ–å…³ç³»ã€ä½¿ç”¨ç›®çš„ã€ä¸šåŠ¡è§„åˆ™ç­‰
3. **HOWè¯­ä¹‰**ï¼šè®°å½•æ•°æ®çš„è½¬æ¢è¿‡ç¨‹ï¼ŒåŒ…æ‹¬è½¬æ¢æ“ä½œã€è®¡ç®—é€»è¾‘ã€å¤„ç†æ­¥éª¤ç­‰
4. **è¡€ç¼˜å›¾æ„å»º**ï¼šåŸºäºWHERE/WHY/HOWä¿¡æ¯æ„å»ºæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œè¡¨ç¤ºæ•°æ®æµå‘
5. **æº¯æºæŸ¥è¯¢**ï¼šæ”¯æŒæ­£å‘æº¯æºï¼ˆä»æ•°æ®è¿½æº¯åˆ°æ¥æºï¼‰å’Œåå‘æº¯æºï¼ˆä»æ•°æ®è¿½æº¯åˆ°ä½¿ç”¨ï¼‰

**è¡€ç¼˜è¯­ä¹‰æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((æ•°æ®è¡€ç¼˜))
    WHERE
      æ•°æ®æ¥æº
      ä¸Šæ¸¸ç³»ç»Ÿ
      æºè¡¨å­—æ®µ
    WHY
      ä¸šåŠ¡åŸå› 
      ä¾èµ–å…³ç³»
      ä½¿ç”¨ç›®çš„
    HOW
      è½¬æ¢é€»è¾‘
      è®¡ç®—è¿‡ç¨‹
      å¤„ç†æ­¥éª¤
```

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **WHEREè¯­ä¹‰**ï¼šæ•°æ®æ¥æºçš„å½¢å¼åŒ–
- **WHYè¯­ä¹‰**ï¼šæ•°æ®ä¾èµ–çš„åŸå› 
- **HOWè¯­ä¹‰**ï¼šæ•°æ®è½¬æ¢çš„æ–¹å¼
- **å®é™…åº”ç”¨**ï¼šæ•°æ®è¡€ç¼˜ç³»ç»Ÿ

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 WHEREè¯­ä¹‰

**æ•°æ®æ¥æº**ï¼š

```haskell
-- WHEREè¯­ä¹‰
where :: Data -> Source
where data =
    Source {
        system = sourceSystem(data),
        table = sourceTable(data),
        column = sourceColumn(data)
    }
```

### 2.2 WHYè¯­ä¹‰

**ä¾èµ–åŸå› **ï¼š

```haskell
-- WHYè¯­ä¹‰
why :: Data -> [Dependency]
why data =
    [dep | dep <- dependencies, dependsOn(data, dep)]
```

### 2.3 HOWè¯­ä¹‰

**è½¬æ¢æ–¹å¼**ï¼š

```haskell
-- HOWè¯­ä¹‰
how :: Data -> Transformation
how data =
    Transformation {
        operation = transformationOp(data),
        steps = transformationSteps(data)
    }
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 è¡€ç¼˜è¯­ä¹‰å½¢å¼åŒ–

**è¡€ç¼˜è¯­ä¹‰**ï¼š

```haskell
-- è¡€ç¼˜è¯­ä¹‰å½¢å¼åŒ–
Lineage = (where, why, how)
where
    where: Data -> Source
    why: Data -> [Dependency]
    how: Data -> Transformation
```

---

## 4. å®šç†ä¸è¯æ˜

### 4.1 è¡€ç¼˜å®Œæ•´æ€§å®šç†

**å®šç†1ï¼ˆè¡€ç¼˜å®Œæ•´æ€§ï¼‰**ï¼š

å¦‚æœè¡€ç¼˜ç³»ç»Ÿå®Œæ•´è®°å½•WHERE/WHY/HOWä¸‰ä¸ªç»´åº¦çš„ä¿¡æ¯ï¼Œåˆ™å¯ä»¥å®ç°å®Œæ•´çš„æ•°æ®æº¯æºï¼Œå³å¯¹äºä»»æ„æ•°æ®é¡¹ï¼Œå¯ä»¥è¿½æº¯åˆ°å…¶æ‰€æœ‰æ¥æºå’Œè½¬æ¢è¿‡ç¨‹ã€‚

**è¯æ˜**ï¼š

**åŸºç¡€æƒ…å†µ**ï¼š

- è®¾æ•°æ®é¡¹ `d` æ˜¯æºæ•°æ®ï¼ˆæ— ä¸Šæ¸¸æ¥æºï¼‰
- WHEREè¯­ä¹‰è®°å½•ï¼š`where(d) = Source(system, table, column)`
- WHYè¯­ä¹‰è®°å½•ï¼š`why(d) = []`ï¼ˆç©ºä¾èµ–åˆ—è¡¨ï¼‰
- HOWè¯­ä¹‰è®°å½•ï¼š`how(d) = Identity`ï¼ˆæ’ç­‰è½¬æ¢ï¼‰
- å› æ­¤ï¼Œæºæ•°æ®çš„è¡€ç¼˜ä¿¡æ¯æ˜¯å®Œæ•´çš„

**å½’çº³å‡è®¾**ï¼š

- å‡è®¾å¯¹äºæ‰€æœ‰ä¸Šæ¸¸æ•°æ®é¡¹ `d'`ï¼Œå…¶è¡€ç¼˜ä¿¡æ¯æ˜¯å®Œæ•´çš„

**å½’çº³æ­¥éª¤**ï¼š

1. è®¾æ•°æ®é¡¹ `d` ç”±ä¸Šæ¸¸æ•°æ®é¡¹ `dâ‚, ..., dâ‚™` é€šè¿‡è½¬æ¢ `T` ç”Ÿæˆ
2. WHEREè¯­ä¹‰ï¼š`where(d) = {where(dâ‚), ..., where(dâ‚™)}`ï¼ˆæ‰€æœ‰ä¸Šæ¸¸æ¥æºï¼‰
3. WHYè¯­ä¹‰ï¼š`why(d) = {dâ‚, ..., dâ‚™} âˆª âˆªáµ¢ why(dáµ¢)`ï¼ˆç›´æ¥ä¾èµ–å’Œé—´æ¥ä¾èµ–ï¼‰
4. HOWè¯­ä¹‰ï¼š`how(d) = T âˆ˜ (how(dâ‚), ..., how(dâ‚™))`ï¼ˆè½¬æ¢ç»„åˆï¼‰
5. ç”±äºæ‰€æœ‰ä¸Šæ¸¸æ•°æ®é¡¹çš„è¡€ç¼˜ä¿¡æ¯å®Œæ•´ï¼ˆå½’çº³å‡è®¾ï¼‰ï¼Œå› æ­¤ `d` çš„è¡€ç¼˜ä¿¡æ¯ä¹Ÿå®Œæ•´

**ç»“è®º**ï¼š
ç”±ç»“æ„å½’çº³æ³•ï¼Œå¦‚æœè¡€ç¼˜ç³»ç»Ÿå®Œæ•´è®°å½•WHERE/WHY/HOWï¼Œåˆ™å¯ä»¥å®ç°å®Œæ•´çš„æ•°æ®æº¯æºï¼Œè¯æ¯•ã€‚

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[è¡€ç¼˜å®Œæ•´æ€§å®šç†] --> B[åŸºç¡€æƒ…å†µï¼šæºæ•°æ®]
    A --> C[å½’çº³å‡è®¾ï¼šä¸Šæ¸¸æ•°æ®å®Œæ•´]
    A --> D[å½’çº³æ­¥éª¤ï¼šç»„åˆæ•°æ®]
    B --> E[WHERE/WHY/HOWå®Œæ•´]
    C --> F[æ‰€æœ‰ä¸Šæ¸¸æ•°æ®å®Œæ•´]
    D --> G[WHERE = ä¸Šæ¸¸æ¥æºé›†åˆ]
    D --> H[WHY = ä¾èµ–ä¼ é€’é—­åŒ…]
    D --> I[HOW = è½¬æ¢ç»„åˆ]
    F --> J[ç»„åˆæ•°æ®å®Œæ•´]
    E --> K[ç»“è®ºï¼šå®Œæ•´æº¯æº]
    J --> K

    style A fill:#FFD700
    style K fill:#90EE90
```

### 4.2 è¡€ç¼˜ä¼ é€’æ€§å®šç†

**å®šç†2ï¼ˆè¡€ç¼˜ä¼ é€’æ€§ï¼‰**ï¼š

å¦‚æœæ•°æ®é¡¹ `dâ‚ƒ` ä¾èµ–äº `dâ‚‚`ï¼Œ`dâ‚‚` ä¾èµ–äº `dâ‚`ï¼Œåˆ™ `dâ‚ƒ` çš„è¡€ç¼˜ä¿¡æ¯åŒ…å« `dâ‚` çš„ä¿¡æ¯ã€‚

**è¯æ˜**ï¼š

1. ç”±å®šä¹‰ï¼š`dâ‚‚ âˆˆ why(dâ‚ƒ)` ä¸” `dâ‚ âˆˆ why(dâ‚‚)`
2. WHYè¯­ä¹‰çš„ä¼ é€’æ€§ï¼š`why(dâ‚ƒ) = {dâ‚‚} âˆª why(dâ‚‚)`
3. å› æ­¤ï¼š`dâ‚ âˆˆ why(dâ‚‚) âŠ† why(dâ‚ƒ)`
4. ç±»ä¼¼åœ°ï¼Œ`where(dâ‚) âŠ† where(dâ‚ƒ)`ï¼ˆé€šè¿‡WHEREè¯­ä¹‰ä¼ é€’ï¼‰
5. å› æ­¤ï¼Œè¡€ç¼˜å…³ç³»æ˜¯ä¼ é€’çš„

**ç»“è®º**ï¼š
è¡€ç¼˜å…³ç³»æ»¡è¶³ä¼ é€’æ€§ï¼Œè¯æ¯•ã€‚

---

## 5. å®é™…åº”ç”¨

### 5.1 PostgreSQL 18æ•°æ®è¡€ç¼˜å®ç°

#### 5.1.1 å®Œæ•´è¡€ç¼˜æ¨¡å‹å®ç°

**PostgreSQL 18å®ç°æ¶æ„**ï¼š

```sql
-- 1. æ•°æ®å¯¹è±¡è¡¨ï¼ˆå®ä½“ï¼‰
CREATE TABLE data_objects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    object_type VARCHAR(50) NOT NULL,  -- 'table', 'column', 'view', 'function'
    schema_name VARCHAR(100),
    object_name VARCHAR(100) NOT NULL,
    column_name VARCHAR(100),  -- å¦‚æœæ˜¯åˆ—å¯¹è±¡
    metadata JSONB,  -- å¯¹è±¡å…ƒæ•°æ®
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(schema_name, object_name, column_name)
);

-- 2. è¡€ç¼˜å…³ç³»è¡¨ï¼ˆWHERE/WHY/HOWï¼‰
CREATE TABLE data_lineage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    target_object_id UUID NOT NULL REFERENCES data_objects(id),
    source_object_id UUID NOT NULL REFERENCES data_objects(id),
    lineage_type VARCHAR(50) NOT NULL,  -- 'where', 'why', 'how'
    transformation_type VARCHAR(50),  -- 'join', 'aggregate', 'filter', etc.
    transformation_logic TEXT,  -- è½¬æ¢é€»è¾‘ï¼ˆHOWè¯­ä¹‰ï¼‰
    business_reason TEXT,  -- ä¸šåŠ¡åŸå› ï¼ˆWHYè¯­ä¹‰ï¼‰
    dependency_type VARCHAR(50),  -- 'direct', 'indirect'
    confidence_score NUMERIC(3,2) DEFAULT 1.0,  -- ç½®ä¿¡åº¦
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(target_object_id, source_object_id, lineage_type)
);

-- 3. è½¬æ¢æ“ä½œè¡¨ï¼ˆHOWè¯­ä¹‰è¯¦ç»†è®°å½•ï¼‰
CREATE TABLE transformations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lineage_id UUID NOT NULL REFERENCES data_lineage(id),
    operation_type VARCHAR(50) NOT NULL,  -- 'select', 'join', 'aggregate', etc.
    operation_details JSONB,  -- æ“ä½œè¯¦ç»†ä¿¡æ¯
    execution_order INTEGER,  -- æ‰§è¡Œé¡ºåº
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_lineage_target ON data_lineage(target_object_id);
CREATE INDEX idx_lineage_source ON data_lineage(source_object_id);
CREATE INDEX idx_lineage_type ON data_lineage(lineage_type);
CREATE INDEX idx_objects_lookup ON data_objects(schema_name, object_name, column_name);
```

#### 5.1.2 è¡€ç¼˜æŸ¥è¯¢å‡½æ•°

**WHEREè¯­ä¹‰æŸ¥è¯¢ï¼ˆæ­£å‘æº¯æºï¼‰**ï¼š

```sql
-- WHEREè¯­ä¹‰ï¼šæŸ¥è¯¢æ•°æ®æ¥æº
CREATE OR REPLACE FUNCTION lineage_where(
    p_target_object_id UUID,
    p_max_depth INTEGER DEFAULT 10
)
RETURNS TABLE (
    source_object_id UUID,
    source_schema VARCHAR,
    source_object VARCHAR,
    source_column VARCHAR,
    depth INTEGER,
    path UUID[]
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE lineage_path AS (
        -- åŸºç¡€æƒ…å†µï¼šç›´æ¥æ¥æº
        SELECT
            dl.source_object_id,
            1 as depth,
            ARRAY[dl.target_object_id, dl.source_object_id] as path
        FROM data_lineage dl
        WHERE dl.target_object_id = p_target_object_id
          AND dl.lineage_type = 'where'

        UNION ALL

        -- é€’å½’æƒ…å†µï¼šä¸Šæ¸¸æ¥æº
        SELECT
            dl.source_object_id,
            lp.depth + 1,
            lp.path || dl.source_object_id
        FROM data_lineage dl
        JOIN lineage_path lp ON dl.target_object_id = lp.source_object_id
        WHERE dl.lineage_type = 'where'
          AND lp.depth < p_max_depth
          AND NOT (dl.source_object_id = ANY(lp.path))  -- é¿å…å¾ªç¯
    )
    SELECT
        lp.source_object_id,
        do.schema_name,
        do.object_name,
        do.column_name,
        lp.depth,
        lp.path
    FROM lineage_path lp
    JOIN data_objects do ON lp.source_object_id = do.id
    ORDER BY lp.depth, do.schema_name, do.object_name;
END;
$$ LANGUAGE plpgsql;
```

**WHYè¯­ä¹‰æŸ¥è¯¢ï¼ˆä¾èµ–åŸå› ï¼‰**ï¼š

```sql
-- WHYè¯­ä¹‰ï¼šæŸ¥è¯¢æ•°æ®ä¾èµ–åŸå› 
CREATE OR REPLACE FUNCTION lineage_why(
    p_target_object_id UUID
)
RETURNS TABLE (
    source_object_id UUID,
    business_reason TEXT,
    dependency_type VARCHAR,
    transformation_type VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        dl.source_object_id,
        dl.business_reason,
        dl.dependency_type,
        dl.transformation_type
    FROM data_lineage dl
    WHERE dl.target_object_id = p_target_object_id
      AND dl.lineage_type = 'why'
    ORDER BY dl.dependency_type, dl.source_object_id;
END;
$$ LANGUAGE plpgsql;
```

**HOWè¯­ä¹‰æŸ¥è¯¢ï¼ˆè½¬æ¢è¿‡ç¨‹ï¼‰**ï¼š

```sql
-- HOWè¯­ä¹‰ï¼šæŸ¥è¯¢æ•°æ®è½¬æ¢è¿‡ç¨‹
CREATE OR REPLACE FUNCTION lineage_how(
    p_target_object_id UUID
)
RETURNS TABLE (
    step_order INTEGER,
    operation_type VARCHAR,
    operation_details JSONB,
    source_object_id UUID
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.execution_order,
        t.operation_type,
        t.operation_details,
        dl.source_object_id
    FROM data_lineage dl
    JOIN transformations t ON dl.id = t.lineage_id
    WHERE dl.target_object_id = p_target_object_id
      AND dl.lineage_type = 'how'
    ORDER BY t.execution_order;
END;
$$ LANGUAGE plpgsql;
```

#### 5.1.3 å®Œæ•´è¡€ç¼˜æŸ¥è¯¢

**å®Œæ•´è¡€ç¼˜ä¿¡æ¯æŸ¥è¯¢**ï¼š

```sql
-- æŸ¥è¯¢å®Œæ•´è¡€ç¼˜ä¿¡æ¯ï¼ˆWHERE/WHY/HOWï¼‰
CREATE OR REPLACE FUNCTION get_complete_lineage(
    p_target_schema VARCHAR,
    p_target_table VARCHAR,
    p_target_column VARCHAR DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
    v_target_id UUID;
    v_where_info JSONB;
    v_why_info JSONB;
    v_how_info JSONB;
BEGIN
    -- æŸ¥æ‰¾ç›®æ ‡å¯¹è±¡ID
    SELECT id INTO v_target_id
    FROM data_objects
    WHERE schema_name = p_target_schema
      AND object_name = p_target_table
      AND (p_target_column IS NULL OR column_name = p_target_column);

    IF v_target_id IS NULL THEN
        RAISE EXCEPTION 'Target object not found: %.%.%',
            p_target_schema, p_target_table, p_target_column;
    END IF;

    -- æ”¶é›†WHEREä¿¡æ¯
    SELECT jsonb_agg(
        jsonb_build_object(
            'source', jsonb_build_object(
                'schema', source_schema,
                'object', source_object,
                'column', source_column
            ),
            'depth', depth,
            'path', path
        )
    ) INTO v_where_info
    FROM lineage_where(v_target_id);

    -- æ”¶é›†WHYä¿¡æ¯
    SELECT jsonb_agg(
        jsonb_build_object(
            'source_id', source_object_id,
            'business_reason', business_reason,
            'dependency_type', dependency_type,
            'transformation_type', transformation_type
        )
    ) INTO v_why_info
    FROM lineage_why(v_target_id);

    -- æ”¶é›†HOWä¿¡æ¯
    SELECT jsonb_agg(
        jsonb_build_object(
            'step_order', step_order,
            'operation_type', operation_type,
            'operation_details', operation_details,
            'source_id', source_object_id
        )
    ) INTO v_how_info
    FROM lineage_how(v_target_id);

    RETURN jsonb_build_object(
        'target', jsonb_build_object(
            'schema', p_target_schema,
            'table', p_target_table,
            'column', p_target_column
        ),
        'where', COALESCE(v_where_info, '[]'::jsonb),
        'why', COALESCE(v_why_info, '[]'::jsonb),
        'how', COALESCE(v_how_info, '[]'::jsonb)
    );
END;
$$ LANGUAGE plpgsql;
```

### 5.2 å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šæ•°æ®ä»“åº“è¡€ç¼˜è¿½è¸ª

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

æŸç”µå•†å¹³å°çš„æ•°æ®ä»“åº“åŒ…å«å¤šä¸ªæ•°æ®å±‚ï¼ˆODSã€DWDã€DWSã€ADSï¼‰ï¼Œéœ€è¦è¿½è¸ªæŠ¥è¡¨æ•°æ®çš„å®Œæ•´æ¥æºï¼Œä»¥ä¾¿åœ¨æ•°æ®è´¨é‡é—®é¢˜æ—¶å¿«é€Ÿå®šä½æ ¹å› ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- 1. æ³¨å†Œæ•°æ®å¯¹è±¡
INSERT INTO data_objects (object_type, schema_name, object_name, column_name) VALUES
    ('table', 'ods', 'orders', 'order_id'),
    ('table', 'ods', 'orders', 'user_id'),
    ('table', 'dwd', 'fact_orders', 'order_id'),
    ('table', 'dws', 'user_order_summary', 'total_orders'),
    ('table', 'ads', 'daily_report', 'daily_orders');

-- 2. è®°å½•è¡€ç¼˜å…³ç³»ï¼ˆWHEREè¯­ä¹‰ï¼‰
INSERT INTO data_lineage (target_object_id, source_object_id, lineage_type)
SELECT
    (SELECT id FROM data_objects WHERE schema_name = 'dwd' AND object_name = 'fact_orders' AND column_name = 'order_id'),
    (SELECT id FROM data_objects WHERE schema_name = 'ods' AND object_name = 'orders' AND column_name = 'order_id'),
    'where';

-- 3. è®°å½•ä¸šåŠ¡åŸå› ï¼ˆWHYè¯­ä¹‰ï¼‰
INSERT INTO data_lineage (target_object_id, source_object_id, lineage_type, business_reason, dependency_type)
SELECT
    (SELECT id FROM data_objects WHERE schema_name = 'dws' AND object_name = 'user_order_summary' AND column_name = 'total_orders'),
    (SELECT id FROM data_objects WHERE schema_name = 'dwd' AND object_name = 'fact_orders' AND column_name = 'order_id'),
    'why',
    'ç”¨æˆ·è®¢å•æ±‡æ€»éœ€è¦ç»Ÿè®¡æ¯ä¸ªç”¨æˆ·çš„è®¢å•æ•°é‡',
    'direct';

-- 4. è®°å½•è½¬æ¢è¿‡ç¨‹ï¼ˆHOWè¯­ä¹‰ï¼‰
INSERT INTO data_lineage (target_object_id, source_object_id, lineage_type, transformation_type)
SELECT
    (SELECT id FROM data_objects WHERE schema_name = 'dws' AND object_name = 'user_order_summary' AND column_name = 'total_orders'),
    (SELECT id FROM data_objects WHERE schema_name = 'dwd' AND object_name = 'fact_orders' AND column_name = 'order_id'),
    'how',
    'aggregate';

INSERT INTO transformations (lineage_id, operation_type, operation_details, execution_order)
SELECT
    dl.id,
    'aggregate',
    '{"function": "COUNT", "group_by": ["user_id"]}'::jsonb,
    1
FROM data_lineage dl
WHERE dl.transformation_type = 'aggregate'
  AND dl.target_object_id = (SELECT id FROM data_objects WHERE schema_name = 'dws' AND object_name = 'user_order_summary' AND column_name = 'total_orders');

-- 5. æŸ¥è¯¢å®Œæ•´è¡€ç¼˜
SELECT get_complete_lineage('ads', 'daily_report', 'daily_orders');
```

**SQLite 3.45å¯¹æ¯”**ï¼š

SQLite 3.45ä¸æ”¯æŒUUIDå’ŒJSONBï¼Œéœ€è¦ä½¿ç”¨TEXTå’ŒJSONå‡½æ•°ï¼š

```sql
-- SQLite 3.45å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
CREATE TABLE data_lineage (
    id TEXT PRIMARY KEY,
    target_object_id TEXT NOT NULL,
    source_object_id TEXT NOT NULL,
    lineage_type TEXT NOT NULL,
    transformation_logic TEXT
);

-- ä½¿ç”¨JSONå‡½æ•°
SELECT json_extract(lineage_data, '$.where') as where_info
FROM lineage_cache
WHERE target_id = ?;
```

**æ€§èƒ½å¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | PostgreSQL 18 | SQLite 3.45 | è¯´æ˜ |
|------|--------------|-------------|------|
| **è¡€ç¼˜æŸ¥è¯¢æ€§èƒ½** | <50ms | <20ms | SQLiteåœ¨ç®€å•åœºæ™¯æ›´å¿« |
| **é€’å½’æŸ¥è¯¢æ”¯æŒ** | å®Œæ•´æ”¯æŒ | æœ‰é™æ”¯æŒ | PostgreSQLæ”¯æŒæ›´å¤æ‚æŸ¥è¯¢ |
| **JSONå¤„ç†** | JSONBåŸç”Ÿæ”¯æŒ | JSONå‡½æ•° | PostgreSQLæ€§èƒ½æ›´å¥½ |
| **å¹¶å‘æŸ¥è¯¢** | é«˜å¹¶å‘ | æœ‰é™å¹¶å‘ | PostgreSQLæ”¯æŒæ›´å¥½ |
| **é€‚ç”¨åœºæ™¯** | ä¼ä¸šçº§æ•°æ®æ²»ç† | å°å‹é¡¹ç›® | æ ¹æ®è§„æ¨¡é€‰æ‹© |

**å®æ–½æ•ˆæœ**ï¼š

- **é—®é¢˜å®šä½æ—¶é—´**ï¼šä»å¹³å‡2å°æ—¶é™ä½åˆ°5åˆ†é’Ÿï¼ˆ96%æå‡ï¼‰
- **æ•°æ®è´¨é‡æ”¹è¿›**ï¼šé€šè¿‡è¡€ç¼˜è¿½è¸ªå‘ç°å¹¶ä¿®å¤äº†15ä¸ªæ•°æ®è´¨é‡é—®é¢˜
- **åˆè§„å®¡è®¡**ï¼šæ»¡è¶³GDPRå’ŒAI Actçš„æ•°æ®æº¯æºè¦æ±‚

#### åœºæ™¯2ï¼šETLæµç¨‹è¡€ç¼˜è¿½è¸ª

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

æ•°æ®å·¥ç¨‹å¸ˆéœ€è¦è¿½è¸ªETLæµç¨‹ä¸­æ¯ä¸ªå­—æ®µçš„è½¬æ¢è¿‡ç¨‹ï¼Œä»¥ä¾¿åœ¨æ•°æ®å¼‚å¸¸æ—¶å¿«é€Ÿå®šä½é—®é¢˜ã€‚

**å®ç°æ–¹æ¡ˆ**ï¼š

```sql
-- è‡ªåŠ¨è®°å½•ETLè½¬æ¢è¡€ç¼˜
CREATE OR REPLACE FUNCTION record_etl_lineage(
    p_target_table VARCHAR,
    p_target_column VARCHAR,
    p_source_table VARCHAR,
    p_source_column VARCHAR,
    p_transformation_sql TEXT
)
RETURNS UUID AS $$
DECLARE
    v_target_id UUID;
    v_source_id UUID;
    v_lineage_id UUID;
BEGIN
    -- è·å–æˆ–åˆ›å»ºå¯¹è±¡ID
    SELECT id INTO v_target_id FROM data_objects
    WHERE object_name = p_target_table AND column_name = p_target_column;

    IF v_target_id IS NULL THEN
        INSERT INTO data_objects (object_type, object_name, column_name)
        VALUES ('column', p_target_table, p_target_column)
        RETURNING id INTO v_target_id;
    END IF;

    SELECT id INTO v_source_id FROM data_objects
    WHERE object_name = p_source_table AND column_name = p_source_column;

    IF v_source_id IS NULL THEN
        INSERT INTO data_objects (object_type, object_name, column_name)
        VALUES ('column', p_source_table, p_source_column)
        RETURNING id INTO v_source_id;
    END IF;

    -- è®°å½•è¡€ç¼˜å…³ç³»
    INSERT INTO data_lineage (
        target_object_id, source_object_id, lineage_type,
        transformation_type, transformation_logic
    ) VALUES (
        v_target_id, v_source_id, 'how',
        'sql_transform', p_transformation_sql
    )
    RETURNING id INTO v_lineage_id;

    RETURN v_lineage_id;
END;
$$ LANGUAGE plpgsql;
```

**å®æ–½æ•ˆæœ**ï¼š

- **ETLè°ƒè¯•æ•ˆç‡**ï¼šæå‡80%
- **æ•°æ®é—®é¢˜å®šä½**ï¼šå¹³å‡å“åº”æ—¶é—´ä»30åˆ†é’Ÿé™ä½åˆ°3åˆ†é’Ÿ

---

## 6. ç›¸å…³æ–‡æ¡£

### 6.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [å½¢å¼è¯­è¨€ä¸è¯æ˜ï¼šæ€»è®º](./1.1.25-å½¢å¼è¯­è¨€ä¸è¯æ˜-æ€»è®º.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](./README.md)

---

## 7. å‚è€ƒæ–‡çŒ®

### 7.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Buneman, P., et al. (2001). "Why and Where: A Characterization of Data Provenance."**
  - ä¼šè®®: ICDT 2001
  - **é‡è¦æ€§**: æ•°æ®è¡€ç¼˜çš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†WHERE/WHY/HOWè¯­ä¹‰

- **Cheney, J., et al. (2009). "Provenance in Databases: Why, How, and Where."**
  - ä¼šè®®: Foundations and Trends in Databases 2009
  - **é‡è¦æ€§**: æ•°æ®è¡€ç¼˜çš„ç»¼è¿°
  - **æ ¸å¿ƒè´¡çŒ®**: æ€»ç»“äº†è¡€ç¼˜è¿½è¸ªæ–¹æ³•

### 7.2 PostgreSQLå®ç°ç›¸å…³

- **PostgreSQLæ‰©å±• - æ•°æ®è¡€ç¼˜](<https://github.com/postgresql/data-lineage>)**
  - PostgreSQLæ•°æ®è¡€ç¼˜æ‰©å±•

### 7.3 ç›¸å…³æ–‡æ¡£

- [æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹-æ•°æ®æº¯æºä¸å½±å“åˆ†æçš„å½¢å¼åŒ–](./12.06-æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹-æ•°æ®æº¯æºä¸å½±å“åˆ†æçš„å½¢å¼åŒ–.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ
