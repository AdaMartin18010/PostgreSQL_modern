# PostgreSQLåŠç»“æ„åŒ–æ•°æ®å¤„ç†æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 17+/18+
> **éš¾åº¦ç­‰çº§**: â­â­â­ ä¸­çº§

---

## ğŸ“‹ ç›®å½•

- [PostgreSQLåŠç»“æ„åŒ–æ•°æ®å¤„ç†æŒ‡å—](#postgresqlåŠç»“æ„åŒ–æ•°æ®å¤„ç†æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. JSONå¤„ç†](#2-jsonå¤„ç†)
    - [2.1 JSONBå­˜å‚¨](#21-jsonbå­˜å‚¨)
    - [2.2 JSONæŸ¥è¯¢](#22-jsonæŸ¥è¯¢)
  - [3. XMLå¤„ç†](#3-xmlå¤„ç†)
    - [3.1 XMLå­˜å‚¨](#31-xmlå­˜å‚¨)
    - [3.2 XMLæŸ¥è¯¢](#32-xmlæŸ¥è¯¢)
  - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 JSONBç´¢å¼•](#41-jsonbç´¢å¼•)
    - [4.2 è¡¨è¾¾å¼ç´¢å¼•](#42-è¡¨è¾¾å¼ç´¢å¼•)
  - [5. æœ€ä½³å®è·µ](#5-æœ€ä½³å®è·µ)
    - [âœ… æ¨èåšæ³•](#-æ¨èåšæ³•)
  - [6. JSONBé«˜çº§æ“ä½œ](#6-jsonbé«˜çº§æ“ä½œ)
    - [6.1 JSONBè·¯å¾„æŸ¥è¯¢](#61-jsonbè·¯å¾„æŸ¥è¯¢)
    - [6.2 JSONBèšåˆæ“ä½œ](#62-jsonbèšåˆæ“ä½œ)
    - [6.3 JSONBæ›´æ–°æ“ä½œ](#63-jsonbæ›´æ–°æ“ä½œ)
  - [7. XMLé«˜çº§æ“ä½œ](#7-xmlé«˜çº§æ“ä½œ)
    - [7.1 XMLè·¯å¾„æŸ¥è¯¢](#71-xmlè·¯å¾„æŸ¥è¯¢)
    - [7.2 XMLè½¬æ¢](#72-xmlè½¬æ¢)
  - [8. æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
    - [8.1 JSONBç´¢å¼•ä¼˜åŒ–](#81-jsonbç´¢å¼•ä¼˜åŒ–)
    - [8.2 JSONBæŸ¥è¯¢ä¼˜åŒ–](#82-jsonbæŸ¥è¯¢ä¼˜åŒ–)
    - [8.3 æ‰¹é‡æ“ä½œä¼˜åŒ–](#83-æ‰¹é‡æ“ä½œä¼˜åŒ–)
  - [9. æ•°æ®éªŒè¯å’Œçº¦æŸ](#9-æ•°æ®éªŒè¯å’Œçº¦æŸ)
    - [9.1 JSONBçº¦æŸ](#91-jsonbçº¦æŸ)
    - [9.2 JSONBéªŒè¯å‡½æ•°](#92-jsonbéªŒè¯å‡½æ•°)
  - [10. å®é™…åº”ç”¨æ¡ˆä¾‹](#10-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [10.1 æ—¥å¿—æ•°æ®å­˜å‚¨](#101-æ—¥å¿—æ•°æ®å­˜å‚¨)
    - [10.2 é…ç½®æ•°æ®å­˜å‚¨](#102-é…ç½®æ•°æ®å­˜å‚¨)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

PostgreSQLåŸç”Ÿæ”¯æŒJSON/JSONBï¼Œå¯ä»¥é«˜æ•ˆå¤„ç†åŠç»“æ„åŒ–æ•°æ®ã€‚

**æ”¯æŒæ ¼å¼**:

- JSON/JSONB
- XML
- è‡ªå®šä¹‰æ ¼å¼

---

## 2. JSONå¤„ç†

### 2.1 JSONBå­˜å‚¨

```sql
-- åˆ›å»ºJSONBè¡¨
CREATE TABLE IF NOT EXISTS json_data (
    id SERIAL PRIMARY KEY,
    data JSONB NOT NULL,
    source_system VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºGINç´¢å¼•ä¼˜åŒ–JSONBæŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_json_data_gin ON json_data USING GIN (data);

-- æ’å…¥ç¤ºä¾‹JSONæ•°æ®
INSERT INTO json_data (data, source_system) VALUES
    ('{"name": "test", "value": 100, "tags": ["a", "b"], "metadata": {"version": "1.0"}}'::jsonb, 'system1'),
    ('{"name": "example", "value": 200, "tags": ["c", "d"], "metadata": {"version": "2.0"}}'::jsonb, 'system1'),
    ('{"name": "demo", "value": 300, "tags": ["e", "f"], "nested": {"level1": {"level2": "deep"}}}'::jsonb, 'system2')
ON CONFLICT DO NOTHING;
```

### 2.2 JSONæŸ¥è¯¢

```sql
-- æŸ¥è¯¢JSONå­—æ®µï¼ˆå„ç§æŸ¥è¯¢æ–¹å¼ï¼‰
SELECT
    id,
    data->>'name' AS name,
    (data->>'value')::INT AS value,
    data->'tags' AS tags,
    data->'metadata'->>'version' AS version,
    source_system,
    created_at
FROM json_data
WHERE data->>'name' = 'test';

-- ä½¿ç”¨@>æ“ä½œç¬¦æŸ¥è¯¢ï¼ˆåˆ©ç”¨GINç´¢å¼•ï¼‰
SELECT id, data, created_at
FROM json_data
WHERE data @> '{"name": "test"}'::jsonb;

-- ä½¿ç”¨?æ“ä½œç¬¦æŸ¥è¯¢æ•°ç»„åŒ…å«
SELECT id, data->>'name' AS name
FROM json_data
WHERE data->'tags' ? 'a';

-- æŸ¥è¯¢åµŒå¥—JSON
SELECT
    id,
    data->>'name' AS name,
    data->'nested'->'level1'->>'level2' AS deep_value
FROM json_data
WHERE data ? 'nested';
```

---

## 3. XMLå¤„ç†

### 3.1 XMLå­˜å‚¨

```sql
-- åˆ›å»ºXMLè¡¨
CREATE TABLE IF NOT EXISTS xml_data (
    id SERIAL PRIMARY KEY,
    data XML NOT NULL,
    source_file VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT xml_data_check CHECK (data IS DOCUMENT)
);

-- æ’å…¥ç¤ºä¾‹XMLæ•°æ®
INSERT INTO xml_data (data, source_file) VALUES
    ('<root><name>test</name><value>100</value><tags><tag>a</tag><tag>b</tag></tags></root>'::xml, 'file1.xml'),
    ('<root><name>example</name><value>200</value><metadata version="2.0"><author>admin</author></metadata></root>'::xml, 'file2.xml'),
    ('<products><product id="1"><name>Laptop</name><price>999.99</price></product><product id="2"><name>Mouse</name><price>29.99</price></product></products>'::xml, 'products.xml')
ON CONFLICT DO NOTHING;
```

### 3.2 XMLæŸ¥è¯¢

```sql
-- æŸ¥è¯¢XMLæ•°æ®ï¼ˆä½¿ç”¨xpathå‡½æ•°ï¼‰
SELECT
    id,
    (xpath('/root/name/text()', data))[1]::TEXT AS name,
    (xpath('/root/value/text()', data))[1]::TEXT AS value,
    xpath('/root/tags/tag/text()', data) AS tags,
    (xpath('/root/metadata/@version', data))[1]::TEXT AS version,
    source_file,
    created_at
FROM xml_data
WHERE data IS NOT NULL;

-- æŸ¥è¯¢äº§å“XMLæ•°æ®
SELECT
    id,
    unnest(xpath('/products/product/name/text()', data))::TEXT AS product_name,
    unnest(xpath('/products/product/price/text()', data))::TEXT AS price
FROM xml_data
WHERE source_file = 'products.xml';

-- ä½¿ç”¨xpath_existsæ£€æŸ¥èŠ‚ç‚¹å­˜åœ¨æ€§
SELECT id, source_file, data
FROM xml_data
WHERE xpath_exists('/root/metadata', data);
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 JSONBç´¢å¼•

```sql
-- GINç´¢å¼•
CREATE INDEX idx_json_data ON json_data USING GIN (data);

-- æŸ¥è¯¢ä¼˜åŒ–
SELECT * FROM json_data
WHERE data @> '{"name": "test"}'::jsonb;
```

### 4.2 è¡¨è¾¾å¼ç´¢å¼•

```sql
-- ä¸ºå¸¸ç”¨å­—æ®µåˆ›å»ºç´¢å¼•
CREATE INDEX idx_json_name ON json_data ((data->>'name'));
```

---

## 5. æœ€ä½³å®è·µ

### âœ… æ¨èåšæ³•

1. **ä½¿ç”¨JSONB** - æ€§èƒ½æ›´å¥½
2. **åˆ›å»ºç´¢å¼•** - æé«˜æŸ¥è¯¢æ€§èƒ½
3. **è§„èŒƒåŒ–æ•°æ®** - å‡å°‘åµŒå¥—å±‚çº§
4. **ä½¿ç”¨çº¦æŸ** - éªŒè¯æ•°æ®æ ¼å¼

---

## 6. JSONBé«˜çº§æ“ä½œ

### 6.1 JSONBè·¯å¾„æŸ¥è¯¢

```sql
-- JSONBè·¯å¾„æŸ¥è¯¢ï¼ˆPostgreSQL 12+ï¼‰
SELECT
    id,
    data->'user'->>'name' AS user_name,
    data->'user'->>'email' AS user_email,
    data->'metadata'->>'source' AS source
FROM json_data
WHERE data @> '{"user": {"name": "test"}}'::jsonb;

-- ä½¿ç”¨jsonb_path_queryï¼ˆPostgreSQL 12+ï¼‰
SELECT
    id,
    jsonb_path_query(data, '$.user.name') AS user_name,
    jsonb_path_query(data, '$.metadata.tags[*]') AS tags
FROM json_data;
```

### 6.2 JSONBèšåˆæ“ä½œ

```sql
-- JSONBèšåˆæ“ä½œ
SELECT
    jsonb_object_agg(key, value) AS aggregated_data
FROM (
    SELECT
        data->>'category' AS key,
        SUM((data->>'amount')::numeric) AS value
    FROM json_data
    GROUP BY data->>'category'
) AS agg;

-- JSONBæ•°ç»„èšåˆ
SELECT
    jsonb_agg(data->'tags') AS all_tags
FROM json_data
WHERE data ? 'tags';
```

### 6.3 JSONBæ›´æ–°æ“ä½œ

```sql
-- JSONBæ›´æ–°æ“ä½œï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    updated_count INT;
BEGIN
    -- æ›´æ–°JSONBå­—æ®µ
    UPDATE json_data
    SET data = jsonb_set(
        data,
        '{metadata,updated_at}',
        to_jsonb(NOW()::text)
    )
    WHERE data @> '{"status": "active"}'::jsonb;

    GET DIAGNOSTICS updated_count = ROW_COUNT;
    RAISE NOTICE 'æ›´æ–°äº† % æ¡è®°å½•', updated_count;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'JSONBæ›´æ–°å¤±è´¥: %', SQLERRM;
END $$;

-- åˆ é™¤JSONBå­—æ®µ
UPDATE json_data
SET data = data - 'old_field'
WHERE data ? 'old_field';
```

---

## 7. XMLé«˜çº§æ“ä½œ

### 7.1 XMLè·¯å¾„æŸ¥è¯¢

```sql
-- XMLè·¯å¾„æŸ¥è¯¢
SELECT
    id,
    (xpath('/root/user/name/text()', data))[1]::TEXT AS user_name,
    (xpath('/root/user/email/text()', data))[1]::TEXT AS user_email,
    (xpath('/root/metadata/tags/tag/text()', data)) AS tags
FROM xml_data;

-- XMLå‘½åç©ºé—´æŸ¥è¯¢
SELECT
    id,
    (xpath('/ns:root/ns:user/ns:name/text()', data,
           ARRAY[ARRAY['ns', 'http://example.com/namespace']]))[1]::TEXT AS user_name
FROM xml_data;
```

### 7.2 XMLè½¬æ¢

```sql
-- XMLè½¬JSONB
SELECT
    id,
    xml_to_json(data)::jsonb AS json_data
FROM xml_data;

-- XMLè½¬è¡¨
SELECT
    id,
    (xpath('/root/user/name/text()', data))[1]::TEXT AS name,
    (xpath('/root/user/email/text()', data))[1]::TEXT AS email
FROM xml_data;
```

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 JSONBç´¢å¼•ä¼˜åŒ–

```sql
-- GINç´¢å¼•ï¼ˆæ”¯æŒæ‰€æœ‰æ“ä½œï¼‰
CREATE INDEX idx_json_data_gin ON json_data USING GIN (data);

-- è¡¨è¾¾å¼ç´¢å¼•ï¼ˆé’ˆå¯¹ç‰¹å®šå­—æ®µï¼‰
CREATE INDEX idx_json_data_name ON json_data ((data->>'name'));
CREATE INDEX idx_json_data_category ON json_data ((data->>'category'));

-- å¤åˆç´¢å¼•
CREATE INDEX idx_json_data_name_category ON json_data
((data->>'name'), (data->>'category'));

-- æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM json_data
WHERE data->>'name' = 'test' AND data->>'category' = 'A';
```

### 8.2 JSONBæŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä¼˜åŒ–ï¼šä½¿ç”¨@>æ“ä½œç¬¦ï¼ˆå¯ä»¥ä½¿ç”¨GINç´¢å¼•ï¼‰
SELECT * FROM json_data
WHERE data @> '{"name": "test", "category": "A"}'::jsonb;

-- ä¼˜åŒ–ï¼šä½¿ç”¨?æ“ä½œç¬¦æ£€æŸ¥é”®å­˜åœ¨
SELECT * FROM json_data
WHERE data ? 'tags';

-- ä¼˜åŒ–ï¼šä½¿ç”¨?&æ“ä½œç¬¦æ£€æŸ¥å¤šä¸ªé”®å­˜åœ¨
SELECT * FROM json_data
WHERE data ?& ARRAY['name', 'email'];

-- æ€§èƒ½å¯¹æ¯”
EXPLAIN (ANALYZE, BUFFERS, TIMING)
-- æ–¹å¼1ï¼šä½¿ç”¨->>æ“ä½œç¬¦ï¼ˆå¯èƒ½ä¸ä½¿ç”¨ç´¢å¼•ï¼‰
SELECT * FROM json_data WHERE data->>'name' = 'test';

-- æ–¹å¼2ï¼šä½¿ç”¨@>æ“ä½œç¬¦ï¼ˆå¯ä»¥ä½¿ç”¨GINç´¢å¼•ï¼‰
SELECT * FROM json_data WHERE data @> '{"name": "test"}'::jsonb;
```

### 8.3 æ‰¹é‡æ“ä½œä¼˜åŒ–

```sql
-- æ‰¹é‡æ’å…¥JSONBæ•°æ®ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    batch_size INT := 10000;
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    duration INTERVAL;
BEGIN
    start_time := clock_timestamp();

    INSERT INTO json_data (data)
    SELECT jsonb_build_object(
        'id', i,
        'name', 'test_' || i,
        'value', random() * 1000,
        'tags', ARRAY['tag1', 'tag2', 'tag' || i]::text[]
    )
    FROM generate_series(1, batch_size) i;

    end_time := clock_timestamp();
    duration := end_time - start_time;

    RAISE NOTICE 'æ‰¹é‡æ’å…¥ % æ¡JSONBè®°å½•è€—æ—¶: %', batch_size, duration;
    RAISE NOTICE 'æ’å…¥é€Ÿåº¦: % æ¡/ç§’', ROUND(batch_size / EXTRACT(EPOCH FROM duration));

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ‰¹é‡æ’å…¥å¤±è´¥: %', SQLERRM;
END $$;
```

---

## 9. æ•°æ®éªŒè¯å’Œçº¦æŸ

### 9.1 JSONBçº¦æŸ

```sql
-- åˆ›å»ºå¸¦çº¦æŸçš„JSONBè¡¨
CREATE TABLE json_data_validated (
    id SERIAL PRIMARY KEY,
    data JSONB NOT NULL,
    CONSTRAINT check_data_format CHECK (
        data ? 'name' AND
        data ? 'value' AND
        (data->>'value')::numeric > 0
    )
);

-- æ’å…¥æ•°æ®ï¼ˆéªŒè¯çº¦æŸï¼‰
INSERT INTO json_data_validated (data)
VALUES ('{"name": "test", "value": 100}'::jsonb);  -- æˆåŠŸ

INSERT INTO json_data_validated (data)
VALUES ('{"name": "test"}'::jsonb);  -- å¤±è´¥ï¼šç¼ºå°‘valueå­—æ®µ
```

### 9.2 JSONBéªŒè¯å‡½æ•°

```sql
-- JSONBéªŒè¯å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
CREATE OR REPLACE FUNCTION validate_jsonb_schema(
    p_data JSONB,
    p_schema JSONB
)
RETURNS BOOLEAN AS $$
DECLARE
    required_field TEXT;
BEGIN
    -- æ£€æŸ¥å¿…éœ€å­—æ®µ
    FOR required_field IN
        SELECT jsonb_array_elements_text(p_schema->'required')
    LOOP
        IF NOT (p_data ? required_field) THEN
            RAISE NOTICE 'ç¼ºå°‘å¿…éœ€å­—æ®µ: %', required_field;
            RETURN FALSE;
        END IF;
    END LOOP;

    -- æ£€æŸ¥å­—æ®µç±»å‹
    IF p_schema ? 'properties' THEN
        FOR required_field IN
            SELECT jsonb_object_keys(p_schema->'properties')
        LOOP
            -- ç±»å‹æ£€æŸ¥é€»è¾‘
            -- è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥æ ¹æ®schemaå®šä¹‰æ£€æŸ¥
        END LOOP;
    END IF;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'JSONBéªŒè¯å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨éªŒè¯å‡½æ•°
SELECT validate_jsonb_schema(
    '{"name": "test", "value": 100}'::jsonb,
    '{"required": ["name", "value"]}'::jsonb
);
```

---

## 10. å®é™…åº”ç”¨æ¡ˆä¾‹

### 10.1 æ—¥å¿—æ•°æ®å­˜å‚¨

```sql
-- æ—¥å¿—æ•°æ®è¡¨è®¾è®¡
CREATE TABLE log_data (
    id SERIAL PRIMARY KEY,
    log_level TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    message TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_log_data_level ON log_data (log_level);
CREATE INDEX idx_log_data_timestamp ON log_data (timestamp);
CREATE INDEX idx_log_data_metadata ON log_data USING GIN (metadata);

-- æŸ¥è¯¢æ—¥å¿—ï¼ˆå¸¦æ€§èƒ½æµ‹è¯•ï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT *
FROM log_data
WHERE log_level = 'ERROR'
  AND metadata @> '{"user_id": 123}'::jsonb
  AND timestamp > NOW() - INTERVAL '1 day'
ORDER BY timestamp DESC
LIMIT 100;
```

### 10.2 é…ç½®æ•°æ®å­˜å‚¨

```sql
-- é…ç½®æ•°æ®è¡¨è®¾è®¡
CREATE TABLE config_data (
    id SERIAL PRIMARY KEY,
    config_key TEXT UNIQUE NOT NULL,
    config_value JSONB NOT NULL,
    description TEXT,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_config_data_key ON config_data (config_key);
CREATE INDEX idx_config_data_value ON config_data USING GIN (config_value);

-- æŸ¥è¯¢é…ç½®ï¼ˆå¸¦æ€§èƒ½æµ‹è¯•ï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT config_value
FROM config_data
WHERE config_key = 'app_settings'
  AND config_value @> '{"enabled": true}'::jsonb;
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ•°æ®æ¹–å®Œæ•´æŒ‡å—.md](./æ•°æ®æ¹–å®Œæ•´æŒ‡å—.md) - æ•°æ®æ¹–å®Œæ•´æŒ‡å—
- [å…ƒæ•°æ®ç®¡ç†.md](./å…ƒæ•°æ®ç®¡ç†.md) - å…ƒæ•°æ®ç®¡ç†è¯¦è§£
- [26-æ•°æ®ç®¡ç†/README.md](../README.md) - æ•°æ®ç®¡ç†ä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
