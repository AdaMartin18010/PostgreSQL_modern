# PostgreSQL半结构化数据处理指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL半结构化数据处理指南](#postgresql半结构化数据处理指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. JSON处理](#2-json处理)
    - [2.1 JSONB存储](#21-jsonb存储)
    - [2.2 JSON查询](#22-json查询)
  - [3. XML处理](#3-xml处理)
    - [3.1 XML存储](#31-xml存储)
    - [3.2 XML查询](#32-xml查询)
  - [4. 性能优化](#4-性能优化)
    - [4.1 JSONB索引](#41-jsonb索引)
    - [4.2 表达式索引](#42-表达式索引)
  - [5. 最佳实践](#5-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
  - [6. JSONB高级操作](#6-jsonb高级操作)
    - [6.1 JSONB路径查询](#61-jsonb路径查询)
    - [6.2 JSONB聚合操作](#62-jsonb聚合操作)
    - [6.3 JSONB更新操作](#63-jsonb更新操作)
  - [7. XML高级操作](#7-xml高级操作)
    - [7.1 XML路径查询](#71-xml路径查询)
    - [7.2 XML转换](#72-xml转换)
  - [8. 性能优化](#8-性能优化)
    - [8.1 JSONB索引优化](#81-jsonb索引优化)
    - [8.2 JSONB查询优化](#82-jsonb查询优化)
    - [8.3 批量操作优化](#83-批量操作优化)
  - [9. 数据验证和约束](#9-数据验证和约束)
    - [9.1 JSONB约束](#91-jsonb约束)
    - [9.2 JSONB验证函数](#92-jsonb验证函数)
  - [10. 实际应用案例](#10-实际应用案例)
    - [10.1 日志数据存储](#101-日志数据存储)
    - [10.2 配置数据存储](#102-配置数据存储)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

PostgreSQL原生支持JSON/JSONB，可以高效处理半结构化数据。

**支持格式**:

- JSON/JSONB
- XML
- 自定义格式

---

## 2. JSON处理

### 2.1 JSONB存储

```sql
-- 创建JSONB表
CREATE TABLE json_data (
    id SERIAL PRIMARY KEY,
    data JSONB
);

-- 插入JSON数据
INSERT INTO json_data (data)
VALUES ('{"name": "test", "value": 100, "tags": ["a", "b"]}'::jsonb);
```

### 2.2 JSON查询

```sql
-- 查询JSON字段
SELECT
    data->>'name' AS name,
    (data->>'value')::INT AS value,
    data->'tags' AS tags
FROM json_data
WHERE data->>'name' = 'test';
```

---

## 3. XML处理

### 3.1 XML存储

```sql
-- 创建XML表
CREATE TABLE xml_data (
    id SERIAL PRIMARY KEY,
    data XML
);

-- 插入XML数据
INSERT INTO xml_data (data)
VALUES ('<root><name>test</name><value>100</value></root>'::xml);
```

### 3.2 XML查询

```sql
-- 查询XML数据
SELECT
    (xpath('/root/name/text()', data))[1]::TEXT AS name,
    (xpath('/root/value/text()', data))[1]::TEXT AS value
FROM xml_data;
```

---

## 4. 性能优化

### 4.1 JSONB索引

```sql
-- GIN索引
CREATE INDEX idx_json_data ON json_data USING GIN (data);

-- 查询优化
SELECT * FROM json_data
WHERE data @> '{"name": "test"}'::jsonb;
```

### 4.2 表达式索引

```sql
-- 为常用字段创建索引
CREATE INDEX idx_json_name ON json_data ((data->>'name'));
```

---

## 5. 最佳实践

### ✅ 推荐做法

1. **使用JSONB** - 性能更好
2. **创建索引** - 提高查询性能
3. **规范化数据** - 减少嵌套层级
4. **使用约束** - 验证数据格式

---

## 6. JSONB高级操作

### 6.1 JSONB路径查询

```sql
-- JSONB路径查询（PostgreSQL 12+）
SELECT
    id,
    data->'user'->>'name' AS user_name,
    data->'user'->>'email' AS user_email,
    data->'metadata'->>'source' AS source
FROM json_data
WHERE data @> '{"user": {"name": "test"}}'::jsonb;

-- 使用jsonb_path_query（PostgreSQL 12+）
SELECT
    id,
    jsonb_path_query(data, '$.user.name') AS user_name,
    jsonb_path_query(data, '$.metadata.tags[*]') AS tags
FROM json_data;
```

### 6.2 JSONB聚合操作

```sql
-- JSONB聚合操作
SELECT
    jsonb_object_agg(key, value) AS aggregated_data
FROM (
    SELECT
        data->>'category' AS key,
        SUM((data->>'amount')::numeric) AS value
    FROM json_data
    GROUP BY data->>'category'
) AS agg;

-- JSONB数组聚合
SELECT
    jsonb_agg(data->'tags') AS all_tags
FROM json_data
WHERE data ? 'tags';
```

### 6.3 JSONB更新操作

```sql
-- JSONB更新操作（带错误处理和性能测试）
DO $$
DECLARE
    updated_count INT;
BEGIN
    -- 更新JSONB字段
    UPDATE json_data
    SET data = jsonb_set(
        data,
        '{metadata,updated_at}',
        to_jsonb(NOW()::text)
    )
    WHERE data @> '{"status": "active"}'::jsonb;

    GET DIAGNOSTICS updated_count = ROW_COUNT;
    RAISE NOTICE '更新了 % 条记录', updated_count;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'JSONB更新失败: %', SQLERRM;
END $$;

-- 删除JSONB字段
UPDATE json_data
SET data = data - 'old_field'
WHERE data ? 'old_field';
```

---

## 7. XML高级操作

### 7.1 XML路径查询

```sql
-- XML路径查询
SELECT
    id,
    (xpath('/root/user/name/text()', data))[1]::TEXT AS user_name,
    (xpath('/root/user/email/text()', data))[1]::TEXT AS user_email,
    (xpath('/root/metadata/tags/tag/text()', data)) AS tags
FROM xml_data;

-- XML命名空间查询
SELECT
    id,
    (xpath('/ns:root/ns:user/ns:name/text()', data,
           ARRAY[ARRAY['ns', 'http://example.com/namespace']]))[1]::TEXT AS user_name
FROM xml_data;
```

### 7.2 XML转换

```sql
-- XML转JSONB
SELECT
    id,
    xml_to_json(data)::jsonb AS json_data
FROM xml_data;

-- XML转表
SELECT
    id,
    (xpath('/root/user/name/text()', data))[1]::TEXT AS name,
    (xpath('/root/user/email/text()', data))[1]::TEXT AS email
FROM xml_data;
```

---

## 8. 性能优化

### 8.1 JSONB索引优化

```sql
-- GIN索引（支持所有操作）
CREATE INDEX idx_json_data_gin ON json_data USING GIN (data);

-- 表达式索引（针对特定字段）
CREATE INDEX idx_json_data_name ON json_data ((data->>'name'));
CREATE INDEX idx_json_data_category ON json_data ((data->>'category'));

-- 复合索引
CREATE INDEX idx_json_data_name_category ON json_data
((data->>'name'), (data->>'category'));

-- 查询性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM json_data
WHERE data->>'name' = 'test' AND data->>'category' = 'A';
```

### 8.2 JSONB查询优化

```sql
-- 优化：使用@>操作符（可以使用GIN索引）
SELECT * FROM json_data
WHERE data @> '{"name": "test", "category": "A"}'::jsonb;

-- 优化：使用?操作符检查键存在
SELECT * FROM json_data
WHERE data ? 'tags';

-- 优化：使用?&操作符检查多个键存在
SELECT * FROM json_data
WHERE data ?& ARRAY['name', 'email'];

-- 性能对比
EXPLAIN (ANALYZE, BUFFERS, TIMING)
-- 方式1：使用->>操作符（可能不使用索引）
SELECT * FROM json_data WHERE data->>'name' = 'test';

-- 方式2：使用@>操作符（可以使用GIN索引）
SELECT * FROM json_data WHERE data @> '{"name": "test"}'::jsonb;
```

### 8.3 批量操作优化

```sql
-- 批量插入JSONB数据（带错误处理和性能测试）
DO $$
DECLARE
    batch_size INT := 10000;
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    duration INTERVAL;
BEGIN
    start_time := clock_timestamp();

    INSERT INTO json_data (data)
    SELECT jsonb_build_object(
        'id', i,
        'name', 'test_' || i,
        'value', random() * 1000,
        'tags', ARRAY['tag1', 'tag2', 'tag' || i]::text[]
    )
    FROM generate_series(1, batch_size) i;

    end_time := clock_timestamp();
    duration := end_time - start_time;

    RAISE NOTICE '批量插入 % 条JSONB记录耗时: %', batch_size, duration;
    RAISE NOTICE '插入速度: % 条/秒', ROUND(batch_size / EXTRACT(EPOCH FROM duration));

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '批量插入失败: %', SQLERRM;
END $$;
```

---

## 9. 数据验证和约束

### 9.1 JSONB约束

```sql
-- 创建带约束的JSONB表
CREATE TABLE json_data_validated (
    id SERIAL PRIMARY KEY,
    data JSONB NOT NULL,
    CONSTRAINT check_data_format CHECK (
        data ? 'name' AND
        data ? 'value' AND
        (data->>'value')::numeric > 0
    )
);

-- 插入数据（验证约束）
INSERT INTO json_data_validated (data)
VALUES ('{"name": "test", "value": 100}'::jsonb);  -- 成功

INSERT INTO json_data_validated (data)
VALUES ('{"name": "test"}'::jsonb);  -- 失败：缺少value字段
```

### 9.2 JSONB验证函数

```sql
-- JSONB验证函数（带错误处理和性能测试）
CREATE OR REPLACE FUNCTION validate_jsonb_schema(
    p_data JSONB,
    p_schema JSONB
)
RETURNS BOOLEAN AS $$
DECLARE
    required_field TEXT;
BEGIN
    -- 检查必需字段
    FOR required_field IN
        SELECT jsonb_array_elements_text(p_schema->'required')
    LOOP
        IF NOT (p_data ? required_field) THEN
            RAISE NOTICE '缺少必需字段: %', required_field;
            RETURN FALSE;
        END IF;
    END LOOP;

    -- 检查字段类型
    IF p_schema ? 'properties' THEN
        FOR required_field IN
            SELECT jsonb_object_keys(p_schema->'properties')
        LOOP
            -- 类型检查逻辑
            -- 这里简化处理，实际应该根据schema定义检查
        END LOOP;
    END IF;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'JSONB验证失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 使用验证函数
SELECT validate_jsonb_schema(
    '{"name": "test", "value": 100}'::jsonb,
    '{"required": ["name", "value"]}'::jsonb
);
```

---

## 10. 实际应用案例

### 10.1 日志数据存储

```sql
-- 日志数据表设计
CREATE TABLE log_data (
    id SERIAL PRIMARY KEY,
    log_level TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    message TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_log_data_level ON log_data (log_level);
CREATE INDEX idx_log_data_timestamp ON log_data (timestamp);
CREATE INDEX idx_log_data_metadata ON log_data USING GIN (metadata);

-- 查询日志（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT *
FROM log_data
WHERE log_level = 'ERROR'
  AND metadata @> '{"user_id": 123}'::jsonb
  AND timestamp > NOW() - INTERVAL '1 day'
ORDER BY timestamp DESC
LIMIT 100;
```

### 10.2 配置数据存储

```sql
-- 配置数据表设计
CREATE TABLE config_data (
    id SERIAL PRIMARY KEY,
    config_key TEXT UNIQUE NOT NULL,
    config_value JSONB NOT NULL,
    description TEXT,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_config_data_key ON config_data (config_key);
CREATE INDEX idx_config_data_value ON config_data USING GIN (config_value);

-- 查询配置（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT config_value
FROM config_data
WHERE config_key = 'app_settings'
  AND config_value @> '{"enabled": true}'::jsonb;
```

---

## 📚 相关文档

- [数据湖完整指南.md](./数据湖完整指南.md) - 数据湖完整指南
- [元数据管理.md](./元数据管理.md) - 元数据管理详解
- [26-数据管理/README.md](../README.md) - 数据管理主题

---

**最后更新**: 2025年1月
