# PostgreSQLæ•°æ®æ¹–å…ƒæ•°æ®ç®¡ç†æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 17+/18+
> **éš¾åº¦ç­‰çº§**: â­â­â­ ä¸­çº§

---

## ğŸ“‹ ç›®å½•

- [PostgreSQLæ•°æ®æ¹–å…ƒæ•°æ®ç®¡ç†æŒ‡å—](#postgresqlæ•°æ®æ¹–å…ƒæ•°æ®ç®¡ç†æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å…ƒæ•°æ®æ¨¡å‹](#2-å…ƒæ•°æ®æ¨¡å‹)
    - [2.1 å…ƒæ•°æ®è¡¨](#21-å…ƒæ•°æ®è¡¨)
  - [3. å…ƒæ•°æ®å­˜å‚¨](#3-å…ƒæ•°æ®å­˜å‚¨)
    - [3.1 è‡ªåŠ¨æ”¶é›†](#31-è‡ªåŠ¨æ”¶é›†)
  - [4. å…ƒæ•°æ®æŸ¥è¯¢](#4-å…ƒæ•°æ®æŸ¥è¯¢)
    - [4.1 æ•°æ®å‘ç°](#41-æ•°æ®å‘ç°)
    - [4.2 æ•°æ®è¡€ç¼˜](#42-æ•°æ®è¡€ç¼˜)
  - [5. å…ƒæ•°æ®ç»´æŠ¤](#5-å…ƒæ•°æ®ç»´æŠ¤)
    - [5.1 å®šæœŸæ›´æ–°](#51-å®šæœŸæ›´æ–°)
    - [5.2 å…ƒæ•°æ®éªŒè¯](#52-å…ƒæ•°æ®éªŒè¯)
  - [6. æ•°æ®è¡€ç¼˜ç®¡ç†](#6-æ•°æ®è¡€ç¼˜ç®¡ç†)
    - [6.1 æ•°æ®è¡€ç¼˜è¡¨](#61-æ•°æ®è¡€ç¼˜è¡¨)
    - [6.2 æ•°æ®è¡€ç¼˜æŸ¥è¯¢](#62-æ•°æ®è¡€ç¼˜æŸ¥è¯¢)
    - [6.3 å½±å“åˆ†æ](#63-å½±å“åˆ†æ)
  - [7. å…ƒæ•°æ®æœç´¢å’Œå‘ç°](#7-å…ƒæ•°æ®æœç´¢å’Œå‘ç°)
    - [7.1 å…¨æ–‡æœç´¢](#71-å…¨æ–‡æœç´¢)
    - [7.2 æ•°æ®å‘ç°](#72-æ•°æ®å‘ç°)
  - [8. å…ƒæ•°æ®ç‰ˆæœ¬ç®¡ç†](#8-å…ƒæ•°æ®ç‰ˆæœ¬ç®¡ç†)
    - [8.1 å…ƒæ•°æ®ç‰ˆæœ¬è¡¨](#81-å…ƒæ•°æ®ç‰ˆæœ¬è¡¨)
    - [8.2 ç‰ˆæœ¬å¯¹æ¯”](#82-ç‰ˆæœ¬å¯¹æ¯”)
  - [9. å…ƒæ•°æ®ç›‘æ§å’Œå‘Šè­¦](#9-å…ƒæ•°æ®ç›‘æ§å’Œå‘Šè­¦)
    - [9.1 å…ƒæ•°æ®ç›‘æ§](#91-å…ƒæ•°æ®ç›‘æ§)
    - [9.2 å…ƒæ•°æ®å‘Šè­¦](#92-å…ƒæ•°æ®å‘Šè­¦)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

å…ƒæ•°æ®ç®¡ç†æ˜¯æ•°æ®æ¹–ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œæä¾›æ•°æ®ç›®å½•å’Œå‘ç°åŠŸèƒ½ã€‚

**å…ƒæ•°æ®å†…å®¹**:

- æ•°æ®æºä¿¡æ¯
- æ•°æ®æ ¼å¼
- æ•°æ®æ¨¡å¼
- æ•°æ®è¡€ç¼˜

---

## 2. å…ƒæ•°æ®æ¨¡å‹

### 2.1 å…ƒæ•°æ®è¡¨

```sql
-- æ•°æ®æºå…ƒæ•°æ®è¡¨
CREATE TABLE IF NOT EXISTS data_source_metadata (
    id SERIAL PRIMARY KEY,
    source_name VARCHAR(200) NOT NULL UNIQUE,
    source_type VARCHAR(50) NOT NULL,
    location TEXT NOT NULL,
    format VARCHAR(50),
    schema_info JSONB DEFAULT '{}',
    connection_info JSONB DEFAULT '{}',
    description TEXT,
    owner VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ•°æ®è¡¨å…ƒæ•°æ®è¡¨
CREATE TABLE IF NOT EXISTS table_metadata (
    id SERIAL PRIMARY KEY,
    table_name VARCHAR(200) NOT NULL,
    schema_name VARCHAR(100) NOT NULL DEFAULT 'public',
    source_id INTEGER REFERENCES data_source_metadata(id),
    columns JSONB NOT NULL DEFAULT '[]',
    row_count BIGINT DEFAULT 0,
    size_bytes BIGINT DEFAULT 0,
    last_updated TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(schema_name, table_name)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_table_metadata_source ON table_metadata(source_id);
CREATE INDEX IF NOT EXISTS idx_table_metadata_columns ON table_metadata USING GIN(columns);

-- æ’å…¥ç¤ºä¾‹æ•°æ®æºå…ƒæ•°æ®
INSERT INTO data_source_metadata (source_name, source_type, location, format, schema_info, description) VALUES
    ('CRM System', 'Database', 'postgresql://crm:5432/crmdb', 'PostgreSQL',
     '{"database": "crmdb", "schema": "public"}'::jsonb, 'Customer Relationship Management System'),
    ('ERP System', 'API', 'https://api.erp.example.com/v1', 'REST API',
     '{"auth": "OAuth2", "rate_limit": 1000}'::jsonb, 'Enterprise Resource Planning System'),
    ('File System', 'File', '/data-lake/raw/', 'JSON',
     '{"file_pattern": "*.json", "encoding": "UTF-8"}'::jsonb, 'Raw data files')
ON CONFLICT (source_name) DO UPDATE
SET updated_at = NOW();

-- æ’å…¥ç¤ºä¾‹è¡¨å…ƒæ•°æ®
INSERT INTO table_metadata (table_name, schema_name, source_id, columns, row_count, size_bytes)
SELECT
    'customers',
    'public',
    (SELECT id FROM data_source_metadata WHERE source_name = 'CRM System'),
    '[{"name": "customer_id", "type": "integer", "nullable": false},
      {"name": "customer_name", "type": "varchar", "nullable": false},
      {"name": "email", "type": "varchar", "nullable": true}]'::jsonb,
    10000,
    1048576
ON CONFLICT (schema_name, table_name) DO UPDATE
SET row_count = EXCLUDED.row_count, size_bytes = EXCLUDED.size_bytes, last_updated = NOW();
```

---

## 3. å…ƒæ•°æ®å­˜å‚¨

### 3.1 è‡ªåŠ¨æ”¶é›†

```sql
-- è‡ªåŠ¨æ”¶é›†è¡¨å…ƒæ•°æ®
CREATE OR REPLACE FUNCTION collect_table_metadata()
RETURNS VOID AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT
            schemaname,
            tablename,
            pg_total_relation_size(schemaname||'.'||tablename) AS size
        FROM pg_tables
        WHERE schemaname = 'public'
    LOOP
        INSERT INTO table_metadata (table_name, size_bytes)
        VALUES (r.tablename, r.size)
        ON CONFLICT (table_name) DO UPDATE
        SET size_bytes = r.size, last_updated = NOW();
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. å…ƒæ•°æ®æŸ¥è¯¢

### 4.1 æ•°æ®å‘ç°

```sql
-- æŸ¥æ‰¾æ•°æ®è¡¨
SELECT
    table_name,
    columns,
    row_count,
    size_bytes
FROM table_metadata
WHERE columns @> '[{"name": "user_id"}]'::jsonb;
```

### 4.2 æ•°æ®è¡€ç¼˜

```sql
-- æ•°æ®è¡€ç¼˜æŸ¥è¯¢
SELECT
    source_table,
    target_table,
    transformation
FROM data_lineage
WHERE source_table = 'users';
```

---

## 5. å…ƒæ•°æ®ç»´æŠ¤

### 5.1 å®šæœŸæ›´æ–°

```sql
-- å®šæœŸæ›´æ–°å…ƒæ•°æ®
SELECT cron.schedule(
    'update-metadata',
    '0 2 * * *',
    'SELECT collect_table_metadata();'
);
```

### 5.2 å…ƒæ•°æ®éªŒè¯

```sql
-- éªŒè¯å…ƒæ•°æ®ä¸€è‡´æ€§ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
CREATE OR REPLACE FUNCTION validate_metadata()
RETURNS TABLE (
    table_name TEXT,
    status TEXT,
    actual_count BIGINT,
    metadata_count BIGINT
) AS $$
DECLARE
    table_rec RECORD;
    actual_row_count BIGINT;
BEGIN
    FOR table_rec IN
        SELECT tm.table_name, tm.row_count
        FROM table_metadata tm
    LOOP
        BEGIN
            -- è·å–å®é™…è¡Œæ•°
            EXECUTE format('SELECT COUNT(*) FROM %I', table_rec.table_name)
            INTO actual_row_count;

            RETURN QUERY SELECT
                table_rec.table_name,
                CASE
                    WHEN actual_row_count = table_rec.row_count THEN 'ä¸€è‡´'
                    ELSE 'ä¸ä¸€è‡´'
                END,
                actual_row_count,
                table_rec.row_count;

        EXCEPTION
            WHEN undefined_table THEN
                RETURN QUERY SELECT
                    table_rec.table_name,
                    'è¡¨ä¸å­˜åœ¨'::TEXT,
                    NULL::BIGINT,
                    table_rec.row_count;
            WHEN OTHERS THEN
                RETURN QUERY SELECT
                    table_rec.table_name,
                    format('éªŒè¯å¤±è´¥: %', SQLERRM)::TEXT,
                    NULL::BIGINT,
                    table_rec.row_count;
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œå…ƒæ•°æ®éªŒè¯
SELECT * FROM validate_metadata();
```

---

## 6. æ•°æ®è¡€ç¼˜ç®¡ç†

### 6.1 æ•°æ®è¡€ç¼˜è¡¨

```sql
-- åˆ›å»ºæ•°æ®è¡€ç¼˜è¡¨
CREATE TABLE IF NOT EXISTS data_lineage (
    id SERIAL PRIMARY KEY,
    source_table TEXT NOT NULL,
    target_table TEXT NOT NULL,
    transformation TEXT,
    transformation_type TEXT,  -- 'ETL', 'VIEW', 'MATERIALIZED_VIEW'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(source_table, target_table)
);

-- æ’å…¥æ•°æ®è¡€ç¼˜å…³ç³»
INSERT INTO data_lineage (source_table, target_table, transformation, transformation_type)
VALUES
    ('source_sales', 'staging_sales', 'Extract from source system', 'ETL'),
    ('staging_sales', 'fact_sales', 'Transform and load', 'ETL'),
    ('fact_sales', 'mv_sales_summary', 'Aggregate by time and product', 'MATERIALIZED_VIEW')
ON CONFLICT (source_table, target_table) DO NOTHING;
```

### 6.2 æ•°æ®è¡€ç¼˜æŸ¥è¯¢

```sql
-- æŸ¥è¯¢æ•°æ®è¡€ç¼˜ï¼ˆé€’å½’æŸ¥è¯¢ï¼‰
WITH RECURSIVE lineage_path AS (
    -- èµ·å§‹ç‚¹
    SELECT
        source_table,
        target_table,
        transformation,
        ARRAY[source_table, target_table] AS path,
        1 AS depth
    FROM data_lineage
    WHERE source_table = 'source_sales'

    UNION ALL

    -- é€’å½’æ‰©å±•
    SELECT
        dl.source_table,
        dl.target_table,
        dl.transformation,
        lp.path || dl.target_table,
        lp.depth + 1
    FROM data_lineage dl
    JOIN lineage_path lp ON dl.source_table = lp.target_table
    WHERE dl.target_table != ALL(lp.path)  -- é¿å…å¾ªç¯
      AND lp.depth < 10  -- é™åˆ¶æ·±åº¦
)
SELECT
    path,
    depth,
    transformation
FROM lineage_path
ORDER BY depth, path;
```

### 6.3 å½±å“åˆ†æ

```sql
-- å½±å“åˆ†æï¼šæŸ¥è¯¢ä¾èµ–æŸä¸ªè¡¨çš„æ‰€æœ‰ä¸‹æ¸¸è¡¨
CREATE OR REPLACE FUNCTION analyze_impact(p_table_name TEXT)
RETURNS TABLE (
    dependent_table TEXT,
    transformation TEXT,
    depth INT
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE impact_analysis AS (
        SELECT
            target_table,
            transformation,
            1 AS depth
        FROM data_lineage
        WHERE source_table = p_table_name

        UNION ALL

        SELECT
            dl.target_table,
            dl.transformation,
            ia.depth + 1
        FROM data_lineage dl
        JOIN impact_analysis ia ON dl.source_table = ia.target_table
        WHERE ia.depth < 10
    )
    SELECT DISTINCT
        target_table,
        transformation,
        MIN(depth) OVER (PARTITION BY target_table) AS depth
    FROM impact_analysis
    ORDER BY depth, target_table;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å½±å“åˆ†æå¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œå½±å“åˆ†æ
SELECT * FROM analyze_impact('source_sales');
```

---

## 7. å…ƒæ•°æ®æœç´¢å’Œå‘ç°

### 7.1 å…¨æ–‡æœç´¢

```sql
-- åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•
ALTER TABLE table_metadata ADD COLUMN IF NOT EXISTS search_vector tsvector;

-- æ›´æ–°æœç´¢å‘é‡
UPDATE table_metadata
SET search_vector =
    to_tsvector('english',
        COALESCE(table_name, '') || ' ' ||
        COALESCE(columns::text, '')
    );

-- åˆ›å»ºGINç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_table_metadata_search
ON table_metadata USING GIN (search_vector);

-- å…¨æ–‡æœç´¢
SELECT
    table_name,
    columns,
    ts_rank(search_vector, query) AS rank
FROM table_metadata, to_tsquery('english', 'user & sales') query
WHERE search_vector @@ query
ORDER BY rank DESC;
```

### 7.2 æ•°æ®å‘ç°

```sql
-- æ•°æ®å‘ç°å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
CREATE OR REPLACE FUNCTION discover_data(
    p_search_term TEXT,
    p_column_name TEXT DEFAULT NULL
)
RETURNS TABLE (
    table_name TEXT,
    column_name TEXT,
    data_type TEXT,
    match_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        tm.table_name,
        col->>'name' AS column_name,
        col->>'type' AS data_type,
        CASE
            WHEN col->>'name' ILIKE '%' || p_search_term || '%' THEN 100.0
            WHEN col->>'type' ILIKE '%' || p_search_term || '%' THEN 50.0
            ELSE 10.0
        END AS match_score
    FROM table_metadata tm,
         jsonb_array_elements(tm.columns) AS col
    WHERE (p_column_name IS NULL OR col->>'name' = p_column_name)
      AND (
          col->>'name' ILIKE '%' || p_search_term || '%' OR
          col->>'type' ILIKE '%' || p_search_term || '%'
      )
    ORDER BY match_score DESC, table_name, column_name;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ•°æ®å‘ç°å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œæ•°æ®å‘ç°
SELECT * FROM discover_data('user');
SELECT * FROM discover_data('amount', 'sales_amount');
```

---

## 8. å…ƒæ•°æ®ç‰ˆæœ¬ç®¡ç†

### 8.1 å…ƒæ•°æ®ç‰ˆæœ¬è¡¨

```sql
-- åˆ›å»ºå…ƒæ•°æ®ç‰ˆæœ¬è¡¨
CREATE TABLE IF NOT EXISTS table_metadata_history (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    columns JSONB,
    row_count BIGINT,
    size_bytes BIGINT,
    version_number INT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç‰ˆæœ¬ç®¡ç†å‡½æ•°
CREATE OR REPLACE FUNCTION create_metadata_version()
RETURNS TRIGGER AS $$
DECLARE
    v_version_number INT;
BEGIN
    -- è·å–ä¸‹ä¸€ä¸ªç‰ˆæœ¬å·
    SELECT COALESCE(MAX(version_number), 0) + 1
    INTO v_version_number
    FROM table_metadata_history
    WHERE table_name = NEW.table_name;

    -- æ’å…¥å†å²ç‰ˆæœ¬
    INSERT INTO table_metadata_history (
        table_name,
        columns,
        row_count,
        size_bytes,
        version_number
    )
    VALUES (
        NEW.table_name,
        NEW.columns,
        NEW.row_count,
        NEW.size_bytes,
        v_version_number
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER metadata_version_trigger
AFTER UPDATE ON table_metadata
FOR EACH ROW
WHEN (OLD.columns IS DISTINCT FROM NEW.columns OR
      OLD.row_count IS DISTINCT FROM NEW.row_count)
EXECUTE FUNCTION create_metadata_version();
```

### 8.2 ç‰ˆæœ¬å¯¹æ¯”

```sql
-- ç‰ˆæœ¬å¯¹æ¯”å‡½æ•°
CREATE OR REPLACE FUNCTION compare_metadata_versions(
    p_table_name TEXT,
    p_version1 INT,
    p_version2 INT
)
RETURNS TABLE (
    change_type TEXT,
    change_detail TEXT
) AS $$
DECLARE
    v1 RECORD;
    v2 RECORD;
BEGIN
    SELECT * INTO v1
    FROM table_metadata_history
    WHERE table_name = p_table_name AND version_number = p_version1;

    SELECT * INTO v2
    FROM table_metadata_history
    WHERE table_name = p_table_name AND version_number = p_version2;

    IF v1 IS NULL OR v2 IS NULL THEN
        RAISE EXCEPTION 'ç‰ˆæœ¬ä¸å­˜åœ¨';
    END IF;

    -- å¯¹æ¯”åˆ—å˜åŒ–
    IF v1.columns IS DISTINCT FROM v2.columns THEN
        RETURN QUERY SELECT 'COLUMN_CHANGE'::TEXT,
            format('åˆ—å®šä¹‰ä» % å˜ä¸º %', v1.columns::text, v2.columns::text)::TEXT;
    END IF;

    -- å¯¹æ¯”è¡Œæ•°å˜åŒ–
    IF v1.row_count IS DISTINCT FROM v2.row_count THEN
        RETURN QUERY SELECT 'ROW_COUNT_CHANGE'::TEXT,
            format('è¡Œæ•°ä» % å˜ä¸º %', v1.row_count, v2.row_count)::TEXT;
    END IF;

    RETURN;
END;
$$ LANGUAGE plpgsql;

-- æ‰§è¡Œç‰ˆæœ¬å¯¹æ¯”
SELECT * FROM compare_metadata_versions('fact_sales', 1, 2);
```

---

## 9. å…ƒæ•°æ®ç›‘æ§å’Œå‘Šè­¦

### 9.1 å…ƒæ•°æ®ç›‘æ§

```sql
-- åˆ›å»ºå…ƒæ•°æ®ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW v_metadata_monitoring AS
SELECT
    tm.table_name,
    tm.row_count,
    tm.size_bytes,
    tm.last_updated,
    NOW() - tm.last_updated AS age,
    CASE
        WHEN NOW() - tm.last_updated > INTERVAL '7 days' THEN 'STALE'
        WHEN NOW() - tm.last_updated > INTERVAL '1 day' THEN 'WARNING'
        ELSE 'FRESH'
    END AS freshness_status
FROM table_metadata tm;

-- æŸ¥è¯¢è¿‡æ—¶çš„å…ƒæ•°æ®
SELECT * FROM v_metadata_monitoring
WHERE freshness_status IN ('STALE', 'WARNING')
ORDER BY age DESC;
```

### 9.2 å…ƒæ•°æ®å‘Šè­¦

```sql
-- å…ƒæ•°æ®å‘Šè­¦å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
CREATE OR REPLACE FUNCTION check_metadata_alerts()
RETURNS TABLE (
    alert_type TEXT,
    alert_message TEXT,
    alert_level TEXT
) AS $$
DECLARE
    stale_count INT;
    inconsistent_count INT;
BEGIN
    -- æ£€æŸ¥è¿‡æ—¶å…ƒæ•°æ®
    SELECT COUNT(*) INTO stale_count
    FROM v_metadata_monitoring
    WHERE freshness_status = 'STALE';

    IF stale_count > 0 THEN
        RETURN QUERY SELECT
            'STALE_METADATA'::TEXT,
            format('å‘ç° % ä¸ªè¿‡æ—¶å…ƒæ•°æ®è¡¨', stale_count)::TEXT,
            'WARNING'::TEXT;
    END IF;

    -- æ£€æŸ¥ä¸ä¸€è‡´å…ƒæ•°æ®
    SELECT COUNT(*) INTO inconsistent_count
    FROM validate_metadata()
    WHERE status != 'ä¸€è‡´';

    IF inconsistent_count > 0 THEN
        RETURN QUERY SELECT
            'INCONSISTENT_METADATA'::TEXT,
            format('å‘ç° % ä¸ªä¸ä¸€è‡´å…ƒæ•°æ®è¡¨', inconsistent_count)::TEXT,
            'CRITICAL'::TEXT;
    END IF;

    RETURN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'å…ƒæ•°æ®å‘Šè­¦æ£€æŸ¥å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢å‘Šè­¦
SELECT * FROM check_metadata_alerts();
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ•°æ®æ¹–å®Œæ•´æŒ‡å—.md](./æ•°æ®æ¹–å®Œæ•´æŒ‡å—.md) - æ•°æ®æ¹–å®Œæ•´æŒ‡å—
- [æ•°æ®æ¹–æ¶æ„è®¾è®¡.md](./æ•°æ®æ¹–æ¶æ„è®¾è®¡.md) - æ•°æ®æ¹–æ¶æ„è®¾è®¡
- [26-æ•°æ®ç®¡ç†/README.md](../README.md) - æ•°æ®ç®¡ç†ä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
