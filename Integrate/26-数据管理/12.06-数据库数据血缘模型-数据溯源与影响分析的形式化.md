---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\12-æ•°æ®ç®¡ç†æ¨¡å‹\12.06-æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹-æ•°æ®æº¯æºä¸å½±å“åˆ†æçš„å½¢å¼åŒ–.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹-æ•°æ®æº¯æºä¸å½±å“åˆ†æçš„å½¢å¼åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹-æ•°æ®æº¯æºä¸å½±å“åˆ†æçš„å½¢å¼åŒ–](#æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹-æ•°æ®æº¯æºä¸å½±å“åˆ†æçš„å½¢å¼åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°](#10-æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 æ•°æ®æº¯æº](#21-æ•°æ®æº¯æº)
    - [2.2 å½±å“åˆ†æ](#22-å½±å“åˆ†æ)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 è¡€ç¼˜æ¨¡å‹å½¢å¼åŒ–](#31-è¡€ç¼˜æ¨¡å‹å½¢å¼åŒ–)
  - [4. å®šç†ä¸è¯æ˜](#4-å®šç†ä¸è¯æ˜)
    - [4.1 è¡€ç¼˜å®Œæ•´æ€§å®šç†](#41-è¡€ç¼˜å®Œæ•´æ€§å®šç†)
  - [5. å®é™…åº”ç”¨](#5-å®é™…åº”ç”¨)
    - [5.1 PostgreSQL 18æ•°æ®è¡€ç¼˜å®ç°](#51-postgresql-18æ•°æ®è¡€ç¼˜å®ç°)
      - [5.1.1 è¡€ç¼˜å›¾æ¨¡å‹](#511-è¡€ç¼˜å›¾æ¨¡å‹)
    - [5.2 å®é™…åº”ç”¨åœºæ™¯](#52-å®é™…åº”ç”¨åœºæ™¯)
      - [åœºæ™¯1ï¼šæ•°æ®æº¯æºæŸ¥è¯¢](#åœºæ™¯1æ•°æ®æº¯æºæŸ¥è¯¢)
      - [åœºæ™¯2ï¼šå½±å“åˆ†ææŸ¥è¯¢](#åœºæ™¯2å½±å“åˆ†ææŸ¥è¯¢)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)
    - [5.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#51-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#61-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [6.2 PostgreSQLå®ç°ç›¸å…³](#62-postgresqlå®ç°ç›¸å…³)
    - [6.3 ç›¸å…³æ–‡æ¡£](#63-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 æ•°æ®åº“æ•°æ®è¡€ç¼˜æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°

**æ•°æ®è¡€ç¼˜**ï¼š

æ•°æ®è¡€ç¼˜è¿½è¸ªæ•°æ®çš„æ¥æºã€è½¬æ¢å’Œä¾èµ–å…³ç³»ï¼Œæ”¯æŒæ•°æ®æº¯æºå’Œå½±å“åˆ†æã€‚

**è¡€ç¼˜æ¨¡å‹æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((æ•°æ®è¡€ç¼˜))
    æ•°æ®æº¯æº
      ä¸Šæ¸¸è¿½è¸ª
      è½¬æ¢è·¯å¾„
      æ•°æ®æ¥æº
    å½±å“åˆ†æ
      ä¸‹æ¸¸å½±å“
      ä¾èµ–åˆ†æ
      å˜æ›´å½±å“
    è¡€ç¼˜å›¾
      èŠ‚ç‚¹æ•°æ®å¯¹è±¡
      è¾¹è½¬æ¢å…³ç³»
      è·¯å¾„æ•°æ®æµ
```

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **æ•°æ®æº¯æº**ï¼šå‘ä¸Šè¿½è¸ªæ•°æ®æ¥æº
- **å½±å“åˆ†æ**ï¼šå‘ä¸‹åˆ†ææ•°æ®å½±å“
- **å®é™…åº”ç”¨**ï¼šæ•°æ®è¡€ç¼˜ç³»ç»Ÿ

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 æ•°æ®æº¯æº

**æº¯æºç®—æ³•**ï¼š

```haskell
-- æ•°æ®æº¯æº
lineage :: DataObject -> [DataObject]
lineage obj =
    let sources = upstream(obj)
    in sources ++ concatMap lineage sources
```

### 2.2 å½±å“åˆ†æ

**å½±å“åˆ†æç®—æ³•**ï¼š

```haskell
-- å½±å“åˆ†æ
impact :: DataObject -> [DataObject]
impact obj =
    let dependents = downstream(obj)
    in dependents ++ concatMap impact dependents
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 è¡€ç¼˜æ¨¡å‹å½¢å¼åŒ–

**è¡€ç¼˜æ¨¡å‹**ï¼š

```haskell
-- è¡€ç¼˜æ¨¡å‹å½¢å¼åŒ–
LineageModel = (O, T, â†’)
where
    O = data object set
    T = transformation set
    â†’ = transformation relation
```

**æº¯æºå’Œå½±å“åˆ†æ**ï¼š

```haskell
-- æº¯æºï¼šå‘ä¸Šè¿½è¸ª
lineage :: DataObject -> [DataObject]
lineage obj = {o | o â†’* obj}  -- æ‰€æœ‰å¯è¾¾çš„ä¸Šæ¸¸å¯¹è±¡

-- å½±å“åˆ†æï¼šå‘ä¸‹è¿½è¸ª
impact :: DataObject -> [DataObject]
impact obj = {o | obj â†’* o}  -- æ‰€æœ‰å¯è¾¾çš„ä¸‹æ¸¸å¯¹è±¡
```

---

## 4. å®šç†ä¸è¯æ˜

### 4.1 è¡€ç¼˜å®Œæ•´æ€§å®šç†

**å®šç†1ï¼ˆè¡€ç¼˜å®Œæ•´æ€§ï¼‰**ï¼š

å¯¹äºè¡€ç¼˜æ¨¡å‹LineageModel = (O, T, â†’)å’Œæ•°æ®å¯¹è±¡obj âˆˆ Oï¼Œæº¯æºlineage(obj)åŒ…å«æ‰€æœ‰äº§ç”Ÿobjçš„æ•°æ®å¯¹è±¡ï¼Œå½±å“åˆ†æimpact(obj)åŒ…å«æ‰€æœ‰ä¾èµ–objçš„æ•°æ®å¯¹è±¡ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š

è®¾è¡€ç¼˜æ¨¡å‹LineageModel = (O, T, â†’)ï¼Œæ•°æ®å¯¹è±¡obj âˆˆ Oã€‚åˆ™ï¼š

- lineage(obj) = {o âˆˆ O | o â†’* obj}ï¼ˆæ‰€æœ‰ä¸Šæ¸¸å¯¹è±¡ï¼‰
- impact(obj) = {o âˆˆ O | obj â†’* o}ï¼ˆæ‰€æœ‰ä¸‹æ¸¸å¯¹è±¡ï¼‰

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šæº¯æºå®šä¹‰**ï¼š

- æº¯æºlineage(obj)å®šä¹‰ä¸ºæ‰€æœ‰é€šè¿‡è½¬æ¢å…³ç³»â†’å¯è¾¾çš„ä¸Šæ¸¸å¯¹è±¡
- å³lineage(obj) = {o âˆˆ O | o â†’*obj}ï¼Œå…¶ä¸­â†’*æ˜¯â†’çš„ä¼ é€’é—­åŒ…

**æ­¥éª¤2ï¼šæº¯æºå®Œæ•´æ€§**ï¼š

- å¯¹äºä»»æ„äº§ç”Ÿobjçš„æ•°æ®å¯¹è±¡oï¼š
  - å¦‚æœoç›´æ¥äº§ç”Ÿobjï¼Œåˆ™o â†’ objï¼Œå› æ­¤o âˆˆ lineage(obj)
  - å¦‚æœoé—´æ¥äº§ç”Ÿobjï¼ˆé€šè¿‡ä¸­é—´è½¬æ¢ï¼‰ï¼Œåˆ™o â†’* objï¼Œå› æ­¤o âˆˆ lineage(obj)
  - å› æ­¤æ‰€æœ‰äº§ç”Ÿobjçš„å¯¹è±¡éƒ½åœ¨lineage(obj)ä¸­

**æ­¥éª¤3ï¼šå½±å“åˆ†æå®šä¹‰**ï¼š

- å½±å“åˆ†æimpact(obj)å®šä¹‰ä¸ºæ‰€æœ‰é€šè¿‡è½¬æ¢å…³ç³»â†’å¯è¾¾çš„ä¸‹æ¸¸å¯¹è±¡
- å³impact(obj) = {o âˆˆ O | obj â†’* o}

**æ­¥éª¤4ï¼šå½±å“åˆ†æå®Œæ•´æ€§**ï¼š

- å¯¹äºä»»æ„ä¾èµ–objçš„æ•°æ®å¯¹è±¡oï¼š
  - å¦‚æœoç›´æ¥ä¾èµ–objï¼Œåˆ™obj â†’ oï¼Œå› æ­¤o âˆˆ impact(obj)
  - å¦‚æœoé—´æ¥ä¾èµ–objï¼ˆé€šè¿‡ä¸­é—´è½¬æ¢ï¼‰ï¼Œåˆ™obj â†’* oï¼Œå› æ­¤o âˆˆ impact(obj)
  - å› æ­¤æ‰€æœ‰ä¾èµ–objçš„å¯¹è±¡éƒ½åœ¨impact(obj)ä¸­

**æ­¥éª¤5ï¼šç»“è®º**ï¼š

- è¡€ç¼˜å®Œæ•´æ€§å®šç†å¾—è¯

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[è¡€ç¼˜å®Œæ•´æ€§å®šç†] --> B[æº¯æºå®šä¹‰]
    A --> C[å½±å“åˆ†æå®šä¹‰]
    B --> D[æº¯æºå®Œæ•´æ€§]
    C --> E[å½±å“åˆ†æå®Œæ•´æ€§]
    D --> F[å®šç†å¾—è¯]
    E --> F

    style A fill:#FFD700
    style F fill:#90EE90
```

---

## 5. å®é™…åº”ç”¨

### 5.1 PostgreSQL 18æ•°æ®è¡€ç¼˜å®ç°

#### 5.1.1 è¡€ç¼˜å›¾æ¨¡å‹

**PostgreSQL 18è¡€ç¼˜è¿½è¸ª**ï¼š

PostgreSQL 18é€šè¿‡é€’å½’CTEå’Œå›¾æŸ¥è¯¢å®ç°æ•°æ®è¡€ç¼˜è¿½è¸ªã€‚

**è¡€ç¼˜è¡¨ç»“æ„**ï¼š

```sql
-- åœºæ™¯ï¼šä¼ä¸šæ•°æ®è¡€ç¼˜ç³»ç»Ÿ
-- 1. åˆ›å»ºè¡€ç¼˜è¡¨
CREATE TABLE data_lineage (
    lineage_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_object_id UUID NOT NULL,
    target_object_id UUID NOT NULL,
    transformation_type VARCHAR(50) NOT NULL,  -- 'SELECT', 'JOIN', 'AGGREGATE', etc.
    transformation_definition TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_lineage_source ON data_lineage(source_object_id);
CREATE INDEX idx_lineage_target ON data_lineage(target_object_id);

-- 2. æ•°æ®å¯¹è±¡è¡¨
CREATE TABLE data_objects (
    object_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    object_name VARCHAR(200) NOT NULL,
    object_type VARCHAR(50) NOT NULL,  -- 'TABLE', 'VIEW', 'COLUMN', etc.
    schema_name VARCHAR(100),
    table_name VARCHAR(200),
    column_name VARCHAR(200),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_objects_name ON data_objects(object_name);
CREATE INDEX idx_objects_type ON data_objects(object_type);
```

### 5.2 å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šæ•°æ®æº¯æºæŸ¥è¯¢

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

æ•°æ®å·¥ç¨‹å¸ˆéœ€è¦è¿½è¸ªæŠ¥è¡¨æ•°æ®çš„æ¥æºï¼Œäº†è§£æ•°æ®æ˜¯å¦‚ä½•ä»åŸå§‹è¡¨ç»è¿‡å¤šæ­¥è½¬æ¢ç”Ÿæˆçš„ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šæ•°æ®æº¯æºæŸ¥è¯¢
-- 1. å®Œæ•´æº¯æºæŸ¥è¯¢ï¼ˆé€’å½’ï¼‰
CREATE OR REPLACE FUNCTION trace_lineage(
    p_target_object_id UUID,
    p_max_depth INTEGER DEFAULT 10
)
RETURNS TABLE (
    object_id UUID,
    object_name VARCHAR,
    object_type VARCHAR,
    depth INTEGER,
    path UUID[]
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE lineage_path AS (
        -- åŸºç¡€æƒ…å†µï¼šç›®æ ‡å¯¹è±¡
        SELECT
            do.object_id,
            do.object_name,
            do.object_type,
            0 as depth,
            ARRAY[do.object_id] as path
        FROM data_objects do
        WHERE do.object_id = p_target_object_id

        UNION ALL

        -- é€’å½’æƒ…å†µï¼šä¸Šæ¸¸å¯¹è±¡
        SELECT
            do.object_id,
            do.object_name,
            do.object_type,
            lp.depth + 1,
            lp.path || do.object_id
        FROM data_objects do
        JOIN data_lineage dl ON do.object_id = dl.source_object_id
        JOIN lineage_path lp ON dl.target_object_id = lp.object_id
        WHERE lp.depth < p_max_depth
          AND NOT (do.object_id = ANY(lp.path))  -- é˜²æ­¢å¾ªç¯
    )
    SELECT * FROM lineage_path
    ORDER BY depth, object_name;
END;
$$ LANGUAGE plpgsql;

-- 2. ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM trace_lineage(
    (SELECT object_id FROM data_objects WHERE object_name = 'sales_report')
);

-- 3. å¯è§†åŒ–è¡€ç¼˜è·¯å¾„
SELECT
    depth,
    object_name,
    object_type,
    array_to_string(path, ' -> ') as lineage_path
FROM trace_lineage(
    (SELECT object_id FROM data_objects WHERE object_name = 'sales_report')
)
ORDER BY depth;
```

#### åœºæ™¯2ï¼šå½±å“åˆ†ææŸ¥è¯¢

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

å½“ä¿®æ”¹æŸä¸ªè¡¨æˆ–åˆ—æ—¶ï¼Œéœ€è¦åˆ†æå“ªäº›ä¸‹æ¸¸å¯¹è±¡ä¼šå—åˆ°å½±å“ï¼Œä»¥ä¾¿è¯„ä¼°å˜æ›´å½±å“èŒƒå›´ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šå½±å“åˆ†ææŸ¥è¯¢
-- 1. å®Œæ•´å½±å“åˆ†ææŸ¥è¯¢ï¼ˆé€’å½’ï¼‰
CREATE OR REPLACE FUNCTION analyze_impact(
    p_source_object_id UUID,
    p_max_depth INTEGER DEFAULT 10
)
RETURNS TABLE (
    object_id UUID,
    object_name VARCHAR,
    object_type VARCHAR,
    depth INTEGER,
    impact_type VARCHAR  -- 'DIRECT', 'INDIRECT'
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE impact_chain AS (
        -- åŸºç¡€æƒ…å†µï¼šç›´æ¥ä¾èµ–
        SELECT
            do.object_id,
            do.object_name,
            do.object_type,
            1 as depth,
            'DIRECT'::VARCHAR as impact_type
        FROM data_objects do
        JOIN data_lineage dl ON do.object_id = dl.target_object_id
        WHERE dl.source_object_id = p_source_object_id

        UNION ALL

        -- é€’å½’æƒ…å†µï¼šé—´æ¥ä¾èµ–
        SELECT
            do.object_id,
            do.object_name,
            do.object_type,
            ic.depth + 1,
            'INDIRECT'::VARCHAR
        FROM data_objects do
        JOIN data_lineage dl ON do.object_id = dl.target_object_id
        JOIN impact_chain ic ON dl.source_object_id = ic.object_id
        WHERE ic.depth < p_max_depth
    )
    SELECT * FROM impact_chain
    ORDER BY depth, impact_type, object_name;
END;
$$ LANGUAGE plpgsql;

-- 2. ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM analyze_impact(
    (SELECT object_id FROM data_objects WHERE object_name = 'customers' AND column_name = 'email')
);

-- 3. å½±å“åˆ†ææŠ¥å‘Š
SELECT
    impact_type,
    object_type,
    COUNT(*) as affected_count,
    array_agg(object_name ORDER BY object_name) as affected_objects
FROM analyze_impact(
    (SELECT object_id FROM data_objects WHERE object_name = 'customers' AND column_name = 'email')
)
GROUP BY impact_type, object_type
ORDER BY impact_type, object_type;
```

---

---

## 6. ç›¸å…³æ–‡æ¡£

### 5.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [å½¢å¼è¯­è¨€ä¸è¯æ˜ï¼šæ€»è®º](./1.1.25-å½¢å¼è¯­è¨€ä¸è¯æ˜-æ€»è®º.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](./README.md)

---

## 7. å‚è€ƒæ–‡çŒ®

### 6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Buneman, P., et al. (2001). "Why and Where: A Characterization of Data Provenance."**
  - ä¼šè®®: ICDT 2001
  - **é‡è¦æ€§**: æ•°æ®è¡€ç¼˜çš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†æº¯æºå’Œå½±å“åˆ†æ

- **Cheney, J., et al. (2009). "Provenance in Databases: Why, How, and Where."**
  - ä¼šè®®: Foundations and Trends in Databases 2009
  - **é‡è¦æ€§**: æ•°æ®è¡€ç¼˜çš„ç»¼è¿°
  - **æ ¸å¿ƒè´¡çŒ®**: æ€»ç»“äº†è¡€ç¼˜è¿½è¸ªæ–¹æ³•

### 6.2 PostgreSQLå®ç°ç›¸å…³

- **PostgreSQLæ‰©å±• - æ•°æ®è¡€ç¼˜](<https://github.com/postgresql/data-lineage>)**
  - PostgreSQLæ•°æ®è¡€ç¼˜æ‰©å±•

### 6.3 ç›¸å…³æ–‡æ¡£

- [æ•°æ®è¡€ç¼˜-why_where_howå½¢å¼è¯­ä¹‰](./12.01-æ•°æ®è¡€ç¼˜-why_where_howå½¢å¼è¯­ä¹‰.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ
