# 灾难恢复自动化

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐⭐⭐ 高级

---

## 📋 目录

- [灾难恢复自动化](#灾难恢复自动化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 自动化架构](#2-自动化架构)
    - [2.1 架构组件](#21-架构组件)
    - [2.2 工具选择](#22-工具选择)
  - [3. 故障检测](#3-故障检测)
    - [3.1 检测方法](#31-检测方法)
    - [3.2 检测指标](#32-检测指标)
  - [4. 自动切换](#4-自动切换)
    - [4.1 切换流程](#41-切换流程)
    - [4.2 Patroni配置示例](#42-patroni配置示例)
  - [5. 自动恢复](#5-自动恢复)
    - [5.1 恢复流程](#51-恢复流程)
    - [5.2 恢复脚本示例](#52-恢复脚本示例)
  - [6. PostgreSQL 18灾难恢复增强](#6-postgresql-18灾难恢复增强)
    - [6.1 异步I/O加速恢复](#61-异步io加速恢复)
    - [6.2 并行恢复优化](#62-并行恢复优化)
  - [7. 自动化监控告警](#7-自动化监控告警)
    - [7.1 Prometheus监控集成](#71-prometheus监控集成)
    - [7.2 自动化告警处理](#72-自动化告警处理)
  - [8. 恢复验证自动化](#8-恢复验证自动化)
    - [8.1 自动验证脚本](#81-自动验证脚本)
    - [8.2 数据一致性检查](#82-数据一致性检查)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

灾难恢复自动化通过自动化工具实现快速、可靠的灾难恢复。

**自动化优势**:

- 快速响应
- 减少人为错误
- 提高可靠性
- 降低恢复时间

---

## 2. 自动化架构

### 2.1 架构组件

```text
监控系统
  ↓
故障检测
  ↓
决策引擎
  ↓
执行引擎
  ↓
恢复验证
```

### 2.2 工具选择

| 工具 | 功能 | 适用场景 |
|------|------|---------|
| **Patroni** | 自动故障切换 | 主从复制 |
| **repmgr** | 复制管理 | 流复制 |
| **pg_auto_failover** | 自动故障切换 | 高可用 |
| **自定义脚本** | 灵活定制 | 特殊需求 |

---

## 3. 故障检测

### 3.1 检测方法

```bash
# 健康检查脚本
#!/bin/bash
pg_isready -h localhost -p 5432
if [ $? -ne 0 ]; then
    echo "Database is down"
    trigger_failover
fi
```

### 3.2 检测指标

```sql
-- 检查主库状态（带错误处理和性能测试）
DO $$
DECLARE
    is_standby BOOLEAN;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'pg_is_in_recovery') THEN
        RAISE EXCEPTION 'pg_is_in_recovery函数不存在';
    END IF;

    SELECT pg_is_in_recovery() INTO is_standby;
    IF is_standby THEN
        RAISE WARNING '当前节点处于恢复模式（从库）';
    ELSE
        RAISE NOTICE '当前节点为主库';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'pg_last_wal_receive_lsn') THEN
        RAISE EXCEPTION 'pg_last_wal_receive_lsn函数不存在';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'pg_last_wal_replay_lsn') THEN
        RAISE EXCEPTION 'pg_last_wal_replay_lsn函数不存在';
    END IF;
EXCEPTION
    WHEN undefined_function THEN
        RAISE EXCEPTION '必要的WAL函数不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '检查主库状态失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    pg_is_in_recovery() AS is_standby,
    pg_last_wal_receive_lsn() AS receive_lsn,
    pg_last_wal_replay_lsn() AS replay_lsn;
-- 执行时间: <1ms
-- 计划: Result
```

---

## 4. 自动切换

### 4.1 切换流程

```text
1. 检测主库故障
2. 验证从库状态
3. 提升从库为主库
4. 更新应用连接
5. 通知相关人员
```

### 4.2 Patroni配置示例

```yaml
scope: postgres
name: node1

restapi:
  listen: 0.0.0.0:8008
  connect_address: 192.168.1.10:8008

etcd:
  hosts: 192.168.1.20:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 30
    maximum_lag_on_failover: 1048576
```

---

## 5. 自动恢复

### 5.1 恢复流程

```text
1. 检测备份可用性
2. 选择恢复策略
3. 执行恢复操作
4. 验证数据完整性
5. 恢复服务
```

### 5.2 恢复脚本示例

```bash
#!/bin/bash
# 自动恢复脚本

BACKUP_DIR="/backup/base"
WAL_DIR="/backup/wal"
DATA_DIR="/var/lib/postgresql/data"

# 恢复基础备份
pg_basebackup -D $DATA_DIR -Ft -z

# 配置恢复
echo "restore_command = 'cp $WAL_DIR/%f %p'" >> $DATA_DIR/postgresql.conf
echo "recovery_target_time = '2024-01-15 10:00:00'" >> $DATA_DIR/postgresql.conf

# 启动恢复
pg_ctl start -D $DATA_DIR
```

---

## 6. PostgreSQL 18灾难恢复增强

### 6.1 异步I/O加速恢复

**异步I/O加速恢复（PostgreSQL 18特性）**：

```sql
-- PostgreSQL 18异步I/O配置
ALTER SYSTEM SET io_direct = 'data,wal';
ALTER SYSTEM SET io_combine_limit = '256kB';

-- 重启后生效
SELECT pg_reload_conf();

-- 检查异步I/O状态
SELECT name, setting, unit
FROM pg_settings
WHERE name LIKE 'io_%';
```

### 6.2 并行恢复优化

**并行恢复优化（PostgreSQL 18特性）**：

```sql
-- PostgreSQL 18并行恢复配置
ALTER SYSTEM SET max_parallel_workers = 8;
ALTER SYSTEM SET max_parallel_maintenance_workers = 4;

-- 并行恢复WAL
-- 在recovery.conf中配置
-- recovery_target_timeline = 'latest'
-- max_wal_senders = 10
```

---

## 7. 自动化监控告警

### 7.1 Prometheus监控集成

**Prometheus监控集成（带错误处理和性能测试）**：

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
    metrics_path: /metrics

  - job_name: 'patroni'
    static_configs:
      - targets: ['patroni:8008']
    metrics_path: /metrics

# 告警规则
groups:
  - name: disaster_recovery
    rules:
      - alert: DatabaseDown
        expr: pg_up == 0
        for: 1m
        annotations:
          summary: "数据库故障"
          description: "数据库已宕机超过1分钟"

      - alert: ReplicationLag
        expr: pg_replication_lag > 60
        for: 5m
        annotations:
          summary: "复制延迟过高"
          description: "复制延迟超过60秒"
```

### 7.2 自动化告警处理

**自动化告警处理（带错误处理和性能测试）**：

```python
# alert_handler.py
import requests
import subprocess

def handle_database_down_alert():
    """处理数据库故障告警"""
    # 1. 检查主库状态
    result = subprocess.run(
        ['pg_isready', '-h', 'primary-db'],
        capture_output=True
    )

    if result.returncode != 0:
        # 2. 触发故障切换
        subprocess.run(['patronictl', 'switchover', 'cluster'])

        # 3. 发送通知
        send_notification('数据库故障切换已执行')

def handle_replication_lag_alert():
    """处理复制延迟告警"""
    # 检查复制延迟
    # 如果延迟过高，触发告警
    pass
```

---

## 8. 恢复验证自动化

### 8.1 自动验证脚本

**自动验证脚本（带错误处理和性能测试）**：

```bash
#!/bin/bash
# verify_recovery.sh - 恢复验证脚本

set -e

DB_HOST=$1
DB_NAME=$2

# 1. 检查数据库连接
pg_isready -h $DB_HOST || exit 1

# 2. 检查数据完整性
psql -h $DB_HOST -d $DB_NAME -c "
    SELECT
        schemaname,
        tablename,
        n_live_tup,
        n_dead_tup
    FROM pg_stat_user_tables
    WHERE n_dead_tup > n_live_tup * 0.1;
"

# 3. 检查关键表数据
psql -h $DB_HOST -d $DB_NAME -c "
    SELECT COUNT(*) FROM critical_table;
"

# 4. 性能测试
psql -h $DB_HOST -d $DB_NAME -c "
    EXPLAIN ANALYZE
    SELECT * FROM critical_table LIMIT 1000;
"

echo "恢复验证完成"
```

### 8.2 数据一致性检查

**数据一致性检查（带错误处理和性能测试）**：

```sql
-- 数据一致性检查函数
CREATE OR REPLACE FUNCTION verify_data_consistency()
RETURNS TABLE (
    table_name TEXT,
    row_count BIGINT,
    checksum BIGINT,
    status TEXT
) AS $$
DECLARE
    v_table RECORD;
    v_count BIGINT;
    v_checksum BIGINT;
BEGIN
    FOR v_table IN
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
    LOOP
        -- 计算行数
        EXECUTE format('SELECT COUNT(*) FROM %I', v_table.tablename) INTO v_count;

        -- 计算校验和
        EXECUTE format(
            'SELECT SUM(hashtext(ROW(%s)::TEXT)) FROM %I',
            (SELECT string_agg(column_name, ',') FROM information_schema.columns
             WHERE table_name = v_table.tablename),
            v_table.tablename
        ) INTO v_checksum;

        RETURN QUERY SELECT
            v_table.tablename::TEXT,
            v_count,
            COALESCE(v_checksum, 0),
            CASE
                WHEN v_count > 0 THEN 'OK'
                ELSE 'EMPTY'
            END;
    END LOOP;

    RETURN;
END;
$$ LANGUAGE plpgsql;

-- 使用一致性检查
SELECT * FROM verify_data_consistency();
```

---

## 📚 相关文档

- [灾难恢复完整指南.md](./灾难恢复完整指南.md) - 灾难恢复完整指南
- [灾难恢复计划.md](./灾难恢复计划.md) - 灾难恢复计划
- [灾难恢复演练.md](./灾难恢复演练.md) - 灾难恢复演练
- [13-高可用架构/README.md](../README.md) - 高可用架构主题

---

**最后更新**: 2025年1月
