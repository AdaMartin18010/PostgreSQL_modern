---

> **📋 文档来源**: `PostgreSQL\06-运维实践\运维手册\故障切换与订阅重建.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# Runbook：故障切换与订阅重建（PostgreSQL 18）

> **文档版本**: v1.0
> **最后更新**: 2025-11-22
> **PostgreSQL版本**: 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)

---

## 📋 目录

- [Runbook：故障切换与订阅重建（PostgreSQL 18）](#runbook故障切换与订阅重建postgresql-18)
  - [📋 目录](#-目录)
  - [场景](#场景)
  - [步骤（示意）](#步骤示意)
    - [1. 故障切换流程](#1-故障切换流程)
    - [2. 逻辑订阅重建](#2-逻辑订阅重建)
    - [3. 完整切换脚本](#3-完整切换脚本)
  - [检查清单](#检查清单)
    - [完整检查清单](#完整检查清单)
  - [演练频率（建议）](#演练频率建议)
    - [演练脚本](#演练脚本)
  - [交叉引用](#交叉引用)
    - [相关文档](#相关文档)
    - [外部资源](#外部资源)

---

## 场景

主库故障，启用从库并平滑恢复逻辑订阅。

## 步骤（示意）

1. 切主：Promote 只读副本；确认复制延迟
2. 更新连接：应用与订阅指向新主
3. 刷新：`ALTER SUBSCRIPTION ... REFRESH PUBLICATION`，校验复制槽
4. 验证：延迟、冲突、缺失表与权限

### 1. 故障切换流程

**步骤1: 确认主库故障**:

```bash
# 检查主库连接
psql -h primary_host -U postgres -c "SELECT 1;" || echo "主库不可用"

# 检查主库服务状态
systemctl status postgresql@14-main || echo "主库服务停止"

# 检查网络连通性
ping -c 3 primary_host || echo "主库网络不可达"
```

**步骤2: 检查从库状态**:

```sql
-- 检查从库复制状态
SELECT
    application_name,
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) as replication_lag_bytes,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) as replication_lag
FROM pg_stat_replication;

-- 检查从库是否在恢复模式
SELECT pg_is_in_recovery();
-- 应该返回: t (true，表示是从库)

-- 检查WAL接收状态
SELECT
    pg_last_wal_receive_lsn(),
    pg_last_wal_replay_lsn(),
    pg_wal_lsn_diff(pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn()) as lag_bytes;
```

**步骤3: Promote从库为主库**:

```bash
# 方法1: 使用pg_ctl promote（推荐）
pg_ctl -D /var/lib/postgresql/data promote

# 方法2: 使用SQL命令
psql -c "SELECT pg_promote();"

# 方法3: 创建promote文件
touch /var/lib/postgresql/data/promote

# 验证提升成功
psql -c "SELECT pg_is_in_recovery();"
# 应该返回: f (false，表示已提升为主库)
```

**步骤4: 更新应用连接**:

```bash
# 更新连接字符串
# 旧: postgresql://primary_host:5432/mydb
# 新: postgresql://standby_host:5432/mydb

# 更新负载均衡配置
# HAProxy配置
# server pg1 standby_host:5432 check

# 更新DNS
# pg-primary.example.com -> standby_host
```

**步骤5: 验证新主库功能**:

```sql
-- 1. 验证可写
CREATE TABLE failover_test (id SERIAL PRIMARY KEY, test_time TIMESTAMP DEFAULT NOW());
INSERT INTO failover_test DEFAULT VALUES;
SELECT * FROM failover_test;

-- 2. 验证数据完整性
SELECT COUNT(*) FROM orders;
SELECT MAX(created_at) FROM orders;

-- 3. 验证复制槽（如果有）
SELECT
    slot_name,
    slot_type,
    database,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) as lag_bytes
FROM pg_replication_slots;
```

### 2. 逻辑订阅重建

**步骤1: 检查订阅状态**:

```sql
-- 检查订阅列表
SELECT
    subname,
    subpublications,
    subenabled,
    subslotname
FROM pg_subscription;

-- 检查订阅状态（需要连接到订阅数据库）
SELECT
    subname,
    subenabled,
    subslotname,
    subpublications
FROM pg_subscription
WHERE subname = 'my_subscription';
```

**步骤2: 更新订阅连接**:

```sql
-- 方法1: 删除旧订阅并创建新订阅
DROP SUBSCRIPTION my_subscription;

CREATE SUBSCRIPTION my_subscription
CONNECTION 'host=new_primary port=5432 dbname=mydb user=replication'
PUBLICATION my_publication
WITH (
    copy_data = false,  -- 如果数据已存在
    create_slot = true,
    enabled = true
);

-- 方法2: 刷新订阅（PostgreSQL 10+）
ALTER SUBSCRIPTION my_subscription
CONNECTION 'host=new_primary port=5432 dbname=mydb user=replication';

-- 刷新发布
ALTER SUBSCRIPTION my_subscription REFRESH PUBLICATION;
```

**步骤3: 验证复制槽**:

```sql
-- 在新主库检查复制槽
SELECT
    slot_name,
    slot_type,
    database,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) as lag_bytes
FROM pg_replication_slots
WHERE slot_name LIKE '%subscription%';

-- 检查槽的WAL保留
SELECT
    slot_name,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) as wal_retained
FROM pg_replication_slots;
```

**步骤4: 检查订阅延迟**:

```sql
-- 在订阅端检查延迟
SELECT
    subname,
    subenabled,
    subslotname,
    pg_subscription_rel.substate,
    pg_subscription_rel.srsubstate
FROM pg_subscription
JOIN pg_subscription_rel ON pg_subscription.oid = pg_subscription_rel.srsubid
WHERE subname = 'my_subscription';

-- 检查应用延迟（需要pg_stat_subscription，PostgreSQL 10+）
SELECT
    subname,
    apply_lsn,
    sync_lsn,
    pg_wal_lsn_diff(sync_lsn, apply_lsn) as lag_bytes
FROM pg_stat_subscription;
```

**步骤5: 处理冲突和缺失对象**:

```sql
-- 检查冲突
SELECT
    subname,
    subenabled,
    subslotname
FROM pg_subscription
WHERE subname = 'my_subscription';

-- 检查缺失表
SELECT
    schemaname,
    tablename
FROM pg_tables
WHERE schemaname = 'public'
AND tablename NOT IN (
    SELECT tablename
    FROM pg_publication_tables
    WHERE pubname = 'my_publication'
);

-- 检查缺失权限
SELECT
    grantee,
    privilege_type
FROM information_schema.role_table_grants
WHERE table_schema = 'public'
AND table_name = 'target_table';
```

### 3. 完整切换脚本

```bash
#!/bin/bash
# failover_and_subscription_recovery.sh

PRIMARY_HOST="primary.example.com"
STANDBY_HOST="standby.example.com"
DB_NAME="mydb"
SUBSCRIPTION_NAME="my_subscription"
PUBLICATION_NAME="my_publication"

echo "=== 故障切换开始 ==="

# 步骤1: 确认主库故障
if ! psql -h ${PRIMARY_HOST} -U postgres -d ${DB_NAME} -c "SELECT 1;" > /dev/null 2>&1; then
    echo "主库不可用，开始故障切换"
else
    echo "主库可用，退出"
    exit 1
fi

# 步骤2: 检查从库状态
REPLICATION_LAG=$(psql -h ${STANDBY_HOST} -U postgres -d ${DB_NAME} -t -c "
    SELECT pg_wal_lsn_diff(
        pg_current_wal_lsn(),
        pg_last_wal_replay_lsn()
    );
")

if [ "${REPLICATION_LAG}" -gt 1073741824 ]; then  # 1GB
    echo "警告：复制延迟超过1GB: ${REPLICATION_LAG} bytes"
fi

# 步骤3: Promote从库
echo "提升从库为主库..."
psql -h ${STANDBY_HOST} -U postgres -d ${DB_NAME} -c "SELECT pg_promote();"

# 等待提升完成
sleep 5

# 验证提升
IS_RECOVERY=$(psql -h ${STANDBY_HOST} -U postgres -d ${DB_NAME} -t -c "SELECT pg_is_in_recovery();")
if [ "${IS_RECOVERY}" = "f" ]; then
    echo "从库已成功提升为主库"
else
    echo "错误：从库提升失败"
    exit 1
fi

# 步骤4: 更新订阅
echo "更新逻辑订阅..."
psql -h ${STANDBY_HOST} -U postgres -d ${DB_NAME} <<EOF
ALTER SUBSCRIPTION ${SUBSCRIPTION_NAME}
CONNECTION 'host=${STANDBY_HOST} port=5432 dbname=${DB_NAME} user=replication';

ALTER SUBSCRIPTION ${SUBSCRIPTION_NAME} REFRESH PUBLICATION;
EOF

# 步骤5: 验证
echo "验证订阅状态..."
psql -h ${STANDBY_HOST} -U postgres -d ${DB_NAME} -c "
SELECT
    subname,
    subenabled,
    subslotname
FROM pg_subscription
WHERE subname = '${SUBSCRIPTION_NAME}';
"

echo "=== 故障切换完成 ==="
```

## 检查清单

- 订阅状态、复制槽状态、冲突与重放、应用可用性
- 复制延迟与缺失对象核对
- 应用连接池刷新与错误率

### 完整检查清单

**切换前检查**:

```sql
-- 1. 主库状态
SELECT pg_is_in_recovery(), pg_current_wal_lsn();

-- 2. 从库状态
SELECT
    pg_is_in_recovery(),
    pg_last_wal_receive_lsn(),
    pg_last_wal_replay_lsn(),
    pg_wal_lsn_diff(pg_current_wal_lsn(), pg_last_wal_replay_lsn()) as lag_bytes;

-- 3. 订阅状态
SELECT
    subname,
    subenabled,
    subslotname,
    subpublications
FROM pg_subscription;
```

**切换后检查**:

```sql
-- 1. 新主库状态
SELECT pg_is_in_recovery(), pg_current_wal_lsn();

-- 2. 订阅状态
SELECT
    subname,
    subenabled,
    subslotname
FROM pg_subscription;

-- 3. 复制槽状态
SELECT
    slot_name,
    slot_type,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) as lag_bytes
FROM pg_replication_slots;

-- 4. 数据一致性
SELECT COUNT(*) FROM orders;
SELECT MAX(created_at) FROM orders;

-- 5. 应用连接
SELECT
    COUNT(*) as total_connections,
    COUNT(*) FILTER (WHERE state = 'active') as active_queries
FROM pg_stat_activity
WHERE datname = current_database();
```

## 演练频率（建议）

- 月度：只读副本 Promote 与回切
- 双月：订阅刷新/重建演练

### 演练脚本

```bash
#!/bin/bash
# failover_drill.sh

echo "=== 故障切换演练开始 ==="

# 1. 记录当前状态
psql -c "SELECT pg_current_wal_lsn();" > /tmp/before_promote_lsn.txt

# 2. 执行Promote
psql -c "SELECT pg_promote();"

# 3. 验证
sleep 5
IS_RECOVERY=$(psql -t -c "SELECT pg_is_in_recovery();")
if [ "${IS_RECOVERY}" = "f" ]; then
    echo "Promote成功"
else
    echo "Promote失败"
    exit 1
fi

# 4. 回切（演练后）
# psql -c "SELECT pg_demote();"  # 如果支持

echo "=== 故障切换演练完成 ==="
```

---

## 交叉引用

### 相关文档

- ⭐⭐⭐ [集群与高可用演练SOP](./03-集群与高可用-演练SOP.md) - 完整故障切换演练流程
- ⭐⭐⭐ [集群部署与高可用](../../05-部署架构/集群部署/05.04-集群部署与高可用.md) - 高可用架构设计
- ⭐⭐ [逻辑复制](../../01-核心课程/01.07-逻辑复制与订阅.md) - 逻辑复制理论基础
- ⭐⭐ [监控与诊断](../监控与诊断/06.01-监控与诊断.md) - 监控和诊断方法
- ⭐ [变更与回滚](./变更与回滚.md) - 变更管理流程

### 外部资源

- [PostgreSQL故障转移文档](https://www.postgresql.org/docs/current/high-availability.html)
- [PostgreSQL逻辑复制文档](https://www.postgresql.org/docs/current/logical-replication.html)
- [PostgreSQL订阅管理](https://www.postgresql.org/docs/current/sql-createsubscription.html)

---

**文档版本**: v1.0
**最后更新**: 2025-11-22
**PostgreSQL版本**: 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
**维护者**: Documentation Team
