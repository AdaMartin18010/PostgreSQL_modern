---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\01-å½¢å¼åŒ–æ–¹æ³•ä¸åŸºç¡€ç†è®º\01.03-èŒƒç•´è®ºåŸºç¡€.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# èŒƒç•´è®ºåŸºç¡€ï¼šPostgreSQLæ¨¡å¼ä¸æŸ¥è¯¢çš„èŒƒç•´è®ºè§†è§’

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [èŒƒç•´è®ºåŸºç¡€ï¼šPostgreSQLæ¨¡å¼ä¸æŸ¥è¯¢çš„èŒƒç•´è®ºè§†è§’](#èŒƒç•´è®ºåŸºç¡€postgresqlæ¨¡å¼ä¸æŸ¥è¯¢çš„èŒƒç•´è®ºè§†è§’)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. PostgreSQLæ¨¡å¼ä½œä¸ºèŒƒç•´](#2-postgresqlæ¨¡å¼ä½œä¸ºèŒƒç•´)
    - [2.1. æ¨¡å¼èŒƒç•´å®šä¹‰](#21-æ¨¡å¼èŒƒç•´å®šä¹‰)
    - [2.2. æ¨¡å¼ç¤ºä¾‹](#22-æ¨¡å¼ç¤ºä¾‹)
  - [3. æ•°æ®åº“å®ä¾‹ä½œä¸ºå‡½å­](#3-æ•°æ®åº“å®ä¾‹ä½œä¸ºå‡½å­)
    - [3.1. å®ä¾‹å‡½å­å®šä¹‰](#31-å®ä¾‹å‡½å­å®šä¹‰)
    - [3.2. å®ä¾‹ç¤ºä¾‹](#32-å®ä¾‹ç¤ºä¾‹)
  - [4. æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢](#4-æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢)
    - [4.1. æŸ¥è¯¢è‡ªç„¶å˜æ¢å®šä¹‰](#41-æŸ¥è¯¢è‡ªç„¶å˜æ¢å®šä¹‰)
    - [4.2. JOINæŸ¥è¯¢ç¤ºä¾‹](#42-joinæŸ¥è¯¢ç¤ºä¾‹)
  - [5. æ¨¡å¼æ˜ å°„ä¸æ•°æ®è¿ç§»](#5-æ¨¡å¼æ˜ å°„ä¸æ•°æ®è¿ç§»)
    - [5.1. æ¨¡å¼ç‰ˆæœ¬å‡çº§](#51-æ¨¡å¼ç‰ˆæœ¬å‡çº§)
    - [5.2. Kanæ‰©å±•åº”ç”¨](#52-kanæ‰©å±•åº”ç”¨)
  - [6. æŸ¥è¯¢ä¼˜åŒ–çš„èŒƒç•´è®ºæ–¹æ³•](#6-æŸ¥è¯¢ä¼˜åŒ–çš„èŒƒç•´è®ºæ–¹æ³•)
    - [6.1. æŸ¥è¯¢é‡å†™çš„è‡ªç„¶å˜æ¢](#61-æŸ¥è¯¢é‡å†™çš„è‡ªç„¶å˜æ¢)
    - [6.2. æŠ•å½±ä¸‹æ¨](#62-æŠ•å½±ä¸‹æ¨)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£ä»èŒƒç•´è®ºè§†è§’åˆ†æPostgreSQLçš„æ•°æ®åº“æ¨¡å¼ã€å®ä¾‹å’ŒæŸ¥è¯¢ï¼Œæä¾›ç»Ÿä¸€çš„æ•°å­¦æ¡†æ¶æ¥ç†è§£æ•°æ®åº“ç³»ç»Ÿçš„ç»“æ„ã€‚

---

## 2. PostgreSQLæ¨¡å¼ä½œä¸ºèŒƒç•´

### 2.1. æ¨¡å¼èŒƒç•´å®šä¹‰

**PostgreSQLæ¨¡å¼èŒƒç•´**ï¼š

```haskell
-- PostgreSQLæ¨¡å¼èŒƒç•´
data PostgreSQLSchema = PGSchema {
    schemas :: [Schema],
    tables :: [Table],
    foreignKeys :: [ForeignKey],
    constraints :: [Constraint],
    indexes :: [Index]
}

-- è¡¨ä½œä¸ºå¯¹è±¡
data Table = Table {
    schema :: Schema,
    name :: TableName,
    columns :: [Column],
    primaryKey :: PrimaryKey,
    constraints :: [TableConstraint]
}

-- å¤–é”®ä½œä¸ºæ€å°„
data ForeignKey = ForeignKey {
    fromTable :: Table,
    toTable :: Table,
    columns :: [(Column, Column)],
    onDelete :: OnDeleteAction,
    onUpdate :: OnUpdateAction
}
```

### 2.2. æ¨¡å¼ç¤ºä¾‹

**ç¤ºä¾‹æ¨¡å¼**ï¼š

```sql
-- åˆ›å»ºç¤ºä¾‹æ¨¡å¼
CREATE SCHEMA ecommerce;

CREATE TABLE ecommerce.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE ecommerce.orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES ecommerce.users(id) ON DELETE CASCADE,
    total_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE ecommerce.order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES ecommerce.orders(id) ON DELETE CASCADE,
    product_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2) NOT NULL
);
```

**èŒƒç•´è¡¨ç¤º**ï¼š

```text
æ¨¡å¼èŒƒç•´ Schema:
  å¯¹è±¡: {users, orders, order_items}
  æ€å°„:
    - users â†’ orders (å¤–é”®: user_id)
    - orders â†’ order_items (å¤–é”®: order_id)
```

---

## 3. æ•°æ®åº“å®ä¾‹ä½œä¸ºå‡½å­

### 3.1. å®ä¾‹å‡½å­å®šä¹‰

**æ•°æ®åº“å®ä¾‹ä½œä¸ºå‡½å­**ï¼š

```haskell
-- æ•°æ®åº“å®ä¾‹ä½œä¸ºä»æ¨¡å¼èŒƒç•´åˆ°SetèŒƒç•´çš„å‡½å­
instance Functor DatabaseInstance where
    type Source DatabaseInstance = PostgreSQLSchema
    type Target DatabaseInstance = Set

    fmap :: Table -> Set Row
    fmap table = rows table

    preserve :: ForeignKey -> (Set Row -> Set Row)
    preserve fk = \rows -> filterRowsByFK fk rows
```

### 3.2. å®ä¾‹ç¤ºä¾‹

**ç¤ºä¾‹å®ä¾‹**ï¼š

```sql
-- æ’å…¥ç¤ºä¾‹æ•°æ®
INSERT INTO ecommerce.users (username, email) VALUES
    ('alice', 'alice@example.com'),
    ('bob', 'bob@example.com');

INSERT INTO ecommerce.orders (user_id, total_amount, status) VALUES
    (1, 99.99, 'completed'),
    (1, 49.99, 'pending'),
    (2, 199.99, 'completed');

INSERT INTO ecommerce.order_items (order_id, product_id, quantity, price) VALUES
    (1, 101, 2, 49.99),
    (2, 102, 1, 49.99),
    (3, 103, 3, 66.66);
```

**å‡½å­è¡¨ç¤º**ï¼š

```text
å®ä¾‹å‡½å­ I: Schema â†’ Set
  I(users) = {alice, bob}
  I(orders) = {order1, order2, order3}
  I(order_items) = {item1, item2, item3}

å¤–é”®çº¦æŸä¿æŒï¼š
  I(user_id: orders â†’ users) = {1 â†’ alice, 1 â†’ alice, 2 â†’ bob}
```

---

## 4. æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢

### 4.1. æŸ¥è¯¢è‡ªç„¶å˜æ¢å®šä¹‰

**æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢**ï¼š

```haskell
-- æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢
data QueryNaturalTransformation = QueryNT {
    source :: QueryPlan,
    target :: QueryPlan,
    components :: forall table. Table -> QueryResult
}

-- SELECTæŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢
selectQuery :: QueryNaturalTransformation
selectQuery = QueryNT {
    source = FullTableScan,
    target = FilteredResult,
    components = \table -> filterRows table
}
```

### 4.2. JOINæŸ¥è¯¢ç¤ºä¾‹

**JOINæŸ¥è¯¢**ï¼š

```sql
-- JOINæŸ¥è¯¢ï¼šè·å–ç”¨æˆ·åŠå…¶è®¢å•
SELECT u.username, o.id, o.total_amount, o.status
FROM ecommerce.users u
JOIN ecommerce.orders o ON u.id = o.user_id
WHERE o.status = 'completed';
```

**è‡ªç„¶å˜æ¢è¡¨ç¤º**ï¼š

```text
æŸ¥è¯¢è‡ªç„¶å˜æ¢ Î·: I â†’ J
  å…¶ä¸­ I æ˜¯æºå®ä¾‹ï¼ŒJ æ˜¯ç»“æœå®ä¾‹

  Î·_users: I(users) â†’ J(result)
  Î·_orders: I(orders) â†’ J(result)

è‡ªç„¶æ€§æ¡ä»¶ï¼š
  Î·_orders âˆ˜ I(user_id) = J(user_id) âˆ˜ Î·_users
```

---

## 5. æ¨¡å¼æ˜ å°„ä¸æ•°æ®è¿ç§»

### 5.1. æ¨¡å¼ç‰ˆæœ¬å‡çº§

**ç‰ˆæœ¬å‡çº§æ˜ å°„**ï¼š

```sql
-- æ—§æ¨¡å¼ v1
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT
);

-- æ–°æ¨¡å¼ v2
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    first_name TEXT,
    last_name TEXT
);
```

**èŒƒç•´è®ºæ˜ å°„**ï¼š

```haskell
-- æ¨¡å¼æ˜ å°„ä½œä¸ºå‡½å­
mapping :: Schema_v1 -> Schema_v2
mapping Users_v1 = Users_v2
mapping (name) = (first_name, last_name)  -- åˆ—æ‹†åˆ†

-- æ•°æ®è¿ç§»ä½œä¸ºè‡ªç„¶å˜æ¢
migration :: DatabaseInstance_v1 -> DatabaseInstance_v2
migration = naturalTransformation {
    components = \table -> migrateTable table
}
```

### 5.2. Kanæ‰©å±•åº”ç”¨

**ä½¿ç”¨Kanæ‰©å±•è¿›è¡Œæ•°æ®è¿ç§»**ï¼š

```haskell
-- å·¦Kanæ‰©å±•
Lan_F G = colim (F â†“ -) G

-- å³Kanæ‰©å±•
Ran_F G = lim (- â†“ F) G

-- æ•°æ®è¿ç§»
migrateData :: Schema_v1 -> Schema_v2 -> Instance_v1 -> Instance_v2
migrateData schema1 schema2 instance1 =
    kanExtension schema1 schema2 instance1
```

---

## 6. æŸ¥è¯¢ä¼˜åŒ–çš„èŒƒç•´è®ºæ–¹æ³•

### 6.1. æŸ¥è¯¢é‡å†™çš„è‡ªç„¶å˜æ¢

**é€‰æ‹©ä¸‹æ¨**ï¼š

```sql
-- åŸå§‹æŸ¥è¯¢
SELECT * FROM (
    SELECT * FROM users WHERE age > 25
) u
JOIN orders o ON u.id = o.user_id
WHERE o.total_amount > 100;

-- ä¼˜åŒ–åæŸ¥è¯¢ï¼ˆé€‰æ‹©ä¸‹æ¨ï¼‰
SELECT * FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.age > 25 AND o.total_amount > 100;
```

**è‡ªç„¶å˜æ¢è¡¨ç¤º**ï¼š

```haskell
-- é€‰æ‹©ä¸‹æ¨ä½œä¸ºè‡ªç„¶å˜æ¢
selectPushDown :: QueryNaturalTransformation
selectPushDown = QueryNT {
    source = JoinPlan (SelectPlan table1) table2,
    target = SelectPlan (JoinPlan table1 table2),
    components = \table -> pushSelectDown table
}
```

### 6.2. æŠ•å½±ä¸‹æ¨

**æŠ•å½±ä¸‹æ¨**ï¼š

```sql
-- åŸå§‹æŸ¥è¯¢
SELECT u.username, o.total_amount FROM (
    SELECT id, username, email, created_at FROM users
) u
JOIN (
    SELECT id, user_id, total_amount, status, created_at FROM orders
) o ON u.id = o.user_id;

-- ä¼˜åŒ–åæŸ¥è¯¢ï¼ˆæŠ•å½±ä¸‹æ¨ï¼‰
SELECT u.username, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id;
```

---

## 7. å‚è€ƒèµ„æ–™

- [æ•°æ®åº“è®¾è®¡ç†è®ºæ‰©å±•è®¡åˆ’](../../Design/00-æ•°æ®åº“è®¾è®¡ç†è®ºæ‰©å±•è®¡åˆ’.md)
- [èŒƒç•´è®ºåŸºç¡€](../../Design/01-ç†è®ºæ¨¡å‹/01.01-èŒƒç•´è®ºåŸºç¡€.md)
- [PostgreSQLç³»ç»Ÿæ¶æ„](../01-æ ¸å¿ƒåŸºç¡€/01.01-ç³»ç»Ÿæ¶æ„ä¸è®¾è®¡åŸç†.md)
- [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md)

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
