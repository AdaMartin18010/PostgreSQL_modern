---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\02-èŒƒç•´è®ºåº”ç”¨\02.03-å…³ç³»çŸ¥è¯†å›¾è½¬æ¢æ¡†æ¶.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# å…³ç³»çŸ¥è¯†å›¾è½¬æ¢æ¡†æ¶ï¼šPostgreSQLå…³ç³»æ•°æ®åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„

> **åˆ›å»ºæ—¥æœŸ**ï¼š2025-01-15
> **æœ€åæ›´æ–°**ï¼š2025-01-15
> **ç‰ˆæœ¬**ï¼šv1.0
> **çŠ¶æ€**ï¼šå®æ–½ä¸­

---

## ğŸ“‹ ç›®å½•

- [å…³ç³»çŸ¥è¯†å›¾è½¬æ¢æ¡†æ¶ï¼šPostgreSQLå…³ç³»æ•°æ®åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„](#å…³ç³»çŸ¥è¯†å›¾è½¬æ¢æ¡†æ¶postgresqlå…³ç³»æ•°æ®åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. å…³ç³»æ¨¡å‹åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„](#2-å…³ç³»æ¨¡å‹åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„)
    - [2.1. æ˜ å°„å‡½å­å®šä¹‰](#21-æ˜ å°„å‡½å­å®šä¹‰)
    - [2.2. è¡¨åˆ°å®ä½“çš„æ˜ å°„](#22-è¡¨åˆ°å®ä½“çš„æ˜ å°„)
    - [2.3. å¤–é”®åˆ°å…³ç³»çš„æ˜ å°„](#23-å¤–é”®åˆ°å…³ç³»çš„æ˜ å°„)
    - [2.4. æ˜ å°„ç¤ºä¾‹](#24-æ˜ å°„ç¤ºä¾‹)
  - [3. çŸ¥è¯†å›¾è°±æŸ¥è¯¢æ¡†æ¶](#3-çŸ¥è¯†å›¾è°±æŸ¥è¯¢æ¡†æ¶)
    - [3.1. å›¾æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢](#31-å›¾æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢)
    - [3.2. SPARQLæŸ¥è¯¢æ˜ å°„](#32-sparqlæŸ¥è¯¢æ˜ å°„)
    - [3.3. å›¾æŸ¥è¯¢ç¤ºä¾‹](#33-å›¾æŸ¥è¯¢ç¤ºä¾‹)
  - [4. çŸ¥è¯†æ¨ç†æ¡†æ¶](#4-çŸ¥è¯†æ¨ç†æ¡†æ¶)
    - [4.1. æ¨ç†è§„åˆ™å®šä¹‰](#41-æ¨ç†è§„åˆ™å®šä¹‰)
    - [4.2. æ¨ç†å¼•æ“](#42-æ¨ç†å¼•æ“)
    - [4.3. æ¨ç†ç¤ºä¾‹](#43-æ¨ç†ç¤ºä¾‹)
  - [5. å‚è€ƒèµ„æ–™](#5-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›PostgreSQLå…³ç³»æ•°æ®åˆ°çŸ¥è¯†å›¾è°±çš„è½¬æ¢æ¡†æ¶ï¼Œä½¿ç”¨èŒƒç•´è®ºæ–¹æ³•å»ºç«‹å…³ç³»æ¨¡å‹å’ŒçŸ¥è¯†å›¾è°±ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚

---

## 2. å…³ç³»æ¨¡å‹åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„

### 2.1. æ˜ å°„å‡½å­å®šä¹‰

**å…³ç³»æ¨¡å‹åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„å‡½å­**ï¼š

```haskell
-- å…³ç³»æ¨¡å‹åˆ°çŸ¥è¯†å›¾è°±çš„æ˜ å°„å‡½å­
class ToKnowledgeGraph a where
    toKnowledgeGraph :: a -> KnowledgeGraph

-- å…³ç³»æ¨¡å‹åˆ°çŸ¥è¯†å›¾è°±
instance ToKnowledgeGraph RelationalModel where
    toKnowledgeGraph (RelationalModel schema) =
        KnowledgeGraph {
            entities = tablesToEntities schema,
            relations = foreignKeysToRelations schema,
            triples = generateTriples schema
        }
```

### 2.2. è¡¨åˆ°å®ä½“çš„æ˜ å°„

**è¡¨åˆ°å®ä½“æ˜ å°„**ï¼š

```haskell
-- è¡¨åˆ°å®ä½“çš„æ˜ å°„
tablesToEntities :: RelationalSchema -> [Entity]
tablesToEntities schema =
    map tableToEntity (tables schema)

-- å•ä¸ªè¡¨åˆ°å®ä½“
tableToEntity :: Table -> Entity
tableToEntity table = Entity {
    id = tableName table,
    type = tableName table,
    attributes = columnsToAttributes (columns table)
}
```

### 2.3. å¤–é”®åˆ°å…³ç³»çš„æ˜ å°„

**å¤–é”®åˆ°å…³ç³»æ˜ å°„**ï¼š

```haskell
-- å¤–é”®åˆ°å…³ç³»çš„æ˜ å°„
foreignKeysToRelations :: RelationalSchema -> [Relation]
foreignKeysToRelations schema =
    map foreignKeyToRelation (foreignKeys schema)

-- å•ä¸ªå¤–é”®åˆ°å…³ç³»
foreignKeyToRelation :: ForeignKey -> Relation
foreignKeyToRelation fk = Relation {
    source = fromTable fk,
    target = toTable fk,
    type = foreignKeyName fk,
    properties = columnsToProperties (columns fk)
}
```

### 2.4. æ˜ å°„ç¤ºä¾‹

**å…³ç³»è¡¨ç¤ºä¾‹**ï¼š

```sql
-- å…³ç³»è¡¨ï¼šåˆ›å»ºç”¨æˆ·å’Œè®¢å•è¡¨
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email VARCHAR(100)
);

CREATE TABLE IF NOT EXISTS orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    total DECIMAL(10, 2) NOT NULL,
    order_date DATE NOT NULL DEFAULT CURRENT_DATE
);

-- æ’å…¥ç¤ºä¾‹æ•°æ®
INSERT INTO users (name, email) VALUES
    ('Alice', 'alice@example.com'),
    ('Bob', 'bob@example.com'),
    ('Charlie', 'charlie@example.com')
ON CONFLICT DO NOTHING;

INSERT INTO orders (user_id, total, order_date) VALUES
    (1, 100.00, '2024-01-15'),
    (1, 200.00, '2024-01-20'),
    (2, 150.00, '2024-01-18'),
    (3, 300.00, '2024-01-22')
ON CONFLICT DO NOTHING;
```

**çŸ¥è¯†å›¾è°±è¡¨ç¤º**ï¼š

```text
å®ä½“ï¼š
  - users (id, name)
  - orders (id, total)

å…³ç³»ï¼š
  - users --[has_order]--> orders
  - orders --[belongs_to]--> users

ä¸‰å…ƒç»„ï¼š
  - (user:1, has_order, order:1)
  - (order:1, belongs_to, user:1)
```

---

## 3. çŸ¥è¯†å›¾è°±æŸ¥è¯¢æ¡†æ¶

### 3.1. å›¾æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢

**å›¾æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢**ï¼š

```haskell
-- å›¾æŸ¥è¯¢ä½œä¸ºè‡ªç„¶å˜æ¢
data GraphQueryNaturalTransformation = GraphQueryNT {
    source :: KnowledgeGraph,
    target :: QueryResult,
    components :: forall entity. Entity -> QueryResult
}

-- è·¯å¾„æŸ¥è¯¢
pathQuery :: GraphQueryNaturalTransformation
pathQuery = GraphQueryNT {
    source = KnowledgeGraph,
    target = PathResult,
    components = \start -> findPaths start
}
```

### 3.2. SPARQLæŸ¥è¯¢æ˜ å°„

**SPARQLæŸ¥è¯¢æ˜ å°„**ï¼š

```haskell
-- SPARQLæŸ¥è¯¢åˆ°SQLçš„æ˜ å°„
sparqlToSQL :: SPARQLQuery -> SQLQuery
sparqlToSQL (SPARQLQuery patterns) =
    SQLQuery {
        select = patternsToSelect patterns,
        from = patternsToFrom patterns,
        where = patternsToWhere patterns
    }
```

### 3.3. å›¾æŸ¥è¯¢ç¤ºä¾‹

**è·¯å¾„æŸ¥è¯¢**ï¼š

```sql
-- æ•°æ®å‡†å¤‡ï¼ˆuserså’Œordersè¡¨å·²åˆ›å»ºï¼‰

-- ä½¿ç”¨é€’å½’CTEè¿›è¡Œå›¾æŸ¥è¯¢ï¼ˆæŸ¥æ‰¾ç”¨æˆ·çš„æ‰€æœ‰è®¢å•è·¯å¾„ï¼‰
WITH RECURSIVE graph_path AS (
    -- èµ·å§‹èŠ‚ç‚¹ï¼šç”¨æˆ·çš„ç›´æ¥è®¢å•
    SELECT
        u.id AS start_node,
        o.id AS end_node,
        u.name AS start_name,
        CAST(o.id AS TEXT) AS path,
        1 AS depth
    FROM users u
    JOIN orders o ON u.id = o.user_id
    WHERE u.id = 1

    UNION

    -- é€’å½’æ‰©å±•ï¼šå¦‚æœorder_idå¯ä»¥ä½œä¸ºå…¶ä»–å…³ç³»çš„èµ·ç‚¹ï¼ˆè¿™é‡Œåªæ˜¯ç¤ºä¾‹ï¼‰
    -- æ³¨æ„ï¼šå®é™…å›¾æŸ¥è¯¢ä¸­ï¼Œorder_idå¯èƒ½éœ€è¦è¿æ¥åˆ°å…¶ä»–å®ä½“
    SELECT
        gp.start_node,
        o.id AS end_node,
        gp.start_name,
        gp.path || ' -> ' || o.id::TEXT,
        gp.depth + 1
    FROM graph_path gp
    JOIN orders o ON gp.end_node = o.user_id  -- æ³¨æ„ï¼šè¿™é‡Œçš„é€»è¾‘å¯èƒ½éœ€è¦æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´
    WHERE gp.depth < 5
)
SELECT * FROM graph_path;
```

---

## 4. çŸ¥è¯†æ¨ç†æ¡†æ¶

### 4.1. æ¨ç†è§„åˆ™å®šä¹‰

**æ¨ç†è§„åˆ™**ï¼š

```haskell
-- çŸ¥è¯†æ¨ç†è§„åˆ™
data InferenceRule = InferenceRule {
    premise :: [Triple],
    conclusion :: Triple
}

-- ä¼ é€’æ€§æ¨ç†è§„åˆ™
transitivityRule :: InferenceRule
transitivityRule = InferenceRule {
    premise = [
        Triple (e1, r1, e2),
        Triple (e2, r2, e3)
    ],
    conclusion = Triple (e1, compose r1 r2, e3)
}
```

### 4.2. æ¨ç†å¼•æ“

**æ¨ç†å¼•æ“**ï¼š

```haskell
-- æ¨ç†å¼•æ“
infer :: [InferenceRule] -> KnowledgeGraph -> KnowledgeGraph
infer rules kg =
    foldl applyRule kg rules

-- åº”ç”¨è§„åˆ™
applyRule :: KnowledgeGraph -> InferenceRule -> KnowledgeGraph
applyRule kg rule =
    if matchesPremise kg (premise rule)
    then addTriple kg (conclusion rule)
    else kg
```

### 4.3. æ¨ç†ç¤ºä¾‹

**ä¼ é€’æ€§æ¨ç†**ï¼š

```text
å·²çŸ¥ä¸‰å…ƒç»„ï¼š
  - (Alice, knows, Bob)
  - (Bob, knows, Charlie)

åº”ç”¨ä¼ é€’æ€§è§„åˆ™ï¼š
  - (Alice, knows, Charlie)
```

**SQLå®ç°**ï¼š

```sql
-- æ•°æ®å‡†å¤‡ï¼šåˆ›å»ºå…³ç³»è¡¨ï¼ˆè¡¨ç¤ºçŸ¥è¯†å›¾è°±ä¸­çš„ä¸‰å…ƒç»„ï¼‰
CREATE TABLE IF NOT EXISTS relations (
    id SERIAL PRIMARY KEY,
    source VARCHAR(100) NOT NULL,
    relation VARCHAR(50) NOT NULL,
    target VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ’å…¥ç¤ºä¾‹æ•°æ®ï¼ˆè¡¨ç¤º"knows"å…³ç³»ï¼‰
INSERT INTO relations (source, relation, target) VALUES
    ('Alice', 'knows', 'Bob'),
    ('Bob', 'knows', 'Charlie'),
    ('Charlie', 'knows', 'David'),
    ('Alice', 'knows', 'Eve'),
    ('Eve', 'knows', 'Frank')
ON CONFLICT DO NOTHING;

-- ä¼ é€’æ€§æ¨ç†æŸ¥è¯¢ï¼šæ‰¾å‡ºé€šè¿‡ä¼ é€’æ€§å¯ä»¥æ¨å¯¼å‡ºçš„å…³ç³»
WITH inferred_relations AS (
    SELECT DISTINCT
        t1.source AS source,
        t2.target AS target,
        'knows' AS relation
    FROM relations t1
    JOIN relations t2 ON t1.target = t2.source
    WHERE t1.relation = 'knows' AND t2.relation = 'knows'
)
SELECT * FROM inferred_relations;
-- ç»“æœç¤ºä¾‹ï¼š
-- Alice knows Charlie (é€šè¿‡Bob)
-- Bob knows David (é€šè¿‡Charlie)
-- Alice knows Frank (é€šè¿‡Eve)
```

---

## 5. å‚è€ƒèµ„æ–™

- [æ•°æ®æ¨¡å‹è®¾è®¡](../../17-æ•°æ®æ¨¡å‹è®¾è®¡/README.md) - æ•°æ®åº“è®¾è®¡ç†è®º
- [å¤šæ¨¡å‹æ•°æ®åº“](../../07-å¤šæ¨¡å‹æ•°æ®åº“/README.md) - çŸ¥è¯†å›¾è°±ç†è®º
- [èŒƒç•´è®ºåŸºç¡€](../25.01-å½¢å¼åŒ–æ–¹æ³•/01.03-èŒƒç•´è®ºåŸºç¡€.md) - èŒƒç•´è®ºåŸºç¡€
- [å¤šæ¨¡å‹æ•°æ®åº“](../../07-å¤šæ¨¡å‹æ•°æ®åº“/README.md) - å›¾æ•°æ®åº“åŠŸèƒ½

---

**æœ€åæ›´æ–°**ï¼š2025-01-15
**ç»´æŠ¤è€…**ï¼šData-Science Team
**çŠ¶æ€**ï¼šå®æ–½ä¸­
