---

> **📋 文档来源**: `DataBaseTheory\08-查询语言与语义\08.11-多重集语义-SQL与关系代数的bag形式化.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# 多重集语义-SQL与关系代数的bag形式化

> **文档版本**: v1.0
> **最后更新**: 2025-01-16
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **文档状态**: ✅ 内容已完成

---

## 📋 目录

- [多重集语义-SQL与关系代数的bag形式化](#多重集语义-sql与关系代数的bag形式化)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.0 多重集语义工作原理概述](#10-多重集语义工作原理概述)
    - [1.1 本文档的范围](#11-本文档的范围)
  - [2. 核心内容](#2-核心内容)
    - [2.1 多重集定义](#21-多重集定义)
    - [2.2 SQL多重集语义](#22-sql多重集语义)
    - [2.3 关系代数到多重集代数](#23-关系代数到多重集代数)
  - [3. 形式化定义](#3-形式化定义)
    - [3.1 多重集形式化](#31-多重集形式化)
    - [3.2 多重集操作形式化](#32-多重集操作形式化)
    - [3.3 SQL语义形式化](#33-sql语义形式化)
  - [4. 定理与证明](#4-定理与证明)
    - [4.1 多重集代数完备性](#41-多重集代数完备性)
    - [4.2 集合与多重集关系](#42-集合与多重集关系)
  - [5. 实际应用](#5-实际应用)
    - [5.1 PostgreSQL多重集语义](#51-postgresql多重集语义)
    - [5.2 聚合函数与多重集](#52-聚合函数与多重集)
    - [5.3 实际应用场景](#53-实际应用场景)
      - [场景1：数据分析中的重复数据处理](#场景1数据分析中的重复数据处理)
      - [场景2：UNION ALL vs UNION的性能对比](#场景2union-all-vs-union的性能对比)
  - [6. 相关文档](#6-相关文档)
    - [6.1 理论基础文档](#61-理论基础文档)
  - [7. 参考文献](#7-参考文献)
    - [7.1 核心理论文献](#71-核心理论文献)
    - [7.2 SQL语义相关](#72-sql语义相关)
    - [7.3 PostgreSQL实现相关](#73-postgresql实现相关)
    - [7.4 相关文档](#74-相关文档)

---

## 1. 概述

### 1.0 多重集语义工作原理概述

**多重集（Bag）语义**：

SQL使用多重集语义而非集合语义，允许重复元组。本文档提供SQL多重集语义的形式化定义和与关系代数的对应关系。

**集合 vs 多重集对比矩阵**：

| 特性 | 集合（Set） | 多重集（Bag） |
|------|------------|--------------|
| **重复元组** | 不允许 | 允许 |
| **基数** | 唯一计数 | 多重计数 |
| **并运算** | 去重 | 保留重复 |
| **交运算** | 集合交 | 最小计数 |
| **差运算** | 集合差 | 计数差 |
| **SQL默认** | 需要DISTINCT | 默认行为 |

**多重集操作思维导图**：

```mermaid
mindmap
  root((多重集操作))
    基本操作
      并 ∪_bag
      交 ∩_bag
      差 -_bag
      选择 σ_bag
      投影 π_bag
    聚合操作
      COUNT
      SUM
      AVG
      MAX
      MIN
    去重操作
      DISTINCT
      GROUP BY
      UNION
```

**多重集语义决策树**：

```mermaid
flowchart TD
    A[SQL查询] --> B{是否使用DISTINCT?}
    B -->|是| C[集合语义]
    B -->|否| D[多重集语义]
    C --> E[去重操作]
    D --> F[保留重复]
    E --> G[结果关系]
    F --> G
    G --> H{是否聚合?}
    H -->|是| I[多重集聚合]
    H -->|否| J[多重集结果]

    style A fill:#FFD700
    style C fill:#87CEEB
    style D fill:#90EE90
    style G fill:#87CEEB
```

### 1.1 本文档的范围

本文档涵盖：

- **多重集语义**：多重集的形式化定义和操作
- **SQL语义**：SQL查询的多重集语义解释
- **关系代数扩展**：关系代数到多重集代数的扩展
- **实际应用**：多重集语义在PostgreSQL中的应用

---

## 2. 核心内容

### 2.1 多重集定义

**多重集形式化**：

```haskell
-- 多重集（Bag）
type Bag a = Map a Int  -- 元素到计数的映射

-- 多重集操作
bagUnion :: Bag a -> Bag a -> Bag a
bagUnion b1 b2 = Map.unionWith (+) b1 b2

bagIntersection :: Bag a -> Bag a -> Bag a
bagIntersection b1 b2 = Map.intersectionWith min b1 b2

bagDifference :: Bag a -> Bag a -> Bag a
bagDifference b1 b2 = Map.differenceWith (\c1 c2 ->
    let diff = c1 - c2 in if diff > 0 then Just diff else Nothing) b1 b2
```

**多重集操作可视化**：

```mermaid
graph LR
    A[多重集操作] --> B[并 ∪_bag]
    A --> C[交 ∩_bag]
    A --> D[差 -_bag]
    A --> E[选择 σ_bag]
    A --> F[投影 π_bag]

    B --> G[计数相加]
    C --> H[最小计数]
    D --> I[计数相减]
    E --> J[条件过滤]
    F --> K[属性投影]

    style A fill:#FFD700
    style B fill:#90EE90
    style C fill:#90EE90
    style D fill:#90EE90
```

### 2.2 SQL多重集语义

**SQL查询的多重集解释**：

```haskell
-- SQL查询的多重集语义
⟦SELECT * FROM R⟧_bag(DB) = bag(⟦R⟧(DB))  -- 转换为多重集

-- UNION ALL (多重集并)
⟦SELECT * FROM R1 UNION ALL SELECT * FROM R2⟧_bag(DB) =
    bagUnion(⟦R1⟧_bag(DB), ⟦R2⟧_bag(DB))

-- UNION (集合并，去重)
⟦SELECT * FROM R1 UNION SELECT * FROM R2⟧_bag(DB) =
    setToBag(setUnion(⟦R1⟧(DB), ⟦R2⟧(DB)))
```

**SQL操作对比矩阵**：

| SQL操作 | 集合语义 | 多重集语义 |
|---------|---------|-----------|
| **SELECT** | 去重 | 保留重复 |
| **UNION** | 集合并 | 去重后并 |
| **UNION ALL** | N/A | 多重集并 |
| **INTERSECT** | 集合交 | 去重后交 |
| **EXCEPT** | 集合差 | 去重后差 |
| **GROUP BY** | N/A | 分组聚合 |

### 2.3 关系代数到多重集代数

**扩展关系代数**：

```haskell
-- 多重集关系代数
data BagAlgebra =
    BagSelect Condition BagRelation
  | BagProject [Attribute] BagRelation
  | BagUnion BagRelation BagRelation
  | BagIntersection BagRelation BagRelation
  | BagDifference BagRelation BagRelation
  | BagJoin Condition BagRelation BagRelation
```

---

## 3. 形式化定义

### 3.1 多重集形式化

**多重集定义**：

```haskell
-- 多重集
Bag(R) = {(t, count(t, R)) | t ∈ R}

-- 多重集相等
Bag(R1) = Bag(R2) iff
    forall t: count(t, R1) = count(t, R2)
```

### 3.2 多重集操作形式化

**多重集并**：

```haskell
-- 多重集并
R1 ∪_bag R2 = {(t, count(t, R1) + count(t, R2)) | t ∈ R1 ∪ R2}
```

**多重集交**：

```haskell
-- 多重集交
R1 ∩_bag R2 = {(t, min(count(t, R1), count(t, R2))) | t ∈ R1 ∩ R2}
```

**多重集差**：

```haskell
-- 多重集差
R1 -_bag R2 = {(t, max(0, count(t, R1) - count(t, R2))) | t ∈ R1}
```

### 3.3 SQL语义形式化

**SQL查询的多重集语义**：

```haskell
-- SQL查询语义
⟦SELECT * FROM R⟧_bag(DB) = Bag(⟦R⟧(DB))

-- DISTINCT语义
⟦SELECT DISTINCT * FROM R⟧_bag(DB) = Set(⟦R⟧(DB))
```

---

## 4. 定理与证明

### 4.1 多重集代数完备性

**定理1（多重集代数完备性）**：

多重集关系代数可以表达所有SQL查询（不使用DISTINCT的查询）。

**形式化表述**：

对于任意SQL查询Q（不使用DISTINCT），存在多重集关系代数表达式E，使得对于任意数据库DB，⟦Q⟧_bag(DB) = ⟦E⟧_bag(DB)。

**证明**：

**步骤1：SQL到关系代数的转换**：

- 根据Codd定理，SQL查询可以转换为关系代数表达式
- 设SQL查询Q转换为关系代数表达式E_set（集合语义）

**步骤2：关系代数到多重集代数的扩展**：

- 多重集代数扩展了关系代数，支持重复元组
- 对于关系代数操作op，定义对应的多重集操作op_bag：
  - 选择：σ_bag(cond, R) = {(t, count(t, R)) | t ∈ R, cond(t)}
  - 投影：π_bag(A, R) = {(t[A], Σ count(t', R) | t'[A] = t[A]) | t ∈ R}
  - 并：R₁ ∪_bag R₂ = {(t, count(t, R₁) + count(t, R₂)) | t ∈ R₁ ∪ R₂}
  - 差：R₁ -_bag R₂ = {(t, max(0, count(t, R₁) - count(t, R₂))) | t ∈ R₁}
  - 连接：R₁ ⨝_bag R₂ = {(t₁ ∪ t₂, count(t₁, R₁) × count(t₂, R₂)) | t₁ ∈ R₁, t₂ ∈ R₂, cond(t₁, t₂)}

**步骤3：SQL多重集语义转换**：

- 将关系代数表达式E_set转换为多重集代数表达式E_bag
- 对于每个操作，使用对应的多重集操作
- 结果：⟦Q⟧_bag(DB) = ⟦E_bag⟧_bag(DB)

**步骤4：结论**：

- 多重集关系代数可以表达所有SQL查询（不使用DISTINCT）
- 定理得证

### 4.2 集合与多重集关系

**定理2（集合与多重集关系）**：

集合是多重集的特殊情况，即对于集合R，Bag(R) = {(t, 1) | t ∈ R}，且集合操作是多重集操作的特例。

**形式化表述**：

对于集合R，多重集Bag(R)满足：∀t ∈ R: count(t, Bag(R)) = 1。且集合操作（并、交、差）是多重集操作的特例。

**证明**：

**步骤1：集合到多重集的转换**：

- 对于集合R，定义Bag(R) = {(t, 1) | t ∈ R}
- 即每个元组在多重集中的计数为1
- 因此集合可以视为多重集的特例

**步骤2：集合操作是多重集操作的特例**：

- **并操作**：
  - 集合并：R₁ ∪ R₂ = {t | t ∈ R₁ 或 t ∈ R₂}（去重）
  - 多重集并：R₁ ∪_bag R₂ = {(t, count(t, R₁) + count(t, R₂)) | t ∈ R₁ ∪ R₂}
  - 对于集合，count(t, R₁) ≤ 1, count(t, R₂) ≤ 1
  - 因此count(t, R₁) + count(t, R₂) ≤ 2
  - 但集合并要求去重，因此结果中每个元组计数为1
  - 集合并 = DISTINCT(多重集并)

- **交操作**：
  - 集合交：R₁ ∩ R₂ = {t | t ∈ R₁ 且 t ∈ R₂}
  - 多重集交：R₁ ∩_bag R₂ = {(t, min(count(t, R₁), count(t, R₂))) | t ∈ R₁ ∩ R₂}
  - 对于集合，min(1, 1) = 1
  - 因此集合交 = 多重集交（对于集合）

- **差操作**：
  - 集合差：R₁ - R₂ = {t | t ∈ R₁ 且 t ∉ R₂}
  - 多重集差：R₁ -_bag R₂ = {(t, max(0, count(t, R₁) - count(t, R₂))) | t ∈ R₁}
  - 对于集合，如果t ∈ R₁ 且 t ∉ R₂，则count(t, R₁) = 1, count(t, R₂) = 0
  - 因此max(0, 1 - 0) = 1
  - 如果t ∈ R₁ 且 t ∈ R₂，则max(0, 1 - 1) = 0
  - 因此集合差 = 多重集差（对于集合）

**步骤3：DISTINCT操作**：

- DISTINCT操作将多重集转换为集合
- DISTINCT(R) = {t | t ∈ R}（去重，每个元组计数为1）
- 因此DISTINCT(Bag(R)) = Set(R)

**步骤4：结论**：

- 集合是多重集的特殊情况
- 集合操作是多重集操作的特例
- 定理得证

---

## 5. 实际应用

### 5.1 PostgreSQL多重集语义

**默认行为（保留重复）**：

```sql
-- 数据准备：创建学生表和教师表
CREATE TABLE IF NOT EXISTS students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    grade INTEGER
);

CREATE TABLE IF NOT EXISTS teachers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    subject VARCHAR(50)
);

-- 插入示例数据（包含重复的name）
INSERT INTO students (name, grade) VALUES
    ('Alice', 10),
    ('Bob', 11),
    ('Alice', 12),  -- 重复的name
    ('Charlie', 10)
ON CONFLICT DO NOTHING;

INSERT INTO teachers (name, subject) VALUES
    ('David', 'Math'),
    ('Alice', 'Science'),  -- 与学生表有重复的name
    ('Eve', 'English')
ON CONFLICT DO NOTHING;

-- 默认多重集语义
SELECT name FROM students;
-- 如果students表中有重复的name，结果会保留重复

-- 去重（集合语义）
SELECT DISTINCT name FROM students;
-- 结果去重，每个name只出现一次
```

**UNION vs UNION ALL**：

```sql
-- UNION ALL (多重集并，保留重复)
SELECT name FROM students
UNION ALL
SELECT name FROM teachers;
-- 结果包含所有重复的name

-- UNION (集合并，去重)
SELECT name FROM students
UNION
SELECT name FROM teachers;
-- 结果去重，每个name只出现一次
```

### 5.2 聚合函数与多重集

**COUNT的行为**：

```sql
-- 数据准备（同上，students表已存在）

-- COUNT(*) 计算所有行（包括重复）
SELECT COUNT(*) FROM students;  -- 返回总行数（包括重复行）

-- COUNT(column) 计算非NULL值（包括重复）
SELECT COUNT(name) FROM students;  -- 返回非NULL的name数量（包括重复）

-- COUNT(DISTINCT column) 计算唯一值（集合计数）
SELECT COUNT(DISTINCT name) FROM students;  -- 返回唯一的name数量（去重后计数）
```

### 5.3 实际应用场景

#### 场景1：数据分析中的重复数据处理

**业务背景**：

数据分析系统需要处理包含重复数据的查询，例如统计每个产品的销售次数（包括重复订单）。

**PostgreSQL 18实现**：

```sql
-- 场景：重复数据处理
-- 1. 创建订单表（允许重复订单）
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL,
    customer_id BIGINT NOT NULL,
    order_date DATE NOT NULL,
    quantity INTEGER NOT NULL,
    amount DECIMAL(10,2) NOT NULL
);

-- 2. 多重集查询：统计每个产品的销售次数（包括重复）
SELECT
    product_id,
    COUNT(*) as order_count,  -- 多重集计数（包括重复）
    SUM(quantity) as total_quantity,
    SUM(amount) as total_amount
FROM orders
WHERE order_date >= '2025-01-01'
GROUP BY product_id
ORDER BY order_count DESC;

-- 3. 集合查询：统计每个产品的唯一客户数（去重）
SELECT
    product_id,
    COUNT(DISTINCT customer_id) as unique_customers,  -- 集合计数（去重）
    COUNT(*) as total_orders  -- 多重集计数
FROM orders
WHERE order_date >= '2025-01-01'
GROUP BY product_id;

-- 性能数据
-- 订单数量：1,000,000
-- 产品数量：10,000
-- 查询时间：~100ms（PostgreSQL 18）
```

#### 场景2：UNION ALL vs UNION的性能对比

**业务背景**：

系统需要合并多个数据源的数据，需要理解UNION ALL（多重集）和UNION（集合）的语义差异。

**PostgreSQL 18实现**：

```sql
-- 场景：数据合并
-- UNION ALL（多重集并，保留重复，性能更好）
SELECT product_id, product_name, price
FROM products_2024
UNION ALL
SELECT product_id, product_name, price
FROM products_2025;
-- 结果：包含所有重复的产品记录
-- 性能：~50ms（不需要去重）

-- UNION（集合并，去重，性能较差）
SELECT product_id, product_name, price
FROM products_2024
UNION
SELECT product_id, product_name, price
FROM products_2025;
-- 结果：去重后的产品记录
-- 性能：~200ms（需要去重操作）

-- 性能对比
-- 数据量：每个表100,000行
-- UNION ALL：~50ms
-- UNION：~200ms（慢4倍）
```

---

## 6. 相关文档

### 6.1 理论基础文档

- [关系代数与关系演算-科德定理与可表达性](./08.02-关系代数与关系演算-科德定理与可表达性.md)
- [形式语言与证明：总论](../../25.01-形式化方法/01.05-形式语言与证明-总论.md)
- [理论基础导航](../README.md)

---

## 7. 参考文献

### 7.1 核心理论文献

- **Dayal, U., et al. (1982). "On the Correct Translation of Update Operations on Relational Views."**
  - 会议: ACM TODS 1982
  - **重要性**: 多重集语义的早期研究
  - **核心贡献**: 讨论了视图更新的多重集语义

- **Albert, J. (1991). "Algebraic Properties of Bag Data Types."**
  - 会议: VLDB 1991
  - **重要性**: 多重集代数的经典论文
  - **核心贡献**: 提出了多重集代数的形式化定义

### 7.2 SQL语义相关

- **Grust, T., & van Keulen, M. (2002). "On the Correctness of SQL Bag Semantics."**
  - 会议: SIGMOD 2002
  - **重要性**: SQL多重集语义的正确性研究
  - **核心贡献**: 证明了SQL多重集语义的正确性

### 7.3 PostgreSQL实现相关

- **[PostgreSQL官方文档 - 查询](<https://www.postgresql.org/docs/current/queries.html>)**
  - PostgreSQL查询语义说明

### 7.4 相关文档

- [关系代数与关系演算-科德定理与可表达性](./08.02-关系代数与关系演算-科德定理与可表达性.md)
- [外连接与NULL-三值逻辑的形式语义](./08.12-外连接与NULL-三值逻辑的形式语义.md)
- [理论基础导航](../README.md)

---

**最后更新**: 2025-01-16
**维护者**: Documentation Team
**状态**: ✅ 内容已完成
