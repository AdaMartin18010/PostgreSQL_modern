---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\08-æŸ¥è¯¢è¯­è¨€ä¸è¯­ä¹‰\08.03-åŒæ€ä¸æŸ¥è¯¢åŒ…å«-Containment_Equivalenceåˆ¤å®š.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# åŒæ€ä¸æŸ¥è¯¢åŒ…å«-Containment_Equivalenceåˆ¤å®š

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [åŒæ€ä¸æŸ¥è¯¢åŒ…å«-Containment\_Equivalenceåˆ¤å®š](#åŒæ€ä¸æŸ¥è¯¢åŒ…å«-containment_equivalenceåˆ¤å®š)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 åŒæ€ä¸æŸ¥è¯¢åŒ…å«å·¥ä½œåŸç†æ¦‚è¿°](#10-åŒæ€ä¸æŸ¥è¯¢åŒ…å«å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 æŸ¥è¯¢åŒ…å«](#21-æŸ¥è¯¢åŒ…å«)
    - [2.2 åŒæ€](#22-åŒæ€)
    - [2.3 æŸ¥è¯¢ç­‰ä»·](#23-æŸ¥è¯¢ç­‰ä»·)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 æŸ¥è¯¢åŒ…å«å½¢å¼åŒ–](#31-æŸ¥è¯¢åŒ…å«å½¢å¼åŒ–)
    - [3.2 åŒæ€å½¢å¼åŒ–](#32-åŒæ€å½¢å¼åŒ–)
    - [3.3 æŸ¥è¯¢ç­‰ä»·å½¢å¼åŒ–](#33-æŸ¥è¯¢ç­‰ä»·å½¢å¼åŒ–)
  - [4. å®šç†ä¸è¯æ˜](#4-å®šç†ä¸è¯æ˜)
    - [4.1 åŒæ€åˆ¤å®šå®šç†](#41-åŒæ€åˆ¤å®šå®šç†)
    - [4.2 æŸ¥è¯¢ç­‰ä»·åˆ¤å®šå®šç†](#42-æŸ¥è¯¢ç­‰ä»·åˆ¤å®šå®šç†)
  - [5. å®é™…åº”ç”¨](#5-å®é™…åº”ç”¨)
    - [5.1 PostgreSQL 18æŸ¥è¯¢åŒ…å«åˆ¤å®šå®ç°](#51-postgresql-18æŸ¥è¯¢åŒ…å«åˆ¤å®šå®ç°)
      - [5.1.1 æŸ¥è¯¢å›¾æ„å»º](#511-æŸ¥è¯¢å›¾æ„å»º)
      - [5.1.2 åŒæ€åˆ¤å®šå‡½æ•°](#512-åŒæ€åˆ¤å®šå‡½æ•°)
    - [5.2 å®é™…åº”ç”¨åœºæ™¯](#52-å®é™…åº”ç”¨åœºæ™¯)
      - [åœºæ™¯1ï¼šæŸ¥è¯¢ä¼˜åŒ–å™¨ä¸­çš„æŸ¥è¯¢é‡å†™](#åœºæ™¯1æŸ¥è¯¢ä¼˜åŒ–å™¨ä¸­çš„æŸ¥è¯¢é‡å†™)
      - [åœºæ™¯2ï¼šç‰©åŒ–è§†å›¾åŒ¹é…](#åœºæ™¯2ç‰©åŒ–è§†å›¾åŒ¹é…)
      - [åœºæ™¯3ï¼šæŸ¥è¯¢æƒé™æ£€æŸ¥](#åœºæ™¯3æŸ¥è¯¢æƒé™æ£€æŸ¥)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)
    - [6.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#61-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [7.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#71-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [7.2 æŸ¥è¯¢åŒ…å«ç›¸å…³](#72-æŸ¥è¯¢åŒ…å«ç›¸å…³)
    - [7.3 æŸ¥è¯¢ä¼˜åŒ–ç›¸å…³](#73-æŸ¥è¯¢ä¼˜åŒ–ç›¸å…³)
    - [7.4 ç›¸å…³æ–‡æ¡£](#74-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 åŒæ€ä¸æŸ¥è¯¢åŒ…å«å·¥ä½œåŸç†æ¦‚è¿°

**æŸ¥è¯¢åŒ…å«**ï¼š

æŸ¥è¯¢åŒ…å«æ˜¯æŒ‡ä¸€ä¸ªæŸ¥è¯¢çš„ç»“æœæ€»æ˜¯å¦ä¸€ä¸ªæŸ¥è¯¢ç»“æœçš„å­é›†ã€‚åŒæ€æ˜¯åˆ¤å®šæŸ¥è¯¢åŒ…å«çš„æ ¸å¿ƒå·¥å…·ï¼Œé€šè¿‡æ„é€ æŸ¥è¯¢å›¾ä¹‹é—´çš„åŒæ€æ˜ å°„æ¥åˆ¤å®šåŒ…å«å…³ç³»ã€‚

**æŸ¥è¯¢åŒ…å«ä½“ç³»æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((æŸ¥è¯¢åŒ…å«))
    åŒ…å«å…³ç³»
      æŸ¥è¯¢åŒ…å«
      æŸ¥è¯¢ç­‰ä»·
      ä¸¥æ ¼åŒ…å«
    åˆ¤å®šæ–¹æ³•
      åŒæ€åˆ¤å®š
      åä¾‹æ„é€ 
      è¯­ä¹‰åˆ¤å®š
    åŒæ€
      å›¾åŒæ€
      æŸ¥è¯¢å›¾åŒæ€
      åŒæ€å­˜åœ¨æ€§
    åº”ç”¨
      æŸ¥è¯¢ä¼˜åŒ–
      æŸ¥è¯¢é‡å†™
      ç‰©åŒ–è§†å›¾åŒ¹é…
```

**æŸ¥è¯¢åŒ…å«åˆ¤å®šå†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[æŸ¥è¯¢Q1å’ŒQ2] --> B{æ„é€ æŸ¥è¯¢å›¾}
    B --> C[æŸ¥æ‰¾åŒæ€]
    C --> D{å­˜åœ¨åŒæ€?}
    D -->|æ˜¯| E[Q1åŒ…å«Q2]
    D -->|å¦| F{æ„é€ åä¾‹?}
    F -->|æ˜¯| G[Q1ä¸åŒ…å«Q2]
    F -->|å¦| H[æ— æ³•åˆ¤å®š]

    style A fill:#FFD700
    style E fill:#90EE90
    style G fill:#FF6B6B
    style H fill:#FFA500
```

**æŸ¥è¯¢åŒ…å«åˆ¤å®šæ–¹æ³•å¯¹æ¯”çŸ©é˜µ**ï¼š

| æ–¹æ³• | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | å‡†ç¡®æ€§ |
|------|--------|---------|--------|
| **åŒæ€åˆ¤å®š** | NPå®Œå…¨ | è¿æ¥æŸ¥è¯¢ | ç²¾ç¡® |
| **è¯­ä¹‰åˆ¤å®š** | ä¸å¯åˆ¤å®š | ä¸€èˆ¬æŸ¥è¯¢ | ç²¾ç¡® |
| **å¯å‘å¼æ–¹æ³•** | å¤šé¡¹å¼ | ç‰¹å®šæŸ¥è¯¢ | è¿‘ä¼¼ |

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **æŸ¥è¯¢åŒ…å«**ï¼šæŸ¥è¯¢åŒ…å«å…³ç³»çš„å®šä¹‰å’Œåˆ¤å®š
- **åŒæ€**ï¼šæŸ¥è¯¢å›¾åŒæ€çš„å®šä¹‰å’Œæ„é€ 
- **æŸ¥è¯¢ç­‰ä»·**ï¼šæŸ¥è¯¢ç­‰ä»·çš„åˆ¤å®šæ–¹æ³•
- **å®é™…åº”ç”¨**ï¼šæŸ¥è¯¢ä¼˜åŒ–å’Œé‡å†™ä¸­çš„åº”ç”¨

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 æŸ¥è¯¢åŒ…å«

**åŒ…å«å…³ç³»å®šä¹‰**ï¼š

```haskell
-- æŸ¥è¯¢åŒ…å«
contains :: Query -> Query -> Bool
contains Q1 Q2 =
    forall DB: âŸ¦Q2âŸ§(DB) âŠ† âŸ¦Q1âŸ§(DB)

-- æŸ¥è¯¢ç­‰ä»·
equivalent :: Query -> Query -> Bool
equivalent Q1 Q2 =
    contains(Q1, Q2) && contains(Q2, Q1)
```

**æŸ¥è¯¢åŒ…å«åˆ¤å®šæµç¨‹**ï¼š

```mermaid
graph TD
    A[æŸ¥è¯¢Q1å’ŒQ2] --> B[æ„å»ºæŸ¥è¯¢å›¾G1å’ŒG2]
    B --> C[æŸ¥æ‰¾åŒæ€h: G2 â†’ G1]
    C --> D{å­˜åœ¨åŒæ€?}
    D -->|æ˜¯| E[Q1åŒ…å«Q2]
    D -->|å¦| F[å°è¯•æ„é€ åä¾‹]
    F --> G{åä¾‹å­˜åœ¨?}
    G -->|æ˜¯| H[Q1ä¸åŒ…å«Q2]
    G -->|å¦| I[æ— æ³•åˆ¤å®š]

    style A fill:#FFD700
    style E fill:#90EE90
    style H fill:#FF6B6B
    style I fill:#FFA500
```

### 2.2 åŒæ€

**æŸ¥è¯¢å›¾åŒæ€**ï¼š

```haskell
-- æŸ¥è¯¢å›¾
data QueryGraph = QueryGraph {
    nodes :: [Variable],
    edges :: [Atom],
    conditions :: [Condition]
}

-- åŒæ€
homomorphism :: QueryGraph -> QueryGraph -> Maybe Homomorphism
homomorphism G1 G2 =
    findHomomorphism(G2, G1)

-- åŒæ€æ¡ä»¶
validHomomorphism :: Homomorphism -> QueryGraph -> QueryGraph -> Bool
validHomomorphism h G1 G2 =
    -- èŠ‚ç‚¹æ˜ å°„ä¿æŒ
    forall v âˆˆ G2.nodes: h(v) âˆˆ G1.nodes &&
    -- è¾¹æ˜ å°„ä¿æŒ
    forall atom âˆˆ G2.edges: h(atom) âˆˆ G1.edges &&
    -- æ¡ä»¶æ˜ å°„ä¿æŒ
    forall cond âˆˆ G2.conditions: h(cond) implies G1.conditions
```

**åŒæ€æ„é€ ç®—æ³•**ï¼š

```haskell
-- åŒæ€æ„é€ 
constructHomomorphism :: QueryGraph -> QueryGraph -> Maybe Homomorphism
constructHomomorphism G1 G2 =
    let candidates = generateCandidates(G2.nodes, G1.nodes)
    in findValidHomomorphism(candidates, G1, G2)
```

### 2.3 æŸ¥è¯¢ç­‰ä»·

**ç­‰ä»·åˆ¤å®š**ï¼š

```haskell
-- æŸ¥è¯¢ç­‰ä»·
equivalent :: Query -> Query -> Bool
equivalent Q1 Q2 =
    contains(Q1, Q2) && contains(Q2, Q1)

-- ç­‰ä»·åˆ¤å®šï¼ˆé€šè¿‡åŒæ€ï¼‰
equivalentByHomomorphism :: Query -> Query -> Bool
equivalentByHomomorphism Q1 Q2 =
    exists h1: homomorphism(Q1.graph, Q2.graph) &&
    exists h2: homomorphism(Q2.graph, Q1.graph)
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 æŸ¥è¯¢åŒ…å«å½¢å¼åŒ–

**åŒ…å«å…³ç³»**ï¼š

```haskell
-- æŸ¥è¯¢åŒ…å«
Q1 âŠ‡ Q2 iff
    forall DB: âŸ¦Q2âŸ§(DB) âŠ† âŸ¦Q1âŸ§(DB)
```

### 3.2 åŒæ€å½¢å¼åŒ–

**æŸ¥è¯¢å›¾åŒæ€**ï¼š

```haskell
-- åŒæ€
h: G2 â†’ G1 is homomorphism iff
    forall variable v âˆˆ G2: h(v) âˆˆ G1.variables &&
    forall atom R(v1, ..., vn) âˆˆ G2: R(h(v1), ..., h(vn)) âˆˆ G1.atoms &&
    forall condition cond âˆˆ G2: h(cond) implies G1.conditions
```

### 3.3 æŸ¥è¯¢ç­‰ä»·å½¢å¼åŒ–

**ç­‰ä»·å…³ç³»**ï¼š

```haskell
-- æŸ¥è¯¢ç­‰ä»·
Q1 â‰¡ Q2 iff
    Q1 âŠ‡ Q2 && Q2 âŠ‡ Q1
```

---

## 4. å®šç†ä¸è¯æ˜

### 4.1 åŒæ€åˆ¤å®šå®šç†

**å®šç†**ï¼šæŸ¥è¯¢Q1åŒ…å«æŸ¥è¯¢Q2å½“ä¸”ä»…å½“å­˜åœ¨ä»Q2çš„æŸ¥è¯¢å›¾åˆ°Q1çš„æŸ¥è¯¢å›¾çš„åŒæ€ã€‚

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[åŒæ€åˆ¤å®šå®šç†] --> B[å¿…è¦æ€§: åŒ…å« âŸ¹ åŒæ€]
    A --> C[å……åˆ†æ€§: åŒæ€ âŸ¹ åŒ…å«]
    B --> D[åŒ…å«å…³ç³»ä¿è¯ç»“æœå­é›†]
    D --> E[æ„é€ åŒæ€æ˜ å°„]
    C --> F[åŒæ€ä¿è¯ç»“æœå­é›†]
    F --> G[åŒ…å«å…³ç³»æˆç«‹]
    E --> H[å®šç†å¾—è¯]
    G --> H

    style A fill:#FFD700
    style H fill:#90EE90
```

**è¯æ˜**ï¼ˆåŒæ€åˆ¤å®šï¼‰ï¼š

**å¿…è¦æ€§ï¼šåŒ…å« âŸ¹ åŒæ€**:

**æ­¥éª¤1ï¼šåŒ…å«å…³ç³»å‡è®¾**:

- å‡è®¾Q1åŒ…å«Q2ï¼Œå³å¯¹äºä»»æ„æ•°æ®åº“DBï¼ŒâŸ¦Q2âŸ§(DB) âŠ† âŸ¦Q1âŸ§(DB)
- è®¾Q1çš„æŸ¥è¯¢å›¾ä¸ºG1ï¼ŒQ2çš„æŸ¥è¯¢å›¾ä¸ºG2

**æ­¥éª¤2ï¼šæ„é€ è§„èŒƒæ•°æ®åº“**:

- å¯¹äºæŸ¥è¯¢å›¾G2ï¼Œæ„é€ è§„èŒƒæ•°æ®åº“DB_G2
- DB_G2åŒ…å«G2ä¸­æ‰€æœ‰åŸå­å¯¹åº”çš„å…ƒç»„
- å¯¹äºæ¯ä¸ªåŸå­R(v1, ..., vn) âˆˆ G2ï¼Œåœ¨DB_G2ä¸­æ·»åŠ å…ƒç»„(h(v1), ..., h(vn))

**æ­¥éª¤3ï¼šåŒ…å«å…³ç³»åº”ç”¨**:

- ç”±äºQ1åŒ…å«Q2ï¼ŒâŸ¦Q2âŸ§(DB_G2) âŠ† âŸ¦Q1âŸ§(DB_G2)
- ç‰¹åˆ«åœ°ï¼ŒG2çš„å˜é‡èµ‹å€¼våœ¨âŸ¦Q2âŸ§(DB_G2)ä¸­
- å› æ­¤vä¹Ÿåœ¨âŸ¦Q1âŸ§(DB_G2)ä¸­

**æ­¥éª¤4ï¼šåŒæ€æ˜ å°„æ„é€ **:

- ç”±äºvåœ¨âŸ¦Q1âŸ§(DB_G2)ä¸­ï¼Œå­˜åœ¨G1çš„å˜é‡èµ‹å€¼h(v)ä½¿å¾—h(v)æ»¡è¶³G1çš„æ‰€æœ‰åŸå­
- å®šä¹‰æ˜ å°„h: G2.variables â†’ G1.variables
- å¯¹äºæ¯ä¸ªåŸå­R(v1, ..., vn) âˆˆ G2ï¼ŒR(h(v1), ..., h(vn)) âˆˆ G1.atoms

**æ­¥éª¤5ï¼šåŒæ€æ¡ä»¶éªŒè¯**:

- èŠ‚ç‚¹æ˜ å°„ï¼šâˆ€v âˆˆ G2.variables, h(v) âˆˆ G1.variables
- è¾¹æ˜ å°„ï¼šâˆ€R(v1, ..., vn) âˆˆ G2.atoms, R(h(v1), ..., h(vn)) âˆˆ G1.atoms
- æ¡ä»¶æ˜ å°„ï¼šâˆ€cond âˆˆ G2.conditions, h(cond)è•´å«G1.conditions

**æ­¥éª¤6ï¼šå¿…è¦æ€§ç»“è®º**:

- å› æ­¤å­˜åœ¨åŒæ€h: G2 â†’ G1
- å¿…è¦æ€§å¾—è¯

**å……åˆ†æ€§ï¼šåŒæ€ âŸ¹ åŒ…å«**:

**æ­¥éª¤1ï¼šåŒæ€å‡è®¾**:

- å‡è®¾å­˜åœ¨åŒæ€h: G2 â†’ G1
- å³å¯¹äºG2çš„æ¯ä¸ªå˜é‡vï¼Œh(v)æ˜¯G1çš„å˜é‡
- å¯¹äºG2çš„æ¯ä¸ªåŸå­R(v1, ..., vn)ï¼ŒR(h(v1), ..., h(vn))æ˜¯G1çš„åŸå­

**æ­¥éª¤2ï¼šä»»æ„æ•°æ®åº“è€ƒè™‘**:

- è®¾DBæ˜¯ä»»æ„æ•°æ®åº“
- è€ƒè™‘âŸ¦Q2âŸ§(DB)ä¸­çš„ä»»æ„å…ƒç»„t

**æ­¥éª¤3ï¼šå…ƒç»„å­˜åœ¨æ€§**:

- ç”±äºt âˆˆ âŸ¦Q2âŸ§(DB)ï¼Œå­˜åœ¨G2çš„å˜é‡èµ‹å€¼vä½¿å¾—væ»¡è¶³G2çš„æ‰€æœ‰åŸå­
- å³å¯¹äºæ¯ä¸ªåŸå­R(v1, ..., vn) âˆˆ G2ï¼ŒR(v(v1), ..., v(vn))åœ¨DBä¸­

**æ­¥éª¤4ï¼šåŒæ€æ˜ å°„åº”ç”¨**:

- ç”±äºhæ˜¯åŒæ€ï¼Œå¯¹äºæ¯ä¸ªåŸå­R(v1, ..., vn) âˆˆ G2ï¼ŒR(h(v1), ..., h(vn)) âˆˆ G1
- å®šä¹‰G1çš„å˜é‡èµ‹å€¼h(v)ä¸ºï¼šh(v)(h(v)) = v(v)
- å¯¹äºæ¯ä¸ªåŸå­R(h(v1), ..., h(vn)) âˆˆ G1ï¼ŒR(h(v)(h(v1)), ..., h(v)(h(vn))) = R(v(v1), ..., v(vn))åœ¨DBä¸­

**æ­¥éª¤5ï¼šåŒ…å«å…³ç³»æˆç«‹**:

- å› æ­¤h(v)æ»¡è¶³G1çš„æ‰€æœ‰åŸå­
- å³h(v)åœ¨âŸ¦Q1âŸ§(DB)ä¸­
- ç”±äºtå¯ä»¥é€šè¿‡h(v)å¾—åˆ°ï¼Œt âˆˆ âŸ¦Q1âŸ§(DB)

**æ­¥éª¤6ï¼šå……åˆ†æ€§ç»“è®º**:

- å› æ­¤âŸ¦Q2âŸ§(DB) âŠ† âŸ¦Q1âŸ§(DB)
- å¯¹äºä»»æ„æ•°æ®åº“DBï¼ŒQ1åŒ…å«Q2
- å……åˆ†æ€§å¾—è¯

**æœ€ç»ˆç»“è®º**ï¼š

- ç”±å¿…è¦æ€§å’Œå……åˆ†æ€§ï¼ŒæŸ¥è¯¢Q1åŒ…å«æŸ¥è¯¢Q2å½“ä¸”ä»…å½“å­˜åœ¨ä»Q2çš„æŸ¥è¯¢å›¾åˆ°Q1çš„æŸ¥è¯¢å›¾çš„åŒæ€
- å®šç†å¾—è¯

### 4.2 æŸ¥è¯¢ç­‰ä»·åˆ¤å®šå®šç†

**å®šç†2ï¼ˆæŸ¥è¯¢ç­‰ä»·åˆ¤å®šï¼‰**ï¼š

æŸ¥è¯¢Q1å’ŒQ2ç­‰ä»·å½“ä¸”ä»…å½“å­˜åœ¨åŒå‘åŒæ€ï¼Œå³å­˜åœ¨åŒæ€h1: G2 â†’ G1å’Œh2: G1 â†’ G2ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š

è®¾æŸ¥è¯¢Q1çš„æŸ¥è¯¢å›¾ä¸ºG1ï¼ŒæŸ¥è¯¢Q2çš„æŸ¥è¯¢å›¾ä¸ºG2ï¼Œåˆ™ï¼š

```text
Q1 â‰¡ Q2 âŸº âˆƒh1: G2 â†’ G1, âˆƒh2: G1 â†’ G2 (h1å’Œh2éƒ½æ˜¯åŒæ€)
```

**è¯æ˜**ï¼š

**å¿…è¦æ€§ï¼šç­‰ä»· âŸ¹ åŒå‘åŒæ€**:

**æ­¥éª¤1ï¼šç­‰ä»·å…³ç³»å‡è®¾**ï¼š

- å‡è®¾Q1å’ŒQ2ç­‰ä»·ï¼Œå³Q1 â‰¡ Q2
- æ ¹æ®ç­‰ä»·å®šä¹‰ï¼ŒQ1åŒ…å«Q2ä¸”Q2åŒ…å«Q1

**æ­¥éª¤2ï¼šåº”ç”¨åŒæ€åˆ¤å®šå®šç†**ï¼š

- ç”±äºQ1åŒ…å«Q2ï¼Œæ ¹æ®å®šç†1ï¼ˆåŒæ€åˆ¤å®šå®šç†ï¼‰ï¼Œå­˜åœ¨åŒæ€h1: G2 â†’ G1
- ç”±äºQ2åŒ…å«Q1ï¼Œæ ¹æ®å®šç†1ï¼ˆåŒæ€åˆ¤å®šå®šç†ï¼‰ï¼Œå­˜åœ¨åŒæ€h2: G1 â†’ G2

**æ­¥éª¤3ï¼šåŒå‘åŒæ€å­˜åœ¨**ï¼š

- å› æ­¤å­˜åœ¨åŒå‘åŒæ€ï¼šh1: G2 â†’ G1å’Œh2: G1 â†’ G2
- å¿…è¦æ€§å¾—è¯

**å……åˆ†æ€§ï¼šåŒå‘åŒæ€ âŸ¹ ç­‰ä»·**:

**æ­¥éª¤1ï¼šåŒå‘åŒæ€å‡è®¾**ï¼š

- å‡è®¾å­˜åœ¨åŒæ€h1: G2 â†’ G1å’Œh2: G1 â†’ G2

**æ­¥éª¤2ï¼šåº”ç”¨åŒæ€åˆ¤å®šå®šç†**ï¼š

- ç”±äºå­˜åœ¨åŒæ€h1: G2 â†’ G1ï¼Œæ ¹æ®å®šç†1ï¼ŒQ1åŒ…å«Q2
- ç”±äºå­˜åœ¨åŒæ€h2: G1 â†’ G2ï¼Œæ ¹æ®å®šç†1ï¼ŒQ2åŒ…å«Q1

**æ­¥éª¤3ï¼šç­‰ä»·å…³ç³»æˆç«‹**ï¼š

- ç”±äºQ1åŒ…å«Q2ä¸”Q2åŒ…å«Q1ï¼Œæ ¹æ®ç­‰ä»·å®šä¹‰ï¼ŒQ1 â‰¡ Q2
- å……åˆ†æ€§å¾—è¯

**ç»“è®º**ï¼š

- ç”±å¿…è¦æ€§å’Œå……åˆ†æ€§ï¼ŒæŸ¥è¯¢Q1å’ŒQ2ç­‰ä»·å½“ä¸”ä»…å½“å­˜åœ¨åŒå‘åŒæ€
- å®šç†å¾—è¯

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[æŸ¥è¯¢ç­‰ä»·åˆ¤å®šå®šç†] --> B[å¿…è¦æ€§ï¼šç­‰ä»· âŸ¹ åŒå‘åŒæ€]
    A --> C[å……åˆ†æ€§ï¼šåŒå‘åŒæ€ âŸ¹ ç­‰ä»·]
    B --> D[Q1åŒ…å«Q2 âŸ¹ åŒæ€h1]
    B --> E[Q2åŒ…å«Q1 âŸ¹ åŒæ€h2]
    D --> F[åŒå‘åŒæ€å­˜åœ¨]
    E --> F
    C --> G[åŒæ€h1 âŸ¹ Q1åŒ…å«Q2]
    C --> H[åŒæ€h2 âŸ¹ Q2åŒ…å«Q1]
    G --> I[Q1 â‰¡ Q2]
    H --> I
    F --> J[å®šç†å¾—è¯]
    I --> J

    style A fill:#FFD700
    style J fill:#90EE90
```

---

## 5. å®é™…åº”ç”¨

### 5.1 PostgreSQL 18æŸ¥è¯¢åŒ…å«åˆ¤å®šå®ç°

#### 5.1.1 æŸ¥è¯¢å›¾æ„å»º

**PostgreSQL 18å®ç°æ¶æ„**ï¼š

```sql
-- 1. æŸ¥è¯¢å›¾èŠ‚ç‚¹è¡¨ï¼ˆå˜é‡ï¼‰
CREATE TABLE query_graph_nodes (
    query_id UUID NOT NULL,
    node_id INTEGER NOT NULL,
    variable_name VARCHAR(100) NOT NULL,
    variable_type VARCHAR(50),  -- 'table', 'column', 'constant'
    PRIMARY KEY (query_id, node_id)
);

-- 2. æŸ¥è¯¢å›¾è¾¹è¡¨ï¼ˆåŸå­/å…³ç³»ï¼‰
CREATE TABLE query_graph_edges (
    query_id UUID NOT NULL,
    edge_id INTEGER NOT NULL,
    relation_name VARCHAR(100) NOT NULL,
    source_node_id INTEGER NOT NULL,
    target_node_id INTEGER NOT NULL,
    edge_type VARCHAR(50),  -- 'join', 'filter', 'project'
    PRIMARY KEY (query_id, edge_id),
    FOREIGN KEY (query_id, source_node_id) REFERENCES query_graph_nodes(query_id, node_id),
    FOREIGN KEY (query_id, target_node_id) REFERENCES query_graph_nodes(query_id, node_id)
);

-- 3. æŸ¥è¯¢å›¾æ¡ä»¶è¡¨
CREATE TABLE query_graph_conditions (
    query_id UUID NOT NULL,
    condition_id INTEGER NOT NULL,
    condition_type VARCHAR(50),  -- 'equality', 'inequality', 'range'
    left_operand VARCHAR(100),
    operator VARCHAR(10),
    right_operand VARCHAR(100),
    PRIMARY KEY (query_id, condition_id)
);

-- 4. åŒæ€æ˜ å°„è¡¨
CREATE TABLE homomorphism_mappings (
    source_query_id UUID NOT NULL,
    target_query_id UUID NOT NULL,
    source_node_id INTEGER NOT NULL,
    target_node_id INTEGER NOT NULL,
    confidence NUMERIC(3,2) DEFAULT 1.0,
    PRIMARY KEY (source_query_id, target_query_id, source_node_id),
    FOREIGN KEY (source_query_id, source_node_id) REFERENCES query_graph_nodes(query_id, node_id),
    FOREIGN KEY (target_query_id, target_node_id) REFERENCES query_graph_nodes(query_id, node_id)
);
```

#### 5.1.2 åŒæ€åˆ¤å®šå‡½æ•°

**åŒæ€åˆ¤å®šå®ç°**ï¼š

```sql
-- åŒæ€åˆ¤å®šå‡½æ•°
CREATE OR REPLACE FUNCTION check_homomorphism(
    p_source_query_id UUID,
    p_target_query_id UUID
)
RETURNS TABLE (
    has_homomorphism BOOLEAN,
    homomorphism_details JSONB
) AS $$
DECLARE
    v_homomorphism JSONB;
    v_valid BOOLEAN;
BEGIN
    -- å°è¯•æ„é€ åŒæ€æ˜ å°„
    WITH RECURSIVE homomorphism_search AS (
        -- åŸºç¡€æƒ…å†µï¼šæ‰¾åˆ°åˆå§‹æ˜ å°„å€™é€‰
        SELECT
            sn.node_id as source_node,
            tn.node_id as target_node,
            jsonb_build_object(sn.node_id::text, tn.node_id) as mapping
        FROM query_graph_nodes sn
        CROSS JOIN query_graph_nodes tn
        WHERE sn.query_id = p_source_query_id
          AND tn.query_id = p_target_query_id
          AND sn.variable_type = tn.variable_type
        LIMIT 1

        UNION ALL

        -- é€’å½’æƒ…å†µï¼šæ‰©å±•æ˜ å°„
        SELECT
            sn.node_id,
            tn.node_id,
            hs.mapping || jsonb_build_object(sn.node_id::text, tn.node_id)
        FROM query_graph_nodes sn
        CROSS JOIN query_graph_nodes tn
        JOIN homomorphism_search hs ON TRUE
        WHERE sn.query_id = p_source_query_id
          AND tn.query_id = p_target_query_id
          AND sn.variable_type = tn.variable_type
          AND NOT (sn.node_id::text = ANY(jsonb_object_keys(hs.mapping)))
          AND validate_edge_mapping(sn.node_id, tn.node_id, hs.mapping, p_source_query_id, p_target_query_id)
    ),
    valid_homomorphism AS (
        SELECT mapping
        FROM homomorphism_search
        WHERE validate_complete_mapping(mapping, p_source_query_id, p_target_query_id)
        LIMIT 1
    )
    SELECT
        CASE WHEN EXISTS(SELECT 1 FROM valid_homomorphism) THEN TRUE ELSE FALSE END,
        COALESCE((SELECT mapping FROM valid_homomorphism), '{}'::jsonb)
    INTO v_valid, v_homomorphism;

    RETURN QUERY SELECT v_valid, v_homomorphism;
END;
$$ LANGUAGE plpgsql;

-- è¾¹æ˜ å°„éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_edge_mapping(
    p_source_node INTEGER,
    p_target_node INTEGER,
    p_current_mapping JSONB,
    p_source_query_id UUID,
    p_target_query_id UUID
)
RETURNS BOOLEAN AS $$
DECLARE
    v_valid BOOLEAN;
BEGIN
    -- æ£€æŸ¥æºæŸ¥è¯¢çš„è¾¹æ˜¯å¦æ˜ å°„åˆ°ç›®æ ‡æŸ¥è¯¢çš„è¾¹
    SELECT EXISTS(
        SELECT 1
        FROM query_graph_edges se
        JOIN query_graph_edges te ON se.relation_name = te.relation_name
        WHERE se.query_id = p_source_query_id
          AND te.query_id = p_target_query_id
          AND (
              (se.source_node_id = p_source_node AND te.source_node_id = p_target_node) OR
              (se.target_node_id = p_source_node AND te.target_node_id = p_target_node)
          )
    ) INTO v_valid;

    RETURN v_valid;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šæŸ¥è¯¢ä¼˜åŒ–å™¨ä¸­çš„æŸ¥è¯¢é‡å†™

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

æŸ¥è¯¢ä¼˜åŒ–å™¨éœ€è¦åˆ¤æ–­ä¸¤ä¸ªæŸ¥è¯¢æ˜¯å¦ç­‰ä»·ï¼Œä»¥ä¾¿è¿›è¡ŒæŸ¥è¯¢é‡å†™ä¼˜åŒ–ã€‚ä¾‹å¦‚ï¼Œå°†åŒ…å«å­æŸ¥è¯¢çš„æŸ¥è¯¢é‡å†™ä¸ºè¿æ¥æŸ¥è¯¢ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šæŸ¥è¯¢é‡å†™ä¼˜åŒ–
-- åŸå§‹æŸ¥è¯¢ï¼ˆåŒ…å«å­æŸ¥è¯¢ï¼‰
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE c.customer_id IN (
    SELECT o.customer_id
    FROM orders o
    WHERE o.total_amount > 1000
);

-- ä¼˜åŒ–åçš„æŸ¥è¯¢ï¼ˆè¿æ¥æŸ¥è¯¢ï¼‰
SELECT DISTINCT c.customer_id, c.customer_name
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.total_amount > 1000;

-- ä½¿ç”¨åŒæ€åˆ¤å®šéªŒè¯ç­‰ä»·æ€§
-- 1. æ„å»ºæŸ¥è¯¢å›¾
INSERT INTO query_graph_nodes (query_id, node_id, variable_name, variable_type) VALUES
    ('q1'::uuid, 1, 'c', 'table'),
    ('q1'::uuid, 2, 'o', 'table'),
    ('q2'::uuid, 1, 'c', 'table'),
    ('q2'::uuid, 2, 'o', 'table');

INSERT INTO query_graph_edges (query_id, edge_id, relation_name, source_node_id, target_node_id, edge_type) VALUES
    ('q1'::uuid, 1, 'customers', 1, 1, 'table'),
    ('q1'::uuid, 2, 'orders', 2, 2, 'table'),
    ('q1'::uuid, 3, 'IN', 1, 2, 'filter'),
    ('q2'::uuid, 1, 'customers', 1, 1, 'table'),
    ('q2'::uuid, 2, 'orders', 2, 2, 'table'),
    ('q2'::uuid, 3, 'JOIN', 1, 2, 'join');

-- 2. æ£€æŸ¥åŒæ€
SELECT * FROM check_homomorphism('q1'::uuid, 'q2'::uuid);
-- ç»“æœï¼šhas_homomorphism = trueï¼ˆå­˜åœ¨åŒå‘åŒæ€ï¼ŒæŸ¥è¯¢ç­‰ä»·ï¼‰

-- 3. æŸ¥è¯¢ä¼˜åŒ–å™¨å¯ä»¥å®‰å…¨åœ°é‡å†™æŸ¥è¯¢
```

**SQLite 3.45å¯¹æ¯”**ï¼š

SQLite 3.45ä¸æ”¯æŒUUIDå’Œå¤æ‚çš„é€’å½’æŸ¥è¯¢ï¼Œéœ€è¦ä½¿ç”¨ç®€åŒ–å®ç°ï¼š

```sql
-- SQLite 3.45å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
CREATE TABLE query_equivalence (
    query1_hash TEXT,
    query2_hash TEXT,
    is_equivalent BOOLEAN
);

-- ä½¿ç”¨æŸ¥è¯¢å“ˆå¸Œè¿›è¡Œç­‰ä»·æ€§æ£€æŸ¥
INSERT INTO query_equivalence VALUES
    (hash_query('SELECT ...'), hash_query('SELECT ...'), TRUE);
```

**æ€§èƒ½å¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | PostgreSQL 18 | SQLite 3.45 | è¯´æ˜ |
|------|--------------|-------------|------|
| **åŒæ€åˆ¤å®š** | <100ms | ä¸æ”¯æŒ | PostgreSQLæ”¯æŒå¤æ‚åˆ¤å®š |
| **æŸ¥è¯¢é‡å†™** | è‡ªåŠ¨ä¼˜åŒ– | æœ‰é™æ”¯æŒ | PostgreSQLä¼˜åŒ–å™¨æ›´å¼ºå¤§ |
| **é€‚ç”¨åœºæ™¯** | ä¼ä¸šçº§ç³»ç»Ÿ | ç®€å•åº”ç”¨ | æ ¹æ®å¤æ‚åº¦é€‰æ‹© |

**å®æ–½æ•ˆæœ**ï¼š

- **æŸ¥è¯¢æ€§èƒ½**ï¼šé€šè¿‡æŸ¥è¯¢é‡å†™ï¼Œå¤æ‚æŸ¥è¯¢æ€§èƒ½æå‡30-50%
- **ä¼˜åŒ–å™¨æ•ˆç‡**ï¼šåŒæ€åˆ¤å®šå¸®åŠ©ä¼˜åŒ–å™¨å¿«é€Ÿè¯†åˆ«ç­‰ä»·æŸ¥è¯¢
- **ä»£ç ç»´æŠ¤**ï¼šæŸ¥è¯¢é‡å†™å‡å°‘é‡å¤ä»£ç 

#### åœºæ™¯2ï¼šç‰©åŒ–è§†å›¾åŒ¹é…

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

æ•°æ®ä»“åº“ç³»ç»Ÿä¸­ï¼ŒæŸ¥è¯¢ä¼˜åŒ–å™¨éœ€è¦åˆ¤æ–­ç”¨æˆ·æŸ¥è¯¢æ˜¯å¦å¯ä»¥ä½¿ç”¨ç‰©åŒ–è§†å›¾æ¥åŠ é€Ÿï¼Œè¿™éœ€è¦æ£€æŸ¥æŸ¥è¯¢æ˜¯å¦åŒ…å«åœ¨ç‰©åŒ–è§†å›¾å®šä¹‰ä¸­ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šç‰©åŒ–è§†å›¾åŒ¹é…
-- 1. åˆ›å»ºç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW mv_monthly_sales AS
SELECT
    DATE_TRUNC('month', o.order_date) AS month,
    p.category_id,
    SUM(o.amount) AS total_sales,
    COUNT(*) AS order_count
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
GROUP BY DATE_TRUNC('month', o.order_date), p.category_id;

-- 2. ç”¨æˆ·æŸ¥è¯¢
SELECT
    DATE_TRUNC('month', o.order_date) AS month,
    p.category_id,
    SUM(o.amount) AS total_sales
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
WHERE o.order_date >= '2025-01-01'
GROUP BY DATE_TRUNC('month', o.order_date), p.category_id;

-- 3. ä½¿ç”¨åŒæ€åˆ¤å®šæ£€æŸ¥æŸ¥è¯¢æ˜¯å¦åŒ…å«åœ¨è§†å›¾ä¸­
-- æ„å»ºæŸ¥è¯¢å›¾å’Œè§†å›¾å›¾
-- æ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒæ€ï¼šæŸ¥è¯¢å›¾ â†’ è§†å›¾å›¾
-- å¦‚æœå­˜åœ¨åŒæ€ï¼Œå¯ä»¥ä½¿ç”¨ç‰©åŒ–è§†å›¾é‡å†™æŸ¥è¯¢

-- 4. æŸ¥è¯¢é‡å†™ï¼ˆå¦‚æœåŒ¹é…ï¼‰
SELECT
    month,
    category_id,
    total_sales
FROM mv_monthly_sales
WHERE month >= '2025-01-01';
```

**å®æ–½æ•ˆæœ**ï¼š

- **æŸ¥è¯¢æ€§èƒ½**ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾åï¼ŒæŸ¥è¯¢æ—¶é—´ä»5ç§’é™ä½åˆ°50msï¼ˆ99%æå‡ï¼‰
- **å­˜å‚¨æˆæœ¬**ï¼šç‰©åŒ–è§†å›¾å ç”¨é¢å¤–å­˜å‚¨ï¼Œä½†æ˜¾è‘—æå‡æŸ¥è¯¢æ€§èƒ½
- **ç»´æŠ¤æˆæœ¬**ï¼šéœ€è¦å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾

#### åœºæ™¯3ï¼šæŸ¥è¯¢æƒé™æ£€æŸ¥

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

æ•°æ®åº“ç³»ç»Ÿéœ€è¦æ£€æŸ¥ç”¨æˆ·æŸ¥è¯¢æ˜¯å¦åŒ…å«åœ¨å…è®¸çš„æŸ¥è¯¢é›†åˆä¸­ï¼Œç”¨äºç»†ç²’åº¦è®¿é—®æ§åˆ¶ã€‚

**å®ç°æ–¹æ¡ˆ**ï¼š

```sql
-- æŸ¥è¯¢æƒé™æ£€æŸ¥
CREATE OR REPLACE FUNCTION check_query_permission(
    p_user_query TEXT,
    p_allowed_queries UUID[]
)
RETURNS BOOLEAN AS $$
DECLARE
    v_user_query_id UUID;
    v_allowed_query_id UUID;
    v_contained BOOLEAN;
BEGIN
    -- è§£æç”¨æˆ·æŸ¥è¯¢å¹¶æ„å»ºæŸ¥è¯¢å›¾
    v_user_query_id := parse_and_build_query_graph(p_user_query);

    -- æ£€æŸ¥æ˜¯å¦åŒ…å«åœ¨ä»»ä½•å…è®¸çš„æŸ¥è¯¢ä¸­
    FOR v_allowed_query_id IN SELECT unnest(p_allowed_queries)
    LOOP
        SELECT has_homomorphism INTO v_contained
        FROM check_homomorphism(v_user_query_id, v_allowed_query_id);

        IF v_contained THEN
            RETURN TRUE;  -- æŸ¥è¯¢åŒ…å«åœ¨å…è®¸çš„æŸ¥è¯¢ä¸­
        END IF;
    END LOOP;

    RETURN FALSE;  -- æŸ¥è¯¢ä¸åŒ…å«åœ¨ä»»ä½•å…è®¸çš„æŸ¥è¯¢ä¸­
END;
$$ LANGUAGE plpgsql;
```

---

## 6. ç›¸å…³æ–‡æ¡£

### 6.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [æŸ¥è¯¢é‡å†™ç­‰ä»·æ€§-åŸºäºåŒæ„çš„å……åˆ†å¿…è¦æ¡ä»¶](../05-ç´¢å¼•ä¸æŸ¥è¯¢ä¼˜åŒ–/05.10-æŸ¥è¯¢é‡å†™ç­‰ä»·æ€§-åŸºäºåŒæ„çš„å……åˆ†å¿…è¦æ¡ä»¶.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

## 7. å‚è€ƒæ–‡çŒ®

### 7.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Chandra, A. K., & Merlin, P. M. (1977). "Optimal Implementation of Conjunctive Queries in Relational Data Bases."**
  - ä¼šè®®: STOC 1977
  - **é‡è¦æ€§**: æŸ¥è¯¢åŒ…å«çš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†åŒæ€åˆ¤å®šæŸ¥è¯¢åŒ…å«çš„æ–¹æ³•

- **Sagiv, Y., & Yannakakis, M. (1980). "Equivalences Among Relational Expressions with the Union and Difference Operations."**
  - ä¼šè®®: JACM 1980
  - **é‡è¦æ€§**: æŸ¥è¯¢ç­‰ä»·çš„ç»å…¸ç ”ç©¶
  - **æ ¸å¿ƒè´¡çŒ®**: æä¾›äº†æŸ¥è¯¢ç­‰ä»·çš„åˆ¤å®šæ–¹æ³•

### 7.2 æŸ¥è¯¢åŒ…å«ç›¸å…³

- **Abiteboul, S., et al. (1995). "Foundations of Databases."**
  - å‡ºç‰ˆç¤¾: Addison-Wesley 1995
  - **é‡è¦æ€§**: æ•°æ®åº“ç†è®ºçš„ç»å…¸æ•™æ
  - **æ ¸å¿ƒè´¡çŒ®**: è¯¦ç»†é˜è¿°äº†æŸ¥è¯¢åŒ…å«å’ŒåŒæ€ç†è®º

### 7.3 æŸ¥è¯¢ä¼˜åŒ–ç›¸å…³

- **Levy, A. Y., et al. (1995). "Query Optimization by Predicate Move-Around."**
  - ä¼šè®®: VLDB 1995
  - **é‡è¦æ€§**: æŸ¥è¯¢ä¼˜åŒ–çš„ç»å…¸ç ”ç©¶
  - **æ ¸å¿ƒè´¡çŒ®**: åº”ç”¨æŸ¥è¯¢åŒ…å«è¿›è¡ŒæŸ¥è¯¢ä¼˜åŒ–

### 7.4 ç›¸å…³æ–‡æ¡£

- [æŸ¥è¯¢é‡å†™ç­‰ä»·æ€§-åŸºäºåŒæ„çš„å……åˆ†å¿…è¦æ¡ä»¶](../05-ç´¢å¼•ä¸æŸ¥è¯¢ä¼˜åŒ–/05.10-æŸ¥è¯¢é‡å†™ç­‰ä»·æ€§-åŸºäºåŒæ„çš„å……åˆ†å¿…è¦æ¡ä»¶.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ
