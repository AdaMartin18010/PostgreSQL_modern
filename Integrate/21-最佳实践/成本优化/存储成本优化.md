# PostgreSQLå­˜å‚¨æˆæœ¬ä¼˜åŒ–æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 17+/18+
> **éš¾åº¦ç­‰çº§**: â­â­â­ ä¸­çº§

---

## ğŸ“‹ ç›®å½•

- [PostgreSQLå­˜å‚¨æˆæœ¬ä¼˜åŒ–æŒ‡å—](#postgresqlå­˜å‚¨æˆæœ¬ä¼˜åŒ–æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. æ•°æ®å‹ç¼©](#2-æ•°æ®å‹ç¼©)
    - [2.1 TOASTå‹ç¼©](#21-toastå‹ç¼©)
    - [2.2 è¡¨å‹ç¼©](#22-è¡¨å‹ç¼©)
  - [3. æ•°æ®å½’æ¡£](#3-æ•°æ®å½’æ¡£)
    - [3.1 å½’æ¡£ç­–ç•¥](#31-å½’æ¡£ç­–ç•¥)
    - [3.2 åˆ†åŒºå½’æ¡£](#32-åˆ†åŒºå½’æ¡£)
  - [4. å¤‡ä»½ä¼˜åŒ–](#4-å¤‡ä»½ä¼˜åŒ–)
    - [4.1 å¢é‡å¤‡ä»½](#41-å¢é‡å¤‡ä»½)
    - [4.2 å¤‡ä»½å‹ç¼©](#42-å¤‡ä»½å‹ç¼©)
  - [5. åˆ†åŒºä¼˜åŒ–](#5-åˆ†åŒºä¼˜åŒ–)
    - [5.1 åˆ†åŒºç®¡ç†](#51-åˆ†åŒºç®¡ç†)
    - [5.2 åˆ†åŒºå½’æ¡£](#52-åˆ†åŒºå½’æ¡£)
    - [5.3 å­˜å‚¨æˆæœ¬ä¼˜åŒ–æœ€ä½³å®è·µ](#53-å­˜å‚¨æˆæœ¬ä¼˜åŒ–æœ€ä½³å®è·µ)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

å­˜å‚¨æˆæœ¬ä¼˜åŒ–é€šè¿‡å‡å°‘å­˜å‚¨ç©ºé—´é™ä½å­˜å‚¨æˆæœ¬ã€‚

**ä¼˜åŒ–ç­–ç•¥**:

- æ•°æ®å‹ç¼©
- æ•°æ®å½’æ¡£
- å¤‡ä»½ä¼˜åŒ–
- åˆ†åŒºç®¡ç†

---

## 2. æ•°æ®å‹ç¼©

### 2.1 TOASTå‹ç¼©

```sql
-- æŸ¥çœ‹TOASTè¡¨
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### 2.2 è¡¨å‹ç¼©

**pg_repackå‹ç¼©**ï¼š

```sql
-- ä½¿ç”¨pg_repackå‹ç¼©è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    -- æ£€æŸ¥pg_repackæ‰©å±•æ˜¯å¦å¯ç”¨
    IF NOT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'pg_repack'
    ) THEN
        RAISE WARNING 'pg_repackæ‰©å±•æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£…';
        RETURN;
    END IF;

    -- å‹ç¼©è¡¨ï¼ˆéœ€è¦åœ¨å‘½ä»¤è¡Œæ‰§è¡Œï¼‰
    -- pg_repack -d mydb -t users --dry-run
    -- pg_repack -d mydb -t users

    RAISE NOTICE 'è¡¨å‹ç¼©å»ºè®®ï¼šä½¿ç”¨pg_repackå·¥å…·è¿›è¡Œåœ¨çº¿è¡¨é‡ç»„';
END $$;

-- æˆ–ä½¿ç”¨ALTER TABLEè®¾ç½®fillfactor
ALTER TABLE users SET (fillfactor = 90);
VACUUM FULL users;
```

**PostgreSQL 18å‹ç¼©ä¼˜åŒ–**ï¼š

```sql
-- æ£€æŸ¥è¡¨å‹ç¼©çŠ¶æ€
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS indexes_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename) -
                   COALESCE((SELECT pg_total_relation_size(oid)
                            FROM pg_class
                            WHERE relname = schemaname||'.'||tablename||'_toast'), 0)) AS toast_size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;
```

**å‹ç¼©æ•ˆæœè¯„ä¼°**ï¼š

```sql
-- åˆ›å»ºå‹ç¼©æ•ˆæœè·Ÿè¸ªè¡¨
CREATE TABLE IF NOT EXISTS compression_tracking (
    table_name VARCHAR(200) PRIMARY KEY,
    schema_name VARCHAR(100),
    size_before_gb NUMERIC,
    size_after_gb NUMERIC,
    compression_ratio NUMERIC,
    compression_date TIMESTAMPTZ DEFAULT NOW(),
    compression_method VARCHAR(50)
);

-- è®°å½•å‹ç¼©å‰å¤§å°
INSERT INTO compression_tracking
(table_name, schema_name, size_before_gb, compression_method)
SELECT
    tablename,
    schemaname,
    pg_total_relation_size(schemaname||'.'||tablename)::NUMERIC / 1024 / 1024 / 1024,
    'pg_repack'
FROM pg_tables
WHERE schemaname = 'public'
  AND tablename = 'users'
ON CONFLICT (table_name) DO UPDATE SET
    size_before_gb = EXCLUDED.size_before_gb;

-- å‹ç¼©åæ›´æ–°è®°å½•
UPDATE compression_tracking
SET
    size_after_gb = (
        SELECT pg_total_relation_size('public.'||table_name)::NUMERIC / 1024 / 1024 / 1024
    ),
    compression_ratio = ROUND(
        (size_before_gb - (
            SELECT pg_total_relation_size('public.'||table_name)::NUMERIC / 1024 / 1024 / 1024
        )) / size_before_gb * 100, 2
    ),
    compression_date = NOW()
WHERE table_name = 'users';

-- æŸ¥è¯¢å‹ç¼©æ•ˆæœ
SELECT
    table_name,
    ROUND(size_before_gb, 2) AS size_before_gb,
    ROUND(size_after_gb, 2) AS size_after_gb,
    compression_ratio || '%' AS compression_ratio,
    compression_method,
    compression_date
FROM compression_tracking
ORDER BY compression_ratio DESC;
```

---

## 3. æ•°æ®å½’æ¡£

### 3.1 å½’æ¡£ç­–ç•¥

**è‡ªåŠ¨å½’æ¡£å®ç°**ï¼š

```sql
-- åˆ›å»ºå½’æ¡£å‡½æ•°
CREATE OR REPLACE FUNCTION archive_old_data(
    p_table_name VARCHAR(200),
    p_schema_name VARCHAR(100) DEFAULT 'public',
    p_archive_age INTERVAL DEFAULT INTERVAL '1 year'
)
RETURNS TABLE (
    archived_rows BIGINT,
    archived_size_gb NUMERIC,
    remaining_rows BIGINT
) AS $$
DECLARE
    v_archive_table_name VARCHAR(200);
    v_row_count BIGINT;
    v_archive_size_gb NUMERIC;
    v_remaining_count BIGINT;
BEGIN
    -- æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_schema = p_schema_name
          AND table_name = p_table_name
    ) THEN
        RAISE EXCEPTION 'è¡¨ % ä¸å­˜åœ¨', p_schema_name||'.'||p_table_name;
    END IF;

    -- åˆ›å»ºå½’æ¡£è¡¨
    v_archive_table_name := p_table_name || '_archive_' || to_char(NOW(), 'YYYYMMDD');

    EXECUTE format('CREATE TABLE IF NOT EXISTS %I.%I (LIKE %I.%I INCLUDING ALL)',
        p_schema_name, v_archive_table_name, p_schema_name, p_table_name);

    -- å½’æ¡£æ•°æ®
    EXECUTE format('
        INSERT INTO %I.%I
        SELECT * FROM %I.%I
        WHERE created_at < NOW() - $1
    ', p_schema_name, v_archive_table_name, p_schema_name, p_table_name)
    USING p_archive_age;

    GET DIAGNOSTICS v_row_count = ROW_COUNT;

    -- è®¡ç®—å½’æ¡£è¡¨å¤§å°
    SELECT pg_total_relation_size(p_schema_name||'.'||v_archive_table_name)::NUMERIC / 1024 / 1024 / 1024
    INTO v_archive_size_gb;

    -- åˆ é™¤å·²å½’æ¡£çš„æ•°æ®
    EXECUTE format('
        DELETE FROM %I.%I
        WHERE created_at < NOW() - $1
    ', p_schema_name, p_table_name)
    USING p_archive_age;

    -- ç»Ÿè®¡å‰©ä½™æ•°æ®
    EXECUTE format('SELECT COUNT(*) FROM %I.%I', p_schema_name, p_table_name)
    INTO v_remaining_count;

    RETURN QUERY SELECT v_row_count, v_archive_size_gb, v_remaining_count;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨å½’æ¡£å‡½æ•°
SELECT * FROM archive_old_data('users', 'public', INTERVAL '1 year');
```

**å½’æ¡£ç­–ç•¥é…ç½®**ï¼š

```sql
-- åˆ›å»ºå½’æ¡£ç­–ç•¥é…ç½®è¡¨
CREATE TABLE IF NOT EXISTS archive_policies (
    policy_id SERIAL PRIMARY KEY,
    table_name VARCHAR(200) NOT NULL,
    schema_name VARCHAR(100) DEFAULT 'public',
    archive_age INTERVAL NOT NULL,
    archive_frequency VARCHAR(50),
    archive_location VARCHAR(500),
    enabled BOOLEAN DEFAULT TRUE,
    last_archive_date TIMESTAMPTZ,
    next_archive_date TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ’å…¥å½’æ¡£ç­–ç•¥
INSERT INTO archive_policies
(table_name, schema_name, archive_age, archive_frequency, archive_location)
VALUES
('orders', 'public', INTERVAL '1 year', 'æ¯æœˆ', '/archive/orders'),
('logs', 'public', INTERVAL '6 months', 'æ¯å‘¨', '/archive/logs'),
('events', 'public', INTERVAL '3 months', 'æ¯å¤©', '/archive/events');

-- æ›´æ–°ä¸‹æ¬¡å½’æ¡£æ—¥æœŸ
UPDATE archive_policies
SET next_archive_date = CASE
    WHEN archive_frequency = 'æ¯å¤©' THEN NOW() + INTERVAL '1 day'
    WHEN archive_frequency = 'æ¯å‘¨' THEN NOW() + INTERVAL '1 week'
    WHEN archive_frequency = 'æ¯æœˆ' THEN NOW() + INTERVAL '1 month'
    ELSE NOW() + INTERVAL '1 month'
END
WHERE enabled = TRUE;

-- æŸ¥è¯¢å¾…å½’æ¡£çš„è¡¨
SELECT
    policy_id,
    table_name,
    schema_name,
    archive_age,
    archive_frequency,
    last_archive_date,
    next_archive_date
FROM archive_policies
WHERE enabled = TRUE
  AND (next_archive_date IS NULL OR next_archive_date <= NOW())
ORDER BY next_archive_date NULLS FIRST;
```

### 3.2 åˆ†åŒºå½’æ¡£

```sql
-- åˆ é™¤æ—§åˆ†åŒº
DROP TABLE IF EXISTS orders_2023_01;

-- æˆ–è¿ç§»åˆ°å½’æ¡£è¡¨
ALTER TABLE orders_2023_01 SET TABLESPACE archive_tablespace;
```

---

## 4. å¤‡ä»½ä¼˜åŒ–

### 4.1 å¢é‡å¤‡ä»½

```bash
# PostgreSQL 18å¢é‡å¤‡ä»½
pg_basebackup --incremental -D /backup/inc

# å‡å°‘å¤‡ä»½å­˜å‚¨
```

### 4.2 å¤‡ä»½å‹ç¼©

**å¤‡ä»½å‹ç¼©ç­–ç•¥**ï¼š

```bash
# PostgreSQL 18å¢é‡å¤‡ä»½ï¼ˆå¸¦å‹ç¼©ï¼‰
pg_basebackup --incremental \
    --pgdata=/backup/incremental \
    --compress=gzip \
    --compress-level=9 \
    -D /backup/incremental

# å‹ç¼©å¤‡ä»½
pg_dump -Fc -Z 9 mydb > backup.dump

# æˆ–ä½¿ç”¨å‹ç¼©å·¥å…·
pg_dump mydb | gzip -9 > backup.sql.gz

# ä½¿ç”¨å¹¶è¡Œå‹ç¼©ï¼ˆæ›´å¿«ï¼‰
pg_dump -Fd -j 4 -Z 9 -f /backup/mydb mydb
```

**å¤‡ä»½å‹ç¼©æ•ˆæœåˆ†æ**ï¼š

```sql
-- åˆ›å»ºå¤‡ä»½è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS backup_records (
    backup_id SERIAL PRIMARY KEY,
    backup_type VARCHAR(50),
    backup_method VARCHAR(50),
    uncompressed_size_gb NUMERIC,
    compressed_size_gb NUMERIC,
    compression_ratio NUMERIC,
    backup_duration INTERVAL,
    backup_date TIMESTAMPTZ DEFAULT NOW(),
    backup_location VARCHAR(500)
);

-- æ’å…¥å¤‡ä»½è®°å½•ï¼ˆç¤ºä¾‹ï¼‰
INSERT INTO backup_records
(backup_type, backup_method, uncompressed_size_gb, compressed_size_gb, backup_duration)
VALUES
('å…¨é‡å¤‡ä»½', 'pg_dump -Fc -Z 9', 100.0, 25.0, INTERVAL '2 hours'),
('å¢é‡å¤‡ä»½', 'pg_basebackup --incremental', 10.0, 3.0, INTERVAL '30 minutes');

-- è®¡ç®—å‹ç¼©æ¯”
UPDATE backup_records
SET compression_ratio = ROUND(
    (uncompressed_size_gb - compressed_size_gb) / uncompressed_size_gb * 100, 2
);

-- æŸ¥è¯¢å¤‡ä»½å‹ç¼©æ•ˆæœ
SELECT
    backup_type,
    backup_method,
    ROUND(uncompressed_size_gb, 2) AS uncompressed_gb,
    ROUND(compressed_size_gb, 2) AS compressed_gb,
    compression_ratio || '%' AS compression_ratio,
    ROUND(uncompressed_size_gb - compressed_size_gb, 2) AS saved_gb,
    backup_duration,
    backup_date
FROM backup_records
ORDER BY backup_date DESC;
```

**å¤‡ä»½æˆæœ¬è®¡ç®—**ï¼š

```sql
-- åˆ›å»ºå¤‡ä»½æˆæœ¬åˆ†æè¡¨
CREATE TABLE IF NOT EXISTS backup_cost_analysis (
    analysis_id SERIAL PRIMARY KEY,
    backup_type VARCHAR(50),
    storage_cost_per_gb_month NUMERIC DEFAULT 0.1,
    uncompressed_size_gb NUMERIC,
    compressed_size_gb NUMERIC,
    monthly_storage_cost NUMERIC,
    annual_storage_cost NUMERIC,
    retention_days INTEGER DEFAULT 30,
    analysis_date DATE DEFAULT CURRENT_DATE
);

-- è®¡ç®—å¤‡ä»½å­˜å‚¨æˆæœ¬
INSERT INTO backup_cost_analysis
(backup_type, uncompressed_size_gb, compressed_size_gb, retention_days)
SELECT
    backup_type,
    uncompressed_size_gb,
    compressed_size_gb,
    30 AS retention_days
FROM backup_records
WHERE backup_date >= NOW() - INTERVAL '30 days';

-- æ›´æ–°æˆæœ¬
UPDATE backup_cost_analysis
SET
    monthly_storage_cost = ROUND(compressed_size_gb * storage_cost_per_gb_month, 2),
    annual_storage_cost = ROUND(compressed_size_gb * storage_cost_per_gb_month * 12, 2);

-- æŸ¥è¯¢å¤‡ä»½æˆæœ¬
SELECT
    backup_type,
    ROUND(uncompressed_size_gb, 2) AS uncompressed_gb,
    ROUND(compressed_size_gb, 2) AS compressed_gb,
    ROUND(uncompressed_size_gb - compressed_size_gb, 2) AS saved_gb,
    ROUND(monthly_storage_cost, 2) AS monthly_cost,
    ROUND(annual_storage_cost, 2) AS annual_cost,
    ROUND((uncompressed_size_gb - compressed_size_gb) * storage_cost_per_gb_month * 12, 2) AS annual_savings
FROM backup_cost_analysis
ORDER BY annual_savings DESC;
```

---

## 5. åˆ†åŒºä¼˜åŒ–

### 5.1 åˆ†åŒºç®¡ç†

```sql
-- æŒ‰æ—¶é—´åˆ†åŒº
CREATE TABLE orders (
    id SERIAL,
    order_date DATE,
    amount NUMERIC
) PARTITION BY RANGE (order_date);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE orders_2024_01 PARTITION OF orders
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

### 5.2 åˆ†åŒºå½’æ¡£

**è‡ªåŠ¨åˆ†åŒºå½’æ¡£**ï¼š

```sql
-- åˆ›å»ºåˆ†åŒºå½’æ¡£å‡½æ•°
CREATE OR REPLACE FUNCTION archive_old_partitions(
    p_table_name VARCHAR(200),
    p_schema_name VARCHAR(100) DEFAULT 'public',
    p_archive_age INTERVAL DEFAULT INTERVAL '1 year'
)
RETURNS TABLE (
    detached_partitions TEXT[],
    archived_size_gb NUMERIC
) AS $$
DECLARE
    v_partition_name VARCHAR(200);
    v_partition_date DATE;
    v_detached_partitions TEXT[] := ARRAY[]::TEXT[];
    v_total_size_gb NUMERIC := 0;
    v_partition_size_gb NUMERIC;
BEGIN
    -- æŸ¥æ‰¾éœ€è¦å½’æ¡£çš„åˆ†åŒº
    FOR v_partition_name, v_partition_date IN
        SELECT
            tablename,
            (regexp_match(tablename, '\d{4}_\d{2}'))[1]::DATE
        FROM pg_tables
        WHERE schemaname = p_schema_name
          AND tablename LIKE p_table_name || '_%'
          AND tablename ~ '\d{4}_\d{2}'
    LOOP
        -- æ£€æŸ¥åˆ†åŒºæ˜¯å¦è¶…è¿‡å½’æ¡£å¹´é¾„
        IF v_partition_date < CURRENT_DATE - p_archive_age THEN
            -- åˆ†ç¦»åˆ†åŒº
            EXECUTE format('ALTER TABLE %I.%I DETACH PARTITION %I.%I',
                p_schema_name, p_table_name, p_schema_name, v_partition_name);

            -- è®¡ç®—åˆ†åŒºå¤§å°
            SELECT pg_total_relation_size(p_schema_name||'.'||v_partition_name)::NUMERIC / 1024 / 1024 / 1024
            INTO v_partition_size_gb;

            v_total_size_gb := v_total_size_gb + v_partition_size_gb;
            v_detached_partitions := array_append(v_detached_partitions, v_partition_name);

            RAISE NOTICE 'å·²åˆ†ç¦»åˆ†åŒº: %', v_partition_name;
        END IF;
    END LOOP;

    RETURN QUERY SELECT v_detached_partitions, v_total_size_gb;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨åˆ†åŒºå½’æ¡£å‡½æ•°
SELECT * FROM archive_old_partitions('orders', 'public', INTERVAL '1 year');
```

**åˆ†åŒºå½’æ¡£åˆ°è¡¨ç©ºé—´**ï¼š

```sql
-- åˆ›å»ºå½’æ¡£è¡¨ç©ºé—´ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
-- CREATE TABLESPACE archive_tablespace LOCATION '/archive/tablespace';

-- ç§»åŠ¨åˆ†åŒºåˆ°å½’æ¡£è¡¨ç©ºé—´
DO $$
DECLARE
    v_partition_name VARCHAR(200);
BEGIN
    FOR v_partition_name IN
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'public'
          AND tablename LIKE 'orders_2023_%'
    LOOP
        BEGIN
            EXECUTE format('ALTER TABLE %I SET TABLESPACE archive_tablespace', v_partition_name);
            RAISE NOTICE 'å·²ç§»åŠ¨åˆ†åŒº % åˆ°å½’æ¡£è¡¨ç©ºé—´', v_partition_name;
        EXCEPTION
            WHEN undefined_object THEN
                RAISE WARNING 'è¡¨ç©ºé—´ archive_tablespace ä¸å­˜åœ¨ï¼Œè·³è¿‡ç§»åŠ¨';
            WHEN OTHERS THEN
                RAISE WARNING 'ç§»åŠ¨åˆ†åŒº % å¤±è´¥: %', v_partition_name, SQLERRM;
        END;
    END LOOP;
END $$;
```

**åˆ†åŒºå½’æ¡£ç›‘æ§**ï¼š

```sql
-- åˆ›å»ºåˆ†åŒºå½’æ¡£ç›‘æ§è§†å›¾
CREATE OR REPLACE VIEW partition_archive_status AS
SELECT
    schemaname,
    tablename AS partition_name,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS partition_size,
    pg_total_relation_size(schemaname||'.'||tablename)::NUMERIC / 1024 / 1024 / 1024 AS size_gb,
    CASE
        WHEN tablename ~ '\d{4}_\d{2}' THEN
            (regexp_match(tablename, '\d{4}_\d{2}'))[1]::DATE
        ELSE NULL
    END AS partition_date,
    CASE
        WHEN tablename ~ '\d{4}_\d{2}' AND
             (regexp_match(tablename, '\d{4}_\d{2}'))[1]::DATE < CURRENT_DATE - INTERVAL '1 year'
        THEN 'å¾…å½’æ¡£'
        ELSE 'æ´»è·ƒ'
    END AS archive_status,
    (SELECT spcname FROM pg_tablespace WHERE oid = (
        SELECT reltablespace FROM pg_class WHERE relname = tablename
    )) AS tablespace_name
FROM pg_tables
WHERE schemaname = 'public'
  AND tablename LIKE 'orders_%'
ORDER BY partition_date DESC NULLS LAST;

-- æŸ¥è¯¢åˆ†åŒºå½’æ¡£çŠ¶æ€
SELECT
    partition_name,
    partition_size,
    ROUND(size_gb, 2) AS size_gb,
    partition_date,
    archive_status,
    tablespace_name
FROM partition_archive_status
ORDER BY partition_date DESC;
```

### 5.3 å­˜å‚¨æˆæœ¬ä¼˜åŒ–æœ€ä½³å®è·µ

**å­˜å‚¨ä¼˜åŒ–æ£€æŸ¥æ¸…å•**ï¼š

```sql
-- åˆ›å»ºå­˜å‚¨ä¼˜åŒ–æ£€æŸ¥è¡¨
CREATE TABLE IF NOT EXISTS storage_optimization_checklist (
    check_id SERIAL PRIMARY KEY,
    check_item VARCHAR(200),
    check_status VARCHAR(20),
    check_result TEXT,
    optimization_potential NUMERIC,
    priority INTEGER,
    checked_date TIMESTAMPTZ DEFAULT NOW()
);

-- æ’å…¥æ£€æŸ¥é¡¹
INSERT INTO storage_optimization_checklist
(check_item, check_status, optimization_potential, priority)
VALUES
('TOASTè¡¨å‹ç¼©', 'å¾…æ£€æŸ¥', 20.0, 1),
('è¡¨å‹ç¼©ä¼˜åŒ–', 'å¾…æ£€æŸ¥', 30.0, 2),
('æ•°æ®å½’æ¡£', 'å¾…æ£€æŸ¥', 40.0, 3),
('å¤‡ä»½å‹ç¼©', 'å¾…æ£€æŸ¥', 25.0, 4),
('åˆ†åŒºå½’æ¡£', 'å¾…æ£€æŸ¥', 35.0, 5);

-- æ‰§è¡Œå­˜å‚¨ä¼˜åŒ–æ£€æŸ¥
CREATE OR REPLACE FUNCTION perform_storage_check()
RETURNS TABLE (
    check_item VARCHAR(200),
    check_status VARCHAR(20),
    optimization_potential NUMERIC,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.check_item,
        c.check_status,
        c.optimization_potential,
        CASE
            WHEN c.optimization_potential >= 30 THEN 'é«˜ä¼˜å…ˆçº§ä¼˜åŒ–'
            WHEN c.optimization_potential >= 20 THEN 'ä¸­ä¼˜å…ˆçº§ä¼˜åŒ–'
            ELSE 'ä½ä¼˜å…ˆçº§ä¼˜åŒ–'
        END AS recommendation
    FROM storage_optimization_checklist c
    WHERE c.check_status = 'å¾…æ£€æŸ¥'
    ORDER BY c.priority, c.optimization_potential DESC;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢å­˜å‚¨ä¼˜åŒ–å»ºè®®
SELECT * FROM perform_storage_check();
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æˆæœ¬ä¼˜åŒ–å®Œæ•´æŒ‡å—.md](./æˆæœ¬ä¼˜åŒ–å®Œæ•´æŒ‡å—.md) - æˆæœ¬ä¼˜åŒ–å®Œæ•´æŒ‡å—
- [èµ„æºä½¿ç”¨ä¼˜åŒ–.md](./èµ„æºä½¿ç”¨ä¼˜åŒ–.md) - èµ„æºä½¿ç”¨ä¼˜åŒ–
- [è®¡ç®—æˆæœ¬ä¼˜åŒ–.md](./è®¡ç®—æˆæœ¬ä¼˜åŒ–.md) - è®¡ç®—æˆæœ¬ä¼˜åŒ–
- [21-æœ€ä½³å®è·µ/README.md](../README.md) - æœ€ä½³å®è·µä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
