# PostgreSQLæˆæœ¬ç›‘æ§ä¸åˆ†ææŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 17+/18+
> **éš¾åº¦ç­‰çº§**: â­â­â­ ä¸­çº§

---

## ğŸ“‹ ç›®å½•

- [PostgreSQLæˆæœ¬ç›‘æ§ä¸åˆ†ææŒ‡å—](#postgresqlæˆæœ¬ç›‘æ§ä¸åˆ†ææŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. ç›‘æ§æŒ‡æ ‡](#2-ç›‘æ§æŒ‡æ ‡)
    - [2.1 èµ„æºç›‘æ§](#21-èµ„æºç›‘æ§)
    - [2.2 å­˜å‚¨ç›‘æ§](#22-å­˜å‚¨ç›‘æ§)
  - [3. æˆæœ¬åˆ†æ](#3-æˆæœ¬åˆ†æ)
    - [3.1 æˆæœ¬æ„æˆåˆ†æ](#31-æˆæœ¬æ„æˆåˆ†æ)
    - [3.2 æŸ¥è¯¢æˆæœ¬åˆ†æ](#32-æŸ¥è¯¢æˆæœ¬åˆ†æ)
  - [4. æŠ¥å‘Šç”Ÿæˆ](#4-æŠ¥å‘Šç”Ÿæˆ)
    - [4.1 æˆæœ¬æŠ¥å‘Š](#41-æˆæœ¬æŠ¥å‘Š)
    - [4.2 è¶‹åŠ¿åˆ†æ](#42-è¶‹åŠ¿åˆ†æ)
  - [5. ä¼˜åŒ–è·Ÿè¸ª](#5-ä¼˜åŒ–è·Ÿè¸ª)
    - [5.1 ä¼˜åŒ–æ•ˆæœ](#51-ä¼˜åŒ–æ•ˆæœ)
    - [5.2 æŒç»­æ”¹è¿›](#52-æŒç»­æ”¹è¿›)
  - [ğŸ“š ç›¸å…³æ–‡æ¡£](#-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

æˆæœ¬ç›‘æ§ä¸åˆ†æå¸®åŠ©è¯†åˆ«æˆæœ¬çƒ­ç‚¹ï¼Œè·Ÿè¸ªä¼˜åŒ–æ•ˆæœã€‚

**ç›‘æ§å†…å®¹**:

- èµ„æºä½¿ç”¨
- æˆæœ¬æ„æˆ
- è¶‹åŠ¿åˆ†æ
- ä¼˜åŒ–æ•ˆæœ

---

## 2. ç›‘æ§æŒ‡æ ‡

### 2.1 èµ„æºç›‘æ§

```sql
-- ç›‘æ§CPUä½¿ç”¨
SELECT
    pid,
    usename,
    application_name,
    state,
    query_start,
    query
FROM pg_stat_activity
WHERE state = 'active';

-- ç›‘æ§å†…å­˜ä½¿ç”¨
SELECT
    name,
    setting,
    unit
FROM pg_settings
WHERE name LIKE '%memory%' OR name LIKE '%buffer%';
```

### 2.2 å­˜å‚¨ç›‘æ§

```sql
-- ç›‘æ§å­˜å‚¨ä½¿ç”¨
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 10;
```

---

## 3. æˆæœ¬åˆ†æ

### 3.1 æˆæœ¬æ„æˆåˆ†æ

```sql
-- åˆ†æè¡¨å¤§å°
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    pg_total_relation_size(schemaname||'.'||tablename) AS size_bytes
FROM pg_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### 3.2 æŸ¥è¯¢æˆæœ¬åˆ†æ

```sql
-- åˆ†ææŸ¥è¯¢æˆæœ¬
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    (total_exec_time / SUM(total_exec_time) OVER ()) * 100 AS pct
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

---

## 4. æŠ¥å‘Šç”Ÿæˆ

### 4.1 æˆæœ¬æŠ¥å‘Š

```sql
-- ç”Ÿæˆæˆæœ¬æŠ¥å‘Š
SELECT
    'Storage Cost' AS cost_type,
    pg_size_pretty(SUM(pg_total_relation_size(schemaname||'.'||tablename))) AS total_size,
    COUNT(*) AS table_count
FROM pg_tables
UNION ALL
SELECT
    'Connection Cost' AS cost_type,
    COUNT(*)::TEXT AS total_connections,
    NULL AS table_count
FROM pg_stat_activity;
```

### 4.2 è¶‹åŠ¿åˆ†æ

**è¶‹åŠ¿åˆ†ææµç¨‹**ï¼š

```text
1. æ”¶é›†å†å²æ•°æ®
2. åˆ†æè¶‹åŠ¿
3. é¢„æµ‹æœªæ¥æˆæœ¬
4. åˆ¶å®šä¼˜åŒ–è®¡åˆ’
```

**æˆæœ¬è¶‹åŠ¿åˆ†æå®ç°**ï¼š

```sql
-- åˆ›å»ºæˆæœ¬è¶‹åŠ¿åˆ†æè¡¨
CREATE TABLE IF NOT EXISTS cost_trend_analysis (
    analysis_id SERIAL PRIMARY KEY,
    analysis_date DATE DEFAULT CURRENT_DATE,
    cost_category VARCHAR(50),
    daily_cost NUMERIC,
    weekly_cost NUMERIC,
    monthly_cost NUMERIC,
    cost_trend VARCHAR(20),
    growth_rate NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ’å…¥è¶‹åŠ¿æ•°æ®
INSERT INTO cost_trend_analysis
(analysis_date, cost_category, daily_cost, weekly_cost, monthly_cost)
SELECT
    CURRENT_DATE - (generate_series(0, 29) || ' days')::INTERVAL AS analysis_date,
    'è®¡ç®—æˆæœ¬' AS cost_category,
    (100 + random() * 20)::NUMERIC AS daily_cost,
    (700 + random() * 140)::NUMERIC AS weekly_cost,
    (3000 + random() * 600)::NUMERIC AS monthly_cost
FROM generate_series(0, 29);

-- è®¡ç®—è¶‹åŠ¿å’Œå¢é•¿ç‡
WITH cost_with_lag AS (
    SELECT
        analysis_date,
        cost_category,
        monthly_cost,
        LAG(monthly_cost) OVER (PARTITION BY cost_category ORDER BY analysis_date) AS prev_monthly_cost
    FROM cost_trend_analysis
)
UPDATE cost_trend_analysis cta
SET
    cost_trend = CASE
        WHEN cwl.monthly_cost > cwl.prev_monthly_cost THEN 'ä¸Šå‡'
        WHEN cwl.monthly_cost < cwl.prev_monthly_cost THEN 'ä¸‹é™'
        ELSE 'ç¨³å®š'
    END,
    growth_rate = CASE
        WHEN cwl.prev_monthly_cost > 0 THEN
            ROUND((cwl.monthly_cost - cwl.prev_monthly_cost) / cwl.prev_monthly_cost * 100, 2)
        ELSE NULL
    END
FROM cost_with_lag cwl
WHERE cta.analysis_id = (
    SELECT analysis_id FROM cost_trend_analysis
    WHERE analysis_date = cwl.analysis_date
      AND cost_category = cwl.cost_category
    LIMIT 1
);

-- æŸ¥è¯¢æˆæœ¬è¶‹åŠ¿
SELECT
    analysis_date,
    cost_category,
    ROUND(monthly_cost, 2) AS monthly_cost,
    cost_trend,
    COALESCE(growth_rate, 0) || '%' AS growth_rate
FROM cost_trend_analysis
ORDER BY analysis_date DESC
LIMIT 30;
```

**æˆæœ¬é¢„æµ‹æ¨¡å‹**ï¼š

```sql
-- åˆ›å»ºæˆæœ¬é¢„æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION predict_cost_trend(
    p_cost_category VARCHAR(50),
    p_months_ahead INTEGER DEFAULT 3
)
RETURNS TABLE (
    prediction_date DATE,
    predicted_cost NUMERIC,
    confidence_interval_lower NUMERIC,
    confidence_interval_upper NUMERIC
) AS $$
DECLARE
    v_avg_cost NUMERIC;
    v_trend NUMERIC;
    v_std_dev NUMERIC;
    v_month_offset INTEGER;
BEGIN
    -- è®¡ç®—å¹³å‡æˆæœ¬ã€è¶‹åŠ¿å’Œæ ‡å‡†å·®
    SELECT
        AVG(monthly_cost),
        (MAX(monthly_cost) - MIN(monthly_cost)) / NULLIF(COUNT(*), 0),
        STDDEV(monthly_cost)
    INTO v_avg_cost, v_trend, v_std_dev
    FROM cost_trend_analysis
    WHERE cost_category = p_cost_category
      AND analysis_date >= CURRENT_DATE - INTERVAL '6 months';

    -- ç”Ÿæˆé¢„æµ‹
    FOR v_month_offset IN 1..p_months_ahead LOOP
        RETURN QUERY SELECT
            CURRENT_DATE + (v_month_offset || ' months')::INTERVAL,
            v_avg_cost + v_trend * v_month_offset,
            (v_avg_cost + v_trend * v_month_offset) - v_std_dev * 1.96,
            (v_avg_cost + v_trend * v_month_offset) + v_std_dev * 1.96;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢æˆæœ¬é¢„æµ‹
SELECT
    prediction_date,
    ROUND(predicted_cost, 2) AS predicted_cost,
    ROUND(confidence_interval_lower, 2) AS lower_bound,
    ROUND(confidence_interval_upper, 2) AS upper_bound
FROM predict_cost_trend('è®¡ç®—æˆæœ¬', 6)
ORDER BY prediction_date;
```

---

## 5. ä¼˜åŒ–è·Ÿè¸ª

### 5.1 ä¼˜åŒ–æ•ˆæœ

**ä¼˜åŒ–æ•ˆæœè·Ÿè¸ª**ï¼š

```text
1. è®°å½•ä¼˜åŒ–å‰æŒ‡æ ‡
2. å®æ–½ä¼˜åŒ–æªæ–½
3. è®°å½•ä¼˜åŒ–åæŒ‡æ ‡
4. è®¡ç®—ä¼˜åŒ–æ•ˆæœ
```

**ä¼˜åŒ–æ•ˆæœåˆ†æå®ç°**ï¼š

```sql
-- åˆ›å»ºä¼˜åŒ–æ•ˆæœè·Ÿè¸ªè¡¨
CREATE TABLE IF NOT EXISTS optimization_effectiveness (
    optimization_id SERIAL PRIMARY KEY,
    optimization_name VARCHAR(200),
    optimization_type VARCHAR(50),
    before_metric NUMERIC,
    after_metric NUMERIC,
    improvement_percentage NUMERIC,
    cost_savings NUMERIC,
    implementation_date DATE,
    evaluation_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ’å…¥ä¼˜åŒ–æ•ˆæœæ•°æ®
INSERT INTO optimization_effectiveness
(optimization_name, optimization_type, before_metric, after_metric, implementation_date, evaluation_date)
VALUES
('æ•°æ®å½’æ¡£', 'å­˜å‚¨æˆæœ¬', 500.0, 350.0, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE),
('è¿æ¥æ± ', 'è®¡ç®—æˆæœ¬', 200.0, 130.0, CURRENT_DATE - INTERVAL '20 days', CURRENT_DATE),
('æŸ¥è¯¢ä¼˜åŒ–', 'è®¡ç®—æˆæœ¬', 1000.0, 800.0, CURRENT_DATE - INTERVAL '15 days', CURRENT_DATE);

-- è®¡ç®—æ”¹è¿›ç™¾åˆ†æ¯”å’Œæˆæœ¬èŠ‚çœ
UPDATE optimization_effectiveness
SET
    improvement_percentage = ROUND(
        (before_metric - after_metric) / before_metric * 100, 2
    ),
    cost_savings = before_metric - after_metric;

-- æŸ¥è¯¢ä¼˜åŒ–æ•ˆæœ
SELECT
    optimization_name,
    optimization_type,
    ROUND(before_metric, 2) AS before_metric,
    ROUND(after_metric, 2) AS after_metric,
    improvement_percentage || '%' AS improvement,
    ROUND(cost_savings, 2) AS monthly_savings,
    ROUND(cost_savings * 12, 2) AS annual_savings,
    implementation_date,
    evaluation_date
FROM optimization_effectiveness
ORDER BY cost_savings DESC;
```

### 5.2 æŒç»­æ”¹è¿›

**æŒç»­æ”¹è¿›æµç¨‹**ï¼š

```text
1. å®šæœŸå®¡æŸ¥æˆæœ¬
2. è¯†åˆ«æ–°çš„ä¼˜åŒ–æœºä¼š
3. å®æ–½ä¼˜åŒ–æªæ–½
4. è·Ÿè¸ªä¼˜åŒ–æ•ˆæœ
```

**æŒç»­æ”¹è¿›è·Ÿè¸ªå®ç°**ï¼š

```sql
-- åˆ›å»ºæŒç»­æ”¹è¿›è·Ÿè¸ªè¡¨
CREATE TABLE IF NOT EXISTS continuous_improvement (
    improvement_id SERIAL PRIMARY KEY,
    improvement_area VARCHAR(100),
    improvement_description TEXT,
    identified_date DATE,
    implementation_date DATE,
    completion_date DATE,
    improvement_status VARCHAR(20),
    expected_savings NUMERIC,
    actual_savings NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ’å…¥æ”¹è¿›é¡¹
INSERT INTO continuous_improvement
(improvement_area, improvement_description, identified_date, improvement_status, expected_savings)
VALUES
('å­˜å‚¨ä¼˜åŒ–', 'å®æ–½è‡ªåŠ¨æ•°æ®å½’æ¡£', CURRENT_DATE - INTERVAL '10 days', 'è¿›è¡Œä¸­', 120.0),
('æŸ¥è¯¢ä¼˜åŒ–', 'ä¼˜åŒ–æ…¢æŸ¥è¯¢', CURRENT_DATE - INTERVAL '5 days', 'è®¡åˆ’ä¸­', 100.0),
('å¤‡ä»½ä¼˜åŒ–', 'å®æ–½å¢é‡å¤‡ä»½', CURRENT_DATE, 'è®¡åˆ’ä¸­', 75.0);

-- æ›´æ–°æ”¹è¿›çŠ¶æ€
UPDATE continuous_improvement
SET
    improvement_status = CASE
        WHEN completion_date IS NOT NULL THEN 'å·²å®Œæˆ'
        WHEN implementation_date IS NOT NULL THEN 'è¿›è¡Œä¸­'
        ELSE 'è®¡åˆ’ä¸­'
    END;

-- æŸ¥è¯¢æŒç»­æ”¹è¿›çŠ¶æ€
SELECT
    improvement_area,
    improvement_description,
    identified_date,
    implementation_date,
    completion_date,
    improvement_status,
    ROUND(expected_savings, 2) AS expected_savings,
    ROUND(actual_savings, 2) AS actual_savings,
    CASE
        WHEN completion_date IS NOT NULL AND actual_savings IS NOT NULL THEN
            ROUND((actual_savings / NULLIF(expected_savings, 0)) * 100, 2) || '%'
        ELSE NULL
    END AS achievement_rate
FROM continuous_improvement
ORDER BY identified_date DESC;
```

**æ”¹è¿›æ•ˆæœæ±‡æ€»**ï¼š

```sql
-- åˆ›å»ºæ”¹è¿›æ•ˆæœæ±‡æ€»è§†å›¾
CREATE OR REPLACE VIEW improvement_summary AS
SELECT
    improvement_area,
    COUNT(*) AS total_improvements,
    COUNT(*) FILTER (WHERE improvement_status = 'å·²å®Œæˆ') AS completed,
    COUNT(*) FILTER (WHERE improvement_status = 'è¿›è¡Œä¸­') AS in_progress,
    COUNT(*) FILTER (WHERE improvement_status = 'è®¡åˆ’ä¸­') AS planned,
    ROUND(SUM(expected_savings), 2) AS total_expected_savings,
    ROUND(SUM(actual_savings), 2) AS total_actual_savings,
    ROUND(AVG(CASE
        WHEN completion_date IS NOT NULL AND actual_savings IS NOT NULL THEN
            actual_savings / NULLIF(expected_savings, 0) * 100
        ELSE NULL
    END), 2) AS avg_achievement_rate
FROM continuous_improvement
GROUP BY improvement_area;

-- æŸ¥è¯¢æ”¹è¿›æ±‡æ€»
SELECT
    improvement_area,
    total_improvements,
    completed,
    in_progress,
    planned,
    total_expected_savings,
    total_actual_savings,
    avg_achievement_rate || '%' AS avg_achievement_rate
FROM improvement_summary
ORDER BY total_expected_savings DESC;
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æˆæœ¬ä¼˜åŒ–å®Œæ•´æŒ‡å—.md](./æˆæœ¬ä¼˜åŒ–å®Œæ•´æŒ‡å—.md) - æˆæœ¬ä¼˜åŒ–å®Œæ•´æŒ‡å—
- [äº‘æˆæœ¬ä¼˜åŒ–.md](./äº‘æˆæœ¬ä¼˜åŒ–.md) - äº‘æˆæœ¬ä¼˜åŒ–
- [èµ„æºä½¿ç”¨ä¼˜åŒ–.md](./èµ„æºä½¿ç”¨ä¼˜åŒ–.md) - èµ„æºä½¿ç”¨ä¼˜åŒ–
- [21-æœ€ä½³å®è·µ/README.md](../README.md) - æœ€ä½³å®è·µä¸»é¢˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
