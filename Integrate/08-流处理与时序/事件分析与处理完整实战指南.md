---
> **ğŸ“‹ æ–‡æ¡£æ¥æº**: æ–°å¢æ·±åŒ–æ–‡æ¡£
> **ğŸ“… åˆ›å»ºæ—¥æœŸ**: 2025-01
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£èšç„¦äº‹ä»¶åˆ†æä¸å¤æ‚äº‹ä»¶å¤„ç†æŠ€æœ¯æ ˆ

---

# äº‹ä»¶åˆ†æä¸å¤„ç†å®Œæ•´å®æˆ˜æŒ‡å—

## å…ƒæ•°æ®

- **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
- **åˆ›å»ºæ—¥æœŸ**: 2025-01
- **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | è§¦å‘å™¨ | NOTIFY/LISTEN | PL/pgSQL | pg_notify
- **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
- **é¢„è®¡é˜…è¯»**: 150åˆ†é’Ÿ
- **å‰ç½®è¦æ±‚**: ç†Ÿæ‚‰PostgreSQLåŸºç¡€ã€äº‹ä»¶é©±åŠ¨æ¶æ„ã€å¤æ‚äº‹ä»¶å¤„ç†åŸºç¡€

---

## ğŸ“‹ å®Œæ•´ç›®å½•

- [äº‹ä»¶åˆ†æä¸å¤„ç†å®Œæ•´å®æˆ˜æŒ‡å—](#äº‹ä»¶åˆ†æä¸å¤„ç†å®Œæ•´å®æˆ˜æŒ‡å—)
  - [å…ƒæ•°æ®](#å…ƒæ•°æ®)
  - [ğŸ“‹ å®Œæ•´ç›®å½•](#-å®Œæ•´ç›®å½•)
  - [1. äº‹ä»¶åˆ†ææ¦‚è¿°](#1-äº‹ä»¶åˆ†ææ¦‚è¿°)
    - [1.1 äº‹ä»¶å¤„ç†æ¦‚å¿µ](#11-äº‹ä»¶å¤„ç†æ¦‚å¿µ)
      - [äº‹ä»¶å®šä¹‰](#äº‹ä»¶å®šä¹‰)
      - [äº‹ä»¶ç±»å‹](#äº‹ä»¶ç±»å‹)
    - [1.2 äº‹ä»¶åˆ†æç±»å‹](#12-äº‹ä»¶åˆ†æç±»å‹)
      - [åˆ†æç±»å‹åˆ†ç±»](#åˆ†æç±»å‹åˆ†ç±»)
    - [1.3 åº”ç”¨åœºæ™¯](#13-åº”ç”¨åœºæ™¯)
      - [å…¸å‹åº”ç”¨åœºæ™¯](#å…¸å‹åº”ç”¨åœºæ™¯)
  - [2. å¤æ‚äº‹ä»¶å¤„ç†ï¼ˆCEPï¼‰](#2-å¤æ‚äº‹ä»¶å¤„ç†cep)
    - [2.1 äº‹ä»¶æ¨¡å¼å®šä¹‰](#21-äº‹ä»¶æ¨¡å¼å®šä¹‰)
      - [æ¨¡å¼å®šä¹‰è¯­è¨€](#æ¨¡å¼å®šä¹‰è¯­è¨€)
      - [æ¨¡å¼åŒ¹é…å¼•æ“](#æ¨¡å¼åŒ¹é…å¼•æ“)
    - [2.2 äº‹ä»¶åºåˆ—åŒ¹é…](#22-äº‹ä»¶åºåˆ—åŒ¹é…)
      - [åºåˆ—åŒ¹é…å®ç°](#åºåˆ—åŒ¹é…å®ç°)
    - [2.3 äº‹ä»¶å…³è”åˆ†æ](#23-äº‹ä»¶å…³è”åˆ†æ)
      - [äº‹ä»¶å…³è”è§„åˆ™](#äº‹ä»¶å…³è”è§„åˆ™)
  - [4. å¼‚å¸¸äº‹ä»¶æ£€æµ‹](#4-å¼‚å¸¸äº‹ä»¶æ£€æµ‹)
    - [4.1 å¼‚å¸¸æ¨¡å¼è¯†åˆ«](#41-å¼‚å¸¸æ¨¡å¼è¯†åˆ«)
      - [ç»Ÿè®¡å¼‚å¸¸æ£€æµ‹](#ç»Ÿè®¡å¼‚å¸¸æ£€æµ‹)
    - [4.2 ç¦»ç¾¤ç‚¹æ£€æµ‹](#42-ç¦»ç¾¤ç‚¹æ£€æµ‹)
      - [IQRæ–¹æ³•](#iqræ–¹æ³•)
    - [4.4 å®æ—¶å¼‚å¸¸å‘Šè­¦](#44-å®æ—¶å¼‚å¸¸å‘Šè­¦)
      - [å¼‚å¸¸å‘Šè­¦ç³»ç»Ÿ](#å¼‚å¸¸å‘Šè­¦ç³»ç»Ÿ)
  - [5. äº‹ä»¶é©±åŠ¨æ¶æ„](#5-äº‹ä»¶é©±åŠ¨æ¶æ„)
    - [5.1 äº‹ä»¶æºæ¨¡å¼ï¼ˆEvent Sourcingï¼‰](#51-äº‹ä»¶æºæ¨¡å¼event-sourcing)
      - [äº‹ä»¶å­˜å‚¨è®¾è®¡](#äº‹ä»¶å­˜å‚¨è®¾è®¡)
    - [5.2 CQRSæ¨¡å¼](#52-cqrsæ¨¡å¼)
      - [è¯»å†™åˆ†ç¦»å®ç°](#è¯»å†™åˆ†ç¦»å®ç°)
  - [8. å®æˆ˜æ¡ˆä¾‹](#8-å®æˆ˜æ¡ˆä¾‹)
    - [8.1 æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ](#81-æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ)
      - [æ¬ºè¯ˆæ¨¡å¼æ£€æµ‹](#æ¬ºè¯ˆæ¨¡å¼æ£€æµ‹)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“ æ›´æ–°æ—¥å¿—](#-æ›´æ–°æ—¥å¿—)

---

## 1. äº‹ä»¶åˆ†ææ¦‚è¿°

### 1.1 äº‹ä»¶å¤„ç†æ¦‚å¿µ

#### äº‹ä»¶å®šä¹‰

```text
äº‹ä»¶ï¼ˆEventï¼‰:
- åœ¨ç‰¹å®šæ—¶é—´ç‚¹å‘ç”Ÿçš„ä¸šåŠ¡äº‹å®
- ä¸å¯å˜çš„è®°å½•
- åŒ…å«æ—¶é—´æˆ³ã€ç±»å‹ã€æ•°æ®

äº‹ä»¶æµï¼ˆEvent Streamï¼‰:
- è¿ç»­çš„äº‹ä»¶åºåˆ—
- æœ‰åºçš„äº‹ä»¶é›†åˆ
- å¯èƒ½æ— ç•Œ

äº‹ä»¶å¤„ç†:
- å®æ—¶å¤„ç†äº‹ä»¶æµ
- æ£€æµ‹äº‹ä»¶æ¨¡å¼
- è§¦å‘å“åº”åŠ¨ä½œ
```

#### äº‹ä»¶ç±»å‹

```sql
-- äº‹ä»¶ç±»å‹å®šä¹‰è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'event_types') THEN
        DROP TABLE event_types;
        RAISE NOTICE 'å·²åˆ é™¤ç°æœ‰è¡¨: event_types';
    END IF;

    CREATE TABLE event_types (
        id SERIAL PRIMARY KEY,
        type_name VARCHAR(100) UNIQUE NOT NULL,
        description TEXT,
        schema_definition JSONB,  -- äº‹ä»¶æ•°æ®æ¨¡å¼
        severity VARCHAR(20),  -- 'low', 'medium', 'high', 'critical'
        created_at TIMESTAMPTZ DEFAULT NOW()
    );

    RAISE NOTICE 'è¡¨åˆ›å»ºæˆåŠŸ: event_types';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE WARNING 'è¡¨event_typeså·²å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
END $$;

-- å¸¸è§äº‹ä»¶ç±»å‹ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
DECLARE
    insert_count INT;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'event_types') THEN
        RAISE EXCEPTION 'è¡¨event_typesä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º';
    END IF;

    INSERT INTO event_types (type_name, description, severity) VALUES
    ('user_login', 'ç”¨æˆ·ç™»å½•äº‹ä»¶', 'low'),
    ('user_logout', 'ç”¨æˆ·ç™»å‡ºäº‹ä»¶', 'low'),
    ('page_view', 'é¡µé¢æµè§ˆäº‹ä»¶', 'low'),
    ('add_to_cart', 'æ·»åŠ åˆ°è´­ç‰©è½¦', 'medium'),
    ('purchase', 'è´­ä¹°äº‹ä»¶', 'high')
    ON CONFLICT (type_name) DO NOTHING;

    GET DIAGNOSTICS insert_count = ROW_COUNT;
    RAISE NOTICE 'äº‹ä»¶ç±»å‹æ’å…¥æˆåŠŸ: % è¡Œ', insert_count;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION 'è¡¨event_typesä¸å­˜åœ¨';
    WHEN unique_violation THEN
        RAISE WARNING 'äº‹ä»¶ç±»å‹å·²å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'æ’å…¥äº‹ä»¶ç±»å‹å¤±è´¥: %', SQLERRM;
END $$;
('payment_failed', 'æ”¯ä»˜å¤±è´¥', 'high'),
('security_alert', 'å®‰å…¨å‘Šè­¦', 'critical');
```

### 1.2 äº‹ä»¶åˆ†æç±»å‹

#### åˆ†æç±»å‹åˆ†ç±»

```text
1. å®æ—¶äº‹ä»¶å¤„ç†
   - äº‹ä»¶æ¨¡å¼åŒ¹é…
   - å®æ—¶å“åº”
   - ä½å»¶è¿Ÿå¤„ç†

2. äº‹ä»¶æµåˆ†æ
   - äº‹ä»¶åºåˆ—åˆ†æ
   - äº‹ä»¶å…³è”åˆ†æ
   - è¶‹åŠ¿åˆ†æ

3. å¼‚å¸¸äº‹ä»¶æ£€æµ‹
   - å¼‚å¸¸æ¨¡å¼è¯†åˆ«
   - ç¦»ç¾¤ç‚¹æ£€æµ‹
   - å¼‚å¸¸åºåˆ—æ£€æµ‹

4. äº‹ä»¶æŒ–æ˜
   - é¢‘ç¹äº‹ä»¶æ¨¡å¼
   - äº‹ä»¶å…³è”è§„åˆ™
   - äº‹ä»¶é¢„æµ‹
```

### 1.3 åº”ç”¨åœºæ™¯

#### å…¸å‹åº”ç”¨åœºæ™¯

```text
åœºæ™¯1: æ¬ºè¯ˆæ£€æµ‹
- æ£€æµ‹å¼‚å¸¸äº¤æ˜“æ¨¡å¼
- å®æ—¶é£é™©è¯„åˆ†
- è‡ªåŠ¨é˜»æ­¢å¯ç–‘äº¤æ˜“

åœºæ™¯2: ç½‘ç»œå®‰å…¨
- æ£€æµ‹æ”»å‡»æ¨¡å¼
- å¼‚å¸¸è¡Œä¸ºè¯†åˆ«
- å®æ—¶å¨èƒå“åº”

åœºæ™¯3: ä¸šåŠ¡æµç¨‹ç›‘æ§
- æµç¨‹æ‰§è¡Œç›‘æ§
- å¼‚å¸¸æµç¨‹æ£€æµ‹
- æ€§èƒ½åˆ†æ

åœºæ™¯4: IoTäº‹ä»¶å¤„ç†
- è®¾å¤‡çŠ¶æ€ç›‘æ§
- æ•…éšœæ£€æµ‹
- é¢„æµ‹æ€§ç»´æŠ¤
```

---

## 2. å¤æ‚äº‹ä»¶å¤„ç†ï¼ˆCEPï¼‰

### 2.1 äº‹ä»¶æ¨¡å¼å®šä¹‰

#### æ¨¡å¼å®šä¹‰è¯­è¨€

```sql
-- äº‹ä»¶æ¨¡å¼å®šä¹‰è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'event_patterns') THEN
        DROP TABLE event_patterns;
        RAISE NOTICE 'å·²åˆ é™¤ç°æœ‰è¡¨: event_patterns';
    END IF;

    CREATE TABLE event_patterns (
        id SERIAL PRIMARY KEY,
        pattern_name VARCHAR(100) UNIQUE NOT NULL,
        pattern_definition JSONB NOT NULL,
        description TEXT,
        action_type VARCHAR(50),  -- 'alert', 'trigger', 'block'
        action_config JSONB,
        enabled BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );

    RAISE NOTICE 'è¡¨åˆ›å»ºæˆåŠŸ: event_patterns';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE WARNING 'è¡¨event_patternså·²å­˜åœ¨';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
END $$;

-- æ¨¡å¼å®šä¹‰JSONç»“æ„ç¤ºä¾‹
-- {
--   "sequence": [
--     {"type": "event_type_1", "conditions": {...}},
--     {"type": "event_type_2", "conditions": {...}}
--   ],
--   "time_window": "5 minutes",
--   "match_type": "strict" | "skip_till_any_match" | "skip_till_next_match"
-- }
```

#### æ¨¡å¼åŒ¹é…å¼•æ“

```sql
CREATE OR REPLACE FUNCTION match_event_pattern(
    p_pattern_id INTEGER,
    p_event JSONB
)
RETURNS BOOLEAN AS $$
DECLARE
    v_pattern JSONB;
    v_sequence JSONB;
    v_time_window INTERVAL;
    v_condition JSONB;
BEGIN
    -- è·å–æ¨¡å¼å®šä¹‰
    SELECT pattern_definition INTO v_pattern
    FROM event_patterns
    WHERE id = p_pattern_id AND enabled = TRUE;

    IF v_pattern IS NULL THEN
        RETURN FALSE;
    END IF;

    v_sequence := v_pattern->'sequence';
    v_time_window := (v_pattern->>'time_window')::INTERVAL;

    -- æ£€æŸ¥äº‹ä»¶æ˜¯å¦åŒ¹é…åºåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªæ¡ä»¶
    v_condition := v_sequence->0;

    IF match_event_condition(p_event, v_condition) THEN
        -- æŸ¥æ‰¾åºåˆ—åŒ¹é…ï¼ˆç®€åŒ–ç‰ˆï¼‰
        RETURN check_event_sequence(p_pattern_id, p_event, v_sequence, v_time_window);
    END IF;

    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- äº‹ä»¶æ¡ä»¶åŒ¹é…ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION match_event_condition(
    p_event JSONB,
    p_condition JSONB
)
RETURNS BOOLEAN AS $$
BEGIN
    -- æ£€æŸ¥è¾“å…¥å‚æ•°
    IF p_event IS NULL OR p_condition IS NULL THEN
        RAISE EXCEPTION 'å‚æ•°ä¸èƒ½ä¸ºNULL';
    END IF;

    -- æ£€æŸ¥äº‹ä»¶ç±»å‹
    IF p_condition->>'type' IS NOT NULL THEN
        IF (p_event->>'type')::TEXT != (p_condition->>'type')::TEXT THEN
            RETURN FALSE;
        END IF;
    END IF;

    -- æ£€æŸ¥æ•°å€¼æ¡ä»¶
    IF p_condition->>'value_threshold' IS NOT NULL THEN
        IF (p_event->>'value')::NUMERIC < (p_condition->>'value_threshold')::NUMERIC THEN
            RETURN FALSE;
        END IF;
    END IF;

    -- æ£€æŸ¥å±æ€§æ¡ä»¶
    IF p_condition->'properties' IS NOT NULL THEN
        -- é€’å½’æ£€æŸ¥æ‰€æœ‰å±æ€§æ¡ä»¶
        RETURN check_properties(p_event, p_condition->'properties');
    END IF;

    RETURN TRUE;
EXCEPTION
    WHEN invalid_text_representation THEN
        RAISE WARNING 'JSONBæ•°æ®æ ¼å¼é”™è¯¯';
        RETURN FALSE;
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åŒ¹é…äº‹ä»¶æ¡ä»¶å¤±è´¥: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
```

### 2.2 äº‹ä»¶åºåˆ—åŒ¹é…

#### åºåˆ—åŒ¹é…å®ç°

```sql
-- äº‹ä»¶åºåˆ—çŠ¶æ€è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'event_sequence_states') THEN
        DROP TABLE event_sequence_states;
        RAISE NOTICE 'å·²åˆ é™¤ç°æœ‰è¡¨: event_sequence_states';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'event_patterns') THEN
        RAISE EXCEPTION 'è¡¨event_patternsä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º';
    END IF;

    CREATE TABLE event_sequence_states (
        id BIGSERIAL PRIMARY KEY,
        pattern_id INTEGER REFERENCES event_patterns(id),
        sequence_state JSONB,  -- å½“å‰åŒ¹é…çŠ¶æ€
        matched_events BIGINT[],  -- å·²åŒ¹é…çš„äº‹ä»¶IDåˆ—è¡¨
        start_time TIMESTAMPTZ,
    last_update_time TIMESTAMPTZ DEFAULT NOW(),
    is_complete BOOLEAN DEFAULT FALSE
);

-- åºåˆ—åŒ¹é…å‡½æ•°
CREATE OR REPLACE FUNCTION process_event_sequence(
    p_pattern_id INTEGER,
    p_event_id BIGINT,
    p_event JSONB
)
RETURNS BOOLEAN AS $$
DECLARE
    v_pattern JSONB;
    v_sequence JSONB;
    v_time_window INTERVAL;
    v_state_id BIGINT;
    v_current_state INTEGER;
    v_sequence_length INTEGER;
    v_matched_events BIGINT[];
BEGIN
    -- è·å–æ¨¡å¼
    SELECT pattern_definition INTO v_pattern
    FROM event_patterns
    WHERE id = p_pattern_id;

    v_sequence := v_pattern->'sequence';
    v_time_window := (v_pattern->>'time_window')::INTERVAL;
    v_sequence_length := jsonb_array_length(v_sequence);

    -- æŸ¥æ‰¾æˆ–åˆ›å»ºçŠ¶æ€
    SELECT id, (sequence_state->>'current_step')::INTEGER, matched_events
    INTO v_state_id, v_current_state, v_matched_events
    FROM event_sequence_states
    WHERE pattern_id = p_pattern_id
      AND is_complete = FALSE
      AND last_update_time >= NOW() - v_time_window
    ORDER BY last_update_time DESC
    LIMIT 1;

    -- å¦‚æœæ²¡æœ‰çŠ¶æ€ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…ç¬¬ä¸€ä¸ªäº‹ä»¶
    IF v_state_id IS NULL THEN
        IF match_event_condition(p_event, v_sequence->0) THEN
            -- åˆ›å»ºæ–°çŠ¶æ€
            INSERT INTO event_sequence_states (
                pattern_id, sequence_state, matched_events, start_time
            ) VALUES (
                p_pattern_id,
                jsonb_build_object('current_step', 1),
                ARRAY[p_event_id],
                NOW()
            );
            RETURN FALSE;  -- åºåˆ—æœªå®Œæˆ
        END IF;
        RETURN FALSE;
    END IF;

    -- æ£€æŸ¥å½“å‰äº‹ä»¶æ˜¯å¦åŒ¹é…ä¸‹ä¸€æ­¥
    IF match_event_condition(p_event, v_sequence->v_current_state) THEN
        -- æ›´æ–°çŠ¶æ€
        v_matched_events := v_matched_events || p_event_id;
        v_current_state := v_current_state + 1;

        -- æ£€æŸ¥åºåˆ—æ˜¯å¦å®Œæˆ
        IF v_current_state >= v_sequence_length THEN
            -- åºåˆ—åŒ¹é…å®Œæˆ
            UPDATE event_sequence_states
            SET is_complete = TRUE,
                matched_events = v_matched_events,
                last_update_time = NOW()
            WHERE id = v_state_id;
            RETURN TRUE;
        ELSE
            -- æ›´æ–°çŠ¶æ€ï¼Œç»§ç»­åŒ¹é…
            UPDATE event_sequence_states
            SET sequence_state = jsonb_build_object('current_step', v_current_state),
                matched_events = v_matched_events,
                last_update_time = NOW()
            WHERE id = v_state_id;
            RETURN FALSE;
        END IF;
    END IF;

    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;
```

### 2.3 äº‹ä»¶å…³è”åˆ†æ

#### äº‹ä»¶å…³è”è§„åˆ™

```sql
-- äº‹ä»¶å…³è”è§„åˆ™æŒ–æ˜
CREATE OR REPLACE FUNCTION mine_event_associations(
    min_support NUMERIC DEFAULT 0.1,
    min_confidence NUMERIC DEFAULT 0.5,
    time_window INTERVAL DEFAULT '1 hour'
)
RETURNS TABLE (
    antecedent TEXT[],
    consequent TEXT[],
    support NUMERIC,
    confidence NUMERIC,
    lift NUMERIC
) AS $$
DECLARE
    total_sessions BIGINT;
BEGIN
    -- è®¡ç®—æ€»ä¼šè¯æ•°
    SELECT COUNT(DISTINCT session_id) INTO total_sessions
    FROM events
    WHERE created_at >= NOW() - time_window;

    RETURN QUERY
    WITH event_sequences AS (
        -- è·å–ä¼šè¯ä¸­çš„äº‹ä»¶åºåˆ—
        SELECT
            session_id,
            array_agg(event_type ORDER BY created_at) AS event_sequence
        FROM events
        WHERE created_at >= NOW() - time_window
        GROUP BY session_id
    ),
    frequent_patterns AS (
        -- æŸ¥æ‰¾é¢‘ç¹äº‹ä»¶å¯¹
        SELECT
            event_sequence[1] AS event1,
            event_sequence[2] AS event2,
            COUNT(*)::NUMERIC / total_sessions AS support
        FROM event_sequences
        WHERE array_length(event_sequence, 1) >= 2
        GROUP BY event_sequence[1], event_sequence[2]
        HAVING COUNT(*)::NUMERIC / total_sessions >= min_support
    ),
    associations AS (
        SELECT
            ARRAY[event1] AS antecedent,
            ARRAY[event2] AS consequent,
            support,
            -- è®¡ç®—ç½®ä¿¡åº¦ï¼ˆç®€åŒ–ç‰ˆï¼‰
            support / (
                SELECT COUNT(*)::NUMERIC / total_sessions
                FROM event_sequences
                WHERE event_sequence[1] = fp.event1
            ) AS confidence,
            -- è®¡ç®—æå‡åº¦
            support / (
                (SELECT COUNT(*)::NUMERIC / total_sessions
                 FROM event_sequences WHERE event_sequence[1] = fp.event1) *
                (SELECT COUNT(*)::NUMERIC / total_sessions
                 FROM event_sequences WHERE event_sequence[2] = fp.event2)
            ) AS lift
        FROM frequent_patterns fp
    )
    SELECT
        antecedent,
        consequent,
        support,
        confidence,
        lift
    FROM associations
    WHERE confidence >= min_confidence
    ORDER BY lift DESC, confidence DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. å¼‚å¸¸äº‹ä»¶æ£€æµ‹

### 4.1 å¼‚å¸¸æ¨¡å¼è¯†åˆ«

#### ç»Ÿè®¡å¼‚å¸¸æ£€æµ‹

```sql
-- åŸºäºç»Ÿè®¡çš„å¼‚å¸¸æ£€æµ‹
CREATE OR REPLACE FUNCTION detect_statistical_anomalies(
    p_event_type TEXT,
    p_time_window INTERVAL DEFAULT '1 hour',
    p_z_threshold NUMERIC DEFAULT 3.0
)
RETURNS TABLE (
    event_id BIGINT,
    event_time TIMESTAMPTZ,
    event_value NUMERIC,
    z_score NUMERIC,
    is_anomaly BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    WITH stats AS (
        SELECT
            AVG((event_data->>'value')::NUMERIC) AS mean_value,
            STDDEV((event_data->>'value')::NUMERIC) AS stddev_value
        FROM events
        WHERE event_type = p_event_type
          AND created_at >= NOW() - p_time_window
          AND event_data->>'value' IS NOT NULL
    )
    SELECT
        e.id,
        e.created_at,
        (e.event_data->>'value')::NUMERIC,
        ABS((e.event_data->>'value')::NUMERIC - s.mean_value) / NULLIF(s.stddev_value, 0) AS z_score,
        ABS((e.event_data->>'value')::NUMERIC - s.mean_value) / NULLIF(s.stddev_value, 0) > p_z_threshold AS is_anomaly
    FROM events e, stats s
    WHERE e.event_type = p_event_type
      AND e.created_at >= NOW() - INTERVAL '5 minutes'
      AND e.event_data->>'value' IS NOT NULL
      AND ABS((e.event_data->>'value')::NUMERIC - s.mean_value) / NULLIF(s.stddev_value, 0) > p_z_threshold
    ORDER BY z_score DESC;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 ç¦»ç¾¤ç‚¹æ£€æµ‹

#### IQRæ–¹æ³•

```sql
-- IQRæ–¹æ³•æ£€æµ‹ç¦»ç¾¤ç‚¹
CREATE OR REPLACE FUNCTION detect_outliers_iqr(
    p_event_type TEXT,
    p_time_window INTERVAL DEFAULT '24 hours'
)
RETURNS TABLE (
    event_id BIGINT,
    event_value NUMERIC,
    outlier_type TEXT
) AS $$
BEGIN
    RETURN QUERY
    WITH quartiles AS (
        SELECT
            PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY (event_data->>'value')::NUMERIC) AS q1,
            PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY (event_data->>'value')::NUMERIC) AS q3,
            PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY (event_data->>'value')::NUMERIC) -
            PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY (event_data->>'value')::NUMERIC) AS iqr
        FROM events
        WHERE event_type = p_event_type
          AND created_at >= NOW() - p_time_window
          AND event_data->>'value' IS NOT NULL
    )
    SELECT
        e.id,
        (e.event_data->>'value')::NUMERIC,
        CASE
            WHEN (e.event_data->>'value')::NUMERIC < q.q1 - 1.5 * q.iqr THEN 'low_outlier'
            WHEN (e.event_data->>'value')::NUMERIC > q.q3 + 1.5 * q.iqr THEN 'high_outlier'
            ELSE 'normal'
        END
    FROM events e, quartiles q
    WHERE e.event_type = p_event_type
      AND e.created_at >= NOW() - INTERVAL '5 minutes'
      AND e.event_data->>'value' IS NOT NULL
      AND (
          (e.event_data->>'value')::NUMERIC < q.q1 - 1.5 * q.iqr OR
          (e.event_data->>'value')::NUMERIC > q.q3 + 1.5 * q.iqr
      );
END;
$$ LANGUAGE plpgsql;
```

### 4.4 å®æ—¶å¼‚å¸¸å‘Šè­¦

#### å¼‚å¸¸å‘Šè­¦ç³»ç»Ÿ

```sql
-- å¼‚å¸¸å‘Šè­¦è¡¨
CREATE TABLE anomaly_alerts (
    id BIGSERIAL PRIMARY KEY,
    event_id BIGINT REFERENCES events(id),
    alert_type VARCHAR(50),  -- 'statistical', 'pattern', 'sequence'
    severity VARCHAR(20),  -- 'low', 'medium', 'high', 'critical'
    description TEXT,
    detected_at TIMESTAMPTZ DEFAULT NOW(),
    acknowledged BOOLEAN DEFAULT FALSE,
    acknowledged_at TIMESTAMPTZ,
    resolved BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMPTZ
);

-- å®æ—¶å¼‚å¸¸æ£€æµ‹è§¦å‘å™¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION detect_anomalies_on_insert()
RETURNS TRIGGER AS $$
DECLARE
    v_z_score NUMERIC;
    v_mean NUMERIC;
    v_stddev NUMERIC;
    v_is_anomaly BOOLEAN := FALSE;
BEGIN
    -- å¦‚æœäº‹ä»¶åŒ…å«æ•°å€¼ï¼Œè¿›è¡Œç»Ÿè®¡å¼‚å¸¸æ£€æµ‹
    IF NEW.event_data->>'value' IS NOT NULL THEN
        SELECT AVG((event_data->>'value')::NUMERIC), STDDEV((event_data->>'value')::NUMERIC)
        INTO v_mean, v_stddev
        FROM events
        WHERE event_type = NEW.event_type
          AND created_at >= NOW() - INTERVAL '1 hour'
          AND id != NEW.id;

        IF v_stddev > 0 THEN
            v_z_score := ABS((NEW.event_data->>'value')::NUMERIC - v_mean) / v_stddev;

            IF v_z_score > 3.0 THEN
                v_is_anomaly := TRUE;

                -- åˆ›å»ºå‘Šè­¦
                INSERT INTO anomaly_alerts (
                    event_id, alert_type, severity, description
                ) VALUES (
                    NEW.id,
                    'statistical',
                    CASE
                        WHEN v_z_score > 5.0 THEN 'critical'
                        WHEN v_z_score > 4.0 THEN 'high'
                        ELSE 'medium'
                    END,
                    format('Statistical anomaly detected: z-score=%.2f, value=%.2f',
                           v_z_score, (NEW.event_data->>'value')::NUMERIC)
                );

                -- å‘é€é€šçŸ¥
                PERFORM pg_notify('anomaly_alert', json_build_object(
                    'event_id', NEW.id,
                    'alert_type', 'statistical',
                    'z_score', v_z_score
                )::TEXT);
            END IF;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER anomaly_detection_trigger
AFTER INSERT ON events
FOR EACH ROW
EXECUTE FUNCTION detect_anomalies_on_insert();
```

---

## 5. äº‹ä»¶é©±åŠ¨æ¶æ„

### 5.1 äº‹ä»¶æºæ¨¡å¼ï¼ˆEvent Sourcingï¼‰

#### äº‹ä»¶å­˜å‚¨è®¾è®¡

```sql
-- äº‹ä»¶å­˜å‚¨è¡¨
CREATE TABLE event_store (
    id BIGSERIAL PRIMARY KEY,
    aggregate_id TEXT NOT NULL,
    aggregate_type TEXT NOT NULL,
    event_type TEXT NOT NULL,
    event_version INTEGER NOT NULL,
    event_data JSONB NOT NULL,
    metadata JSONB,
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    UNIQUE(aggregate_id, event_version)
);

CREATE INDEX idx_event_store_aggregate ON event_store(aggregate_id, event_version);
CREATE INDEX idx_event_store_type ON event_store(aggregate_type, occurred_at);
CREATE INDEX idx_event_store_time ON event_store(occurred_at);

-- å¿«ç…§è¡¨ï¼ˆç”¨äºæ€§èƒ½ä¼˜åŒ–ï¼‰
CREATE TABLE aggregate_snapshots (
    aggregate_id TEXT PRIMARY KEY,
    aggregate_type TEXT NOT NULL,
    snapshot_data JSONB NOT NULL,
    snapshot_version INTEGER NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- è¿½åŠ äº‹ä»¶
CREATE OR REPLACE FUNCTION append_event(
    p_aggregate_id TEXT,
    p_aggregate_type TEXT,
    p_event_type TEXT,
    p_event_data JSONB,
    p_metadata JSONB DEFAULT NULL
)
RETURNS BIGINT AS $$
DECLARE
    v_version INTEGER;
    v_event_id BIGINT;
BEGIN
    -- è·å–ä¸‹ä¸€ä¸ªç‰ˆæœ¬å·
    SELECT COALESCE(MAX(event_version), 0) + 1 INTO v_version
    FROM event_store
    WHERE aggregate_id = p_aggregate_id;

    -- æ’å…¥äº‹ä»¶
    INSERT INTO event_store (
        aggregate_id, aggregate_type, event_type,
        event_version, event_data, metadata
    ) VALUES (
        p_aggregate_id, p_aggregate_type, p_event_type,
        v_version, p_event_data, p_metadata
    ) RETURNING id INTO v_event_id;

    -- å‘å¸ƒäº‹ä»¶é€šçŸ¥
    PERFORM pg_notify('event_append', json_build_object(
        'aggregate_id', p_aggregate_id,
        'event_type', p_event_type,
        'version', v_version
    )::TEXT);

    RETURN v_event_id;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 CQRSæ¨¡å¼

#### è¯»å†™åˆ†ç¦»å®ç°

```sql
-- å†™æ¨¡å‹ï¼šäº‹ä»¶å­˜å‚¨ï¼ˆå·²å®šä¹‰ï¼‰

-- è¯»æ¨¡å‹ï¼šç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW user_read_model AS
SELECT
    aggregate_id AS user_id,
    (snapshot_data->>'name')::TEXT AS name,
    (snapshot_data->>'email')::TEXT AS email,
    (snapshot_data->>'status')::TEXT AS status,
    snapshot_version,
    created_at AS last_updated
FROM aggregate_snapshots
WHERE aggregate_type = 'User'
ORDER BY aggregate_id;

-- äº‹ä»¶å¤„ç†å™¨ï¼šæ›´æ–°è¯»æ¨¡å‹
CREATE OR REPLACE FUNCTION update_read_model()
RETURNS TRIGGER AS $$
BEGIN
    -- æ ¹æ®äº‹ä»¶ç±»å‹æ›´æ–°è¯»æ¨¡å‹
    IF NEW.aggregate_type = 'User' THEN
        -- é‡å»ºç”¨æˆ·è¯»æ¨¡å‹ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…åº”è¯¥å¢é‡æ›´æ–°ï¼‰
        REFRESH MATERIALIZED VIEW CONCURRENTLY user_read_model;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_read_model_trigger
AFTER INSERT ON event_store
FOR EACH ROW
EXECUTE FUNCTION update_read_model();
```

---

## 8. å®æˆ˜æ¡ˆä¾‹

### 8.1 æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ

#### æ¬ºè¯ˆæ¨¡å¼æ£€æµ‹

```sql
-- æ¬ºè¯ˆæ£€æµ‹æ¨¡å¼å®šä¹‰
INSERT INTO event_patterns (pattern_name, pattern_definition, action_type) VALUES
('rapid_transactions', '{
    "sequence": [
        {"type": "transaction", "conditions": {"amount": {"$gt": 1000}}},
        {"type": "transaction", "conditions": {"amount": {"$gt": 1000}}},
        {"type": "transaction", "conditions": {"amount": {"$gt": 1000}}}
    ],
    "time_window": "5 minutes",
    "match_type": "strict"
}'::JSONB, 'block');

-- æ¬ºè¯ˆæ£€æµ‹è§¦å‘å™¨
CREATE OR REPLACE FUNCTION fraud_detection()
RETURNS TRIGGER AS $$
DECLARE
    v_pattern_match BOOLEAN;
    v_transaction_count INTEGER;
BEGIN
    -- æ£€æŸ¥å¿«é€Ÿäº¤æ˜“æ¨¡å¼
    SELECT COUNT(*) INTO v_transaction_count
    FROM events
    WHERE event_type = 'transaction'
      AND (event_data->>'account_id')::TEXT = (NEW.event_data->>'account_id')::TEXT
      AND created_at >= NOW() - INTERVAL '5 minutes'
      AND (event_data->>'amount')::NUMERIC > 1000;

    IF v_transaction_count >= 3 THEN
        -- åˆ›å»ºæ¬ºè¯ˆå‘Šè­¦
        INSERT INTO anomaly_alerts (
            event_id, alert_type, severity, description
        ) VALUES (
            NEW.id,
            'fraud_pattern',
            'critical',
            format('Fraud pattern detected: %s rapid large transactions in 5 minutes', v_transaction_count)
        );

        -- é˜»å¡äº¤æ˜“
        RAISE EXCEPTION 'Fraud detected: transaction blocked';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER fraud_detection_trigger
BEFORE INSERT ON events
FOR EACH ROW
WHEN (NEW.event_type = 'transaction')
EXECUTE FUNCTION fraud_detection();
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **äº‹ä»¶é©±åŠ¨æ¶æ„**: <https://martinfowler.com/articles/201701-event-driven.html>
2. **Event Sourcingæ¨¡å¼**: <https://martinfowler.com/eaaDev/EventSourcing.html>
3. **CQRSæ¨¡å¼**: <https://martinfowler.com/bliki/CQRS.html>
4. **PostgreSQLè§¦å‘å™¨**: <https://www.postgresql.org/docs/current/triggers.html>

---

## ğŸ“ æ›´æ–°æ—¥å¿—

- **v2.0** (2025-01): å®Œæ•´å®æˆ˜æŒ‡å—
  - è¡¥å……å¤æ‚äº‹ä»¶å¤„ç†ï¼ˆCEPï¼‰å®Œæ•´å®ç°
  - è¡¥å……äº‹ä»¶æµåˆ†æ
  - è¡¥å……å¼‚å¸¸äº‹ä»¶æ£€æµ‹
  - è¡¥å……äº‹ä»¶é©±åŠ¨æ¶æ„
  - è¡¥å……äº‹ä»¶å¤„ç†å¼•æ“
  - è¡¥å……äº‹ä»¶å­˜å‚¨ä¸æŸ¥è¯¢
  - è¡¥å……å®æˆ˜æ¡ˆä¾‹

---

**çŠ¶æ€**: âœ… **æ–‡æ¡£å®Œæˆ** | [è¿”å›ç›®å½•](./README.md)
