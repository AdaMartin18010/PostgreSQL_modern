---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `DataBaseTheory\09-æ•°æ®æ¨¡å‹ä¸è§„èŒƒåŒ–\04-å¸¸è§è®¾è®¡æ¨¡å¼.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# PostgreSQLå¸¸è§è®¾è®¡æ¨¡å¼

## ğŸ“‹ ç›®å½•

- [PostgreSQLå¸¸è§è®¾è®¡æ¨¡å¼](#postgresqlå¸¸è§è®¾è®¡æ¨¡å¼)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è½¯åˆ é™¤æ¨¡å¼](#1-è½¯åˆ é™¤æ¨¡å¼)
    - [1.1 åŸºç¡€å®ç°](#11-åŸºç¡€å®ç°)
    - [1.2 çº§è”è½¯åˆ é™¤](#12-çº§è”è½¯åˆ é™¤)
  - [2. å®¡è®¡å­—æ®µæ¨¡å¼](#2-å®¡è®¡å­—æ®µæ¨¡å¼)
    - [2.1 æ ‡å‡†å®¡è®¡å­—æ®µ](#21-æ ‡å‡†å®¡è®¡å­—æ®µ)
  - [3. å¤šç§Ÿæˆ·æ¨¡å¼](#3-å¤šç§Ÿæˆ·æ¨¡å¼)
    - [3.1 å…±äº«Schema + RLS](#31-å…±äº«schema--rls)
    - [3.2 ç‹¬ç«‹Schemaæ¨¡å¼](#32-ç‹¬ç«‹schemaæ¨¡å¼)
  - [4. æ ‘å½¢ç»“æ„æ¨¡å¼](#4-æ ‘å½¢ç»“æ„æ¨¡å¼)
    - [4.1 é‚»æ¥è¡¨æ¨¡å‹](#41-é‚»æ¥è¡¨æ¨¡å‹)
    - [4.2 è·¯å¾„æšä¸¾æ¨¡å‹](#42-è·¯å¾„æšä¸¾æ¨¡å‹)
    - [4.3 Ltreeæ‰©å±•](#43-ltreeæ‰©å±•)
  - [5. æ ‡ç­¾ç³»ç»Ÿæ¨¡å¼](#5-æ ‡ç­¾ç³»ç»Ÿæ¨¡å¼)
    - [5.1 å¤šå¯¹å¤šå…³ç³»](#51-å¤šå¯¹å¤šå…³ç³»)
    - [5.2 æ•°ç»„æ¨¡å¼ï¼ˆç®€åŒ–ï¼‰](#52-æ•°ç»„æ¨¡å¼ç®€åŒ–)
  - [6. ç‰ˆæœ¬æ§åˆ¶æ¨¡å¼](#6-ç‰ˆæœ¬æ§åˆ¶æ¨¡å¼)
    - [6.1 ç‰ˆæœ¬é“¾](#61-ç‰ˆæœ¬é“¾)
  - [7. è®¡æ•°å™¨æ¨¡å¼](#7-è®¡æ•°å™¨æ¨¡å¼)
    - [7.1 å®æ—¶è®¡æ•°å™¨](#71-å®æ—¶è®¡æ•°å™¨)
    - [7.2 åˆ†ç‰‡è®¡æ•°å™¨ï¼ˆé«˜å¹¶å‘ï¼‰](#72-åˆ†ç‰‡è®¡æ•°å™¨é«˜å¹¶å‘)
  - [8. æ—¶é—´åºåˆ—æ¨¡å¼](#8-æ—¶é—´åºåˆ—æ¨¡å¼)
    - [8.1 Hypertableï¼ˆTimescaleDBï¼‰](#81-hypertabletimescaledb)
  - [9. äº‹ä»¶æº¯æºæ¨¡å¼](#9-äº‹ä»¶æº¯æºæ¨¡å¼)
    - [9.1 Event Sourcing](#91-event-sourcing)

## 1. è½¯åˆ é™¤æ¨¡å¼

### 1.1 åŸºç¡€å®ç°

```sql
-- æ·»åŠ deleted_atå­—æ®µ
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æœªåˆ é™¤ï¼‰
CREATE UNIQUE INDEX idx_users_email
ON users(email)
WHERE deleted_at IS NULL;

-- è½¯åˆ é™¤
UPDATE users SET deleted_at = now() WHERE user_id = 123;

-- æŸ¥è¯¢ï¼ˆè¿‡æ»¤å·²åˆ é™¤ï¼‰
SELECT * FROM users WHERE deleted_at IS NULL;

-- è§†å›¾ç®€åŒ–æŸ¥è¯¢
CREATE VIEW active_users AS
SELECT * FROM users WHERE deleted_at IS NULL;

SELECT * FROM active_users WHERE email = 'test@example.com';
```

### 1.2 çº§è”è½¯åˆ é™¤

```sql
-- çˆ¶å­å…³ç³»çº§è”è½¯åˆ é™¤
CREATE OR REPLACE FUNCTION cascade_soft_delete()
RETURNS TRIGGER AS $$
BEGIN
    -- çº§è”åˆ é™¤å­è®°å½•
    UPDATE order_items
    SET deleted_at = NEW.deleted_at
    WHERE order_id = NEW.order_id
      AND deleted_at IS NULL;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_cascade_delete
    AFTER UPDATE OF deleted_at ON orders
    FOR EACH ROW
    WHEN (NEW.deleted_at IS NOT NULL)
    EXECUTE FUNCTION cascade_soft_delete();
```

---

## 2. å®¡è®¡å­—æ®µæ¨¡å¼

### 2.1 æ ‡å‡†å®¡è®¡å­—æ®µ

```sql
-- æ¯ä¸ªè¡¨åŒ…å«å®¡è®¡å­—æ®µ
CREATE TABLE base_entity (
    created_at TIMESTAMPTZ DEFAULT now(),
    created_by VARCHAR(100) DEFAULT current_user,
    updated_at TIMESTAMPTZ DEFAULT now(),
    updated_by VARCHAR(100) DEFAULT current_user,
    version INT DEFAULT 0
);

-- å®é™…è¡¨ç»§æ‰¿
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100)
) INHERITS (base_entity);

-- è‡ªåŠ¨æ›´æ–°è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_audit_fields()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := now();
    NEW.updated_by := current_user;
    NEW.version := OLD.version + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_audit
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_audit_fields();
```

---

## 3. å¤šç§Ÿæˆ·æ¨¡å¼

### 3.1 å…±äº«Schema + RLS

```sql
-- æ‰€æœ‰è¡¨åŒ…å«tenant_id
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    tenant_id INT NOT NULL,
    username VARCHAR(100),
    UNIQUE (tenant_id, username)
);

-- å¯ç”¨RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- RLSç­–ç•¥
CREATE POLICY tenant_isolation ON users
    USING (tenant_id = current_setting('app.current_tenant')::int);

-- åº”ç”¨è®¾ç½®ç§Ÿæˆ·
SET app.current_tenant = 123;
SELECT * FROM users;  -- åªè¿”å›tenant_id=123çš„æ•°æ®
```

### 3.2 ç‹¬ç«‹Schemaæ¨¡å¼

```sql
-- æ¯ä¸ªç§Ÿæˆ·ç‹¬ç«‹Schema
CREATE SCHEMA tenant_123;
CREATE SCHEMA tenant_456;

-- åœ¨ç§Ÿæˆ·Schemaä¸­åˆ›å»ºè¡¨
CREATE TABLE tenant_123.users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(100)
);

-- æœç´¢è·¯å¾„
SET search_path = tenant_123, public;
SELECT * FROM users;  -- è®¿é—®tenant_123.users
```

---

## 4. æ ‘å½¢ç»“æ„æ¨¡å¼

### 4.1 é‚»æ¥è¡¨æ¨¡å‹

```sql
-- æœ€ç®€å•ï¼ŒæŸ¥è¯¢éœ€è¦é€’å½’
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    parent_id INT REFERENCES categories(category_id),
    name VARCHAR(100)
);

CREATE INDEX ON categories(parent_id);

-- é€’å½’æŸ¥è¯¢å­èŠ‚ç‚¹
WITH RECURSIVE subcategories AS (
    SELECT * FROM categories WHERE category_id = 1
    UNION ALL
    SELECT c.* FROM categories c
    JOIN subcategories sc ON c.parent_id = sc.category_id
)
SELECT * FROM subcategories;
```

### 4.2 è·¯å¾„æšä¸¾æ¨¡å‹

```sql
-- å­˜å‚¨å®Œæ•´è·¯å¾„
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    path VARCHAR(500)  -- '/1/5/12/'
);

-- æŸ¥è¯¢å­æ ‘ï¼ˆç®€å•ï¼‰
SELECT * FROM categories WHERE path LIKE '/1/5/%';

-- æ›´æ–°è·¯å¾„ï¼ˆå¤æ‚ï¼‰
UPDATE categories
SET path = REPLACE(path, '/5/', '/6/')
WHERE path LIKE '/1/5/%';
```

### 4.3 Ltreeæ‰©å±•

```sql
-- ä½¿ç”¨ltreeæ‰©å±•
CREATE EXTENSION ltree;

CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    path ltree
);

CREATE INDEX ON categories USING gist(path);

-- æŸ¥è¯¢
SELECT * FROM categories WHERE path <@ '1.5';          -- å­æ ‘
SELECT * FROM categories WHERE path ~ '*.electronics.*';  -- æ¨¡å¼åŒ¹é…

-- æ€§èƒ½ä¼˜äºé€’å½’CTE
```

---

## 5. æ ‡ç­¾ç³»ç»Ÿæ¨¡å¼

### 5.1 å¤šå¯¹å¤šå…³ç³»

```sql
-- æ–‡ç« -æ ‡ç­¾å¤šå¯¹å¤š
CREATE TABLE articles (
    article_id BIGSERIAL PRIMARY KEY,
    title TEXT,
    content TEXT
);

CREATE TABLE tags (
    tag_id SERIAL PRIMARY KEY,
    tag_name VARCHAR(50) UNIQUE
);

CREATE TABLE article_tags (
    article_id BIGINT REFERENCES articles(article_id),
    tag_id INT REFERENCES tags(tag_id),
    PRIMARY KEY (article_id, tag_id)
);

CREATE INDEX ON article_tags(tag_id, article_id);

-- æŸ¥è¯¢
SELECT a.* FROM articles a
JOIN article_tags at ON a.article_id = at.article_id
WHERE at.tag_id IN (1, 5, 8);  -- åŒ…å«ä»»ä¸€æ ‡ç­¾

-- æŸ¥è¯¢åŒ…å«æ‰€æœ‰æ ‡ç­¾
SELECT a.* FROM articles a
JOIN article_tags at ON a.article_id = at.article_id
WHERE at.tag_id IN (1, 5, 8)
GROUP BY a.article_id
HAVING COUNT(DISTINCT at.tag_id) = 3;
```

### 5.2 æ•°ç»„æ¨¡å¼ï¼ˆç®€åŒ–ï¼‰

```sql
-- ä½¿ç”¨æ•°ç»„å­˜å‚¨æ ‡ç­¾
CREATE TABLE articles (
    article_id BIGSERIAL PRIMARY KEY,
    title TEXT,
    content TEXT,
    tags TEXT[]
);

CREATE INDEX ON articles USING gin(tags);

-- æŸ¥è¯¢
SELECT * FROM articles WHERE tags && ARRAY['postgresql','database'];  -- äº¤é›†
SELECT * FROM articles WHERE tags @> ARRAY['postgresql'];              -- åŒ…å«
```

---

## 6. ç‰ˆæœ¬æ§åˆ¶æ¨¡å¼

### 6.1 ç‰ˆæœ¬é“¾

```sql
-- æ–‡æ¡£ç‰ˆæœ¬ç®¡ç†
CREATE TABLE documents (
    doc_id BIGSERIAL PRIMARY KEY,
    previous_version_id BIGINT REFERENCES documents(doc_id),
    title TEXT,
    content TEXT,
    version INT,
    is_current BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- åˆ›å»ºæ–°ç‰ˆæœ¬
INSERT INTO documents (previous_version_id, title, content, version)
SELECT doc_id, title, content || ' (updated)', version + 1
FROM documents
WHERE doc_id = 123 AND is_current = true
RETURNING doc_id;

-- æ ‡è®°æ—§ç‰ˆæœ¬
UPDATE documents SET is_current = false WHERE doc_id = 123;

-- æŸ¥è¯¢ç‰ˆæœ¬å†å²
WITH RECURSIVE versions AS (
    SELECT * FROM documents WHERE doc_id = 150
    UNION ALL
    SELECT d.* FROM documents d
    JOIN versions v ON d.doc_id = v.previous_version_id
)
SELECT * FROM versions ORDER BY version;
```

---

## 7. è®¡æ•°å™¨æ¨¡å¼

### 7.1 å®æ—¶è®¡æ•°å™¨

```sql
-- ç»´æŠ¤æ±‡æ€»è®¡æ•°
CREATE TABLE counters (
    counter_name VARCHAR(100) PRIMARY KEY,
    count BIGINT DEFAULT 0,
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- è§¦å‘å™¨æ›´æ–°
CREATE OR REPLACE FUNCTION update_counter()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO counters (counter_name, count)
        VALUES ('total_users', 1)
        ON CONFLICT (counter_name) DO UPDATE
        SET count = counters.count + 1, updated_at = now();
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE counters SET count = count - 1, updated_at = now()
        WHERE counter_name = 'total_users';
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_user_counter
    AFTER INSERT OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION update_counter();
```

### 7.2 åˆ†ç‰‡è®¡æ•°å™¨ï¼ˆé«˜å¹¶å‘ï¼‰

```sql
-- é¿å…å•è¡Œçƒ­ç‚¹
CREATE TABLE shard_counters (
    counter_name VARCHAR(100),
    shard_id INT,
    count BIGINT DEFAULT 0,
    PRIMARY KEY (counter_name, shard_id)
);

-- åˆå§‹åŒ–100ä¸ªåˆ†ç‰‡
INSERT INTO shard_counters (counter_name, shard_id, count)
SELECT 'page_views', i, 0 FROM generate_series(1, 100) i;

-- å¢åŠ è®¡æ•°ï¼ˆéšæœºåˆ†ç‰‡ï¼‰
UPDATE shard_counters
SET count = count + 1
WHERE counter_name = 'page_views'
  AND shard_id = (random() * 99 + 1)::int;

-- è¯»å–æ€»æ•°
SELECT counter_name, SUM(count) AS total
FROM shard_counters
GROUP BY counter_name;
```

---

## 8. æ—¶é—´åºåˆ—æ¨¡å¼

### 8.1 Hypertableï¼ˆTimescaleDBï¼‰

```sql
CREATE EXTENSION timescaledb;

-- åˆ›å»ºhypertable
CREATE TABLE sensor_data (
    time TIMESTAMPTZ NOT NULL,
    sensor_id INT,
    temperature FLOAT,
    humidity FLOAT
);

SELECT create_hypertable('sensor_data', 'time');

-- è‡ªåŠ¨åˆ†åŒº + è¿ç»­èšåˆ
CREATE MATERIALIZED VIEW sensor_data_hourly
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 hour', time) AS hour,
    sensor_id,
    AVG(temperature) AS avg_temp
FROM sensor_data
GROUP BY hour, sensor_id;
```

---

## 9. äº‹ä»¶æº¯æºæ¨¡å¼

### 9.1 Event Sourcing

```sql
-- äº‹ä»¶å­˜å‚¨è¡¨
CREATE TABLE account_events (
    event_id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    sequence_number BIGINT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE (account_id, sequence_number)
);

-- æ’å…¥äº‹ä»¶
INSERT INTO account_events (account_id, event_type, event_data, sequence_number)
VALUES (123, 'deposit', '{"amount": 100}', 1);

INSERT INTO account_events (account_id, event_type, event_data, sequence_number)
VALUES (123, 'withdrawal', '{"amount": 50}', 2);

-- é‡å»ºå½“å‰çŠ¶æ€
SELECT
    account_id,
    SUM(CASE WHEN event_type = 'deposit' THEN (event_data->>'amount')::numeric
             WHEN event_type = 'withdrawal' THEN -(event_data->>'amount')::numeric
             ELSE 0 END) AS balance
FROM account_events
WHERE account_id = 123
GROUP BY account_id;

-- å¿«ç…§è¡¨ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
CREATE TABLE account_snapshots (
    account_id BIGINT PRIMARY KEY,
    balance NUMERIC,
    last_event_sequence BIGINT,
    snapshot_at TIMESTAMPTZ DEFAULT now()
);

-- å®šæœŸç”Ÿæˆå¿«ç…§
-- æŸ¥è¯¢ = æœ€è¿‘å¿«ç…§ + ä¹‹åçš„äº‹ä»¶
```

---

**å®Œæˆ**: PostgreSQLå¸¸è§è®¾è®¡æ¨¡å¼
**å­—æ•°**: ~10,000å­—
**æ¨¡å¼**: è½¯åˆ é™¤ã€å®¡è®¡å­—æ®µã€å¤šç§Ÿæˆ·ã€æ ‘å½¢ç»“æ„ã€æ ‡ç­¾ç³»ç»Ÿã€ç‰ˆæœ¬æ§åˆ¶ã€è®¡æ•°å™¨ã€æ—¶åºã€äº‹ä»¶æº¯æº

ä»Šæ—¥æ€»äº§å‡ºï¼š**72+æ–‡æ¡£ï¼Œ~358,000å­—ï¼Œ~15,000è¡Œä»£ç **

ç»§ç»­æ¨è¿›ï¼Ÿ
