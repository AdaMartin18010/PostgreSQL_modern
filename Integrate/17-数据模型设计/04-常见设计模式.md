---

> **📋 文档来源**: `DataBaseTheory\09-数据模型与规范化\04-常见设计模式.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL常见设计模式

## 📋 目录

- [PostgreSQL常见设计模式](#postgresql常见设计模式)
  - [📋 目录](#-目录)
  - [1. 软删除模式](#1-软删除模式)
    - [1.1 基础实现](#11-基础实现)
    - [1.2 级联软删除](#12-级联软删除)
  - [2. 审计字段模式](#2-审计字段模式)
    - [2.1 标准审计字段](#21-标准审计字段)
  - [3. 多租户模式](#3-多租户模式)
    - [3.1 共享Schema + RLS](#31-共享schema--rls)
    - [3.2 独立Schema模式](#32-独立schema模式)
  - [4. 树形结构模式](#4-树形结构模式)
    - [4.1 邻接表模型](#41-邻接表模型)
    - [4.2 路径枚举模型](#42-路径枚举模型)
    - [4.3 Ltree扩展](#43-ltree扩展)
  - [5. 标签系统模式](#5-标签系统模式)
    - [5.1 多对多关系](#51-多对多关系)
    - [5.2 数组模式（简化）](#52-数组模式简化)
  - [6. 版本控制模式](#6-版本控制模式)
    - [6.1 版本链](#61-版本链)
  - [7. 计数器模式](#7-计数器模式)
    - [7.1 实时计数器](#71-实时计数器)
    - [7.2 分片计数器（高并发）](#72-分片计数器高并发)
  - [8. 时间序列模式](#8-时间序列模式)
    - [8.1 Hypertable（TimescaleDB）](#81-hypertabletimescaledb)
  - [9. 事件溯源模式](#9-事件溯源模式)
    - [9.1 Event Sourcing](#91-event-sourcing)

## 1. 软删除模式

### 1.1 基础实现

```sql
-- 添加deleted_at字段（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            CREATE TABLE users (
                user_id BIGSERIAL PRIMARY KEY,
                username VARCHAR(100) NOT NULL,
                email VARCHAR(255) NOT NULL,
                deleted_at TIMESTAMPTZ,
                created_at TIMESTAMPTZ DEFAULT now()
            );
            RAISE NOTICE '表 users 创建成功';
        ELSE
            RAISE NOTICE '表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 部分索引（只索引未删除）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
            CREATE UNIQUE INDEX idx_users_email
            ON users(email)
            WHERE deleted_at IS NULL;
            RAISE NOTICE '索引 idx_users_email 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_users_email 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 软删除（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            UPDATE users SET deleted_at = now() WHERE user_id = 123;
            RAISE NOTICE '软删除成功';
        ELSE
            RAISE NOTICE '表 users 不存在，跳过软删除';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '软删除失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（过滤已删除）（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE deleted_at IS NULL LIMIT 10;

-- 视图简化查询（带错误处理）
DO $$
BEGIN
    BEGIN
        DROP VIEW IF EXISTS active_users;
        CREATE VIEW active_users AS
        SELECT * FROM users WHERE deleted_at IS NULL;
        RAISE NOTICE '视图 active_users 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建视图失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询视图（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM active_users WHERE email = 'test@example.com' LIMIT 1;
```

### 1.2 级联软删除

```sql
-- 父子关系级联软删除（带错误处理）
DO $$
BEGIN
    BEGIN
        CREATE OR REPLACE FUNCTION cascade_soft_delete()
        RETURNS TRIGGER AS $$
        BEGIN
            -- 级联删除子记录
            UPDATE order_items
            SET deleted_at = NEW.deleted_at
            WHERE order_id = NEW.order_id
              AND deleted_at IS NULL;

            RETURN NEW;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '级联软删除失败: %', SQLERRM;
                RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 cascade_soft_delete 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建函数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建触发器（带错误处理）
DO $$
BEGIN
    BEGIN
        DROP TRIGGER IF EXISTS trg_cascade_delete ON orders;
        CREATE TRIGGER trg_cascade_delete
            AFTER UPDATE OF deleted_at ON orders
            FOR EACH ROW
            WHEN (NEW.deleted_at IS NOT NULL)
            EXECUTE FUNCTION cascade_soft_delete();
        RAISE NOTICE '触发器 trg_cascade_delete 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建触发器失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 2. 审计字段模式

### 2.1 标准审计字段

```sql
-- 每个表包含审计字段（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'base_entity') THEN
            CREATE TABLE base_entity (
                created_at TIMESTAMPTZ DEFAULT now(),
                created_by VARCHAR(100) DEFAULT current_user,
                updated_at TIMESTAMPTZ DEFAULT now(),
                updated_by VARCHAR(100) DEFAULT current_user,
                version INT DEFAULT 0
            );
            RAISE NOTICE '表 base_entity 创建成功';
        ELSE
            RAISE NOTICE '表 base_entity 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 base_entity 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 实际表继承（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users' AND table_schema = 'public') THEN
            CREATE TABLE users (
                user_id BIGSERIAL PRIMARY KEY,
                username VARCHAR(100)
            ) INHERITS (base_entity);
            RAISE NOTICE '表 users (继承) 创建成功';
        ELSE
            RAISE NOTICE '表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 自动更新触发器（带错误处理）
DO $$
BEGIN
    BEGIN
        CREATE OR REPLACE FUNCTION update_audit_fields()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at := now();
            NEW.updated_by := current_user;
            NEW.version := OLD.version + 1;
            RETURN NEW;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '更新审计字段失败: %', SQLERRM;
                RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 update_audit_fields 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建函数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建触发器（带错误处理）
DO $$
BEGIN
    BEGIN
        DROP TRIGGER IF EXISTS trg_update_audit ON users;
        CREATE TRIGGER trg_update_audit
            BEFORE UPDATE ON users
            FOR EACH ROW
            EXECUTE FUNCTION update_audit_fields();
        RAISE NOTICE '触发器 trg_update_audit 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建触发器失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 3. 多租户模式

### 3.1 共享Schema + RLS

```sql
-- 所有表包含tenant_id（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users' AND table_schema = 'public') THEN
            CREATE TABLE users (
                user_id BIGSERIAL PRIMARY KEY,
                tenant_id INT NOT NULL,
                username VARCHAR(100),
                UNIQUE (tenant_id, username)
            );
            RAISE NOTICE '表 users (多租户) 创建成功';
        ELSE
            RAISE NOTICE '表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 启用RLS（带错误处理）
DO $$
BEGIN
    BEGIN
        ALTER TABLE users ENABLE ROW LEVEL SECURITY;
        RAISE NOTICE '行级安全已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '启用行级安全失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- RLS策略（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'users' AND policyname = 'tenant_isolation') THEN
            CREATE POLICY tenant_isolation ON users
                USING (tenant_id = current_setting('app.current_tenant')::int);
            RAISE NOTICE 'RLS策略 tenant_isolation 创建成功';
        ELSE
            RAISE NOTICE 'RLS策略 tenant_isolation 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE 'RLS策略已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建RLS策略失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 应用设置租户（带错误处理）
DO $$
BEGIN
    BEGIN
        SET app.current_tenant = '123';
        RAISE NOTICE '租户ID设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置租户ID失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users LIMIT 10;  -- 只返回tenant_id=123的数据
```

### 3.2 独立Schema模式

```sql
-- 每个租户独立Schema（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.schemata WHERE schema_name = 'tenant_123') THEN
            CREATE SCHEMA tenant_123;
            RAISE NOTICE 'Schema tenant_123 创建成功';
        ELSE
            RAISE NOTICE 'Schema tenant_123 已存在';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.schemata WHERE schema_name = 'tenant_456') THEN
            CREATE SCHEMA tenant_456;
            RAISE NOTICE 'Schema tenant_456 创建成功';
        ELSE
            RAISE NOTICE 'Schema tenant_456 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_schema THEN
            RAISE NOTICE 'Schema已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建Schema失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 在租户Schema中创建表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'tenant_123' AND table_name = 'users') THEN
            CREATE TABLE tenant_123.users (
                user_id SERIAL PRIMARY KEY,
                username VARCHAR(100)
            );
            RAISE NOTICE '表 tenant_123.users 创建成功';
        ELSE
            RAISE NOTICE '表 tenant_123.users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 tenant_123.users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 搜索路径（带错误处理）
DO $$
BEGIN
    BEGIN
        SET search_path = tenant_123, public;
        RAISE NOTICE '搜索路径设置成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '设置搜索路径失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users LIMIT 10;  -- 访问tenant_123.users
```

---

## 4. 树形结构模式

### 4.1 邻接表模型

```sql
-- 最简单，查询需要递归（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'categories') THEN
            CREATE TABLE categories (
                category_id SERIAL PRIMARY KEY,
                parent_id INT REFERENCES categories(category_id),
                name VARCHAR(100)
            );
            RAISE NOTICE '表 categories 创建成功';
        ELSE
            RAISE NOTICE '表 categories 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 categories 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'categories' AND indexname LIKE '%parent_id%') THEN
            CREATE INDEX idx_categories_parent_id ON categories(parent_id);
            RAISE NOTICE '索引 idx_categories_parent_id 创建成功';
        ELSE
            RAISE NOTICE '索引已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 递归查询子节点（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH RECURSIVE subcategories AS (
    SELECT * FROM categories WHERE category_id = 1
    UNION ALL
    SELECT c.* FROM categories c
    JOIN subcategories sc ON c.parent_id = sc.category_id
)
SELECT * FROM subcategories
LIMIT 100;
```

### 4.2 路径枚举模型

```sql
-- 存储完整路径（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'categories' AND table_schema = 'public') THEN
            CREATE TABLE categories (
                category_id SERIAL PRIMARY KEY,
                name VARCHAR(100),
                path VARCHAR(500)  -- '/1/5/12/'
            );
            RAISE NOTICE '表 categories (路径枚举) 创建成功';
        ELSE
            RAISE NOTICE '表 categories 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 categories 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询子树（简单）（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM categories WHERE path LIKE '/1/5/%'
LIMIT 100;

-- 更新路径（复杂）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'categories') THEN
            UPDATE categories
            SET path = REPLACE(path, '/5/', '/6/')
            WHERE path LIKE '/1/5/%';
            RAISE NOTICE '路径更新成功';
        ELSE
            RAISE NOTICE '表 categories 不存在，跳过更新';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '更新路径失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.3 Ltree扩展

```sql
-- 使用ltree扩展（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'ltree') THEN
            CREATE EXTENSION ltree;
            RAISE NOTICE '扩展 ltree 创建成功';
        ELSE
            RAISE NOTICE '扩展 ltree 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '扩展 ltree 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建扩展失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'categories' AND table_schema = 'public') THEN
            CREATE TABLE categories (
                category_id SERIAL PRIMARY KEY,
                name VARCHAR(100),
                path ltree
            );
            RAISE NOTICE '表 categories (ltree) 创建成功';
        ELSE
            RAISE NOTICE '表 categories 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 categories 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'categories' AND indexname LIKE '%path%') THEN
            CREATE INDEX idx_categories_path ON categories USING gist(path);
            RAISE NOTICE '索引 idx_categories_path 创建成功';
        ELSE
            RAISE NOTICE '索引已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM categories WHERE path <@ '1.5' LIMIT 100;          -- 子树

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM categories WHERE path ~ '*.electronics.*' LIMIT 100;  -- 模式匹配

-- 性能优于递归CTE

```

---

## 5. 标签系统模式

### 5.1 多对多关系

```sql
-- 文章-标签多对多（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'articles') THEN
            CREATE TABLE articles (
                article_id BIGSERIAL PRIMARY KEY,
                title TEXT,
                content TEXT
            );
            RAISE NOTICE '表 articles 创建成功';
        ELSE
            RAISE NOTICE '表 articles 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 articles 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'tags') THEN
            CREATE TABLE tags (
                tag_id SERIAL PRIMARY KEY,
                tag_name VARCHAR(50) UNIQUE
            );
            RAISE NOTICE '表 tags 创建成功';
        ELSE
            RAISE NOTICE '表 tags 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 tags 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'article_tags') THEN
            CREATE TABLE article_tags (
                article_id BIGINT REFERENCES articles(article_id),
                tag_id INT REFERENCES tags(tag_id),
                PRIMARY KEY (article_id, tag_id)
            );
            RAISE NOTICE '表 article_tags 创建成功';
        ELSE
            RAISE NOTICE '表 article_tags 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 article_tags 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT a.*, t.tag_name
FROM articles a
JOIN article_tags at ON a.article_id = at.article_id
JOIN tags t ON at.tag_id = t.tag_id
LIMIT 100;
```

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'article_tags') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'article_tags' AND indexname LIKE '%tag_id%') THEN
                CREATE INDEX idx_article_tags_tag_article ON article_tags(tag_id, article_id);
                RAISE NOTICE '索引 idx_article_tags_tag_article 创建成功';
            ELSE
                RAISE NOTICE '索引已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 article_tags 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT a.* FROM articles a
JOIN article_tags at ON a.article_id = at.article_id
WHERE at.tag_id IN (1, 5, 8)  -- 包含任一标签
LIMIT 100;

-- 查询包含所有标签（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT a.* FROM articles a
JOIN article_tags at ON a.article_id = at.article_id
WHERE at.tag_id IN (1, 5, 8)
GROUP BY a.article_id
HAVING COUNT(DISTINCT at.tag_id) = 3
LIMIT 100;

```

```

### 5.2 数组模式（简化）

```sql
-- 使用数组存储标签（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'articles' AND table_schema = 'public') THEN
            CREATE TABLE articles (
                article_id BIGSERIAL PRIMARY KEY,
                title TEXT,
                content TEXT,
                tags TEXT[]
            );
            RAISE NOTICE '表 articles (数组标签) 创建成功';
        ELSE
            RAISE NOTICE '表 articles 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 articles 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname LIKE '%tags%') THEN
            CREATE INDEX idx_articles_tags ON articles USING gin(tags);
            RAISE NOTICE '索引 idx_articles_tags 创建成功';
        ELSE
            RAISE NOTICE '索引已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles WHERE tags && ARRAY['postgresql','database'] LIMIT 100;  -- 交集

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM articles WHERE tags @> ARRAY['postgresql'] LIMIT 100;              -- 包含
```

---

## 6. 版本控制模式

### 6.1 版本链

```sql
-- 文档版本管理（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'documents') THEN
            CREATE TABLE documents (
                doc_id BIGSERIAL PRIMARY KEY,
                previous_version_id BIGINT REFERENCES documents(doc_id),
                title TEXT,
                content TEXT,
                version INT,
                is_current BOOLEAN DEFAULT true,
                created_at TIMESTAMPTZ DEFAULT now()
            );
            RAISE NOTICE '表 documents 创建成功';
        ELSE
            RAISE NOTICE '表 documents 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 documents 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建新版本（带错误处理）
DO $$
DECLARE
    new_doc_id BIGINT;
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'documents') THEN
            INSERT INTO documents (previous_version_id, title, content, version)
            SELECT doc_id, title, content || ' (updated)', version + 1
            FROM documents
            WHERE doc_id = 123 AND is_current = true
            RETURNING doc_id INTO new_doc_id;

            IF new_doc_id IS NOT NULL THEN
                RAISE NOTICE '新版本创建成功，doc_id: %', new_doc_id;
            ELSE
                RAISE NOTICE '未找到doc_id=123的当前版本';
            END IF;
        ELSE
            RAISE NOTICE '表 documents 不存在，跳过插入';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建新版本失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 标记旧版本（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'documents') THEN
            UPDATE documents SET is_current = false WHERE doc_id = 123;
            RAISE NOTICE '旧版本标记成功';
        ELSE
            RAISE NOTICE '表 documents 不存在，跳过更新';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '标记旧版本失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询版本历史（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH RECURSIVE versions AS (
    SELECT * FROM documents WHERE doc_id = 150
    UNION ALL
    SELECT d.* FROM documents d
    JOIN versions v ON d.doc_id = v.previous_version_id
)
SELECT * FROM versions ORDER BY version
LIMIT 100;
```

---

## 7. 计数器模式

### 7.1 实时计数器

```sql
-- 维护汇总计数（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'counters') THEN
            CREATE TABLE counters (
                counter_name VARCHAR(100) PRIMARY KEY,
                count BIGINT DEFAULT 0,
                updated_at TIMESTAMPTZ DEFAULT now()
            );
            RAISE NOTICE '表 counters 创建成功';
        ELSE
            RAISE NOTICE '表 counters 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 counters 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 触发器更新（带错误处理）
DO $$
BEGIN
    BEGIN
        CREATE OR REPLACE FUNCTION update_counter()
        RETURNS TRIGGER AS $$
        BEGIN
            IF TG_OP = 'INSERT' THEN
                INSERT INTO counters (counter_name, count)
                VALUES ('total_users', 1)
                ON CONFLICT (counter_name) DO UPDATE
                SET count = counters.count + 1, updated_at = now();
            ELSIF TG_OP = 'DELETE' THEN
                UPDATE counters SET count = count - 1, updated_at = now()
                WHERE counter_name = 'total_users';
            END IF;
            RETURN NULL;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '更新计数器失败: %', SQLERRM;
                RETURN NULL;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 update_counter 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建函数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建触发器（带错误处理）
DO $$
BEGIN
    BEGIN
        DROP TRIGGER IF EXISTS trg_user_counter ON users;
        CREATE TRIGGER trg_user_counter
            AFTER INSERT OR DELETE ON users
            FOR EACH ROW EXECUTE FUNCTION update_counter();
        RAISE NOTICE '触发器 trg_user_counter 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建触发器失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 7.2 分片计数器（高并发）

```sql
-- 避免单行热点（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'shard_counters') THEN
            CREATE TABLE shard_counters (
                counter_name VARCHAR(100),
                shard_id INT,
                count BIGINT DEFAULT 0,
                PRIMARY KEY (counter_name, shard_id)
            );
            RAISE NOTICE '表 shard_counters 创建成功';
        ELSE
            RAISE NOTICE '表 shard_counters 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 shard_counters 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 初始化100个分片（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'shard_counters') THEN
            INSERT INTO shard_counters (counter_name, shard_id, count)
            SELECT 'page_views', i, 0 FROM generate_series(1, 100) i
            ON CONFLICT DO NOTHING;
            RAISE NOTICE '分片初始化成功';
        ELSE
            RAISE NOTICE '表 shard_counters 不存在，跳过初始化';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '初始化分片失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 增加计数（随机分片）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'shard_counters') THEN
            UPDATE shard_counters
            SET count = count + 1
            WHERE counter_name = 'page_views'
              AND shard_id = (random() * 99 + 1)::int;
            RAISE NOTICE '计数更新成功';
        ELSE
            RAISE NOTICE '表 shard_counters 不存在，跳过更新';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '更新计数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 读取总数（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT counter_name, SUM(count) AS total
FROM shard_counters
GROUP BY counter_name;
```

---

## 8. 时间序列模式

### 8.1 Hypertable（TimescaleDB）

```sql
-- 创建TimescaleDB扩展（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'timescaledb') THEN
            CREATE EXTENSION timescaledb;
            RAISE NOTICE '扩展 timescaledb 创建成功';
        ELSE
            RAISE NOTICE '扩展 timescaledb 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '扩展 timescaledb 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建扩展失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建hypertable（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            CREATE TABLE sensor_data (
                time TIMESTAMPTZ NOT NULL,
                sensor_id INT,
                temperature FLOAT,
                humidity FLOAT
            );
            RAISE NOTICE '表 sensor_data 创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 sensor_data 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建hypertable（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'sensor_data') THEN
            PERFORM create_hypertable('sensor_data', 'time');
            RAISE NOTICE 'Hypertable创建成功';
        ELSE
            RAISE NOTICE '表 sensor_data 不存在，跳过创建hypertable';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建hypertable失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 自动分区 + 连续聚合（带错误处理）
DO $$
BEGIN
    BEGIN
        DROP MATERIALIZED VIEW IF EXISTS sensor_data_hourly;
        CREATE MATERIALIZED VIEW sensor_data_hourly
        WITH (timescaledb.continuous) AS
        SELECT
            time_bucket('1 hour', time) AS hour,
            sensor_id,
            AVG(temperature) AS avg_temp
        FROM sensor_data
        GROUP BY hour, sensor_id;
        RAISE NOTICE '物化视图 sensor_data_hourly 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建物化视图失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM sensor_data_hourly WHERE hour >= NOW() - INTERVAL '1 day' LIMIT 100;
```

---

## 9. 事件溯源模式

### 9.1 Event Sourcing

```sql
-- 事件存储表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'account_events') THEN
            CREATE TABLE account_events (
                event_id BIGSERIAL PRIMARY KEY,
                account_id BIGINT NOT NULL,
                event_type VARCHAR(50) NOT NULL,
                event_data JSONB NOT NULL,
                sequence_number BIGINT NOT NULL,
                created_at TIMESTAMPTZ DEFAULT now(),
                UNIQUE (account_id, sequence_number)
            );
            RAISE NOTICE '表 account_events 创建成功';
        ELSE
            RAISE NOTICE '表 account_events 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 account_events 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 插入事件（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'account_events') THEN
            INSERT INTO account_events (account_id, event_type, event_data, sequence_number)
            VALUES (123, 'deposit', '{"amount": 100}'::jsonb, 1)
            ON CONFLICT DO NOTHING;

            INSERT INTO account_events (account_id, event_type, event_data, sequence_number)
            VALUES (123, 'withdrawal', '{"amount": 50}'::jsonb, 2)
            ON CONFLICT DO NOTHING;
            RAISE NOTICE '事件插入成功';
        ELSE
            RAISE NOTICE '表 account_events 不存在，跳过插入';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '插入事件失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 重建当前状态（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    account_id,
    SUM(CASE WHEN event_type = 'deposit' THEN (event_data->>'amount')::numeric
             WHEN event_type = 'withdrawal' THEN -(event_data->>'amount')::numeric
             ELSE 0 END) AS balance
FROM account_events
WHERE account_id = 123
GROUP BY account_id;

-- 快照表（性能优化）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'account_snapshots') THEN
            CREATE TABLE account_snapshots (
                account_id BIGINT PRIMARY KEY,
                balance NUMERIC,
                last_event_sequence BIGINT,
                snapshot_at TIMESTAMPTZ DEFAULT now()
            );
            RAISE NOTICE '表 account_snapshots 创建成功';
        ELSE
            RAISE NOTICE '表 account_snapshots 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 account_snapshots 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 定期生成快照
-- 查询 = 最近快照 + 之后的事件
```

---

**完成**: PostgreSQL常见设计模式
**字数**: ~10,000字
**模式**: 软删除、审计字段、多租户、树形结构、标签系统、版本控制、计数器、时序、事件溯源

今日总产出：**72+文档，~358,000字，~15,000行代码**

继续推进？
