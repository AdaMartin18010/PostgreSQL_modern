---

> **ğŸ“‹ æ–‡æ¡£æ¥æº**: `PostgreSQL\09-åº”ç”¨è®¾è®¡\æ•°æ®æ¨¡å‹è®¾è®¡\09.03-æ•°æ®ä»“åº“è®¾è®¡æŒ‡å—.md`
> **ğŸ“… å¤åˆ¶æ—¥æœŸ**: 2025-12-22
> **âš ï¸ æ³¨æ„**: æœ¬æ–‡æ¡£ä¸ºå¤åˆ¶ç‰ˆæœ¬ï¼ŒåŸæ–‡ä»¶ä¿æŒä¸å˜

---

# PostgreSQLæ•°æ®ä»“åº“è®¾è®¡å®Œæ•´æŒ‡å—

> **ç‰ˆæœ¬**: v1.1
> **æœ€åæ›´æ–°**: 2025-11-22
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­â­â­
> **åº”ç”¨åœºæ™¯**: æ•°æ®ä»“åº“ã€å•†ä¸šæ™ºèƒ½ã€OLAPåˆ†æã€æŠ¥è¡¨ç³»ç»Ÿã€æ•°æ®æŒ–æ˜

---

## ğŸ“‹ ç›®å½•

- [PostgreSQLæ•°æ®ä»“åº“è®¾è®¡å®Œæ•´æŒ‡å—](#postgresqlæ•°æ®ä»“åº“è®¾è®¡å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 æ•°æ®ä»“åº“æ¦‚å¿µ](#11-æ•°æ®ä»“åº“æ¦‚å¿µ)
    - [1.2 æ•°æ®ä»“åº“æ¶æ„](#12-æ•°æ®ä»“åº“æ¶æ„)
    - [1.3 PostgreSQLæ•°æ®ä»“åº“ä¼˜åŠ¿](#13-postgresqlæ•°æ®ä»“åº“ä¼˜åŠ¿)
    - [1.4 ç‰ˆæœ¬è¦æ±‚](#14-ç‰ˆæœ¬è¦æ±‚)
  - [äºŒã€æ•°æ®ä»“åº“å»ºæ¨¡](#äºŒæ•°æ®ä»“åº“å»ºæ¨¡)
    - [2.1 æ˜Ÿå‹æ¨¡å‹](#21-æ˜Ÿå‹æ¨¡å‹)
    - [2.2 é›ªèŠ±æ¨¡å‹](#22-é›ªèŠ±æ¨¡å‹)
    - [2.3 äº‹å®è¡¨è®¾è®¡](#23-äº‹å®è¡¨è®¾è®¡)
    - [2.4 ç»´åº¦è¡¨è®¾è®¡](#24-ç»´åº¦è¡¨è®¾è®¡)
  - [ä¸‰ã€ETLæµç¨‹è®¾è®¡](#ä¸‰etlæµç¨‹è®¾è®¡)
    - [3.1 æ•°æ®æŠ½å–](#31-æ•°æ®æŠ½å–)
    - [3.2 æ•°æ®è½¬æ¢](#32-æ•°æ®è½¬æ¢)
    - [3.3 æ•°æ®åŠ è½½](#33-æ•°æ®åŠ è½½)
    - [3.4 å¢é‡æ›´æ–°](#34-å¢é‡æ›´æ–°)
  - [å››ã€æ€§èƒ½ä¼˜åŒ–](#å››æ€§èƒ½ä¼˜åŒ–)
    - [4.1 åˆ†åŒºç­–ç•¥](#41-åˆ†åŒºç­–ç•¥)
    - [4.2 ç´¢å¼•ä¼˜åŒ–](#42-ç´¢å¼•ä¼˜åŒ–)
    - [4.3 ç‰©åŒ–è§†å›¾](#43-ç‰©åŒ–è§†å›¾)
    - [4.4 å¹¶è¡ŒæŸ¥è¯¢](#44-å¹¶è¡ŒæŸ¥è¯¢)
    - [4.5 åˆ—å­˜å‚¨ä¼˜åŒ– ğŸ†•](#45-åˆ—å­˜å‚¨ä¼˜åŒ–-)
      - [ğŸ“Š æ•°æ®ä»“åº“åˆ—å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘](#-æ•°æ®ä»“åº“åˆ—å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘)
      - [ğŸ“Š åˆ—å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”çŸ©é˜µ](#-åˆ—å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”çŸ©é˜µ)
      - [ğŸ“Š æ•°æ®ä»“åº“åˆ—å­˜å‚¨æ¶æ„å›¾](#-æ•°æ®ä»“åº“åˆ—å­˜å‚¨æ¶æ„å›¾)
      - [ğŸ“Š æ•°æ®ä»“åº“ETLåˆ°åˆ—å­˜å‚¨æ•°æ®æµå›¾](#-æ•°æ®ä»“åº“etlåˆ°åˆ—å­˜å‚¨æ•°æ®æµå›¾)
      - [ğŸ“Š æ•°æ®ä»“åº“æ˜Ÿå‹æ¨¡å‹åˆ—å­˜å‚¨ERå›¾](#-æ•°æ®ä»“åº“æ˜Ÿå‹æ¨¡å‹åˆ—å­˜å‚¨erå›¾)
      - [ğŸ“Š åˆ—å­˜å‚¨ETLæµç¨‹æ—¶åºå›¾](#-åˆ—å­˜å‚¨etlæµç¨‹æ—¶åºå›¾)
  - [äº”ã€æ•°æ®è´¨é‡](#äº”æ•°æ®è´¨é‡)
    - [5.1 æ•°æ®æ¸…æ´—](#51-æ•°æ®æ¸…æ´—)
    - [5.2 æ•°æ®éªŒè¯](#52-æ•°æ®éªŒè¯)
    - [5.3 æ•°æ®ä¸€è‡´æ€§](#53-æ•°æ®ä¸€è‡´æ€§)
  - [å…­ã€å®è·µæ¡ˆä¾‹](#å…­å®è·µæ¡ˆä¾‹)
    - [6.1 é›¶å”®æ•°æ®ä»“åº“](#61-é›¶å”®æ•°æ®ä»“åº“)
    - [6.2 é‡‘èæ•°æ®ä»“åº“](#62-é‡‘èæ•°æ®ä»“åº“)
    - [6.3 ç”µå•†æ•°æ®ä»“åº“](#63-ç”µå•†æ•°æ®ä»“åº“)
  - [ä¸ƒã€ç°ä»£æ•°æ®ä»“åº“æ¶æ„](#ä¸ƒç°ä»£æ•°æ®ä»“åº“æ¶æ„)
    - [7.1 å®æ—¶æ•°æ®ä»“åº“](#71-å®æ—¶æ•°æ®ä»“åº“)
    - [7.2 æ•°æ®æ¹–é›†æˆ](#72-æ•°æ®æ¹–é›†æˆ)
    - [7.3 AIè¾…åŠ©æ•°æ®ä»“åº“å»ºæ¨¡](#73-aiè¾…åŠ©æ•°æ®ä»“åº“å»ºæ¨¡)
    - [7.4 æ•°æ®ç½‘æ ¼ï¼ˆData Meshï¼‰æ¶æ„ ğŸ†•](#74-æ•°æ®ç½‘æ ¼data-meshæ¶æ„-)
  - [å…«ã€PostgreSQL 18æ–°ç‰¹æ€§](#å…«postgresql-18æ–°ç‰¹æ€§)
    - [8.1 å¹¶è¡ŒæŸ¥è¯¢å¢å¼º](#81-å¹¶è¡ŒæŸ¥è¯¢å¢å¼º)
    - [8.2 å¼‚æ­¥I/Oä¼˜åŒ–](#82-å¼‚æ­¥ioä¼˜åŒ–)
    - [8.3 å¢é‡å¤‡ä»½ä¼˜åŒ–](#83-å¢é‡å¤‡ä»½ä¼˜åŒ–)
  - [ä¹ã€æœ€ä½³å®è·µ](#ä¹æœ€ä½³å®è·µ)
  - [åã€å‚è€ƒèµ„æº](#åå‚è€ƒèµ„æº)
    - [9.1 å®˜æ–¹æ–‡æ¡£](#91-å®˜æ–¹æ–‡æ¡£)
    - [9.2 ç›¸å…³æ–‡æ¡£](#92-ç›¸å…³æ–‡æ¡£)
    - [9.3 å¤–éƒ¨èµ„æº](#93-å¤–éƒ¨èµ„æº)
  - [åä¸€ã€äº¤å‰å¼•ç”¨](#åä¸€äº¤å‰å¼•ç”¨)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ä¸€ã€æ¦‚è¿°

### 1.1 æ•°æ®ä»“åº“æ¦‚å¿µ

**æ•°æ®ä»“åº“ï¼ˆData Warehouseï¼‰**æ˜¯ä¸€ä¸ªé¢å‘ä¸»é¢˜çš„ã€é›†æˆçš„ã€ç›¸å¯¹ç¨³å®šçš„ã€åæ˜ å†å²å˜åŒ–çš„æ•°æ®é›†åˆï¼Œç”¨äºæ”¯æŒç®¡ç†å†³ç­–ã€‚

**æ•°æ®ä»“åº“ç‰¹å¾**ï¼š

- **é¢å‘ä¸»é¢˜**ï¼šå›´ç»•ä¸šåŠ¡ä¸»é¢˜ç»„ç»‡æ•°æ®
- **é›†æˆæ€§**ï¼šæ•´åˆå¤šä¸ªæ•°æ®æº
- **éæ˜“å¤±æ€§**ï¼šæ•°æ®ç›¸å¯¹ç¨³å®šï¼Œä¸»è¦è¿›è¡ŒæŸ¥è¯¢
- **æ—¶å˜æ€§**ï¼šåæ˜ å†å²å˜åŒ–

**æ•°æ®ä»“åº“ä¸OLTPçš„åŒºåˆ«**ï¼š

| ç‰¹æ€§ | OLTP | æ•°æ®ä»“åº“ï¼ˆOLAPï¼‰ |
| --- | --- | --- |
| **ç”¨é€”** | äº‹åŠ¡å¤„ç† | åˆ†æå†³ç­– |
| **æ•°æ®æ¨¡å‹** | è§„èŒƒåŒ–æ¨¡å‹ | ç»´åº¦æ¨¡å‹ |
| **æŸ¥è¯¢ç±»å‹** | ç®€å•æŸ¥è¯¢ï¼Œé¢‘ç¹æ›´æ–° | å¤æ‚æŸ¥è¯¢ï¼Œæ‰¹é‡åŠ è½½ |
| **æ•°æ®é‡** | ç›¸å¯¹è¾ƒå° | é€šå¸¸å¾ˆå¤§ |
| **æ€§èƒ½è¦æ±‚** | ä½å»¶è¿Ÿå†™å…¥ | å¿«é€ŸæŸ¥è¯¢ |

### 1.2 æ•°æ®ä»“åº“æ¶æ„

**æ•°æ®ä»“åº“æ¶æ„å±‚æ¬¡**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®æºå±‚    â”‚  â† OLTPç³»ç»Ÿã€å¤–éƒ¨æ•°æ®æº
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ETLå±‚      â”‚  â† æ•°æ®æŠ½å–ã€è½¬æ¢ã€åŠ è½½
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®ä»“åº“å±‚  â”‚  â† äº‹å®è¡¨ã€ç»´åº¦è¡¨
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®é›†å¸‚å±‚  â”‚  â† é¢å‘ç‰¹å®šä¸»é¢˜çš„æ•°æ®é›†å¸‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨å±‚      â”‚  â† BIå·¥å…·ã€æŠ¥è¡¨ç³»ç»Ÿ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 PostgreSQLæ•°æ®ä»“åº“ä¼˜åŠ¿

**PostgreSQLåœ¨æ•°æ®ä»“åº“ä¸­çš„ä¼˜åŠ¿**ï¼š

- âœ… **å¼ºå¤§çš„SQLåŠŸèƒ½**ï¼šæ”¯æŒå¤æ‚çš„åˆ†ææŸ¥è¯¢
- âœ… **å¹¶è¡ŒæŸ¥è¯¢**ï¼šæ”¯æŒå¹¶è¡Œå¤„ç†å¤§æ•°æ®é›†
- âœ… **åˆ†åŒºæ”¯æŒ**ï¼šæ”¯æŒå¤šç§åˆ†åŒºç­–ç•¥
- âœ… **ç‰©åŒ–è§†å›¾**ï¼šæ”¯æŒé¢„è®¡ç®—å’Œç¼“å­˜
- âœ… **æ‰©å±•æ”¯æŒ**ï¼šæ”¯æŒPostGISã€pgvectorç­‰æ‰©å±•
- âœ… **æˆæœ¬æ•ˆç›Š**ï¼šå¼€æºå…è´¹ï¼Œæˆæœ¬ä½

### 1.4 ç‰ˆæœ¬è¦æ±‚

- **PostgreSQL 18.x**ï¼ˆæ¨èï¼‰- æ”¯æŒå¹¶è¡ŒæŸ¥è¯¢å¢å¼ºã€å¼‚æ­¥I/O
- **PostgreSQL 17.x**ï¼ˆæ¨èï¼‰- åŠŸèƒ½å®Œæ•´
- **PostgreSQL 16.x**ï¼ˆå…¼å®¹ï¼‰- åŸºç¡€åŠŸèƒ½æ”¯æŒ

---

## äºŒã€æ•°æ®ä»“åº“å»ºæ¨¡

### 2.1 æ˜Ÿå‹æ¨¡å‹

**æ˜Ÿå‹æ¨¡å‹**æ˜¯æ•°æ®ä»“åº“æœ€å¸¸ç”¨çš„æ¨¡å‹ï¼Œç”±ä¸€ä¸ªäº‹å®è¡¨å’Œå¤šä¸ªç»´åº¦è¡¨ç»„æˆã€‚

**æ˜Ÿå‹æ¨¡å‹ç»“æ„**ï¼š

```sql
-- äº‹å®è¡¨ï¼ˆFact Tableï¼‰
CREATE TABLE sales_fact (
    sale_id BIGSERIAL,
    -- ç»´åº¦é”®ï¼ˆDimension Keysï¼‰
    date_id INTEGER NOT NULL REFERENCES date_dim(date_id),
    product_id INTEGER NOT NULL REFERENCES product_dim(product_id),
    customer_id INTEGER NOT NULL REFERENCES customer_dim(customer_id),
    store_id INTEGER NOT NULL REFERENCES store_dim(store_id),
    -- åº¦é‡ï¼ˆMeasuresï¼‰
    quantity INTEGER NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2) NOT NULL,
    profit NUMERIC(10,2) GENERATED ALWAYS AS (amount - cost) STORED,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    PRIMARY KEY (sale_id, date_id)
) PARTITION BY RANGE (date_id);

-- æ—¥æœŸç»´åº¦è¡¨
CREATE TABLE date_dim (
    date_id INTEGER PRIMARY KEY,
    date DATE NOT NULL UNIQUE,
    -- æ—¥æœŸå±æ€§
    year INTEGER NOT NULL,
    quarter INTEGER NOT NULL,
    month INTEGER NOT NULL,
    week INTEGER NOT NULL,
    day_of_month INTEGER NOT NULL,
    day_of_week INTEGER NOT NULL,
    day_name VARCHAR(20) NOT NULL,
    is_weekend BOOLEAN NOT NULL,
    is_holiday BOOLEAN NOT NULL,
    holiday_name VARCHAR(100),
    -- è´¢åŠ¡å¹´åº¦
    fiscal_year INTEGER,
    fiscal_quarter INTEGER,
    fiscal_month INTEGER
);

-- äº§å“ç»´åº¦è¡¨ï¼ˆæ‰å¹³åŒ–ï¼‰
CREATE TABLE product_dim (
    product_id INTEGER PRIMARY KEY,
    product_code VARCHAR(50) UNIQUE NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    -- ç›´æ¥å­˜å‚¨åˆ†ç±»ä¿¡æ¯ï¼ˆä¸è§„èŒƒåŒ–ï¼‰
    category_id INTEGER NOT NULL,
    category_name VARCHAR(100) NOT NULL,
    category_group VARCHAR(50),
    -- ç›´æ¥å­˜å‚¨å“ç‰Œä¿¡æ¯
    brand_id INTEGER NOT NULL,
    brand_name VARCHAR(100) NOT NULL,
    manufacturer VARCHAR(200),
    -- äº§å“å±æ€§
    price NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2) NOT NULL,
    unit VARCHAR(20),
    -- SCDç±»å‹2ï¼šç‰ˆæœ¬æ§åˆ¶
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT TRUE
);

-- å®¢æˆ·ç»´åº¦è¡¨
CREATE TABLE customer_dim (
    customer_id INTEGER PRIMARY KEY,
    customer_code VARCHAR(50) UNIQUE NOT NULL,
    customer_name VARCHAR(100) NOT NULL,
    -- äººå£ç»Ÿè®¡ä¿¡æ¯
    gender VARCHAR(10),
    age INTEGER,
    age_group VARCHAR(20),
    -- åœ°ç†ä¿¡æ¯
    city VARCHAR(100),
    province VARCHAR(100),
    region VARCHAR(100),
    country VARCHAR(100),
    -- å®¢æˆ·åˆ†ç±»
    customer_segment VARCHAR(50),
    customer_type VARCHAR(50),
    -- SCDç±»å‹2ï¼šç‰ˆæœ¬æ§åˆ¶
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT TRUE
);

-- é—¨åº—ç»´åº¦è¡¨
CREATE TABLE store_dim (
    store_id INTEGER PRIMARY KEY,
    store_code VARCHAR(50) UNIQUE NOT NULL,
    store_name VARCHAR(200) NOT NULL,
    -- åœ°ç†ä¿¡æ¯
    city VARCHAR(100),
    province VARCHAR(100),
    region VARCHAR(100),
    country VARCHAR(100),
    address TEXT,
    -- é—¨åº—å±æ€§
    store_type VARCHAR(50),
    store_size NUMERIC(10,2),
    opening_date DATE,
    -- SCDç±»å‹2ï¼šç‰ˆæœ¬æ§åˆ¶
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT TRUE
);
```

### 2.2 é›ªèŠ±æ¨¡å‹

**é›ªèŠ±æ¨¡å‹**æ˜¯è§„èŒƒåŒ–çš„ç»´åº¦æ¨¡å‹ï¼Œç»´åº¦è¡¨è¿›ä¸€æ­¥è§„èŒƒåŒ–ã€‚

```sql
-- é›ªèŠ±æ¨¡å‹ï¼šç»´åº¦è¡¨è§„èŒƒåŒ–
CREATE TABLE product_dim (
    product_id INTEGER PRIMARY KEY,
    product_code VARCHAR(50) UNIQUE NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_id INTEGER NOT NULL REFERENCES category_dim(category_id),
    brand_id INTEGER NOT NULL REFERENCES brand_dim(brand_id),
    price NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2) NOT NULL
);

CREATE TABLE category_dim (
    category_id INTEGER PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL,
    category_group_id INTEGER NOT NULL REFERENCES category_group_dim(category_group_id)
);

CREATE TABLE category_group_dim (
    category_group_id INTEGER PRIMARY KEY,
    category_group_name VARCHAR(100) NOT NULL
);

CREATE TABLE brand_dim (
    brand_id INTEGER PRIMARY KEY,
    brand_name VARCHAR(100) NOT NULL,
    manufacturer_id INTEGER NOT NULL REFERENCES manufacturer_dim(manufacturer_id)
);

CREATE TABLE manufacturer_dim (
    manufacturer_id INTEGER PRIMARY KEY,
    manufacturer_name VARCHAR(200) NOT NULL,
    country VARCHAR(100),
    region VARCHAR(100)
);
```

### 2.3 äº‹å®è¡¨è®¾è®¡

**äº‹å®è¡¨ç±»å‹**ï¼š

**1. äº‹åŠ¡äº‹å®è¡¨**ï¼šè®°å½•æ¯ä¸ªäº‹åŠ¡äº‹ä»¶

```sql
-- äº‹åŠ¡äº‹å®è¡¨ï¼šè®°å½•æ¯ç¬”é”€å”®
CREATE TABLE sales_fact (
    sale_id BIGSERIAL,
    date_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    -- åº¦é‡
    quantity INTEGER NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2) NOT NULL,
    PRIMARY KEY (sale_id, date_id)
) PARTITION BY RANGE (date_id);
```

**2. å¿«ç…§äº‹å®è¡¨**ï¼šè®°å½•ç‰¹å®šæ—¶é—´ç‚¹çš„çŠ¶æ€

```sql
-- å¿«ç…§äº‹å®è¡¨ï¼šæ¯æ—¥åº“å­˜å¿«ç…§
CREATE TABLE inventory_snapshot_fact (
    snapshot_id BIGSERIAL,
    date_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    -- åº¦é‡
    quantity_on_hand INTEGER NOT NULL,
    quantity_on_order INTEGER DEFAULT 0,
    reorder_level INTEGER,
    PRIMARY KEY (snapshot_id, date_id)
) PARTITION BY RANGE (date_id);
```

**3. ç´¯ç§¯å¿«ç…§äº‹å®è¡¨**ï¼šè®°å½•è¿‡ç¨‹çš„å¤šä¸ªé˜¶æ®µ

```sql
-- ç´¯ç§¯å¿«ç…§äº‹å®è¡¨ï¼šè®¢å•å¤„ç†æµç¨‹
CREATE TABLE order_process_fact (
    order_id BIGINT NOT NULL,
    order_date_id INTEGER NOT NULL,
    ship_date_id INTEGER,
    delivery_date_id INTEGER,
    customer_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    -- åº¦é‡
    order_amount NUMERIC(10,2) NOT NULL,
    shipping_cost NUMERIC(10,2),
    days_to_ship INTEGER,
    days_to_deliver INTEGER,
    PRIMARY KEY (order_id, order_date_id)
);
```

### 2.4 ç»´åº¦è¡¨è®¾è®¡

**ç»´åº¦è¡¨è®¾è®¡åŸåˆ™**ï¼š

```sql
-- ç»´åº¦è¡¨è®¾è®¡ç¤ºä¾‹ï¼šäº§å“ç»´åº¦ï¼ˆSCDç±»å‹2ï¼‰
CREATE TABLE product_dim (
    product_id INTEGER PRIMARY KEY,
    product_code VARCHAR(50) NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_id INTEGER NOT NULL,
    brand_id INTEGER NOT NULL,
    price NUMERIC(10,2) NOT NULL,
    -- SCDç±»å‹2å­—æ®µ
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT TRUE,
    -- ä»£ç†é”®
    surrogate_key BIGSERIAL UNIQUE NOT NULL
);

-- æŸ¥è¯¢å½“å‰ç‰ˆæœ¬çš„äº§å“
SELECT * FROM product_dim WHERE is_current = TRUE;

-- æŸ¥è¯¢å†å²ç‰ˆæœ¬çš„äº§å“
SELECT * FROM product_dim WHERE product_code = 'P001' ORDER BY effective_date;
```

**ç¼“æ…¢å˜åŒ–ç»´åº¦ï¼ˆSCDï¼‰ç±»å‹**ï¼š

- **SCDç±»å‹1**ï¼šè¦†ç›–æ—§å€¼
- **SCDç±»å‹2**ï¼šåˆ›å»ºæ–°è®°å½•ï¼ˆæ¨èï¼‰
- **SCDç±»å‹3**ï¼šæ·»åŠ æ–°åˆ—

---

## ä¸‰ã€ETLæµç¨‹è®¾è®¡

### 3.1 æ•°æ®æŠ½å–

**æ•°æ®æŠ½å–**ä»å„ç§æ•°æ®æºæå–æ•°æ®ã€‚

```sql
-- ä½¿ç”¨å¤–éƒ¨æ•°æ®åŒ…è£…å™¨ï¼ˆFDWï¼‰æŠ½å–æ•°æ®
CREATE EXTENSION IF NOT EXISTS postgres_fdw;

-- åˆ›å»ºå¤–éƒ¨æœåŠ¡å™¨
CREATE SERVER source_db
FOREIGN DATA WRAPPER postgres_fdw
OPTIONS (host 'source_host', port '5432', dbname 'source_db');

-- åˆ›å»ºç”¨æˆ·æ˜ å°„
CREATE USER MAPPING FOR CURRENT_USER
SERVER source_db
OPTIONS (user 'source_user', password 'source_password');

-- åˆ›å»ºå¤–éƒ¨è¡¨
CREATE FOREIGN TABLE source_orders (
    order_id BIGINT,
    user_id BIGINT,
    order_date DATE,
    amount NUMERIC(10,2)
) SERVER source_db
OPTIONS (schema_name 'public', table_name 'orders');

-- æŠ½å–æ•°æ®åˆ°ä¸´æ—¶è¡¨
CREATE TEMP TABLE temp_orders AS
SELECT * FROM source_orders
WHERE order_date >= CURRENT_DATE - INTERVAL '1 day';
```

### 3.2 æ•°æ®è½¬æ¢

**æ•°æ®è½¬æ¢**æ¸…æ´—å’Œè½¬æ¢æ•°æ®ã€‚

```sql
-- æ•°æ®æ¸…æ´—å’Œè½¬æ¢å‡½æ•°
-- è½¬æ¢è®¢å•æ•°æ®å‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION transform_orders()
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_transformed_count INTEGER := 0;
BEGIN
    -- æ£€æŸ¥å¿…éœ€è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'temp_orders') THEN
        RAISE EXCEPTION 'temp_ordersè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'staging_orders') THEN
        RAISE EXCEPTION 'staging_ordersè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'date_dim') THEN
        RAISE EXCEPTION 'date_dimè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customer_dim') THEN
        RAISE EXCEPTION 'customer_dimè¡¨ä¸å­˜åœ¨';
    END IF;

    -- æ¸…æ´—å’Œè½¬æ¢è®¢å•æ•°æ®
    BEGIN
        INSERT INTO staging_orders (
            order_id, date_id, customer_id, amount, status
        )
        SELECT
            o.order_id,
            d.date_id,
            c.customer_id,
            COALESCE(o.amount, 0) AS amount,
            CASE
                WHEN o.status = 'completed' THEN 'delivered'
                WHEN o.status = 'pending' THEN 'pending'
                ELSE 'other'
            END AS status
        FROM temp_orders o
        INNER JOIN date_dim d ON d.date = o.order_date
        INNER JOIN customer_dim c ON c.customer_code = o.user_id::text
        WHERE COALESCE(o.amount, 0) > 0  -- è¿‡æ»¤æ— æ•ˆæ•°æ®
          AND o.order_date >= '2024-01-01'  -- åªå¤„ç†æœ‰æ•ˆæ—¥æœŸèŒƒå›´
          AND o.order_date IS NOT NULL
          AND o.user_id IS NOT NULL;

        GET DIAGNOSTICS v_transformed_count = ROW_COUNT;
        RAISE NOTICE 'è½¬æ¢è®¢å•æ•°æ®: % æ¡', v_transformed_count;
    EXCEPTION
        WHEN unique_violation THEN
            RAISE WARNING 'å­˜åœ¨é‡å¤çš„è®¢å•ID';
        WHEN foreign_key_violation THEN
            RAISE EXCEPTION 'è¿åå¤–é”®çº¦æŸï¼Œè¯·æ£€æŸ¥date_dimå’Œcustomer_dimæ•°æ®';
        WHEN numeric_value_out_of_range THEN
            RAISE EXCEPTION 'é‡‘é¢æ•°å€¼æº¢å‡º';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'è½¬æ¢è®¢å•æ•°æ®å¤±è´¥: %', SQLERRM;
    END;

    RETURN v_transformed_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'transform_ordersæ‰§è¡Œå¤±è´¥: %', SQLERRM;
END;
$$;
```

### 3.3 æ•°æ®åŠ è½½

**æ•°æ®åŠ è½½**å°†è½¬æ¢åçš„æ•°æ®åŠ è½½åˆ°æ•°æ®ä»“åº“ã€‚

```sql
-- æ•°æ®åŠ è½½å‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION load_sales_fact()
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_loaded_count INTEGER := 0;
BEGIN
    -- æ£€æŸ¥å¿…éœ€è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_fact') THEN
        RAISE EXCEPTION 'sales_factè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'staging_orders') THEN
        RAISE EXCEPTION 'staging_ordersè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'staging_order_items') THEN
        RAISE EXCEPTION 'staging_order_itemsè¡¨ä¸å­˜åœ¨';
    END IF;

    -- åŠ è½½åˆ°äº‹å®è¡¨
    BEGIN
        INSERT INTO sales_fact (
            date_id, product_id, customer_id, store_id,
            quantity, amount, cost
        )
        SELECT
            so.date_id,
            p.product_id,
            so.customer_id,
            s.store_id,
            COALESCE(oi.quantity, 0) AS quantity,
            COALESCE(oi.amount, 0) AS amount,
            COALESCE(oi.cost, 0) AS cost
        FROM staging_orders so
        INNER JOIN staging_order_items oi ON oi.order_id = so.order_id
        INNER JOIN product_dim p ON p.product_code = oi.product_code
            AND p.is_current = TRUE
        INNER JOIN store_dim s ON s.store_code = so.store_code
            AND s.is_current = TRUE
        WHERE NOT EXISTS (
            SELECT 1 FROM sales_fact sf
            WHERE sf.sale_id = so.order_id
              AND sf.date_id = so.date_id
        )  -- é¿å…é‡å¤åŠ è½½
          AND so.date_id IS NOT NULL
          AND p.product_id IS NOT NULL
          AND so.customer_id IS NOT NULL
          AND s.store_id IS NOT NULL;

        GET DIAGNOSTICS v_loaded_count = ROW_COUNT;
        RAISE NOTICE 'åŠ è½½é”€å”®äº‹å®æ•°æ®: % æ¡', v_loaded_count;
    EXCEPTION
        WHEN unique_violation THEN
            RAISE WARNING 'å­˜åœ¨é‡å¤çš„é”€å”®äº‹å®è®°å½•';
        WHEN foreign_key_violation THEN
            RAISE EXCEPTION 'è¿åå¤–é”®çº¦æŸï¼Œè¯·æ£€æŸ¥ç»´åº¦è¡¨æ•°æ®';
        WHEN numeric_value_out_of_range THEN
            RAISE EXCEPTION 'é‡‘é¢æˆ–æ•°é‡æ•°å€¼æº¢å‡º';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åŠ è½½é”€å”®äº‹å®æ•°æ®å¤±è´¥: %', SQLERRM;
    END;

    RETURN v_loaded_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'load_sales_factæ‰§è¡Œå¤±è´¥: %', SQLERRM;
END;
$$;
```

### 3.4 å¢é‡æ›´æ–°

**å¢é‡æ›´æ–°**åªå¤„ç†å˜æ›´çš„æ•°æ®ã€‚

```sql
-- å¢é‡æ›´æ–°å‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION incremental_update_sales()
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_last_update_date DATE;
    v_updated_count INTEGER := 0;
BEGIN
    -- æ£€æŸ¥å¿…éœ€è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_fact') THEN
        RAISE EXCEPTION 'sales_factè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'date_dim') THEN
        RAISE EXCEPTION 'date_dimè¡¨ä¸å­˜åœ¨';
    END IF;

    -- è·å–ä¸Šæ¬¡æ›´æ–°æ—¶é—´
    BEGIN
        SELECT MAX(d.date) INTO v_last_update_date
        FROM date_dim d
        INNER JOIN sales_fact sf ON sf.date_id = d.date_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è·å–ä¸Šæ¬¡æ›´æ–°æ—¶é—´å¤±è´¥: %', SQLERRM;
            v_last_update_date := NULL;
    END;

    -- å¦‚æœæ²¡æœ‰å†å²æ•°æ®ï¼Œä»æŒ‡å®šæ—¥æœŸå¼€å§‹
    IF v_last_update_date IS NULL THEN
        v_last_update_date := '2024-01-01';
        RAISE NOTICE 'æ²¡æœ‰å†å²æ•°æ®ï¼Œä» % å¼€å§‹å¢é‡æ›´æ–°', v_last_update_date;
    ELSE
        RAISE NOTICE 'ä¸Šæ¬¡æ›´æ–°æ—¥æœŸ: %', v_last_update_date;
    END IF;

    -- å¢é‡åŠ è½½æ–°æ•°æ®
    BEGIN
        INSERT INTO sales_fact (
            date_id, product_id, customer_id, store_id,
            quantity, amount, cost
        )
        SELECT
            so.date_id,
            p.product_id,
            so.customer_id,
            s.store_id,
            COALESCE(oi.quantity, 0) AS quantity,
            COALESCE(oi.amount, 0) AS amount,
            COALESCE(oi.cost, 0) AS cost
        FROM staging_orders so
        INNER JOIN staging_order_items oi ON oi.order_id = so.order_id
        INNER JOIN product_dim p ON p.product_code = oi.product_code
            AND p.is_current = TRUE
        INNER JOIN store_dim s ON s.store_code = so.store_code
            AND s.is_current = TRUE
        INNER JOIN date_dim d ON d.date_id = so.date_id
        WHERE d.date > v_last_update_date
          AND so.date_id IS NOT NULL
          AND p.product_id IS NOT NULL
          AND so.customer_id IS NOT NULL
          AND s.store_id IS NOT NULL
          AND NOT EXISTS (
              SELECT 1 FROM sales_fact sf
              WHERE sf.sale_id = so.order_id
                AND sf.date_id = so.date_id
          );

        GET DIAGNOSTICS v_updated_count = ROW_COUNT;
        RAISE NOTICE 'å¢é‡æ›´æ–°é”€å”®æ•°æ®: % æ¡', v_updated_count;
    EXCEPTION
        WHEN unique_violation THEN
            RAISE WARNING 'å­˜åœ¨é‡å¤çš„é”€å”®äº‹å®è®°å½•';
        WHEN foreign_key_violation THEN
            RAISE EXCEPTION 'è¿åå¤–é”®çº¦æŸï¼Œè¯·æ£€æŸ¥ç»´åº¦è¡¨æ•°æ®';
        WHEN numeric_value_out_of_range THEN
            RAISE EXCEPTION 'é‡‘é¢æˆ–æ•°é‡æ•°å€¼æº¢å‡º';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'å¢é‡åŠ è½½æ–°æ•°æ®å¤±è´¥: %', SQLERRM;
    END;

    RETURN v_updated_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'incremental_update_salesæ‰§è¡Œå¤±è´¥: %', SQLERRM;
END;
$$;
```

---

## å››ã€æ€§èƒ½ä¼˜åŒ–

### 4.1 åˆ†åŒºç­–ç•¥

**åˆ†åŒºç­–ç•¥**ç”¨äºç®¡ç†å¤§æ•°æ®è¡¨ã€‚

```sql
-- æŒ‰æ—¥æœŸåˆ†åŒºäº‹å®è¡¨
CREATE TABLE sales_fact (
    sale_id BIGSERIAL,
    date_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2) NOT NULL,
    PRIMARY KEY (sale_id, date_id)
) PARTITION BY RANGE (date_id);

-- åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE sales_fact_2024_01 PARTITION OF sales_fact
    FOR VALUES FROM (20240101) TO (20240201);

CREATE TABLE sales_fact_2024_02 PARTITION OF sales_fact
    FOR VALUES FROM (20240201) TO (20240301);

-- è‡ªåŠ¨åˆ›å»ºåˆ†åŒºå‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION create_monthly_partition(p_table_name TEXT, p_start_date DATE)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    v_partition_name TEXT;
    v_start_date DATE;
    v_end_date DATE;
    v_start_int INTEGER;
    v_end_int INTEGER;
BEGIN
    -- å‚æ•°éªŒè¯
    IF p_table_name IS NULL OR TRIM(p_table_name) = '' THEN
        RAISE EXCEPTION 'è¡¨åä¸èƒ½ä¸ºç©º';
    END IF;

    IF p_start_date IS NULL THEN
        RAISE EXCEPTION 'å¼€å§‹æ—¥æœŸä¸èƒ½ä¸ºç©º';
    END IF;

    -- è¡¨åæ ¼å¼éªŒè¯ï¼ˆé˜²æ­¢SQLæ³¨å…¥ï¼‰
    IF p_table_name !~ '^[a-zA-Z_][a-zA-Z0-9_]*$' THEN
        RAISE EXCEPTION 'è¡¨åæ ¼å¼æ— æ•ˆ: %', p_table_name;
    END IF;

    -- æ£€æŸ¥ä¸»è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = p_table_name) THEN
        RAISE EXCEPTION 'ä¸»è¡¨ä¸å­˜åœ¨: %', p_table_name;
    END IF;

    -- è®¡ç®—åˆ†åŒºæ—¥æœŸèŒƒå›´
    v_start_date := date_trunc('month', p_start_date);
    v_end_date := v_start_date + INTERVAL '1 month';
    v_start_int := to_char(v_start_date, 'YYYYMMDD')::INTEGER;
    v_end_int := to_char(v_end_date, 'YYYYMMDD')::INTEGER;
    v_partition_name := p_table_name || '_' || to_char(v_start_date, 'YYYY_MM');

    -- æ£€æŸ¥åˆ†åŒºæ˜¯å¦å·²å­˜åœ¨
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = v_partition_name) THEN
        RAISE NOTICE 'åˆ†åŒºå·²å­˜åœ¨: %', v_partition_name;
        RETURN;
    END IF;

    -- åˆ›å»ºåˆ†åŒº
    BEGIN
        EXECUTE format('CREATE TABLE %I PARTITION OF %I
                        FOR VALUES FROM (%L) TO (%L)',
                       v_partition_name, p_table_name,
                       v_start_int, v_end_int);
        RAISE NOTICE 'æˆåŠŸåˆ›å»ºåˆ†åŒº: % (æ—¥æœŸèŒƒå›´: % è‡³ %)', v_partition_name, v_start_date, v_end_date;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE 'åˆ†åŒºå·²å­˜åœ¨: %', v_partition_name;
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºåˆ†åŒºå¤±è´¥: % (é”™è¯¯: %)', v_partition_name, SQLERRM;
    END;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'create_monthly_partitionæ‰§è¡Œå¤±è´¥: %', SQLERRM;
END;
$$;
```

### 4.2 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**æå‡æŸ¥è¯¢æ€§èƒ½ã€‚

```sql
-- äº‹å®è¡¨ç´¢å¼•
CREATE INDEX idx_sales_fact_date ON sales_fact(date_id);
CREATE INDEX idx_sales_fact_product ON sales_fact(product_id);
CREATE INDEX idx_sales_fact_customer ON sales_fact(customer_id);
CREATE INDEX idx_sales_fact_store ON sales_fact(store_id);
CREATE INDEX idx_sales_fact_date_product ON sales_fact(date_id, product_id);

-- ç»´åº¦è¡¨ç´¢å¼•
CREATE INDEX idx_product_dim_code ON product_dim(product_code) WHERE is_current = TRUE;
CREATE INDEX idx_customer_dim_code ON customer_dim(customer_code) WHERE is_current = TRUE;
CREATE INDEX idx_store_dim_code ON store_dim(store_code) WHERE is_current = TRUE;
```

### 4.3 ç‰©åŒ–è§†å›¾

**ç‰©åŒ–è§†å›¾**é¢„è®¡ç®—å¸¸ç”¨æŸ¥è¯¢ã€‚

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW mv_sales_summary AS
SELECT
    d.year,
    d.quarter,
    d.month,
    p.category_name,
    c.region,
    s.store_type,
    COUNT(*) AS order_count,
    SUM(sf.quantity) AS total_quantity,
    SUM(sf.amount) AS total_amount,
    SUM(sf.cost) AS total_cost,
    SUM(sf.profit) AS total_profit,
    AVG(sf.amount) AS avg_amount
FROM sales_fact sf
JOIN date_dim d ON d.date_id = sf.date_id
JOIN product_dim p ON p.product_id = sf.product_id AND p.is_current = TRUE
JOIN customer_dim c ON c.customer_id = sf.customer_id AND c.is_current = TRUE
JOIN store_dim s ON s.store_id = sf.store_id AND s.is_current = TRUE
GROUP BY d.year, d.quarter, d.month, p.category_name, c.region, s.store_type;

-- åˆ›å»ºå”¯ä¸€ç´¢å¼•æ”¯æŒCONCURRENTLYåˆ·æ–°
CREATE UNIQUE INDEX ON mv_sales_summary(year, quarter, month, category_name, region, store_type);

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary;
```

### 4.4 å¹¶è¡ŒæŸ¥è¯¢

**å¹¶è¡ŒæŸ¥è¯¢**æå‡å¤§æ•°æ®æŸ¥è¯¢æ€§èƒ½ã€‚

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;

-- å¹¶è¡ŒèšåˆæŸ¥è¯¢
EXPLAIN ANALYZE
SELECT
    p.category_name,
    SUM(sf.amount) AS total_amount,
    COUNT(*) AS order_count
FROM sales_fact sf
JOIN product_dim p ON p.product_id = sf.product_id AND p.is_current = TRUE
WHERE sf.date_id >= 20240101
GROUP BY p.category_name;
```

### 4.5 åˆ—å­˜å‚¨ä¼˜åŒ– ğŸ†•

**åˆ—å­˜å‚¨æ¦‚è¿°**ï¼š

æ•°æ®ä»“åº“åœºæ™¯ä¸­ï¼Œå¤§é‡æŸ¥è¯¢æ˜¯**åˆ†æå‹æŸ¥è¯¢ï¼ˆOLAPï¼‰**ï¼Œç‰¹ç‚¹ï¼š

- åªæŸ¥è¯¢éƒ¨åˆ†åˆ—ï¼ˆå¦‚ï¼šåªæŸ¥è¯¢é”€å”®é‡‘é¢ã€æ•°é‡ï¼‰
- å¤§é‡èšåˆæ“ä½œï¼ˆSUMã€AVGã€COUNTï¼‰
- æ‰«æå¤§é‡æ•°æ®è¡Œ
- å¾ˆå°‘æ›´æ–°æ“ä½œ

åˆ—å­˜å‚¨åœ¨è¿™äº›åœºæ™¯ä¸‹å…·æœ‰æ˜¾è‘—ä¼˜åŠ¿ï¼š

- **I/Oå‡å°‘**ï¼šåªè¯»å–éœ€è¦çš„åˆ—ï¼ŒI/Oå‡å°‘50-90%
- **å‹ç¼©ç‡é«˜**ï¼šåŒåˆ—æ•°æ®ç±»å‹ç›¸åŒï¼Œå‹ç¼©ç‡æå‡3-10å€
- **èšåˆæ€§èƒ½**ï¼šåˆ—æ•°æ®å¯æ‰¹é‡å¤„ç†ï¼Œèšåˆæ€§èƒ½æå‡10-100å€

#### ğŸ“Š æ•°æ®ä»“åº“åˆ—å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘

```mermaid
flowchart TD
    A[é€‰æ‹©åˆ—å­˜å‚¨æ–¹æ¡ˆ] --> B{æ•°æ®è§„æ¨¡}

    B -->|< 1TB| C{éƒ¨ç½²å¤æ‚åº¦}
    B -->|1TB - 10TB| D{æ‰©å±•éœ€æ±‚}
    B -->|> 10TB| E[è€ƒè™‘Greenplumæˆ–Citus]

    C -->|ç®€å•éƒ¨ç½²| F[cstore_fdw âœ…<br/>å•æœºåˆ—å­˜å‚¨]
    C -->|éœ€è¦åˆ†å¸ƒå¼| G[Citusåˆ—å­˜å‚¨ âœ…]

    D -->|éœ€è¦æ°´å¹³æ‰©å±•| G
    D -->|å•æœºå¯å¤„ç†| F

    E -->|ä¼ä¸šçº§éœ€æ±‚| H[Greenplum âœ…<br/>å®Œæ•´åˆ—å­˜å‚¨]
    E -->|PostgreSQLç”Ÿæ€| G

    F --> F1[ä¼˜åŠ¿: ç®€å•æ˜“ç”¨<br/>åŠ£åŠ¿: åªè¯»]
    G --> G1[ä¼˜åŠ¿: åˆ†å¸ƒå¼<br/>åŠ£åŠ¿: éœ€è¦é›†ç¾¤]
    H --> H1[ä¼˜åŠ¿: é«˜æ€§èƒ½<br/>åŠ£åŠ¿: ç‹¬ç«‹ç³»ç»Ÿ]

    style F fill:#90EE90
    style G fill:#87CEEB
    style H fill:#FFD700
```

**åˆ—å­˜å‚¨æ–¹æ¡ˆé€‰æ‹©**ï¼š

PostgreSQLæ”¯æŒå¤šç§åˆ—å­˜å‚¨æ–¹æ¡ˆï¼š

#### ğŸ“Š åˆ—å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”çŸ©é˜µ

| ç»´åº¦ | cstore_fdw | Citusåˆ—å­˜å‚¨ | Greenplum | æœ€ä½³é€‰æ‹© |
| --- | --- | --- | --- | --- |
| **ç±»å‹** | å•æœºæ‰©å±• | åˆ†å¸ƒå¼æ‰©å±• | ç‹¬ç«‹ç³»ç»Ÿ | - |
| **æ€§èƒ½** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | Greenplum |
| **å‹ç¼©ç‡** | â­â­â­â­ (70-80%) | â­â­â­â­ (70-80%) | â­â­â­â­â­ (80-90%) | Greenplum |
| **æ˜“ç”¨æ€§** | â­â­â­â­â­ | â­â­â­ | â­â­â­ | cstore_fdw |
| **æ‰©å±•æ€§** | â­â­ (å•æœº) | â­â­â­â­â­ (æ°´å¹³æ‰©å±•) | â­â­â­â­ (é›†ç¾¤) | Citus |
| **PostgreSQLå…¼å®¹** | âœ… å®Œå…¨å…¼å®¹ | âœ… å…¼å®¹ | âš ï¸ åŸºäºPostgreSQL | cstore_fdw |
| **éƒ¨ç½²å¤æ‚åº¦** | â­â­â­â­â­ (ä½) | â­â­â­ (ä¸­) | â­â­ (é«˜) | cstore_fdw |
| **æˆæœ¬** | â­â­â­â­â­ (å…è´¹) | â­â­â­â­ (å¼€æº) | â­â­â­ (å•†ä¸š/å¼€æº) | cstore_fdw |
| **é€‚ç”¨åœºæ™¯** | å•æœºæ•°æ®ä»“åº“ã€å†å²æ•°æ® | å¤§è§„æ¨¡åˆ†å¸ƒå¼æ•°æ®ä»“åº“ | ä¼ä¸šçº§æ•°æ®ä»“åº“ | - |
| **æ•°æ®è§„æ¨¡** | < 1TB | 1TB - 100TB | > 10TB | - |
| **æ›´æ–°æ”¯æŒ** | âŒ åªè¯» | âš ï¸ æœ‰é™æ”¯æŒ | âœ… æ”¯æŒ | Greenplum |

**cstore_fdwåˆ—å­˜å‚¨å®ç°**ï¼š

```sql
-- 1. å®‰è£…cstore_fdwæ‰©å±•
CREATE EXTENSION IF NOT EXISTS cstore_fdw;

-- 2. åˆ›å»ºåˆ—å­˜å‚¨æœåŠ¡å™¨
CREATE SERVER cstore_server
FOREIGN DATA WRAPPER cstore_fdw;

-- 3. åˆ›å»ºåˆ—å­˜å‚¨è¡¨ï¼ˆå†å²æ•°æ®æŸ¥è¯¢ï¼‰
CREATE FOREIGN TABLE fact_sales_columnar (
    sale_id BIGINT,
    date_id INTEGER,
    product_id INTEGER,
    customer_id INTEGER,
    store_id INTEGER,
    quantity INTEGER,
    amount DECIMAL(10,2),
    cost DECIMAL(10,2),
    profit DECIMAL(10,2)
) SERVER cstore_server
OPTIONS (
    compression 'pglz',  -- å‹ç¼©ç®—æ³•
    stripe_row_count '150000'  -- æ¡å¸¦è¡Œæ•°
);

-- 4. ä»è¡Œå­˜å‚¨è¡¨å¯¼å…¥æ•°æ®åˆ°åˆ—å­˜å‚¨è¡¨
INSERT INTO fact_sales_columnar
SELECT sale_id, date_id, product_id, customer_id, store_id,
       quantity, amount, cost, profit
FROM sales_fact
WHERE date_id < 20240101;  -- å†å²æ•°æ®

-- 5. åˆ—å­˜å‚¨æŸ¥è¯¢ç¤ºä¾‹
-- æŸ¥è¯¢ï¼šæŒ‰äº§å“ç»Ÿè®¡é”€å”®é‡‘é¢å’Œæ•°é‡
SELECT
    product_id,
    SUM(amount) as total_amount,
    SUM(quantity) as total_quantity,
    AVG(amount) as avg_amount
FROM fact_sales_columnar
WHERE date_id BETWEEN 20230101 AND 20231231
GROUP BY product_id
ORDER BY total_amount DESC
LIMIT 100;

-- æ€§èƒ½å¯¹æ¯”ï¼š
-- è¡Œå­˜å‚¨ï¼šæ‰«ææ‰€æœ‰åˆ—ï¼ŒI/Oå¤§ï¼ŒæŸ¥è¯¢æ—¶é—´ï¼š10-30ç§’
-- åˆ—å­˜å‚¨ï¼šåªæ‰«æproduct_id, amount, quantity, date_idï¼ŒI/Oå°ï¼ŒæŸ¥è¯¢æ—¶é—´ï¼š1-3ç§’
-- æ€§èƒ½æå‡ï¼š5-10å€
```

**åˆ—å­˜å‚¨å‹ç¼©ä¼˜åŒ–**ï¼š

```sql
-- ä½¿ç”¨zstdå‹ç¼©ï¼ˆæ›´é«˜å‹ç¼©ç‡ï¼‰
CREATE FOREIGN TABLE analytics_columnar_zstd (
    id BIGINT,
    metric_name TEXT,
    metric_value DOUBLE PRECISION,
    timestamp TIMESTAMP
) SERVER cstore_server
OPTIONS (
    compression 'zstd',  -- zstdå‹ç¼©ï¼Œå‹ç¼©ç‡80%
    stripe_row_count '150000'
);

-- å‹ç¼©ç®—æ³•å¯¹æ¯”ï¼š
-- åŸå§‹æ•°æ®ï¼š100GB
-- pglzå‹ç¼©ï¼š30GBï¼ˆå‹ç¼©ç‡70%ï¼‰
-- zstdå‹ç¼©ï¼š20GBï¼ˆå‹ç¼©ç‡80%ï¼‰
-- å­˜å‚¨èŠ‚çœï¼š80GB
```

#### ğŸ“Š æ•°æ®ä»“åº“åˆ—å­˜å‚¨æ¶æ„å›¾

```mermaid
graph TB
    subgraph "æ•°æ®ä»“åº“åˆ—å­˜å‚¨æ¶æ„"
        A[æ•°æ®æº] --> B[ETLæµç¨‹]
        B --> C{æ•°æ®åˆ†ç±»}

        C -->|çƒ­æ•°æ®| D[è¡Œå­˜å‚¨è¡¨<br/>sales_fact]
        C -->|æ¸©æ•°æ®| E[è¡Œå­˜å‚¨åˆ†åŒºè¡¨<br/>sales_fact_2023]
        C -->|å†·æ•°æ®| F[åˆ—å­˜å‚¨è¡¨<br/>fact_sales_columnar]

        D --> D1[æ”¯æŒæ›´æ–°<br/>ç‚¹æŸ¥è¯¢å¿«]
        E --> E1[åªè¯»åˆ†åŒº<br/>åˆ†åŒºæŸ¥è¯¢]
        F --> F1[cstore_fdw<br/>å‹ç¼©å­˜å‚¨]

        F1 --> G1[å‹ç¼©å—1]
        F1 --> G2[å‹ç¼©å—2]
        F1 --> G3[å‹ç¼©å—N]

        G1 --> H[å­—å…¸ç¼–ç ]
        G2 --> I[å¢é‡ç¼–ç ]
        G3 --> J[é€šç”¨å‹ç¼©]
    end

    style D fill:#90EE90
    style E fill:#FFD700
    style F fill:#87CEEB
```

#### ğŸ“Š æ•°æ®ä»“åº“ETLåˆ°åˆ—å­˜å‚¨æ•°æ®æµå›¾

```mermaid
flowchart LR
    subgraph "ETLæµç¨‹"
        A[æºæ•°æ®] --> B[æ•°æ®æŠ½å–]
        B --> C[æ•°æ®è½¬æ¢]
        C --> D[æ•°æ®æ¸…æ´—]
        D --> E{æ•°æ®åˆ†ç±»}
    end

    subgraph "æ•°æ®åŠ è½½"
        E -->|çƒ­æ•°æ®| F[åŠ è½½åˆ°è¡Œå­˜å‚¨è¡¨]
        E -->|æ¸©æ•°æ®| G[åŠ è½½åˆ°åˆ†åŒºè¡¨]
        E -->|å†·æ•°æ®| H[åŠ è½½åˆ°åˆ—å­˜å‚¨è¡¨]
    end

    subgraph "åˆ—å­˜å‚¨å¤„ç†"
        H --> I[åˆ—å¼ç»„ç»‡]
        I --> J[å‹ç¼©å¤„ç†]
        J --> K[å­˜å‚¨åˆ°åˆ—æ–‡ä»¶]
    end

    subgraph "æŸ¥è¯¢è·¯ç”±"
        L[æŸ¥è¯¢è¯·æ±‚] --> M{æŸ¥è¯¢æ—¶é—´èŒƒå›´}
        M -->|æœ€è¿‘3ä¸ªæœˆ| N[æŸ¥è¯¢è¡Œå­˜å‚¨è¡¨]
        M -->|3-12ä¸ªæœˆ| O[æŸ¥è¯¢åˆ†åŒºè¡¨]
        M -->|å†å²æ•°æ®| P[æŸ¥è¯¢åˆ—å­˜å‚¨è¡¨]
    end

    style F fill:#90EE90
    style G fill:#FFD700
    style H fill:#87CEEB
    style P fill:#87CEEB
```

**æ··åˆå­˜å‚¨æ¶æ„**ï¼š

```text
æ··åˆå­˜å‚¨æ¶æ„ï¼š
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  çƒ­æ•°æ®ï¼ˆæœ€è¿‘3ä¸ªæœˆï¼‰              â”‚
  â”‚  è¡Œå­˜å‚¨è¡¨ï¼šsales_fact            â”‚
  â”‚  ç‰¹ç‚¹ï¼šæ”¯æŒæ›´æ–°ã€ç‚¹æŸ¥è¯¢å¿«         â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ å®šæœŸå½’æ¡£
           â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  æ¸©æ•°æ®ï¼ˆ3-12ä¸ªæœˆï¼‰              â”‚
  â”‚  è¡Œå­˜å‚¨åˆ†åŒºè¡¨ï¼šsales_fact_2023   â”‚
  â”‚  ç‰¹ç‚¹ï¼šåªè¯»ã€åˆ†åŒºæŸ¥è¯¢             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ å®šæœŸå½’æ¡£
           â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  å†·æ•°æ®ï¼ˆ12ä¸ªæœˆä»¥ä¸Šï¼‰             â”‚
  â”‚  åˆ—å­˜å‚¨è¡¨ï¼šfact_sales_columnar   â”‚
  â”‚  ç‰¹ç‚¹ï¼šåªè¯»ã€åˆ†ææŸ¥è¯¢ã€å‹ç¼©ç‡é«˜   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ“Š æ•°æ®ä»“åº“æ˜Ÿå‹æ¨¡å‹åˆ—å­˜å‚¨ERå›¾

```mermaid
erDiagram
    FACT_SALES_COLUMNAR ||--|| DATE_DIM : "å…³è”"
    FACT_SALES_COLUMNAR ||--|| PRODUCT_DIM : "å…³è”"
    FACT_SALES_COLUMNAR ||--|| CUSTOMER_DIM : "å…³è”"
    FACT_SALES_COLUMNAR ||--|| STORE_DIM : "å…³è”"

    FACT_SALES_COLUMNAR {
        bigint sale_id PK
        integer date_id FK
        integer product_id FK
        integer customer_id FK
        integer store_id FK
        integer quantity
        decimal amount
        decimal cost
        decimal profit
    }

    DATE_DIM {
        integer date_id PK
        date date_value
        integer year
        integer quarter
        integer month
        integer week
        varchar day_name
    }

    PRODUCT_DIM {
        integer product_id PK
        varchar product_code
        varchar product_name
        integer category_id
        decimal price
    }

    CUSTOMER_DIM {
        integer customer_id PK
        varchar customer_code
        varchar customer_name
        varchar city
        varchar region
    }

    STORE_DIM {
        integer store_id PK
        varchar store_code
        varchar store_name
        varchar city
        varchar region
    }
```

#### ğŸ“Š åˆ—å­˜å‚¨ETLæµç¨‹æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant ETL
    participant SourceDB
    participant Staging
    participant RowStore
    participant ColumnStore
    participant Compression

    ETL->>SourceDB: æŠ½å–æ•°æ®
    SourceDB-->>ETL: è¿”å›æºæ•°æ®

    ETL->>Staging: æ•°æ®è½¬æ¢å’Œæ¸…æ´—
    Staging-->>ETL: è¿”å›æ¸…æ´—åæ•°æ®

    ETL->>ETL: æ•°æ®åˆ†ç±»ï¼ˆçƒ­/æ¸©/å†·ï¼‰

    alt çƒ­æ•°æ®
        ETL->>RowStore: åŠ è½½åˆ°è¡Œå­˜å‚¨è¡¨
    else æ¸©æ•°æ®
        ETL->>RowStore: åŠ è½½åˆ°åˆ†åŒºè¡¨
    else å†·æ•°æ®
        ETL->>ColumnStore: åŠ è½½åˆ°åˆ—å­˜å‚¨è¡¨
        ColumnStore->>Compression: åˆ—å¼ç»„ç»‡
        Compression->>Compression: å‹ç¼©å¤„ç†
        Compression-->>ColumnStore: å­˜å‚¨å‹ç¼©æ•°æ®
    end

    Note over ETL,ColumnStore: å®šæœŸå½’æ¡£ï¼šå°†å†å²æ•°æ®è¿ç§»åˆ°åˆ—å­˜å‚¨
```

**åˆ—å­˜å‚¨ETLæµç¨‹**ï¼š

```sql
-- 1. å®šæœŸå°†å†å²æ•°æ®è¿ç§»åˆ°åˆ—å­˜å‚¨
-- å½’æ¡£åˆ°åˆ—å­˜å‚¨å‡½æ•°ï¼ˆå¸¦å®Œæ•´é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION archive_to_columnar()
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    v_archive_date DATE;
    v_archive_date_id INTEGER;
    v_archived_count INTEGER := 0;
BEGIN
    -- æ£€æŸ¥å¿…éœ€è¡¨æ˜¯å¦å­˜åœ¨
    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_fact') THEN
        RAISE EXCEPTION 'sales_factè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'fact_sales_columnar') THEN
        RAISE EXCEPTION 'fact_sales_columnarè¡¨ä¸å­˜åœ¨';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'date_dim') THEN
        RAISE EXCEPTION 'date_dimè¡¨ä¸å­˜åœ¨';
    END IF;

    -- è®¡ç®—å½’æ¡£æ—¥æœŸï¼ˆ12ä¸ªæœˆå‰ï¼‰
    v_archive_date := CURRENT_DATE - INTERVAL '12 months';

    -- è·å–å½’æ¡£æ—¥æœŸID
    BEGIN
        SELECT date_id INTO v_archive_date_id
        FROM date_dim
        WHERE date = v_archive_date;

        IF v_archive_date_id IS NULL THEN
            RAISE EXCEPTION 'æ— æ³•æ‰¾åˆ°å½’æ¡£æ—¥æœŸå¯¹åº”çš„date_id: %', v_archive_date;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'è·å–å½’æ¡£æ—¥æœŸIDå¤±è´¥: %', SQLERRM;
    END;

    -- å°†12ä¸ªæœˆå‰çš„æ•°æ®è¿ç§»åˆ°åˆ—å­˜å‚¨
    BEGIN
        INSERT INTO fact_sales_columnar
        SELECT sale_id, date_id, product_id, customer_id, store_id,
               COALESCE(quantity, 0), COALESCE(amount, 0), COALESCE(cost, 0), COALESCE(profit, 0)
        FROM sales_fact
        WHERE date_id < v_archive_date_id
          AND sale_id NOT IN (SELECT sale_id FROM fact_sales_columnar)
          AND sale_id IS NOT NULL
          AND date_id IS NOT NULL
          AND product_id IS NOT NULL
          AND customer_id IS NOT NULL
          AND store_id IS NOT NULL;

        GET DIAGNOSTICS v_archived_count = ROW_COUNT;
        RAISE NOTICE 'å½’æ¡£åˆ°åˆ—å­˜å‚¨: % æ¡è®°å½•', v_archived_count;
    EXCEPTION
        WHEN unique_violation THEN
            RAISE WARNING 'å­˜åœ¨é‡å¤çš„å½’æ¡£è®°å½•';
        WHEN foreign_key_violation THEN
            RAISE EXCEPTION 'è¿åå¤–é”®çº¦æŸ';
        WHEN numeric_value_out_of_range THEN
            RAISE EXCEPTION 'é‡‘é¢æˆ–æ•°é‡æ•°å€¼æº¢å‡º';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'å½’æ¡£åˆ°åˆ—å­˜å‚¨å¤±è´¥: %', SQLERRM;
    END;

    -- åˆ é™¤å·²è¿ç§»çš„æ•°æ®ï¼ˆå¯é€‰ï¼Œæ ¹æ®éœ€æ±‚å†³å®šæ˜¯å¦å¯ç”¨ï¼‰
    -- BEGIN
    --     DELETE FROM sales_fact
    --     WHERE date_id < v_archive_date_id
    --       AND sale_id IN (SELECT sale_id FROM fact_sales_columnar);
    --     RAISE NOTICE 'åˆ é™¤å·²å½’æ¡£æ•°æ®å®Œæˆ';
    -- EXCEPTION
    --     WHEN OTHERS THEN
    --         RAISE WARNING 'åˆ é™¤å·²å½’æ¡£æ•°æ®å¤±è´¥: %', SQLERRM;
    -- END;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'archive_to_columnaræ‰§è¡Œå¤±è´¥: %', SQLERRM;
END;
$$;

-- 2. å®šæ—¶ä»»åŠ¡ï¼ˆä½¿ç”¨pg_cronæ‰©å±•ï¼‰
SELECT cron.schedule(
    'archive-to-columnar',  -- ä»»åŠ¡å
    '0 2 * * *',  -- æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ
    $$SELECT archive_to_columnar()$$
);
```

**åˆ—å­˜å‚¨æŸ¥è¯¢ä¼˜åŒ–**ï¼š

```sql
-- 1. åˆ—å­˜å‚¨é€‚åˆçš„æŸ¥è¯¢æ¨¡å¼
-- âœ… åªæŸ¥è¯¢éƒ¨åˆ†åˆ—
SELECT product_id, SUM(amount)
FROM fact_sales_columnar
WHERE date_id BETWEEN 20230101 AND 20231231
GROUP BY product_id;

-- âœ… å¤§é‡èšåˆæ“ä½œ
SELECT
    date_id,
    product_id,
    COUNT(*) as sale_count,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount,
    MAX(amount) as max_amount,
    MIN(amount) as min_amount
FROM fact_sales_columnar
GROUP BY date_id, product_id;

-- âŒ ä¸é€‚åˆçš„æŸ¥è¯¢æ¨¡å¼
-- æŸ¥è¯¢æ‰€æœ‰åˆ—ï¼ˆåˆ—å­˜å‚¨ä¼˜åŠ¿ä¸æ˜æ˜¾ï¼‰
SELECT * FROM fact_sales_columnar WHERE sale_id = 12345;

-- é¢‘ç¹æ›´æ–°ï¼ˆåˆ—å­˜å‚¨ä¸æ”¯æŒæ›´æ–°ï¼‰
UPDATE fact_sales_columnar SET amount = 100 WHERE sale_id = 12345;
```

**åˆ—å­˜å‚¨æ€§èƒ½æ•ˆæœ**ï¼š

| æŒ‡æ ‡ | è¡Œå­˜å‚¨ | åˆ—å­˜å‚¨ | æå‡ |
| --- | --- | --- | --- |
| **å­˜å‚¨ç©ºé—´** | 100GB | 20-30GB | 70-80% |
| **åˆ—æ‰«æI/O** | 100% | 10-20% | 80-90% |
| **èšåˆæŸ¥è¯¢** | 10ç§’ | 1-2ç§’ | 5-10å€ |
| **å‹ç¼©ç‡** | 10-20% | 70-80% | 3-10å€ |
| **åˆ†ææŸ¥è¯¢** | åŸºå‡† | 5-10å€ | 5-10å€ |

---

## äº”ã€æ•°æ®è´¨é‡

### 5.1 æ•°æ®æ¸…æ´—

**æ•°æ®æ¸…æ´—**å¤„ç†è„æ•°æ®ã€‚

```sql
-- æ•°æ®æ¸…æ´—å‡½æ•°
CREATE OR REPLACE FUNCTION clean_staging_data()
RETURNS TABLE (
    cleaned_count INTEGER,
    error_count INTEGER
) AS $$
DECLARE
    v_cleaned_count INTEGER := 0;
    v_error_count INTEGER := 0;
BEGIN
    -- åˆ é™¤é‡å¤æ•°æ®
    DELETE FROM staging_orders o1
    WHERE EXISTS (
        SELECT 1 FROM staging_orders o2
        WHERE o2.order_id = o1.order_id
          AND o2.ctid < o1.ctid
    );
    GET DIAGNOSTICS v_cleaned_count = ROW_COUNT;

    -- åˆ é™¤æ— æ•ˆæ•°æ®
    DELETE FROM staging_orders
    WHERE amount < 0
       OR order_date < '2020-01-01'
       OR order_date > CURRENT_DATE;
    GET DIAGNOSTICS v_error_count = ROW_COUNT;

    RETURN QUERY SELECT v_cleaned_count, v_error_count;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 æ•°æ®éªŒè¯

**æ•°æ®éªŒè¯**éªŒè¯æ•°æ®è´¨é‡ã€‚

```sql
-- æ•°æ®éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_staging_data()
RETURNS TABLE (
    validation_rule TEXT,
    passed BOOLEAN,
    error_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    -- éªŒè¯1ï¼šè®¢å•é‡‘é¢å¿…é¡»å¤§äº0
    SELECT
        'è®¢å•é‡‘é¢å¿…é¡»å¤§äº0'::TEXT,
        COUNT(*) FILTER (WHERE amount <= 0) = 0,
        COUNT(*) FILTER (WHERE amount <= 0)
    FROM staging_orders
    UNION ALL
    -- éªŒè¯2ï¼šè®¢å•æ—¥æœŸå¿…é¡»åœ¨æœ‰æ•ˆèŒƒå›´å†…
    SELECT
        'è®¢å•æ—¥æœŸå¿…é¡»åœ¨æœ‰æ•ˆèŒƒå›´å†…'::TEXT,
        COUNT(*) FILTER (WHERE order_date < '2020-01-01' OR order_date > CURRENT_DATE) = 0,
        COUNT(*) FILTER (WHERE order_date < '2020-01-01' OR order_date > CURRENT_DATE)
    FROM staging_orders
    UNION ALL
    -- éªŒè¯3ï¼šæ‰€æœ‰ç»´åº¦é”®å¿…é¡»å­˜åœ¨
    SELECT
        'äº§å“ç»´åº¦é”®å¿…é¡»å­˜åœ¨'::TEXT,
        COUNT(*) FILTER (WHERE product_code NOT IN (SELECT product_code FROM product_dim WHERE is_current = TRUE)) = 0,
        COUNT(*) FILTER (WHERE product_code NOT IN (SELECT product_code FROM product_dim WHERE is_current = TRUE))
    FROM staging_order_items;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 æ•°æ®ä¸€è‡´æ€§

**æ•°æ®ä¸€è‡´æ€§**ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§ã€‚

```sql
-- æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥
CREATE OR REPLACE FUNCTION check_data_consistency()
RETURNS TABLE (
    check_name TEXT,
    is_consistent BOOLEAN,
    error_message TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- æ£€æŸ¥1ï¼šäº‹å®è¡¨ä¸ç»´åº¦è¡¨çš„ä¸€è‡´æ€§
    SELECT
        'äº‹å®è¡¨ä¸ç»´åº¦è¡¨ä¸€è‡´æ€§'::TEXT,
        NOT EXISTS (
            SELECT 1 FROM sales_fact sf
            LEFT JOIN product_dim p ON p.product_id = sf.product_id AND p.is_current = TRUE
            WHERE p.product_id IS NULL
        ),
        CASE
            WHEN EXISTS (
                SELECT 1 FROM sales_fact sf
                LEFT JOIN product_dim p ON p.product_id = sf.product_id AND p.is_current = TRUE
                WHERE p.product_id IS NULL
            ) THEN 'å­˜åœ¨å­¤ç«‹çš„äº‹å®è®°å½•'
            ELSE NULL
        END
    UNION ALL
    -- æ£€æŸ¥2ï¼šåº¦é‡å€¼çš„åˆç†æ€§
    SELECT
        'åº¦é‡å€¼åˆç†æ€§'::TEXT,
        NOT EXISTS (
            SELECT 1 FROM sales_fact
            WHERE amount < 0 OR cost < 0 OR quantity < 0
        ),
        CASE
            WHEN EXISTS (
                SELECT 1 FROM sales_fact
                WHERE amount < 0 OR cost < 0 OR quantity < 0
            ) THEN 'å­˜åœ¨è´Ÿæ•°çš„åº¦é‡å€¼'
            ELSE NULL
        END;
END;
$$ LANGUAGE plpgsql;
```

---

## å…­ã€å®è·µæ¡ˆä¾‹

### 6.1 é›¶å”®æ•°æ®ä»“åº“

**é›¶å”®æ•°æ®ä»“åº“å®Œæ•´è®¾è®¡**ï¼š

```sql
-- é›¶å”®æ•°æ®ä»“åº“äº‹å®è¡¨
CREATE TABLE retail_sales_fact (
    sale_id BIGSERIAL,
    date_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    promotion_id INTEGER,
    quantity INTEGER NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2) NOT NULL,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    PRIMARY KEY (sale_id, date_id)
) PARTITION BY RANGE (date_id);

-- ä¿ƒé”€ç»´åº¦è¡¨
CREATE TABLE promotion_dim (
    promotion_id INTEGER PRIMARY KEY,
    promotion_code VARCHAR(50) UNIQUE NOT NULL,
    promotion_name VARCHAR(200) NOT NULL,
    promotion_type VARCHAR(50),
    discount_type VARCHAR(50),
    discount_value NUMERIC(10,2),
    start_date DATE NOT NULL,
    end_date DATE NOT NULL
);
```

### 6.2 é‡‘èæ•°æ®ä»“åº“

**é‡‘èæ•°æ®ä»“åº“è®¾è®¡**ï¼š

```sql
-- äº¤æ˜“äº‹å®è¡¨
CREATE TABLE transaction_fact (
    transaction_id BIGSERIAL,
    date_id INTEGER NOT NULL,
    account_id INTEGER NOT NULL,
    transaction_type_id INTEGER NOT NULL,
    channel_id INTEGER NOT NULL,
    amount NUMERIC(15,2) NOT NULL,
    fee NUMERIC(10,2) DEFAULT 0,
    balance_after NUMERIC(15,2),
    PRIMARY KEY (transaction_id, date_id)
) PARTITION BY RANGE (date_id);

-- è´¦æˆ·ç»´åº¦è¡¨
CREATE TABLE account_dim (
    account_id INTEGER PRIMARY KEY,
    account_number VARCHAR(50) UNIQUE NOT NULL,
    account_type VARCHAR(50) NOT NULL,
    customer_id INTEGER NOT NULL,
    branch_id INTEGER NOT NULL,
    currency VARCHAR(10) NOT NULL,
    open_date DATE NOT NULL,
    status VARCHAR(20) NOT NULL
);
```

### 6.3 ç”µå•†æ•°æ®ä»“åº“

**ç”µå•†æ•°æ®ä»“åº“è®¾è®¡**ï¼š

```sql
-- ç”µå•†é”€å”®äº‹å®è¡¨
CREATE TABLE ecommerce_sales_fact (
    sale_id BIGSERIAL,
    date_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    channel_id INTEGER NOT NULL,
    payment_method_id INTEGER NOT NULL,
    shipping_method_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    shipping_cost NUMERIC(10,2) DEFAULT 0,
    tax_amount NUMERIC(10,2) DEFAULT 0,
    PRIMARY KEY (sale_id, date_id)
) PARTITION BY RANGE (date_id);

-- æ¸ é“ç»´åº¦è¡¨
CREATE TABLE channel_dim (
    channel_id INTEGER PRIMARY KEY,
    channel_code VARCHAR(50) UNIQUE NOT NULL,
    channel_name VARCHAR(100) NOT NULL,
    channel_type VARCHAR(50) NOT NULL
);
```

---

## ä¸ƒã€ç°ä»£æ•°æ®ä»“åº“æ¶æ„

### 7.1 å®æ—¶æ•°æ®ä»“åº“

**å®æ—¶æ•°æ®ä»“åº“**æ”¯æŒè¿‘å®æ—¶çš„æ•°æ®æ›´æ–°å’ŒæŸ¥è¯¢ï¼Œæ»¡è¶³å®æ—¶åˆ†æå’Œå†³ç­–éœ€æ±‚ã€‚

**æ¶æ„è®¾è®¡**ï¼š

```sql
-- 1. å®æ—¶æ•°æ®æµï¼šä½¿ç”¨é€»è¾‘å¤åˆ¶å®ç°å®æ—¶åŒæ­¥
-- æºæ•°æ®åº“åˆ›å»ºå‘å¸ƒ
CREATE PUBLICATION realtime_pub FOR TABLE orders, order_items, customers;

-- ç›®æ ‡æ•°æ®ä»“åº“åˆ›å»ºè®¢é˜…
CREATE SUBSCRIPTION realtime_sub
CONNECTION 'host=source_host dbname=source_db user=replicator'
PUBLICATION realtime_pub
WITH (copy_data = false, create_slot = true);

-- 2. å®æ—¶äº‹å®è¡¨ï¼šæ”¯æŒå®æ—¶æ’å…¥
CREATE TABLE sales_fact_realtime (
    sale_id BIGSERIAL,
    date_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    PRIMARY KEY (sale_id, date_id)
) PARTITION BY RANGE (date_id);

-- 3. å®æ—¶ç‰©åŒ–è§†å›¾ï¼šè‡ªåŠ¨åˆ·æ–°
CREATE MATERIALIZED VIEW mv_realtime_sales_summary AS
SELECT
    DATE_TRUNC('hour', created_at) AS hour,
    product_id,
    COUNT(*) AS sale_count,
    SUM(amount) AS total_amount
FROM sales_fact_realtime
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY DATE_TRUNC('hour', created_at), product_id;

CREATE UNIQUE INDEX ON mv_realtime_sales_summary(hour, product_id);

-- è‡ªåŠ¨åˆ·æ–°å‡½æ•°ï¼ˆä½¿ç”¨pg_cronæ‰©å±•ï¼‰
-- SELECT cron.schedule('refresh-realtime-summary', '*/5 * * * *',
--   'REFRESH MATERIALIZED VIEW CONCURRENTLY mv_realtime_sales_summary;');

-- 4. å®æ—¶èšåˆï¼šä½¿ç”¨çª—å£å‡½æ•°
CREATE VIEW v_realtime_metrics AS
SELECT
    product_id,
    COUNT(*) OVER (
        PARTITION BY product_id
        ORDER BY created_at
        RANGE BETWEEN INTERVAL '1 hour' PRECEDING AND CURRENT ROW
    ) AS sales_last_hour,
    SUM(amount) OVER (
        PARTITION BY product_id
        ORDER BY created_at
        RANGE BETWEEN INTERVAL '1 hour' PRECEDING AND CURRENT ROW
    ) AS revenue_last_hour
FROM sales_fact_realtime
WHERE created_at >= NOW() - INTERVAL '1 hour';
```

**å®æ—¶æ•°æ®ä»“åº“ä¼˜åŠ¿**ï¼š

- **ä½å»¶è¿Ÿ**ï¼šæ•°æ®æ›´æ–°å»¶è¿Ÿåœ¨ç§’çº§
- **å®æ—¶åˆ†æ**ï¼šæ”¯æŒå®æ—¶æŸ¥è¯¢å’Œåˆ†æ
- **æµå¼å¤„ç†**ï¼šæ”¯æŒæµå¼æ•°æ®å¤„ç†

### 7.2 æ•°æ®æ¹–é›†æˆ

**æ•°æ®æ¹–é›†æˆ**å°†æ•°æ®ä»“åº“ä¸æ•°æ®æ¹–ç»“åˆï¼Œæ”¯æŒç»“æ„åŒ–ã€åŠç»“æ„åŒ–å’Œéç»“æ„åŒ–æ•°æ®çš„ç»Ÿä¸€ç®¡ç†ã€‚

**PostgreSQLæ•°æ®æ¹–é›†æˆæ¶æ„**ï¼š

```sql
-- 1. å¤–éƒ¨æ•°æ®åŒ…è£…å™¨ï¼šè¿æ¥æ•°æ®æ¹–ï¼ˆå¦‚S3ã€HDFSï¼‰
CREATE EXTENSION IF NOT EXISTS aws_s3;

-- åˆ›å»ºå¤–éƒ¨è¡¨ï¼ˆä»S3è¯»å–æ•°æ®ï¼‰
CREATE FOREIGN TABLE s3_sales_data (
    sale_id BIGINT,
    sale_date DATE,
    product_id INTEGER,
    amount NUMERIC(10,2)
) SERVER s3_server
OPTIONS (
    bucket 'data-lake-bucket',
    object_path 'sales/',
    format 'csv'
);

-- 2. æ•°æ®æ¹–åˆ°æ•°æ®ä»“åº“ETL
CREATE TABLE sales_fact_staging AS
SELECT * FROM s3_sales_data
WHERE sale_date >= CURRENT_DATE - INTERVAL '1 day';

-- 3. JSONBæ”¯æŒï¼šå¤„ç†åŠç»“æ„åŒ–æ•°æ®
CREATE TABLE data_lake_events (
    event_id BIGSERIAL PRIMARY KEY,
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    event_time TIMESTAMPTZ DEFAULT NOW(),
    source_system VARCHAR(100)
);

CREATE INDEX idx_events_data ON data_lake_events USING GIN (event_data);
CREATE INDEX idx_events_type_time ON data_lake_events(event_type, event_time DESC);

-- æŸ¥è¯¢JSONBæ•°æ®
SELECT
    event_type,
    event_data->>'user_id' AS user_id,
    event_data->>'action' AS action,
    event_time
FROM data_lake_events
WHERE event_data->>'action' = 'purchase'
AND event_time >= NOW() - INTERVAL '1 day';

-- 4. æ•°æ®æ¹–æ•°æ®è´¨é‡æ£€æŸ¥
CREATE OR REPLACE FUNCTION validate_lake_data()
RETURNS TABLE (
    table_name TEXT,
    total_rows BIGINT,
    valid_rows BIGINT,
    invalid_rows BIGINT,
    quality_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        's3_sales_data'::TEXT,
        COUNT(*)::BIGINT,
        COUNT(*) FILTER (WHERE sale_id IS NOT NULL AND amount > 0)::BIGINT,
        COUNT(*) FILTER (WHERE sale_id IS NULL OR amount <= 0)::BIGINT,
        (COUNT(*) FILTER (WHERE sale_id IS NOT NULL AND amount > 0) * 100.0 / COUNT(*))::NUMERIC
    FROM s3_sales_data;
END;
$$ LANGUAGE plpgsql;
```

**æ•°æ®æ¹–é›†æˆä¼˜åŠ¿**ï¼š

- **ç»Ÿä¸€ç®¡ç†**ï¼šç»Ÿä¸€ç®¡ç†ç»“æ„åŒ–ã€åŠç»“æ„åŒ–å’Œéç»“æ„åŒ–æ•°æ®
- **çµæ´»å­˜å‚¨**ï¼šæ”¯æŒå¤šç§æ•°æ®æ ¼å¼
- **æˆæœ¬ä¼˜åŒ–**ï¼šåˆ©ç”¨å¯¹è±¡å­˜å‚¨é™ä½æˆæœ¬

### 7.3 AIè¾…åŠ©æ•°æ®ä»“åº“å»ºæ¨¡

**AIè¾…åŠ©å»ºæ¨¡**åˆ©ç”¨æœºå™¨å­¦ä¹ æŠ€æœ¯è‡ªåŠ¨å‘ç°æ•°æ®å…³ç³»ã€ä¼˜åŒ–æ¨¡å‹è®¾è®¡ã€‚

**PostgreSQLä¸­çš„AIè¾…åŠ©å»ºæ¨¡**ï¼š

```sql
-- 1. è‡ªåŠ¨å‘ç°æ•°æ®å…³ç³»ï¼šä½¿ç”¨ç»Ÿè®¡ä¿¡æ¯åˆ†æ
CREATE OR REPLACE FUNCTION discover_relationships(p_schema_name TEXT)
RETURNS TABLE (
    table1_name TEXT,
    table2_name TEXT,
    relationship_type TEXT,
    confidence NUMERIC,
    suggested_fk TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t1.table_name::TEXT,
        t2.table_name::TEXT,
        CASE
            WHEN COUNT(DISTINCT t1.column_name) = 1 AND COUNT(DISTINCT t2.column_name) = 1 THEN 'One-to-One'
            WHEN COUNT(DISTINCT t1.column_name) = 1 THEN 'One-to-Many'
            ELSE 'Many-to-Many'
        END::TEXT AS relationship_type,
        -- åŸºäºæ•°æ®åˆ†å¸ƒè®¡ç®—ç½®ä¿¡åº¦
        (COUNT(DISTINCT t1.column_value)::NUMERIC / NULLIF(COUNT(DISTINCT t2.column_value), 0)) AS confidence,
        format('%s.%s -> %s.%s', t1.table_name, t1.column_name, t2.table_name, t2.column_name)::TEXT AS suggested_fk
    FROM (
        SELECT table_name, column_name, column_value
        FROM information_schema.columns
        WHERE table_schema = p_schema_name
    ) t1
    JOIN (
        SELECT table_name, column_name, column_value
        FROM information_schema.columns
        WHERE table_schema = p_schema_name
    ) t2 ON t1.column_name = t2.column_name
    WHERE t1.table_name != t2.table_name
    GROUP BY t1.table_name, t2.table_name;
END;
$$ LANGUAGE plpgsql;

-- 2. è‡ªåŠ¨ä¼˜åŒ–åˆ†åŒºç­–ç•¥ï¼šåŸºäºæŸ¥è¯¢æ¨¡å¼
CREATE OR REPLACE FUNCTION suggest_partition_strategy(p_table_name TEXT)
RETURNS TABLE (
    partition_column TEXT,
    partition_type TEXT,
    partition_count INTEGER,
    estimated_benefit NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        column_name::TEXT,
        CASE
            WHEN data_type IN ('date', 'timestamp', 'timestamptz') THEN 'RANGE'
            WHEN data_type IN ('integer', 'bigint') THEN 'RANGE'
            WHEN data_type IN ('varchar', 'text') THEN 'LIST'
            ELSE 'HASH'
        END::TEXT AS partition_type,
        CASE
            WHEN data_type IN ('date', 'timestamp', 'timestamptz') THEN 12  -- æŒ‰æœˆåˆ†åŒº
            WHEN data_type IN ('integer', 'bigint') THEN 10  -- æŒ‰èŒƒå›´åˆ†åŒº
            ELSE 4  -- é»˜è®¤åˆ†åŒºæ•°
        END::INTEGER AS partition_count,
        -- åŸºäºæŸ¥è¯¢é¢‘ç‡ä¼°ç®—æ”¶ç›Š
        (query_count * avg_query_time)::NUMERIC AS estimated_benefit
    FROM (
        SELECT
            column_name,
            data_type,
            COUNT(*) AS query_count,
            AVG(execution_time) AS avg_query_time
        FROM pg_stat_statements
        WHERE query LIKE '%' || p_table_name || '%'
        GROUP BY column_name, data_type
    ) stats;
END;
$$ LANGUAGE plpgsql;

-- 3. è‡ªåŠ¨ç´¢å¼•æ¨èï¼šåŸºäºæŸ¥è¯¢æ¨¡å¼
CREATE OR REPLACE FUNCTION suggest_indexes(p_table_name TEXT)
RETURNS TABLE (
    index_name TEXT,
    index_columns TEXT,
    index_type TEXT,
    estimated_benefit NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        format('idx_%s_%s', p_table_name, column_list)::TEXT AS index_name,
        column_list::TEXT,
        CASE
            WHEN column_count = 1 THEN 'B-Tree'
            WHEN has_jsonb THEN 'GIN'
            WHEN has_array THEN 'GIN'
            ELSE 'B-Tree'
        END::TEXT AS index_type,
        (query_count * avg_query_time)::NUMERIC AS estimated_benefit
    FROM (
        SELECT
            STRING_AGG(column_name, ', ' ORDER BY column_name) AS column_list,
            COUNT(*) AS column_count,
            BOOL_OR(data_type = 'jsonb') AS has_jsonb,
            BOOL_OR(data_type LIKE '%[]') AS has_array,
            COUNT(*) AS query_count,
            AVG(execution_time) AS avg_query_time
        FROM pg_stat_statements
        WHERE query LIKE '%' || p_table_name || '%'
        GROUP BY column_list
    ) stats
    ORDER BY estimated_benefit DESC
    LIMIT 10;
END;
$$ LANGUAGE plpgsql;
```

**AIè¾…åŠ©å»ºæ¨¡ä¼˜åŠ¿**ï¼š

- **è‡ªåŠ¨åŒ–**ï¼šè‡ªåŠ¨å‘ç°æ•°æ®å…³ç³»å’Œä¼˜åŒ–æœºä¼š
- **æ™ºèƒ½åŒ–**ï¼šåŸºäºæŸ¥è¯¢æ¨¡å¼æ™ºèƒ½æ¨è
- **æ•ˆç‡æå‡**ï¼šå‡å°‘æ‰‹åŠ¨åˆ†æå’Œè®¾è®¡æ—¶é—´

### 7.4 æ•°æ®ç½‘æ ¼ï¼ˆData Meshï¼‰æ¶æ„ ğŸ†•

**æ•°æ®ç½‘æ ¼ï¼ˆData Meshï¼‰**æ˜¯ä¸€ç§åˆ†å¸ƒå¼æ•°æ®æ¶æ„èŒƒå¼ï¼Œå¼ºè°ƒé¢†åŸŸå¯¼å‘ã€æ•°æ®äº§å“åŒ–ã€è‡ªåŠ©å¼æ•°æ®åŸºç¡€è®¾æ–½å’Œè”åˆæ²»ç†ã€‚

**PostgreSQLä¸­çš„æ•°æ®ç½‘æ ¼å®ç°**ï¼š

```sql
-- 1. é¢†åŸŸæ•°æ®äº§å“ï¼šæ¯ä¸ªé¢†åŸŸæ‹¥æœ‰ç‹¬ç«‹çš„æ•°æ®äº§å“
-- é”€å”®é¢†åŸŸæ•°æ®äº§å“
CREATE SCHEMA sales_domain;
CREATE TABLE sales_domain.sales_data_product (
    product_id BIGINT PRIMARY KEY,
    product_name VARCHAR(200) NOT NULL,
    sales_amount NUMERIC(10,2) NOT NULL,
    sales_date DATE NOT NULL,
    domain_owner VARCHAR(100) NOT NULL,
    data_product_version INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- å®¢æˆ·é¢†åŸŸæ•°æ®äº§å“
CREATE SCHEMA customer_domain;
CREATE TABLE customer_domain.customer_data_product (
    customer_id BIGINT PRIMARY KEY,
    customer_name VARCHAR(200) NOT NULL,
    customer_segment VARCHAR(50),
    domain_owner VARCHAR(100) NOT NULL,
    data_product_version INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. æ•°æ®äº§å“ç›®å½•ï¼šå…ƒæ•°æ®ç®¡ç†
CREATE TABLE data_product_catalog (
    data_product_id BIGSERIAL PRIMARY KEY,
    domain_name VARCHAR(100) NOT NULL,
    data_product_name VARCHAR(200) NOT NULL,
    schema_name VARCHAR(100) NOT NULL,
    table_name VARCHAR(200) NOT NULL,
    domain_owner VARCHAR(100) NOT NULL,
    data_product_version INTEGER DEFAULT 1,
    description TEXT,
    tags TEXT[],
    quality_metrics JSONB DEFAULT '{}'::jsonb,
    access_policy JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(domain_name, data_product_name, data_product_version)
);

CREATE INDEX idx_data_product_catalog_domain ON data_product_catalog(domain_name);
CREATE INDEX idx_data_product_catalog_tags ON data_product_catalog USING GIN (tags);

-- æ³¨å†Œæ•°æ®äº§å“
INSERT INTO data_product_catalog (
    domain_name, data_product_name, schema_name, table_name,
    domain_owner, description, tags
) VALUES (
    'sales', 'sales_data_product', 'sales_domain', 'sales_data_product',
    'sales-team@example.com',
    'é”€å”®é¢†åŸŸæ•°æ®äº§å“ï¼ŒåŒ…å«äº§å“é”€å”®æ•°æ®',
    ARRAY['sales', 'revenue', 'analytics']
);

-- 3. æ•°æ®äº§å“è®¿é—®å±‚ï¼šç»Ÿä¸€æŸ¥è¯¢æ¥å£
CREATE VIEW v_data_product_access AS
SELECT
    dpc.domain_name,
    dpc.data_product_name,
    dpc.schema_name,
    dpc.table_name,
    dpc.domain_owner,
    dpc.description,
    dpc.tags,
    dpc.quality_metrics,
    dpc.access_policy
FROM data_product_catalog dpc
WHERE dpc.data_product_version = (
    SELECT MAX(dpc2.data_product_version)
    FROM data_product_catalog dpc2
    WHERE dpc2.domain_name = dpc.domain_name
    AND dpc2.data_product_name = dpc.data_product_name
);

-- 4. é¢†åŸŸæ•°æ®æœåŠ¡ï¼šé¢†åŸŸç‰¹å®šçš„æ•°æ®æœåŠ¡
CREATE OR REPLACE FUNCTION get_sales_domain_data(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
    product_id BIGINT,
    product_name VARCHAR(200),
    sales_amount NUMERIC(10,2),
    sales_date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        sdp.product_id,
        sdp.product_name,
        sdp.sales_amount,
        sdp.sales_date
    FROM sales_domain.sales_data_product sdp
    WHERE (p_start_date IS NULL OR sdp.sales_date >= p_start_date)
    AND (p_end_date IS NULL OR sdp.sales_date <= p_end_date)
    ORDER BY sdp.sales_date DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5. æ•°æ®äº§å“ç‰ˆæœ¬ç®¡ç†
CREATE TABLE data_product_versions (
    version_id BIGSERIAL PRIMARY KEY,
    domain_name VARCHAR(100) NOT NULL,
    data_product_name VARCHAR(200) NOT NULL,
    version_number INTEGER NOT NULL,
    schema_snapshot JSONB NOT NULL,
    migration_script TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    UNIQUE(domain_name, data_product_name, version_number)
);

-- 6. æ•°æ®äº§å“è´¨é‡ç›‘æ§
CREATE TABLE data_product_quality_metrics (
    metric_id BIGSERIAL PRIMARY KEY,
    domain_name VARCHAR(100) NOT NULL,
    data_product_name VARCHAR(200) NOT NULL,
    metric_type VARCHAR(50) NOT NULL,
    metric_value NUMERIC NOT NULL,
    threshold NUMERIC,
    status VARCHAR(20) NOT NULL,
    check_time TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_dp_quality_metrics ON data_product_quality_metrics(domain_name, data_product_name, check_time DESC);

-- 7. æ•°æ®äº§å“è®¿é—®æ—¥å¿—
CREATE TABLE data_product_access_log (
    access_id BIGSERIAL PRIMARY KEY,
    domain_name VARCHAR(100) NOT NULL,
    data_product_name VARCHAR(200) NOT NULL,
    user_id VARCHAR(100) NOT NULL,
    access_type VARCHAR(50) NOT NULL,
    access_time TIMESTAMPTZ DEFAULT NOW(),
    query_text TEXT,
    rows_returned INTEGER
);

CREATE INDEX idx_dp_access_log ON data_product_access_log(domain_name, data_product_name, access_time DESC);
```

**æ•°æ®ç½‘æ ¼æ¶æ„ä¼˜åŠ¿**ï¼š

- **é¢†åŸŸå¯¼å‘**ï¼šæ•°æ®æŒ‰ä¸šåŠ¡é¢†åŸŸç»„ç»‡ï¼Œæé«˜å¯ç†è§£æ€§
- **æ•°æ®äº§å“åŒ–**ï¼šæ•°æ®ä½œä¸ºäº§å“ç®¡ç†ï¼Œæé«˜æ•°æ®è´¨é‡
- **è‡ªåŠ©å¼è®¿é—®**ï¼šæä¾›ç»Ÿä¸€çš„æ•°æ®è®¿é—®æ¥å£
- **è”åˆæ²»ç†**ï¼šåˆ†æ•£æ²»ç†ï¼Œé›†ä¸­åè°ƒ

---

## å…«ã€PostgreSQL 18æ–°ç‰¹æ€§

### 8.1 å¹¶è¡ŒæŸ¥è¯¢å¢å¼º

**å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**æå‡åˆ†ææŸ¥è¯¢æ€§èƒ½ã€‚

```sql
-- PostgreSQL 18å¹¶è¡ŒæŸ¥è¯¢å¢å¼º
SET max_parallel_workers_per_gather = 8;
SET parallel_setup_cost = 50;
SET parallel_tuple_cost = 0.005;

-- å¹¶è¡ŒèšåˆæŸ¥è¯¢æ€§èƒ½æå‡30-40%
EXPLAIN ANALYZE
SELECT
    p.category_name,
    SUM(sf.amount) AS total_amount
FROM sales_fact sf
JOIN product_dim p ON p.product_id = sf.product_id
WHERE sf.date_id >= 20240101
GROUP BY p.category_name;
```

### 8.2 å¼‚æ­¥I/Oä¼˜åŒ–

**å¼‚æ­¥I/Oä¼˜åŒ–**æå‡I/Oæ€§èƒ½ã€‚

```sql
-- PostgreSQL 18å¼‚æ­¥I/Oè‡ªåŠ¨å¯ç”¨
-- åœ¨postgresql.confä¸­é…ç½®ï¼š
-- io_uring = on
-- max_io_concurrency = 10

-- æ•°æ®ä»“åº“æŸ¥è¯¢è‡ªåŠ¨å—ç›Šäºå¼‚æ­¥I/O
-- I/Oæ€§èƒ½æå‡2-3å€
```

### 8.3 å¢é‡å¤‡ä»½ä¼˜åŒ–

**å¢é‡å¤‡ä»½ä¼˜åŒ–**å‡å°‘å¤‡ä»½æ—¶é—´ã€‚

```sql
-- PostgreSQL 18å¢é‡å¤‡ä»½
-- ä½¿ç”¨pg_basebackup --incremental
-- å¤‡ä»½æ—¶é—´å‡å°‘94%
```

---

## ä¹ã€æœ€ä½³å®è·µ

1. **å»ºæ¨¡åŸåˆ™**ï¼š
   - ä½¿ç”¨æ˜Ÿå‹æ¨¡å‹æˆ–é›ªèŠ±æ¨¡å‹
   - åˆç†è®¾è®¡äº‹å®è¡¨å’Œç»´åº¦è¡¨
   - ä½¿ç”¨SCDç±»å‹2å¤„ç†ç¼“æ…¢å˜åŒ–ç»´åº¦

2. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨åˆ†åŒºç®¡ç†å¤§æ•°æ®è¡¨
   - åˆ›å»ºåˆé€‚çš„ç´¢å¼•
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾é¢„è®¡ç®—

3. **æ•°æ®è´¨é‡**ï¼š
   - å»ºç«‹æ•°æ®æ¸…æ´—æµç¨‹
   - å®æ–½æ•°æ®éªŒè¯è§„åˆ™
   - å®šæœŸæ£€æŸ¥æ•°æ®ä¸€è‡´æ€§

4. **ETLæµç¨‹**ï¼š
   - è®¾è®¡å¯é‡å¤çš„ETLæµç¨‹
   - æ”¯æŒå¢é‡æ›´æ–°
   - è®°å½•ETLæ‰§è¡Œæ—¥å¿—

---

## åã€å‚è€ƒèµ„æº

### 9.1 å®˜æ–¹æ–‡æ¡£

- [PostgreSQLåˆ†åŒº](https://www.postgresql.org/docs/current/ddl-partitioning.html)
- [PostgreSQLå¹¶è¡ŒæŸ¥è¯¢](https://www.postgresql.org/docs/current/parallel-query.html)
- [PostgreSQLç‰©åŒ–è§†å›¾](https://www.postgresql.org/docs/current/sql-creatematerializedview.html)

### 9.2 ç›¸å…³æ–‡æ¡£

- [æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—](./09.02-æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—.md) - æ•°æ®å»ºæ¨¡ç†è®ºåŸºç¡€ã€å­˜å‚¨æ¶æ„é€‰æ‹© ğŸ†•
- [ETLæµç¨‹å®Œæ•´æŒ‡å—](./09.04-ETLæµç¨‹å®Œæ•´æŒ‡å—.md) - ETLæµç¨‹è¯¦ç»†è¯´æ˜
- [æ•°æ®åˆ†æå®Œæ•´æŒ‡å—](./09.01-æ•°æ®åˆ†æå®Œæ•´æŒ‡å—.md) - æ•°æ®åˆ†æå®è·µã€åˆ—å­˜å‚¨ä¼˜åŒ– ğŸ†•
- [å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–](../../04-å­˜å‚¨ä¸æ¢å¤/01.06-å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–.md) - åˆ—å­˜å‚¨æ¶æ„åˆ†æã€åˆ—å‹ç¼©æŠ€æœ¯è¯¦è§£ ğŸ†•
- [æ‰©å±•ç³»ç»Ÿ](../../06-æ‰©å±•ç³»ç»Ÿ/README.md) - åˆ—å­˜å‚¨æ‰©å±•ï¼ˆcstore_fdwï¼‰ğŸ†•
- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.02-ç´¢å¼•ç»“æ„/02.02-ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–.md) - åˆ—å­˜å‚¨ç´¢å¼•ä¼˜åŒ– ğŸ†•
- [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.03-æ‰§è¡Œè®¡åˆ’/02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - åˆ—å­˜å‚¨æŸ¥è¯¢ä¼˜åŒ– ğŸ†•
- [å®æˆ˜æ¡ˆä¾‹](../../19-å®æˆ˜æ¡ˆä¾‹/README.md) - æ•°æ®ä»“åº“å®è·µæ¡ˆä¾‹ ğŸ†•

### 9.3 å¤–éƒ¨èµ„æº

- [æ•°æ®ä»“åº“è®¾è®¡æœ€ä½³å®è·µ](https://www.postgresql.org/docs/current/)
- [Kimballç»´åº¦å»ºæ¨¡](https://www.kimballgroup.com/)
- [Inmonä¼ä¸šæ•°æ®ä»“åº“](https://www.inmoncif.com/)

---

## åä¸€ã€äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£

- â­â­â­ [æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—](./09.02-æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—.md) - æ•°æ®å»ºæ¨¡ç†è®ºåŸºç¡€ã€å­˜å‚¨æ¶æ„é€‰æ‹© ğŸ†•
- â­â­â­ [ETLæµç¨‹å®Œæ•´æŒ‡å—](./09.04-ETLæµç¨‹å®Œæ•´æŒ‡å—.md) - ETLæµç¨‹è¯¦ç»†è¯´æ˜
- â­â­â­ [æ•°æ®åˆ†æå®Œæ•´æŒ‡å—](./09.01-æ•°æ®åˆ†æå®Œæ•´æŒ‡å—.md) - æ•°æ®åˆ†æå®è·µã€åˆ—å­˜å‚¨ä¼˜åŒ– ğŸ†•
- â­â­ [æ•°æ®è´¨é‡ç®¡ç†æŒ‡å—](./09.05-æ•°æ®è´¨é‡ç®¡ç†æŒ‡å—.md) - æ•°æ®è´¨é‡ä¿è¯
- â­â­ [æ•°æ®ç§‘å­¦å®è·µ](../../16-åº”ç”¨è®¾è®¡ä¸å¼€å‘/åº”ç”¨æ¶æ„/07.06-æ•°æ®ç§‘å­¦å®è·µ.md) - æ•°æ®ç§‘å­¦å®Œæ•´æŒ‡å—
- â­â­â­ [å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–](../../04-å­˜å‚¨ä¸æ¢å¤/01.06-å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–.md) - åˆ—å­˜å‚¨æ¶æ„åˆ†æã€åˆ—å‹ç¼©æŠ€æœ¯è¯¦è§£ ğŸ†•
- â­â­ [æ‰©å±•ç³»ç»Ÿ](../../06-æ‰©å±•ç³»ç»Ÿ/README.md) - åˆ—å­˜å‚¨æ‰©å±•ï¼ˆcstore_fdwï¼‰ğŸ†•
- â­â­ [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.02-ç´¢å¼•ç»“æ„/02.02-ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–.md) - åˆ—å­˜å‚¨ç´¢å¼•ä¼˜åŒ– ğŸ†•
- â­â­ [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.03-æ‰§è¡Œè®¡åˆ’/02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - åˆ—å­˜å‚¨æŸ¥è¯¢ä¼˜åŒ– ğŸ†•
- â­â­ [å®æˆ˜æ¡ˆä¾‹](../../19-å®æˆ˜æ¡ˆä¾‹/README.md) - æ•°æ®ä»“åº“å®è·µæ¡ˆä¾‹ ğŸ†•
- â­ [å¹¶è¡ŒæŸ¥è¯¢å¤„ç†](../../02-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.05-å¹¶è¡ŒæŸ¥è¯¢/02.05-å¹¶è¡ŒæŸ¥è¯¢å¤„ç†.md) - å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

### å¤–éƒ¨èµ„æº

- [PostgreSQLåˆ†åŒºæ–‡æ¡£](https://www.postgresql.org/docs/current/ddl-partitioning.html)
- [PostgreSQLå¹¶è¡ŒæŸ¥è¯¢æ–‡æ¡£](https://www.postgresql.org/docs/current/parallel-query.html)
- [PostgreSQLç‰©åŒ–è§†å›¾æ–‡æ¡£](https://www.postgresql.org/docs/current/sql-creatematerializedview.html)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1
**æœ€åæ›´æ–°**: 2025-11-22
**PostgreSQLç‰ˆæœ¬**: 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
**ç»´æŠ¤è€…**: Documentation Team
