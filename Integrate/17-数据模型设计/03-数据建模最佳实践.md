---

> **📋 文档来源**: `DataBaseTheory\09-数据模型与规范化\03-数据建模最佳实践.md`
> **📅 复制日期**: 2025-12-22
> **⚠️ 注意**: 本文档为复制版本，原文件保持不变

---

# PostgreSQL数据建模最佳实践

## 📋 目录

- [PostgreSQL数据建模最佳实践](#postgresql数据建模最佳实践)
  - [📋 目录](#-目录)
  - [1. 主键设计](#1-主键设计)
    - [1.1 主键类型选择](#11-主键类型选择)
  - [2. 外键设计](#2-外键设计)
    - [2.1 外键约束](#21-外键约束)
    - [2.2 软外键（性能）](#22-软外键性能)
  - [3. 索引策略](#3-索引策略)
    - [3.1 单列索引](#31-单列索引)
    - [3.2 组合索引](#32-组合索引)
    - [3.3 覆盖索引](#33-覆盖索引)
  - [4. 反规范化](#4-反规范化)
    - [4.1 何时反规范化](#41-何时反规范化)
    - [4.2 汇总表](#42-汇总表)
    - [5.3 哈希分区](#53-哈希分区)
  - [6. JSON vs 列](#6-json-vs-列)
    - [6.1 何时使用JSONB](#61-何时使用jsonb)

## 1. 主键设计

### 1.1 主键类型选择

```sql
-- 选项1: SERIAL/BIGSERIAL（自增）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            CREATE TABLE users (
                user_id BIGSERIAL PRIMARY KEY,
                username VARCHAR(100)
            );
            RAISE NOTICE '表 users 创建成功';
        ELSE
            RAISE NOTICE '表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;
-- 优点: 简单、顺序、B-Tree友好
-- 缺点: 分布式环境冲突、无业务意义

-- 选项2: UUID（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'uuid-ossp') THEN
            CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
            RAISE NOTICE '扩展 uuid-ossp 创建成功';
        ELSE
            RAISE NOTICE '扩展 uuid-ossp 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_object THEN
            RAISE NOTICE '扩展 uuid-ossp 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建扩展失败: %', SQLERRM;
            RAISE;
    END;
END $$;

DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users' AND table_schema = 'public') THEN
            CREATE TABLE users (
                user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                username VARCHAR(100)
            );
            RAISE NOTICE '表 users (UUID) 创建成功';
        ELSE
            RAISE NOTICE '表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;
-- 优点: 全局唯一、分布式友好
-- 缺点: 16字节、随机（索引性能差）

-- 选项3: UUIDv7（PostgreSQL 18，推荐）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users' AND table_schema = 'public') THEN
            CREATE TABLE users (
                user_id UUID PRIMARY KEY DEFAULT uuid_generate_v7(),
                username VARCHAR(100)
            );
            RAISE NOTICE '表 users (UUIDv7) 创建成功';
        ELSE
            RAISE NOTICE '表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;
-- 优点: 全局唯一+时间有序
-- 性能: 接近BIGSERIAL

-- 选项4: 雪花ID（Snowflake）（带错误处理）
DO $$
BEGIN
    BEGIN
        CREATE OR REPLACE FUNCTION generate_snowflake_id()
        RETURNS BIGINT AS $$
        DECLARE
            epoch BIGINT := 1640995200000;  -- 2022-01-01 00:00:00 UTC (毫秒)
            machine_id INT := 1;
            sequence INT;
            current_time BIGINT;
            result BIGINT;
        BEGIN
            current_time := (EXTRACT(EPOCH FROM clock_timestamp()) * 1000)::BIGINT;
            sequence := nextval('snowflake_seq') % 4096;

            result := ((current_time - epoch) << 22) | (machine_id << 12) | sequence;

            RETURN result;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '生成雪花ID失败: %', SQLERRM;
                RETURN NULL;
        END;
        $$ LANGUAGE plpgsql;
        RAISE NOTICE '函数 generate_snowflake_id 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建函数失败: %', SQLERRM;
            RAISE;
    END;
END $$;

DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_sequences WHERE sequencename = 'snowflake_seq') THEN
            CREATE SEQUENCE snowflake_seq;
            RAISE NOTICE '序列 snowflake_seq 创建成功';
        ELSE
            RAISE NOTICE '序列 snowflake_seq 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '序列 snowflake_seq 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建序列失败: %', SQLERRM;
            RAISE;
    END;
END $$;

DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users' AND table_schema = 'public') THEN
            CREATE TABLE users (
                user_id BIGINT PRIMARY KEY DEFAULT generate_snowflake_id(),
                username VARCHAR(100)
            );
            RAISE NOTICE '表 users (雪花ID) 创建成功';
        ELSE
            RAISE NOTICE '表 users 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 users 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = 1 LIMIT 1;
```

---

## 2. 外键设计

### 2.1 外键约束

```sql
-- 基础外键（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            CREATE TABLE orders (
                order_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL REFERENCES users(user_id),
                created_at TIMESTAMPTZ DEFAULT now()
            );
            RAISE NOTICE '表 orders 创建成功';
        ELSE
            RAISE NOTICE '表 orders 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 orders 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 级联操作（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'order_items') THEN
            CREATE TABLE order_items (
                item_id BIGSERIAL PRIMARY KEY,
                order_id BIGINT NOT NULL REFERENCES orders(order_id)
                    ON DELETE CASCADE          -- 删除订单时删除订单项
                    ON UPDATE CASCADE,         -- 更新订单ID时同步更新
                product_id BIGINT NOT NULL REFERENCES products(product_id)
                    ON DELETE RESTRICT,        -- 禁止删除被引用的产品
                quantity INT NOT NULL
            );
            RAISE NOTICE '表 order_items 创建成功';
        ELSE
            RAISE NOTICE '表 order_items 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 order_items 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 延迟约束检查（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders' AND table_schema = 'public') THEN
            CREATE TABLE orders (
                order_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,
                FOREIGN KEY (user_id) REFERENCES users(user_id) DEFERRABLE INITIALLY DEFERRED
            );
            RAISE NOTICE '表 orders (延迟约束) 创建成功';
        ELSE
            RAISE NOTICE '表 orders 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 orders 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 事务结束时检查（带错误处理）
DO $$
BEGIN
    BEGIN
        BEGIN;
        INSERT INTO orders (order_id, user_id) VALUES (1, 999) ON CONFLICT DO NOTHING;  -- user不存在
        INSERT INTO users (user_id, username) VALUES (999, 'test') ON CONFLICT DO NOTHING;  -- 后插入
        COMMIT;  -- 此时检查约束，成功
        RAISE NOTICE '延迟约束检查成功';
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE WARNING '延迟约束检查失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 2.2 软外键（性能）

```sql
-- 场景: 高频写入，外键检查成本高（带错误处理）
-- 方案: 应用层保证 + 定期验证

DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'logs') THEN
            CREATE TABLE logs (
                log_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT NOT NULL,  -- 无FOREIGN KEY
                message TEXT,
                created_at TIMESTAMPTZ DEFAULT now()
            );
            RAISE NOTICE '表 logs 创建成功';
        ELSE
            RAISE NOTICE '表 logs 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 logs 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 定期验证数据完整性（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'logs') THEN
            EXPLAIN (ANALYZE, BUFFERS, TIMING)
            SELECT l.user_id
            FROM logs l
            LEFT JOIN users u ON l.user_id = u.user_id
            WHERE u.user_id IS NULL
            LIMIT 100;
        ELSE
            RAISE NOTICE '表 logs 不存在，跳过验证';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '数据完整性验证失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 3. 索引策略

### 3.1 单列索引

```sql
-- 高选择性列（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
            CREATE INDEX idx_users_email ON users(email);  -- 唯一或接近唯一
            RAISE NOTICE '索引 idx_users_email 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_users_email 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 低选择性列（考虑部分索引）（带错误处理）
-- Bad
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_status') THEN
            CREATE INDEX idx_users_status ON users(status);  -- 只有3种状态
            RAISE NOTICE '索引 idx_users_status 创建成功（不推荐）';
        ELSE
            RAISE NOTICE '索引 idx_users_status 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Good
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_active') THEN
            CREATE INDEX idx_users_active ON users(status) WHERE status = 'active';
            RAISE NOTICE '索引 idx_users_active 创建成功（推荐）';
        ELSE
            RAISE NOTICE '索引 idx_users_active 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE status = 'active' LIMIT 10;
```

### 3.2 组合索引

```sql
-- 查询: WHERE a = ? AND b = ? ORDER BY c（带错误处理）
-- 注意：这里使用示例表名，实际使用时需要替换为真实表名
DO $$
BEGIN
    BEGIN
        -- 示例：为表创建组合索引
        -- CREATE INDEX idx_abc ON table_name(a, b, c);
        RAISE NOTICE '组合索引创建示例（需要替换为实际表名）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建组合索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 可以使用索引的查询:
-- WHERE a = ?                              ✓
-- WHERE a = ? AND b = ?                    ✓
-- WHERE a = ? AND b = ? ORDER BY c         ✓
-- WHERE a = ? ORDER BY b, c                ✓

-- 无法使用索引:
-- WHERE b = ?                              ✗
-- WHERE c = ?                              ✗ (PostgreSQL 18: Skip Scan可以!)
-- WHERE b = ? AND c = ?                    ✗

-- 原则: 查询列在前，排序列在后

-- 性能测试示例
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE user_id = 1 AND username = 'test' ORDER BY created_at LIMIT 10;
```

### 3.3 覆盖索引

```sql
-- Index Only Scan（无需访问表）（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email_name') THEN
            CREATE INDEX idx_users_email_name ON users(email, username);
            RAISE NOTICE '索引 idx_users_email_name 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_users_email_name 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT username FROM users WHERE email = 'test@example.com';
-- Index Only Scan: 只扫描索引，不访问表

-- 注意: 需要定期VACUUM更新可见性映射
```

---

## 4. 反规范化

### 4.1 何时反规范化

```sql
-- 场景: 高频JOIN查询（带错误处理）

-- 规范化设计（3NF）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders' AND table_schema = 'public') THEN
            CREATE TABLE orders (
                order_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT REFERENCES users(user_id),
                created_at TIMESTAMPTZ
            );
            RAISE NOTICE '表 orders (规范化) 创建成功';
        ELSE
            RAISE NOTICE '表 orders 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 orders 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT o.*, u.username, u.email
FROM orders o
JOIN users u ON o.user_id = u.user_id
LIMIT 100;
-- 每次查询都需要JOIN

-- 反规范化（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders' AND table_schema = 'public') THEN
            CREATE TABLE orders (
                order_id BIGSERIAL PRIMARY KEY,
                user_id BIGINT,
                user_name VARCHAR(100),  -- 冗余
                user_email VARCHAR(255), -- 冗余
                created_at TIMESTAMPTZ
            );
            RAISE NOTICE '表 orders (反规范化) 创建成功';
        ELSE
            RAISE NOTICE '表 orders 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 orders 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT * FROM orders;  -- 无需JOIN

-- 维护一致性（触发器）
CREATE OR REPLACE FUNCTION sync_user_info()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders
    SET user_name = NEW.username,
        user_email = NEW.email
    WHERE user_id = NEW.user_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_sync_user
    AFTER UPDATE OF username, email ON users
    FOR EACH ROW
    EXECUTE FUNCTION sync_user_info();
```

### 4.2 汇总表

```sql
-- 实时汇总（物化视图）（带错误处理）
DO $$
BEGIN
    BEGIN
        DROP MATERIALIZED VIEW IF EXISTS user_statistics;
        CREATE MATERIALIZED VIEW user_statistics AS
        SELECT
            user_id,
            COUNT(*) AS order_count,
            SUM(amount) AS total_spent,
            MAX(created_at) AS last_order_at
        FROM orders
        GROUP BY user_id;
        RAISE NOTICE '物化视图 user_statistics 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建物化视图失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_user_stats_user') THEN
            CREATE UNIQUE INDEX idx_user_stats_user ON user_statistics(user_id);
            RAISE NOTICE '索引 idx_user_stats_user 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_user_stats_user 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 定期刷新（带错误处理）
DO $$
BEGIN
    BEGIN
        REFRESH MATERIALIZED VIEW CONCURRENTLY user_statistics;
        RAISE NOTICE '物化视图刷新成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '刷新物化视图失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM user_statistics WHERE user_id = 1;
```

-- 或用触发器实时维护普通表

```

---

## 5. 分区策略

### 5.1 时间分区

```sql
-- 日志表按月分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'logs') THEN
            CREATE TABLE logs (
                log_id BIGSERIAL,
                message TEXT,
                created_at TIMESTAMPTZ NOT NULL,
                PRIMARY KEY (log_id, created_at)
            ) PARTITION BY RANGE (created_at);
            RAISE NOTICE '分区表 logs 创建成功';
        ELSE
            RAISE NOTICE '分区表 logs 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区表 logs 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'logs_2024_01') THEN
            CREATE TABLE logs_2024_01 PARTITION OF logs
            FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
            RAISE NOTICE '分区 logs_2024_01 创建成功';
        ELSE
            RAISE NOTICE '分区 logs_2024_01 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 自动分区裁剪（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM logs
WHERE created_at >= '2024-01-15' AND created_at < '2024-01-20'
LIMIT 100;
```

-- 只扫描logs_2024_01分区

```

### 5.2 列表分区

```sql
-- 按地区分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders' AND table_schema = 'public') THEN
            CREATE TABLE orders (
                order_id BIGSERIAL,
                region VARCHAR(10),
                amount NUMERIC,
                PRIMARY KEY (order_id, region)
            ) PARTITION BY LIST (region);
            RAISE NOTICE '分区表 orders (LIST) 创建成功';
        ELSE
            RAISE NOTICE '分区表 orders 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区表 orders 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'orders_asia') THEN
            CREATE TABLE orders_asia PARTITION OF orders
            FOR VALUES IN ('CN', 'JP', 'KR', 'SG');
            RAISE NOTICE '分区 orders_asia 创建成功';
        ELSE
            RAISE NOTICE '分区 orders_asia 已存在';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'orders_europe') THEN
            CREATE TABLE orders_europe PARTITION OF orders
            FOR VALUES IN ('UK', 'FR', 'DE', 'IT');
            RAISE NOTICE '分区 orders_europe 创建成功';
        ELSE
            RAISE NOTICE '分区 orders_europe 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM orders WHERE region = 'CN' LIMIT 100;
```

### 5.3 哈希分区

```sql
-- 均匀分布大表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users_partitioned') THEN
            CREATE TABLE users_partitioned (
                user_id BIGINT PRIMARY KEY,
                username VARCHAR(100)
            ) PARTITION BY HASH (user_id);
            RAISE NOTICE '分区表 users_partitioned 创建成功';
        ELSE
            RAISE NOTICE '分区表 users_partitioned 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区表 users_partitioned 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建8个分区（带错误处理）
DO $$
DECLARE
    i INT;
BEGIN
    BEGIN
        FOR i IN 0..7 LOOP
            IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'users_p' || i) THEN
                EXECUTE format('CREATE TABLE users_p%s PARTITION OF users_partitioned FOR VALUES WITH (MODULUS 8, REMAINDER %s)', i, i);
                RAISE NOTICE '分区 users_p% 创建成功', i;
            ELSE
                RAISE NOTICE '分区 users_p% 已存在', i;
            END IF;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建分区失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users_partitioned WHERE user_id = 1 LIMIT 1;
```

---

## 6. JSON vs 列

### 6.1 何时使用JSONB

```sql
-- 适合JSONB:（带错误处理）
-- 1. Schema不固定
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'events') THEN
            CREATE TABLE events (
                event_id BIGSERIAL PRIMARY KEY,
                event_type VARCHAR(50),
                event_data JSONB  -- 不同事件类型有不同字段
            );
            RAISE NOTICE '表 events 创建成功';
        ELSE
            RAISE NOTICE '表 events 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 events 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 2. 稀疏数据（大部分字段为NULL）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'products') THEN
            CREATE TABLE products (
                product_id BIGSERIAL PRIMARY KEY,
                name VARCHAR(200),
                specs JSONB  -- 不同产品类型有不同规格
            );
            RAISE NOTICE '表 products 创建成功';
        ELSE
            RAISE NOTICE '表 products 已存在';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 products 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM events WHERE event_data->>'type' = 'click' LIMIT 10;
```

-- 不适合JSONB:
-- 1. 高频查询字段
-- 2. 需要JOIN的字段
-- 3. 需要强类型约束

-- 混合方案
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,     -- 列
    category_id INT NOT NULL,       -- 列（需要JOIN）
    price NUMERIC(10,2) NOT NULL,   -- 列（需要索引和聚合）
    specs JSONB                     -- JSONB（灵活属性）
);

```

---

## 7. 命名规范

```sql
-- 表名: 复数、小写、下划线
-- users, order_items, product_categories

-- 列名: 单数、小写、下划线
-- user_id, first_name, created_at

-- 索引: idx_表名_列名（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'users') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_users_email') THEN
                CREATE INDEX idx_users_email ON users(email);
                RAISE NOTICE '索引 idx_users_email 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_users_email 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 users 不存在，跳过索引创建';
        END IF;

        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'orders') THEN
            IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_orders_user_date') THEN
                CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);
                RAISE NOTICE '索引 idx_orders_user_date 创建成功';
            ELSE
                RAISE NOTICE '索引 idx_orders_user_date 已存在';
            END IF;
        ELSE
            RAISE NOTICE '表 orders 不存在，跳过索引创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 约束:
-- PK: 表名_pkey (自动)
-- FK: fk_表名_引用表
-- UK: uk_表名_列名
-- CK: ck_表名_描述

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM users WHERE email = 'test@example.com' LIMIT 1;
```

ALTER TABLE orders ADD CONSTRAINT fk_orders_users
    FOREIGN KEY (user_id) REFERENCES users(user_id);

ALTER TABLE products ADD CONSTRAINT ck_products_price_positive
    CHECK (price >= 0);

```

---

**完成**: PostgreSQL数据建模最佳实践
**字数**: ~10,000字
**涵盖**: 主键、外键、索引、反规范化、分区、JSONB、命名规范
