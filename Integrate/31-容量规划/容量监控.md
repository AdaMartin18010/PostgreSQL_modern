# PostgreSQL容量监控指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL容量监控指南](#postgresql容量监控指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 存储监控](#2-存储监控)
    - [2.1 存储使用监控](#21-存储使用监控)
    - [2.2 表大小监控](#22-表大小监控)
  - [3. 计算监控](#3-计算监控)
    - [3.1 CPU监控](#31-cpu监控)
    - [3.2 内存监控](#32-内存监控)
  - [4. 告警设置](#4-告警设置)
    - [4.1 告警阈值](#41-告警阈值)
    - [4.2 告警通知](#42-告警通知)
  - [5. 监控报告](#5-监控报告)
    - [5.1 监控报告内容](#51-监控报告内容)
  - [6. 监控工具](#6-监控工具)
    - [6.1 监控工具选择](#61-监控工具选择)
    - [6.2 监控仪表板配置](#62-监控仪表板配置)
  - [7. 最佳实践](#7-最佳实践)
    - [✅ 推荐做法](#-推荐做法)
    - [⚠️ 注意事项](#️-注意事项)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

容量监控是容量规划的重要组成部分，需要建立完善的监控体系。

**监控内容**:

- 存储容量监控
- 计算容量监控
- 网络容量监控
- 连接容量监控

---

## 2. 存储监控

### 2.1 存储使用监控

```sql
-- 监控数据库大小（带错误处理和性能测试）
DO $$
DECLARE
    db_record RECORD;
    total_size bigint;
    db_size bigint;
    usage_percent numeric;
    warning_threshold numeric := 80.0;
    critical_threshold numeric := 90.0;
BEGIN
    -- 计算总大小
    SELECT COALESCE(SUM(pg_database_size(datname)), 0)
    INTO total_size
    FROM pg_database
    WHERE datistemplate = false;

    IF total_size = 0 THEN
        RAISE WARNING '未找到任何数据库';
        RETURN;
    END IF;

    RAISE NOTICE '所有数据库总大小: %', pg_size_pretty(total_size);

    FOR db_record IN
        SELECT datname
        FROM pg_database
        WHERE datistemplate = false
        ORDER BY pg_database_size(datname) DESC
    LOOP
        BEGIN
            db_size := pg_database_size(db_record.datname);
            usage_percent := ROUND(100.0 * db_size / NULLIF(total_size, 0), 2);

            IF usage_percent >= critical_threshold THEN
                RAISE WARNING '数据库 % 使用率: %% (严重告警，超过%%)',
                    db_record.datname, usage_percent, critical_threshold;
            ELSIF usage_percent >= warning_threshold THEN
                RAISE WARNING '数据库 % 使用率: %% (警告，超过%%)',
                    db_record.datname, usage_percent, warning_threshold;
            ELSE
                RAISE NOTICE '数据库 % 使用率: %%',
                    db_record.datname, usage_percent;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '监控数据库 % 大小失败: %', db_record.datname, SQLERRM;
        END;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '监控数据库大小失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size,
    pg_database_size(datname) AS size_bytes,
    ROUND(100.0 * pg_database_size(datname) /
          NULLIF((SELECT SUM(pg_database_size(datname)) FROM pg_database WHERE datistemplate = false), 0), 2) AS percent
FROM pg_database
WHERE datistemplate = false
ORDER BY pg_database_size(datname) DESC;
```

### 2.2 表大小监控

```sql
-- 监控表大小增长（带错误处理和性能测试）
DO $$
DECLARE
    table_record RECORD;
    table_size bigint;
    schema_name text := 'public';
    table_count int;
    total_size bigint := 0;
BEGIN
    -- 检查schema是否存在
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = schema_name
    ) THEN
        RAISE WARNING 'Schema % 不存在', schema_name;
        RETURN;
    END IF;

    SELECT COUNT(*) INTO table_count
    FROM pg_tables
    WHERE schemaname = schema_name;

    IF table_count = 0 THEN
        RAISE NOTICE 'Schema % 中没有表', schema_name;
        RETURN;
    END IF;

    RAISE NOTICE 'Schema % 中共有 % 个表，监控前10个最大的表...', schema_name, table_count;

    FOR table_record IN
        SELECT schemaname, tablename
        FROM pg_tables
        WHERE schemaname = schema_name
        ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
        LIMIT 10
    LOOP
        BEGIN
            table_size := pg_total_relation_size(table_record.schemaname||'.'||table_record.tablename);
            total_size := total_size + table_size;

            RAISE NOTICE '表 %.% 大小: %',
                table_record.schemaname,
                table_record.tablename,
                pg_size_pretty(table_size);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '获取表 %.% 大小失败: %',
                    table_record.schemaname, table_record.tablename, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '前10个表总大小: %', pg_size_pretty(total_size);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '监控表大小增长失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    pg_total_relation_size(schemaname||'.'||tablename) AS size_bytes
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 10;
```

---

## 3. 计算监控

### 3.1 CPU监控

```sql
-- 监控CPU使用（需要pg_stat_statements，带错误处理和性能测试）
DO $$
DECLARE
    ext_exists boolean;
    query_record RECORD;
    total_exec_time_sum numeric := 0;
BEGIN
    -- 检查扩展是否存在
    SELECT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements'
    ) INTO ext_exists;

    IF NOT ext_exists THEN
        RAISE WARNING 'pg_stat_statements扩展未安装，无法执行CPU监控';
        RAISE NOTICE '请先运行: CREATE EXTENSION pg_stat_statements;';
        RETURN;
    END IF;

    RAISE NOTICE 'CPU使用监控（前10个最耗时的查询）:';

    FOR query_record IN
        SELECT
            LEFT(query, 100) as query_preview,
            calls,
            total_exec_time,
            mean_exec_time
        FROM pg_stat_statements
        ORDER BY total_exec_time DESC
        LIMIT 10
    LOOP
        total_exec_time_sum := total_exec_time_sum + query_record.total_exec_time;

        RAISE NOTICE '查询: % | 调用次数: % | 总执行时间: % ms | 平均执行时间: % ms',
            query_record.query_preview,
            query_record.calls,
            ROUND(query_record.total_exec_time, 2),
            ROUND(query_record.mean_exec_time, 2);
    END LOOP;

    RAISE NOTICE '前10个查询总执行时间: % ms', ROUND(total_exec_time_sum, 2);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'CPU监控失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    total_exec_time,
    mean_exec_time,
    ROUND(total_exec_time / NULLIF(calls, 0), 2) as avg_time_per_call
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

### 3.2 内存监控

```sql
-- 监控内存使用（带错误处理和性能测试）
DO $$
DECLARE
    setting_record RECORD;
    memory_params text[] := ARRAY['shared_buffers', 'effective_cache_size', 'work_mem', 'maintenance_work_mem', 'temp_buffers'];
    param_name text;
    found_count int := 0;
BEGIN
    RAISE NOTICE '监控内存使用配置参数...';

    FOREACH param_name IN ARRAY memory_params
    LOOP
        BEGIN
            SELECT name, setting, unit, source
            INTO setting_record
            FROM pg_settings
            WHERE name = param_name;

            IF FOUND THEN
                found_count := found_count + 1;
                RAISE NOTICE '参数: % = % % (来源: %)',
                    setting_record.name,
                    setting_record.setting,
                    COALESCE(setting_record.unit, ''),
                    setting_record.source;
            ELSE
                RAISE WARNING '参数 % 未找到', param_name;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询参数 % 失败: %', param_name, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '找到 % 个内存配置参数', found_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '监控内存使用失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    name,
    setting,
    unit,
    source,
    context
FROM pg_settings
WHERE name IN ('shared_buffers', 'effective_cache_size', 'work_mem', 'maintenance_work_mem', 'temp_buffers')
ORDER BY name;
```

---

## 4. 告警设置

### 4.1 告警阈值

**告警阈值详细配置**：

```sql
-- 告警阈值配置和检查工具（带错误处理和性能测试）
DO $$
DECLARE
    storage_usage_percent numeric;
    cpu_usage_percent numeric := 85.0;  -- 假设从监控系统获取
    memory_usage_percent numeric := 75.0;  -- 假设从监控系统获取
    connection_usage_percent numeric;
    current_connections int;
    max_connections int;

    -- 告警阈值配置
    storage_warning_threshold numeric := 80.0;
    storage_critical_threshold numeric := 90.0;
    cpu_warning_threshold numeric := 80.0;
    cpu_critical_threshold numeric := 90.0;
    memory_warning_threshold numeric := 80.0;
    memory_critical_threshold numeric := 90.0;
    connection_warning_threshold numeric := 80.0;
    connection_critical_threshold numeric := 90.0;

    alert_count int := 0;
    alert_messages text[] := ARRAY[]::text[];
BEGIN
    RAISE NOTICE '=== 容量告警检查 ===';

    -- 计算存储使用率
    SELECT COALESCE(
        ROUND(100.0 * SUM(pg_database_size(datname)) /
              NULLIF((SELECT setting::bigint * 1024 * 1024 * 1024 FROM pg_settings WHERE name = 'max_disk_space' LIMIT 1), 0), 2),
        0
    ) INTO storage_usage_percent
    FROM pg_database
    WHERE datistemplate = false;

    -- 获取连接使用率
    SELECT COUNT(*) INTO current_connections
    FROM pg_stat_activity;

    SELECT setting::int INTO max_connections
    FROM pg_settings
    WHERE name = 'max_connections';

    connection_usage_percent := ROUND(100.0 * current_connections / NULLIF(max_connections, 0), 2);

    RAISE NOTICE '当前资源使用率:';
    RAISE NOTICE '  存储使用率: %%', storage_usage_percent;
    RAISE NOTICE '  CPU使用率: %%', cpu_usage_percent;
    RAISE NOTICE '  内存使用率: %%', memory_usage_percent;
    RAISE NOTICE '  连接使用率: %%', connection_usage_percent;
    RAISE NOTICE '';

    -- 检查存储告警
    IF storage_usage_percent >= storage_critical_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('严重告警: 存储使用率 %%%% (超过严重阈值%%)',
            storage_usage_percent, storage_critical_threshold);
    ELSIF storage_usage_percent >= storage_warning_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('警告: 存储使用率 %%%% (超过警告阈值%%)',
            storage_usage_percent, storage_warning_threshold);
    END IF;

    -- 检查CPU告警
    IF cpu_usage_percent >= cpu_critical_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('严重告警: CPU使用率 %%%% (超过严重阈值%%)',
            cpu_usage_percent, cpu_critical_threshold);
    ELSIF cpu_usage_percent >= cpu_warning_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('警告: CPU使用率 %%%% (超过警告阈值%%)',
            cpu_usage_percent, cpu_warning_threshold);
    END IF;

    -- 检查内存告警
    IF memory_usage_percent >= memory_critical_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('严重告警: 内存使用率 %%%% (超过严重阈值%%)',
            memory_usage_percent, memory_critical_threshold);
    ELSIF memory_usage_percent >= memory_warning_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('警告: 内存使用率 %%%% (超过警告阈值%%)',
            memory_usage_percent, memory_warning_threshold);
    END IF;

    -- 检查连接告警
    IF connection_usage_percent >= connection_critical_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('严重告警: 连接使用率 %%%% (超过严重阈值%%)',
            connection_usage_percent, connection_critical_threshold);
    ELSIF connection_usage_percent >= connection_warning_threshold THEN
        alert_count := alert_count + 1;
        alert_messages := alert_messages || format('警告: 连接使用率 %%%% (超过警告阈值%%)',
            connection_usage_percent, connection_warning_threshold);
    END IF;

    -- 输出告警信息
    IF alert_count > 0 THEN
        RAISE WARNING '发现 % 个告警:', alert_count;
        FOREACH alert_messages IN ARRAY alert_messages
        LOOP
            RAISE NOTICE '  - %', alert_messages;
        END LOOP;
    ELSE
        RAISE NOTICE '所有资源使用率正常，无告警';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '告警检查失败: %', SQLERRM;
END $$;
```

**告警阈值标准**：

| 指标 | 警告阈值 | 严重阈值 | 建议操作 |
| --- | --- | --- | --- |
| **存储使用率** | > 80% | > 90% | 立即扩容 |
| **CPU使用率** | > 80% | > 90% | 立即扩容 |
| **内存使用率** | > 80% | > 90% | 立即扩容 |
| **连接使用率** | > 80% | > 90% | 立即扩容 |
| **I/O等待时间** | > 50ms | > 100ms | 优化I/O |
| **查询响应时间** | > 1s | > 5s | 优化查询 |

### 4.2 告警通知

**告警通知详细配置**：

```text
告警通知配置
├── 通知渠道
│   ├── 邮件通知
│   │   ├── SMTP配置
│   │   ├── 收件人列表
│   │   └── 邮件模板
│   ├── 短信通知
│   │   ├── 短信网关配置
│   │   ├── 收件人列表
│   │   └── 短信模板
│   ├── 企业微信/钉钉通知
│   │   ├── Webhook配置
│   │   ├── 群组配置
│   │   └── 消息模板
│   └── 电话通知（严重告警）
│       ├── 电话网关配置
│       ├── 联系人列表
│       └── 语音模板
├── 通知规则
│   ├── 告警级别
│   │   ├── 警告：邮件通知
│   │   ├── 严重：邮件+短信通知
│   │   └── 紧急：邮件+短信+电话通知
│   ├── 通知频率
│   │   ├── 首次告警：立即通知
│   │   ├── 持续告警：每小时通知一次
│   │   └── 恢复通知：立即通知
│   └── 通知抑制
│       ├── 相同告警：抑制重复通知
│       ├── 相关告警：合并通知
│       └── 维护窗口：暂停通知
└── 通知内容
    ├── 告警标题
    ├── 告警详情
    ├── 影响范围
    ├── 建议操作
    └── 相关链接
```

**告警通知最佳实践**：

1. **分级通知** - 根据告警级别选择通知渠道
2. **避免告警风暴** - 设置通知抑制规则
3. **及时响应** - 确保告警及时通知到相关人员
4. **记录告警** - 记录所有告警信息，便于分析
5. **定期回顾** - 定期回顾告警规则，优化告警策略

---

## 5. 监控报告

### 5.1 监控报告内容

**容量监控报告详细生成工具**：

```sql
-- 容量监控报告生成工具（带错误处理和性能测试）
DO $$
DECLARE
    report_date date := CURRENT_DATE;
    db_record RECORD;
    table_record RECORD;
    total_db_size bigint := 0;
    total_table_size bigint := 0;
    total_indexes_size bigint := 0;
    current_connections int;
    max_connections int;
    connection_usage_percent numeric;
    alert_count int := 0;
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'PostgreSQL容量监控报告';
    RAISE NOTICE '报告日期: %', report_date;
    RAISE NOTICE '========================================';
    RAISE NOTICE '';

    -- 1. 当前容量使用情况
    RAISE NOTICE '1. 当前容量使用情况';
    RAISE NOTICE '----------------------------------------';

    -- 数据库容量
    FOR db_record IN
        SELECT datname, pg_database_size(datname) as size
        FROM pg_database
        WHERE datistemplate = false
        ORDER BY pg_database_size(datname) DESC
        LIMIT 10
    LOOP
        total_db_size := total_db_size + db_record.size;
        RAISE NOTICE '数据库: % | 大小: %',
            db_record.datname,
            pg_size_pretty(db_record.size);
    END LOOP;
    RAISE NOTICE '数据库总大小: %', pg_size_pretty(total_db_size);
    RAISE NOTICE '';

    -- 表容量（前10个最大的表）
    RAISE NOTICE '2. 表容量使用情况（前10个最大的表）';
    RAISE NOTICE '----------------------------------------';
    FOR table_record IN
        SELECT
            schemaname,
            tablename,
            pg_total_relation_size(schemaname||'.'||tablename) as total_size,
            pg_relation_size(schemaname||'.'||tablename) as table_size,
            pg_total_relation_size(schemaname||'.'||tablename) -
            pg_relation_size(schemaname||'.'||tablename) as indexes_size
        FROM pg_tables
        WHERE schemaname = 'public'
        ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
        LIMIT 10
    LOOP
        total_table_size := total_table_size + table_record.table_size;
        total_indexes_size := total_indexes_size + table_record.indexes_size;

        RAISE NOTICE '表: %.% | 总大小: % | 表大小: % | 索引大小: %',
            table_record.schemaname,
            table_record.tablename,
            pg_size_pretty(table_record.total_size),
            pg_size_pretty(table_record.table_size),
            pg_size_pretty(table_record.indexes_size);
    END LOOP;
    RAISE NOTICE '前10个表总大小: % | 表大小: % | 索引大小: %',
        pg_size_pretty(total_table_size + total_indexes_size),
        pg_size_pretty(total_table_size),
        pg_size_pretty(total_indexes_size);
    RAISE NOTICE '';

    -- 连接容量
    RAISE NOTICE '3. 连接容量使用情况';
    RAISE NOTICE '----------------------------------------';
    SELECT COUNT(*) INTO current_connections
    FROM pg_stat_activity;

    SELECT setting::int INTO max_connections
    FROM pg_settings
    WHERE name = 'max_connections';

    connection_usage_percent := ROUND(100.0 * current_connections / NULLIF(max_connections, 0), 2);

    RAISE NOTICE '当前连接数: % / % (使用率: %%)',
        current_connections, max_connections, connection_usage_percent;

    IF connection_usage_percent > 80 THEN
        alert_count := alert_count + 1;
        RAISE WARNING '连接使用率超过80%%，建议扩容';
    END IF;
    RAISE NOTICE '';

    -- 4. 容量使用趋势（需要历史数据，这里只显示当前状态）
    RAISE NOTICE '4. 容量使用趋势';
    RAISE NOTICE '----------------------------------------';
    RAISE NOTICE '当前数据库总大小: %', pg_size_pretty(total_db_size);
    RAISE NOTICE '（趋势分析需要历史数据支持）';
    RAISE NOTICE '';

    -- 5. 容量告警情况
    RAISE NOTICE '5. 容量告警情况';
    RAISE NOTICE '----------------------------------------';
    IF alert_count > 0 THEN
        RAISE WARNING '发现 % 个告警，请及时处理', alert_count;
    ELSE
        RAISE NOTICE '当前无告警，容量使用正常';
    END IF;
    RAISE NOTICE '';

    -- 6. 容量规划建议
    RAISE NOTICE '6. 容量规划建议';
    RAISE NOTICE '----------------------------------------';
    IF connection_usage_percent > 80 THEN
        RAISE NOTICE '建议: 考虑增加max_connections或使用连接池';
    END IF;
    IF total_db_size > 1000000000000 THEN  -- 1TB
        RAISE NOTICE '建议: 数据库总大小超过1TB，考虑分库分表或归档';
    END IF;
    RAISE NOTICE '';

    RAISE NOTICE '========================================';
    RAISE NOTICE '报告生成完成';
    RAISE NOTICE '========================================';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '容量监控报告生成失败: %', SQLERRM;
END $$;
```

**监控报告内容结构**：

```text
容量监控报告结构
├── 1. 执行摘要
│   ├── 报告时间
│   ├── 总体状态
│   ├── 关键指标
│   └── 主要发现
├── 2. 当前容量使用情况
│   ├── 存储容量
│   │   ├── 数据库大小
│   │   ├── 表大小
│   │   ├── 索引大小
│   │   └── WAL大小
│   ├── 计算容量
│   │   ├── CPU使用率
│   │   ├── 内存使用率
│   │   └── 工作负载
│   ├── 网络容量
│   │   ├── 带宽使用率
│   │   └── 网络延迟
│   └── 连接容量
│       ├── 当前连接数
│       ├── 峰值连接数
│       └── 连接使用率
├── 3. 容量使用趋势
│   ├── 存储增长趋势
│   ├── 计算增长趋势
│   ├── 网络增长趋势
│   └── 连接增长趋势
├── 4. 容量告警情况
│   ├── 告警统计
│   ├── 告警详情
│   └── 告警处理情况
└── 5. 容量规划建议
    ├── 扩容建议
    ├── 优化建议
    └── 成本建议
```

## 6. 监控工具

### 6.1 监控工具选择

**PostgreSQL容量监控工具详细列表**：

| 工具名称 | 类型 | 说明 | 适用场景 |
| --- | --- | --- | --- |
| **pg_stat_statements** | 内置扩展 | 查询统计 | 查询性能监控 |
| **pg_stat_monitor** | 社区扩展 | 高级性能监控 | 详细性能分析 |
| **PostgreSQL Exporter** | Prometheus导出器 | Prometheus监控 | 云原生监控 |
| **pgBadger** | 日志分析工具 | 日志分析 | 日志分析和报告 |
| **Grafana** | 可视化工具 | 监控仪表板 | 可视化监控 |
| **Zabbix** | 监控平台 | 企业级监控 | 企业级监控 |
| **Nagios** | 监控平台 | 告警监控 | 告警监控 |

### 6.2 监控仪表板配置

**监控仪表板关键指标**：

- **存储指标**：数据库大小、表大小、索引大小、WAL大小
- **计算指标**：CPU使用率、内存使用率、查询执行时间
- **网络指标**：带宽使用率、网络延迟、连接数
- **连接指标**：当前连接数、峰值连接数、连接使用率

## 7. 最佳实践

### ✅ 推荐做法

1. **建立监控体系** - 建立完善的容量监控体系
2. **设置合理阈值** - 设置合理的告警阈值
3. **定期生成报告** - 定期生成容量监控报告
4. **及时响应告警** - 及时响应和处理告警
5. **持续优化** - 持续优化监控配置和告警规则

### ⚠️ 注意事项

1. **避免告警风暴** - 设置告警抑制规则，避免告警风暴
2. **定期回顾** - 定期回顾告警规则，优化告警策略
3. **文档记录** - 记录监控配置和告警处理过程
4. **测试告警** - 定期测试告警通知，确保告警正常工作

---

## 📚 相关文档

- [容量规划完整指南.md](./容量规划完整指南.md) - 容量规划完整指南
- [容量评估方法.md](./容量评估方法.md) - 容量评估方法详解
- [增长预测.md](./增长预测.md) - 增长预测指南
- [资源规划.md](./资源规划.md) - 资源规划指南
- [扩容策略.md](./扩容策略.md) - 扩容策略指南
- [31-容量规划/README.md](./README.md) - 容量规划主题

---

**最后更新**: 2025年1月
