# PostgreSQL容量监控指南

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL容量监控指南](#postgresql容量监控指南)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 存储监控](#2-存储监控)
    - [2.1 存储使用监控](#21-存储使用监控)
    - [2.2 表大小监控](#22-表大小监控)
  - [3. 计算监控](#3-计算监控)
    - [3.1 CPU监控](#31-cpu监控)
    - [3.2 内存监控](#32-内存监控)
  - [4. 告警设置](#4-告警设置)
    - [4.1 告警阈值](#41-告警阈值)
    - [4.2 告警通知](#42-告警通知)
  - [5. 监控报告](#5-监控报告)
    - [5.1 监控报告内容](#51-监控报告内容)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

容量监控是容量规划的重要组成部分，需要建立完善的监控体系。

**监控内容**:

- 存储容量监控
- 计算容量监控
- 网络容量监控
- 连接容量监控

---

## 2. 存储监控

### 2.1 存储使用监控

```sql
-- 监控数据库大小（带错误处理和性能测试）
DO $$
DECLARE
    db_record RECORD;
    total_size bigint;
    db_size bigint;
    usage_percent numeric;
    warning_threshold numeric := 80.0;
    critical_threshold numeric := 90.0;
BEGIN
    -- 计算总大小
    SELECT COALESCE(SUM(pg_database_size(datname)), 0)
    INTO total_size
    FROM pg_database
    WHERE datistemplate = false;

    IF total_size = 0 THEN
        RAISE WARNING '未找到任何数据库';
        RETURN;
    END IF;

    RAISE NOTICE '所有数据库总大小: %', pg_size_pretty(total_size);

    FOR db_record IN
        SELECT datname
        FROM pg_database
        WHERE datistemplate = false
        ORDER BY pg_database_size(datname) DESC
    LOOP
        BEGIN
            db_size := pg_database_size(db_record.datname);
            usage_percent := ROUND(100.0 * db_size / NULLIF(total_size, 0), 2);

            IF usage_percent >= critical_threshold THEN
                RAISE WARNING '数据库 % 使用率: %% (严重告警，超过%%)',
                    db_record.datname, usage_percent, critical_threshold;
            ELSIF usage_percent >= warning_threshold THEN
                RAISE WARNING '数据库 % 使用率: %% (警告，超过%%)',
                    db_record.datname, usage_percent, warning_threshold;
            ELSE
                RAISE NOTICE '数据库 % 使用率: %%',
                    db_record.datname, usage_percent;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '监控数据库 % 大小失败: %', db_record.datname, SQLERRM;
        END;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '监控数据库大小失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size,
    pg_database_size(datname) AS size_bytes,
    ROUND(100.0 * pg_database_size(datname) /
          NULLIF((SELECT SUM(pg_database_size(datname)) FROM pg_database WHERE datistemplate = false), 0), 2) AS percent
FROM pg_database
WHERE datistemplate = false
ORDER BY pg_database_size(datname) DESC;
```

### 2.2 表大小监控

```sql
-- 监控表大小增长（带错误处理和性能测试）
DO $$
DECLARE
    table_record RECORD;
    table_size bigint;
    schema_name text := 'public';
    table_count int;
    total_size bigint := 0;
BEGIN
    -- 检查schema是否存在
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = schema_name
    ) THEN
        RAISE WARNING 'Schema % 不存在', schema_name;
        RETURN;
    END IF;

    SELECT COUNT(*) INTO table_count
    FROM pg_tables
    WHERE schemaname = schema_name;

    IF table_count = 0 THEN
        RAISE NOTICE 'Schema % 中没有表', schema_name;
        RETURN;
    END IF;

    RAISE NOTICE 'Schema % 中共有 % 个表，监控前10个最大的表...', schema_name, table_count;

    FOR table_record IN
        SELECT schemaname, tablename
        FROM pg_tables
        WHERE schemaname = schema_name
        ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
        LIMIT 10
    LOOP
        BEGIN
            table_size := pg_total_relation_size(table_record.schemaname||'.'||table_record.tablename);
            total_size := total_size + table_size;

            RAISE NOTICE '表 %.% 大小: %',
                table_record.schemaname,
                table_record.tablename,
                pg_size_pretty(table_size);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '获取表 %.% 大小失败: %',
                    table_record.schemaname, table_record.tablename, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '前10个表总大小: %', pg_size_pretty(total_size);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '监控表大小增长失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    pg_total_relation_size(schemaname||'.'||tablename) AS size_bytes
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 10;
```

---

## 3. 计算监控

### 3.1 CPU监控

```sql
-- 监控CPU使用（需要pg_stat_statements，带错误处理和性能测试）
DO $$
DECLARE
    ext_exists boolean;
    query_record RECORD;
    total_exec_time_sum numeric := 0;
BEGIN
    -- 检查扩展是否存在
    SELECT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements'
    ) INTO ext_exists;

    IF NOT ext_exists THEN
        RAISE WARNING 'pg_stat_statements扩展未安装，无法执行CPU监控';
        RAISE NOTICE '请先运行: CREATE EXTENSION pg_stat_statements;';
        RETURN;
    END IF;

    RAISE NOTICE 'CPU使用监控（前10个最耗时的查询）:';

    FOR query_record IN
        SELECT
            LEFT(query, 100) as query_preview,
            calls,
            total_exec_time,
            mean_exec_time
        FROM pg_stat_statements
        ORDER BY total_exec_time DESC
        LIMIT 10
    LOOP
        total_exec_time_sum := total_exec_time_sum + query_record.total_exec_time;

        RAISE NOTICE '查询: % | 调用次数: % | 总执行时间: % ms | 平均执行时间: % ms',
            query_record.query_preview,
            query_record.calls,
            ROUND(query_record.total_exec_time, 2),
            ROUND(query_record.mean_exec_time, 2);
    END LOOP;

    RAISE NOTICE '前10个查询总执行时间: % ms', ROUND(total_exec_time_sum, 2);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'CPU监控失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    total_exec_time,
    mean_exec_time,
    ROUND(total_exec_time / NULLIF(calls, 0), 2) as avg_time_per_call
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

### 3.2 内存监控

```sql
-- 监控内存使用（带错误处理和性能测试）
DO $$
DECLARE
    setting_record RECORD;
    memory_params text[] := ARRAY['shared_buffers', 'effective_cache_size', 'work_mem', 'maintenance_work_mem', 'temp_buffers'];
    param_name text;
    found_count int := 0;
BEGIN
    RAISE NOTICE '监控内存使用配置参数...';

    FOREACH param_name IN ARRAY memory_params
    LOOP
        BEGIN
            SELECT name, setting, unit, source
            INTO setting_record
            FROM pg_settings
            WHERE name = param_name;

            IF FOUND THEN
                found_count := found_count + 1;
                RAISE NOTICE '参数: % = % % (来源: %)',
                    setting_record.name,
                    setting_record.setting,
                    COALESCE(setting_record.unit, ''),
                    setting_record.source;
            ELSE
                RAISE WARNING '参数 % 未找到', param_name;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询参数 % 失败: %', param_name, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '找到 % 个内存配置参数', found_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '监控内存使用失败: %', SQLERRM;
END $$;

EXPLAIN ANALYZE
SELECT
    name,
    setting,
    unit,
    source,
    context
FROM pg_settings
WHERE name IN ('shared_buffers', 'effective_cache_size', 'work_mem', 'maintenance_work_mem', 'temp_buffers')
ORDER BY name;
```

---

## 4. 告警设置

### 4.1 告警阈值

```text
- 存储使用率 > 80%：警告
- 存储使用率 > 90%：严重
- CPU使用率 > 80%：警告
- 连接数使用率 > 80%：警告
```

### 4.2 告警通知

```text
- 邮件通知
- 短信通知
- 企业微信/钉钉通知
```

---

## 5. 监控报告

### 5.1 监控报告内容

```text
- 当前容量使用情况
- 容量使用趋势
- 容量告警情况
- 容量规划建议
```

---

## 📚 相关文档

- [容量规划完整指南.md](./容量规划完整指南.md) - 容量规划完整指南
- [容量评估方法.md](./容量评估方法.md) - 容量评估方法详解
- [31-容量规划/README.md](./README.md) - 容量规划主题

---

**最后更新**: 2025年1月
