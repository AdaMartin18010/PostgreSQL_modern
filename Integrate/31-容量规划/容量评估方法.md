# PostgreSQL容量评估方法

> **创建日期**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **难度等级**: ⭐⭐⭐ 中级

---

## 📋 目录

- [PostgreSQL容量评估方法](#postgresql容量评估方法)
  - [📋 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 存储容量评估](#2-存储容量评估)
    - [2.1 数据库大小](#21-数据库大小)
    - [2.2 表大小](#22-表大小)
  - [3. 计算容量评估](#3-计算容量评估)
    - [3.1 CPU使用率](#31-cpu使用率)
    - [3.2 内存使用率](#32-内存使用率)
  - [4. 网络容量评估](#4-网络容量评估)
    - [4.1 网络流量](#41-网络流量)
    - [4.2 连接数](#42-连接数)
  - [5. 容量报告](#5-容量报告)
    - [5.1 容量报告模板](#51-容量报告模板)
  - [📚 相关文档](#-相关文档)

---

## 1. 概述

容量评估是容量规划的基础，需要准确评估当前容量使用情况。

**评估内容**:

- 存储容量
- 计算容量
- 网络容量
- 连接容量

---

## 2. 存储容量评估

### 2.1 数据库大小

```sql
-- 查看所有数据库大小（带错误处理和性能测试）
DO $$
DECLARE
    db_record RECORD;
    total_size bigint := 0;
    db_count int := 0;
BEGIN
    RAISE NOTICE '开始评估所有数据库大小...';

    FOR db_record IN
        SELECT datname
        FROM pg_database
        WHERE datistemplate = false
        ORDER BY pg_database_size(datname) DESC
    LOOP
        BEGIN
            db_count := db_count + 1;
            total_size := total_size + pg_database_size(db_record.datname);

            RAISE NOTICE '数据库 % 大小: %',
                db_record.datname,
                pg_size_pretty(pg_database_size(db_record.datname));
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '评估数据库 % 大小失败: %', db_record.datname, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '评估完成: % 个数据库，总大小: %', db_count, pg_size_pretty(total_size);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '数据库大小评估失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size,
    pg_database_size(datname) AS size_bytes
FROM pg_database
WHERE datistemplate = false
ORDER BY pg_database_size(datname) DESC;
```

### 2.2 表大小

```sql
-- 查看表大小（带错误处理和性能测试）
DO $$
DECLARE
    table_record RECORD;
    schema_name text := 'public';
    total_size bigint;
    table_size bigint;
    indexes_size bigint;
    total_total_size bigint := 0;
    total_table_size bigint := 0;
    total_indexes_size bigint := 0;
BEGIN
    -- 检查schema是否存在
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.schemata WHERE schema_name = schema_name
    ) THEN
        RAISE WARNING 'Schema % 不存在', schema_name;
        RETURN;
    END IF;

    RAISE NOTICE '开始评估Schema % 中的表大小...', schema_name;

    FOR table_record IN
        SELECT schemaname, tablename
        FROM pg_tables
        WHERE schemaname = schema_name
        ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
    LOOP
        BEGIN
            total_size := pg_total_relation_size(table_record.schemaname||'.'||table_record.tablename);
            table_size := pg_relation_size(table_record.schemaname||'.'||table_record.tablename);
            indexes_size := total_size - table_size;

            total_total_size := total_total_size + total_size;
            total_table_size := total_table_size + table_size;
            total_indexes_size := total_indexes_size + indexes_size;

            RAISE NOTICE '表 %.% - 总大小: %, 表大小: %, 索引大小: %',
                table_record.schemaname,
                table_record.tablename,
                pg_size_pretty(total_size),
                pg_size_pretty(table_size),
                pg_size_pretty(indexes_size);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '评估表 %.% 大小失败: %',
                    table_record.schemaname, table_record.tablename, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '评估完成 - 总大小: %, 表大小: %, 索引大小: %',
        pg_size_pretty(total_total_size),
        pg_size_pretty(total_table_size),
        pg_size_pretty(total_indexes_size);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '表大小评估失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_total_relation_size(schemaname||'.'||tablename) AS total_size_bytes,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_relation_size(schemaname||'.'||tablename) AS table_size_bytes,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS indexes_size,
    (pg_total_relation_size(schemaname||'.'||tablename) -
     pg_relation_size(schemaname||'.'||tablename)) AS indexes_size_bytes
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## 3. 计算容量评估

### 3.1 CPU使用率

```sql
-- 查看CPU使用情况（需要pg_stat_statements，带错误处理和性能测试）
DO $$
DECLARE
    ext_exists boolean;
    query_record RECORD;
    total_cpu_time numeric := 0;
BEGIN
    -- 检查扩展是否存在
    SELECT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'pg_stat_statements'
    ) INTO ext_exists;

    IF NOT ext_exists THEN
        RAISE WARNING 'pg_stat_statements扩展未安装，无法评估CPU使用情况';
        RAISE NOTICE '请先运行: CREATE EXTENSION pg_stat_statements;';
        RETURN;
    END IF;

    RAISE NOTICE '开始评估CPU使用情况（前10个最耗时的查询）...';

    FOR query_record IN
        SELECT
            LEFT(query, 100) as query_preview,
            calls,
            total_exec_time,
            mean_exec_time
        FROM pg_stat_statements
        ORDER BY total_exec_time DESC
        LIMIT 10
    LOOP
        total_cpu_time := total_cpu_time + query_record.total_exec_time;

        RAISE NOTICE '查询: % | 调用次数: % | 总执行时间: % ms | 平均执行时间: % ms',
            query_record.query_preview,
            query_record.calls,
            ROUND(query_record.total_exec_time, 2),
            ROUND(query_record.mean_exec_time, 2);
    END LOOP;

    RAISE NOTICE '评估完成 - 前10个查询总CPU时间: % ms', ROUND(total_cpu_time, 2);
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'CPU使用情况评估失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    total_exec_time,
    mean_exec_time,
    ROUND(total_exec_time / NULLIF(calls, 0), 2) as avg_time_per_call
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

### 3.2 内存使用率

```sql
-- 查看共享内存使用（带错误处理和性能测试）
DO $$
DECLARE
    setting_record RECORD;
    memory_params text[] := ARRAY['shared_buffers', 'effective_cache_size', 'work_mem'];
    param_name text;
    found_count int := 0;
    total_shared_memory bigint := 0;
BEGIN
    RAISE NOTICE '开始评估共享内存使用情况...';

    FOREACH param_name IN ARRAY memory_params
    LOOP
        BEGIN
            SELECT name, setting, unit, source
            INTO setting_record
            FROM pg_settings
            WHERE name = param_name;

            IF FOUND THEN
                found_count := found_count + 1;

                -- 转换shared_buffers为字节（用于计算）
                IF param_name = 'shared_buffers' THEN
                    -- setting通常是文本格式（如'8GB'），这里只记录
                    RAISE NOTICE '参数: % = % % (来源: %)',
                        setting_record.name,
                        setting_record.setting,
                        COALESCE(setting_record.unit, ''),
                        setting_record.source;
                ELSE
                    RAISE NOTICE '参数: % = % % (来源: %)',
                        setting_record.name,
                        setting_record.setting,
                        COALESCE(setting_record.unit, ''),
                        setting_record.source;
                END IF;
            ELSE
                RAISE WARNING '参数 % 未找到', param_name;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING '查询参数 % 失败: %', param_name, SQLERRM;
        END;
    END LOOP;

    RAISE NOTICE '评估完成 - 找到 % 个内存配置参数', found_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '共享内存使用评估失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    name,
    setting,
    unit,
    source,
    context
FROM pg_settings
WHERE name IN ('shared_buffers', 'effective_cache_size', 'work_mem')
ORDER BY name;
```

---

## 4. 网络容量评估

### 4.1 网络流量

```text
监控网络流量
- 入站流量
- 出站流量
- 峰值流量
```

### 4.2 连接数

```sql
-- 查看连接数使用（带错误处理和性能测试）
DO $$
DECLARE
    current_connections int;
    max_connections int;
    usage_percent numeric;
    warning_threshold numeric := 80.0;
    critical_threshold numeric := 90.0;
BEGIN
    -- 获取当前连接数
    SELECT COUNT(*) INTO current_connections
    FROM pg_stat_activity;

    -- 获取最大连接数
    SELECT setting::int INTO max_connections
    FROM pg_settings
    WHERE name = 'max_connections';

    IF max_connections IS NULL OR max_connections = 0 THEN
        RAISE EXCEPTION '无法获取最大连接数配置';
    END IF;

    -- 计算使用率
    usage_percent := ROUND(100.0 * current_connections / NULLIF(max_connections, 0), 2);

    RAISE NOTICE '当前连接数: % / % (使用率: %%)',
        current_connections, max_connections, usage_percent;

    -- 检查阈值
    IF usage_percent >= critical_threshold THEN
        RAISE WARNING '连接数使用率: %% (严重告警，超过%%)',
            usage_percent, critical_threshold;
    ELSIF usage_percent >= warning_threshold THEN
        RAISE WARNING '连接数使用率: %% (警告，超过%%)',
            usage_percent, warning_threshold;
    ELSE
        RAISE NOTICE '连接数使用率: %% (正常)', usage_percent;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '评估连接数使用失败: %', SQLERRM;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    COUNT(*) AS current_connections,
    (SELECT setting::int FROM pg_settings WHERE name = 'max_connections') AS max_connections,
    ROUND(100.0 * COUNT(*) / NULLIF((SELECT setting::int FROM pg_settings WHERE name = 'max_connections'), 0), 2) AS usage_percent
FROM pg_stat_activity;
```

<｜tool▁calls▁begin｜><｜tool▁call▁begin｜>
grep

---

## 5. 容量报告

### 5.1 容量报告模板

**容量评估报告详细模板**：

```sql
-- 容量评估报告生成工具（带错误处理和性能测试）
DO $$
DECLARE
    report_date date := CURRENT_DATE;
    db_record RECORD;
    table_record RECORD;
    total_db_size bigint := 0;
    total_table_size bigint := 0;
    total_indexes_size bigint := 0;
    current_connections int;
    max_connections int;
    connection_usage_percent numeric;
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'PostgreSQL容量评估报告';
    RAISE NOTICE '报告日期: %', report_date;
    RAISE NOTICE '========================================';
    RAISE NOTICE '';

    -- 1. 数据库容量评估
    RAISE NOTICE '1. 数据库容量评估';
    RAISE NOTICE '----------------------------------------';
    FOR db_record IN
        SELECT datname, pg_database_size(datname) as size
        FROM pg_database
        WHERE datistemplate = false
        ORDER BY pg_database_size(datname) DESC
    LOOP
        total_db_size := total_db_size + db_record.size;
        RAISE NOTICE '数据库: % | 大小: %',
            db_record.datname,
            pg_size_pretty(db_record.size);
    END LOOP;
    RAISE NOTICE '数据库总大小: %', pg_size_pretty(total_db_size);
    RAISE NOTICE '';

    -- 2. 表容量评估
    RAISE NOTICE '2. 表容量评估（前10个最大的表）';
    RAISE NOTICE '----------------------------------------';
    FOR table_record IN
        SELECT
            schemaname,
            tablename,
            pg_total_relation_size(schemaname||'.'||tablename) as total_size,
            pg_relation_size(schemaname||'.'||tablename) as table_size,
            pg_total_relation_size(schemaname||'.'||tablename) -
            pg_relation_size(schemaname||'.'||tablename) as indexes_size
        FROM pg_tables
        WHERE schemaname = 'public'
        ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
        LIMIT 10
    LOOP
        total_table_size := total_table_size + table_record.table_size;
        total_indexes_size := total_indexes_size + table_record.indexes_size;

        RAISE NOTICE '表: %.% | 总大小: % | 表大小: % | 索引大小: %',
            table_record.schemaname,
            table_record.tablename,
            pg_size_pretty(table_record.total_size),
            pg_size_pretty(table_record.table_size),
            pg_size_pretty(table_record.indexes_size);
    END LOOP;
    RAISE NOTICE '前10个表总大小: % | 表大小: % | 索引大小: %',
        pg_size_pretty(total_table_size + total_indexes_size),
        pg_size_pretty(total_table_size),
        pg_size_pretty(total_indexes_size);
    RAISE NOTICE '';

    -- 3. 连接容量评估
    RAISE NOTICE '3. 连接容量评估';
    RAISE NOTICE '----------------------------------------';
    SELECT COUNT(*) INTO current_connections
    FROM pg_stat_activity;

    SELECT setting::int INTO max_connections
    FROM pg_settings
    WHERE name = 'max_connections';

    connection_usage_percent := ROUND(100.0 * current_connections / NULLIF(max_connections, 0), 2);

    RAISE NOTICE '当前连接数: % / % (使用率: %%)',
        current_connections, max_connections, connection_usage_percent;

    IF connection_usage_percent > 80 THEN
        RAISE WARNING '连接使用率超过80%%，建议扩容';
    END IF;
    RAISE NOTICE '';

    -- 4. 容量评估总结
    RAISE NOTICE '4. 容量评估总结';
    RAISE NOTICE '----------------------------------------';
    RAISE NOTICE '数据库总大小: %', pg_size_pretty(total_db_size);
    RAISE NOTICE '连接使用率: %%', connection_usage_percent;
    RAISE NOTICE '';
    RAISE NOTICE '========================================';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '容量评估报告生成失败: %', SQLERRM;
END $$;
```

**容量报告内容结构**：

```text
容量评估报告结构
├── 1. 执行摘要
│   ├── 评估目的
│   ├── 评估范围
│   ├── 评估时间
│   └── 主要发现
├── 2. 当前容量使用情况
│   ├── 存储容量使用
│   │   ├── 数据库大小
│   │   ├── 表大小
│   │   ├── 索引大小
│   │   └── WAL大小
│   ├── 计算容量使用
│   │   ├── CPU使用率
│   │   ├── 内存使用率
│   │   └── 工作负载
│   ├── 网络容量使用
│   │   ├── 带宽使用率
│   │   └── 网络延迟
│   └── 连接容量使用
│       ├── 当前连接数
│       ├── 峰值连接数
│       └── 连接使用率
├── 3. 容量使用趋势
│   ├── 存储增长趋势
│   ├── 计算增长趋势
│   ├── 网络增长趋势
│   └── 连接增长趋势
├── 4. 容量瓶颈识别
│   ├── 存储瓶颈
│   ├── 计算瓶颈
│   ├── 网络瓶颈
│   └── 连接瓶颈
├── 5. 容量增长预测
│   ├── 短期预测（1-3个月）
│   ├── 中期预测（3-6个月）
│   └── 长期预测（6-12个月）
└── 6. 容量规划建议
    ├── 扩容建议
    ├── 优化建议
    └── 成本建议
```

---

## 📚 相关文档

- [容量规划完整指南.md](./容量规划完整指南.md) - 容量规划完整指南
- [增长预测.md](./增长预测.md) - 增长预测指南
- [31-容量规划/README.md](./README.md) - 容量规划主题

---

**最后更新**: 2025年1月
