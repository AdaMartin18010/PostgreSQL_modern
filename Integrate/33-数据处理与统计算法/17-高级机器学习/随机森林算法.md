# PostgreSQL éšæœºæ£®æ—ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æœºå™¨å­¦ä¹  | é›†æˆå­¦ä¹  | å†³ç­–æ ‘
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Random Forests (Breiman), Ensemble Methods, Machine Learning

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL éšæœºæ£®æ—ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-éšæœºæ£®æ—ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [éšæœºæ£®æ—æ¦‚è¿°](#éšæœºæ£®æ—æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [æ ¸å¿ƒæ€æƒ³](#æ ¸å¿ƒæ€æƒ³)
    - [ä¼˜åŠ¿ç‰¹ç‚¹](#ä¼˜åŠ¿ç‰¹ç‚¹)
  - [1. Baggingé›†æˆ](#1-baggingé›†æˆ)
    - [1.1 Bootstrapé‡‡æ ·](#11-bootstrapé‡‡æ ·)
    - [1.2 å†³ç­–æ ‘æ„å»º](#12-å†³ç­–æ ‘æ„å»º)
  - [2. éšæœºç‰¹å¾é€‰æ‹©](#2-éšæœºç‰¹å¾é€‰æ‹©)
    - [2.1 ç‰¹å¾å­é›†é€‰æ‹©](#21-ç‰¹å¾å­é›†é€‰æ‹©)
    - [2.2 ä¿¡æ¯å¢ç›Šè®¡ç®—](#22-ä¿¡æ¯å¢ç›Šè®¡ç®—)
  - [3. é¢„æµ‹ä¸æŠ•ç¥¨](#3-é¢„æµ‹ä¸æŠ•ç¥¨)
    - [3.1 å¤šæ•°æŠ•ç¥¨](#31-å¤šæ•°æŠ•ç¥¨)
    - [3.2 æ¦‚ç‡ä¼°è®¡](#32-æ¦‚ç‡ä¼°è®¡)
  - [4. ç‰¹å¾é‡è¦æ€§](#4-ç‰¹å¾é‡è¦æ€§)
    - [4.1 åŸºå°¼é‡è¦æ€§](#41-åŸºå°¼é‡è¦æ€§)
    - [4.2 ç½®æ¢é‡è¦æ€§](#42-ç½®æ¢é‡è¦æ€§)
  - [5. OOBè¯¯å·®](#5-oobè¯¯å·®)
    - [5.1 OOBæ ·æœ¬è¯†åˆ«](#51-oobæ ·æœ¬è¯†åˆ«)
    - [5.2 OOBè¯¯å·®è®¡ç®—](#52-oobè¯¯å·®è®¡ç®—)
  - [6. å¤æ‚åº¦åˆ†æ](#6-å¤æ‚åº¦åˆ†æ)
  - [7. PostgreSQL 18 å¹¶è¡Œéšæœºæ£®æ—å¢å¼º](#7-postgresql-18-å¹¶è¡Œéšæœºæ£®æ—å¢å¼º)
    - [7.1 å¹¶è¡Œéšæœºæ£®æ—åŸç†](#71-å¹¶è¡Œéšæœºæ£®æ—åŸç†)
    - [7.2 å¹¶è¡ŒBootstrapé‡‡æ ·](#72-å¹¶è¡Œbootstrapé‡‡æ ·)
    - [7.3 å¹¶è¡Œå†³ç­–æ ‘æ„å»º](#73-å¹¶è¡Œå†³ç­–æ ‘æ„å»º)
    - [7.4 å¹¶è¡Œé¢„æµ‹æŠ•ç¥¨](#74-å¹¶è¡Œé¢„æµ‹æŠ•ç¥¨)
  - [8. å®é™…åº”ç”¨æ¡ˆä¾‹](#8-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1 åˆ†ç±»ä»»åŠ¡](#71-åˆ†ç±»ä»»åŠ¡)
    - [7.2 å›å½’ä»»åŠ¡](#72-å›å½’ä»»åŠ¡)
    - [7.3 ç‰¹å¾é€‰æ‹©](#73-ç‰¹å¾é€‰æ‹©)
    - [7.4 å¼‚å¸¸æ£€æµ‹](#74-å¼‚å¸¸æ£€æµ‹)
  - [9. PostgreSQL 18 å¹¶è¡Œéšæœºæ£®æ—æ€§èƒ½ä¼˜åŒ–](#9-postgresql-18-å¹¶è¡Œéšæœºæ£®æ—æ€§èƒ½ä¼˜åŒ–)
    - [å¹¶è¡ŒåŒ–ä¼˜åŒ–](#å¹¶è¡ŒåŒ–ä¼˜åŒ–)
    - [é‡‡æ ·ä¼˜åŒ–](#é‡‡æ ·ä¼˜åŒ–)
    - [ç‰¹å¾å­é›†ä¼˜åŒ–](#ç‰¹å¾å­é›†ä¼˜åŒ–)
    - [ç´¢å¼•ä¼˜åŒ–](#ç´¢å¼•ä¼˜åŒ–)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [å‚æ•°è°ƒä¼˜](#å‚æ•°è°ƒä¼˜)
    - [ç‰¹å¾å·¥ç¨‹](#ç‰¹å¾å·¥ç¨‹)
    - [æ¨¡å‹è¯„ä¼°](#æ¨¡å‹è¯„ä¼°)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“ˆ éšæœºæ£®æ— vs å…¶ä»–ç®—æ³•å¯¹æ¯”](#-éšæœºæ£®æ—-vs-å…¶ä»–ç®—æ³•å¯¹æ¯”)
  - [ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
    - [é—®é¢˜1ï¼šè¿‡æ‹Ÿåˆ](#é—®é¢˜1è¿‡æ‹Ÿåˆ)
    - [é—®é¢˜2ï¼šè®­ç»ƒæ…¢](#é—®é¢˜2è®­ç»ƒæ…¢)
    - [é—®é¢˜3ï¼šç‰¹å¾é‡è¦æ€§ä¸ä¸€è‡´](#é—®é¢˜3ç‰¹å¾é‡è¦æ€§ä¸ä¸€è‡´)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)

---

## éšæœºæ£®æ—æ¦‚è¿°

**éšæœºæ£®æ—ï¼ˆRandom Forestï¼‰**æ˜¯ä¸€ç§åŸºäºå†³ç­–æ ‘çš„é›†æˆå­¦ä¹ ç®—æ³•ï¼Œé€šè¿‡ç»„åˆå¤šä¸ªå†³ç­–æ ‘çš„é¢„æµ‹ç»“æœæ¥æé«˜æ¨¡å‹æ€§èƒ½ã€‚

### ç†è®ºåŸºç¡€

éšæœºæ£®æ—ç»“åˆäº†**Bagging**ï¼ˆBootstrap Aggregatingï¼‰å’Œ**éšæœºç‰¹å¾é€‰æ‹©**ä¸¤ç§æŠ€æœ¯ï¼š

1. **Bagging**: é€šè¿‡Bootstrapé‡‡æ ·è®­ç»ƒå¤šä¸ªæ¨¡å‹
2. **éšæœºç‰¹å¾é€‰æ‹©**: æ¯ä¸ªèŠ‚ç‚¹éšæœºé€‰æ‹©ç‰¹å¾å­é›†

### æ ¸å¿ƒæ€æƒ³

**ç®—æ³•æµç¨‹**:

1. ä»è®­ç»ƒé›†ä¸­æœ‰æ”¾å›æŠ½æ ·ï¼Œç”ŸæˆBootstrapæ ·æœ¬
2. å¯¹æ¯ä¸ªBootstrapæ ·æœ¬è®­ç»ƒå†³ç­–æ ‘
3. æ¯ä¸ªèŠ‚ç‚¹éšæœºé€‰æ‹©ç‰¹å¾å­é›†è¿›è¡Œåˆ†è£‚
4. é¢„æµ‹æ—¶å¯¹æ‰€æœ‰æ ‘çš„é¢„æµ‹ç»“æœè¿›è¡ŒæŠ•ç¥¨ï¼ˆåˆ†ç±»ï¼‰æˆ–å¹³å‡ï¼ˆå›å½’ï¼‰

### ä¼˜åŠ¿ç‰¹ç‚¹

| ä¼˜åŠ¿ | è¯´æ˜ |
|------|------|
| **é«˜å‡†ç¡®æ€§** | é›†æˆå¤šä¸ªæ¨¡å‹é™ä½æ–¹å·® |
| **æŠ—è¿‡æ‹Ÿåˆ** | éšæœºæ€§å‡å°‘è¿‡æ‹Ÿåˆé£é™© |
| **ç‰¹å¾é‡è¦æ€§** | å¯ä»¥è¯„ä¼°ç‰¹å¾é‡è¦æ€§ |
| **å¤„ç†ç¼ºå¤±å€¼** | å¯¹ç¼ºå¤±å€¼ç›¸å¯¹é²æ£’ |
| **å¹¶è¡ŒåŒ–** | æ ‘ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œæ˜“äºå¹¶è¡Œ |

---

## 1. Baggingé›†æˆ

### 1.1 Bootstrapé‡‡æ ·

**Bootstrapé‡‡æ ·**æ˜¯æœ‰æ”¾å›æŠ½æ ·ï¼Œæ¯ä¸ªBootstrapæ ·æœ¬å¤§å°ç­‰äºåŸå§‹è®­ç»ƒé›†ã€‚

**é‡‡æ ·æ¦‚ç‡**: æ¯ä¸ªæ ·æœ¬ä¸è¢«é€‰ä¸­çš„æ¦‚ç‡ä¸º $(1 - 1/n)^n \approx e^{-1} \approx 0.368$

```sql
-- Bootstrapé‡‡æ ·å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'rf_training_data') THEN
            RAISE WARNING 'è¡¨ rf_training_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE rf_training_data CASCADE;
        END IF;

        CREATE TABLE rf_training_data (
            id SERIAL PRIMARY KEY,
            feature1 NUMERIC NOT NULL,
            feature2 NUMERIC NOT NULL,
            feature3 NUMERIC NOT NULL,
            label INTEGER NOT NULL
        );

        -- æ’å…¥è®­ç»ƒæ•°æ®
        INSERT INTO rf_training_data (feature1, feature2, feature3, label) VALUES
            (1.0, 2.0, 3.0, 0), (1.5, 2.5, 3.5, 0),
            (2.0, 3.0, 4.0, 1), (2.5, 3.5, 4.5, 1),
            (3.0, 4.0, 5.0, 0), (3.5, 4.5, 5.5, 0);

        RAISE NOTICE 'è¡¨ rf_training_data åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥6æ¡æ•°æ®';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ rf_training_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Bootstrapé‡‡æ ·ï¼ˆç®€åŒ–ç‰ˆï¼šå±•ç¤ºé‡‡æ ·è¿‡ç¨‹ï¼‰
WITH bootstrap_samples AS (
    SELECT
        tree_id,
        id,
        feature1,
        feature2,
        feature3,
        label
    FROM (
        SELECT
            generate_series(1, 10) AS tree_id,  -- 10æ£µæ ‘
            (SELECT id FROM rf_training_data ORDER BY RANDOM() LIMIT 1) AS id
        FROM generate_series(1, 6)  -- æ¯ä¸ªBootstrapæ ·æœ¬6ä¸ªæ ·æœ¬
    ) bootstrap_ids
    JOIN rf_training_data ON bootstrap_ids.id = rf_training_data.id
)
SELECT
    tree_id,
    COUNT(*) AS sample_count,
    COUNT(DISTINCT id) AS unique_samples,
    COUNT(*) FILTER (WHERE label = 0) AS label_0_count,
    COUNT(*) FILTER (WHERE label = 1) AS label_1_count
FROM bootstrap_samples
GROUP BY tree_id
ORDER BY tree_id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) AS total_samples,
    COUNT(DISTINCT id) AS unique_samples
FROM rf_training_data;
```

### 1.2 å†³ç­–æ ‘æ„å»º

**å†³ç­–æ ‘æ„å»º**ä½¿ç”¨CARTç®—æ³•ï¼ŒåŸºäºåŸºå°¼ä¸çº¯åº¦æˆ–ä¿¡æ¯å¢ç›Šè¿›è¡Œåˆ†è£‚ã€‚

**åŸºå°¼ä¸çº¯åº¦**:
$$Gini(D) = 1 - \sum_{i=1}^{c} p_i^2$$

å…¶ä¸­ $p_i$ æ˜¯ç±»åˆ« $i$ åœ¨æ•°æ®é›† $D$ ä¸­çš„æ¯”ä¾‹ã€‚

```sql
-- å†³ç­–æ ‘èŠ‚ç‚¹åˆ†è£‚ï¼ˆåŸºäºåŸºå°¼ä¸çº¯åº¦ï¼‰
WITH node_data AS (
    SELECT
        feature1,
        feature2,
        label
    FROM rf_training_data
),
gini_impurity AS (
    SELECT
        COUNT(*) AS total,
        COUNT(*) FILTER (WHERE label = 0) AS label_0_count,
        COUNT(*) FILTER (WHERE label = 1) AS label_1_count,
        1.0 - POWER(COUNT(*) FILTER (WHERE label = 0)::NUMERIC / COUNT(*), 2) -
             POWER(COUNT(*) FILTER (WHERE label = 1)::NUMERIC / COUNT(*), 2) AS gini
    FROM node_data
),
split_candidates AS (
    SELECT
        feature1 AS split_value,
        COUNT(*) FILTER (WHERE feature1 <= AVG(feature1) OVER ()) AS left_count,
        COUNT(*) FILTER (WHERE feature1 > AVG(feature1) OVER ()) AS right_count
    FROM node_data
    GROUP BY feature1
)
SELECT
    ROUND(gini::numeric, 4) AS node_gini_impurity,
    ROUND(AVG(feature1)::numeric, 2) AS best_split_value
FROM gini_impurity
CROSS JOIN node_data
GROUP BY gini;
```

---

## 2. éšæœºç‰¹å¾é€‰æ‹©

### 2.1 ç‰¹å¾å­é›†é€‰æ‹©

**éšæœºç‰¹å¾é€‰æ‹©**åœ¨æ¯ä¸ªèŠ‚ç‚¹åˆ†è£‚æ—¶ï¼Œéšæœºé€‰æ‹© $\sqrt{p}$ ä¸ªç‰¹å¾ï¼ˆåˆ†ç±»ï¼‰æˆ– $p/3$ ä¸ªç‰¹å¾ï¼ˆå›å½’ï¼‰ï¼Œå…¶ä¸­ $p$ æ˜¯æ€»ç‰¹å¾æ•°ã€‚

```sql
-- éšæœºç‰¹å¾é€‰æ‹©å®ç°
WITH feature_count AS (
    SELECT COUNT(*) AS total_features FROM information_schema.columns
    WHERE table_name = 'rf_training_data' AND column_name LIKE 'feature%'
),
selected_features AS (
    SELECT
        tree_id,
        node_id,
        ARRAY_AGG(feature_name ORDER BY RANDOM()) AS selected_feature_subset
    FROM (
        SELECT
            generate_series(1, 10) AS tree_id,
            generate_series(1, 5) AS node_id,
            'feature' || generate_series(1, 3) AS feature_name
    ) all_features
    CROSS JOIN feature_count
    WHERE RANDOM() < SQRT(total_features)::NUMERIC / total_features
    GROUP BY tree_id, node_id
)
SELECT
    tree_id,
    node_id,
    selected_feature_subset,
    array_length(selected_feature_subset, 1) AS num_selected_features
FROM selected_features
ORDER BY tree_id, node_id;
```

### 2.2 ä¿¡æ¯å¢ç›Šè®¡ç®—

**ä¿¡æ¯å¢ç›Š**è¡¡é‡ç‰¹å¾åˆ†è£‚åä¿¡æ¯ç†µçš„å‡å°‘ï¼š

$$IG(D, A) = Entropy(D) - \sum_{v} \frac{|D_v|}{|D|} Entropy(D_v)$$

```sql
-- ä¿¡æ¯å¢ç›Šè®¡ç®—
WITH entropy_calculation AS (
    SELECT
        feature1,
        label,
        COUNT(*) AS count,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () AS proportion
    FROM rf_training_data
    GROUP BY feature1, label
),
entropy_values AS (
    SELECT
        feature1,
        -SUM(proportion * LOG(2, NULLIF(proportion, 0))) AS conditional_entropy
    FROM entropy_calculation
    GROUP BY feature1
),
overall_entropy AS (
    SELECT
        -SUM(proportion * LOG(2, NULLIF(proportion, 0))) AS base_entropy
    FROM (
        SELECT
            label,
            COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () AS proportion
        FROM rf_training_data
        GROUP BY label
    ) label_proportions
)
SELECT
    ev.feature1,
    ROUND(ev.conditional_entropy::numeric, 4) AS conditional_entropy,
    ROUND(oe.base_entropy::numeric, 4) AS base_entropy,
    ROUND((oe.base_entropy - ev.conditional_entropy)::numeric, 4) AS information_gain
FROM entropy_values ev
CROSS JOIN overall_entropy oe
ORDER BY information_gain DESC;
```

---

## 3. é¢„æµ‹ä¸æŠ•ç¥¨

### 3.1 å¤šæ•°æŠ•ç¥¨

**å¤šæ•°æŠ•ç¥¨**æ˜¯åˆ†ç±»ä»»åŠ¡ä¸­å¸¸ç”¨çš„é›†æˆç­–ç•¥ã€‚

```sql
-- éšæœºæ£®æ—é¢„æµ‹ï¼ˆå¤šæ•°æŠ•ç¥¨ï¼‰
WITH tree_predictions AS (
    SELECT
        sample_id,
        tree_id,
        predicted_label
    FROM decision_tree_predictions
),
majority_vote AS (
    SELECT
        sample_id,
        predicted_label,
        COUNT(*) AS vote_count,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY sample_id) AS vote_proportion
    FROM tree_predictions
    GROUP BY sample_id, predicted_label
),
final_prediction AS (
    SELECT
        sample_id,
        predicted_label AS final_label,
        vote_proportion AS confidence
    FROM majority_vote
    WHERE (sample_id, vote_count) IN (
        SELECT sample_id, MAX(vote_count)
        FROM majority_vote
        GROUP BY sample_id
    )
)
SELECT
    sample_id,
    final_label,
    ROUND(confidence::numeric, 4) AS prediction_confidence
FROM final_prediction
ORDER BY sample_id;
```

### 3.2 æ¦‚ç‡ä¼°è®¡

**æ¦‚ç‡ä¼°è®¡**é€šè¿‡è®¡ç®—å„ç±»åˆ«çš„å¹³å‡æ¦‚ç‡ã€‚

```sql
-- æ¦‚ç‡ä¼°è®¡
WITH tree_probabilities AS (
    SELECT
        sample_id,
        label,
        AVG(probability) AS avg_probability
    FROM tree_prediction_probabilities
    GROUP BY sample_id, label
)
SELECT
    sample_id,
    label,
    ROUND(avg_probability::numeric, 4) AS predicted_probability
FROM tree_probabilities
ORDER BY sample_id, predicted_probability DESC;
```

---

## 4. ç‰¹å¾é‡è¦æ€§

### 4.1 åŸºå°¼é‡è¦æ€§

**åŸºå°¼é‡è¦æ€§**åŸºäºç‰¹å¾åœ¨æ‰€æœ‰æ ‘ä¸­çš„åŸºå°¼ä¸çº¯åº¦å‡å°‘é‡ã€‚

```sql
-- åŸºå°¼é‡è¦æ€§è®¡ç®—
WITH feature_importance AS (
    SELECT
        feature_name,
        SUM(gini_reduction) AS total_gini_reduction,
        COUNT(*) AS split_count,
        AVG(gini_reduction) AS avg_gini_reduction
    FROM tree_splits
    GROUP BY feature_name
),
normalized_importance AS (
    SELECT
        feature_name,
        total_gini_reduction,
        total_gini_reduction / NULLIF(SUM(total_gini_reduction) OVER (), 0) AS normalized_importance
    FROM feature_importance
)
SELECT
    feature_name,
    ROUND(total_gini_reduction::numeric, 4) AS importance_score,
    ROUND(normalized_importance::numeric, 4) AS normalized_importance,
    ROUND((normalized_importance * 100)::numeric, 2) AS importance_percentage
FROM normalized_importance
ORDER BY importance_score DESC;
```

### 4.2 ç½®æ¢é‡è¦æ€§

**ç½®æ¢é‡è¦æ€§**é€šè¿‡éšæœºç½®æ¢ç‰¹å¾å€¼ï¼Œè§‚å¯Ÿæ¨¡å‹æ€§èƒ½ä¸‹é™ã€‚

```sql
-- ç½®æ¢é‡è¦æ€§è®¡ç®—
WITH original_accuracy AS (
    SELECT AVG(accuracy) AS baseline_accuracy
    FROM model_evaluation
),
permuted_importance AS (
    SELECT
        feature_name,
        AVG(accuracy) AS permuted_accuracy,
        (SELECT baseline_accuracy FROM original_accuracy) - AVG(accuracy) AS importance_score
    FROM permuted_evaluations
    GROUP BY feature_name
)
SELECT
    feature_name,
    ROUND(importance_score::numeric, 4) AS permutation_importance
FROM permuted_importance
ORDER BY importance_score DESC;
```

---

## 5. OOBè¯¯å·®

### 5.1 OOBæ ·æœ¬è¯†åˆ«

**OOBï¼ˆOut-of-Bagï¼‰æ ·æœ¬**æ˜¯åœ¨Bootstrapé‡‡æ ·ä¸­æœªè¢«é€‰ä¸­çš„æ ·æœ¬ã€‚

```sql
-- OOBæ ·æœ¬è¯†åˆ«
WITH bootstrap_samples AS (
    SELECT
        tree_id,
        id AS sample_id
    FROM bootstrap_sampling
),
oob_samples AS (
    SELECT
        td.id AS sample_id,
        td.label,
        COUNT(DISTINCT bs.tree_id) AS oob_tree_count
    FROM rf_training_data td
    LEFT JOIN bootstrap_samples bs ON td.id = bs.sample_id
    WHERE bs.tree_id IS NULL
    GROUP BY td.id, td.label
)
SELECT
    sample_id,
    label,
    oob_tree_count
FROM oob_samples
ORDER BY sample_id;
```

### 5.2 OOBè¯¯å·®è®¡ç®—

**OOBè¯¯å·®**ä½¿ç”¨OOBæ ·æœ¬è¯„ä¼°æ¨¡å‹æ€§èƒ½ï¼Œæ— éœ€å•ç‹¬çš„éªŒè¯é›†ã€‚

```sql
-- OOBè¯¯å·®è®¡ç®—
WITH oob_predictions AS (
    SELECT
        sample_id,
        label,
        MODE() WITHIN GROUP (ORDER BY predicted_label) AS oob_prediction
    FROM oob_tree_predictions
    GROUP BY sample_id, label
)
SELECT
    COUNT(*) FILTER (WHERE label != oob_prediction)::NUMERIC / COUNT(*) AS oob_error_rate,
    COUNT(*) FILTER (WHERE label = oob_prediction)::NUMERIC / COUNT(*) AS oob_accuracy
FROM oob_predictions;
```

---

## 6. å¤æ‚åº¦åˆ†æ

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
|------|-----------|-----------|
| **Bootstrapé‡‡æ ·** | $O(Bn)$ | $O(Bn)$ |
| **å†³ç­–æ ‘æ„å»º** | $O(Bn \log n \times p)$ | $O(Bn)$ |
| **é¢„æµ‹** | $O(B \log n)$ | $O(B)$ |
| **æ€»ä½“** | $O(Bn \log n \times p)$ | $O(Bn)$ |

å…¶ä¸­ $B$ æ˜¯æ ‘çš„æ•°é‡ï¼Œ$n$ æ˜¯æ ·æœ¬æ•°ï¼Œ$p$ æ˜¯ç‰¹å¾æ•°ã€‚

---

## 7. PostgreSQL 18 å¹¶è¡Œéšæœºæ£®æ—å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œéšæœºæ£®æ—è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡ŒBootstrapé‡‡æ ·ã€å†³ç­–æ ‘æ„å»ºå’Œé¢„æµ‹æŠ•ç¥¨ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡éšæœºæ£®æ—è®­ç»ƒå’Œé¢„æµ‹çš„æ€§èƒ½ã€‚

### 7.1 å¹¶è¡Œéšæœºæ£®æ—åŸç†

PostgreSQL 18 çš„å¹¶è¡Œéšæœºæ£®æ—é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æè®­ç»ƒæ•°æ®
2. **å¹¶è¡ŒBootstrapé‡‡æ ·**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡ŒBootstrapé‡‡æ ·
3. **å¹¶è¡Œæ ‘æ„å»º**ï¼šå¹¶è¡Œæ„å»ºå¤šä¸ªå†³ç­–æ ‘
4. **å¹¶è¡Œé¢„æµ‹**ï¼šå¹¶è¡Œæ‰§è¡Œé¢„æµ‹å’ŒæŠ•ç¥¨
5. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„ç»“æœ

### 7.2 å¹¶è¡ŒBootstrapé‡‡æ ·

```sql
-- PostgreSQL 18 å¹¶è¡ŒBootstrapé‡‡æ ·ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'random_forest_data') THEN
            RAISE WARNING 'è¡¨ random_forest_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒBootstrapé‡‡æ ·';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒBootstrapé‡‡æ ·';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒBootstrapé‡‡æ ·å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒBootstrapé‡‡æ ·ï¼šæœ‰æ”¾å›æŠ½æ ·
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH bootstrap_samples AS (
    SELECT
        tree_id,
        (random() * (SELECT COUNT(*) FROM random_forest_data) + 1)::INTEGER AS sample_id
    FROM generate_series(1, 100) AS tree_id  -- 100æ£µæ ‘
    CROSS JOIN generate_series(1, (SELECT COUNT(*) FROM random_forest_data)) AS sample_idx
)
SELECT
    tree_id,
    sample_id,
    COUNT(*) AS sample_count
FROM bootstrap_samples
GROUP BY tree_id, sample_id
ORDER BY tree_id, sample_id
LIMIT 1000;
```

### 7.3 å¹¶è¡Œå†³ç­–æ ‘æ„å»º

```sql
-- PostgreSQL 18 å¹¶è¡Œå†³ç­–æ ‘æ„å»ºï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'bootstrap_samples') THEN
            RAISE WARNING 'è¡¨ bootstrap_samples ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå†³ç­–æ ‘æ„å»º';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå†³ç­–æ ‘æ„å»º';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå†³ç­–æ ‘æ„å»ºå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå†³ç­–æ ‘æ„å»ºï¼šä¿¡æ¯å¢ç›Šè®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH tree_data AS (
    SELECT
        bs.tree_id,
        rfd.feature1,
        rfd.feature2,
        rfd.label
    FROM bootstrap_samples bs
    JOIN random_forest_data rfd ON bs.sample_id = rfd.id
),
feature_entropy AS (
    SELECT
        tree_id,
        feature1,
        -SUM((label_count::numeric / total_count) * LN(NULLIF(label_count::numeric / total_count, 0))) AS entropy
    FROM (
        SELECT
            tree_id,
            feature1,
            label,
            COUNT(*) AS label_count,
            COUNT(*) OVER (PARTITION BY tree_id, feature1) AS total_count
        FROM tree_data
        GROUP BY tree_id, feature1, label
    ) AS grouped
    GROUP BY tree_id, feature1
)
SELECT
    tree_id,
    feature1,
    ROUND(entropy::numeric, 4) AS feature_entropy
FROM feature_entropy
ORDER BY tree_id, feature1
LIMIT 100;
```

### 7.4 å¹¶è¡Œé¢„æµ‹æŠ•ç¥¨

```sql
-- PostgreSQL 18 å¹¶è¡Œé¢„æµ‹æŠ•ç¥¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'random_forest_predictions') THEN
            RAISE WARNING 'è¡¨ random_forest_predictions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œé¢„æµ‹æŠ•ç¥¨';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œé¢„æµ‹æŠ•ç¥¨';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œé¢„æµ‹æŠ•ç¥¨å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œé¢„æµ‹æŠ•ç¥¨ï¼šå¤šæ•°æŠ•ç¥¨
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH tree_predictions AS (
    SELECT
        test_sample_id,
        tree_id,
        predicted_class
    FROM random_forest_predictions
),
vote_counts AS (
    SELECT
        test_sample_id,
        predicted_class,
        COUNT(*) AS vote_count
    FROM tree_predictions
    GROUP BY test_sample_id, predicted_class
),
majority_vote AS (
    SELECT DISTINCT ON (test_sample_id)
        test_sample_id,
        predicted_class,
        vote_count
    FROM vote_counts
    ORDER BY test_sample_id, vote_count DESC
)
SELECT
    test_sample_id,
    predicted_class,
    vote_count,
    ROUND(vote_count::numeric / (SELECT COUNT(DISTINCT tree_id) FROM tree_predictions) * 100, 2) AS confidence_percentage
FROM majority_vote
ORDER BY test_sample_id;
```

---

## 8. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1 åˆ†ç±»ä»»åŠ¡

```sql
-- éšæœºæ£®æ—åˆ†ç±»åº”ç”¨
WITH rf_classification AS (
    SELECT
        test_sample_id,
        MODE() WITHIN GROUP (ORDER BY tree_prediction) AS predicted_class,
        AVG(tree_probability) AS prediction_confidence
    FROM random_forest_predictions
    GROUP BY test_sample_id
)
SELECT
    test_sample_id,
    predicted_class,
    ROUND(prediction_confidence::numeric, 4) AS confidence
FROM rf_classification;
```

### 7.2 å›å½’ä»»åŠ¡

```sql
-- éšæœºæ£®æ—å›å½’åº”ç”¨
WITH rf_regression AS (
    SELECT
        test_sample_id,
        AVG(tree_prediction) AS predicted_value,
        STDDEV(tree_prediction) AS prediction_std
    FROM random_forest_predictions
    GROUP BY test_sample_id
)
SELECT
    test_sample_id,
    ROUND(predicted_value::numeric, 4) AS predicted_value,
    ROUND(prediction_std::numeric, 4) AS prediction_uncertainty
FROM rf_regression;
```

---

### 7.3 ç‰¹å¾é€‰æ‹©

```sql
-- éšæœºæ£®æ—ç‰¹å¾é€‰æ‹©åº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'feature_selection_data') THEN
            CREATE TABLE feature_selection_data (
                id SERIAL PRIMARY KEY,
                feature1 NUMERIC NOT NULL,
                feature2 NUMERIC NOT NULL,
                feature3 NUMERIC NOT NULL,
                feature4 NUMERIC NOT NULL,
                feature5 NUMERIC NOT NULL,
                label INTEGER NOT NULL
            );

            -- æ’å…¥ç‰¹å¾é€‰æ‹©æ•°æ®
            INSERT INTO feature_selection_data (feature1, feature2, feature3, feature4, feature5, label) VALUES
                (1.0, 2.0, 3.0, 4.0, 5.0, 1),
                (1.1, 2.1, 3.1, 4.1, 5.1, 1),
                (5.0, 6.0, 7.0, 8.0, 9.0, 0),
                (5.1, 6.1, 7.1, 8.1, 9.1, 0);

            RAISE NOTICE 'ç‰¹å¾é€‰æ‹©æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç‰¹å¾é€‰æ‹©åº”ç”¨å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç‰¹å¾é‡è¦æ€§æ’åº
WITH feature_importance AS (
    SELECT
        'feature1' AS feature_name,
        AVG(importance_score) AS avg_importance
    FROM rf_feature_importance
    WHERE feature_name = 'feature1'
    UNION ALL
    SELECT 'feature2', AVG(importance_score) FROM rf_feature_importance WHERE feature_name = 'feature2'
    UNION ALL
    SELECT 'feature3', AVG(importance_score) FROM rf_feature_importance WHERE feature_name = 'feature3'
)
SELECT
    feature_name,
    ROUND(avg_importance::numeric, 4) AS importance_score,
    ROW_NUMBER() OVER (ORDER BY avg_importance DESC) AS importance_rank
FROM feature_importance
ORDER BY importance_rank;
```

### 7.4 å¼‚å¸¸æ£€æµ‹

```sql
-- éšæœºæ£®æ—å¼‚å¸¸æ£€æµ‹åº”ç”¨
WITH anomaly_scores AS (
    SELECT
        id,
        -- å¼‚å¸¸åˆ†æ•°ï¼šOOBé¢„æµ‹è¯¯å·®
        ABS(predicted_value - actual_value) AS anomaly_score
    FROM rf_predictions
)
SELECT
    id,
    ROUND(anomaly_score::numeric, 4) AS anomaly_score,
    CASE
        WHEN anomaly_score > PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY anomaly_score) OVER () THEN 'Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM anomaly_scores
ORDER BY anomaly_score DESC;
```

---

## 9. PostgreSQL 18 å¹¶è¡Œéšæœºæ£®æ—æ€§èƒ½ä¼˜åŒ–

### å¹¶è¡ŒåŒ–ä¼˜åŒ–

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;

-- å¹¶è¡Œè®­ç»ƒå¤šæ£µæ ‘
WITH parallel_trees AS (
    SELECT
        tree_id,
        -- å¹¶è¡Œè®­ç»ƒæ¯æ£µæ ‘
        train_decision_tree(bootstrap_sample) AS tree_model
    FROM bootstrap_samples
    GROUP BY tree_id
)
SELECT COUNT(*) AS total_trees FROM parallel_trees;
```

### é‡‡æ ·ä¼˜åŒ–

```sql
-- ä½¿ç”¨é‡‡æ ·æ¯”ä¾‹åŠ é€Ÿè®­ç»ƒ
WITH sampled_data AS (
    SELECT *
    FROM rf_training_data TABLESAMPLE SYSTEM(80)  -- 80%é‡‡æ ·
)
SELECT COUNT(*) AS sampled_size FROM sampled_data;
```

### ç‰¹å¾å­é›†ä¼˜åŒ–

```sql
-- åŠ¨æ€ç‰¹å¾æ•°é‡é€‰æ‹©
WITH feature_count AS (
    SELECT
        COUNT(DISTINCT column_name) AS total_features
    FROM information_schema.columns
    WHERE table_name = 'rf_training_data'
        AND column_name LIKE 'feature%'
)
SELECT
    total_features,
    CEIL(SQRT(total_features)) AS sqrt_features,
    CEIL(LOG(2, total_features)) AS log_features
FROM feature_count;
```

### ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå…³é”®ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_features ON rf_training_data(feature1, feature2, feature3);
CREATE INDEX IF NOT EXISTS idx_label ON rf_training_data(label);
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### å‚æ•°è°ƒä¼˜

1. **æ ‘çš„æ•°é‡**: é€šå¸¸100-500æ£µæ ‘è¶³å¤Ÿ
   - å°æ•°æ®é›†ï¼š50-100æ£µæ ‘
   - ä¸­ç­‰æ•°æ®é›†ï¼š100-300æ£µæ ‘
   - å¤§æ•°æ®é›†ï¼š300-500æ£µæ ‘

2. **ç‰¹å¾æ•°é‡**: ä½¿ç”¨ $\sqrt{p}$ æˆ– $\log_2(p)$ ä¸ªç‰¹å¾

   ```sql
   -- ç‰¹å¾æ•°é‡è®¡ç®—
   SELECT
       CEIL(SQRT(5)) AS sqrt_features,  -- 5ä¸ªç‰¹å¾ â†’ 3ä¸ª
       CEIL(LOG(2, 5)) AS log_features;  -- 5ä¸ªç‰¹å¾ â†’ 3ä¸ª
   ```

3. **æ ‘æ·±åº¦**: é€šå¸¸ä¸é™åˆ¶æ·±åº¦ï¼Œè®©æ ‘å®Œå…¨ç”Ÿé•¿
   - åˆ†ç±»ä»»åŠ¡ï¼šä¸é™åˆ¶æ·±åº¦
   - å›å½’ä»»åŠ¡ï¼šå¯ä»¥é™åˆ¶æ·±åº¦é˜²æ­¢è¿‡æ‹Ÿåˆ

### ç‰¹å¾å·¥ç¨‹

1. **ç¼ºå¤±å€¼å¤„ç†**: éšæœºæ£®æ—å¯¹ç¼ºå¤±å€¼ç›¸å¯¹é²æ£’

   ```sql
   -- ç¼ºå¤±å€¼å¡«å……
   UPDATE rf_training_data
   SET feature1 = COALESCE(feature1, (SELECT AVG(feature1) FROM rf_training_data))
   WHERE feature1 IS NULL;
   ```

2. **å¼‚å¸¸å€¼å¤„ç†**: å¯ä»¥ä½¿ç”¨IQRæ–¹æ³•

   ```sql
   -- å¼‚å¸¸å€¼æ£€æµ‹
   WITH outlier_detection AS (
       SELECT
           id,
           feature1,
           PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY feature1) OVER () AS q1,
           PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY feature1) OVER () AS q3
       FROM rf_training_data
   )
   SELECT * FROM outlier_detection
   WHERE feature1 BETWEEN q1 - 1.5 * (q3 - q1) AND q3 + 1.5 * (q3 - q1);
   ```

### æ¨¡å‹è¯„ä¼°

1. **OOBè¯¯å·®**: ä½¿ç”¨OOBè¯¯å·®è¯„ä¼°ï¼Œæ— éœ€éªŒè¯é›†
2. **äº¤å‰éªŒè¯**: ä½¿ç”¨kæŠ˜äº¤å‰éªŒè¯
3. **ç‰¹å¾é‡è¦æ€§**: åˆ©ç”¨ç‰¹å¾é‡è¦æ€§è¿›è¡Œç‰¹å¾é€‰æ‹©

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**: ä½¿ç”¨DOå—å’ŒEXCEPTIONè¿›è¡Œé”™è¯¯å¤„ç†
2. **å†…å­˜ç®¡ç†**: æ³¨æ„å¤§è§„æ¨¡æ•°æ®çš„å†…å­˜å ç”¨
3. **æ€§èƒ½ä¼˜åŒ–**: ä½¿ç”¨å¹¶è¡Œè®¡ç®—å’Œé‡‡æ ·ä¼˜åŒ–æ€§èƒ½
4. **ç»“æœè§£é‡Š**: æ­£ç¡®è§£é‡Šç‰¹å¾é‡è¦æ€§å’Œé¢„æµ‹ç»“æœ

---

## ğŸ“ˆ éšæœºæ£®æ— vs å…¶ä»–ç®—æ³•å¯¹æ¯”

| ç‰¹æ€§ | éšæœºæ£®æ— | å†³ç­–æ ‘ | æ¢¯åº¦æå‡ |
|------|---------|--------|---------|
| **å‡†ç¡®æ€§** | é«˜ | ä¸­ | å¾ˆé«˜ |
| **è®­ç»ƒé€Ÿåº¦** | å¿« | å¿« | æ…¢ |
| **é¢„æµ‹é€Ÿåº¦** | å¿« | å¿« | ä¸­ |
| **å¯è§£é‡Šæ€§** | ä¸­ | é«˜ | ä½ |
| **è¿‡æ‹Ÿåˆ** | ä½ | é«˜ | ä¸­ |
| **å¹¶è¡ŒåŒ–** | å®¹æ˜“ | å®¹æ˜“ | å›°éš¾ |

---

## ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šè¿‡æ‹Ÿåˆ

**åŸå› **ï¼š

- æ ‘çš„æ•°é‡è¿‡å¤š
- ç‰¹å¾æ•°é‡è¿‡å¤š
- æ ·æœ¬é‡å°

**è§£å†³æ–¹æ¡ˆ**ï¼š

- å‡å°‘æ ‘çš„æ•°é‡
- å‡å°‘ç‰¹å¾æ•°é‡
- å¢åŠ é‡‡æ ·æ¯”ä¾‹
- é™åˆ¶æ ‘æ·±åº¦

### é—®é¢˜2ï¼šè®­ç»ƒæ…¢

**åŸå› **ï¼š

- æ ‘çš„æ•°é‡å¤š
- æ•°æ®é‡å¤§
- ç‰¹å¾å¤š
- æœªä½¿ç”¨å¹¶è¡Œè®¡ç®—

**è§£å†³æ–¹æ¡ˆ**ï¼š

- å‡å°‘æ ‘çš„æ•°é‡
- ä½¿ç”¨é‡‡æ ·å‡å°‘æ•°æ®é‡
- å‡å°‘ç‰¹å¾æ•°é‡
- å¯ç”¨å¹¶è¡Œè®¡ç®—

### é—®é¢˜3ï¼šç‰¹å¾é‡è¦æ€§ä¸ä¸€è‡´

**åŸå› **ï¼š

- éšæœºæ€§
- ç‰¹å¾ç›¸å…³æ€§å¼º
- æ ·æœ¬é‡å°

**è§£å†³æ–¹æ¡ˆ**ï¼š

- å¢åŠ æ ‘çš„æ•°é‡
- å¤šæ¬¡è¿è¡Œå–å¹³å‡
- ä½¿ç”¨ç½®æ¢é‡è¦æ€§
- å¢åŠ æ ·æœ¬é‡

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Breiman, L. (2001)**: "Random Forests", Machine Learning, 45(1), 5-32
2. **Hastie, T., Tibshirani, R., Friedman, J. (2009)**: "The Elements of Statistical Learning", 2nd Edition, Springer
3. **Zhou, Z.H. (2012)**: "Ensemble Methods: Foundations and Algorithms", MIT Press
4. **Liaw, A., Wiener, M. (2002)**: "Classification and Regression by randomForest", R News, 2(3), 18-22

---

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡éšæœºæ£®æ—ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«ç‰¹å¾åˆ—çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nç‰¹å¾é‡è¦æ€§æŸ¥è¯¢å’Œå¤šæ ‘å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡éšæœºæ£®æ—è®­ç»ƒï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡Bootstrapé‡‡æ ·å’Œå¹¶è¡Œå†³ç­–æ ‘æ„å»º

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - éšæœºæ£®æ—æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨7èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡æ£®æ—è®­ç»ƒå’Œå¹¶è¡Œé¢„æµ‹æŠ•ç¥¨

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–éšæœºæ£®æ—æŸ¥è¯¢**

```sql
-- ä¸ºéšæœºæ£®æ—æ•°æ®åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_rf_data_skip_scan
ON rf_training_data(label, feature1 DESC, feature2 DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªç±»åˆ«çš„æœ€é‡è¦ç‰¹å¾ç»„åˆ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (label)
    id,
    label,
    feature1,
    feature2,
    feature3
FROM rf_training_data
ORDER BY label, feature1 DESC, feature2 DESC
LIMIT 50;
```

### é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜éšæœºæ£®æ—ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„éšæœºæ£®æ—é¢„æµ‹ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜éšæœºæ£®æ—é¢„æµ‹ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS random_forest_prediction_cache AS
WITH tree_predictions AS (
    SELECT
        test_id,
        tree_id,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ ‘é¢„æµ‹ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN feature1 > AVG(feature1) OVER (PARTITION BY tree_id) THEN 1
            ELSE 0
        END AS tree_prediction
    FROM rf_training_data
    CROSS JOIN generate_series(1, 10) AS tree_id  -- 10æ£µæ ‘
),
forest_vote AS (
    SELECT
        test_id,
        AVG(tree_prediction) AS prediction_probability,
        CASE
            WHEN AVG(tree_prediction) > 0.5 THEN 1
            ELSE 0
        END AS final_prediction
    FROM tree_predictions
    GROUP BY test_id
)
SELECT
    test_id,
    ROUND(prediction_probability::numeric, 4) AS prediction_probability,
    final_prediction,
    CASE
        WHEN prediction_probability > 0.8 THEN 'High Confidence'
        WHEN prediction_probability > 0.6 THEN 'Moderate Confidence'
        ELSE 'Low Confidence'
    END AS confidence_level
FROM forest_vote
ORDER BY test_id;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_rf_prediction_cache_test ON random_forest_prediction_cache(test_id);
CREATE INDEX idx_rf_prediction_cache_confidence ON random_forest_prediction_cache(confidence_level, prediction_probability DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY random_forest_prediction_cache;
```

**2. å®æ—¶éšæœºæ£®æ—ï¼šå¢é‡æ ‘æ›´æ–°**

**å®æ—¶éšæœºæ£®æ—**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°æ ‘é¢„æµ‹ç»“æœã€‚

```sql
-- å®æ—¶éšæœºæ£®æ—ï¼šå¢é‡æ ‘æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'random_forest_state') THEN
            CREATE TABLE random_forest_state (
                forest_id VARCHAR(100) NOT NULL,
                tree_id INTEGER NOT NULL,
                sample_count BIGINT DEFAULT 0,
                feature_importance JSONB,
                oob_error NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (forest_id, tree_id)
            );

            CREATE INDEX idx_random_forest_state_forest ON random_forest_state(forest_id, last_updated DESC);
            CREATE INDEX idx_random_forest_state_updated ON random_forest_state(last_updated DESC);

            RAISE NOTICE 'éšæœºæ£®æ—çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡éšæœºæ£®æ—æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡éšæœºæ£®æ—æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**3. æ™ºèƒ½éšæœºæ£®æ—ä¼˜åŒ–ï¼šè‡ªé€‚åº”å‚æ•°é€‰æ‹©**

**æ™ºèƒ½éšæœºæ£®æ—ä¼˜åŒ–**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜éšæœºæ£®æ—å‚æ•°ã€‚

```sql
-- æ™ºèƒ½éšæœºæ£®æ—ä¼˜åŒ–ï¼šè‡ªé€‚åº”å‚æ•°é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    sample_size BIGINT;
    feature_count INTEGER;
    recommended_trees INTEGER;
    recommended_features INTEGER;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'rf_training_data') THEN
            RAISE WARNING 'è¡¨ rf_training_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½éšæœºæ£®æ—ä¼˜åŒ–';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        SELECT
            COUNT(*),
            (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'rf_training_data' AND column_name LIKE 'feature%')
        INTO sample_size, feature_count
        FROM rf_training_data;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©å‚æ•°
        IF sample_size < 1000 THEN
            recommended_trees := 50;  -- å°æ ·æœ¬ï¼šå°‘é‡æ ‘
        ELSIF sample_size < 10000 THEN
            recommended_trees := 100;  -- ä¸­ç­‰æ ·æœ¬ï¼šä¸­ç­‰æ ‘
        ELSE
            recommended_trees := 500;  -- å¤§æ ·æœ¬ï¼šå¤§é‡æ ‘
        END IF;

        recommended_features := GREATEST(1, SQRT(feature_count)::INTEGER);  -- ç»å…¸é€‰æ‹©ï¼šsqrt(ç‰¹å¾æ•°)

        RAISE NOTICE 'æ ·æœ¬å¤§å°: %, ç‰¹å¾æ•°: %, æ¨èæ ‘æ•°: %, æ¨èç‰¹å¾æ•°: %',
            sample_size, feature_count, recommended_trees, recommended_features;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½éšæœºæ£®æ—ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç†è®ºæ¨å¯¼ã€å®ç°å’ŒPostgreSQL 18æ–°ç‰¹æ€§æ”¯æŒï¼‰
