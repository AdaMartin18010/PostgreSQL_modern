# PostgreSQL é›†æˆå­¦ä¹ ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æœºå™¨å­¦ä¹  | é›†æˆå­¦ä¹  | æ¨¡å‹èåˆ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Ensemble Methods (Zhou), Machine Learning, Pattern Recognition

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL é›†æˆå­¦ä¹ ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-é›†æˆå­¦ä¹ ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [é›†æˆå­¦ä¹ æ¦‚è¿°](#é›†æˆå­¦ä¹ æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [æ ¸å¿ƒæ€æƒ³](#æ ¸å¿ƒæ€æƒ³)
    - [é›†æˆç­–ç•¥](#é›†æˆç­–ç•¥)
  - [1. Bagging](#1-bagging)
    - [1.1 Bootstrapé‡‡æ ·](#11-bootstrapé‡‡æ ·)
  - [2. Boosting](#2-boosting)
    - [2.1 AdaBoost](#21-adaboost)
    - [2.2 Stacking](#22-stacking)
  - [3. æ¨¡å‹èåˆ](#3-æ¨¡å‹èåˆ)
    - [3.1 æŠ•ç¥¨æ³•](#31-æŠ•ç¥¨æ³•)
    - [3.2 åŠ æƒå¹³å‡](#32-åŠ æƒå¹³å‡)
  - [4. å¤æ‚åº¦åˆ†æ](#4-å¤æ‚åº¦åˆ†æ)
    - [4.1 æ—¶é—´å¤æ‚åº¦](#41-æ—¶é—´å¤æ‚åº¦)
    - [4.2 ç©ºé—´å¤æ‚åº¦](#42-ç©ºé—´å¤æ‚åº¦)
  - [5. PostgreSQL 18 å¹¶è¡Œé›†æˆå­¦ä¹ å¢å¼º](#5-postgresql-18-å¹¶è¡Œé›†æˆå­¦ä¹ å¢å¼º)
    - [5.1 å¹¶è¡Œé›†æˆå­¦ä¹ åŸç†](#51-å¹¶è¡Œé›†æˆå­¦ä¹ åŸç†)
    - [5.2 å¹¶è¡ŒBagging](#52-å¹¶è¡Œbagging)
    - [5.3 å¹¶è¡Œæ¨¡å‹èåˆ](#53-å¹¶è¡Œæ¨¡å‹èåˆ)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 åˆ†ç±»ä»»åŠ¡é›†æˆ](#51-åˆ†ç±»ä»»åŠ¡é›†æˆ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)

---

## é›†æˆå­¦ä¹ æ¦‚è¿°

**é›†æˆå­¦ä¹ **é€šè¿‡ç»„åˆå¤šä¸ªå¼±å­¦ä¹ å™¨æ„å»ºå¼ºå­¦ä¹ å™¨ã€‚

### ç†è®ºåŸºç¡€

**é›†æˆå­¦ä¹ çš„ä¼˜åŠ¿**:

- é™ä½æ–¹å·®ï¼ˆBaggingï¼‰
- é™ä½åå·®ï¼ˆBoostingï¼‰
- æé«˜æ³›åŒ–èƒ½åŠ›

### æ ¸å¿ƒæ€æƒ³

**ä¸‰ä¸ªè‡­çš®åŒ é¡¶ä¸ªè¯¸è‘›äº®**: å¤šä¸ªæ¨¡å‹çš„ç»„åˆé€šå¸¸æ¯”å•ä¸ªæ¨¡å‹æ›´å¥½ã€‚

### é›†æˆç­–ç•¥

| ç­–ç•¥ | æ–¹æ³• | ç‰¹ç‚¹ |
|------|------|------|
| **Bagging** | å¹¶è¡Œè®­ç»ƒï¼ŒæŠ•ç¥¨/å¹³å‡ | é™ä½æ–¹å·® |
| **Boosting** | ä¸²è¡Œè®­ç»ƒï¼ŒåŠ æƒç»„åˆ | é™ä½åå·® |
| **Stacking** | å…ƒå­¦ä¹ å™¨ç»„åˆ | å­¦ä¹ æœ€ä¼˜ç»„åˆ |

---

## 1. Bagging

### 1.1 Bootstrapé‡‡æ ·

**Bootstrapé‡‡æ ·**ç”Ÿæˆå¤šä¸ªè®­ç»ƒé›†ã€‚

```sql
-- Baggingå®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ensemble_data') THEN
            DROP TABLE ensemble_data CASCADE;
        END IF;

        CREATE TABLE ensemble_data (
            id SERIAL PRIMARY KEY,
            feature1 NUMERIC NOT NULL,
            feature2 NUMERIC NOT NULL,
            label INTEGER NOT NULL
        );

        INSERT INTO ensemble_data (feature1, feature2, label) VALUES
            (1.0, 2.0, 0), (1.5, 2.5, 0), (2.0, 3.0, 1);

        RAISE NOTICE 'è¡¨ ensemble_data åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Bootstrapé‡‡æ ·
WITH bootstrap_samples AS (
    SELECT
        model_id,
        id,
        feature1,
        feature2,
        label
    FROM (
        SELECT
            generate_series(1, 10) AS model_id,
            (SELECT id FROM ensemble_data ORDER BY RANDOM() LIMIT 1) AS id
        FROM generate_series(1, 100)
    ) bootstrap_ids
    JOIN ensemble_data ON bootstrap_ids.id = ensemble_data.id
)
SELECT
    model_id,
    COUNT(*) AS sample_count
FROM bootstrap_samples
GROUP BY model_id;
```

---

## 2. Boosting

### 2.1 AdaBoost

**AdaBoost**é€šè¿‡åŠ æƒç»„åˆå¼±å­¦ä¹ å™¨ï¼Œé€æ­¥æå‡æ¨¡å‹æ€§èƒ½ã€‚

**ç®—æ³•æµç¨‹**ï¼š

1. åˆå§‹åŒ–æ ·æœ¬æƒé‡ $w_i = 1/N$
2. è®­ç»ƒå¼±å­¦ä¹ å™¨
3. è®¡ç®—é”™è¯¯ç‡ $\epsilon_t$
4. è®¡ç®—æƒé‡ $\alpha_t = \frac{1}{2}\ln\left(\frac{1-\epsilon_t}{\epsilon_t}\right)$
5. æ›´æ–°æ ·æœ¬æƒé‡
6. é‡å¤æ­¥éª¤2-5ç›´åˆ°æ”¶æ•›

**æƒé‡æ›´æ–°**:
$$\alpha_t = \frac{1}{2}\ln\left(\frac{1-\epsilon_t}{\epsilon_t}\right)$$

```sql
-- AdaBoostå®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'adaboost_iteration') THEN
            DROP TABLE adaboost_iteration, adaboost_models CASCADE;
        END IF;

        -- AdaBoostè¿­ä»£è¡¨
        CREATE TABLE adaboost_iteration (
            iteration INTEGER NOT NULL,
            sample_id INTEGER NOT NULL,
            initial_weight NUMERIC NOT NULL,
            prediction INTEGER,
            actual_label INTEGER NOT NULL,
            prediction_error INTEGER DEFAULT 0,
            alpha NUMERIC,
            updated_weight NUMERIC,
            PRIMARY KEY (iteration, sample_id)
        );

        -- åˆå§‹åŒ–ï¼šç¬¬1æ¬¡è¿­ä»£
        INSERT INTO adaboost_iteration (iteration, sample_id, initial_weight, actual_label)
        SELECT
            1,
            id,
            1.0 / (SELECT COUNT(*) FROM ensemble_data) AS initial_weight,
            label
        FROM ensemble_data;

        RAISE NOTICE 'AdaBoostè¿­ä»£è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- AdaBoostï¼šè®¡ç®—é”™è¯¯ç‡å’Œæƒé‡
WITH iteration_stats AS (
    SELECT
        iteration,
        SUM(initial_weight * prediction_error) AS weighted_error,
        COUNT(*) AS total_samples
    FROM adaboost_iteration
    GROUP BY iteration
),
adaboost_weights AS (
    SELECT
        ai.iteration,
        ai.sample_id,
        ai.initial_weight,
        ai.prediction_error,
        is_stats.weighted_error AS error_rate,
        -- è®¡ç®—alpha
        CASE
            WHEN is_stats.weighted_error > 0 AND is_stats.weighted_error < 0.5 THEN
                0.5 * LN((1 - is_stats.weighted_error) / NULLIF(is_stats.weighted_error, 0))
            ELSE 0
        END AS alpha,
        -- æ›´æ–°æƒé‡
        ai.initial_weight * EXP(
            CASE
                WHEN ai.prediction_error = 1 THEN
                    0.5 * LN((1 - is_stats.weighted_error) / NULLIF(is_stats.weighted_error, 0))
                ELSE
                    -0.5 * LN((1 - is_stats.weighted_error) / NULLIF(is_stats.weighted_error, 0))
            END
        ) AS updated_weight
    FROM adaboost_iteration ai
    JOIN iteration_stats is_stats ON ai.iteration = is_stats.iteration
)
SELECT
    iteration,
    sample_id,
    ROUND(initial_weight::numeric, 4) AS initial_weight,
    prediction_error,
    ROUND(error_rate::numeric, 4) AS error_rate,
    ROUND(alpha::numeric, 4) AS alpha,
    ROUND(updated_weight::numeric, 4) AS updated_weight
FROM adaboost_weights
ORDER BY iteration, sample_id;
```

### 2.2 Stacking

**Stacking**ä½¿ç”¨å…ƒå­¦ä¹ å™¨å­¦ä¹ å¦‚ä½•ç»„åˆåŸºå­¦ä¹ å™¨ã€‚

**ç®—æ³•æµç¨‹**ï¼š

1. è®­ç»ƒå¤šä¸ªåŸºå­¦ä¹ å™¨
2. ä½¿ç”¨åŸºå­¦ä¹ å™¨é¢„æµ‹
3. è®­ç»ƒå…ƒå­¦ä¹ å™¨ç»„åˆé¢„æµ‹

```sql
-- Stackingï¼šåŸºå­¦ä¹ å™¨é¢„æµ‹
WITH base_models AS (
    SELECT
        id,
        label AS actual_label,
        -- åŸºå­¦ä¹ å™¨1é¢„æµ‹ï¼ˆç®€åŒ–ï¼šä½¿ç”¨çº¿æ€§åˆ†ç±»ï¼‰
        CASE WHEN feature1 + feature2 > 3 THEN 1 ELSE 0 END AS model1_pred,
        -- åŸºå­¦ä¹ å™¨2é¢„æµ‹
        CASE WHEN feature1 * feature2 > 4 THEN 1 ELSE 0 END AS model2_pred,
        -- åŸºå­¦ä¹ å™¨3é¢„æµ‹
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END AS model3_pred
    FROM ensemble_data
),
meta_features AS (
    SELECT
        id,
        actual_label,
        model1_pred,
        model2_pred,
        model3_pred,
        -- å…ƒç‰¹å¾ï¼šåŸºå­¦ä¹ å™¨é¢„æµ‹çš„å¹³å‡å€¼
        (model1_pred + model2_pred + model3_pred) / 3.0 AS meta_feature
    FROM base_models
)
SELECT
    id,
    actual_label,
    model1_pred,
    model2_pred,
    model3_pred,
    ROUND(meta_feature::numeric, 4) AS meta_feature,
    -- å…ƒå­¦ä¹ å™¨é¢„æµ‹ï¼ˆç®€åŒ–ï¼šé˜ˆå€¼0.5ï¼‰
    CASE WHEN meta_feature > 0.5 THEN 1 ELSE 0 END AS stacking_prediction
FROM meta_features
ORDER BY id;
```

---

## 3. æ¨¡å‹èåˆ

### 3.1 æŠ•ç¥¨æ³•

**æŠ•ç¥¨æ³•**é€šè¿‡å¤šæ•°æŠ•ç¥¨ç»„åˆé¢„æµ‹ã€‚

```sql
-- æŠ•ç¥¨æ³•ï¼šå¤šæ•°æŠ•ç¥¨
WITH model_predictions AS (
    SELECT
        id,
        label AS actual_label,
        CASE WHEN feature1 + feature2 > 3 THEN 1 ELSE 0 END AS model1_pred,
        CASE WHEN feature1 * feature2 > 4 THEN 1 ELSE 0 END AS model2_pred,
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END AS model3_pred
    FROM ensemble_data
),
voting_result AS (
    SELECT
        id,
        actual_label,
        model1_pred,
        model2_pred,
        model3_pred,
        -- å¤šæ•°æŠ•ç¥¨
        CASE
            WHEN (model1_pred + model2_pred + model3_pred) >= 2 THEN 1
            ELSE 0
        END AS majority_vote,
        -- ä¸€è‡´æ€§æ£€æŸ¥
        CASE
            WHEN model1_pred = model2_pred AND model2_pred = model3_pred THEN 'Unanimous'
            ELSE 'Majority'
        END AS vote_type
    FROM model_predictions
)
SELECT
    id,
    actual_label,
    model1_pred || ',' || model2_pred || ',' || model3_pred AS individual_predictions,
    majority_vote AS ensemble_prediction,
    vote_type,
    CASE
        WHEN majority_vote = actual_label THEN 'Correct âœ“'
        ELSE 'Incorrect âœ—'
    END AS prediction_status
FROM voting_result
ORDER BY id;
```

### 3.2 åŠ æƒå¹³å‡

**åŠ æƒå¹³å‡**æ ¹æ®æ¨¡å‹æ€§èƒ½åˆ†é…æƒé‡ã€‚

```sql
-- åŠ æƒå¹³å‡ï¼šæ ¹æ®å‡†ç¡®ç‡åˆ†é…æƒé‡
WITH model_performance AS (
    SELECT
        'model1' AS model_name,
        CASE WHEN feature1 + feature2 > 3 THEN 1 ELSE 0 END AS prediction,
        label AS actual_label
    FROM ensemble_data

    UNION ALL

    SELECT
        'model2',
        CASE WHEN feature1 * feature2 > 4 THEN 1 ELSE 0 END,
        label
    FROM ensemble_data

    UNION ALL

    SELECT
        'model3',
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END,
        label
    FROM ensemble_data
),
model_accuracy AS (
    SELECT
        model_name,
        COUNT(*) FILTER (WHERE prediction = actual_label)::NUMERIC / COUNT(*) AS accuracy
    FROM model_performance
    GROUP BY model_name
),
model_weights AS (
    SELECT
        model_name,
        accuracy,
        -- æƒé‡ï¼šå‡†ç¡®ç‡å½’ä¸€åŒ–
        accuracy / SUM(accuracy) OVER () AS weight
    FROM model_accuracy
),
weighted_predictions AS (
    SELECT
        ed.id,
        ed.label AS actual_label,
        CASE WHEN ed.feature1 + ed.feature2 > 3 THEN 1 ELSE 0 END AS model1_pred,
        CASE WHEN ed.feature1 * ed.feature2 > 4 THEN 1 ELSE 0 END AS model2_pred,
        CASE WHEN ed.feature1 > 1.5 THEN 1 ELSE 0 END AS model3_pred,
        (SELECT weight FROM model_weights WHERE model_name = 'model1') AS w1,
        (SELECT weight FROM model_weights WHERE model_name = 'model2') AS w2,
        (SELECT weight FROM model_weights WHERE model_name = 'model3') AS w3
    FROM ensemble_data ed
)
SELECT
    id,
    actual_label,
    ROUND((model1_pred * w1 + model2_pred * w2 + model3_pred * w3)::numeric, 4) AS weighted_prediction,
    CASE
        WHEN (model1_pred * w1 + model2_pred * w2 + model3_pred * w3) > 0.5 THEN 1
        ELSE 0
    END AS ensemble_prediction
FROM weighted_predictions
ORDER BY id;
```

---

## 4. å¤æ‚åº¦åˆ†æ

### 4.1 æ—¶é—´å¤æ‚åº¦

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | è¯´æ˜ |
|------|-----------|------|
| **Bagging** | $O(T \cdot n \log n)$ | Tä¸ªæ¨¡å‹ï¼Œnä¸ªæ ·æœ¬ |
| **Boosting** | $O(T \cdot n \log n)$ | Tæ¬¡è¿­ä»£ |
| **Stacking** | $O(T \cdot n \log n + n \log n)$ | åŸºå­¦ä¹ å™¨+å…ƒå­¦ä¹ å™¨ |

### 4.2 ç©ºé—´å¤æ‚åº¦

| æ–¹æ³• | ç©ºé—´å¤æ‚åº¦ |
|------|-----------|
| **Bagging** | $O(T \cdot n)$ |
| **Boosting** | $O(n)$ |
| **Stacking** | $O(T \cdot n)$ |

---

## 5. PostgreSQL 18 å¹¶è¡Œé›†æˆå­¦ä¹ å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œé›†æˆå­¦ä¹ è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡ŒBaggingã€Boostingå’Œæ¨¡å‹èåˆï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡é›†æˆå­¦ä¹ è®­ç»ƒçš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œé›†æˆå­¦ä¹ åŸç†

PostgreSQL 18 çš„å¹¶è¡Œé›†æˆå­¦ä¹ é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æè®­ç»ƒæ•°æ®
2. **å¹¶è¡ŒBootstrapé‡‡æ ·**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡ŒBootstrapé‡‡æ ·
3. **å¹¶è¡Œæ¨¡å‹è®­ç»ƒ**ï¼šå¹¶è¡Œè®­ç»ƒå¤šä¸ªå¼±å­¦ä¹ å™¨
4. **å¹¶è¡Œé¢„æµ‹èåˆ**ï¼šå¹¶è¡Œæ‰§è¡ŒæŠ•ç¥¨å’ŒåŠ æƒå¹³å‡
5. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„ç»“æœ

### 5.2 å¹¶è¡ŒBagging

```sql
-- PostgreSQL 18 å¹¶è¡ŒBaggingï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ensemble_data') THEN
            RAISE WARNING 'è¡¨ ensemble_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒBagging';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒBagging';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒBaggingå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒBootstrapé‡‡æ ·
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH bootstrap_samples AS (
    SELECT
        model_id,
        (random() * (SELECT COUNT(*) FROM ensemble_data) + 1)::INTEGER AS sample_id
    FROM generate_series(1, 100) AS model_id
    CROSS JOIN generate_series(1, (SELECT COUNT(*) FROM ensemble_data)) AS sample_idx
)
SELECT
    model_id,
    sample_id,
    COUNT(*) AS sample_count
FROM bootstrap_samples
GROUP BY model_id, sample_id
ORDER BY model_id, sample_id
LIMIT 1000;
```

### 5.3 å¹¶è¡Œæ¨¡å‹èåˆ

```sql
-- PostgreSQL 18 å¹¶è¡Œæ¨¡å‹èåˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'model_predictions') THEN
            RAISE WARNING 'è¡¨ model_predictions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæ¨¡å‹èåˆ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæ¨¡å‹èåˆ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ¨¡å‹èåˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒæŠ•ç¥¨å’ŒåŠ æƒå¹³å‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH ensemble_predictions AS (
    SELECT
        sample_id,
        predicted_class,
        prediction_weight,
        COUNT(*) AS vote_count
    FROM model_predictions
    GROUP BY sample_id, predicted_class, prediction_weight
),
majority_vote AS (
    SELECT DISTINCT ON (sample_id)
        sample_id,
        predicted_class,
        vote_count,
        SUM(prediction_weight) AS weighted_sum
    FROM ensemble_predictions
    GROUP BY sample_id, predicted_class, vote_count
    ORDER BY sample_id, vote_count DESC, weighted_sum DESC
)
SELECT
    sample_id,
    predicted_class AS ensemble_prediction,
    vote_count,
    ROUND(weighted_sum::numeric, 4) AS weighted_score
FROM majority_vote
ORDER BY sample_id;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 åˆ†ç±»ä»»åŠ¡é›†æˆ

```sql
-- åˆ†ç±»ä»»åŠ¡ï¼šé›†æˆå¤šä¸ªåˆ†ç±»å™¨
WITH ensemble_classification AS (
    SELECT
        id,
        feature1,
        feature2,
        label AS actual_label,
        -- å¤šä¸ªåŸºåˆ†ç±»å™¨
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END AS classifier1,
        CASE WHEN feature2 > 2.5 THEN 1 ELSE 0 END AS classifier2,
        CASE WHEN feature1 + feature2 > 4 THEN 1 ELSE 0 END AS classifier3
    FROM ensemble_data
),
ensemble_result AS (
    SELECT
        id,
        actual_label,
        classifier1,
        classifier2,
        classifier3,
        -- å¤šæ•°æŠ•ç¥¨
        CASE
            WHEN (classifier1 + classifier2 + classifier3) >= 2 THEN 1
            ELSE 0
        END AS ensemble_prediction
    FROM ensemble_classification
)
SELECT
    COUNT(*) AS total_samples,
    COUNT(*) FILTER (WHERE ensemble_prediction = actual_label) AS correct_predictions,
    ROUND(COUNT(*) FILTER (WHERE ensemble_prediction = actual_label)::NUMERIC / COUNT(*) * 100, 2) AS ensemble_accuracy
FROM ensemble_result;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Zhou, Z.H. (2012)**: "Ensemble Methods: Foundations and Algorithms"
2. **Dietterich, T.G. (2000)**: "Ensemble Methods in Machine Learning"
3. **Breiman, L. (1996)**: "Bagging Predictors"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¹¶è¡Œè®­ç»ƒ**ï¼šå¹¶è¡Œè®­ç»ƒå¤šä¸ªåŸºå­¦ä¹ å™¨
2. **æ¨¡å‹é€‰æ‹©**ï¼šé€‰æ‹©å¤šæ ·åŒ–çš„åŸºå­¦ä¹ å™¨
3. **æƒé‡ä¼˜åŒ–**ï¼šä¼˜åŒ–é›†æˆæƒé‡
4. **äº¤å‰éªŒè¯**ï¼šä½¿ç”¨äº¤å‰éªŒè¯è¯„ä¼°é›†æˆæ€§èƒ½

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **åŸºå­¦ä¹ å™¨å¤šæ ·æ€§**ï¼šé€‰æ‹©ä¸åŒç±»å‹çš„åŸºå­¦ä¹ å™¨
2. **é›†æˆç­–ç•¥**ï¼šæ ¹æ®é—®é¢˜ç‰¹æ€§é€‰æ‹©Baggingæˆ–Boosting
3. **è¶…å‚æ•°è°ƒä¼˜**ï¼šè°ƒä¼˜åŸºå­¦ä¹ å™¨å’Œé›†æˆå‚æ•°
4. **æ€§èƒ½è¯„ä¼°**ï¼šä½¿ç”¨ç‹¬ç«‹æµ‹è¯•é›†è¯„ä¼°é›†æˆæ€§èƒ½

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ¨¡å‹å¤šæ ·æ€§**: ç¡®ä¿åŸºå­¦ä¹ å™¨å…·æœ‰å¤šæ ·æ€§ï¼Œé¿å…åŒè´¨åŒ–
2. **é›†æˆæƒé‡**: å¯¹äºåŠ æƒé›†æˆï¼Œæ³¨æ„æƒé‡å½’ä¸€åŒ–
3. **å¹¶è¡Œè®­ç»ƒ**: åˆ©ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢å¹¶è¡Œè®­ç»ƒå¤šä¸ªåŸºå­¦ä¹ å™¨
4. **æŠ•ç¥¨æœºåˆ¶**: å®ç°æœ‰æ•ˆçš„æŠ•ç¥¨æˆ–åŠ æƒå¹³å‡æœºåˆ¶

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡é›†æˆå­¦ä¹ ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«æ¨¡å‹IDçš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Næ¨¡å‹é¢„æµ‹æŸ¥è¯¢å’Œå¤šæ¨¡å‹å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡é›†æˆå­¦ä¹ ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡Baggingé‡‡æ ·å’Œå¹¶è¡Œæ¨¡å‹èåˆ

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - é›†æˆå­¦ä¹ æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡é›†æˆå’Œå¹¶è¡ŒåŸºå­¦ä¹ å™¨è®­ç»ƒ

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–é›†æˆå­¦ä¹ æŸ¥è¯¢**

```sql
-- ä¸ºé›†æˆå­¦ä¹ æ•°æ®åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_ensemble_data_skip_scan
ON ensemble_data(label, feature1 DESC, feature2 DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªç±»åˆ«çš„æœ€å…¸å‹æ ·æœ¬
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (label)
    id,
    label,
    feature1,
    feature2
FROM ensemble_data
ORDER BY label, feature1 DESC, feature2 DESC
LIMIT 50;
```

### é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜é›†æˆå­¦ä¹ ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„é›†æˆå­¦ä¹ é¢„æµ‹ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜é›†æˆå­¦ä¹ é¢„æµ‹ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS ensemble_learning_prediction_cache AS
WITH base_learner_predictions AS (
    SELECT
        sample_id,
        learner_id,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—åŸºå­¦ä¹ å™¨é¢„æµ‹ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN feature1 > AVG(feature1) OVER (PARTITION BY learner_id) THEN 1
            ELSE 0
        END AS learner_prediction,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—åŸºå­¦ä¹ å™¨æƒé‡ï¼ˆåŸºäºå‡†ç¡®ç‡ï¼‰
        0.5 + (CASE
            WHEN feature1 > AVG(feature1) OVER (PARTITION BY learner_id) THEN 0.1
            ELSE -0.1
        END) AS learner_weight
    FROM ensemble_data
    CROSS JOIN generate_series(1, 10) AS learner_id  -- 10ä¸ªåŸºå­¦ä¹ å™¨
),
ensemble_vote AS (
    SELECT
        sample_id,
        -- åŠ æƒæŠ•ç¥¨
        SUM(learner_prediction * learner_weight) / NULLIF(SUM(learner_weight), 0) AS weighted_prediction,
        -- ç®€å•æŠ•ç¥¨
        AVG(learner_prediction) AS simple_vote,
        COUNT(*) FILTER (WHERE learner_prediction = 1) AS positive_votes,
        COUNT(*) FILTER (WHERE learner_prediction = 0) AS negative_votes
    FROM base_learner_predictions
    GROUP BY sample_id
)
SELECT
    sample_id,
    ROUND(weighted_prediction::numeric, 4) AS weighted_prediction,
    ROUND(simple_vote::numeric, 4) AS simple_vote,
    positive_votes,
    negative_votes,
    CASE
        WHEN weighted_prediction > 0.6 THEN 'Strong Positive Prediction'
        WHEN weighted_prediction > 0.4 THEN 'Weak Positive Prediction'
        WHEN weighted_prediction > 0.6 THEN 'Weak Negative Prediction'
        ELSE 'Strong Negative Prediction'
    END AS ensemble_category
FROM ensemble_vote
ORDER BY ABS(weighted_prediction - 0.5) DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_ensemble_prediction_cache_sample ON ensemble_learning_prediction_cache(sample_id);
CREATE INDEX idx_ensemble_prediction_cache_category ON ensemble_learning_prediction_cache(ensemble_category, ABS(weighted_prediction) DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY ensemble_learning_prediction_cache;
```

**2. å®æ—¶é›†æˆå­¦ä¹ ï¼šå¢é‡æ¨¡å‹æ›´æ–°**

**å®æ—¶é›†æˆå­¦ä¹ **ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°é›†æˆç»“æœã€‚

```sql
-- å®æ—¶é›†æˆå­¦ä¹ ï¼šå¢é‡æ¨¡å‹æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ensemble_learning_state') THEN
            CREATE TABLE ensemble_learning_state (
                ensemble_id VARCHAR(100) NOT NULL,
                learner_id INTEGER NOT NULL,
                learner_type VARCHAR(50) NOT NULL,  -- 'decision_tree', 'svm', 'neural_network', etc.
                sum_correct_predictions BIGINT DEFAULT 0,
                sum_total_predictions BIGINT DEFAULT 0,
                accuracy NUMERIC,
                learner_weight NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (ensemble_id, learner_id)
            );

            CREATE INDEX idx_ensemble_learning_state_ensemble ON ensemble_learning_state(ensemble_id, last_updated DESC);
            CREATE INDEX idx_ensemble_learning_state_updated ON ensemble_learning_state(last_updated DESC);

            RAISE NOTICE 'é›†æˆå­¦ä¹ çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡é›†æˆå­¦ä¹ æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡é›†æˆå­¦ä¹ æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**3. æ™ºèƒ½é›†æˆå­¦ä¹ ä¼˜åŒ–ï¼šè‡ªé€‚åº”é›†æˆç­–ç•¥é€‰æ‹©**

**æ™ºèƒ½é›†æˆå­¦ä¹ ä¼˜åŒ–**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜é›†æˆç­–ç•¥ã€‚

```sql
-- æ™ºèƒ½é›†æˆå­¦ä¹ ä¼˜åŒ–ï¼šè‡ªé€‚åº”é›†æˆç­–ç•¥é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    sample_size BIGINT;
    feature_count INTEGER;
    class_balance NUMERIC;
    recommended_strategy VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ensemble_data') THEN
            RAISE WARNING 'è¡¨ ensemble_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½é›†æˆå­¦ä¹ ä¼˜åŒ–';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        SELECT
            COUNT(*),
            (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'ensemble_data' AND column_name LIKE 'feature%'),
            MIN(class_ratio) / NULLIF(MAX(class_ratio), 0)
        INTO sample_size, feature_count, class_balance
        FROM (
            SELECT
                label,
                COUNT(*)::numeric / SUM(COUNT(*)) OVER () AS class_ratio
            FROM ensemble_data
            GROUP BY label
        ) class_ratios;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©é›†æˆç­–ç•¥
        IF sample_size < 1000 AND class_balance > 0.8 THEN
            recommended_strategy := 'BOOSTING';  -- å°æ ·æœ¬å¹³è¡¡ï¼šBoosting
        ELSIF sample_size >= 1000 THEN
            recommended_strategy := 'BAGGING';  -- å¤§æ ·æœ¬ï¼šBagging
        ELSIF class_balance < 0.5 THEN
            recommended_strategy := 'STACKING';  -- ä¸å¹³è¡¡ï¼šStacking
        ELSE
            recommended_strategy := 'VOTING';  -- å…¶ä»–ï¼šç®€å•æŠ•ç¥¨
        END IF;

        RAISE NOTICE 'æ ·æœ¬å¤§å°: %, ç‰¹å¾æ•°: %, ç±»åˆ«å¹³è¡¡åº¦: %, æ¨èç­–ç•¥: %',
            sample_size, feature_count, class_balance, recommended_strategy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½é›†æˆå­¦ä¹ ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç†è®ºæ¨å¯¼ã€å®ç°å’ŒPostgreSQL 18æ–°ç‰¹æ€§æ”¯æŒï¼‰
