# PostgreSQL é›†æˆå­¦ä¹ ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æœºå™¨å­¦ä¹  | é›†æˆå­¦ä¹  | æ¨¡å‹èåˆ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Ensemble Methods (Zhou), Machine Learning, Pattern Recognition

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL é›†æˆå­¦ä¹ ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-é›†æˆå­¦ä¹ ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [é›†æˆå­¦ä¹ æ¦‚è¿°](#é›†æˆå­¦ä¹ æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [æ ¸å¿ƒæ€æƒ³](#æ ¸å¿ƒæ€æƒ³)
    - [é›†æˆç­–ç•¥](#é›†æˆç­–ç•¥)
  - [1. Bagging](#1-bagging)
    - [1.1 Bootstrapé‡‡æ ·](#11-bootstrapé‡‡æ ·)
  - [2. Boosting](#2-boosting)
    - [2.1 AdaBoost](#21-adaboost)
    - [2.2 Stacking](#22-stacking)
  - [3. æ¨¡å‹èåˆ](#3-æ¨¡å‹èåˆ)
    - [3.1 æŠ•ç¥¨æ³•](#31-æŠ•ç¥¨æ³•)
    - [3.2 åŠ æƒå¹³å‡](#32-åŠ æƒå¹³å‡)
  - [4. å¤æ‚åº¦åˆ†æ](#4-å¤æ‚åº¦åˆ†æ)
    - [4.1 æ—¶é—´å¤æ‚åº¦](#41-æ—¶é—´å¤æ‚åº¦)
    - [4.2 ç©ºé—´å¤æ‚åº¦](#42-ç©ºé—´å¤æ‚åº¦)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 åˆ†ç±»ä»»åŠ¡é›†æˆ](#51-åˆ†ç±»ä»»åŠ¡é›†æˆ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## é›†æˆå­¦ä¹ æ¦‚è¿°

**é›†æˆå­¦ä¹ **é€šè¿‡ç»„åˆå¤šä¸ªå¼±å­¦ä¹ å™¨æ„å»ºå¼ºå­¦ä¹ å™¨ã€‚

### ç†è®ºåŸºç¡€

**é›†æˆå­¦ä¹ çš„ä¼˜åŠ¿**:

- é™ä½æ–¹å·®ï¼ˆBaggingï¼‰
- é™ä½åå·®ï¼ˆBoostingï¼‰
- æé«˜æ³›åŒ–èƒ½åŠ›

### æ ¸å¿ƒæ€æƒ³

**ä¸‰ä¸ªè‡­çš®åŒ é¡¶ä¸ªè¯¸è‘›äº®**: å¤šä¸ªæ¨¡å‹çš„ç»„åˆé€šå¸¸æ¯”å•ä¸ªæ¨¡å‹æ›´å¥½ã€‚

### é›†æˆç­–ç•¥

| ç­–ç•¥ | æ–¹æ³• | ç‰¹ç‚¹ |
|------|------|------|
| **Bagging** | å¹¶è¡Œè®­ç»ƒï¼ŒæŠ•ç¥¨/å¹³å‡ | é™ä½æ–¹å·® |
| **Boosting** | ä¸²è¡Œè®­ç»ƒï¼ŒåŠ æƒç»„åˆ | é™ä½åå·® |
| **Stacking** | å…ƒå­¦ä¹ å™¨ç»„åˆ | å­¦ä¹ æœ€ä¼˜ç»„åˆ |

---

## 1. Bagging

### 1.1 Bootstrapé‡‡æ ·

**Bootstrapé‡‡æ ·**ç”Ÿæˆå¤šä¸ªè®­ç»ƒé›†ã€‚

```sql
-- Baggingå®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ensemble_data') THEN
            DROP TABLE ensemble_data CASCADE;
        END IF;

        CREATE TABLE ensemble_data (
            id SERIAL PRIMARY KEY,
            feature1 NUMERIC NOT NULL,
            feature2 NUMERIC NOT NULL,
            label INTEGER NOT NULL
        );

        INSERT INTO ensemble_data (feature1, feature2, label) VALUES
            (1.0, 2.0, 0), (1.5, 2.5, 0), (2.0, 3.0, 1);

        RAISE NOTICE 'è¡¨ ensemble_data åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Bootstrapé‡‡æ ·
WITH bootstrap_samples AS (
    SELECT
        model_id,
        id,
        feature1,
        feature2,
        label
    FROM (
        SELECT
            generate_series(1, 10) AS model_id,
            (SELECT id FROM ensemble_data ORDER BY RANDOM() LIMIT 1) AS id
        FROM generate_series(1, 100)
    ) bootstrap_ids
    JOIN ensemble_data ON bootstrap_ids.id = ensemble_data.id
)
SELECT
    model_id,
    COUNT(*) AS sample_count
FROM bootstrap_samples
GROUP BY model_id;
```

---

## 2. Boosting

### 2.1 AdaBoost

**AdaBoost**é€šè¿‡åŠ æƒç»„åˆå¼±å­¦ä¹ å™¨ï¼Œé€æ­¥æå‡æ¨¡å‹æ€§èƒ½ã€‚

**ç®—æ³•æµç¨‹**ï¼š

1. åˆå§‹åŒ–æ ·æœ¬æƒé‡ $w_i = 1/N$
2. è®­ç»ƒå¼±å­¦ä¹ å™¨
3. è®¡ç®—é”™è¯¯ç‡ $\epsilon_t$
4. è®¡ç®—æƒé‡ $\alpha_t = \frac{1}{2}\ln\left(\frac{1-\epsilon_t}{\epsilon_t}\right)$
5. æ›´æ–°æ ·æœ¬æƒé‡
6. é‡å¤æ­¥éª¤2-5ç›´åˆ°æ”¶æ•›

**æƒé‡æ›´æ–°**:
$$\alpha_t = \frac{1}{2}\ln\left(\frac{1-\epsilon_t}{\epsilon_t}\right)$$

```sql
-- AdaBoostå®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'adaboost_iteration') THEN
            DROP TABLE adaboost_iteration, adaboost_models CASCADE;
        END IF;

        -- AdaBoostè¿­ä»£è¡¨
        CREATE TABLE adaboost_iteration (
            iteration INTEGER NOT NULL,
            sample_id INTEGER NOT NULL,
            initial_weight NUMERIC NOT NULL,
            prediction INTEGER,
            actual_label INTEGER NOT NULL,
            prediction_error INTEGER DEFAULT 0,
            alpha NUMERIC,
            updated_weight NUMERIC,
            PRIMARY KEY (iteration, sample_id)
        );

        -- åˆå§‹åŒ–ï¼šç¬¬1æ¬¡è¿­ä»£
        INSERT INTO adaboost_iteration (iteration, sample_id, initial_weight, actual_label)
        SELECT
            1,
            id,
            1.0 / (SELECT COUNT(*) FROM ensemble_data) AS initial_weight,
            label
        FROM ensemble_data;

        RAISE NOTICE 'AdaBoostè¿­ä»£è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- AdaBoostï¼šè®¡ç®—é”™è¯¯ç‡å’Œæƒé‡
WITH iteration_stats AS (
    SELECT
        iteration,
        SUM(initial_weight * prediction_error) AS weighted_error,
        COUNT(*) AS total_samples
    FROM adaboost_iteration
    GROUP BY iteration
),
adaboost_weights AS (
    SELECT
        ai.iteration,
        ai.sample_id,
        ai.initial_weight,
        ai.prediction_error,
        is_stats.weighted_error AS error_rate,
        -- è®¡ç®—alpha
        CASE
            WHEN is_stats.weighted_error > 0 AND is_stats.weighted_error < 0.5 THEN
                0.5 * LN((1 - is_stats.weighted_error) / NULLIF(is_stats.weighted_error, 0))
            ELSE 0
        END AS alpha,
        -- æ›´æ–°æƒé‡
        ai.initial_weight * EXP(
            CASE
                WHEN ai.prediction_error = 1 THEN
                    0.5 * LN((1 - is_stats.weighted_error) / NULLIF(is_stats.weighted_error, 0))
                ELSE
                    -0.5 * LN((1 - is_stats.weighted_error) / NULLIF(is_stats.weighted_error, 0))
            END
        ) AS updated_weight
    FROM adaboost_iteration ai
    JOIN iteration_stats is_stats ON ai.iteration = is_stats.iteration
)
SELECT
    iteration,
    sample_id,
    ROUND(initial_weight::numeric, 4) AS initial_weight,
    prediction_error,
    ROUND(error_rate::numeric, 4) AS error_rate,
    ROUND(alpha::numeric, 4) AS alpha,
    ROUND(updated_weight::numeric, 4) AS updated_weight
FROM adaboost_weights
ORDER BY iteration, sample_id;
```

### 2.2 Stacking

**Stacking**ä½¿ç”¨å…ƒå­¦ä¹ å™¨å­¦ä¹ å¦‚ä½•ç»„åˆåŸºå­¦ä¹ å™¨ã€‚

**ç®—æ³•æµç¨‹**ï¼š

1. è®­ç»ƒå¤šä¸ªåŸºå­¦ä¹ å™¨
2. ä½¿ç”¨åŸºå­¦ä¹ å™¨é¢„æµ‹
3. è®­ç»ƒå…ƒå­¦ä¹ å™¨ç»„åˆé¢„æµ‹

```sql
-- Stackingï¼šåŸºå­¦ä¹ å™¨é¢„æµ‹
WITH base_models AS (
    SELECT
        id,
        label AS actual_label,
        -- åŸºå­¦ä¹ å™¨1é¢„æµ‹ï¼ˆç®€åŒ–ï¼šä½¿ç”¨çº¿æ€§åˆ†ç±»ï¼‰
        CASE WHEN feature1 + feature2 > 3 THEN 1 ELSE 0 END AS model1_pred,
        -- åŸºå­¦ä¹ å™¨2é¢„æµ‹
        CASE WHEN feature1 * feature2 > 4 THEN 1 ELSE 0 END AS model2_pred,
        -- åŸºå­¦ä¹ å™¨3é¢„æµ‹
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END AS model3_pred
    FROM ensemble_data
),
meta_features AS (
    SELECT
        id,
        actual_label,
        model1_pred,
        model2_pred,
        model3_pred,
        -- å…ƒç‰¹å¾ï¼šåŸºå­¦ä¹ å™¨é¢„æµ‹çš„å¹³å‡å€¼
        (model1_pred + model2_pred + model3_pred) / 3.0 AS meta_feature
    FROM base_models
)
SELECT
    id,
    actual_label,
    model1_pred,
    model2_pred,
    model3_pred,
    ROUND(meta_feature::numeric, 4) AS meta_feature,
    -- å…ƒå­¦ä¹ å™¨é¢„æµ‹ï¼ˆç®€åŒ–ï¼šé˜ˆå€¼0.5ï¼‰
    CASE WHEN meta_feature > 0.5 THEN 1 ELSE 0 END AS stacking_prediction
FROM meta_features
ORDER BY id;
```

---

## 3. æ¨¡å‹èåˆ

### 3.1 æŠ•ç¥¨æ³•

**æŠ•ç¥¨æ³•**é€šè¿‡å¤šæ•°æŠ•ç¥¨ç»„åˆé¢„æµ‹ã€‚

```sql
-- æŠ•ç¥¨æ³•ï¼šå¤šæ•°æŠ•ç¥¨
WITH model_predictions AS (
    SELECT
        id,
        label AS actual_label,
        CASE WHEN feature1 + feature2 > 3 THEN 1 ELSE 0 END AS model1_pred,
        CASE WHEN feature1 * feature2 > 4 THEN 1 ELSE 0 END AS model2_pred,
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END AS model3_pred
    FROM ensemble_data
),
voting_result AS (
    SELECT
        id,
        actual_label,
        model1_pred,
        model2_pred,
        model3_pred,
        -- å¤šæ•°æŠ•ç¥¨
        CASE
            WHEN (model1_pred + model2_pred + model3_pred) >= 2 THEN 1
            ELSE 0
        END AS majority_vote,
        -- ä¸€è‡´æ€§æ£€æŸ¥
        CASE
            WHEN model1_pred = model2_pred AND model2_pred = model3_pred THEN 'Unanimous'
            ELSE 'Majority'
        END AS vote_type
    FROM model_predictions
)
SELECT
    id,
    actual_label,
    model1_pred || ',' || model2_pred || ',' || model3_pred AS individual_predictions,
    majority_vote AS ensemble_prediction,
    vote_type,
    CASE
        WHEN majority_vote = actual_label THEN 'Correct âœ“'
        ELSE 'Incorrect âœ—'
    END AS prediction_status
FROM voting_result
ORDER BY id;
```

### 3.2 åŠ æƒå¹³å‡

**åŠ æƒå¹³å‡**æ ¹æ®æ¨¡å‹æ€§èƒ½åˆ†é…æƒé‡ã€‚

```sql
-- åŠ æƒå¹³å‡ï¼šæ ¹æ®å‡†ç¡®ç‡åˆ†é…æƒé‡
WITH model_performance AS (
    SELECT
        'model1' AS model_name,
        CASE WHEN feature1 + feature2 > 3 THEN 1 ELSE 0 END AS prediction,
        label AS actual_label
    FROM ensemble_data

    UNION ALL

    SELECT
        'model2',
        CASE WHEN feature1 * feature2 > 4 THEN 1 ELSE 0 END,
        label
    FROM ensemble_data

    UNION ALL

    SELECT
        'model3',
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END,
        label
    FROM ensemble_data
),
model_accuracy AS (
    SELECT
        model_name,
        COUNT(*) FILTER (WHERE prediction = actual_label)::NUMERIC / COUNT(*) AS accuracy
    FROM model_performance
    GROUP BY model_name
),
model_weights AS (
    SELECT
        model_name,
        accuracy,
        -- æƒé‡ï¼šå‡†ç¡®ç‡å½’ä¸€åŒ–
        accuracy / SUM(accuracy) OVER () AS weight
    FROM model_accuracy
),
weighted_predictions AS (
    SELECT
        ed.id,
        ed.label AS actual_label,
        CASE WHEN ed.feature1 + ed.feature2 > 3 THEN 1 ELSE 0 END AS model1_pred,
        CASE WHEN ed.feature1 * ed.feature2 > 4 THEN 1 ELSE 0 END AS model2_pred,
        CASE WHEN ed.feature1 > 1.5 THEN 1 ELSE 0 END AS model3_pred,
        (SELECT weight FROM model_weights WHERE model_name = 'model1') AS w1,
        (SELECT weight FROM model_weights WHERE model_name = 'model2') AS w2,
        (SELECT weight FROM model_weights WHERE model_name = 'model3') AS w3
    FROM ensemble_data ed
)
SELECT
    id,
    actual_label,
    ROUND((model1_pred * w1 + model2_pred * w2 + model3_pred * w3)::numeric, 4) AS weighted_prediction,
    CASE
        WHEN (model1_pred * w1 + model2_pred * w2 + model3_pred * w3) > 0.5 THEN 1
        ELSE 0
    END AS ensemble_prediction
FROM weighted_predictions
ORDER BY id;
```

---

## 4. å¤æ‚åº¦åˆ†æ

### 4.1 æ—¶é—´å¤æ‚åº¦

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | è¯´æ˜ |
|------|-----------|------|
| **Bagging** | $O(T \cdot n \log n)$ | Tä¸ªæ¨¡å‹ï¼Œnä¸ªæ ·æœ¬ |
| **Boosting** | $O(T \cdot n \log n)$ | Tæ¬¡è¿­ä»£ |
| **Stacking** | $O(T \cdot n \log n + n \log n)$ | åŸºå­¦ä¹ å™¨+å…ƒå­¦ä¹ å™¨ |

### 4.2 ç©ºé—´å¤æ‚åº¦

| æ–¹æ³• | ç©ºé—´å¤æ‚åº¦ |
|------|-----------|
| **Bagging** | $O(T \cdot n)$ |
| **Boosting** | $O(n)$ |
| **Stacking** | $O(T \cdot n)$ |

---

## 5. PostgreSQL 18 å¹¶è¡Œé›†æˆå­¦ä¹ å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œé›†æˆå­¦ä¹ è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡ŒBaggingã€Boostingå’Œæ¨¡å‹èåˆï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡é›†æˆå­¦ä¹ è®­ç»ƒçš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œé›†æˆå­¦ä¹ åŸç†

PostgreSQL 18 çš„å¹¶è¡Œé›†æˆå­¦ä¹ é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æè®­ç»ƒæ•°æ®
2. **å¹¶è¡ŒBootstrapé‡‡æ ·**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡ŒBootstrapé‡‡æ ·
3. **å¹¶è¡Œæ¨¡å‹è®­ç»ƒ**ï¼šå¹¶è¡Œè®­ç»ƒå¤šä¸ªå¼±å­¦ä¹ å™¨
4. **å¹¶è¡Œé¢„æµ‹èåˆ**ï¼šå¹¶è¡Œæ‰§è¡ŒæŠ•ç¥¨å’ŒåŠ æƒå¹³å‡
5. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„ç»“æœ

### 5.2 å¹¶è¡ŒBagging

```sql
-- PostgreSQL 18 å¹¶è¡ŒBaggingï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ensemble_data') THEN
            RAISE WARNING 'è¡¨ ensemble_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒBagging';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒBagging';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒBaggingå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒBootstrapé‡‡æ ·
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH bootstrap_samples AS (
    SELECT
        model_id,
        (random() * (SELECT COUNT(*) FROM ensemble_data) + 1)::INTEGER AS sample_id
    FROM generate_series(1, 100) AS model_id
    CROSS JOIN generate_series(1, (SELECT COUNT(*) FROM ensemble_data)) AS sample_idx
)
SELECT
    model_id,
    sample_id,
    COUNT(*) AS sample_count
FROM bootstrap_samples
GROUP BY model_id, sample_id
ORDER BY model_id, sample_id
LIMIT 1000;
```

### 5.3 å¹¶è¡Œæ¨¡å‹èåˆ

```sql
-- PostgreSQL 18 å¹¶è¡Œæ¨¡å‹èåˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'model_predictions') THEN
            RAISE WARNING 'è¡¨ model_predictions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæ¨¡å‹èåˆ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæ¨¡å‹èåˆ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ¨¡å‹èåˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒæŠ•ç¥¨å’ŒåŠ æƒå¹³å‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH ensemble_predictions AS (
    SELECT
        sample_id,
        predicted_class,
        prediction_weight,
        COUNT(*) AS vote_count
    FROM model_predictions
    GROUP BY sample_id, predicted_class, prediction_weight
),
majority_vote AS (
    SELECT DISTINCT ON (sample_id)
        sample_id,
        predicted_class,
        vote_count,
        SUM(prediction_weight) AS weighted_sum
    FROM ensemble_predictions
    GROUP BY sample_id, predicted_class, vote_count
    ORDER BY sample_id, vote_count DESC, weighted_sum DESC
)
SELECT
    sample_id,
    predicted_class AS ensemble_prediction,
    vote_count,
    ROUND(weighted_sum::numeric, 4) AS weighted_score
FROM majority_vote
ORDER BY sample_id;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 åˆ†ç±»ä»»åŠ¡é›†æˆ

```sql
-- åˆ†ç±»ä»»åŠ¡ï¼šé›†æˆå¤šä¸ªåˆ†ç±»å™¨
WITH ensemble_classification AS (
    SELECT
        id,
        feature1,
        feature2,
        label AS actual_label,
        -- å¤šä¸ªåŸºåˆ†ç±»å™¨
        CASE WHEN feature1 > 1.5 THEN 1 ELSE 0 END AS classifier1,
        CASE WHEN feature2 > 2.5 THEN 1 ELSE 0 END AS classifier2,
        CASE WHEN feature1 + feature2 > 4 THEN 1 ELSE 0 END AS classifier3
    FROM ensemble_data
),
ensemble_result AS (
    SELECT
        id,
        actual_label,
        classifier1,
        classifier2,
        classifier3,
        -- å¤šæ•°æŠ•ç¥¨
        CASE
            WHEN (classifier1 + classifier2 + classifier3) >= 2 THEN 1
            ELSE 0
        END AS ensemble_prediction
    FROM ensemble_classification
)
SELECT
    COUNT(*) AS total_samples,
    COUNT(*) FILTER (WHERE ensemble_prediction = actual_label) AS correct_predictions,
    ROUND(COUNT(*) FILTER (WHERE ensemble_prediction = actual_label)::NUMERIC / COUNT(*) * 100, 2) AS ensemble_accuracy
FROM ensemble_result;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Zhou, Z.H. (2012)**: "Ensemble Methods: Foundations and Algorithms"
2. **Dietterich, T.G. (2000)**: "Ensemble Methods in Machine Learning"
3. **Breiman, L. (1996)**: "Bagging Predictors"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¹¶è¡Œè®­ç»ƒ**ï¼šå¹¶è¡Œè®­ç»ƒå¤šä¸ªåŸºå­¦ä¹ å™¨
2. **æ¨¡å‹é€‰æ‹©**ï¼šé€‰æ‹©å¤šæ ·åŒ–çš„åŸºå­¦ä¹ å™¨
3. **æƒé‡ä¼˜åŒ–**ï¼šä¼˜åŒ–é›†æˆæƒé‡
4. **äº¤å‰éªŒè¯**ï¼šä½¿ç”¨äº¤å‰éªŒè¯è¯„ä¼°é›†æˆæ€§èƒ½

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **åŸºå­¦ä¹ å™¨å¤šæ ·æ€§**ï¼šé€‰æ‹©ä¸åŒç±»å‹çš„åŸºå­¦ä¹ å™¨
2. **é›†æˆç­–ç•¥**ï¼šæ ¹æ®é—®é¢˜ç‰¹æ€§é€‰æ‹©Baggingæˆ–Boosting
3. **è¶…å‚æ•°è°ƒä¼˜**ï¼šè°ƒä¼˜åŸºå­¦ä¹ å™¨å’Œé›†æˆå‚æ•°
4. **æ€§èƒ½è¯„ä¼°**ï¼šä½¿ç”¨ç‹¬ç«‹æµ‹è¯•é›†è¯„ä¼°é›†æˆæ€§èƒ½

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
