# PostgreSQL 多重比较校正算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 统计推断 | 多重比较 | 错误控制
> **难度级别**: ⭐⭐⭐⭐ (高级)
> **参考标准**: Multiple Comparisons, Family-Wise Error Rate, Statistical Inference

---

## 📋 目录

- [PostgreSQL 多重比较校正算法完整指南](#postgresql-多重比较校正算法完整指南)
  - [📋 目录](#-目录)
  - [多重比较概述](#多重比较概述)
  - [1. Bonferroni校正](#1-bonferroni校正)
  - [2. FDR控制](#2-fdr控制)
  - [3. Holm方法](#3-holm方法)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 基因组学研究](#41-基因组学研究)
    - [4.2 A/B测试](#42-ab测试)
  - [📊 性能优化建议](#-性能优化建议)
    - [索引优化](#索引优化)
    - [并行计算](#并行计算)
  - [🎯 最佳实践](#-最佳实践)
    - [方法选择](#方法选择)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 多重比较方法对比](#-多重比较方法对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：校正后无显著结果](#问题1校正后无显著结果)
    - [问题2：方法选择困难](#问题2方法选择困难)
  - [📚 参考资源](#-参考资源)

---

## 多重比较概述

**多重比较问题**：进行多个假设检验时，第一类错误率会累积增加。

---

## 1. Bonferroni校正

**Bonferroni校正**：将显著性水平除以检验次数。

$$\alpha_{adjusted} = \frac{\alpha}{m}$$

其中 $m$ 是检验次数。

```sql
-- Bonferroni校正实现（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multiple_tests') THEN
            RAISE WARNING '表 multiple_tests 已存在，先删除';
            DROP TABLE multiple_tests CASCADE;
        END IF;

        CREATE TABLE multiple_tests (
            test_id SERIAL PRIMARY KEY,
            p_value NUMERIC NOT NULL,
            test_name VARCHAR(100) NOT NULL
        );

        INSERT INTO multiple_tests (p_value, test_name) VALUES
            (0.01, 'Test1'), (0.02, 'Test2'), (0.03, 'Test3'),
            (0.04, 'Test4'), (0.05, 'Test5');

        RAISE NOTICE '表 multiple_tests 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- Bonferroni校正
WITH test_count AS (
    SELECT COUNT(*) AS m FROM multiple_tests
),
bonferroni_correction AS (
    SELECT
        test_id,
        test_name,
        p_value,
        0.05 / (SELECT m FROM test_count) AS adjusted_alpha,
        CASE
            WHEN p_value < (0.05 / (SELECT m FROM test_count)) THEN 'Significant'
            ELSE 'Not significant'
        END AS bonferroni_result
    FROM multiple_tests
    CROSS JOIN test_count
)
SELECT
    test_id,
    test_name,
    ROUND(p_value::numeric, 4) AS p_value,
    ROUND(adjusted_alpha::numeric, 4) AS adjusted_alpha,
    bonferroni_result
FROM bonferroni_correction
ORDER BY p_value;
```

---

## 2. FDR控制

**FDR（False Discovery Rate）控制**使用Benjamini-Hochberg方法。

```sql
-- FDR控制（Benjamini-Hochberg）
WITH ranked_tests AS (
    SELECT
        test_id,
        test_name,
        p_value,
        ROW_NUMBER() OVER (ORDER BY p_value) AS rank,
        COUNT(*) OVER () AS total_tests
    FROM multiple_tests
),
fdr_thresholds AS (
    SELECT
        test_id,
        test_name,
        p_value,
        rank,
        (rank::NUMERIC / total_tests) * 0.05 AS fdr_threshold
    FROM ranked_tests
)
SELECT
    test_id,
    test_name,
    ROUND(p_value::numeric, 4) AS p_value,
    ROUND(fdr_threshold::numeric, 4) AS fdr_threshold,
    CASE
        WHEN p_value <= fdr_threshold THEN 'Significant'
        ELSE 'Not significant'
    END AS fdr_result
FROM fdr_thresholds
ORDER BY p_value;
```

---

## 3. Holm方法

**Holm方法**是Bonferroni的改进，更powerful。

```sql
-- Holm方法
WITH ranked_tests AS (
    SELECT
        test_id,
        p_value,
        ROW_NUMBER() OVER (ORDER BY p_value) AS rank,
        COUNT(*) OVER () AS total_tests
    FROM multiple_tests
),
holm_adjustment AS (
    SELECT
        test_id,
        p_value,
        rank,
        0.05 / (total_tests - rank + 1) AS holm_alpha
    FROM ranked_tests
)
SELECT
    test_id,
    ROUND(p_value::numeric, 4) AS p_value,
    ROUND(holm_alpha::numeric, 4) AS holm_alpha,
    CASE
        WHEN p_value < holm_alpha THEN 'Significant'
        ELSE 'Not significant'
    END AS holm_result
FROM holm_adjustment
ORDER BY p_value;
```

---

## 4. 实际应用案例

### 4.1 基因组学研究

```sql
-- 基因组学多重比较应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'genomics_tests') THEN
            CREATE TABLE genomics_tests (
                gene_id INTEGER PRIMARY KEY,
                p_value NUMERIC NOT NULL,
                gene_name VARCHAR(100)
            );

            -- 插入基因表达差异检验结果
            INSERT INTO genomics_tests (gene_id, p_value, gene_name) VALUES
                (1, 0.001, 'Gene1'), (2, 0.002, 'Gene2'), (3, 0.003, 'Gene3'),
                (4, 0.01, 'Gene4'), (5, 0.02, 'Gene5');

            RAISE NOTICE '基因组学检验数据表创建成功';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '基因组学应用准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- FDR控制（适用于大规模检验）
WITH ranked_genes AS (
    SELECT
        gene_id,
        gene_name,
        p_value,
        ROW_NUMBER() OVER (ORDER BY p_value) AS rank,
        COUNT(*) OVER () AS total_genes
    FROM genomics_tests
),
fdr_correction AS (
    SELECT
        gene_id,
        gene_name,
        p_value,
        rank,
        (rank::NUMERIC / total_genes) * 0.05 AS fdr_threshold
    FROM ranked_genes
)
SELECT
    gene_id,
    gene_name,
    ROUND(p_value::numeric, 6) AS p_value,
    ROUND(fdr_threshold::numeric, 6) AS fdr_threshold,
    CASE
        WHEN p_value <= fdr_threshold THEN 'Significant'
        ELSE 'Not significant'
    END AS fdr_result
FROM fdr_correction
ORDER BY p_value;
```

### 4.2 A/B测试

```sql
-- A/B测试多重比较应用
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ab_test_results') THEN
            CREATE TABLE ab_test_results (
                test_id INTEGER PRIMARY KEY,
                metric_name VARCHAR(50) NOT NULL,
                p_value NUMERIC NOT NULL
            );

            -- 插入A/B测试结果
            INSERT INTO ab_test_results (test_id, metric_name, p_value) VALUES
                (1, 'Click Rate', 0.03),
                (2, 'Conversion Rate', 0.04),
                (3, 'Revenue', 0.05),
                (4, 'Retention', 0.06);

            RAISE NOTICE 'A/B测试结果表创建成功';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'A/B测试应用准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Bonferroni校正（保守方法）
WITH test_count AS (
    SELECT COUNT(*) AS m FROM ab_test_results
),
bonferroni_corrected AS (
    SELECT
        test_id,
        metric_name,
        p_value,
        0.05 / (SELECT m FROM test_count) AS adjusted_alpha
    FROM ab_test_results
    CROSS JOIN test_count
)
SELECT
    test_id,
    metric_name,
    ROUND(p_value::numeric, 4) AS p_value,
    ROUND(adjusted_alpha::numeric, 6) AS adjusted_alpha,
    CASE
        WHEN p_value < adjusted_alpha THEN 'Significant'
        ELSE 'Not significant'
    END AS bonferroni_result
FROM bonferroni_corrected
ORDER BY p_value;
```

---

## 📊 性能优化建议

### 索引优化

```sql
-- 创建关键索引
CREATE INDEX IF NOT EXISTS idx_p_value ON multiple_tests(p_value);
CREATE INDEX IF NOT EXISTS idx_test_id ON multiple_tests(test_id);
```

### 并行计算

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;
```

---

## 🎯 最佳实践

### 方法选择

1. **Bonferroni**: 保守，适用于检验数量少
2. **Holm**: 比Bonferroni更powerful，推荐使用
3. **FDR**: 适用于大规模检验（如基因组学）

### SQL实现注意事项

1. **错误处理**: 使用DO块和EXCEPTION进行错误处理
2. **数值精度**: 注意p值排序和比较的精度
3. **性能优化**: 使用索引优化排序性能

---

## 📈 多重比较方法对比

| 方法 | FWER控制 | Power | 适用场景 |
|------|---------|-------|---------|
| **Bonferroni** | 是 | 低 | 检验数量少 |
| **Holm** | 是 | 中 | 一般情况 |
| **FDR (BH)** | 否 | 高 | 大规模检验 |

---

## 🔍 常见问题与解决方案

### 问题1：校正后无显著结果

**原因**：

- 检验数量多
- 效应量小
- 样本量不足

**解决方案**：

- 使用FDR方法
- 增加样本量
- 预筛选检验

### 问题2：方法选择困难

**原因**：

- 不了解方法差异
- 应用场景不明确

**解决方案**：

- FWER控制：使用Bonferroni或Holm
- FDR控制：使用BH方法
- 大规模检验：使用FDR

---

## 📚 参考资源

1. **Benjamini, Y., Hochberg, Y. (1995)**: "Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing", Journal of the Royal Statistical Society, Series B, 57(1), 289-300
2. **Holm, S. (1979)**: "A Simple Sequentially Rejective Multiple Test Procedure", Scandinavian Journal of Statistics, 6(2), 65-70
3. **Bonferroni, C.E. (1936)**: "Teoria statistica delle classi e calcolo delle probabilità", Pubblicazioni del R Istituto Superiore di Scienze Economiche e Commerciali di Firenze, 8, 3-62

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
