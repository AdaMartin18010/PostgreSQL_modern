# PostgreSQL è´å¶æ–¯ç»Ÿè®¡ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ç»Ÿè®¡æ¨æ–­ | è´å¶æ–¯ç»Ÿè®¡ | æ¦‚ç‡æ¨ç†
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Bayesian Data Analysis (Gelman et al.), Statistical Inference, Probability Theory

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL è´å¶æ–¯ç»Ÿè®¡ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-è´å¶æ–¯ç»Ÿè®¡ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [è´å¶æ–¯ç»Ÿè®¡æ¦‚è¿°](#è´å¶æ–¯ç»Ÿè®¡æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [è´å¶æ–¯å®šç†](#è´å¶æ–¯å®šç†)
    - [å…ˆéªŒä¸åéªŒ](#å…ˆéªŒä¸åéªŒ)
  - [1. è´å¶æ–¯æ¨æ–­](#1-è´å¶æ–¯æ¨æ–­)
    - [1.1 åéªŒåˆ†å¸ƒ](#11-åéªŒåˆ†å¸ƒ)
    - [1.2 å…±è½­å…ˆéªŒ](#12-å…±è½­å…ˆéªŒ)
    - [1.3 åéªŒé¢„æµ‹](#13-åéªŒé¢„æµ‹)
  - [2. MCMCæ–¹æ³•](#2-mcmcæ–¹æ³•)
    - [2.1 Metropolis-Hastingsç®—æ³•](#21-metropolis-hastingsç®—æ³•)
    - [2.2 Gibbsé‡‡æ ·](#22-gibbsé‡‡æ ·)
  - [3. è´å¶æ–¯æ¨¡å‹é€‰æ‹©](#3-è´å¶æ–¯æ¨¡å‹é€‰æ‹©)
    - [3.1 è´å¶æ–¯å› å­](#31-è´å¶æ–¯å› å­)
    - [3.2 ä¿¡æ¯å‡†åˆ™](#32-ä¿¡æ¯å‡†åˆ™)
  - [4. PostgreSQL 18 å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡å¢å¼º](#4-postgresql-18-å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡å¢å¼º)
    - [4.1 å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡åŸç†](#41-å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡åŸç†)
    - [4.2 å¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—](#42-å¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—)
    - [4.3 å¹¶è¡ŒMCMCé‡‡æ ·](#43-å¹¶è¡Œmcmcé‡‡æ ·)
  - [5. å¤æ‚åº¦åˆ†æ](#5-å¤æ‚åº¦åˆ†æ)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 å‚æ•°ä¼°è®¡](#51-å‚æ•°ä¼°è®¡)
    - [5.2 A/Bæµ‹è¯•](#52-abæµ‹è¯•)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## è´å¶æ–¯ç»Ÿè®¡æ¦‚è¿°

**è´å¶æ–¯ç»Ÿè®¡**æ˜¯ä¸€ç§æ¦‚ç‡æ¨ç†æ–¹æ³•ï¼Œé€šè¿‡ç»“åˆå…ˆéªŒçŸ¥è¯†å’Œè§‚æµ‹æ•°æ®æ¥æ›´æ–°å¯¹å‚æ•°çš„ä¿¡å¿µã€‚

### ç†è®ºåŸºç¡€

è´å¶æ–¯ç»Ÿè®¡çš„æ ¸å¿ƒæ˜¯å°†å‚æ•°è§†ä¸ºéšæœºå˜é‡ï¼Œä½¿ç”¨æ¦‚ç‡åˆ†å¸ƒæè¿°ä¸ç¡®å®šæ€§ã€‚

### è´å¶æ–¯å®šç†

**è´å¶æ–¯å®šç†**:
$$P(\theta | x) = \frac{P(x | \theta) P(\theta)}{P(x)} = \frac{P(x | \theta) P(\theta)}{\int P(x | \theta) P(\theta) d\theta}$$

å…¶ä¸­ï¼š

- $P(\theta | x)$ æ˜¯**åéªŒåˆ†å¸ƒ**ï¼ˆPosteriorï¼‰
- $P(x | \theta)$ æ˜¯**ä¼¼ç„¶å‡½æ•°**ï¼ˆLikelihoodï¼‰
- $P(\theta)$ æ˜¯**å…ˆéªŒåˆ†å¸ƒ**ï¼ˆPriorï¼‰
- $P(x)$ æ˜¯**è¾¹é™…ä¼¼ç„¶**ï¼ˆMarginal Likelihoodï¼‰

### å…ˆéªŒä¸åéªŒ

**å…ˆéªŒåˆ†å¸ƒ**: åœ¨è§‚æµ‹æ•°æ®ä¹‹å‰çš„å‚æ•°åˆ†å¸ƒ
**åéªŒåˆ†å¸ƒ**: ç»“åˆè§‚æµ‹æ•°æ®åçš„å‚æ•°åˆ†å¸ƒ
**æ›´æ–°è¿‡ç¨‹**: å…ˆéªŒ Ã— ä¼¼ç„¶ â†’ åéªŒ

---

## 1. è´å¶æ–¯æ¨æ–­

### 1.1 åéªŒåˆ†å¸ƒ

**åéªŒåˆ†å¸ƒ**æ˜¯è´å¶æ–¯æ¨æ–­çš„æ ¸å¿ƒï¼ŒåŒ…å«äº†å‚æ•°çš„æ‰€æœ‰ä¿¡æ¯ã€‚

```sql
-- è´å¶æ–¯æ¨æ–­æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'bayesian_data') THEN
            RAISE WARNING 'è¡¨ bayesian_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE bayesian_data CASCADE;
        END IF;

        CREATE TABLE bayesian_data (
            id SERIAL PRIMARY KEY,
            observation NUMERIC NOT NULL
        );

        -- æ’å…¥è§‚æµ‹æ•°æ®ï¼ˆäºŒé¡¹åˆ†å¸ƒç¤ºä¾‹ï¼‰
        INSERT INTO bayesian_data (observation) VALUES
            (1), (1), (0), (1), (1), (0), (1), (1), (1), (0);

        RAISE NOTICE 'è¡¨ bayesian_data åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ bayesian_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- è´å¶æ–¯åéªŒåˆ†å¸ƒè®¡ç®—ï¼ˆBeta-Binomialå…±è½­ï¼‰
WITH data_stats AS (
    SELECT
        COUNT(*) AS n,
        SUM(observation) AS successes,
        COUNT(*) - SUM(observation) AS failures
    FROM bayesian_data
),
prior_params AS (
    SELECT
        2.0 AS alpha_prior,  -- Betaå…ˆéªŒå‚æ•°
        2.0 AS beta_prior
),
posterior_params AS (
    SELECT
        ds.successes + pp.alpha_prior AS alpha_posterior,
        ds.failures + pp.beta_prior AS beta_posterior
    FROM data_stats ds
    CROSS JOIN prior_params pp
)
SELECT
    ROUND(alpha_posterior::numeric, 2) AS posterior_alpha,
    ROUND(beta_posterior::numeric, 2) AS posterior_beta,
    ROUND((alpha_posterior / (alpha_posterior + beta_posterior))::numeric, 4) AS posterior_mean,
    ROUND((alpha_posterior * beta_posterior /
           POWER(alpha_posterior + beta_posterior, 2) /
           (alpha_posterior + beta_posterior + 1))::numeric, 4) AS posterior_variance
FROM posterior_params;
```

### 1.2 å…±è½­å…ˆéªŒ

**å…±è½­å…ˆéªŒ**ä½¿å¾—åéªŒåˆ†å¸ƒä¸å…ˆéªŒåˆ†å¸ƒå±äºåŒä¸€åˆ†å¸ƒæ—ã€‚

**å¸¸è§å…±è½­å¯¹**:

- Beta-Binomial
- Gamma-Poisson
- Normal-Normal
- Dirichlet-Multinomial

```sql
-- Beta-Binomialå…±è½­å…ˆéªŒç¤ºä¾‹
WITH beta_prior AS (
    SELECT
        generate_series(1, 100)::NUMERIC / 100 AS theta,
        2.0 AS alpha,
        2.0 AS beta,
        -- Betaå…ˆéªŒå¯†åº¦ï¼ˆç®€åŒ–ï¼‰
        POWER(theta, alpha - 1) * POWER(1 - theta, beta - 1) AS prior_density
    FROM generate_series(1, 100)
),
likelihood AS (
    SELECT
        theta,
        7 AS successes,
        3 AS failures,
        POWER(theta, 7) * POWER(1 - theta, 3) AS likelihood_value
    FROM beta_prior
),
posterior AS (
    SELECT
        bp.theta,
        bp.prior_density,
        l.likelihood_value,
        bp.prior_density * l.likelihood_value AS unnormalized_posterior
    FROM beta_prior bp
    JOIN likelihood l ON bp.theta = l.theta
)
SELECT
    ROUND(theta::numeric, 2) AS parameter_value,
    ROUND(prior_density::numeric, 4) AS prior_density,
    ROUND(likelihood_value::numeric, 4) AS likelihood,
    ROUND(unnormalized_posterior::numeric, 4) AS posterior_density
FROM posterior
ORDER BY theta
LIMIT 20;
```

### 1.3 åéªŒé¢„æµ‹

**åéªŒé¢„æµ‹åˆ†å¸ƒ**ç”¨äºé¢„æµ‹æ–°è§‚æµ‹å€¼ã€‚

```sql
-- åéªŒé¢„æµ‹åˆ†å¸ƒè®¡ç®—
WITH posterior_predictive AS (
    SELECT
        generate_series(0, 10) AS new_successes,
        10 AS n_new_trials,
        9.0 AS posterior_alpha,
        5.0 AS posterior_beta
),
beta_binomial_predictive AS (
    SELECT
        new_successes,
        n_new_trials,
        -- Beta-Binomialé¢„æµ‹åˆ†å¸ƒï¼ˆç®€åŒ–ï¼‰
        (FACTORIAL(n_new_trials)::NUMERIC /
         (FACTORIAL(new_successes) * FACTORIAL(n_new_trials - new_successes))) *
        (GAMMA(posterior_alpha + new_successes) * GAMMA(posterior_beta + n_new_trials - new_successes) /
         GAMMA(posterior_alpha + posterior_beta + n_new_trials)) *
        (GAMMA(posterior_alpha + posterior_beta) /
         (GAMMA(posterior_alpha) * GAMMA(posterior_beta))) AS predictive_probability
    FROM posterior_predictive
)
SELECT
    new_successes,
    ROUND(predictive_probability::numeric, 4) AS predictive_prob
FROM beta_binomial_predictive
ORDER BY new_successes;
```

---

## 2. MCMCæ–¹æ³•

### 2.1 Metropolis-Hastingsç®—æ³•

**Metropolis-Hastingsç®—æ³•**æ˜¯MCMCçš„æ ¸å¿ƒæ–¹æ³•ï¼Œç”¨äºä»å¤æ‚åéªŒåˆ†å¸ƒä¸­é‡‡æ ·ã€‚

**æ¥å—æ¦‚ç‡**:
$$\alpha = \min\left(1, \frac{P(\theta^* | x) q(\theta^{(t)} | \theta^*)}{P(\theta^{(t)} | x) q(\theta^* | \theta^{(t)})}\right)$$

```sql
-- Metropolis-Hastingsç®—æ³•å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
WITH mh_state AS (
    SELECT
        iteration,
        current_theta,
        proposed_theta,
        current_log_posterior,
        proposed_log_posterior
    FROM mcmc_chain
    WHERE iteration = (SELECT MAX(iteration) FROM mcmc_chain)
),
acceptance_probability AS (
    SELECT
        current_theta,
        proposed_theta,
        EXP(proposed_log_posterior - current_log_posterior) AS acceptance_ratio,
        CASE
            WHEN proposed_log_posterior > current_log_posterior THEN 1.0
            ELSE EXP(proposed_log_posterior - current_log_posterior)
        END AS accept_prob
    FROM mh_state
)
SELECT
    ROUND(current_theta::numeric, 4) AS current_value,
    ROUND(proposed_theta::numeric, 4) AS proposed_value,
    ROUND(accept_prob::numeric, 4) AS acceptance_probability,
    CASE
        WHEN accept_prob > RANDOM() THEN 'Accept'
        ELSE 'Reject'
    END AS decision
FROM acceptance_probability;
```

### 2.2 Gibbsé‡‡æ ·

**Gibbsé‡‡æ ·**æ˜¯MCMCçš„ç‰¹æ®Šæƒ…å†µï¼Œé€‚ç”¨äºå¤šå‚æ•°é—®é¢˜ã€‚

**ç®—æ³•**: ä¾æ¬¡ä»æ¯ä¸ªå‚æ•°çš„æ¡ä»¶åéªŒåˆ†å¸ƒä¸­é‡‡æ ·ã€‚

```sql
-- Gibbsé‡‡æ ·å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼š2å‚æ•°ï¼‰
WITH gibbs_iteration AS (
    SELECT
        iteration,
        theta1,
        theta2
    FROM gibbs_chain
    WHERE iteration = (SELECT MAX(iteration) FROM gibbs_chain)
),
conditional_samples AS (
    SELECT
        -- ä»æ¡ä»¶åéªŒåˆ†å¸ƒé‡‡æ ·
        -- P(theta1 | theta2, data)
        NORMAL(mean_theta1_given_theta2, std_theta1) AS new_theta1,
        -- P(theta2 | theta1, data)
        NORMAL(mean_theta2_given_theta1, std_theta2) AS new_theta2
    FROM gibbs_iteration
    CROSS JOIN conditional_posterior_params
)
SELECT
    ROUND(new_theta1::numeric, 4) AS sampled_theta1,
    ROUND(new_theta2::numeric, 4) AS sampled_theta2
FROM conditional_samples;
```

---

## 3. è´å¶æ–¯æ¨¡å‹é€‰æ‹©

### 3.1 è´å¶æ–¯å› å­

**è´å¶æ–¯å› å­**ç”¨äºæ¯”è¾ƒä¸¤ä¸ªæ¨¡å‹ï¼š

$$BF_{12} = \frac{P(x | M_1)}{P(x | M_2)} = \frac{\int P(x | \theta_1, M_1) P(\theta_1 | M_1) d\theta_1}{\int P(x | \theta_2, M_2) P(\theta_2 | M_2) d\theta_2}$$

```sql
-- è´å¶æ–¯å› å­è®¡ç®—
WITH model_evidence AS (
    SELECT
        'Model1' AS model_name,
        marginal_likelihood AS evidence
    FROM model1_marginal_likelihood
    UNION ALL
    SELECT
        'Model2' AS model_name,
        marginal_likelihood AS evidence
    FROM model2_marginal_likelihood
),
bayes_factor AS (
    SELECT
        m1.evidence / NULLIF(m2.evidence, 0) AS bf_12
    FROM model_evidence m1
    CROSS JOIN model_evidence m2
    WHERE m1.model_name = 'Model1' AND m2.model_name = 'Model2'
)
SELECT
    ROUND(bf_12::numeric, 4) AS bayes_factor,
    CASE
        WHEN bf_12 > 100 THEN 'Very strong evidence for M1'
        WHEN bf_12 > 10 THEN 'Strong evidence for M1'
        WHEN bf_12 > 3 THEN 'Moderate evidence for M1'
        WHEN bf_12 > 1 THEN 'Weak evidence for M1'
        ELSE 'Evidence for M2'
    END AS interpretation
FROM bayes_factor;
```

### 3.2 ä¿¡æ¯å‡†åˆ™

**BICï¼ˆBayesian Information Criterionï¼‰**:
$$BIC = -2 \log L + k \log n$$

```sql
-- BICè®¡ç®—
WITH model_comparison AS (
    SELECT
        model_name,
        log_likelihood,
        num_parameters,
        sample_size,
        -2 * log_likelihood + num_parameters * LN(sample_size) AS bic
    FROM model_fits
)
SELECT
    model_name,
    ROUND(bic::numeric, 2) AS bic_value,
    RANK() OVER (ORDER BY bic) AS bic_rank
FROM model_comparison
ORDER BY bic;
```

---

## 4. PostgreSQL 18 å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—ã€MCMCé‡‡æ ·å’Œè´å¶æ–¯å› å­è®¡ç®—ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡è´å¶æ–¯æ¨æ–­çš„æ€§èƒ½ã€‚

### 4.1 å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡åŸç†

PostgreSQL 18 çš„å¹¶è¡Œè´å¶æ–¯ç»Ÿè®¡é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«ææ•°æ®
2. **å¹¶è¡Œä¼¼ç„¶è®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—éƒ¨åˆ†ä¼¼ç„¶å‡½æ•°
3. **å¹¶è¡ŒMCMCé‡‡æ ·**ï¼šå¹¶è¡Œæ‰§è¡Œå¤šä¸ªMCMCé“¾
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„ç»Ÿè®¡ç»“æœ

### 4.2 å¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—

```sql
-- PostgreSQL 18 å¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'bayesian_data') THEN
            RAISE WARNING 'è¡¨ bayesian_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒBeta-BinomialåéªŒåˆ†å¸ƒè®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH data_stats AS (
    SELECT
        COUNT(*) FILTER (WHERE observation = 1) AS successes,
        COUNT(*) AS total_trials
    FROM bayesian_data
),
posterior_params AS (
    SELECT
        successes + 1 AS posterior_alpha,  -- å…ˆéªŒ: Beta(1, 1)
        total_trials - successes + 1 AS posterior_beta
    FROM data_stats
)
SELECT
    posterior_alpha,
    posterior_beta,
    ROUND(posterior_alpha::numeric / NULLIF(posterior_alpha + posterior_beta, 0), 4) AS posterior_mean,
    ROUND(SQRT((posterior_alpha * posterior_beta)::numeric /
        NULLIF(POWER(posterior_alpha + posterior_beta, 2) * (posterior_alpha + posterior_beta + 1), 0)), 4) AS posterior_stddev
FROM posterior_params;
```

### 4.3 å¹¶è¡ŒMCMCé‡‡æ ·

```sql
-- PostgreSQL 18 å¹¶è¡ŒMCMCé‡‡æ ·ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'mcmc_chain') THEN
            RAISE WARNING 'è¡¨ mcmc_chain ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒMCMCé‡‡æ ·';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒMCMCé‡‡æ ·';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒMCMCé‡‡æ ·å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒMCMCé“¾é‡‡æ ·ï¼šå¤šä¸ªé“¾å¹¶è¡Œè¿è¡Œ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH parallel_chains AS (
    SELECT
        chain_id,
        iteration,
        theta_value,
        AVG(theta_value) OVER (PARTITION BY chain_id ORDER BY iteration ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) AS running_mean,
        STDDEV(theta_value) OVER (PARTITION BY chain_id ORDER BY iteration ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) AS running_stddev
    FROM mcmc_chain
    WHERE iteration > 100  -- å»é™¤burn-in
)
SELECT
    chain_id,
    AVG(theta_value) AS chain_mean,
    STDDEV(theta_value) AS chain_stddev,
    PERCENTILE_CONT(0.025) WITHIN GROUP (ORDER BY theta_value) AS ci_lower,
    PERCENTILE_CONT(0.975) WITHIN GROUP (ORDER BY theta_value) AS ci_upper
FROM parallel_chains
GROUP BY chain_id
ORDER BY chain_id;
```

---

## 5. å¤æ‚åº¦åˆ†æ

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|-----------|---------|
| **å…±è½­å…ˆéªŒ** | $O(1)$ | $O(1)$ | ç®€å•æ¨¡å‹ |
| **MCMC** | $O(iterations \times n)$ | $O(iterations)$ | å¤æ‚æ¨¡å‹ |
| **å˜åˆ†æ¨æ–­** | $O(iterations \times n)$ | $O(parameters)$ | å¤§è§„æ¨¡æ•°æ® |

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 å‚æ•°ä¼°è®¡

```sql
-- è´å¶æ–¯å‚æ•°ä¼°è®¡åº”ç”¨
WITH posterior_samples AS (
    SELECT
        theta_sample,
        COUNT(*) AS frequency
    FROM mcmc_samples
    GROUP BY theta_sample
),
credible_interval AS (
    SELECT
        PERCENTILE_CONT(0.025) WITHIN GROUP (ORDER BY theta_sample) AS ci_lower,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY theta_sample) AS median,
        PERCENTILE_CONT(0.975) WITHIN GROUP (ORDER BY theta_sample) AS ci_upper
    FROM mcmc_samples
)
SELECT
    ROUND(median::numeric, 4) AS posterior_median,
    ROUND(ci_lower::numeric, 4) AS ci_lower_95,
    ROUND(ci_upper::numeric, 4) AS ci_upper_95
FROM credible_interval;
```

### 5.2 A/Bæµ‹è¯•

```sql
-- è´å¶æ–¯A/Bæµ‹è¯•
WITH ab_test_data AS (
    SELECT
        variant,
        conversions,
        trials
    FROM ab_test_results
),
beta_posteriors AS (
    SELECT
        variant,
        conversions + 1 AS alpha_post,
        trials - conversions + 1 AS beta_post
    FROM ab_test_data
),
posterior_comparison AS (
    SELECT
        a.variant AS variant_a,
        b.variant AS variant_b,
        -- P(variant_a > variant_b)
        beta_comparison_probability AS probability_a_better
    FROM beta_posteriors a
    CROSS JOIN beta_posteriors b
    WHERE a.variant < b.variant
)
SELECT
    variant_a,
    variant_b,
    ROUND(probability_a_better::numeric, 4) AS prob_a_better
FROM posterior_comparison;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Gelman, A., et al. (2013)**: "Bayesian Data Analysis"
2. **Robert, C.P., Casella, G. (2004)**: "Monte Carlo Statistical Methods"
3. **Kruschke, J.K. (2014)**: "Doing Bayesian Data Analysis"

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å…±è½­å…ˆéªŒ**: å°½å¯èƒ½ä½¿ç”¨å…±è½­å…ˆéªŒç®€åŒ–è®¡ç®—
2. **MCMCè°ƒä¼˜**: è°ƒæ•´MCMCå‚æ•°æé«˜æ•ˆç‡
3. **å¹¶è¡ŒåŒ–**: åˆ©ç”¨PostgreSQLå¹¶è¡Œå¤„ç†å¤šä¸ªé“¾

## ğŸ¯ æœ€ä½³å®è·µ

1. **å…ˆéªŒé€‰æ‹©**: é€‰æ‹©åˆç†çš„å…ˆéªŒåˆ†å¸ƒ
2. **æ”¶æ•›è¯Šæ–­**: æ£€æŸ¥MCMCé“¾çš„æ”¶æ•›æ€§
3. **æ•æ„Ÿæ€§åˆ†æ**: åˆ†æå…ˆéªŒå¯¹ç»“æœçš„å½±å“
4. **æ¨¡å‹éªŒè¯**: ä½¿ç”¨åéªŒé¢„æµ‹æ£€æŸ¥éªŒè¯æ¨¡å‹

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **åéªŒåˆ†å¸ƒè®¡ç®—**: å¯èƒ½éœ€è¦MCMCé‡‡æ ·ï¼Œè®¡ç®—é‡å¤§
2. **æ•°å€¼ç²¾åº¦**: ä½¿ç”¨NUMERICç±»å‹ä¿æŒè®¡ç®—ç²¾åº¦
3. **å…±è½­å…ˆéªŒ**: å°½å¯èƒ½ä½¿ç”¨å…±è½­å…ˆéªŒç®€åŒ–è®¡ç®—
4. **MCMCè°ƒä¼˜**: è°ƒæ•´MCMCå‚æ•°æé«˜æ•ˆç‡

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡è´å¶æ–¯ç»Ÿè®¡ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«å‚æ•°IDçš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-NåéªŒåˆ†å¸ƒæŸ¥è¯¢å’Œå¤šå‚æ•°å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡è´å¶æ–¯è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡MCMCé‡‡æ ·å’Œå¹¶è¡ŒåéªŒåˆ†å¸ƒè®¡ç®—

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - è´å¶æ–¯ç»Ÿè®¡æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨4èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡MCMCå’Œå¤šé“¾å¹¶è¡Œé‡‡æ ·

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–è´å¶æ–¯æŸ¥è¯¢**

```sql
-- ä¸ºè´å¶æ–¯ç»Ÿè®¡åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_bayesian_skip_scan
ON bayesian_data(id DESC, observation DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æœ€æ–°è§‚æµ‹çš„åéªŒåˆ†å¸ƒ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (DATE_TRUNC('day', CURRENT_TIMESTAMP))
    id,
    observation,
    AVG(observation) OVER () AS posterior_mean
FROM bayesian_data
ORDER BY id DESC
LIMIT 50;
```

### é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜è´å¶æ–¯ç»Ÿè®¡ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„è´å¶æ–¯ç»Ÿè®¡ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜è´å¶æ–¯åéªŒåˆ†å¸ƒç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS bayesian_posterior_cache AS
WITH posterior_calculation AS (
    SELECT
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—åéªŒåˆ†å¸ƒå‚æ•°ï¼ˆBeta-Binomialå…±è½­ï¼‰
        COUNT(*) AS n_samples,
        SUM(observation) AS successes,
        COUNT(*) - SUM(observation) AS failures,
        SUM(observation)::numeric / COUNT(*) AS sample_mean,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—åéªŒå‡å€¼ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        (SUM(observation) + 2.0) / (COUNT(*) + 4.0) AS posterior_mean,  -- Beta(2,2)å…ˆéªŒ
        (SUM(observation) + 2.0) * (COUNT(*) - SUM(observation) + 2.0) /
        NULLIF(POWER(COUNT(*) + 4.0, 2) * (COUNT(*) + 5.0), 0) AS posterior_variance
    FROM bayesian_data
),
posterior_quality AS (
    SELECT
        n_samples,
        successes,
        failures,
        ROUND(sample_mean::numeric, 4) AS sample_mean,
        ROUND(posterior_mean::numeric, 4) AS posterior_mean,
        ROUND(posterior_variance::numeric, 4) AS posterior_variance,
        CASE
            WHEN posterior_variance < 0.01 THEN 'High Precision - Confident Estimate'
            WHEN posterior_variance < 0.05 THEN 'Moderate Precision - Reasonable Estimate'
            ELSE 'Low Precision - More Data Needed'
        END AS posterior_quality
    FROM posterior_calculation
)
SELECT
    n_samples,
    successes,
    failures,
    sample_mean,
    posterior_mean,
    posterior_variance,
    posterior_quality
FROM posterior_quality;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_bayesian_posterior_cache_quality ON bayesian_posterior_cache(posterior_quality, posterior_variance);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY bayesian_posterior_cache;
```

**2. å®æ—¶è´å¶æ–¯åˆ†æï¼šå¢é‡åéªŒæ›´æ–°**

**å®æ—¶è´å¶æ–¯åˆ†æ**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°åéªŒåˆ†å¸ƒç»“æœã€‚

```sql
-- å®æ—¶è´å¶æ–¯åˆ†æï¼šå¢é‡åéªŒæ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'bayesian_analysis_state') THEN
            CREATE TABLE bayesian_analysis_state (
                parameter_name VARCHAR(100) NOT NULL,
                prior_alpha NUMERIC DEFAULT 2.0,
                prior_beta NUMERIC DEFAULT 2.0,
                sum_observations NUMERIC DEFAULT 0,
                count_observations BIGINT DEFAULT 0,
                posterior_alpha NUMERIC,
                posterior_beta NUMERIC,
                posterior_mean NUMERIC,
                posterior_variance NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (parameter_name)
            );

            CREATE INDEX idx_bayesian_analysis_state_parameter ON bayesian_analysis_state(parameter_name, last_updated DESC);
            CREATE INDEX idx_bayesian_analysis_state_updated ON bayesian_analysis_state(last_updated DESC);

            RAISE NOTICE 'è´å¶æ–¯åˆ†æçŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡è´å¶æ–¯åˆ†ææ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡è´å¶æ–¯åˆ†ææ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**3. æ™ºèƒ½è´å¶æ–¯ä¼˜åŒ–ï¼šè‡ªé€‚åº”å…ˆéªŒé€‰æ‹©**

**æ™ºèƒ½è´å¶æ–¯ä¼˜åŒ–**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜å…ˆéªŒåˆ†å¸ƒã€‚

```sql
-- æ™ºèƒ½è´å¶æ–¯ä¼˜åŒ–ï¼šè‡ªé€‚åº”å…ˆéªŒé€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    data_mean NUMERIC;
    data_variance NUMERIC;
    recommended_alpha NUMERIC;
    recommended_beta NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'bayesian_data') THEN
            RAISE WARNING 'è¡¨ bayesian_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½è´å¶æ–¯ä¼˜åŒ–';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        SELECT
            AVG(observation),
            POWER(STDDEV(observation), 2)
        INTO data_mean, data_variance
        FROM bayesian_data;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©Betaå…ˆéªŒå‚æ•°
        IF data_mean > 0.8 THEN
            recommended_alpha := 5.0;  -- é«˜å‡å€¼ï¼šé«˜alpha
            recommended_beta := 1.0;
        ELSIF data_mean < 0.2 THEN
            recommended_alpha := 1.0;  -- ä½å‡å€¼ï¼šä½alpha
            recommended_beta := 5.0;
        ELSE
            recommended_alpha := 2.0;  -- ä¸­ç­‰å‡å€¼ï¼šå‡åŒ€å…ˆéªŒ
            recommended_beta := 2.0;
        END IF;

        RAISE NOTICE 'æ•°æ®å‡å€¼: %, æ•°æ®æ–¹å·®: %, æ¨èalpha: %, æ¨èbeta: %',
            data_mean, data_variance, recommended_alpha, recommended_beta;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½è´å¶æ–¯ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç†è®ºæ¨å¯¼ã€å®ç°å’ŒPostgreSQL 18æ–°ç‰¹æ€§æ”¯æŒï¼‰
