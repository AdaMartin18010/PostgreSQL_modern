# PostgreSQL è´å¶æ–¯ç»Ÿè®¡ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ç»Ÿè®¡æŽ¨æ–­ | è´å¶æ–¯ç»Ÿè®¡ | æ¦‚çŽ‡æŽ¨ç†
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Bayesian Data Analysis (Gelman et al.), Statistical Inference, Probability Theory

---

## ðŸ“‹ ç›®å½•

- [PostgreSQL è´å¶æ–¯ç»Ÿè®¡ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-è´å¶æ–¯ç»Ÿè®¡ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ðŸ“‹ ç›®å½•](#-ç›®å½•)
  - [è´å¶æ–¯ç»Ÿè®¡æ¦‚è¿°](#è´å¶æ–¯ç»Ÿè®¡æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [è´å¶æ–¯å®šç†](#è´å¶æ–¯å®šç†)
    - [å…ˆéªŒä¸ŽåŽéªŒ](#å…ˆéªŒä¸ŽåŽéªŒ)
  - [1. è´å¶æ–¯æŽ¨æ–­](#1-è´å¶æ–¯æŽ¨æ–­)
    - [1.1 åŽéªŒåˆ†å¸ƒ](#11-åŽéªŒåˆ†å¸ƒ)
    - [1.2 å…±è½­å…ˆéªŒ](#12-å…±è½­å…ˆéªŒ)
    - [1.3 åŽéªŒé¢„æµ‹](#13-åŽéªŒé¢„æµ‹)
  - [2. MCMCæ–¹æ³•](#2-mcmcæ–¹æ³•)
    - [2.1 Metropolis-Hastingsç®—æ³•](#21-metropolis-hastingsç®—æ³•)
    - [2.2 Gibbsé‡‡æ ·](#22-gibbsé‡‡æ ·)
  - [3. è´å¶æ–¯æ¨¡åž‹é€‰æ‹©](#3-è´å¶æ–¯æ¨¡åž‹é€‰æ‹©)
    - [3.1 è´å¶æ–¯å› å­](#31-è´å¶æ–¯å› å­)
    - [3.2 ä¿¡æ¯å‡†åˆ™](#32-ä¿¡æ¯å‡†åˆ™)
  - [4. å¤æ‚åº¦åˆ†æž](#4-å¤æ‚åº¦åˆ†æž)
  - [5. å®žé™…åº”ç”¨æ¡ˆä¾‹](#5-å®žé™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 å‚æ•°ä¼°è®¡](#51-å‚æ•°ä¼°è®¡)
    - [5.2 A/Bæµ‹è¯•](#52-abæµ‹è¯•)
  - [ðŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ðŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ðŸŽ¯ æœ€ä½³å®žè·µ](#-æœ€ä½³å®žè·µ)

---

## è´å¶æ–¯ç»Ÿè®¡æ¦‚è¿°

**è´å¶æ–¯ç»Ÿè®¡**æ˜¯ä¸€ç§æ¦‚çŽ‡æŽ¨ç†æ–¹æ³•ï¼Œé€šè¿‡ç»“åˆå…ˆéªŒçŸ¥è¯†å’Œè§‚æµ‹æ•°æ®æ¥æ›´æ–°å¯¹å‚æ•°çš„ä¿¡å¿µã€‚

### ç†è®ºåŸºç¡€

è´å¶æ–¯ç»Ÿè®¡çš„æ ¸å¿ƒæ˜¯å°†å‚æ•°è§†ä¸ºéšæœºå˜é‡ï¼Œä½¿ç”¨æ¦‚çŽ‡åˆ†å¸ƒæè¿°ä¸ç¡®å®šæ€§ã€‚

### è´å¶æ–¯å®šç†

**è´å¶æ–¯å®šç†**:
$$P(\theta | x) = \frac{P(x | \theta) P(\theta)}{P(x)} = \frac{P(x | \theta) P(\theta)}{\int P(x | \theta) P(\theta) d\theta}$$

å…¶ä¸­ï¼š

- $P(\theta | x)$ æ˜¯**åŽéªŒåˆ†å¸ƒ**ï¼ˆPosteriorï¼‰
- $P(x | \theta)$ æ˜¯**ä¼¼ç„¶å‡½æ•°**ï¼ˆLikelihoodï¼‰
- $P(\theta)$ æ˜¯**å…ˆéªŒåˆ†å¸ƒ**ï¼ˆPriorï¼‰
- $P(x)$ æ˜¯**è¾¹é™…ä¼¼ç„¶**ï¼ˆMarginal Likelihoodï¼‰

### å…ˆéªŒä¸ŽåŽéªŒ

**å…ˆéªŒåˆ†å¸ƒ**: åœ¨è§‚æµ‹æ•°æ®ä¹‹å‰çš„å‚æ•°åˆ†å¸ƒ
**åŽéªŒåˆ†å¸ƒ**: ç»“åˆè§‚æµ‹æ•°æ®åŽçš„å‚æ•°åˆ†å¸ƒ
**æ›´æ–°è¿‡ç¨‹**: å…ˆéªŒ Ã— ä¼¼ç„¶ â†’ åŽéªŒ

---

## 1. è´å¶æ–¯æŽ¨æ–­

### 1.1 åŽéªŒåˆ†å¸ƒ

**åŽéªŒåˆ†å¸ƒ**æ˜¯è´å¶æ–¯æŽ¨æ–­çš„æ ¸å¿ƒï¼ŒåŒ…å«äº†å‚æ•°çš„æ‰€æœ‰ä¿¡æ¯ã€‚

```sql
-- è´å¶æ–¯æŽ¨æ–­æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'bayesian_data') THEN
            RAISE WARNING 'è¡¨ bayesian_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE bayesian_data CASCADE;
        END IF;

        CREATE TABLE bayesian_data (
            id SERIAL PRIMARY KEY,
            observation NUMERIC NOT NULL
        );

        -- æ’å…¥è§‚æµ‹æ•°æ®ï¼ˆäºŒé¡¹åˆ†å¸ƒç¤ºä¾‹ï¼‰
        INSERT INTO bayesian_data (observation) VALUES
            (1), (1), (0), (1), (1), (0), (1), (1), (1), (0);

        RAISE NOTICE 'è¡¨ bayesian_data åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ bayesian_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- è´å¶æ–¯åŽéªŒåˆ†å¸ƒè®¡ç®—ï¼ˆBeta-Binomialå…±è½­ï¼‰
WITH data_stats AS (
    SELECT
        COUNT(*) AS n,
        SUM(observation) AS successes,
        COUNT(*) - SUM(observation) AS failures
    FROM bayesian_data
),
prior_params AS (
    SELECT
        2.0 AS alpha_prior,  -- Betaå…ˆéªŒå‚æ•°
        2.0 AS beta_prior
),
posterior_params AS (
    SELECT
        ds.successes + pp.alpha_prior AS alpha_posterior,
        ds.failures + pp.beta_prior AS beta_posterior
    FROM data_stats ds
    CROSS JOIN prior_params pp
)
SELECT
    ROUND(alpha_posterior::numeric, 2) AS posterior_alpha,
    ROUND(beta_posterior::numeric, 2) AS posterior_beta,
    ROUND((alpha_posterior / (alpha_posterior + beta_posterior))::numeric, 4) AS posterior_mean,
    ROUND((alpha_posterior * beta_posterior /
           POWER(alpha_posterior + beta_posterior, 2) /
           (alpha_posterior + beta_posterior + 1))::numeric, 4) AS posterior_variance
FROM posterior_params;
```

### 1.2 å…±è½­å…ˆéªŒ

**å…±è½­å…ˆéªŒ**ä½¿å¾—åŽéªŒåˆ†å¸ƒä¸Žå…ˆéªŒåˆ†å¸ƒå±žäºŽåŒä¸€åˆ†å¸ƒæ—ã€‚

**å¸¸è§å…±è½­å¯¹**:

- Beta-Binomial
- Gamma-Poisson
- Normal-Normal
- Dirichlet-Multinomial

```sql
-- Beta-Binomialå…±è½­å…ˆéªŒç¤ºä¾‹
WITH beta_prior AS (
    SELECT
        generate_series(1, 100)::NUMERIC / 100 AS theta,
        2.0 AS alpha,
        2.0 AS beta,
        -- Betaå…ˆéªŒå¯†åº¦ï¼ˆç®€åŒ–ï¼‰
        POWER(theta, alpha - 1) * POWER(1 - theta, beta - 1) AS prior_density
    FROM generate_series(1, 100)
),
likelihood AS (
    SELECT
        theta,
        7 AS successes,
        3 AS failures,
        POWER(theta, 7) * POWER(1 - theta, 3) AS likelihood_value
    FROM beta_prior
),
posterior AS (
    SELECT
        bp.theta,
        bp.prior_density,
        l.likelihood_value,
        bp.prior_density * l.likelihood_value AS unnormalized_posterior
    FROM beta_prior bp
    JOIN likelihood l ON bp.theta = l.theta
)
SELECT
    ROUND(theta::numeric, 2) AS parameter_value,
    ROUND(prior_density::numeric, 4) AS prior_density,
    ROUND(likelihood_value::numeric, 4) AS likelihood,
    ROUND(unnormalized_posterior::numeric, 4) AS posterior_density
FROM posterior
ORDER BY theta
LIMIT 20;
```

### 1.3 åŽéªŒé¢„æµ‹

**åŽéªŒé¢„æµ‹åˆ†å¸ƒ**ç”¨äºŽé¢„æµ‹æ–°è§‚æµ‹å€¼ã€‚

```sql
-- åŽéªŒé¢„æµ‹åˆ†å¸ƒè®¡ç®—
WITH posterior_predictive AS (
    SELECT
        generate_series(0, 10) AS new_successes,
        10 AS n_new_trials,
        9.0 AS posterior_alpha,
        5.0 AS posterior_beta
),
beta_binomial_predictive AS (
    SELECT
        new_successes,
        n_new_trials,
        -- Beta-Binomialé¢„æµ‹åˆ†å¸ƒï¼ˆç®€åŒ–ï¼‰
        (FACTORIAL(n_new_trials)::NUMERIC /
         (FACTORIAL(new_successes) * FACTORIAL(n_new_trials - new_successes))) *
        (GAMMA(posterior_alpha + new_successes) * GAMMA(posterior_beta + n_new_trials - new_successes) /
         GAMMA(posterior_alpha + posterior_beta + n_new_trials)) *
        (GAMMA(posterior_alpha + posterior_beta) /
         (GAMMA(posterior_alpha) * GAMMA(posterior_beta))) AS predictive_probability
    FROM posterior_predictive
)
SELECT
    new_successes,
    ROUND(predictive_probability::numeric, 4) AS predictive_prob
FROM beta_binomial_predictive
ORDER BY new_successes;
```

---

## 2. MCMCæ–¹æ³•

### 2.1 Metropolis-Hastingsç®—æ³•

**Metropolis-Hastingsç®—æ³•**æ˜¯MCMCçš„æ ¸å¿ƒæ–¹æ³•ï¼Œç”¨äºŽä»Žå¤æ‚åŽéªŒåˆ†å¸ƒä¸­é‡‡æ ·ã€‚

**æŽ¥å—æ¦‚çŽ‡**:
$$\alpha = \min\left(1, \frac{P(\theta^* | x) q(\theta^{(t)} | \theta^*)}{P(\theta^{(t)} | x) q(\theta^* | \theta^{(t)})}\right)$$

```sql
-- Metropolis-Hastingsç®—æ³•å®žçŽ°ï¼ˆç®€åŒ–ç‰ˆï¼‰
WITH mh_state AS (
    SELECT
        iteration,
        current_theta,
        proposed_theta,
        current_log_posterior,
        proposed_log_posterior
    FROM mcmc_chain
    WHERE iteration = (SELECT MAX(iteration) FROM mcmc_chain)
),
acceptance_probability AS (
    SELECT
        current_theta,
        proposed_theta,
        EXP(proposed_log_posterior - current_log_posterior) AS acceptance_ratio,
        CASE
            WHEN proposed_log_posterior > current_log_posterior THEN 1.0
            ELSE EXP(proposed_log_posterior - current_log_posterior)
        END AS accept_prob
    FROM mh_state
)
SELECT
    ROUND(current_theta::numeric, 4) AS current_value,
    ROUND(proposed_theta::numeric, 4) AS proposed_value,
    ROUND(accept_prob::numeric, 4) AS acceptance_probability,
    CASE
        WHEN accept_prob > RANDOM() THEN 'Accept'
        ELSE 'Reject'
    END AS decision
FROM acceptance_probability;
```

### 2.2 Gibbsé‡‡æ ·

**Gibbsé‡‡æ ·**æ˜¯MCMCçš„ç‰¹æ®Šæƒ…å†µï¼Œé€‚ç”¨äºŽå¤šå‚æ•°é—®é¢˜ã€‚

**ç®—æ³•**: ä¾æ¬¡ä»Žæ¯ä¸ªå‚æ•°çš„æ¡ä»¶åŽéªŒåˆ†å¸ƒä¸­é‡‡æ ·ã€‚

```sql
-- Gibbsé‡‡æ ·å®žçŽ°ï¼ˆç®€åŒ–ç‰ˆï¼š2å‚æ•°ï¼‰
WITH gibbs_iteration AS (
    SELECT
        iteration,
        theta1,
        theta2
    FROM gibbs_chain
    WHERE iteration = (SELECT MAX(iteration) FROM gibbs_chain)
),
conditional_samples AS (
    SELECT
        -- ä»Žæ¡ä»¶åŽéªŒåˆ†å¸ƒé‡‡æ ·
        -- P(theta1 | theta2, data)
        NORMAL(mean_theta1_given_theta2, std_theta1) AS new_theta1,
        -- P(theta2 | theta1, data)
        NORMAL(mean_theta2_given_theta1, std_theta2) AS new_theta2
    FROM gibbs_iteration
    CROSS JOIN conditional_posterior_params
)
SELECT
    ROUND(new_theta1::numeric, 4) AS sampled_theta1,
    ROUND(new_theta2::numeric, 4) AS sampled_theta2
FROM conditional_samples;
```

---

## 3. è´å¶æ–¯æ¨¡åž‹é€‰æ‹©

### 3.1 è´å¶æ–¯å› å­

**è´å¶æ–¯å› å­**ç”¨äºŽæ¯”è¾ƒä¸¤ä¸ªæ¨¡åž‹ï¼š

$$BF_{12} = \frac{P(x | M_1)}{P(x | M_2)} = \frac{\int P(x | \theta_1, M_1) P(\theta_1 | M_1) d\theta_1}{\int P(x | \theta_2, M_2) P(\theta_2 | M_2) d\theta_2}$$

```sql
-- è´å¶æ–¯å› å­è®¡ç®—
WITH model_evidence AS (
    SELECT
        'Model1' AS model_name,
        marginal_likelihood AS evidence
    FROM model1_marginal_likelihood
    UNION ALL
    SELECT
        'Model2' AS model_name,
        marginal_likelihood AS evidence
    FROM model2_marginal_likelihood
),
bayes_factor AS (
    SELECT
        m1.evidence / NULLIF(m2.evidence, 0) AS bf_12
    FROM model_evidence m1
    CROSS JOIN model_evidence m2
    WHERE m1.model_name = 'Model1' AND m2.model_name = 'Model2'
)
SELECT
    ROUND(bf_12::numeric, 4) AS bayes_factor,
    CASE
        WHEN bf_12 > 100 THEN 'Very strong evidence for M1'
        WHEN bf_12 > 10 THEN 'Strong evidence for M1'
        WHEN bf_12 > 3 THEN 'Moderate evidence for M1'
        WHEN bf_12 > 1 THEN 'Weak evidence for M1'
        ELSE 'Evidence for M2'
    END AS interpretation
FROM bayes_factor;
```

### 3.2 ä¿¡æ¯å‡†åˆ™

**BICï¼ˆBayesian Information Criterionï¼‰**:
$$BIC = -2 \log L + k \log n$$

```sql
-- BICè®¡ç®—
WITH model_comparison AS (
    SELECT
        model_name,
        log_likelihood,
        num_parameters,
        sample_size,
        -2 * log_likelihood + num_parameters * LN(sample_size) AS bic
    FROM model_fits
)
SELECT
    model_name,
    ROUND(bic::numeric, 2) AS bic_value,
    RANK() OVER (ORDER BY bic) AS bic_rank
FROM model_comparison
ORDER BY bic;
```

---

## 4. å¤æ‚åº¦åˆ†æž

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|-----------|---------|
| **å…±è½­å…ˆéªŒ** | $O(1)$ | $O(1)$ | ç®€å•æ¨¡åž‹ |
| **MCMC** | $O(iterations \times n)$ | $O(iterations)$ | å¤æ‚æ¨¡åž‹ |
| **å˜åˆ†æŽ¨æ–­** | $O(iterations \times n)$ | $O(parameters)$ | å¤§è§„æ¨¡æ•°æ® |

---

## 5. å®žé™…åº”ç”¨æ¡ˆä¾‹

### 5.1 å‚æ•°ä¼°è®¡

```sql
-- è´å¶æ–¯å‚æ•°ä¼°è®¡åº”ç”¨
WITH posterior_samples AS (
    SELECT
        theta_sample,
        COUNT(*) AS frequency
    FROM mcmc_samples
    GROUP BY theta_sample
),
credible_interval AS (
    SELECT
        PERCENTILE_CONT(0.025) WITHIN GROUP (ORDER BY theta_sample) AS ci_lower,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY theta_sample) AS median,
        PERCENTILE_CONT(0.975) WITHIN GROUP (ORDER BY theta_sample) AS ci_upper
    FROM mcmc_samples
)
SELECT
    ROUND(median::numeric, 4) AS posterior_median,
    ROUND(ci_lower::numeric, 4) AS ci_lower_95,
    ROUND(ci_upper::numeric, 4) AS ci_upper_95
FROM credible_interval;
```

### 5.2 A/Bæµ‹è¯•

```sql
-- è´å¶æ–¯A/Bæµ‹è¯•
WITH ab_test_data AS (
    SELECT
        variant,
        conversions,
        trials
    FROM ab_test_results
),
beta_posteriors AS (
    SELECT
        variant,
        conversions + 1 AS alpha_post,
        trials - conversions + 1 AS beta_post
    FROM ab_test_data
),
posterior_comparison AS (
    SELECT
        a.variant AS variant_a,
        b.variant AS variant_b,
        -- P(variant_a > variant_b)
        beta_comparison_probability AS probability_a_better
    FROM beta_posteriors a
    CROSS JOIN beta_posteriors b
    WHERE a.variant < b.variant
)
SELECT
    variant_a,
    variant_b,
    ROUND(probability_a_better::numeric, 4) AS prob_a_better
FROM posterior_comparison;
```

---

## ðŸ“š å‚è€ƒèµ„æº

1. **Gelman, A., et al. (2013)**: "Bayesian Data Analysis"
2. **Robert, C.P., Casella, G. (2004)**: "Monte Carlo Statistical Methods"
3. **Kruschke, J.K. (2014)**: "Doing Bayesian Data Analysis"

## ðŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å…±è½­å…ˆéªŒ**: å°½å¯èƒ½ä½¿ç”¨å…±è½­å…ˆéªŒç®€åŒ–è®¡ç®—
2. **MCMCè°ƒä¼˜**: è°ƒæ•´MCMCå‚æ•°æé«˜æ•ˆçŽ‡
3. **å¹¶è¡ŒåŒ–**: åˆ©ç”¨PostgreSQLå¹¶è¡Œå¤„ç†å¤šä¸ªé“¾

## ðŸŽ¯ æœ€ä½³å®žè·µ

1. **å…ˆéªŒé€‰æ‹©**: é€‰æ‹©åˆç†çš„å…ˆéªŒåˆ†å¸ƒ
2. **æ”¶æ•›è¯Šæ–­**: æ£€æŸ¥MCMCé“¾çš„æ”¶æ•›æ€§
3. **æ•æ„Ÿæ€§åˆ†æž**: åˆ†æžå…ˆéªŒå¯¹ç»“æžœçš„å½±å“
4. **æ¨¡åž‹éªŒè¯**: ä½¿ç”¨åŽéªŒé¢„æµ‹æ£€æŸ¥éªŒè¯æ¨¡åž‹

---

**æœ€åŽæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
