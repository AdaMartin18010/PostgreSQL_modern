# PostgreSQL é€»è¾‘å›å½’å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | é€»è¾‘å›å½’ | åˆ†ç±»ç®—æ³•
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL é€»è¾‘å›å½’å®Œæ•´æŒ‡å—](#postgresql-é€»è¾‘å›å½’å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [é€»è¾‘å›å½’æ¦‚è¿°](#é€»è¾‘å›å½’æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æ¨¡å‹å®šä¹‰](#æ¨¡å‹å®šä¹‰)
      - [ä¼˜åŠ¿æ¯”ï¼ˆOdds Ratioï¼‰](#ä¼˜åŠ¿æ¯”odds-ratio)
      - [å‚æ•°ä¼°è®¡](#å‚æ•°ä¼°è®¡)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. äºŒåˆ†ç±»é€»è¾‘å›å½’](#1-äºŒåˆ†ç±»é€»è¾‘å›å½’)
    - [1.1 Sigmoidå‡½æ•°åŸç†](#11-sigmoidå‡½æ•°åŸç†)
      - [æ•°å­¦å®šä¹‰](#æ•°å­¦å®šä¹‰)
      - [æ€§è´¨](#æ€§è´¨)
      - [ä¼˜åŠ¿](#ä¼˜åŠ¿)
    - [1.2 Sigmoidå‡½æ•°å®ç°](#12-sigmoidå‡½æ•°å®ç°)
  - [2. å¤šåˆ†ç±»é€»è¾‘å›å½’](#2-å¤šåˆ†ç±»é€»è¾‘å›å½’)
    - [2.1 Softmaxå‡½æ•°åŸç†](#21-softmaxå‡½æ•°åŸç†)
      - [æ•°å­¦å®šä¹‰](#æ•°å­¦å®šä¹‰-1)
      - [æ€§è´¨](#æ€§è´¨-1)
      - [ä¸Sigmoidçš„å…³ç³»](#ä¸sigmoidçš„å…³ç³»)
    - [2.2 Softmaxå‡½æ•°å®ç°](#22-softmaxå‡½æ•°å®ç°)
  - [3. å‚æ•°ä¼°è®¡æ–¹æ³•](#3-å‚æ•°ä¼°è®¡æ–¹æ³•)
    - [3.1 æ¢¯åº¦ä¸Šå‡æ³•](#31-æ¢¯åº¦ä¸Šå‡æ³•)
      - [ç®—æ³•æ­¥éª¤](#ç®—æ³•æ­¥éª¤)
    - [3.2 ç‰›é¡¿æ³•](#32-ç‰›é¡¿æ³•)
  - [4. æ¨¡å‹è¯„ä¼°](#4-æ¨¡å‹è¯„ä¼°)
    - [4.1 æ··æ·†çŸ©é˜µ](#41-æ··æ·†çŸ©é˜µ)
    - [4.2 è¯„ä¼°æŒ‡æ ‡](#42-è¯„ä¼°æŒ‡æ ‡)
      - [4.2.1 å‡†ç¡®ç‡ï¼ˆAccuracyï¼‰](#421-å‡†ç¡®ç‡accuracy)
      - [4.2.2 ç²¾ç¡®ç‡ï¼ˆPrecisionï¼‰](#422-ç²¾ç¡®ç‡precision)
      - [4.2.3 å¬å›ç‡ï¼ˆRecallï¼‰](#423-å¬å›ç‡recall)
      - [4.2.4 F1åˆ†æ•°](#424-f1åˆ†æ•°)
      - [4.2.5 ç‰¹å¼‚æ€§ï¼ˆSpecificityï¼‰](#425-ç‰¹å¼‚æ€§specificity)
    - [4.3 ROCæ›²çº¿å’ŒAUC](#43-rocæ›²çº¿å’Œauc)
      - [ROCæ›²çº¿](#rocæ›²çº¿)
      - [AUCï¼ˆArea Under Curveï¼‰](#aucarea-under-curve)
      - [AUCçš„è®¡ç®—](#aucçš„è®¡ç®—)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 ç”¨æˆ·æµå¤±é¢„æµ‹](#51-ç”¨æˆ·æµå¤±é¢„æµ‹)
    - [5.2 ä¿¡ç”¨è¯„åˆ†](#52-ä¿¡ç”¨è¯„åˆ†)
    - [5.3 åŒ»å­¦è¯Šæ–­](#53-åŒ»å­¦è¯Šæ–­)
    - [5.4 è¥é”€å“åº”é¢„æµ‹](#54-è¥é”€å“åº”é¢„æµ‹)
  - [6. PostgreSQL 18å¹¶è¡Œé€»è¾‘å›å½’](#6-postgresql-18å¹¶è¡Œé€»è¾‘å›å½’)
    - [6.1 å¹¶è¡Œé€»è¾‘å›å½’æ¦‚è¿°](#61-å¹¶è¡Œé€»è¾‘å›å½’æ¦‚è¿°)
      - [å¹¶è¡Œé€»è¾‘å›å½’é…ç½®](#å¹¶è¡Œé€»è¾‘å›å½’é…ç½®)
      - [å¹¶è¡Œé€»è¾‘å›å½’å®ç°](#å¹¶è¡Œé€»è¾‘å›å½’å®ç°)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [7.1 é€»è¾‘å›å½’ vs å…¶ä»–åˆ†ç±»ç®—æ³•](#71-é€»è¾‘å›å½’-vs-å…¶ä»–åˆ†ç±»ç®—æ³•)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#73-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æ•°æ®å‡†å¤‡](#81-æ•°æ®å‡†å¤‡)
    - [8.2 æ¨¡å‹è®­ç»ƒ](#82-æ¨¡å‹è®­ç»ƒ)
    - [8.3 æ¨¡å‹è¯„ä¼°](#83-æ¨¡å‹è¯„ä¼°)
    - [8.4 æ¨¡å‹è§£é‡Š](#84-æ¨¡å‹è§£é‡Š)
    - [8.5 SQLå®ç°æ³¨æ„äº‹é¡¹](#85-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [8.6 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨](#86-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨)
    - [8.7 é«˜çº§ä¼˜åŒ–æŠ€å·§](#87-é«˜çº§ä¼˜åŒ–æŠ€å·§)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## é€»è¾‘å›å½’æ¦‚è¿°

**é€»è¾‘å›å½’ï¼ˆLogistic Regressionï¼‰**æ˜¯ä¸€ç§ç»å…¸çš„åˆ†ç±»ç®—æ³•ï¼Œè™½ç„¶åå­—åŒ…å«"å›å½’"ï¼Œä½†å®é™…ä¸Šæ˜¯ç”¨äºåˆ†ç±»é—®é¢˜çš„çº¿æ€§æ¨¡å‹ã€‚é€»è¾‘å›å½’é€šè¿‡Sigmoidå‡½æ•°ï¼ˆäºŒåˆ†ç±»ï¼‰æˆ–Softmaxå‡½æ•°ï¼ˆå¤šåˆ†ç±»ï¼‰å°†çº¿æ€§ç»„åˆæ˜ å°„åˆ°æ¦‚ç‡ç©ºé—´ï¼Œå¹¿æ³›åº”ç”¨äºåŒ»å­¦è¯Šæ–­ã€ä¿¡ç”¨è¯„åˆ†ã€ç”¨æˆ·è¡Œä¸ºé¢„æµ‹ç­‰é¢†åŸŸã€‚

### ç†è®ºåŸºç¡€

#### æ¨¡å‹å®šä¹‰

**äºŒåˆ†ç±»é€»è¾‘å›å½’æ¨¡å‹**ï¼š
$$P(Y=1|X) = \frac{1}{1 + e^{-(\beta_0 + \beta_1 x_1 + ... + \beta_p x_p)}} = \sigma(\boldsymbol{\beta}^T \mathbf{x})$$

å…¶ä¸­ï¼š

- $Y \in \{0, 1\}$ æ˜¯ç±»åˆ«æ ‡ç­¾
- $\mathbf{x} = [1, x_1, ..., x_p]^T$ æ˜¯ç‰¹å¾å‘é‡ï¼ˆåŒ…å«æˆªè·é¡¹ï¼‰
- $\boldsymbol{\beta} = [\beta_0, \beta_1, ..., \beta_p]^T$ æ˜¯å‚æ•°å‘é‡
- $\sigma(z) = \frac{1}{1+e^{-z}}$ æ˜¯Sigmoidå‡½æ•°

#### ä¼˜åŠ¿æ¯”ï¼ˆOdds Ratioï¼‰

**ä¼˜åŠ¿ï¼ˆOddsï¼‰**ï¼š
$$\text{Odds} = \frac{P(Y=1|X)}{P(Y=0|X)} = \frac{P(Y=1|X)}{1 - P(Y=1|X)} = e^{\boldsymbol{\beta}^T \mathbf{x}}$$

**å¯¹æ•°ä¼˜åŠ¿ï¼ˆLog-Oddsï¼‰**ï¼š
$$\log(\text{Odds}) = \boldsymbol{\beta}^T \mathbf{x}$$

#### å‚æ•°ä¼°è®¡

**æœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼ˆMaximum Likelihood Estimation, MLEï¼‰**ï¼š

ä¼¼ç„¶å‡½æ•°ï¼š
$$L(\boldsymbol{\beta}) = \prod_{i=1}^{n} P(Y=y_i|X=x_i) = \prod_{i=1}^{n} [\sigma(\boldsymbol{\beta}^T \mathbf{x}_i)]^{y_i} [1-\sigma(\boldsymbol{\beta}^T \mathbf{x}_i)]^{1-y_i}$$

å¯¹æ•°ä¼¼ç„¶å‡½æ•°ï¼š
$$\ell(\boldsymbol{\beta}) = \sum_{i=1}^{n} [y_i \log(\sigma(\boldsymbol{\beta}^T \mathbf{x}_i)) + (1-y_i)\log(1-\sigma(\boldsymbol{\beta}^T \mathbf{x}_i))]$$

**æ¢¯åº¦**ï¼š
$$\frac{\partial \ell}{\partial \beta_j} = \sum_{i=1}^{n} (y_i - \sigma(\boldsymbol{\beta}^T \mathbf{x}_i)) x_{ij}$$

**æ¢¯åº¦ä¸Šå‡æ›´æ–°**ï¼š
$$\beta_j^{(t+1)} = \beta_j^{(t)} + \alpha \sum_{i=1}^{n} (y_i - \sigma(\boldsymbol{\beta}^T \mathbf{x}_i)) x_{ij}$$

å…¶ä¸­ $\alpha$ æ˜¯å­¦ä¹ ç‡ã€‚

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ | è¯´æ˜ |
|------|------|--------|------|
| **Sigmoidå‡½æ•°** | äºŒåˆ†ç±»æ¦‚ç‡æ˜ å°„ | $O(1)$ | å°†çº¿æ€§ç»„åˆæ˜ å°„åˆ°[0,1] |
| **Softmaxå‡½æ•°** | å¤šåˆ†ç±»æ¦‚ç‡æ˜ å°„ | $O(k)$ | $k$æ˜¯ç±»åˆ«æ•° |
| **æœ€å¤§ä¼¼ç„¶ä¼°è®¡** | å‚æ•°ä¼°è®¡ | $O(n \cdot p \cdot iter)$ | $iter$æ˜¯è¿­ä»£æ¬¡æ•° |
| **æ¢¯åº¦ä¸Šå‡/ä¸‹é™** | ä¼˜åŒ–ç®—æ³• | $O(n \cdot p \cdot iter)$ | è¿­ä»£æ±‚è§£æœ€ä¼˜å‚æ•° |
| **ç‰›é¡¿æ³•** | ä¼˜åŒ–ç®—æ³• | $O(n \cdot p^2 \cdot iter)$ | äºŒé˜¶ä¼˜åŒ–æ–¹æ³• |

---

## 1. äºŒåˆ†ç±»é€»è¾‘å›å½’

### 1.1 Sigmoidå‡½æ•°åŸç†

**Sigmoidå‡½æ•°ï¼ˆLogisticå‡½æ•°ï¼‰**å°†çº¿æ€§ç»„åˆæ˜ å°„åˆ°0-1ä¹‹é—´çš„æ¦‚ç‡å€¼ã€‚

#### æ•°å­¦å®šä¹‰

**Sigmoidå‡½æ•°**ï¼š
$$\sigma(z) = \frac{1}{1 + e^{-z}} = \frac{e^z}{1 + e^z}$$

#### æ€§è´¨

1. **å€¼åŸŸ**ï¼š$\sigma(z) \in (0, 1)$
2. **å•è°ƒæ€§**ï¼šä¸¥æ ¼å•è°ƒé€’å¢
3. **å¯¹ç§°æ€§**ï¼š$\sigma(-z) = 1 - \sigma(z)$
4. **å¯¼æ•°**ï¼š$\sigma'(z) = \sigma(z)(1 - \sigma(z))$
5. **æ¸è¿‘æ€§**ï¼š
   - $\lim_{z \to +\infty} \sigma(z) = 1$
   - $\lim_{z \to -\infty} \sigma(z) = 0$

#### ä¼˜åŠ¿

- **æ¦‚ç‡è§£é‡Š**ï¼šè¾“å‡ºå¯ä»¥ç›´æ¥è§£é‡Šä¸ºæ¦‚ç‡
- **å¹³æ»‘æ€§**ï¼šå¤„å¤„å¯å¯¼ï¼Œä¾¿äºä¼˜åŒ–
- **æœ‰ç•Œæ€§**ï¼šè¾“å‡ºåœ¨[0,1]èŒƒå›´å†…ï¼Œé¿å…æº¢å‡º

### 1.2 Sigmoidå‡½æ•°å®ç°

```sql
-- åˆ›å»ºé€»è¾‘å›å½’æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'logistic_data') THEN
            RAISE WARNING 'è¡¨ logistic_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE logistic_data CASCADE;
        END IF;

        CREATE TABLE logistic_data (
            id SERIAL PRIMARY KEY,
            feature1 NUMERIC NOT NULL,
            feature2 NUMERIC NOT NULL,
            label INTEGER NOT NULL CHECK (label IN (0, 1))
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO logistic_data (feature1, feature2, label) VALUES
            (1.0, 2.0, 0), (2.0, 3.0, 0), (3.0, 4.0, 1),
            (4.0, 5.0, 1), (5.0, 6.0, 1), (6.0, 7.0, 1),
            (7.0, 8.0, 1), (8.0, 9.0, 1), (9.0, 10.0, 1), (10.0, 11.0, 1);

        RAISE NOTICE 'è¡¨ logistic_data åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥10æ¡æ•°æ®';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ logistic_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Sigmoidå‡½æ•°å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION sigmoid(z NUMERIC)
RETURNS NUMERIC
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
    BEGIN
        -- Sigmoidå‡½æ•°: 1 / (1 + exp(-z))
        -- é˜²æ­¢æº¢å‡º
        IF z > 700 THEN
            RETURN 1.0;
        ELSIF z < -700 THEN
            RETURN 0.0;
        ELSE
            RETURN 1.0 / (1.0 + EXP(-z));
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Sigmoidå‡½æ•°è®¡ç®—å¤±è´¥: %', SQLERRM;
            RETURN NULL;
    END;
END;
$$;

-- é€»è¾‘å›å½’é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'logistic_data') THEN
            RAISE WARNING 'è¡¨ logistic_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œé€»è¾‘å›å½’';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'sigmoid') THEN
            RAISE WARNING 'Sigmoidå‡½æ•°ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º';
            RETURN;
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œé€»è¾‘å›å½’é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é€»è¾‘å›å½’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨ç®€åŒ–çš„æƒé‡è¿›è¡Œé¢„æµ‹ï¼ˆå®é™…åº”ç”¨ä¸­éœ€è¦é€šè¿‡è®­ç»ƒå¾—åˆ°ï¼‰
WITH weights AS (
    SELECT 0.5 AS w1, 0.3 AS w2, -2.0 AS bias
),
predictions AS (
    SELECT
        id,
        feature1,
        feature2,
        label,
        sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) AS probability,
        CASE
            WHEN sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) > 0.5 THEN 1
            ELSE 0
        END AS predicted_label
    FROM logistic_data, weights w
)
SELECT
    id,
    feature1,
    feature2,
    label AS actual_label,
    ROUND(probability::numeric, 4) AS probability,
    predicted_label,
    CASE WHEN label = predicted_label THEN 1 ELSE 0 END AS is_correct
FROM predictions
ORDER BY id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH weights AS (
    SELECT 0.5 AS w1, 0.3 AS w2, -2.0 AS bias
)
SELECT
    sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) AS probability
FROM logistic_data, weights w
LIMIT 100;
```

---

## 2. å¤šåˆ†ç±»é€»è¾‘å›å½’

### 2.1 Softmaxå‡½æ•°åŸç†

**Softmaxå‡½æ•°**å°†å¤šä¸ªçº¿æ€§ç»„åˆæ˜ å°„åˆ°æ¦‚ç‡åˆ†å¸ƒï¼Œæ˜¯å¤šåˆ†ç±»é€»è¾‘å›å½’çš„æ ¸å¿ƒã€‚

#### æ•°å­¦å®šä¹‰

**Softmaxå‡½æ•°**ï¼š
$$\text{Softmax}(z_j) = \frac{e^{z_j}}{\sum_{k=1}^{K} e^{z_k}}$$

å…¶ä¸­ $z_j = \boldsymbol{\beta}_j^T \mathbf{x}$ æ˜¯ç¬¬ $j$ ç±»çš„çº¿æ€§ç»„åˆã€‚

#### æ€§è´¨

1. **æ¦‚ç‡åˆ†å¸ƒ**ï¼š$\sum_{j=1}^{K} \text{Softmax}(z_j) = 1$
2. **éè´Ÿæ€§**ï¼š$\text{Softmax}(z_j) > 0$ å¯¹æ‰€æœ‰ $j$
3. **å•è°ƒæ€§**ï¼šå¦‚æœ $z_j > z_k$ï¼Œåˆ™ $\text{Softmax}(z_j) > \text{Softmax}(z_k)$
4. **æ•°å€¼ç¨³å®šæ€§**ï¼šä½¿ç”¨ $z_j - \max_k z_k$ é˜²æ­¢æº¢å‡º

#### ä¸Sigmoidçš„å…³ç³»

å¯¹äºäºŒåˆ†ç±»é—®é¢˜ï¼ˆ$K=2$ï¼‰ï¼ŒSoftmaxç­‰ä»·äºSigmoidï¼š
$$\text{Softmax}(z_1) = \frac{e^{z_1}}{e^{z_1} + e^{z_2}} = \frac{1}{1 + e^{z_2 - z_1}} = \sigma(z_1 - z_2)$$

### 2.2 Softmaxå‡½æ•°å®ç°

```sql
-- Softmaxå‡½æ•°å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION softmax(z NUMERIC[])
RETURNS NUMERIC[]
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
    max_z NUMERIC;
    exp_sum NUMERIC;
    result NUMERIC[];
    i INTEGER;
BEGIN
    BEGIN
        IF z IS NULL OR array_length(z, 1) IS NULL THEN
            RAISE WARNING 'è¾“å…¥æ•°ç»„ä¸ºç©º';
            RETURN NULL;
        END IF;

        -- æ‰¾åˆ°æœ€å¤§å€¼ï¼ˆé˜²æ­¢æº¢å‡ºï¼‰
        SELECT MAX(unnest) INTO max_z FROM unnest(z) AS unnest;

        -- è®¡ç®—exp(z_i - max_z)çš„å’Œ
        SELECT SUM(EXP(unnest - max_z)) INTO exp_sum FROM unnest(z) AS unnest;

        -- è®¡ç®—Softmax
        result := ARRAY[]::NUMERIC[];
        FOR i IN 1..array_length(z, 1) LOOP
            result := result || EXP(z[i] - max_z) / exp_sum;
        END LOOP;

        RETURN result;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Softmaxå‡½æ•°è®¡ç®—å¤±è´¥: %', SQLERRM;
            RETURN NULL;
    END;
END;
$$;

-- å¤šåˆ†ç±»é€»è¾‘å›å½’ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multiclass_data') THEN
            RAISE WARNING 'è¡¨ multiclass_data ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE multiclass_data (
                id SERIAL PRIMARY KEY,
                feature1 NUMERIC NOT NULL,
                feature2 NUMERIC NOT NULL,
                class_label INTEGER NOT NULL CHECK (class_label IN (0, 1, 2))
            );

            INSERT INTO multiclass_data (feature1, feature2, class_label) VALUES
                (1.0, 2.0, 0), (2.0, 3.0, 0), (3.0, 4.0, 1),
                (4.0, 5.0, 1), (5.0, 6.0, 2), (6.0, 7.0, 2);

            RAISE NOTICE 'è¡¨ multiclass_data åˆ›å»ºæˆåŠŸ';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'softmax') THEN
            RAISE WARNING 'Softmaxå‡½æ•°ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º';
            RETURN;
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¤šåˆ†ç±»é€»è¾‘å›å½’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¤šåˆ†ç±»é€»è¾‘å›å½’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¤šåˆ†ç±»é¢„æµ‹ï¼ˆä½¿ç”¨ç®€åŒ–çš„æƒé‡ï¼‰
WITH weights AS (
    SELECT
        ARRAY[0.5, 0.3, -0.2] AS w1,  -- ç±»åˆ«0çš„æƒé‡
        ARRAY[0.2, 0.4, -0.1] AS w2,  -- ç±»åˆ«1çš„æƒé‡
        ARRAY[-0.3, 0.1, 0.5] AS w3,  -- ç±»åˆ«2çš„æƒé‡
        ARRAY[-1.0, -0.5, 0.0] AS bias
),
scores AS (
    SELECT
        id,
        feature1,
        feature2,
        class_label,
        ARRAY[
            w.w1[1] * feature1 + w.w1[2] * feature2 + w.w1[3] + w.bias[1],
            w.w2[1] * feature1 + w.w2[2] * feature2 + w.w2[3] + w.bias[2],
            w.w3[1] * feature1 + w.w3[2] * feature2 + w.w3[3] + w.bias[3]
        ] AS class_scores
    FROM multiclass_data, weights w
),
probabilities AS (
    SELECT
        id,
        feature1,
        feature2,
        class_label,
        class_scores,
        softmax(class_scores) AS probabilities
    FROM scores
)
SELECT
    id,
    feature1,
    feature2,
    class_label AS actual_class,
    probabilities[1] AS prob_class0,
    probabilities[2] AS prob_class1,
    probabilities[3] AS prob_class2,
    CASE
        WHEN probabilities[1] >= probabilities[2] AND probabilities[1] >= probabilities[3] THEN 0
        WHEN probabilities[2] >= probabilities[3] THEN 1
        ELSE 2
    END AS predicted_class
FROM probabilities
ORDER BY id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH weights AS (
    SELECT ARRAY[0.5, 0.3, -0.2] AS w1
)
SELECT feature1, feature2 FROM multiclass_data LIMIT 100;
```

---

## 3. å‚æ•°ä¼°è®¡æ–¹æ³•

### 3.1 æ¢¯åº¦ä¸Šå‡æ³•

**æ¢¯åº¦ä¸Šå‡æ³•ï¼ˆGradient Ascentï¼‰**é€šè¿‡è¿­ä»£æ›´æ–°å‚æ•°æœ€å¤§åŒ–å¯¹æ•°ä¼¼ç„¶å‡½æ•°ã€‚

#### ç®—æ³•æ­¥éª¤

1. **åˆå§‹åŒ–**ï¼š$\boldsymbol{\beta}^{(0)} = \mathbf{0}$
2. **è¿­ä»£æ›´æ–°**ï¼š
   $$\beta_j^{(t+1)} = \beta_j^{(t)} + \alpha \sum_{i=1}^{n} (y_i - \sigma(\boldsymbol{\beta}^{(t)T} \mathbf{x}_i)) x_{ij}$$
3. **æ”¶æ•›åˆ¤æ–­**ï¼šå½“ $||\boldsymbol{\beta}^{(t+1)} - \boldsymbol{\beta}^{(t)}|| < \epsilon$ æ—¶åœæ­¢

```sql
-- æ¢¯åº¦ä¸Šå‡æ³•å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼šå±•ç¤ºè¿­ä»£è¿‡ç¨‹ï¼‰
WITH initial_weights AS (
    SELECT
        0.0 AS beta0,
        0.0 AS beta1,
        0.0 AS beta2
),
gradient_step AS (
    SELECT
        iw.beta0 + 0.01 * SUM(ld.label - sigmoid(iw.beta0 + iw.beta1 * ld.feature1 + iw.beta2 * ld.feature2)) AS new_beta0,
        iw.beta1 + 0.01 * SUM((ld.label - sigmoid(iw.beta0 + iw.beta1 * ld.feature1 + iw.beta2 * ld.feature2)) * ld.feature1) AS new_beta1,
        iw.beta2 + 0.01 * SUM((ld.label - sigmoid(iw.beta0 + iw.beta1 * ld.feature1 + iw.beta2 * ld.feature2)) * ld.feature2) AS new_beta2
    FROM logistic_data ld
    CROSS JOIN initial_weights iw
    GROUP BY iw.beta0, iw.beta1, iw.beta2
)
SELECT
    ROUND(new_beta0::numeric, 6) AS updated_beta0,
    ROUND(new_beta1::numeric, 6) AS updated_beta1,
    ROUND(new_beta2::numeric, 6) AS updated_beta2
FROM gradient_step;
```

### 3.2 ç‰›é¡¿æ³•

**ç‰›é¡¿æ³•ï¼ˆNewton's Methodï¼‰**ä½¿ç”¨äºŒé˜¶å¯¼æ•°ä¿¡æ¯ï¼Œæ”¶æ•›é€Ÿåº¦æ›´å¿«ã€‚

**æ›´æ–°å…¬å¼**ï¼š
$$\boldsymbol{\beta}^{(t+1)} = \boldsymbol{\beta}^{(t)} - [H(\boldsymbol{\beta}^{(t)})]^{-1} \nabla \ell(\boldsymbol{\beta}^{(t)})$$

å…¶ä¸­ $H(\boldsymbol{\beta})$ æ˜¯HessiançŸ©é˜µï¼ˆäºŒé˜¶å¯¼æ•°çŸ©é˜µï¼‰ã€‚

## 4. æ¨¡å‹è¯„ä¼°

### 4.1 æ··æ·†çŸ©é˜µ

**æ··æ·†çŸ©é˜µï¼ˆConfusion Matrixï¼‰**å±•ç¤ºåˆ†ç±»ç»“æœçš„å‡†ç¡®æ€§ï¼Œæ˜¯åˆ†ç±»æ¨¡å‹è¯„ä¼°çš„åŸºç¡€ã€‚

```sql
-- æ··æ·†çŸ©é˜µè®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'logistic_data') THEN
            RAISE WARNING 'è¡¨ logistic_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—æ··æ·†çŸ©é˜µ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—æ··æ·†çŸ©é˜µ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ··æ·†çŸ©é˜µè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—æ··æ·†çŸ©é˜µ
WITH weights AS (
    SELECT 0.5 AS w1, 0.3 AS w2, -2.0 AS bias
),
predictions AS (
    SELECT
        label AS actual,
        CASE
            WHEN sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) > 0.5 THEN 1
            ELSE 0
        END AS predicted
    FROM logistic_data, weights w
),
confusion_matrix AS (
    SELECT
        actual,
        predicted,
        COUNT(*) AS count
    FROM predictions
    GROUP BY actual, predicted
)
SELECT
    SUM(CASE WHEN actual = 0 AND predicted = 0 THEN count ELSE 0 END) AS true_negative,
    SUM(CASE WHEN actual = 0 AND predicted = 1 THEN count ELSE 0 END) AS false_positive,
    SUM(CASE WHEN actual = 1 AND predicted = 0 THEN count ELSE 0 END) AS false_negative,
    SUM(CASE WHEN actual = 1 AND predicted = 1 THEN count ELSE 0 END) AS true_positive,
    COUNT(*) AS total
FROM predictions;

-- è®¡ç®—å‡†ç¡®ç‡ã€ç²¾ç¡®ç‡ã€å¬å›ç‡
WITH weights AS (
    SELECT 0.5 AS w1, 0.3 AS w2, -2.0 AS bias
),
predictions AS (
    SELECT
        label AS actual,
        CASE
            WHEN sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) > 0.5 THEN 1
            ELSE 0
        END AS predicted
    FROM logistic_data, weights w
),
metrics AS (
    SELECT
        SUM(CASE WHEN actual = 0 AND predicted = 0 THEN 1 ELSE 0 END) AS tn,
        SUM(CASE WHEN actual = 0 AND predicted = 1 THEN 1 ELSE 0 END) AS fp,
        SUM(CASE WHEN actual = 1 AND predicted = 0 THEN 1 ELSE 0 END) AS fn,
        SUM(CASE WHEN actual = 1 AND predicted = 1 THEN 1 ELSE 0 END) AS tp,
        COUNT(*) AS total
    FROM predictions
)
SELECT
    tn,
    fp,
    fn,
    tp,
    total,
    ROUND((tp + tn)::numeric / NULLIF(total, 0), 4) AS accuracy,
    ROUND(tp::numeric / NULLIF(tp + fp, 0), 4) AS precision,
    ROUND(tp::numeric / NULLIF(tp + fn, 0), 4) AS recall,
    ROUND(2 * tp::numeric / NULLIF(2 * tp + fp + fn, 0), 4) AS f1_score
FROM metrics;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH weights AS (
    SELECT 0.5 AS w1, 0.3 AS w2, -2.0 AS bias
)
SELECT
    label AS actual,
    CASE
        WHEN sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) > 0.5 THEN 1
        ELSE 0
    END AS predicted
FROM logistic_data, weights w;
```

### 4.2 è¯„ä¼°æŒ‡æ ‡

#### 4.2.1 å‡†ç¡®ç‡ï¼ˆAccuracyï¼‰

**å‡†ç¡®ç‡**ï¼šæ­£ç¡®åˆ†ç±»çš„æ ·æœ¬æ¯”ä¾‹
$$Accuracy = \frac{TP + TN}{TP + TN + FP + FN}$$

#### 4.2.2 ç²¾ç¡®ç‡ï¼ˆPrecisionï¼‰

**ç²¾ç¡®ç‡**ï¼šé¢„æµ‹ä¸ºæ­£ç±»ä¸­å®é™…ä¸ºæ­£ç±»çš„æ¯”ä¾‹
$$Precision = \frac{TP}{TP + FP}$$

#### 4.2.3 å¬å›ç‡ï¼ˆRecallï¼‰

**å¬å›ç‡**ï¼šå®é™…æ­£ç±»ä¸­è¢«æ­£ç¡®é¢„æµ‹çš„æ¯”ä¾‹
$$Recall = \frac{TP}{TP + FN}$$

#### 4.2.4 F1åˆ†æ•°

**F1åˆ†æ•°**ï¼šç²¾ç¡®ç‡å’Œå¬å›ç‡çš„è°ƒå’Œå¹³å‡
$$F1 = \frac{2 \times Precision \times Recall}{Precision + Recall}$$

#### 4.2.5 ç‰¹å¼‚æ€§ï¼ˆSpecificityï¼‰

**ç‰¹å¼‚æ€§**ï¼šå®é™…è´Ÿç±»ä¸­è¢«æ­£ç¡®é¢„æµ‹çš„æ¯”ä¾‹
$$Specificity = \frac{TN}{TN + FP}$$

### 4.3 ROCæ›²çº¿å’ŒAUC

**ROCæ›²çº¿ï¼ˆReceiver Operating Characteristic Curveï¼‰**è¯„ä¼°åˆ†ç±»å™¨åœ¨ä¸åŒé˜ˆå€¼ä¸‹çš„æ€§èƒ½ã€‚

#### ROCæ›²çº¿

- **æ¨ªè½´**ï¼šå‡æ­£ç‡ï¼ˆFalse Positive Rate, FPRï¼‰= $\frac{FP}{FP + TN}$
- **çºµè½´**ï¼šçœŸæ­£ç‡ï¼ˆTrue Positive Rate, TPRï¼‰= $\frac{TP}{TP + FN}$ = Recall

#### AUCï¼ˆArea Under Curveï¼‰

**AUCå€¼**ï¼šROCæ›²çº¿ä¸‹çš„é¢ç§¯ï¼Œå–å€¼èŒƒå›´[0, 1]

- **AUC = 1**ï¼šå®Œç¾åˆ†ç±»å™¨
- **AUC = 0.5**ï¼šéšæœºåˆ†ç±»å™¨
- **AUC > 0.7**ï¼šè¾ƒå¥½çš„åˆ†ç±»å™¨
- **AUC > 0.9**ï¼šä¼˜ç§€çš„åˆ†ç±»å™¨

#### AUCçš„è®¡ç®—

ä½¿ç”¨æ¢¯å½¢æ³•åˆ™æˆ–Mann-Whitney Uç»Ÿè®¡é‡ï¼š
$$AUC = \frac{1}{n_+ n_-} \sum_{i:y_i=1} \sum_{j:y_j=0} I(p_i > p_j)$$

å…¶ä¸­ $p_i$ æ˜¯ç¬¬ $i$ ä¸ªæ ·æœ¬çš„é¢„æµ‹æ¦‚ç‡ã€‚

```sql
-- ROCæ›²çº¿æ•°æ®è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'logistic_data') THEN
            RAISE WARNING 'è¡¨ logistic_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ROCæ›²çº¿';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—ROCæ›²çº¿æ•°æ®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ROCæ›²çº¿è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—ä¸åŒé˜ˆå€¼ä¸‹çš„TPRå’ŒFPR
WITH weights AS (
    SELECT 0.5 AS w1, 0.3 AS w2, -2.0 AS bias
),
probabilities AS (
    SELECT
        label AS actual,
        sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) AS prob
    FROM logistic_data, weights w
),
thresholds AS (
    SELECT unnest(ARRAY[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]) AS threshold
),
roc_points AS (
    SELECT
        t.threshold,
        SUM(CASE WHEN p.actual = 1 AND p.prob >= t.threshold THEN 1 ELSE 0 END)::numeric /
        NULLIF(SUM(CASE WHEN p.actual = 1 THEN 1 ELSE 0 END), 0) AS tpr,
        SUM(CASE WHEN p.actual = 0 AND p.prob >= t.threshold THEN 1 ELSE 0 END)::numeric /
        NULLIF(SUM(CASE WHEN p.actual = 0 THEN 1 ELSE 0 END), 0) AS fpr
    FROM thresholds t
    CROSS JOIN probabilities p
    GROUP BY t.threshold
)
SELECT
    threshold,
    ROUND(COALESCE(tpr, 0)::numeric, 4) AS tpr,
    ROUND(COALESCE(fpr, 0)::numeric, 4) AS fpr
FROM roc_points
ORDER BY threshold;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH weights AS (
    SELECT 0.5 AS w1, 0.3 AS w2, -2.0 AS bias
)
SELECT
    sigmoid(w.w1 * feature1 + w.w2 * feature2 + w.bias) AS prob
FROM logistic_data, weights w
LIMIT 100;
```

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 ç”¨æˆ·æµå¤±é¢„æµ‹

**ç”¨æˆ·æµå¤±é¢„æµ‹**ä½¿ç”¨é€»è¾‘å›å½’é¢„æµ‹ç”¨æˆ·æ˜¯å¦ä¼šæµå¤±ï¼Œæ”¯æŒå®¢æˆ·ä¿ç•™ç­–ç•¥ã€‚

```sql
-- ç”¨æˆ·æµå¤±é¢„æµ‹ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_behavior') THEN
            RAISE WARNING 'è¡¨ user_behavior ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE user_behavior (
                user_id SERIAL PRIMARY KEY,
                login_days INTEGER NOT NULL,
                purchase_count INTEGER NOT NULL,
                avg_session_duration NUMERIC NOT NULL,
                churned INTEGER NOT NULL CHECK (churned IN (0, 1))
            );

            INSERT INTO user_behavior (login_days, purchase_count, avg_session_duration, churned) VALUES
                (5, 2, 10.5, 1), (15, 5, 25.3, 0), (20, 8, 30.1, 0),
                (3, 1, 8.2, 1), (25, 10, 35.5, 0), (2, 0, 5.1, 1),
                (30, 12, 40.2, 0), (1, 0, 3.5, 1), (18, 6, 28.7, 0), (4, 1, 9.8, 1);

            RAISE NOTICE 'è¡¨ user_behavior åˆ›å»ºæˆåŠŸ';
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç”¨æˆ·æµå¤±é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç”¨æˆ·æµå¤±é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨é€»è¾‘å›å½’é¢„æµ‹ç”¨æˆ·æµå¤±æ¦‚ç‡
WITH weights AS (
    SELECT
        -0.1 AS w_login,
        0.05 AS w_purchase,
        -0.02 AS w_duration,
        -1.5 AS bias
),
predictions AS (
    SELECT
        user_id,
        login_days,
        purchase_count,
        avg_session_duration,
        churned AS actual_churned,
        sigmoid(
            w.w_login * login_days +
            w.w_purchase * purchase_count +
            w.w_duration * avg_session_duration +
            w.bias
        ) AS churn_probability,
        CASE
            WHEN sigmoid(
                w.w_login * login_days +
                w.w_purchase * purchase_count +
                w.w_duration * avg_session_duration +
                w.bias
            ) > 0.5 THEN 1
            ELSE 0
        END AS predicted_churned
    FROM user_behavior, weights w
)
SELECT
    user_id,
    login_days,
    purchase_count,
    avg_session_duration,
    actual_churned,
    ROUND(churn_probability::numeric, 4) AS churn_probability,
    predicted_churned,
    CASE WHEN actual_churned = predicted_churned THEN 'Correct' ELSE 'Wrong' END AS prediction_status
FROM predictions
ORDER BY churn_probability DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH weights AS (
    SELECT -0.1 AS w_login, 0.05 AS w_purchase, -0.02 AS w_duration, -1.5 AS bias
)
SELECT
    sigmoid(
        w.w_login * login_days +
        w.w_purchase * purchase_count +
        w.w_duration * avg_session_duration +
        w.bias
    ) AS churn_probability
FROM user_behavior, weights w;
```

### 5.2 ä¿¡ç”¨è¯„åˆ†

**åœºæ™¯**ï¼šä½¿ç”¨é€»è¾‘å›å½’è¿›è¡Œä¿¡ç”¨è¯„åˆ†ï¼Œè¯„ä¼°è´·æ¬¾ç”³è¯·äººçš„è¿çº¦é£é™©ã€‚

```sql
-- ä¿¡ç”¨è¯„åˆ†ï¼šè¿çº¦é£é™©é¢„æµ‹
WITH credit_data AS (
    SELECT
        applicant_id,
        age,
        income,
        credit_score,
        debt_to_income_ratio,
        employment_years,
        default_flag  -- 0: æœªè¿çº¦, 1: è¿çº¦
    FROM loan_applications
    WHERE application_date >= CURRENT_DATE - INTERVAL '12 months'
),
normalized_features AS (
    SELECT
        applicant_id,
        default_flag,
        (age - AVG(age) OVER ()) / NULLIF(STDDEV(age) OVER (), 0) AS norm_age,
        (income - AVG(income) OVER ()) / NULLIF(STDDEV(income) OVER (), 0) AS norm_income,
        (credit_score - AVG(credit_score) OVER ()) / NULLIF(STDDEV(credit_score) OVER (), 0) AS norm_credit_score,
        (debt_to_income_ratio - AVG(debt_to_income_ratio) OVER ()) / NULLIF(STDDEV(debt_to_income_ratio) OVER (), 0) AS norm_dti,
        (employment_years - AVG(employment_years) OVER ()) / NULLIF(STDDEV(employment_years) OVER (), 0) AS norm_employment
    FROM credit_data
),
regression_weights AS (
    -- è®­ç»ƒå¾—åˆ°çš„æƒé‡ï¼ˆç¤ºä¾‹å€¼ï¼‰
    SELECT
        -0.5 AS w_age,
        -0.8 AS w_income,
        -1.2 AS w_credit_score,
        0.6 AS w_dti,
        -0.4 AS w_employment,
        -1.0 AS bias
),
risk_predictions AS (
    SELECT
        nf.applicant_id,
        cd.age,
        cd.income,
        cd.credit_score,
        cd.debt_to_income_ratio,
        cd.default_flag AS actual_default,
        sigmoid(
            rw.w_age * nf.norm_age +
            rw.w_income * nf.norm_income +
            rw.w_credit_score * nf.norm_credit_score +
            rw.w_dti * nf.norm_dti +
            rw.w_employment * nf.norm_employment +
            rw.bias
        ) AS default_probability,
        CASE
            WHEN sigmoid(
                rw.w_age * nf.norm_age +
                rw.w_income * nf.norm_income +
                rw.w_credit_score * nf.norm_credit_score +
                rw.w_dti * nf.norm_dti +
                rw.w_employment * nf.norm_employment +
                rw.bias
            ) > 0.3 THEN 1  -- é˜ˆå€¼0.3ï¼ˆå¯æ ¹æ®ä¸šåŠ¡è°ƒæ•´ï¼‰
            ELSE 0
        END AS predicted_default
    FROM normalized_features nf
    JOIN credit_data cd ON nf.applicant_id = cd.applicant_id
    CROSS JOIN regression_weights rw
),
risk_assessment AS (
    SELECT
        applicant_id,
        age,
        income,
        credit_score,
        ROUND(default_probability::numeric, 4) AS default_probability,
        CASE
            WHEN default_probability < 0.1 THEN 'ä½é£é™©'
            WHEN default_probability < 0.3 THEN 'ä¸­é£é™©'
            WHEN default_probability < 0.5 THEN 'é«˜é£é™©'
            ELSE 'æé«˜é£é™©'
        END AS risk_level,
        CASE
            WHEN default_probability < 0.1 THEN 'æ‰¹å‡†'
            WHEN default_probability < 0.3 THEN 'æ¡ä»¶æ‰¹å‡†'
            WHEN default_probability < 0.5 THEN 'æ‹’ç»'
            ELSE 'æ‹’ç»'
        END AS recommendation
    FROM risk_predictions
)
SELECT
    applicant_id,
    credit_score,
    ROUND(default_probability::numeric, 4) AS default_probability,
    risk_level,
    recommendation
FROM risk_assessment
ORDER BY default_probability DESC;
```

### 5.3 åŒ»å­¦è¯Šæ–­

**åœºæ™¯**ï¼šä½¿ç”¨é€»è¾‘å›å½’è¿›è¡Œç–¾ç—…è¯Šæ–­ï¼Œé¢„æµ‹æ‚£è€…æ‚£ç—…çš„æ¦‚ç‡ã€‚

```sql
-- åŒ»å­¦è¯Šæ–­ï¼šç–¾ç—…é¢„æµ‹
WITH patient_data AS (
    SELECT
        patient_id,
        age,
        bmi,
        blood_pressure,
        cholesterol_level,
        glucose_level,
        family_history_flag,
        disease_flag  -- 0: å¥åº·, 1: æ‚£ç—…
    FROM medical_records
    WHERE exam_date >= CURRENT_DATE - INTERVAL '6 months'
),
diagnostic_model AS (
    SELECT
        patient_id,
        age,
        bmi,
        blood_pressure,
        cholesterol_level,
        glucose_level,
        family_history_flag,
        disease_flag AS actual_disease,
        -- ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹æƒé‡ï¼ˆç¤ºä¾‹å€¼ï¼‰
        sigmoid(
            -0.05 * age +
            0.1 * bmi +
            0.02 * blood_pressure +
            0.01 * cholesterol_level +
            0.015 * glucose_level +
            0.5 * family_history_flag +
            -3.0  -- bias
        ) AS disease_probability
    FROM patient_data
),
diagnosis_results AS (
    SELECT
        patient_id,
        age,
        bmi,
        ROUND(disease_probability::numeric, 4) AS disease_probability,
        CASE
            WHEN disease_probability > 0.5 THEN 1
            ELSE 0
        END AS predicted_disease,
        actual_disease,
        CASE
            WHEN disease_probability < 0.2 THEN 'ä½é£é™©'
            WHEN disease_probability < 0.5 THEN 'ä¸­ç­‰é£é™©'
            WHEN disease_probability < 0.8 THEN 'é«˜é£é™©'
            ELSE 'æé«˜é£é™©'
        END AS risk_category
    FROM diagnostic_model
)
SELECT
    patient_id,
    age,
    ROUND(disease_probability::numeric, 4) AS disease_probability,
    risk_category,
    CASE
        WHEN actual_disease = predicted_disease THEN 'æ­£ç¡®'
        ELSE 'é”™è¯¯'
    END AS prediction_status
FROM diagnosis_results
ORDER BY disease_probability DESC;
```

### 5.4 è¥é”€å“åº”é¢„æµ‹

**åœºæ™¯**ï¼šé¢„æµ‹å®¢æˆ·å¯¹è¥é”€æ´»åŠ¨çš„å“åº”æ¦‚ç‡ï¼Œä¼˜åŒ–è¥é”€ç­–ç•¥ã€‚

```sql
-- è¥é”€å“åº”é¢„æµ‹ï¼šé¢„æµ‹å®¢æˆ·å¯¹ä¿ƒé”€æ´»åŠ¨çš„å“åº”
WITH customer_data AS (
    SELECT
        customer_id,
        age,
        total_purchases,
        avg_order_value,
        days_since_last_purchase,
        email_opens_rate,
        clicked_ads_count,
        responded_to_campaign  -- 0: æœªå“åº”, 1: å“åº”
    FROM marketing_campaign_data
    WHERE campaign_date >= CURRENT_DATE - INTERVAL '3 months'
),
response_model AS (
    SELECT
        customer_id,
        age,
        total_purchases,
        avg_order_value,
        days_since_last_purchase,
        email_opens_rate,
        clicked_ads_count,
        responded_to_campaign AS actual_response,
        -- ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹æƒé‡
        sigmoid(
            0.01 * age +
            0.05 * total_purchases +
            0.02 * avg_order_value +
            -0.01 * days_since_last_purchase +
            0.8 * email_opens_rate +
            0.3 * clicked_ads_count +
            -2.0  -- bias
        ) AS response_probability
    FROM customer_data
),
response_predictions AS (
    SELECT
        customer_id,
        age,
        total_purchases,
        ROUND(response_probability::numeric, 4) AS response_probability,
        CASE
            WHEN response_probability > 0.5 THEN 1
            ELSE 0
        END AS predicted_response,
        actual_response,
        CASE
            WHEN response_probability > 0.7 THEN 'é«˜å“åº”æ¦‚ç‡'
            WHEN response_probability > 0.5 THEN 'ä¸­ç­‰å“åº”æ¦‚ç‡'
            WHEN response_probability > 0.3 THEN 'ä½å“åº”æ¦‚ç‡'
            ELSE 'æä½å“åº”æ¦‚ç‡'
        END AS response_category
    FROM response_model
)
SELECT
    customer_id,
    total_purchases,
    ROUND(response_probability::numeric, 4) AS response_probability,
    response_category,
    CASE
        WHEN actual_response = predicted_response THEN 'æ­£ç¡®'
        ELSE 'é”™è¯¯'
    END AS prediction_status
FROM response_predictions
ORDER BY response_probability DESC;
```

---

## 6. PostgreSQL 18å¹¶è¡Œé€»è¾‘å›å½’

### 6.1 å¹¶è¡Œé€»è¾‘å›å½’æ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œé€»è¾‘å›å½’**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡é€»è¾‘å›å½’è®¡ç®—çš„æ€§èƒ½ã€‚

#### å¹¶è¡Œé€»è¾‘å›å½’é…ç½®

```sql
-- é…ç½®å¹¶è¡Œé€»è¾‘å›å½’å‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œé€»è¾‘å›å½’å‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œé€»è¾‘å›å½’é…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œé€»è¾‘å›å½’å®ç°

```sql
-- å¹¶è¡Œé€»è¾‘å›å½’ï¼šå¤§è§„æ¨¡æ•°æ®åˆ†ç±»åˆ†æï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œé€»è¾‘å›å½’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œé€»è¾‘å›å½’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡ŒSigmoidå‡½æ•°è®¡ç®—å’Œæ¦‚ç‡é¢„æµ‹
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_features AS (
    SELECT
        id,
        feature1,
        feature2,
        feature3,
        label
    FROM training_data
),
parallel_predictions AS (
    SELECT
        id,
        feature1,
        feature2,
        feature3,
        label,
        -- çº¿æ€§ç»„åˆï¼ˆå‡è®¾ç³»æ•°å·²è®­ç»ƒï¼‰
        1.0 * feature1 + 0.5 * feature2 - 0.3 * feature3 AS linear_combination,
        -- Sigmoidå‡½æ•°ï¼š1 / (1 + exp(-z))
        1.0 / (1.0 + EXP(-(1.0 * feature1 + 0.5 * feature2 - 0.3 * feature3))) AS predicted_probability
    FROM parallel_features
)
SELECT
    label,
    COUNT(*) AS total_samples,
    COUNT(*) FILTER (WHERE predicted_probability > 0.5) AS predicted_positive,
    COUNT(*) FILTER (WHERE predicted_probability <= 0.5) AS predicted_negative,
    ROUND(AVG(predicted_probability)::numeric, 4) AS avg_probability
FROM parallel_predictions
GROUP BY label
ORDER BY label;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 7.1 é€»è¾‘å›å½’ vs å…¶ä»–åˆ†ç±»ç®—æ³•

| ç®—æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **é€»è¾‘å›å½’** | å¯è§£é‡Šæ€§å¼ºã€æ¦‚ç‡è¾“å‡ºã€è®­ç»ƒå¿« | å‡è®¾çº¿æ€§å…³ç³»ã€å¯¹å¼‚å¸¸å€¼æ•æ„Ÿ | çº¿æ€§å¯åˆ†æ•°æ®ã€éœ€è¦æ¦‚ç‡è¾“å‡º |
| **çº¿æ€§SVM** | æ³›åŒ–èƒ½åŠ›å¼ºã€æ”¯æŒé«˜ç»´æ•°æ® | ä¸æä¾›æ¦‚ç‡ã€å‚æ•°æ•æ„Ÿ | çº¿æ€§åˆ†ç±»ã€é«˜ç»´æ•°æ® |
| **å†³ç­–æ ‘** | å¯è§£é‡Šã€å¤„ç†éçº¿æ€§ | å®¹æ˜“è¿‡æ‹Ÿåˆ | ç‰¹å¾é‡è¦æ€§åˆ†æ |
| **éšæœºæ£®æ—** | å‡†ç¡®ç‡é«˜ã€æŠ—è¿‡æ‹Ÿåˆ | å¯è§£é‡Šæ€§å·® | å¤§è§„æ¨¡æ•°æ® |
| **ç¥ç»ç½‘ç»œ** | è¡¨è¾¾èƒ½åŠ›å¼º | éœ€è¦å¤§é‡æ•°æ®ã€è°ƒå‚å¤æ‚ | å¤æ‚éçº¿æ€§å…³ç³» |

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å‡½æ•°ä¼˜åŒ–**ï¼šä½¿ç”¨IMMUTABLEæ ‡è®°æé«˜å‡½æ•°æ€§èƒ½
2. **ç´¢å¼•ä¼˜åŒ–**ï¼šåœ¨ç‰¹å¾åˆ—ä¸Šåˆ›å»ºç´¢å¼•åŠ é€ŸæŸ¥è¯¢
3. **æ‰¹é‡å¤„ç†**ï¼šä½¿ç”¨æ•°ç»„æ“ä½œå‡å°‘å‡½æ•°è°ƒç”¨æ¬¡æ•°
4. **å¹¶è¡Œè®¡ç®—**ï¼šåˆ©ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢åŠ é€Ÿæ¢¯åº¦è®¡ç®—
5. **ç‰¹å¾é€‰æ‹©**ï¼šå‡å°‘ç‰¹å¾æ•°é‡é™ä½è®¡ç®—å¤æ‚åº¦

### 7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šæ¨¡å‹ä¸æ”¶æ•›

- **è§£å†³æ–¹æ¡ˆ**ï¼šå‡å°å­¦ä¹ ç‡ã€å¢åŠ è¿­ä»£æ¬¡æ•°ã€æ£€æŸ¥æ•°æ®è´¨é‡

**é—®é¢˜2**ï¼šè¿‡æ‹Ÿåˆ

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨L1/L2æ­£åˆ™åŒ–ã€å‡å°‘ç‰¹å¾æ•°ã€å¢åŠ æ•°æ®é‡

**é—®é¢˜3**ï¼šç±»åˆ«ä¸å¹³è¡¡

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ç±»åˆ«æƒé‡ã€SMOTEé‡‡æ ·ã€è°ƒæ•´é˜ˆå€¼

**é—®é¢˜4**ï¼šç‰¹å¾å…±çº¿æ€§

- **è§£å†³æ–¹æ¡ˆ**ï¼šåˆ é™¤ç›¸å…³ç‰¹å¾ã€ä½¿ç”¨æ­£åˆ™åŒ–ã€ä¸»æˆåˆ†åˆ†æ

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ•°æ®å‡†å¤‡

1. **ç‰¹å¾å·¥ç¨‹**ï¼š
   - **æ ‡å‡†åŒ–**ï¼šå¯¹è¿ç»­ç‰¹å¾è¿›è¡ŒZ-scoreæ ‡å‡†åŒ–
   - **ç¼–ç **ï¼šå¯¹åˆ†ç±»ç‰¹å¾è¿›è¡Œç‹¬çƒ­ç¼–ç æˆ–æ ‡ç­¾ç¼–ç 
   - **ç‰¹å¾é€‰æ‹©**ï¼šé€‰æ‹©ä¸ç›®æ ‡å˜é‡ç›¸å…³æ€§é«˜çš„ç‰¹å¾

2. **æ•°æ®è´¨é‡**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼ï¼šåˆ é™¤æˆ–å¡«å……
   - å¤„ç†å¼‚å¸¸å€¼ï¼šè¯†åˆ«å’Œå¤„ç†æç«¯å€¼
   - æ£€æŸ¥å¤šé‡å…±çº¿æ€§ï¼šè®¡ç®—ç‰¹å¾é—´ç›¸å…³ç³»æ•°

3. **æ•°æ®åˆ†å‰²**ï¼š
   - è®­ç»ƒé›†ï¼š70-80%
   - éªŒè¯é›†ï¼š10-15%
   - æµ‹è¯•é›†ï¼š10-15%

### 8.2 æ¨¡å‹è®­ç»ƒ

1. **å‚æ•°åˆå§‹åŒ–**ï¼š
   - é€šå¸¸åˆå§‹åŒ–ä¸º0æˆ–å°çš„éšæœºå€¼
   - é¿å…åˆå§‹å€¼è¿‡å¤§å¯¼è‡´æ¢¯åº¦æ¶ˆå¤±

2. **å­¦ä¹ ç‡é€‰æ‹©**ï¼š
   - é€šå¸¸ä»0.01å¼€å§‹
   - ä½¿ç”¨å­¦ä¹ ç‡è¡°å‡ç­–ç•¥
   - ç›‘æ§æŸå¤±å‡½æ•°å˜åŒ–

3. **æ­£åˆ™åŒ–**ï¼š
   - **L1æ­£åˆ™åŒ–ï¼ˆLassoï¼‰**ï¼š$\lambda \sum_{j=1}^{p} |\beta_j|$ï¼Œç‰¹å¾é€‰æ‹©
   - **L2æ­£åˆ™åŒ–ï¼ˆRidgeï¼‰**ï¼š$\lambda \sum_{j=1}^{p} \beta_j^2$ï¼Œé˜²æ­¢è¿‡æ‹Ÿåˆ
   - **å¼¹æ€§ç½‘ç»œ**ï¼šç»“åˆL1å’ŒL2

### 8.3 æ¨¡å‹è¯„ä¼°

1. **è¯„ä¼°æŒ‡æ ‡é€‰æ‹©**ï¼š
   - **å‡†ç¡®ç‡**ï¼šç±»åˆ«å¹³è¡¡æ—¶ä½¿ç”¨
   - **ç²¾ç¡®ç‡å’Œå¬å›ç‡**ï¼šç±»åˆ«ä¸å¹³è¡¡æ—¶ä½¿ç”¨
   - **F1åˆ†æ•°**ï¼šå¹³è¡¡ç²¾ç¡®ç‡å’Œå¬å›ç‡
   - **AUC**ï¼šè¯„ä¼°æ•´ä½“åˆ†ç±»èƒ½åŠ›

2. **äº¤å‰éªŒè¯**ï¼š
   - kæŠ˜äº¤å‰éªŒè¯ï¼ˆé€šå¸¸k=5æˆ–k=10ï¼‰
   - åˆ†å±‚kæŠ˜äº¤å‰éªŒè¯ï¼ˆä¿æŒç±»åˆ«æ¯”ä¾‹ï¼‰

3. **é˜ˆå€¼ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨ROCæ›²çº¿é€‰æ‹©æœ€ä¼˜é˜ˆå€¼
   - æ ¹æ®ä¸šåŠ¡éœ€æ±‚è°ƒæ•´é˜ˆå€¼ï¼ˆå¦‚æˆæœ¬æ•æ„Ÿï¼‰

### 8.4 æ¨¡å‹è§£é‡Š

1. **ç³»æ•°è§£é‡Š**ï¼š
   - ç³»æ•°ç¬¦å·ï¼šæ­£ç³»æ•°å¢åŠ æ¦‚ç‡ï¼Œè´Ÿç³»æ•°é™ä½æ¦‚ç‡
   - ç³»æ•°å¤§å°ï¼šç»å¯¹å€¼è¶Šå¤§ï¼Œå½±å“è¶Šå¤§
   - ä¼˜åŠ¿æ¯”ï¼š$e^{\beta_j}$ è¡¨ç¤ºç‰¹å¾å¢åŠ 1å•ä½æ—¶ä¼˜åŠ¿çš„å€æ•°

2. **ç‰¹å¾é‡è¦æ€§**ï¼š
   - ä½¿ç”¨ç³»æ•°ç»å¯¹å€¼æ’åº
   - ä½¿ç”¨på€¼åˆ¤æ–­ç»Ÿè®¡æ˜¾è‘—æ€§
   - ä½¿ç”¨ä¼˜åŠ¿æ¯”è§£é‡Šå®é™…å½±å“

### 8.5 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ•°å€¼ç¨³å®šæ€§**ï¼š
   - Sigmoidå‡½æ•°é˜²æ­¢æº¢å‡ºï¼ˆæ£€æŸ¥zçš„èŒƒå›´ï¼‰
   - Softmaxå‡½æ•°å‡å»æœ€å¤§å€¼é˜²æ­¢æº¢å‡º
   - ä½¿ç”¨NUMERICç±»å‹ä¿æŒç²¾åº¦

2. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - åˆ›å»ºç‰¹å¾ç´¢å¼•
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ä¸­é—´ç»“æœ
   - æ‰¹é‡å¤„ç†å‡å°‘å‡½æ•°è°ƒç”¨

3. **æ‰©å±•å‡½æ•°**ï¼š
   - è€ƒè™‘ä½¿ç”¨PL/Pythonè°ƒç”¨scikit-learn
   - æˆ–ä½¿ç”¨PostgreSQLæ‰©å±•ï¼ˆå¦‚MADlibï¼‰

### 8.6 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡é€»è¾‘å›å½’è®¡ç®—çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«ç‰¹å¾å€¼çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºç‰¹å¾é€‰æ‹©å’ŒTop-Ké¢„æµ‹æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡é€»è¾‘å›å½’è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡é¢„æµ‹å’Œå¤šåˆ†ç±»é€»è¾‘å›å½’

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - é€»è¾‘å›å½’æ¢¯åº¦è®¡ç®—æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œ
   - é€‚ç”¨äºå¤§è§„æ¨¡åˆ†ç±»åˆ†æå’Œæ‰¹é‡é¢„æµ‹

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–ç‰¹å¾é€‰æ‹©æŸ¥è¯¢**

```sql
-- ä¸ºé€»è¾‘å›å½’ç‰¹å¾åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_logistic_features_skip_scan
ON classification_data USING btree(feature1 DESC, feature2 DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾ç‰¹å¾å€¼æœ€é«˜çš„å‰10ä¸ªæ ·æœ¬
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    sample_id,
    feature1,
    feature2,
    label
FROM classification_data
WHERE feature1 > 0.5 AND feature2 > 0.5
ORDER BY feature1 DESC, feature2 DESC
LIMIT 10;
```

### 8.7 é«˜çº§ä¼˜åŒ–æŠ€å·§

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜é€»è¾‘å›å½’æ¨¡å‹å‚æ•°**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„é€»è¾‘å›å½’æ¨¡å‹ï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å‚æ•°ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜é€»è¾‘å›å½’æ¨¡å‹å‚æ•°
CREATE MATERIALIZED VIEW IF NOT EXISTS logistic_models_cache AS
WITH logistic_stats AS (
    SELECT
        model_id,
        COUNT(*) FILTER (WHERE label = 1) AS positive_count,
        COUNT(*) FILTER (WHERE label = 0) AS negative_count,
        COUNT(*) AS total_count,
        AVG(feature1) AS feature1_mean,
        AVG(feature2) AS feature2_mean,
        STDDEV(feature1) AS feature1_stddev,
        STDDEV(feature2) AS feature2_stddev
    FROM classification_data
    GROUP BY model_id
)
SELECT
    model_id,
    positive_count,
    negative_count,
    total_count,
    feature1_mean,
    feature2_mean,
    feature1_stddev,
    feature2_stddev,
    -- è®¡ç®—é€»è¾‘å›å½’ç³»æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
    LN(positive_count::numeric / NULLIF(negative_count, 0)) AS log_odds
FROM logistic_stats;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_logistic_models_cache_id ON logistic_models_cache(model_id);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY logistic_models_cache;
```

**2. å®æ—¶åˆ†ç±»é¢„æµ‹ï¼šæ‰¹é‡é¢„æµ‹ä¼˜åŒ–**

ä½¿ç”¨çª—å£å‡½æ•°ä¼˜åŒ–æ‰¹é‡é¢„æµ‹è®¡ç®—ï¼š

```sql
-- å®æ—¶åˆ†ç±»é¢„æµ‹ï¼šæ‰¹é‡é¢„æµ‹ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'classification_data') THEN
            RAISE WARNING 'è¡¨ classification_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ‰¹é‡é¢„æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œæ‰¹é‡åˆ†ç±»é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ‰¹é‡é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ‰¹é‡é¢„æµ‹ï¼šä½¿ç”¨é€»è¾‘å›å½’æ¨¡å‹è¿›è¡Œæ‰¹é‡åˆ†ç±»
WITH logistic_coefficients AS (
    SELECT
        -- ä½¿ç”¨æœ€å¤§ä¼¼ç„¶ä¼°è®¡è®¡ç®—é€»è¾‘å›å½’ç³»æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
        (SUM(feature1 * label) - AVG(feature1) * SUM(label)) /
        NULLIF(SUM(POWER(feature1 - AVG(feature1), 2)), 0) AS beta1,
        (SUM(feature2 * label) - AVG(feature2) * SUM(label)) /
        NULLIF(SUM(POWER(feature2 - AVG(feature2), 2)), 0) AS beta2,
        LN(SUM(label)::numeric / NULLIF(COUNT(*) - SUM(label), 0)) AS beta0
    FROM classification_data
    WHERE feature1 IS NOT NULL AND feature2 IS NOT NULL AND label IS NOT NULL
),
predictions AS (
    SELECT
        cd.sample_id,
        cd.feature1,
        cd.feature2,
        cd.label AS actual_label,
        -- è®¡ç®—é€»è¾‘å›å½’å¾—åˆ†
        lc.beta0 + lc.beta1 * cd.feature1 + lc.beta2 * cd.feature2 AS logit_score,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—é¢„æµ‹æ¦‚ç‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        1.0 / (1.0 + EXP(-(lc.beta0 + lc.beta1 * cd.feature1 + lc.beta2 * cd.feature2))) AS predicted_probability
    FROM classification_data cd
    CROSS JOIN logistic_coefficients lc
    WHERE cd.feature1 IS NOT NULL AND cd.feature2 IS NOT NULL
)
SELECT
    sample_id,
    feature1,
    feature2,
    actual_label,
    ROUND(logit_score::numeric, 4) AS logit_score,
    ROUND(predicted_probability::numeric, 4) AS predicted_probability,
    CASE
        WHEN predicted_probability >= 0.5 THEN 1
        ELSE 0
    END AS predicted_label,
    CASE
        WHEN (predicted_probability >= 0.5 AND actual_label = 1) OR
             (predicted_probability < 0.5 AND actual_label = 0) THEN 'Correct'
        ELSE 'Incorrect'
    END AS prediction_status
FROM predictions
ORDER BY predicted_probability DESC
LIMIT 100;
```

**3. å¤šåˆ†ç±»é€»è¾‘å›å½’ï¼šSoftmaxå›å½’å®ç°**

**å¤šåˆ†ç±»é€»è¾‘å›å½’**ï¼šä½¿ç”¨Softmaxå‡½æ•°å®ç°å¤šåˆ†ç±»é€»è¾‘å›å½’ã€‚

```sql
-- å¤šåˆ†ç±»é€»è¾‘å›å½’ï¼šSoftmaxå›å½’å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multiclass_data') THEN
            CREATE TABLE multiclass_data (
                sample_id SERIAL PRIMARY KEY,
                feature1 NUMERIC NOT NULL,
                feature2 NUMERIC NOT NULL,
                feature3 NUMERIC NOT NULL,
                class_label INTEGER NOT NULL  -- 0, 1, 2, 3
            );

            CREATE INDEX idx_multiclass_features ON multiclass_data(feature1, feature2, feature3);
            CREATE INDEX idx_multiclass_label ON multiclass_data(class_label);

            RAISE NOTICE 'å¤šåˆ†ç±»æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¤šåˆ†ç±»é€»è¾‘å›å½’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¤šåˆ†ç±»é€»è¾‘å›å½’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Softmaxå›å½’ï¼šå¤šåˆ†ç±»é€»è¾‘å›å½’é¢„æµ‹
WITH class_coefficients AS (
    SELECT
        class_label,
        -- ä¸ºæ¯ä¸ªç±»åˆ«è®¡ç®—é€»è¾‘å›å½’ç³»æ•°ï¼ˆç®€åŒ–ç‰ˆï¼Œä½¿ç”¨çº¿æ€§å›å½’è¿‘ä¼¼ï¼‰
        AVG(feature1) FILTER (WHERE class_label = class_label) AS beta1,
        AVG(feature2) FILTER (WHERE class_label = class_label) AS beta2,
        AVG(feature3) FILTER (WHERE class_label = class_label) AS beta3
    FROM multiclass_data
    GROUP BY class_label
),
sample_scores AS (
    SELECT
        md.sample_id,
        md.feature1,
        md.feature2,
        md.feature3,
        md.class_label AS actual_class,
        -- è®¡ç®—æ¯ä¸ªç±»åˆ«çš„å¾—åˆ†
        cc.beta1 * md.feature1 + cc.beta2 * md.feature2 + cc.beta3 * md.feature3 AS class_score,
        cc.class_label AS predicted_class
    FROM multiclass_data md
    CROSS JOIN class_coefficients cc
),
softmax_probabilities AS (
    SELECT
        sample_id,
        feature1,
        feature2,
        feature3,
        actual_class,
        predicted_class,
        class_score,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—Softmaxæ¦‚ç‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        EXP(class_score) / SUM(EXP(class_score)) OVER (PARTITION BY sample_id) AS class_probability
    FROM sample_scores
)
SELECT
    sample_id,
    feature1,
    feature2,
    feature3,
    actual_class,
    predicted_class,
    ROUND(class_score::numeric, 4) AS class_score,
    ROUND(class_probability::numeric, 4) AS class_probability
FROM softmax_probabilities
WHERE class_probability = (
    SELECT MAX(class_probability)
    FROM softmax_probabilities sp2
    WHERE sp2.sample_id = softmax_probabilities.sample_id
)
ORDER BY sample_id, class_probability DESC;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **Cox, D.R. (1958)**: "The Regression Analysis of Binary Sequences", *Journal of the Royal Statistical Society*.

2. **Hosmer, D.W., Lemeshow, S. (2000)**: "Applied Logistic Regression", 2nd Edition, Wiley.

3. **ã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹**ï¼ˆæèˆªï¼Œ2012ï¼‰- ç¬¬6ç«  é€»è¾‘æ–¯è°›å›å½’ä¸æœ€å¤§ç†µæ¨¡å‹

4. **ã€ŠThe Elements of Statistical Learningã€‹**ï¼ˆHastie et al., 2009ï¼‰- Chapter 4: Linear Methods for Classification

5. **ã€ŠAn Introduction to Statistical Learningã€‹**ï¼ˆJames et al., 2013ï¼‰- Chapter 4: Classification

### åœ¨çº¿èµ„æº

- **scikit-learné€»è¾‘å›å½’**: <https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html>
- **PostgreSQL MADlibæ‰©å±•**: <https://madlib.apache.org/>
- **é€»è¾‘å›å½’å¯è§†åŒ–**: <https://seeing-theory.brown.edu/probability-distributions/index.html>

### ç›¸å…³ç®—æ³•

- **çº¿æ€§å›å½’**ï¼šå›å½’é—®é¢˜çš„çº¿æ€§æ¨¡å‹
- **æ„ŸçŸ¥æœº**ï¼šçº¿æ€§åˆ†ç±»å™¨
- **æ”¯æŒå‘é‡æœº**ï¼šæœ€å¤§é—´éš”åˆ†ç±»å™¨
- **Softmaxå›å½’**ï¼šå¤šåˆ†ç±»é€»è¾‘å›å½’
- **å¹¿ä¹‰çº¿æ€§æ¨¡å‹ï¼ˆGLMï¼‰**ï¼šé€»è¾‘å›å½’çš„æ‰©å±•

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
