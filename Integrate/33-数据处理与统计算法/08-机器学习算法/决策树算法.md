# PostgreSQL å†³ç­–æ ‘ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | å†³ç­–æ ‘ | åˆ†ç±»ç®—æ³•
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å†³ç­–æ ‘ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å†³ç­–æ ‘ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å†³ç­–æ ‘æ¦‚è¿°](#å†³ç­–æ ‘æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [å†³ç­–æ ‘å®šä¹‰](#å†³ç­–æ ‘å®šä¹‰)
      - [å†³ç­–æ ‘æ„å»ºè¿‡ç¨‹](#å†³ç­–æ ‘æ„å»ºè¿‡ç¨‹)
      - [å†³ç­–æ ‘ç®—æ³•ç±»å‹](#å†³ç­–æ ‘ç®—æ³•ç±»å‹)
      - [å†³ç­–æ ‘ä¼˜ç¼ºç‚¹](#å†³ç­–æ ‘ä¼˜ç¼ºç‚¹)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. ä¿¡æ¯ç†µè®¡ç®—](#1-ä¿¡æ¯ç†µè®¡ç®—)
    - [1.1 ä¿¡æ¯ç†µåŸç†](#11-ä¿¡æ¯ç†µåŸç†)
      - [ä¿¡æ¯ç†µå®šä¹‰](#ä¿¡æ¯ç†µå®šä¹‰)
      - [ç†µçš„ç‰¹æ€§](#ç†µçš„ç‰¹æ€§)
    - [1.2 ç†µå‡½æ•°å®ç°](#12-ç†µå‡½æ•°å®ç°)
    - [1.3 æ¡ä»¶ç†µè®¡ç®—](#13-æ¡ä»¶ç†µè®¡ç®—)
  - [2. ä¿¡æ¯å¢ç›Š](#2-ä¿¡æ¯å¢ç›Š)
    - [2.1 ä¿¡æ¯å¢ç›ŠåŸç†](#21-ä¿¡æ¯å¢ç›ŠåŸç†)
      - [ä¿¡æ¯å¢ç›Šå®šä¹‰](#ä¿¡æ¯å¢ç›Šå®šä¹‰)
    - [2.2 ä¿¡æ¯å¢ç›Šè®¡ç®—å®ç°](#22-ä¿¡æ¯å¢ç›Šè®¡ç®—å®ç°)
    - [2.3 ä¿¡æ¯å¢ç›Šç‡](#23-ä¿¡æ¯å¢ç›Šç‡)
    - [2.4 åŸºå°¼ä¸çº¯åº¦](#24-åŸºå°¼ä¸çº¯åº¦)
  - [3. å†³ç­–æ ‘æ„å»º](#3-å†³ç­–æ ‘æ„å»º)
    - [3.1 å†³ç­–æ ‘æ„å»ºåŸç†](#31-å†³ç­–æ ‘æ„å»ºåŸç†)
      - [ID3ç®—æ³•æ­¥éª¤](#id3ç®—æ³•æ­¥éª¤)
    - [3.2 ç®€å•å†³ç­–æ ‘å®ç°](#32-ç®€å•å†³ç­–æ ‘å®ç°)
    - [3.3 å†³ç­–æ ‘å‰ªæ](#33-å†³ç­–æ ‘å‰ªæ)
    - [3.4 å†³ç­–æ ‘å¯è§†åŒ–ï¼ˆç®€åŒ–ç‰ˆï¼‰](#34-å†³ç­–æ ‘å¯è§†åŒ–ç®€åŒ–ç‰ˆ)
  - [4. æ¨¡å‹è¯„ä¼°](#4-æ¨¡å‹è¯„ä¼°)
    - [4.1 å‡†ç¡®ç‡è®¡ç®—](#41-å‡†ç¡®ç‡è®¡ç®—)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 å®¢æˆ·åˆ†ç±»](#51-å®¢æˆ·åˆ†ç±»)
    - [5.2 è´·æ¬¾é£é™©è¯„ä¼°](#52-è´·æ¬¾é£é™©è¯„ä¼°)
    - [5.3 äº§å“æ¨èå†³ç­–æ ‘](#53-äº§å“æ¨èå†³ç­–æ ‘)
    - [5.4 åŒ»ç–—è¯Šæ–­å†³ç­–æ ‘](#54-åŒ»ç–—è¯Šæ–­å†³ç­–æ ‘)
  - [6. PostgreSQL 18å¹¶è¡Œå†³ç­–æ ‘](#6-postgresql-18å¹¶è¡Œå†³ç­–æ ‘)
    - [6.1 å¹¶è¡Œå†³ç­–æ ‘æ¦‚è¿°](#61-å¹¶è¡Œå†³ç­–æ ‘æ¦‚è¿°)
      - [å¹¶è¡Œå†³ç­–æ ‘é…ç½®](#å¹¶è¡Œå†³ç­–æ ‘é…ç½®)
      - [å¹¶è¡Œå†³ç­–æ ‘å®ç°](#å¹¶è¡Œå†³ç­–æ ‘å®ç°)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [7.1 å†³ç­–æ ‘ç®—æ³•å¯¹æ¯”](#71-å†³ç­–æ ‘ç®—æ³•å¯¹æ¯”)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#73-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 å†³ç­–æ ‘æ„å»ºæµç¨‹](#81-å†³ç­–æ ‘æ„å»ºæµç¨‹)
    - [8.2 å†³ç­–æ ‘æ³¨æ„äº‹é¡¹](#82-å†³ç­–æ ‘æ³¨æ„äº‹é¡¹)
    - [8.3 SQLå®ç°æ³¨æ„äº‹é¡¹](#83-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [8.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨](#84-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨)
    - [8.5 é«˜çº§ä¼˜åŒ–æŠ€å·§](#85-é«˜çº§ä¼˜åŒ–æŠ€å·§)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## å†³ç­–æ ‘æ¦‚è¿°

**å†³ç­–æ ‘ï¼ˆDecision Treeï¼‰**æ˜¯ä¸€ç§æ ‘å½¢ç»“æ„çš„åˆ†ç±»å’Œå›å½’ç®—æ³•ï¼Œé€šè¿‡é€’å½’åˆ†å‰²æ•°æ®æ¥æ„å»ºå†³ç­–è§„åˆ™ã€‚å†³ç­–æ ‘å…·æœ‰å¯è§£é‡Šæ€§å¼ºã€æ˜“äºç†è§£å’Œå®ç°çš„ä¼˜ç‚¹ï¼Œæ˜¯æœºå™¨å­¦ä¹ ä¸­æœ€å¸¸ç”¨çš„ç®—æ³•ä¹‹ä¸€ã€‚

### ç†è®ºåŸºç¡€

#### å†³ç­–æ ‘å®šä¹‰

**å†³ç­–æ ‘**æ˜¯ä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œå…¶ä¸­ï¼š

- **å†…éƒ¨èŠ‚ç‚¹**ï¼šè¡¨ç¤ºç‰¹å¾ï¼ˆå±æ€§ï¼‰
- **åˆ†æ”¯**ï¼šè¡¨ç¤ºç‰¹å¾çš„å–å€¼
- **å¶èŠ‚ç‚¹**ï¼šè¡¨ç¤ºç±»åˆ«ï¼ˆåˆ†ç±»ï¼‰æˆ–å€¼ï¼ˆå›å½’ï¼‰

#### å†³ç­–æ ‘æ„å»ºè¿‡ç¨‹

1. **ç‰¹å¾é€‰æ‹©**ï¼šé€‰æ‹©æœ€ä½³ç‰¹å¾è¿›è¡Œåˆ†å‰²
2. **æ•°æ®åˆ†å‰²**ï¼šæ ¹æ®ç‰¹å¾å€¼åˆ†å‰²æ•°æ®
3. **é€’å½’æ„å»º**ï¼šå¯¹æ¯ä¸ªå­é›†é€’å½’æ„å»ºå­æ ‘
4. **åœæ­¢æ¡ä»¶**ï¼šæ»¡è¶³åœæ­¢æ¡ä»¶æ—¶åˆ›å»ºå¶èŠ‚ç‚¹

#### å†³ç­–æ ‘ç®—æ³•ç±»å‹

1. **ID3ç®—æ³•**ï¼šä½¿ç”¨ä¿¡æ¯å¢ç›Šé€‰æ‹©ç‰¹å¾
2. **C4.5ç®—æ³•**ï¼šä½¿ç”¨ä¿¡æ¯å¢ç›Šç‡é€‰æ‹©ç‰¹å¾
3. **CARTç®—æ³•**ï¼šä½¿ç”¨åŸºå°¼ä¸çº¯åº¦é€‰æ‹©ç‰¹å¾
4. **CHAIDç®—æ³•**ï¼šä½¿ç”¨å¡æ–¹æ£€éªŒé€‰æ‹©ç‰¹å¾

#### å†³ç­–æ ‘ä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**ï¼š

- å¯è§£é‡Šæ€§å¼º
- æ˜“äºç†è§£å’Œå®ç°
- ä¸éœ€è¦ç‰¹å¾ç¼©æ”¾
- å¯ä»¥å¤„ç†éçº¿æ€§å…³ç³»

**ç¼ºç‚¹**ï¼š

- å®¹æ˜“è¿‡æ‹Ÿåˆ
- å¯¹å™ªå£°æ•æ„Ÿ
- ä¸ç¨³å®šï¼ˆæ•°æ®å¾®å°å˜åŒ–å¯èƒ½å¯¼è‡´æ ‘ç»“æ„å˜åŒ–ï¼‰

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ | æ•°å­¦è¡¨ç¤º |
|------|------|--------|---------|
| **ä¿¡æ¯ç†µ** | è¡¡é‡æ•°æ®çº¯åº¦ | $O(n)$ | $H(S) = -\sum p_i \log_2 p_i$ |
| **ä¿¡æ¯å¢ç›Š** | é€‰æ‹©æœ€ä½³åˆ†å‰²ç‚¹ | $O(nm)$ | $IG(S,A) = H(S) - H(S\|A)$ |
| **åŸºå°¼ä¸çº¯åº¦** | è¡¡é‡æ•°æ®ä¸çº¯åº¦ | $O(n)$ | $Gini(S) = 1 - \sum p_i^2$ |
| **ID3ç®—æ³•** | æ„å»ºå†³ç­–æ ‘ | $O(nm \log n)$ | é€’å½’æ„å»º |

---

## 1. ä¿¡æ¯ç†µè®¡ç®—

### 1.1 ä¿¡æ¯ç†µåŸç†

**ä¿¡æ¯ç†µï¼ˆInformation Entropyï¼‰**è¡¡é‡æ•°æ®é›†çš„æ··ä¹±ç¨‹åº¦æˆ–ä¸çº¯åº¦ã€‚ç†µå€¼è¶Šå¤§ï¼Œæ•°æ®è¶Šæ··ä¹±ï¼›ç†µå€¼è¶Šå°ï¼Œæ•°æ®è¶Šçº¯å‡€ã€‚

#### ä¿¡æ¯ç†µå®šä¹‰

**ä¿¡æ¯ç†µ**ï¼š
$$H(S) = -\sum_{i=1}^{c} p_i \log_2 p_i$$

å…¶ä¸­ï¼š

- $S$ï¼šæ•°æ®é›†
- $c$ï¼šç±»åˆ«æ•°
- $p_i$ï¼šç±»åˆ«$i$çš„æ¦‚ç‡

#### ç†µçš„ç‰¹æ€§

1. **æœ€å¤§å€¼**ï¼šå½“æ‰€æœ‰ç±»åˆ«æ¦‚ç‡ç›¸ç­‰æ—¶ï¼Œç†µæœ€å¤§
2. **æœ€å°å€¼**ï¼šå½“åªæœ‰ä¸€ä¸ªç±»åˆ«æ—¶ï¼Œç†µä¸º0
3. **èŒƒå›´**ï¼š$0 \leq H(S) \leq \log_2 c$

### 1.2 ç†µå‡½æ•°å®ç°

```sql
-- åˆ›å»ºå†³ç­–æ ‘æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE decision_tree_data CASCADE;
        END IF;

        CREATE TABLE decision_tree_data (
            id SERIAL PRIMARY KEY,
            outlook VARCHAR(20) NOT NULL,
            temperature NUMERIC NOT NULL,
            humidity NUMERIC NOT NULL,
            windy BOOLEAN NOT NULL,
            play_tennis INTEGER NOT NULL CHECK (play_tennis IN (0, 1))
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO decision_tree_data (outlook, temperature, humidity, windy, play_tennis) VALUES
            ('sunny', 85, 85, false, 0), ('sunny', 80, 90, true, 0),
            ('overcast', 83, 86, false, 1), ('rain', 70, 96, false, 1),
            ('rain', 68, 80, false, 1), ('rain', 65, 70, true, 0),
            ('overcast', 64, 65, true, 1), ('sunny', 72, 95, false, 0),
            ('sunny', 69, 70, false, 1), ('rain', 75, 80, false, 1);

        RAISE NOTICE 'è¡¨ decision_tree_data åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥10æ¡æ•°æ®';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ decision_tree_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- ä¿¡æ¯ç†µè®¡ç®—å‡½æ•°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
CREATE OR REPLACE FUNCTION calculate_entropy(class_counts NUMERIC[])
RETURNS NUMERIC
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
    total NUMERIC;
    entropy NUMERIC := 0;
    p NUMERIC;
    i INTEGER;
BEGIN
    BEGIN
        IF class_counts IS NULL OR array_length(class_counts, 1) IS NULL THEN
            RAISE WARNING 'ç±»åˆ«è®¡æ•°æ•°ç»„ä¸ºç©º';
            RETURN 0;
        END IF;

        -- è®¡ç®—æ€»æ•°
        SELECT SUM(unnest) INTO total FROM unnest(class_counts) AS unnest;

        IF total = 0 THEN
            RETURN 0;
        END IF;

        -- è®¡ç®—ç†µ: -Î£(p * log2(p))
        FOR i IN 1..array_length(class_counts, 1) LOOP
            p := class_counts[i] / total;
            IF p > 0 THEN
                entropy := entropy - p * LOG(2, p);
            END IF;
        END LOOP;

        RETURN entropy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç†µè®¡ç®—å¤±è´¥: %', SQLERRM;
            RETURN NULL;
    END;
END;
$$;

-- è®¡ç®—æ•°æ®é›†çš„æ€»ç†µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ç†µ';
            RETURN;
        END IF;

        IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'calculate_entropy') THEN
            RAISE WARNING 'calculate_entropyå‡½æ•°ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º';
            RETURN;
        END IF;

        RAISE NOTICE 'å¼€å§‹è®¡ç®—ä¿¡æ¯ç†µ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç†µè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—æ€»ç†µ
WITH class_distribution AS (
    SELECT
        play_tennis,
        COUNT(*) AS count
    FROM decision_tree_data
    GROUP BY play_tennis
),
class_counts AS (
    SELECT ARRAY_AGG(count ORDER BY play_tennis) AS counts
    FROM class_distribution
)
SELECT
    counts,
    calculate_entropy(counts) AS entropy
FROM class_counts;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    play_tennis,
    COUNT(*) AS count
FROM decision_tree_data
GROUP BY play_tennis;
```

---

### 1.3 æ¡ä»¶ç†µè®¡ç®—

**æ¡ä»¶ç†µ**è®¡ç®—åœ¨ç»™å®šç‰¹å¾æ¡ä»¶ä¸‹çš„ç†µã€‚

```sql
-- æ¡ä»¶ç†µè®¡ç®—ï¼šç»™å®šç‰¹å¾Açš„æ¡ä»¶ç†µ
WITH feature_entropy AS (
    SELECT
        outlook,
        COUNT(*) AS outlook_count,
        calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
    FROM (
        SELECT outlook, play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY outlook, play_tennis
    ) t
    GROUP BY outlook
)
SELECT
    outlook,
    outlook_count,
    ROUND(conditional_entropy::numeric, 4) AS conditional_entropy,
    -- åŠ æƒæ¡ä»¶ç†µ
    ROUND((outlook_count * conditional_entropy)::numeric, 4) AS weighted_entropy
FROM feature_entropy
ORDER BY outlook;
```

---

## 2. ä¿¡æ¯å¢ç›Š

### 2.1 ä¿¡æ¯å¢ç›ŠåŸç†

**ä¿¡æ¯å¢ç›Šï¼ˆInformation Gainï¼‰**è¡¡é‡ä½¿ç”¨æŸä¸ªç‰¹å¾åˆ†å‰²æ•°æ®åç†µçš„å‡å°‘é‡ã€‚ä¿¡æ¯å¢ç›Šè¶Šå¤§ï¼Œè¯¥ç‰¹å¾å¯¹åˆ†ç±»çš„è´¡çŒ®è¶Šå¤§ã€‚

#### ä¿¡æ¯å¢ç›Šå®šä¹‰

**ä¿¡æ¯å¢ç›Š**ï¼š
$$IG(S, A) = H(S) - H(S|A)$$

å…¶ä¸­ï¼š

- $H(S)$ï¼šæ•°æ®é›†$S$çš„ç†µ
- $H(S|A)$ï¼šç»™å®šç‰¹å¾$A$çš„æ¡ä»¶ç†µ

**æ¡ä»¶ç†µ**ï¼š
$$H(S|A) = \sum_{v \in Values(A)} \frac{|S_v|}{|S|} H(S_v)$$

å…¶ä¸­$S_v$æ˜¯ç‰¹å¾$A$å–å€¼ä¸º$v$çš„å­é›†ã€‚

### 2.2 ä¿¡æ¯å¢ç›Šè®¡ç®—å®ç°

```sql
-- ä¿¡æ¯å¢ç›Šè®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ä¿¡æ¯å¢ç›Š';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—ä¿¡æ¯å¢ç›Š';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¿¡æ¯å¢ç›Šè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—outlookç‰¹å¾çš„ä¿¡æ¯å¢ç›Š
WITH total_entropy AS (
    SELECT calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS entropy
    FROM (
        SELECT play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY play_tennis
    ) t
),
outlook_entropy AS (
    SELECT
        outlook,
        COUNT(*) AS outlook_count,
        calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
    FROM (
        SELECT outlook, play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY outlook, play_tennis
    ) t
    GROUP BY outlook
),
weighted_entropy AS (
    SELECT
        SUM(outlook_count * conditional_entropy) / SUM(outlook_count) AS weighted_avg_entropy,
        SUM(outlook_count) AS total_count
    FROM outlook_entropy
)
SELECT
    t.entropy AS total_entropy,
    w.weighted_avg_entropy AS weighted_entropy,
    t.entropy - w.weighted_avg_entropy AS information_gain
FROM total_entropy t, weighted_entropy w;

-- è®¡ç®—æ‰€æœ‰ç‰¹å¾çš„ä¿¡æ¯å¢ç›Š
WITH total_entropy AS (
    SELECT calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS entropy
    FROM (
        SELECT play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY play_tennis
    ) t
),
feature_gains AS (
    -- Outlookç‰¹å¾
    SELECT
        'outlook' AS feature,
        t.entropy - (
            SELECT SUM(outlook_count * conditional_entropy) / SUM(outlook_count)
            FROM (
                SELECT
                    outlook,
                    COUNT(*) AS outlook_count,
                    calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
                FROM (
                    SELECT outlook, play_tennis, COUNT(*) AS count
                    FROM decision_tree_data
                    GROUP BY outlook, play_tennis
                ) t2
                GROUP BY outlook
            ) t3
        ) AS information_gain
    FROM total_entropy t

    UNION ALL

    -- Temperatureç‰¹å¾ï¼ˆç¦»æ•£åŒ–ï¼‰
    SELECT
        'temperature' AS feature,
        t.entropy - (
            SELECT SUM(temp_count * conditional_entropy) / SUM(temp_count)
            FROM (
                SELECT
                    CASE
                        WHEN temperature < 70 THEN 'cool'
                        WHEN temperature < 80 THEN 'mild'
                        ELSE 'hot'
                    END AS temp_category,
                    COUNT(*) AS temp_count,
                    calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
                FROM (
                    SELECT
                        CASE
                            WHEN temperature < 70 THEN 'cool'
                            WHEN temperature < 80 THEN 'mild'
                            ELSE 'hot'
                        END AS temp_category,
                        play_tennis,
                        COUNT(*) AS count
                    FROM decision_tree_data
                    GROUP BY temp_category, play_tennis
                ) t2
                GROUP BY temp_category
            ) t3
        ) AS information_gain
    FROM total_entropy t
)
SELECT
    feature,
    ROUND(information_gain::numeric, 4) AS information_gain
FROM feature_gains
ORDER BY information_gain DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    outlook,
    play_tennis,
    COUNT(*) AS count
FROM decision_tree_data
GROUP BY outlook, play_tennis;
```

---

### 2.3 ä¿¡æ¯å¢ç›Šç‡

**ä¿¡æ¯å¢ç›Šç‡**è§£å†³ä¿¡æ¯å¢ç›Šåå‘å¤šå€¼ç‰¹å¾çš„é—®é¢˜ã€‚

```sql
-- ä¿¡æ¯å¢ç›Šç‡è®¡ç®—ï¼šIGR = IG / IV
WITH total_entropy AS (
    SELECT calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS entropy
    FROM (
        SELECT play_tennis, COUNT(*) AS count
        FROM decision_tree_data
        GROUP BY play_tennis
    ) t
),
feature_stats AS (
    SELECT
        'outlook' AS feature,
        COUNT(DISTINCT outlook) AS value_count,
        COUNT(*) AS total_count,
        -- ä¿¡æ¯å¢ç›Š
        (SELECT entropy FROM total_entropy) - (
            SELECT SUM(outlook_count * conditional_entropy) / SUM(outlook_count)
            FROM (
                SELECT
                    outlook,
                    COUNT(*) AS outlook_count,
                    calculate_entropy(ARRAY_AGG(count ORDER BY play_tennis)) AS conditional_entropy
                FROM (
                    SELECT outlook, play_tennis, COUNT(*) AS count
                    FROM decision_tree_data
                    GROUP BY outlook, play_tennis
                ) t2
                GROUP BY outlook
            ) t3
        ) AS information_gain,
        -- å›ºæœ‰å€¼ï¼ˆIntrinsic Valueï¼‰
        calculate_entropy(ARRAY_AGG(outlook_count)) AS intrinsic_value
    FROM (
        SELECT outlook, COUNT(*) AS outlook_count
        FROM decision_tree_data
        GROUP BY outlook
    ) t4
)
SELECT
    feature,
    value_count,
    ROUND(information_gain::numeric, 4) AS information_gain,
    ROUND(intrinsic_value::numeric, 4) AS intrinsic_value,
    -- ä¿¡æ¯å¢ç›Šç‡
    ROUND((information_gain / NULLIF(intrinsic_value, 0))::numeric, 4) AS gain_ratio
FROM feature_stats;
```

### 2.4 åŸºå°¼ä¸çº¯åº¦

**åŸºå°¼ä¸çº¯åº¦ï¼ˆGini Impurityï¼‰**æ˜¯å¦ä¸€ç§è¡¡é‡æ•°æ®ä¸çº¯åº¦çš„æ–¹æ³•ã€‚

```sql
-- åŸºå°¼ä¸çº¯åº¦è®¡ç®—å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_gini(class_counts NUMERIC[])
RETURNS NUMERIC
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
    total NUMERIC;
    gini NUMERIC := 1;
    p NUMERIC;
    i INTEGER;
BEGIN
    BEGIN
        IF class_counts IS NULL OR array_length(class_counts, 1) IS NULL THEN
            RETURN 0;
        END IF;

        SELECT SUM(unnest) INTO total FROM unnest(class_counts) AS unnest;

        IF total = 0 THEN
            RETURN 0;
        END IF;

        -- è®¡ç®—åŸºå°¼ä¸çº¯åº¦: 1 - Î£(p_i^2)
        FOR i IN 1..array_length(class_counts, 1) LOOP
            p := class_counts[i] / total;
            gini := gini - p * p;
        END LOOP;

        RETURN gini;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END;
END;
$$;

-- åŸºå°¼ä¸çº¯åº¦è®¡ç®—
WITH class_distribution AS (
    SELECT
        play_tennis,
        COUNT(*) AS count
    FROM decision_tree_data
    GROUP BY play_tennis
),
class_counts AS (
    SELECT ARRAY_AGG(count ORDER BY play_tennis) AS counts
    FROM class_distribution
)
SELECT
    counts,
    calculate_gini(counts) AS gini_impurity,
    calculate_entropy(counts) AS entropy
FROM class_counts;
```

---

## 3. å†³ç­–æ ‘æ„å»º

### 3.1 å†³ç­–æ ‘æ„å»ºåŸç†

**å†³ç­–æ ‘æ„å»º**ä½¿ç”¨é€’å½’æ–¹å¼é€‰æ‹©æœ€ä½³ç‰¹å¾è¿›è¡Œåˆ†å‰²ï¼Œç›´åˆ°æ»¡è¶³åœæ­¢æ¡ä»¶ã€‚

#### ID3ç®—æ³•æ­¥éª¤

1. **è®¡ç®—æ•°æ®é›†ç†µ**ï¼š$H(S)$
2. **å¯¹æ¯ä¸ªç‰¹å¾**ï¼š
   - è®¡ç®—æ¡ä»¶ç†µï¼š$H(S|A)$
   - è®¡ç®—ä¿¡æ¯å¢ç›Šï¼š$IG(S, A) = H(S) - H(S|A)$
3. **é€‰æ‹©ä¿¡æ¯å¢ç›Šæœ€å¤§çš„ç‰¹å¾**ä½œä¸ºåˆ†å‰²ç‰¹å¾
4. **é€’å½’æ„å»ºå­æ ‘**ï¼šå¯¹æ¯ä¸ªç‰¹å¾å€¼åˆ›å»ºå­èŠ‚ç‚¹
5. **åœæ­¢æ¡ä»¶**ï¼š
   - æ‰€æœ‰æ ·æœ¬å±äºåŒä¸€ç±»åˆ«
   - æ²¡æœ‰æ›´å¤šç‰¹å¾
   - ä¿¡æ¯å¢ç›Šå°äºé˜ˆå€¼

### 3.2 ç®€å•å†³ç­–æ ‘å®ç°

```sql
-- ç®€å•å†³ç­–æ ‘é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_data') THEN
            RAISE WARNING 'è¡¨ decision_tree_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ„å»ºå†³ç­–æ ‘';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ„å»ºå†³ç­–æ ‘';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å†³ç­–æ ‘æ„å»ºå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨ç®€åŒ–çš„å†³ç­–è§„åˆ™è¿›è¡Œé¢„æµ‹
WITH predictions AS (
    SELECT
        id,
        outlook,
        temperature,
        humidity,
        windy,
        play_tennis AS actual,
        CASE
            -- ç¬¬ä¸€å±‚ï¼šæ ¹æ®outlookåˆ†å‰²
            WHEN outlook = 'overcast' THEN 1
            WHEN outlook = 'sunny' THEN
                CASE
                    -- ç¬¬äºŒå±‚ï¼šæ ¹æ®humidityåˆ†å‰²
                    WHEN humidity <= 75 THEN 1
                    ELSE 0
                END
            WHEN outlook = 'rain' THEN
                CASE
                    -- ç¬¬äºŒå±‚ï¼šæ ¹æ®windyåˆ†å‰²
                    WHEN windy = false THEN 1
                    ELSE 0
                END
            ELSE 0
        END AS predicted
    FROM decision_tree_data
)
SELECT
    id,
    outlook,
    temperature,
    humidity,
    windy,
    actual,
    predicted,
    CASE WHEN actual = predicted THEN 'Correct' ELSE 'Wrong' END AS status
FROM predictions
ORDER BY id;

-- è®¡ç®—å‡†ç¡®ç‡
WITH predictions AS (
    SELECT
        play_tennis AS actual,
        CASE
            WHEN outlook = 'overcast' THEN 1
            WHEN outlook = 'sunny' AND humidity <= 75 THEN 1
            WHEN outlook = 'rain' AND windy = false THEN 1
            ELSE 0
        END AS predicted
    FROM decision_tree_data
)
SELECT
    COUNT(*) AS total,
    SUM(CASE WHEN actual = predicted THEN 1 ELSE 0 END) AS correct,
    ROUND(SUM(CASE WHEN actual = predicted THEN 1 ELSE 0 END)::numeric / COUNT(*), 4) AS accuracy
FROM predictions;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    CASE
        WHEN outlook = 'overcast' THEN 1
        WHEN outlook = 'sunny' AND humidity <= 75 THEN 1
        WHEN outlook = 'rain' AND windy = false THEN 1
        ELSE 0
    END AS predicted
FROM decision_tree_data;
```

---

### 3.3 å†³ç­–æ ‘å‰ªæ

**å‰ªæ**é˜²æ­¢å†³ç­–æ ‘è¿‡æ‹Ÿåˆã€‚

```sql
-- å†³ç­–æ ‘å‰ªæï¼šä½¿ç”¨æœ€å°æ ·æœ¬æ•°é™åˆ¶
WITH tree_nodes AS (
    SELECT
        outlook,
        humidity,
        windy,
        play_tennis,
        COUNT(*) AS node_count
    FROM decision_tree_data
    GROUP BY outlook, humidity, windy, play_tennis
),
pruned_nodes AS (
    SELECT
        outlook,
        humidity,
        windy,
        play_tennis,
        node_count,
        -- å¦‚æœèŠ‚ç‚¹æ ·æœ¬æ•°å°äºé˜ˆå€¼ï¼Œåˆ™åˆå¹¶åˆ°çˆ¶èŠ‚ç‚¹
        CASE
            WHEN node_count < 2 THEN 'pruned'
            ELSE 'kept'
        END AS pruning_status
    FROM tree_nodes
)
SELECT
    outlook,
    humidity,
    windy,
    play_tennis,
    node_count,
    pruning_status
FROM pruned_nodes
ORDER BY outlook, humidity, windy;
```

### 3.4 å†³ç­–æ ‘å¯è§†åŒ–ï¼ˆç®€åŒ–ç‰ˆï¼‰

**å¯è§†åŒ–**å±•ç¤ºå†³ç­–æ ‘çš„ç»“æ„ã€‚

```sql
-- å†³ç­–æ ‘ç»“æ„å¯è§†åŒ–ï¼šå±•ç¤ºå†³ç­–è·¯å¾„
WITH decision_paths AS (
    SELECT
        id,
        outlook,
        humidity,
        windy,
        play_tennis,
        -- å†³ç­–è·¯å¾„
        CASE
            WHEN outlook = 'overcast' THEN 'Root -> Overcast -> Play'
            WHEN outlook = 'sunny' AND humidity <= 75 THEN 'Root -> Sunny -> Low Humidity -> Play'
            WHEN outlook = 'sunny' AND humidity > 75 THEN 'Root -> Sunny -> High Humidity -> Don''t Play'
            WHEN outlook = 'rain' AND windy = false THEN 'Root -> Rain -> Not Windy -> Play'
            WHEN outlook = 'rain' AND windy = true THEN 'Root -> Rain -> Windy -> Don''t Play'
            ELSE 'Unknown'
        END AS decision_path
    FROM decision_tree_data
)
SELECT
    decision_path,
    COUNT(*) AS path_count,
    COUNT(*) FILTER (WHERE play_tennis = 1) AS play_count,
    COUNT(*) FILTER (WHERE play_tennis = 0) AS dont_play_count
FROM decision_paths
GROUP BY decision_path
ORDER BY path_count DESC;
```

---

## 4. æ¨¡å‹è¯„ä¼°

### 4.1 å‡†ç¡®ç‡è®¡ç®—

**å‡†ç¡®ç‡**è¡¡é‡åˆ†ç±»æ¨¡å‹çš„æ€§èƒ½ã€‚

```sql
-- å‡†ç¡®ç‡ã€ç²¾ç¡®ç‡ã€å¬å›ç‡è®¡ç®—
WITH predictions AS (
    SELECT
        play_tennis AS actual,
        CASE
            WHEN outlook = 'overcast' THEN 1
            WHEN outlook = 'sunny' AND humidity <= 75 THEN 1
            WHEN outlook = 'rain' AND windy = false THEN 1
            ELSE 0
        END AS predicted
    FROM decision_tree_data
),
confusion_matrix AS (
    SELECT
        SUM(CASE WHEN actual = 1 AND predicted = 1 THEN 1 ELSE 0 END) AS tp,
        SUM(CASE WHEN actual = 1 AND predicted = 0 THEN 1 ELSE 0 END) AS fn,
        SUM(CASE WHEN actual = 0 AND predicted = 1 THEN 1 ELSE 0 END) AS fp,
        SUM(CASE WHEN actual = 0 AND predicted = 0 THEN 1 ELSE 0 END) AS tn,
        COUNT(*) AS total
    FROM predictions
)
SELECT
    tp,
    fn,
    fp,
    tn,
    total,
    -- å‡†ç¡®ç‡
    ROUND((tp + tn)::numeric / total, 4) AS accuracy,
    -- ç²¾ç¡®ç‡
    ROUND(tp::numeric / NULLIF(tp + fp, 0), 4) AS precision,
    -- å¬å›ç‡
    ROUND(tp::numeric / NULLIF(tp + fn, 0), 4) AS recall,
    -- F1åˆ†æ•°
    ROUND(2 * tp::numeric / NULLIF(2 * tp + fp + fn, 0), 4) AS f1_score
FROM confusion_matrix;
```

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 å®¢æˆ·åˆ†ç±»

**å®¢æˆ·åˆ†ç±»**ä½¿ç”¨å†³ç­–æ ‘å¯¹å®¢æˆ·è¿›è¡Œåˆ†ç±»ã€‚

```sql
-- å®¢æˆ·åˆ†ç±»ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customer_data') THEN
            RAISE WARNING 'è¡¨ customer_data ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE customer_data (
                customer_id SERIAL PRIMARY KEY,
                age INTEGER NOT NULL,
                income NUMERIC NOT NULL,
                credit_score INTEGER NOT NULL,
                purchase_history INTEGER NOT NULL,
                customer_segment VARCHAR(20) NOT NULL
            );

            INSERT INTO customer_data (age, income, credit_score, purchase_history, customer_segment) VALUES
                (25, 30000, 650, 5, 'low'), (35, 50000, 720, 15, 'medium'),
                (45, 80000, 780, 30, 'high'), (30, 40000, 680, 8, 'low'),
                (50, 100000, 800, 50, 'high'), (28, 35000, 660, 6, 'low'),
                (40, 70000, 750, 25, 'medium'), (55, 120000, 820, 60, 'high');

            RAISE NOTICE 'è¡¨ customer_data åˆ›å»ºæˆåŠŸ';
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®¢æˆ·åˆ†ç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·åˆ†ç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨å†³ç­–æ ‘è§„åˆ™è¿›è¡Œå®¢æˆ·åˆ†ç±»
WITH predictions AS (
    SELECT
        customer_id,
        age,
        income,
        credit_score,
        purchase_history,
        customer_segment AS actual_segment,
        CASE
            WHEN income >= 90000 THEN 'high'
            WHEN income >= 60000 AND credit_score >= 750 THEN 'high'
            WHEN income >= 40000 AND purchase_history >= 20 THEN 'medium'
            WHEN income >= 40000 THEN 'medium'
            ELSE 'low'
        END AS predicted_segment
    FROM customer_data
)
SELECT
    customer_id,
    age,
    income,
    credit_score,
    purchase_history,
    actual_segment,
    predicted_segment,
    CASE WHEN actual_segment = predicted_segment THEN 'Correct' ELSE 'Wrong' END AS status
FROM predictions
ORDER BY customer_id;

-- è®¡ç®—æ··æ·†çŸ©é˜µ
WITH predictions AS (
    SELECT
        customer_segment AS actual,
        CASE
            WHEN income >= 90000 THEN 'high'
            WHEN income >= 60000 AND credit_score >= 750 THEN 'high'
            WHEN income >= 40000 AND purchase_history >= 20 THEN 'medium'
            WHEN income >= 40000 THEN 'medium'
            ELSE 'low'
        END AS predicted
    FROM customer_data
)
SELECT
    actual,
    predicted,
    COUNT(*) AS count
FROM predictions
GROUP BY actual, predicted
ORDER BY actual, predicted;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    customer_id,
    CASE
        WHEN income >= 90000 THEN 'high'
        WHEN income >= 60000 AND credit_score >= 750 THEN 'high'
        WHEN income >= 40000 AND purchase_history >= 20 THEN 'medium'
        WHEN income >= 40000 THEN 'medium'
        ELSE 'low'
    END AS predicted_segment
FROM customer_data;
```

---

### 5.2 è´·æ¬¾é£é™©è¯„ä¼°

**åœºæ™¯**ï¼šä½¿ç”¨å†³ç­–æ ‘è¯„ä¼°è´·æ¬¾é£é™©ã€‚

```sql
-- è´·æ¬¾é£é™©è¯„ä¼°ï¼šä½¿ç”¨å†³ç­–æ ‘è§„åˆ™è¯„ä¼°è´·æ¬¾é£é™©
WITH loan_applications AS (
    SELECT
        application_id,
        age,
        income,
        credit_score,
        employment_years,
        loan_amount,
        CASE
            WHEN credit_score < 600 THEN 'high_risk'
            WHEN credit_score < 700 AND income < 50000 THEN 'high_risk'
            WHEN credit_score < 700 AND employment_years < 2 THEN 'high_risk'
            WHEN credit_score >= 700 AND income >= 50000 THEN 'low_risk'
            WHEN credit_score >= 650 AND income >= 40000 AND employment_years >= 3 THEN 'medium_risk'
            ELSE 'medium_risk'
        END AS risk_level
    FROM loan_applications_table
)
SELECT
    application_id,
    age,
    income,
    credit_score,
    employment_years,
    loan_amount,
    risk_level,
    -- é£é™©è¯„åˆ†
    CASE
        WHEN risk_level = 'low_risk' THEN 'æ‰¹å‡†'
        WHEN risk_level = 'medium_risk' THEN 'æ¡ä»¶æ‰¹å‡†'
        ELSE 'æ‹’ç»'
    END AS decision
FROM loan_applications
ORDER BY credit_score DESC, income DESC;
```

### 5.3 äº§å“æ¨èå†³ç­–æ ‘

**åœºæ™¯**ï¼šä½¿ç”¨å†³ç­–æ ‘è§„åˆ™è¿›è¡Œäº§å“æ¨èã€‚

```sql
-- äº§å“æ¨èå†³ç­–æ ‘ï¼šæ ¹æ®ç”¨æˆ·ç‰¹å¾æ¨èäº§å“
WITH user_features AS (
    SELECT
        user_id,
        age,
        gender,
        purchase_frequency,
        avg_order_value,
        preferred_category
    FROM users
),
product_recommendations AS (
    SELECT
        uf.user_id,
        uf.age,
        uf.gender,
        uf.purchase_frequency,
        uf.avg_order_value,
        uf.preferred_category,
        -- å†³ç­–æ ‘æ¨èè§„åˆ™
        CASE
            WHEN uf.age < 25 AND uf.purchase_frequency > 10 THEN 'ç”µå­äº§å“'
            WHEN uf.age >= 25 AND uf.age < 40 AND uf.avg_order_value > 500 THEN 'é«˜ç«¯å•†å“'
            WHEN uf.age >= 40 AND uf.preferred_category IS NOT NULL THEN uf.preferred_category
            WHEN uf.gender = 'female' AND uf.purchase_frequency > 5 THEN 'ç¾å¦†æŠ¤è‚¤'
            WHEN uf.gender = 'male' AND uf.purchase_frequency > 5 THEN 'è¿åŠ¨æˆ·å¤–'
            ELSE 'é€šç”¨å•†å“'
        END AS recommended_category
    FROM user_features uf
)
SELECT
    user_id,
    age,
    gender,
    purchase_frequency,
    avg_order_value,
    preferred_category,
    recommended_category,
    -- æ¨èç½®ä¿¡åº¦
    CASE
        WHEN recommended_category = preferred_category THEN 'é«˜ç½®ä¿¡åº¦'
        WHEN purchase_frequency > 10 THEN 'ä¸­ç½®ä¿¡åº¦'
        ELSE 'ä½ç½®ä¿¡åº¦'
    END AS confidence_level
FROM product_recommendations
ORDER BY user_id;
```

### 5.4 åŒ»ç–—è¯Šæ–­å†³ç­–æ ‘

**åœºæ™¯**ï¼šä½¿ç”¨å†³ç­–æ ‘è¾…åŠ©åŒ»ç–—è¯Šæ–­ã€‚

```sql
-- åŒ»ç–—è¯Šæ–­å†³ç­–æ ‘ï¼šæ ¹æ®ç—‡çŠ¶è¯Šæ–­ç–¾ç—…
WITH patient_symptoms AS (
    SELECT
        patient_id,
        fever,
        cough,
        headache,
        fatigue,
        age,
        CASE
            WHEN fever > 38.5 AND cough = true AND age > 60 THEN 'é«˜é£é™©'
            WHEN fever > 38.5 AND cough = true THEN 'ä¸­é£é™©'
            WHEN fever > 37.5 AND (cough = true OR headache = true) THEN 'ä½é£é™©'
            WHEN fatigue = true AND age > 50 THEN 'è§‚å¯Ÿ'
            ELSE 'æ­£å¸¸'
        END AS risk_level
    FROM patient_records
)
SELECT
    patient_id,
    fever,
    cough,
    headache,
    fatigue,
    age,
    risk_level,
    -- å»ºè®®æªæ–½
    CASE
        WHEN risk_level = 'é«˜é£é™©' THEN 'ç«‹å³å°±åŒ»'
        WHEN risk_level = 'ä¸­é£é™©' THEN 'å»ºè®®å°±åŒ»'
        WHEN risk_level = 'ä½é£é™©' THEN 'è§‚å¯Ÿç—‡çŠ¶'
        WHEN risk_level = 'è§‚å¯Ÿ' THEN 'æ³¨æ„ä¼‘æ¯'
        ELSE 'æ­£å¸¸ç”Ÿæ´»'
    END AS recommendation
FROM patient_symptoms
ORDER BY
    CASE risk_level
        WHEN 'é«˜é£é™©' THEN 1
        WHEN 'ä¸­é£é™©' THEN 2
        WHEN 'ä½é£é™©' THEN 3
        WHEN 'è§‚å¯Ÿ' THEN 4
        ELSE 5
    END;
```

---

## 6. PostgreSQL 18å¹¶è¡Œå†³ç­–æ ‘

### 6.1 å¹¶è¡Œå†³ç­–æ ‘æ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œå†³ç­–æ ‘**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡å†³ç­–æ ‘è®¡ç®—çš„æ€§èƒ½ã€‚

#### å¹¶è¡Œå†³ç­–æ ‘é…ç½®

```sql
-- é…ç½®å¹¶è¡Œå†³ç­–æ ‘å‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œå†³ç­–æ ‘å‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå†³ç­–æ ‘é…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œå†³ç­–æ ‘å®ç°

```sql
-- å¹¶è¡Œä¿¡æ¯å¢ç›Šè®¡ç®—ï¼šå¤§è§„æ¨¡æ•°æ®ç‰¹å¾é€‰æ‹©ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œå†³ç­–æ ‘è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå†³ç­–æ ‘å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œä¿¡æ¯å¢ç›Šè®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_class_distribution AS (
    SELECT
        feature_value,
        class_label,
        COUNT(*) AS class_count
    FROM training_data
    GROUP BY feature_value, class_label
),
parallel_feature_stats AS (
    SELECT
        feature_value,
        SUM(class_count) AS feature_count,
        COUNT(DISTINCT class_label) AS class_variety
    FROM parallel_class_distribution
    GROUP BY feature_value
)
SELECT
    feature_value,
    feature_count,
    class_variety,
    -- ä¿¡æ¯å¢ç›Šè®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
    -SUM((class_count::numeric / SUM(class_count) OVER ()) *
         LOG(2, NULLIF(class_count::numeric / SUM(class_count) OVER (), 0))) AS entropy
FROM parallel_class_distribution
GROUP BY feature_value, feature_count, class_variety
ORDER BY entropy DESC;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 7.1 å†³ç­–æ ‘ç®—æ³•å¯¹æ¯”

| ç®—æ³• | åˆ†å‰²å‡†åˆ™ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|---------|------|------|
| **ID3** | ä¿¡æ¯å¢ç›Š | åˆ†ç±»é—®é¢˜ | ç®€å•ç›´è§‚ | åå‘å¤šå€¼ç‰¹å¾ |
| **C4.5** | ä¿¡æ¯å¢ç›Šç‡ | åˆ†ç±»é—®é¢˜ | å¤„ç†è¿ç»­å€¼ | è®¡ç®—å¤æ‚ |
| **CART** | åŸºå°¼ä¸çº¯åº¦ | åˆ†ç±»/å›å½’ | å¤„ç†å›å½’ | äºŒå‰æ ‘ç»“æ„ |
| **CHAID** | å¡æ–¹æ£€éªŒ | åˆ†ç±»é—®é¢˜ | å¤šè·¯åˆ†å‰² | éœ€è¦å¤§æ ·æœ¬ |

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è®¡ç®—ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨çª—å£å‡½æ•°å‡å°‘é‡å¤è®¡ç®—
   - ç¼“å­˜ç†µå€¼è®¡ç®—ç»“æœ
   - å¹¶è¡Œå¤„ç†ç‰¹å¾

2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - åˆ›å»ºç‰¹å¾ç´¢å¼•
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾
   - é™åˆ¶æ•°æ®èŒƒå›´

3. **ç®—æ³•ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨å‰ªæç­–ç•¥
   - ç‰¹å¾é€‰æ‹©
   - å¢é‡å­¦ä¹ 

### 7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šè¿‡æ‹Ÿåˆ

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å‰ªæã€é™åˆ¶æ ‘æ·±åº¦ã€å¢åŠ æœ€å°æ ·æœ¬æ•°

**é—®é¢˜2**ï¼šä¿¡æ¯å¢ç›Šåå‘å¤šå€¼ç‰¹å¾

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ä¿¡æ¯å¢ç›Šç‡ã€ä½¿ç”¨åŸºå°¼ä¸çº¯åº¦

**é—®é¢˜3**ï¼šè®¡ç®—æ€§èƒ½é—®é¢˜

- **è§£å†³æ–¹æ¡ˆ**ï¼šä¼˜åŒ–SQLæŸ¥è¯¢ã€ä½¿ç”¨ç´¢å¼•ã€é‡‡æ ·è®¡ç®—

**é—®é¢˜4**ï¼šè¿ç»­ç‰¹å¾å¤„ç†

- **è§£å†³æ–¹æ¡ˆ**ï¼šç¦»æ•£åŒ–ã€ä½¿ç”¨CARTç®—æ³•ã€ä½¿ç”¨åˆ†ä½æ•°åˆ†å‰²

---

## 8. æœ€ä½³å®è·µ

### 8.1 å†³ç­–æ ‘æ„å»ºæµç¨‹

1. **æ•°æ®å‡†å¤‡**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼
   - ç‰¹å¾ç¼–ç 
   - æ•°æ®æ¸…æ´—

2. **ç‰¹å¾é€‰æ‹©**ï¼š
   - è®¡ç®—ä¿¡æ¯å¢ç›Š
   - é€‰æ‹©é‡è¦ç‰¹å¾
   - ç‰¹å¾å·¥ç¨‹

3. **æ ‘æ„å»º**ï¼š
   - é€‰æ‹©åˆ†å‰²å‡†åˆ™
   - é€’å½’æ„å»º
   - è®¾ç½®åœæ­¢æ¡ä»¶

4. **æ¨¡å‹è¯„ä¼°**ï¼š
   - è®¡ç®—å‡†ç¡®ç‡
   - äº¤å‰éªŒè¯
   - æ··æ·†çŸ©é˜µ

### 8.2 å†³ç­–æ ‘æ³¨æ„äº‹é¡¹

1. **è¿‡æ‹Ÿåˆ**ï¼š
   - ä½¿ç”¨å‰ªæ
   - é™åˆ¶æ ‘æ·±åº¦
   - å¢åŠ æœ€å°æ ·æœ¬æ•°

2. **ç‰¹å¾é€‰æ‹©**ï¼š
   - é¿å…åå‘å¤šå€¼ç‰¹å¾
   - è€ƒè™‘ç‰¹å¾é‡è¦æ€§
   - ç‰¹å¾å·¥ç¨‹

3. **æ•°æ®è´¨é‡**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼
   - å»é™¤å¼‚å¸¸å€¼
   - æ•°æ®å¹³è¡¡

### 8.3 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼š
   - ä¼˜åŒ–èšåˆæŸ¥è¯¢
   - åˆ›å»ºç‰¹å¾ç´¢å¼•
   - ä½¿ç”¨çª—å£å‡½æ•°

2. **å‡†ç¡®æ€§**ï¼š
   - å¤„ç†NULLå€¼
   - é¿å…æ•°å€¼ç²¾åº¦é—®é¢˜
   - éªŒè¯è®¡ç®—ç»“æœ

3. **å¯ç»´æŠ¤æ€§**ï¼š
   - ä½¿ç”¨æ¸…æ™°çš„å˜é‡å
   - æ·»åŠ æ³¨é‡Š
   - æ¨¡å—åŒ–è®¾è®¡

### 8.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡å†³ç­–æ ‘ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«ç‰¹å¾å€¼çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºç‰¹å¾é€‰æ‹©å’Œåˆ†å‰²ç‚¹æŸ¥æ‰¾

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡å†³ç­–æ ‘è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºä¿¡æ¯å¢ç›Šè®¡ç®—å’Œæ‰¹é‡é¢„æµ‹

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - å†³ç­–æ ‘ä¿¡æ¯å¢ç›Šè®¡ç®—æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œ
   - é€‚ç”¨äºå¤§è§„æ¨¡ç‰¹å¾é€‰æ‹©å’Œæ ‘æ„å»º

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–ç‰¹å¾é€‰æ‹©æŸ¥è¯¢**

```sql
-- ä¸ºå†³ç­–æ ‘ç‰¹å¾åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_decision_tree_features_skip_scan
ON classification_data USING btree(feature1 DESC, label);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾ä¿¡æ¯å¢ç›Šæœ€é«˜çš„ç‰¹å¾åˆ†å‰²ç‚¹
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH feature_splits AS (
    SELECT DISTINCT
        feature1 AS split_value,
        COUNT(*) FILTER (WHERE label = 1) AS positive_count,
        COUNT(*) FILTER (WHERE label = 0) AS negative_count
    FROM classification_data
    WHERE feature1 IS NOT NULL
    GROUP BY feature1
)
SELECT
    split_value,
    positive_count,
    negative_count,
    ROUND((positive_count::numeric / NULLIF(positive_count + negative_count, 0))::numeric, 4) AS positive_ratio
FROM feature_splits
ORDER BY ABS(positive_ratio - 0.5) ASC  -- é€‰æ‹©æœ€æ¥è¿‘0.5çš„åˆ†å‰²ç‚¹
LIMIT 10;
```

### 8.5 é«˜çº§ä¼˜åŒ–æŠ€å·§

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å†³ç­–æ ‘æ¨¡å‹**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„å†³ç­–æ ‘æ¨¡å‹ï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜å†³ç­–æ ‘èŠ‚ç‚¹ä¿¡æ¯
CREATE MATERIALIZED VIEW IF NOT EXISTS decision_tree_nodes_cache AS
WITH tree_nodes AS (
    SELECT
        node_id,
        feature_name,
        split_value,
        parent_node_id,
        COUNT(*) FILTER (WHERE label = 1) AS positive_samples,
        COUNT(*) FILTER (WHERE label = 0) AS negative_samples,
        COUNT(*) AS total_samples
    FROM decision_tree_data
    GROUP BY node_id, feature_name, split_value, parent_node_id
)
SELECT
    node_id,
    feature_name,
    split_value,
    parent_node_id,
    positive_samples,
    negative_samples,
    total_samples,
    -- è®¡ç®—èŠ‚ç‚¹çº¯åº¦ï¼ˆGiniä¸çº¯åº¦ï¼‰
    1 - POWER(positive_samples::numeric / NULLIF(total_samples, 0), 2) -
        POWER(negative_samples::numeric / NULLIF(total_samples, 0), 2) AS gini_impurity
FROM tree_nodes;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_decision_tree_nodes_cache_parent ON decision_tree_nodes_cache(parent_node_id);
CREATE INDEX idx_decision_tree_nodes_cache_feature ON decision_tree_nodes_cache(feature_name, split_value);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY decision_tree_nodes_cache;
```

**2. å†³ç­–æ ‘é¢„æµ‹ï¼šæ‰¹é‡é¢„æµ‹ä¼˜åŒ–**

ä½¿ç”¨é€’å½’CTEä¼˜åŒ–å†³ç­–æ ‘é¢„æµ‹ï¼š

```sql
-- å†³ç­–æ ‘é¢„æµ‹ï¼šæ‰¹é‡é¢„æµ‹ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'decision_tree_model') THEN
            CREATE TABLE decision_tree_model (
                node_id INTEGER PRIMARY KEY,
                feature_name VARCHAR(50),
                split_value NUMERIC,
                parent_node_id INTEGER,
                is_leaf BOOLEAN DEFAULT false,
                predicted_label INTEGER,
                FOREIGN KEY (parent_node_id) REFERENCES decision_tree_model(node_id)
            );

            CREATE INDEX idx_decision_tree_model_parent ON decision_tree_model(parent_node_id);
            CREATE INDEX idx_decision_tree_model_feature ON decision_tree_model(feature_name, split_value);

            RAISE NOTICE 'å†³ç­–æ ‘æ¨¡å‹è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå†³ç­–æ ‘æ‰¹é‡é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å†³ç­–æ ‘é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å†³ç­–æ ‘é¢„æµ‹ï¼šä½¿ç”¨é€’å½’CTEéå†å†³ç­–æ ‘
WITH RECURSIVE tree_traversal AS (
    -- èµ·å§‹ï¼šä»æ ¹èŠ‚ç‚¹å¼€å§‹
    SELECT
        cd.sample_id,
        cd.feature1,
        cd.feature2,
        dtm.node_id AS current_node,
        dtm.feature_name,
        dtm.split_value,
        dtm.is_leaf,
        dtm.predicted_label,
        ARRAY[dtm.node_id] AS path
    FROM classification_data cd
    CROSS JOIN decision_tree_model dtm
    WHERE dtm.parent_node_id IS NULL  -- æ ¹èŠ‚ç‚¹

    UNION ALL

    -- é€’å½’ï¼šæ ¹æ®ç‰¹å¾å€¼é€‰æ‹©å­èŠ‚ç‚¹
    SELECT
        tt.sample_id,
        tt.feature1,
        tt.feature2,
        dtm.node_id AS current_node,
        dtm.feature_name,
        dtm.split_value,
        dtm.is_leaf,
        dtm.predicted_label,
        tt.path || dtm.node_id
    FROM tree_traversal tt
    JOIN decision_tree_model dtm ON dtm.parent_node_id = tt.current_node
    WHERE NOT dtm.node_id = ANY(tt.path)  -- é¿å…å¾ªç¯
      AND (
          (dtm.feature_name = 'feature1' AND
           CASE WHEN dtm.split_value IS NOT NULL THEN
               CASE WHEN tt.feature1 <= dtm.split_value THEN true ELSE false END
           ELSE true END)
          OR
          (dtm.feature_name = 'feature2' AND
           CASE WHEN dtm.split_value IS NOT NULL THEN
               CASE WHEN tt.feature2 <= dtm.split_value THEN true ELSE false END
           ELSE true END)
      )
)
SELECT DISTINCT ON (sample_id)
    sample_id,
    feature1,
    feature2,
    current_node AS final_node,
    predicted_label,
    path AS decision_path
FROM tree_traversal
WHERE is_leaf = true
ORDER BY sample_id, array_length(path, 1) DESC;
```

**3. éšæœºæ£®æ—ï¼šé›†æˆå†³ç­–æ ‘é¢„æµ‹**

**éšæœºæ£®æ—**ï¼šä½¿ç”¨å¤šä¸ªå†³ç­–æ ‘çš„é›†æˆé¢„æµ‹ã€‚

```sql
-- éšæœºæ£®æ—ï¼šé›†æˆå†³ç­–æ ‘é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'random_forest_trees') THEN
            CREATE TABLE random_forest_trees (
                tree_id INTEGER NOT NULL,
                node_id INTEGER NOT NULL,
                feature_name VARCHAR(50),
                split_value NUMERIC,
                parent_node_id INTEGER,
                is_leaf BOOLEAN DEFAULT false,
                predicted_label INTEGER,
                PRIMARY KEY (tree_id, node_id)
            );

            CREATE INDEX idx_rf_trees_tree_node ON random_forest_trees(tree_id, parent_node_id);

            RAISE NOTICE 'éšæœºæ£®æ—æ ‘è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œéšæœºæ£®æ—é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'éšæœºæ£®æ—é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- éšæœºæ£®æ—é¢„æµ‹ï¼šé›†æˆå¤šä¸ªå†³ç­–æ ‘çš„é¢„æµ‹ç»“æœ
WITH tree_predictions AS (
    SELECT
        cd.sample_id,
        rft.tree_id,
        rft.predicted_label,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ¯ä¸ªæ ‘çš„é¢„æµ‹ï¼ˆç®€åŒ–ç‰ˆï¼‰
        ROW_NUMBER() OVER (PARTITION BY cd.sample_id, rft.tree_id ORDER BY rft.node_id) AS tree_prediction_rank
    FROM classification_data cd
    CROSS JOIN random_forest_trees rft
    WHERE rft.is_leaf = true
      AND rft.tree_id IN (SELECT DISTINCT tree_id FROM random_forest_trees LIMIT 10)  -- ä½¿ç”¨10æ£µæ ‘
),
forest_votes AS (
    SELECT
        sample_id,
        predicted_label,
        COUNT(*) AS vote_count,
        COUNT(*)::numeric / (SELECT COUNT(DISTINCT tree_id) FROM random_forest_trees LIMIT 10) AS vote_ratio
    FROM tree_predictions
    WHERE tree_prediction_rank = 1
    GROUP BY sample_id, predicted_label
),
forest_predictions AS (
    SELECT DISTINCT ON (sample_id)
        sample_id,
        predicted_label AS forest_predicted_label,
        vote_count,
        ROUND(vote_ratio::numeric, 4) AS confidence
    FROM forest_votes
    ORDER BY sample_id, vote_count DESC
)
SELECT
    sample_id,
    forest_predicted_label,
    vote_count,
    confidence
FROM forest_predictions
ORDER BY sample_id;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **ã€Šæœºå™¨å­¦ä¹ ã€‹**ï¼ˆMitchell, T. M., 1997ï¼‰- å†³ç­–æ ‘ç†è®º

2. **ã€Šæ•°æ®æŒ–æ˜ï¼šæ¦‚å¿µä¸æŠ€æœ¯ã€‹**ï¼ˆHan, J., et al., 2011ï¼‰- å†³ç­–æ ‘ç®—æ³•

3. **ã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹**ï¼ˆæèˆª, 2012ï¼‰- å†³ç­–æ ‘æ–¹æ³•

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- **èšåˆå‡½æ•°**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **çª—å£å‡½æ•°**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **æ•°ç»„å‡½æ•°**: <https://www.postgresql.org/docs/current/functions-array.html>

### åœ¨çº¿èµ„æº

- **å†³ç­–æ ‘**: <https://en.wikipedia.org/wiki/Decision_tree>
- **ID3ç®—æ³•**: <https://en.wikipedia.org/wiki/ID3_algorithm>
- **C4.5ç®—æ³•**: <https://en.wikipedia.org/wiki/C4.5_algorithm>

### ç›¸å…³ç®—æ³•

- **åˆ†ç±»ç®—æ³•**ï¼šå†³ç­–æ ‘åˆ†ç±»
- **éšæœºæ£®æ—**ï¼šåŸºäºå†³ç­–æ ‘çš„é›†æˆæ–¹æ³•
- **æ¢¯åº¦æå‡æ ‘**ï¼šåŸºäºå†³ç­–æ ‘çš„æå‡æ–¹æ³•
- **ç‰¹å¾é€‰æ‹©ç®—æ³•**ï¼šä¿¡æ¯å¢ç›Šç‰¹å¾é€‰æ‹©

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
