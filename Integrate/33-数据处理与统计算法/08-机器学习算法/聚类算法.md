# PostgreSQL æœºå™¨å­¦ä¹ èšç±»ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | èšç±»ç®—æ³• | æ— ç›‘ç£å­¦ä¹ 
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æœºå™¨å­¦ä¹ èšç±»ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æœºå™¨å­¦ä¹ èšç±»ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [èšç±»ç®—æ³•æ¦‚è¿°](#èšç±»ç®—æ³•æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [èšç±»å®šä¹‰](#èšç±»å®šä¹‰)
      - [èšç±»ç›®æ ‡](#èšç±»ç›®æ ‡)
      - [èšç±»ç®—æ³•åˆ†ç±»](#èšç±»ç®—æ³•åˆ†ç±»)
      - [è·ç¦»åº¦é‡](#è·ç¦»åº¦é‡)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. K-meansèšç±»](#1-k-meansèšç±»)
    - [1.1 K-meansåŸç†](#11-k-meansåŸç†)
      - [K-meansç®—æ³•æ­¥éª¤](#k-meansç®—æ³•æ­¥éª¤)
      - [K-meansæ•°å­¦å®šä¹‰](#k-meansæ•°å­¦å®šä¹‰)
      - [K-meansä¼˜ç¼ºç‚¹](#k-meansä¼˜ç¼ºç‚¹)
    - [1.2 è¿­ä»£K-meanså®ç°](#12-è¿­ä»£k-meanså®ç°)
    - [1.3 K-means++åˆå§‹åŒ–](#13-k-meansåˆå§‹åŒ–)
    - [1.4 å¤šè¿­ä»£K-means](#14-å¤šè¿­ä»£k-means)
  - [2. DBSCANèšç±»](#2-dbscanèšç±»)
    - [2.1 DBSCANåŸç†](#21-dbscanåŸç†)
      - [DBSCANæ ¸å¿ƒæ¦‚å¿µ](#dbscanæ ¸å¿ƒæ¦‚å¿µ)
      - [DBSCANç®—æ³•æ­¥éª¤](#dbscanç®—æ³•æ­¥éª¤)
      - [DBSCANå‚æ•°](#dbscanå‚æ•°)
    - [2.2 å¯†åº¦èšç±»å®ç°](#22-å¯†åº¦èšç±»å®ç°)
    - [2.3 DBSCANç°‡æ‰©å±•](#23-dbscanç°‡æ‰©å±•)
  - [3. èšç±»è¯„ä¼°](#3-èšç±»è¯„ä¼°)
    - [3.1 èšç±»è¯„ä¼°åŸç†](#31-èšç±»è¯„ä¼°åŸç†)
      - [å†…éƒ¨è¯„ä¼°æŒ‡æ ‡](#å†…éƒ¨è¯„ä¼°æŒ‡æ ‡)
      - [å¤–éƒ¨è¯„ä¼°æŒ‡æ ‡](#å¤–éƒ¨è¯„ä¼°æŒ‡æ ‡)
    - [3.2 è½®å»“ç³»æ•°å®ç°](#32-è½®å»“ç³»æ•°å®ç°)
    - [3.2 è‚˜éƒ¨æ³•åˆ™](#32-è‚˜éƒ¨æ³•åˆ™)
    - [3.3 WCSSå’ŒBCSSè®¡ç®—](#33-wcsså’Œbcssè®¡ç®—)
  - [4. å±‚æ¬¡èšç±»](#4-å±‚æ¬¡èšç±»)
    - [4.1 å±‚æ¬¡èšç±»åŸç†](#41-å±‚æ¬¡èšç±»åŸç†)
      - [å±‚æ¬¡èšç±»ç±»å‹](#å±‚æ¬¡èšç±»ç±»å‹)
      - [é“¾æ¥å‡†åˆ™](#é“¾æ¥å‡†åˆ™)
    - [4.2 å±‚æ¬¡èšç±»å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰](#42-å±‚æ¬¡èšç±»å®ç°ç®€åŒ–ç‰ˆ)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 å®¢æˆ·ç»†åˆ†](#51-å®¢æˆ·ç»†åˆ†)
    - [5.2 ç”¨æˆ·è¡Œä¸ºèšç±»](#52-ç”¨æˆ·è¡Œä¸ºèšç±»)
    - [5.3 äº§å“èšç±»åˆ†æ](#53-äº§å“èšç±»åˆ†æ)
    - [5.4 å¼‚å¸¸æ£€æµ‹èšç±»](#54-å¼‚å¸¸æ£€æµ‹èšç±»)
  - [6. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#6-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [6.1 èšç±»ç®—æ³•å¯¹æ¯”](#61-èšç±»ç®—æ³•å¯¹æ¯”)
    - [6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#62-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#63-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 èšç±»æµç¨‹](#71-èšç±»æµç¨‹)
    - [7.2 èšç±»æ³¨æ„äº‹é¡¹](#72-èšç±»æ³¨æ„äº‹é¡¹)
    - [7.3 SQLå®ç°æ³¨æ„äº‹é¡¹](#73-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [7.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨](#74-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨)
    - [7.5 é«˜çº§ä¼˜åŒ–æŠ€å·§](#75-é«˜çº§ä¼˜åŒ–æŠ€å·§)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## èšç±»ç®—æ³•æ¦‚è¿°

**èšç±»ç®—æ³•ï¼ˆClustering Algorithmï¼‰**æ˜¯æ— ç›‘ç£å­¦ä¹ çš„æ ¸å¿ƒæ–¹æ³•ï¼Œç”¨äºå‘ç°æ•°æ®ä¸­çš„éšè—æ¨¡å¼å’Œåˆ†ç»„ã€‚èšç±»å°†ç›¸ä¼¼çš„æ•°æ®ç‚¹å½’ä¸ºä¸€ç±»ï¼Œä¸åŒç±»çš„æ•°æ®ç‚¹å°½å¯èƒ½ä¸åŒã€‚

### ç†è®ºåŸºç¡€

#### èšç±»å®šä¹‰

**èšç±»ï¼ˆClusteringï¼‰**æ˜¯å°†æ•°æ®å¯¹è±¡åˆ†æˆå¤šä¸ªç»„ï¼ˆç°‡ï¼‰çš„è¿‡ç¨‹ï¼Œä½¿å¾—ï¼š

- **ç°‡å†…ç›¸ä¼¼åº¦é«˜**ï¼šåŒä¸€ç°‡å†…çš„å¯¹è±¡å°½å¯èƒ½ç›¸ä¼¼
- **ç°‡é—´ç›¸ä¼¼åº¦ä½**ï¼šä¸åŒç°‡çš„å¯¹è±¡å°½å¯èƒ½ä¸åŒ

#### èšç±»ç›®æ ‡

**èšç±»ç›®æ ‡å‡½æ•°**ï¼ˆä»¥K-meansä¸ºä¾‹ï¼‰ï¼š
$$J = \sum_{i=1}^{k}\sum_{x \in C_i}||x - \mu_i||^2$$

å…¶ä¸­ï¼š

- $k$ï¼šç°‡çš„æ•°é‡
- $C_i$ï¼šç¬¬$i$ä¸ªç°‡
- $\mu_i$ï¼šç¬¬$i$ä¸ªç°‡çš„ä¸­å¿ƒ
- $||x - \mu_i||^2$ï¼šæ•°æ®ç‚¹åˆ°ç°‡ä¸­å¿ƒçš„è·ç¦»å¹³æ–¹

#### èšç±»ç®—æ³•åˆ†ç±»

1. **åŸºäºåˆ’åˆ†çš„èšç±»**ï¼š
   - K-means
   - K-medoids
   - K-means++

2. **åŸºäºå¯†åº¦çš„èšç±»**ï¼š
   - DBSCAN
   - OPTICS
   - Mean Shift

3. **åŸºäºå±‚æ¬¡çš„èšç±»**ï¼š
   - å‡èšèšç±»ï¼ˆAgglomerativeï¼‰
   - åˆ†è£‚èšç±»ï¼ˆDivisiveï¼‰

4. **åŸºäºæ¨¡å‹çš„èšç±»**ï¼š
   - é«˜æ–¯æ··åˆæ¨¡å‹ï¼ˆGMMï¼‰
   - æœŸæœ›æœ€å¤§åŒ–ï¼ˆEMï¼‰

#### è·ç¦»åº¦é‡

**æ¬§æ°è·ç¦»**ï¼š
$$d(x, y) = \sqrt{\sum_{i=1}^{n}(x_i - y_i)^2}$$

**æ›¼å“ˆé¡¿è·ç¦»**ï¼š
$$d(x, y) = \sum_{i=1}^{n}|x_i - y_i|$$

**ä½™å¼¦è·ç¦»**ï¼š
$$d(x, y) = 1 - \frac{x \cdot y}{||x|| \cdot ||y||}$$

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ | æ•°å­¦è¡¨ç¤º |
|------|------|--------|---------|
| **K-means** | åŸºäºä¸­å¿ƒçš„èšç±» | $O(nki)$ | $J = \sum_{i=1}^{k}\sum_{x \in C_i}||x - \mu_i||^2$ |
| **DBSCAN** | åŸºäºå¯†åº¦çš„èšç±» | $O(n \log n)$ | å¯†åº¦å¯è¾¾æ€§ |
| **å±‚æ¬¡èšç±»** | æ ‘çŠ¶èšç±» | $O(n^2)$ | é“¾æ¥å‡†åˆ™ |

---

## 1. K-meansèšç±»

### 1.1 K-meansåŸç†

**K-meansèšç±»ï¼ˆK-means Clusteringï¼‰**æ˜¯æœ€å¸¸ç”¨çš„èšç±»ç®—æ³•ï¼Œé€šè¿‡è¿­ä»£ä¼˜åŒ–èšç±»ä¸­å¿ƒæ¥æœ€å°åŒ–ç°‡å†…å¹³æ–¹å’Œï¼ˆWCSSï¼‰ã€‚

#### K-meansç®—æ³•æ­¥éª¤

1. **åˆå§‹åŒ–**ï¼šéšæœºé€‰æ‹©$k$ä¸ªåˆå§‹èšç±»ä¸­å¿ƒ
2. **åˆ†é…**ï¼šå°†æ¯ä¸ªæ•°æ®ç‚¹åˆ†é…åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
3. **æ›´æ–°**ï¼šé‡æ–°è®¡ç®—æ¯ä¸ªç°‡çš„èšç±»ä¸­å¿ƒ
4. **è¿­ä»£**ï¼šé‡å¤æ­¥éª¤2-3ç›´åˆ°æ”¶æ•›

#### K-meansæ•°å­¦å®šä¹‰

**ç›®æ ‡å‡½æ•°**ï¼š
$$J = \sum_{i=1}^{k}\sum_{x \in C_i}||x - \mu_i||^2$$

**èšç±»ä¸­å¿ƒæ›´æ–°**ï¼š
$$\mu_i = \frac{1}{|C_i|}\sum_{x \in C_i}x$$

#### K-meansä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**ï¼š

- ç®€å•é«˜æ•ˆ
- é€‚ç”¨äºçƒå½¢ç°‡
- å¯æ‰©å±•æ€§å¼º

**ç¼ºç‚¹**ï¼š

- éœ€è¦é¢„å…ˆæŒ‡å®š$k$
- å¯¹åˆå§‹å€¼æ•æ„Ÿ
- åªèƒ½å¤„ç†çƒå½¢ç°‡

### 1.2 è¿­ä»£K-meanså®ç°

```sql
-- åˆ›å»ºèšç±»æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE cluster_data CASCADE;
        END IF;

        CREATE TABLE cluster_data (
            id SERIAL PRIMARY KEY,
            x NUMERIC NOT NULL,
            y NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®ï¼ˆ3ä¸ªç°‡ï¼‰
        INSERT INTO cluster_data (x, y) VALUES
            -- ç°‡1
            (2, 3), (2.5, 3.5), (3, 4), (2.2, 3.2), (2.8, 3.8),
            -- ç°‡2
            (8, 9), (8.5, 9.5), (9, 10), (8.2, 9.2), (8.8, 9.8),
            -- ç°‡3
            (5, 2), (5.5, 2.5), (6, 3), (5.2, 2.2), (5.8, 2.8);

        RAISE NOTICE 'è¡¨ cluster_data åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥15æ¡æ•°æ®';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ cluster_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- K-meansè¿­ä»£å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    k INTEGER := 3;
    max_iterations INTEGER := 10;
    iteration INTEGER := 0;
    converged BOOLEAN := false;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒK-meansèšç±»';
            RETURN;
        END IF;

        -- åˆ›å»ºä¸´æ—¶è¡¨å­˜å‚¨èšç±»ä¸­å¿ƒ
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_centers') THEN
            DROP TABLE cluster_centers CASCADE;
        END IF;

        -- åˆå§‹åŒ–èšç±»ä¸­å¿ƒï¼ˆéšæœºé€‰æ‹©kä¸ªç‚¹ï¼‰
        CREATE TEMP TABLE cluster_centers AS
        SELECT
            ROW_NUMBER() OVER () AS cluster_id,
            x AS center_x,
            y AS center_y
        FROM (
            SELECT x, y FROM cluster_data ORDER BY RANDOM() LIMIT k
        ) t;

        RAISE NOTICE 'K-meansèšç±»å¼€å§‹ï¼Œk=%, æœ€å¤§è¿­ä»£æ¬¡æ•°=%', k, max_iterations;

        -- è¿­ä»£ä¼˜åŒ–ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…éœ€è¦å¾ªç¯ï¼‰
        RAISE NOTICE 'è¿­ä»£å®Œæˆï¼ˆç®€åŒ–å®ç°ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'K-meansèšç±»å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- K-meansèšç±»ï¼ˆä½¿ç”¨çª—å£å‡½æ•°å®ç°ï¼‰
WITH initial_centers AS (
    SELECT
        ROW_NUMBER() OVER () AS cluster_id,
        x AS center_x,
        y AS center_y
    FROM (
        SELECT x, y FROM cluster_data ORDER BY RANDOM() LIMIT 3
    ) t
),
distances AS (
    SELECT
        d.id,
        d.x,
        d.y,
        c.cluster_id,
        SQRT(POWER(d.x - c.center_x, 2) + POWER(d.y - c.center_y, 2)) AS distance
    FROM cluster_data d
    CROSS JOIN initial_centers c
),
closest_clusters AS (
    SELECT
        id,
        x,
        y,
        cluster_id,
        ROW_NUMBER() OVER (PARTITION BY id ORDER BY distance) AS rn
    FROM distances
),
assignments AS (
    SELECT
        id,
        x,
        y,
        cluster_id
    FROM closest_clusters
    WHERE rn = 1
),
new_centers AS (
    SELECT
        cluster_id,
        AVG(x) AS center_x,
        AVG(y) AS center_y,
        COUNT(*) AS cluster_size
    FROM assignments
    GROUP BY cluster_id
)
SELECT
    a.id,
    a.x,
    a.y,
    a.cluster_id,
    nc.center_x,
    nc.center_y,
    nc.cluster_size
FROM assignments a
JOIN new_centers nc ON a.cluster_id = nc.cluster_id
ORDER BY a.cluster_id, a.id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH initial_centers AS (
    SELECT ROW_NUMBER() OVER () AS cluster_id, x AS center_x, y AS center_y
    FROM (SELECT x, y FROM cluster_data ORDER BY RANDOM() LIMIT 3) t
)
SELECT
    d.id,
    c.cluster_id,
    SQRT(POWER(d.x - c.center_x, 2) + POWER(d.y - c.center_y, 2)) AS distance
FROM cluster_data d
CROSS JOIN initial_centers c
LIMIT 100;
```

---

### 1.3 K-means++åˆå§‹åŒ–

**K-means++**æ”¹è¿›åˆå§‹åŒ–æ–¹æ³•ï¼Œé€‰æ‹©æ›´åˆ†æ•£çš„åˆå§‹ä¸­å¿ƒã€‚

```sql
-- K-means++åˆå§‹åŒ–ï¼šé€‰æ‹©æ›´åˆ†æ•£çš„åˆå§‹ä¸­å¿ƒ
WITH first_center AS (
    SELECT id, x, y
    FROM cluster_data
    ORDER BY RANDOM()
    LIMIT 1
),
distance_to_first AS (
    SELECT
        d.id,
        d.x,
        d.y,
        SQRT(POWER(d.x - fc.x, 2) + POWER(d.y - fc.y, 2)) AS distance
    FROM cluster_data d
    CROSS JOIN first_center fc
),
second_center AS (
    SELECT id, x, y
    FROM distance_to_first
    ORDER BY distance DESC
    LIMIT 1
),
distance_to_centers AS (
    SELECT
        d.id,
        d.x,
        d.y,
        LEAST(
            SQRT(POWER(d.x - fc.x, 2) + POWER(d.y - fc.y, 2)),
            SQRT(POWER(d.x - sc.x, 2) + POWER(d.y - sc.y, 2))
        ) AS min_distance
    FROM cluster_data d
    CROSS JOIN first_center fc
    CROSS JOIN second_center sc
),
third_center AS (
    SELECT id, x, y
    FROM distance_to_centers
    ORDER BY min_distance DESC
    LIMIT 1
)
SELECT
    ROW_NUMBER() OVER () AS cluster_id,
    x AS center_x,
    y AS center_y
FROM (
    SELECT x, y FROM first_center
    UNION ALL
    SELECT x, y FROM second_center
    UNION ALL
    SELECT x, y FROM third_center
) centers;
```

### 1.4 å¤šè¿­ä»£K-means

**å¤šè¿­ä»£**å®ç°å®Œæ•´çš„K-meansè¿­ä»£è¿‡ç¨‹ã€‚

```sql
-- å¤šè¿­ä»£K-meansï¼šå®ç°å®Œæ•´çš„è¿­ä»£è¿‡ç¨‹
WITH RECURSIVE kmeans_iterations AS (
    -- åˆå§‹ä¸­å¿ƒ
    SELECT
        0 AS iteration,
        ROW_NUMBER() OVER () AS cluster_id,
        x AS center_x,
        y AS center_y
    FROM (
        SELECT x, y FROM cluster_data ORDER BY RANDOM() LIMIT 3
    ) initial_centers

    UNION ALL

    -- è¿­ä»£æ›´æ–°
    SELECT
        ki.iteration + 1,
        nc.cluster_id,
        nc.center_x,
        nc.center_y
    FROM kmeans_iterations ki
    JOIN (
        SELECT
            cluster_id,
            AVG(x) AS center_x,
            AVG(y) AS center_y
        FROM (
            SELECT
                d.id,
                d.x,
                d.y,
                c.cluster_id,
                ROW_NUMBER() OVER (PARTITION BY d.id ORDER BY
                    SQRT(POWER(d.x - c.center_x, 2) + POWER(d.y - c.center_y, 2))
                ) AS rn
            FROM cluster_data d
            CROSS JOIN kmeans_iterations c
            WHERE c.iteration = (SELECT MAX(iteration) FROM kmeans_iterations)
        ) assignments
        WHERE rn = 1
        GROUP BY cluster_id
    ) nc ON ki.cluster_id = nc.cluster_id
    WHERE ki.iteration < 10  -- æœ€å¤§è¿­ä»£æ¬¡æ•°
)
SELECT * FROM kmeans_iterations WHERE iteration = (SELECT MAX(iteration) FROM kmeans_iterations);
```

---

## 2. DBSCANèšç±»

### 2.1 DBSCANåŸç†

**DBSCANï¼ˆDensity-Based Spatial Clustering of Applications with Noiseï¼‰**åŸºäºå¯†åº¦çš„èšç±»ç®—æ³•ï¼Œå¯ä»¥å‘ç°ä»»æ„å½¢çŠ¶çš„ç°‡ï¼Œå¹¶è¯†åˆ«å™ªå£°ç‚¹ã€‚

#### DBSCANæ ¸å¿ƒæ¦‚å¿µ

1. **æ ¸å¿ƒç‚¹ï¼ˆCore Pointï¼‰**ï¼šé‚»åŸŸå†…è‡³å°‘æœ‰$minPts$ä¸ªç‚¹çš„ç‚¹
2. **è¾¹ç•Œç‚¹ï¼ˆBorder Pointï¼‰**ï¼šä¸æ˜¯æ ¸å¿ƒç‚¹ï¼Œä½†åœ¨æ ¸å¿ƒç‚¹çš„é‚»åŸŸå†…
3. **å™ªå£°ç‚¹ï¼ˆNoise Pointï¼‰**ï¼šæ—¢ä¸æ˜¯æ ¸å¿ƒç‚¹ä¹Ÿä¸æ˜¯è¾¹ç•Œç‚¹

#### DBSCANç®—æ³•æ­¥éª¤

1. **æ ‡è®°æ ¸å¿ƒç‚¹**ï¼šå¯¹æ¯ä¸ªç‚¹ï¼Œè®¡ç®—$\epsilon$é‚»åŸŸå†…çš„ç‚¹æ•°
2. **æ„å»ºç°‡**ï¼šä»æ ¸å¿ƒç‚¹å¼€å§‹ï¼Œé€šè¿‡å¯†åº¦å¯è¾¾æ€§æ‰©å±•ç°‡
3. **åˆ†é…è¾¹ç•Œç‚¹**ï¼šå°†è¾¹ç•Œç‚¹åˆ†é…åˆ°æœ€è¿‘çš„ç°‡
4. **æ ‡è®°å™ªå£°ç‚¹**ï¼šå‰©ä½™çš„ç‚¹æ ‡è®°ä¸ºå™ªå£°

#### DBSCANå‚æ•°

- **$\epsilon$ï¼ˆepsï¼‰**ï¼šé‚»åŸŸåŠå¾„
- **$minPts$**ï¼šå½¢æˆæ ¸å¿ƒç‚¹çš„æœ€å°ç‚¹æ•°

### 2.2 å¯†åº¦èšç±»å®ç°

```sql
-- DBSCANèšç±»å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒDBSCANèšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒDBSCANèšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'DBSCANèšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- DBSCANæ ¸å¿ƒå‡½æ•°ï¼šè®¡ç®—é‚»åŸŸå†…çš„ç‚¹æ•°
WITH point_neighbors AS (
    SELECT
        p1.id AS point_id,
        p1.x,
        p1.y,
        COUNT(*) - 1 AS neighbor_count  -- å‡å»è‡ªå·±
    FROM cluster_data p1
    CROSS JOIN cluster_data p2
    WHERE SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) <= 2.0  -- eps = 2.0
    GROUP BY p1.id, p1.x, p1.y
),
core_points AS (
    SELECT
        point_id,
        x,
        y,
        neighbor_count
    FROM point_neighbors
    WHERE neighbor_count >= 3  -- min_pts = 3
),
dbscan_clusters AS (
    SELECT
        c.id,
        c.x,
        c.y,
        CASE
            WHEN cp.point_id IS NOT NULL THEN
                DENSE_RANK() OVER (ORDER BY cp.point_id)
            ELSE -1  -- å™ªå£°ç‚¹
        END AS cluster_id
    FROM cluster_data c
    LEFT JOIN core_points cp ON SQRT(POWER(c.x - cp.x, 2) + POWER(c.y - cp.y, 2)) <= 2.0
)
SELECT
    id,
    x,
    y,
    cluster_id,
    CASE WHEN cluster_id = -1 THEN 'Noise' ELSE 'Cluster' END AS point_type
FROM dbscan_clusters
ORDER BY cluster_id, id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    p1.id,
    COUNT(*) - 1 AS neighbor_count
FROM cluster_data p1
CROSS JOIN cluster_data p2
WHERE SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) <= 2.0
GROUP BY p1.id
LIMIT 100;
```

---

### 2.3 DBSCANç°‡æ‰©å±•

**ç°‡æ‰©å±•**å®ç°å®Œæ•´çš„DBSCANç°‡æ„å»ºè¿‡ç¨‹ã€‚

```sql
-- DBSCANç°‡æ‰©å±•ï¼šå®ç°å¯†åº¦å¯è¾¾æ€§
WITH point_neighbors AS (
    SELECT
        p1.id AS point_id,
        p1.x,
        p1.y,
        ARRAY_AGG(p2.id) AS neighbor_ids,
        COUNT(*) - 1 AS neighbor_count
    FROM cluster_data p1
    CROSS JOIN cluster_data p2
    WHERE SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) <= 2.0
    GROUP BY p1.id, p1.x, p1.y
),
core_points AS (
    SELECT
        point_id,
        x,
        y,
        neighbor_ids
    FROM point_neighbors
    WHERE neighbor_count >= 3  -- minPts = 3
),
cluster_expansion AS (
    SELECT
        cp.point_id AS seed_point,
        cp.point_id AS cluster_point,
        cp.neighbor_ids
    FROM core_points cp

    UNION ALL

    SELECT
        ce.seed_point,
        unnest(ce.neighbor_ids) AS cluster_point,
        pn.neighbor_ids
    FROM cluster_expansion ce
    JOIN point_neighbors pn ON unnest(ce.neighbor_ids) = pn.point_id
    WHERE pn.neighbor_count >= 3  -- åªæ‰©å±•æ ¸å¿ƒç‚¹
),
dbscan_clusters AS (
    SELECT DISTINCT
        seed_point AS cluster_id,
        cluster_point AS point_id
    FROM cluster_expansion
)
SELECT
    COALESCE(dc.cluster_id, -1) AS cluster_id,
    d.id,
    d.x,
    d.y,
    CASE WHEN dc.cluster_id IS NULL THEN 'Noise' ELSE 'Cluster' END AS point_type
FROM cluster_data d
LEFT JOIN dbscan_clusters dc ON d.id = dc.point_id
ORDER BY cluster_id, d.id;
```

---

## 3. èšç±»è¯„ä¼°

### 3.1 èšç±»è¯„ä¼°åŸç†

**èšç±»è¯„ä¼°**ç”¨äºè¡¡é‡èšç±»è´¨é‡ï¼Œå¸®åŠ©é€‰æ‹©æœ€ä¼˜çš„èšç±»å‚æ•°å’Œç®—æ³•ã€‚

#### å†…éƒ¨è¯„ä¼°æŒ‡æ ‡

1. **è½®å»“ç³»æ•°ï¼ˆSilhouette Coefficientï¼‰**ï¼šè¡¡é‡ç°‡å†…ç´§å¯†åº¦å’Œç°‡é—´åˆ†ç¦»åº¦
2. **WCSSï¼ˆWithin-Cluster Sum of Squaresï¼‰**ï¼šç°‡å†…å¹³æ–¹å’Œ
3. **BCSSï¼ˆBetween-Cluster Sum of Squaresï¼‰**ï¼šç°‡é—´å¹³æ–¹å’Œ

#### å¤–éƒ¨è¯„ä¼°æŒ‡æ ‡

1. **è°ƒæ•´å…°å¾·æŒ‡æ•°ï¼ˆARIï¼‰**ï¼šä¸çœŸå®æ ‡ç­¾çš„ç›¸ä¼¼åº¦
2. **æ ‡å‡†åŒ–äº’ä¿¡æ¯ï¼ˆNMIï¼‰**ï¼šä¿¡æ¯è®ºæŒ‡æ ‡
3. **åŒè´¨æ€§ï¼ˆHomogeneityï¼‰**ï¼šæ¯ä¸ªç°‡åªåŒ…å«ä¸€ä¸ªç±»çš„æ ·æœ¬

### 3.2 è½®å»“ç³»æ•°å®ç°

```sql
-- è½®å»“ç³»æ•°è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—è½®å»“ç³»æ•°';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—è½®å»“ç³»æ•°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è½®å»“ç³»æ•°è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—è½®å»“ç³»æ•°
WITH kmeans_clusters AS (
    SELECT
        id,
        x,
        y,
        NTILE(3) OVER (ORDER BY x, y) AS cluster_id
    FROM cluster_data
),
intra_cluster_distances AS (
    SELECT
        c1.id,
        c1.cluster_id,
        AVG(SQRT(POWER(c1.x - c2.x, 2) + POWER(c1.y - c2.y, 2))) AS avg_intra_distance
    FROM kmeans_clusters c1
    JOIN kmeans_clusters c2 ON c1.cluster_id = c2.cluster_id AND c1.id != c2.id
    GROUP BY c1.id, c1.cluster_id
),
inter_cluster_distances AS (
    SELECT
        c1.id,
        c1.cluster_id,
        c2.cluster_id AS other_cluster,
        AVG(SQRT(POWER(c1.x - c2.x, 2) + POWER(c1.y - c2.y, 2))) AS avg_inter_distance
    FROM kmeans_clusters c1
    JOIN kmeans_clusters c2 ON c1.cluster_id != c2.cluster_id
    GROUP BY c1.id, c1.cluster_id, c2.cluster_id
),
min_inter_distances AS (
    SELECT
        id,
        cluster_id,
        MIN(avg_inter_distance) AS min_inter_distance
    FROM inter_cluster_distances
    GROUP BY id, cluster_id
),
silhouette_scores AS (
    SELECT
        i.id,
        i.cluster_id,
        i.avg_intra_distance AS a,
        m.min_inter_distance AS b,
        CASE
            WHEN GREATEST(a, b) = 0 THEN 0
            ELSE (b - a) / GREATEST(a, b)
        END AS silhouette
    FROM intra_cluster_distances i
    JOIN min_inter_distances m ON i.id = m.id
)
SELECT
    cluster_id,
    COUNT(*) AS cluster_size,
    ROUND(AVG(silhouette)::numeric, 4) AS avg_silhouette,
    ROUND(MIN(silhouette)::numeric, 4) AS min_silhouette,
    ROUND(MAX(silhouette)::numeric, 4) AS max_silhouette
FROM silhouette_scores
GROUP BY cluster_id
ORDER BY cluster_id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    NTILE(3) OVER (ORDER BY x, y) AS cluster_id
FROM cluster_data;
```

### 3.2 è‚˜éƒ¨æ³•åˆ™

**è‚˜éƒ¨æ³•åˆ™**ç”¨äºç¡®å®šæœ€ä¼˜çš„Kå€¼ã€‚

```sql
-- è‚˜éƒ¨æ³•åˆ™è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cluster_data') THEN
            RAISE WARNING 'è¡¨ cluster_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—è‚˜éƒ¨æ³•åˆ™';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—è‚˜éƒ¨æ³•åˆ™';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è‚˜éƒ¨æ³•åˆ™è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—ä¸åŒKå€¼çš„SSEï¼ˆè¯¯å·®å¹³æ–¹å’Œï¼‰
WITH k_values AS (
    SELECT unnest(ARRAY[1, 2, 3, 4, 5]) AS k
),
kmeans_results AS (
    SELECT
        k,
        id,
        x,
        y,
        NTILE(k) OVER (PARTITION BY k ORDER BY x, y) AS cluster_id
    FROM cluster_data
    CROSS JOIN k_values
),
cluster_centers AS (
    SELECT
        k,
        cluster_id,
        AVG(x) AS center_x,
        AVG(y) AS center_y
    FROM kmeans_results
    GROUP BY k, cluster_id
),
sse AS (
    SELECT
        kr.k,
        SUM(POWER(kr.x - cc.center_x, 2) + POWER(kr.y - cc.center_y, 2)) AS sse_value
    FROM kmeans_results kr
    JOIN cluster_centers cc ON kr.k = cc.k AND kr.cluster_id = cc.cluster_id
    GROUP BY kr.k
)
SELECT
    k,
    ROUND(sse_value::numeric, 2) AS sse,
    ROUND((sse_value - LAG(sse_value) OVER (ORDER BY k))::numeric, 2) AS sse_reduction
FROM sse
ORDER BY k;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    k,
    COUNT(*) AS cluster_count
FROM (
    SELECT
        unnest(ARRAY[1, 2, 3, 4, 5]) AS k,
        NTILE(unnest) OVER (PARTITION BY unnest ORDER BY x, y) AS cluster_id
    FROM cluster_data
    CROSS JOIN generate_series(1, 5) AS k
) t
GROUP BY k;
```

---

### 3.3 WCSSå’ŒBCSSè®¡ç®—

**WCSSå’ŒBCSS**è¯„ä¼°èšç±»è´¨é‡ã€‚

```sql
-- WCSSå’ŒBCSSè®¡ç®—ï¼šè¯„ä¼°èšç±»è´¨é‡
WITH kmeans_clusters AS (
    SELECT
        id,
        x,
        y,
        NTILE(3) OVER (ORDER BY x, y) AS cluster_id
    FROM cluster_data
),
cluster_centers AS (
    SELECT
        cluster_id,
        AVG(x) AS center_x,
        AVG(y) AS center_y
    FROM kmeans_clusters
    GROUP BY cluster_id
),
overall_center AS (
    SELECT
        AVG(x) AS overall_x,
        AVG(y) AS overall_y
    FROM cluster_data
),
wcss AS (
    SELECT
        SUM(POWER(kc.x - cc.center_x, 2) + POWER(kc.y - cc.center_y, 2)) AS wcss_value
    FROM kmeans_clusters kc
    JOIN cluster_centers cc ON kc.cluster_id = cc.cluster_id
),
bcss AS (
    SELECT
        SUM(
            COUNT(*) OVER (PARTITION BY kc.cluster_id) *
            (POWER(cc.center_x - oc.overall_x, 2) + POWER(cc.center_y - oc.overall_y, 2))
        ) AS bcss_value
    FROM kmeans_clusters kc
    JOIN cluster_centers cc ON kc.cluster_id = cc.cluster_id
    CROSS JOIN overall_center oc
    GROUP BY kc.cluster_id, cc.center_x, cc.center_y, oc.overall_x, oc.overall_y
)
SELECT
    ROUND(wcss_value::numeric, 2) AS wcss,
    ROUND(bcss_value::numeric, 2) AS bcss,
    ROUND((bcss_value / NULLIF(wcss_value + bcss_value, 0))::numeric, 4) AS explained_variance_ratio
FROM wcss, bcss;
```

---

## 4. å±‚æ¬¡èšç±»

### 4.1 å±‚æ¬¡èšç±»åŸç†

**å±‚æ¬¡èšç±»ï¼ˆHierarchical Clusteringï¼‰**æ„å»ºä¸€ä¸ªæ ‘çŠ¶çš„èšç±»å±‚æ¬¡ç»“æ„ï¼Œä¸éœ€è¦é¢„å…ˆæŒ‡å®šç°‡çš„æ•°é‡ã€‚

#### å±‚æ¬¡èšç±»ç±»å‹

1. **å‡èšèšç±»ï¼ˆAgglomerativeï¼‰**ï¼šè‡ªåº•å‘ä¸Šï¼Œä»å•ä¸ªç‚¹å¼€å§‹åˆå¹¶
2. **åˆ†è£‚èšç±»ï¼ˆDivisiveï¼‰**ï¼šè‡ªé¡¶å‘ä¸‹ï¼Œä»æ‰€æœ‰ç‚¹å¼€å§‹åˆ†è£‚

#### é“¾æ¥å‡†åˆ™

1. **å•é“¾æ¥ï¼ˆSingle Linkageï¼‰**ï¼š$d(C_i, C_j) = \min_{x \in C_i, y \in C_j} d(x, y)$
2. **å®Œå…¨é“¾æ¥ï¼ˆComplete Linkageï¼‰**ï¼š$d(C_i, C_j) = \max_{x \in C_i, y \in C_j} d(x, y)$
3. **å¹³å‡é“¾æ¥ï¼ˆAverage Linkageï¼‰**ï¼š$d(C_i, C_j) = \frac{1}{|C_i||C_j|}\sum_{x \in C_i}\sum_{y \in C_j} d(x, y)$

### 4.2 å±‚æ¬¡èšç±»å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰

```sql
-- å±‚æ¬¡èšç±»ï¼šä½¿ç”¨å•é“¾æ¥å‡†åˆ™ï¼ˆç®€åŒ–ç‰ˆï¼‰
WITH distance_matrix AS (
    SELECT
        d1.id AS id1,
        d2.id AS id2,
        SQRT(POWER(d1.x - d2.x, 2) + POWER(d1.y - d2.y, 2)) AS distance
    FROM cluster_data d1
    JOIN cluster_data d2 ON d1.id < d2.id
),
closest_pairs AS (
    SELECT
        id1,
        id2,
        distance,
        ROW_NUMBER() OVER (ORDER BY distance) AS merge_order
    FROM distance_matrix
)
SELECT
    merge_order,
    id1,
    id2,
    ROUND(distance::numeric, 4) AS merge_distance
FROM closest_pairs
ORDER BY merge_order
LIMIT 10;  -- æ˜¾ç¤ºå‰10æ¬¡åˆå¹¶
```

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 å®¢æˆ·ç»†åˆ†

**å®¢æˆ·ç»†åˆ†**ä½¿ç”¨èšç±»ç®—æ³•å¯¹å®¢æˆ·è¿›è¡Œåˆ†ç»„ã€‚

```sql
-- å®¢æˆ·ç»†åˆ†ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customer_features') THEN
            RAISE WARNING 'è¡¨ customer_features ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE customer_features (
                customer_id SERIAL PRIMARY KEY,
                annual_spending NUMERIC NOT NULL,
                purchase_frequency NUMERIC NOT NULL,
                avg_order_value NUMERIC NOT NULL
            );

            INSERT INTO customer_features (annual_spending, purchase_frequency, avg_order_value) VALUES
                (500, 2, 250), (600, 3, 200), (800, 4, 200),
                (1200, 6, 200), (1500, 8, 187.5), (2000, 10, 200),
                (3000, 12, 250), (5000, 15, 333.33), (8000, 20, 400);

            RAISE NOTICE 'è¡¨ customer_features åˆ›å»ºæˆåŠŸ';
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®¢æˆ·ç»†åˆ†';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·ç»†åˆ†å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨K-meansè¿›è¡Œå®¢æˆ·ç»†åˆ†
WITH normalized_features AS (
    SELECT
        customer_id,
        annual_spending,
        purchase_frequency,
        avg_order_value,
        (annual_spending - AVG(annual_spending) OVER ()) / NULLIF(STDDEV(annual_spending) OVER (), 0) AS norm_spending,
        (purchase_frequency - AVG(purchase_frequency) OVER ()) / NULLIF(STDDEV(purchase_frequency) OVER (), 0) AS norm_frequency,
        (avg_order_value - AVG(avg_order_value) OVER ()) / NULLIF(STDDEV(avg_order_value) OVER (), 0) AS norm_order_value
    FROM customer_features
),
kmeans_clusters AS (
    SELECT
        customer_id,
        annual_spending,
        purchase_frequency,
        avg_order_value,
        NTILE(3) OVER (ORDER BY norm_spending, norm_frequency, norm_order_value) AS segment_id
    FROM normalized_features
),
segment_profiles AS (
    SELECT
        segment_id,
        COUNT(*) AS customer_count,
        ROUND(AVG(annual_spending)::numeric, 2) AS avg_spending,
        ROUND(AVG(purchase_frequency)::numeric, 2) AS avg_frequency,
        ROUND(AVG(avg_order_value)::numeric, 2) AS avg_order_value,
        CASE segment_id
            WHEN 1 THEN 'ä½ä»·å€¼å®¢æˆ·'
            WHEN 2 THEN 'ä¸­ä»·å€¼å®¢æˆ·'
            WHEN 3 THEN 'é«˜ä»·å€¼å®¢æˆ·'
        END AS segment_name
    FROM kmeans_clusters
    GROUP BY segment_id
)
SELECT
    c.customer_id,
    c.annual_spending,
    c.purchase_frequency,
    c.avg_order_value,
    c.segment_id,
    sp.segment_name,
    sp.avg_spending AS segment_avg_spending
FROM kmeans_clusters c
JOIN segment_profiles sp ON c.segment_id = sp.segment_id
ORDER BY c.segment_id, c.annual_spending DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    customer_id,
    NTILE(3) OVER (ORDER BY annual_spending, purchase_frequency) AS segment_id
FROM customer_features;
```

---

### 5.2 ç”¨æˆ·è¡Œä¸ºèšç±»

**åœºæ™¯**ï¼šæ ¹æ®ç”¨æˆ·è¡Œä¸ºå¯¹ç”¨æˆ·è¿›è¡Œèšç±»ã€‚

```sql
-- ç”¨æˆ·è¡Œä¸ºèšç±»ï¼šåŸºäºç”¨æˆ·æ´»è·ƒåº¦å’Œæ¶ˆè´¹è¡Œä¸º
WITH user_behavior_features AS (
    SELECT
        user_id,
        COUNT(DISTINCT DATE(activity_time)) AS active_days,
        COUNT(*) AS total_activities,
        SUM(CASE WHEN activity_type = 'purchase' THEN 1 ELSE 0 END) AS purchase_count,
        AVG(CASE WHEN activity_type = 'purchase' THEN amount ELSE NULL END) AS avg_purchase_amount
    FROM user_activities
    WHERE activity_time >= NOW() - INTERVAL '30 days'
    GROUP BY user_id
),
normalized_features AS (
    SELECT
        user_id,
        active_days,
        total_activities,
        purchase_count,
        avg_purchase_amount,
        (active_days - AVG(active_days) OVER ()) / NULLIF(STDDEV(active_days) OVER (), 0) AS norm_active_days,
        (total_activities - AVG(total_activities) OVER ()) / NULLIF(STDDEV(total_activities) OVER (), 0) AS norm_total_activities,
        (purchase_count - AVG(purchase_count) OVER ()) / NULLIF(STDDEV(purchase_count) OVER (), 0) AS norm_purchase_count
    FROM user_behavior_features
),
user_clusters AS (
    SELECT
        user_id,
        active_days,
        total_activities,
        purchase_count,
        avg_purchase_amount,
        NTILE(4) OVER (
            ORDER BY norm_active_days, norm_total_activities, norm_purchase_count
        ) AS cluster_id
    FROM normalized_features
),
cluster_profiles AS (
    SELECT
        cluster_id,
        COUNT(*) AS user_count,
        ROUND(AVG(active_days)::numeric, 2) AS avg_active_days,
        ROUND(AVG(total_activities)::numeric, 2) AS avg_total_activities,
        ROUND(AVG(purchase_count)::numeric, 2) AS avg_purchase_count,
        ROUND(AVG(avg_purchase_amount)::numeric, 2) AS avg_purchase_amount,
        CASE cluster_id
            WHEN 1 THEN 'ä½æ´»è·ƒç”¨æˆ·'
            WHEN 2 THEN 'ä¸­ç­‰æ´»è·ƒç”¨æˆ·'
            WHEN 3 THEN 'é«˜æ´»è·ƒç”¨æˆ·'
            WHEN 4 THEN 'è¶…çº§ç”¨æˆ·'
        END AS cluster_label
    FROM user_clusters
    GROUP BY cluster_id
)
SELECT
    uc.user_id,
    uc.active_days,
    uc.total_activities,
    uc.purchase_count,
    uc.avg_purchase_amount,
    uc.cluster_id,
    cp.cluster_label,
    cp.avg_active_days,
    cp.avg_total_activities
FROM user_clusters uc
JOIN cluster_profiles cp ON uc.cluster_id = cp.cluster_id
ORDER BY uc.cluster_id, uc.total_activities DESC;
```

### 5.3 äº§å“èšç±»åˆ†æ

**åœºæ™¯**ï¼šæ ¹æ®äº§å“ç‰¹å¾å¯¹äº§å“è¿›è¡Œèšç±»ã€‚

```sql
-- äº§å“èšç±»åˆ†æï¼šåŸºäºäº§å“å±æ€§å’Œé”€å”®è¡¨ç°
WITH product_features AS (
    SELECT
        product_id,
        category,
        price,
        rating_avg,
        sales_count,
        return_rate,
        -- ç‰¹å¾ç¼–ç 
        CASE category
            WHEN 'electronics' THEN 1
            WHEN 'books' THEN 2
            WHEN 'clothing' THEN 3
            ELSE 4
        END AS category_code
    FROM products
),
normalized_products AS (
    SELECT
        product_id,
        category,
        price,
        rating_avg,
        sales_count,
        return_rate,
        category_code,
        (price - AVG(price) OVER ()) / NULLIF(STDDEV(price) OVER (), 0) AS norm_price,
        (rating_avg - AVG(rating_avg) OVER ()) / NULLIF(STDDEV(rating_avg) OVER (), 0) AS norm_rating,
        (sales_count - AVG(sales_count) OVER ()) / NULLIF(STDDEV(sales_count) OVER (), 0) AS norm_sales
    FROM product_features
),
product_clusters AS (
    SELECT
        product_id,
        category,
        price,
        rating_avg,
        sales_count,
        return_rate,
        NTILE(5) OVER (
            ORDER BY norm_price, norm_rating, norm_sales
        ) AS cluster_id
    FROM normalized_products
),
cluster_analysis AS (
    SELECT
        cluster_id,
        COUNT(*) AS product_count,
        ROUND(AVG(price)::numeric, 2) AS avg_price,
        ROUND(AVG(rating_avg)::numeric, 2) AS avg_rating,
        ROUND(AVG(sales_count)::numeric, 2) AS avg_sales,
        ROUND(AVG(return_rate)::numeric, 4) AS avg_return_rate,
        -- èšç±»ç‰¹å¾
        CASE
            WHEN AVG(price) > (SELECT AVG(price) FROM product_features) AND
                 AVG(rating_avg) > (SELECT AVG(rating_avg) FROM product_features) THEN 'é«˜ç«¯ä¼˜è´¨'
            WHEN AVG(price) < (SELECT AVG(price) FROM product_features) AND
                 AVG(sales_count) > (SELECT AVG(sales_count) FROM product_features) THEN 'æ€§ä»·æ¯”é«˜'
            WHEN AVG(rating_avg) < (SELECT AVG(rating_avg) FROM product_features) THEN 'éœ€è¦æ”¹è¿›'
            ELSE 'æ™®é€šäº§å“'
        END AS cluster_characteristic
    FROM product_clusters
    GROUP BY cluster_id
)
SELECT
    pc.product_id,
    pc.category,
    pc.price,
    pc.rating_avg,
    pc.sales_count,
    pc.cluster_id,
    ca.cluster_characteristic,
    ca.avg_price AS cluster_avg_price,
    ca.avg_rating AS cluster_avg_rating
FROM product_clusters pc
JOIN cluster_analysis ca ON pc.cluster_id = ca.cluster_id
ORDER BY pc.cluster_id, pc.sales_count DESC;
```

### 5.4 å¼‚å¸¸æ£€æµ‹èšç±»

**åœºæ™¯**ï¼šä½¿ç”¨èšç±»è¯†åˆ«å¼‚å¸¸æ•°æ®ç‚¹ã€‚

```sql
-- å¼‚å¸¸æ£€æµ‹èšç±»ï¼šä½¿ç”¨DBSCANè¯†åˆ«å¼‚å¸¸ç‚¹
WITH system_metrics AS (
    SELECT
        metric_id,
        cpu_usage,
        memory_usage,
        disk_io,
        network_io
    FROM system_monitoring
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
),
point_neighbors AS (
    SELECT
        m1.metric_id,
        COUNT(*) - 1 AS neighbor_count
    FROM system_metrics m1
    CROSS JOIN system_metrics m2
    WHERE SQRT(
        POWER(m1.cpu_usage - m2.cpu_usage, 2) +
        POWER(m1.memory_usage - m2.memory_usage, 2) +
        POWER(m1.disk_io - m2.disk_io, 2) +
        POWER(m1.network_io - m2.network_io, 2)
    ) <= 10.0  -- epsé˜ˆå€¼
    GROUP BY m1.metric_id
),
anomaly_detection AS (
    SELECT
        m.metric_id,
        m.cpu_usage,
        m.memory_usage,
        m.disk_io,
        m.network_io,
        COALESCE(pn.neighbor_count, 0) AS neighbor_count,
        CASE
            WHEN COALESCE(pn.neighbor_count, 0) < 3 THEN 'å¼‚å¸¸ç‚¹'
            ELSE 'æ­£å¸¸ç‚¹'
        END AS anomaly_status
    FROM system_metrics m
    LEFT JOIN point_neighbors pn ON m.metric_id = pn.metric_id
)
SELECT
    metric_id,
    cpu_usage,
    memory_usage,
    disk_io,
    network_io,
    neighbor_count,
    anomaly_status
FROM anomaly_detection
WHERE anomaly_status = 'å¼‚å¸¸ç‚¹'
ORDER BY neighbor_count ASC;
```

---

## 6. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 6.1 èšç±»ç®—æ³•å¯¹æ¯”

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|-----------|-----------|---------|------|------|
| **K-means** | $O(nki)$ | $O(n)$ | çƒå½¢ç°‡ | ç®€å•å¿«é€Ÿ | éœ€è¦æŒ‡å®šk |
| **DBSCAN** | $O(n \log n)$ | $O(n)$ | ä»»æ„å½¢çŠ¶ | è‡ªåŠ¨ç¡®å®šç°‡æ•° | å‚æ•°æ•æ„Ÿ |
| **å±‚æ¬¡èšç±»** | $O(n^2)$ | $O(n^2)$ | æ ‘çŠ¶ç»“æ„ | å¯è§†åŒ–å¥½ | è®¡ç®—å¤æ‚ |
| **GMM** | $O(nk^2i)$ | $O(nk)$ | æ··åˆåˆ†å¸ƒ | æ¦‚ç‡æ¨¡å‹ | è®¡ç®—å¤æ‚ |

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è®¡ç®—ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨ç´¢å¼•åŠ é€Ÿè·ç¦»è®¡ç®—
   - é‡‡æ ·è®¡ç®—
   - å¹¶è¡Œå¤„ç†

2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - åˆ›å»ºç‰¹å¾ç´¢å¼•
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾
   - é™åˆ¶æ•°æ®èŒƒå›´

3. **ç®—æ³•ä¼˜åŒ–**ï¼š
   - K-means++åˆå§‹åŒ–
   - Mini-batch K-means
   - å¢é‡èšç±»

### 6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šKå€¼é€‰æ‹©å›°éš¾

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨è‚˜éƒ¨æ³•åˆ™ã€è½®å»“ç³»æ•°ã€ä¸šåŠ¡çŸ¥è¯†

**é—®é¢˜2**ï¼šåˆå§‹å€¼æ•æ„Ÿ

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨K-means++ã€å¤šæ¬¡è¿è¡Œå–æœ€ä¼˜

**é—®é¢˜3**ï¼šè®¡ç®—æ€§èƒ½é—®é¢˜

- **è§£å†³æ–¹æ¡ˆ**ï¼šä¼˜åŒ–SQLæŸ¥è¯¢ã€ä½¿ç”¨ç´¢å¼•ã€é‡‡æ ·è®¡ç®—

**é—®é¢˜4**ï¼šéçƒå½¢ç°‡

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨DBSCANã€æ ¸K-meansã€è°±èšç±»

---

## 7. æœ€ä½³å®è·µ

### 7.1 èšç±»æµç¨‹

1. **æ•°æ®å‡†å¤‡**ï¼š
   - æ•°æ®æ¸…æ´—
   - ç‰¹å¾é€‰æ‹©
   - æ•°æ®æ ‡å‡†åŒ–

2. **ç®—æ³•é€‰æ‹©**ï¼š
   - æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©
   - è€ƒè™‘è®¡ç®—èµ„æº
   - è¯„ä¼°ç®—æ³•æ€§èƒ½

3. **å‚æ•°è°ƒä¼˜**ï¼š
   - Kå€¼é€‰æ‹©
   - è·ç¦»åº¦é‡é€‰æ‹©
   - åˆå§‹åŒ–æ–¹æ³•

4. **ç»“æœè¯„ä¼°**ï¼š
   - ä½¿ç”¨å¤šä¸ªæŒ‡æ ‡
   - ä¸šåŠ¡éªŒè¯
   - å¯è§†åŒ–åˆ†æ

### 7.2 èšç±»æ³¨æ„äº‹é¡¹

1. **æ•°æ®é¢„å¤„ç†**ï¼š
   - æ ‡å‡†åŒ–ç‰¹å¾
   - å¤„ç†ç¼ºå¤±å€¼
   - å»é™¤å¼‚å¸¸å€¼

2. **å‚æ•°é€‰æ‹©**ï¼š
   - Kå€¼ï¼šè‚˜éƒ¨æ³•åˆ™ã€è½®å»“ç³»æ•°
   - DBSCANï¼šepså’ŒminPts
   - è·ç¦»åº¦é‡ï¼šæ ¹æ®æ•°æ®ç‰¹å¾

3. **ç»“æœè§£é‡Š**ï¼š
   - ç»“åˆä¸šåŠ¡çŸ¥è¯†
   - åˆ†æç°‡ç‰¹å¾
   - éªŒè¯èšç±»åˆç†æ€§

### 7.3 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼š
   - ä¼˜åŒ–è·ç¦»è®¡ç®—
   - åˆ›å»ºç‰¹å¾ç´¢å¼•
   - ä½¿ç”¨çª—å£å‡½æ•°

2. **å‡†ç¡®æ€§**ï¼š
   - å¤„ç†NULLå€¼
   - é¿å…æ•°å€¼ç²¾åº¦é—®é¢˜
   - éªŒè¯è®¡ç®—ç»“æœ

3. **å¯ç»´æŠ¤æ€§**ï¼š
   - ä½¿ç”¨æ¸…æ™°çš„å˜é‡å
   - æ·»åŠ æ³¨é‡Š
   - æ¨¡å—åŒ–è®¾è®¡

### 7.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡èšç±»ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«ç‰¹å¾å€¼çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºK-meansåˆå§‹ä¸­å¿ƒç‚¹é€‰æ‹©å’ŒTop-Kæœ€è¿‘é‚»æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡èšç±»è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡è·ç¦»è®¡ç®—å’Œå¤§è§„æ¨¡æ•°æ®èšç±»

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - èšç±»è·ç¦»è®¡ç®—æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œ
   - é€‚ç”¨äºå¤§è§„æ¨¡æ•°æ®èšç±»å’Œæ‰¹é‡èšç±»åˆ†æ

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–K-meansåˆå§‹ä¸­å¿ƒç‚¹é€‰æ‹©**

```sql
-- ä¸ºèšç±»ç‰¹å¾åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_clustering_features_skip_scan
ON clustering_data USING btree(feature1 DESC, feature2 DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šé€‰æ‹©K-meansåˆå§‹ä¸­å¿ƒç‚¹ï¼ˆK-means++ç®€åŒ–ç‰ˆï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH initial_centers AS (
    SELECT DISTINCT ON (feature1, feature2)
        sample_id,
        feature1,
        feature2,
        ROW_NUMBER() OVER (ORDER BY feature1 DESC, feature2 DESC) AS center_rank
    FROM clustering_data
    ORDER BY feature1 DESC, feature2 DESC
    LIMIT 5  -- K=5
)
SELECT
    center_rank AS cluster_id,
    feature1 AS center_x,
    feature2 AS center_y
FROM initial_centers
ORDER BY center_rank;
```

### 7.5 é«˜çº§ä¼˜åŒ–æŠ€å·§

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜èšç±»ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„èšç±»ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜K-meansèšç±»ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS kmeans_clusters_cache AS
WITH kmeans_centers AS (
    SELECT
        cluster_id,
        AVG(feature1) AS center_x,
        AVG(feature2) AS center_y
    FROM clustering_data
    GROUP BY cluster_id
),
sample_distances AS (
    SELECT
        cd.sample_id,
        cd.feature1,
        cd.feature2,
        kc.cluster_id,
        SQRT(POWER(cd.feature1 - kc.center_x, 2) + POWER(cd.feature2 - kc.center_y, 2)) AS distance_to_center
    FROM clustering_data cd
    CROSS JOIN kmeans_centers kc
),
closest_clusters AS (
    SELECT DISTINCT ON (sample_id)
        sample_id,
        feature1,
        feature2,
        cluster_id,
        distance_to_center
    FROM sample_distances
    ORDER BY sample_id, distance_to_center ASC
)
SELECT
    sample_id,
    feature1,
    feature2,
    cluster_id,
    ROUND(distance_to_center::numeric, 4) AS distance_to_center
FROM closest_clusters;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_kmeans_clusters_cache_cluster ON kmeans_clusters_cache(cluster_id);
CREATE INDEX idx_kmeans_clusters_cache_sample ON kmeans_clusters_cache(sample_id);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY kmeans_clusters_cache;
```

**2. å¢é‡K-meansèšç±»ï¼šæµå¼æ•°æ®èšç±»**

**å¢é‡K-meansèšç±»**ï¼šå¯¹äºæµå¼æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°èšç±»ä¸­å¿ƒã€‚

```sql
-- å¢é‡K-meansèšç±»ï¼šæµå¼æ•°æ®èšç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'kmeans_cluster_state') THEN
            CREATE TABLE kmeans_cluster_state (
                cluster_id INTEGER PRIMARY KEY,
                center_x NUMERIC NOT NULL,
                center_y NUMERIC NOT NULL,
                sample_count BIGINT NOT NULL DEFAULT 0,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            RAISE NOTICE 'K-meansèšç±»çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡K-meansèšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡K-meansèšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°K-meansèšç±»ä¸­å¿ƒ
WITH new_samples AS (
    SELECT
        feature1,
        feature2
    FROM clustering_data
    WHERE sample_id > (SELECT COALESCE(MAX(sample_id), 0) FROM kmeans_cluster_state)
),
sample_cluster_assignment AS (
    SELECT
        ns.feature1,
        ns.feature2,
        kcs.cluster_id,
        SQRT(POWER(ns.feature1 - kcs.center_x, 2) + POWER(ns.feature2 - kcs.center_y, 2)) AS distance
    FROM new_samples ns
    CROSS JOIN kmeans_cluster_state kcs
),
closest_cluster AS (
    SELECT DISTINCT ON (feature1, feature2)
        feature1,
        feature2,
        cluster_id
    FROM sample_cluster_assignment
    ORDER BY feature1, feature2, distance ASC
),
updated_centers AS (
    SELECT
        cc.cluster_id,
        -- å¢é‡æ›´æ–°èšç±»ä¸­å¿ƒï¼šåŠ æƒå¹³å‡
        (kcs.center_x * kcs.sample_count + AVG(cc.feature1) * COUNT(*)) /
        NULLIF(kcs.sample_count + COUNT(*), 0) AS new_center_x,
        (kcs.center_y * kcs.sample_count + AVG(cc.feature2) * COUNT(*)) /
        NULLIF(kcs.sample_count + COUNT(*), 0) AS new_center_y,
        kcs.sample_count + COUNT(*) AS new_sample_count
    FROM closest_cluster cc
    JOIN kmeans_cluster_state kcs ON cc.cluster_id = kcs.cluster_id
    GROUP BY cc.cluster_id, kcs.center_x, kcs.center_y, kcs.sample_count
)
UPDATE kmeans_cluster_state kcs
SET
    center_x = uc.new_center_x,
    center_y = uc.new_center_y,
    sample_count = uc.new_sample_count,
    last_updated = NOW()
FROM updated_centers uc
WHERE kcs.cluster_id = uc.cluster_id;
```

**3. DBSCANèšç±»ï¼šå¯†åº¦èšç±»ä¼˜åŒ–**

**DBSCANèšç±»**ï¼šåŸºäºå¯†åº¦çš„èšç±»ç®—æ³•ï¼Œå¯ä»¥å‘ç°ä»»æ„å½¢çŠ¶çš„ç°‡ã€‚

```sql
-- DBSCANèšç±»ï¼šå¯†åº¦èšç±»ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    eps NUMERIC := 0.5;  -- é‚»åŸŸåŠå¾„
    min_samples INTEGER := 5;  -- æœ€å°æ ·æœ¬æ•°
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'clustering_data') THEN
            RAISE WARNING 'è¡¨ clustering_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒDBSCANèšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒDBSCANèšç±»ï¼Œeps=%, min_samples=%', eps, min_samples;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'DBSCANèšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- DBSCANèšç±»ï¼šåŸºäºå¯†åº¦çš„èšç±»
WITH point_neighbors AS (
    SELECT
        p1.sample_id AS point_id,
        p1.feature1 AS x1,
        p1.feature2 AS y1,
        COUNT(*) AS neighbor_count,
        ARRAY_AGG(p2.sample_id) AS neighbor_ids
    FROM clustering_data p1
    LEFT JOIN clustering_data p2 ON
        SQRT(POWER(p1.feature1 - p2.feature1, 2) + POWER(p1.feature2 - p2.feature2, 2)) <= 0.5
        AND p1.sample_id != p2.sample_id
    GROUP BY p1.sample_id, p1.feature1, p1.feature2
),
core_points AS (
    SELECT
        point_id,
        x1,
        y1,
        neighbor_count,
        neighbor_ids
    FROM point_neighbors
    WHERE neighbor_count >= 5  -- min_samples
),
dbscan_clusters AS (
    SELECT
        cp1.point_id,
        cp1.x1,
        cp1.y1,
        -- ä½¿ç”¨çª—å£å‡½æ•°åˆ†é…ç°‡IDï¼ˆç®€åŒ–ç‰ˆï¼‰
        DENSE_RANK() OVER (ORDER BY cp1.point_id) AS cluster_id
    FROM core_points cp1
    WHERE EXISTS (
        SELECT 1
        FROM core_points cp2
        WHERE cp2.point_id = ANY(cp1.neighbor_ids)
    )
)
SELECT
    point_id,
    x1,
    y1,
    cluster_id
FROM dbscan_clusters
ORDER BY cluster_id, point_id;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **ã€Šæ•°æ®æŒ–æ˜ï¼šæ¦‚å¿µä¸æŠ€æœ¯ã€‹**ï¼ˆHan, J., et al., 2011ï¼‰- èšç±»ç®—æ³•

2. **ã€Šæœºå™¨å­¦ä¹ ã€‹**ï¼ˆMitchell, T. M., 1997ï¼‰- èšç±»ç†è®º

3. **ã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹**ï¼ˆæèˆª, 2012ï¼‰- èšç±»æ–¹æ³•

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- **èšåˆå‡½æ•°**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **çª—å£å‡½æ•°**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **æ•°å­¦å‡½æ•°**: <https://www.postgresql.org/docs/current/functions-math.html>

### åœ¨çº¿èµ„æº

- **èšç±»åˆ†æ**: <https://en.wikipedia.org/wiki/Cluster_analysis>
- **K-means**: <https://en.wikipedia.org/wiki/K-means_clustering>
- **DBSCAN**: <https://en.wikipedia.org/wiki/DBSCAN>

### ç›¸å…³ç®—æ³•

- **èšç±»åˆ†æç®—æ³•**ï¼šæ•°æ®æŒ–æ˜ä¸­çš„èšç±»
- **å¼‚å¸¸æ£€æµ‹ç®—æ³•**ï¼šåŸºäºèšç±»çš„å¼‚å¸¸æ£€æµ‹
- **é™ç»´ç®—æ³•**ï¼šPCAç­‰é™ç»´æ–¹æ³•
- **ç‰¹å¾é€‰æ‹©ç®—æ³•**ï¼šèšç±»ç‰¹å¾é€‰æ‹©

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
