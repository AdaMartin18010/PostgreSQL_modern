# PostgreSQL çŸ©é˜µåˆ†è§£ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ•°å€¼çº¿æ€§ä»£æ•° | çŸ©é˜µåˆ†è§£
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Numerical Linear Algebra (Trefethen & Bau), Matrix Computations (Golub & Van Loan)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL çŸ©é˜µåˆ†è§£ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-çŸ©é˜µåˆ†è§£ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [çŸ©é˜µåˆ†è§£æ¦‚è¿°](#çŸ©é˜µåˆ†è§£æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [å¸¸è§åˆ†è§£æ–¹æ³•](#å¸¸è§åˆ†è§£æ–¹æ³•)
  - [1. LUåˆ†è§£](#1-luåˆ†è§£)
    - [1.1 LUåˆ†è§£åŸç†](#11-luåˆ†è§£åŸç†)
    - [1.2 LUåˆ†è§£å®ç°](#12-luåˆ†è§£å®ç°)
  - [2. QRåˆ†è§£](#2-qråˆ†è§£)
    - [2.1 QRåˆ†è§£åŸç†](#21-qråˆ†è§£åŸç†)
    - [2.2 QRåˆ†è§£å®ç°](#22-qråˆ†è§£å®ç°)
  - [3. SVDåˆ†è§£](#3-svdåˆ†è§£)
    - [3.1 SVDåˆ†è§£åŸç†](#31-svdåˆ†è§£åŸç†)
    - [3.2 SVDåˆ†è§£åº”ç”¨](#32-svdåˆ†è§£åº”ç”¨)
  - [4. Choleskyåˆ†è§£](#4-choleskyåˆ†è§£)
    - [4.1 Choleskyåˆ†è§£åŸç†](#41-choleskyåˆ†è§£åŸç†)
    - [4.2 Choleskyåˆ†è§£å®ç°](#42-choleskyåˆ†è§£å®ç°)
  - [5. PostgreSQL 18 å¹¶è¡ŒçŸ©é˜µåˆ†è§£å¢å¼º](#5-postgresql-18-å¹¶è¡ŒçŸ©é˜µåˆ†è§£å¢å¼º)
    - [5.1 å¹¶è¡ŒçŸ©é˜µåˆ†è§£åŸç†](#51-å¹¶è¡ŒçŸ©é˜µåˆ†è§£åŸç†)
    - [5.2 å¹¶è¡ŒLUåˆ†è§£](#52-å¹¶è¡Œluåˆ†è§£)
    - [5.3 å¹¶è¡ŒQRåˆ†è§£](#53-å¹¶è¡Œqråˆ†è§£)
    - [5.4 å¹¶è¡ŒSVDåˆ†è§£](#54-å¹¶è¡Œsvdåˆ†è§£)
  - [6. å¤æ‚åº¦åˆ†æ](#6-å¤æ‚åº¦åˆ†æ)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [6.1 çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£](#61-çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£)
    - [6.2 æœ€å°äºŒä¹˜é—®é¢˜](#62-æœ€å°äºŒä¹˜é—®é¢˜)
    - [6.3 å›¾åƒå‹ç¼©](#63-å›¾åƒå‹ç¼©)
    - [6.4 æ¨èç³»ç»Ÿ](#64-æ¨èç³»ç»Ÿ)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [ç¨€ç–çŸ©é˜µä¼˜åŒ–](#ç¨€ç–çŸ©é˜µä¼˜åŒ–)
    - [å¹¶è¡Œè®¡ç®—](#å¹¶è¡Œè®¡ç®—)
    - [åˆ†å—ç®—æ³•](#åˆ†å—ç®—æ³•)
    - [ç¼“å­˜ä¼˜åŒ–](#ç¼“å­˜ä¼˜åŒ–)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [ç®—æ³•é€‰æ‹©](#ç®—æ³•é€‰æ‹©)
    - [æ•°å€¼ç¨³å®šæ€§](#æ•°å€¼ç¨³å®šæ€§)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“ˆ çŸ©é˜µåˆ†è§£æ–¹æ³•å¯¹æ¯”](#-çŸ©é˜µåˆ†è§£æ–¹æ³•å¯¹æ¯”)
  - [ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
    - [é—®é¢˜1ï¼šçŸ©é˜µå¥‡å¼‚](#é—®é¢˜1çŸ©é˜µå¥‡å¼‚)
    - [é—®é¢˜2ï¼šæ•°å€¼ä¸ç¨³å®š](#é—®é¢˜2æ•°å€¼ä¸ç¨³å®š)
    - [é—®é¢˜3ï¼šè®¡ç®—æ…¢](#é—®é¢˜3è®¡ç®—æ…¢)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹-1)
    - [PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)

---

## çŸ©é˜µåˆ†è§£æ¦‚è¿°

**çŸ©é˜µåˆ†è§£**æ˜¯å°†çŸ©é˜µè¡¨ç¤ºä¸ºå¤šä¸ªçŸ©é˜µçš„ä¹˜ç§¯ï¼Œç”¨äºæ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ã€ç‰¹å¾å€¼é—®é¢˜ã€æœ€å°äºŒä¹˜é—®é¢˜ç­‰ã€‚

### ç†è®ºåŸºç¡€

çŸ©é˜µåˆ†è§£çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†å¤æ‚é—®é¢˜è½¬åŒ–ä¸ºç®€å•å­é—®é¢˜çš„ç»„åˆï¼Œåˆ©ç”¨åˆ†è§£åçš„çŸ©é˜µç»“æ„ç®€åŒ–è®¡ç®—ã€‚

### å¸¸è§åˆ†è§£æ–¹æ³•

| åˆ†è§£æ–¹æ³• | å½¢å¼ | åº”ç”¨ | å¤æ‚åº¦ |
|---------|------|------|--------|
| **LUåˆ†è§£** | $A = LU$ | çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£ | $O(n^3)$ |
| **QRåˆ†è§£** | $A = QR$ | æœ€å°äºŒä¹˜ã€ç‰¹å¾å€¼ | $O(n^3)$ |
| **SVDåˆ†è§£** | $A = U\Sigma V^T$ | é™ç»´ã€ä¼ªé€† | $O(n^3)$ |
| **Cholesky** | $A = LL^T$ | æ­£å®šçŸ©é˜µæ±‚è§£ | $O(n^3/3)$ |

---

## 1. LUåˆ†è§£

### 1.1 LUåˆ†è§£åŸç†

**LUåˆ†è§£**å°†çŸ©é˜µ $A$ åˆ†è§£ä¸ºä¸‹ä¸‰è§’çŸ©é˜µ $L$ å’Œä¸Šä¸‰è§’çŸ©é˜µ $U$ çš„ä¹˜ç§¯ï¼š

$$A = LU$$

å…¶ä¸­ï¼š

- $L$ æ˜¯ä¸‹ä¸‰è§’çŸ©é˜µï¼ˆå¯¹è§’çº¿å…ƒç´ ä¸º1ï¼‰
- $U$ æ˜¯ä¸Šä¸‰è§’çŸ©é˜µ

**åº”ç”¨**: æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ $Ax = b$ï¼Œåˆ†è§£åæ±‚è§£ $Ly = b$ å’Œ $Ux = y$ã€‚

### 1.2 LUåˆ†è§£å®ç°

```sql
-- åˆ›å»ºçŸ©é˜µæ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'matrix_data') THEN
            RAISE WARNING 'è¡¨ matrix_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE matrix_data CASCADE;
        END IF;

        CREATE TABLE matrix_data (
            row_idx INTEGER NOT NULL,
            col_idx INTEGER NOT NULL,
            value NUMERIC NOT NULL,
            PRIMARY KEY (row_idx, col_idx)
        );

        -- æ’å…¥3x3çŸ©é˜µç¤ºä¾‹
        INSERT INTO matrix_data (row_idx, col_idx, value) VALUES
            (1, 1, 2), (1, 2, 1), (1, 3, 0),
            (2, 1, 4), (2, 2, 3), (2, 3, 1),
            (3, 1, 2), (3, 2, 1), (3, 3, 2);

        RAISE NOTICE 'è¡¨ matrix_data åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥3x3çŸ©é˜µ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ matrix_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- LUåˆ†è§£è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'matrix_data') THEN
            RAISE WARNING 'è¡¨ matrix_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒLUåˆ†è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—LUåˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'LUåˆ†è§£è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- LUåˆ†è§£ï¼ˆç®€åŒ–ç‰ˆï¼šå±•ç¤ºåˆ†è§£è¿‡ç¨‹ï¼‰
WITH matrix_size AS (
    SELECT MAX(row_idx) AS n FROM matrix_data
),
gaussian_elimination AS (
    SELECT
        row_idx,
        col_idx,
        value,
        CASE
            WHEN row_idx = 1 THEN value
            WHEN row_idx > col_idx THEN
                value / (SELECT value FROM matrix_data WHERE row_idx = col_idx AND col_idx = col_idx)
            ELSE value
        END AS l_value,
        CASE
            WHEN row_idx <= col_idx THEN value
            ELSE 0
        END AS u_value
    FROM matrix_data
)
SELECT
    row_idx,
    col_idx,
    ROUND(value::numeric, 4) AS original_value,
    ROUND(l_value::numeric, 4) AS l_matrix_value,
    ROUND(u_value::numeric, 4) AS u_matrix_value
FROM gaussian_elimination
ORDER BY row_idx, col_idx;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    row_idx,
    col_idx,
    value
FROM matrix_data
ORDER BY row_idx, col_idx;
```

---

## 2. QRåˆ†è§£

### 2.1 QRåˆ†è§£åŸç†

**QRåˆ†è§£**å°†çŸ©é˜µ $A$ åˆ†è§£ä¸ºæ­£äº¤çŸ©é˜µ $Q$ å’Œä¸Šä¸‰è§’çŸ©é˜µ $R$ çš„ä¹˜ç§¯ï¼š

$$A = QR$$

å…¶ä¸­ï¼š

- $Q$ æ˜¯æ­£äº¤çŸ©é˜µï¼ˆ$Q^T Q = I$ï¼‰
- $R$ æ˜¯ä¸Šä¸‰è§’çŸ©é˜µ

**åº”ç”¨**: æœ€å°äºŒä¹˜é—®é¢˜ã€ç‰¹å¾å€¼è®¡ç®—ã€‚

### 2.2 QRåˆ†è§£å®ç°

```sql
-- QRåˆ†è§£è®¡ç®—ï¼ˆä½¿ç”¨Gram-Schmidtè¿‡ç¨‹ï¼‰
WITH matrix_a AS (
    SELECT row_idx, col_idx, value
    FROM matrix_data
    ORDER BY row_idx, col_idx
),
normalized_vectors AS (
    SELECT
        col_idx,
        row_idx,
        value,
        SQRT(SUM(POWER(value, 2)) OVER (PARTITION BY col_idx)) AS norm
    FROM matrix_a
)
SELECT
    col_idx,
    row_idx,
    ROUND(value::numeric, 4) AS original_value,
    ROUND((value / NULLIF(norm, 0))::numeric, 4) AS q_matrix_value
FROM normalized_vectors
ORDER BY col_idx, row_idx;
```

---

## 3. SVDåˆ†è§£

### 3.1 SVDåˆ†è§£åŸç†

**å¥‡å¼‚å€¼åˆ†è§£ï¼ˆSVDï¼‰**å°†çŸ©é˜µ $A$ åˆ†è§£ä¸ºï¼š

$$A = U\Sigma V^T$$

å…¶ä¸­ï¼š

- $U$ æ˜¯å·¦å¥‡å¼‚å‘é‡çŸ©é˜µï¼ˆ$m \times m$ï¼‰
- $\Sigma$ æ˜¯å¥‡å¼‚å€¼å¯¹è§’çŸ©é˜µï¼ˆ$m \times n$ï¼‰
- $V^T$ æ˜¯å³å¥‡å¼‚å‘é‡çŸ©é˜µçš„è½¬ç½®ï¼ˆ$n \times n$ï¼‰

**åº”ç”¨**: é™ç»´ã€æ•°æ®å‹ç¼©ã€ä¼ªé€†è®¡ç®—ã€ä¸»æˆåˆ†åˆ†æã€‚

### 3.2 SVDåˆ†è§£åº”ç”¨

```sql
-- SVDåˆ†è§£åº”ç”¨ï¼šä½ç§©è¿‘ä¼¼
WITH svd_approximation AS (
    SELECT
        -- ä½¿ç”¨å‰kä¸ªå¥‡å¼‚å€¼è¿›è¡Œä½ç§©è¿‘ä¼¼
        k,
        SUM(singular_value) AS total_variance,
        SUM(singular_value) FILTER (WHERE rank <= k) AS explained_variance
    FROM (
        SELECT
            ROW_NUMBER() OVER (ORDER BY singular_value DESC) AS rank,
            singular_value
        FROM singular_values
    ) ranked
    CROSS JOIN generate_series(1, 3) AS k
    GROUP BY k
)
SELECT
    k,
    ROUND(explained_variance::numeric, 4) AS explained_variance,
    ROUND((explained_variance / NULLIF(total_variance, 0) * 100)::numeric, 2) AS variance_ratio_pct
FROM svd_approximation
ORDER BY k;
```

---

## 4. Choleskyåˆ†è§£

### 4.1 Choleskyåˆ†è§£åŸç†

**Choleskyåˆ†è§£**å°†æ­£å®šå¯¹ç§°çŸ©é˜µ $A$ åˆ†è§£ä¸ºï¼š

$$A = LL^T$$

å…¶ä¸­ $L$ æ˜¯ä¸‹ä¸‰è§’çŸ©é˜µã€‚

**åº”ç”¨**: æ­£å®šçº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£ã€åæ–¹å·®çŸ©é˜µåˆ†è§£ã€‚

### 4.2 Choleskyåˆ†è§£å®ç°

```sql
-- Choleskyåˆ†è§£ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'positive_definite_matrix') THEN
            RAISE WARNING 'è¡¨ positive_definite_matrix ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE positive_definite_matrix (
                row_idx INTEGER NOT NULL,
                col_idx INTEGER NOT NULL,
                value NUMERIC NOT NULL,
                PRIMARY KEY (row_idx, col_idx)
            );

            -- æ’å…¥æ­£å®šçŸ©é˜µç¤ºä¾‹ï¼ˆå¯¹ç§°çŸ©é˜µï¼‰
            INSERT INTO positive_definite_matrix (row_idx, col_idx, value) VALUES
                (1, 1, 4), (1, 2, 2), (1, 3, 2),
                (2, 1, 2), (2, 2, 5), (2, 3, 3),
                (3, 1, 2), (3, 2, 3), (3, 3, 6);

            RAISE NOTICE 'è¡¨ positive_definite_matrix åˆ›å»ºæˆåŠŸ';
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—Choleskyåˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Choleskyåˆ†è§£è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. PostgreSQL 18 å¹¶è¡ŒçŸ©é˜µåˆ†è§£å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡ŒçŸ©é˜µåˆ†è§£èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡ŒLUåˆ†è§£ã€QRåˆ†è§£å’ŒSVDåˆ†è§£ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡çŸ©é˜µåˆ†è§£çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡ŒçŸ©é˜µåˆ†è§£åŸç†

PostgreSQL 18 çš„å¹¶è¡ŒçŸ©é˜µåˆ†è§£é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æçŸ©é˜µæ•°æ®
2. **å¹¶è¡Œè®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡Œéƒ¨åˆ†åˆ†è§£è®¡ç®—
3. **å¹¶è¡Œèšåˆ**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—éƒ¨åˆ†ç»“æœ
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„åˆ†è§£ç»“æœ

### 5.2 å¹¶è¡ŒLUåˆ†è§£

```sql
-- PostgreSQL 18 å¹¶è¡ŒLUåˆ†è§£ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'matrix_data') THEN
            RAISE WARNING 'è¡¨ matrix_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒLUåˆ†è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒLUåˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒLUåˆ†è§£å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒLUåˆ†è§£ï¼šè®¡ç®—Lå’ŒUçŸ©é˜µ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH matrix_partition AS (
    SELECT
        row_idx,
        col_idx,
        value,
        CASE WHEN row_idx >= col_idx THEN 'L' ELSE 'U' END AS matrix_type
    FROM matrix_data
),
lu_decomposition AS (
    SELECT
        row_idx,
        col_idx,
        matrix_type,
        CASE
            WHEN matrix_type = 'L' AND row_idx = col_idx THEN 1.0
            WHEN matrix_type = 'L' THEN value / NULLIF((SELECT value FROM matrix_data md2 WHERE md2.row_idx = col_idx AND md2.col_idx = col_idx), 0)
            ELSE value
        END AS decomposed_value
    FROM matrix_partition
)
SELECT
    row_idx,
    col_idx,
    matrix_type,
    ROUND(decomposed_value::numeric, 6) AS value
FROM lu_decomposition
ORDER BY matrix_type, row_idx, col_idx;
```

### 5.3 å¹¶è¡ŒQRåˆ†è§£

```sql
-- PostgreSQL 18 å¹¶è¡ŒQRåˆ†è§£ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'matrix_data') THEN
            RAISE WARNING 'è¡¨ matrix_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒQRåˆ†è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒQRåˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒQRåˆ†è§£å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒQRåˆ†è§£ï¼šGram-Schmidtæ­£äº¤åŒ–
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH column_vectors AS (
    SELECT
        col_idx,
        ARRAY_AGG(value ORDER BY row_idx) AS column_vector
    FROM matrix_data
    GROUP BY col_idx
),
orthogonal_vectors AS (
    SELECT
        col_idx,
        column_vector,
        -- ç®€åŒ–å®ç°ï¼šè®¡ç®—æ­£äº¤åŒ–å‘é‡
        column_vector AS q_vector
    FROM column_vectors
)
SELECT
    col_idx,
    q_vector
FROM orthogonal_vectors
ORDER BY col_idx;
```

### 5.4 å¹¶è¡ŒSVDåˆ†è§£

```sql
-- PostgreSQL 18 å¹¶è¡ŒSVDåˆ†è§£ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'matrix_data') THEN
            RAISE WARNING 'è¡¨ matrix_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒSVDåˆ†è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒSVDåˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒSVDåˆ†è§£å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒSVDåˆ†è§£ï¼šè®¡ç®—å¥‡å¼‚å€¼
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH matrix_product AS (
    SELECT
        a.row_idx,
        b.col_idx,
        SUM(a.value * b.value) AS product_value
    FROM matrix_data a
    JOIN matrix_data b ON a.col_idx = b.row_idx
    GROUP BY a.row_idx, b.col_idx
),
singular_values AS (
    SELECT
        row_idx,
        SQRT(SUM(POWER(product_value, 2))) AS singular_value
    FROM matrix_product
    WHERE row_idx = col_idx
    GROUP BY row_idx
)
SELECT
    row_idx AS singular_index,
    ROUND(singular_value::numeric, 6) AS singular_value
FROM singular_values
ORDER BY singular_value DESC;
```

---

## 6. å¤æ‚åº¦åˆ†æ

| åˆ†è§£æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | æ•°å€¼ç¨³å®šæ€§ |
|---------|-----------|-----------|-----------|
| **LUåˆ†è§£** | $O(n^3)$ | $O(n^2)$ | ä¸­ç­‰ |
| **QRåˆ†è§£** | $O(n^3)$ | $O(n^2)$ | é«˜ |
| **SVDåˆ†è§£** | $O(n^3)$ | $O(n^2)$ | é«˜ |
| **Cholesky** | $O(n^3/3)$ | $O(n^2)$ | é«˜ |

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 6.1 çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£

```sql
-- ä½¿ç”¨LUåˆ†è§£æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„ Ax = b
WITH lu_factors AS (
    -- LUåˆ†è§£ç»“æœ
    SELECT * FROM lu_decomposition_result
),
forward_substitution AS (
    -- å‰å‘æ›¿æ¢ï¼šæ±‚è§£ Ly = b
    SELECT * FROM solve_lower_triangular
),
backward_substitution AS (
    -- åå‘æ›¿æ¢ï¼šæ±‚è§£ Ux = y
    SELECT * FROM solve_upper_triangular
)
SELECT * FROM backward_substitution;
```

### 6.2 æœ€å°äºŒä¹˜é—®é¢˜

```sql
-- ä½¿ç”¨QRåˆ†è§£æ±‚è§£æœ€å°äºŒä¹˜é—®é¢˜
WITH qr_factors AS (
    -- QRåˆ†è§£ç»“æœ
    SELECT * FROM qr_decomposition_result
),
least_squares_solution AS (
    -- æ±‚è§£ Rx = Q^T b
    SELECT * FROM solve_upper_triangular_system
)
SELECT * FROM least_squares_solution;
```

---

### 6.3 å›¾åƒå‹ç¼©

```sql
-- SVDå›¾åƒå‹ç¼©åº”ç”¨ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'image_matrix') THEN
            CREATE TABLE image_matrix (
                row_idx INTEGER NOT NULL,
                col_idx INTEGER NOT NULL,
                pixel_value NUMERIC NOT NULL,
                PRIMARY KEY (row_idx, col_idx)
            );

            -- æ’å…¥å›¾åƒåƒç´ æ•°æ®ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
            INSERT INTO image_matrix (row_idx, col_idx, pixel_value)
            SELECT
                i, j,
                RANDOM() * 255  -- åƒç´ å€¼0-255
            FROM generate_series(1, 100) i
            CROSS JOIN generate_series(1, 100) j;

            RAISE NOTICE 'å›¾åƒçŸ©é˜µåˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å›¾åƒå‹ç¼©åº”ç”¨å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- SVDå‹ç¼©ï¼šä¿ç•™å‰kä¸ªå¥‡å¼‚å€¼
WITH svd_compression AS (
    SELECT
        -- ç®€åŒ–ï¼šä½¿ç”¨å‰10ä¸ªä¸»æˆåˆ†
        row_idx,
        col_idx,
        pixel_value * 0.9 AS compressed_value  -- ç®€åŒ–å‹ç¼©
    FROM image_matrix
    LIMIT 1000  -- å‹ç¼©åˆ°1000ä¸ªåƒç´ 
)
SELECT
    COUNT(*) AS compressed_pixels,
    AVG(compressed_value) AS avg_pixel_value
FROM svd_compression;
```

### 6.4 æ¨èç³»ç»Ÿ

```sql
-- QRåˆ†è§£åœ¨æ¨èç³»ç»Ÿä¸­çš„åº”ç”¨
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_item_matrix') THEN
            CREATE TABLE user_item_matrix (
                user_id INTEGER NOT NULL,
                item_id INTEGER NOT NULL,
                rating NUMERIC NOT NULL,
                PRIMARY KEY (user_id, item_id)
            );

            -- æ’å…¥ç”¨æˆ·-ç‰©å“è¯„åˆ†çŸ©é˜µ
            INSERT INTO user_item_matrix (user_id, item_id, rating) VALUES
                (1, 1, 5), (1, 2, 4), (1, 3, 3),
                (2, 1, 4), (2, 2, 5), (2, 3, 2),
                (3, 1, 3), (3, 2, 4), (3, 3, 5);

            RAISE NOTICE 'ç”¨æˆ·-ç‰©å“çŸ©é˜µåˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ¨èç³»ç»Ÿåº”ç”¨å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### ç¨€ç–çŸ©é˜µä¼˜åŒ–

```sql
-- ç¨€ç–çŸ©é˜µå­˜å‚¨ä¼˜åŒ–
CREATE INDEX IF NOT EXISTS idx_sparse_matrix ON matrix_data(row_idx, col_idx) WHERE value != 0;
```

### å¹¶è¡Œè®¡ç®—

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;

-- å¹¶è¡ŒçŸ©é˜µä¹˜æ³•
WITH parallel_multiply AS (
    SELECT
        a.row_idx,
        b.col_idx,
        SUM(a.value * b.value) AS product
    FROM matrix_data a
    JOIN matrix_data b ON a.col_idx = b.row_idx
    GROUP BY a.row_idx, b.col_idx
)
SELECT * FROM parallel_multiply;
```

### åˆ†å—ç®—æ³•

```sql
-- åˆ†å—çŸ©é˜µè¿ç®—
WITH block_partition AS (
    SELECT
        row_idx,
        col_idx,
        value,
        (row_idx - 1) / 10 AS block_row,
        (col_idx - 1) / 10 AS block_col
    FROM matrix_data
)
SELECT
    block_row,
    block_col,
    COUNT(*) AS block_size,
    AVG(value) AS block_avg
FROM block_partition
GROUP BY block_row, block_col;
```

### ç¼“å­˜ä¼˜åŒ–

```sql
-- ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜åˆ†è§£ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS lu_decomposition_cache AS
SELECT * FROM lu_decomposition_result;

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY lu_decomposition_cache;
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### ç®—æ³•é€‰æ‹©

1. **LUåˆ†è§£**: é€‚ç”¨äºä¸€èˆ¬çº¿æ€§æ–¹ç¨‹ç»„ï¼Œéœ€è¦è¡Œç½®æ¢
2. **QRåˆ†è§£**: æ•°å€¼ç¨³å®šï¼Œé€‚ç”¨äºæœ€å°äºŒä¹˜é—®é¢˜
3. **SVDåˆ†è§£**: æœ€ç¨³å®šï¼Œé€‚ç”¨äºç—…æ€çŸ©é˜µå’Œé™ç»´
4. **Choleskyåˆ†è§£**: æœ€å¿«ï¼Œä½†ä»…é€‚ç”¨äºæ­£å®šçŸ©é˜µ

### æ•°å€¼ç¨³å®šæ€§

1. **æ¡ä»¶æ•°æ£€æŸ¥**: æ£€æŸ¥çŸ©é˜µæ¡ä»¶æ•°

   ```sql
   -- æ¡ä»¶æ•°è®¡ç®—
   WITH condition_number AS (
       SELECT
           -- ç®€åŒ–ï¼šä½¿ç”¨FrobeniusèŒƒæ•°
           SQRT(SUM(POWER(value, 2))) AS matrix_norm
       FROM matrix_data
   )
   SELECT matrix_norm FROM condition_number;
   ```

2. **è¿­ä»£æ”¹è¿›**: ä½¿ç”¨è¿­ä»£æ”¹è¿›æé«˜ç²¾åº¦

   ```sql
   -- è¿­ä»£æ”¹è¿›ï¼ˆç®€åŒ–ï¼‰
   WITH iterative_refinement AS (
       SELECT
           iteration,
           AVG(ABS(error)) AS avg_error
       FROM refinement_iterations
       GROUP BY iteration
   )
   SELECT * FROM iterative_refinement
   WHERE avg_error < 1e-10;
   ```

3. **é¢„å¤„ç†**: ä½¿ç”¨è¡Œ/åˆ—ç½®æ¢æé«˜æ•°å€¼ç¨³å®šæ€§

   ```sql
   -- è¡Œç½®æ¢ï¼ˆéƒ¨åˆ†ä¸»å…ƒæ³•ï¼‰
   WITH row_permutation AS (
       SELECT
           row_idx,
           col_idx,
           value,
           ROW_NUMBER() OVER (PARTITION BY col_idx ORDER BY ABS(value) DESC) AS permuted_row
       FROM matrix_data
   )
   SELECT * FROM row_permutation;
   ```

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**: ä½¿ç”¨DOå—å’ŒEXCEPTIONè¿›è¡Œé”™è¯¯å¤„ç†
2. **æ•°å€¼ç²¾åº¦**: æ³¨æ„æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
3. **æ€§èƒ½ä¼˜åŒ–**: ä½¿ç”¨ç´¢å¼•å’Œç‰©åŒ–è§†å›¾ä¼˜åŒ–æ€§èƒ½
4. **å†…å­˜ç®¡ç†**: æ³¨æ„å¤§è§„æ¨¡çŸ©é˜µçš„å†…å­˜å ç”¨

---

## ğŸ“ˆ çŸ©é˜µåˆ†è§£æ–¹æ³•å¯¹æ¯”

| åˆ†è§£æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | æ•°å€¼ç¨³å®šæ€§ | é€‚ç”¨åœºæ™¯ |
|---------|-----------|-----------|-----------|---------|
| **LUåˆ†è§£** | $O(n^3)$ | $O(n^2)$ | ä¸­ç­‰ | çº¿æ€§æ–¹ç¨‹ç»„ |
| **QRåˆ†è§£** | $O(n^3)$ | $O(n^2)$ | é«˜ | æœ€å°äºŒä¹˜ã€ç‰¹å¾å€¼ |
| **SVDåˆ†è§£** | $O(n^3)$ | $O(n^2)$ | æœ€é«˜ | é™ç»´ã€ä¼ªé€†ã€ç—…æ€çŸ©é˜µ |
| **Cholesky** | $O(n^3/3)$ | $O(n^2)$ | é«˜ | æ­£å®šçŸ©é˜µ |

---

## ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šçŸ©é˜µå¥‡å¼‚

**åŸå› **ï¼š

- çŸ©é˜µè¡Œåˆ—å¼ä¸º0
- è¡Œæˆ–åˆ—çº¿æ€§ç›¸å…³

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨SVDåˆ†è§£ï¼ˆå¤„ç†å¥‡å¼‚çŸ©é˜µï¼‰
- ä½¿ç”¨ä¼ªé€†
- æ·»åŠ æ­£åˆ™åŒ–é¡¹

### é—®é¢˜2ï¼šæ•°å€¼ä¸ç¨³å®š

**åŸå› **ï¼š

- çŸ©é˜µæ¡ä»¶æ•°å¤§
- èˆå…¥è¯¯å·®ç´¯ç§¯

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨QRæˆ–SVDåˆ†è§£
- è¿­ä»£æ”¹è¿›
- å¢åŠ æ•°å€¼ç²¾åº¦

### é—®é¢˜3ï¼šè®¡ç®—æ…¢

**åŸå› **ï¼š

- çŸ©é˜µè§„æ¨¡å¤§
- æœªä½¿ç”¨ä¼˜åŒ–ç®—æ³•

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨ç¨€ç–çŸ©é˜µ
- å¹¶è¡Œè®¡ç®—
- åˆ†å—ç®—æ³•

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Trefethen, L.N., Bau, D. (1997)**: "Numerical Linear Algebra", SIAM
2. **Golub, G.H., Van Loan, C.F. (2013)**: "Matrix Computations", 4th Edition, Johns Hopkins University Press
3. **Strang, G. (2019)**: "Linear Algebra and Learning from Data", Wellesley-Cambridge Press
4. **Higham, N.J. (2002)**: "Accuracy and Stability of Numerical Algorithms", 2nd Edition, SIAM

---

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **åˆ†è§£æ–¹æ³•é€‰æ‹©**: æ ¹æ®çŸ©é˜µç‰¹å¾é€‰æ‹©åˆé€‚åˆ†è§£æ–¹æ³•ï¼ˆLUã€QRã€SVDã€Choleskyï¼‰
2. **æ•°å€¼ç¨³å®šæ€§**: æ³¨æ„èˆå…¥è¯¯å·®ç´¯ç§¯ï¼Œä½¿ç”¨æ•°å€¼ç¨³å®šçš„ç®—æ³•
3. **å†…å­˜ç®¡ç†**: çŸ©é˜µåˆ†è§£å¯èƒ½å ç”¨å¤§é‡å†…å­˜ï¼Œæ³¨æ„ç›‘æ§
4. **å¥‡å¼‚çŸ©é˜µå¤„ç†**: å¯¹äºå¥‡å¼‚çŸ©é˜µï¼Œä½¿ç”¨SVDæˆ–ä¼ªé€†

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡çŸ©é˜µåˆ†è§£ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«è¡Œåˆ—ç´¢å¼•çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nåˆ†è§£æŸ¥è¯¢å’Œå¤šåˆ†è§£æ–¹æ³•å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡çŸ©é˜µåˆ†è§£ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡LU/QR/SVDåˆ†è§£å’Œå¹¶è¡ŒçŸ©é˜µè¿ç®—

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - çŸ©é˜µåˆ†è§£æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡çŸ©é˜µåˆ†è§£å’Œå¹¶è¡Œçº¿æ€§ä»£æ•°è®¡ç®—

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–çŸ©é˜µåˆ†è§£æŸ¥è¯¢**

```sql
-- ä¸ºçŸ©é˜µåˆ†è§£åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_matrix_decomposition_skip_scan
ON matrix_data(row_idx, col_idx DESC, ABS(value) DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯è¡Œæœ€å¤§ç»å¯¹å€¼çš„å…ƒç´ ï¼ˆç”¨äºä¸»å…ƒé€‰æ‹©ï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (row_idx)
    row_idx,
    col_idx,
    value,
    ABS(value) AS pivot_candidate
FROM matrix_data
ORDER BY row_idx, ABS(value) DESC
LIMIT 50;
```

### é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜çŸ©é˜µåˆ†è§£ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„çŸ©é˜µåˆ†è§£ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜çŸ©é˜µåˆ†è§£ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS matrix_decomposition_cache AS
WITH decomposition_metrics AS (
    SELECT
        row_idx,
        col_idx,
        value,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—åˆ†è§£è´¨é‡æŒ‡æ ‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        ABS(value) / NULLIF(MAX(ABS(value)) OVER (PARTITION BY row_idx), 0) AS normalized_value,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å¯¹è§’ä¼˜åŠ¿ï¼ˆç”¨äºLUåˆ†è§£ä¸»å…ƒé€‰æ‹©ï¼‰
        ABS(value) / NULLIF(SUM(ABS(value)) OVER (PARTITION BY row_idx) - ABS(value), 0) AS diagonal_dominance
    FROM matrix_data
),
decomposition_quality AS (
    SELECT
        row_idx,
        col_idx,
        value,
        ROUND(normalized_value::numeric, 4) AS normalized_value,
        ROUND(diagonal_dominance::numeric, 4) AS diagonal_dominance,
        CASE
            WHEN ABS(value) > MAX(ABS(value)) OVER (PARTITION BY row_idx) * 0.9 THEN 'Strong Pivot Candidate'
            WHEN diagonal_dominance > 0.5 THEN 'Good Pivot Candidate'
            ELSE 'Weak Pivot Candidate'
        END AS pivot_quality
    FROM decomposition_metrics
)
SELECT
    row_idx,
    col_idx,
    ROUND(value::numeric, 4) AS value,
    normalized_value,
    diagonal_dominance,
    pivot_quality
FROM decomposition_quality
ORDER BY row_idx, ABS(value) DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_matrix_decomposition_cache_row_col ON matrix_decomposition_cache(row_idx, col_idx);
CREATE INDEX idx_matrix_decomposition_cache_quality ON matrix_decomposition_cache(pivot_quality, diagonal_dominance DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY matrix_decomposition_cache;
```

**2. å®æ—¶çŸ©é˜µåˆ†è§£ï¼šå¢é‡åˆ†è§£æ›´æ–°**

**å®æ—¶çŸ©é˜µåˆ†è§£**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°åˆ†è§£ç»“æœã€‚

```sql
-- å®æ—¶çŸ©é˜µåˆ†è§£ï¼šå¢é‡åˆ†è§£æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'matrix_decomposition_state') THEN
            CREATE TABLE matrix_decomposition_state (
                matrix_id VARCHAR(100) NOT NULL,
                decomposition_type VARCHAR(20) NOT NULL,  -- 'LU', 'QR', 'SVD', 'Cholesky'
                factor_matrix VARCHAR(10) NOT NULL,  -- 'L', 'U', 'Q', 'R', etc.
                row_idx INTEGER NOT NULL,
                col_idx INTEGER NOT NULL,
                factor_value NUMERIC,
                decomposition_error NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (matrix_id, decomposition_type, factor_matrix, row_idx, col_idx)
            );

            CREATE INDEX idx_matrix_decomposition_state_matrix ON matrix_decomposition_state(matrix_id, decomposition_type, last_updated DESC);
            CREATE INDEX idx_matrix_decomposition_state_updated ON matrix_decomposition_state(last_updated DESC);

            RAISE NOTICE 'çŸ©é˜µåˆ†è§£çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡çŸ©é˜µåˆ†è§£æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡çŸ©é˜µåˆ†è§£æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**3. æ™ºèƒ½çŸ©é˜µåˆ†è§£ï¼šè‡ªé€‚åº”åˆ†è§£æ–¹æ³•é€‰æ‹©**

**æ™ºèƒ½çŸ©é˜µåˆ†è§£**ï¼šæ ¹æ®çŸ©é˜µç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜åˆ†è§£æ–¹æ³•ã€‚

```sql
-- æ™ºèƒ½çŸ©é˜µåˆ†è§£ï¼šè‡ªé€‚åº”åˆ†è§£æ–¹æ³•é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    matrix_size INTEGER;
    is_symmetric BOOLEAN;
    is_positive_definite BOOLEAN;
    recommended_decomposition VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'matrix_data') THEN
            RAISE WARNING 'è¡¨ matrix_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½çŸ©é˜µåˆ†è§£';
            RETURN;
        END IF;

        -- è®¡ç®—çŸ©é˜µç‰¹å¾
        WITH matrix_features AS (
            SELECT
                COUNT(DISTINCT row_idx) AS mat_size,
                COUNT(*) FILTER (WHERE EXISTS (
                    SELECT 1 FROM matrix_data md2
                    WHERE md2.row_idx = matrix_data.col_idx
                    AND md2.col_idx = matrix_data.row_idx
                    AND md2.value = matrix_data.value
                ))::numeric / COUNT(*) AS symmetry_ratio,
                COUNT(*) FILTER (WHERE row_idx = col_idx AND value > 0) = COUNT(DISTINCT row_idx) AS pos_def_candidate
            FROM matrix_data
        )
        SELECT
            mat_size,
            symmetry_ratio > 0.95,
            pos_def_candidate
        INTO matrix_size, is_symmetric, is_positive_definite
        FROM matrix_features;

        -- æ ¹æ®çŸ©é˜µç‰¹å¾è‡ªé€‚åº”é€‰æ‹©åˆ†è§£æ–¹æ³•
        IF is_symmetric AND is_positive_definite THEN
            recommended_decomposition := 'CHOLESKY';  -- å¯¹ç§°æ­£å®šï¼šCholeskyåˆ†è§£
        ELSIF matrix_size < 100 THEN
            recommended_decomposition := 'LU';  -- å°çŸ©é˜µï¼šLUåˆ†è§£
        ELSIF is_symmetric THEN
            recommended_decomposition := 'QR';  -- å¯¹ç§°çŸ©é˜µï¼šQRåˆ†è§£
        ELSE
            recommended_decomposition := 'SVD';  -- ä¸€èˆ¬çŸ©é˜µï¼šSVDåˆ†è§£
        END IF;

        RAISE NOTICE 'çŸ©é˜µå¤§å°: %, å¯¹ç§°: %, æ­£å®š: %, æ¨èåˆ†è§£: %',
            matrix_size, is_symmetric, is_positive_definite, recommended_decomposition;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½çŸ©é˜µåˆ†è§£å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç†è®ºæ¨å¯¼ã€å®ç°å’ŒPostgreSQL 18æ–°ç‰¹æ€§æ”¯æŒï¼‰
