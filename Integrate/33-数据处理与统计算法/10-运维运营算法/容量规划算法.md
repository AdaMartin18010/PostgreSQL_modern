# PostgreSQL å®¹é‡è§„åˆ’ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | å®¹é‡è§„åˆ’ | èµ„æºé¢„æµ‹
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ðŸ“‹ ç›®å½•

- [PostgreSQL å®¹é‡è§„åˆ’ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å®¹é‡è§„åˆ’ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ðŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å®¹é‡è§„åˆ’æ¦‚è¿°](#å®¹é‡è§„åˆ’æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [å®¹é‡è§„åˆ’é—®é¢˜å®šä¹‰](#å®¹é‡è§„åˆ’é—®é¢˜å®šä¹‰)
      - [é¢„æµ‹æ–¹æ³•åˆ†ç±»](#é¢„æµ‹æ–¹æ³•åˆ†ç±»)
      - [é¢„æµ‹æ–¹æ³•é€‰æ‹©](#é¢„æµ‹æ–¹æ³•é€‰æ‹©)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. å¢žé•¿è¶‹åŠ¿åˆ†æž](#1-å¢žé•¿è¶‹åŠ¿åˆ†æž)
    - [1.1 å¢žé•¿è¶‹åŠ¿åˆ†æžåŽŸç†](#11-å¢žé•¿è¶‹åŠ¿åˆ†æžåŽŸç†)
      - [å¢žé•¿è¶‹åŠ¿å®šä¹‰](#å¢žé•¿è¶‹åŠ¿å®šä¹‰)
      - [è¶‹åŠ¿åˆ†æžæ–¹æ³•](#è¶‹åŠ¿åˆ†æžæ–¹æ³•)
    - [1.2 çº¿æ€§è¶‹åŠ¿é¢„æµ‹å®žçŽ°](#12-çº¿æ€§è¶‹åŠ¿é¢„æµ‹å®žçŽ°)
    - [1.3 æŒ‡æ•°å¢žé•¿é¢„æµ‹](#13-æŒ‡æ•°å¢žé•¿é¢„æµ‹)
    - [1.4 å­£èŠ‚æ€§è¶‹åŠ¿åˆ†æž](#14-å­£èŠ‚æ€§è¶‹åŠ¿åˆ†æž)
  - [2. å®¹é‡éœ€æ±‚é¢„æµ‹](#2-å®¹é‡éœ€æ±‚é¢„æµ‹)
    - [2.1 å®¹é‡éœ€æ±‚é¢„æµ‹åŽŸç†](#21-å®¹é‡éœ€æ±‚é¢„æµ‹åŽŸç†)
      - [å®¹é‡éœ€æ±‚å®šä¹‰](#å®¹é‡éœ€æ±‚å®šä¹‰)
      - [é¢„æµ‹æ–¹æ³•](#é¢„æµ‹æ–¹æ³•)
    - [2.2 åŸºäºŽåŽ†å²æ•°æ®çš„é¢„æµ‹å®žçŽ°](#22-åŸºäºŽåŽ†å²æ•°æ®çš„é¢„æµ‹å®žçŽ°)
    - [2.3 å¤šå› ç´ å®¹é‡é¢„æµ‹](#23-å¤šå› ç´ å®¹é‡é¢„æµ‹)
  - [3. èµ„æºåˆ©ç”¨çŽ‡åˆ†æž](#3-èµ„æºåˆ©ç”¨çŽ‡åˆ†æž)
    - [3.1 èµ„æºåˆ©ç”¨çŽ‡åˆ†æžåŽŸç†](#31-èµ„æºåˆ©ç”¨çŽ‡åˆ†æžåŽŸç†)
      - [èµ„æºåˆ©ç”¨çŽ‡å®šä¹‰](#èµ„æºåˆ©ç”¨çŽ‡å®šä¹‰)
      - [åˆ©ç”¨çŽ‡åˆ†æžæ–¹æ³•](#åˆ©ç”¨çŽ‡åˆ†æžæ–¹æ³•)
    - [3.2 èµ„æºä½¿ç”¨è¶‹åŠ¿å®žçŽ°](#32-èµ„æºä½¿ç”¨è¶‹åŠ¿å®žçŽ°)
    - [3.3 åˆ©ç”¨çŽ‡é¢„æµ‹](#33-åˆ©ç”¨çŽ‡é¢„æµ‹)
  - [4. PostgreSQL 18å¹¶è¡Œå®¹é‡è§„åˆ’](#4-postgresql-18å¹¶è¡Œå®¹é‡è§„åˆ’)
    - [4.1 å¹¶è¡Œå®¹é‡è§„åˆ’æ¦‚è¿°](#41-å¹¶è¡Œå®¹é‡è§„åˆ’æ¦‚è¿°)
      - [å¹¶è¡Œå®¹é‡è§„åˆ’é…ç½®](#å¹¶è¡Œå®¹é‡è§„åˆ’é…ç½®)
      - [å¹¶è¡Œå®¹é‡è§„åˆ’å®žçŽ°](#å¹¶è¡Œå®¹é‡è§„åˆ’å®žçŽ°)
  - [5. å®¹é‡è§„åˆ’ä¼˜åŒ–ç­–ç•¥](#5-å®¹é‡è§„åˆ’ä¼˜åŒ–ç­–ç•¥)
    - [5.1 ç´¢å¼•ä¼˜åŒ–](#51-ç´¢å¼•ä¼˜åŒ–)
    - [5.2 é¢„æµ‹æ¨¡åž‹ä¼˜åŒ–](#52-é¢„æµ‹æ¨¡åž‹ä¼˜åŒ–)
    - [5.3 æ‰¹é‡é¢„æµ‹ä¼˜åŒ–](#53-æ‰¹é‡é¢„æµ‹ä¼˜åŒ–)
  - [6. å®žé™…åº”ç”¨æ¡ˆä¾‹](#6-å®žé™…åº”ç”¨æ¡ˆä¾‹)
    - [6.1 æ•°æ®åº“å®¹é‡è§„åˆ’](#61-æ•°æ®åº“å®¹é‡è§„åˆ’)
    - [6.2 å­˜å‚¨å®¹é‡è§„åˆ’](#62-å­˜å‚¨å®¹é‡è§„åˆ’)
    - [6.3 è®¡ç®—èµ„æºè§„åˆ’](#63-è®¡ç®—èµ„æºè§„åˆ’)
    - [6.4 ç»¼åˆå®¹é‡è§„åˆ’](#64-ç»¼åˆå®¹é‡è§„åˆ’)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸Žä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸Žä¼˜åŒ–)
    - [7.1 é¢„æµ‹æ–¹æ³•å¯¹æ¯”](#71-é¢„æµ‹æ–¹æ³•å¯¹æ¯”)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ](#73-å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®žè·µ](#8-æœ€ä½³å®žè·µ)
    - [8.1 é¢„æµ‹æ–¹æ³•é€‰æ‹©](#81-é¢„æµ‹æ–¹æ³•é€‰æ‹©)
    - [8.2 æ•°æ®è´¨é‡](#82-æ•°æ®è´¨é‡)
    - [8.3 é¢„æµ‹ç²¾åº¦](#83-é¢„æµ‹ç²¾åº¦)
    - [8.4 SQLå®žçŽ°æ³¨æ„äº‹é¡¹](#84-sqlå®žçŽ°æ³¨æ„äº‹é¡¹)
    - [8.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢žå¼ºï¼‰](#85-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢žå¼º)
    - [8.6 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢žå¼ºï¼‰](#86-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢žå¼º)
  - [ðŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## å®¹é‡è§„åˆ’æ¦‚è¿°

**å®¹é‡è§„åˆ’ï¼ˆCapacity Planningï¼‰**ç”¨äºŽé¢„æµ‹æœªæ¥èµ„æºéœ€æ±‚ï¼Œç¡®ä¿ç³»ç»Ÿæœ‰è¶³å¤Ÿçš„å®¹é‡æ”¯æŒä¸šåŠ¡å¢žé•¿ï¼Œæ˜¯è¿ç»´ç®¡ç†çš„å…³é”®ã€‚

### ç†è®ºåŸºç¡€

#### å®¹é‡è§„åˆ’é—®é¢˜å®šä¹‰

**å®¹é‡è§„åˆ’é—®é¢˜**ï¼šç»™å®šåŽ†å²èµ„æºä½¿ç”¨æ•°æ®$U = \{u_1, u_2, \ldots, u_T\}$ï¼Œé¢„æµ‹æœªæ¥$k$æœŸçš„èµ„æºéœ€æ±‚$\hat{U} = \{\hat{u}_{T+1}, \hat{u}_{T+2}, \ldots, \hat{u}_{T+k}\}$ï¼š
$$\hat{u}_{T+i} = f(U, i)$$

å…¶ä¸­$f$æ˜¯é¢„æµ‹å‡½æ•°ã€‚

#### é¢„æµ‹æ–¹æ³•åˆ†ç±»

å®¹é‡è§„åˆ’é¢„æµ‹æ–¹æ³•åˆ†ç±»ï¼š

1. **çº¿æ€§å›žå½’**ï¼š
   - æ¨¡åž‹ï¼š$u_t = a + b \cdot t + \epsilon_t$
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
   - é€‚ç”¨ï¼šçº¿æ€§å¢žé•¿è¶‹åŠ¿

2. **æŒ‡æ•°å¢žé•¿**ï¼š
   - æ¨¡åž‹ï¼š$u_t = a \cdot e^{b \cdot t} + \epsilon_t$
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
   - é€‚ç”¨ï¼šæŒ‡æ•°å¢žé•¿è¶‹åŠ¿

3. **ç§»åŠ¨å¹³å‡**ï¼š
   - æ¨¡åž‹ï¼š$\hat{u}_t = \frac{1}{n}\sum_{i=0}^{n-1} u_{t-i}$
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
   - é€‚ç”¨ï¼šå¹³ç¨³è¶‹åŠ¿

4. **å¢žé•¿çŽ‡è®¡ç®—**ï¼š
   - æ¨¡åž‹ï¼š$\hat{u}_{T+i} = u_T \cdot (1 + r)^i$
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$
   - é€‚ç”¨ï¼šæ’å®šå¢žé•¿çŽ‡

#### é¢„æµ‹æ–¹æ³•é€‰æ‹©

é€‰æ‹©é¢„æµ‹æ–¹æ³•çš„è€ƒè™‘å› ç´ ï¼š

1. **æ•°æ®ç‰¹å¾**ï¼šçº¿æ€§è¶‹åŠ¿ç”¨çº¿æ€§å›žå½’ï¼ŒæŒ‡æ•°è¶‹åŠ¿ç”¨æŒ‡æ•°å¢žé•¿
2. **æ—¶é—´èŒƒå›´**ï¼šçŸ­æœŸç”¨ç§»åŠ¨å¹³å‡ï¼Œé•¿æœŸç”¨å›žå½’
3. **ç²¾åº¦è¦æ±‚**ï¼šé«˜ç²¾åº¦ç”¨å¤æ‚æ¨¡åž‹ï¼Œå¿«é€Ÿç”¨ç®€å•æ¨¡åž‹

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | æ•°å­¦å®šä¹‰ | ç”¨é€” | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|---------|------|-----------|-----------|---------|
| **çº¿æ€§å›žå½’** | $u_t = a + b \cdot t$ | è¶‹åŠ¿é¢„æµ‹ | $O(n)$ | $O(1)$ | çº¿æ€§å¢žé•¿ |
| **ç§»åŠ¨å¹³å‡** | $\hat{u}_t = \frac{1}{n}\sum_{i=0}^{n-1} u_{t-i}$ | å¹³æ»‘æ•°æ® | $O(n)$ | $O(1)$ | å¹³ç¨³è¶‹åŠ¿ |
| **å¢žé•¿çŽ‡è®¡ç®—** | $\hat{u}_{T+i} = u_T \cdot (1 + r)^i$ | å¢žé•¿é¢„æµ‹ | $O(1)$ | $O(1)$ | æ’å®šå¢žé•¿ |

---

## 1. å¢žé•¿è¶‹åŠ¿åˆ†æž

### 1.1 å¢žé•¿è¶‹åŠ¿åˆ†æžåŽŸç†

**å¢žé•¿è¶‹åŠ¿åˆ†æžï¼ˆGrowth Trend Analysisï¼‰**è¯†åˆ«èµ„æºä½¿ç”¨çš„å¢žé•¿æ¨¡å¼ã€‚

#### å¢žé•¿è¶‹åŠ¿å®šä¹‰

**å¢žé•¿è¶‹åŠ¿**ï¼šèµ„æºä½¿ç”¨é‡éšæ—¶é—´çš„å˜åŒ–æ¨¡å¼ï¼š

- **çº¿æ€§å¢žé•¿**ï¼š$u_t = a + b \cdot t$
- **æŒ‡æ•°å¢žé•¿**ï¼š$u_t = a \cdot e^{b \cdot t}$
- **å¯¹æ•°å¢žé•¿**ï¼š$u_t = a + b \cdot \ln(t)$

#### è¶‹åŠ¿åˆ†æžæ–¹æ³•

**è¶‹åŠ¿åˆ†æžæ–¹æ³•**ï¼š

1. **çº¿æ€§å›žå½’**ï¼šæ‹Ÿåˆçº¿æ€§æ¨¡åž‹
2. **æŒ‡æ•°æ‹Ÿåˆ**ï¼šæ‹ŸåˆæŒ‡æ•°æ¨¡åž‹
3. **ç§»åŠ¨å¹³å‡**ï¼šå¹³æ»‘æ•°æ®è¯†åˆ«è¶‹åŠ¿

### 1.2 çº¿æ€§è¶‹åŠ¿é¢„æµ‹å®žçŽ°

**çº¿æ€§è¶‹åŠ¿é¢„æµ‹**çš„å®žçŽ°å’Œä½¿ç”¨ã€‚

```sql
-- åˆ›å»ºå®¹é‡åŽ†å²æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE capacity_history CASCADE;
        END IF;

        CREATE TABLE capacity_history (
            date DATE NOT NULL,
            resource_type VARCHAR(50) NOT NULL,
            usage_value NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (date, resource_type)
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO capacity_history (date, resource_type, usage_value) VALUES
            ('2024-01-01', 'storage_gb', 100.0),
            ('2024-01-02', 'storage_gb', 102.5),
            ('2024-01-03', 'storage_gb', 105.0),
            ('2024-01-04', 'storage_gb', 107.5),
            ('2024-01-05', 'storage_gb', 110.0),
            ('2024-01-01', 'cpu_percent', 45.0),
            ('2024-01-02', 'cpu_percent', 46.5),
            ('2024-01-03', 'cpu_percent', 48.0),
            ('2024-01-04', 'cpu_percent', 49.5),
            ('2024-01-05', 'cpu_percent', 51.0);

        RAISE NOTICE 'è¡¨ capacity_history åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ capacity_history å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- çº¿æ€§è¶‹åŠ¿é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œè¶‹åŠ¿é¢„æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œçº¿æ€§è¶‹åŠ¿é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è¶‹åŠ¿é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—çº¿æ€§è¶‹åŠ¿å¹¶é¢„æµ‹æœªæ¥30å¤©
WITH numbered_data AS (
    SELECT
        date,
        resource_type,
        usage_value,
        ROW_NUMBER() OVER (PARTITION BY resource_type ORDER BY date) AS day_num
    FROM capacity_history
),
regression_stats AS (
    SELECT
        resource_type,
        COUNT(*) AS n,
        AVG(day_num) AS avg_day,
        AVG(usage_value) AS avg_usage,
        SUM(day_num * usage_value) AS sum_xy,
        SUM(day_num * day_num) AS sum_x2
    FROM numbered_data
    GROUP BY resource_type
),
regression_coeffs AS (
    SELECT
        resource_type,
        n,
        (sum_xy - n * avg_day * avg_usage) / NULLIF(sum_x2 - n * avg_day * avg_day, 0) AS slope,
        avg_usage - ((sum_xy - n * avg_day * avg_usage) / NULLIF(sum_x2 - n * avg_day * avg_day, 0)) * avg_day AS intercept
    FROM regression_stats
),
future_dates AS (
    SELECT
        resource_type,
        generate_series(
            (SELECT MAX(date) FROM capacity_history) + INTERVAL '1 day',
            (SELECT MAX(date) FROM capacity_history) + INTERVAL '30 days',
            INTERVAL '1 day'
        )::DATE AS future_date,
        ROW_NUMBER() OVER (PARTITION BY resource_type ORDER BY generate_series) + (SELECT MAX(day_num) FROM numbered_data) AS future_day_num
    FROM regression_coeffs
)
SELECT
    fd.future_date,
    fd.resource_type,
    ROUND((rc.slope * fd.future_day_num + rc.intercept)::numeric, 2) AS predicted_usage
FROM future_dates fd
JOIN regression_coeffs rc ON fd.resource_type = rc.resource_type
ORDER BY fd.resource_type, fd.future_date;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    resource_type,
    AVG(usage_value) AS avg_usage
FROM capacity_history
GROUP BY resource_type;
```

---

### 1.3 æŒ‡æ•°å¢žé•¿é¢„æµ‹

**æŒ‡æ•°å¢žé•¿é¢„æµ‹**ï¼šé¢„æµ‹æŒ‡æ•°å¢žé•¿è¶‹åŠ¿ã€‚

```sql
-- æŒ‡æ•°å¢žé•¿é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡ŒæŒ‡æ•°å¢žé•¿é¢„æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡ŒæŒ‡æ•°å¢žé•¿é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŒ‡æ•°å¢žé•¿é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æŒ‡æ•°å¢žé•¿é¢„æµ‹ï¼šä½¿ç”¨å¯¹æ•°çº¿æ€§å›žå½’
WITH numbered_data AS (
    SELECT
        date,
        resource_type,
        usage_value,
        ROW_NUMBER() OVER (PARTITION BY resource_type ORDER BY date) AS day_num
    FROM capacity_history
    WHERE usage_value > 0
),
log_regression AS (
    SELECT
        resource_type,
        COUNT(*) AS n,
        AVG(day_num) AS avg_day,
        AVG(LN(usage_value)) AS avg_log_usage,
        SUM(day_num * LN(usage_value)) AS sum_xy,
        SUM(day_num * day_num) AS sum_x2
    FROM numbered_data
    GROUP BY resource_type
),
regression_coeffs AS (
    SELECT
        resource_type,
        (sum_xy - n * avg_day * avg_log_usage) / NULLIF(sum_x2 - n * avg_day * avg_day, 0) AS growth_rate,
        EXP(avg_log_usage - ((sum_xy - n * avg_day * avg_log_usage) / NULLIF(sum_x2 - n * avg_day * avg_day, 0)) * avg_day) AS initial_value
    FROM log_regression
),
future_predictions AS (
    SELECT
        resource_type,
        generate_series(
            (SELECT MAX(date) FROM capacity_history) + INTERVAL '1 day',
            (SELECT MAX(date) FROM capacity_history) + INTERVAL '30 days',
            INTERVAL '1 day'
        )::DATE AS future_date,
        ROW_NUMBER() OVER (PARTITION BY resource_type ORDER BY generate_series) AS future_day_num
    FROM regression_coeffs
)
SELECT
    fp.future_date,
    fp.resource_type,
    ROUND((rc.initial_value * EXP(rc.growth_rate * (fp.future_day_num + (SELECT MAX(day_num) FROM numbered_data))))::numeric, 2) AS predicted_usage
FROM future_predictions fp
JOIN regression_coeffs rc ON fp.resource_type = rc.resource_type
ORDER BY fp.resource_type, fp.future_date;
```

### 1.4 å­£èŠ‚æ€§è¶‹åŠ¿åˆ†æž

**å­£èŠ‚æ€§è¶‹åŠ¿åˆ†æž**ï¼šè¯†åˆ«å­£èŠ‚æ€§æ¨¡å¼ã€‚

```sql
-- å­£èŠ‚æ€§è¶‹åŠ¿åˆ†æžï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ†æžå­£èŠ‚æ€§è¶‹åŠ¿';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹åˆ†æžå­£èŠ‚æ€§è¶‹åŠ¿';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å­£èŠ‚æ€§è¶‹åŠ¿åˆ†æžå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å­£èŠ‚æ€§è¶‹åŠ¿åˆ†æžï¼šè¯†åˆ«å‘¨æœŸæ€§æ¨¡å¼
WITH monthly_patterns AS (
    SELECT
        resource_type,
        EXTRACT(MONTH FROM date) AS month,
        AVG(usage_value) AS avg_monthly_usage
    FROM capacity_history
    GROUP BY resource_type, EXTRACT(MONTH FROM date)
),
seasonal_index AS (
    SELECT
        resource_type,
        month,
        avg_monthly_usage,
        avg_monthly_usage / AVG(avg_monthly_usage) OVER (PARTITION BY resource_type) AS seasonal_factor
    FROM monthly_patterns
)
SELECT
    resource_type,
    month,
    ROUND(avg_monthly_usage::numeric, 2) AS avg_monthly_usage,
    ROUND(seasonal_factor::numeric, 4) AS seasonal_factor,
    CASE
        WHEN seasonal_factor > 1.1 THEN 'Peak Season'
        WHEN seasonal_factor < 0.9 THEN 'Low Season'
        ELSE 'Normal Season'
    END AS season_type
FROM seasonal_index
ORDER BY resource_type, month;
```

---

## 2. å®¹é‡éœ€æ±‚é¢„æµ‹

### 2.1 å®¹é‡éœ€æ±‚é¢„æµ‹åŽŸç†

**å®¹é‡éœ€æ±‚é¢„æµ‹ï¼ˆCapacity Demand Forecastingï¼‰**é¢„æµ‹æœªæ¥èµ„æºéœ€æ±‚ã€‚

#### å®¹é‡éœ€æ±‚å®šä¹‰

**å®¹é‡éœ€æ±‚**ï¼šæœªæ¥$k$æœŸçš„èµ„æºéœ€æ±‚ï¼š
$$\hat{U}_{T+k} = f(U_1, U_2, \ldots, U_T, k)$$

å…¶ä¸­$f$æ˜¯é¢„æµ‹å‡½æ•°ã€‚

#### é¢„æµ‹æ–¹æ³•

**é¢„æµ‹æ–¹æ³•**ï¼š

1. **åŽ†å²å¢žé•¿çŽ‡**ï¼šåŸºäºŽåŽ†å²å¢žé•¿çŽ‡å¤–æŽ¨
2. **å›žå½’æ¨¡åž‹**ï¼šä½¿ç”¨å›žå½’æ¨¡åž‹é¢„æµ‹
3. **æ—¶é—´åºåˆ—**ï¼šä½¿ç”¨æ—¶é—´åºåˆ—æ¨¡åž‹

### 2.2 åŸºäºŽåŽ†å²æ•°æ®çš„é¢„æµ‹å®žçŽ°

**åŸºäºŽåŽ†å²æ•°æ®çš„é¢„æµ‹**çš„å®žçŽ°å’Œä½¿ç”¨ã€‚

```sql
-- å®¹é‡éœ€æ±‚é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå®¹é‡éœ€æ±‚é¢„æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå®¹é‡éœ€æ±‚é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¹é‡éœ€æ±‚é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—å¢žé•¿çŽ‡å¹¶é¢„æµ‹æœªæ¥éœ€æ±‚
WITH monthly_aggregates AS (
    SELECT
        DATE_TRUNC('month', date) AS month,
        resource_type,
        AVG(usage_value) AS avg_usage
    FROM capacity_history
    GROUP BY DATE_TRUNC('month', date), resource_type
),
growth_rates AS (
    SELECT
        resource_type,
        month,
        avg_usage,
        LAG(avg_usage) OVER (PARTITION BY resource_type ORDER BY month) AS prev_usage,
        CASE
            WHEN LAG(avg_usage) OVER (PARTITION BY resource_type ORDER BY month) = 0 THEN NULL
            ELSE (avg_usage - LAG(avg_usage) OVER (PARTITION BY resource_type ORDER BY month)) /
                 LAG(avg_usage) OVER (PARTITION BY resource_type ORDER BY month)
        END AS growth_rate
    FROM monthly_aggregates
),
avg_growth_rate AS (
    SELECT
        resource_type,
        AVG(growth_rate) AS avg_growth_rate,
        MAX(month) AS last_month,
        MAX(avg_usage) AS last_usage
    FROM growth_rates
    WHERE growth_rate IS NOT NULL
    GROUP BY resource_type
),
future_predictions AS (
    SELECT
        resource_type,
        last_month + (generate_series(1, 12) || ' months')::INTERVAL AS future_month,
        last_usage * POWER(1 + COALESCE(avg_growth_rate, 0), generate_series(1, 12)) AS predicted_usage
    FROM avg_growth_rate
)
SELECT
    resource_type,
    future_month::DATE AS prediction_month,
    ROUND(predicted_usage::numeric, 2) AS predicted_usage,
    ROUND((predicted_usage - LAG(predicted_usage) OVER (PARTITION BY resource_type ORDER BY future_month))::numeric, 2) AS monthly_increase
FROM future_predictions
ORDER BY resource_type, future_month;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('month', date) AS month,
    resource_type,
    AVG(usage_value) AS avg_usage
FROM capacity_history
GROUP BY DATE_TRUNC('month', date), resource_type
ORDER BY month, resource_type;
```

---

### 2.3 å¤šå› ç´ å®¹é‡é¢„æµ‹

**å¤šå› ç´ å®¹é‡é¢„æµ‹**ï¼šè€ƒè™‘å¤šä¸ªå› ç´ çš„å®¹é‡é¢„æµ‹ã€‚

```sql
-- å¤šå› ç´ å®¹é‡é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_factors') THEN
            RAISE WARNING 'è¡¨ capacity_factors ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE capacity_factors (
                date DATE NOT NULL,
                resource_type VARCHAR(50) NOT NULL,
                usage_value NUMERIC(10, 2) NOT NULL,
                user_count INTEGER,
                transaction_count INTEGER,
                PRIMARY KEY (date, resource_type)
            );

            INSERT INTO capacity_factors (date, resource_type, usage_value, user_count, transaction_count) VALUES
                ('2024-01-01', 'storage_gb', 100.0, 1000, 50000),
                ('2024-01-02', 'storage_gb', 102.5, 1050, 52000),
                ('2024-01-03', 'storage_gb', 105.0, 1100, 54000);

            RAISE NOTICE 'è¡¨ capacity_factors åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå¤šå› ç´ å®¹é‡é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¤šå› ç´ å®¹é‡é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¤šå› ç´ å®¹é‡é¢„æµ‹ï¼šè€ƒè™‘ç”¨æˆ·æ•°å’Œäº‹åŠ¡æ•°
WITH factor_correlation AS (
    SELECT
        resource_type,
        AVG(usage_value) AS avg_usage,
        AVG(user_count) AS avg_users,
        AVG(transaction_count) AS avg_transactions,
        SUM((usage_value - AVG(usage_value) OVER (PARTITION BY resource_type)) *
            (user_count - AVG(user_count) OVER (PARTITION BY resource_type))) /
        NULLIF(COUNT(*) * STDDEV(usage_value) OVER (PARTITION BY resource_type) *
               STDDEV(user_count) OVER (PARTITION BY resource_type), 0) AS user_correlation,
        SUM((usage_value - AVG(usage_value) OVER (PARTITION BY resource_type)) *
            (transaction_count - AVG(transaction_count) OVER (PARTITION BY resource_type))) /
        NULLIF(COUNT(*) * STDDEV(usage_value) OVER (PARTITION BY resource_type) *
               STDDEV(transaction_count) OVER (PARTITION BY resource_type), 0) AS transaction_correlation
    FROM capacity_factors
    GROUP BY resource_type
),
future_factors AS (
    SELECT
        resource_type,
        generate_series(1, 30) AS future_day,
        -- å‡è®¾ç”¨æˆ·æ•°å’Œäº‹åŠ¡æ•°æŒ‰5%å¢žé•¿
        avg_users * POWER(1.05, generate_series(1, 30)) AS predicted_users,
        avg_transactions * POWER(1.05, generate_series(1, 30)) AS predicted_transactions
    FROM factor_correlation
)
SELECT
    ff.resource_type,
    ff.future_day,
    ROUND(ff.predicted_users::numeric, 0) AS predicted_users,
    ROUND(ff.predicted_transactions::numeric, 0) AS predicted_transactions,
    ROUND((fc.avg_usage + fc.user_correlation * (ff.predicted_users - fc.avg_users) +
           fc.transaction_correlation * (ff.predicted_transactions - fc.avg_transactions))::numeric, 2) AS predicted_usage
FROM future_factors ff
JOIN factor_correlation fc ON ff.resource_type = fc.resource_type
ORDER BY ff.resource_type, ff.future_day;
```

---

## 3. èµ„æºåˆ©ç”¨çŽ‡åˆ†æž

### 3.1 èµ„æºåˆ©ç”¨çŽ‡åˆ†æžåŽŸç†

**èµ„æºåˆ©ç”¨çŽ‡åˆ†æžï¼ˆResource Utilization Analysisï¼‰**åˆ†æžèµ„æºåˆ©ç”¨çŽ‡çš„å˜åŒ–è¶‹åŠ¿ã€‚

#### èµ„æºåˆ©ç”¨çŽ‡å®šä¹‰

**èµ„æºåˆ©ç”¨çŽ‡**ï¼šèµ„æºä½¿ç”¨é‡ä¸Žæ€»å®¹é‡çš„æ¯”å€¼ï¼š
$$\text{Utilization} = \frac{\text{Used}}{\text{Total}} \times 100\%$$

#### åˆ©ç”¨çŽ‡åˆ†æžæ–¹æ³•

**åˆ©ç”¨çŽ‡åˆ†æžæ–¹æ³•**ï¼š

1. **è¶‹åŠ¿åˆ†æž**ï¼šè¯†åˆ«åˆ©ç”¨çŽ‡å˜åŒ–è¶‹åŠ¿
2. **å³°å€¼åˆ†æž**ï¼šè¯†åˆ«åˆ©ç”¨çŽ‡å³°å€¼
3. **é¢„æµ‹åˆ†æž**ï¼šé¢„æµ‹æœªæ¥åˆ©ç”¨çŽ‡

### 3.2 èµ„æºä½¿ç”¨è¶‹åŠ¿å®žçŽ°

**èµ„æºä½¿ç”¨è¶‹åŠ¿**çš„å®žçŽ°å’Œä½¿ç”¨ã€‚

```sql
-- èµ„æºä½¿ç”¨è¶‹åŠ¿åˆ†æžï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ†æžèµ„æºä½¿ç”¨è¶‹åŠ¿';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹åˆ†æžèµ„æºä½¿ç”¨è¶‹åŠ¿';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'èµ„æºä½¿ç”¨è¶‹åŠ¿åˆ†æžå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åˆ†æžèµ„æºä½¿ç”¨è¶‹åŠ¿
WITH usage_trends AS (
    SELECT
        date,
        resource_type,
        usage_value,
        AVG(usage_value) OVER (
            PARTITION BY resource_type
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS moving_avg_7d,
        STDDEV(usage_value) OVER (
            PARTITION BY resource_type
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS moving_std_7d
    FROM capacity_history
),
trend_analysis AS (
    SELECT
        date,
        resource_type,
        usage_value,
        moving_avg_7d,
        moving_std_7d,
        CASE
            WHEN usage_value > moving_avg_7d + 2 * moving_std_7d THEN 'Spike'
            WHEN usage_value < moving_avg_7d - 2 * moving_std_7d THEN 'Drop'
            ELSE 'Normal'
        END AS trend_status
    FROM usage_trends
    WHERE moving_avg_7d IS NOT NULL
)
SELECT
    date,
    resource_type,
    ROUND(usage_value::numeric, 2) AS usage_value,
    ROUND(moving_avg_7d::numeric, 2) AS moving_avg,
    ROUND(moving_std_7d::numeric, 2) AS moving_std,
    trend_status
FROM trend_analysis
ORDER BY resource_type, date;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    resource_type,
    AVG(usage_value) OVER (PARTITION BY resource_type ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg
FROM capacity_history
ORDER BY resource_type, date;
```

---

### 3.3 åˆ©ç”¨çŽ‡é¢„æµ‹

**åˆ©ç”¨çŽ‡é¢„æµ‹**ï¼šé¢„æµ‹æœªæ¥èµ„æºåˆ©ç”¨çŽ‡ã€‚

```sql
-- åˆ©ç”¨çŽ‡é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•é¢„æµ‹åˆ©ç”¨çŽ‡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹é¢„æµ‹åˆ©ç”¨çŽ‡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ©ç”¨çŽ‡é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åˆ©ç”¨çŽ‡é¢„æµ‹ï¼šé¢„æµ‹æœªæ¥åˆ©ç”¨çŽ‡è¶‹åŠ¿
WITH utilization_trends AS (
    SELECT
        date,
        resource_type,
        usage_value,
        -- å‡è®¾æ€»å®¹é‡ä¸ºå½“å‰æœ€å¤§å€¼çš„1.5å€
        MAX(usage_value) OVER (PARTITION BY resource_type) * 1.5 AS total_capacity,
        usage_value / (MAX(usage_value) OVER (PARTITION BY resource_type) * 1.5) AS utilization_rate
    FROM capacity_history
),
utilization_growth AS (
    SELECT
        resource_type,
        AVG(utilization_rate) AS avg_utilization,
        (MAX(utilization_rate) - MIN(utilization_rate)) / COUNT(*) AS daily_growth_rate
    FROM utilization_trends
    GROUP BY resource_type
),
future_utilization AS (
    SELECT
        resource_type,
        generate_series(1, 90) AS future_day,
        avg_utilization + daily_growth_rate * generate_series(1, 90) AS predicted_utilization
    FROM utilization_growth
)
SELECT
    resource_type,
    future_day,
    ROUND((predicted_utilization * 100)::numeric, 2) AS predicted_utilization_pct,
    CASE
        WHEN predicted_utilization > 0.9 THEN 'Critical - Need Expansion'
        WHEN predicted_utilization > 0.8 THEN 'Warning - Plan Expansion'
        WHEN predicted_utilization > 0.7 THEN 'Monitor Closely'
        ELSE 'Normal'
    END AS capacity_status
FROM future_utilization
WHERE predicted_utilization > 0.7
ORDER BY resource_type, future_day;
```

---

## 4. PostgreSQL 18å¹¶è¡Œå®¹é‡è§„åˆ’

### 4.1 å¹¶è¡Œå®¹é‡è§„åˆ’æ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œå®¹é‡è§„åˆ’**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡å®¹é‡è§„åˆ’é¢„æµ‹çš„æ€§èƒ½ã€‚

#### å¹¶è¡Œå®¹é‡è§„åˆ’é…ç½®

```sql
-- é…ç½®å¹¶è¡Œå®¹é‡è§„åˆ’å‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œå®¹é‡è§„åˆ’å‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå®¹é‡è§„åˆ’é…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œå®¹é‡è§„åˆ’å®žçŽ°

```sql
-- å¹¶è¡Œå®¹é‡è§„åˆ’ï¼šå¤§è§„æ¨¡èµ„æºä½¿ç”¨é¢„æµ‹ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œå®¹é‡è§„åˆ’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå®¹é‡è§„åˆ’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œå®¹é‡éœ€æ±‚é¢„æµ‹
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_history AS (
    SELECT
        resource_type,
        date,
        usage_value
    FROM capacity_history
    WHERE date >= CURRENT_DATE - INTERVAL '1 year'
),
parallel_trends AS (
    SELECT
        resource_type,
        AVG(usage_value) AS avg_usage,
        (MAX(usage_value) - MIN(usage_value)) / COUNT(*) AS daily_growth_rate
    FROM parallel_history
    GROUP BY resource_type
),
parallel_projections AS (
    SELECT
        resource_type,
        generate_series(1, 90) AS future_day,
        avg_usage + daily_growth_rate * generate_series(1, 90) AS predicted_usage
    FROM parallel_trends
)
SELECT
    resource_type,
    future_day,
    ROUND(predicted_usage::numeric, 2) AS predicted_usage,
    CASE
        WHEN predicted_usage > 90 THEN 'Critical - Need Upgrade'
        WHEN predicted_usage > 80 THEN 'Warning - Plan Upgrade'
        ELSE 'Normal'
    END AS capacity_status
FROM parallel_projections
WHERE predicted_usage > 70
ORDER BY resource_type, future_day;
```

---

## 5. å®¹é‡è§„åˆ’ä¼˜åŒ–ç­–ç•¥

### 5.1 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºå®¹é‡è§„åˆ’æŸ¥è¯¢åˆ›å»ºåˆé€‚çš„ç´¢å¼•ã€‚

```sql
-- ç´¢å¼•ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        -- å®¹é‡åŽ†å²è¡¨ç´¢å¼•
        CREATE INDEX IF NOT EXISTS idx_capacity_history_date_resource
        ON capacity_history(date, resource_type);

        CREATE INDEX IF NOT EXISTS idx_capacity_history_resource_date
        ON capacity_history(resource_type, date);

        RAISE NOTICE 'å®¹é‡è§„åˆ’ç´¢å¼•åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç´¢å¼•åˆ›å»ºå¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 é¢„æµ‹æ¨¡åž‹ä¼˜åŒ–

**é¢„æµ‹æ¨¡åž‹ä¼˜åŒ–**ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜é¢„æµ‹ç»“æžœã€‚

```sql
-- é¢„æµ‹æ¨¡åž‹ä¼˜åŒ–ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜é¢„æµ‹ç»“æžœ
CREATE MATERIALIZED VIEW IF NOT EXISTS capacity_predictions_cache AS
WITH numbered_data AS (
    SELECT
        date,
        resource_type,
        usage_value,
        ROW_NUMBER() OVER (PARTITION BY resource_type ORDER BY date) AS day_num
    FROM capacity_history
),
regression_stats AS (
    SELECT
        resource_type,
        COUNT(*) AS n,
        AVG(day_num) AS avg_day,
        AVG(usage_value) AS avg_usage,
        SUM(day_num * usage_value) AS sum_xy,
        SUM(day_num * day_num) AS sum_x2
    FROM numbered_data
    GROUP BY resource_type
)
SELECT
    resource_type,
    (sum_xy - n * avg_day * avg_usage) / NULLIF(sum_x2 - n * avg_day * avg_day, 0) AS slope,
    avg_usage - ((sum_xy - n * avg_day * avg_usage) / NULLIF(sum_x2 - n * avg_day * avg_day, 0)) * avg_day AS intercept
FROM regression_stats;

CREATE INDEX IF NOT EXISTS idx_capacity_predictions_cache_resource
ON capacity_predictions_cache(resource_type);

-- åˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY capacity_predictions_cache;
```

### 5.3 æ‰¹é‡é¢„æµ‹ä¼˜åŒ–

**æ‰¹é‡é¢„æµ‹ä¼˜åŒ–**ï¼šæ‰¹é‡é¢„æµ‹å¤šä¸ªèµ„æºã€‚

```sql
-- æ‰¹é‡é¢„æµ‹ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        SET work_mem = '512MB';
        SET max_parallel_workers_per_gather = 4;
        RAISE NOTICE 'æ‰¹é‡é¢„æµ‹ä¼˜åŒ–é…ç½®å·²è®¾ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ‰¹é‡é¢„æµ‹ä¼˜åŒ–å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 6. å®žé™…åº”ç”¨æ¡ˆä¾‹

### 6.1 æ•°æ®åº“å®¹é‡è§„åˆ’

**æ•°æ®åº“å®¹é‡è§„åˆ’**é¢„æµ‹æ•°æ®åº“å­˜å‚¨å’Œæ€§èƒ½éœ€æ±‚ã€‚

```sql
-- æ•°æ®åº“å®¹é‡è§„åˆ’ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'database_metrics') THEN
            RAISE WARNING 'è¡¨ database_metrics ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE database_metrics (
                date DATE NOT NULL,
                database_name VARCHAR(100) NOT NULL,
                size_gb NUMERIC(10, 2) NOT NULL,
                table_count INTEGER NOT NULL,
                index_count INTEGER NOT NULL,
                query_count BIGINT NOT NULL,
                PRIMARY KEY (date, database_name)
            );

            INSERT INTO database_metrics (date, database_name, size_gb, table_count, index_count, query_count) VALUES
                ('2024-01-01', 'db_prod', 500.0, 150, 200, 1000000),
                ('2024-01-02', 'db_prod', 502.5, 152, 202, 1050000),
                ('2024-01-03', 'db_prod', 505.0, 154, 204, 1100000);

            RAISE NOTICE 'è¡¨ database_metrics åˆ›å»ºæˆåŠŸ';
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œæ•°æ®åº“å®¹é‡è§„åˆ’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ•°æ®åº“å®¹é‡è§„åˆ’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- é¢„æµ‹æ•°æ®åº“æœªæ¥å®¹é‡éœ€æ±‚
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH growth_analysis AS (
    SELECT
        database_name,
        date,
        size_gb,
        LAG(size_gb) OVER (PARTITION BY database_name ORDER BY date) AS prev_size,
        (size_gb - LAG(size_gb) OVER (PARTITION BY database_name ORDER BY date)) /
        NULLIF(LAG(size_gb) OVER (PARTITION BY database_name ORDER BY date), 0) AS daily_growth_rate
    FROM database_metrics
),
avg_growth AS (
    SELECT
        database_name,
        AVG(daily_growth_rate) AS avg_daily_growth,
        MAX(date) AS last_date,
        MAX(size_gb) AS last_size
    FROM growth_analysis
    WHERE daily_growth_rate IS NOT NULL
    GROUP BY database_name
),
future_capacity AS (
    SELECT
        database_name,
        last_date + (generate_series(1, 90) || ' days')::INTERVAL AS future_date,
        last_size * POWER(1 + COALESCE(avg_daily_growth, 0), generate_series(1, 90)) AS predicted_size_gb
    FROM avg_growth
)
SELECT
    database_name,
    future_date::DATE AS prediction_date,
    ROUND(predicted_size_gb::numeric, 2) AS predicted_size_gb,
    CASE
        WHEN predicted_size_gb > 1000 THEN 'Critical - Need Expansion'
        WHEN predicted_size_gb > 800 THEN 'Warning - Monitor Closely'
        ELSE 'Normal'
    END AS capacity_status
FROM future_capacity
WHERE future_date <= (SELECT MAX(last_date) FROM avg_growth) + INTERVAL '90 days'
ORDER BY database_name, future_date;
```

### 6.2 å­˜å‚¨å®¹é‡è§„åˆ’

**å­˜å‚¨å®¹é‡è§„åˆ’**ï¼šé¢„æµ‹å­˜å‚¨å®¹é‡éœ€æ±‚ã€‚

```sql
-- å­˜å‚¨å®¹é‡è§„åˆ’ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå­˜å‚¨å®¹é‡è§„åˆ’';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå­˜å‚¨å®¹é‡è§„åˆ’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å­˜å‚¨å®¹é‡è§„åˆ’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å­˜å‚¨å®¹é‡è§„åˆ’ï¼šé¢„æµ‹å­˜å‚¨éœ€æ±‚
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH storage_data AS (
    SELECT
        date,
        usage_value AS storage_gb
    FROM capacity_history
    WHERE resource_type = 'storage_gb'
),
storage_growth AS (
    SELECT
        date,
        storage_gb,
        LAG(storage_gb) OVER (ORDER BY date) AS prev_storage,
        (storage_gb - LAG(storage_gb) OVER (ORDER BY date)) /
        NULLIF(LAG(storage_gb) OVER (ORDER BY date), 0) AS daily_growth_rate
    FROM storage_data
),
avg_growth_rate AS (
    SELECT
        AVG(daily_growth_rate) AS avg_daily_growth,
        MAX(date) AS last_date,
        MAX(storage_gb) AS last_storage
    FROM storage_growth
    WHERE daily_growth_rate IS NOT NULL
),
future_storage AS (
    SELECT
        last_date + (generate_series(1, 365) || ' days')::INTERVAL AS future_date,
        last_storage * POWER(1 + COALESCE(avg_daily_growth, 0), generate_series(1, 365)) AS predicted_storage_gb
    FROM avg_growth_rate
)
SELECT
    future_date::DATE AS prediction_date,
    ROUND(predicted_storage_gb::numeric, 2) AS predicted_storage_gb,
    ROUND((predicted_storage_gb - LAG(predicted_storage_gb) OVER (ORDER BY future_date))::numeric, 2) AS daily_increase_gb,
    CASE
        WHEN predicted_storage_gb > 2000 THEN 'Critical - Need Expansion'
        WHEN predicted_storage_gb > 1500 THEN 'Warning - Plan Expansion'
        ELSE 'Normal'
    END AS capacity_status
FROM future_storage
WHERE EXTRACT(DAY FROM future_date) = 1  -- æ¯æœˆç¬¬ä¸€å¤©
ORDER BY future_date;
```

### 6.3 è®¡ç®—èµ„æºè§„åˆ’

**è®¡ç®—èµ„æºè§„åˆ’**ï¼šé¢„æµ‹è®¡ç®—èµ„æºéœ€æ±‚ã€‚

```sql
-- è®¡ç®—èµ„æºè§„åˆ’ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œè®¡ç®—èµ„æºè§„åˆ’';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œè®¡ç®—èµ„æºè§„åˆ’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è®¡ç®—èµ„æºè§„åˆ’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—èµ„æºè§„åˆ’ï¼šé¢„æµ‹CPUå’Œå†…å­˜éœ€æ±‚
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH compute_resources AS (
    SELECT
        date,
        resource_type,
        usage_value
    FROM capacity_history
    WHERE resource_type IN ('cpu_percent', 'memory_percent')
),
resource_growth AS (
    SELECT
        date,
        resource_type,
        usage_value,
        AVG(usage_value) OVER (
            PARTITION BY resource_type
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS moving_avg_7d
    FROM compute_resources
),
growth_trends AS (
    SELECT
        resource_type,
        AVG(usage_value) AS avg_usage,
        (MAX(usage_value) - MIN(usage_value)) / COUNT(*) AS daily_growth_rate
    FROM resource_growth
    GROUP BY resource_type
),
future_compute AS (
    SELECT
        resource_type,
        generate_series(1, 90) AS future_day,
        avg_usage + daily_growth_rate * generate_series(1, 90) AS predicted_usage
    FROM growth_trends
)
SELECT
    resource_type,
    future_day,
    ROUND(predicted_usage::numeric, 2) AS predicted_usage,
    CASE
        WHEN predicted_usage > 90 THEN 'Critical - Need Upgrade'
        WHEN predicted_usage > 80 THEN 'Warning - Plan Upgrade'
        WHEN predicted_usage > 70 THEN 'Monitor Closely'
        ELSE 'Normal'
    END AS resource_status
FROM future_compute
WHERE predicted_usage > 70
ORDER BY resource_type, future_day;
```

### 6.4 ç»¼åˆå®¹é‡è§„åˆ’

**ç»¼åˆå®¹é‡è§„åˆ’**ï¼šç»¼åˆè€ƒè™‘å¤šä¸ªèµ„æºçš„å®¹é‡è§„åˆ’ã€‚

```sql
-- ç»¼åˆå®¹é‡è§„åˆ’ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œç»¼åˆå®¹é‡è§„åˆ’';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œç»¼åˆå®¹é‡è§„åˆ’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç»¼åˆå®¹é‡è§„åˆ’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç»¼åˆå®¹é‡è§„åˆ’ï¼šç»¼åˆåˆ†æžå¤šä¸ªèµ„æº
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH resource_summary AS (
    SELECT
        resource_type,
        MAX(date) AS last_date,
        MAX(usage_value) AS max_usage,
        AVG(usage_value) AS avg_usage,
        (MAX(usage_value) - MIN(usage_value)) / COUNT(*) AS daily_growth_rate
    FROM capacity_history
    GROUP BY resource_type
),
future_projections AS (
    SELECT
        resource_type,
        last_date + INTERVAL '90 days' AS projection_date,
        max_usage * POWER(1 + COALESCE(daily_growth_rate, 0), 90) AS projected_usage
    FROM resource_summary
),
capacity_assessment AS (
    SELECT
        resource_type,
        projection_date,
        ROUND(projected_usage::numeric, 2) AS projected_usage,
        CASE
            WHEN resource_type = 'storage_gb' AND projected_usage > 2000 THEN 'Critical'
            WHEN resource_type = 'storage_gb' AND projected_usage > 1500 THEN 'Warning'
            WHEN resource_type = 'cpu_percent' AND projected_usage > 90 THEN 'Critical'
            WHEN resource_type = 'cpu_percent' AND projected_usage > 80 THEN 'Warning'
            WHEN resource_type = 'memory_percent' AND projected_usage > 95 THEN 'Critical'
            WHEN resource_type = 'memory_percent' AND projected_usage > 85 THEN 'Warning'
            ELSE 'Normal'
        END AS capacity_status
    FROM future_projections
)
SELECT
    resource_type,
    projection_date,
    projected_usage,
    capacity_status,
    CASE
        WHEN capacity_status = 'Critical' THEN 'Immediate expansion required'
        WHEN capacity_status = 'Warning' THEN 'Plan expansion within 30 days'
        ELSE 'Monitor and review quarterly'
    END AS action_required
FROM capacity_assessment
WHERE capacity_status != 'Normal'
ORDER BY
    CASE capacity_status WHEN 'Critical' THEN 1 WHEN 'Warning' THEN 2 ELSE 3 END,
    resource_type;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸Žä¼˜åŒ–

### 7.1 é¢„æµ‹æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | æ•°å­¦å®šä¹‰ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|-----------|-----------|---------|------|------|
| **çº¿æ€§å›žå½’** | $u_t = a + b \cdot t$ | $O(n)$ | $O(1)$ | çº¿æ€§å¢žé•¿ | ç®€å•ã€å¿«é€Ÿ | å‡è®¾çº¿æ€§ |
| **æŒ‡æ•°å¢žé•¿** | $u_t = a \cdot e^{b \cdot t}$ | $O(n)$ | $O(1)$ | æŒ‡æ•°å¢žé•¿ | é€‚åˆå¿«é€Ÿå¢žé•¿ | å¯èƒ½è¿‡åº¦é¢„æµ‹ |
| **ç§»åŠ¨å¹³å‡** | $\hat{u}_t = \frac{1}{n}\sum_{i=0}^{n-1} u_{t-i}$ | $O(n)$ | $O(1)$ | å¹³ç¨³è¶‹åŠ¿ | å¹³æ»‘ | æ»žåŽæ€§ |
| **å¢žé•¿çŽ‡è®¡ç®—** | $\hat{u}_{T+i} = u_T \cdot (1 + r)^i$ | $O(1)$ | $O(1)$ | æ’å®šå¢žé•¿ | å¿«é€Ÿ | å‡è®¾æ’å®šå¢žé•¿ |

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**ï¼š
   - åœ¨(date, resource_type)ä¸Šåˆ›å»ºå¤åˆç´¢å¼•
   - ä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ›å»ºç´¢å¼•

2. **é¢„æµ‹æ¨¡åž‹ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜é¢„æµ‹ç»“æžœ
   - å®šæœŸæ›´æ–°é¢„æµ‹æ¨¡åž‹

3. **æ‰¹é‡é¢„æµ‹**ï¼š
   - æ‰¹é‡é¢„æµ‹å¤šä¸ªèµ„æº
   - ä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢

### 7.3 å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šé¢„æµ‹ç²¾åº¦ä½Ž

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æ›´å¤æ‚çš„æ¨¡åž‹ã€å¢žåŠ åŽ†å²æ•°æ®ã€è€ƒè™‘å¤šå› ç´ 

**é—®é¢˜2**ï¼šé¢„æµ‹ç»“æžœä¸ç¨³å®š

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ç§»åŠ¨å¹³å‡ã€å¹³æ»‘æ•°æ®ã€å¼‚å¸¸å€¼å¤„ç†

**é—®é¢˜3**ï¼šè®¡ç®—æ€§èƒ½æ…¢

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ã€ç´¢å¼•ä¼˜åŒ–ã€å¹¶è¡ŒæŸ¥è¯¢

**é—®é¢˜4**ï¼šå­£èŠ‚æ€§æ¨¡å¼æœªè€ƒè™‘

- **è§£å†³æ–¹æ¡ˆ**ï¼šå­£èŠ‚æ€§åˆ†æžã€æ—¶é—´åºåˆ—æ¨¡åž‹ã€å¤šå‘¨æœŸé¢„æµ‹

---

## 8. æœ€ä½³å®žè·µ

### 8.1 é¢„æµ‹æ–¹æ³•é€‰æ‹©

1. **çº¿æ€§å¢žé•¿**ï¼šä½¿ç”¨çº¿æ€§å›žå½’
2. **æŒ‡æ•°å¢žé•¿**ï¼šä½¿ç”¨æŒ‡æ•°æ¨¡åž‹
3. **å¹³ç¨³è¶‹åŠ¿**ï¼šä½¿ç”¨ç§»åŠ¨å¹³å‡
4. **å­£èŠ‚æ€§**ï¼šä½¿ç”¨å­£èŠ‚æ€§åˆ†æž

### 8.2 æ•°æ®è´¨é‡

1. **æ•°æ®å®Œæ•´æ€§**ï¼šç¡®ä¿åŽ†å²æ•°æ®å®Œæ•´
2. **å¼‚å¸¸å€¼å¤„ç†**ï¼šè¯†åˆ«å’Œå¤„ç†å¼‚å¸¸å€¼
3. **æ•°æ®æ›´æ–°**ï¼šå®šæœŸæ›´æ–°åŽ†å²æ•°æ®

### 8.3 é¢„æµ‹ç²¾åº¦

1. **æ¨¡åž‹é€‰æ‹©**ï¼šé€‰æ‹©åˆé€‚çš„é¢„æµ‹æ¨¡åž‹
2. **å‚æ•°è°ƒä¼˜**ï¼šä¼˜åŒ–æ¨¡åž‹å‚æ•°
3. **éªŒè¯**ï¼šä½¿ç”¨åŽ†å²æ•°æ®éªŒè¯é¢„æµ‹

### 8.4 SQLå®žçŽ°æ³¨æ„äº‹é¡¹

1. **æ—¶é—´èŒƒå›´**ï¼šåˆç†è®¾ç½®é¢„æµ‹æ—¶é—´èŒƒå›´
2. **å¢žé•¿çŽ‡**ï¼šå¤„ç†è´Ÿå¢žé•¿å’Œé›¶å¢žé•¿
3. **ç²¾åº¦æŽ§åˆ¶**ï¼šæŽ§åˆ¶æ•°å€¼ç²¾åº¦
4. **é”™è¯¯å¤„ç†**ï¼šå¤„ç†é™¤é›¶å’ŒNULLå€¼

### 8.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢žå¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢žå¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡å®¹é‡è§„åˆ’ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºŽåŒ…å«æ—¥æœŸå’Œèµ„æºç±»åž‹çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºŽTop-Nå®¹é‡é¢„æµ‹æŸ¥è¯¢å’Œå¤šèµ„æºå®¹é‡å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢žå¼º**ï¼š
   - å¯¹äºŽå¤§è§„æ¨¡å®¹é‡è§„åˆ’è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºŽæ‰¹é‡å®¹é‡é¢„æµ‹å’Œå¤šæ—¶é—´èŒƒå›´å®¹é‡åˆ†æž

3. **å¹¶è¡ŒæŸ¥è¯¢å¢žå¼º**ï¼š
   - å®¹é‡è§„åˆ’æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨4èŠ‚è¯¦ç»†è¯´æ˜Žï¼‰
   - é€‚ç”¨äºŽå¤§è§„æ¨¡èµ„æºå®¹é‡åˆ†æžå’Œå¤šç»´åº¦å®¹é‡é¢„æµ‹

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–å®¹é‡è§„åˆ’æŸ¥è¯¢**

```sql
-- ä¸ºå®¹é‡è§„åˆ’åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_capacity_planning_skip_scan
ON capacity_history(resource_type, date DESC, usage_value DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªèµ„æºç±»åž‹æœ€æ–°æ—¥æœŸçš„ä½¿ç”¨æƒ…å†µ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (resource_type)
    resource_type,
    date,
    usage_value,
    (usage_value - LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date)) /
    NULLIF(LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date), 0) * 100 AS growth_rate_pct
FROM capacity_history
ORDER BY resource_type, date DESC
LIMIT 50;
```

### 8.6 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢žå¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å®¹é‡é¢„æµ‹ç»“æžœ**

å¯¹äºŽé¢‘ç¹ä½¿ç”¨çš„å®¹é‡é¢„æµ‹ç»“æžœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜å®¹é‡é¢„æµ‹ç»“æžœ
CREATE MATERIALIZED VIEW IF NOT EXISTS capacity_prediction_cache AS
WITH capacity_projection AS (
    SELECT
        resource_type,
        date,
        usage_value,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å¢žé•¿çŽ‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        AVG((usage_value - LAG(usage_value) OVER (
            PARTITION BY resource_type
            ORDER BY date
        )) / NULLIF(LAG(usage_value) OVER (
            PARTITION BY resource_type
            ORDER BY date
        ), 0) * 100) OVER (
            PARTITION BY resource_type
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS avg_growth_rate_30d,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—é¢„æµ‹å€¼ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        usage_value * POWER(
            1 + AVG((usage_value - LAG(usage_value) OVER (
                PARTITION BY resource_type
                ORDER BY date
            )) / NULLIF(LAG(usage_value) OVER (
                PARTITION BY resource_type
                ORDER BY date
            ), 0)) OVER (
                PARTITION BY resource_type
                ORDER BY date
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            ),
            30
        ) AS predicted_value_30d,
        usage_value * POWER(
            1 + AVG((usage_value - LAG(usage_value) OVER (
                PARTITION BY resource_type
                ORDER BY date
            )) / NULLIF(LAG(usage_value) OVER (
                PARTITION BY resource_type
                ORDER BY date
            ), 0)) OVER (
                PARTITION BY resource_type
                ORDER BY date
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            ),
            90
        ) AS predicted_value_90d
    FROM capacity_history
    WHERE date >= CURRENT_DATE - INTERVAL '180 days'
)
SELECT
    resource_type,
    date,
    usage_value,
    ROUND(avg_growth_rate_30d::numeric, 4) AS avg_growth_rate_30d,
    ROUND(predicted_value_30d::numeric, 2) AS predicted_value_30d,
    ROUND(predicted_value_90d::numeric, 2) AS predicted_value_90d,
    CASE
        WHEN resource_type = 'storage_gb' AND predicted_value_90d > 2000 THEN 'Critical'
        WHEN resource_type = 'storage_gb' AND predicted_value_90d > 1500 THEN 'Warning'
        WHEN resource_type = 'cpu_percent' AND predicted_value_90d > 90 THEN 'Critical'
        WHEN resource_type = 'cpu_percent' AND predicted_value_90d > 80 THEN 'Warning'
        ELSE 'Normal'
    END AS capacity_status
FROM capacity_projection
ORDER BY resource_type, date DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_capacity_prediction_cache_resource_date ON capacity_prediction_cache(resource_type, date DESC);
CREATE INDEX idx_capacity_prediction_cache_status ON capacity_prediction_cache(capacity_status, predicted_value_90d DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY capacity_prediction_cache;
```

**2. å®žæ—¶å®¹é‡è§„åˆ’ï¼šå¢žé‡å®¹é‡æ›´æ–°**

**å®žæ—¶å®¹é‡è§„åˆ’**ï¼šå¯¹äºŽå®žæ—¶æ•°æ®ï¼Œä½¿ç”¨å¢žé‡æ–¹æ³•æ›´æ–°å®¹é‡é¢„æµ‹ç»“æžœã€‚

```sql
-- å®žæ—¶å®¹é‡è§„åˆ’ï¼šå¢žé‡å®¹é‡æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_planning_state') THEN
            CREATE TABLE capacity_planning_state (
                resource_type VARCHAR(50) NOT NULL,
                last_date DATE NOT NULL,
                last_usage_value NUMERIC DEFAULT 0,
                sum_growth_rates NUMERIC DEFAULT 0,
                count_growth_samples BIGINT DEFAULT 0,
                avg_growth_rate NUMERIC,
                predicted_value_30d NUMERIC,
                predicted_value_90d NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (resource_type)
            );

            CREATE INDEX idx_capacity_planning_state_resource_date ON capacity_planning_state(resource_type, last_date DESC);
            CREATE INDEX idx_capacity_planning_state_updated ON capacity_planning_state(last_updated DESC);

            RAISE NOTICE 'å®¹é‡è§„åˆ’çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢žé‡å®¹é‡è§„åˆ’æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢žé‡å®¹é‡è§„åˆ’æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢žé‡æ›´æ–°å®¹é‡è§„åˆ’ç»Ÿè®¡ï¼šå®žæ—¶å®¹é‡è§„åˆ’
WITH new_capacity_data AS (
    SELECT
        resource_type,
        date,
        usage_value,
        LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date) AS prev_usage_value
    FROM capacity_history
    WHERE date > (SELECT COALESCE(MAX(last_date), '1970-01-01') FROM capacity_planning_state)
      AND date <= CURRENT_DATE
),
growth_rates AS (
    SELECT
        resource_type,
        date,
        usage_value,
        (usage_value - prev_usage_value) / NULLIF(prev_usage_value, 0) AS daily_growth_rate
    FROM new_capacity_data
    WHERE prev_usage_value IS NOT NULL
),
updated_capacity_stats AS (
    SELECT
        COALESCE(cps.resource_type, gr.resource_type) AS resource_type,
        MAX(gr.date) AS new_last_date,
        MAX(gr.usage_value) AS new_last_usage_value,
        COALESCE(cps.sum_growth_rates, 0) + SUM(gr.daily_growth_rate) AS new_sum_growth_rates,
        COALESCE(cps.count_growth_samples, 0) + COUNT(*) AS new_count_growth_samples,
        (COALESCE(cps.sum_growth_rates, 0) + SUM(gr.daily_growth_rate)) /
        NULLIF(COALESCE(cps.count_growth_samples, 0) + COUNT(*), 0) AS new_avg_growth_rate
    FROM capacity_planning_state cps
    FULL OUTER JOIN growth_rates gr ON cps.resource_type = gr.resource_type
    GROUP BY cps.resource_type, gr.resource_type, cps.sum_growth_rates, cps.count_growth_samples
),
capacity_predictions AS (
    SELECT
        resource_type,
        new_last_date,
        new_last_usage_value,
        new_avg_growth_rate,
        new_last_usage_value * POWER(1 + COALESCE(new_avg_growth_rate, 0), 30) AS new_predicted_value_30d,
        new_last_usage_value * POWER(1 + COALESCE(new_avg_growth_rate, 0), 90) AS new_predicted_value_90d
    FROM updated_capacity_stats
)
-- æ›´æ–°æˆ–æ’å…¥å®¹é‡è§„åˆ’çŠ¶æ€
INSERT INTO capacity_planning_state (
    resource_type,
    last_date,
    last_usage_value,
    sum_growth_rates,
    count_growth_samples,
    avg_growth_rate,
    predicted_value_30d,
    predicted_value_90d,
    last_updated
)
SELECT
    resource_type,
    new_last_date,
    new_last_usage_value,
    new_sum_growth_rates,
    new_count_growth_samples,
    new_avg_growth_rate,
    new_predicted_value_30d,
    new_predicted_value_90d,
    NOW()
FROM updated_capacity_stats cps
JOIN capacity_predictions cp USING (resource_type)
ON CONFLICT (resource_type)
DO UPDATE SET
    last_date = EXCLUDED.last_date,
    last_usage_value = EXCLUDED.last_usage_value,
    sum_growth_rates = EXCLUDED.sum_growth_rates,
    count_growth_samples = EXCLUDED.count_growth_samples,
    avg_growth_rate = EXCLUDED.avg_growth_rate,
    predicted_value_30d = EXCLUDED.predicted_value_30d,
    predicted_value_90d = EXCLUDED.predicted_value_90d,
    last_updated = NOW();
```

**3. æ™ºèƒ½å®¹é‡è§„åˆ’ï¼šè‡ªé€‚åº”é¢„æµ‹æ–¹æ³•é€‰æ‹©**

**æ™ºèƒ½å®¹é‡è§„åˆ’**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜é¢„æµ‹æ–¹æ³•ã€‚

```sql
-- æ™ºèƒ½å®¹é‡è§„åˆ’ï¼šè‡ªé€‚åº”é¢„æµ‹æ–¹æ³•é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    growth_linearity NUMERIC;
    growth_stability NUMERIC;
    recommended_method VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'capacity_history') THEN
            RAISE WARNING 'è¡¨ capacity_history ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½å®¹é‡è§„åˆ’';
            RETURN;
        END IF;

        -- è®¡ç®—å¢žé•¿ç‰¹å¾
        WITH growth_analysis AS (
            SELECT
                resource_type,
                AVG((usage_value - LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date)) /
                    NULLIF(LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date), 0)) AS avg_growth_rate,
                STDDEV((usage_value - LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date)) /
                       NULLIF(LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date), 0)) AS growth_stddev
            FROM capacity_history
            WHERE date >= CURRENT_DATE - INTERVAL '90 days'
            GROUP BY resource_type
        )
        SELECT
            AVG(ABS(avg_growth_rate)),
            AVG(growth_stddev / NULLIF(ABS(avg_growth_rate), 0))
        INTO growth_linearity, growth_stability
        FROM growth_analysis;

        -- æ ¹æ®å¢žé•¿ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©é¢„æµ‹æ–¹æ³•
        IF growth_linearity > 0.05 AND growth_stability < 0.5 THEN
            recommended_method := 'LINEAR_GROWTH';  -- é«˜çº¿æ€§ä½Žæ³¢åŠ¨ï¼šçº¿æ€§å¢žé•¿æ¨¡åž‹
        ELSIF growth_linearity > 0.02 AND growth_stability < 1.0 THEN
            recommended_method := 'EXPONENTIAL_GROWTH';  -- ä¸­çº¿æ€§ä¸­æ³¢åŠ¨ï¼šæŒ‡æ•°å¢žé•¿æ¨¡åž‹
        ELSE
            recommended_method := 'MOVING_AVERAGE';  -- ä½Žçº¿æ€§é«˜æ³¢åŠ¨ï¼šç§»åŠ¨å¹³å‡æ¨¡åž‹
        END IF;

        RAISE NOTICE 'å¢žé•¿çº¿æ€§åº¦: %, å¢žé•¿ç¨³å®šæ€§: %, æŽ¨èæ–¹æ³•: %',
            growth_linearity, growth_stability, recommended_method;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½å®¹é‡è§„åˆ’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ™ºèƒ½å®¹é‡è§„åˆ’ï¼šæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„é¢„æµ‹æ–¹æ³•
WITH growth_characteristics AS (
    SELECT
        resource_type,
        AVG((usage_value - LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date)) /
            NULLIF(LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date), 0)) AS avg_growth_rate,
        STDDEV((usage_value - LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date)) /
               NULLIF(LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date), 0)) AS growth_stddev,
        STDDEV((usage_value - LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date)) /
               NULLIF(LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date), 0)) /
        NULLIF(ABS(AVG((usage_value - LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date)) /
                      NULLIF(LAG(usage_value) OVER (PARTITION BY resource_type ORDER BY date), 0))), 0) AS growth_stability
    FROM capacity_history
    WHERE date >= CURRENT_DATE - INTERVAL '90 days'
    GROUP BY resource_type
),
adaptive_capacity_prediction AS (
    SELECT
        ch.resource_type,
        ch.date,
        ch.usage_value,
        gc.avg_growth_rate,
        gc.growth_stability,
        CASE
            WHEN ABS(gc.avg_growth_rate) > 0.05 AND gc.growth_stability < 0.5 THEN 'LINEAR_GROWTH'
            WHEN ABS(gc.avg_growth_rate) > 0.02 AND gc.growth_stability < 1.0 THEN 'EXPONENTIAL_GROWTH'
            ELSE 'MOVING_AVERAGE'
        END AS recommended_method,
        -- æ ¹æ®æŽ¨èæ–¹æ³•è®¡ç®—é¢„æµ‹å€¼ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN ABS(gc.avg_growth_rate) > 0.05 AND gc.growth_stability < 0.5 THEN
                ch.usage_value + gc.avg_growth_rate * ch.usage_value * 30  -- çº¿æ€§å¢žé•¿ï¼š30å¤©é¢„æµ‹
            WHEN ABS(gc.avg_growth_rate) > 0.02 AND gc.growth_stability < 1.0 THEN
                ch.usage_value * POWER(1 + gc.avg_growth_rate, 30)  -- æŒ‡æ•°å¢žé•¿ï¼š30å¤©é¢„æµ‹
            ELSE
                AVG(ch.usage_value) OVER (
                    PARTITION BY ch.resource_type
                    ORDER BY ch.date
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                )  -- ç§»åŠ¨å¹³å‡ï¼š30å¤©å¹³å‡å€¼
        END AS predicted_value_30d
    FROM capacity_history ch
    JOIN growth_characteristics gc ON ch.resource_type = gc.resource_type
    WHERE ch.date >= CURRENT_DATE - INTERVAL '30 days'
)
SELECT
    resource_type,
    date,
    usage_value,
    ROUND(avg_growth_rate::numeric, 4) AS avg_growth_rate,
    ROUND(growth_stability::numeric, 4) AS growth_stability,
    recommended_method,
    ROUND(predicted_value_30d::numeric, 2) AS predicted_value_30d,
    CASE
        WHEN resource_type = 'storage_gb' AND predicted_value_30d > 2000 THEN 'Critical'
        WHEN resource_type = 'storage_gb' AND predicted_value_30d > 1500 THEN 'Warning'
        WHEN resource_type = 'cpu_percent' AND predicted_value_30d > 90 THEN 'Critical'
        WHEN resource_type = 'cpu_percent' AND predicted_value_30d > 80 THEN 'Warning'
        ELSE 'Normal'
    END AS capacity_status
FROM adaptive_capacity_prediction
WHERE date = CURRENT_DATE
ORDER BY capacity_status DESC, predicted_value_30d DESC;
```

---

## ðŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

- ã€Šå®¹é‡è§„åˆ’ä¸Žæ€§èƒ½ä¼˜åŒ–ã€‹ï¼ˆCapacity Planning and Performance Optimizationï¼‰- å®¹é‡è§„åˆ’ç†è®º
- ã€Šæ—¶é—´åºåˆ—é¢„æµ‹ã€‹ï¼ˆTime Series Forecastingï¼‰- é¢„æµ‹æ–¹æ³•

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- [çª—å£å‡½æ•°](https://www.postgresql.org/docs/current/tutorial-window.html)
- [èšåˆå‡½æ•°](https://www.postgresql.org/docs/current/functions-aggregate.html)
- [æ•°å­¦å‡½æ•°](https://www.postgresql.org/docs/current/functions-math.html)

### åœ¨çº¿èµ„æº

- PostgreSQLå®¹é‡è§„åˆ’æŒ‡å—
- å®¹é‡é¢„æµ‹æ–¹æ³•è¯¦è§£
- å®¹é‡è§„åˆ’æœ€ä½³å®žè·µ

### ç›¸å…³ç®—æ³•

- [æ€§èƒ½æŒ‡æ ‡è®¡ç®—](./æ€§èƒ½æŒ‡æ ‡è®¡ç®—.md) - æ€§èƒ½ç›‘æŽ§
- [å¼‚å¸¸æ£€æµ‹ç®—æ³•](./å¼‚å¸¸æ£€æµ‹ç®—æ³•.md) - å¼‚å¸¸æ£€æµ‹
- [èµ„æºä¼˜åŒ–ç®—æ³•](./èµ„æºä¼˜åŒ–ç®—æ³•.md) - èµ„æºä¼˜åŒ–

---

**æœ€åŽæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
