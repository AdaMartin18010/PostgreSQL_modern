# PostgreSQL 异常检测算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 异常检测 | 监控告警
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 异常检测算法完整指南](#postgresql-异常检测算法完整指南)
  - [📋 目录](#-目录)
  - [异常检测概述](#异常检测概述)
    - [理论基础](#理论基础)
      - [异常检测问题定义](#异常检测问题定义)
      - [异常检测方法分类](#异常检测方法分类)
      - [异常检测方法选择](#异常检测方法选择)
    - [核心算法](#核心算法)
  - [1. 统计异常检测](#1-统计异常检测)
    - [1.1 统计异常检测原理](#11-统计异常检测原理)
      - [异常值定义](#异常值定义)
      - [统计方法](#统计方法)
    - [1.2 Z-score方法实现](#12-z-score方法实现)
    - [1.3 IQR方法实现](#13-iqr方法实现)
    - [1.4 3-sigma规则](#14-3-sigma规则)
  - [2. 时间序列异常](#2-时间序列异常)
    - [2.1 时间序列异常原理](#21-时间序列异常原理)
      - [时间序列异常定义](#时间序列异常定义)
      - [检测方法](#检测方法)
    - [2.2 移动平均异常实现](#22-移动平均异常实现)
    - [2.3 趋势异常检测](#23-趋势异常检测)
  - [3. 异常评分](#3-异常评分)
    - [3.1 异常评分原理](#31-异常评分原理)
      - [异常评分定义](#异常评分定义)
      - [评分方法](#评分方法)
    - [3.2 异常评分计算实现](#32-异常评分计算实现)
    - [3.3 综合异常评分](#33-综合异常评分)
  - [4. 异常检测优化策略](#4-异常检测优化策略)
    - [4.1 索引优化](#41-索引优化)
    - [4.2 窗口函数优化](#42-窗口函数优化)
    - [4.3 实时检测优化](#43-实时检测优化)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 系统监控异常检测](#51-系统监控异常检测)
    - [5.2 性能异常检测](#52-性能异常检测)
    - [5.3 业务异常检测](#53-业务异常检测)
    - [5.4 异常告警系统](#54-异常告警系统)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 异常检测方法对比](#61-异常检测方法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 方法选择](#71-方法选择)
    - [7.2 阈值设置](#72-阈值设置)
    - [7.3 误报处理](#73-误报处理)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 异常检测概述

**异常检测（Anomaly Detection）**识别数据中的异常值，用于系统监控和故障预警，是运维监控的核心技术。

### 理论基础

#### 异常检测问题定义

**异常检测问题**：给定数据序列$X = \{x_1, x_2, \ldots, x_n\}$，识别异常值$A = \{a_1, a_2, \ldots, a_k\}$：
$$a_i \in X \text{ and } f(a_i) > \theta$$

其中$f$是异常评分函数，$\theta$是阈值。

#### 异常检测方法分类

异常检测方法分类：

1. **统计方法**：
   - Z-score：$z = \frac{x - \mu}{\sigma}$
   - IQR：$\text{outlier} = x < Q1 - 1.5 \times IQR \text{ or } x > Q3 + 1.5 \times IQR$
   - 时间复杂度：$O(n \log n)$

2. **时间序列方法**：
   - 移动平均：基于移动平均和标准差
   - 趋势分析：基于趋势偏离
   - 时间复杂度：$O(n)$

3. **机器学习方法**：
   - 聚类：基于距离
   - 孤立森林：基于树结构
   - 时间复杂度：$O(n \log n)$

#### 异常检测方法选择

选择检测方法的考虑因素：

1. **数据分布**：正态分布用Z-score，偏态分布用IQR
2. **时间序列**：时间序列用移动平均，静态数据用统计方法
3. **精度要求**：高精度用复杂方法，快速用简单方法

### 核心算法

| 算法 | 数学定义 | 用途 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **Z-score** | $z = \frac{x - \mu}{\sigma}$ | 统计异常 | $O(n)$ | $O(1)$ | 正态分布 |
| **IQR** | $\text{outlier} = x < Q1 - 1.5 \times IQR \text{ or } x > Q3 + 1.5 \times IQR$ | 四分位距异常 | $O(n \log n)$ | $O(n)$ | 偏态分布 |
| **移动平均** | 基于移动平均和标准差 | 时间序列异常 | $O(n)$ | $O(1)$ | 时间序列 |

---

## 1. 统计异常检测

### 1.1 统计异常检测原理

**统计异常检测（Statistical Anomaly Detection）**基于统计分布识别异常值。

#### 异常值定义

**异常值（Outlier）**：与数据集中其他值显著不同的值：

- **全局异常**：与整个数据集不同
- **局部异常**：与局部数据不同

#### 统计方法

**统计方法**：

1. **Z-score**：基于标准差
2. **IQR**：基于四分位距
3. **3-sigma规则**：基于3倍标准差

### 1.2 Z-score方法实现

**Z-score方法**的实现和使用。

```sql
-- 创建监控数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 已存在，先删除';
            DROP TABLE monitoring_data CASCADE;
        END IF;

        CREATE TABLE monitoring_data (
            timestamp TIMESTAMP NOT NULL,
            metric_name VARCHAR(50) NOT NULL,
            metric_value NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (timestamp, metric_name)
        );

        -- 插入示例数据（包含一些异常值）
        INSERT INTO monitoring_data (timestamp, metric_name, metric_value) VALUES
            ('2024-01-01 10:00:00', 'cpu_usage', 45.5),
            ('2024-01-01 10:01:00', 'cpu_usage', 52.3),
            ('2024-01-01 10:02:00', 'cpu_usage', 48.7),
            ('2024-01-01 10:03:00', 'cpu_usage', 95.2),  -- 异常值
            ('2024-01-01 10:04:00', 'cpu_usage', 50.1),
            ('2024-01-01 10:05:00', 'cpu_usage', 5.3),   -- 异常值
            ('2024-01-01 10:06:00', 'cpu_usage', 49.8);

        RAISE NOTICE '表 monitoring_data 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 monitoring_data 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- Z-score异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法进行异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行Z-score异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算Z-score并识别异常
WITH stats AS (
    SELECT
        metric_name,
        AVG(metric_value) AS mean_value,
        STDDEV(metric_value) AS std_value
    FROM monitoring_data
    GROUP BY metric_name
),
z_scores AS (
    SELECT
        md.timestamp,
        md.metric_name,
        md.metric_value,
        s.mean_value,
        s.std_value,
        CASE
            WHEN s.std_value = 0 THEN 0
            ELSE ABS((md.metric_value - s.mean_value) / s.std_value)
        END AS z_score
    FROM monitoring_data md
    JOIN stats s ON md.metric_name = s.metric_name
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    ROUND(mean_value::numeric, 2) AS mean_value,
    ROUND(std_value::numeric, 2) AS std_value,
    ROUND(z_score::numeric, 2) AS z_score,
    CASE
        WHEN z_score > 3 THEN 'Critical Anomaly'
        WHEN z_score > 2 THEN 'Warning Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM z_scores
ORDER BY z_score DESC, timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    metric_name,
    AVG(metric_value) AS mean_value,
    STDDEV(metric_value) AS std_value
FROM monitoring_data
GROUP BY metric_name;
```

### 1.3 IQR方法实现

**IQR方法**的实现和使用。

```sql
-- IQR异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法进行IQR异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行IQR异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'IQR异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用IQR方法检测异常
WITH quartiles AS (
    SELECT
        metric_name,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY metric_value) AS q1,
        PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY metric_value) AS median,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY metric_value) AS q3
    FROM monitoring_data
    GROUP BY metric_name
),
iqr_values AS (
    SELECT
        metric_name,
        q1,
        median,
        q3,
        q3 - q1 AS iqr,
        q1 - 1.5 * (q3 - q1) AS lower_bound,
        q3 + 1.5 * (q3 - q1) AS upper_bound
    FROM quartiles
)
SELECT
    md.timestamp,
    md.metric_name,
    ROUND(md.metric_value::numeric, 2) AS metric_value,
    ROUND(iq.lower_bound::numeric, 2) AS lower_bound,
    ROUND(iq.upper_bound::numeric, 2) AS upper_bound,
    CASE
        WHEN md.metric_value < iq.lower_bound OR md.metric_value > iq.upper_bound THEN 'Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM monitoring_data md
JOIN iqr_values iq ON md.metric_name = iq.metric_name
ORDER BY md.timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    metric_name,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY metric_value) AS q1,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY metric_value) AS q3
FROM monitoring_data
GROUP BY metric_name;
```

---

### 1.4 3-sigma规则

**3-sigma规则**：使用3倍标准差识别异常。

```sql
-- 3-sigma规则异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法进行3-sigma规则异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行3-sigma规则异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '3-sigma规则异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 3-sigma规则：使用3倍标准差
WITH stats AS (
    SELECT
        metric_name,
        AVG(metric_value) AS mean_value,
        STDDEV(metric_value) AS std_value
    FROM monitoring_data
    GROUP BY metric_name
),
three_sigma AS (
    SELECT
        md.timestamp,
        md.metric_name,
        md.metric_value,
        s.mean_value,
        s.std_value,
        s.mean_value - 3 * s.std_value AS lower_bound,
        s.mean_value + 3 * s.std_value AS upper_bound
    FROM monitoring_data md
    JOIN stats s ON md.metric_name = s.metric_name
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    ROUND(mean_value::numeric, 2) AS mean_value,
    ROUND(std_value::numeric, 2) AS std_value,
    ROUND(lower_bound::numeric, 2) AS lower_bound,
    ROUND(upper_bound::numeric, 2) AS upper_bound,
    CASE
        WHEN metric_value < lower_bound OR metric_value > upper_bound THEN 'Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM three_sigma
WHERE metric_value < lower_bound OR metric_value > upper_bound
ORDER BY timestamp DESC;
```

---

## 2. 时间序列异常

### 2.1 时间序列异常原理

**时间序列异常检测（Time Series Anomaly Detection）**识别时间序列中的异常模式。

#### 时间序列异常定义

**时间序列异常**：

- **点异常**：单个时间点的异常值
- **模式异常**：异常的模式或趋势
- **上下文异常**：在特定上下文下的异常

#### 检测方法

**检测方法**：

1. **移动平均**：基于移动平均和标准差
2. **趋势分析**：基于趋势偏离
3. **季节性分析**：基于季节性模式

### 2.2 移动平均异常实现

**移动平均异常**的实现和使用。

```sql
-- 移动平均异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法进行移动平均异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行移动平均异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '移动平均异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 基于移动平均的异常检测
WITH moving_stats AS (
    SELECT
        timestamp,
        metric_name,
        metric_value,
        AVG(metric_value) OVER (
            PARTITION BY metric_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS moving_avg,
        STDDEV(metric_value) OVER (
            PARTITION BY metric_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS moving_std
    FROM monitoring_data
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    ROUND(moving_avg::numeric, 2) AS moving_avg,
    ROUND(moving_std::numeric, 2) AS moving_std,
    CASE
        WHEN moving_std = 0 THEN 'Normal'
        WHEN ABS(metric_value - moving_avg) > 2 * moving_std THEN 'Anomaly'
        WHEN ABS(metric_value - moving_avg) > 1.5 * moving_std THEN 'Warning'
        ELSE 'Normal'
    END AS anomaly_status,
    ROUND(ABS(metric_value - moving_avg) / NULLIF(moving_std, 0)::numeric, 2) AS deviation_score
FROM moving_stats
WHERE moving_avg IS NOT NULL AND moving_std IS NOT NULL
ORDER BY deviation_score DESC, timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    timestamp,
    AVG(metric_value) OVER (ORDER BY timestamp ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS moving_avg
FROM monitoring_data
WHERE metric_name = 'cpu_usage'
ORDER BY timestamp;
```

---

### 2.3 趋势异常检测

**趋势异常检测**：识别趋势中的异常变化。

```sql
-- 趋势异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法进行趋势异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行趋势异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 趋势异常检测：识别趋势中的异常变化
WITH trend_analysis AS (
    SELECT
        timestamp,
        metric_name,
        metric_value,
        AVG(metric_value) OVER (
            PARTITION BY metric_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS moving_avg,
        LAG(metric_value) OVER (PARTITION BY metric_name ORDER BY timestamp) AS prev_value,
        metric_value - LAG(metric_value) OVER (PARTITION BY metric_name ORDER BY timestamp) AS change_rate
    FROM monitoring_data
),
trend_anomalies AS (
    SELECT
        timestamp,
        metric_name,
        metric_value,
        moving_avg,
        change_rate,
        AVG(change_rate) OVER (
            PARTITION BY metric_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS avg_change_rate,
        STDDEV(change_rate) OVER (
            PARTITION BY metric_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS std_change_rate
    FROM trend_analysis
    WHERE change_rate IS NOT NULL
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    ROUND(moving_avg::numeric, 2) AS moving_avg,
    ROUND(change_rate::numeric, 2) AS change_rate,
    ROUND(avg_change_rate::numeric, 2) AS avg_change_rate,
    ROUND(std_change_rate::numeric, 2) AS std_change_rate,
    CASE
        WHEN ABS(change_rate - avg_change_rate) > 3 * std_change_rate THEN 'Trend Anomaly'
        WHEN ABS(change_rate - avg_change_rate) > 2 * std_change_rate THEN 'Trend Warning'
        ELSE 'Normal'
    END AS trend_status
FROM trend_anomalies
WHERE ABS(change_rate - avg_change_rate) > 2 * std_change_rate
ORDER BY timestamp DESC;
```

---

## 3. 异常评分

### 3.1 异常评分原理

**异常评分（Anomaly Scoring）**量化异常程度，便于排序和筛选。

#### 异常评分定义

**异常评分**：将异常程度量化为数值：
$$S(x) = f(x, \text{context})$$

其中$f$是评分函数，值越大表示异常程度越高。

#### 评分方法

**评分方法**：

1. **Z-score评分**：$S(x) = |z|$
2. **IQR评分**：基于四分位距的距离
3. **综合评分**：结合多种方法

### 3.2 异常评分计算实现

**异常评分计算**的实现和使用。

```sql
-- 异常评分计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法计算异常评分';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算异常评分';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '异常评分计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 综合异常评分（结合Z-score和IQR）
WITH z_score_stats AS (
    SELECT
        metric_name,
        AVG(metric_value) AS mean_value,
        STDDEV(metric_value) AS std_value
    FROM monitoring_data
    GROUP BY metric_name
),
iqr_stats AS (
    SELECT
        metric_name,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY metric_value) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY metric_value) AS q3
    FROM monitoring_data
    GROUP BY metric_name
),
anomaly_scores AS (
    SELECT
        md.timestamp,
        md.metric_name,
        md.metric_value,
        ABS((md.metric_value - zs.mean_value) / NULLIF(zs.std_value, 0)) AS z_score,
        CASE
            WHEN md.metric_value < iqs.q1 - 1.5 * (iqs.q3 - iqs.q1) THEN 1
            WHEN md.metric_value > iqs.q3 + 1.5 * (iqs.q3 - iqs.q1) THEN 1
            ELSE 0
        END AS iqr_anomaly,
        (ABS((md.metric_value - zs.mean_value) / NULLIF(zs.std_value, 0)) +
         CASE
            WHEN md.metric_value < iqs.q1 - 1.5 * (iqs.q3 - iqs.q1) THEN 1 ELSE 0
            WHEN md.metric_value > iqs.q3 + 1.5 * (iqs.q3 - iqs.q1) THEN 1 ELSE 0
            ELSE 0
         END) / 2.0 AS anomaly_score
    FROM monitoring_data md
    JOIN z_score_stats zs ON md.metric_name = zs.metric_name
    JOIN iqr_stats iqs ON md.metric_name = iqs.metric_name
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    ROUND(z_score::numeric, 2) AS z_score,
    iqr_anomaly,
    ROUND(anomaly_score::numeric, 2) AS anomaly_score,
    CASE
        WHEN anomaly_score > 2.0 THEN 'Critical'
        WHEN anomaly_score > 1.5 THEN 'High'
        WHEN anomaly_score > 1.0 THEN 'Medium'
        ELSE 'Low'
    END AS severity
FROM anomaly_scores
ORDER BY anomaly_score DESC, timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    metric_name,
    COUNT(*) AS record_count
FROM monitoring_data
GROUP BY metric_name;
```

---

### 3.3 综合异常评分

**综合异常评分**：结合多种方法的异常评分。

```sql
-- 综合异常评分（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法计算综合异常评分';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算综合异常评分';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '综合异常评分计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 综合异常评分：结合Z-score、IQR和移动平均
WITH z_score_stats AS (
    SELECT
        metric_name,
        AVG(metric_value) AS mean_value,
        STDDEV(metric_value) AS std_value
    FROM monitoring_data
    GROUP BY metric_name
),
iqr_stats AS (
    SELECT
        metric_name,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY metric_value) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY metric_value) AS q3
    FROM monitoring_data
    GROUP BY metric_name
),
moving_stats AS (
    SELECT
        timestamp,
        metric_name,
        metric_value,
        AVG(metric_value) OVER (
            PARTITION BY metric_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS moving_avg,
        STDDEV(metric_value) OVER (
            PARTITION BY metric_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS moving_std
    FROM monitoring_data
),
composite_scores AS (
    SELECT
        ms.timestamp,
        ms.metric_name,
        ms.metric_value,
        ABS((ms.metric_value - zs.mean_value) / NULLIF(zs.std_value, 0)) AS z_score,
        CASE
            WHEN ms.metric_value < iqs.q1 - 1.5 * (iqs.q3 - iqs.q1) OR
                 ms.metric_value > iqs.q3 + 1.5 * (iqs.q3 - iqs.q1) THEN 1
            ELSE 0
        END AS iqr_flag,
        ABS((ms.metric_value - ms.moving_avg) / NULLIF(ms.moving_std, 0)) AS moving_z_score,
        -- 综合评分：加权平均
        (ABS((ms.metric_value - zs.mean_value) / NULLIF(zs.std_value, 0)) * 0.4 +
         CASE
            WHEN ms.metric_value < iqs.q1 - 1.5 * (iqs.q3 - iqs.q1) OR
                 ms.metric_value > iqs.q3 + 1.5 * (iqs.q3 - iqs.q1) THEN 3 ELSE 0
         END * 0.3 +
         ABS((ms.metric_value - ms.moving_avg) / NULLIF(ms.moving_std, 0)) * 0.3) AS composite_score
    FROM moving_stats ms
    JOIN z_score_stats zs ON ms.metric_name = zs.metric_name
    JOIN iqr_stats iqs ON ms.metric_name = iqs.metric_name
    WHERE ms.moving_avg IS NOT NULL AND ms.moving_std IS NOT NULL
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    ROUND(z_score::numeric, 2) AS z_score,
    iqr_flag,
    ROUND(moving_z_score::numeric, 2) AS moving_z_score,
    ROUND(composite_score::numeric, 2) AS composite_score,
    CASE
        WHEN composite_score > 3.0 THEN 'Critical'
        WHEN composite_score > 2.0 THEN 'High'
        WHEN composite_score > 1.0 THEN 'Medium'
        ELSE 'Low'
    END AS severity
FROM composite_scores
WHERE composite_score > 1.0
ORDER BY composite_score DESC, timestamp DESC;
```

---

## 4. 异常检测优化策略

### 4.1 索引优化

**索引优化**：为异常检测查询创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 监控数据表索引
        CREATE INDEX IF NOT EXISTS idx_monitoring_data_timestamp_metric
        ON monitoring_data(timestamp, metric_name);

        CREATE INDEX IF NOT EXISTS idx_monitoring_data_metric_timestamp
        ON monitoring_data(metric_name, timestamp);

        RAISE NOTICE '异常检测索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 窗口函数优化

**窗口函数优化**：使用物化视图缓存统计信息。

```sql
-- 窗口函数优化：使用物化视图缓存统计信息
CREATE MATERIALIZED VIEW IF NOT EXISTS anomaly_stats_cache AS
SELECT
    metric_name,
    AVG(metric_value) AS mean_value,
    STDDEV(metric_value) AS std_value,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY metric_value) AS q1,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY metric_value) AS q3
FROM monitoring_data
WHERE timestamp >= NOW() - INTERVAL '24 hours'
GROUP BY metric_name;

CREATE INDEX IF NOT EXISTS idx_anomaly_stats_cache_metric
ON anomaly_stats_cache(metric_name);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY anomaly_stats_cache;
```

### 4.3 实时检测优化

**实时检测优化**：优化实时异常检测性能。

```sql
-- 实时检测优化（带错误处理）
DO $$
BEGIN
    BEGIN
        SET work_mem = '256MB';
        RAISE NOTICE '实时检测优化配置已设置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '实时检测优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. 实际应用案例

### 5.1 系统监控异常检测

**系统监控异常检测**实时监控系统指标并识别异常。

```sql
-- 系统监控异常检测示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法进行系统监控异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行系统监控异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '系统监控异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 实时异常检测查询
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH recent_data AS (
    SELECT
        timestamp,
        metric_name,
        metric_value
    FROM monitoring_data
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
),
statistics AS (
    SELECT
        metric_name,
        AVG(metric_value) AS mean_value,
        STDDEV(metric_value) AS std_value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY metric_value) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY metric_value) AS q3
    FROM recent_data
    GROUP BY metric_name
),
anomalies AS (
    SELECT
        rd.timestamp,
        rd.metric_name,
        rd.metric_value,
        s.mean_value,
        s.std_value,
        ABS((rd.metric_value - s.mean_value) / NULLIF(s.std_value, 0)) AS z_score,
        CASE
            WHEN rd.metric_value < s.q1 - 1.5 * (s.q3 - s.q1) OR
                 rd.metric_value > s.q3 + 1.5 * (s.q3 - s.q1) THEN TRUE
            ELSE FALSE
        END AS is_iqr_anomaly
    FROM recent_data rd
    JOIN statistics s ON rd.metric_name = s.metric_name
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    ROUND(z_score::numeric, 2) AS z_score,
    is_iqr_anomaly,
    CASE
        WHEN z_score > 3 OR is_iqr_anomaly THEN 'CRITICAL'
        WHEN z_score > 2 THEN 'WARNING'
        ELSE 'NORMAL'
    END AS alert_level
FROM anomalies
WHERE z_score > 2 OR is_iqr_anomaly
ORDER BY z_score DESC, timestamp;
```

### 5.2 性能异常检测

**性能异常检测**：检测性能指标的异常。

```sql
-- 性能异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_performance') THEN
            RAISE WARNING '表 query_performance 不存在，无法进行性能异常检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行性能异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能异常检测：检测查询性能异常
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH query_stats AS (
    SELECT
        query_id,
        AVG(execution_time_ms) AS avg_time,
        STDDEV(execution_time_ms) AS std_time,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY execution_time_ms) AS p95_time
    FROM query_performance
    WHERE timestamp >= NOW() - INTERVAL '24 hours'
    GROUP BY query_id
),
recent_queries AS (
    SELECT
        timestamp,
        query_id,
        execution_time_ms
    FROM query_performance
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
),
performance_anomalies AS (
    SELECT
        rq.timestamp,
        rq.query_id,
        rq.execution_time_ms,
        qs.avg_time,
        qs.p95_time,
        ABS((rq.execution_time_ms - qs.avg_time) / NULLIF(qs.std_time, 0)) AS z_score,
        CASE
            WHEN rq.execution_time_ms > qs.p95_time * 2 THEN TRUE
            WHEN rq.execution_time_ms > qs.avg_time + 3 * qs.std_time THEN TRUE
            ELSE FALSE
        END AS is_anomaly
    FROM recent_queries rq
    JOIN query_stats qs ON rq.query_id = qs.query_id
)
SELECT
    timestamp,
    query_id,
    ROUND(execution_time_ms::numeric, 2) AS execution_time_ms,
    ROUND(avg_time::numeric, 2) AS avg_time,
    ROUND(p95_time::numeric, 2) AS p95_time,
    ROUND(z_score::numeric, 2) AS z_score,
    CASE
        WHEN execution_time_ms > p95_time * 2 THEN 'Critical Performance Degradation'
        WHEN z_score > 3 THEN 'Severe Anomaly'
        WHEN z_score > 2 THEN 'Moderate Anomaly'
        ELSE 'Normal'
    END AS anomaly_type
FROM performance_anomalies
WHERE is_anomaly
ORDER BY z_score DESC, timestamp DESC;
```

### 5.3 业务异常检测

**业务异常检测**：检测业务指标的异常。

```sql
-- 业务异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_metrics') THEN
            RAISE WARNING '表 business_metrics 不存在，创建示例表';

            CREATE TABLE business_metrics (
                timestamp TIMESTAMP NOT NULL,
                metric_name VARCHAR(50) NOT NULL,
                metric_value NUMERIC(10, 2) NOT NULL,
                PRIMARY KEY (timestamp, metric_name)
            );

            INSERT INTO business_metrics (timestamp, metric_name, metric_value) VALUES
                ('2024-01-01 10:00:00', 'order_count', 1000),
                ('2024-01-01 11:00:00', 'order_count', 1050),
                ('2024-01-01 12:00:00', 'order_count', 500),  -- 异常值
                ('2024-01-01 13:00:00', 'order_count', 1100);

            RAISE NOTICE '表 business_metrics 创建成功';
        END IF;

        RAISE NOTICE '开始进行业务异常检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '业务异常检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 业务异常检测：检测业务指标异常
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH hourly_aggregates AS (
    SELECT
        DATE_TRUNC('hour', timestamp) AS hour,
        metric_name,
        SUM(metric_value) AS hourly_value
    FROM business_metrics
    WHERE timestamp >= NOW() - INTERVAL '7 days'
    GROUP BY DATE_TRUNC('hour', timestamp), metric_name
),
hourly_stats AS (
    SELECT
        metric_name,
        EXTRACT(HOUR FROM hour) AS hour_of_day,
        AVG(hourly_value) AS avg_hourly_value,
        STDDEV(hourly_value) AS std_hourly_value
    FROM hourly_aggregates
    GROUP BY metric_name, EXTRACT(HOUR FROM hour)
),
recent_hourly AS (
    SELECT
        DATE_TRUNC('hour', timestamp) AS hour,
        metric_name,
        SUM(metric_value) AS hourly_value
    FROM business_metrics
    WHERE timestamp >= NOW() - INTERVAL '1 day'
    GROUP BY DATE_TRUNC('hour', timestamp), metric_name
),
business_anomalies AS (
    SELECT
        rh.hour,
        rh.metric_name,
        rh.hourly_value,
        hs.avg_hourly_value,
        hs.std_hourly_value,
        ABS((rh.hourly_value - hs.avg_hourly_value) / NULLIF(hs.std_hourly_value, 0)) AS z_score
    FROM recent_hourly rh
    JOIN hourly_stats hs ON rh.metric_name = hs.metric_name
        AND EXTRACT(HOUR FROM rh.hour) = hs.hour_of_day
)
SELECT
    hour,
    metric_name,
    ROUND(hourly_value::numeric, 2) AS hourly_value,
    ROUND(avg_hourly_value::numeric, 2) AS expected_value,
    ROUND(z_score::numeric, 2) AS z_score,
    CASE
        WHEN z_score > 3 THEN 'Critical Business Anomaly'
        WHEN z_score > 2 THEN 'Significant Deviation'
        WHEN z_score > 1.5 THEN 'Moderate Deviation'
        ELSE 'Normal'
    END AS anomaly_severity
FROM business_anomalies
WHERE z_score > 1.5
ORDER BY z_score DESC, hour DESC;
```

### 5.4 异常告警系统

**异常告警系统**：基于异常检测生成告警。

```sql
-- 异常告警系统（带错误处理和性能测试）
DO $$
DECLARE
    critical_threshold NUMERIC := 3.0;
    warning_threshold NUMERIC := 2.0;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'monitoring_data') THEN
            RAISE WARNING '表 monitoring_data 不存在，无法生成异常告警';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成异常告警，临界阈值: %, 警告阈值: %', critical_threshold, warning_threshold;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '异常告警系统准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 异常告警系统：生成告警
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH recent_metrics AS (
    SELECT
        timestamp,
        metric_name,
        metric_value
    FROM monitoring_data
    WHERE timestamp >= NOW() - INTERVAL '5 minutes'
),
statistics AS (
    SELECT
        metric_name,
        AVG(metric_value) AS mean_value,
        STDDEV(metric_value) AS std_value
    FROM monitoring_data
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
    GROUP BY metric_name
),
anomaly_scores AS (
    SELECT
        rm.timestamp,
        rm.metric_name,
        rm.metric_value,
        s.mean_value,
        s.std_value,
        ABS((rm.metric_value - s.mean_value) / NULLIF(s.std_value, 0)) AS z_score
    FROM recent_metrics rm
    JOIN statistics s ON rm.metric_name = s.metric_name
),
alerts AS (
    SELECT
        timestamp,
        metric_name,
        ROUND(metric_value::numeric, 2) AS metric_value,
        ROUND(mean_value::numeric, 2) AS expected_value,
        ROUND(z_score::numeric, 2) AS anomaly_score,
        CASE
            WHEN z_score > critical_threshold THEN 'CRITICAL'
            WHEN z_score > warning_threshold THEN 'WARNING'
            ELSE 'INFO'
        END AS alert_level,
        CASE
            WHEN z_score > critical_threshold THEN 'Immediate action required'
            WHEN z_score > warning_threshold THEN 'Investigation recommended'
            ELSE 'Monitor closely'
        END AS alert_message
    FROM anomaly_scores
    WHERE z_score > warning_threshold
)
SELECT
    timestamp,
    metric_name,
    metric_value,
    expected_value,
    anomaly_score,
    alert_level,
    alert_message
FROM alerts
ORDER BY
    CASE alert_level WHEN 'CRITICAL' THEN 1 WHEN 'WARNING' THEN 2 ELSE 3 END,
    anomaly_score DESC,
    timestamp DESC;
```

---

## 6. 算法性能对比与优化

### 6.1 异常检测方法对比

| 方法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **Z-score** | $z = \frac{x - \mu}{\sigma}$ | $O(n)$ | $O(1)$ | 正态分布 | 简单、快速 | 假设正态分布 |
| **IQR** | $\text{outlier} = x < Q1 - 1.5 \times IQR \text{ or } x > Q3 + 1.5 \times IQR$ | $O(n \log n)$ | $O(n)$ | 偏态分布 | 稳健 | 需要排序 |
| **移动平均** | 基于移动平均和标准差 | $O(n)$ | $O(1)$ | 时间序列 | 考虑时间性 | 滞后性 |
| **综合评分** | 加权组合多种方法 | $O(n \log n)$ | $O(n)$ | 综合场景 | 准确 | 计算复杂 |

### 6.2 性能优化建议

1. **索引优化**：
   - 在(timestamp, metric_name)上创建复合索引
   - 为常用查询创建索引

2. **窗口函数优化**：
   - 使用物化视图缓存统计信息
   - 优化窗口函数计算

3. **实时检测**：
   - 限制查询时间范围
   - 使用采样减少数据量

### 6.3 常见问题与解决方案

**问题1**：误报率高

- **解决方案**：调整阈值、使用移动平均、添加过滤条件

**问题2**：漏报率高

- **解决方案**：降低阈值、使用多种方法、考虑上下文

**问题3**：计算性能慢

- **解决方案**：使用物化视图、索引优化、并行查询

**问题4**：阈值选择困难

- **解决方案**：基于历史数据、A/B测试、动态调整

---

## 7. 最佳实践

### 7.1 方法选择

1. **正态分布数据**：使用Z-score
2. **偏态分布数据**：使用IQR
3. **时间序列数据**：使用移动平均
4. **综合场景**：使用综合评分

### 7.2 阈值设置

1. **Z-score阈值**：常用2或3
2. **IQR倍数**：常用1.5或3
3. **动态阈值**：基于历史数据动态调整

### 7.3 误报处理

1. **阈值调整**：根据业务需求调整阈值
2. **过滤规则**：添加业务规则过滤误报
3. **告警聚合**：聚合相似告警减少噪音

### 7.4 SQL实现注意事项

1. **NULL处理**：正确处理NULL值
2. **除零处理**：使用NULLIF避免除零
3. **精度控制**：控制数值精度
4. **性能优化**：使用索引和物化视图

---

## 📚 参考资源

### 学术文献

- 《异常检测》（Anomaly Detection）- 异常检测理论
- 《时间序列异常检测》（Time Series Anomaly Detection）- 时间序列方法

### PostgreSQL官方文档

- [窗口函数](https://www.postgresql.org/docs/current/tutorial-window.html)
- [聚合函数](https://www.postgresql.org/docs/current/functions-aggregate.html)
- [统计函数](https://www.postgresql.org/docs/current/functions-aggregate.html#FUNCTIONS-AGGREGATE-STATISTICS-TABLE)

### 在线资源

- PostgreSQL异常检测指南
- 异常检测方法详解
- 异常检测最佳实践

### 相关算法

- [性能指标计算](./性能指标计算.md) - 性能监控
- [容量规划算法](./容量规划算法.md) - 容量规划
- [预测性维护](./预测性维护.md) - 预测性维护

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
