# PostgreSQL 性能指标计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 性能监控 | 指标计算
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 性能指标计算完整指南](#postgresql-性能指标计算完整指南)
  - [📋 目录](#-目录)
  - [性能指标概述](#性能指标概述)
    - [理论基础](#理论基础)
      - [性能指标问题定义](#性能指标问题定义)
      - [性能指标分类](#性能指标分类)
      - [指标计算方法选择](#指标计算方法选择)
    - [核心指标](#核心指标)
  - [1. CPU使用率](#1-cpu使用率)
    - [1.1 CPU使用率原理](#11-cpu使用率原理)
      - [CPU使用率定义](#cpu使用率定义)
      - [CPU使用率计算](#cpu使用率计算)
    - [1.2 CPU使用率计算实现](#12-cpu使用率计算实现)
    - [1.3 CPU负载分析](#13-cpu负载分析)
  - [2. 内存使用率](#2-内存使用率)
    - [2.1 内存使用率原理](#21-内存使用率原理)
      - [内存使用率定义](#内存使用率定义)
      - [内存使用率计算](#内存使用率计算)
    - [2.2 内存使用率计算实现](#22-内存使用率计算实现)
    - [2.3 内存压力分析](#23-内存压力分析)
  - [3. 磁盘I/O](#3-磁盘io)
    - [3.1 磁盘I/O原理](#31-磁盘io原理)
      - [磁盘I/O定义](#磁盘io定义)
      - [I/O指标计算](#io指标计算)
    - [3.2 磁盘I/O统计实现](#32-磁盘io统计实现)
    - [3.3 I/O性能分析](#33-io性能分析)
  - [4. 数据库性能指标](#4-数据库性能指标)
    - [4.1 数据库性能指标原理](#41-数据库性能指标原理)
      - [数据库性能指标定义](#数据库性能指标定义)
      - [性能指标分类](#性能指标分类-1)
    - [4.2 查询性能统计实现](#42-查询性能统计实现)
    - [4.3 连接和事务统计](#43-连接和事务统计)
  - [5. 性能指标优化策略](#5-性能指标优化策略)
    - [5.1 索引优化](#51-索引优化)
    - [5.2 聚合优化](#52-聚合优化)
    - [5.3 实时监控优化](#53-实时监控优化)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 性能监控仪表板](#61-性能监控仪表板)
    - [6.2 性能趋势分析](#62-性能趋势分析)
    - [6.3 性能告警系统](#63-性能告警系统)
    - [6.4 性能瓶颈识别](#64-性能瓶颈识别)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 性能指标计算方法对比](#71-性能指标计算方法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 指标选择](#81-指标选择)
    - [8.2 采样频率](#82-采样频率)
    - [8.3 数据保留](#83-数据保留)
    - [8.4 SQL实现注意事项](#84-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 性能指标概述

**性能指标计算（Performance Metrics Calculation）**用于监控系统运行状态，识别性能瓶颈，是运维监控的核心。

### 理论基础

#### 性能指标问题定义

**性能指标问题**：给定系统监控数据$M = \{m_1, m_2, \ldots, m_T\}$，计算性能指标$I = \{i_1, i_2, \ldots, i_T\}$：
$$i_t = f(m_t, m_{t-1}, \ldots, m_{t-k})$$

其中$f$是指标计算函数。

#### 性能指标分类

性能指标分类：

1. **资源使用指标**：
   - CPU使用率：$\text{CPU\%} = \frac{\text{CPU\_used}}{\text{CPU\_total}} \times 100\%$
   - 内存使用率：$\text{Memory\%} = \frac{\text{Memory\_used}}{\text{Memory\_total}} \times 100\%$
   - 时间复杂度：$O(1)$

2. **I/O性能指标**：
   - IOPS：每秒I/O操作数
   - 吞吐量：每秒传输字节数
   - 延迟：平均响应时间
   - 时间复杂度：$O(n)$

3. **数据库性能指标**：
   - 查询执行时间
   - 连接数
   - 事务吞吐量
   - 时间复杂度：$O(n)$

#### 指标计算方法选择

选择计算方法的考虑因素：

1. **指标类型**：资源使用用比率，I/O用统计，数据库用聚合
2. **时间粒度**：实时用当前值，趋势用移动平均
3. **精度要求**：高精度用详细统计，概览用聚合

### 核心指标

| 指标 | 数学定义 | 用途 | 单位 | 时间复杂度 | 适用场景 |
|------|---------|------|------|-----------|---------|
| **CPU使用率** | $\frac{\text{CPU\_used}}{\text{CPU\_total}} \times 100\%$ | CPU负载 | % | $O(1)$ | 系统监控 |
| **内存使用率** | $\frac{\text{Memory\_used}}{\text{Memory\_total}} \times 100\%$ | 内存占用 | % | $O(1)$ | 内存监控 |
| **磁盘I/O** | $\text{IOPS} = \frac{\text{IO\_count}}{\text{time\_interval}}$ | 磁盘读写 | IOPS | $O(n)$ | I/O监控 |
| **查询性能** | $\text{Avg\_Time} = \frac{1}{n}\sum_{i=1}^{n} t_i$ | 数据库性能 | ms | $O(n)$ | 数据库监控 |

---

## 1. CPU使用率

### 1.1 CPU使用率原理

**CPU使用率（CPU Usage）**是衡量CPU繁忙程度的核心指标。

#### CPU使用率定义

**CPU使用率**：CPU在单位时间内的使用比例：
$$\text{CPU\%} = \frac{\text{CPU\_used\_time}}{\text{CPU\_total\_time}} \times 100\%$$

**Linux系统CPU使用率**：
$$\text{CPU\%} = \left(1 - \frac{\text{idle\_time}}{\text{total\_time}}\right) \times 100\%$$

#### CPU使用率计算

**计算方法**：

1. **瞬时值**：当前时刻的CPU使用率
2. **平均值**：一段时间内的平均CPU使用率
3. **峰值**：一段时间内的最大CPU使用率

### 1.2 CPU使用率计算实现

**CPU使用率**的实现和使用。

```sql
-- 创建系统监控数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 已存在，先删除';
            DROP TABLE system_metrics CASCADE;
        END IF;

        CREATE TABLE system_metrics (
            timestamp TIMESTAMP NOT NULL,
            metric_name VARCHAR(50) NOT NULL,
            metric_value NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (timestamp, metric_name)
        );

        -- 插入示例数据
        INSERT INTO system_metrics (timestamp, metric_name, metric_value) VALUES
            ('2024-01-01 10:00:00', 'cpu_usage', 45.5),
            ('2024-01-01 10:01:00', 'cpu_usage', 52.3),
            ('2024-01-01 10:02:00', 'cpu_usage', 48.7),
            ('2024-01-01 10:00:00', 'memory_usage', 65.2),
            ('2024-01-01 10:01:00', 'memory_usage', 67.8),
            ('2024-01-01 10:02:00', 'memory_usage', 69.1);

        RAISE NOTICE '表 system_metrics 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 system_metrics 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算CPU使用率统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法计算CPU使用率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算CPU使用率统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'CPU使用率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算CPU使用率统计
SELECT
    metric_name,
    COUNT(*) AS sample_count,
    ROUND(AVG(metric_value)::numeric, 2) AS avg_value,
    ROUND(MIN(metric_value)::numeric, 2) AS min_value,
    ROUND(MAX(metric_value)::numeric, 2) AS max_value,
    ROUND(STDDEV(metric_value)::numeric, 2) AS std_value
FROM system_metrics
WHERE metric_name = 'cpu_usage'
GROUP BY metric_name;

-- 计算移动平均CPU使用率
SELECT
    timestamp,
    metric_value,
    AVG(metric_value) OVER (
        ORDER BY timestamp
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS moving_avg_5min
FROM system_metrics
WHERE metric_name = 'cpu_usage'
ORDER BY timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    timestamp,
    AVG(metric_value) OVER (ORDER BY timestamp ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS moving_avg
FROM system_metrics
WHERE metric_name = 'cpu_usage'
ORDER BY timestamp;
```

---

### 1.3 CPU负载分析

**CPU负载分析**：分析CPU负载趋势和峰值。

```sql
-- CPU负载分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法分析CPU负载';
            RETURN;
        END IF;
        RAISE NOTICE '开始分析CPU负载';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'CPU负载分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- CPU负载分析：识别CPU峰值和趋势
WITH cpu_trends AS (
    SELECT
        timestamp,
        metric_value AS cpu_usage,
        AVG(metric_value) OVER (
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS moving_avg_10min,
        MAX(metric_value) OVER (
            ORDER BY timestamp
            ROWS BETWEEN 59 PRECEDING AND CURRENT ROW
        ) AS max_1h
    FROM system_metrics
    WHERE metric_name = 'cpu_usage'
)
SELECT
    timestamp,
    ROUND(cpu_usage::numeric, 2) AS cpu_usage,
    ROUND(moving_avg_10min::numeric, 2) AS moving_avg_10min,
    ROUND(max_1h::numeric, 2) AS max_1h,
    CASE
        WHEN cpu_usage > 90 THEN 'Critical'
        WHEN cpu_usage > 80 THEN 'High'
        WHEN cpu_usage > 70 THEN 'Warning'
        ELSE 'Normal'
    END AS load_level,
    CASE
        WHEN cpu_usage > moving_avg_10min * 1.2 THEN 'Spike'
        WHEN cpu_usage < moving_avg_10min * 0.8 THEN 'Drop'
        ELSE 'Stable'
    END AS trend
FROM cpu_trends
ORDER BY timestamp;
```

---

## 2. 内存使用率

### 2.1 内存使用率原理

**内存使用率（Memory Usage）**监控内存占用情况。

#### 内存使用率定义

**内存使用率**：内存使用量与总内存的比值：
$$\text{Memory\%} = \frac{\text{Memory\_used}}{\text{Memory\_total}} \times 100\%$$

**内存压力**：当内存使用率接近上限时，系统可能出现内存压力。

#### 内存使用率计算

**计算方法**：

1. **当前使用率**：当前时刻的内存使用率
2. **峰值使用率**：一段时间内的最大使用率
3. **平均使用率**：一段时间内的平均使用率

### 2.2 内存使用率计算实现

**内存使用率**的实现和使用。

```sql
-- 内存使用率计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法计算内存使用率';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算内存使用率统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '内存使用率计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算内存使用率统计
SELECT
    timestamp,
    metric_value AS memory_usage_pct,
    CASE
        WHEN metric_value > 90 THEN 'Critical'
        WHEN metric_value > 80 THEN 'Warning'
        WHEN metric_value > 70 THEN 'Caution'
        ELSE 'Normal'
    END AS status
FROM system_metrics
WHERE metric_name = 'memory_usage'
ORDER BY timestamp;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    timestamp,
    metric_value
FROM system_metrics
WHERE metric_name = 'memory_usage'
ORDER BY timestamp;
```

---

### 2.3 内存压力分析

**内存压力分析**：分析内存压力和交换使用。

```sql
-- 内存压力分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法分析内存压力';
            RETURN;
        END IF;
        RAISE NOTICE '开始分析内存压力';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '内存压力分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 内存压力分析：识别内存压力事件
WITH memory_analysis AS (
    SELECT
        timestamp,
        metric_value AS memory_usage,
        LAG(metric_value) OVER (ORDER BY timestamp) AS prev_memory_usage,
        AVG(metric_value) OVER (
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS moving_avg_10min
    FROM system_metrics
    WHERE metric_name = 'memory_usage'
)
SELECT
    timestamp,
    ROUND(memory_usage::numeric, 2) AS memory_usage,
    ROUND(moving_avg_10min::numeric, 2) AS moving_avg_10min,
    CASE
        WHEN memory_usage > 95 THEN 'Critical Pressure'
        WHEN memory_usage > 90 THEN 'High Pressure'
        WHEN memory_usage > 80 THEN 'Moderate Pressure'
        ELSE 'Normal'
    END AS pressure_level,
    CASE
        WHEN memory_usage - COALESCE(prev_memory_usage, memory_usage) > 5 THEN 'Rapid Increase'
        WHEN memory_usage - COALESCE(prev_memory_usage, memory_usage) < -5 THEN 'Rapid Decrease'
        ELSE 'Stable'
    END AS change_trend
FROM memory_analysis
WHERE memory_usage > 80
ORDER BY timestamp;
```

---

## 3. 磁盘I/O

### 3.1 磁盘I/O原理

**磁盘I/O（Disk I/O）**监控磁盘读写性能。

#### 磁盘I/O定义

**IOPS（Input/Output Operations Per Second）**：每秒I/O操作数：
$$\text{IOPS} = \frac{\text{IO\_count}}{\text{time\_interval}}$$

**吞吐量（Throughput）**：每秒传输的字节数：
$$\text{Throughput} = \frac{\text{bytes\_transferred}}{\text{time\_interval}}$$

**延迟（Latency）**：平均响应时间：
$$\text{Latency} = \frac{1}{n}\sum_{i=1}^{n} t_i$$

#### I/O指标计算

**I/O指标**：

1. **IOPS**：读写操作频率
2. **吞吐量**：数据传输速度
3. **延迟**：响应时间
4. **队列深度**：等待队列长度

### 3.2 磁盘I/O统计实现

**磁盘I/O统计**的实现和使用。

```sql
-- 创建磁盘I/O数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'disk_io_metrics') THEN
            RAISE WARNING '表 disk_io_metrics 已存在，先删除';
            DROP TABLE disk_io_metrics CASCADE;
        END IF;

        CREATE TABLE disk_io_metrics (
            timestamp TIMESTAMP NOT NULL,
            device VARCHAR(50) NOT NULL,
            read_iops INTEGER NOT NULL,
            write_iops INTEGER NOT NULL,
            read_bytes BIGINT NOT NULL,
            write_bytes BIGINT NOT NULL,
            PRIMARY KEY (timestamp, device)
        );

        INSERT INTO disk_io_metrics (timestamp, device, read_iops, write_iops, read_bytes, write_bytes) VALUES
            ('2024-01-01 10:00:00', 'sda', 100, 50, 1048576, 524288),
            ('2024-01-01 10:01:00', 'sda', 120, 60, 1258291, 629146),
            ('2024-01-01 10:02:00', 'sda', 110, 55, 1153434, 576717);

        RAISE NOTICE '表 disk_io_metrics 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 disk_io_metrics 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算磁盘I/O统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'disk_io_metrics') THEN
            RAISE WARNING '表 disk_io_metrics 不存在，无法计算磁盘I/O统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算磁盘I/O统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '磁盘I/O统计计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算磁盘I/O统计
SELECT
    device,
    COUNT(*) AS sample_count,
    ROUND(AVG(read_iops)::numeric, 2) AS avg_read_iops,
    ROUND(AVG(write_iops)::numeric, 2) AS avg_write_iops,
    ROUND(AVG(read_iops + write_iops)::numeric, 2) AS avg_total_iops,
    ROUND(AVG(read_bytes)::numeric / 1024 / 1024, 2) AS avg_read_mbps,
    ROUND(AVG(write_bytes)::numeric / 1024 / 1024, 2) AS avg_write_mbps
FROM disk_io_metrics
GROUP BY device
ORDER BY device;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    device,
    AVG(read_iops + write_iops) AS avg_total_iops
FROM disk_io_metrics
GROUP BY device;
```

---

### 3.3 I/O性能分析

**I/O性能分析**：分析I/O瓶颈和性能趋势。

```sql
-- I/O性能分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'disk_io_metrics') THEN
            RAISE WARNING '表 disk_io_metrics 不存在，无法分析I/O性能';
            RETURN;
        END IF;
        RAISE NOTICE '开始分析I/O性能';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'I/O性能分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- I/O性能分析：识别I/O瓶颈
WITH io_performance AS (
    SELECT
        timestamp,
        device,
        read_iops,
        write_iops,
        read_iops + write_iops AS total_iops,
        read_bytes + write_bytes AS total_bytes,
        AVG(read_iops + write_iops) OVER (
            PARTITION BY device
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS avg_iops_10min,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY read_iops + write_iops) OVER (
            PARTITION BY device
            ORDER BY timestamp
            ROWS BETWEEN 59 PRECEDING AND CURRENT ROW
        ) AS p95_iops_1h
    FROM disk_io_metrics
)
SELECT
    timestamp,
    device,
    total_iops,
    ROUND((total_bytes / 1024 / 1024)::numeric, 2) AS total_mbps,
    ROUND(avg_iops_10min::numeric, 2) AS avg_iops_10min,
    ROUND(p95_iops_1h::numeric, 2) AS p95_iops_1h,
    CASE
        WHEN total_iops > p95_iops_1h * 1.5 THEN 'I/O Spike'
        WHEN total_iops > avg_iops_10min * 1.2 THEN 'High I/O'
        ELSE 'Normal'
    END AS io_status
FROM io_performance
WHERE total_iops > avg_iops_10min * 1.2
ORDER BY device, timestamp;
```

---

## 4. 数据库性能指标

### 4.1 数据库性能指标原理

**数据库性能指标（Database Performance Metrics）**监控数据库查询和事务性能。

#### 数据库性能指标定义

**查询性能指标**：

- **平均执行时间**：$\bar{t} = \frac{1}{n}\sum_{i=1}^{n} t_i$
- **P95执行时间**：95%的查询执行时间小于此值
- **吞吐量**：$\text{QPS} = \frac{\text{query\_count}}{\text{time\_interval}}$

#### 性能指标分类

**数据库性能指标分类**：

1. **查询性能**：执行时间、返回行数
2. **连接性能**：连接数、连接等待时间
3. **事务性能**：事务吞吐量、事务延迟
4. **锁性能**：锁等待时间、死锁数

### 4.2 查询性能统计实现

**查询性能统计**的实现和使用。

```sql
-- 创建查询性能数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_performance') THEN
            RAISE WARNING '表 query_performance 已存在，先删除';
            DROP TABLE query_performance CASCADE;
        END IF;

        CREATE TABLE query_performance (
            timestamp TIMESTAMP NOT NULL,
            query_id VARCHAR(100) NOT NULL,
            execution_time_ms NUMERIC(10, 2) NOT NULL,
            rows_returned INTEGER NOT NULL,
            PRIMARY KEY (timestamp, query_id)
        );

        INSERT INTO query_performance (timestamp, query_id, execution_time_ms, rows_returned) VALUES
            ('2024-01-01 10:00:00', 'query_001', 125.5, 1000),
            ('2024-01-01 10:01:00', 'query_001', 130.2, 1050),
            ('2024-01-01 10:02:00', 'query_001', 118.7, 980),
            ('2024-01-01 10:00:00', 'query_002', 45.3, 500),
            ('2024-01-01 10:01:00', 'query_002', 42.1, 480);

        RAISE NOTICE '表 query_performance 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 query_performance 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算查询性能统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_performance') THEN
            RAISE WARNING '表 query_performance 不存在，无法计算查询性能统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算查询性能统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询性能统计计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算查询性能统计
SELECT
    query_id,
    COUNT(*) AS execution_count,
    ROUND(AVG(execution_time_ms)::numeric, 2) AS avg_execution_time,
    ROUND(MIN(execution_time_ms)::numeric, 2) AS min_execution_time,
    ROUND(MAX(execution_time_ms)::numeric, 2) AS max_execution_time,
    ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY execution_time_ms)::numeric, 2) AS p95_execution_time,
    ROUND(AVG(rows_returned)::numeric, 0) AS avg_rows_returned
FROM query_performance
GROUP BY query_id
ORDER BY avg_execution_time DESC;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    query_id,
    AVG(execution_time_ms) AS avg_time
FROM query_performance
GROUP BY query_id;
```

---

### 4.3 连接和事务统计

**连接和事务统计**：监控数据库连接和事务性能。

```sql
-- 连接和事务统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'database_connections') THEN
            RAISE WARNING '表 database_connections 不存在，创建示例表';

            CREATE TABLE database_connections (
                timestamp TIMESTAMP NOT NULL,
                database_name VARCHAR(100) NOT NULL,
                active_connections INTEGER NOT NULL,
                idle_connections INTEGER NOT NULL,
                waiting_connections INTEGER NOT NULL,
                PRIMARY KEY (timestamp, database_name)
            );

            INSERT INTO database_connections (timestamp, database_name, active_connections, idle_connections, waiting_connections) VALUES
                ('2024-01-01 10:00:00', 'db_prod', 50, 20, 2),
                ('2024-01-01 10:01:00', 'db_prod', 55, 18, 3),
                ('2024-01-01 10:02:00', 'db_prod', 60, 15, 5);

            RAISE NOTICE '表 database_connections 创建成功';
        END IF;

        RAISE NOTICE '开始统计连接和事务';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '连接和事务统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 连接和事务统计
WITH connection_stats AS (
    SELECT
        database_name,
        timestamp,
        active_connections,
        idle_connections,
        waiting_connections,
        active_connections + idle_connections + waiting_connections AS total_connections,
        AVG(active_connections) OVER (
            PARTITION BY database_name
            ORDER BY timestamp
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS avg_active_connections
    FROM database_connections
)
SELECT
    database_name,
    timestamp,
    active_connections,
    idle_connections,
    waiting_connections,
    total_connections,
    ROUND(avg_active_connections::numeric, 2) AS avg_active_connections,
    ROUND((waiting_connections::NUMERIC / NULLIF(total_connections, 0) * 100)::numeric, 2) AS waiting_pct,
    CASE
        WHEN waiting_connections > 10 THEN 'Connection Contention'
        WHEN waiting_connections > 5 THEN 'Moderate Wait'
        ELSE 'Normal'
    END AS connection_status
FROM connection_stats
ORDER BY database_name, timestamp;
```

---

## 5. 性能指标优化策略

### 5.1 索引优化

**索引优化**：为性能指标查询创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 系统指标表索引
        CREATE INDEX IF NOT EXISTS idx_system_metrics_timestamp_metric
        ON system_metrics(timestamp, metric_name);

        CREATE INDEX IF NOT EXISTS idx_system_metrics_metric_timestamp
        ON system_metrics(metric_name, timestamp);

        -- 磁盘I/O表索引
        CREATE INDEX IF NOT EXISTS idx_disk_io_metrics_timestamp_device
        ON disk_io_metrics(timestamp, device);

        -- 查询性能表索引
        CREATE INDEX IF NOT EXISTS idx_query_performance_timestamp_query
        ON query_performance(timestamp, query_id);

        RAISE NOTICE '性能指标索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 聚合优化

**聚合优化**：使用物化视图缓存常用统计。

```sql
-- 聚合优化：使用物化视图缓存性能指标统计
CREATE MATERIALIZED VIEW IF NOT EXISTS performance_metrics_summary AS
SELECT
    metric_name,
    DATE_TRUNC('hour', timestamp) AS hour,
    COUNT(*) AS sample_count,
    AVG(metric_value) AS avg_value,
    MIN(metric_value) AS min_value,
    MAX(metric_value) AS max_value,
    STDDEV(metric_value) AS std_value
FROM system_metrics
GROUP BY metric_name, DATE_TRUNC('hour', timestamp);

CREATE INDEX IF NOT EXISTS idx_performance_metrics_summary_metric_hour
ON performance_metrics_summary(metric_name, hour);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY performance_metrics_summary;
```

### 5.3 实时监控优化

**实时监控优化**：优化实时监控查询性能。

```sql
-- 实时监控优化（带错误处理）
DO $$
BEGIN
    BEGIN
        SET work_mem = '256MB';
        RAISE NOTICE '实时监控优化配置已设置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '实时监控优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 6. 实际应用案例

### 6.1 性能监控仪表板

**性能监控仪表板**综合展示各项性能指标。

```sql
-- 性能监控仪表板数据查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法生成监控仪表板';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成性能监控仪表板数据';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '监控仪表板生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 生成性能监控仪表板数据
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH latest_metrics AS (
    SELECT
        metric_name,
        metric_value,
        timestamp
    FROM system_metrics
    WHERE timestamp = (SELECT MAX(timestamp) FROM system_metrics)
),
summary_stats AS (
    SELECT
        metric_name,
        COUNT(*) AS sample_count,
        AVG(metric_value) AS avg_value,
        MIN(metric_value) AS min_value,
        MAX(metric_value) AS max_value,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY metric_value) AS p95_value
    FROM system_metrics
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
    GROUP BY metric_name
)
SELECT
    lm.metric_name,
    lm.metric_value AS current_value,
    ROUND(ss.avg_value::numeric, 2) AS avg_value_1h,
    ROUND(ss.min_value::numeric, 2) AS min_value_1h,
    ROUND(ss.max_value::numeric, 2) AS max_value_1h,
    ROUND(ss.p95_value::numeric, 2) AS p95_value_1h,
    CASE
        WHEN lm.metric_name = 'cpu_usage' AND lm.metric_value > 80 THEN 'Critical'
        WHEN lm.metric_name = 'cpu_usage' AND lm.metric_value > 70 THEN 'Warning'
        WHEN lm.metric_name = 'memory_usage' AND lm.metric_value > 90 THEN 'Critical'
        WHEN lm.metric_name = 'memory_usage' AND lm.metric_value > 80 THEN 'Warning'
        ELSE 'Normal'
    END AS status
FROM latest_metrics lm
JOIN summary_stats ss ON lm.metric_name = ss.metric_name
ORDER BY lm.metric_name;
```

### 6.2 性能趋势分析

**性能趋势分析**：分析性能指标的变化趋势。

```sql
-- 性能趋势分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法分析性能趋势';
            RETURN;
        END IF;
        RAISE NOTICE '开始分析性能趋势';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能趋势分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能趋势分析：识别性能变化趋势
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH hourly_metrics AS (
    SELECT
        DATE_TRUNC('hour', timestamp) AS hour,
        metric_name,
        AVG(metric_value) AS avg_value,
        MIN(metric_value) AS min_value,
        MAX(metric_value) AS max_value
    FROM system_metrics
    WHERE timestamp >= NOW() - INTERVAL '24 hours'
    GROUP BY DATE_TRUNC('hour', timestamp), metric_name
),
trend_analysis AS (
    SELECT
        hour,
        metric_name,
        avg_value,
        LAG(avg_value) OVER (PARTITION BY metric_name ORDER BY hour) AS prev_avg,
        AVG(avg_value) OVER (
            PARTITION BY metric_name
            ORDER BY hour
            ROWS BETWEEN 3 PRECEDING AND CURRENT ROW
        ) AS moving_avg_4h
    FROM hourly_metrics
)
SELECT
    hour,
    metric_name,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(prev_avg::numeric, 2) AS prev_avg,
    ROUND(moving_avg_4h::numeric, 2) AS moving_avg_4h,
    ROUND(((avg_value - COALESCE(prev_avg, avg_value)) / NULLIF(prev_avg, 0) * 100)::numeric, 2) AS change_pct,
    CASE
        WHEN avg_value > moving_avg_4h * 1.2 THEN 'Increasing Trend'
        WHEN avg_value < moving_avg_4h * 0.8 THEN 'Decreasing Trend'
        ELSE 'Stable Trend'
    END AS trend_direction
FROM trend_analysis
WHERE prev_avg IS NOT NULL
ORDER BY metric_name, hour;
```

### 6.3 性能告警系统

**性能告警系统**：基于性能指标生成告警。

```sql
-- 性能告警系统（带错误处理和性能测试）
DO $$
DECLARE
    cpu_warning_threshold NUMERIC := 70;
    cpu_critical_threshold NUMERIC := 80;
    memory_warning_threshold NUMERIC := 80;
    memory_critical_threshold NUMERIC := 90;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法生成性能告警';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成性能告警，CPU警告阈值: %, 临界阈值: %', cpu_warning_threshold, cpu_critical_threshold;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能告警系统准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能告警系统：实时监控并生成告警
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH recent_metrics AS (
    SELECT
        timestamp,
        metric_name,
        metric_value
    FROM system_metrics
    WHERE timestamp >= NOW() - INTERVAL '5 minutes'
),
alert_conditions AS (
    SELECT
        timestamp,
        metric_name,
        metric_value,
        CASE
            WHEN metric_name = 'cpu_usage' AND metric_value > cpu_critical_threshold THEN 'CRITICAL'
            WHEN metric_name = 'cpu_usage' AND metric_value > cpu_warning_threshold THEN 'WARNING'
            WHEN metric_name = 'memory_usage' AND metric_value > memory_critical_threshold THEN 'CRITICAL'
            WHEN metric_name = 'memory_usage' AND metric_value > memory_warning_threshold THEN 'WARNING'
            ELSE 'NORMAL'
        END AS alert_level,
        CASE
            WHEN metric_name = 'cpu_usage' AND metric_value > cpu_critical_threshold THEN 'CPU usage exceeds critical threshold'
            WHEN metric_name = 'cpu_usage' AND metric_value > cpu_warning_threshold THEN 'CPU usage exceeds warning threshold'
            WHEN metric_name = 'memory_usage' AND metric_value > memory_critical_threshold THEN 'Memory usage exceeds critical threshold'
            WHEN metric_name = 'memory_usage' AND metric_value > memory_warning_threshold THEN 'Memory usage exceeds warning threshold'
            ELSE NULL
        END AS alert_message
    FROM recent_metrics
)
SELECT
    timestamp,
    metric_name,
    ROUND(metric_value::numeric, 2) AS metric_value,
    alert_level,
    alert_message
FROM alert_conditions
WHERE alert_level != 'NORMAL'
ORDER BY
    CASE alert_level WHEN 'CRITICAL' THEN 1 WHEN 'WARNING' THEN 2 ELSE 3 END,
    timestamp DESC;
```

### 6.4 性能瓶颈识别

**性能瓶颈识别**：识别系统性能瓶颈。

```sql
-- 性能瓶颈识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'system_metrics') THEN
            RAISE WARNING '表 system_metrics 不存在，无法识别性能瓶颈';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'disk_io_metrics') THEN
            RAISE WARNING '表 disk_io_metrics 不存在，无法识别性能瓶颈';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_performance') THEN
            RAISE WARNING '表 query_performance 不存在，无法识别性能瓶颈';
            RETURN;
        END IF;
        RAISE NOTICE '开始识别性能瓶颈';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能瓶颈识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能瓶颈识别：综合分析多个指标
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH cpu_bottleneck AS (
    SELECT
        'CPU' AS resource_type,
        COUNT(*) FILTER (WHERE metric_value > 80) AS critical_count,
        AVG(metric_value) FILTER (WHERE metric_value > 80) AS avg_critical_value
    FROM system_metrics
    WHERE metric_name = 'cpu_usage' AND timestamp >= NOW() - INTERVAL '1 hour'
),
memory_bottleneck AS (
    SELECT
        'Memory' AS resource_type,
        COUNT(*) FILTER (WHERE metric_value > 90) AS critical_count,
        AVG(metric_value) FILTER (WHERE metric_value > 90) AS avg_critical_value
    FROM system_metrics
    WHERE metric_name = 'memory_usage' AND timestamp >= NOW() - INTERVAL '1 hour'
),
io_bottleneck AS (
    SELECT
        'Disk I/O' AS resource_type,
        COUNT(*) FILTER (WHERE read_iops + write_iops > 1000) AS critical_count,
        AVG(read_iops + write_iops) FILTER (WHERE read_iops + write_iops > 1000) AS avg_critical_value
    FROM disk_io_metrics
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
),
query_bottleneck AS (
    SELECT
        'Query Performance' AS resource_type,
        COUNT(*) FILTER (WHERE execution_time_ms > 1000) AS critical_count,
        AVG(execution_time_ms) FILTER (WHERE execution_time_ms > 1000) AS avg_critical_value
    FROM query_performance
    WHERE timestamp >= NOW() - INTERVAL '1 hour'
),
all_bottlenecks AS (
    SELECT * FROM cpu_bottleneck
    UNION ALL SELECT * FROM memory_bottleneck
    UNION ALL SELECT * FROM io_bottleneck
    UNION ALL SELECT * FROM query_bottleneck
)
SELECT
    resource_type,
    critical_count,
    ROUND(avg_critical_value::numeric, 2) AS avg_critical_value,
    CASE
        WHEN critical_count > 10 THEN 'Severe Bottleneck'
        WHEN critical_count > 5 THEN 'Moderate Bottleneck'
        WHEN critical_count > 0 THEN 'Minor Bottleneck'
        ELSE 'No Bottleneck'
    END AS bottleneck_severity,
    CASE
        WHEN critical_count > 10 THEN 'Immediate action required'
        WHEN critical_count > 5 THEN 'Investigation recommended'
        WHEN critical_count > 0 THEN 'Monitor closely'
        ELSE 'System operating normally'
    END AS recommendation
FROM all_bottlenecks
ORDER BY critical_count DESC;
```

---

## 7. 算法性能对比与优化

### 7.1 性能指标计算方法对比

| 方法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **瞬时值** | $I_t = M_t$ | $O(1)$ | $O(1)$ | 实时监控 | 简单、快速 | 波动大 |
| **移动平均** | $I_t = \frac{1}{n}\sum_{i=0}^{n-1} M_{t-i}$ | $O(n)$ | $O(1)$ | 趋势分析 | 平滑 | 滞后性 |
| **聚合统计** | $I = \{\text{avg}, \text{min}, \text{max}, \text{std}\}$ | $O(n)$ | $O(1)$ | 历史分析 | 全面 | 计算复杂 |

### 7.2 性能优化建议

1. **索引优化**：
   - 在(timestamp, metric_name)上创建复合索引
   - 为常用查询创建索引

2. **聚合优化**：
   - 使用物化视图缓存统计
   - 按时间分区存储数据

3. **实时监控**：
   - 限制查询时间范围
   - 使用采样减少数据量

### 7.3 常见问题与解决方案

**问题1**：监控数据量大

- **解决方案**：时间分区、数据归档、采样

**问题2**：实时查询性能慢

- **解决方案**：物化视图、索引优化、限制时间范围

**问题3**：告警误报多

- **解决方案**：调整阈值、使用移动平均、添加过滤条件

**问题4**：指标不一致

- **解决方案**：统一计算方法、标准化数据格式、定期校准

---

## 8. 最佳实践

### 8.1 指标选择

1. **核心指标**：CPU、内存、磁盘I/O、网络
2. **数据库指标**：查询性能、连接数、事务吞吐量
3. **业务指标**：响应时间、错误率、吞吐量

### 8.2 采样频率

1. **实时监控**：1-5分钟采样
2. **趋势分析**：15-60分钟采样
3. **历史分析**：1小时或1天采样

### 8.3 数据保留

1. **实时数据**：保留1-7天
2. **历史数据**：保留30-90天
3. **归档数据**：保留1年以上

### 8.4 SQL实现注意事项

1. **时间范围**：限制查询时间范围
2. **索引使用**：确保使用索引
3. **聚合优化**：使用物化视图
4. **错误处理**：处理NULL值和边界情况

---

## 📚 参考资源

### 学术文献

- 《系统性能优化》（Systems Performance）- 性能监控理论
- 《数据库性能调优》（Database Performance Tuning）- 数据库性能优化

### PostgreSQL官方文档

- [系统视图](https://www.postgresql.org/docs/current/monitoring-stats.html)
- [性能统计](https://www.postgresql.org/docs/current/monitoring.html)
- [pg_stat_statements](https://www.postgresql.org/docs/current/pgstatstatements.html)

### 在线资源

- PostgreSQL性能监控指南
- 系统性能指标详解
- 性能监控最佳实践

### 相关算法

- [容量规划算法](./容量规划算法.md) - 容量规划
- [异常检测算法](./异常检测算法.md) - 异常检测
- [资源优化算法](./资源优化算法.md) - 资源优化

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
