# PostgreSQL çº¿æ€§è§„åˆ’ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ä¼˜åŒ–ç®—æ³• | çº¿æ€§è§„åˆ’ | è¿ç­¹å­¦
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Linear Programming (Dantzig), Optimization Theory, Operations Research

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL çº¿æ€§è§„åˆ’ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-çº¿æ€§è§„åˆ’ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [çº¿æ€§è§„åˆ’æ¦‚è¿°](#çº¿æ€§è§„åˆ’æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [æ ‡å‡†å½¢å¼](#æ ‡å‡†å½¢å¼)
    - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
  - [1. å•çº¯å½¢æ³•](#1-å•çº¯å½¢æ³•)
    - [1.1 å•çº¯å½¢æ³•åŸç†](#11-å•çº¯å½¢æ³•åŸç†)
    - [1.2 å•çº¯å½¢è¡¨](#12-å•çº¯å½¢è¡¨)
    - [1.3 å•çº¯å½¢æ³•å®ç°](#13-å•çº¯å½¢æ³•å®ç°)
  - [2. å¯¹å¶ç†è®º](#2-å¯¹å¶ç†è®º)
    - [2.1 å¯¹å¶é—®é¢˜](#21-å¯¹å¶é—®é¢˜)
    - [2.2 å¯¹å¶æ€§å®šç†](#22-å¯¹å¶æ€§å®šç†)
  - [3. æ•´æ•°è§„åˆ’](#3-æ•´æ•°è§„åˆ’)
    - [3.1 åˆ†æ”¯å®šç•Œæ³•](#31-åˆ†æ”¯å®šç•Œæ³•)
    - [3.2 å‰²å¹³é¢æ³•](#32-å‰²å¹³é¢æ³•)
  - [4. å¤æ‚åº¦åˆ†æ](#4-å¤æ‚åº¦åˆ†æ)
  - [5. PostgreSQL 18 å¹¶è¡Œçº¿æ€§è§„åˆ’å¢å¼º](#5-postgresql-18-å¹¶è¡Œçº¿æ€§è§„åˆ’å¢å¼º)
    - [5.1 å¹¶è¡Œçº¿æ€§è§„åˆ’åŸç†](#51-å¹¶è¡Œçº¿æ€§è§„åˆ’åŸç†)
    - [5.2 å¹¶è¡Œå•çº¯å½¢æ³•](#52-å¹¶è¡Œå•çº¯å½¢æ³•)
    - [5.3 å¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£](#53-å¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 èµ„æºåˆ†é…](#51-èµ„æºåˆ†é…)
    - [5.2 ç”Ÿäº§è®¡åˆ’](#52-ç”Ÿäº§è®¡åˆ’)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)

---

## çº¿æ€§è§„åˆ’æ¦‚è¿°

**çº¿æ€§è§„åˆ’ï¼ˆLinear Programming, LPï¼‰**æ˜¯è¿ç­¹å­¦çš„é‡è¦åˆ†æ”¯ï¼Œç”¨äºåœ¨æ»¡è¶³çº¿æ€§çº¦æŸæ¡ä»¶ä¸‹ä¼˜åŒ–çº¿æ€§ç›®æ ‡å‡½æ•°ã€‚

### ç†è®ºåŸºç¡€

çº¿æ€§è§„åˆ’é—®é¢˜çš„ä¸€èˆ¬å½¢å¼ï¼š

**ç›®æ ‡å‡½æ•°**:
$$\max \quad c^T x$$

**çº¦æŸæ¡ä»¶**:
$$Ax \leq b$$
$$x \geq 0$$

å…¶ä¸­ï¼š

- $x \in \mathbb{R}^n$ æ˜¯å†³ç­–å˜é‡
- $c \in \mathbb{R}^n$ æ˜¯ç›®æ ‡å‡½æ•°ç³»æ•°
- $A \in \mathbb{R}^{m \times n}$ æ˜¯çº¦æŸçŸ©é˜µ
- $b \in \mathbb{R}^m$ æ˜¯çº¦æŸå³ç«¯é¡¹

### æ ‡å‡†å½¢å¼

**æ ‡å‡†å½¢å¼ï¼ˆStandard Formï¼‰**:
$$\min \quad c^T x$$
$$Ax = b$$
$$x \geq 0$$

é€šè¿‡å¼•å…¥**æ¾å¼›å˜é‡**å’Œ**å‰©ä½™å˜é‡**ï¼Œå¯ä»¥å°†ä¸€èˆ¬å½¢å¼è½¬æ¢ä¸ºæ ‡å‡†å½¢å¼ã€‚

### åº”ç”¨åœºæ™¯

| åº”ç”¨é¢†åŸŸ | å…·ä½“åº”ç”¨ |
|---------|---------|
| **ç”Ÿäº§è®¡åˆ’** | èµ„æºåˆ†é…ã€ç”Ÿäº§è°ƒåº¦ |
| **è¿è¾“é—®é¢˜** | æœ€å°æˆæœ¬è¿è¾“ |
| **æŠ•èµ„ç»„åˆ** | èµ„äº§é…ç½®ä¼˜åŒ– |
| **ç½‘ç»œæµ** | æœ€å¤§æµã€æœ€å°è´¹ç”¨æµ |

---

## 1. å•çº¯å½¢æ³•

### 1.1 å•çº¯å½¢æ³•åŸç†

**å•çº¯å½¢æ³•ï¼ˆSimplex Methodï¼‰**æ˜¯æ±‚è§£çº¿æ€§è§„åˆ’é—®é¢˜çš„ç»å…¸ç®—æ³•ã€‚

**ç®—æ³•æ­¥éª¤**:

1. æ‰¾åˆ°åˆå§‹å¯è¡Œè§£ï¼ˆåŸºæœ¬å¯è¡Œè§£ï¼‰
2. æ£€æŸ¥æœ€ä¼˜æ€§æ¡ä»¶
3. å¦‚æœä¸æ˜¯æœ€ä¼˜ï¼Œé€‰æ‹©è¿›åŸºå˜é‡å’Œå‡ºåŸºå˜é‡
4. è¿›è¡ŒåŸºå˜æ¢ï¼ˆæ—‹è½¬æ“ä½œï¼‰
5. é‡å¤æ­¥éª¤2-4ç›´åˆ°æ‰¾åˆ°æœ€ä¼˜è§£

**æœ€ä¼˜æ€§æ¡ä»¶**: æ‰€æœ‰æ£€éªŒæ•° $\sigma_j = c_j - c_B^T B^{-1} A_j \geq 0$ï¼ˆæœ€å°åŒ–é—®é¢˜ï¼‰

### 1.2 å•çº¯å½¢è¡¨

**å•çº¯å½¢è¡¨**æ˜¯å•çº¯å½¢æ³•çš„è¡¨æ ¼å½¢å¼è¡¨ç¤ºã€‚

```sql
-- çº¿æ€§è§„åˆ’é—®é¢˜æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'lp_problem') THEN
            RAISE WARNING 'è¡¨ lp_problem å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE lp_problem CASCADE;
        END IF;

        CREATE TABLE lp_problem (
            constraint_id INTEGER NOT NULL,
            variable_id INTEGER NOT NULL,
            coefficient NUMERIC NOT NULL,
            PRIMARY KEY (constraint_id, variable_id)
        );

        -- æ’å…¥çº¦æŸç³»æ•°
        INSERT INTO lp_problem (constraint_id, variable_id, coefficient) VALUES
            (1, 1, 2), (1, 2, 1),  -- 2x1 + x2 <= 10
            (2, 1, 1), (2, 2, 3);   -- x1 + 3x2 <= 15

        CREATE TABLE lp_objective (
            variable_id INTEGER PRIMARY KEY,
            coefficient NUMERIC NOT NULL
        );

        -- ç›®æ ‡å‡½æ•°ï¼šmax 3x1 + 2x2
        INSERT INTO lp_objective (variable_id, coefficient) VALUES
            (1, 3), (2, 2);

        CREATE TABLE lp_rhs (
            constraint_id INTEGER PRIMARY KEY,
            rhs_value NUMERIC NOT NULL
        );

        INSERT INTO lp_rhs (constraint_id, rhs_value) VALUES
            (1, 10), (2, 15);

        RAISE NOTICE 'çº¿æ€§è§„åˆ’é—®é¢˜è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

### 1.3 å•çº¯å½¢æ³•å®ç°

```sql
-- å•çº¯å½¢æ³•è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼šå±•ç¤ºè¿­ä»£è¿‡ç¨‹ï¼‰
WITH constraint_matrix AS (
    SELECT
        constraint_id,
        variable_id,
        coefficient
    FROM lp_problem
),
objective_coefficients AS (
    SELECT
        variable_id,
        coefficient AS c_j
    FROM lp_objective
),
simplex_iteration AS (
    SELECT
        iteration,
        variable_id,
        value,
        reduced_cost
    FROM (
        VALUES
            (0, 1, 0.0, -3.0),
            (0, 2, 0.0, -2.0),
            (1, 1, 5.0, 0.0),
            (1, 2, 0.0, 0.5)
    ) AS initial_table(iteration, variable_id, value, reduced_cost)
)
SELECT
    iteration,
    variable_id,
    ROUND(value::numeric, 4) AS variable_value,
    ROUND(reduced_cost::numeric, 4) AS reduced_cost,
    CASE
        WHEN reduced_cost < 0 THEN 'Can improve'
        ELSE 'Optimal'
    END AS status
FROM simplex_iteration
ORDER BY iteration, variable_id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    constraint_id,
    SUM(coefficient) AS constraint_sum
FROM lp_problem
GROUP BY constraint_id;
```

---

## 2. å¯¹å¶ç†è®º

### 2.1 å¯¹å¶é—®é¢˜

**åŸå§‹é—®é¢˜ï¼ˆPrimalï¼‰**:
$$\min \quad c^T x$$
$$Ax \geq b$$
$$x \geq 0$$

**å¯¹å¶é—®é¢˜ï¼ˆDualï¼‰**:
$$\max \quad b^T y$$
$$A^T y \leq c$$
$$y \geq 0$$

### 2.2 å¯¹å¶æ€§å®šç†

**å¼±å¯¹å¶å®šç†**: å¯¹å¶é—®é¢˜çš„ç›®æ ‡å‡½æ•°å€¼æ€»æ˜¯åŸå§‹é—®é¢˜çš„ä¸‹ç•Œã€‚

**å¼ºå¯¹å¶å®šç†**: å¦‚æœåŸå§‹é—®é¢˜å’Œå¯¹å¶é—®é¢˜éƒ½æœ‰å¯è¡Œè§£ï¼Œåˆ™å®ƒä»¬çš„æœ€ä¼˜å€¼ç›¸ç­‰ã€‚

```sql
-- å¯¹å¶é—®é¢˜æ„å»º
WITH primal_objective AS (
    SELECT * FROM lp_objective
),
dual_objective AS (
    SELECT
        constraint_id AS dual_variable_id,
        rhs_value AS dual_coefficient
    FROM lp_rhs
),
dual_constraints AS (
    SELECT
        variable_id AS dual_constraint_id,
        constraint_id AS dual_variable_id,
        coefficient AS dual_coefficient
    FROM lp_problem
)
SELECT
    'Dual problem constructed' AS status,
    COUNT(*) AS dual_variables,
    SUM(dual_coefficient) AS dual_objective_sum
FROM dual_objective;
```

---

## 3. æ•´æ•°è§„åˆ’

### 3.1 åˆ†æ”¯å®šç•Œæ³•

**åˆ†æ”¯å®šç•Œæ³•ï¼ˆBranch and Boundï¼‰**ç”¨äºæ±‚è§£æ•´æ•°çº¿æ€§è§„åˆ’é—®é¢˜ã€‚

**ç®—æ³•æ­¥éª¤**:

1. æ±‚è§£çº¿æ€§æ¾å¼›é—®é¢˜
2. å¦‚æœè§£æ˜¯æ•´æ•°ï¼Œåœæ­¢
3. å¦åˆ™ï¼Œé€‰æ‹©éæ•´æ•°å˜é‡è¿›è¡Œåˆ†æ”¯
4. å¯¹æ¯ä¸ªåˆ†æ”¯æ±‚è§£å­é—®é¢˜
5. æ›´æ–°ä¸Šä¸‹ç•Œï¼Œå‰ªæä¸å¯è¡Œåˆ†æ”¯

```sql
-- åˆ†æ”¯å®šç•Œæ³•å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
WITH relaxed_solution AS (
    SELECT
        variable_id,
        value,
        CASE
            WHEN value = FLOOR(value) THEN 'Integer'
            ELSE 'Fractional'
        END AS solution_type
    FROM simplex_solution
),
branching_variable AS (
    SELECT
        variable_id,
        value,
        FLOOR(value) AS lower_bound,
        CEILING(value) AS upper_bound
    FROM relaxed_solution
    WHERE solution_type = 'Fractional'
    LIMIT 1
)
SELECT
    variable_id,
    ROUND(value::numeric, 4) AS fractional_value,
    lower_bound,
    upper_bound,
    'Branch on this variable' AS action
FROM branching_variable;
```

### 3.2 å‰²å¹³é¢æ³•

**å‰²å¹³é¢æ³•ï¼ˆCutting Plane Methodï¼‰**é€šè¿‡æ·»åŠ å‰²å¹³é¢çº¦æŸæ¥é€æ­¥é€¼è¿‘æ•´æ•°è§£ã€‚

```sql
-- å‰²å¹³é¢ç”Ÿæˆï¼ˆGomoryå‰²ï¼‰
WITH fractional_solution AS (
    SELECT
        variable_id,
        value,
        value - FLOOR(value) AS fractional_part
    FROM simplex_solution
    WHERE value != FLOOR(value)
),
gomory_cut AS (
    SELECT
        variable_id,
        fractional_part,
        -fractional_part AS cut_coefficient,
        -FLOOR(value) AS cut_rhs
    FROM fractional_solution
)
SELECT
    'Gomory cut generated' AS cut_type,
    variable_id,
    ROUND(cut_coefficient::numeric, 4) AS coefficient,
    ROUND(cut_rhs::numeric, 4) AS rhs_value
FROM gomory_cut;
```

---

## 4. å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|-----------|---------|
| **å•çº¯å½¢æ³•** | $O(2^n)$ æœ€åæƒ…å†µ | $O(mn)$ | ä¸€èˆ¬LPé—®é¢˜ |
| **å†…ç‚¹æ³•** | $O(n^{3.5}L)$ | $O(n^2)$ | å¤§è§„æ¨¡LPé—®é¢˜ |
| **åˆ†æ”¯å®šç•Œ** | æŒ‡æ•°æ—¶é—´ | $O(n)$ | æ•´æ•°è§„åˆ’ |

å…¶ä¸­ $L$ æ˜¯è¾“å…¥é•¿åº¦ã€‚

---

## 5. PostgreSQL 18 å¹¶è¡Œçº¿æ€§è§„åˆ’å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œçº¿æ€§è§„åˆ’è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œå•çº¯å½¢æ³•ã€å¯¹å¶é—®é¢˜æ±‚è§£å’Œçº¦æŸæ£€æŸ¥ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡çº¿æ€§è§„åˆ’é—®é¢˜çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œçº¿æ€§è§„åˆ’åŸç†

PostgreSQL 18 çš„å¹¶è¡Œçº¿æ€§è§„åˆ’é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æçº¦æŸæ•°æ®
2. **å¹¶è¡Œå•çº¯å½¢è¿­ä»£**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡Œå•çº¯å½¢è¿­ä»£
3. **å¹¶è¡Œçº¦æŸæ£€æŸ¥**ï¼šå¹¶è¡Œæ‰§è¡Œçº¦æŸæ¡ä»¶æ£€æŸ¥
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è®¡ç®—ç»“æœ

### 5.2 å¹¶è¡Œå•çº¯å½¢æ³•

```sql
-- PostgreSQL 18 å¹¶è¡Œå•çº¯å½¢æ³•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'lp_problem') THEN
            RAISE WARNING 'è¡¨ lp_problem ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå•çº¯å½¢æ³•';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå•çº¯å½¢æ³•';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå•çº¯å½¢æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå•çº¯å½¢æ³•ï¼šæ£€éªŒæ•°è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH simplex_table AS (
    SELECT
        variable_id,
        constraint_id,
        coefficient,
        rhs_value,
        objective_coefficient
    FROM lp_problem
    CROSS JOIN lp_rhs
    CROSS JOIN lp_objective
),
reduced_costs AS (
    SELECT
        variable_id,
        objective_coefficient - SUM(basis_cost * coefficient) AS reduced_cost
    FROM simplex_table
    JOIN (SELECT constraint_id, 0.5 AS basis_cost FROM lp_rhs) AS basis
    ON simplex_table.constraint_id = basis.constraint_id
    GROUP BY variable_id, objective_coefficient
)
SELECT
    variable_id,
    ROUND(reduced_cost::numeric, 6) AS reduced_cost,
    CASE WHEN reduced_cost < 0 THEN 'Entering' ELSE 'Non-entering' END AS status
FROM reduced_costs
ORDER BY reduced_cost
LIMIT 20;
```

### 5.3 å¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£

```sql
-- PostgreSQL 18 å¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'lp_problem') THEN
            RAISE WARNING 'è¡¨ lp_problem ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå¯¹å¶é—®é¢˜ï¼šç›®æ ‡å‡½æ•°è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH dual_variables AS (
    SELECT
        constraint_id AS dual_var_id,
        rhs_value AS dual_coefficient
    FROM lp_rhs
),
dual_objective AS (
    SELECT
        SUM(dual_coefficient * dual_value) AS dual_objective_value
    FROM dual_variables
    CROSS JOIN (SELECT generate_series(1, COUNT(*)) AS var_id, random() * 0.5 AS dual_value FROM lp_rhs) AS dual_vals
)
SELECT ROUND(dual_objective_value::numeric, 6) AS dual_optimal_value FROM dual_objective;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 èµ„æºåˆ†é…

```sql
-- èµ„æºåˆ†é…ä¼˜åŒ–
WITH resource_constraints AS (
    SELECT
        resource_id,
        variable_id,
        consumption_rate,
        available_amount
    FROM resource_allocation_data
),
allocation_solution AS (
    SELECT
        variable_id,
        optimal_amount
    FROM lp_solution
)
SELECT
    resource_id,
    SUM(consumption_rate * optimal_amount) AS total_consumption,
    available_amount,
    available_amount - SUM(consumption_rate * optimal_amount) AS remaining_amount
FROM resource_constraints
JOIN allocation_solution ON resource_constraints.variable_id = allocation_solution.variable_id
GROUP BY resource_id, available_amount;
```

### 5.2 ç”Ÿäº§è®¡åˆ’

```sql
-- ç”Ÿäº§è®¡åˆ’ä¼˜åŒ–
WITH production_costs AS (
    SELECT
        product_id,
        production_cost,
        profit_margin
    FROM product_data
),
production_solution AS (
    SELECT
        product_id,
        optimal_quantity
    FROM lp_solution
)
SELECT
    ps.product_id,
    ROUND(ps.optimal_quantity::numeric, 2) AS optimal_production,
    ROUND((ps.optimal_quantity * pc.profit_margin)::numeric, 2) AS total_profit,
    ROUND((ps.optimal_quantity * pc.production_cost)::numeric, 2) AS total_cost
FROM production_solution ps
JOIN production_costs pc ON ps.product_id = pc.product_id
ORDER BY total_profit DESC;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

1. **Dantzig, G.B. (1963)**: "Linear Programming and Extensions"
2. **ChvÃ¡tal, V. (1983)**: "Linear Programming"
3. **Bertsimas, D., Tsitsiklis, J.N. (1997)**: "Introduction to Linear Optimization"

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **é¢„å¤„ç†**: ç§»é™¤å†—ä½™çº¦æŸå’Œå˜é‡
2. **åˆå§‹è§£**: ä½¿ç”¨å¯å‘å¼æ–¹æ³•æ‰¾åˆ°å¥½çš„åˆå§‹è§£
3. **æ•°å€¼ç¨³å®šæ€§**: æ³¨æ„èˆå…¥è¯¯å·®ç´¯ç§¯
4. **ç¨€ç–çŸ©é˜µ**: åˆ©ç”¨ç¨€ç–æ€§åŠ é€Ÿè®¡ç®—

## ğŸ¯ æœ€ä½³å®è·µ

1. **é—®é¢˜å»ºæ¨¡**: å‡†ç¡®åœ°å°†å®é™…é—®é¢˜è½¬åŒ–ä¸ºLPå½¢å¼
2. **å¯¹å¶åˆ†æ**: åˆ©ç”¨å¯¹å¶é—®é¢˜è·å¾—æ´å¯Ÿ
3. **æ•æ„Ÿæ€§åˆ†æ**: åˆ†æå‚æ•°å˜åŒ–å¯¹è§£çš„å½±å“
4. **æ•´æ•°çº¦æŸ**: è°¨æ…æ·»åŠ æ•´æ•°çº¦æŸï¼Œä¼šå¢åŠ å¤æ‚åº¦

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **å•çº¯å½¢æ³•**: PostgreSQLåŸç”Ÿä¸æ”¯æŒå•çº¯å½¢æ³•ï¼Œéœ€è¦ä½¿ç”¨æ‰©å±•æˆ–å¤–éƒ¨å·¥å…·
2. **æ•°å€¼ç¨³å®šæ€§**: æ³¨æ„çŸ©é˜µè¿ç®—çš„ç²¾åº¦ï¼Œä½¿ç”¨NUMERICç±»å‹
3. **çº¦æŸæ£€æŸ¥**: éªŒè¯çº¦æŸæ¡ä»¶çš„å¯è¡Œæ€§å’Œä¸€è‡´æ€§
4. **æœ€ä¼˜æ€§æ¡ä»¶**: æ£€æŸ¥æ£€éªŒæ•°åˆ¤æ–­æœ€ä¼˜æ€§

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡çº¿æ€§è§„åˆ’ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«çº¦æŸIDçš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nçº¦æŸæŸ¥è¯¢å’Œå˜é‡å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡çº¿æ€§è§„åˆ’ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡å•çº¯å½¢æ³•è¿­ä»£å’Œå¹¶è¡Œå¯¹å¶é—®é¢˜æ±‚è§£

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - çº¿æ€§è§„åˆ’æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡LPé—®é¢˜å’Œå¹¶è¡Œçº¦æŸæ£€æŸ¥

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–çº¿æ€§è§„åˆ’æŸ¥è¯¢**

```sql
-- ä¸ºçº¿æ€§è§„åˆ’åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_lp_problem_skip_scan
ON lp_problem(constraint_id, variable_id DESC, ABS(coefficient) DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªçº¦æŸçš„æœ€å¤§ç³»æ•°å˜é‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (constraint_id)
    constraint_id,
    variable_id,
    coefficient,
    ABS(coefficient) AS abs_coefficient
FROM lp_problem
ORDER BY constraint_id, ABS(coefficient) DESC
LIMIT 50;
```

### é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜çº¿æ€§è§„åˆ’ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„çº¿æ€§è§„åˆ’æ±‚è§£ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜çº¿æ€§è§„åˆ’æ±‚è§£ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS linear_programming_solution_cache AS
WITH constraint_analysis AS (
    SELECT
        constraint_id,
        variable_id,
        coefficient,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—çº¦æŸå¼ºåº¦ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        ABS(coefficient) / NULLIF(SUM(ABS(coefficient)) OVER (PARTITION BY constraint_id), 0) AS constraint_weight,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å˜é‡é‡è¦æ€§
        SUM(ABS(coefficient)) OVER (PARTITION BY variable_id) AS variable_importance
    FROM lp_problem
),
solution_quality AS (
    SELECT
        constraint_id,
        variable_id,
        ROUND(coefficient::numeric, 4) AS coefficient,
        ROUND(constraint_weight::numeric, 4) AS constraint_weight,
        ROUND(variable_importance::numeric, 4) AS variable_importance,
        CASE
            WHEN constraint_weight > 0.5 THEN 'Key Constraint - High Impact'
            WHEN constraint_weight > 0.2 THEN 'Important Constraint - Moderate Impact'
            ELSE 'Minor Constraint - Low Impact'
        END AS constraint_category
    FROM constraint_analysis
)
SELECT
    constraint_id,
    variable_id,
    coefficient,
    constraint_weight,
    variable_importance,
    constraint_category
FROM solution_quality
ORDER BY variable_importance DESC, constraint_weight DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_lp_solution_cache_constraint ON linear_programming_solution_cache(constraint_id, variable_id);
CREATE INDEX idx_lp_solution_cache_category ON linear_programming_solution_cache(constraint_category, variable_importance DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY linear_programming_solution_cache;
```

**2. å®æ—¶çº¿æ€§è§„åˆ’ï¼šå¢é‡æ±‚è§£æ›´æ–°**

**å®æ—¶çº¿æ€§è§„åˆ’**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°æ±‚è§£ç»“æœã€‚

```sql
-- å®æ—¶çº¿æ€§è§„åˆ’ï¼šå¢é‡æ±‚è§£æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'linear_programming_state') THEN
            CREATE TABLE linear_programming_state (
                problem_id VARCHAR(100) NOT NULL,
                variable_id INTEGER NOT NULL,
                optimal_value NUMERIC,
                reduced_cost NUMERIC,
                is_basic BOOLEAN,
                shadow_price NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (problem_id, variable_id)
            );

            CREATE INDEX idx_linear_programming_state_problem ON linear_programming_state(problem_id, last_updated DESC);
            CREATE INDEX idx_linear_programming_state_updated ON linear_programming_state(last_updated DESC);

            RAISE NOTICE 'çº¿æ€§è§„åˆ’çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡çº¿æ€§è§„åˆ’æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡çº¿æ€§è§„åˆ’æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**3. æ™ºèƒ½çº¿æ€§è§„åˆ’ä¼˜åŒ–ï¼šè‡ªé€‚åº”æ±‚è§£æ–¹æ³•é€‰æ‹©**

**æ™ºèƒ½çº¿æ€§è§„åˆ’ä¼˜åŒ–**ï¼šæ ¹æ®é—®é¢˜ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ±‚è§£æ–¹æ³•ã€‚

```sql
-- æ™ºèƒ½çº¿æ€§è§„åˆ’ä¼˜åŒ–ï¼šè‡ªé€‚åº”æ±‚è§£æ–¹æ³•é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    constraint_count INTEGER;
    variable_count INTEGER;
    sparsity_ratio NUMERIC;
    recommended_method VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'lp_problem') THEN
            RAISE WARNING 'è¡¨ lp_problem ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½çº¿æ€§è§„åˆ’ä¼˜åŒ–';
            RETURN;
        END IF;

        -- è®¡ç®—é—®é¢˜ç‰¹å¾
        WITH problem_features AS (
            SELECT
                COUNT(DISTINCT constraint_id) AS constr_count,
                COUNT(DISTINCT variable_id) AS var_count,
                COUNT(*)::numeric / NULLIF(COUNT(DISTINCT constraint_id) * COUNT(DISTINCT variable_id), 0) AS sparsity
            FROM lp_problem
        )
        SELECT
            constr_count,
            var_count,
            sparsity
        INTO constraint_count, variable_count, sparsity_ratio
        FROM problem_features;

        -- æ ¹æ®é—®é¢˜ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©æ±‚è§£æ–¹æ³•
        IF sparsity_ratio < 0.1 AND constraint_count * variable_count > 10000 THEN
            recommended_method := 'SPARSE_SIMPLEX';  -- å¤§è§„æ¨¡ç¨€ç–ï¼šç¨€ç–å•çº¯å½¢æ³•
        ELSIF constraint_count < 100 AND variable_count < 100 THEN
            recommended_method := 'STANDARD_SIMPLEX';  -- å°è§„æ¨¡ï¼šæ ‡å‡†å•çº¯å½¢æ³•
        ELSIF constraint_count > variable_count * 2 THEN
            recommended_method := 'DUAL_SIMPLEX';  -- çº¦æŸå¤šï¼šå¯¹å¶å•çº¯å½¢æ³•
        ELSE
            recommended_method := 'INTERIOR_POINT';  -- å…¶ä»–ï¼šå†…ç‚¹æ³•
        END IF;

        RAISE NOTICE 'çº¦æŸæ•°: %, å˜é‡æ•°: %, ç¨€ç–åº¦: %, æ¨èæ–¹æ³•: %',
            constraint_count, variable_count, sparsity_ratio, recommended_method;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½çº¿æ€§è§„åˆ’ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç†è®ºæ¨å¯¼ã€å®ç°å’ŒPostgreSQL 18æ–°ç‰¹æ€§æ”¯æŒï¼‰
