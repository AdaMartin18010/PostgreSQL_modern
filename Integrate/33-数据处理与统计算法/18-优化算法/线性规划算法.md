# PostgreSQL 线性规划算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 优化算法 | 线性规划 | 运筹学
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Linear Programming (Dantzig), Optimization Theory, Operations Research

---

## 📋 目录

- [PostgreSQL 线性规划算法完整指南](#postgresql-线性规划算法完整指南)
  - [📋 目录](#-目录)
  - [线性规划概述](#线性规划概述)
    - [理论基础](#理论基础)
    - [标准形式](#标准形式)
    - [应用场景](#应用场景)
  - [1. 单纯形法](#1-单纯形法)
    - [1.1 单纯形法原理](#11-单纯形法原理)
    - [1.2 单纯形表](#12-单纯形表)
    - [1.3 单纯形法实现](#13-单纯形法实现)
  - [2. 对偶理论](#2-对偶理论)
    - [2.1 对偶问题](#21-对偶问题)
    - [2.2 对偶性定理](#22-对偶性定理)
  - [3. 整数规划](#3-整数规划)
    - [3.1 分支定界法](#31-分支定界法)
    - [3.2 割平面法](#32-割平面法)
  - [4. 复杂度分析](#4-复杂度分析)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 资源分配](#51-资源分配)
    - [5.2 生产计划](#52-生产计划)
  - [📚 参考资源](#-参考资源)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 线性规划概述

**线性规划（Linear Programming, LP）**是运筹学的重要分支，用于在满足线性约束条件下优化线性目标函数。

### 理论基础

线性规划问题的一般形式：

**目标函数**:
$$\max \quad c^T x$$

**约束条件**:
$$Ax \leq b$$
$$x \geq 0$$

其中：

- $x \in \mathbb{R}^n$ 是决策变量
- $c \in \mathbb{R}^n$ 是目标函数系数
- $A \in \mathbb{R}^{m \times n}$ 是约束矩阵
- $b \in \mathbb{R}^m$ 是约束右端项

### 标准形式

**标准形式（Standard Form）**:
$$\min \quad c^T x$$
$$Ax = b$$
$$x \geq 0$$

通过引入**松弛变量**和**剩余变量**，可以将一般形式转换为标准形式。

### 应用场景

| 应用领域 | 具体应用 |
|---------|---------|
| **生产计划** | 资源分配、生产调度 |
| **运输问题** | 最小成本运输 |
| **投资组合** | 资产配置优化 |
| **网络流** | 最大流、最小费用流 |

---

## 1. 单纯形法

### 1.1 单纯形法原理

**单纯形法（Simplex Method）**是求解线性规划问题的经典算法。

**算法步骤**:

1. 找到初始可行解（基本可行解）
2. 检查最优性条件
3. 如果不是最优，选择进基变量和出基变量
4. 进行基变换（旋转操作）
5. 重复步骤2-4直到找到最优解

**最优性条件**: 所有检验数 $\sigma_j = c_j - c_B^T B^{-1} A_j \geq 0$（最小化问题）

### 1.2 单纯形表

**单纯形表**是单纯形法的表格形式表示。

```sql
-- 线性规划问题数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'lp_problem') THEN
            RAISE WARNING '表 lp_problem 已存在，先删除';
            DROP TABLE lp_problem CASCADE;
        END IF;

        CREATE TABLE lp_problem (
            constraint_id INTEGER NOT NULL,
            variable_id INTEGER NOT NULL,
            coefficient NUMERIC NOT NULL,
            PRIMARY KEY (constraint_id, variable_id)
        );

        -- 插入约束系数
        INSERT INTO lp_problem (constraint_id, variable_id, coefficient) VALUES
            (1, 1, 2), (1, 2, 1),  -- 2x1 + x2 <= 10
            (2, 1, 1), (2, 2, 3);   -- x1 + 3x2 <= 15

        CREATE TABLE lp_objective (
            variable_id INTEGER PRIMARY KEY,
            coefficient NUMERIC NOT NULL
        );

        -- 目标函数：max 3x1 + 2x2
        INSERT INTO lp_objective (variable_id, coefficient) VALUES
            (1, 3), (2, 2);

        CREATE TABLE lp_rhs (
            constraint_id INTEGER PRIMARY KEY,
            rhs_value NUMERIC NOT NULL
        );

        INSERT INTO lp_rhs (constraint_id, rhs_value) VALUES
            (1, 10), (2, 15);

        RAISE NOTICE '线性规划问题表创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;
```

### 1.3 单纯形法实现

```sql
-- 单纯形法计算（简化版：展示迭代过程）
WITH constraint_matrix AS (
    SELECT
        constraint_id,
        variable_id,
        coefficient
    FROM lp_problem
),
objective_coefficients AS (
    SELECT
        variable_id,
        coefficient AS c_j
    FROM lp_objective
),
simplex_iteration AS (
    SELECT
        iteration,
        variable_id,
        value,
        reduced_cost
    FROM (
        VALUES
            (0, 1, 0.0, -3.0),
            (0, 2, 0.0, -2.0),
            (1, 1, 5.0, 0.0),
            (1, 2, 0.0, 0.5)
    ) AS initial_table(iteration, variable_id, value, reduced_cost)
)
SELECT
    iteration,
    variable_id,
    ROUND(value::numeric, 4) AS variable_value,
    ROUND(reduced_cost::numeric, 4) AS reduced_cost,
    CASE
        WHEN reduced_cost < 0 THEN 'Can improve'
        ELSE 'Optimal'
    END AS status
FROM simplex_iteration
ORDER BY iteration, variable_id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    constraint_id,
    SUM(coefficient) AS constraint_sum
FROM lp_problem
GROUP BY constraint_id;
```

---

## 2. 对偶理论

### 2.1 对偶问题

**原始问题（Primal）**:
$$\min \quad c^T x$$
$$Ax \geq b$$
$$x \geq 0$$

**对偶问题（Dual）**:
$$\max \quad b^T y$$
$$A^T y \leq c$$
$$y \geq 0$$

### 2.2 对偶性定理

**弱对偶定理**: 对偶问题的目标函数值总是原始问题的下界。

**强对偶定理**: 如果原始问题和对偶问题都有可行解，则它们的最优值相等。

```sql
-- 对偶问题构建
WITH primal_objective AS (
    SELECT * FROM lp_objective
),
dual_objective AS (
    SELECT
        constraint_id AS dual_variable_id,
        rhs_value AS dual_coefficient
    FROM lp_rhs
),
dual_constraints AS (
    SELECT
        variable_id AS dual_constraint_id,
        constraint_id AS dual_variable_id,
        coefficient AS dual_coefficient
    FROM lp_problem
)
SELECT
    'Dual problem constructed' AS status,
    COUNT(*) AS dual_variables,
    SUM(dual_coefficient) AS dual_objective_sum
FROM dual_objective;
```

---

## 3. 整数规划

### 3.1 分支定界法

**分支定界法（Branch and Bound）**用于求解整数线性规划问题。

**算法步骤**:

1. 求解线性松弛问题
2. 如果解是整数，停止
3. 否则，选择非整数变量进行分支
4. 对每个分支求解子问题
5. 更新上下界，剪枝不可行分支

```sql
-- 分支定界法实现（简化版）
WITH relaxed_solution AS (
    SELECT
        variable_id,
        value,
        CASE
            WHEN value = FLOOR(value) THEN 'Integer'
            ELSE 'Fractional'
        END AS solution_type
    FROM simplex_solution
),
branching_variable AS (
    SELECT
        variable_id,
        value,
        FLOOR(value) AS lower_bound,
        CEILING(value) AS upper_bound
    FROM relaxed_solution
    WHERE solution_type = 'Fractional'
    LIMIT 1
)
SELECT
    variable_id,
    ROUND(value::numeric, 4) AS fractional_value,
    lower_bound,
    upper_bound,
    'Branch on this variable' AS action
FROM branching_variable;
```

### 3.2 割平面法

**割平面法（Cutting Plane Method）**通过添加割平面约束来逐步逼近整数解。

```sql
-- 割平面生成（Gomory割）
WITH fractional_solution AS (
    SELECT
        variable_id,
        value,
        value - FLOOR(value) AS fractional_part
    FROM simplex_solution
    WHERE value != FLOOR(value)
),
gomory_cut AS (
    SELECT
        variable_id,
        fractional_part,
        -fractional_part AS cut_coefficient,
        -FLOOR(value) AS cut_rhs
    FROM fractional_solution
)
SELECT
    'Gomory cut generated' AS cut_type,
    variable_id,
    ROUND(cut_coefficient::numeric, 4) AS coefficient,
    ROUND(cut_rhs::numeric, 4) AS rhs_value
FROM gomory_cut;
```

---

## 4. 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|-----------|-----------|---------|
| **单纯形法** | $O(2^n)$ 最坏情况 | $O(mn)$ | 一般LP问题 |
| **内点法** | $O(n^{3.5}L)$ | $O(n^2)$ | 大规模LP问题 |
| **分支定界** | 指数时间 | $O(n)$ | 整数规划 |

其中 $L$ 是输入长度。

---

## 5. 实际应用案例

### 5.1 资源分配

```sql
-- 资源分配优化
WITH resource_constraints AS (
    SELECT
        resource_id,
        variable_id,
        consumption_rate,
        available_amount
    FROM resource_allocation_data
),
allocation_solution AS (
    SELECT
        variable_id,
        optimal_amount
    FROM lp_solution
)
SELECT
    resource_id,
    SUM(consumption_rate * optimal_amount) AS total_consumption,
    available_amount,
    available_amount - SUM(consumption_rate * optimal_amount) AS remaining_amount
FROM resource_constraints
JOIN allocation_solution ON resource_constraints.variable_id = allocation_solution.variable_id
GROUP BY resource_id, available_amount;
```

### 5.2 生产计划

```sql
-- 生产计划优化
WITH production_costs AS (
    SELECT
        product_id,
        production_cost,
        profit_margin
    FROM product_data
),
production_solution AS (
    SELECT
        product_id,
        optimal_quantity
    FROM lp_solution
)
SELECT
    ps.product_id,
    ROUND(ps.optimal_quantity::numeric, 2) AS optimal_production,
    ROUND((ps.optimal_quantity * pc.profit_margin)::numeric, 2) AS total_profit,
    ROUND((ps.optimal_quantity * pc.production_cost)::numeric, 2) AS total_cost
FROM production_solution ps
JOIN production_costs pc ON ps.product_id = pc.product_id
ORDER BY total_profit DESC;
```

---

## 📚 参考资源

1. **Dantzig, G.B. (1963)**: "Linear Programming and Extensions"
2. **Chvátal, V. (1983)**: "Linear Programming"
3. **Bertsimas, D., Tsitsiklis, J.N. (1997)**: "Introduction to Linear Optimization"

## 📊 性能优化建议

1. **预处理**: 移除冗余约束和变量
2. **初始解**: 使用启发式方法找到好的初始解
3. **数值稳定性**: 注意舍入误差累积
4. **稀疏矩阵**: 利用稀疏性加速计算

## 🎯 最佳实践

1. **问题建模**: 准确地将实际问题转化为LP形式
2. **对偶分析**: 利用对偶问题获得洞察
3. **敏感性分析**: 分析参数变化对解的影响
4. **整数约束**: 谨慎添加整数约束，会增加复杂度

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
