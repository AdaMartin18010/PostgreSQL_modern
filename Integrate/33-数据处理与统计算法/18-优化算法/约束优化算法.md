# PostgreSQL çº¦æŸä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ä¼˜åŒ–ç®—æ³• | çº¦æŸä¼˜åŒ– | KKTæ¡ä»¶
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Constrained Optimization, KKT Conditions, Nonlinear Programming

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL çº¦æŸä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-çº¦æŸä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [çº¦æŸä¼˜åŒ–æ¦‚è¿°](#çº¦æŸä¼˜åŒ–æ¦‚è¿°)
    - [é—®é¢˜å½¢å¼](#é—®é¢˜å½¢å¼)
  - [1. æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•](#1-æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•)
    - [1.1 æ‹‰æ ¼æœ—æ—¥å‡½æ•°](#11-æ‹‰æ ¼æœ—æ—¥å‡½æ•°)
    - [1.2 å¯¹å¶é—®é¢˜](#12-å¯¹å¶é—®é¢˜)
  - [2. KKTæ¡ä»¶](#2-kktæ¡ä»¶)
    - [2.1 KKTæ¡ä»¶å®šä¹‰](#21-kktæ¡ä»¶å®šä¹‰)
    - [2.2 KKTæ¡ä»¶æ£€æŸ¥](#22-kktæ¡ä»¶æ£€æŸ¥)
  - [3. ç½šå‡½æ•°æ³•](#3-ç½šå‡½æ•°æ³•)
    - [3.1 å¤–ç‚¹ç½šå‡½æ•°æ³•](#31-å¤–ç‚¹ç½šå‡½æ•°æ³•)
    - [3.2 å†…ç‚¹æ³•](#32-å†…ç‚¹æ³•)
  - [4. å¤æ‚åº¦åˆ†æ](#4-å¤æ‚åº¦åˆ†æ)
    - [4.1 æ—¶é—´å¤æ‚åº¦](#41-æ—¶é—´å¤æ‚åº¦)
    - [4.2 ç©ºé—´å¤æ‚åº¦](#42-ç©ºé—´å¤æ‚åº¦)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 æŠ•èµ„ç»„åˆä¼˜åŒ–](#51-æŠ•èµ„ç»„åˆä¼˜åŒ–)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## çº¦æŸä¼˜åŒ–æ¦‚è¿°

**çº¦æŸä¼˜åŒ–**åœ¨æ»¡è¶³çº¦æŸæ¡ä»¶ä¸‹ä¼˜åŒ–ç›®æ ‡å‡½æ•°ã€‚

### é—®é¢˜å½¢å¼

**ä¸€èˆ¬çº¦æŸä¼˜åŒ–é—®é¢˜**ï¼š
$$\min_{x} f(x)$$
$$\text{s.t. } g_i(x) \leq 0, \quad i = 1, ..., m$$
$$\quad h_j(x) = 0, \quad j = 1, ..., p$$

å…¶ä¸­ï¼š

- $f(x)$ æ˜¯ç›®æ ‡å‡½æ•°
- $g_i(x) \leq 0$ æ˜¯ä¸ç­‰å¼çº¦æŸ
- $h_j(x) = 0$ æ˜¯ç­‰å¼çº¦æŸ

---

## 1. æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•

### 1.1 æ‹‰æ ¼æœ—æ—¥å‡½æ•°

**æ‹‰æ ¼æœ—æ—¥å‡½æ•°**ï¼š
$$L(x, \lambda, \nu) = f(x) + \sum_{i=1}^{m} \lambda_i g_i(x) + \sum_{j=1}^{p} \nu_j h_j(x)$$

å…¶ä¸­ $\lambda_i \geq 0$ å’Œ $\nu_j$ æ˜¯æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°ã€‚

### 1.2 å¯¹å¶é—®é¢˜

**å¯¹å¶å‡½æ•°**ï¼š
$$g(\lambda, \nu) = \inf_{x} L(x, \lambda, \nu)$$

**å¯¹å¶é—®é¢˜**ï¼š
$$\max_{\lambda \geq 0, \nu} g(\lambda, \nu)$$

```sql
-- çº¦æŸä¼˜åŒ–é—®é¢˜ï¼šæœ€å°åŒ– f(x,y) = xÂ² + yÂ²ï¼Œçº¦æŸ x + y = 1
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'optimization_variables') THEN
            DROP TABLE optimization_variables CASCADE;
        END IF;

        CREATE TABLE optimization_variables (
            iteration INTEGER PRIMARY KEY,
            x NUMERIC NOT NULL,
            y NUMERIC NOT NULL,
            lambda NUMERIC NOT NULL,
            objective_value NUMERIC NOT NULL,
            constraint_value NUMERIC NOT NULL
        );

        -- åˆå§‹åŒ–
        INSERT INTO optimization_variables VALUES
            (0, 0.5, 0.5, 1.0, 0.5, 1.0);

        RAISE NOTICE 'ä¼˜åŒ–å˜é‡è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æ‹‰æ ¼æœ—æ—¥å‡½æ•°è®¡ç®—
WITH lagrangian AS (
    SELECT
        iteration,
        x,
        y,
        lambda,
        -- ç›®æ ‡å‡½æ•°ï¼šf(x,y) = xÂ² + yÂ²
        POWER(x, 2) + POWER(y, 2) AS f_value,
        -- çº¦æŸï¼šh(x,y) = x + y - 1 = 0
        x + y - 1 AS h_value,
        -- æ‹‰æ ¼æœ—æ—¥å‡½æ•°ï¼šL = f + Î»h
        POWER(x, 2) + POWER(y, 2) + lambda * (x + y - 1) AS lagrangian_value
    FROM optimization_variables
)
SELECT
    iteration,
    ROUND(x::numeric, 4) AS x,
    ROUND(y::numeric, 4) AS y,
    ROUND(lambda::numeric, 4) AS lambda,
    ROUND(f_value::numeric, 4) AS objective,
    ROUND(h_value::numeric, 4) AS constraint,
    ROUND(lagrangian_value::numeric, 4) AS lagrangian
FROM lagrangian;
```

---

## 2. KKTæ¡ä»¶

### 2.1 KKTæ¡ä»¶å®šä¹‰

**KKTï¼ˆKarush-Kuhn-Tuckerï¼‰æ¡ä»¶**æ˜¯çº¦æŸä¼˜åŒ–çš„æœ€ä¼˜æ€§æ¡ä»¶ã€‚

**KKTæ¡ä»¶**ï¼š

1. **åŸå§‹å¯è¡Œæ€§**ï¼š$g_i(x^*) \leq 0$ï¼Œ$h_j(x^*) = 0$
2. **å¯¹å¶å¯è¡Œæ€§**ï¼š$\lambda_i^* \geq 0$
3. **äº’è¡¥æ¾å¼›æ€§**ï¼š$\lambda_i^* g_i(x^*) = 0$
4. **æ¢¯åº¦æ¡ä»¶**ï¼š$\nabla_x L(x^*, \lambda^*, \nu^*) = 0$

### 2.2 KKTæ¡ä»¶æ£€æŸ¥

```sql
-- KKTæ¡ä»¶æ£€æŸ¥
WITH kkt_check AS (
    SELECT
        x,
        y,
        lambda,
        -- æ¢¯åº¦æ¡ä»¶ï¼šâˆ‚L/âˆ‚x = 2x + Î» = 0
        2 * x + lambda AS grad_x,
        -- æ¢¯åº¦æ¡ä»¶ï¼šâˆ‚L/âˆ‚y = 2y + Î» = 0
        2 * y + lambda AS grad_y,
        -- çº¦æŸï¼šx + y - 1 = 0
        x + y - 1 AS constraint_value,
        -- äº’è¡¥æ¾å¼›æ€§ï¼ˆæ— ä¸ç­‰å¼çº¦æŸï¼Œè·³è¿‡ï¼‰
        0 AS complementarity
    FROM optimization_variables
    WHERE iteration = (SELECT MAX(iteration) FROM optimization_variables)
)
SELECT
    ROUND(x::numeric, 4) AS x,
    ROUND(y::numeric, 4) AS y,
    ROUND(lambda::numeric, 4) AS lambda,
    ROUND(ABS(grad_x)::numeric, 6) AS grad_x_error,
    ROUND(ABS(grad_y)::numeric, 6) AS grad_y_error,
    ROUND(ABS(constraint_value)::numeric, 6) AS constraint_error,
    CASE
        WHEN ABS(grad_x) < 0.001 AND ABS(grad_y) < 0.001 AND ABS(constraint_value) < 0.001
        THEN 'KKTæ¡ä»¶æ»¡è¶³'
        ELSE 'KKTæ¡ä»¶ä¸æ»¡è¶³'
    END AS kkt_status
FROM kkt_check;
```

---

## 3. ç½šå‡½æ•°æ³•

### 3.1 å¤–ç‚¹ç½šå‡½æ•°æ³•

**å¤–ç‚¹ç½šå‡½æ•°**ï¼š
$$P(x, \mu) = f(x) + \mu \sum_{i=1}^{m} \max(0, g_i(x))^2 + \mu \sum_{j=1}^{p} h_j(x)^2$$

å…¶ä¸­ $\mu > 0$ æ˜¯ç½šå‚æ•°ã€‚

**ç®—æ³•æµç¨‹**ï¼š

1. åˆå§‹åŒ– $\mu_0$ å’Œ $x_0$
2. æ±‚è§£æ— çº¦æŸä¼˜åŒ–é—®é¢˜ï¼š$\min_x P(x, \mu_k)$
3. æ›´æ–° $\mu_{k+1} = \rho \mu_k$ï¼ˆ$\rho > 1$ï¼‰
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°æ”¶æ•›

```sql
-- ç½šå‡½æ•°æ³•å®ç°
DO $$
DECLARE
    current_mu NUMERIC := 1.0;
    rho NUMERIC := 2.0;
    max_iterations INTEGER := 10;
    iteration INTEGER := 0;
    x_val NUMERIC := 0.5;
    y_val NUMERIC := 0.5;
    tolerance NUMERIC := 0.001;
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'penalty_method') THEN
            DROP TABLE penalty_method CASCADE;
        END IF;

        CREATE TABLE penalty_method (
            iteration INTEGER PRIMARY KEY,
            mu NUMERIC NOT NULL,
            x NUMERIC NOT NULL,
            y NUMERIC NOT NULL,
            objective NUMERIC NOT NULL,
            constraint_violation NUMERIC NOT NULL,
            penalty_value NUMERIC NOT NULL
        );

        -- è¿­ä»£æ±‚è§£
        WHILE iteration < max_iterations LOOP
            -- æ±‚è§£æ— çº¦æŸä¼˜åŒ–ï¼ˆç®€åŒ–ï¼šä½¿ç”¨è§£æè§£ï¼‰
            -- å¯¹äº f(x,y) = xÂ² + yÂ²ï¼Œçº¦æŸ x + y = 1
            -- ç½šå‡½æ•°ï¼šP = xÂ² + yÂ² + Î¼(x + y - 1)Â²
            -- æœ€ä¼˜è§£ï¼šx = y = Î¼/(2 + 2Î¼)
            x_val := current_mu / (2.0 + 2.0 * current_mu);
            y_val := current_mu / (2.0 + 2.0 * current_mu);

            INSERT INTO penalty_method VALUES (
                iteration,
                current_mu,
                x_val,
                y_val,
                POWER(x_val, 2) + POWER(y_val, 2),
                ABS(x_val + y_val - 1),
                POWER(x_val, 2) + POWER(y_val, 2) + current_mu * POWER(x_val + y_val - 1, 2)
            );

            -- æ£€æŸ¥æ”¶æ•›
            IF ABS(x_val + y_val - 1) < tolerance THEN
                RAISE NOTICE 'æ”¶æ•›äºè¿­ä»£ %ï¼Œx=%, y=%, çº¦æŸè¿å=%',
                    iteration, x_val, y_val, ABS(x_val + y_val - 1);
                EXIT;
            END IF;

            current_mu := current_mu * rho;
            iteration := iteration + 1;
        END LOOP;

        RAISE NOTICE 'ç½šå‡½æ•°æ³•å®Œæˆï¼Œå…± % æ¬¡è¿­ä»£', iteration;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'ç½šå‡½æ•°æ³•å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æŸ¥çœ‹ç½šå‡½æ•°æ³•è¿­ä»£è¿‡ç¨‹
SELECT
    iteration,
    ROUND(mu::numeric, 2) AS penalty_parameter,
    ROUND(x::numeric, 4) AS x,
    ROUND(y::numeric, 4) AS y,
    ROUND(objective::numeric, 4) AS objective,
    ROUND(constraint_violation::numeric, 6) AS constraint_violation,
    ROUND(penalty_value::numeric, 4) AS penalty_value
FROM penalty_method
ORDER BY iteration;
```

### 3.2 å†…ç‚¹æ³•

**å†…ç‚¹æ³•ï¼ˆInterior Point Methodï¼‰**åœ¨å¯è¡ŒåŸŸå†…éƒ¨è¿­ä»£ã€‚

**éšœç¢å‡½æ•°**ï¼š
$$B(x, t) = f(x) - t \sum_{i=1}^{m} \log(-g_i(x))$$

---

## 4. å¤æ‚åº¦åˆ†æ

### 4.1 æ—¶é—´å¤æ‚åº¦

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ |
|------|-----------|
| **æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•** | $O(n^3)$ï¼ˆæ±‚è§£KKTç³»ç»Ÿï¼‰ |
| **ç½šå‡½æ•°æ³•** | $O(k \cdot n^3)$ï¼ˆkæ¬¡è¿­ä»£ï¼‰ |
| **å†…ç‚¹æ³•** | $O(\sqrt{m} \cdot n^3)$ |

### 4.2 ç©ºé—´å¤æ‚åº¦

| æ–¹æ³• | ç©ºé—´å¤æ‚åº¦ |
|------|-----------|
| **æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•** | $O(n^2)$ |
| **ç½šå‡½æ•°æ³•** | $O(n)$ |
| **å†…ç‚¹æ³•** | $O(n^2)$ |

---

## 5. PostgreSQL 18 å¹¶è¡Œçº¦æŸä¼˜åŒ–å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œçº¦æŸä¼˜åŒ–è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œæ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•ã€KKTæ¡ä»¶æ£€æŸ¥å’Œç½šå‡½æ•°æ³•ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡çº¦æŸä¼˜åŒ–é—®é¢˜çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œçº¦æŸä¼˜åŒ–åŸç†

PostgreSQL 18 çš„å¹¶è¡Œçº¦æŸä¼˜åŒ–é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æçº¦æŸæ•°æ®
2. **å¹¶è¡Œæ‹‰æ ¼æœ—æ—¥è®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—æ‹‰æ ¼æœ—æ—¥å‡½æ•°
3. **å¹¶è¡ŒKKTæ£€æŸ¥**ï¼šå¹¶è¡Œæ‰§è¡ŒKKTæ¡ä»¶æ£€æŸ¥
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è®¡ç®—ç»“æœ

### 5.2 å¹¶è¡Œæ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•

```sql
-- PostgreSQL 18 å¹¶è¡Œæ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'optimization_variables') THEN
            RAISE WARNING 'è¡¨ optimization_variables ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ‹‰æ ¼æœ—æ—¥ä¹˜æ•°æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œæ‹‰æ ¼æœ—æ—¥å‡½æ•°è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH lagrangian_calc AS (
    SELECT
        iteration,
        x,
        y,
        lambda,
        POWER(x, 2) + POWER(y, 2) AS objective,
        x + y - 1 AS constraint_value,
        POWER(x, 2) + POWER(y, 2) + lambda * POWER(x + y - 1, 2) AS lagrangian_value
    FROM optimization_variables
)
SELECT
    iteration,
    ROUND(x::numeric, 4) AS x_value,
    ROUND(y::numeric, 4) AS y_value,
    ROUND(lambda::numeric, 4) AS lambda_value,
    ROUND(lagrangian_value::numeric, 6) AS lagrangian
FROM lagrangian_calc
ORDER BY iteration;
```

### 5.3 å¹¶è¡ŒKKTæ¡ä»¶æ£€æŸ¥

```sql
-- PostgreSQL 18 å¹¶è¡ŒKKTæ¡ä»¶æ£€æŸ¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'optimization_variables') THEN
            RAISE WARNING 'è¡¨ optimization_variables ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒKKTæ¡ä»¶æ£€æŸ¥';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒKKTæ¡ä»¶æ£€æŸ¥';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒKKTæ¡ä»¶æ£€æŸ¥å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒKKTæ¡ä»¶éªŒè¯
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH kkt_conditions AS (
    SELECT
        iteration,
        x,
        y,
        lambda,
        2 * x + lambda AS grad_x,
        2 * y + lambda AS grad_y,
        x + y - 1 AS constraint_val,
        CASE WHEN ABS(2 * x + lambda) < 0.001 AND ABS(2 * y + lambda) < 0.001
             AND ABS(x + y - 1) < 0.001 THEN true ELSE false END AS kkt_satisfied
    FROM optimization_variables
)
SELECT
    iteration,
    ROUND(grad_x::numeric, 6) AS gradient_x,
    ROUND(grad_y::numeric, 6) AS gradient_y,
    ROUND(constraint_val::numeric, 6) AS constraint,
    CASE WHEN kkt_satisfied THEN 'KKT satisfied âœ“' ELSE 'KKT not satisfied âœ—' END AS kkt_status
FROM kkt_conditions
ORDER BY iteration;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æŠ•èµ„ç»„åˆä¼˜åŒ–

**é—®é¢˜**ï¼šæœ€å°åŒ–é£é™©ï¼Œçº¦æŸæœŸæœ›æ”¶ç›Šã€‚

```sql
-- æŠ•èµ„ç»„åˆä¼˜åŒ–ï¼šæœ€å°åŒ–é£é™©ï¼Œçº¦æŸæ”¶ç›Š
WITH portfolio_optimization AS (
    SELECT
        asset_id,
        expected_return,
        risk,
        -- çº¦æŸï¼šæ€»æƒé‡ = 1
        -- çº¦æŸï¼šæœŸæœ›æ”¶ç›Š >= target_return
        weight
    FROM assets
)
SELECT
    asset_id,
    ROUND(weight::numeric, 4) AS optimal_weight
FROM portfolio_optimization;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Nocedal, J., Wright, S. (2006)**: "Numerical Optimization", 2nd Edition
2. **Boyd, S., Vandenberghe, L. (2004)**: "Convex Optimization"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **é€‰æ‹©åˆé€‚çš„ç®—æ³•**ï¼šæ ¹æ®é—®é¢˜ç‰¹æ€§é€‰æ‹©æ‹‰æ ¼æœ—æ—¥æ³•æˆ–ç½šå‡½æ•°æ³•
2. **åˆå§‹å€¼é€‰æ‹©**ï¼šå¥½çš„åˆå§‹å€¼å¯ä»¥åŠ é€Ÿæ”¶æ•›
3. **å‚æ•°è°ƒä¼˜**ï¼šè°ƒæ•´ç½šå‚æ•°æ›´æ–°ç‡
4. **å¹¶è¡Œè®¡ç®—**ï¼šåˆ©ç”¨å¹¶è¡ŒæŸ¥è¯¢åŠ é€Ÿ

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **é—®é¢˜è½¬æ¢**ï¼šå°†å¤æ‚çº¦æŸè½¬æ¢ä¸ºæ ‡å‡†å½¢å¼
2. **æ”¶æ•›åˆ¤æ–­**ï¼šè®¾ç½®åˆç†çš„æ”¶æ•›é˜ˆå€¼
3. **æ•°å€¼ç¨³å®šæ€§**ï¼šæ³¨æ„æ•°å€¼ç²¾åº¦é—®é¢˜
4. **éªŒè¯è§£**ï¼šæ£€æŸ¥KKTæ¡ä»¶æ˜¯å¦æ»¡è¶³

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
