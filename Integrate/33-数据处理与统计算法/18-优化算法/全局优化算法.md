# PostgreSQL å…¨å±€ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ä¼˜åŒ–ç®—æ³• | å…¨å±€ä¼˜åŒ– | å…ƒå¯å‘å¼
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Global Optimization, Metaheuristics, Evolutionary Algorithms

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å…¨å±€ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å…¨å±€ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å…¨å±€ä¼˜åŒ–æ¦‚è¿°](#å…¨å±€ä¼˜åŒ–æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [é—®é¢˜ç‰¹ç‚¹](#é—®é¢˜ç‰¹ç‚¹)
    - [ç®—æ³•åˆ†ç±»](#ç®—æ³•åˆ†ç±»)
  - [1. æ¨¡æ‹Ÿé€€ç«](#1-æ¨¡æ‹Ÿé€€ç«)
    - [1.1 æ¨¡æ‹Ÿé€€ç«åŸç†](#11-æ¨¡æ‹Ÿé€€ç«åŸç†)
    - [1.2 æ¸©åº¦è°ƒåº¦](#12-æ¸©åº¦è°ƒåº¦)
  - [2. é—ä¼ ç®—æ³•](#2-é—ä¼ ç®—æ³•)
    - [2.1 é—ä¼ ç®—æ³•åŸç†](#21-é—ä¼ ç®—æ³•åŸç†)
    - [2.2 é€‰æ‹©æ“ä½œ](#22-é€‰æ‹©æ“ä½œ)
    - [2.3 äº¤å‰å’Œå˜å¼‚](#23-äº¤å‰å’Œå˜å¼‚)
  - [3. ç²’å­ç¾¤ä¼˜åŒ–](#3-ç²’å­ç¾¤ä¼˜åŒ–)
    - [3.1 PSOåŸç†](#31-psoåŸç†)
  - [4. å¤æ‚åº¦åˆ†æ](#4-å¤æ‚åº¦åˆ†æ)
  - [5. PostgreSQL 18 å¹¶è¡Œå…¨å±€ä¼˜åŒ–å¢å¼º](#5-postgresql-18-å¹¶è¡Œå…¨å±€ä¼˜åŒ–å¢å¼º)
    - [5.1 å¹¶è¡Œå…¨å±€ä¼˜åŒ–åŸç†](#51-å¹¶è¡Œå…¨å±€ä¼˜åŒ–åŸç†)
    - [5.2 å¹¶è¡Œæ¨¡æ‹Ÿé€€ç«](#52-å¹¶è¡Œæ¨¡æ‹Ÿé€€ç«)
    - [5.3 å¹¶è¡Œé—ä¼ ç®—æ³•](#53-å¹¶è¡Œé—ä¼ ç®—æ³•)
    - [5.4 å¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–](#54-å¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 å‡½æ•°ä¼˜åŒ–](#51-å‡½æ•°ä¼˜åŒ–)
    - [5.2 ç»„åˆä¼˜åŒ–](#52-ç»„åˆä¼˜åŒ–)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## å…¨å±€ä¼˜åŒ–æ¦‚è¿°

**å…¨å±€ä¼˜åŒ–**æ˜¯åœ¨æ•´ä¸ªæœç´¢ç©ºé—´ä¸­å¯»æ‰¾å…¨å±€æœ€ä¼˜è§£ï¼Œè€Œä¸ä»…ä»…æ˜¯å±€éƒ¨æœ€ä¼˜è§£ã€‚

### ç†è®ºåŸºç¡€

å…¨å±€ä¼˜åŒ–é—®é¢˜é€šå¸¸å…·æœ‰ï¼š

- **å¤šå³°æ€§**: å¤šä¸ªå±€éƒ¨æœ€ä¼˜è§£
- **éå‡¸æ€§**: ç›®æ ‡å‡½æ•°éå‡¸
- **é«˜ç»´æ€§**: æœç´¢ç©ºé—´ç»´åº¦é«˜

### é—®é¢˜ç‰¹ç‚¹

**æŒ‘æˆ˜**:

- å±€éƒ¨æœ€ä¼˜è§£é™·é˜±
- æœç´¢ç©ºé—´å·¨å¤§
- è®¡ç®—æˆæœ¬é«˜

**ä¼˜åŠ¿**:

- èƒ½æ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£
- å¯¹é—®é¢˜ç»“æ„è¦æ±‚ä½
- é€‚ç”¨äºå¤æ‚é—®é¢˜

### ç®—æ³•åˆ†ç±»

| ç®—æ³•ç±»å‹ | ä»£è¡¨ç®—æ³• | ç‰¹ç‚¹ |
|---------|---------|------|
| **åŸºäºç‰©ç†** | æ¨¡æ‹Ÿé€€ç« | å—ç‰©ç†è¿‡ç¨‹å¯å‘ |
| **åŸºäºè¿›åŒ–** | é—ä¼ ç®—æ³• | æ¨¡æ‹Ÿç”Ÿç‰©è¿›åŒ– |
| **åŸºäºç¾¤ä½“** | ç²’å­ç¾¤ä¼˜åŒ– | æ¨¡æ‹Ÿç¾¤ä½“è¡Œä¸º |
| **åŸºäºå±€éƒ¨æœç´¢** | ç¦å¿Œæœç´¢ | é¿å…é‡å¤æœç´¢ |

---

## 1. æ¨¡æ‹Ÿé€€ç«

### 1.1 æ¨¡æ‹Ÿé€€ç«åŸç†

**æ¨¡æ‹Ÿé€€ç«ï¼ˆSimulated Annealingï¼‰**å—é‡‘å±é€€ç«è¿‡ç¨‹å¯å‘ï¼Œé€šè¿‡æ¥å—è¾ƒå·®è§£æ¥è·³å‡ºå±€éƒ¨æœ€ä¼˜ã€‚

**æ¥å—æ¦‚ç‡**:
$$P(accept) = \begin{cases} 1 & \text{if } \Delta E < 0 \\ e^{-\Delta E/T} & \text{if } \Delta E \geq 0 \end{cases}$$

å…¶ä¸­ï¼š

- $\Delta E$ æ˜¯èƒ½é‡å·®ï¼ˆç›®æ ‡å‡½æ•°å·®ï¼‰
- $T$ æ˜¯å½“å‰æ¸©åº¦

```sql
-- æ¨¡æ‹Ÿé€€ç«å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sa_state') THEN
            RAISE WARNING 'è¡¨ sa_state å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE sa_state CASCADE;
        END IF;

        CREATE TABLE sa_state (
            iteration INTEGER PRIMARY KEY,
            x1 NUMERIC NOT NULL,
            x2 NUMERIC NOT NULL,
            objective_value NUMERIC NOT NULL,
            temperature NUMERIC NOT NULL
        );

        -- æ’å…¥åˆå§‹çŠ¶æ€
        INSERT INTO sa_state (iteration, x1, x2, objective_value, temperature) VALUES
            (0, 0.0, 0.0, 10.0, 100.0);

        RAISE NOTICE 'è¡¨ sa_state åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ sa_state å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æ¨¡æ‹Ÿé€€ç«è¿­ä»£
WITH current_state AS (
    SELECT * FROM sa_state
    WHERE iteration = (SELECT MAX(iteration) FROM sa_state)
),
neighbor_state AS (
    SELECT
        x1 + (RANDOM() - 0.5) * 0.1 AS new_x1,
        x2 + (RANDOM() - 0.5) * 0.1 AS new_x2,
        temperature * 0.95 AS new_temperature  -- æ¸©åº¦è¡°å‡
    FROM current_state
),
new_objective AS (
    SELECT
        new_x1,
        new_x2,
        POWER(new_x1, 2) + POWER(new_x2, 2) AS new_obj_value,
        new_temperature
    FROM neighbor_state
),
acceptance_probability AS (
    SELECT
        ns.new_x1,
        ns.new_x2,
        no.new_obj_value,
        cs.objective_value AS current_obj,
        no.new_obj_value - cs.objective_value AS delta_e,
        no.new_temperature,
        CASE
            WHEN no.new_obj_value < cs.objective_value THEN 1.0
            ELSE EXP(-(no.new_obj_value - cs.objective_value) / NULLIF(no.new_temperature, 0))
        END AS accept_prob
    FROM new_objective no
    CROSS JOIN current_state cs
    CROSS JOIN neighbor_state ns
)
SELECT
    ROUND(new_x1::numeric, 4) AS candidate_x1,
    ROUND(new_x2::numeric, 4) AS candidate_x2,
    ROUND(new_obj_value::numeric, 4) AS candidate_objective,
    ROUND(delta_e::numeric, 4) AS energy_difference,
    ROUND(accept_prob::numeric, 4) AS acceptance_probability,
    CASE
        WHEN accept_prob > RANDOM() THEN 'Accept'
        ELSE 'Reject'
    END AS decision
FROM acceptance_probability;
```

### 1.2 æ¸©åº¦è°ƒåº¦

**æ¸©åº¦è°ƒåº¦ç­–ç•¥**:

- **çº¿æ€§å†·å´**: $T_k = T_0 - k \times \alpha$
- **æŒ‡æ•°å†·å´**: $T_k = T_0 \times \alpha^k$
- **å¯¹æ•°å†·å´**: $T_k = \frac{T_0}{\log(k+1)}$

```sql
-- æ¸©åº¦è°ƒåº¦
WITH temperature_schedule AS (
    SELECT
        iteration,
        100.0 * POWER(0.95, iteration) AS exponential_cooling,
        100.0 / LN(iteration + 2) AS logarithmic_cooling,
        100.0 - iteration * 0.5 AS linear_cooling
    FROM generate_series(0, 100) AS iteration
)
SELECT
    iteration,
    ROUND(exponential_cooling::numeric, 4) AS exp_temp,
    ROUND(logarithmic_cooling::numeric, 4) AS log_temp,
    ROUND(linear_cooling::numeric, 4) AS linear_temp
FROM temperature_schedule
ORDER BY iteration;
```

---

## 2. é—ä¼ ç®—æ³•

### 2.1 é—ä¼ ç®—æ³•åŸç†

**é—ä¼ ç®—æ³•ï¼ˆGenetic Algorithmï¼‰**æ¨¡æ‹Ÿç”Ÿç‰©è¿›åŒ–è¿‡ç¨‹ï¼Œé€šè¿‡é€‰æ‹©ã€äº¤å‰ã€å˜å¼‚æ“ä½œæœç´¢æœ€ä¼˜è§£ã€‚

**ç®—æ³•æµç¨‹**:

1. åˆå§‹åŒ–ç§ç¾¤
2. è¯„ä¼°é€‚åº”åº¦
3. é€‰æ‹©
4. äº¤å‰
5. å˜å¼‚
6. é‡å¤æ­¥éª¤2-5ç›´åˆ°æ”¶æ•›

```sql
-- é—ä¼ ç®—æ³•å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ga_population') THEN
            RAISE WARNING 'è¡¨ ga_population å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE ga_population CASCADE;
        END IF;

        CREATE TABLE ga_population (
            individual_id SERIAL PRIMARY KEY,
            chromosome VARCHAR(10) NOT NULL,
            fitness NUMERIC NOT NULL
        );

        -- æ’å…¥åˆå§‹ç§ç¾¤
        INSERT INTO ga_population (chromosome, fitness) VALUES
            ('10101010', 0.5),
            ('11001100', 0.6),
            ('10110110', 0.4),
            ('11011011', 0.7);

        RAISE NOTICE 'è¡¨ ga_population åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ ga_population å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

### 2.2 é€‰æ‹©æ“ä½œ

**è½®ç›˜èµŒé€‰æ‹©**:
$$P_i = \frac{f_i}{\sum_{j=1}^{n} f_j}$$

```sql
-- è½®ç›˜èµŒé€‰æ‹©
WITH fitness_sum AS (
    SELECT SUM(fitness) AS total_fitness FROM ga_population
),
selection_probability AS (
    SELECT
        individual_id,
        chromosome,
        fitness,
        fitness / NULLIF((SELECT total_fitness FROM fitness_sum), 0) AS selection_prob,
        SUM(fitness / NULLIF((SELECT total_fitness FROM fitness_sum), 0)) OVER (ORDER BY individual_id) AS cumulative_prob
    FROM ga_population
    CROSS JOIN fitness_sum
)
SELECT
    individual_id,
    chromosome,
    ROUND(fitness::numeric, 4) AS fitness,
    ROUND(selection_prob::numeric, 4) AS selection_probability,
    ROUND(cumulative_prob::numeric, 4) AS cumulative_probability
FROM selection_probability
ORDER BY individual_id;
```

### 2.3 äº¤å‰å’Œå˜å¼‚

**å•ç‚¹äº¤å‰**:

```sql
-- å•ç‚¹äº¤å‰
WITH parent_pair AS (
    SELECT
        p1.chromosome AS parent1,
        p2.chromosome AS parent2,
        4 AS crossover_point
    FROM ga_population p1
    CROSS JOIN ga_population p2
    WHERE p1.individual_id < p2.individual_id
    LIMIT 1
)
SELECT
    parent1,
    parent2,
    LEFT(parent1, crossover_point) || RIGHT(parent2, LENGTH(parent2) - crossover_point) AS offspring1,
    LEFT(parent2, crossover_point) || RIGHT(parent1, LENGTH(parent1) - crossover_point) AS offspring2
FROM parent_pair;
```

**å˜å¼‚**:

```sql
-- å˜å¼‚æ“ä½œ
WITH mutation AS (
    SELECT
        chromosome,
        -- éšæœºç¿»è½¬ä¸€ä½
        OVERLAY(chromosome PLACING CASE SUBSTRING(chromosome FROM 3 FOR 1) WHEN '0' THEN '1' ELSE '0' END FROM 3 FOR 1) AS mutated_chromosome
    FROM ga_population
    WHERE RANDOM() < 0.1  -- 10%å˜å¼‚æ¦‚ç‡
)
SELECT
    chromosome AS original,
    mutated_chromosome AS mutated
FROM mutation;
```

---

## 3. ç²’å­ç¾¤ä¼˜åŒ–

### 3.1 PSOåŸç†

**ç²’å­ç¾¤ä¼˜åŒ–ï¼ˆParticle Swarm Optimizationï¼‰**æ¨¡æ‹Ÿé¸Ÿç¾¤è§…é£Ÿè¡Œä¸ºã€‚

**ç²’å­æ›´æ–°**:
$$v_i^{t+1} = w v_i^t + c_1 r_1 (p_i - x_i^t) + c_2 r_2 (g - x_i^t)$$
$$x_i^{t+1} = x_i^t + v_i^{t+1}$$

å…¶ä¸­ï¼š

- $v_i$ æ˜¯ç²’å­é€Ÿåº¦
- $x_i$ æ˜¯ç²’å­ä½ç½®
- $p_i$ æ˜¯ç²’å­å†å²æœ€ä¼˜ä½ç½®
- $g$ æ˜¯å…¨å±€æœ€ä¼˜ä½ç½®
- $w$ æ˜¯æƒ¯æ€§æƒé‡
- $c_1, c_2$ æ˜¯å­¦ä¹ å› å­

```sql
-- PSOå®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'pso_particles') THEN
            RAISE WARNING 'è¡¨ pso_particles å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE pso_particles CASCADE;
        END IF;

        CREATE TABLE pso_particles (
            particle_id INTEGER PRIMARY KEY,
            x1 NUMERIC NOT NULL,
            x2 NUMERIC NOT NULL,
            v1 NUMERIC NOT NULL,
            v2 NUMERIC NOT NULL,
            best_x1 NUMERIC NOT NULL,
            best_x2 NUMERIC NOT NULL,
            best_fitness NUMERIC NOT NULL
        );

        -- æ’å…¥åˆå§‹ç²’å­
        INSERT INTO pso_particles (particle_id, x1, x2, v1, v2, best_x1, best_x2, best_fitness) VALUES
            (1, 1.0, 1.0, 0.1, 0.1, 1.0, 1.0, 2.0),
            (2, 2.0, 2.0, 0.1, 0.1, 2.0, 2.0, 8.0);

        RAISE NOTICE 'è¡¨ pso_particles åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ pso_particles å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- PSOæ›´æ–°
WITH global_best AS (
    SELECT
        best_x1 AS g_x1,
        best_x2 AS g_x2
    FROM pso_particles
    ORDER BY best_fitness
    LIMIT 1
),
particle_update AS (
    SELECT
        pp.particle_id,
        pp.x1,
        pp.x2,
        pp.v1,
        pp.v2,
        pp.best_x1,
        pp.best_x2,
        gb.g_x1,
        gb.g_x2,
        0.7 AS inertia_weight,
        1.5 AS c1,
        1.5 AS c2,
        -- é€Ÿåº¦æ›´æ–°
        0.7 * pp.v1 + 1.5 * RANDOM() * (pp.best_x1 - pp.x1) + 1.5 * RANDOM() * (gb.g_x1 - pp.x1) AS new_v1,
        0.7 * pp.v2 + 1.5 * RANDOM() * (pp.best_x2 - pp.x2) + 1.5 * RANDOM() * (gb.g_x2 - pp.x2) AS new_v2
    FROM pso_particles pp
    CROSS JOIN global_best gb
),
position_update AS (
    SELECT
        particle_id,
        x1 + new_v1 AS new_x1,
        x2 + new_v2 AS new_x2,
        new_v1,
        new_v2,
        POWER(x1 + new_v1, 2) + POWER(x2 + new_v2, 2) AS new_fitness
    FROM particle_update
)
SELECT
    particle_id,
    ROUND(new_x1::numeric, 4) AS updated_x1,
    ROUND(new_x2::numeric, 4) AS updated_x2,
    ROUND(new_v1::numeric, 4) AS updated_v1,
    ROUND(new_v2::numeric, 4) AS updated_v2,
    ROUND(new_fitness::numeric, 4) AS new_fitness
FROM position_update;
```

---

## 4. å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | æ”¶æ•›é€Ÿåº¦ |
|------|-----------|-----------|---------|
| **æ¨¡æ‹Ÿé€€ç«** | $O(iterations)$ | $O(1)$ | æ…¢ |
| **é—ä¼ ç®—æ³•** | $O(pop_size \times iterations)$ | $O(pop_size)$ | ä¸­ç­‰ |
| **ç²’å­ç¾¤ä¼˜åŒ–** | $O(pop_size \times iterations)$ | $O(pop_size)$ | å¿« |

---

## 5. PostgreSQL 18 å¹¶è¡Œå…¨å±€ä¼˜åŒ–å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œå…¨å±€ä¼˜åŒ–è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œæ¨¡æ‹Ÿé€€ç«ã€é—ä¼ ç®—æ³•å’Œç²’å­ç¾¤ä¼˜åŒ–ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡å…¨å±€ä¼˜åŒ–é—®é¢˜çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œå…¨å±€ä¼˜åŒ–åŸç†

PostgreSQL 18 çš„å¹¶è¡Œå…¨å±€ä¼˜åŒ–é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æè§£ç©ºé—´
2. **å¹¶è¡Œè¯„ä¼°**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è¯„ä¼°ç›®æ ‡å‡½æ•°
3. **å¹¶è¡Œè¿­ä»£**ï¼šå¹¶è¡Œæ‰§è¡Œä¼˜åŒ–è¿­ä»£
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„æœ€ä¼˜è§£

### 5.2 å¹¶è¡Œæ¨¡æ‹Ÿé€€ç«

```sql
-- PostgreSQL 18 å¹¶è¡Œæ¨¡æ‹Ÿé€€ç«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sa_state') THEN
            RAISE WARNING 'è¡¨ sa_state ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæ¨¡æ‹Ÿé€€ç«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæ¨¡æ‹Ÿé€€ç«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ¨¡æ‹Ÿé€€ç«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œæ¨¡æ‹Ÿé€€ç«ï¼šæ¥å—æ¦‚ç‡è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH sa_iterations AS (
    SELECT
        iteration,
        x1,
        x2,
        objective_value,
        LAG(objective_value) OVER (ORDER BY iteration) AS prev_objective,
        temperature
    FROM sa_state
),
acceptance_prob AS (
    SELECT
        iteration,
        x1,
        x2,
        objective_value,
        prev_objective,
        objective_value - COALESCE(prev_objective, objective_value) AS delta_e,
        temperature,
        CASE
            WHEN objective_value - COALESCE(prev_objective, objective_value) < 0 THEN 1.0
            ELSE EXP(-(objective_value - COALESCE(prev_objective, objective_value)) / temperature)
        END AS accept_probability
    FROM sa_iterations
)
SELECT
    iteration,
    ROUND(objective_value::numeric, 4) AS objective,
    ROUND(accept_probability::numeric, 4) AS accept_prob
FROM acceptance_prob
ORDER BY iteration;
```

### 5.3 å¹¶è¡Œé—ä¼ ç®—æ³•

```sql
-- PostgreSQL 18 å¹¶è¡Œé—ä¼ ç®—æ³•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ga_population') THEN
            RAISE WARNING 'è¡¨ ga_population ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œé—ä¼ ç®—æ³•';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œé—ä¼ ç®—æ³•';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œé—ä¼ ç®—æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œé—ä¼ ç®—æ³•ï¼šé€‚åº”åº¦è®¡ç®—å’Œé€‰æ‹©
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH fitness_scores AS (
    SELECT
        chromosome,
        fitness_value,
        fitness_value / SUM(fitness_value) OVER () AS selection_probability
    FROM ga_population
),
roulette_selection AS (
    SELECT
        chromosome,
        fitness_value,
        selection_probability,
        SUM(selection_probability) OVER (ORDER BY fitness_value DESC) AS cumulative_prob
    FROM fitness_scores
)
SELECT
    chromosome,
    ROUND(fitness_value::numeric, 4) AS fitness,
    ROUND(selection_probability::numeric, 4) AS selection_prob
FROM roulette_selection
ORDER BY fitness DESC
LIMIT 20;
```

### 5.4 å¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–

```sql
-- PostgreSQL 18 å¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'pso_particles') THEN
            RAISE WARNING 'è¡¨ pso_particles ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œç²’å­ç¾¤ä¼˜åŒ–ï¼šé€Ÿåº¦å’Œä½ç½®æ›´æ–°
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH pso_update AS (
    SELECT
        particle_id,
        position_x,
        position_y,
        velocity_x,
        velocity_y,
        best_position_x,
        best_position_y,
        (SELECT position_x FROM pso_particles WHERE fitness = (SELECT MAX(fitness) FROM pso_particles)) AS global_best_x,
        (SELECT position_y FROM pso_particles WHERE fitness = (SELECT MAX(fitness) FROM pso_particles)) AS global_best_y,
        0.7 AS inertia_weight,
        1.5 AS cognitive_coeff,
        1.5 AS social_coeff
    FROM pso_particles
)
SELECT
    particle_id,
    ROUND((inertia_weight * velocity_x + cognitive_coeff * random() * (best_position_x - position_x) +
           social_coeff * random() * (global_best_x - position_x))::numeric, 4) AS new_velocity_x,
    ROUND((position_x + velocity_x)::numeric, 4) AS new_position_x
FROM pso_update
ORDER BY particle_id;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 å‡½æ•°ä¼˜åŒ–

```sql
-- å…¨å±€å‡½æ•°ä¼˜åŒ–åº”ç”¨
WITH optimization_result AS (
    SELECT
        algorithm_name,
        best_x1,
        best_x2,
        best_objective_value
    FROM global_optimization_results
)
SELECT
    algorithm_name,
    ROUND(best_x1::numeric, 4) AS optimal_x1,
    ROUND(best_x2::numeric, 4) AS optimal_x2,
    ROUND(best_objective_value::numeric, 4) AS optimal_value
FROM optimization_result
ORDER BY best_objective_value;
```

### 5.2 ç»„åˆä¼˜åŒ–

```sql
-- ç»„åˆä¼˜åŒ–åº”ç”¨ï¼ˆTSPé—®é¢˜ï¼‰
WITH tsp_solution AS (
    SELECT
        tour_sequence,
        total_distance
    FROM traveling_salesman_solution
)
SELECT
    tour_sequence,
    ROUND(total_distance::numeric, 2) AS tour_length
FROM tsp_solution
ORDER BY total_distance
LIMIT 1;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Kirkpatrick, S., et al. (1983)**: "Optimization by simulated annealing"
2. **Holland, J.H. (1992)**: "Adaptation in Natural and Artificial Systems"
3. **Kennedy, J., Eberhart, R. (1995)**: "Particle swarm optimization"

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å‚æ•°è°ƒä¼˜**: è°ƒæ•´ç®—æ³•å‚æ•°æé«˜æ€§èƒ½
2. **æ··åˆç­–ç•¥**: ç»“åˆå¤šç§ç®—æ³•
3. **å¹¶è¡ŒåŒ–**: åˆ©ç”¨PostgreSQLå¹¶è¡Œå¤„ç†
4. **æ—©åœ**: è®¾ç½®åˆç†çš„åœæ­¢æ¡ä»¶

## ğŸ¯ æœ€ä½³å®è·µ

1. **é—®é¢˜åˆ†æ**: ç†è§£é—®é¢˜ç‰¹ç‚¹é€‰æ‹©åˆé€‚ç®—æ³•
2. **å‚æ•°è®¾ç½®**: æ ¹æ®é—®é¢˜è§„æ¨¡è°ƒæ•´å‚æ•°
3. **å¤šæ¬¡è¿è¡Œ**: å¤šæ¬¡è¿è¡Œå–æœ€å¥½ç»“æœ
4. **ç»“æœéªŒè¯**: éªŒè¯æ‰¾åˆ°çš„è§£çš„è´¨é‡

---

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **å…ƒå¯å‘å¼ç®—æ³•**: å…¨å±€ä¼˜åŒ–é€šå¸¸ä½¿ç”¨å…ƒå¯å‘å¼ç®—æ³•ï¼Œéœ€è¦å¤§é‡è¿­ä»£
2. **éšæœºæ€§**: ç®—æ³•å…·æœ‰éšæœºæ€§ï¼Œéœ€è¦å¤šæ¬¡è¿è¡Œå–å¹³å‡
3. **å‚æ•°è°ƒä¼˜**: æ¸©åº¦ã€ç§ç¾¤å¤§å°ç­‰å‚æ•°éœ€è¦ä»”ç»†è°ƒä¼˜
4. **æ”¶æ•›åˆ¤æ–­**: å…¨å±€ä¼˜åŒ–æ²¡æœ‰æ˜ç¡®çš„æ”¶æ•›æ¡ä»¶ï¼Œéœ€è¦è®¾ç½®è¿­ä»£ä¸Šé™

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡å…¨å±€ä¼˜åŒ–ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«è¿­ä»£IDçš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nè§£æŸ¥è¯¢å’Œä¼˜åŒ–å†å²åˆ†ææŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡å…¨å±€ä¼˜åŒ–ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡å‡½æ•°è¯„ä¼°å’Œå¹¶è¡Œç§ç¾¤æ›´æ–°

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - å…¨å±€ä¼˜åŒ–æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡ä¼˜åŒ–å’Œå¹¶è¡Œç§ç¾¤è¿›åŒ–

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–å…¨å±€ä¼˜åŒ–æŸ¥è¯¢**

```sql
-- ä¸ºå…¨å±€ä¼˜åŒ–åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_global_optimization_skip_scan
ON sa_state(iteration DESC, energy_value ASC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾å…¨å±€æœ€ä¼˜è§£
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (DATE_TRUNC('day', CURRENT_TIMESTAMP))
    iteration,
    x_value,
    y_value,
    energy_value,
    temperature
FROM sa_state
ORDER BY energy_value ASC
LIMIT 50;
```

### é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å…¨å±€ä¼˜åŒ–ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„å…¨å±€ä¼˜åŒ–ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜å…¨å±€ä¼˜åŒ–ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS global_optimization_cache AS
WITH optimization_progress AS (
    SELECT
        iteration,
        x_value,
        y_value,
        energy_value,
        temperature,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æœ€ä¼˜å€¼å†å²ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        MIN(energy_value) OVER (ORDER BY iteration ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS best_energy_so_far,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ¥å—ç‡
        COUNT(*) FILTER (WHERE accepted = TRUE) OVER (
            PARTITION BY DATE_TRUNC('minute', timestamp)
            ORDER BY iteration
            ROWS BETWEEN 99 PRECEDING AND CURRENT ROW
        )::numeric / 100 AS acceptance_rate
    FROM sa_state
),
optimization_quality AS (
    SELECT
        iteration,
        ROUND(x_value::numeric, 4) AS x_value,
        ROUND(y_value::numeric, 4) AS y_value,
        ROUND(energy_value::numeric, 4) AS energy_value,
        ROUND(temperature::numeric, 4) AS temperature,
        ROUND(best_energy_so_far::numeric, 4) AS best_energy_so_far,
        ROUND(acceptance_rate::numeric, 4) AS acceptance_rate,
        CASE
            WHEN energy_value = best_energy_so_far THEN 'Global Best - Optimal Solution'
            WHEN energy_value < best_energy_so_far * 1.1 THEN 'Near Optimal - Good Solution'
            WHEN acceptance_rate > 0.5 THEN 'Exploring - Accepting Moves'
            ELSE 'Exploiting - Local Search'
        END AS optimization_phase
    FROM optimization_progress
)
SELECT
    iteration,
    x_value,
    y_value,
    energy_value,
    temperature,
    best_energy_so_far,
    acceptance_rate,
    optimization_phase
FROM optimization_quality
ORDER BY iteration;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_global_optimization_cache_iteration ON global_optimization_cache(iteration DESC);
CREATE INDEX idx_global_optimization_cache_phase ON global_optimization_cache(optimization_phase, energy_value ASC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY global_optimization_cache;
```

**2. å®æ—¶å…¨å±€ä¼˜åŒ–ï¼šå¢é‡ç§ç¾¤æ›´æ–°**

**å®æ—¶å…¨å±€ä¼˜åŒ–**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°ç§ç¾¤ç»“æœã€‚

```sql
-- å®æ—¶å…¨å±€ä¼˜åŒ–ï¼šå¢é‡ç§ç¾¤æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'global_optimization_state') THEN
            CREATE TABLE global_optimization_state (
                optimization_id VARCHAR(100) NOT NULL,
                generation INTEGER NOT NULL,
                individual_id INTEGER NOT NULL,
                parameter_vector JSONB,
                fitness_value NUMERIC,
                is_elite BOOLEAN,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (optimization_id, generation, individual_id)
            );

            CREATE INDEX idx_global_optimization_state_opt ON global_optimization_state(optimization_id, generation DESC);
            CREATE INDEX idx_global_optimization_state_updated ON global_optimization_state(last_updated DESC);

            RAISE NOTICE 'å…¨å±€ä¼˜åŒ–çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡å…¨å±€ä¼˜åŒ–æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡å…¨å±€ä¼˜åŒ–æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**3. æ™ºèƒ½å…¨å±€ä¼˜åŒ–ï¼šè‡ªé€‚åº”ç®—æ³•é€‰æ‹©**

**æ™ºèƒ½å…¨å±€ä¼˜åŒ–**ï¼šæ ¹æ®é—®é¢˜ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜å…¨å±€ä¼˜åŒ–ç®—æ³•ã€‚

```sql
-- æ™ºèƒ½å…¨å±€ä¼˜åŒ–ï¼šè‡ªé€‚åº”ç®—æ³•é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    problem_dimension INTEGER;
    search_space_size NUMERIC;
    recommended_algorithm VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sa_state') THEN
            RAISE WARNING 'è¡¨ sa_state ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½å…¨å±€ä¼˜åŒ–';
            RETURN;
        END IF;

        -- è®¡ç®—é—®é¢˜ç‰¹å¾
        SELECT
            2,  -- å‡è®¾2ç»´é—®é¢˜
            COUNT(DISTINCT x_value) * COUNT(DISTINCT y_value)
        INTO problem_dimension, search_space_size
        FROM sa_state;

        -- æ ¹æ®é—®é¢˜ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©ç®—æ³•
        IF search_space_size < 1000 THEN
            recommended_algorithm := 'EXHAUSTIVE_SEARCH';  -- å°æœç´¢ç©ºé—´ï¼šç©·ä¸¾æœç´¢
        ELSIF problem_dimension < 5 THEN
            recommended_algorithm := 'SIMULATED_ANNEALING';  -- ä½ç»´ï¼šæ¨¡æ‹Ÿé€€ç«
        ELSIF problem_dimension < 20 THEN
            recommended_algorithm := 'GENETIC_ALGORITHM';  -- ä¸­ç­‰ç»´åº¦ï¼šé—ä¼ ç®—æ³•
        ELSE
            recommended_algorithm := 'PARTICLE_SWARM_OPTIMIZATION';  -- é«˜ç»´ï¼šç²’å­ç¾¤ä¼˜åŒ–
        END IF;

        RAISE NOTICE 'é—®é¢˜ç»´åº¦: %, æœç´¢ç©ºé—´å¤§å°: %, æ¨èç®—æ³•: %',
            problem_dimension, search_space_size, recommended_algorithm;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½å…¨å±€ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç†è®ºæ¨å¯¼ã€å®ç°å’ŒPostgreSQL 18æ–°ç‰¹æ€§æ”¯æŒï¼‰
