# PostgreSQL å…¨å±€ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ä¼˜åŒ–ç®—æ³• | å…¨å±€ä¼˜åŒ– | å…ƒå¯å‘å¼
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Global Optimization, Metaheuristics, Evolutionary Algorithms

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å…¨å±€ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å…¨å±€ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å…¨å±€ä¼˜åŒ–æ¦‚è¿°](#å…¨å±€ä¼˜åŒ–æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [é—®é¢˜ç‰¹ç‚¹](#é—®é¢˜ç‰¹ç‚¹)
    - [ç®—æ³•åˆ†ç±»](#ç®—æ³•åˆ†ç±»)
  - [1. æ¨¡æ‹Ÿé€€ç«](#1-æ¨¡æ‹Ÿé€€ç«)
    - [1.1 æ¨¡æ‹Ÿé€€ç«åŸç†](#11-æ¨¡æ‹Ÿé€€ç«åŸç†)
    - [1.2 æ¸©åº¦è°ƒåº¦](#12-æ¸©åº¦è°ƒåº¦)
  - [2. é—ä¼ ç®—æ³•](#2-é—ä¼ ç®—æ³•)
    - [2.1 é—ä¼ ç®—æ³•åŸç†](#21-é—ä¼ ç®—æ³•åŸç†)
    - [2.2 é€‰æ‹©æ“ä½œ](#22-é€‰æ‹©æ“ä½œ)
    - [2.3 äº¤å‰å’Œå˜å¼‚](#23-äº¤å‰å’Œå˜å¼‚)
  - [3. ç²’å­ç¾¤ä¼˜åŒ–](#3-ç²’å­ç¾¤ä¼˜åŒ–)
    - [3.1 PSOåŸç†](#31-psoåŸç†)
  - [4. å¤æ‚åº¦åˆ†æ](#4-å¤æ‚åº¦åˆ†æ)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 å‡½æ•°ä¼˜åŒ–](#51-å‡½æ•°ä¼˜åŒ–)
    - [5.2 ç»„åˆä¼˜åŒ–](#52-ç»„åˆä¼˜åŒ–)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## å…¨å±€ä¼˜åŒ–æ¦‚è¿°

**å…¨å±€ä¼˜åŒ–**æ˜¯åœ¨æ•´ä¸ªæœç´¢ç©ºé—´ä¸­å¯»æ‰¾å…¨å±€æœ€ä¼˜è§£ï¼Œè€Œä¸ä»…ä»…æ˜¯å±€éƒ¨æœ€ä¼˜è§£ã€‚

### ç†è®ºåŸºç¡€

å…¨å±€ä¼˜åŒ–é—®é¢˜é€šå¸¸å…·æœ‰ï¼š

- **å¤šå³°æ€§**: å¤šä¸ªå±€éƒ¨æœ€ä¼˜è§£
- **éå‡¸æ€§**: ç›®æ ‡å‡½æ•°éå‡¸
- **é«˜ç»´æ€§**: æœç´¢ç©ºé—´ç»´åº¦é«˜

### é—®é¢˜ç‰¹ç‚¹

**æŒ‘æˆ˜**:

- å±€éƒ¨æœ€ä¼˜è§£é™·é˜±
- æœç´¢ç©ºé—´å·¨å¤§
- è®¡ç®—æˆæœ¬é«˜

**ä¼˜åŠ¿**:

- èƒ½æ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£
- å¯¹é—®é¢˜ç»“æ„è¦æ±‚ä½
- é€‚ç”¨äºå¤æ‚é—®é¢˜

### ç®—æ³•åˆ†ç±»

| ç®—æ³•ç±»å‹ | ä»£è¡¨ç®—æ³• | ç‰¹ç‚¹ |
|---------|---------|------|
| **åŸºäºç‰©ç†** | æ¨¡æ‹Ÿé€€ç« | å—ç‰©ç†è¿‡ç¨‹å¯å‘ |
| **åŸºäºè¿›åŒ–** | é—ä¼ ç®—æ³• | æ¨¡æ‹Ÿç”Ÿç‰©è¿›åŒ– |
| **åŸºäºç¾¤ä½“** | ç²’å­ç¾¤ä¼˜åŒ– | æ¨¡æ‹Ÿç¾¤ä½“è¡Œä¸º |
| **åŸºäºå±€éƒ¨æœç´¢** | ç¦å¿Œæœç´¢ | é¿å…é‡å¤æœç´¢ |

---

## 1. æ¨¡æ‹Ÿé€€ç«

### 1.1 æ¨¡æ‹Ÿé€€ç«åŸç†

**æ¨¡æ‹Ÿé€€ç«ï¼ˆSimulated Annealingï¼‰**å—é‡‘å±é€€ç«è¿‡ç¨‹å¯å‘ï¼Œé€šè¿‡æ¥å—è¾ƒå·®è§£æ¥è·³å‡ºå±€éƒ¨æœ€ä¼˜ã€‚

**æ¥å—æ¦‚ç‡**:
$$P(accept) = \begin{cases} 1 & \text{if } \Delta E < 0 \\ e^{-\Delta E/T} & \text{if } \Delta E \geq 0 \end{cases}$$

å…¶ä¸­ï¼š

- $\Delta E$ æ˜¯èƒ½é‡å·®ï¼ˆç›®æ ‡å‡½æ•°å·®ï¼‰
- $T$ æ˜¯å½“å‰æ¸©åº¦

```sql
-- æ¨¡æ‹Ÿé€€ç«å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sa_state') THEN
            RAISE WARNING 'è¡¨ sa_state å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE sa_state CASCADE;
        END IF;

        CREATE TABLE sa_state (
            iteration INTEGER PRIMARY KEY,
            x1 NUMERIC NOT NULL,
            x2 NUMERIC NOT NULL,
            objective_value NUMERIC NOT NULL,
            temperature NUMERIC NOT NULL
        );

        -- æ’å…¥åˆå§‹çŠ¶æ€
        INSERT INTO sa_state (iteration, x1, x2, objective_value, temperature) VALUES
            (0, 0.0, 0.0, 10.0, 100.0);

        RAISE NOTICE 'è¡¨ sa_state åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ sa_state å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æ¨¡æ‹Ÿé€€ç«è¿­ä»£
WITH current_state AS (
    SELECT * FROM sa_state
    WHERE iteration = (SELECT MAX(iteration) FROM sa_state)
),
neighbor_state AS (
    SELECT
        x1 + (RANDOM() - 0.5) * 0.1 AS new_x1,
        x2 + (RANDOM() - 0.5) * 0.1 AS new_x2,
        temperature * 0.95 AS new_temperature  -- æ¸©åº¦è¡°å‡
    FROM current_state
),
new_objective AS (
    SELECT
        new_x1,
        new_x2,
        POWER(new_x1, 2) + POWER(new_x2, 2) AS new_obj_value,
        new_temperature
    FROM neighbor_state
),
acceptance_probability AS (
    SELECT
        ns.new_x1,
        ns.new_x2,
        no.new_obj_value,
        cs.objective_value AS current_obj,
        no.new_obj_value - cs.objective_value AS delta_e,
        no.new_temperature,
        CASE
            WHEN no.new_obj_value < cs.objective_value THEN 1.0
            ELSE EXP(-(no.new_obj_value - cs.objective_value) / NULLIF(no.new_temperature, 0))
        END AS accept_prob
    FROM new_objective no
    CROSS JOIN current_state cs
    CROSS JOIN neighbor_state ns
)
SELECT
    ROUND(new_x1::numeric, 4) AS candidate_x1,
    ROUND(new_x2::numeric, 4) AS candidate_x2,
    ROUND(new_obj_value::numeric, 4) AS candidate_objective,
    ROUND(delta_e::numeric, 4) AS energy_difference,
    ROUND(accept_prob::numeric, 4) AS acceptance_probability,
    CASE
        WHEN accept_prob > RANDOM() THEN 'Accept'
        ELSE 'Reject'
    END AS decision
FROM acceptance_probability;
```

### 1.2 æ¸©åº¦è°ƒåº¦

**æ¸©åº¦è°ƒåº¦ç­–ç•¥**:

- **çº¿æ€§å†·å´**: $T_k = T_0 - k \times \alpha$
- **æŒ‡æ•°å†·å´**: $T_k = T_0 \times \alpha^k$
- **å¯¹æ•°å†·å´**: $T_k = \frac{T_0}{\log(k+1)}$

```sql
-- æ¸©åº¦è°ƒåº¦
WITH temperature_schedule AS (
    SELECT
        iteration,
        100.0 * POWER(0.95, iteration) AS exponential_cooling,
        100.0 / LN(iteration + 2) AS logarithmic_cooling,
        100.0 - iteration * 0.5 AS linear_cooling
    FROM generate_series(0, 100) AS iteration
)
SELECT
    iteration,
    ROUND(exponential_cooling::numeric, 4) AS exp_temp,
    ROUND(logarithmic_cooling::numeric, 4) AS log_temp,
    ROUND(linear_cooling::numeric, 4) AS linear_temp
FROM temperature_schedule
ORDER BY iteration;
```

---

## 2. é—ä¼ ç®—æ³•

### 2.1 é—ä¼ ç®—æ³•åŸç†

**é—ä¼ ç®—æ³•ï¼ˆGenetic Algorithmï¼‰**æ¨¡æ‹Ÿç”Ÿç‰©è¿›åŒ–è¿‡ç¨‹ï¼Œé€šè¿‡é€‰æ‹©ã€äº¤å‰ã€å˜å¼‚æ“ä½œæœç´¢æœ€ä¼˜è§£ã€‚

**ç®—æ³•æµç¨‹**:

1. åˆå§‹åŒ–ç§ç¾¤
2. è¯„ä¼°é€‚åº”åº¦
3. é€‰æ‹©
4. äº¤å‰
5. å˜å¼‚
6. é‡å¤æ­¥éª¤2-5ç›´åˆ°æ”¶æ•›

```sql
-- é—ä¼ ç®—æ³•å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'ga_population') THEN
            RAISE WARNING 'è¡¨ ga_population å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE ga_population CASCADE;
        END IF;

        CREATE TABLE ga_population (
            individual_id SERIAL PRIMARY KEY,
            chromosome VARCHAR(10) NOT NULL,
            fitness NUMERIC NOT NULL
        );

        -- æ’å…¥åˆå§‹ç§ç¾¤
        INSERT INTO ga_population (chromosome, fitness) VALUES
            ('10101010', 0.5),
            ('11001100', 0.6),
            ('10110110', 0.4),
            ('11011011', 0.7);

        RAISE NOTICE 'è¡¨ ga_population åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ ga_population å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

### 2.2 é€‰æ‹©æ“ä½œ

**è½®ç›˜èµŒé€‰æ‹©**:
$$P_i = \frac{f_i}{\sum_{j=1}^{n} f_j}$$

```sql
-- è½®ç›˜èµŒé€‰æ‹©
WITH fitness_sum AS (
    SELECT SUM(fitness) AS total_fitness FROM ga_population
),
selection_probability AS (
    SELECT
        individual_id,
        chromosome,
        fitness,
        fitness / NULLIF((SELECT total_fitness FROM fitness_sum), 0) AS selection_prob,
        SUM(fitness / NULLIF((SELECT total_fitness FROM fitness_sum), 0)) OVER (ORDER BY individual_id) AS cumulative_prob
    FROM ga_population
    CROSS JOIN fitness_sum
)
SELECT
    individual_id,
    chromosome,
    ROUND(fitness::numeric, 4) AS fitness,
    ROUND(selection_prob::numeric, 4) AS selection_probability,
    ROUND(cumulative_prob::numeric, 4) AS cumulative_probability
FROM selection_probability
ORDER BY individual_id;
```

### 2.3 äº¤å‰å’Œå˜å¼‚

**å•ç‚¹äº¤å‰**:

```sql
-- å•ç‚¹äº¤å‰
WITH parent_pair AS (
    SELECT
        p1.chromosome AS parent1,
        p2.chromosome AS parent2,
        4 AS crossover_point
    FROM ga_population p1
    CROSS JOIN ga_population p2
    WHERE p1.individual_id < p2.individual_id
    LIMIT 1
)
SELECT
    parent1,
    parent2,
    LEFT(parent1, crossover_point) || RIGHT(parent2, LENGTH(parent2) - crossover_point) AS offspring1,
    LEFT(parent2, crossover_point) || RIGHT(parent1, LENGTH(parent1) - crossover_point) AS offspring2
FROM parent_pair;
```

**å˜å¼‚**:

```sql
-- å˜å¼‚æ“ä½œ
WITH mutation AS (
    SELECT
        chromosome,
        -- éšæœºç¿»è½¬ä¸€ä½
        OVERLAY(chromosome PLACING CASE SUBSTRING(chromosome FROM 3 FOR 1) WHEN '0' THEN '1' ELSE '0' END FROM 3 FOR 1) AS mutated_chromosome
    FROM ga_population
    WHERE RANDOM() < 0.1  -- 10%å˜å¼‚æ¦‚ç‡
)
SELECT
    chromosome AS original,
    mutated_chromosome AS mutated
FROM mutation;
```

---

## 3. ç²’å­ç¾¤ä¼˜åŒ–

### 3.1 PSOåŸç†

**ç²’å­ç¾¤ä¼˜åŒ–ï¼ˆParticle Swarm Optimizationï¼‰**æ¨¡æ‹Ÿé¸Ÿç¾¤è§…é£Ÿè¡Œä¸ºã€‚

**ç²’å­æ›´æ–°**:
$$v_i^{t+1} = w v_i^t + c_1 r_1 (p_i - x_i^t) + c_2 r_2 (g - x_i^t)$$
$$x_i^{t+1} = x_i^t + v_i^{t+1}$$

å…¶ä¸­ï¼š

- $v_i$ æ˜¯ç²’å­é€Ÿåº¦
- $x_i$ æ˜¯ç²’å­ä½ç½®
- $p_i$ æ˜¯ç²’å­å†å²æœ€ä¼˜ä½ç½®
- $g$ æ˜¯å…¨å±€æœ€ä¼˜ä½ç½®
- $w$ æ˜¯æƒ¯æ€§æƒé‡
- $c_1, c_2$ æ˜¯å­¦ä¹ å› å­

```sql
-- PSOå®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'pso_particles') THEN
            RAISE WARNING 'è¡¨ pso_particles å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE pso_particles CASCADE;
        END IF;

        CREATE TABLE pso_particles (
            particle_id INTEGER PRIMARY KEY,
            x1 NUMERIC NOT NULL,
            x2 NUMERIC NOT NULL,
            v1 NUMERIC NOT NULL,
            v2 NUMERIC NOT NULL,
            best_x1 NUMERIC NOT NULL,
            best_x2 NUMERIC NOT NULL,
            best_fitness NUMERIC NOT NULL
        );

        -- æ’å…¥åˆå§‹ç²’å­
        INSERT INTO pso_particles (particle_id, x1, x2, v1, v2, best_x1, best_x2, best_fitness) VALUES
            (1, 1.0, 1.0, 0.1, 0.1, 1.0, 1.0, 2.0),
            (2, 2.0, 2.0, 0.1, 0.1, 2.0, 2.0, 8.0);

        RAISE NOTICE 'è¡¨ pso_particles åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ pso_particles å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- PSOæ›´æ–°
WITH global_best AS (
    SELECT
        best_x1 AS g_x1,
        best_x2 AS g_x2
    FROM pso_particles
    ORDER BY best_fitness
    LIMIT 1
),
particle_update AS (
    SELECT
        pp.particle_id,
        pp.x1,
        pp.x2,
        pp.v1,
        pp.v2,
        pp.best_x1,
        pp.best_x2,
        gb.g_x1,
        gb.g_x2,
        0.7 AS inertia_weight,
        1.5 AS c1,
        1.5 AS c2,
        -- é€Ÿåº¦æ›´æ–°
        0.7 * pp.v1 + 1.5 * RANDOM() * (pp.best_x1 - pp.x1) + 1.5 * RANDOM() * (gb.g_x1 - pp.x1) AS new_v1,
        0.7 * pp.v2 + 1.5 * RANDOM() * (pp.best_x2 - pp.x2) + 1.5 * RANDOM() * (gb.g_x2 - pp.x2) AS new_v2
    FROM pso_particles pp
    CROSS JOIN global_best gb
),
position_update AS (
    SELECT
        particle_id,
        x1 + new_v1 AS new_x1,
        x2 + new_v2 AS new_x2,
        new_v1,
        new_v2,
        POWER(x1 + new_v1, 2) + POWER(x2 + new_v2, 2) AS new_fitness
    FROM particle_update
)
SELECT
    particle_id,
    ROUND(new_x1::numeric, 4) AS updated_x1,
    ROUND(new_x2::numeric, 4) AS updated_x2,
    ROUND(new_v1::numeric, 4) AS updated_v1,
    ROUND(new_v2::numeric, 4) AS updated_v2,
    ROUND(new_fitness::numeric, 4) AS new_fitness
FROM position_update;
```

---

## 4. å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | æ”¶æ•›é€Ÿåº¦ |
|------|-----------|-----------|---------|
| **æ¨¡æ‹Ÿé€€ç«** | $O(iterations)$ | $O(1)$ | æ…¢ |
| **é—ä¼ ç®—æ³•** | $O(pop_size \times iterations)$ | $O(pop_size)$ | ä¸­ç­‰ |
| **ç²’å­ç¾¤ä¼˜åŒ–** | $O(pop_size \times iterations)$ | $O(pop_size)$ | å¿« |

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 å‡½æ•°ä¼˜åŒ–

```sql
-- å…¨å±€å‡½æ•°ä¼˜åŒ–åº”ç”¨
WITH optimization_result AS (
    SELECT
        algorithm_name,
        best_x1,
        best_x2,
        best_objective_value
    FROM global_optimization_results
)
SELECT
    algorithm_name,
    ROUND(best_x1::numeric, 4) AS optimal_x1,
    ROUND(best_x2::numeric, 4) AS optimal_x2,
    ROUND(best_objective_value::numeric, 4) AS optimal_value
FROM optimization_result
ORDER BY best_objective_value;
```

### 5.2 ç»„åˆä¼˜åŒ–

```sql
-- ç»„åˆä¼˜åŒ–åº”ç”¨ï¼ˆTSPé—®é¢˜ï¼‰
WITH tsp_solution AS (
    SELECT
        tour_sequence,
        total_distance
    FROM traveling_salesman_solution
)
SELECT
    tour_sequence,
    ROUND(total_distance::numeric, 2) AS tour_length
FROM tsp_solution
ORDER BY total_distance
LIMIT 1;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Kirkpatrick, S., et al. (1983)**: "Optimization by simulated annealing"
2. **Holland, J.H. (1992)**: "Adaptation in Natural and Artificial Systems"
3. **Kennedy, J., Eberhart, R. (1995)**: "Particle swarm optimization"

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å‚æ•°è°ƒä¼˜**: è°ƒæ•´ç®—æ³•å‚æ•°æé«˜æ€§èƒ½
2. **æ··åˆç­–ç•¥**: ç»“åˆå¤šç§ç®—æ³•
3. **å¹¶è¡ŒåŒ–**: åˆ©ç”¨PostgreSQLå¹¶è¡Œå¤„ç†
4. **æ—©åœ**: è®¾ç½®åˆç†çš„åœæ­¢æ¡ä»¶

## ğŸ¯ æœ€ä½³å®è·µ

1. **é—®é¢˜åˆ†æ**: ç†è§£é—®é¢˜ç‰¹ç‚¹é€‰æ‹©åˆé€‚ç®—æ³•
2. **å‚æ•°è®¾ç½®**: æ ¹æ®é—®é¢˜è§„æ¨¡è°ƒæ•´å‚æ•°
3. **å¤šæ¬¡è¿è¡Œ**: å¤šæ¬¡è¿è¡Œå–æœ€å¥½ç»“æœ
4. **ç»“æœéªŒè¯**: éªŒè¯æ‰¾åˆ°çš„è§£çš„è´¨é‡

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
