# PostgreSQL 文本挖掘算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 文本挖掘 | 关键词提取
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 文本挖掘算法完整指南](#postgresql-文本挖掘算法完整指南)
  - [📋 目录](#-目录)
  - [文本挖掘算法概述](#文本挖掘算法概述)
    - [理论基础](#理论基础)
      - [文本挖掘问题定义](#文本挖掘问题定义)
      - [挖掘算法分类](#挖掘算法分类)
      - [挖掘策略选择](#挖掘策略选择)
    - [核心挖掘功能](#核心挖掘功能)
  - [1. 关键词提取](#1-关键词提取)
    - [1.1 关键词提取原理](#11-关键词提取原理)
      - [关键词定义](#关键词定义)
      - [提取方法](#提取方法)
    - [1.2 高频词提取实现](#12-高频词提取实现)
    - [1.3 TF-IDF关键词提取](#13-tf-idf关键词提取)
    - [1.4 关键词过滤](#14-关键词过滤)
  - [2. 词频统计](#2-词频统计)
    - [2.1 词频统计原理](#21-词频统计原理)
      - [词频定义](#词频定义)
      - [统计方法](#统计方法)
    - [2.2 文档词频统计实现](#22-文档词频统计实现)
    - [2.3 全局词频统计](#23-全局词频统计)
    - [2.4 词频分布分析](#24-词频分布分析)
  - [3. TF-IDF计算](#3-tf-idf计算)
    - [3.1 TF-IDF原理](#31-tf-idf原理)
      - [TF-IDF定义](#tf-idf定义)
      - [TF-IDF公式](#tf-idf公式)
    - [3.2 TF-IDF评分实现](#32-tf-idf评分实现)
    - [3.3 TF-IDF优化](#33-tf-idf优化)
  - [4. 主题建模](#4-主题建模)
    - [4.1 主题建模原理](#41-主题建模原理)
      - [主题定义](#主题定义)
      - [LDA模型](#lda模型)
    - [4.2 简单主题提取](#42-简单主题提取)
  - [5. 文本挖掘优化策略](#5-文本挖掘优化策略)
    - [5.1 索引优化](#51-索引优化)
    - [5.2 批量处理优化](#52-批量处理优化)
    - [5.3 并行计算优化](#53-并行计算优化)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 主题关键词提取](#61-主题关键词提取)
    - [6.2 文档摘要生成](#62-文档摘要生成)
    - [6.3 热点话题分析](#63-热点话题分析)
    - [6.4 内容推荐系统](#64-内容推荐系统)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 挖掘算法对比](#71-挖掘算法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 算法选择](#81-算法选择)
    - [8.2 参数调优](#82-参数调优)
    - [8.3 性能优化](#83-性能优化)
    - [8.4 SQL实现注意事项](#84-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 文本挖掘算法概述

**文本挖掘算法（Text Mining Algorithm）**用于从文本中提取有用信息，如关键词、主题、模式等。文本挖掘是自然语言处理和信息检索的重要分支。

### 理论基础

#### 文本挖掘问题定义

**文本挖掘问题**：给定文本集合$D = \{d_1, d_2, \ldots, d_n\}$，提取有用信息：

- **关键词**：$K = \{k_1, k_2, \ldots, k_m\}$
- **主题**：$T = \{t_1, t_2, \ldots, t_k\}$
- **模式**：$P = \{p_1, p_2, \ldots, p_l\}$

**挖掘任务**：

1. **关键词提取**：从文本中提取重要关键词
2. **主题建模**：发现文本的主题分布
3. **模式发现**：发现文本中的模式

#### 挖掘算法分类

文本挖掘算法分类：

1. **基于频率**：
   - 词频统计
   - 高频词提取
   - 时间复杂度：$O(n)$

2. **基于重要性**：
   - TF-IDF计算
   - 关键词评分
   - 时间复杂度：$O(n)$

3. **基于主题**：
   - 主题建模（LDA等）
   - 主题提取
   - 时间复杂度：$O(n \times k)$（$k$为主题数）

#### 挖掘策略选择

选择挖掘策略的考虑因素：

1. **数据规模**：小数据集用简单方法，大数据集用高效算法
2. **精度要求**：高精度用TF-IDF，快速提取用词频
3. **应用场景**：关键词提取、主题发现、模式识别

### 核心挖掘功能

| 功能 | 数学定义 | 用途 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **关键词提取** | $K = \{k_i \mid \text{score}(k_i) > \theta\}$ | 提取关键词 | $O(n)$ | $O(n)$ | 文档摘要 |
| **词频统计** | $\text{tf}(w, d) = \frac{\text{count}(w, d)}{|d|}$ | 统计词频 | $O(n)$ | $O(n)$ | 文本分析 |
| **TF-IDF** | $\text{tf-idf}(w, d) = \text{tf}(w, d) \times \text{idf}(w)$ | 重要性评分 | $O(n)$ | $O(n)$ | 关键词提取 |

---

## 1. 关键词提取

### 1.1 关键词提取原理

**关键词提取（Keyword Extraction）**是从文本中提取重要关键词的过程。

#### 关键词定义

**关键词**：关键词$k$是文本中的重要词，满足：
$$\text{score}(k) > \theta$$

其中$\text{score}(k)$是关键词的评分，$\theta$是阈值。

#### 提取方法

**关键词提取方法**：

1. **词频方法**：选择高频词
2. **TF-IDF方法**：选择TF-IDF值高的词
3. **位置方法**：选择出现在标题、摘要等位置的词
4. **组合方法**：组合多种方法

### 1.2 高频词提取实现

**高频词提取**的实现和使用。

```sql
-- 关键词提取（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行关键词提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行关键词提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '关键词提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH word_frequencies AS (
    SELECT
        unnest(string_to_array(lower(content), ' ')) AS word,
        COUNT(*) AS frequency
    FROM documents
    GROUP BY unnest(string_to_array(lower(content), ' '))
    HAVING length(unnest(string_to_array(lower(content), ' '))) > 3  -- 过滤短词
)
SELECT
    word,
    frequency,
    frequency * 100.0 / SUM(frequency) OVER () AS frequency_pct
FROM word_frequencies
ORDER BY frequency DESC
LIMIT 50;
```

---

### 1.3 TF-IDF关键词提取

**TF-IDF关键词提取**：使用TF-IDF值提取关键词。

```sql
-- TF-IDF关键词提取（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行TF-IDF关键词提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行TF-IDF关键词提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'TF-IDF关键词提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- TF-IDF关键词提取：提取每个文档的Top N关键词
WITH document_words AS (
    SELECT
        id,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
    WHERE length(unnest(string_to_array(lower(content), ' '))) > 3
),
term_frequency AS (
    SELECT
        id,
        word,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) AS tf
    FROM document_words
    GROUP BY id, word
),
document_frequency AS (
    SELECT
        word,
        COUNT(DISTINCT id) AS df
    FROM document_words
    GROUP BY word
),
total_documents AS (
    SELECT COUNT(DISTINCT id) AS total
    FROM documents
),
tf_idf_scores AS (
    SELECT
        tf.id,
        tf.word,
        tf.tf * LN(td.total::NUMERIC / NULLIF(df.df, 0)) AS tf_idf
    FROM term_frequency tf
    JOIN document_frequency df ON tf.word = df.word
    CROSS JOIN total_documents td
)
SELECT
    id,
    word,
    tf_idf
FROM (
    SELECT
        id,
        word,
        tf_idf,
        ROW_NUMBER() OVER (PARTITION BY id ORDER BY tf_idf DESC) AS rn
    FROM tf_idf_scores
) AS ranked
WHERE rn <= 10  -- Top 10关键词
ORDER BY id, tf_idf DESC;
```

### 1.4 关键词过滤

**关键词过滤**：过滤停用词和无意义词。

```sql
-- 关键词过滤（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 创建停用词表
        CREATE TABLE IF NOT EXISTS stop_words (
            word TEXT PRIMARY KEY
        );

        -- 插入常见停用词
        INSERT INTO stop_words (word) VALUES
            ('the'), ('a'), ('an'), ('and'), ('or'), ('but'), ('in'), ('on'), ('at'), ('to'), ('for'), ('of'), ('with'), ('by')
        ON CONFLICT (word) DO NOTHING;

        RAISE NOTICE '停用词表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '停用词表创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 过滤停用词的关键词提取
SELECT
    word,
    COUNT(*) AS frequency
FROM (
    SELECT unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
) AS expanded
WHERE length(word) > 3
  AND word NOT IN (SELECT word FROM stop_words)
GROUP BY word
ORDER BY frequency DESC
LIMIT 50;
```

---

## 2. 词频统计

### 2.1 词频统计原理

**词频统计（Term Frequency Statistics）**是统计文本中词的出现频率。

#### 词频定义

**词频（Term Frequency, TF）**：词$w$在文档$d$中的频率：
$$\text{tf}(w, d) = \frac{\text{count}(w, d)}{|d|}$$

其中：

- $\text{count}(w, d)$：词$w$在文档$d$中的出现次数
- $|d|$：文档$d$的总词数

#### 统计方法

**词频统计方法**：

1. **文档词频**：统计每个文档中的词频
2. **全局词频**：统计整个语料库中的词频
3. **相对词频**：词频相对于总词数的比例

### 2.2 文档词频统计实现

**文档词频统计**的实现和使用。

```sql
-- 词频统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行词频统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行词频统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '词频统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT
    id,
    word,
    COUNT(*) AS word_count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY id) AS word_frequency_pct
FROM (
    SELECT
        id,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
) AS expanded
GROUP BY id, word
ORDER BY id, word_count DESC;
```

---

### 2.3 全局词频统计

**全局词频统计**：统计整个语料库中的词频。

```sql
-- 全局词频统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行全局词频统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行全局词频统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '全局词频统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 全局词频统计：统计所有文档中的词频
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    word,
    COUNT(*) AS global_frequency,
    COUNT(DISTINCT id) AS document_frequency,
    COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () AS global_frequency_pct
FROM (
    SELECT
        id,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
    WHERE length(unnest(string_to_array(lower(content), ' '))) > 3
) AS expanded
GROUP BY word
ORDER BY global_frequency DESC
LIMIT 100;
```

### 2.4 词频分布分析

**词频分布分析**：分析词频的分布特征。

```sql
-- 词频分布分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行词频分布分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行词频分布分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '词频分布分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 词频分布分析：Zipf定律验证
WITH word_frequencies AS (
    SELECT
        word,
        COUNT(*) AS frequency
    FROM (
        SELECT unnest(string_to_array(lower(content), ' ')) AS word
        FROM documents
    ) AS expanded
    GROUP BY word
),
ranked_words AS (
    SELECT
        word,
        frequency,
        ROW_NUMBER() OVER (ORDER BY frequency DESC) AS rank
    FROM word_frequencies
)
SELECT
    rank,
    word,
    frequency,
    frequency::NUMERIC / (SELECT MAX(frequency) FROM word_frequencies) AS normalized_frequency,
    1.0 / rank AS zipf_prediction
FROM ranked_words
ORDER BY rank
LIMIT 50;
```

---

## 3. TF-IDF计算

### 3.1 TF-IDF原理

**TF-IDF（Term Frequency-Inverse Document Frequency）**是衡量词在文档集合中重要性的经典方法。

#### TF-IDF定义

**TF-IDF**：词$w$在文档$d$中的TF-IDF值为：
$$\text{tf-idf}(w, d) = \text{tf}(w, d) \times \text{idf}(w)$$

其中：

- **TF（Term Frequency）**：$\text{tf}(w, d) = \frac{\text{count}(w, d)}{|d|}$
- **IDF（Inverse Document Frequency）**：$\text{idf}(w) = \ln\left(\frac{N}{\text{df}(w)}\right)$
  - $N$：文档总数
  - $\text{df}(w)$：包含词$w$的文档数

#### TF-IDF公式

**TF-IDF公式**：
$$\text{tf-idf}(w, d) = \frac{\text{count}(w, d)}{|d|} \times \ln\left(\frac{N}{\text{df}(w)}\right)$$

**性质**：

- TF-IDF值越高，词越重要
- 常见词（高DF）的IDF值低
- 稀有词（低DF）的IDF值高

### 3.2 TF-IDF评分实现

**TF-IDF评分**的实现和使用。

```sql
-- TF-IDF计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行TF-IDF计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行TF-IDF计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'TF-IDF计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH document_words AS (
    SELECT
        id,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
),
term_frequency AS (
    SELECT
        id,
        word,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) AS tf
    FROM document_words
    GROUP BY id, word
),
document_frequency AS (
    SELECT
        word,
        COUNT(DISTINCT id) AS df
    FROM document_words
    GROUP BY word
),
total_documents AS (
    SELECT COUNT(DISTINCT id) AS total
    FROM documents
)
SELECT
    tf.id,
    tf.word,
    tf.tf,
    df.df,
    td.total,
    LN(td.total::NUMERIC / NULLIF(df.df, 0)) AS idf,
    tf.tf * LN(td.total::NUMERIC / NULLIF(df.df, 0)) AS tf_idf
FROM term_frequency tf
JOIN document_frequency df ON tf.word = df.word
CROSS JOIN total_documents td
ORDER BY tf.id, tf_idf DESC;
```

---

### 3.3 TF-IDF优化

**TF-IDF优化**：优化TF-IDF计算性能。

```sql
-- TF-IDF优化：使用物化视图缓存中间结果
CREATE MATERIALIZED VIEW IF NOT EXISTS document_word_tf AS
SELECT
    id,
    word,
    COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) AS tf
FROM (
    SELECT
        id,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
) AS expanded
GROUP BY id, word;

CREATE INDEX IF NOT EXISTS idx_document_word_tf_id_word
ON document_word_tf(id, word);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY document_word_tf;
```

---

## 4. 主题建模

### 4.1 主题建模原理

**主题建模（Topic Modeling）**是发现文本集合中潜在主题的方法。

#### 主题定义

**主题**：主题$t$是词的分布：$P(w \mid t)$

**文档主题分布**：文档$d$的主题分布：$P(t \mid d)$

#### LDA模型

**LDA（Latent Dirichlet Allocation）**是经典的主题建模方法：
$$P(w \mid d) = \sum_{t} P(w \mid t) \times P(t \mid d)$$

### 4.2 简单主题提取

**简单主题提取**：使用关键词聚类提取主题（简化版LDA）。

```sql
-- 简单主题提取（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行简单主题提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行简单主题提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '简单主题提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 简单主题提取：基于TF-IDF和关键词聚类
WITH document_keywords AS (
    SELECT
        id,
        word,
        tf_idf
    FROM (
        -- TF-IDF计算（简化版）
        SELECT
            id,
            word,
            COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) *
            LN(COUNT(DISTINCT id) OVER ()::NUMERIC / COUNT(DISTINCT id) OVER (PARTITION BY word)) AS tf_idf
        FROM (
            SELECT id, unnest(string_to_array(lower(content), ' ')) AS word
            FROM documents
        ) AS expanded
        GROUP BY id, word
    ) AS tf_idf_calc
    WHERE tf_idf > 0.5
),
top_keywords_per_doc AS (
    SELECT
        id,
        array_agg(word ORDER BY tf_idf DESC) AS keywords
    FROM (
        SELECT
            id,
            word,
            tf_idf,
            ROW_NUMBER() OVER (PARTITION BY id ORDER BY tf_idf DESC) AS rn
        FROM document_keywords
    ) AS ranked
    WHERE rn <= 5
    GROUP BY id
)
SELECT
    id,
    keywords,
    -- 简单主题标签（基于关键词）
    CASE
        WHEN 'technology' = ANY(keywords) OR 'software' = ANY(keywords) THEN 'Technology'
        WHEN 'business' = ANY(keywords) OR 'finance' = ANY(keywords) THEN 'Business'
        WHEN 'health' = ANY(keywords) OR 'medical' = ANY(keywords) THEN 'Health'
        ELSE 'General'
    END AS topic
FROM top_keywords_per_doc;
```

---

## 5. 文本挖掘优化策略

### 5.1 索引优化

**索引优化**：为文本挖掘创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- GIN索引：全文搜索
        CREATE INDEX IF NOT EXISTS idx_documents_content_gin
        ON documents USING GIN (to_tsvector('english', content));

        RAISE NOTICE '文本挖掘索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 批量处理优化

**批量处理优化**：使用批量操作提高性能。

```sql
-- 批量处理优化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        SET work_mem = '512MB';
        RAISE NOTICE 'work_mem已设置为512MB';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '批量处理优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.3 并行计算优化

**并行计算优化**：使用并行查询处理大规模数据。

```sql
-- 并行计算优化（带错误处理）
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        RAISE NOTICE '并行查询已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行计算优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 6. 实际应用案例

### 6.1 主题关键词提取

**主题关键词提取**提取文档的主题关键词。

```sql
-- 主题关键词提取（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行主题关键词提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行主题关键词提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '主题关键词提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 主题关键词提取：使用TF-IDF提取每个文档的Top关键词
WITH article_words AS (
    SELECT
        id,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM articles
    WHERE length(unnest(string_to_array(lower(content), ' '))) > 4
),
word_stats AS (
    SELECT
        id,
        word,
        COUNT(*) AS word_count,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) AS tf
    FROM article_words
    GROUP BY id, word
),
document_frequency AS (
    SELECT
        word,
        COUNT(DISTINCT id) AS df
    FROM article_words
    GROUP BY word
),
total_docs AS (
    SELECT COUNT(DISTINCT id) AS total
    FROM articles
),
tf_idf_scores AS (
    SELECT
        ws.id,
        ws.word,
        ws.word_count,
        ws.tf,
        df.df,
        ws.tf * LN(td.total::NUMERIC / NULLIF(df.df, 0)) AS tf_idf_score
    FROM word_stats ws
    JOIN document_frequency df ON ws.word = df.word
    CROSS JOIN total_docs td
)
SELECT
    id,
    word,
    tf_idf_score
FROM (
    SELECT
        id,
        word,
        tf_idf_score,
        ROW_NUMBER() OVER (PARTITION BY id ORDER BY tf_idf_score DESC) AS rn
    FROM tf_idf_scores
    WHERE tf_idf_score > 0.5
) AS ranked
WHERE rn <= 10
ORDER BY id, tf_idf_score DESC;
```

### 6.2 文档摘要生成

**文档摘要生成**：基于关键词生成文档摘要。

```sql
-- 文档摘要生成（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行文档摘要生成';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行文档摘要生成';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '文档摘要生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 文档摘要生成：提取包含关键词的句子
WITH document_keywords AS (
    SELECT
        id,
        word,
        tf_idf_score
    FROM (
        -- TF-IDF计算（简化版）
        SELECT
            id,
            word,
            COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) *
            LN(COUNT(DISTINCT id) OVER ()::NUMERIC / COUNT(DISTINCT id) OVER (PARTITION BY word)) AS tf_idf_score
        FROM (
            SELECT id, unnest(string_to_array(lower(content), ' ')) AS word
            FROM documents
        ) AS expanded
        GROUP BY id, word
    ) AS tf_idf_calc
    WHERE tf_idf_score > 0.5
),
top_keywords AS (
    SELECT
        id,
        array_agg(word ORDER BY tf_idf_score DESC) AS keywords
    FROM (
        SELECT
            id,
            word,
            tf_idf_score,
            ROW_NUMBER() OVER (PARTITION BY id ORDER BY tf_idf_score DESC) AS rn
        FROM document_keywords
    ) AS ranked
    WHERE rn <= 5
    GROUP BY id
)
SELECT
    d.id,
    d.title,
    -- 提取包含关键词的句子作为摘要（简化版）
    substring(d.content FROM 1 FOR 200) AS summary_preview,
    tk.keywords AS key_terms
FROM documents d
JOIN top_keywords tk ON d.id = tk.id
ORDER BY d.id;
```

### 6.3 热点话题分析

**热点话题分析**：分析时间序列中的热点话题。

```sql
-- 热点话题分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'news_articles') THEN
            RAISE WARNING '表 news_articles 不存在，无法执行热点话题分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行热点话题分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '热点话题分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 热点话题分析：按时间段分析关键词趋势
WITH time_periods AS (
    SELECT
        DATE_TRUNC('week', published_at) AS week_start,
        id,
        content
    FROM news_articles
    WHERE published_at >= CURRENT_DATE - INTERVAL '12 weeks'
),
weekly_keywords AS (
    SELECT
        week_start,
        word,
        COUNT(*) AS frequency
    FROM (
        SELECT
            week_start,
            unnest(string_to_array(lower(content), ' ')) AS word
        FROM time_periods
    ) AS expanded
    WHERE length(word) > 4
    GROUP BY week_start, word
),
keyword_trends AS (
    SELECT
        word,
        week_start,
        frequency,
        LAG(frequency) OVER (PARTITION BY word ORDER BY week_start) AS prev_frequency,
        frequency - LAG(frequency) OVER (PARTITION BY word ORDER BY week_start) AS frequency_change
    FROM weekly_keywords
)
SELECT
    word,
    week_start,
    frequency,
    frequency_change,
    CASE
        WHEN frequency_change > 0 THEN 'Rising'
        WHEN frequency_change < 0 THEN 'Declining'
        ELSE 'Stable'
    END AS trend
FROM keyword_trends
WHERE frequency_change IS NOT NULL
ORDER BY ABS(frequency_change) DESC, week_start DESC
LIMIT 50;
```

### 6.4 内容推荐系统

**内容推荐系统**：基于TF-IDF推荐相似内容。

```sql
-- 内容推荐系统（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行内容推荐';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行内容推荐';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '内容推荐准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 内容推荐：基于TF-IDF向量相似度推荐相似文章
WITH article_tf_idf AS (
    SELECT
        id,
        word,
        tf_idf_score
    FROM (
        -- TF-IDF计算
        SELECT
            id,
            word,
            COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) *
            LN(COUNT(DISTINCT id) OVER ()::NUMERIC / COUNT(DISTINCT id) OVER (PARTITION BY word)) AS tf_idf_score
        FROM (
            SELECT id, unnest(string_to_array(lower(content), ' ')) AS word
            FROM articles
        ) AS expanded
        GROUP BY id, word
    ) AS tf_idf_calc
    WHERE tf_idf_score > 0.1
),
article_vectors AS (
    SELECT
        id,
        array_agg(word ORDER BY word) AS word_vector,
        array_agg(tf_idf_score ORDER BY word) AS tf_idf_vector
    FROM article_tf_idf
    GROUP BY id
),
similarity_scores AS (
    SELECT
        a1.id AS article1_id,
        a2.id AS article2_id,
        -- 计算余弦相似度（简化版）
        (SELECT COUNT(*) FROM unnest(a1.word_vector) AS w1
         WHERE w1 = ANY(a2.word_vector))::NUMERIC /
        GREATEST(array_length(a1.word_vector, 1), array_length(a2.word_vector, 1)) AS similarity
    FROM article_vectors a1
    CROSS JOIN article_vectors a2
    WHERE a1.id < a2.id
)
SELECT
    article1_id,
    article2_id,
    similarity
FROM similarity_scores
WHERE similarity > 0.3
ORDER BY similarity DESC
LIMIT 20;
```

---

## 7. 算法性能对比与优化

### 7.1 挖掘算法对比

| 算法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **词频统计** | $\text{tf}(w, d) = \frac{\text{count}(w, d)}{|d|}$ | $O(n)$ | $O(n)$ | 简单分析 | 快速、简单 | 忽略重要性 |
| **TF-IDF** | $\text{tf-idf}(w, d) = \text{tf}(w, d) \times \text{idf}(w)$ | $O(n)$ | $O(n)$ | 关键词提取 | 考虑重要性 | 计算复杂 |
| **主题建模** | $P(w \mid d) = \sum_t P(w \mid t) \times P(t \mid d)$ | $O(n \times k)$ | $O(n \times k)$ | 主题发现 | 发现主题 | 计算复杂 |

### 7.2 性能优化建议

1. **索引优化**：
   - 全文搜索：使用GIN索引
   - 词频统计：使用表达式索引

2. **批量处理**：
   - 使用物化视图缓存中间结果
   - 批量计算TF-IDF

3. **并行计算**：
   - 启用并行查询
   - 使用分区表

### 7.3 常见问题与解决方案

**问题1**：TF-IDF计算性能慢

- **解决方案**：使用物化视图、批量处理、并行查询

**问题2**：关键词提取不准确

- **解决方案**：调整TF-IDF阈值、过滤停用词、使用组合方法

**问题3**：主题建模复杂

- **解决方案**：使用简化版主题提取、外部工具（如Python）

**问题4**：大规模数据处理内存不足

- **解决方案**：分批处理、使用流式处理、优化数据结构

---

## 8. 最佳实践

### 8.1 算法选择

1. **简单分析**：使用词频统计
2. **关键词提取**：使用TF-IDF
3. **主题发现**：使用主题建模（需要外部工具）

### 8.2 参数调优

1. **TF-IDF阈值**：根据应用场景调整
2. **关键词数量**：选择Top N关键词
3. **停用词过滤**：过滤常见停用词

### 8.3 性能优化

1. **索引优化**：为常用查询创建索引
2. **批量处理**：使用批量操作提高性能
3. **结果缓存**：使用物化视图缓存结果

### 8.4 SQL实现注意事项

1. **性能考虑**：避免在大数据集上使用复杂计算
2. **内存管理**：控制work_mem配置
3. **结果验证**：验证挖掘结果的准确性
4. **错误处理**：处理NULL值和边界情况

---

## 📚 参考资源

### 学术文献

- 《信息检索导论》（Introduction to Information Retrieval）- TF-IDF理论
- 《数据挖掘：概念与技术》（Data Mining: Concepts and Techniques）- 文本挖掘

### PostgreSQL官方文档

- [全文搜索](https://www.postgresql.org/docs/current/textsearch.html)
- [数组操作](https://www.postgresql.org/docs/current/arrays.html)
- [窗口函数](https://www.postgresql.org/docs/current/tutorial-window.html)

### 在线资源

- PostgreSQL文本挖掘指南
- TF-IDF算法详解
- 主题建模最佳实践

### 相关算法

- [文本搜索算法](./文本搜索算法.md) - 文本搜索
- [文本相似度计算](./文本相似度计算.md) - 相似度计算
- [文本分类算法](./文本分类算法.md) - 文本分类

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
