# PostgreSQL 文本分类算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 文本分类 | 文档分类
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 文本分类算法完整指南](#postgresql-文本分类算法完整指南)
  - [📋 目录](#-目录)
  - [文本分类算法概述](#文本分类算法概述)
    - [理论基础](#理论基础)
      - [文本分类问题定义](#文本分类问题定义)
      - [分类算法分类](#分类算法分类)
      - [分类策略选择](#分类策略选择)
    - [核心分类方法](#核心分类方法)
  - [1. 关键词分类](#1-关键词分类)
    - [1.1 关键词分类原理](#11-关键词分类原理)
      - [关键词匹配定义](#关键词匹配定义)
      - [关键词权重](#关键词权重)
    - [1.2 关键词匹配分类实现](#12-关键词匹配分类实现)
    - [1.3 多关键词分类](#13-多关键词分类)
  - [2. 基于规则的分类](#2-基于规则的分类)
    - [2.1 规则分类原理](#21-规则分类原理)
      - [规则定义](#规则定义)
      - [规则优先级](#规则优先级)
    - [2.2 规则引擎分类实现](#22-规则引擎分类实现)
    - [2.3 复杂规则分类](#23-复杂规则分类)
  - [3. 文本特征提取](#3-文本特征提取)
    - [3.1 特征提取原理](#31-特征提取原理)
      - [特征定义](#特征定义)
      - [特征选择](#特征选择)
    - [3.2 特征向量提取实现](#32-特征向量提取实现)
    - [3.3 TF-IDF特征提取](#33-tf-idf特征提取)
  - [4. 分类优化策略](#4-分类优化策略)
    - [4.1 索引优化](#41-索引优化)
    - [4.2 规则优化](#42-规则优化)
    - [4.3 性能优化](#43-性能优化)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 文档自动分类](#51-文档自动分类)
    - [5.2 邮件分类系统](#52-邮件分类系统)
    - [5.3 新闻分类系统](#53-新闻分类系统)
    - [5.4 情感分析分类](#54-情感分析分类)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 分类方法对比](#61-分类方法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 分类策略选择](#71-分类策略选择)
    - [7.2 特征工程](#72-特征工程)
    - [7.3 规则设计](#73-规则设计)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 文本分类算法概述

**文本分类算法（Text Classification Algorithm）**用于将文本自动分类到预定义的类别，是自然语言处理和信息检索的核心任务之一。PostgreSQL可以通过SQL实现基于规则和特征的分类算法。

### 理论基础

#### 文本分类问题定义

**文本分类问题**：给定文本集合$D = \{d_1, d_2, \ldots, d_n\}$和类别集合$C = \{c_1, c_2, \ldots, c_k\}$，找到一个分类函数$f: D \to C$，使得：
$$f(d_i) = c_j$$

**分类任务类型**：

1. **二分类**：$|C| = 2$
2. **多分类**：$|C| > 2$
3. **多标签分类**：一个文档可以属于多个类别

#### 分类算法分类

文本分类算法分类：

1. **基于规则**：
   - 关键词匹配
   - 正则表达式匹配
   - 规则引擎
   - 时间复杂度：$O(n)$

2. **基于特征**：
   - 特征向量提取
   - TF-IDF特征
   - 统计特征
   - 时间复杂度：$O(n)$

3. **基于机器学习**（需要外部工具）：
   - 朴素贝叶斯
   - 支持向量机
   - 神经网络

#### 分类策略选择

选择分类策略的考虑因素：

1. **数据量**：小数据集用规则，大数据集用特征
2. **类别数量**：少类别用规则，多类别用特征
3. **精度要求**：高精度用机器学习，快速分类用规则
4. **可解释性**：需要可解释性用规则

### 核心分类方法

| 方法 | 数学定义 | 用途 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **关键词分类** | $f(d) = c_i \text{ if } \text{keywords}(d) \cap K_i \neq \emptyset$ | 基于关键词 | $O(n)$ | $O(n)$ | 简单分类 |
| **规则分类** | $f(d) = c_i \text{ if } r_i(d) = \text{true}$ | 基于规则 | $O(n)$ | $O(1)$ | 复杂规则 |
| **特征分类** | $f(d) = \arg\max_{c_i} \text{score}(\text{features}(d), c_i)$ | 基于特征 | $O(n)$ | $O(n)$ | 精确分类 |

---

## 1. 关键词分类

### 1.1 关键词分类原理

**关键词分类（Keyword-based Classification）**是基于关键词匹配的简单分类方法。

#### 关键词匹配定义

**关键词匹配**：给定文档$d$和关键词集合$K = \{k_1, k_2, \ldots, k_n\}$，如果文档包含关键词，则分类到对应类别：
$$f(d) = c_i \text{ if } \exists k_j \in K_i \text{ such that } k_j \in d$$

#### 关键词权重

**关键词权重**：不同关键词可以有不同的权重：
$$f(d) = \arg\max_{c_i} \sum_{k_j \in K_i} w_j \times \text{count}(k_j, d)$$

### 1.2 关键词匹配分类实现

**关键词匹配分类**的实现和使用。

```sql
-- 关键词分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行关键词分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行关键词分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '关键词分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    CASE
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'technology | software | programming') THEN 'Technology'
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'business | finance | market') THEN 'Business'
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'health | medical | doctor') THEN 'Health'
        ELSE 'Other'
    END AS category
FROM articles;
```

---

### 1.3 多关键词分类

**多关键词分类**：使用多个关键词组合进行分类。

```sql
-- 多关键词分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行多关键词分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多关键词分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多关键词分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 多关键词分类：使用关键词权重
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    -- 计算每个类别的关键词匹配分数
    (SELECT COUNT(*) FROM unnest(string_to_array('technology software programming', ' ')) AS kw
     WHERE to_tsvector('english', content) @@ to_tsquery('english', kw)) AS tech_score,
    (SELECT COUNT(*) FROM unnest(string_to_array('business finance market', ' ')) AS kw
     WHERE to_tsvector('english', content) @@ to_tsquery('english', kw)) AS business_score,
    (SELECT COUNT(*) FROM unnest(string_to_array('health medical doctor', ' ')) AS kw
     WHERE to_tsvector('english', content) @@ to_tsquery('english', kw)) AS health_score,
    -- 选择得分最高的类别
    CASE
        WHEN (SELECT COUNT(*) FROM unnest(string_to_array('technology software programming', ' ')) AS kw
              WHERE to_tsvector('english', content) @@ to_tsquery('english', kw)) >= 2 THEN 'Technology'
        WHEN (SELECT COUNT(*) FROM unnest(string_to_array('business finance market', ' ')) AS kw
              WHERE to_tsvector('english', content) @@ to_tsquery('english', kw)) >= 2 THEN 'Business'
        WHEN (SELECT COUNT(*) FROM unnest(string_to_array('health medical doctor', ' ')) AS kw
              WHERE to_tsvector('english', content) @@ to_tsquery('english', kw)) >= 2 THEN 'Health'
        ELSE 'Other'
    END AS category
FROM articles;
```

---

## 2. 基于规则的分类

### 2.1 规则分类原理

**基于规则的分类（Rule-based Classification）**使用预定义的规则进行分类。

#### 规则定义

**分类规则**：规则$r$是一个条件表达式，如果满足条件，则将文档分类到对应类别：
$$f(d) = c_i \text{ if } r_i(d) = \text{true}$$

**规则类型**：

- **关键词规则**：包含特定关键词
- **长度规则**：文本长度满足条件
- **模式规则**：匹配正则表达式
- **组合规则**：多个条件的逻辑组合

#### 规则优先级

**规则优先级**：多个规则可能同时匹配，需要定义优先级：
$$f(d) = c_i \text{ if } r_i(d) = \text{true} \text{ and } \forall j < i, r_j(d) = \text{false}$$

### 2.2 规则引擎分类实现

**规则引擎分类**的实现和使用。

```sql
-- 基于规则的分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行基于规则的分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行基于规则的分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '基于规则的分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH classification_rules AS (
    SELECT
        id,
        title,
        content,
        CASE
            WHEN length(content) > 5000 AND similarity(title, 'report') > 0.3 THEN 'Long Report'
            WHEN length(content) < 500 AND similarity(title, 'note') > 0.3 THEN 'Short Note'
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'urgent | important') THEN 'Urgent'
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'meeting | schedule') THEN 'Meeting'
            ELSE 'General'
        END AS document_category
    FROM documents
)
SELECT
    document_category,
    COUNT(*) AS count,
    AVG(length(content)) AS avg_length
FROM classification_rules
GROUP BY document_category
ORDER BY count DESC;
```

---

### 2.3 复杂规则分类

**复杂规则分类**：使用复杂的规则组合进行分类。

```sql
-- 复杂规则分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行复杂规则分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行复杂规则分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '复杂规则分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 复杂规则分类：组合多个条件
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    length(content) AS content_length,
    array_length(string_to_array(content, ' '), 1) AS word_count,
    CASE
        -- 优先级1：紧急文档
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'urgent | critical | emergency') THEN 'Urgent'
        -- 优先级2：长报告
        WHEN length(content) > 5000 AND similarity(title, 'report') > 0.3 THEN 'Long Report'
        -- 优先级3：短笔记
        WHEN length(content) < 500 AND similarity(title, 'note') > 0.3 THEN 'Short Note'
        -- 优先级4：会议相关
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'meeting | schedule | appointment') THEN 'Meeting'
        -- 优先级5：技术文档
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'technology | software | code') THEN 'Technical'
        -- 默认类别
        ELSE 'General'
    END AS document_category
FROM documents;
```

---

## 3. 基于向量的分类（pgvector）

### 3.1 向量分类概述

**基于向量的分类（Vector-based Classification）**：使用pgvector扩展进行语义级别的文本分类，通过向量相似度实现更准确的分类。

#### 向量分类原理

**向量分类**：将文本转换为向量嵌入（embedding），通过计算向量相似度进行分类。

**向量分类优势**：
- 语义理解能力强
- 支持相似文本自动归类
- 可以结合预训练模型（如OpenAI、Cohere）

#### pgvector扩展安装

```sql
-- 安装pgvector扩展（需要PostgreSQL 11+）
DO $$
BEGIN
    BEGIN
        CREATE EXTENSION IF NOT EXISTS vector;
        RAISE NOTICE 'pgvector扩展已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'pgvector扩展安装失败: %。请确保已安装pgvector扩展。', SQLERRM;
            RAISE;
    END;
END $$;
```

### 3.2 向量分类实现

**创建向量分类表**：

```sql
-- 创建文档向量分类表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_classification') THEN
            RAISE WARNING '表 document_classification 已存在，先删除';
            DROP TABLE document_classification CASCADE;
        END IF;

        -- 创建包含向量嵌入的分类表
        CREATE TABLE document_classification (
            id SERIAL PRIMARY KEY,
            title TEXT NOT NULL,
            content TEXT NOT NULL,
            -- 使用vector类型存储1536维向量（OpenAI text-embedding-3-large）
            embedding vector(1536),
            -- 分类标签
            category TEXT,
            confidence_score NUMERIC,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        -- 创建向量相似度索引（HNSW索引，PostgreSQL 18+）
        CREATE INDEX idx_document_classification_vector
        ON document_classification
        USING hnsw (embedding vector_cosine_ops)
        WITH (m = 16, ef_construction = 64);

        -- 创建分类索引
        CREATE INDEX idx_document_classification_category
        ON document_classification(category);

        RAISE NOTICE '文档向量分类表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建文档向量分类表失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**基于向量相似度的分类**：

```sql
-- 向量分类：基于类别中心向量分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_classification') THEN
            RAISE WARNING '表 document_classification 不存在，无法执行向量分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行向量分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '向量分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算每个类别的中心向量
WITH category_centroids AS (
    SELECT
        category,
        AVG(embedding) AS centroid_embedding
    FROM document_classification
    WHERE category IS NOT NULL AND embedding IS NOT NULL
    GROUP BY category
),
-- 对未分类文档进行分类
unclassified_documents AS (
    SELECT
        id,
        title,
        content,
        embedding
    FROM document_classification
    WHERE category IS NULL AND embedding IS NOT NULL
),
-- 计算与每个类别中心的相似度
similarity_scores AS (
    SELECT
        ud.id,
        ud.title,
        cc.category,
        1 - (ud.embedding <=> cc.centroid_embedding) AS similarity
    FROM unclassified_documents ud
    CROSS JOIN category_centroids cc
),
-- 选择相似度最高的类别
best_matches AS (
    SELECT DISTINCT ON (id)
        id,
        title,
        category,
        similarity
    FROM similarity_scores
    ORDER BY id, similarity DESC
)
-- 更新分类结果
UPDATE document_classification dc
SET
    category = bm.category,
    confidence_score = bm.similarity
FROM best_matches bm
WHERE dc.id = bm.id AND bm.similarity > 0.7;  -- 相似度阈值
```

**混合分类（向量 + 关键词）**：

```sql
-- 混合分类：结合向量相似度和关键词匹配（带错误处理和性能测试）
WITH vector_classification AS (
    SELECT
        id,
        title,
        content,
        embedding,
        -- 向量相似度分类
        (SELECT category
         FROM document_classification
         WHERE category IS NOT NULL
         ORDER BY embedding <=> dc.embedding
         LIMIT 1) AS vector_category,
        (SELECT 1 - (embedding <=> dc.embedding)
         FROM document_classification
         WHERE category IS NOT NULL
         ORDER BY embedding <=> dc.embedding
         LIMIT 1) AS vector_score
    FROM document_classification dc
    WHERE category IS NULL
),
keyword_classification AS (
    SELECT
        id,
        CASE
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'technology | software') THEN 'Technology'
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'business | finance') THEN 'Business'
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'health | medical') THEN 'Health'
            ELSE NULL
        END AS keyword_category,
        CASE
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'technology | software') THEN 0.8
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'business | finance') THEN 0.8
            WHEN to_tsvector('english', content) @@ to_tsquery('english', 'health | medical') THEN 0.8
            ELSE 0.0
        END AS keyword_score
    FROM document_classification
    WHERE category IS NULL
)
SELECT
    vc.id,
    vc.title,
    -- 加权组合：向量相似度权重0.7，关键词匹配权重0.3
    COALESCE(vc.vector_category, kc.keyword_category) AS final_category,
    (COALESCE(vc.vector_score, 0) * 0.7 + COALESCE(kc.keyword_score, 0) * 0.3) AS final_score
FROM vector_classification vc
LEFT JOIN keyword_classification kc ON vc.id = kc.id
WHERE COALESCE(vc.vector_score, 0) * 0.7 + COALESCE(kc.keyword_score, 0) * 0.3 > 0.6;
```

### 3.3 向量分类性能优化

**索引优化**：

```sql
-- pgvector索引优化（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- HNSW索引：适合高维向量，查询速度快
        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'document_classification' AND indexname = 'idx_document_classification_vector') THEN
            RAISE WARNING '向量索引已存在';
        ELSE
            CREATE INDEX idx_document_classification_vector
            ON document_classification
            USING hnsw (embedding vector_cosine_ops)
            WITH (m = 16, ef_construction = 64);
            RAISE NOTICE 'HNSW向量索引创建成功';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '向量索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 4. 文本特征提取

### 4.1 特征提取原理

**文本特征提取（Text Feature Extraction）**是从文本中提取用于分类的特征向量。

#### 特征定义

**特征**：特征$f_i$是文本的一个属性，可以是：

- **统计特征**：文本长度、词数、句子数
- **词汇特征**：词频、关键词出现次数
- **语义特征**：TF-IDF值、词向量

**特征向量**：$\mathbf{f}(d) = (f_1(d), f_2(d), \ldots, f_n(d))$

#### 特征选择

**特征选择**：选择最相关的特征用于分类：

- **信息增益**：选择信息增益高的特征
- **卡方检验**：选择与类别相关性高的特征
- **相关性分析**：选择与类别相关性高的特征

### 4.2 特征向量提取实现

**特征向量提取**的实现和使用。

```sql
-- 文本特征提取（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'texts') THEN
            RAISE WARNING '表 texts 不存在，无法执行文本特征提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行文本特征提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '文本特征提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH text_features AS (
    SELECT
        id,
        text,
        length(text) AS text_length,
        array_length(string_to_array(text, ' '), 1) AS word_count,
        (SELECT COUNT(*) FROM unnest(string_to_array(lower(text), ' ')) AS word WHERE word IN ('important', 'urgent', 'critical')) AS important_words_count,
        similarity(text, 'reference text') AS similarity_score
    FROM texts
)
SELECT
    id,
    text_length,
    word_count,
    important_words_count,
    similarity_score,
    CASE
        WHEN important_words_count >= 2 THEN 'High Priority'
        WHEN similarity_score > 0.7 THEN 'Similar'
        WHEN word_count > 100 THEN 'Long'
        ELSE 'Normal'
    END AS text_class
FROM text_features;
```

---

### 4.3 TF-IDF特征提取

**TF-IDF特征提取**：使用TF-IDF值作为特征。

```sql
-- TF-IDF特征提取（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行TF-IDF特征提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行TF-IDF特征提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'TF-IDF特征提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- TF-IDF特征提取：提取每个文档的TF-IDF特征向量
WITH document_words AS (
    SELECT
        id,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
),
term_frequency AS (
    SELECT
        id,
        word,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY id) AS tf
    FROM document_words
    GROUP BY id, word
),
document_frequency AS (
    SELECT
        word,
        COUNT(DISTINCT id) AS df
    FROM document_words
    GROUP BY word
),
total_documents AS (
    SELECT COUNT(DISTINCT id) AS total
    FROM documents
),
tf_idf_features AS (
    SELECT
        tf.id,
        tf.word,
        tf.tf * LN(td.total::NUMERIC / NULLIF(df.df, 0)) AS tf_idf
    FROM term_frequency tf
    JOIN document_frequency df ON tf.word = df.word
    CROSS JOIN total_documents td
    WHERE tf.tf * LN(td.total::NUMERIC / NULLIF(df.df, 0)) > 0.1
)
SELECT
    id,
    array_agg(word ORDER BY tf_idf DESC) AS top_keywords,
    array_agg(tf_idf ORDER BY tf_idf DESC) AS tf_idf_scores
FROM tf_idf_features
GROUP BY id
ORDER BY id;
```

---

## 5. 分类优化策略

### 5.1 索引优化

**索引优化**：为分类查询创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- GIN索引：全文搜索分类
        CREATE INDEX IF NOT EXISTS idx_documents_content_gin
        ON documents USING GIN (to_tsvector('english', content));

        -- Trigram索引：相似度分类
        CREATE EXTENSION IF NOT EXISTS pg_trgm;
        CREATE INDEX IF NOT EXISTS idx_documents_title_trgm
        ON documents USING GIN (title gin_trgm_ops);

        RAISE NOTICE '分类索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 规则优化

**规则优化**：优化分类规则提高性能。

```sql
-- 规则优化：使用物化视图缓存分类结果
CREATE MATERIALIZED VIEW IF NOT EXISTS document_categories AS
SELECT
    id,
    title,
    content,
    CASE
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'technology | software') THEN 'Technology'
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'business | finance') THEN 'Business'
        ELSE 'Other'
    END AS category
FROM documents;

-- 创建索引加速分类查询
CREATE INDEX IF NOT EXISTS idx_document_categories_category
ON document_categories(category);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY document_categories;
```

### 5.3 性能优化

**性能优化**：使用批量处理和并行查询。

```sql
-- 性能优化：批量分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        RAISE NOTICE '并行查询已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 批量分类：使用并行查询
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    CASE
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'technology | software') THEN 'Technology'
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'business | finance') THEN 'Business'
        ELSE 'Other'
    END AS category
FROM documents;
```

---

## 6. 实际应用案例

### 6.1 文档自动分类

**文档自动分类**根据内容自动分类文档。

```sql
-- 文档自动分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行文档自动分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行文档自动分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '文档自动分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 文档自动分类：多类别分类
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    CASE
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'technology | software | programming') THEN 'Technology'
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'business | finance | market') THEN 'Business'
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'health | medical | doctor') THEN 'Health'
        WHEN to_tsvector('english', content) @@ to_tsquery('english', 'education | learning | school') THEN 'Education'
        ELSE 'General'
    END AS category,
    ts_rank(to_tsvector('english', content),
            to_tsquery('english', 'technology | business | health | education')) AS relevance_score
FROM documents
ORDER BY relevance_score DESC;
```

### 6.2 邮件分类系统

**邮件分类系统**：自动分类邮件到不同文件夹。

```sql
-- 邮件分类系统（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'emails') THEN
            RAISE WARNING '表 emails 不存在，无法执行邮件分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行邮件分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '邮件分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 邮件分类：根据主题和内容分类
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    sender,
    subject,
    body,
    CASE
        WHEN to_tsvector('english', subject || ' ' || body) @@ to_tsquery('english', 'spam | promotion | discount') THEN 'Spam'
        WHEN to_tsvector('english', subject || ' ' || body) @@ to_tsquery('english', 'urgent | important | asap') THEN 'Urgent'
        WHEN to_tsvector('english', subject || ' ' || body) @@ to_tsquery('english', 'meeting | schedule | appointment') THEN 'Meeting'
        WHEN to_tsvector('english', subject || ' ' || body) @@ to_tsquery('english', 'invoice | payment | bill') THEN 'Finance'
        ELSE 'General'
    END AS email_category,
    CASE
        WHEN sender ~* '@spam\.com$' THEN 'Spam'
        WHEN sender IN (SELECT email FROM trusted_senders) THEN 'Trusted'
        ELSE 'Unknown'
    END AS sender_category
FROM emails
ORDER BY received_at DESC;
```

### 6.3 新闻分类系统

**新闻分类系统**：自动分类新闻文章。

```sql
-- 新闻分类系统（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'news_articles') THEN
            RAISE WARNING '表 news_articles 不存在，无法执行新闻分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行新闻分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '新闻分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 新闻分类：根据标题和内容分类
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    author,
    published_at,
    CASE
        WHEN to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', 'politics | election | government') THEN 'Politics'
        WHEN to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', 'sports | game | match') THEN 'Sports'
        WHEN to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', 'technology | tech | innovation') THEN 'Technology'
        WHEN to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', 'business | economy | market') THEN 'Business'
        WHEN to_tsvector('english', title || ' ' || content) @@ to_tsquery('english', 'health | medical | science') THEN 'Health'
        ELSE 'General'
    END AS news_category
FROM news_articles
ORDER BY published_at DESC;
```

### 6.4 情感分析分类

**情感分析分类**：根据文本情感倾向分类。

```sql
-- 情感分析分类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'reviews') THEN
            RAISE WARNING '表 reviews 不存在，无法执行情感分析分类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行情感分析分类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '情感分析分类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 情感分析分类：基于情感词汇
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    review_text,
    rating,
    -- 正面情感词计数
    (SELECT COUNT(*) FROM unnest(string_to_array('good great excellent amazing wonderful', ' ')) AS word
     WHERE to_tsvector('english', review_text) @@ to_tsquery('english', word)) AS positive_count,
    -- 负面情感词计数
    (SELECT COUNT(*) FROM unnest(string_to_array('bad terrible awful horrible poor', ' ')) AS word
     WHERE to_tsvector('english', review_text) @@ to_tsquery('english', word)) AS negative_count,
    -- 情感分类
    CASE
        WHEN (SELECT COUNT(*) FROM unnest(string_to_array('good great excellent amazing wonderful', ' ')) AS word
              WHERE to_tsvector('english', review_text) @@ to_tsquery('english', word)) >
             (SELECT COUNT(*) FROM unnest(string_to_array('bad terrible awful horrible poor', ' ')) AS word
              WHERE to_tsvector('english', review_text) @@ to_tsquery('english', word)) THEN 'Positive'
        WHEN (SELECT COUNT(*) FROM unnest(string_to_array('bad terrible awful horrible poor', ' ')) AS word
              WHERE to_tsvector('english', review_text) @@ to_tsquery('english', word)) >
             (SELECT COUNT(*) FROM unnest(string_to_array('good great excellent amazing wonderful', ' ')) AS word
              WHERE to_tsvector('english', review_text) @@ to_tsquery('english', word)) THEN 'Negative'
        ELSE 'Neutral'
    END AS sentiment_category
FROM reviews
ORDER BY id;
```

---

## 7. 算法性能对比与优化

### 7.1 分类方法对比

| 分类方法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|---------|---------|-----------|-----------|---------|------|------|
| **关键词分类** | $f(d) = c_i \text{ if } \text{keywords}(d) \cap K_i \neq \emptyset$ | $O(n)$ | $O(n)$ | 简单分类 | 快速、简单 | 精度低 |
| **规则分类** | $f(d) = c_i \text{ if } r_i(d) = \text{true}$ | $O(n)$ | $O(1)$ | 复杂规则 | 灵活、可解释 | 规则维护难 |
| **特征分类** | $f(d) = \arg\max_{c_i} \text{score}(\text{features}(d), c_i)$ | $O(n)$ | $O(n)$ | 精确分类 | 精度高 | 特征工程复杂 |

### 7.2 性能优化建议

1. **索引优化**：
   - 全文搜索：使用GIN索引
   - 关键词匹配：使用表达式索引
   - 规则匹配：使用函数索引

2. **规则优化**：
   - 优化规则顺序
   - 使用物化视图缓存
   - 批量分类

3. **特征优化**：
   - 选择有效特征
   - 使用特征索引
   - 批量特征提取

### 7.3 常见问题与解决方案

**问题1**：分类精度低

- **解决方案**：优化关键词集合、改进规则、使用特征分类

**问题2**：分类性能慢

- **解决方案**：创建索引、使用物化视图、批量处理

**问题3**：规则维护困难

- **解决方案**：使用规则表、规则版本管理、规则测试

**问题4**：多类别分类

- **解决方案**：使用多标签分类、概率分类、阈值调整

---

## 8. 最佳实践

### 8.1 分类策略选择

1. **简单分类**：使用关键词分类
2. **复杂分类**：使用规则分类
3. **精确分类**：使用特征分类

### 8.2 特征工程

1. **特征选择**：选择与类别相关的特征
2. **特征提取**：使用TF-IDF、词频等
3. **特征标准化**：标准化特征值

### 8.3 规则设计

1. **规则优先级**：定义清晰的优先级
2. **规则测试**：测试规则准确性
3. **规则维护**：定期更新规则

### 8.4 SQL实现注意事项

1. **性能考虑**：避免在大数据集上使用复杂规则
2. **索引使用**：确保查询使用索引
3. **结果缓存**：使用物化视图缓存分类结果
4. **错误处理**：处理NULL值和边界情况

---

## 📚 参考资源

### 学术文献

- 《自然语言处理综论》（Speech and Language Processing）- 文本分类理论
- 《机器学习》（Machine Learning）- 分类算法

### PostgreSQL官方文档

- [全文搜索](https://www.postgresql.org/docs/current/textsearch.html)
- [模式匹配](https://www.postgresql.org/docs/current/functions-matching.html)
- [数组操作](https://www.postgresql.org/docs/current/arrays.html)

### 在线资源

- PostgreSQL文本分类指南
- 自然语言处理最佳实践
- 分类算法对比分析

### 相关算法

- [文本搜索算法](./文本搜索算法.md) - 文本搜索
- [文本相似度计算](./文本相似度计算.md) - 相似度计算
- [文本挖掘算法](./文本挖掘算法.md) - 文本挖掘

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
