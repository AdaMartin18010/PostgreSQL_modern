# PostgreSQL 文本相似度计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 文本相似度 | 相似度匹配
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 文本相似度计算完整指南](#postgresql-文本相似度计算完整指南)
  - [📋 目录](#-目录)
  - [文本相似度计算概述](#文本相似度计算概述)
    - [核心相似度算法](#核心相似度算法)
  - [1. 编辑距离](#1-编辑距离)
    - [1.1 Levenshtein距离](#11-levenshtein距离)
  - [2. Jaccard相似度](#2-jaccard相似度)
    - [2.1 词集合相似度](#21-词集合相似度)
  - [3. 余弦相似度](#3-余弦相似度)
    - [3.1 向量相似度](#31-向量相似度)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 重复文档检测](#41-重复文档检测)

---

## 文本相似度计算概述

**文本相似度计算**用于衡量两个文本之间的相似程度，常用于重复检测和相似度匹配。

### 核心相似度算法

| 算法 | 用途 | 复杂度 |
|------|------|--------|
| **编辑距离** | Levenshtein距离 | O(n*m) |
| **Jaccard** | 集合相似度 | O(n+m) |
| **余弦相似度** | 向量相似度 | O(n) |

---

## 1. 编辑距离

### 1.1 Levenshtein距离

**编辑距离**计算将一个字符串转换为另一个字符串所需的最少操作次数。

```sql
-- 编辑距离计算（带错误处理和性能测试）
DO $$
DECLARE
    text1 TEXT := 'kitten';
    text2 TEXT := 'sitting';
    edit_dist INTEGER;
    similarity_score NUMERIC;
BEGIN
    BEGIN
        edit_dist := levenshtein(text1, text2);
        similarity_score := 1.0 - edit_dist::NUMERIC / GREATEST(length(text1), length(text2));

        RAISE NOTICE '编辑距离计算:';
        RAISE NOTICE '  文本1: %', text1;
        RAISE NOTICE '  文本2: %', text2;
        RAISE NOTICE '  编辑距离: %', edit_dist;
        RAISE NOTICE '  相似度: %', similarity_score;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '编辑距离计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 批量计算编辑距离
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    t1.text AS text1,
    t2.text AS text2,
    levenshtein(t1.text, t2.text) AS edit_distance,
    1.0 - levenshtein(t1.text, t2.text)::NUMERIC / GREATEST(length(t1.text), length(t2.text)) AS similarity
FROM text_pairs t1
JOIN text_pairs t2 ON t1.id < t2.id
ORDER BY edit_distance;
```

---

## 2. Jaccard相似度

### 2.1 词集合相似度

**Jaccard相似度**计算两个词集合的交集与并集的比值。

```sql
-- Jaccard相似度计算（带错误处理和性能测试）
DO $$
DECLARE
    text1 TEXT := 'hello world';
    text2 TEXT := 'hello postgresql';
    jaccard_sim NUMERIC;
BEGIN
    BEGIN
        WITH words1 AS (
            SELECT unnest(string_to_array(lower(text1), ' ')) AS word
        ),
        words2 AS (
            SELECT unnest(string_to_array(lower(text2), ' ')) AS word
        ),
        intersection AS (
            SELECT COUNT(DISTINCT w1.word) AS count
            FROM words1 w1
            JOIN words2 w2 ON w1.word = w2.word
        ),
        union_set AS (
            SELECT COUNT(DISTINCT word) AS count
            FROM (SELECT word FROM words1 UNION SELECT word FROM words2) AS all_words
        )
        SELECT i.count::NUMERIC / NULLIF(u.count, 0) INTO jaccard_sim
        FROM intersection i, union_set u;

        RAISE NOTICE 'Jaccard相似度计算:';
        RAISE NOTICE '  文本1: %', text1;
        RAISE NOTICE '  文本2: %', text2;
        RAISE NOTICE '  Jaccard相似度: %', jaccard_sim;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Jaccard相似度计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 批量计算Jaccard相似度
WITH text_words AS (
    SELECT
        id,
        text,
        array_agg(DISTINCT word) AS word_array
    FROM (
        SELECT
            id,
            text,
            unnest(string_to_array(lower(text), ' ')) AS word
        FROM text_documents
    ) AS expanded
    GROUP BY id, text
)
SELECT
    t1.id AS id1,
    t2.id AS id2,
    (
        SELECT COUNT(*)
        FROM unnest(t1.word_array) AS w1
        WHERE w1 = ANY(t2.word_array)
    )::NUMERIC / NULLIF(
        (
            SELECT COUNT(DISTINCT word)
            FROM unnest(t1.word_array || t2.word_array) AS word
        ),
        0
    ) AS jaccard_similarity
FROM text_words t1
JOIN text_words t2 ON t1.id < t2.id
ORDER BY jaccard_similarity DESC;
```

---

## 3. 余弦相似度

### 3.1 向量相似度

**余弦相似度**计算两个文本向量的余弦值。

```sql
-- 余弦相似度计算（带错误处理和性能测试）
DO $$
DECLARE
    text1 TEXT := 'hello world';
    text2 TEXT := 'hello postgresql';
    cosine_sim NUMERIC;
BEGIN
    BEGIN
        WITH words1 AS (
            SELECT unnest(string_to_array(lower(text1), ' ')) AS word
        ),
        words2 AS (
            SELECT unnest(string_to_array(lower(text2), ' ')) AS word
        ),
        word_counts AS (
            SELECT
                word,
                COUNT(*) FILTER (WHERE source = 1) AS count1,
                COUNT(*) FILTER (WHERE source = 2) AS count2
            FROM (
                SELECT word, 1 AS source FROM words1
                UNION ALL
                SELECT word, 2 AS source FROM words2
            ) AS all_words
            GROUP BY word
        ),
        dot_product AS (
            SELECT SUM(count1 * count2) AS dot
            FROM word_counts
        ),
        norm1 AS (
            SELECT SQRT(SUM(count1 * count1)) AS norm
            FROM word_counts
        ),
        norm2 AS (
            SELECT SQRT(SUM(count2 * count2)) AS norm
            FROM word_counts
        )
        SELECT dp.dot / NULLIF(n1.norm * n2.norm, 0) INTO cosine_sim
        FROM dot_product dp, norm1 n1, norm2 n2;

        RAISE NOTICE '余弦相似度计算:';
        RAISE NOTICE '  文本1: %', text1;
        RAISE NOTICE '  文本2: %', text2;
        RAISE NOTICE '  余弦相似度: %', cosine_sim;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '余弦相似度计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 4. 实际应用案例

### 4.1 重复文档检测

**重复文档检测**使用相似度检测重复文档。

```sql
-- 重复文档检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行重复文档检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行重复文档检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '重复文档检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH document_similarity AS (
    SELECT
        d1.id AS doc1_id,
        d2.id AS doc2_id,
        similarity(d1.content, d2.content) AS sim_score
    FROM documents d1
    JOIN documents d2 ON d1.id < d2.id
    WHERE similarity(d1.content, d2.content) > 0.8
)
SELECT
    doc1_id,
    doc2_id,
    sim_score,
    CASE
        WHEN sim_score > 0.9 THEN '高度相似'
        WHEN sim_score > 0.8 THEN '相似'
        ELSE '可能相似'
    END AS similarity_level
FROM document_similarity
ORDER BY sim_score DESC;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
