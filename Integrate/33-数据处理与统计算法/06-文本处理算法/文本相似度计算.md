# PostgreSQL 文本相似度计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 文本相似度 | 相似度匹配
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 文本相似度计算完整指南](#postgresql-文本相似度计算完整指南)
  - [📋 目录](#-目录)
  - [文本相似度计算概述](#文本相似度计算概述)
    - [理论基础](#理论基础)
      - [相似度问题定义](#相似度问题定义)
      - [相似度算法分类](#相似度算法分类)
      - [相似度度量选择](#相似度度量选择)
    - [核心相似度算法](#核心相似度算法)
  - [1. 编辑距离](#1-编辑距离)
    - [1.1 编辑距离原理](#11-编辑距离原理)
      - [编辑距离定义](#编辑距离定义)
      - [Levenshtein算法](#levenshtein算法)
    - [1.2 Levenshtein距离实现](#12-levenshtein距离实现)
    - [1.3 其他编辑距离算法](#13-其他编辑距离算法)
  - [2. Jaccard相似度](#2-jaccard相似度)
    - [2.1 Jaccard相似度原理](#21-jaccard相似度原理)
      - [Jaccard相似度定义](#jaccard相似度定义)
      - [集合运算](#集合运算)
    - [2.2 词集合相似度实现](#22-词集合相似度实现)
    - [2.3 N-gram相似度](#23-n-gram相似度)
  - [3. 余弦相似度](#3-余弦相似度)
    - [3.1 余弦相似度原理](#31-余弦相似度原理)
      - [余弦相似度定义](#余弦相似度定义)
      - [向量表示](#向量表示)
    - [3.2 向量相似度实现](#32-向量相似度实现)
    - [3.3 TF-IDF加权余弦相似度](#33-tf-idf加权余弦相似度)
  - [4. 其他相似度算法](#4-其他相似度算法)
    - [4.1 Jaro-Winkler相似度](#41-jaro-winkler相似度)
    - [4.2 Trigram相似度](#42-trigram相似度)
    - [4.3 语义相似度（pgvector向量相似度）](#43-语义相似度pgvector向量相似度)
      - [pgvector扩展安装](#pgvector扩展安装)
      - [向量嵌入表结构](#向量嵌入表结构)
      - [向量相似度计算](#向量相似度计算)
      - [混合搜索（向量 + 全文搜索）](#混合搜索向量--全文搜索)
      - [pgvector性能优化](#pgvector性能优化)
  - [5. PostgreSQL 18 并行相似度计算与AI增强](#5-postgresql-18-并行相似度计算与ai增强)
    - [5.1 并行相似度计算原理](#51-并行相似度计算原理)
    - [5.2 并行编辑距离计算](#52-并行编辑距离计算)
    - [5.3 并行Jaccard相似度计算](#53-并行jaccard相似度计算)
    - [5.4 并行向量相似度计算（pgvector AI增强）](#54-并行向量相似度计算pgvector-ai增强)
    - [5.5 并行批量相似度计算](#55-并行批量相似度计算)
  - [6. 相似度计算优化策略](#6-相似度计算优化策略)
    - [5.1 索引优化](#51-索引优化)
    - [5.2 批量计算优化](#52-批量计算优化)
    - [5.3 近似算法优化](#53-近似算法优化)
  - [7. 实际应用案例](#7-实际应用案例)
    - [6.1 重复文档检测](#61-重复文档检测)
    - [6.2 推荐系统：相似内容推荐](#62-推荐系统相似内容推荐)
    - [6.3 数据清洗：重复记录识别](#63-数据清洗重复记录识别)
    - [6.4 搜索引擎：相似文档检索](#64-搜索引擎相似文档检索)
  - [8. 算法性能对比与优化](#8-算法性能对比与优化)
    - [7.1 相似度算法对比](#71-相似度算法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [9. 最佳实践](#9-最佳实践)
    - [8.1 算法选择](#81-算法选择)
    - [8.2 阈值设置](#82-阈值设置)
    - [8.3 性能优化](#83-性能优化)
    - [8.4 SQL实现注意事项](#84-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 文本相似度计算概述

**文本相似度计算（Text Similarity Calculation）**用于衡量两个文本之间的相似程度，是信息检索、数据清洗、推荐系统等领域的核心操作。

### 理论基础

#### 相似度问题定义

**相似度问题**：给定两个文本$t_1$和$t_2$，计算相似度函数$\text{sim}(t_1, t_2)$，返回相似度分数$s \in [0, 1]$：
$$\text{sim}(t_1, t_2) = s$$

其中：

- $s = 1$：完全相似
- $s = 0$：完全不相似
- $s \in (0, 1)$：部分相似

#### 相似度算法分类

文本相似度算法分类：

1. **基于编辑距离**：
   - Levenshtein距离
   - Damerau-Levenshtein距离
   - 时间复杂度：$O(n \times m)$

2. **基于集合**：
   - Jaccard相似度
   - Dice相似度
   - 时间复杂度：$O(n + m)$

3. **基于向量**：
   - 余弦相似度
   - 欧几里得距离
   - 时间复杂度：$O(n)$

4. **基于N-gram**：
   - Trigram相似度
   - N-gram重叠
   - 时间复杂度：$O(n)$

#### 相似度度量选择

选择相似度算法的考虑因素：

1. **文本长度**：短文本用编辑距离，长文本用向量相似度
2. **应用场景**：重复检测用Jaccard，语义相似用余弦相似度
3. **性能要求**：实时计算用Trigram，批量计算用向量相似度
4. **精度要求**：高精度用编辑距离，快速计算用Trigram

### 核心相似度算法

| 算法 | 数学定义 | 用途 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **编辑距离** | $\text{lev}(s, t) = \min\{d \mid s \to t \text{ in } d \text{ operations}\}$ | Levenshtein距离 | $O(n \times m)$ | $O(n \times m)$ | 短文本、拼写检查 |
| **Jaccard** | $J(A, B) = \frac{|A \cap B|}{|A \cup B|}$ | 集合相似度 | $O(n + m)$ | $O(n + m)$ | 词集合、文档相似度 |
| **余弦相似度** | $\cos(\theta) = \frac{\mathbf{a} \cdot \mathbf{b}}{||\mathbf{a}|| \times ||\mathbf{b}||}$ | 向量相似度 | $O(n)$ | $O(n)$ | 长文本、语义相似度 |

---

## 1. 编辑距离

### 1.1 编辑距离原理

**编辑距离（Edit Distance）**是衡量两个字符串相似度的经典方法，计算将一个字符串转换为另一个字符串所需的最少操作次数。

#### 编辑距离定义

**编辑距离**：给定两个字符串$s$和$t$，编辑距离$\text{lev}(s, t)$是使用以下操作将$s$转换为$t$所需的最少操作数：

- **插入**：在$s$中插入一个字符
- **删除**：从$s$中删除一个字符
- **替换**：将$s$中的一个字符替换为另一个字符

#### Levenshtein算法

**Levenshtein算法**使用动态规划计算编辑距离：

$$
\text{lev}(s, t) = \begin{cases}
|s| & \text{if } |t| = 0 \\
|t| & \text{if } |s| = 0 \\
\text{lev}(\text{tail}(s), \text{tail}(t)) & \text{if } s[0] = t[0] \\
1 + \min\begin{cases}
\text{lev}(\text{tail}(s), t) \\
\text{lev}(s, \text{tail}(t)) \\
\text{lev}(\text{tail}(s), \text{tail}(t))
\end{cases} & \text{otherwise}
\end{cases}
$$

### 1.2 Levenshtein距离实现

**Levenshtein距离**的实现和使用。

```sql
-- 编辑距离计算（带错误处理和性能测试）
DO $$
DECLARE
    text1 TEXT := 'kitten';
    text2 TEXT := 'sitting';
    edit_dist INTEGER;
    similarity_score NUMERIC;
BEGIN
    BEGIN
        edit_dist := levenshtein(text1, text2);
        similarity_score := 1.0 - edit_dist::NUMERIC / GREATEST(length(text1), length(text2));

        RAISE NOTICE '编辑距离计算:';
        RAISE NOTICE '  文本1: %', text1;
        RAISE NOTICE '  文本2: %', text2;
        RAISE NOTICE '  编辑距离: %', edit_dist;
        RAISE NOTICE '  相似度: %', similarity_score;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '编辑距离计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 批量计算编辑距离
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    t1.text AS text1,
    t2.text AS text2,
    levenshtein(t1.text, t2.text) AS edit_distance,
    1.0 - levenshtein(t1.text, t2.text)::NUMERIC / GREATEST(length(t1.text), length(t2.text)) AS similarity
FROM text_pairs t1
JOIN text_pairs t2 ON t1.id < t2.id
ORDER BY edit_distance;
```

---

### 1.3 其他编辑距离算法

**其他编辑距离算法**：Damerau-Levenshtein距离（支持交换操作）。

```sql
-- Damerau-Levenshtein距离（需要fuzzystrmatch扩展）
DO $$
BEGIN
    BEGIN
        -- 启用fuzzystrmatch扩展
        CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;

        RAISE NOTICE 'fuzzystrmatch扩展已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '扩展启用失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Damerau-Levenshtein距离计算
SELECT
    text1,
    text2,
    levenshtein(text1, text2) AS levenshtein_dist,
    damerau_levenshtein(text1, text2) AS damerau_levenshtein_dist
FROM (VALUES
    ('kitten', 'sitting'),
    ('abc', 'bac')  -- 交换操作示例
) AS t(text1, text2);
```

---

## 2. Jaccard相似度

### 2.1 Jaccard相似度原理

**Jaccard相似度（Jaccard Similarity）**是衡量两个集合相似度的经典方法。

#### Jaccard相似度定义

**Jaccard相似度**：给定两个集合$A$和$B$，Jaccard相似度为：
$$J(A, B) = \frac{|A \cap B|}{|A \cup B|} = \frac{|A \cap B|}{|A| + |B| - |A \cap B|}$$

**性质**：

- $J(A, B) \in [0, 1]$
- $J(A, B) = 1$当且仅当$A = B$
- $J(A, B) = 0$当且仅当$A \cap B = \emptyset$

#### 集合运算

**集合运算**：

- **交集**：$A \cap B = \{x \mid x \in A \text{ and } x \in B\}$
- **并集**：$A \cup B = \{x \mid x \in A \text{ or } x \in B\}$

### 2.2 词集合相似度实现

**词集合相似度**的实现和使用。

```sql
-- Jaccard相似度计算（带错误处理和性能测试）
DO $$
DECLARE
    text1 TEXT := 'hello world';
    text2 TEXT := 'hello postgresql';
    jaccard_sim NUMERIC;
BEGIN
    BEGIN
        WITH words1 AS (
            SELECT unnest(string_to_array(lower(text1), ' ')) AS word
        ),
        words2 AS (
            SELECT unnest(string_to_array(lower(text2), ' ')) AS word
        ),
        intersection AS (
            SELECT COUNT(DISTINCT w1.word) AS count
            FROM words1 w1
            JOIN words2 w2 ON w1.word = w2.word
        ),
        union_set AS (
            SELECT COUNT(DISTINCT word) AS count
            FROM (SELECT word FROM words1 UNION SELECT word FROM words2) AS all_words
        )
        SELECT i.count::NUMERIC / NULLIF(u.count, 0) INTO jaccard_sim
        FROM intersection i, union_set u;

        RAISE NOTICE 'Jaccard相似度计算:';
        RAISE NOTICE '  文本1: %', text1;
        RAISE NOTICE '  文本2: %', text2;
        RAISE NOTICE '  Jaccard相似度: %', jaccard_sim;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Jaccard相似度计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 批量计算Jaccard相似度
WITH text_words AS (
    SELECT
        id,
        text,
        array_agg(DISTINCT word) AS word_array
    FROM (
        SELECT
            id,
            text,
            unnest(string_to_array(lower(text), ' ')) AS word
        FROM text_documents
    ) AS expanded
    GROUP BY id, text
)
SELECT
    t1.id AS id1,
    t2.id AS id2,
    (
        SELECT COUNT(*)
        FROM unnest(t1.word_array) AS w1
        WHERE w1 = ANY(t2.word_array)
    )::NUMERIC / NULLIF(
        (
            SELECT COUNT(DISTINCT word)
            FROM unnest(t1.word_array || t2.word_array) AS word
        ),
        0
    ) AS jaccard_similarity
FROM text_words t1
JOIN text_words t2 ON t1.id < t2.id
ORDER BY jaccard_similarity DESC;
```

---

### 2.3 N-gram相似度

**N-gram相似度**：使用N-gram集合计算Jaccard相似度。

```sql
-- N-gram相似度计算（带错误处理）
CREATE OR REPLACE FUNCTION ngram_similarity(text1 TEXT, text2 TEXT, n INTEGER DEFAULT 3)
RETURNS NUMERIC
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
    ngrams1 TEXT[];
    ngrams2 TEXT[];
    intersection_count INTEGER;
    union_count INTEGER;
BEGIN
    BEGIN
        IF n < 1 OR n > 10 THEN
            RAISE EXCEPTION 'n必须在1到10之间';
        END IF;

        -- 生成N-gram
        SELECT array_agg(substring(text1 FROM i FOR n))
        INTO ngrams1
        FROM generate_series(1, length(text1) - n + 1) AS i;

        SELECT array_agg(substring(text2 FROM i FOR n))
        INTO ngrams2
        FROM generate_series(1, length(text2) - n + 1) AS i;

        -- 计算交集和并集
        SELECT COUNT(*) INTO intersection_count
        FROM unnest(ngrams1) AS ng1
        WHERE ng1 = ANY(ngrams2);

        SELECT COUNT(DISTINCT ng) INTO union_count
        FROM unnest(ngrams1 || ngrams2) AS ng;

        RETURN intersection_count::NUMERIC / NULLIF(union_count, 0);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'N-gram相似度计算失败: %', SQLERRM;
            RETURN NULL;
    END;
END $$;

-- 测试N-gram相似度
SELECT ngram_similarity('hello', 'hallo', 2) AS bigram_similarity;
```

---

## 3. 余弦相似度

### 3.1 余弦相似度原理

**余弦相似度（Cosine Similarity）**是衡量两个向量相似度的经典方法，广泛应用于文本相似度计算。

#### 余弦相似度定义

**余弦相似度**：给定两个向量$\mathbf{a}$和$\mathbf{b}$，余弦相似度为：
$$\cos(\theta) = \frac{\mathbf{a} \cdot \mathbf{b}}{||\mathbf{a}|| \times ||\mathbf{b}||} = \frac{\sum_{i=1}^{n} a_i \times b_i}{\sqrt{\sum_{i=1}^{n} a_i^2} \times \sqrt{\sum_{i=1}^{n} b_i^2}}$$

**性质**：

- $\cos(\theta) \in [-1, 1]$（对于非负向量，$\cos(\theta) \in [0, 1]$）
- $\cos(\theta) = 1$：向量方向相同
- $\cos(\theta) = 0$：向量正交
- $\cos(\theta) = -1$：向量方向相反

#### 向量表示

**文本向量化**：

- **词频向量**：每个维度表示一个词的频率
- **TF-IDF向量**：每个维度表示一个词的TF-IDF值
- **词嵌入向量**：使用预训练的词向量（如Word2Vec）

### 3.2 向量相似度实现

**向量相似度**的实现和使用。

```sql
-- 余弦相似度计算（带错误处理和性能测试）
DO $$
DECLARE
    text1 TEXT := 'hello world';
    text2 TEXT := 'hello postgresql';
    cosine_sim NUMERIC;
BEGIN
    BEGIN
        WITH words1 AS (
            SELECT unnest(string_to_array(lower(text1), ' ')) AS word
        ),
        words2 AS (
            SELECT unnest(string_to_array(lower(text2), ' ')) AS word
        ),
        word_counts AS (
            SELECT
                word,
                COUNT(*) FILTER (WHERE source = 1) AS count1,
                COUNT(*) FILTER (WHERE source = 2) AS count2
            FROM (
                SELECT word, 1 AS source FROM words1
                UNION ALL
                SELECT word, 2 AS source FROM words2
            ) AS all_words
            GROUP BY word
        ),
        dot_product AS (
            SELECT SUM(count1 * count2) AS dot
            FROM word_counts
        ),
        norm1 AS (
            SELECT SQRT(SUM(count1 * count1)) AS norm
            FROM word_counts
        ),
        norm2 AS (
            SELECT SQRT(SUM(count2 * count2)) AS norm
            FROM word_counts
        )
        SELECT dp.dot / NULLIF(n1.norm * n2.norm, 0) INTO cosine_sim
        FROM dot_product dp, norm1 n1, norm2 n2;

        RAISE NOTICE '余弦相似度计算:';
        RAISE NOTICE '  文本1: %', text1;
        RAISE NOTICE '  文本2: %', text2;
        RAISE NOTICE '  余弦相似度: %', cosine_sim;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '余弦相似度计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

### 3.3 TF-IDF加权余弦相似度

**TF-IDF加权余弦相似度**：使用TF-IDF权重计算余弦相似度。

```sql
-- TF-IDF加权余弦相似度（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行TF-IDF加权余弦相似度';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行TF-IDF加权余弦相似度';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'TF-IDF加权余弦相似度准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- TF-IDF加权余弦相似度计算
WITH document_vectors AS (
    SELECT
        id,
        word,
        tf_idf_value
    FROM (
        SELECT
            d.id,
            unnest(string_to_array(lower(d.content), ' ')) AS word,
            -- TF-IDF计算（简化版）
            COUNT(*) OVER (PARTITION BY d.id, word)::NUMERIC /
            COUNT(*) OVER (PARTITION BY d.id) *
            LN(COUNT(DISTINCT d.id) OVER ()::NUMERIC /
               COUNT(DISTINCT d.id) OVER (PARTITION BY word)) AS tf_idf_value
        FROM documents d
    ) AS expanded
    GROUP BY id, word, tf_idf_value
)
SELECT
    d1.id AS doc1_id,
    d2.id AS doc2_id,
    -- 余弦相似度
    SUM(d1.tf_idf_value * d2.tf_idf_value) /
    (SQRT(SUM(d1.tf_idf_value * d1.tf_idf_value)) *
     SQRT(SUM(d2.tf_idf_value * d2.tf_idf_value))) AS cosine_similarity
FROM document_vectors d1
JOIN document_vectors d2 ON d1.word = d2.word AND d1.id < d2.id
GROUP BY d1.id, d2.id
HAVING SUM(d1.tf_idf_value * d2.tf_idf_value) /
       (SQRT(SUM(d1.tf_idf_value * d1.tf_idf_value)) *
        SQRT(SUM(d2.tf_idf_value * d2.tf_idf_value))) > 0.5
ORDER BY cosine_similarity DESC;
```

---

## 4. 其他相似度算法

### 4.1 Jaro-Winkler相似度

**Jaro-Winkler相似度**：对Jaro相似度的改进，对前缀匹配给予更高权重。

```sql
-- Jaro-Winkler相似度（需要fuzzystrmatch扩展）
DO $$
BEGIN
    BEGIN
        CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
        RAISE NOTICE 'fuzzystrmatch扩展已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '扩展启用失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Jaro-Winkler相似度计算
SELECT
    text1,
    text2,
    jaro(text1, text2) AS jaro_similarity,
    jaro_winkler(text1, text2) AS jaro_winkler_similarity
FROM (VALUES
    ('MARTHA', 'MARHTA'),
    ('DWAYNE', 'DUANE'),
    ('DIXON', 'DICKSONX')
) AS t(text1, text2);
```

### 4.2 Trigram相似度

**Trigram相似度**：使用pg_trgm扩展的Trigram相似度。

```sql
-- Trigram相似度（需要pg_trgm扩展）
DO $$
BEGIN
    BEGIN
        CREATE EXTENSION IF NOT EXISTS pg_trgm;
        RAISE NOTICE 'pg_trgm扩展已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '扩展启用失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Trigram相似度计算
SELECT
    text1,
    text2,
    similarity(text1, text2) AS trigram_similarity
FROM (VALUES
    ('hello world', 'hello postgresql'),
    ('kitten', 'sitting')
) AS t(text1, text2);
```

### 4.3 语义相似度（pgvector向量相似度）

**语义相似度**：使用pgvector扩展进行向量嵌入相似度计算，支持语义级别的文本相似度匹配。

#### pgvector扩展安装

```sql
-- 安装pgvector扩展（需要PostgreSQL 11+）
DO $$
BEGIN
    BEGIN
        CREATE EXTENSION IF NOT EXISTS vector;
        RAISE NOTICE 'pgvector扩展已启用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'pgvector扩展安装失败: %。请确保已安装pgvector扩展。', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 向量嵌入表结构

```sql
-- 创建文档向量表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_embeddings') THEN
            RAISE WARNING '表 document_embeddings 已存在，先删除';
            DROP TABLE document_embeddings CASCADE;
        END IF;

        -- 创建包含向量嵌入的表
        CREATE TABLE document_embeddings (
            id SERIAL PRIMARY KEY,
            title TEXT NOT NULL,
            content TEXT NOT NULL,
            -- 使用vector类型存储1536维向量（OpenAI text-embedding-3-large）
            embedding vector(1536),
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        -- 创建向量相似度索引（HNSW索引，PostgreSQL 18+）
        CREATE INDEX idx_document_embeddings_vector
        ON document_embeddings
        USING hnsw (embedding vector_cosine_ops)
        WITH (m = 16, ef_construction = 64);

        RAISE NOTICE '文档向量表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建文档向量表失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 向量相似度计算

**余弦相似度**：使用pgvector的`<=>`操作符计算余弦相似度。

```sql
-- 向量相似度搜索：查找最相似的文档
DO $$
DECLARE
    query_embedding vector(1536);
BEGIN
    BEGIN
        -- 假设查询向量（实际应用中需要调用嵌入模型API生成）
        -- 这里使用示例向量，实际应使用OpenAI、Cohere等API生成
        query_embedding := (SELECT embedding FROM document_embeddings LIMIT 1);

        IF query_embedding IS NULL THEN
            RAISE WARNING '查询向量为空，无法执行相似度搜索';
            RETURN;
        END IF;

        RAISE NOTICE '开始执行向量相似度搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '向量相似度搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 向量相似度搜索：使用余弦相似度
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    -- 1 - 余弦距离 = 余弦相似度（值越大越相似）
    1 - (embedding <=> (SELECT embedding FROM document_embeddings WHERE id = 1)) AS cosine_similarity
FROM document_embeddings
WHERE id != 1  -- 排除查询文档本身
ORDER BY embedding <=> (SELECT embedding FROM document_embeddings WHERE id = 1)
LIMIT 10;
```

#### 混合搜索（向量 + 全文搜索）

**混合搜索**：结合向量相似度和全文搜索，提供更准确的语义检索。

```sql
-- 混合搜索：向量相似度 + 全文搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_embeddings') THEN
            RAISE WARNING '表 document_embeddings 不存在，无法执行混合搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行混合搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '混合搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 混合搜索：结合向量相似度和全文搜索排名
WITH query_vector AS (
    SELECT embedding FROM document_embeddings WHERE id = 1
),
vector_similarity AS (
    SELECT
        id,
        title,
        content,
        1 - (embedding <=> (SELECT embedding FROM query_vector)) AS vector_score
    FROM document_embeddings
    WHERE id != 1
),
fulltext_search AS (
    SELECT
        id,
        ts_rank(to_tsvector('english', content),
                to_tsquery('english', 'search query')) AS fulltext_score
    FROM document_embeddings
    WHERE to_tsvector('english', content) @@
          to_tsquery('english', 'search query')
)
SELECT
    vs.id,
    vs.title,
    vs.vector_score,
    COALESCE(fts.fulltext_score, 0) AS fulltext_score,
    -- 加权组合：向量相似度权重0.7，全文搜索权重0.3
    (vs.vector_score * 0.7 + COALESCE(fts.fulltext_score, 0) * 0.3) AS combined_score
FROM vector_similarity vs
LEFT JOIN fulltext_search fts ON vs.id = fts.id
ORDER BY combined_score DESC
LIMIT 20;
```

#### pgvector性能优化

**索引优化**：

```sql
-- pgvector索引优化（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- HNSW索引：适合高维向量，查询速度快
        -- 注意：需要PostgreSQL 18+支持HNSW索引
        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'document_embeddings' AND indexname = 'idx_document_embeddings_vector') THEN
            RAISE WARNING '向量索引已存在';
        ELSE
            CREATE INDEX idx_document_embeddings_vector
            ON document_embeddings
            USING hnsw (embedding vector_cosine_ops)
            WITH (m = 16, ef_construction = 64);
            RAISE NOTICE 'HNSW向量索引创建成功';
        END IF;

        -- 如果PostgreSQL版本不支持HNSW，使用IVFFlat索引
        -- CREATE INDEX idx_document_embeddings_vector_ivfflat
        -- ON document_embeddings
        -- USING ivfflat (embedding vector_cosine_ops)
        -- WITH (lists = 100);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '向量索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**性能测试**：

```sql
-- 向量相似度搜索性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    1 - (embedding <=> (SELECT embedding FROM document_embeddings WHERE id = 1)) AS similarity
FROM document_embeddings
WHERE id != 1
ORDER BY embedding <=> (SELECT embedding FROM document_embeddings WHERE id = 1)
LIMIT 10;
```

---

## 5. PostgreSQL 18 并行相似度计算与AI增强

**PostgreSQL 18** 显著增强了并行相似度计算能力，支持并行执行编辑距离、Jaccard相似度和向量相似度计算，同时结合pgvector实现基于向量嵌入的AI增强相似度匹配，大幅提升大规模文本相似度计算的性能。

### 5.1 并行相似度计算原理

PostgreSQL 18 的并行相似度计算通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描文档数据
2. **并行相似度计算**：每个工作进程独立计算相似度
3. **并行排序**：每个工作进程独立排序相似度结果
4. **结果合并**：主进程合并所有工作进程的相似度结果

### 5.2 并行编辑距离计算

```sql
-- PostgreSQL 18 并行编辑距离计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行并行编辑距离计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行编辑距离计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行编辑距离计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行编辑距离计算：查找与目标文本相似的文档
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH target_text AS (
    SELECT 'hello world' AS text
),
document_distances AS (
    SELECT
        id,
        title,
        content,
        levenshtein(content, (SELECT text FROM target_text)) AS edit_distance,
        length(content) AS content_length
    FROM documents
)
SELECT
    id,
    title,
    edit_distance,
    content_length,
    ROUND((1.0 - edit_distance::numeric / GREATEST(content_length, LENGTH((SELECT text FROM target_text))))::numeric, 4) AS similarity
FROM document_distances
WHERE edit_distance <= 10  -- 阈值过滤
ORDER BY edit_distance
LIMIT 20;
```

### 5.3 并行Jaccard相似度计算

```sql
-- PostgreSQL 18 并行 Jaccard相似度计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行并行Jaccard相似度计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行Jaccard相似度计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行Jaccard相似度计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行Jaccard相似度计算：计算文档之间的Jaccard相似度
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH target_words AS (
    SELECT unnest(string_to_array(lower('hello world postgresql'), ' ')) AS word
),
document_words AS (
    SELECT
        id,
        title,
        unnest(string_to_array(lower(content), ' ')) AS word
    FROM documents
),
document_word_sets AS (
    SELECT
        id,
        title,
        array_agg(DISTINCT word) AS word_set
    FROM document_words
    GROUP BY id, title
),
jaccard_similarities AS (
    SELECT
        dws.id,
        dws.title,
        (
            SELECT COUNT(*)::numeric
            FROM unnest(dws.word_set) AS w
            WHERE w = ANY((SELECT array_agg(word) FROM target_words))
        ) / NULLIF(
            (SELECT COUNT(DISTINCT word) FROM target_words) +
            (SELECT COUNT(DISTINCT word) FROM unnest(dws.word_set) AS w) -
            (SELECT COUNT(*)::numeric FROM unnest(dws.word_set) AS w WHERE w = ANY((SELECT array_agg(word) FROM target_words))),
            0
        ) AS jaccard_similarity
    FROM document_word_sets dws
)
SELECT
    id,
    title,
    ROUND(jaccard_similarity::numeric, 4) AS jaccard_similarity
FROM jaccard_similarities
WHERE jaccard_similarity > 0.1  -- 阈值过滤
ORDER BY jaccard_similarity DESC
LIMIT 20;
```

### 5.4 并行向量相似度计算（pgvector AI增强）

```sql
-- PostgreSQL 18 并行向量相似度计算：基于pgvector的AI增强相似度（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 确保pgvector扩展已安装
        CREATE EXTENSION IF NOT EXISTS vector;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_embeddings') THEN
            RAISE WARNING '表 document_embeddings 不存在，无法执行并行向量相似度计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行向量相似度计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行向量相似度计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行向量相似度计算：查找与目标向量最相似的文档
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH target_embedding AS (
    SELECT embedding
    FROM document_embeddings
    WHERE id = 1  -- 目标文档ID
    LIMIT 1
),
similar_documents AS (
    SELECT
        de.id,
        de.title,
        de.content,
        1 - (de.embedding <=> (SELECT embedding FROM target_embedding)) AS cosine_similarity
    FROM document_embeddings de
    WHERE de.id != (SELECT id FROM document_embeddings WHERE id = 1 LIMIT 1)
)
SELECT
    id,
    title,
    ROUND(cosine_similarity::numeric, 4) AS similarity_score
FROM similar_documents
WHERE cosine_similarity > 0.7  -- 相似度阈值
ORDER BY cosine_similarity DESC
LIMIT 20;
```

### 5.5 并行批量相似度计算

```sql
-- PostgreSQL 18 并行批量相似度计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_embeddings') THEN
            RAISE WARNING '表 document_embeddings 不存在，无法执行并行批量相似度计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行批量相似度计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行批量相似度计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行批量相似度计算：计算所有文档对之间的相似度
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    de1.id AS doc1_id,
    de1.title AS doc1_title,
    de2.id AS doc2_id,
    de2.title AS doc2_title,
    ROUND((1 - (de1.embedding <=> de2.embedding))::numeric, 4) AS cosine_similarity
FROM document_embeddings de1
CROSS JOIN document_embeddings de2
WHERE de1.id < de2.id  -- 避免重复计算
  AND (1 - (de1.embedding <=> de2.embedding)) > 0.7  -- 相似度阈值
ORDER BY cosine_similarity DESC
LIMIT 100;
```

---

## 6. 相似度计算优化策略

### 5.1 索引优化

**索引优化**：为相似度计算创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- Trigram索引：加速Trigram相似度计算
        CREATE EXTENSION IF NOT EXISTS pg_trgm;
        CREATE INDEX IF NOT EXISTS idx_documents_content_trgm
        ON documents USING GIN (content gin_trgm_ops);

        RAISE NOTICE '相似度计算索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 批量计算优化

**批量计算优化**：使用批量操作提高相似度计算性能。

```sql
-- 批量计算优化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'text_documents') THEN
            RAISE WARNING '表 text_documents 不存在，无法执行批量计算优化';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行批量计算优化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '批量计算优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 批量计算相似度：使用并行查询
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    t1.id AS id1,
    t2.id AS id2,
    similarity(t1.text, t2.text) AS similarity_score
FROM text_documents t1
CROSS JOIN text_documents t2
WHERE t1.id < t2.id
  AND similarity(t1.text, t2.text) > 0.5
ORDER BY similarity_score DESC;
```

### 5.3 近似算法优化

**近似算法优化**：使用近似算法提高大规模相似度计算性能。

```sql
-- 近似算法优化：使用MinHash（概念演示）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '近似算法优化（MinHash等）需要自定义实现';
        -- MinHash可以大幅提高大规模集合相似度计算性能
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '近似算法优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 7. 实际应用案例

### 6.1 重复文档检测

**重复文档检测**使用相似度检测重复文档。

```sql
-- 重复文档检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行重复文档检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行重复文档检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '重复文档检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 重复文档检测：使用多种相似度算法
WITH document_similarity AS (
    SELECT
        d1.id AS doc1_id,
        d2.id AS doc2_id,
        similarity(d1.content, d2.content) AS trigram_sim,
        levenshtein(d1.content, d2.content) AS edit_dist,
        1.0 - levenshtein(d1.content, d2.content)::NUMERIC /
             GREATEST(length(d1.content), length(d2.content)) AS normalized_edit_sim
    FROM documents d1
    JOIN documents d2 ON d1.id < d2.id
    WHERE similarity(d1.content, d2.content) > 0.8
       OR levenshtein(d1.content, d2.content) < length(d1.content) * 0.2
)
SELECT
    doc1_id,
    doc2_id,
    trigram_sim,
    normalized_edit_sim,
    GREATEST(trigram_sim, normalized_edit_sim) AS combined_similarity,
    CASE
        WHEN GREATEST(trigram_sim, normalized_edit_sim) > 0.9 THEN '高度相似'
        WHEN GREATEST(trigram_sim, normalized_edit_sim) > 0.8 THEN '相似'
        ELSE '可能相似'
    END AS similarity_level
FROM document_similarity
ORDER BY combined_similarity DESC;
```

### 6.2 推荐系统：相似内容推荐

**相似内容推荐**：基于相似度为用户推荐相似内容。

```sql
-- 相似内容推荐（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行相似内容推荐';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行相似内容推荐';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '相似内容推荐准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 相似内容推荐：为用户推荐相似文章
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH user_article AS (
    SELECT content FROM articles WHERE id = 1
),
article_similarity AS (
    SELECT
        a.id,
        a.title,
        similarity(a.content, ua.content) AS similarity_score
    FROM articles a
    CROSS JOIN user_article ua
    WHERE a.id != 1
      AND similarity(a.content, ua.content) > 0.3
)
SELECT
    id,
    title,
    similarity_score
FROM article_similarity
ORDER BY similarity_score DESC
LIMIT 10;
```

### 6.3 数据清洗：重复记录识别

**重复记录识别**：识别数据表中的重复记录。

```sql
-- 重复记录识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customer_records') THEN
            RAISE WARNING '表 customer_records 不存在，无法执行重复记录识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行重复记录识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '重复记录识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 重复记录识别：基于姓名和地址相似度
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    r1.id AS record1_id,
    r2.id AS record2_id,
    r1.name AS name1,
    r2.name AS name2,
    similarity(r1.name, r2.name) AS name_similarity,
    similarity(r1.address, r2.address) AS address_similarity,
    (similarity(r1.name, r2.name) + similarity(r1.address, r2.address)) / 2 AS combined_similarity
FROM customer_records r1
JOIN customer_records r2 ON r1.id < r2.id
WHERE similarity(r1.name, r2.name) > 0.7
   OR similarity(r1.address, r2.address) > 0.7
ORDER BY combined_similarity DESC;
```

### 6.4 搜索引擎：相似文档检索

**相似文档检索**：基于查询文档检索相似文档。

```sql
-- 相似文档检索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行相似文档检索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行相似文档检索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '相似文档检索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 相似文档检索：基于查询文本检索相似文档
WITH query_text AS (
    SELECT 'search query text' AS query
),
document_similarity AS (
    SELECT
        d.id,
        d.title,
        d.content,
        similarity(d.content, qt.query) AS similarity_score,
        ts_rank(to_tsvector('english', d.content),
                to_tsquery('english', replace(qt.query, ' ', ' | '))) AS fulltext_rank
    FROM documents d
    CROSS JOIN query_text qt
    WHERE similarity(d.content, qt.query) > 0.3
       OR to_tsvector('english', d.content) @@
          to_tsquery('english', replace(qt.query, ' ', ' | '))
)
SELECT
    id,
    title,
    similarity_score,
    fulltext_rank,
    COALESCE(similarity_score, 0) * 0.5 + COALESCE(fulltext_rank, 0) * 0.5 AS combined_score
FROM document_similarity
ORDER BY combined_score DESC
LIMIT 20;
```

---

## 8. 算法性能对比与优化

### 7.1 相似度算法对比

| 算法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **编辑距离** | $\text{lev}(s, t)$ | $O(n \times m)$ | $O(n \times m)$ | 短文本、拼写检查 | 精确 | 性能慢 |
| **Jaccard** | $J(A, B) = \frac{|A \cap B|}{|A \cup B|}$ | $O(n + m)$ | $O(n + m)$ | 词集合、文档相似度 | 快速 | 忽略顺序 |
| **余弦相似度** | $\cos(\theta) = \frac{\mathbf{a} \cdot \mathbf{b}}{||\mathbf{a}|| \times ||\mathbf{b}||}$ | $O(n)$ | $O(n)$ | 长文本、语义相似度 | 快速、语义 | 需要向量化 |
| **Trigram** | 基于3-gram重叠 | $O(n)$ | $O(n)$ | 通用文本相似度 | 快速、有索引 | 精度中等 |
| **Jaro-Winkler** | 改进的Jaro相似度 | $O(n \times m)$ | $O(n \times m)$ | 姓名匹配 | 前缀敏感 | 性能慢 |

### 7.2 性能优化建议

1. **索引优化**：
   - Trigram相似度：使用GIN索引
   - 全文搜索：使用GIN索引
   - 编辑距离：难以索引，考虑近似算法

2. **算法选择**：
   - 短文本：使用编辑距离
   - 长文本：使用余弦相似度或Trigram
   - 实时搜索：使用Trigram索引

3. **批量计算**：
   - 使用并行查询
   - 使用近似算法（如MinHash）
   - 缓存计算结果

### 7.3 常见问题与解决方案

**问题1**：相似度计算性能慢

- **解决方案**：使用Trigram索引、并行查询、近似算法

**问题2**：相似度阈值选择困难

- **解决方案**：根据应用场景调整阈值，使用多算法组合

**问题3**：大规模相似度计算内存不足

- **解决方案**：分批处理、使用流式处理、优化数据结构

**问题4**：相似度结果不准确

- **解决方案**：使用多种算法组合、调整权重、优化文本预处理

---

## 9. 最佳实践

### 8.1 算法选择

1. **短文本**：使用编辑距离或Jaro-Winkler
2. **长文本**：使用余弦相似度或Trigram
3. **实时搜索**：使用Trigram索引
4. **批量计算**：使用并行查询和近似算法

### 8.2 阈值设置

1. **重复检测**：阈值0.8-0.9
2. **相似推荐**：阈值0.5-0.7
3. **模糊搜索**：阈值0.3-0.5

### 8.3 性能优化

1. **索引优化**：为常用相似度计算创建索引
2. **批量处理**：使用批量操作提高性能
3. **并行计算**：启用并行查询处理大规模数据

### 8.4 SQL实现注意事项

1. **扩展安装**：确保安装了pg_trgm、fuzzystrmatch等扩展
2. **性能考虑**：避免在大数据集上使用编辑距离
3. **结果缓存**：缓存相似度计算结果
4. **错误处理**：处理NULL值和空字符串

---

## 📚 参考资源

### 学术文献

- 《信息检索导论》（Introduction to Information Retrieval）- 相似度计算理论
- 《数据挖掘：概念与技术》（Data Mining: Concepts and Techniques）- 相似度算法

### PostgreSQL官方文档

- [pg_trgm扩展](https://www.postgresql.org/docs/current/pgtrgm.html)
- [fuzzystrmatch扩展](https://www.postgresql.org/docs/current/fuzzystrmatch.html)
- [全文搜索](https://www.postgresql.org/docs/current/textsearch.html)

### 在线资源

- PostgreSQL文本相似度计算指南
- 相似度算法对比分析
- 推荐系统最佳实践

### 相关算法

- [文本搜索算法](./文本搜索算法.md) - 文本搜索
- [文本分类算法](./文本分类算法.md) - 文本分类
- [文本挖掘算法](./文本挖掘算法.md) - 文本挖掘

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
