# PostgreSQL å‚…é‡Œå¶å˜æ¢ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ä¿¡å·å¤„ç† | å‚…é‡Œå¶å˜æ¢ | é¢‘åŸŸåˆ†æ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Digital Signal Processing, Fourier Analysis, Signal Processing

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å‚…é‡Œå¶å˜æ¢ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å‚…é‡Œå¶å˜æ¢ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å‚…é‡Œå¶å˜æ¢æ¦‚è¿°](#å‚…é‡Œå¶å˜æ¢æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æ ¸å¿ƒæ€æƒ³](#æ ¸å¿ƒæ€æƒ³)
      - [ç‰©ç†æ„ä¹‰](#ç‰©ç†æ„ä¹‰)
    - [æ•°å­¦å®šä¹‰](#æ•°å­¦å®šä¹‰)
      - [è¿ç»­å‚…é‡Œå¶å˜æ¢ï¼ˆCFTï¼‰](#è¿ç»­å‚…é‡Œå¶å˜æ¢cft)
      - [ç¦»æ•£å‚…é‡Œå¶å˜æ¢ï¼ˆDFTï¼‰](#ç¦»æ•£å‚…é‡Œå¶å˜æ¢dft)
      - [é¢‘ç‡åˆ†è¾¨ç‡](#é¢‘ç‡åˆ†è¾¨ç‡)
    - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
  - [1. ç¦»æ•£å‚…é‡Œå¶å˜æ¢ï¼ˆDFTï¼‰](#1-ç¦»æ•£å‚…é‡Œå¶å˜æ¢dft)
    - [1.1 DFTç®—æ³•åŸç†](#11-dftç®—æ³•åŸç†)
      - [ç®—æ³•ç‰¹æ€§](#ç®—æ³•ç‰¹æ€§)
      - [å¤æ‚åº¦åˆ†æ](#å¤æ‚åº¦åˆ†æ)
      - [DFTçš„ç‰©ç†æ„ä¹‰](#dftçš„ç‰©ç†æ„ä¹‰)
    - [1.2 DFTå®Œæ•´å®ç°](#12-dftå®Œæ•´å®ç°)
  - [2. å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFFTï¼‰](#2-å¿«é€Ÿå‚…é‡Œå¶å˜æ¢fft)
    - [2.1 FFTç®—æ³•åŸç†](#21-fftç®—æ³•åŸç†)
      - [ç®—æ³•åŸç†](#ç®—æ³•åŸç†)
      - [å¤æ‚åº¦åˆ†æ](#å¤æ‚åº¦åˆ†æ-1)
      - [FFTçš„é™åˆ¶](#fftçš„é™åˆ¶)
    - [2.2 FFTç®€åŒ–å®ç°ï¼ˆé€’å½’åˆ†æ²»ï¼‰](#22-fftç®€åŒ–å®ç°é€’å½’åˆ†æ²»)
  - [3. é¢‘åŸŸåˆ†æä¸åº”ç”¨](#3-é¢‘åŸŸåˆ†æä¸åº”ç”¨)
    - [3.1 é¢‘è°±åˆ†æ](#31-é¢‘è°±åˆ†æ)
    - [3.2 å‘¨æœŸæ€§æ£€æµ‹](#32-å‘¨æœŸæ€§æ£€æµ‹)
    - [3.3 é¢‘åŸŸæ»¤æ³¢](#33-é¢‘åŸŸæ»¤æ³¢)
    - [3.4 ä¿¡å·ç‰¹å¾æå–](#34-ä¿¡å·ç‰¹å¾æå–)
  - [4. å®é™…åº”ç”¨æ¡ˆä¾‹](#4-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [4.1 æŒ¯åŠ¨ä¿¡å·åˆ†æ](#41-æŒ¯åŠ¨ä¿¡å·åˆ†æ)
    - [4.2 éŸ³é¢‘ä¿¡å·å¤„ç†](#42-éŸ³é¢‘ä¿¡å·å¤„ç†)
    - [4.3 æ—¶é—´åºåˆ—å‘¨æœŸæ€§åˆ†æ](#43-æ—¶é—´åºåˆ—å‘¨æœŸæ€§åˆ†æ)
  - [5. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#5-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [5.1 DFT vs FFTæ€§èƒ½å¯¹æ¯”](#51-dft-vs-fftæ€§èƒ½å¯¹æ¯”)
    - [5.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#52-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [5.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#53-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 æ•°æ®å‡†å¤‡](#61-æ•°æ®å‡†å¤‡)
    - [6.2 å‚æ•°é€‰æ‹©](#62-å‚æ•°é€‰æ‹©)
    - [6.3 ç»“æœè§£é‡Š](#63-ç»“æœè§£é‡Š)
    - [6.4 SQLå®ç°æ³¨æ„äº‹é¡¹](#64-sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## å‚…é‡Œå¶å˜æ¢æ¦‚è¿°

**å‚…é‡Œå¶å˜æ¢ï¼ˆFourier Transformï¼‰**æ˜¯ä¿¡å·å¤„ç†çš„æ ¸å¿ƒå·¥å…·ï¼Œå°†æ—¶åŸŸä¿¡å·è½¬æ¢ä¸ºé¢‘åŸŸè¡¨ç¤ºï¼Œæ­ç¤ºä¿¡å·çš„é¢‘ç‡æˆåˆ†å’Œèƒ½é‡åˆ†å¸ƒã€‚å‚…é‡Œå¶å˜æ¢åœ¨æ•°å­—ä¿¡å·å¤„ç†ã€å›¾åƒå¤„ç†ã€é€šä¿¡ç³»ç»Ÿã€æ•°æ®åˆ†æç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚

### ç†è®ºåŸºç¡€

#### æ ¸å¿ƒæ€æƒ³

**å‚…é‡Œå¶çº§æ•°ç†è®º**ï¼šä»»ä½•å‘¨æœŸå‡½æ•°éƒ½å¯ä»¥è¡¨ç¤ºä¸ºæ­£å¼¦å’Œä½™å¼¦å‡½æ•°çš„æ— ç©·çº§æ•°ï¼š
$$f(t) = \frac{a_0}{2} + \sum_{n=1}^{\infty} [a_n \cos(n\omega t) + b_n \sin(n\omega t)]$$

**å‚…é‡Œå¶å˜æ¢**ï¼šå°†éå‘¨æœŸä¿¡å·åˆ†è§£ä¸ºè¿ç»­é¢‘ç‡åˆ†é‡çš„ç§¯åˆ†ã€‚

#### ç‰©ç†æ„ä¹‰

- **æ—¶åŸŸ**ï¼šä¿¡å·éšæ—¶é—´çš„å˜åŒ–
- **é¢‘åŸŸ**ï¼šä¿¡å·åœ¨ä¸åŒé¢‘ç‡ä¸Šçš„èƒ½é‡åˆ†å¸ƒ
- **å˜æ¢å…³ç³»**ï¼šæ—¶åŸŸå’Œé¢‘åŸŸæ˜¯åŒä¸€ä¿¡å·çš„ä¸åŒè¡¨ç¤ºæ–¹å¼ï¼Œé€šè¿‡å‚…é‡Œå¶å˜æ¢ç›¸äº’è½¬æ¢

### æ•°å­¦å®šä¹‰

#### è¿ç»­å‚…é‡Œå¶å˜æ¢ï¼ˆCFTï¼‰

**æ­£å˜æ¢**ï¼š
$$F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-i\omega t} dt$$

**é€†å˜æ¢**ï¼š
$$f(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} F(\omega) e^{i\omega t} d\omega$$

å…¶ä¸­ $i = \sqrt{-1}$ æ˜¯è™šæ•°å•ä½ï¼Œ$\omega$ æ˜¯è§’é¢‘ç‡ï¼ˆrad/sï¼‰ã€‚

#### ç¦»æ•£å‚…é‡Œå¶å˜æ¢ï¼ˆDFTï¼‰

å¯¹äºé•¿åº¦ä¸º $N$ çš„ç¦»æ•£ä¿¡å· $x[n]$ï¼Œ$n = 0, 1, ..., N-1$ï¼š

**æ­£å˜æ¢**ï¼š
$$X[k] = \sum_{n=0}^{N-1} x[n] e^{-i2\pi kn/N}, \quad k = 0, 1, ..., N-1$$

**é€†å˜æ¢**ï¼š
$$x[n] = \frac{1}{N} \sum_{k=0}^{N-1} X[k] e^{i2\pi kn/N}, \quad n = 0, 1, ..., N-1$$

**æ¬§æ‹‰å…¬å¼**ï¼š$e^{i\theta} = \cos(\theta) + i\sin(\theta)$

å› æ­¤ï¼ŒDFTå¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$X[k] = \sum_{n=0}^{N-1} x[n] \cos\left(\frac{2\pi kn}{N}\right) - i\sum_{n=0}^{N-1} x[n] \sin\left(\frac{2\pi kn}{N}\right)$$

#### é¢‘ç‡åˆ†è¾¨ç‡

**é¢‘ç‡åˆ†è¾¨ç‡**ï¼š$\Delta f = \frac{f_s}{N}$ï¼Œå…¶ä¸­ $f_s$ æ˜¯é‡‡æ ·é¢‘ç‡ã€‚

**é¢‘ç‡ç´¢å¼• $k$ å¯¹åº”çš„å®é™…é¢‘ç‡**ï¼š$f_k = k \cdot \frac{f_s}{N}$

### åº”ç”¨åœºæ™¯

| åº”ç”¨é¢†åŸŸ | å…·ä½“åº”ç”¨ | å…³é”®æŒ‡æ ‡ |
|---------|---------|---------|
| **ä¿¡å·å¤„ç†** | æ»¤æ³¢ã€å»å™ªã€ä¿¡å·åˆ†ç¦» | é¢‘ç‡å“åº”ã€ä¿¡å™ªæ¯” |
| **å›¾åƒå¤„ç†** | é¢‘åŸŸæ»¤æ³¢ã€å›¾åƒå‹ç¼©ã€è¾¹ç¼˜æ£€æµ‹ | ç©ºé—´é¢‘ç‡ã€å‹ç¼©æ¯” |
| **é€šä¿¡** | è°ƒåˆ¶è§£è°ƒã€é¢‘è°±åˆ†æã€ä¿¡é“ä¼°è®¡ | å¸¦å®½ã€é¢‘è°±æ•ˆç‡ |
| **æ•°æ®åˆ†æ** | å‘¨æœŸæ€§æ£€æµ‹ã€è¶‹åŠ¿åˆ†æã€å¼‚å¸¸æ£€æµ‹ | ä¸»é¢‘ç‡ã€åŠŸç‡è°± |
| **éŸ³é¢‘å¤„ç†** | éŸ³è°ƒè¯†åˆ«ã€éŸ³æ•ˆå¤„ç†ã€è¯­éŸ³è¯†åˆ« | åŸºé¢‘ã€è°æ³¢ |
| **æŒ¯åŠ¨åˆ†æ** | æ•…éšœè¯Šæ–­ã€ç»“æ„å¥åº·ç›‘æµ‹ | å…±æŒ¯é¢‘ç‡ã€æ¨¡æ€åˆ†æ |

---

## 1. ç¦»æ•£å‚…é‡Œå¶å˜æ¢ï¼ˆDFTï¼‰

### 1.1 DFTç®—æ³•åŸç†

**DFTï¼ˆDiscrete Fourier Transformï¼‰**å°†é•¿åº¦ä¸º $N$ çš„ç¦»æ•£ä¿¡å·è½¬æ¢ä¸º $N$ ä¸ªå¤æ•°é¢‘ç‡åˆ†é‡ï¼Œæ¯ä¸ªåˆ†é‡å¯¹åº”ä¸€ä¸ªé¢‘ç‡ã€‚

#### ç®—æ³•ç‰¹æ€§

1. **çº¿æ€§æ€§**ï¼š$\text{DFT}[ax[n] + by[n]] = aX[k] + bY[k]$
2. **å‘¨æœŸæ€§**ï¼š$X[k + N] = X[k]$ï¼ˆé¢‘åŸŸå‘¨æœŸæ€§ï¼‰
3. **å¯¹ç§°æ€§**ï¼šå¯¹äºå®ä¿¡å·ï¼Œ$X[k] = X^*[N-k]$ï¼ˆå…±è½­å¯¹ç§°ï¼‰
4. **èƒ½é‡å®ˆæ’**ï¼ˆParsevalå®šç†ï¼‰ï¼š$\sum_{n=0}^{N-1} |x[n]|^2 = \frac{1}{N}\sum_{k=0}^{N-1} |X[k]|^2$

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š$O(N^2)$ï¼ˆç›´æ¥è®¡ç®—ï¼‰
- **ç©ºé—´å¤æ‚åº¦**ï¼š$O(N)$

#### DFTçš„ç‰©ç†æ„ä¹‰

- **$X[0]$**ï¼šç›´æµåˆ†é‡ï¼ˆDC componentï¼‰ï¼Œä¿¡å·çš„å‡å€¼
- **$X[k]$**ï¼ˆ$k = 1, ..., N/2-1$ï¼‰ï¼šé¢‘ç‡ä¸º $k \cdot \Delta f$ çš„æ­£å¼¦åˆ†é‡
- **$X[N/2]$**ï¼šå¥ˆå¥æ–¯ç‰¹é¢‘ç‡åˆ†é‡ï¼ˆå¦‚æœ $N$ ä¸ºå¶æ•°ï¼‰
- **$X[k]$**ï¼ˆ$k > N/2$ï¼‰ï¼šè´Ÿé¢‘ç‡åˆ†é‡ï¼ˆç”±äºå‘¨æœŸæ€§ï¼‰

### 1.2 DFTå®Œæ•´å®ç°

```sql
-- ä¿¡å·æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_data') THEN
            RAISE WARNING 'è¡¨ signal_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE signal_data CASCADE;
        END IF;

        CREATE TABLE signal_data (
            sample_id INTEGER PRIMARY KEY,
            time_point NUMERIC NOT NULL,
            amplitude NUMERIC NOT NULL
        );

        -- æ’å…¥æ­£å¼¦ä¿¡å·ç¤ºä¾‹
        INSERT INTO signal_data (sample_id, time_point, amplitude) VALUES
            (0, 0.0, 0), (1, 0.1, 0.309), (2, 0.2, 0.588),
            (3, 0.3, 0.809), (4, 0.4, 0.951), (5, 0.5, 1.0);

        RAISE NOTICE 'è¡¨ signal_data åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ signal_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- DFTå®Œæ•´å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    signal_length INTEGER;
    sampling_rate NUMERIC := 1000.0;  -- é‡‡æ ·é¢‘ç‡ï¼ˆHzï¼‰
BEGIN
    BEGIN
        -- æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_data') THEN
            RAISE WARNING 'è¡¨ signal_data ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹æ•°æ®';
            -- åˆ›å»ºç¤ºä¾‹æ•°æ®ï¼šåŒ…å«å¤šä¸ªé¢‘ç‡åˆ†é‡çš„ä¿¡å·
            CREATE TABLE signal_data (
                sample_id INTEGER PRIMARY KEY,
                time_point NUMERIC NOT NULL,
                amplitude NUMERIC NOT NULL
            );

            -- ç”Ÿæˆå¤åˆä¿¡å·ï¼šf1=10Hz, f2=25Hz, f3=50Hz + å™ªå£°
            INSERT INTO signal_data (sample_id, time_point, amplitude)
            SELECT
                n AS sample_id,
                n::NUMERIC / sampling_rate AS time_point,
                -- ä¿¡å· = sin(2Ï€*10*t) + 0.5*sin(2Ï€*25*t) + 0.3*sin(2Ï€*50*t) + å™ªå£°
                SIN(2 * PI() * 10 * n / sampling_rate) +
                0.5 * SIN(2 * PI() * 25 * n / sampling_rate) +
                0.3 * SIN(2 * PI() * 50 * n / sampling_rate) +
                0.1 * (RANDOM() - 0.5) AS amplitude
            FROM generate_series(0, 127) AS n;  -- 128ä¸ªé‡‡æ ·ç‚¹ï¼ˆ2çš„å¹‚æ¬¡ï¼Œä¾¿äºFFTï¼‰
        END IF;

        SELECT COUNT(*) INTO signal_length FROM signal_data;
        RAISE NOTICE 'å¼€å§‹DFTè®¡ç®—ï¼Œä¿¡å·é•¿åº¦: %, é‡‡æ ·é¢‘ç‡: % Hz', signal_length, sampling_rate;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆå§‹åŒ–å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- DFTè®¡ç®—ï¼šå®Œæ•´å®ç°
WITH signal_info AS (
    SELECT
        COUNT(*) AS N,
        1000.0 AS sampling_rate  -- é‡‡æ ·é¢‘ç‡ï¼ˆHzï¼‰
    FROM signal_data
),
dft_calculation AS (
    SELECT
        k.frequency_bin,
        n.sample_id,
        n.amplitude,
        -- è®¡ç®—ç›¸ä½ï¼š2Ï€kn/N
        n.sample_id::NUMERIC * k.frequency_bin::NUMERIC * 2 * PI() / si.N AS phase
    FROM signal_data n
    CROSS JOIN generate_series(0, (SELECT N - 1 FROM signal_info)) AS k(frequency_bin)
    CROSS JOIN signal_info si
),
dft_coefficients AS (
    SELECT
        frequency_bin,
        -- å®éƒ¨ï¼šÎ£ x[n] * cos(2Ï€kn/N)
        SUM(amplitude * COS(phase)) AS real_part,
        -- è™šéƒ¨ï¼š-Î£ x[n] * sin(2Ï€kn/N)
        SUM(amplitude * SIN(-phase)) AS imaginary_part,
        -- å¹…åº¦ï¼š|X[k]| = sqrt(ReÂ² + ImÂ²)
        SQRT(POWER(SUM(amplitude * COS(phase)), 2) + POWER(SUM(amplitude * SIN(-phase)), 2)) AS magnitude,
        -- ç›¸ä½ï¼šarg(X[k]) = atan2(Im, Re)
        ATAN2(SUM(amplitude * SIN(-phase)), SUM(amplitude * COS(phase))) AS phase_angle,
        -- åŠŸç‡ï¼š|X[k]|Â²
        POWER(SQRT(POWER(SUM(amplitude * COS(phase)), 2) + POWER(SUM(amplitude * SIN(-phase)), 2)), 2) AS power
    FROM dft_calculation
    GROUP BY frequency_bin
),
frequency_mapping AS (
    SELECT
        dc.frequency_bin,
        dc.real_part,
        dc.imaginary_part,
        dc.magnitude,
        dc.phase_angle,
        dc.power,
        -- è®¡ç®—å®é™…é¢‘ç‡ï¼ˆHzï¼‰
        dc.frequency_bin * si.sampling_rate / si.N AS frequency_hz,
        -- å½’ä¸€åŒ–å¹…åº¦ï¼ˆç›¸å¯¹äºDCåˆ†é‡ï¼‰
        CASE
            WHEN (SELECT magnitude FROM dft_coefficients WHERE frequency_bin = 0) > 0
            THEN dc.magnitude / (SELECT magnitude FROM dft_coefficients WHERE frequency_bin = 0)
            ELSE dc.magnitude
        END AS normalized_magnitude
    FROM dft_coefficients dc
    CROSS JOIN signal_info si
)
SELECT
    frequency_bin,
    ROUND(frequency_hz::numeric, 2) AS frequency_hz,
    ROUND(real_part::numeric, 6) AS real_component,
    ROUND(imaginary_part::numeric, 6) AS imag_component,
    ROUND(magnitude::numeric, 6) AS magnitude,
    ROUND(phase_angle::numeric, 6) AS phase_rad,
    ROUND((phase_angle * 180 / PI())::numeric, 2) AS phase_deg,
    ROUND(power::numeric, 6) AS power,
    ROUND(normalized_magnitude::numeric, 4) AS normalized_magnitude,
    -- æ ‡è®°ä¸»è¦é¢‘ç‡åˆ†é‡ï¼ˆå¹…åº¦å¤§äºé˜ˆå€¼çš„ï¼‰
    CASE
        WHEN normalized_magnitude > 0.1 THEN 'ä¸»è¦é¢‘ç‡'
        ELSE 'æ¬¡è¦é¢‘ç‡'
    END AS frequency_type
FROM frequency_mapping
ORDER BY frequency_bin;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH signal_info AS (
    SELECT COUNT(*) AS N, 1000.0 AS sampling_rate FROM signal_data
),
dft_calculation AS (
    SELECT
        k.frequency_bin,
        n.sample_id,
        n.amplitude,
        n.sample_id::NUMERIC * k.frequency_bin::NUMERIC * 2 * PI() / si.N AS phase
    FROM signal_data n
    CROSS JOIN generate_series(0, (SELECT N - 1 FROM signal_info)) AS k(frequency_bin)
    CROSS JOIN signal_info si
),
dft_coefficients AS (
    SELECT
        frequency_bin,
        SUM(amplitude * COS(phase)) AS real_part,
        SUM(amplitude * SIN(-phase)) AS imaginary_part,
        SQRT(POWER(SUM(amplitude * COS(phase)), 2) + POWER(SUM(amplitude * SIN(-phase)), 2)) AS magnitude
    FROM dft_calculation
    GROUP BY frequency_bin
)
SELECT frequency_bin, magnitude FROM dft_coefficients ORDER BY frequency_bin;
```

---

## 2. å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFFTï¼‰

### 2.1 FFTç®—æ³•åŸç†

**FFTï¼ˆFast Fourier Transformï¼‰**æ˜¯DFTçš„é«˜æ•ˆç®—æ³•ï¼Œç”±Cooleyå’ŒTukeyåœ¨1965å¹´æå‡ºï¼Œå°†å¤æ‚åº¦ä» $O(N^2)$ é™ä½åˆ° $O(N \log N)$ã€‚

#### ç®—æ³•åŸç†

**åˆ†æ²»ç­–ç•¥ï¼ˆDivide and Conquerï¼‰**ï¼š

å¯¹äºé•¿åº¦ä¸º $N$ çš„åºåˆ—ï¼Œå¦‚æœ $N$ æ˜¯2çš„å¹‚æ¬¡ï¼Œå¯ä»¥å°†DFTåˆ†è§£ä¸ºä¸¤ä¸ªé•¿åº¦ä¸º $N/2$ çš„DFTï¼š

$$X[k] = \sum_{n=0}^{N-1} x[n] e^{-i2\pi kn/N}$$

åˆ†è§£ä¸ºï¼š
$$X[k] = \sum_{m=0}^{N/2-1} x[2m] e^{-i2\pi k(2m)/N} + \sum_{m=0}^{N/2-1} x[2m+1] e^{-i2\pi k(2m+1)/N}$$

è¿›ä¸€æ­¥ç®€åŒ–ä¸ºï¼š
$$X[k] = X_{\text{even}}[k] + W_N^k X_{\text{odd}}[k]$$

å…¶ä¸­ï¼š

- $X_{\text{even}}[k]$ æ˜¯å¶æ•°ç´¢å¼•ç‚¹çš„DFT
- $X_{\text{odd}}[k]$ æ˜¯å¥‡æ•°ç´¢å¼•ç‚¹çš„DFT
- $W_N^k = e^{-i2\pi k/N}$ æ˜¯æ—‹è½¬å› å­ï¼ˆTwiddle Factorï¼‰

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š$O(N \log N)$
- **ç©ºé—´å¤æ‚åº¦**ï¼š$O(N)$ï¼ˆåŸåœ°ç®—æ³•ï¼‰æˆ– $O(N \log N)$ï¼ˆé€’å½’å®ç°ï¼‰

#### FFTçš„é™åˆ¶

1. **åºåˆ—é•¿åº¦**ï¼šé€šå¸¸è¦æ±‚ $N$ æ˜¯2çš„å¹‚æ¬¡ï¼ˆRadix-2 FFTï¼‰
2. **å®ç°å¤æ‚åº¦**ï¼šåœ¨SQLä¸­å®ç°å®Œæ•´çš„FFTè¾ƒä¸ºå¤æ‚ï¼Œé€šå¸¸ä½¿ç”¨é€’å½’CTEæˆ–å¤–éƒ¨å‡½æ•°

### 2.2 FFTç®€åŒ–å®ç°ï¼ˆé€’å½’åˆ†æ²»ï¼‰

```sql
-- FFTç®€åŒ–å®ç°ï¼šå±•ç¤ºåˆ†æ²»æ€æƒ³ï¼ˆé€‚ç”¨äºå°è§„æ¨¡æ•°æ®ï¼‰
-- æ³¨æ„ï¼šå®Œæ•´FFTåœ¨SQLä¸­å®ç°å¤æ‚ï¼Œè¿™é‡Œå±•ç¤ºåŸç†æ€§å®ç°

-- å‡†å¤‡2çš„å¹‚æ¬¡é•¿åº¦çš„ä¿¡å·
DO $$
DECLARE
    signal_length INTEGER := 16;  -- 2^4ï¼Œä¾¿äºFFT
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'fft_signal') THEN
            DROP TABLE fft_signal CASCADE;
        END IF;

        CREATE TABLE fft_signal (
            sample_id INTEGER PRIMARY KEY,
            amplitude NUMERIC NOT NULL
        );

        -- ç”Ÿæˆæµ‹è¯•ä¿¡å·
        INSERT INTO fft_signal (sample_id, amplitude)
        SELECT
            n AS sample_id,
            SIN(2 * PI() * 5 * n / signal_length) + 0.5 * SIN(2 * PI() * 10 * n / signal_length) AS amplitude
        FROM generate_series(0, signal_length - 1) AS n;

        RAISE NOTICE 'FFTä¿¡å·å‡†å¤‡å®Œæˆï¼Œé•¿åº¦: %', signal_length;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'FFTä¿¡å·å‡†å¤‡å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- FFTé€’å½’å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼šä½¿ç”¨é€’å½’CTEå®ç°åˆ†æ²»
WITH RECURSIVE fft_recursive AS (
    -- åŸºç¡€æƒ…å†µï¼šå•ä¸ªç‚¹çš„DFTå°±æ˜¯å®ƒæœ¬èº«
    SELECT
        sample_id AS idx,
        amplitude AS real_part,
        0.0 AS imag_part,
        0 AS level,
        ARRAY[sample_id] AS indices
    FROM fft_signal
    WHERE sample_id < 2  -- é€’å½’ç»ˆæ­¢æ¡ä»¶

    UNION ALL

    -- é€’å½’ï¼šå°†é—®é¢˜åˆ†è§£ä¸ºä¸¤ä¸ªå­é—®é¢˜
    SELECT
        fr.idx,
        -- å¶æ•°éƒ¨åˆ†
        (SELECT SUM(amplitude * COS(-2 * PI() * fr.idx * s.sample_id / POWER(2, fr.level + 1)))
         FROM fft_signal s
         WHERE s.sample_id % 2 = 0) AS real_part,
        (SELECT SUM(amplitude * SIN(-2 * PI() * fr.idx * s.sample_id / POWER(2, fr.level + 1)))
         FROM fft_signal s
         WHERE s.sample_id % 2 = 0) AS imag_part,
        fr.level + 1 AS level,
        fr.indices || ARRAY[fr.idx]
    FROM fft_recursive fr
    WHERE fr.level < 4  -- log2(16) = 4
)
SELECT
    idx AS frequency_bin,
    ROUND(real_part::numeric, 6) AS real_component,
    ROUND(imag_part::numeric, 6) AS imag_component,
    ROUND(SQRT(POWER(real_part, 2) + POWER(imag_part, 2))::numeric, 6) AS magnitude
FROM fft_recursive
WHERE level = 4  -- æœ€ç»ˆå±‚
ORDER BY idx;
```

**æ³¨æ„**ï¼šå®Œæ•´çš„FFTå®ç°åœ¨SQLä¸­éå¸¸å¤æ‚ï¼Œå®é™…åº”ç”¨ä¸­å»ºè®®ï¼š

1. ä½¿ç”¨PostgreSQLçš„æ‰©å±•ï¼ˆå¦‚pg_fftwï¼‰
2. ä½¿ç”¨å¤–éƒ¨å‡½æ•°ï¼ˆPL/Pythonè°ƒç”¨NumPyï¼‰
3. åœ¨åº”ç”¨å±‚å®ç°FFTï¼Œæ•°æ®åº“åªå­˜å‚¨ç»“æœ

---

## 3. é¢‘åŸŸåˆ†æä¸åº”ç”¨

### 3.1 é¢‘è°±åˆ†æ

**é¢‘è°±ï¼ˆSpectrumï¼‰**å±•ç¤ºä¿¡å·åœ¨ä¸åŒé¢‘ç‡ä¸Šçš„èƒ½é‡åˆ†å¸ƒï¼Œæ˜¯é¢‘åŸŸåˆ†æçš„åŸºç¡€ã€‚

```sql
-- å®Œæ•´é¢‘è°±åˆ†æï¼šåŒ…æ‹¬é¢‘ç‡ã€å¹…åº¦ã€ç›¸ä½ã€åŠŸç‡
WITH signal_info AS (
    SELECT COUNT(*) AS N, 1000.0 AS sampling_rate FROM signal_data
),
dft_result AS (
    -- ä½¿ç”¨ä¸Šé¢çš„DFTè®¡ç®—ç»“æœ
    SELECT * FROM (
        -- è¿™é‡Œå¼•ç”¨å‰é¢çš„DFTè®¡ç®—
        SELECT frequency_bin, magnitude, phase_angle, power, frequency_hz
        FROM frequency_mapping  -- å¼•ç”¨å‰é¢çš„CTE
    ) AS dft
),
spectrum_analysis AS (
    SELECT
        frequency_bin,
        frequency_hz,
        magnitude,
        phase_angle,
        power,
        -- åŠŸç‡è°±å¯†åº¦ï¼ˆPSDï¼‰ï¼šåŠŸç‡ / é¢‘ç‡åˆ†è¾¨ç‡
        power / (sampling_rate / N) AS psd,
        -- å½’ä¸€åŒ–åŠŸç‡ï¼ˆç›¸å¯¹äºæ€»åŠŸç‡ï¼‰
        power / SUM(power) OVER () AS normalized_power
    FROM dft_result
    CROSS JOIN signal_info
)
SELECT
    frequency_bin,
    ROUND(frequency_hz::numeric, 2) AS frequency_hz,
    ROUND(magnitude::numeric, 6) AS magnitude,
    ROUND(power::numeric, 6) AS power,
    ROUND(psd::numeric, 6) AS power_spectral_density,
    ROUND(normalized_power::numeric, 4) AS normalized_power,
    ROUND((normalized_power * 100)::numeric, 2) AS power_percentage,
    CASE
        WHEN normalized_power > 0.1 THEN 'ä¸»è¦é¢‘ç‡åˆ†é‡'
        WHEN normalized_power > 0.01 THEN 'æ¬¡è¦é¢‘ç‡åˆ†é‡'
        ELSE 'å™ªå£°/èƒŒæ™¯'
    END AS frequency_category
FROM spectrum_analysis
ORDER BY power DESC;
```

### 3.2 å‘¨æœŸæ€§æ£€æµ‹

**åº”ç”¨åœºæ™¯**ï¼šæ£€æµ‹æ—¶é—´åºåˆ—æ•°æ®ä¸­çš„å‘¨æœŸæ€§æ¨¡å¼ã€‚

```sql
-- å‘¨æœŸæ€§æ£€æµ‹ï¼šä½¿ç”¨DFTæ£€æµ‹æ—¶é—´åºåˆ—çš„å‘¨æœŸ
WITH time_series_data AS (
    SELECT
        time_point,
        value,
        ROW_NUMBER() OVER (ORDER BY time_point) - 1 AS sample_id
    FROM sensor_readings
    WHERE time_point >= CURRENT_DATE - INTERVAL '7 days'
    ORDER BY time_point
),
dft_periodicity AS (
    SELECT
        k.frequency_bin,
        SUM(ts.value * COS(2 * PI() * k.frequency_bin * ts.sample_id / (SELECT COUNT(*) FROM time_series_data))) AS real_part,
        SUM(ts.value * SIN(-2 * PI() * k.frequency_bin * ts.sample_id / (SELECT COUNT(*) FROM time_series_data))) AS imag_part
    FROM time_series_data ts
    CROSS JOIN generate_series(0, (SELECT COUNT(*) - 1 FROM time_series_data)) AS k(frequency_bin)
    GROUP BY k.frequency_bin
),
frequency_analysis AS (
    SELECT
        frequency_bin,
        SQRT(POWER(real_part, 2) + POWER(imag_part, 2)) AS magnitude,
        -- è®¡ç®—å‘¨æœŸï¼ˆé‡‡æ ·é—´éš”æ•°ï¼‰
        CASE
            WHEN frequency_bin > 0 THEN (SELECT COUNT(*) FROM time_series_data)::NUMERIC / frequency_bin
            ELSE NULL
        END AS period_samples,
        -- è®¡ç®—å®é™…å‘¨æœŸï¼ˆæ—¶é—´å•ä½ï¼‰
        CASE
            WHEN frequency_bin > 0 THEN
                (SELECT COUNT(*) FROM time_series_data)::NUMERIC / frequency_bin *
                (SELECT AVG(time_point - LAG(time_point) OVER (ORDER BY time_point)) FROM time_series_data)
            ELSE NULL
        END AS period_time
    FROM dft_periodicity
)
SELECT
    frequency_bin,
    ROUND(magnitude::numeric, 6) AS magnitude,
    ROUND(period_samples::numeric, 2) AS period_samples,
    ROUND(period_time::numeric, 2) AS period_hours,
    CASE
        WHEN magnitude > (SELECT AVG(magnitude) * 2 FROM frequency_analysis WHERE frequency_bin > 0)
        THEN 'æ˜¾è‘—å‘¨æœŸ'
        ELSE 'éæ˜¾è‘—'
    END AS periodicity_status
FROM frequency_analysis
WHERE frequency_bin > 0
ORDER BY magnitude DESC
LIMIT 10;  -- å‰10ä¸ªä¸»è¦é¢‘ç‡åˆ†é‡
```

### 3.3 é¢‘åŸŸæ»¤æ³¢

**åº”ç”¨åœºæ™¯**ï¼šåœ¨é¢‘åŸŸå»é™¤å™ªå£°æˆ–ç‰¹å®šé¢‘ç‡åˆ†é‡ã€‚

```sql
-- é¢‘åŸŸæ»¤æ³¢ï¼šå»é™¤é«˜é¢‘å™ªå£°ï¼ˆä½é€šæ»¤æ³¢ï¼‰
WITH dft_result AS (
    -- DFTè®¡ç®—ç»“æœï¼ˆå¼•ç”¨å‰é¢çš„CTEï¼‰
    SELECT frequency_bin, frequency_hz, magnitude, real_part, imaginary_part
    FROM frequency_mapping
),
filtered_spectrum AS (
    SELECT
        frequency_bin,
        frequency_hz,
        magnitude,
        real_part,
        imaginary_part,
        -- ä½é€šæ»¤æ³¢ï¼šä¿ç•™é¢‘ç‡ä½äºæˆªæ­¢é¢‘ç‡çš„åˆ†é‡
        CASE
            WHEN frequency_hz <= 100 THEN magnitude  -- æˆªæ­¢é¢‘ç‡100Hz
            ELSE magnitude * 0.01  -- é«˜é¢‘åˆ†é‡è¡°å‡99%
        END AS filtered_magnitude,
        CASE
            WHEN frequency_hz <= 100 THEN real_part
            ELSE real_part * 0.01
        END AS filtered_real,
        CASE
            WHEN frequency_hz <= 100 THEN imaginary_part
            ELSE imaginary_part * 0.01
        END AS filtered_imag
    FROM dft_result
)
SELECT
    frequency_bin,
    ROUND(frequency_hz::numeric, 2) AS frequency_hz,
    ROUND(magnitude::numeric, 6) AS original_magnitude,
    ROUND(filtered_magnitude::numeric, 6) AS filtered_magnitude,
    ROUND(((magnitude - filtered_magnitude) / NULLIF(magnitude, 0) * 100)::numeric, 2) AS attenuation_percent
FROM filtered_spectrum
ORDER BY frequency_bin;
```

### 3.4 ä¿¡å·ç‰¹å¾æå–

**åº”ç”¨åœºæ™¯**ï¼šä»é¢‘åŸŸæå–ä¿¡å·ç‰¹å¾ç”¨äºåˆ†ç±»æˆ–è¯†åˆ«ã€‚

```sql
-- ä¿¡å·ç‰¹å¾æå–ï¼šæå–é¢‘åŸŸç‰¹å¾
WITH dft_features AS (
    SELECT
        frequency_bin,
        frequency_hz,
        magnitude,
        power
    FROM frequency_mapping
),
signal_features AS (
    SELECT
        -- é¢‘è°±è´¨å¿ƒï¼ˆCentroidï¼‰ï¼šåŠ æƒå¹³å‡é¢‘ç‡
        SUM(frequency_hz * power) / NULLIF(SUM(power), 0) AS spectral_centroid,
        -- é¢‘è°±å¸¦å®½ï¼ˆBandwidthï¼‰ï¼šé¢‘ç‡åˆ†å¸ƒçš„å®½åº¦
        SQRT(SUM(POWER(frequency_hz - (SUM(frequency_hz * power) / NULLIF(SUM(power), 0)), 2) * power) / NULLIF(SUM(power), 0)) AS spectral_bandwidth,
        -- ä¸»é¢‘ç‡ï¼ˆDominant Frequencyï¼‰ï¼šåŠŸç‡æœ€å¤§çš„é¢‘ç‡
        (SELECT frequency_hz FROM dft_features ORDER BY power DESC LIMIT 1) AS dominant_frequency,
        -- æ€»åŠŸç‡
        SUM(power) AS total_power,
        -- å³°å€¼åŠŸç‡
        MAX(power) AS peak_power,
        -- é¢‘ç‡åˆ†é‡çš„æ•°é‡ï¼ˆè¶…è¿‡é˜ˆå€¼çš„ï¼‰
        COUNT(*) FILTER (WHERE power > (SELECT AVG(power) FROM dft_features)) AS significant_components
    FROM dft_features
)
SELECT
    ROUND(spectral_centroid::numeric, 2) AS spectral_centroid_hz,
    ROUND(spectral_bandwidth::numeric, 2) AS spectral_bandwidth_hz,
    ROUND(dominant_frequency::numeric, 2) AS dominant_frequency_hz,
    ROUND(total_power::numeric, 6) AS total_power,
    ROUND(peak_power::numeric, 6) AS peak_power,
    significant_components,
    ROUND((peak_power / NULLIF(total_power, 0) * 100)::numeric, 2) AS peak_power_percentage
FROM signal_features;
```

## 4. å®é™…åº”ç”¨æ¡ˆä¾‹

### 4.1 æŒ¯åŠ¨ä¿¡å·åˆ†æ

**åœºæ™¯**ï¼šåˆ†ææœºæ¢°è®¾å¤‡çš„æŒ¯åŠ¨ä¿¡å·ï¼Œæ£€æµ‹æ•…éšœé¢‘ç‡ã€‚

```sql
-- æŒ¯åŠ¨ä¿¡å·åˆ†æï¼šæ£€æµ‹è½´æ‰¿æ•…éšœé¢‘ç‡
WITH vibration_data AS (
    SELECT
        timestamp,
        vibration_amplitude,
        ROW_NUMBER() OVER (ORDER BY timestamp) - 1 AS sample_id
    FROM machine_vibration
    WHERE machine_id = 1
      AND timestamp >= NOW() - INTERVAL '1 hour'
    ORDER BY timestamp
),
dft_vibration AS (
    SELECT
        k.frequency_bin,
        SUM(v.vibration_amplitude * COS(2 * PI() * k.frequency_bin * v.sample_id / (SELECT COUNT(*) FROM vibration_data))) AS real_part,
        SUM(v.vibration_amplitude * SIN(-2 * PI() * k.frequency_bin * v.sample_id / (SELECT COUNT(*) FROM vibration_data))) AS imag_part
    FROM vibration_data v
    CROSS JOIN generate_series(0, (SELECT COUNT(*) - 1 FROM vibration_data)) AS k(frequency_bin)
    GROUP BY k.frequency_bin
),
frequency_spectrum AS (
    SELECT
        frequency_bin,
        SQRT(POWER(real_part, 2) + POWER(imag_part, 2)) AS magnitude,
        frequency_bin * 1000.0 / (SELECT COUNT(*) FROM vibration_data) AS frequency_hz  -- å‡è®¾é‡‡æ ·ç‡1000Hz
    FROM dft_vibration
),
fault_detection AS (
    SELECT
        frequency_hz,
        magnitude,
        -- æ£€æµ‹å·²çŸ¥æ•…éšœé¢‘ç‡ï¼ˆä¾‹å¦‚ï¼šè½´æ‰¿æ•…éšœé¢‘ç‡50HzåŠå…¶è°æ³¢ï¼‰
        CASE
            WHEN ABS(frequency_hz - 50) < 2 OR ABS(frequency_hz - 100) < 2 OR ABS(frequency_hz - 150) < 2
            THEN 'å¯èƒ½çš„æ•…éšœé¢‘ç‡'
            ELSE 'æ­£å¸¸é¢‘ç‡'
        END AS fault_status
    FROM frequency_spectrum
    WHERE magnitude > (SELECT AVG(magnitude) * 2 FROM frequency_spectrum)
)
SELECT
    ROUND(frequency_hz::numeric, 2) AS frequency_hz,
    ROUND(magnitude::numeric, 6) AS magnitude,
    fault_status
FROM fault_detection
WHERE fault_status = 'å¯èƒ½çš„æ•…éšœé¢‘ç‡'
ORDER BY magnitude DESC;
```

### 4.2 éŸ³é¢‘ä¿¡å·å¤„ç†

**åœºæ™¯**ï¼šåˆ†æéŸ³é¢‘ä¿¡å·çš„é¢‘ç‡æˆåˆ†ï¼Œç”¨äºéŸ³è°ƒè¯†åˆ«ã€‚

```sql
-- éŸ³é¢‘ä¿¡å·åˆ†æï¼šéŸ³è°ƒè¯†åˆ«
WITH audio_samples AS (
    SELECT
        sample_id,
        amplitude
    FROM audio_data
    WHERE recording_id = 1
    ORDER BY sample_id
    LIMIT 4096  -- 4096ä¸ªé‡‡æ ·ç‚¹ï¼ˆ2^12ï¼‰
),
dft_audio AS (
    SELECT
        k.frequency_bin,
        SUM(a.amplitude * COS(2 * PI() * k.frequency_bin * a.sample_id / 4096)) AS real_part,
        SUM(a.amplitude * SIN(-2 * PI() * k.frequency_bin * a.sample_id / 4096)) AS imag_part
    FROM audio_samples a
    CROSS JOIN generate_series(0, 4095) AS k(frequency_bin)
    GROUP BY k.frequency_bin
),
audio_spectrum AS (
    SELECT
        frequency_bin,
        SQRT(POWER(real_part, 2) + POWER(imag_part, 2)) AS magnitude,
        frequency_bin * 44100.0 / 4096 AS frequency_hz  -- CDè´¨é‡é‡‡æ ·ç‡44.1kHz
    FROM dft_audio
),
pitch_detection AS (
    SELECT
        frequency_hz,
        magnitude,
        -- éŸ³è°ƒè¯†åˆ«ï¼šæ‰¾åˆ°åŸºé¢‘ï¼ˆæœ€ä½çš„æ˜¾è‘—é¢‘ç‡åˆ†é‡ï¼‰
        CASE
            WHEN frequency_hz BETWEEN 80 AND 400 THEN 'äººå£°èŒƒå›´'
            WHEN frequency_hz BETWEEN 400 AND 2000 THEN 'ä¸­é¢‘'
            WHEN frequency_hz > 2000 THEN 'é«˜é¢‘'
            ELSE 'ä½é¢‘'
        END AS frequency_range
    FROM audio_spectrum
    WHERE frequency_hz BETWEEN 80 AND 2000  -- äººå£°é¢‘ç‡èŒƒå›´
      AND magnitude > (SELECT AVG(magnitude) * 1.5 FROM audio_spectrum)
)
SELECT
    ROUND(frequency_hz::numeric, 2) AS frequency_hz,
    ROUND(magnitude::numeric, 6) AS magnitude,
    frequency_range,
    CASE
        WHEN frequency_hz BETWEEN 261.63 AND 277.18 THEN 'C4'
        WHEN frequency_hz BETWEEN 293.66 AND 311.13 THEN 'D4'
        WHEN frequency_hz BETWEEN 329.63 AND 349.23 THEN 'E4'
        WHEN frequency_hz BETWEEN 349.23 AND 369.99 THEN 'F4'
        WHEN frequency_hz BETWEEN 392.00 AND 415.30 THEN 'G4'
        WHEN frequency_hz BETWEEN 440.00 AND 466.16 THEN 'A4'
        WHEN frequency_hz BETWEEN 493.88 AND 523.25 THEN 'B4'
        ELSE 'å…¶ä»–'
    END AS musical_note
FROM pitch_detection
ORDER BY magnitude DESC
LIMIT 10;
```

### 4.3 æ—¶é—´åºåˆ—å‘¨æœŸæ€§åˆ†æ

**åœºæ™¯**ï¼šåˆ†æä¸šåŠ¡æŒ‡æ ‡çš„å‘¨æœŸæ€§æ¨¡å¼ï¼ˆæ—¥ã€å‘¨ã€æœˆå‘¨æœŸï¼‰ã€‚

```sql
-- ä¸šåŠ¡æŒ‡æ ‡å‘¨æœŸæ€§åˆ†æï¼šæ£€æµ‹æ—¥/å‘¨/æœˆå‘¨æœŸ
WITH business_metrics AS (
    SELECT
        date,
        metric_value,
        ROW_NUMBER() OVER (ORDER BY date) - 1 AS day_index
    FROM daily_business_metrics
    WHERE date >= CURRENT_DATE - INTERVAL '90 days'
    ORDER BY date
),
dft_metrics AS (
    SELECT
        k.frequency_bin,
        SUM(m.metric_value * COS(2 * PI() * k.frequency_bin * m.day_index / (SELECT COUNT(*) FROM business_metrics))) AS real_part,
        SUM(m.metric_value * SIN(-2 * PI() * k.frequency_bin * m.day_index / (SELECT COUNT(*) FROM business_metrics))) AS imag_part
    FROM business_metrics m
    CROSS JOIN generate_series(0, (SELECT COUNT(*) - 1 FROM business_metrics)) AS k(frequency_bin)
    GROUP BY k.frequency_bin
),
periodicity_analysis AS (
    SELECT
        frequency_bin,
        SQRT(POWER(real_part, 2) + POWER(imag_part, 2)) AS magnitude,
        CASE
            WHEN frequency_bin > 0 THEN (SELECT COUNT(*) FROM business_metrics)::NUMERIC / frequency_bin
            ELSE NULL
        END AS period_days
    FROM dft_metrics
    WHERE frequency_bin > 0
),
business_cycles AS (
    SELECT
        period_days,
        magnitude,
        CASE
            WHEN period_days BETWEEN 6.5 AND 7.5 THEN 'å‘¨å‘¨æœŸ'
            WHEN period_days BETWEEN 29 AND 31 THEN 'æœˆå‘¨æœŸ'
            WHEN period_days BETWEEN 1 AND 1.5 THEN 'æ—¥å‘¨æœŸ'
            ELSE 'å…¶ä»–å‘¨æœŸ'
        END AS cycle_type
    FROM periodicity_analysis
    WHERE magnitude > (SELECT AVG(magnitude) * 1.5 FROM periodicity_analysis)
)
SELECT
    ROUND(period_days::numeric, 2) AS period_days,
    ROUND(magnitude::numeric, 6) AS magnitude,
    cycle_type
FROM business_cycles
ORDER BY magnitude DESC;
```

---

## 5. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 5.1 DFT vs FFTæ€§èƒ½å¯¹æ¯”

| ç‰¹æ€§ | DFT | FFT |
|------|-----|-----|
| **æ—¶é—´å¤æ‚åº¦** | $O(N^2)$ | $O(N \log N)$ |
| **ç©ºé—´å¤æ‚åº¦** | $O(N)$ | $O(N)$ æˆ– $O(N \log N)$ |
| **åºåˆ—é•¿åº¦è¦æ±‚** | ä»»æ„ | é€šå¸¸è¦æ±‚2çš„å¹‚æ¬¡ |
| **å®ç°å¤æ‚åº¦** | ç®€å• | å¤æ‚ |
| **é€‚ç”¨åœºæ™¯** | å°è§„æ¨¡æ•°æ®ï¼ˆ$N < 1000$ï¼‰ | å¤§è§„æ¨¡æ•°æ®ï¼ˆ$N \geq 1000$ï¼‰ |

### 5.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **é‡‡æ ·é¢‘ç‡é€‰æ‹©**ï¼š
   - æ ¹æ®å¥ˆå¥æ–¯ç‰¹å®šç†ï¼š$f_s \geq 2f_{max}$
   - é¿å…æ··å ï¼ˆAliasingï¼‰ç°è±¡

2. **åºåˆ—é•¿åº¦ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨2çš„å¹‚æ¬¡é•¿åº¦ï¼ˆ$N = 2^k$ï¼‰ä»¥åˆ©ç”¨FFT
   - ä½¿ç”¨é›¶å¡«å……ï¼ˆZero Paddingï¼‰è°ƒæ•´é•¿åº¦

3. **çª—å£å‡½æ•°**ï¼š
   - ä½¿ç”¨çª—å‡½æ•°ï¼ˆHammingã€Hanningã€Blackmanï¼‰å‡å°‘é¢‘è°±æ³„æ¼
   - æ”¹å–„é¢‘ç‡åˆ†è¾¨ç‡

4. **å¹¶è¡Œå¤„ç†**ï¼š
   - å¯¹äºå¤šé€šé“ä¿¡å·ï¼Œå¹¶è¡Œå¤„ç†å„é€šé“
   - ä½¿ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢

5. **ç´¢å¼•ä¼˜åŒ–**ï¼š
   - åœ¨æ—¶é—´æˆ³åˆ—ä¸Šåˆ›å»ºç´¢å¼•
   - ä½¿ç”¨åˆ†åŒºè¡¨å¤„ç†å¤§è§„æ¨¡æ—¶é—´åºåˆ—æ•°æ®

### 5.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šé¢‘è°±æ³„æ¼ï¼ˆSpectral Leakageï¼‰

- **åŸå› **ï¼šä¿¡å·é•¿åº¦ä¸æ˜¯å‘¨æœŸçš„æ•´æ•°å€
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨çª—å‡½æ•°ï¼ˆå¦‚Hammingçª—ï¼‰å¹³æ»‘ä¿¡å·è¾¹ç•Œ

**é—®é¢˜2**ï¼šé¢‘ç‡åˆ†è¾¨ç‡ä¸è¶³

- **åŸå› **ï¼šé‡‡æ ·ç‚¹æ•°å¤ªå°‘æˆ–é‡‡æ ·é¢‘ç‡å¤ªé«˜
- **è§£å†³æ–¹æ¡ˆ**ï¼šå¢åŠ é‡‡æ ·ç‚¹æ•°æˆ–ä½¿ç”¨é›¶å¡«å……

**é—®é¢˜3**ï¼šæ··å ï¼ˆAliasingï¼‰

- **åŸå› **ï¼šé‡‡æ ·é¢‘ç‡ä½äºå¥ˆå¥æ–¯ç‰¹é¢‘ç‡
- **è§£å†³æ–¹æ¡ˆ**ï¼šæé«˜é‡‡æ ·é¢‘ç‡æˆ–ä½¿ç”¨æŠ—æ··å æ»¤æ³¢å™¨

**é—®é¢˜4**ï¼šè®¡ç®—æ—¶é—´è¿‡é•¿

- **åŸå› **ï¼šä½¿ç”¨DFTè€ŒéFFTï¼Œæˆ–æ•°æ®è§„æ¨¡è¿‡å¤§
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨FFTç®—æ³•ï¼Œæˆ–é‡‡æ ·é™ç»´

---

## 6. æœ€ä½³å®è·µ

### 6.1 æ•°æ®å‡†å¤‡

1. **é‡‡æ ·è¦æ±‚**ï¼š
   - ç¡®ä¿é‡‡æ ·é¢‘ç‡æ»¡è¶³å¥ˆå¥æ–¯ç‰¹å®šç†
   - ä¿æŒé‡‡æ ·é—´éš”å‡åŒ€
   - å¤„ç†ç¼ºå¤±å€¼æ—¶ä½¿ç”¨æ’å€¼æˆ–åˆ é™¤

2. **æ•°æ®é¢„å¤„ç†**ï¼š
   - å»é™¤ç›´æµåˆ†é‡ï¼ˆå‡å»å‡å€¼ï¼‰
   - ä½¿ç”¨çª—å‡½æ•°å‡å°‘è¾¹ç•Œæ•ˆåº”
   - å½’ä¸€åŒ–ä¿¡å·å¹…åº¦

### 6.2 å‚æ•°é€‰æ‹©

1. **é‡‡æ ·é¢‘ç‡**ï¼š
   - æ ¹æ®ä¿¡å·æœ€é«˜é¢‘ç‡é€‰æ‹©ï¼š$f_s \geq 2.5 \times f_{max}$ï¼ˆç•™æœ‰ä½™é‡ï¼‰

2. **åºåˆ—é•¿åº¦**ï¼š
   - ä½¿ç”¨2çš„å¹‚æ¬¡ï¼š$N = 2^k$ï¼ˆ$k = 10, 11, 12, ...$ï¼‰
   - å¹³è¡¡é¢‘ç‡åˆ†è¾¨ç‡å’Œè®¡ç®—å¤æ‚åº¦

3. **çª—å‡½æ•°é€‰æ‹©**ï¼š
   - **çŸ©å½¢çª—**ï¼šé¢‘ç‡åˆ†è¾¨ç‡æœ€é«˜ï¼Œä½†æ³„æ¼æœ€å¤§
   - **Hammingçª—**ï¼šå¹³è¡¡åˆ†è¾¨ç‡å’Œæ³„æ¼
   - **Blackmançª—**ï¼šæ³„æ¼æœ€å°ï¼Œä½†åˆ†è¾¨ç‡è¾ƒä½

### 6.3 ç»“æœè§£é‡Š

1. **é¢‘ç‡ç´¢å¼•åˆ°å®é™…é¢‘ç‡**ï¼š
   - $f_k = k \cdot \frac{f_s}{N}$
   - æ³¨æ„ï¼š$k > N/2$ å¯¹åº”è´Ÿé¢‘ç‡ï¼ˆç”±äºå‘¨æœŸæ€§ï¼‰

2. **å¹…åº¦è§£é‡Š**ï¼š
   - å¹…åº¦ $|X[k]|$ è¡¨ç¤ºé¢‘ç‡ $f_k$ åˆ†é‡çš„å¼ºåº¦
   - ç›¸ä½ $\arg(X[k])$ è¡¨ç¤ºé¢‘ç‡ $f_k$ åˆ†é‡çš„åˆå§‹ç›¸ä½

3. **åŠŸç‡è§£é‡Š**ï¼š
   - åŠŸç‡ $|X[k]|^2$ è¡¨ç¤ºé¢‘ç‡ $f_k$ åˆ†é‡çš„èƒ½é‡
   - æ€»åŠŸç‡ï¼š$\sum_{k=0}^{N-1} |X[k]|^2 = N \sum_{n=0}^{N-1} |x[n]|^2$

### 6.4 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **å¤æ•°è¿ç®—**ï¼š
   - PostgreSQLä¸ç›´æ¥æ”¯æŒå¤æ•°ï¼Œéœ€è¦åˆ†åˆ«å¤„ç†å®éƒ¨å’Œè™šéƒ¨
   - ä½¿ç”¨ `COS()` å’Œ `SIN()` å‡½æ•°è®¡ç®—æ—‹è½¬å› å­

2. **æ€§èƒ½è€ƒè™‘**ï¼š
   - å¯¹äºå¤§è§„æ¨¡æ•°æ®ï¼Œè€ƒè™‘ä½¿ç”¨å¤–éƒ¨å‡½æ•°ï¼ˆPL/Python + NumPyï¼‰
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜DFTç»“æœ

3. **ç²¾åº¦é—®é¢˜**ï¼š
   - ä½¿ç”¨ `NUMERIC` ç±»å‹ä¿æŒç²¾åº¦
   - æ³¨æ„ä¸‰è§’å‡½æ•°è®¡ç®—çš„ç²¾åº¦é™åˆ¶

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **Oppenheim, A.V., Schafer, R.W. (2009)**: "Discrete-Time Signal Processing", 3rd Edition, Prentice Hall.

2. **Brigham, E.O. (1988)**: "The Fast Fourier Transform and Its Applications", Prentice Hall.

3. **Cooley, J.W., Tukey, J.W. (1965)**: "An Algorithm for the Machine Calculation of Complex Fourier Series", *Mathematics of Computation*, 19(90), 297-301.

4. **Proakis, J.G., Manolakis, D.G. (2006)**: "Digital Signal Processing: Principles, Algorithms, and Applications", 4th Edition, Prentice Hall.

5. **Smith, S.W. (1997)**: "The Scientist and Engineer's Guide to Digital Signal Processing", California Technical Publishing.

### åœ¨çº¿èµ„æº

- **PostgreSQLå®˜æ–¹æ–‡æ¡£**: <https://www.postgresql.org/docs/>
- **NumPy FFTæ–‡æ¡£**: <https://numpy.org/doc/stable/reference/routines.fft.html>
- **FFTç®—æ³•å¯è§†åŒ–**: <https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/>
- **ä¿¡å·å¤„ç†æ•™ç¨‹**: <https://www.dspguide.com/>

### ç›¸å…³ç®—æ³•

- **çŸ­æ—¶å‚…é‡Œå¶å˜æ¢ï¼ˆSTFTï¼‰**ï¼šæ—¶é¢‘åˆ†æ
- **å°æ³¢å˜æ¢**ï¼šå¤šåˆ†è¾¨ç‡åˆ†æ
- **Zå˜æ¢**ï¼šç¦»æ•£æ—¶é—´ç³»ç»Ÿçš„é¢‘åŸŸåˆ†æ
- **ç¦»æ•£ä½™å¼¦å˜æ¢ï¼ˆDCTï¼‰**ï¼šå›¾åƒå‹ç¼©ï¼ˆJPEGï¼‰

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ”¹è¿›å®Œæˆ
