# PostgreSQL å°æ³¢å˜æ¢ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ä¿¡å·å¤„ç† | å°æ³¢å˜æ¢ | å¤šåˆ†è¾¨ç‡åˆ†æ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Wavelet Transform, Multiresolution Analysis, Signal Processing

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å°æ³¢å˜æ¢ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å°æ³¢å˜æ¢ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å°æ³¢å˜æ¢æ¦‚è¿°](#å°æ³¢å˜æ¢æ¦‚è¿°)
    - [å°æ³¢ç±»å‹](#å°æ³¢ç±»å‹)
  - [1. ç¦»æ•£å°æ³¢å˜æ¢](#1-ç¦»æ•£å°æ³¢å˜æ¢)
    - [1.1 DWTåŸç†](#11-dwtåŸç†)
    - [1.2 Haarå°æ³¢å®ç°](#12-haarå°æ³¢å®ç°)
    - [1.3 å¤šçº§å°æ³¢åˆ†è§£](#13-å¤šçº§å°æ³¢åˆ†è§£)
  - [2. å¤šåˆ†è¾¨ç‡åˆ†æ](#2-å¤šåˆ†è¾¨ç‡åˆ†æ)
    - [2.1 MRAåŸç†](#21-mraåŸç†)
    - [2.2 MRAå®ç°](#22-mraå®ç°)
    - [2.3 å°æ³¢å»å™ª](#23-å°æ³¢å»å™ª)
  - [3. å°æ³¢é‡æ„](#3-å°æ³¢é‡æ„)
    - [3.1 é€†å°æ³¢å˜æ¢](#31-é€†å°æ³¢å˜æ¢)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## å°æ³¢å˜æ¢æ¦‚è¿°

**å°æ³¢å˜æ¢**æä¾›æ—¶é¢‘åŸŸåˆ†æï¼Œæ¯”å‚…é‡Œå¶å˜æ¢æ›´é€‚åˆéå¹³ç¨³ä¿¡å·ã€‚

### å°æ³¢ç±»å‹

| å°æ³¢ç±»å‹ | ç‰¹ç‚¹ | åº”ç”¨ |
|---------|------|------|
| **Haarå°æ³¢** | ç®€å•ã€å¿«é€Ÿ | ä¿¡å·å‹ç¼© |
| **Daubechieså°æ³¢** | ç´§æ”¯æ’‘ã€æ­£äº¤ | ä¿¡å·å»å™ª |
| **Morletå°æ³¢** | è¿ç»­å°æ³¢ | æ—¶é¢‘åˆ†æ |

---

## 1. ç¦»æ•£å°æ³¢å˜æ¢

### 1.1 DWTåŸç†

**ç¦»æ•£å°æ³¢å˜æ¢ï¼ˆDWTï¼‰**ï¼š
$$W(a,b) = \frac{1}{\sqrt{a}}\int_{-\infty}^{\infty} x(t) \psi^*\left(\frac{t-b}{a}\right) dt$$

**å¤šåˆ†è¾¨ç‡åˆ†æï¼ˆMRAï¼‰**ï¼š

- **è¿‘ä¼¼ç³»æ•°**ï¼šä½é¢‘æˆåˆ†
- **ç»†èŠ‚ç³»æ•°**ï¼šé«˜é¢‘æˆåˆ†

### 1.2 Haarå°æ³¢å®ç°

```sql
-- å°æ³¢å˜æ¢æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'wavelet_signal') THEN
            DROP TABLE wavelet_signal, wavelet_coefficients CASCADE;
        END IF;

        CREATE TABLE wavelet_signal (
            sample_id INTEGER PRIMARY KEY,
            signal_value NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹ä¿¡å·ï¼ˆ8ä¸ªæ ·æœ¬ï¼‰
        INSERT INTO wavelet_signal (sample_id, signal_value) VALUES
            (1, 1.0), (2, 2.0), (3, 3.0), (4, 4.0),
            (5, 5.0), (6, 6.0), (7, 7.0), (8, 8.0);

        RAISE NOTICE 'å°æ³¢ä¿¡å·è¡¨åˆ›å»ºæˆåŠŸï¼Œå…± % æ¡è®°å½•', (SELECT COUNT(*) FROM wavelet_signal);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Haarå°æ³¢åˆ†è§£ï¼šç¬¬ä¸€å±‚
WITH haar_level1 AS (
    SELECT
        (sample_id + 1) / 2 AS level1_index,
        CASE
            WHEN sample_id % 2 = 1 THEN
                (signal_value + LEAD(signal_value) OVER (ORDER BY sample_id)) / 2.0
            ELSE NULL
        END AS approximation,
        CASE
            WHEN sample_id % 2 = 1 THEN
                (signal_value - LEAD(signal_value) OVER (ORDER BY sample_id)) / 2.0
            ELSE NULL
        END AS detail
    FROM wavelet_signal
)
SELECT
    level1_index,
    ROUND(approximation::numeric, 4) AS approximation_coeff,
    ROUND(detail::numeric, 4) AS detail_coeff
FROM haar_level1
WHERE approximation IS NOT NULL
ORDER BY level1_index;
```

### 1.3 å¤šçº§å°æ³¢åˆ†è§£

```sql
-- å¤šçº§å°æ³¢åˆ†è§£ï¼šé€’å½’åˆ†è§£è¿‘ä¼¼ç³»æ•°
CREATE OR REPLACE FUNCTION haar_wavelet_decompose(
    p_signal_values NUMERIC[]
)
RETURNS TABLE (
    level INTEGER,
    coeff_index INTEGER,
    approximation NUMERIC,
    detail NUMERIC
) AS $$
DECLARE
    current_level INTEGER := 1;
    current_signal NUMERIC[];
    next_approximation NUMERIC[];
    current_detail NUMERIC[];
    signal_length INTEGER;
BEGIN
    current_signal := p_signal_values;
    signal_length := array_length(current_signal, 1);

    -- é€’å½’åˆ†è§£ç›´åˆ°ä¿¡å·é•¿åº¦<2
    WHILE signal_length >= 2 LOOP
        -- è®¡ç®—å½“å‰å±‚çš„è¿‘ä¼¼å’Œç»†èŠ‚ç³»æ•°
        FOR i IN 1..(signal_length / 2) LOOP
            RETURN QUERY SELECT
                current_level,
                i,
                (current_signal[2*i-1] + current_signal[2*i]) / 2.0,
                (current_signal[2*i-1] - current_signal[2*i]) / 2.0;
        END LOOP;

        -- å‡†å¤‡ä¸‹ä¸€å±‚ï¼ˆä½¿ç”¨è¿‘ä¼¼ç³»æ•°ï¼‰
        SELECT ARRAY_AGG(approx) INTO next_approximation
        FROM (
            SELECT (current_signal[2*i-1] + current_signal[2*i]) / 2.0 AS approx
            FROM generate_series(1, signal_length / 2) i
        ) t;

        current_signal := next_approximation;
        signal_length := array_length(current_signal, 1);
        current_level := current_level + 1;
    END LOOP;

    RETURN;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨å¤šçº§åˆ†è§£å‡½æ•°
WITH signal_array AS (
    SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
    FROM wavelet_signal
)
SELECT
    level,
    coeff_index,
    ROUND(approximation::numeric, 4) AS approximation,
    ROUND(detail::numeric, 4) AS detail
FROM signal_array,
LATERAL haar_wavelet_decompose(signal_values)
ORDER BY level, coeff_index;
```

---

## 2. å¤šåˆ†è¾¨ç‡åˆ†æ

### 2.1 MRAåŸç†

**å¤šåˆ†è¾¨ç‡åˆ†æï¼ˆMRAï¼‰**å°†ä¿¡å·åˆ†è§£ä¸ºä¸åŒåˆ†è¾¨ç‡å±‚æ¬¡ã€‚

**åˆ†è§£å…¬å¼**ï¼š
$$x(t) = A_1(t) + D_1(t) = A_2(t) + D_2(t) + D_1(t) = ...$$

å…¶ä¸­ï¼š

- $A_k(t)$ï¼šç¬¬kå±‚è¿‘ä¼¼
- $D_k(t)$ï¼šç¬¬kå±‚ç»†èŠ‚

### 2.2 MRAå®ç°

```sql
-- å¤šåˆ†è¾¨ç‡åˆ†æï¼šé‡å»ºä¸åŒåˆ†è¾¨ç‡çš„ä¿¡å·
WITH wavelet_decomposition AS (
    SELECT
        level,
        coeff_index,
        approximation,
        detail
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
),
-- é‡å»ºç¬¬1å±‚è¿‘ä¼¼ï¼ˆåªä½¿ç”¨è¿‘ä¼¼ç³»æ•°ï¼‰
level1_reconstruction AS (
    SELECT
        coeff_index * 2 - 1 AS sample_id,
        approximation AS reconstructed_value
    FROM wavelet_decomposition
    WHERE level = 1
    UNION ALL
    SELECT
        coeff_index * 2,
        approximation AS reconstructed_value
    FROM wavelet_decomposition
    WHERE level = 1
)
SELECT
    sample_id,
    ROUND(reconstructed_value::numeric, 4) AS level1_approximation
FROM level1_reconstruction
ORDER BY sample_id;
```

### 2.3 å°æ³¢å»å™ª

```sql
-- å°æ³¢å»å™ªï¼šé˜ˆå€¼å¤„ç†ç»†èŠ‚ç³»æ•°
WITH wavelet_decomp AS (
    SELECT
        level,
        coeff_index,
        approximation,
        detail,
        -- è®¡ç®—é˜ˆå€¼ï¼ˆä½¿ç”¨è½¯é˜ˆå€¼ï¼‰
        CASE
            WHEN ABS(detail) > 0.5 THEN detail - SIGN(detail) * 0.5
            ELSE 0
        END AS thresholded_detail
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
)
SELECT
    level,
    coeff_index,
    ROUND(approximation::numeric, 4) AS approximation,
    ROUND(detail::numeric, 4) AS original_detail,
    ROUND(thresholded_detail::numeric, 4) AS thresholded_detail
FROM wavelet_decomp
ORDER BY level, coeff_index;
```

---

## 3. å°æ³¢é‡æ„

### 3.1 é€†å°æ³¢å˜æ¢

**é€†å°æ³¢å˜æ¢**ä»å°æ³¢ç³»æ•°é‡å»ºåŸå§‹ä¿¡å·ã€‚

```sql
-- Haarå°æ³¢é‡æ„ï¼šä»ç³»æ•°é‡å»ºä¿¡å·
CREATE OR REPLACE FUNCTION haar_wavelet_reconstruct(
    p_approximation NUMERIC[],
    p_detail NUMERIC[]
)
RETURNS NUMERIC[] AS $$
DECLARE
    reconstructed NUMERIC[];
    i INTEGER;
BEGIN
    -- Haaré‡æ„å…¬å¼ï¼šx[2i-1] = a[i] + d[i], x[2i] = a[i] - d[i]
    reconstructed := ARRAY[]::NUMERIC[];

    FOR i IN 1..array_length(p_approximation, 1) LOOP
        reconstructed := reconstructed || (p_approximation[i] + p_detail[i]);
        IF i <= array_length(p_detail, 1) THEN
            reconstructed := reconstructed || (p_approximation[i] - p_detail[i]);
        END IF;
    END LOOP;

    RETURN reconstructed;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨é‡æ„å‡½æ•°
WITH level1_coeffs AS (
    SELECT
        ARRAY_AGG(approximation ORDER BY coeff_index) AS approx_coeffs,
        ARRAY_AGG(detail ORDER BY coeff_index) AS detail_coeffs
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
    WHERE level = 1
)
SELECT
    unnest(haar_wavelet_reconstruct(approx_coeffs, detail_coeffs))
    WITH ORDINALITY AS reconstructed(value, index)
FROM level1_coeffs;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Mallat, S. (2009)**: "A Wavelet Tour of Signal Processing", 3rd Edition
2. **Daubechies, I. (1992)**: "Ten Lectures on Wavelets"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¿«é€Ÿå°æ³¢å˜æ¢**ï¼šä½¿ç”¨FFTåŠ é€Ÿè®¡ç®—
2. **å¹¶è¡Œåˆ†è§£**ï¼šå¹¶è¡Œå¤„ç†å¤šä¸ªä¿¡å·
3. **ç¨€ç–è¡¨ç¤º**ï¼šåˆ©ç”¨å°æ³¢ç³»æ•°çš„ç¨€ç–æ€§
4. **ç¼“å­˜ä¼˜åŒ–**ï¼šç¼“å­˜å¸¸ç”¨å°æ³¢åŸºå‡½æ•°

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **å°æ³¢é€‰æ‹©**ï¼šæ ¹æ®ä¿¡å·ç‰¹æ€§é€‰æ‹©åˆé€‚å°æ³¢
2. **åˆ†è§£å±‚æ•°**ï¼šæ ¹æ®ä¿¡å·é•¿åº¦é€‰æ‹©åˆ†è§£å±‚æ•°
3. **é˜ˆå€¼é€‰æ‹©**ï¼šåˆç†é€‰æ‹©å»å™ªé˜ˆå€¼
4. **é‡æ„éªŒè¯**ï¼šéªŒè¯é‡æ„è¯¯å·®

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
