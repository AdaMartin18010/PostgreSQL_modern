# PostgreSQL 小波变换算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 信号处理 | 小波变换 | 多分辨率分析
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Wavelet Transform, Multiresolution Analysis, Signal Processing

---

## 📋 目录

- [PostgreSQL 小波变换算法完整指南](#postgresql-小波变换算法完整指南)
  - [📋 目录](#-目录)
  - [小波变换概述](#小波变换概述)
  - [理论基础](#理论基础)
    - [小波变换问题定义](#小波变换问题定义)
    - [核心概念](#核心概念)
    - [算法分类](#算法分类)
    - [小波类型对比](#小波类型对比)
    - [技术栈](#技术栈)
  - [1. 离散小波变换](#1-离散小波变换)
    - [1.1 DWT原理](#11-dwt原理)
    - [1.2 Haar小波实现](#12-haar小波实现)
    - [1.3 多级小波分解](#13-多级小波分解)
  - [2. 多分辨率分析](#2-多分辨率分析)
    - [2.1 MRA原理](#21-mra原理)
    - [2.2 MRA实现](#22-mra实现)
    - [2.3 小波去噪](#23-小波去噪)
  - [3. 小波重构](#3-小波重构)
    - [3.1 逆小波变换](#31-逆小波变换)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 信号去噪](#41-信号去噪)
    - [4.2 信号压缩](#42-信号压缩)
    - [4.3 特征提取](#43-特征提取)
    - [4.4 时频分析](#44-时频分析)
  - [📊 性能优化建议](#-性能优化建议)
    - [算法优化](#算法优化)
    - [索引优化](#索引优化)
    - [物化视图](#物化视图)
  - [🎯 最佳实践](#-最佳实践)
    - [小波选择](#小波选择)
    - [分解层数选择](#分解层数选择)
    - [阈值选择](#阈值选择)
    - [重构验证](#重构验证)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 算法对比](#-算法对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：重构误差大](#问题1重构误差大)
    - [问题2：计算性能慢](#问题2计算性能慢)
    - [问题3：去噪效果不好](#问题3去噪效果不好)
  - [📚 参考资源](#-参考资源)

---

## 小波变换概述

**小波变换**提供时频域分析，比傅里叶变换更适合非平稳信号。

## 理论基础

### 小波变换问题定义

小波变换是一种时频域分析方法，通过将信号分解为不同尺度和位置的基函数（小波），实现对信号的局部化时频分析。

### 核心概念

1. **小波基函数**：
   - 母小波（Mother Wavelet）：$\psi(t)$
   - 小波族：$\psi_{a,b}(t) = \frac{1}{\sqrt{a}}\psi\left(\frac{t-b}{a}\right)$
   - 尺度参数 $a$：控制频率
   - 平移参数 $b$：控制时间位置

2. **离散小波变换（DWT）**：
   - 使用正交小波基
   - 多分辨率分析（MRA）
   - 快速算法（Mallat算法）

3. **连续小波变换（CWT）**：
   - 连续尺度和平移
   - 冗余表示
   - 时频分析

### 算法分类

1. **按变换类型分类**：
   - 离散小波变换（DWT）
   - 连续小波变换（CWT）
   - 小波包变换（Wavelet Packet Transform）

2. **按小波类型分类**：
   - Haar小波：最简单、快速
   - Daubechies小波：紧支撑、正交
   - Morlet小波：连续小波、时频分析
   - Coiflet小波：对称、紧支撑
   - Biorthogonal小波：非正交、对称

### 小波类型对比

| 小波类型 | 特点 | 应用 | 优势 | 局限性 |
|---------|------|------|------|--------|
| **Haar小波** | 简单、快速、不连续 | 信号压缩、图像处理 | 计算简单、快速 | 不光滑、频域特性差 |
| **Daubechies小波** | 紧支撑、正交、光滑 | 信号去噪、压缩 | 频域特性好、正交性 | 不对称 |
| **Morlet小波** | 连续、高斯包络 | 时频分析、特征提取 | 时频分辨率好 | 冗余表示 |
| **Coiflet小波** | 对称、紧支撑 | 信号分析、去噪 | 对称性、光滑性 | 计算复杂度较高 |

### 技术栈

- **窗口函数**：LAG、LEAD、ROW_NUMBER
- **数组操作**：ARRAY_AGG、unnest、数组索引
- **PL/pgSQL函数**：递归函数、循环处理
- **数学函数**：SIN、COS、SQRT、ABS

---

## 1. 离散小波变换

### 1.1 DWT原理

**离散小波变换（DWT）**：
$$W(a,b) = \frac{1}{\sqrt{a}}\int_{-\infty}^{\infty} x(t) \psi^*\left(\frac{t-b}{a}\right) dt$$

**多分辨率分析（MRA）**：

- **近似系数**：低频成分
- **细节系数**：高频成分

### 1.2 Haar小波实现

```sql
-- 小波变换数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'wavelet_signal') THEN
            DROP TABLE wavelet_signal, wavelet_coefficients CASCADE;
        END IF;

        CREATE TABLE wavelet_signal (
            sample_id INTEGER PRIMARY KEY,
            signal_value NUMERIC NOT NULL
        );

        -- 插入示例信号（8个样本）
        INSERT INTO wavelet_signal (sample_id, signal_value) VALUES
            (1, 1.0), (2, 2.0), (3, 3.0), (4, 4.0),
            (5, 5.0), (6, 6.0), (7, 7.0), (8, 8.0);

        RAISE NOTICE '小波信号表创建成功，共 % 条记录', (SELECT COUNT(*) FROM wavelet_signal);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- Haar小波分解：第一层
WITH haar_level1 AS (
    SELECT
        (sample_id + 1) / 2 AS level1_index,
        CASE
            WHEN sample_id % 2 = 1 THEN
                (signal_value + LEAD(signal_value) OVER (ORDER BY sample_id)) / 2.0
            ELSE NULL
        END AS approximation,
        CASE
            WHEN sample_id % 2 = 1 THEN
                (signal_value - LEAD(signal_value) OVER (ORDER BY sample_id)) / 2.0
            ELSE NULL
        END AS detail
    FROM wavelet_signal
)
SELECT
    level1_index,
    ROUND(approximation::numeric, 4) AS approximation_coeff,
    ROUND(detail::numeric, 4) AS detail_coeff
FROM haar_level1
WHERE approximation IS NOT NULL
ORDER BY level1_index;
```

### 1.3 多级小波分解

```sql
-- 多级小波分解：递归分解近似系数
CREATE OR REPLACE FUNCTION haar_wavelet_decompose(
    p_signal_values NUMERIC[]
)
RETURNS TABLE (
    level INTEGER,
    coeff_index INTEGER,
    approximation NUMERIC,
    detail NUMERIC
) AS $$
DECLARE
    current_level INTEGER := 1;
    current_signal NUMERIC[];
    next_approximation NUMERIC[];
    current_detail NUMERIC[];
    signal_length INTEGER;
BEGIN
    current_signal := p_signal_values;
    signal_length := array_length(current_signal, 1);

    -- 递归分解直到信号长度<2
    WHILE signal_length >= 2 LOOP
        -- 计算当前层的近似和细节系数
        FOR i IN 1..(signal_length / 2) LOOP
            RETURN QUERY SELECT
                current_level,
                i,
                (current_signal[2*i-1] + current_signal[2*i]) / 2.0,
                (current_signal[2*i-1] - current_signal[2*i]) / 2.0;
        END LOOP;

        -- 准备下一层（使用近似系数）
        SELECT ARRAY_AGG(approx) INTO next_approximation
        FROM (
            SELECT (current_signal[2*i-1] + current_signal[2*i]) / 2.0 AS approx
            FROM generate_series(1, signal_length / 2) i
        ) t;

        current_signal := next_approximation;
        signal_length := array_length(current_signal, 1);
        current_level := current_level + 1;
    END LOOP;

    RETURN;
END;
$$ LANGUAGE plpgsql;

-- 使用多级分解函数
WITH signal_array AS (
    SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
    FROM wavelet_signal
)
SELECT
    level,
    coeff_index,
    ROUND(approximation::numeric, 4) AS approximation,
    ROUND(detail::numeric, 4) AS detail
FROM signal_array,
LATERAL haar_wavelet_decompose(signal_values)
ORDER BY level, coeff_index;
```

---

## 2. 多分辨率分析

### 2.1 MRA原理

**多分辨率分析（MRA）**将信号分解为不同分辨率层次。

**分解公式**：
$$x(t) = A_1(t) + D_1(t) = A_2(t) + D_2(t) + D_1(t) = ...$$

其中：

- $A_k(t)$：第k层近似
- $D_k(t)$：第k层细节

### 2.2 MRA实现

```sql
-- 多分辨率分析：重建不同分辨率的信号
WITH wavelet_decomposition AS (
    SELECT
        level,
        coeff_index,
        approximation,
        detail
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
),
-- 重建第1层近似（只使用近似系数）
level1_reconstruction AS (
    SELECT
        coeff_index * 2 - 1 AS sample_id,
        approximation AS reconstructed_value
    FROM wavelet_decomposition
    WHERE level = 1
    UNION ALL
    SELECT
        coeff_index * 2,
        approximation AS reconstructed_value
    FROM wavelet_decomposition
    WHERE level = 1
)
SELECT
    sample_id,
    ROUND(reconstructed_value::numeric, 4) AS level1_approximation
FROM level1_reconstruction
ORDER BY sample_id;
```

### 2.3 小波去噪

```sql
-- 小波去噪：阈值处理细节系数
WITH wavelet_decomp AS (
    SELECT
        level,
        coeff_index,
        approximation,
        detail,
        -- 计算阈值（使用软阈值）
        CASE
            WHEN ABS(detail) > 0.5 THEN detail - SIGN(detail) * 0.5
            ELSE 0
        END AS thresholded_detail
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
)
SELECT
    level,
    coeff_index,
    ROUND(approximation::numeric, 4) AS approximation,
    ROUND(detail::numeric, 4) AS original_detail,
    ROUND(thresholded_detail::numeric, 4) AS thresholded_detail
FROM wavelet_decomp
ORDER BY level, coeff_index;
```

---

## 3. 小波重构

### 3.1 逆小波变换

**逆小波变换**从小波系数重建原始信号。

```sql
-- Haar小波重构：从系数重建信号
CREATE OR REPLACE FUNCTION haar_wavelet_reconstruct(
    p_approximation NUMERIC[],
    p_detail NUMERIC[]
)
RETURNS NUMERIC[] AS $$
DECLARE
    reconstructed NUMERIC[];
    i INTEGER;
BEGIN
    -- Haar重构公式：x[2i-1] = a[i] + d[i], x[2i] = a[i] - d[i]
    reconstructed := ARRAY[]::NUMERIC[];

    FOR i IN 1..array_length(p_approximation, 1) LOOP
        reconstructed := reconstructed || (p_approximation[i] + p_detail[i]);
        IF i <= array_length(p_detail, 1) THEN
            reconstructed := reconstructed || (p_approximation[i] - p_detail[i]);
        END IF;
    END LOOP;

    RETURN reconstructed;
END;
$$ LANGUAGE plpgsql;

-- 使用重构函数
WITH level1_coeffs AS (
    SELECT
        ARRAY_AGG(approximation ORDER BY coeff_index) AS approx_coeffs,
        ARRAY_AGG(detail ORDER BY coeff_index) AS detail_coeffs
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
    WHERE level = 1
)
SELECT
    unnest(haar_wavelet_reconstruct(approx_coeffs, detail_coeffs))
    WITH ORDINALITY AS reconstructed(value, index)
FROM level1_coeffs;
```

---

## 4. 实际应用案例

### 4.1 信号去噪

```sql
-- 信号去噪应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建带噪声的信号
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'noisy_signal') THEN
            DROP TABLE noisy_signal CASCADE;
        END IF;

        CREATE TABLE noisy_signal (
            sample_id INTEGER PRIMARY KEY,
            clean_signal NUMERIC NOT NULL,
            noisy_signal NUMERIC NOT NULL
        );

        -- 插入示例信号（正弦波 + 噪声）
        INSERT INTO noisy_signal (sample_id, clean_signal, noisy_signal)
        SELECT
            i,
            SIN(i * 0.1) AS clean_signal,
            SIN(i * 0.1) + (RANDOM() - 0.5) * 0.5 AS noisy_signal
        FROM generate_series(1, 128) i;

        RAISE NOTICE '带噪声信号表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '信号去噪准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 小波去噪：使用软阈值
WITH wavelet_decomp AS (
    SELECT
        level,
        coeff_index,
        approximation,
        detail,
        -- 计算阈值（基于中位数绝对偏差）
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ABS(detail)) OVER () * 1.4826 AS threshold
    FROM (
        SELECT ARRAY_AGG(noisy_signal ORDER BY sample_id) AS signal_values
        FROM noisy_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
),
thresholded_coeffs AS (
    SELECT
        level,
        coeff_index,
        approximation,
        CASE
            WHEN ABS(detail) > threshold THEN detail - SIGN(detail) * threshold
            ELSE 0
        END AS thresholded_detail
    FROM wavelet_decomp
)
SELECT
    level,
    COUNT(*) AS coeff_count,
    COUNT(*) FILTER (WHERE thresholded_detail != 0) AS non_zero_coeffs,
    ROUND(AVG(ABS(thresholded_detail))::numeric, 4) AS avg_thresholded_detail
FROM thresholded_coeffs
GROUP BY level
ORDER BY level;
```

### 4.2 信号压缩

```sql
-- 信号压缩应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'wavelet_signal') THEN
            RAISE WARNING '表 wavelet_signal 不存在，无法进行信号压缩';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行信号压缩';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '信号压缩准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 小波压缩：保留主要系数
WITH wavelet_decomp AS (
    SELECT
        level,
        coeff_index,
        approximation,
        detail,
        ABS(detail) AS abs_detail
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
),
compression_stats AS (
    SELECT
        PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY abs_detail) AS threshold_90,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY abs_detail) AS threshold_95
    FROM wavelet_decomp
)
SELECT
    'Original' AS compression_type,
    COUNT(*) AS coeff_count,
    COUNT(*) AS retained_coeffs,
    100.0 AS compression_ratio
FROM wavelet_decomp
UNION ALL
SELECT
    '90% Threshold',
    COUNT(*) AS coeff_count,
    COUNT(*) FILTER (WHERE abs_detail >= (SELECT threshold_90 FROM compression_stats)),
    ROUND((COUNT(*) FILTER (WHERE abs_detail >= (SELECT threshold_90 FROM compression_stats))::numeric / COUNT(*) * 100)::numeric, 2)
FROM wavelet_decomp
UNION ALL
SELECT
    '95% Threshold',
    COUNT(*) AS coeff_count,
    COUNT(*) FILTER (WHERE abs_detail >= (SELECT threshold_95 FROM compression_stats)),
    ROUND((COUNT(*) FILTER (WHERE abs_detail >= (SELECT threshold_95 FROM compression_stats))::numeric / COUNT(*) * 100)::numeric, 2)
FROM wavelet_decomp;
```

### 4.3 特征提取

```sql
-- 特征提取应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'wavelet_signal') THEN
            RAISE WARNING '表 wavelet_signal 不存在，无法进行特征提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行特征提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '特征提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 小波特征提取：能量、方差、峰值
WITH wavelet_decomp AS (
    SELECT
        level,
        coeff_index,
        approximation,
        detail
    FROM (
        SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM wavelet_signal
    ) sa,
    LATERAL haar_wavelet_decompose(signal_values)
),
level_features AS (
    SELECT
        level,
        COUNT(*) AS coeff_count,
        SUM(approximation^2) AS approx_energy,
        SUM(detail^2) AS detail_energy,
        AVG(ABS(detail)) AS avg_detail_magnitude,
        MAX(ABS(detail)) AS max_detail_magnitude,
        STDDEV(detail) AS detail_stddev
    FROM wavelet_decomp
    GROUP BY level
)
SELECT
    level,
    coeff_count,
    ROUND(approx_energy::numeric, 4) AS approximation_energy,
    ROUND(detail_energy::numeric, 4) AS detail_energy,
    ROUND(avg_detail_magnitude::numeric, 4) AS avg_detail_magnitude,
    ROUND(max_detail_magnitude::numeric, 4) AS max_detail_magnitude,
    ROUND(detail_stddev::numeric, 4) AS detail_stddev,
    ROUND((detail_energy / NULLIF(approx_energy + detail_energy, 0) * 100)::numeric, 2) AS detail_energy_percentage
FROM level_features
ORDER BY level;
```

### 4.4 时频分析

```sql
-- 时频分析应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建时变信号
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_varying_signal') THEN
            DROP TABLE time_varying_signal CASCADE;
        END IF;

        CREATE TABLE time_varying_signal (
            sample_id INTEGER PRIMARY KEY,
            sample_time NUMERIC NOT NULL,
            signal_value NUMERIC NOT NULL
        );

        -- 插入时变信号（频率随时间变化）
        INSERT INTO time_varying_signal (sample_id, sample_time, signal_value)
        SELECT
            i,
            i * 0.1 AS sample_time,
            CASE
                WHEN i < 50 THEN SIN(i * 0.1)
                WHEN i < 100 THEN SIN(i * 0.2)
                ELSE SIN(i * 0.3)
            END + (RANDOM() - 0.5) * 0.2 AS signal_value
        FROM generate_series(1, 128) i;

        RAISE NOTICE '时变信号表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '时频分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 时频分析：不同时间段的频率特征
WITH time_segments AS (
    SELECT
        sample_id,
        sample_time,
        signal_value,
        CASE
            WHEN sample_id <= 50 THEN 1
            WHEN sample_id <= 100 THEN 2
            ELSE 3
        END AS time_segment
    FROM time_varying_signal
),
segment_wavelets AS (
    SELECT
        time_segment,
        level,
        AVG(ABS(detail)) AS avg_detail_magnitude,
        MAX(ABS(detail)) AS max_detail_magnitude
    FROM (
        SELECT
            time_segment,
            ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
        FROM time_segments
        GROUP BY time_segment
    ) ts,
    LATERAL haar_wavelet_decompose(signal_values)
    GROUP BY time_segment, level
)
SELECT
    time_segment,
    level,
    ROUND(avg_detail_magnitude::numeric, 4) AS avg_detail_magnitude,
    ROUND(max_detail_magnitude::numeric, 4) AS max_detail_magnitude
FROM segment_wavelets
ORDER BY time_segment, level;
```

---

## 📊 性能优化建议

### 算法优化

1. **快速小波变换**：
   - 使用Mallat算法（快速算法）
   - 利用FFT加速计算
   - 减少冗余计算

2. **并行处理**：
   - 并行处理多个信号
   - 并行计算不同尺度
   - 利用PostgreSQL并行查询

3. **稀疏表示**：
   - 利用小波系数的稀疏性
   - 只存储非零系数
   - 压缩存储

### 索引优化

```sql
-- 创建关键索引
CREATE INDEX IF NOT EXISTS idx_wavelet_signal_id ON wavelet_signal(sample_id);
CREATE INDEX IF NOT EXISTS idx_wavelet_coeffs_level ON wavelet_coefficients(level);
```

### 物化视图

```sql
-- 创建常用分析的物化视图
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_wavelet_features AS
SELECT
    level,
    COUNT(*) AS coeff_count,
    AVG(ABS(detail)) AS avg_detail_magnitude,
    MAX(ABS(detail)) AS max_detail_magnitude
FROM (
    SELECT ARRAY_AGG(signal_value ORDER BY sample_id) AS signal_values
    FROM wavelet_signal
) sa,
LATERAL haar_wavelet_decompose(signal_values)
GROUP BY level;

CREATE UNIQUE INDEX ON mv_wavelet_features(level);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_wavelet_features;
```

---

## 🎯 最佳实践

### 小波选择

1. **Haar小波**：
   - 适用于简单信号
   - 计算快速
   - 不适用于光滑信号

2. **Daubechies小波**：
   - 适用于一般信号
   - 频域特性好
   - 去噪效果好

3. **Morlet小波**：
   - 适用于时频分析
   - 连续小波变换
   - 特征提取

### 分解层数选择

1. **信号长度**：分解层数不应超过 $\log_2(N)$，其中 $N$ 是信号长度
2. **应用需求**：根据应用需求选择分解层数
3. **计算资源**：考虑计算资源和时间限制

### 阈值选择

1. **软阈值**：$T_{soft}(x) = \text{sign}(x) \max(|x| - \lambda, 0)$
2. **硬阈值**：$T_{hard}(x) = x \cdot \mathbf{1}_{|x| > \lambda}$
3. **自适应阈值**：基于信号统计特性

### 重构验证

1. **重构误差**：验证重构误差是否在可接受范围内
2. **能量守恒**：验证能量是否守恒
3. **信号对比**：对比原始信号和重构信号

### SQL实现注意事项

1. **错误处理**：使用DO块进行错误处理
2. **数组操作**：注意数组索引和边界
3. **性能优化**：使用物化视图缓存结果
4. **数据类型转换**：注意数据类型转换和精度

---

## 📈 算法对比

| 算法类型 | 时间复杂度 | 空间复杂度 | 适用场景 | 优势 | 局限性 |
|---------|-----------|-----------|---------|------|--------|
| Haar小波 | $O(n)$ | $O(n)$ | 简单信号、快速处理 | 计算简单、快速 | 不光滑、频域特性差 |
| Daubechies小波 | $O(n)$ | $O(n)$ | 一般信号、去噪 | 频域特性好、正交性 | 不对称 |
| Morlet小波 | $O(n^2)$ | $O(n^2)$ | 时频分析 | 时频分辨率好 | 冗余表示、计算复杂 |

---

## 🔍 常见问题与解决方案

### 问题1：重构误差大

**原因**：

- 阈值选择不当
- 分解层数过多
- 数值精度问题

**解决方案**：

- 调整阈值参数
- 减少分解层数
- 提高数值精度

### 问题2：计算性能慢

**原因**：

- 信号长度过大
- 分解层数过多
- 未使用快速算法

**解决方案**：

- 使用快速小波变换
- 减少分解层数
- 并行处理

### 问题3：去噪效果不好

**原因**：

- 小波选择不当
- 阈值选择不当
- 信号特性不匹配

**解决方案**：

- 选择合适的小波
- 调整阈值参数
- 分析信号特性

---

## 📚 参考资源

1. **Mallat, S. (2009)**: "A Wavelet Tour of Signal Processing", 3rd Edition
2. **Daubechies, I. (1992)**: "Ten Lectures on Wavelets"
3. **Strang, G. & Nguyen, T. (1996)**: "Wavelets and Filter Banks"
4. **Vetterli, M. & Kovačević, J. (1995)**: "Wavelets and Subband Coding"

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
