# PostgreSQL é¢‘è°±åˆ†æç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ä¿¡å·å¤„ç† | é¢‘è°±åˆ†æ | åŠŸç‡è°±
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
> **å‚è€ƒæ ‡å‡†**: Spectral Analysis, Power Spectral Density, Signal Processing

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL é¢‘è°±åˆ†æç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-é¢‘è°±åˆ†æç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [é¢‘è°±åˆ†ææ¦‚è¿°](#é¢‘è°±åˆ†ææ¦‚è¿°)
  - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [é¢‘è°±åˆ†æé—®é¢˜å®šä¹‰](#é¢‘è°±åˆ†æé—®é¢˜å®šä¹‰)
    - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [ç®—æ³•åˆ†ç±»](#ç®—æ³•åˆ†ç±»)
    - [æ ¸å¿ƒæ¦‚å¿µå¯¹æ¯”](#æ ¸å¿ƒæ¦‚å¿µå¯¹æ¯”)
    - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
  - [1. åŠŸç‡è°±å¯†åº¦](#1-åŠŸç‡è°±å¯†åº¦)
    - [1.1 åŠŸç‡è°±å¯†åº¦å®šä¹‰](#11-åŠŸç‡è°±å¯†åº¦å®šä¹‰)
    - [1.2 åŠŸç‡è°±å¯†åº¦è®¡ç®—](#12-åŠŸç‡è°±å¯†åº¦è®¡ç®—)
    - [1.3 å³°å€¼é¢‘ç‡æ£€æµ‹](#13-å³°å€¼é¢‘ç‡æ£€æµ‹)
  - [2. è‡ªç›¸å…³å‡½æ•°](#2-è‡ªç›¸å…³å‡½æ•°)
    - [2.1 è‡ªç›¸å…³å‡½æ•°å®šä¹‰](#21-è‡ªç›¸å…³å‡½æ•°å®šä¹‰)
    - [2.2 è‡ªç›¸å…³å‡½æ•°è®¡ç®—](#22-è‡ªç›¸å…³å‡½æ•°è®¡ç®—)
    - [2.3 å‘¨æœŸæ€§æ£€æµ‹](#23-å‘¨æœŸæ€§æ£€æµ‹)
  - [3. é¢‘è°±ç‰¹å¾æå–](#3-é¢‘è°±ç‰¹å¾æå–)
    - [3.1 é¢‘è°±è´¨å¿ƒ](#31-é¢‘è°±è´¨å¿ƒ)
    - [3.2 é¢‘è°±å¸¦å®½](#32-é¢‘è°±å¸¦å®½)
  - [4. å®é™…åº”ç”¨æ¡ˆä¾‹](#4-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [4.1 æŒ¯åŠ¨ä¿¡å·åˆ†æ](#41-æŒ¯åŠ¨ä¿¡å·åˆ†æ)
    - [4.2 éŸ³é¢‘ä¿¡å·åˆ†æ](#42-éŸ³é¢‘ä¿¡å·åˆ†æ)
    - [4.3 æ—¶é—´åºåˆ—å‘¨æœŸæ€§æ£€æµ‹](#43-æ—¶é—´åºåˆ—å‘¨æœŸæ€§æ£€æµ‹)
    - [4.4 ä¿¡å·åˆ†ç±»](#44-ä¿¡å·åˆ†ç±»)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [ç®—æ³•ä¼˜åŒ–](#ç®—æ³•ä¼˜åŒ–)
    - [ç´¢å¼•ä¼˜åŒ–](#ç´¢å¼•ä¼˜åŒ–)
    - [ç‰©åŒ–è§†å›¾](#ç‰©åŒ–è§†å›¾)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [é‡‡æ ·ç‡é€‰æ‹©](#é‡‡æ ·ç‡é€‰æ‹©)
    - [çª—å£å¤§å°é€‰æ‹©](#çª—å£å¤§å°é€‰æ‹©)
    - [é¢‘è°±æ³„æ¼å¤„ç†](#é¢‘è°±æ³„æ¼å¤„ç†)
    - [å™ªå£°å¤„ç†](#å™ªå£°å¤„ç†)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“ˆ æ–¹æ³•å¯¹æ¯”](#-æ–¹æ³•å¯¹æ¯”)
  - [ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
    - [é—®é¢˜1ï¼šé¢‘è°±æ³„æ¼ä¸¥é‡](#é—®é¢˜1é¢‘è°±æ³„æ¼ä¸¥é‡)
    - [é—®é¢˜2ï¼šé¢‘ç‡åˆ†è¾¨ç‡ä½](#é—®é¢˜2é¢‘ç‡åˆ†è¾¨ç‡ä½)
    - [é—®é¢˜3ï¼šè®¡ç®—æ€§èƒ½æ…¢](#é—®é¢˜3è®¡ç®—æ€§èƒ½æ…¢)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)

---

## é¢‘è°±åˆ†ææ¦‚è¿°

**é¢‘è°±åˆ†æ**åˆ†æä¿¡å·çš„é¢‘ç‡æˆåˆ†å’ŒåŠŸç‡åˆ†å¸ƒï¼Œç”¨äºä¿¡å·ç‰¹å¾æå–å’Œé¢‘åŸŸåˆ†æã€‚

## ç†è®ºåŸºç¡€

### é¢‘è°±åˆ†æé—®é¢˜å®šä¹‰

é¢‘è°±åˆ†ææ˜¯å°†æ—¶åŸŸä¿¡å·è½¬æ¢åˆ°é¢‘åŸŸï¼Œåˆ†æä¿¡å·çš„é¢‘ç‡æˆåˆ†ã€åŠŸç‡åˆ†å¸ƒå’Œå‘¨æœŸæ€§ç‰¹å¾çš„è¿‡ç¨‹ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

1. **åŠŸç‡è°±å¯†åº¦ï¼ˆPSDï¼‰**ï¼š
   - å®šä¹‰ï¼š$S(\omega) = |X(\omega)|^2$
   - ç‰©ç†æ„ä¹‰ï¼šä¿¡å·åŠŸç‡åœ¨é¢‘åŸŸçš„åˆ†å¸ƒ
   - åº”ç”¨ï¼šé¢‘ç‡æˆåˆ†åˆ†æã€å™ªå£°åˆ†æ

2. **è‡ªç›¸å…³å‡½æ•°ï¼ˆACFï¼‰**ï¼š
   - å®šä¹‰ï¼š$R(\tau) = \mathbb{E}[x(t) \cdot x(t+\tau)]$
   - ç‰©ç†æ„ä¹‰ï¼šä¿¡å·ä¸å…¶è‡ªèº«çš„ç›¸å…³æ€§
   - åº”ç”¨ï¼šå‘¨æœŸæ€§æ£€æµ‹ã€ä¿¡å·ç›¸ä¼¼åº¦

3. **é¢‘è°±ç‰¹å¾**ï¼š
   - é¢‘è°±è´¨å¿ƒï¼šåŠŸç‡è°±çš„åŠ æƒå¹³å‡é¢‘ç‡
   - é¢‘è°±å¸¦å®½ï¼šåŠŸç‡è°±çš„åˆ†æ•£ç¨‹åº¦
   - å³°å€¼é¢‘ç‡ï¼šåŠŸç‡è°±çš„æœ€å¤§å€¼é¢‘ç‡

### ç®—æ³•åˆ†ç±»

1. **æŒ‰åˆ†ææ–¹æ³•åˆ†ç±»**ï¼š
   - å‘¨æœŸå›¾æ³•ï¼ˆPeriodogramï¼‰
   - Welchæ–¹æ³•ï¼ˆWelch's Methodï¼‰
   - å¤šçª—å£æ–¹æ³•ï¼ˆMultitaper Methodï¼‰
   - è‡ªç›¸å…³æ–¹æ³•ï¼ˆAutocorrelation Methodï¼‰

2. **æŒ‰å˜æ¢ç±»å‹åˆ†ç±»**ï¼š
   - DFT/FFTæ–¹æ³•
   - è‡ªç›¸å…³æ–¹æ³•
   - å‚æ•°åŒ–æ–¹æ³•ï¼ˆAR/MA/ARMAï¼‰

### æ ¸å¿ƒæ¦‚å¿µå¯¹æ¯”

| æ¦‚å¿µ | å®šä¹‰ | åº”ç”¨ | ä¼˜åŠ¿ | å±€é™æ€§ |
|------|------|------|------|--------|
| **åŠŸç‡è°±å¯†åº¦** | ä¿¡å·åŠŸç‡åœ¨é¢‘åŸŸçš„åˆ†å¸ƒ | é¢‘ç‡æˆåˆ†åˆ†æã€å™ªå£°åˆ†æ | ç›´è§‚ã€æ˜“äºç†è§£ | éœ€è¦è¶³å¤Ÿæ•°æ® |
| **è‡ªç›¸å…³å‡½æ•°** | ä¿¡å·ä¸å…¶è‡ªèº«çš„ç›¸å…³æ€§ | å‘¨æœŸæ€§æ£€æµ‹ã€ä¿¡å·ç›¸ä¼¼åº¦ | æ—¶åŸŸåˆ†æã€ç®€å• | è®¡ç®—å¤æ‚åº¦é«˜ |
| **é¢‘è°±ç‰¹å¾** | åŠŸç‡è°±çš„ç»Ÿè®¡ç‰¹å¾ | ç‰¹å¾æå–ã€åˆ†ç±» | å‹ç¼©ä¿¡æ¯ã€æ˜“äºæ¯”è¾ƒ | å¯èƒ½ä¸¢å¤±ç»†èŠ‚ |

### æŠ€æœ¯æ ˆ

- **çª—å£å‡½æ•°**ï¼šLAGã€LEADã€ROW_NUMBERã€AVGã€SUM
- **æ•°å­¦å‡½æ•°**ï¼šSINã€COSã€SQRTã€POWERã€LOG10
- **èšåˆå‡½æ•°**ï¼šSUMã€AVGã€STDDEVã€PERCENTILE_CONT
- **æ•°ç»„æ“ä½œ**ï¼šARRAY_AGGã€unnest

---

## 1. åŠŸç‡è°±å¯†åº¦

### 1.1 åŠŸç‡è°±å¯†åº¦å®šä¹‰

**åŠŸç‡è°±å¯†åº¦ï¼ˆPSDï¼‰**ï¼š
$$S(\omega) = |X(\omega)|^2 = X(\omega) \cdot X^*(\omega)$$

å…¶ä¸­ $X(\omega)$ æ˜¯ä¿¡å·çš„å‚…é‡Œå¶å˜æ¢ã€‚

### 1.2 åŠŸç‡è°±å¯†åº¦è®¡ç®—

```sql
-- ä¿¡å·æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_spectrum') THEN
            DROP TABLE signal_spectrum, dft_coefficients CASCADE;
        END IF;

        CREATE TABLE signal_spectrum (
            sample_id SERIAL PRIMARY KEY,
            sample_time TIMESTAMP NOT NULL,
            signal_value NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹ä¿¡å·ï¼ˆæ­£å¼¦æ³¢ + å™ªå£°ï¼‰
        INSERT INTO signal_spectrum (sample_time, signal_value)
        SELECT
            '2024-01-01'::TIMESTAMP + (i * INTERVAL '0.1 second'),
            SIN(i * 0.1) + 0.5 * SIN(i * 0.3) + (RANDOM() - 0.5) * 0.2
        FROM generate_series(1, 1000) i;

        -- DFTç³»æ•°è¡¨ï¼ˆç®€åŒ–ï¼šä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—DFTï¼‰
        CREATE TABLE dft_coefficients AS
        WITH signal_data AS (
            SELECT
                sample_id,
                signal_value,
                sample_id::NUMERIC / (SELECT COUNT(*) FROM signal_spectrum) AS normalized_index
            FROM signal_spectrum
        ),
        dft_calc AS (
            SELECT
                k AS frequency_bin,
                -- ç®€åŒ–çš„DFTè®¡ç®—ï¼ˆå®éƒ¨ï¼‰
                SUM(signal_value * COS(2 * PI() * k * normalized_index)) AS real_part,
                SUM(signal_value * SIN(2 * PI() * k * normalized_index)) AS imag_part
            FROM signal_data
            CROSS JOIN generate_series(0, 50) k  -- 0åˆ°50Hz
            GROUP BY k
        )
        SELECT
            frequency_bin,
            real_part,
            imag_part,
            SQRT(POWER(real_part, 2) + POWER(imag_part, 2)) AS magnitude
        FROM dft_calc;

        CREATE INDEX idx_dft_frequency ON dft_coefficients(frequency_bin);

        RAISE NOTICE 'é¢‘è°±åˆ†ææ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- åŠŸç‡è°±å¯†åº¦è®¡ç®—
WITH psd_calculation AS (
    SELECT
        frequency_bin,
        magnitude,
        POWER(magnitude, 2) AS power_spectrum,
        -- å½’ä¸€åŒ–PSD
        POWER(magnitude, 2) / (SELECT SUM(POWER(magnitude, 2)) FROM dft_coefficients) AS normalized_psd
    FROM dft_coefficients
    WHERE frequency_bin > 0  -- æ’é™¤DCåˆ†é‡
)
SELECT
    frequency_bin,
    ROUND(magnitude::numeric, 4) AS magnitude,
    ROUND(power_spectrum::numeric, 6) AS power_spectral_density,
    ROUND(normalized_psd::numeric, 6) AS normalized_psd,
    ROUND(100.0 * normalized_psd::numeric, 2) AS psd_percentage
FROM psd_calculation
ORDER BY power_spectrum DESC
LIMIT 20;
```

### 1.3 å³°å€¼é¢‘ç‡æ£€æµ‹

```sql
-- å³°å€¼é¢‘ç‡æ£€æµ‹ï¼šæ‰¾åˆ°åŠŸç‡è°±çš„ä¸»è¦é¢‘ç‡æˆåˆ†
WITH peak_detection AS (
    SELECT
        frequency_bin,
        power_spectrum,
        LAG(power_spectrum) OVER (ORDER BY frequency_bin) AS prev_power,
        LEAD(power_spectrum) OVER (ORDER BY frequency_bin) AS next_power
    FROM (
        SELECT
            frequency_bin,
            POWER(magnitude, 2) AS power_spectrum
        FROM dft_coefficients
        WHERE frequency_bin > 0
    ) psd
),
peaks AS (
    SELECT
        frequency_bin,
        power_spectrum,
        ROUND(power_spectrum::numeric, 6) AS peak_power
    FROM peak_detection
    WHERE power_spectrum > COALESCE(prev_power, 0)
      AND power_spectrum > COALESCE(next_power, 0)
      AND power_spectrum > (
          SELECT AVG(power_spectrum) + 2 * STDDEV(power_spectrum)
          FROM peak_detection
      )
)
SELECT
    frequency_bin AS peak_frequency,
    peak_power,
    ROW_NUMBER() OVER (ORDER BY peak_power DESC) AS peak_rank
FROM peaks
ORDER BY peak_power DESC
LIMIT 10;
```

---

## 2. è‡ªç›¸å…³å‡½æ•°

### 2.1 è‡ªç›¸å…³å‡½æ•°å®šä¹‰

**è‡ªç›¸å…³å‡½æ•°ï¼ˆACFï¼‰**ï¼š
$$R(\tau) = \mathbb{E}[x(t) \cdot x(t+\tau)]$$

### 2.2 è‡ªç›¸å…³å‡½æ•°è®¡ç®—

```sql
-- è‡ªç›¸å…³å‡½æ•°è®¡ç®—
WITH autocorrelation AS (
    SELECT
        lag_value,
        -- è‡ªç›¸å…³è®¡ç®—
        AVG(s1.signal_value * s2.signal_value) AS autocorr_value,
        COUNT(*) AS sample_count
    FROM signal_spectrum s1
    CROSS JOIN generate_series(0, 100) lag_value
    JOIN signal_spectrum s2 ON s2.sample_id = s1.sample_id + lag_value
    GROUP BY lag_value
),
normalized_acf AS (
    SELECT
        lag_value,
        autocorr_value,
        -- å½’ä¸€åŒ–ï¼šé™¤ä»¥é›¶å»¶è¿Ÿçš„è‡ªç›¸å…³ï¼ˆæ–¹å·®ï¼‰
        autocorr_value / NULLIF(
            (SELECT autocorr_value FROM autocorrelation WHERE lag_value = 0),
            0
        ) AS normalized_acf
    FROM autocorrelation
)
SELECT
    lag_value,
    ROUND(autocorr_value::numeric, 6) AS autocorrelation,
    ROUND(normalized_acf::numeric, 4) AS normalized_acf,
    CASE
        WHEN ABS(normalized_acf) > 0.7 THEN 'Strong correlation'
        WHEN ABS(normalized_acf) > 0.3 THEN 'Moderate correlation'
        ELSE 'Weak correlation'
    END AS correlation_strength
FROM normalized_acf
WHERE lag_value <= 50
ORDER BY lag_value;
```

### 2.3 å‘¨æœŸæ€§æ£€æµ‹

```sql
-- å‘¨æœŸæ€§æ£€æµ‹ï¼šä½¿ç”¨è‡ªç›¸å…³å‡½æ•°æ‰¾åˆ°å‘¨æœŸ
WITH autocorrelation AS (
    SELECT
        lag_value,
        AVG(s1.signal_value * s2.signal_value) AS autocorr_value
    FROM signal_spectrum s1
    CROSS JOIN generate_series(1, 200) lag_value
    JOIN signal_spectrum s2 ON s2.sample_id = s1.sample_id + lag_value
    GROUP BY lag_value
),
normalized_acf AS (
    SELECT
        lag_value,
        autocorr_value / NULLIF(
            (SELECT autocorr_value FROM autocorrelation WHERE lag_value = 0),
            0
        ) AS normalized_acf
    FROM autocorrelation
),
period_candidates AS (
    SELECT
        lag_value,
        normalized_acf,
        LAG(normalized_acf) OVER (ORDER BY lag_value) AS prev_acf,
        LEAD(normalized_acf) OVER (ORDER BY lag_value) AS next_acf
    FROM normalized_acf
    WHERE lag_value > 0
),
periods AS (
    SELECT
        lag_value AS period,
        normalized_acf AS peak_correlation
    FROM period_candidates
    WHERE normalized_acf > 0.5  -- æœ€å°ç›¸å…³æ€§é˜ˆå€¼
      AND normalized_acf > COALESCE(prev_acf, 0)
      AND normalized_acf > COALESCE(next_acf, 0)
)
SELECT
    period,
    ROUND(peak_correlation::numeric, 4) AS peak_correlation,
    'Detected period' AS period_type
FROM periods
ORDER BY peak_correlation DESC
LIMIT 5;
```

---

## 3. é¢‘è°±ç‰¹å¾æå–

### 3.1 é¢‘è°±è´¨å¿ƒ

**é¢‘è°±è´¨å¿ƒ**ï¼šåŠŸç‡è°±çš„åŠ æƒå¹³å‡é¢‘ç‡ã€‚

$$C = \frac{\sum_k k \cdot S(k)}{\sum_k S(k)}$$

```sql
-- é¢‘è°±è´¨å¿ƒè®¡ç®—
WITH spectral_centroid AS (
    SELECT
        SUM(frequency_bin * POWER(magnitude, 2)) /
        NULLIF(SUM(POWER(magnitude, 2)), 0) AS centroid_frequency
    FROM dft_coefficients
    WHERE frequency_bin > 0
)
SELECT
    ROUND(centroid_frequency::numeric, 4) AS spectral_centroid,
    CASE
        WHEN centroid_frequency < 10 THEN 'Low frequency dominant'
        WHEN centroid_frequency < 30 THEN 'Mid frequency dominant'
        ELSE 'High frequency dominant'
    END AS frequency_characteristic
FROM spectral_centroid;
```

### 3.2 é¢‘è°±å¸¦å®½

**é¢‘è°±å¸¦å®½**ï¼šåŠŸç‡è°±çš„åˆ†æ•£ç¨‹åº¦ã€‚

```sql
-- é¢‘è°±å¸¦å®½è®¡ç®—
WITH spectral_bandwidth AS (
    SELECT
        frequency_bin,
        POWER(magnitude, 2) AS power,
        (SELECT SUM(frequency_bin * POWER(magnitude, 2)) /
                NULLIF(SUM(POWER(magnitude, 2)), 0)
         FROM dft_coefficients WHERE frequency_bin > 0) AS centroid
    FROM dft_coefficients
    WHERE frequency_bin > 0
)
SELECT
    SQRT(
        SUM(POWER(frequency_bin - centroid, 2) * power) /
        NULLIF(SUM(power), 0)
    ) AS spectral_bandwidth
FROM spectral_bandwidth;
```

---

## 4. PostgreSQL 18 å¹¶è¡Œé¢‘è°±åˆ†æå¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œé¢‘è°±åˆ†æè®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡ŒåŠŸç‡è°±å¯†åº¦è®¡ç®—ã€è‡ªç›¸å…³å‡½æ•°è®¡ç®—å’Œé¢‘è°±ç‰¹å¾æå–ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡ä¿¡å·é¢‘è°±åˆ†æçš„æ€§èƒ½ã€‚

### 4.1 å¹¶è¡Œé¢‘è°±åˆ†æåŸç†

PostgreSQL 18 çš„å¹¶è¡Œé¢‘è°±åˆ†æé€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æä¿¡å·æ•°æ®
2. **å¹¶è¡ŒDFTè®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—DFT
3. **å¹¶è¡ŒåŠŸç‡è°±è®¡ç®—**ï¼šå¹¶è¡Œæ‰§è¡ŒåŠŸç‡è°±å¯†åº¦è®¡ç®—
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è®¡ç®—ç»“æœ

### 4.2 å¹¶è¡ŒåŠŸç‡è°±å¯†åº¦è®¡ç®—

```sql
-- PostgreSQL 18 å¹¶è¡ŒåŠŸç‡è°±å¯†åº¦è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vibration_signal') THEN
            RAISE WARNING 'è¡¨ vibration_signal ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒåŠŸç‡è°±å¯†åº¦è®¡ç®—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒåŠŸç‡è°±å¯†åº¦è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒåŠŸç‡è°±å¯†åº¦è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒåŠŸç‡è°±å¯†åº¦ï¼šé¢‘åŸŸåˆ†æ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH signal_info AS (
    SELECT COUNT(*) AS N FROM vibration_signal
),
dft_result AS (
    SELECT
        k AS frequency_bin,
        SUM(acceleration * COS(-2 * PI() * k * sample_id / N)) AS real_part,
        SUM(acceleration * SIN(-2 * PI() * k * sample_id / N)) AS imag_part
    FROM vibration_signal
    CROSS JOIN signal_info
    CROSS JOIN generate_series(0, N - 1) AS k
    GROUP BY k, N
),
power_spectrum AS (
    SELECT
        frequency_bin,
        POWER(SQRT(POWER(real_part, 2) + POWER(imag_part, 2)), 2) AS power_spectral_density,
        SQRT(POWER(real_part, 2) + POWER(imag_part, 2)) AS magnitude
    FROM dft_result
)
SELECT
    frequency_bin,
    ROUND(power_spectral_density::numeric, 6) AS psd,
    ROUND(magnitude::numeric, 6) AS amplitude
FROM power_spectrum
ORDER BY power_spectral_density DESC
LIMIT 50;
```

### 4.3 å¹¶è¡Œè‡ªç›¸å…³å‡½æ•°è®¡ç®—

```sql
-- PostgreSQL 18 å¹¶è¡Œè‡ªç›¸å…³å‡½æ•°è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vibration_signal') THEN
            RAISE WARNING 'è¡¨ vibration_signal ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œè‡ªç›¸å…³å‡½æ•°è®¡ç®—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œè‡ªç›¸å…³å‡½æ•°è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œè‡ªç›¸å…³å‡½æ•°è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œè‡ªç›¸å…³å‡½æ•°ï¼šå‘¨æœŸæ€§æ£€æµ‹
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH autocorrelation AS (
    SELECT
        tau,
        AVG(v1.acceleration * v2.acceleration) AS acf_value
    FROM vibration_signal v1
    CROSS JOIN vibration_signal v2
    CROSS JOIN generate_series(0, 100) AS tau
    WHERE v2.sample_id = v1.sample_id + tau
    GROUP BY tau
)
SELECT
    tau AS lag,
    ROUND(acf_value::numeric, 6) AS autocorrelation,
    CASE
        WHEN acf_value > 0.5 THEN 'Strong correlation'
        WHEN acf_value > 0.3 THEN 'Moderate correlation'
        ELSE 'Weak correlation'
    END AS correlation_strength
FROM autocorrelation
ORDER BY ABS(acf_value) DESC
LIMIT 20;
```

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 4.1 æŒ¯åŠ¨ä¿¡å·åˆ†æ

```sql
-- æŒ¯åŠ¨ä¿¡å·åˆ†æåº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        -- åˆ›å»ºæŒ¯åŠ¨ä¿¡å·æ•°æ®
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vibration_signal') THEN
            DROP TABLE vibration_signal CASCADE;
        END IF;

        CREATE TABLE vibration_signal (
            sample_id INTEGER PRIMARY KEY,
            timestamp TIMESTAMP NOT NULL,
            acceleration NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹æŒ¯åŠ¨ä¿¡å·ï¼ˆå¤šé¢‘ç‡æˆåˆ†ï¼‰
        INSERT INTO vibration_signal (sample_id, timestamp, acceleration)
        SELECT
            i,
            '2024-01-01'::TIMESTAMP + (i * INTERVAL '0.01 second'),
            SIN(i * 0.1) + 0.5 * SIN(i * 0.3) + 0.3 * SIN(i * 0.5) + (RANDOM() - 0.5) * 0.1
        FROM generate_series(1, 1000) i;

        CREATE INDEX idx_vibration_time ON vibration_signal(timestamp);

        RAISE NOTICE 'æŒ¯åŠ¨ä¿¡å·è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŒ¯åŠ¨ä¿¡å·åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æŒ¯åŠ¨ä¿¡å·é¢‘è°±åˆ†æï¼šæ£€æµ‹ä¸»è¦é¢‘ç‡æˆåˆ†
WITH dft_analysis AS (
    SELECT
        k AS frequency_bin,
        SUM(acceleration * COS(2 * PI() * k * sample_id::NUMERIC / 1000)) AS real_part,
        SUM(acceleration * SIN(2 * PI() * k * sample_id::NUMERIC / 1000)) AS imag_part
    FROM vibration_signal
    CROSS JOIN generate_series(0, 50) k
    GROUP BY k
),
power_spectrum AS (
    SELECT
        frequency_bin,
        SQRT(POWER(real_part, 2) + POWER(imag_part, 2)) AS magnitude,
        POWER(SQRT(POWER(real_part, 2) + POWER(imag_part, 2)), 2) AS power
    FROM dft_analysis
    WHERE frequency_bin > 0
),
dominant_frequencies AS (
    SELECT
        frequency_bin,
        magnitude,
        power,
        ROW_NUMBER() OVER (ORDER BY power DESC) AS frequency_rank
    FROM power_spectrum
    WHERE power > (SELECT AVG(power) + 2 * STDDEV(power) FROM power_spectrum)
)
SELECT
    frequency_bin AS dominant_frequency_hz,
    ROUND(magnitude::numeric, 4) AS magnitude,
    ROUND(power::numeric, 6) AS power,
    frequency_rank
FROM dominant_frequencies
ORDER BY frequency_rank
LIMIT 5;
```

### 4.2 éŸ³é¢‘ä¿¡å·åˆ†æ

```sql
-- éŸ³é¢‘ä¿¡å·åˆ†æåº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_spectrum') THEN
            RAISE WARNING 'è¡¨ signal_spectrum ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡ŒéŸ³é¢‘ä¿¡å·åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡ŒéŸ³é¢‘ä¿¡å·åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'éŸ³é¢‘ä¿¡å·åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- éŸ³é¢‘ä¿¡å·é¢‘è°±ç‰¹å¾æå–
WITH spectral_features AS (
    SELECT
        frequency_bin,
        POWER(magnitude, 2) AS power
    FROM dft_coefficients
    WHERE frequency_bin > 0
),
features AS (
    SELECT
        SUM(frequency_bin * power) / NULLIF(SUM(power), 0) AS spectral_centroid,
        SQRT(SUM(POWER(frequency_bin - (SUM(frequency_bin * power) / NULLIF(SUM(power), 0)), 2) * power) / NULLIF(SUM(power), 0)) AS spectral_bandwidth,
        MAX(power) AS peak_power,
        SUM(power) AS total_power
    FROM spectral_features
)
SELECT
    ROUND(spectral_centroid::numeric, 4) AS spectral_centroid_hz,
    ROUND(spectral_bandwidth::numeric, 4) AS spectral_bandwidth_hz,
    ROUND(peak_power::numeric, 6) AS peak_power,
    ROUND(total_power::numeric, 6) AS total_power,
    CASE
        WHEN spectral_centroid < 10 THEN 'Low frequency audio'
        WHEN spectral_centroid < 30 THEN 'Mid frequency audio'
        ELSE 'High frequency audio'
    END AS audio_characteristic
FROM features;
```

### 4.3 æ—¶é—´åºåˆ—å‘¨æœŸæ€§æ£€æµ‹

```sql
-- æ—¶é—´åºåˆ—å‘¨æœŸæ€§æ£€æµ‹åº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        -- åˆ›å»ºæ—¶é—´åºåˆ—æ•°æ®
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            DROP TABLE time_series_data CASCADE;
        END IF;

        CREATE TABLE time_series_data (
            time_point INTEGER PRIMARY KEY,
            value NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹æ—¶é—´åºåˆ—ï¼ˆåŒ…å«å‘¨æœŸæ€§ï¼‰
        INSERT INTO time_series_data (time_point, value)
        SELECT
            i,
            SIN(i * 2 * PI() / 20) + (RANDOM() - 0.5) * 0.2 AS value  -- å‘¨æœŸçº¦ä¸º20
        FROM generate_series(1, 500) i;

        RAISE NOTICE 'æ—¶é—´åºåˆ—æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ—¶é—´åºåˆ—å‘¨æœŸæ€§æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å‘¨æœŸæ€§æ£€æµ‹ï¼šä½¿ç”¨è‡ªç›¸å…³å‡½æ•°
WITH autocorrelation AS (
    SELECT
        lag_value,
        AVG(t1.value * t2.value) AS autocorr_value
    FROM time_series_data t1
    CROSS JOIN generate_series(1, 100) lag_value
    JOIN time_series_data t2 ON t2.time_point = t1.time_point + lag_value
    GROUP BY lag_value
),
normalized_acf AS (
    SELECT
        lag_value,
        autocorr_value / NULLIF(
            (SELECT autocorr_value FROM autocorrelation WHERE lag_value = 0),
            0
        ) AS normalized_acf
    FROM autocorrelation
),
period_candidates AS (
    SELECT
        lag_value AS period,
        normalized_acf,
        LAG(normalized_acf) OVER (ORDER BY lag_value) AS prev_acf,
        LEAD(normalized_acf) OVER (ORDER BY lag_value) AS next_acf
    FROM normalized_acf
    WHERE lag_value > 0
)
SELECT
    period,
    ROUND(normalized_acf::numeric, 4) AS correlation,
    CASE
        WHEN normalized_acf > 0.7 THEN 'Strong periodicity'
        WHEN normalized_acf > 0.5 THEN 'Moderate periodicity'
        ELSE 'Weak periodicity'
    END AS periodicity_strength
FROM period_candidates
WHERE normalized_acf > 0.5
  AND normalized_acf > COALESCE(prev_acf, 0)
  AND normalized_acf > COALESCE(next_acf, 0)
ORDER BY normalized_acf DESC
LIMIT 5;
```

### 4.4 ä¿¡å·åˆ†ç±»

```sql
-- ä¿¡å·åˆ†ç±»åº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_spectrum') THEN
            RAISE WARNING 'è¡¨ signal_spectrum ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œä¿¡å·åˆ†ç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œä¿¡å·åˆ†ç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¿¡å·åˆ†ç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä¿¡å·åˆ†ç±»ï¼šåŸºäºé¢‘è°±ç‰¹å¾
WITH spectral_features AS (
    SELECT
        frequency_bin,
        POWER(magnitude, 2) AS power
    FROM dft_coefficients
    WHERE frequency_bin > 0
),
signal_features AS (
    SELECT
        SUM(frequency_bin * power) / NULLIF(SUM(power), 0) AS centroid,
        SQRT(SUM(POWER(frequency_bin - (SUM(frequency_bin * power) / NULLIF(SUM(power), 0)), 2) * power) / NULLIF(SUM(power), 0)) AS bandwidth,
        MAX(power) AS peak_power,
        COUNT(*) FILTER (WHERE power > (SELECT AVG(power) FROM spectral_features)) AS dominant_bins
    FROM spectral_features
)
SELECT
    ROUND(centroid::numeric, 4) AS spectral_centroid,
    ROUND(bandwidth::numeric, 4) AS spectral_bandwidth,
    ROUND(peak_power::numeric, 6) AS peak_power,
    dominant_bins,
    CASE
        WHEN centroid < 5 AND bandwidth < 3 THEN 'Low frequency narrowband'
        WHEN centroid < 5 AND bandwidth >= 3 THEN 'Low frequency broadband'
        WHEN centroid < 20 AND bandwidth < 5 THEN 'Mid frequency narrowband'
        WHEN centroid < 20 AND bandwidth >= 5 THEN 'Mid frequency broadband'
        WHEN bandwidth < 5 THEN 'High frequency narrowband'
        ELSE 'High frequency broadband'
    END AS signal_type
FROM signal_features;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### ç®—æ³•ä¼˜åŒ–

1. **FFTä¼˜åŒ–**ï¼š
   - ä½¿ç”¨å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFFTï¼‰
   - åˆ©ç”¨PostgreSQLçš„å¹¶è¡ŒæŸ¥è¯¢
   - å‡å°‘å†—ä½™è®¡ç®—

2. **çª—å£å‡½æ•°ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨çª—å£å‡½æ•°å‡å°‘é¢‘è°±æ³„æ¼
   - é€‰æ‹©åˆé€‚çš„çª—å‡½æ•°ï¼ˆHammingã€Hanningã€Blackmanï¼‰
   - å¹³è¡¡é¢‘ç‡åˆ†è¾¨ç‡å’Œæ—¶é—´åˆ†è¾¨ç‡

3. **å¹¶è¡Œè®¡ç®—**ï¼š
   - å¹¶è¡Œè®¡ç®—ä¸åŒé¢‘ç‡çš„DFTç³»æ•°
   - å¹¶è¡Œå¤„ç†å¤šä¸ªä¿¡å·
   - åˆ©ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢

### ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå…³é”®ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_spectrum_time ON signal_spectrum(sample_time);
CREATE INDEX IF NOT EXISTS idx_dft_frequency ON dft_coefficients(frequency_bin);
```

### ç‰©åŒ–è§†å›¾

```sql
-- åˆ›å»ºå¸¸ç”¨é¢‘è°±åˆ†æçš„ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_power_spectrum AS
SELECT
    frequency_bin,
    POWER(magnitude, 2) AS power_spectrum
FROM dft_coefficients
WHERE frequency_bin > 0;

CREATE UNIQUE INDEX ON mv_power_spectrum(frequency_bin);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_power_spectrum;
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### é‡‡æ ·ç‡é€‰æ‹©

1. **Nyquistå‡†åˆ™**ï¼šé‡‡æ ·ç‡åº”è‡³å°‘æ˜¯ä¿¡å·æœ€é«˜é¢‘ç‡çš„2å€
2. **å®é™…åº”ç”¨**ï¼šé€šå¸¸é€‰æ‹©é‡‡æ ·ç‡ä¸ºæœ€é«˜é¢‘ç‡çš„4-10å€
3. **è®¡ç®—èµ„æº**ï¼šå¹³è¡¡é‡‡æ ·ç‡å’Œè®¡ç®—èµ„æº

### çª—å£å¤§å°é€‰æ‹©

1. **é¢‘ç‡åˆ†è¾¨ç‡**ï¼šçª—å£è¶Šå¤§ï¼Œé¢‘ç‡åˆ†è¾¨ç‡è¶Šé«˜
2. **æ—¶é—´åˆ†è¾¨ç‡**ï¼šçª—å£è¶Šå°ï¼Œæ—¶é—´åˆ†è¾¨ç‡è¶Šé«˜
3. **å¹³è¡¡**ï¼šæ ¹æ®åº”ç”¨éœ€æ±‚å¹³è¡¡é¢‘ç‡å’Œæ—¶é—´åˆ†è¾¨ç‡

### é¢‘è°±æ³„æ¼å¤„ç†

1. **çª—å‡½æ•°**ï¼šä½¿ç”¨çª—å‡½æ•°å‡å°‘é¢‘è°±æ³„æ¼
2. **é‡å **ï¼šä½¿ç”¨é‡å çª—å£æé«˜æ—¶é—´åˆ†è¾¨ç‡
3. **é›¶å¡«å……**ï¼šä½¿ç”¨é›¶å¡«å……æé«˜é¢‘ç‡åˆ†è¾¨ç‡

### å™ªå£°å¤„ç†

1. **é¢„å¤„ç†**ï¼šé¢„å¤„ç†å»é™¤å™ªå£°å½±å“
2. **å¹³æ»‘**ï¼šä½¿ç”¨å¹³æ»‘æŠ€æœ¯å‡å°‘å™ªå£°
3. **é˜ˆå€¼**ï¼šä½¿ç”¨é˜ˆå€¼è¿‡æ»¤å™ªå£°

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨DOå—è¿›è¡Œé”™è¯¯å¤„ç†
2. **NULLå€¼å¤„ç†**ï¼šä½¿ç”¨COALESCEå’ŒNULLIFå¤„ç†NULLå€¼
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ
4. **æ•°æ®ç±»å‹è½¬æ¢**ï¼šæ³¨æ„æ•°æ®ç±»å‹è½¬æ¢å’Œç²¾åº¦

---

## ğŸ“ˆ æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | é¢‘ç‡åˆ†è¾¨ç‡ | æ—¶é—´åˆ†è¾¨ç‡ | è®¡ç®—å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|-----------|-----------|---------|
| å‘¨æœŸå›¾æ³• | é«˜ | ä½ | $O(n \log n)$ | é•¿ä¿¡å·ã€é«˜é¢‘ç‡åˆ†è¾¨ç‡ |
| Welchæ–¹æ³• | ä¸­ç­‰ | ä¸­ç­‰ | $O(n \log n)$ | ä¸€èˆ¬ä¿¡å·ã€å¹³è¡¡éœ€æ±‚ |
| è‡ªç›¸å…³æ–¹æ³• | ä½ | é«˜ | $O(n^2)$ | çŸ­ä¿¡å·ã€é«˜æ—¶é—´åˆ†è¾¨ç‡ |
| å¤šçª—å£æ–¹æ³• | é«˜ | é«˜ | $O(n \log n)$ | é«˜è´¨é‡åˆ†æ |

---

## ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šé¢‘è°±æ³„æ¼ä¸¥é‡

**åŸå› **ï¼š

- æœªä½¿ç”¨çª—å‡½æ•°
- ä¿¡å·é•¿åº¦ä¸è¶³
- é¢‘ç‡ä¸åŒ¹é…

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨çª—å‡½æ•°ï¼ˆHammingã€Hanningï¼‰
- å¢åŠ ä¿¡å·é•¿åº¦
- ä½¿ç”¨é›¶å¡«å……

### é—®é¢˜2ï¼šé¢‘ç‡åˆ†è¾¨ç‡ä½

**åŸå› **ï¼š

- çª—å£å¤§å°å¤ªå°
- é‡‡æ ·ç‡ä¸è¶³
- ä¿¡å·é•¿åº¦ä¸è¶³

**è§£å†³æ–¹æ¡ˆ**ï¼š

- å¢åŠ çª—å£å¤§å°
- æé«˜é‡‡æ ·ç‡
- å¢åŠ ä¿¡å·é•¿åº¦

### é—®é¢˜3ï¼šè®¡ç®—æ€§èƒ½æ…¢

**åŸå› **ï¼š

- æ•°æ®é‡å¤§
- æœªä½¿ç”¨FFT
- æœªä½¿ç”¨å¹¶è¡Œè®¡ç®—

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨FFTåŠ é€Ÿ
- ä½¿ç”¨å¹¶è¡Œè®¡ç®—
- ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Oppenheim, A.V., Schafer, R.W. (2010)**: "Discrete-Time Signal Processing", 3rd Edition
2. **Stoica, P., Moses, R.L. (2005)**: "Spectral Analysis of Signals"
3. **Welch, P.D. (1967)**: "The Use of Fast Fourier Transform for the Estimation of Power Spectra"
4. **Harris, F.J. (1978)**: "On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform"

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
