# PostgreSQL 数字滤波算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 信号处理 | 数字滤波 | 频域滤波
> **难度级别**: ⭐⭐⭐⭐ (高级)
> **参考标准**: Digital Signal Processing, Filter Design, Signal Filtering

---

## 📋 目录

- [PostgreSQL 数字滤波算法完整指南](#postgresql-数字滤波算法完整指南)
  - [📋 目录](#-目录)
  - [数字滤波概述](#数字滤波概述)
  - [理论基础](#理论基础)
    - [数字滤波问题定义](#数字滤波问题定义)
    - [核心概念](#核心概念)
    - [算法分类](#算法分类)
    - [滤波器分类对比](#滤波器分类对比)
    - [技术栈](#技术栈)
  - [1. 移动平均滤波](#1-移动平均滤波)
    - [1.1 简单移动平均（SMA）](#11-简单移动平均sma)
    - [1.2 指数移动平均（EMA）](#12-指数移动平均ema)
  - [2. 低通滤波](#2-低通滤波)
    - [2.1 理想低通滤波](#21-理想低通滤波)
    - [2.2 Butterworth低通滤波](#22-butterworth低通滤波)
  - [3. 高通滤波](#3-高通滤波)
    - [3.1 理想高通滤波](#31-理想高通滤波)
    - [3.2 高通滤波实现](#32-高通滤波实现)
  - [4. 带通滤波](#4-带通滤波)
    - [4.1 带通滤波原理](#41-带通滤波原理)
  - [5. 滤波器性能评估](#5-滤波器性能评估)
    - [5.1 信噪比改善](#51-信噪比改善)
  - [6. PostgreSQL 18 并行数字滤波增强](#6-postgresql-18-并行数字滤波增强)
    - [6.1 并行数字滤波原理](#61-并行数字滤波原理)
    - [6.2 并行移动平均滤波](#62-并行移动平均滤波)
    - [6.3 并行低通滤波](#63-并行低通滤波)
  - [7. 实际应用案例](#7-实际应用案例)
    - [6.1 传感器数据去噪](#61-传感器数据去噪)
    - [6.2 金融数据平滑](#62-金融数据平滑)
    - [6.3 图像边缘检测（信号处理模拟）](#63-图像边缘检测信号处理模拟)
    - [6.4 信号特征提取](#64-信号特征提取)
  - [📊 性能优化建议](#-性能优化建议)
    - [算法优化](#算法优化)
    - [索引优化](#索引优化)
    - [物化视图](#物化视图)
  - [🎯 最佳实践](#-最佳实践)
    - [滤波器选择](#滤波器选择)
    - [参数调优](#参数调优)
    - [性能监控](#性能监控)
    - [结果验证](#结果验证)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 滤波器对比](#-滤波器对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：滤波后信号失真](#问题1滤波后信号失真)
    - [问题2：滤波计算慢](#问题2滤波计算慢)
    - [问题3：边界效应](#问题3边界效应)
  - [📚 参考资源](#-参考资源)

---

## 数字滤波概述

**数字滤波**用于去除信号中的噪声或提取特定频率成分。

## 理论基础

### 数字滤波问题定义

数字滤波是通过对数字信号进行数学运算，去除不需要的频率成分或噪声，保留有用信号的过程。

### 核心概念

1. **滤波器类型**：
   - **低通滤波器（LPF）**：保留低频，去除高频
   - **高通滤波器（HPF）**：保留高频，去除低频
   - **带通滤波器（BPF）**：保留特定频段
   - **带阻滤波器（BSF）**：去除特定频段

2. **滤波器实现方式**：
   - **时域滤波**：直接对时域信号进行运算
   - **频域滤波**：转换到频域进行滤波，再转换回时域

3. **滤波器特性**：
   - **频率响应**：$H(\omega)$
   - **幅度响应**：$|H(\omega)|$
   - **相位响应**：$\angle H(\omega)$

### 算法分类

1. **按实现方式分类**：
   - 移动平均滤波（时域）
   - IIR滤波器（无限脉冲响应）
   - FIR滤波器（有限脉冲响应）
   - 频域滤波（FFT-based）

2. **按频率特性分类**：
   - 低通滤波
   - 高通滤波
   - 带通滤波
   - 带阻滤波

### 滤波器分类对比

| 类型 | 功能 | 应用场景 | 优势 | 局限性 |
|------|------|---------|------|--------|
| **低通滤波** | 保留低频，去除高频 | 去噪、平滑、趋势提取 | 简单、快速 | 可能丢失高频信息 |
| **高通滤波** | 保留高频，去除低频 | 边缘检测、趋势去除、细节提取 | 保留细节信息 | 可能放大噪声 |
| **带通滤波** | 保留特定频段 | 信号提取、特征提取 | 精确频率选择 | 需要知道频率范围 |
| **带阻滤波** | 去除特定频段 | 干扰去除、陷波滤波 | 精确频率去除 | 可能影响邻近频率 |

### 技术栈

- **窗口函数**：AVG、SUM、ROW_NUMBER、LAG、LEAD
- **数学函数**：SIN、COS、SQRT、POWER、LOG10
- **数组操作**：ARRAY_AGG、unnest
- **PL/pgSQL函数**：递归函数、循环处理

---

## 1. 移动平均滤波

### 1.1 简单移动平均（SMA）

**简单移动平均**是最基本的低通滤波器。

**传递函数**：$H(z) = \frac{1}{N}\sum_{k=0}^{N-1} z^{-k}$

```sql
-- 信号数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_samples') THEN
            DROP TABLE signal_samples CASCADE;
        END IF;

        CREATE TABLE signal_samples (
            sample_id SERIAL PRIMARY KEY,
            sample_time TIMESTAMP NOT NULL,
            signal_value NUMERIC NOT NULL,
            noise_level NUMERIC DEFAULT 0.1
        );

        -- 插入示例信号（正弦波 + 噪声）
        INSERT INTO signal_samples (sample_time, signal_value)
        SELECT
            '2024-01-01'::TIMESTAMP + (i * INTERVAL '1 second'),
            SIN(i * 0.1) + (RANDOM() - 0.5) * 0.5 AS signal_value
        FROM generate_series(1, 1000) i;

        CREATE INDEX idx_signal_time ON signal_samples(sample_time);

        RAISE NOTICE '信号数据表创建成功，共 % 条记录', (SELECT COUNT(*) FROM signal_samples);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 简单移动平均滤波（窗口大小=5）
WITH sma_filtered AS (
    SELECT
        sample_id,
        sample_time,
        signal_value,
        AVG(signal_value) OVER (
            ORDER BY sample_id
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS filtered_value,
        COUNT(*) OVER (
            ORDER BY sample_id
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS window_size
    FROM signal_samples
)
SELECT
    sample_id,
    sample_time,
    ROUND(signal_value::numeric, 4) AS original_signal,
    ROUND(filtered_value::numeric, 4) AS filtered_signal,
    ROUND(ABS(signal_value - filtered_value)::numeric, 4) AS noise_reduction
FROM sma_filtered
WHERE window_size = 5  -- 完整窗口
ORDER BY sample_id
LIMIT 50;
```

### 1.2 指数移动平均（EMA）

**指数移动平均**对近期数据赋予更高权重。

**更新公式**：$EMA_t = \alpha \cdot x_t + (1-\alpha) \cdot EMA_{t-1}$

其中 $\alpha$ 是平滑因子（通常 $\alpha = 2/(N+1)$，N是窗口大小）。

```sql
-- 指数移动平均滤波
WITH ema_calculation AS (
    SELECT
        sample_id,
        signal_value,
        0.2 AS alpha,  -- 平滑因子
        -- 递归计算EMA（使用窗口函数近似）
        SUM(signal_value * POWER(1 - 0.2, ROW_NUMBER() OVER (ORDER BY sample_id DESC) - 1))
        OVER (ORDER BY sample_id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
        / SUM(POWER(1 - 0.2, ROW_NUMBER() OVER (ORDER BY sample_id DESC) - 1))
        OVER (ORDER BY sample_id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS ema_value
    FROM signal_samples
)
SELECT
    sample_id,
    ROUND(signal_value::numeric, 4) AS original,
    ROUND(ema_value::numeric, 4) AS ema_filtered
FROM ema_calculation
ORDER BY sample_id
LIMIT 50;
```

---

## 2. 低通滤波

### 2.1 理想低通滤波

**理想低通滤波**在频域中完全保留低频，去除高频。

**频率响应**：
$$
H(\omega) = \begin{cases}
1 & |\omega| \leq \omega_c \\
0 & |\omega| > \omega_c
\end{cases}
$$

### 2.2 Butterworth低通滤波

**Butterworth滤波器**具有最平坦的通带响应。

**传递函数**：$|H(\omega)|^2 = \frac{1}{1 + (\omega/\omega_c)^{2n}}$

其中 $n$ 是滤波器阶数，$\omega_c$ 是截止频率。

```sql
-- Butterworth低通滤波（简化实现）
WITH frequency_analysis AS (
    SELECT
        sample_id,
        signal_value,
        -- 计算频率（简化：假设采样频率=1Hz）
        sample_id::NUMERIC / (SELECT COUNT(*) FROM signal_samples) AS frequency
    FROM signal_samples
),
butterworth_filter AS (
    SELECT
        sample_id,
        signal_value,
        frequency,
        0.1 AS cutoff_frequency,  -- 截止频率
        2 AS filter_order,  -- 滤波器阶数
        -- Butterworth频率响应
        1.0 / SQRT(1 + POWER(frequency / 0.1, 2 * 2)) AS filter_gain
    FROM frequency_analysis
)
SELECT
    sample_id,
    ROUND(signal_value::numeric, 4) AS original,
    ROUND((signal_value * filter_gain)::numeric, 4) AS filtered,
    ROUND(filter_gain::numeric, 4) AS gain
FROM butterworth_filter
ORDER BY sample_id
LIMIT 50;
```

---

## 3. 高通滤波

### 3.1 理想高通滤波

**理想高通滤波**去除低频，保留高频。

**频率响应**：
$$
H(\omega) = \begin{cases}
0 & |\omega| \leq \omega_c \\
1 & |\omega| > \omega_c
\end{cases}
$$

### 3.2 高通滤波实现

```sql
-- 高通滤波：去除趋势，保留细节
WITH trend_removal AS (
    SELECT
        sample_id,
        signal_value,
        -- 计算趋势（使用移动平均）
        AVG(signal_value) OVER (
            ORDER BY sample_id
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS trend,
        -- 高通滤波：原始信号 - 趋势
        signal_value - AVG(signal_value) OVER (
            ORDER BY sample_id
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS highpass_filtered
    FROM signal_samples
)
SELECT
    sample_id,
    ROUND(signal_value::numeric, 4) AS original,
    ROUND(trend::numeric, 4) AS trend,
    ROUND(highpass_filtered::numeric, 4) AS highpass_signal
FROM trend_removal
ORDER BY sample_id
LIMIT 50;
```

---

## 4. 带通滤波

### 4.1 带通滤波原理

**带通滤波**只保留特定频率范围的信号。

**频率响应**：
$$
H(\omega) = \begin{cases}
1 & \omega_1 \leq |\omega| \leq \omega_2 \\
0 & \text{其他}
\end{cases}
$$

```sql
-- 带通滤波：提取特定频段
WITH bandpass_filter AS (
    SELECT
        sample_id,
        signal_value,
        sample_id::NUMERIC / (SELECT COUNT(*) FROM signal_samples) AS frequency,
        0.05 AS lower_cutoff,  -- 下截止频率
        0.15 AS upper_cutoff   -- 上截止频率
    FROM signal_samples
),
filtered_signal AS (
    SELECT
        sample_id,
        signal_value,
        frequency,
        CASE
            WHEN frequency BETWEEN lower_cutoff AND upper_cutoff THEN signal_value
            ELSE 0
        END AS bandpass_filtered
    FROM bandpass_filter
)
SELECT
    sample_id,
    ROUND(signal_value::numeric, 4) AS original,
    ROUND(bandpass_filtered::numeric, 4) AS bandpass_signal,
    ROUND(frequency::numeric, 4) AS frequency
FROM filtered_signal
WHERE bandpass_filtered != 0
ORDER BY sample_id
LIMIT 50;
```

---

## 5. 滤波器性能评估

### 5.1 信噪比改善

```sql
-- 滤波器性能评估：信噪比改善
WITH filter_performance AS (
    SELECT
        AVG(POWER(signal_value, 2)) AS original_power,
        AVG(POWER(
            signal_value - AVG(signal_value) OVER (
                ORDER BY sample_id
                ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
            ), 2
        )) AS filtered_power
    FROM signal_samples
    WHERE sample_id > 5
),
snr_improvement AS (
    SELECT
        original_power,
        filtered_power,
        10 * LOG10(original_power / NULLIF(filtered_power, 0)) AS snr_db
    FROM filter_performance
)
SELECT
    ROUND(original_power::numeric, 4) AS original_signal_power,
    ROUND(filtered_power::numeric, 4) AS filtered_signal_power,
    ROUND(snr_db::numeric, 2) AS snr_improvement_db
FROM snr_improvement;
```

---

## 6. PostgreSQL 18 并行数字滤波增强

**PostgreSQL 18** 显著增强了并行数字滤波计算能力，支持并行执行移动平均滤波、低通滤波、高通滤波和带通滤波，大幅提升大规模信号滤波的性能。

### 6.1 并行数字滤波原理

PostgreSQL 18 的并行数字滤波通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描信号数据
2. **并行滤波计算**：每个工作进程独立执行滤波操作
3. **并行频域变换**：并行执行FFT和频域滤波
4. **结果合并**：主进程合并所有工作进程的滤波结果

### 6.2 并行移动平均滤波

```sql
-- PostgreSQL 18 并行移动平均滤波（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_samples') THEN
            RAISE WARNING '表 signal_samples 不存在，无法执行并行移动平均滤波';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行移动平均滤波';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行移动平均滤波准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行移动平均：多窗口大小
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    sample_id,
    sample_time,
    price AS original_signal,
    AVG(price) OVER (
        ORDER BY sample_time
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS ma_5,
    AVG(price) OVER (
        ORDER BY sample_time
        ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
    ) AS ma_10,
    AVG(price) OVER (
        ORDER BY sample_time
        ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
    ) AS ma_20
FROM signal_samples
WHERE sample_time >= CURRENT_DATE - INTERVAL '1 day'
ORDER BY sample_time;
```

### 6.3 并行低通滤波

```sql
-- PostgreSQL 18 并行低通滤波（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_samples') THEN
            RAISE WARNING '表 signal_samples 不存在，无法执行并行低通滤波';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行低通滤波';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行低通滤波准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行低通滤波：Butterworth滤波器（简化实现）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH filtered_signal AS (
    SELECT
        sample_id,
        sample_time,
        price,
        -- 简化Butterworth低通滤波：使用指数移动平均近似
        AVG(price) OVER (
            ORDER BY sample_time
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS lowpass_filtered
    FROM signal_samples
    WHERE sample_time >= CURRENT_DATE - INTERVAL '1 day'
)
SELECT
    sample_id,
    sample_time,
    ROUND(price::numeric, 4) AS original,
    ROUND(lowpass_filtered::numeric, 4) AS filtered
FROM filtered_signal
ORDER BY sample_time;
```

---

## 7. 实际应用案例

### 6.1 传感器数据去噪

```sql
-- 传感器数据去噪应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建传感器数据表
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sensor_data') THEN
            DROP TABLE sensor_data CASCADE;
        END IF;

        CREATE TABLE sensor_data (
            sensor_id INTEGER,
            timestamp TIMESTAMP NOT NULL,
            raw_value NUMERIC NOT NULL,
            clean_value NUMERIC
        );

        -- 插入示例传感器数据（带噪声）
        INSERT INTO sensor_data (sensor_id, timestamp, raw_value)
        SELECT
            1 AS sensor_id,
            '2024-01-01'::TIMESTAMP + (i * INTERVAL '1 second'),
            10.0 + SIN(i * 0.1) + (RANDOM() - 0.5) * 0.5 AS raw_value
        FROM generate_series(1, 1000) i;

        CREATE INDEX idx_sensor_time ON sensor_data(sensor_id, timestamp);

        RAISE NOTICE '传感器数据表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '传感器数据去噪准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 传感器数据去噪：使用移动平均滤波
WITH filtered_data AS (
    SELECT
        sensor_id,
        timestamp,
        raw_value,
        AVG(raw_value) OVER (
            PARTITION BY sensor_id
            ORDER BY timestamp
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS filtered_value,
        STDDEV(raw_value) OVER (
            PARTITION BY sensor_id
            ORDER BY timestamp
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS noise_level
    FROM sensor_data
)
SELECT
    sensor_id,
    timestamp,
    ROUND(raw_value::numeric, 4) AS raw_value,
    ROUND(filtered_value::numeric, 4) AS filtered_value,
    ROUND(noise_level::numeric, 4) AS noise_level,
    ROUND(ABS(raw_value - filtered_value)::numeric, 4) AS noise_reduction
FROM filtered_data
WHERE sensor_id = 1
ORDER BY timestamp
LIMIT 50;
```

### 6.2 金融数据平滑

```sql
-- 金融数据平滑应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_samples') THEN
            RAISE WARNING '表 signal_samples 不存在，无法进行金融数据平滑';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行金融数据平滑';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '金融数据平滑准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 金融数据平滑：使用EMA滤波
WITH ema_smoothing AS (
    SELECT
        sample_id,
        sample_time,
        signal_value AS price,
        -- EMA计算（使用递归CTE）
        signal_value AS ema_short,
        AVG(signal_value) OVER (
            ORDER BY sample_id
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS ema_long
    FROM signal_samples
)
SELECT
    sample_id,
    sample_time,
    ROUND(price::numeric, 4) AS price,
    ROUND(ema_short::numeric, 4) AS ema_short_term,
    ROUND(ema_long::numeric, 4) AS ema_long_term,
    CASE
        WHEN ema_short > ema_long THEN 'Bullish'
        WHEN ema_short < ema_long THEN 'Bearish'
        ELSE 'Neutral'
    END AS trend
FROM ema_smoothing
WHERE sample_id > 20
ORDER BY sample_id
LIMIT 50;
```

### 6.3 图像边缘检测（信号处理模拟）

```sql
-- 图像边缘检测应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建图像信号数据（模拟一维图像行）
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'image_signal') THEN
            DROP TABLE image_signal CASCADE;
        END IF;

        CREATE TABLE image_signal (
            pixel_id INTEGER PRIMARY KEY,
            intensity NUMERIC NOT NULL
        );

        -- 插入示例图像信号（包含边缘）
        INSERT INTO image_signal (pixel_id, intensity)
        SELECT
            i,
            CASE
                WHEN i < 50 THEN 100.0
                WHEN i < 100 THEN 200.0
                ELSE 100.0
            END + (RANDOM() - 0.5) * 10 AS intensity
        FROM generate_series(1, 200) i;

        RAISE NOTICE '图像信号表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '图像边缘检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 边缘检测：使用高通滤波
WITH edge_detection AS (
    SELECT
        pixel_id,
        intensity,
        -- 高通滤波：去除低频（平滑部分），保留高频（边缘）
        intensity - AVG(intensity) OVER (
            ORDER BY pixel_id
            ROWS BETWEEN 5 PRECEDING AND 5 FOLLOWING
        ) AS edge_signal,
        ABS(intensity - AVG(intensity) OVER (
            ORDER BY pixel_id
            ROWS BETWEEN 5 PRECEDING AND 5 FOLLOWING
        )) AS edge_magnitude
    FROM image_signal
)
SELECT
    pixel_id,
    ROUND(intensity::numeric, 2) AS intensity,
    ROUND(edge_signal::numeric, 2) AS edge_signal,
    ROUND(edge_magnitude::numeric, 2) AS edge_magnitude,
    CASE
        WHEN edge_magnitude > 20 THEN 'Edge'
        ELSE 'Background'
    END AS edge_classification
FROM edge_detection
ORDER BY pixel_id;
```

### 6.4 信号特征提取

```sql
-- 信号特征提取应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'signal_samples') THEN
            RAISE WARNING '表 signal_samples 不存在，无法进行信号特征提取';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行信号特征提取';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '信号特征提取准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 信号特征提取：使用带通滤波提取特定频率成分
WITH bandpass_features AS (
    SELECT
        sample_id,
        signal_value,
        sample_id::NUMERIC / (SELECT COUNT(*) FROM signal_samples) AS frequency,
        -- 提取0.08-0.12 Hz频段（主要信号成分）
        CASE
            WHEN sample_id::NUMERIC / (SELECT COUNT(*) FROM signal_samples) BETWEEN 0.08 AND 0.12
            THEN signal_value
            ELSE 0
        END AS bandpass_signal
    FROM signal_samples
),
feature_stats AS (
    SELECT
        COUNT(*) FILTER (WHERE bandpass_signal != 0) AS active_samples,
        AVG(ABS(bandpass_signal)) FILTER (WHERE bandpass_signal != 0) AS avg_amplitude,
        MAX(ABS(bandpass_signal)) AS max_amplitude,
        STDDEV(bandpass_signal) FILTER (WHERE bandpass_signal != 0) AS amplitude_stddev
    FROM bandpass_features
)
SELECT
    active_samples,
    ROUND(avg_amplitude::numeric, 4) AS avg_amplitude,
    ROUND(max_amplitude::numeric, 4) AS max_amplitude,
    ROUND(amplitude_stddev::numeric, 4) AS amplitude_stddev
FROM feature_stats;
```

---

## 📊 性能优化建议

### 算法优化

1. **窗口大小选择**：
   - 平衡平滑度和响应速度
   - 根据信号特性选择窗口大小
   - 使用自适应窗口大小

2. **并行计算**：
   - 利用窗口函数的并行性
   - 并行处理多个信号
   - 使用PostgreSQL并行查询

3. **缓存优化**：
   - 使用物化视图缓存滤波结果
   - 缓存常用滤波器参数
   - 减少重复计算

### 索引优化

```sql
-- 创建关键索引
CREATE INDEX IF NOT EXISTS idx_signal_time ON signal_samples(sample_time);
CREATE INDEX IF NOT EXISTS idx_signal_id ON signal_samples(sample_id);
```

### 物化视图

```sql
-- 创建常用滤波结果的物化视图
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_filtered_signals AS
SELECT
    sample_id,
    sample_time,
    signal_value AS original_signal,
    AVG(signal_value) OVER (
        ORDER BY sample_id
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS filtered_signal
FROM signal_samples;

CREATE UNIQUE INDEX ON mv_filtered_signals(sample_id);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_filtered_signals;
```

---

## 🎯 最佳实践

### 滤波器选择

1. **移动平均滤波**：
   - 适用于简单去噪
   - 计算快速
   - 可能产生延迟

2. **EMA滤波**：
   - 适用于实时处理
   - 对近期数据敏感
   - 参数选择重要

3. **Butterworth滤波**：
   - 适用于精确频率控制
   - 频域特性好
   - 计算复杂度较高

### 参数调优

1. **窗口大小**：
   - 小窗口：响应快，平滑度差
   - 大窗口：响应慢，平滑度好
   - 根据应用需求选择

2. **截止频率**：
   - 低截止频率：保留更多低频
   - 高截止频率：保留更多高频
   - 根据信号特性选择

3. **滤波器阶数**：
   - 低阶：计算简单，过渡带宽
   - 高阶：计算复杂，过渡带窄
   - 平衡计算和性能

### 性能监控

1. **计算时间**：监控滤波计算时间
2. **内存使用**：监控内存使用情况
3. **查询性能**：使用EXPLAIN (ANALYZE, BUFFERS, TIMING)分析

### 结果验证

1. **频域分析**：使用FFT验证滤波效果
2. **信噪比**：计算信噪比改善
3. **视觉检查**：可视化对比原始和滤波信号

### SQL实现注意事项

1. **错误处理**：使用DO块进行错误处理
2. **NULL值处理**：使用COALESCE处理NULL值
3. **边界处理**：处理窗口边界情况
4. **数据类型转换**：注意数据类型转换和精度

---

## 📈 滤波器对比

| 滤波器类型 | 计算复杂度 | 平滑效果 | 响应速度 | 适用场景 |
|-----------|-----------|---------|---------|---------|
| 简单移动平均 | $O(n)$ | 中等 | 慢 | 简单去噪 |
| 指数移动平均 | $O(n)$ | 中等 | 快 | 实时处理 |
| Butterworth低通 | $O(n \log n)$ | 好 | 中等 | 精确频率控制 |
| 理想低通 | $O(n^2)$ | 最好 | 慢 | 理论分析 |

---

## 🔍 常见问题与解决方案

### 问题1：滤波后信号失真

**原因**：

- 窗口大小过大
- 截止频率选择不当
- 滤波器类型不匹配

**解决方案**：

- 减小窗口大小
- 调整截止频率
- 选择合适的滤波器类型

### 问题2：滤波计算慢

**原因**：

- 数据量大
- 窗口大小过大
- 未使用索引

**解决方案**：

- 使用物化视图缓存
- 减小窗口大小
- 创建合适的索引

### 问题3：边界效应

**原因**：

- 窗口边界处理不当
- 数据不足

**解决方案**：

- 使用对称扩展
- 使用零填充
- 处理边界情况

---

## 📚 参考资源

1. **Oppenheim, A.V., Schafer, R.W. (2010)**: "Discrete-Time Signal Processing", 3rd Edition
2. **Proakis, J.G., Manolakis, D.G. (2006)**: "Digital Signal Processing", 4th Edition
3. **Smith, S.W. (1997)**: "The Scientist and Engineer's Guide to Digital Signal Processing"
4. **Lyons, R.G. (2010)**: "Understanding Digital Signal Processing", 3rd Edition

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
