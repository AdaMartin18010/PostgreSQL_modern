# PostgreSQL å­£èŠ‚æ€§åˆ†è§£ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ—¶é—´åºåˆ— | å­£èŠ‚æ€§åˆ†è§£ | STLåˆ†è§£
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
> **å‚è€ƒæ ‡å‡†**: Seasonal Decomposition, STL Decomposition, Time Series Analysis

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å­£èŠ‚æ€§åˆ†è§£ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å­£èŠ‚æ€§åˆ†è§£ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å­£èŠ‚æ€§åˆ†è§£æ¦‚è¿°](#å­£èŠ‚æ€§åˆ†è§£æ¦‚è¿°)
    - [åˆ†è§£æ¨¡å‹](#åˆ†è§£æ¨¡å‹)
  - [1. STLåˆ†è§£](#1-stlåˆ†è§£)
    - [1.1 STLç®—æ³•åŸç†](#11-stlç®—æ³•åŸç†)
    - [1.2 STLåˆ†è§£å®ç°](#12-stlåˆ†è§£å®ç°)
    - [1.3 å­£èŠ‚æ€§å¼ºåº¦è¯„ä¼°](#13-å­£èŠ‚æ€§å¼ºåº¦è¯„ä¼°)
  - [2. ç§»åŠ¨å¹³å‡åˆ†è§£](#2-ç§»åŠ¨å¹³å‡åˆ†è§£)
    - [2.1 ç»å…¸åˆ†è§£æ–¹æ³•](#21-ç»å…¸åˆ†è§£æ–¹æ³•)
    - [2.2 ç§»åŠ¨å¹³å‡åˆ†è§£å®ç°](#22-ç§»åŠ¨å¹³å‡åˆ†è§£å®ç°)
    - [2.3 ä¹˜æ³•æ¨¡å‹åˆ†è§£](#23-ä¹˜æ³•æ¨¡å‹åˆ†è§£)
  - [3. åˆ†è§£è´¨é‡è¯„ä¼°](#3-åˆ†è§£è´¨é‡è¯„ä¼°)
    - [3.1 æ®‹å·®åˆ†æ](#31-æ®‹å·®åˆ†æ)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## å­£èŠ‚æ€§åˆ†è§£æ¦‚è¿°

**å­£èŠ‚æ€§åˆ†è§£**å°†æ—¶é—´åºåˆ—åˆ†è§£ä¸ºè¶‹åŠ¿ã€å­£èŠ‚æ€§å’Œæ®‹å·®æˆåˆ†ï¼Œç”¨äºç†è§£æ—¶é—´åºåˆ—çš„ç»“æ„ã€‚

### åˆ†è§£æ¨¡å‹

**åŠ æ³•æ¨¡å‹**ï¼š$Y_t = T_t + S_t + R_t$

**ä¹˜æ³•æ¨¡å‹**ï¼š$Y_t = T_t \times S_t \times R_t$

å…¶ä¸­ï¼š

- $T_t$ï¼šè¶‹åŠ¿æˆåˆ†
- $S_t$ï¼šå­£èŠ‚æ€§æˆåˆ†
- $R_t$ï¼šæ®‹å·®æˆåˆ†

---

## 1. STLåˆ†è§£

### 1.1 STLç®—æ³•åŸç†

**STLï¼ˆSeasonal and Trend decomposition using Loessï¼‰**ä½¿ç”¨å±€éƒ¨å›å½’è¿›è¡Œåˆ†è§£ã€‚

**ç®—æ³•æ­¥éª¤**ï¼š

1. **å»è¶‹åŠ¿**ï¼šå»é™¤è¶‹åŠ¿æˆåˆ†
2. **å­£èŠ‚æ€§å¹³æ»‘**ï¼šæå–å­£èŠ‚æ€§æˆåˆ†
3. **å»å­£èŠ‚æ€§**ï¼šå»é™¤å­£èŠ‚æ€§æˆåˆ†
4. **è¶‹åŠ¿å¹³æ»‘**ï¼šæå–è¶‹åŠ¿æˆåˆ†
5. **è¿­ä»£**ï¼šé‡å¤æ­¥éª¤1-4ç›´åˆ°æ”¶æ•›

### 1.2 STLåˆ†è§£å®ç°

```sql
-- å­£èŠ‚æ€§åˆ†è§£æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'seasonal_data') THEN
            DROP TABLE seasonal_data CASCADE;
        END IF;

        CREATE TABLE seasonal_data (
            date DATE PRIMARY KEY,
            value NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®ï¼ˆå¸¦è¶‹åŠ¿å’Œå­£èŠ‚æ€§ï¼‰
        INSERT INTO seasonal_data (date, value)
        SELECT
            '2023-01-01'::DATE + (i || ' days')::INTERVAL,
            -- è¶‹åŠ¿ï¼šçº¿æ€§å¢é•¿
            100 + i * 0.1 +
            -- å­£èŠ‚æ€§ï¼š12ä¸ªæœˆå‘¨æœŸ
            10 * SIN(2 * PI() * EXTRACT(MONTH FROM ('2023-01-01'::DATE + (i || ' days')::INTERVAL)) / 12) +
            -- å™ªå£°
            (RANDOM() - 0.5) * 2
        FROM generate_series(0, 730) i;  -- 2å¹´æ•°æ®

        CREATE INDEX idx_seasonal_date ON seasonal_data(date);

        RAISE NOTICE 'å­£èŠ‚æ€§æ•°æ®è¡¨åˆ›å»ºæˆåŠŸï¼Œå…± % æ¡è®°å½•', (SELECT COUNT(*) FROM seasonal_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- STLåˆ†è§£ï¼šæ­¥éª¤1 - è¶‹åŠ¿æå–ï¼ˆç§»åŠ¨å¹³å‡ï¼‰
WITH trend_component AS (
    SELECT
        date,
        value,
        -- ç§»åŠ¨å¹³å‡æå–è¶‹åŠ¿ï¼ˆçª—å£å¤§å°=12ï¼Œå¯¹åº”æœˆåº¦æ•°æ®ï¼‰
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ) AS trend
    FROM seasonal_data
),
detrended AS (
    SELECT
        date,
        value,
        trend,
        value - trend AS detrended_value
    FROM trend_component
),
-- STLåˆ†è§£ï¼šæ­¥éª¤2 - å­£èŠ‚æ€§æå–
seasonal_component AS (
    SELECT
        date,
        value,
        trend,
        detrended_value,
        -- å­£èŠ‚æ€§ï¼šæŒ‰æœˆä»½å¹³å‡å»è¶‹åŠ¿å€¼
        AVG(detrended_value) OVER (
            PARTITION BY EXTRACT(MONTH FROM date)
        ) AS seasonal,
        -- å­£èŠ‚æ€§è°ƒæ•´ï¼šç¡®ä¿å­£èŠ‚æ€§å‡å€¼ä¸º0
        AVG(detrended_value) OVER (
            PARTITION BY EXTRACT(MONTH FROM date)
        ) - AVG(detrended_value) OVER () AS seasonal_adjusted
    FROM detrended
),
-- STLåˆ†è§£ï¼šæ­¥éª¤3 - æ®‹å·®è®¡ç®—
residual_component AS (
    SELECT
        date,
        value,
        trend,
        seasonal_adjusted AS seasonal,
        value - trend - seasonal_adjusted AS residual
    FROM seasonal_component
)
SELECT
    date,
    EXTRACT(MONTH FROM date) AS month,
    ROUND(value::numeric, 2) AS original,
    ROUND(trend::numeric, 2) AS trend,
    ROUND(seasonal::numeric, 2) AS seasonal,
    ROUND(residual::numeric, 2) AS residual,
    -- éªŒè¯ï¼šåŸå§‹å€¼ = è¶‹åŠ¿ + å­£èŠ‚æ€§ + æ®‹å·®
    ROUND(ABS(value - (trend + seasonal + residual))::numeric, 4) AS decomposition_error
FROM residual_component
ORDER BY date
LIMIT 50;
```

### 1.3 å­£èŠ‚æ€§å¼ºåº¦è¯„ä¼°

```sql
-- å­£èŠ‚æ€§å¼ºåº¦ï¼šè¯„ä¼°å­£èŠ‚æ€§çš„é‡è¦æ€§
WITH decomposition AS (
    SELECT
        date,
        value,
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ) AS trend,
        AVG(value - AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        )) OVER (
            PARTITION BY EXTRACT(MONTH FROM date)
        ) - AVG(value - AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        )) OVER () AS seasonal
    FROM seasonal_data
),
seasonal_strength AS (
    SELECT
        VAR_POP(seasonal) AS seasonal_variance,
        VAR_POP(value - trend - seasonal) AS residual_variance,
        VAR_POP(value) AS total_variance
    FROM decomposition
)
SELECT
    ROUND(seasonal_variance::numeric, 4) AS seasonal_variance,
    ROUND(residual_variance::numeric, 4) AS residual_variance,
    ROUND(total_variance::numeric, 4) AS total_variance,
    ROUND((seasonal_variance / NULLIF(total_variance, 0))::numeric, 4) AS seasonal_strength,
    CASE
        WHEN (seasonal_variance / NULLIF(total_variance, 0)) > 0.5 THEN 'Strong seasonality'
        WHEN (seasonal_variance / NULLIF(total_variance, 0)) > 0.2 THEN 'Moderate seasonality'
        ELSE 'Weak seasonality'
    END AS seasonality_assessment
FROM seasonal_strength;
```

---

## 2. ç§»åŠ¨å¹³å‡åˆ†è§£

### 2.1 ç»å…¸åˆ†è§£æ–¹æ³•

**ç»å…¸åˆ†è§£**ä½¿ç”¨ç§»åŠ¨å¹³å‡æå–è¶‹åŠ¿å’Œå­£èŠ‚æ€§ã€‚

**æ­¥éª¤**ï¼š

1. è®¡ç®—ç§»åŠ¨å¹³å‡æå–è¶‹åŠ¿
2. ä»åŸå§‹åºåˆ—å‡å»è¶‹åŠ¿å¾—åˆ°å»è¶‹åŠ¿åºåˆ—
3. æŒ‰å­£èŠ‚å¹³å‡å»è¶‹åŠ¿åºåˆ—å¾—åˆ°å­£èŠ‚æ€§
4. æ®‹å·® = åŸå§‹ - è¶‹åŠ¿ - å­£èŠ‚æ€§

### 2.2 ç§»åŠ¨å¹³å‡åˆ†è§£å®ç°

```sql
-- ç§»åŠ¨å¹³å‡åˆ†è§£ï¼šç»å…¸æ–¹æ³•
WITH ma_trend AS (
    SELECT
        date,
        value,
        -- ä¸­å¿ƒç§»åŠ¨å¹³å‡ï¼ˆçª—å£å¤§å°=12ï¼‰
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ) AS ma_trend
    FROM seasonal_data
),
classical_seasonal AS (
    SELECT
        date,
        value,
        ma_trend,
        value - ma_trend AS detrended,
        -- å­£èŠ‚æ€§ï¼šæŒ‰æœˆä»½å¹³å‡
        AVG(value - ma_trend) OVER (
            PARTITION BY EXTRACT(MONTH FROM date)
        ) AS seasonal_raw
    FROM ma_trend
),
seasonal_adjusted AS (
    SELECT
        date,
        value,
        ma_trend AS trend,
        seasonal_raw - AVG(seasonal_raw) OVER () AS seasonal,
        value - ma_trend - (seasonal_raw - AVG(seasonal_raw) OVER ()) AS residual
    FROM classical_seasonal
)
SELECT
    date,
    EXTRACT(MONTH FROM date) AS month,
    ROUND(value::numeric, 2) AS original,
    ROUND(trend::numeric, 2) AS trend,
    ROUND(seasonal::numeric, 2) AS seasonal,
    ROUND(residual::numeric, 2) AS residual
FROM seasonal_adjusted
ORDER BY date
LIMIT 50;
```

### 2.3 ä¹˜æ³•æ¨¡å‹åˆ†è§£

```sql
-- ä¹˜æ³•æ¨¡å‹åˆ†è§£ï¼šY = T Ã— S Ã— R
WITH multiplicative_decomposition AS (
    SELECT
        date,
        value,
        -- è¶‹åŠ¿ï¼ˆä½¿ç”¨ç§»åŠ¨å¹³å‡ï¼‰
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ) AS trend,
        -- å»è¶‹åŠ¿åºåˆ—
        value / NULLIF(AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ), 0) AS detrended_ratio
    FROM seasonal_data
    WHERE value > 0  -- ç¡®ä¿æ­£å€¼
),
multiplicative_seasonal AS (
    SELECT
        date,
        value,
        trend,
        -- å­£èŠ‚æ€§æ¯”ç‡
        AVG(detrended_ratio) OVER (
            PARTITION BY EXTRACT(MONTH FROM date)
        ) AS seasonal_ratio,
        -- æ®‹å·®æ¯”ç‡
        detrended_ratio / NULLIF(
            AVG(detrended_ratio) OVER (
                PARTITION BY EXTRACT(MONTH FROM date)
            ),
            0
        ) AS residual_ratio
    FROM multiplicative_decomposition
)
SELECT
    date,
    ROUND(value::numeric, 2) AS original,
    ROUND(trend::numeric, 2) AS trend,
    ROUND(seasonal_ratio::numeric, 4) AS seasonal_ratio,
    ROUND(residual_ratio::numeric, 4) AS residual_ratio,
    -- éªŒè¯ï¼šåŸå§‹å€¼ â‰ˆ è¶‹åŠ¿ Ã— å­£èŠ‚æ€§æ¯”ç‡ Ã— æ®‹å·®æ¯”ç‡
    ROUND(ABS(value - (trend * seasonal_ratio * residual_ratio))::numeric, 4) AS decomposition_error
FROM multiplicative_seasonal
ORDER BY date
LIMIT 50;
```

---

## 3. åˆ†è§£è´¨é‡è¯„ä¼°

### 3.1 æ®‹å·®åˆ†æ

```sql
-- æ®‹å·®åˆ†æï¼šæ£€æŸ¥åˆ†è§£è´¨é‡
WITH decomposition AS (
    SELECT
        date,
        value,
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ) AS trend,
        AVG(value - AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        )) OVER (
            PARTITION BY EXTRACT(MONTH FROM date)
        ) - AVG(value - AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        )) OVER () AS seasonal
    FROM seasonal_data
),
residuals AS (
    SELECT
        value - trend - seasonal AS residual
    FROM decomposition
)
SELECT
    COUNT(*) AS sample_count,
    ROUND(AVG(residual)::numeric, 6) AS mean_residual,
    ROUND(STDDEV(residual)::numeric, 4) AS std_residual,
    ROUND(MIN(residual)::numeric, 2) AS min_residual,
    ROUND(MAX(residual)::numeric, 2) AS max_residual,
    CASE
        WHEN ABS(AVG(residual)) < 0.01 AND STDDEV(residual) < STDDEV(value) * 0.1
        THEN 'Good decomposition'
        ELSE 'Poor decomposition'
    END AS quality_assessment
FROM residuals
CROSS JOIN (SELECT STDDEV(value) AS value_std FROM seasonal_data) stats;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Cleveland, R.B., et al. (1990)**: "STL: A Seasonal-Trend Decomposition Procedure Based on Loess"
2. **Hyndman, R.J., Athanasopoulos, G. (2021)**: "Forecasting: Principles and Practice", 3rd Edition

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **çª—å£å¤§å°**ï¼šæ ¹æ®æ•°æ®é¢‘ç‡é€‰æ‹©åˆé€‚çª—å£å¤§å°
2. **è¿­ä»£æ¬¡æ•°**ï¼šSTLåˆ†è§£éœ€è¦å¤šæ¬¡è¿­ä»£
3. **å¹¶è¡Œè®¡ç®—**ï¼šå¹¶è¡Œå¤„ç†å¤šä¸ªæ—¶é—´åºåˆ—
4. **ç¼“å­˜ç»“æœ**ï¼šç¼“å­˜åˆ†è§£ç»“æœé¿å…é‡å¤è®¡ç®—

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **æ¨¡å‹é€‰æ‹©**ï¼šæ ¹æ®æ•°æ®ç‰¹æ€§é€‰æ‹©åŠ æ³•æˆ–ä¹˜æ³•æ¨¡å‹
2. **å­£èŠ‚æ€§å‘¨æœŸ**ï¼šæ­£ç¡®è¯†åˆ«å­£èŠ‚æ€§å‘¨æœŸ
3. **è¶‹åŠ¿å¤„ç†**ï¼šå¤„ç†éçº¿æ€§è¶‹åŠ¿
4. **æ®‹å·®æ£€æŸ¥**ï¼šæ£€æŸ¥æ®‹å·®æ˜¯å¦éšæœº

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
