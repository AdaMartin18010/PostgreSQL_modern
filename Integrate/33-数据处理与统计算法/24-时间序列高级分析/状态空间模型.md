# PostgreSQL çŠ¶æ€ç©ºé—´æ¨¡å‹å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ—¶é—´åºåˆ— | çŠ¶æ€ç©ºé—´ | Kalmanæ»¤æ³¢
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: State Space Models, Kalman Filtering, Time Series Analysis

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL çŠ¶æ€ç©ºé—´æ¨¡å‹å®Œæ•´æŒ‡å—](#postgresql-çŠ¶æ€ç©ºé—´æ¨¡å‹å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [çŠ¶æ€ç©ºé—´æ¨¡å‹æ¦‚è¿°](#çŠ¶æ€ç©ºé—´æ¨¡å‹æ¦‚è¿°)
  - [1. Kalmanæ»¤æ³¢](#1-kalmanæ»¤æ³¢)

---

## çŠ¶æ€ç©ºé—´æ¨¡å‹æ¦‚è¿°

**çŠ¶æ€ç©ºé—´æ¨¡å‹**æè¿°ç³»ç»Ÿçš„çŠ¶æ€æ¼”åŒ–è¿‡ç¨‹ã€‚

**çŠ¶æ€æ–¹ç¨‹**: $x_t = F x_{t-1} + w_t$
**è§‚æµ‹æ–¹ç¨‹**: $y_t = H x_t + v_t$

---

## 1. Kalmanæ»¤æ³¢

**Kalmanæ»¤æ³¢**ç”¨äºä¼°è®¡ç³»ç»ŸçŠ¶æ€ã€‚

```sql
-- Kalmanæ»¤æ³¢å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'kalman_data') THEN
            DROP TABLE kalman_data CASCADE;
        END IF;

        CREATE TABLE kalman_data (
            time_point INTEGER PRIMARY KEY,
            observation NUMERIC NOT NULL
        );

        INSERT INTO kalman_data (time_point, observation) VALUES
            (1, 10.1), (2, 10.2), (3, 10.0), (4, 10.3);

        RAISE NOTICE 'è¡¨ kalman_data åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Kalmanæ»¤æ³¢é¢„æµ‹å’Œæ›´æ–°
WITH kalman_state AS (
    SELECT
        time_point,
        observation,
        -- é¢„æµ‹æ­¥éª¤
        LAG(state_estimate) OVER (ORDER BY time_point) AS predicted_state,
        -- æ›´æ–°æ­¥éª¤
        predicted_state + kalman_gain * (observation - predicted_state) AS updated_state
    FROM kalman_data
    CROSS JOIN (
        SELECT 0.5 AS kalman_gain
    ) kg
)
SELECT
    time_point,
    ROUND(observation::numeric, 2) AS observation,
    ROUND(updated_state::numeric, 2) AS state_estimate
FROM kalman_state
ORDER BY time_point;
```

### 1.1 Kalmanæ»¤æ³¢åŸç†

**Kalmanæ»¤æ³¢**é€šè¿‡é¢„æµ‹å’Œæ›´æ–°ä¸¤ä¸ªæ­¥éª¤ä¼°è®¡ç³»ç»ŸçŠ¶æ€ã€‚

**é¢„æµ‹æ­¥éª¤**ï¼š
$$\hat{x}_{t|t-1} = F \hat{x}_{t-1|t-1}$$
$$P_{t|t-1} = F P_{t-1|t-1} F^T + Q$$

**æ›´æ–°æ­¥éª¤**ï¼š
$$K_t = P_{t|t-1} H^T (H P_{t|t-1} H^T + R)^{-1}$$
$$\hat{x}_{t|t} = \hat{x}_{t|t-1} + K_t (y_t - H \hat{x}_{t|t-1})$$
$$P_{t|t} = (I - K_t H) P_{t|t-1}$$

å…¶ä¸­ï¼š

- $F$ï¼šçŠ¶æ€è½¬ç§»çŸ©é˜µ
- $H$ï¼šè§‚æµ‹çŸ©é˜µ
- $Q$ï¼šè¿‡ç¨‹å™ªå£°åæ–¹å·®
- $R$ï¼šè§‚æµ‹å™ªå£°åæ–¹å·®
- $K_t$ï¼šKalmanå¢ç›Š

### 1.2 Kalmanæ»¤æ³¢å®ç°

```sql
-- å®Œæ•´çš„Kalmanæ»¤æ³¢å®ç°
WITH kalman_parameters AS (
    SELECT
        1.0 AS F,  -- çŠ¶æ€è½¬ç§»çŸ©é˜µï¼ˆæ ‡é‡ï¼‰
        1.0 AS H,  -- è§‚æµ‹çŸ©é˜µï¼ˆæ ‡é‡ï¼‰
        0.1 AS Q,  -- è¿‡ç¨‹å™ªå£°æ–¹å·®
        0.5 AS R   -- è§‚æµ‹å™ªå£°æ–¹å·®
    FROM generate_series(1, 1)
),
kalman_iteration AS (
    SELECT
        kd.time_point,
        kd.observation,
        kp.F,
        kp.H,
        kp.Q,
        kp.R,
        -- åˆå§‹çŠ¶æ€
        CASE WHEN kd.time_point = 1 THEN kd.observation ELSE NULL END AS initial_state,
        -- åˆå§‹åæ–¹å·®
        CASE WHEN kd.time_point = 1 THEN kp.R ELSE NULL END AS initial_covariance
    FROM kalman_data kd
    CROSS JOIN kalman_parameters kp
),
kalman_filter AS (
    SELECT
        time_point,
        observation,
        -- é¢„æµ‹çŠ¶æ€
        LAG(state_estimate) OVER (ORDER BY time_point) * F AS predicted_state,
        -- é¢„æµ‹åæ–¹å·®
        LAG(state_covariance) OVER (ORDER BY time_point) * F * F + Q AS predicted_covariance,
        -- Kalmanå¢ç›Š
        (LAG(state_covariance) OVER (ORDER BY time_point) * F * F + Q) * H /
        ((LAG(state_covariance) OVER (ORDER BY time_point) * F * F + Q) * H * H + R) AS kalman_gain,
        -- æ›´æ–°çŠ¶æ€
        (LAG(state_estimate) OVER (ORDER BY time_point) * F) +
        ((LAG(state_covariance) OVER (ORDER BY time_point) * F * F + Q) * H /
         ((LAG(state_covariance) OVER (ORDER BY time_point) * F * F + Q) * H * H + R)) *
        (observation - LAG(state_estimate) OVER (ORDER BY time_point) * F * H) AS state_estimate
    FROM kalman_iteration
    CROSS JOIN kalman_parameters
)
SELECT
    time_point,
    ROUND(observation::numeric, 2) AS observation,
    ROUND(state_estimate::numeric, 2) AS filtered_state
FROM kalman_filter
ORDER BY time_point;
```

---

## 2. çŠ¶æ€ç©ºé—´æ¨¡å‹åº”ç”¨

### 2.1 æ—¶é—´åºåˆ—å¹³æ»‘

```sql
-- ä½¿ç”¨Kalmanæ»¤æ³¢è¿›è¡Œæ—¶é—´åºåˆ—å¹³æ»‘
WITH smoothed_series AS (
    SELECT
        time_point,
        observation,
        state_estimate AS smoothed_value
    FROM kalman_filter
)
SELECT
    time_point,
    ROUND(observation::numeric, 2) AS original_value,
    ROUND(smoothed_value::numeric, 2) AS smoothed_value,
    ROUND(ABS(observation - smoothed_value)::numeric, 2) AS smoothing_error
FROM smoothed_series
ORDER BY time_point;
```

### 2.2 çŠ¶æ€ä¼°è®¡

```sql
-- çŠ¶æ€ä¼°è®¡åº”ç”¨
WITH state_estimation AS (
    SELECT
        time_point,
        observation,
        state_estimate,
        state_covariance,
        SQRT(state_covariance) AS state_std_error
    FROM kalman_filter
)
SELECT
    time_point,
    ROUND(state_estimate::numeric, 2) AS estimated_state,
    ROUND(state_std_error::numeric, 2) AS std_error,
    ROUND((state_estimate - 1.96 * state_std_error)::numeric, 2) AS lower_bound,
    ROUND((state_estimate + 1.96 * state_std_error)::numeric, 2) AS upper_bound
FROM state_estimation
ORDER BY time_point;
```

---

## 3. å®é™…åº”ç”¨æ¡ˆä¾‹

### 3.1 GPSå®šä½

```sql
-- GPSå®šä½åº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'gps_measurements') THEN
            CREATE TABLE gps_measurements (
                time_point INTEGER PRIMARY KEY,
                measured_position NUMERIC NOT NULL,
                true_position NUMERIC NOT NULL
            );

            -- æ’å…¥GPSæµ‹é‡æ•°æ®
            INSERT INTO gps_measurements (time_point, measured_position, true_position) VALUES
                (1, 10.1, 10.0),
                (2, 10.2, 10.0),
                (3, 9.9, 10.0),
                (4, 10.1, 10.0);

            RAISE NOTICE 'GPSæµ‹é‡æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'GPSå®šä½åº”ç”¨å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Kalmanæ»¤æ³¢GPSå®šä½
WITH gps_kalman AS (
    SELECT
        time_point,
        measured_position,
        true_position,
        -- Kalmanæ»¤æ³¢ä½ç½®ä¼°è®¡
        state_estimate AS filtered_position
    FROM kalman_filter
    JOIN gps_measurements USING (time_point)
)
SELECT
    time_point,
    ROUND(measured_position::numeric, 2) AS measured_pos,
    ROUND(true_position::numeric, 2) AS true_pos,
    ROUND(filtered_position::numeric, 2) AS filtered_pos,
    ROUND(ABS(measured_position - true_position)::numeric, 2) AS measurement_error,
    ROUND(ABS(filtered_position - true_position)::numeric, 2) AS filtered_error
FROM gps_kalman
ORDER BY time_point;
```

### 3.2 è‚¡ç¥¨ä»·æ ¼é¢„æµ‹

```sql
-- è‚¡ç¥¨ä»·æ ¼é¢„æµ‹åº”ç”¨
WITH stock_kalman AS (
    SELECT
        date,
        price AS observed_price,
        state_estimate AS predicted_price
    FROM kalman_filter
    JOIN stock_prices USING (time_point)
)
SELECT
    date,
    ROUND(observed_price::numeric, 2) AS observed_price,
    ROUND(predicted_price::numeric, 2) AS predicted_price,
    ROUND((predicted_price - observed_price)::numeric, 2) AS prediction_error
FROM stock_kalman
ORDER BY date;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### çŸ©é˜µè¿ç®—ä¼˜åŒ–

```sql
-- ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜Kalmanå‚æ•°
CREATE MATERIALIZED VIEW IF NOT EXISTS kalman_parameters_cache AS
SELECT
    F,
    H,
    Q,
    R
FROM kalman_model_parameters
WHERE model_id = (SELECT model_id FROM best_kalman_model);

REFRESH MATERIALIZED VIEW CONCURRENTLY kalman_parameters_cache;
```

### å¹¶è¡Œè®¡ç®—

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;
```

### ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºæ—¶é—´ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_kalman_time ON kalman_data(time_point);
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### å‚æ•°é€‰æ‹©

1. **è¿‡ç¨‹å™ªå£°Q**: åæ˜ çŠ¶æ€å˜åŒ–çš„ä¸ç¡®å®šæ€§
2. **è§‚æµ‹å™ªå£°R**: åæ˜ è§‚æµ‹è¯¯å·®
3. **åˆå§‹çŠ¶æ€**: ä½¿ç”¨ç¬¬ä¸€ä¸ªè§‚æµ‹å€¼æˆ–å…ˆéªŒçŸ¥è¯†

### æ¨¡å‹è¯Šæ–­

1. **æ®‹å·®åˆ†æ**: æ£€æŸ¥æ®‹å·®æ˜¯å¦ç™½å™ªå£°
2. **é¢„æµ‹è¯¯å·®**: è¯„ä¼°é¢„æµ‹ç²¾åº¦
3. **æ”¶æ•›æ€§**: æ£€æŸ¥çŠ¶æ€ä¼°è®¡æ˜¯å¦æ”¶æ•›

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**: ä½¿ç”¨DOå—å’ŒEXCEPTIONè¿›è¡Œé”™è¯¯å¤„ç†
2. **æ•°å€¼ç¨³å®šæ€§**: æ³¨æ„çŸ©é˜µè¿ç®—çš„ç²¾åº¦
3. **æ€§èƒ½ä¼˜åŒ–**: ä½¿ç”¨ç´¢å¼•å’Œç‰©åŒ–è§†å›¾ä¼˜åŒ–æ€§èƒ½

---

## ğŸ“ˆ Kalmanæ»¤æ³¢ vs å…¶ä»–æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **Kalmanæ»¤æ³¢** | æœ€ä¼˜çº¿æ€§ä¼°è®¡ | éœ€è¦çº¿æ€§å‡è®¾ | çº¿æ€§ç³»ç»Ÿ |
| **ç²’å­æ»¤æ³¢** | å¤„ç†éçº¿æ€§ | è®¡ç®—é‡å¤§ | éçº¿æ€§ç³»ç»Ÿ |
| **ç§»åŠ¨å¹³å‡** | ç®€å• | æ»å | ç®€å•å¹³æ»‘ |

---

## ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šæ»¤æ³¢å‘æ•£

**åŸå› **ï¼š

- è¿‡ç¨‹å™ªå£°Qè¿‡å°
- è§‚æµ‹å™ªå£°Rè¿‡å¤§
- æ¨¡å‹ä¸åŒ¹é…

**è§£å†³æ–¹æ¡ˆ**ï¼š

- è°ƒæ•´Qå’ŒRå‚æ•°
- æ£€æŸ¥æ¨¡å‹å‡è®¾
- ä½¿ç”¨è‡ªé€‚åº”Kalmanæ»¤æ³¢

### é—®é¢˜2ï¼šè®¡ç®—å¤æ‚åº¦é«˜

**åŸå› **ï¼š

- çŠ¶æ€ç»´åº¦é«˜
- çŸ©é˜µè¿ç®—å¤š
- æœªä½¿ç”¨ä¼˜åŒ–

**è§£å†³æ–¹æ¡ˆ**ï¼š

- é™ä½çŠ¶æ€ç»´åº¦
- ä½¿ç”¨ç¨€ç–çŸ©é˜µ
- å¹¶è¡Œè®¡ç®—

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Kalman, R.E. (1960)**: "A New Approach to Linear Filtering and Prediction Problems", Journal of Basic Engineering, 82(1), 35-45
2. **Harvey, A.C. (1989)**: "Forecasting, Structural Time Series Models and the Kalman Filter", Cambridge University Press
3. **Durbin, J., Koopman, S.J. (2012)**: "Time Series Analysis by State Space Methods", 2nd Edition, Oxford University Press

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
