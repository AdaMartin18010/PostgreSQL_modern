# PostgreSQL åæ•´åˆ†æç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ—¶é—´åºåˆ— | åæ•´åˆ†æ | å•ä½æ ¹æ£€éªŒ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Cointegration Analysis, Engle-Granger Test, Johansen Test

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL åæ•´åˆ†æç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-åæ•´åˆ†æç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [åæ•´åˆ†ææ¦‚è¿°](#åæ•´åˆ†ææ¦‚è¿°)
    - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
  - [1. Engle-Grangeræ£€éªŒ](#1-engle-grangeræ£€éªŒ)
    - [1.1 Engle-Grangerä¸¤æ­¥æ³•](#11-engle-grangerä¸¤æ­¥æ³•)
    - [1.2 Engle-Grangerå®ç°](#12-engle-grangerå®ç°)
  - [2. Johansenæ£€éªŒ](#2-johansenæ£€éªŒ)
    - [2.1 Johansenæ£€éªŒåŸç†](#21-johansenæ£€éªŒåŸç†)
    - [2.2 Johansenæ£€éªŒå®ç°](#22-johansenæ£€éªŒå®ç°)
  - [3. è¯¯å·®ä¿®æ­£æ¨¡å‹ï¼ˆECMï¼‰](#3-è¯¯å·®ä¿®æ­£æ¨¡å‹ecm)
    - [3.1 ECMåŸç†](#31-ecmåŸç†)
    - [3.2 ECMå®ç°](#32-ecmå®ç°)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## åæ•´åˆ†ææ¦‚è¿°

**åæ•´**æè¿°éå¹³ç¨³æ—¶é—´åºåˆ—ä¹‹é—´çš„é•¿æœŸå‡è¡¡å…³ç³»ï¼Œæ˜¯æ—¶é—´åºåˆ—åˆ†æçš„é‡è¦å·¥å…·ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

**åæ•´å®šä¹‰**ï¼šå¦‚æœä¸¤ä¸ªéå¹³ç¨³åºåˆ—çš„çº¿æ€§ç»„åˆæ˜¯å¹³ç¨³çš„ï¼Œåˆ™å®ƒä»¬åæ•´ã€‚

**åæ•´å‘é‡**ï¼š$\beta$ ä½¿å¾— $y_t - \beta x_t$ æ˜¯å¹³ç¨³çš„ã€‚

### åº”ç”¨åœºæ™¯

| åº”ç”¨é¢†åŸŸ | å…·ä½“åº”ç”¨ |
|---------|---------|
| **é‡‘è** | é…å¯¹äº¤æ˜“ã€å¥—åˆ©ç­–ç•¥ |
| **ç»æµ** | é•¿æœŸå‡è¡¡å…³ç³»åˆ†æ |
| **èƒ½æº** | ä»·æ ¼å…³ç³»åˆ†æ |

---

## 1. Engle-Grangeræ£€éªŒ

### 1.1 Engle-Grangerä¸¤æ­¥æ³•

**Engle-Grangerä¸¤æ­¥æ³•**ï¼š

1. **ç¬¬ä¸€æ­¥**ï¼šä¼°è®¡åæ•´å…³ç³» $y_t = \alpha + \beta x_t + \epsilon_t$
2. **ç¬¬äºŒæ­¥**ï¼šæ£€éªŒæ®‹å·® $\epsilon_t$ çš„å¹³ç¨³æ€§ï¼ˆADFæ£€éªŒï¼‰

### 1.2 Engle-Grangerå®ç°

```sql
-- åæ•´åˆ†ææ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'cointegration_data') THEN
            DROP TABLE cointegration_data CASCADE;
        END IF;

        CREATE TABLE cointegration_data (
            date DATE PRIMARY KEY,
            series1 NUMERIC NOT NULL,
            series2 NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®ï¼ˆä¸¤ä¸ªåæ•´çš„æ—¶é—´åºåˆ—ï¼‰
        INSERT INTO cointegration_data (date, series1, series2)
        SELECT
            '2020-01-01'::DATE + (i || ' days')::INTERVAL,
            -- series1: éšæœºæ¸¸èµ° + è¶‹åŠ¿
            100 + i * 0.1 + SUM((RANDOM() - 0.5) * 2) OVER (ORDER BY i),
            -- series2: series1çš„çº¿æ€§å˜æ¢ + å¹³ç¨³è¯¯å·®
            (100 + i * 0.1 + SUM((RANDOM() - 0.5) * 2) OVER (ORDER BY i)) * 2 + (RANDOM() - 0.5) * 0.5
        FROM generate_series(1, 1000) i;

        CREATE INDEX idx_cointegration_date ON cointegration_data(date);

        RAISE NOTICE 'åæ•´æ•°æ®è¡¨åˆ›å»ºæˆåŠŸï¼Œå…± % æ¡è®°å½•', (SELECT COUNT(*) FROM cointegration_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Engle-Grangeræ£€éªŒï¼šç¬¬ä¸€æ­¥ - ä¼°è®¡åæ•´å…³ç³»
WITH regression_coefficients AS (
    SELECT
        -- ä½¿ç”¨æœ€å°äºŒä¹˜æ³•ä¼°è®¡ç³»æ•°
        REGR_SLOPE(series1, series2) AS beta,
        REGR_INTERCEPT(series1, series2) AS alpha,
        REGR_R2(series1, series2) AS r_squared
    FROM cointegration_data
),
regression_residuals AS (
    SELECT
        cd.date,
        cd.series1,
        cd.series2,
        cd.series1 - (rc.alpha + rc.beta * cd.series2) AS residual
    FROM cointegration_data cd
    CROSS JOIN regression_coefficients rc
)
SELECT
    ROUND(alpha::numeric, 4) AS intercept,
    ROUND(beta::numeric, 4) AS slope,
    ROUND(r_squared::numeric, 4) AS r_squared
FROM regression_coefficients;

-- Engle-Grangeræ£€éªŒï¼šç¬¬äºŒæ­¥ - ADFæ£€éªŒæ®‹å·®
WITH regression_coefficients AS (
    SELECT
        REGR_SLOPE(series1, series2) AS beta,
        REGR_INTERCEPT(series1, series2) AS alpha
    FROM cointegration_data
),
residuals AS (
    SELECT
        date,
        series1 - (alpha + beta * series2) AS residual
    FROM cointegration_data
    CROSS JOIN regression_coefficients
),
adf_regression AS (
    SELECT
        -- ADFæ£€éªŒï¼šæ®‹å·®å¯¹æ»åæ®‹å·®å›å½’
        REGR_SLOPE(residual, LAG(residual) OVER (ORDER BY date)) AS rho,
        REGR_INTERCEPT(residual, LAG(residual) OVER (ORDER BY date)) AS intercept,
        COUNT(*) AS n
    FROM residuals
    WHERE LAG(residual) OVER (ORDER BY date) IS NOT NULL
),
adf_statistic AS (
    SELECT
        rho,
        n,
        -- ADFç»Ÿè®¡é‡ï¼št = (rho - 1) / SE(rho)
        (rho - 1) / NULLIF(
            SQRT((1 - POWER(rho, 2)) / NULLIF(n - 2, 0)),
            0
        ) AS adf_stat
    FROM adf_regression
)
SELECT
    ROUND(rho::numeric, 6) AS rho_coefficient,
    ROUND(adf_stat::numeric, 4) AS adf_statistic,
    CASE
        WHEN adf_stat < -3.34 THEN 'Cointegrated (1% level) âœ“'
        WHEN adf_stat < -2.86 THEN 'Cointegrated (5% level) âœ“'
        WHEN adf_stat < -2.57 THEN 'Cointegrated (10% level) âœ“'
        ELSE 'Not cointegrated âœ—'
    END AS cointegration_result
FROM adf_statistic;
```

---

## 2. Johansenæ£€éªŒ

### 2.1 Johansenæ£€éªŒåŸç†

**Johansenæ£€éªŒ**ç”¨äºå¤šå˜é‡åæ•´åˆ†æã€‚

**æ£€éªŒç»Ÿè®¡é‡**ï¼š

- **è¿¹ç»Ÿè®¡é‡**ï¼š$\lambda_{trace} = -T \sum_{i=r+1}^{n} \ln(1-\hat{\lambda}_i)$
- **æœ€å¤§ç‰¹å¾å€¼ç»Ÿè®¡é‡**ï¼š$\lambda_{max} = -T \ln(1-\hat{\lambda}_{r+1})$

### 2.2 Johansenæ£€éªŒå®ç°

```sql
-- Johansenæ£€éªŒï¼šå¤šå˜é‡åæ•´
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multivariate_cointegration') THEN
            DROP TABLE multivariate_cointegration CASCADE;
        END IF;

        CREATE TABLE multivariate_cointegration (
            date DATE PRIMARY KEY,
            series1 NUMERIC NOT NULL,
            series2 NUMERIC NOT NULL,
            series3 NUMERIC NOT NULL
        );

        -- æ’å…¥å¤šå˜é‡æ•°æ®
        INSERT INTO multivariate_cointegration (date, series1, series2, series3)
        SELECT
            '2020-01-01'::DATE + (i || ' days')::INTERVAL,
            100 + i * 0.1 + SUM((RANDOM() - 0.5) * 2) OVER (ORDER BY i),
            (100 + i * 0.1) * 2 + SUM((RANDOM() - 0.5) * 2) OVER (ORDER BY i),
            (100 + i * 0.1) * 3 + SUM((RANDOM() - 0.5) * 2) OVER (ORDER BY i)
        FROM generate_series(1, 500) i;

        RAISE NOTICE 'å¤šå˜é‡åæ•´æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- Johansenæ£€éªŒï¼šè®¡ç®—ç‰¹å¾å€¼ï¼ˆç®€åŒ–ç‰ˆï¼‰
WITH differences AS (
    SELECT
        date,
        series1 - LAG(series1) OVER (ORDER BY date) AS d_series1,
        series2 - LAG(series2) OVER (ORDER BY date) AS d_series2,
        series3 - LAG(series3) OVER (ORDER BY date) AS d_series3,
        LAG(series1) OVER (ORDER BY date) AS lag_series1,
        LAG(series2) OVER (ORDER BY date) AS lag_series2,
        LAG(series3) OVER (ORDER BY date) AS lag_series3
    FROM multivariate_cointegration
    WHERE LAG(series1) OVER (ORDER BY date) IS NOT NULL
),
-- è®¡ç®—åæ–¹å·®çŸ©é˜µï¼ˆç®€åŒ–ï¼‰
covariance_matrix AS (
    SELECT
        VAR_POP(d_series1) AS var1,
        VAR_POP(d_series2) AS var2,
        VAR_POP(d_series3) AS var3,
        COVAR_POP(d_series1, d_series2) AS cov12,
        COVAR_POP(d_series1, d_series3) AS cov13,
        COVAR_POP(d_series2, d_series3) AS cov23
    FROM differences
)
SELECT
    ROUND(var1::numeric, 4) AS variance_series1,
    ROUND(var2::numeric, 4) AS variance_series2,
    ROUND(var3::numeric, 4) AS variance_series3,
    ROUND(cov12::numeric, 4) AS covariance_12,
    ROUND(cov13::numeric, 4) AS covariance_13,
    ROUND(cov23::numeric, 4) AS covariance_23
FROM covariance_matrix;
```

---

## 3. è¯¯å·®ä¿®æ­£æ¨¡å‹ï¼ˆECMï¼‰

### 3.1 ECMåŸç†

**è¯¯å·®ä¿®æ­£æ¨¡å‹**æè¿°çŸ­æœŸåŠ¨æ€è°ƒæ•´åˆ°é•¿æœŸå‡è¡¡çš„è¿‡ç¨‹ã€‚

$$\Delta y_t = \alpha + \beta \Delta x_t + \gamma (y_{t-1} - \theta x_{t-1}) + \epsilon_t$$

å…¶ä¸­ $(y_{t-1} - \theta x_{t-1})$ æ˜¯è¯¯å·®ä¿®æ­£é¡¹ã€‚

### 3.2 ECMå®ç°

```sql
-- è¯¯å·®ä¿®æ­£æ¨¡å‹
WITH regression_coeffs AS (
    SELECT
        REGR_SLOPE(series1, series2) AS beta,
        REGR_INTERCEPT(series1, series2) AS alpha
    FROM cointegration_data
),
ecm_data AS (
    SELECT
        cd.date,
        cd.series1 - LAG(cd.series1) OVER (ORDER BY cd.date) AS delta_y,
        cd.series2 - LAG(cd.series2) OVER (ORDER BY cd.date) AS delta_x,
        cd.series1 - (rc.alpha + rc.beta * cd.series2) AS error_correction_term
    FROM cointegration_data cd
    CROSS JOIN regression_coeffs rc
    WHERE LAG(cd.series1) OVER (ORDER BY cd.date) IS NOT NULL
),
ecm_regression AS (
    SELECT
        REGR_SLOPE(delta_y, delta_x) AS short_term_coeff,
        REGR_SLOPE(delta_y, error_correction_term) AS ecm_coeff,
        REGR_R2(delta_y, delta_x) AS r_squared
    FROM ecm_data
)
SELECT
    ROUND(short_term_coeff::numeric, 4) AS short_term_coefficient,
    ROUND(ecm_coeff::numeric, 4) AS error_correction_coefficient,
    ROUND(r_squared::numeric, 4) AS r_squared,
    CASE
        WHEN ecm_coeff < 0 THEN 'Error correction mechanism present âœ“'
        ELSE 'No error correction'
    END AS ecm_interpretation
FROM ecm_regression;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Engle, R.F., Granger, C.W.J. (1987)**: "Co-integration and Error Correction: Representation, Estimation, and Testing"
2. **Johansen, S. (1991)**: "Estimation and Hypothesis Testing of Cointegration Vectors in Gaussian Vector Autoregressive Models"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **æ•°æ®é¢„å¤„ç†**ï¼šç¡®ä¿æ•°æ®æ˜¯I(1)è¿‡ç¨‹
2. **æ»åé€‰æ‹©**ï¼šä½¿ç”¨ä¿¡æ¯å‡†åˆ™é€‰æ‹©æœ€ä¼˜æ»å
3. **å¹¶è¡Œè®¡ç®—**ï¼šå¹¶è¡Œè®¡ç®—å¤šä¸ªåæ•´å…³ç³»
4. **ç¼“å­˜ç»“æœ**ï¼šç¼“å­˜å›å½’ç³»æ•°å’Œæ£€éªŒç»Ÿè®¡é‡

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **å•ä½æ ¹æ£€éªŒ**ï¼šå…ˆæ£€éªŒåºåˆ—çš„å¹³ç¨³æ€§
2. **åæ•´æ£€éªŒ**ï¼šä½¿ç”¨Engle-Grangeræˆ–Johansenæ£€éªŒ
3. **ECMå»ºæ¨¡**ï¼šå¦‚æœåæ•´ï¼Œå»ºç«‹è¯¯å·®ä¿®æ­£æ¨¡å‹
4. **ç»“æœè§£é‡Š**ï¼šè§£é‡Šåæ•´å‘é‡çš„ç»æµæ„ä¹‰

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
