# PostgreSQL 网络流算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 图算法 | 网络流 | 最大流最小割
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Network Flows (Ahuja et al.), Graph Algorithms, Max-Flow Min-Cut

---

## 📋 目录

- [PostgreSQL 网络流算法完整指南](#postgresql-网络流算法完整指南)
  - [📋 目录](#-目录)
  - [网络流概述](#网络流概述)
    - [理论基础](#理论基础)
    - [问题定义](#问题定义)
    - [应用场景](#应用场景)
  - [1. 最大流问题](#1-最大流问题)
    - [1.1 Ford-Fulkerson算法](#11-ford-fulkerson算法)
    - [1.2 Edmonds-Karp算法](#12-edmonds-karp算法)
  - [2. 最小割问题](#2-最小割问题)
    - [2.1 最小割原理](#21-最小割原理)
  - [3. 实际应用案例](#3-实际应用案例)
    - [3.1 网络带宽分配](#31-网络带宽分配)
    - [3.2 任务分配问题](#32-任务分配问题)
  - [📊 性能优化建议](#-性能优化建议)
    - [索引优化](#索引优化)
    - [物化视图](#物化视图)
  - [🎯 最佳实践](#-最佳实践)
    - [算法选择](#算法选择)
    - [网络设计](#网络设计)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 网络流算法对比](#-网络流算法对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：增广路径查找慢](#问题1增广路径查找慢)
    - [问题2：最大流计算不准确](#问题2最大流计算不准确)
  - [📚 参考资源](#-参考资源)

---

## 网络流概述

**网络流**是在有向图中寻找从源点到汇点的最大流量。

### 理论基础

给定有向图 $G = (V, E)$，每条边有容量 $c(u,v)$，求从源点 $s$ 到汇点 $t$ 的最大流。

### 问题定义

**流函数** $f: E \rightarrow \mathbb{R}$ 满足：

1. **容量约束**: $0 \leq f(u,v) \leq c(u,v)$
2. **流量守恒**: $\sum_{v} f(u,v) = \sum_{v} f(v,u)$（除源汇外）

**最大流**: $\max \sum_{v} f(s,v)$

### 应用场景

| 应用领域 | 具体应用 |
|---------|---------|
| **网络设计** | 网络带宽分配 |
| **匹配问题** | 二分图匹配 |
| **图像处理** | 图像分割 |
| **资源分配** | 任务分配 |

---

## 1. 最大流问题

### 1.1 Ford-Fulkerson算法

**Ford-Fulkerson算法**通过寻找增广路径增加流量。

**算法步骤**:

1. 初始化流为0
2. 在残差图中寻找增广路径
3. 沿增广路径增加流量
4. 重复直到没有增广路径

```sql
-- 网络流数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'flow_network') THEN
            RAISE WARNING '表 flow_network 已存在，先删除';
            DROP TABLE flow_network CASCADE;
        END IF;

        CREATE TABLE flow_network (
            from_node INTEGER NOT NULL,
            to_node INTEGER NOT NULL,
            capacity NUMERIC NOT NULL,
            flow NUMERIC DEFAULT 0,
            PRIMARY KEY (from_node, to_node)
        );

        -- 插入网络流边
        INSERT INTO flow_network (from_node, to_node, capacity) VALUES
            (1, 2, 10), (1, 3, 5),
            (2, 3, 15), (2, 4, 10),
            (3, 4, 10);

        RAISE NOTICE '表 flow_network 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 flow_network 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 残差图计算
WITH residual_graph AS (
    SELECT
        from_node,
        to_node,
        capacity - flow AS residual_capacity,
        flow AS reverse_capacity
    FROM flow_network
    WHERE capacity - flow > 0
    UNION ALL
    SELECT
        to_node AS from_node,
        from_node AS to_node,
        flow AS residual_capacity,
        0 AS reverse_capacity
    FROM flow_network
    WHERE flow > 0
)
SELECT
    from_node,
    to_node,
    ROUND(residual_capacity::numeric, 2) AS residual_capacity
FROM residual_graph
ORDER BY from_node, to_node;
```

---

### 1.2 Edmonds-Karp算法

**Edmonds-Karp算法**使用BFS寻找增广路径，保证多项式时间复杂度。

```sql
-- Edmonds-Karp算法：BFS寻找增广路径（简化版）
WITH bfs_paths AS (
    SELECT
        from_node,
        to_node,
        residual_capacity,
        1 AS path_length,
        ARRAY[from_node, to_node] AS path
    FROM (
        SELECT
            from_node,
            to_node,
            capacity - flow AS residual_capacity
        FROM flow_network
        WHERE capacity - flow > 0
    ) residual
    WHERE from_node = 1  -- 源点
)
SELECT
    path,
    path_length,
    MIN(residual_capacity) OVER (PARTITION BY path) AS path_capacity
FROM bfs_paths
WHERE to_node = 4  -- 汇点
ORDER BY path_length
LIMIT 1;
```

---

## 2. 最小割问题

### 2.1 最小割原理

**最小割（Min-Cut）**是最大流的对偶问题。

**最大流最小割定理**：最大流等于最小割的容量。

```sql
-- 最小割计算（基于最大流）
WITH max_flow AS (
    SELECT
        SUM(flow) AS total_flow
    FROM flow_network
    WHERE from_node = 1  -- 源点
),
min_cut AS (
    SELECT
        from_node,
        to_node,
        capacity,
        flow,
        CASE
            WHEN flow = capacity THEN 'Saturated'
            ELSE 'Available'
        END AS edge_status
    FROM flow_network
)
SELECT
    ROUND((SELECT total_flow FROM max_flow)::numeric, 2) AS max_flow_value,
    COUNT(CASE WHEN edge_status = 'Saturated' THEN 1 END) AS saturated_edges,
    COUNT(*) AS total_edges
FROM min_cut;
```

---

## 3. 实际应用案例

### 3.1 网络带宽分配

```sql
-- 网络带宽分配应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建网络拓扑表
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'network_topology') THEN
            DROP TABLE network_topology CASCADE;
        END IF;

        CREATE TABLE network_topology (
            router_id INTEGER NOT NULL,
            next_hop INTEGER NOT NULL,
            bandwidth_capacity NUMERIC NOT NULL,
            current_usage NUMERIC DEFAULT 0,
            PRIMARY KEY (router_id, next_hop)
        );

        -- 插入示例网络拓扑数据
        INSERT INTO network_topology (router_id, next_hop, bandwidth_capacity, current_usage) VALUES
            (1, 2, 100, 0), (1, 3, 50, 0),
            (2, 3, 80, 0), (2, 4, 100, 0),
            (3, 4, 60, 0);

        CREATE INDEX idx_router_id ON network_topology(router_id);
        CREATE INDEX idx_next_hop ON network_topology(next_hop);

        RAISE NOTICE '网络拓扑表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '网络带宽分配准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 最大流计算：从路由器1到路由器4
WITH residual_network AS (
    SELECT
        router_id AS from_node,
        next_hop AS to_node,
        bandwidth_capacity - current_usage AS residual_capacity
    FROM network_topology
    WHERE bandwidth_capacity - current_usage > 0
),
max_flow_paths AS (
    SELECT
        from_node,
        to_node,
        residual_capacity,
        CASE
            WHEN from_node = 1 THEN 1
            ELSE 0
        END AS is_source
    FROM residual_network
)
SELECT
    from_node,
    to_node,
    ROUND(residual_capacity::numeric, 2) AS available_bandwidth,
    CASE
        WHEN is_source = 1 THEN 'Source'
        WHEN to_node = 4 THEN 'Sink'
        ELSE 'Intermediate'
    END AS node_type
FROM max_flow_paths
ORDER BY from_node, to_node;
```

### 3.2 任务分配问题

```sql
-- 任务分配问题应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建任务分配网络
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'task_assignment') THEN
            DROP TABLE task_assignment CASCADE;
        END IF;

        CREATE TABLE task_assignment (
            worker_id INTEGER NOT NULL,
            task_id INTEGER NOT NULL,
            capacity NUMERIC NOT NULL,
            PRIMARY KEY (worker_id, task_id)
        );

        -- 插入示例任务分配数据
        INSERT INTO task_assignment (worker_id, task_id, capacity) VALUES
            (1, 1, 10), (1, 2, 5),
            (2, 2, 8), (2, 3, 12),
            (3, 1, 6), (3, 3, 9);

        RAISE NOTICE '任务分配表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '任务分配问题准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 最大匹配：使用网络流解决任务分配
WITH assignment_flow AS (
    SELECT
        worker_id,
        task_id,
        capacity AS flow_capacity,
        SUM(capacity) OVER (PARTITION BY worker_id) AS worker_total_capacity,
        SUM(capacity) OVER (PARTITION BY task_id) AS task_total_capacity
    FROM task_assignment
)
SELECT
    worker_id,
    task_id,
    ROUND(flow_capacity::numeric, 2) AS assigned_capacity,
    ROUND(worker_total_capacity::numeric, 2) AS worker_total,
    ROUND(task_total_capacity::numeric, 2) AS task_total
FROM assignment_flow
ORDER BY worker_id, task_id;
```

---

## 📊 性能优化建议

### 索引优化

```sql
-- 创建关键索引
CREATE INDEX IF NOT EXISTS idx_from_node ON flow_network(from_node);
CREATE INDEX IF NOT EXISTS idx_to_node ON flow_network(to_node);
CREATE INDEX IF NOT EXISTS idx_from_to ON flow_network(from_node, to_node);
```

### 物化视图

```sql
-- 创建残差网络的物化视图
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_residual_network AS
SELECT
    from_node,
    to_node,
    capacity - flow AS residual_capacity
FROM flow_network
WHERE capacity - flow > 0;

CREATE INDEX ON mv_residual_network(from_node, to_node);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_residual_network;
```

---

## 🎯 最佳实践

### 算法选择

1. **Ford-Fulkerson**：适合小规模网络
2. **Edmonds-Karp**：保证多项式时间，适合中等规模
3. **Dinic算法**：适合大规模网络，效率高

### 网络设计

1. **容量设置**：合理设置边容量
2. **源汇选择**：选择合适的源点和汇点
3. **路径优化**：优化增广路径查找

### SQL实现注意事项

1. **错误处理**：使用DO块和EXCEPTION进行错误处理
2. **性能优化**：使用索引和物化视图优化性能
3. **数值精度**：注意流量计算的精度
4. **循环检测**：避免无限循环

---

## 📈 网络流算法对比

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优势 | 局限性 |
|------|-----------|-----------|---------|------|--------|
| Ford-Fulkerson | $O(E \cdot f)$ | $O(V+E)$ | 小规模网络 | 简单、灵活 | 可能很慢 |
| Edmonds-Karp | $O(VE^2)$ | $O(V+E)$ | 中等规模 | 多项式时间 | 效率中等 |
| Dinic | $O(V^2E)$ | $O(V+E)$ | 大规模网络 | 高效 | 实现复杂 |

---

## 🔍 常见问题与解决方案

### 问题1：增广路径查找慢

**原因**：

- 图规模大
- 未使用BFS优化
- 路径查找策略不当

**解决方案**：

- 使用Edmonds-Karp算法（BFS）
- 使用索引优化
- 优化路径查找算法

### 问题2：最大流计算不准确

**原因**：

- 残差图计算错误
- 流量更新错误
- 数值精度问题

**解决方案**：

- 验证残差图计算
- 检查流量更新逻辑
- 注意数值精度

---

## 📚 参考资源

1. **Ahuja, R.K., et al. (1993)**: "Network Flows: Theory, Algorithms, and Applications"
2. **Cormen, T.H., et al. (2009)**: "Introduction to Algorithms", 3rd Edition
3. **Ford, L.R., Fulkerson, D.R. (1956)**: "Maximal flow through a network"

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
