# PostgreSQL 最小生成树算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 图算法 | 最小生成树 | 网络优化
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Graph Theory, Network Algorithms, Minimum Spanning Tree

---

## 📋 目录

- [PostgreSQL 最小生成树算法完整指南](#postgresql-最小生成树算法完整指南)
  - [📋 目录](#-目录)
  - [最小生成树概述](#最小生成树概述)
    - [理论基础](#理论基础)
    - [问题定义](#问题定义)
    - [应用场景](#应用场景)
  - [1. Kruskal算法](#1-kruskal算法)
    - [1.1 Kruskal原理](#11-kruskal原理)
    - [1.2 并查集](#12-并查集)
  - [2. Prim算法](#2-prim算法)
    - [2.1 Prim原理](#21-prim原理)
  - [3. 复杂度分析](#3-复杂度分析)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 网络设计](#41-网络设计)
  - [📚 参考资源](#-参考资源)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 最小生成树概述

**最小生成树（Minimum Spanning Tree, MST）**是连接所有顶点的边权重和最小的树。

### 理论基础

给定连通无向图 $G = (V, E)$，MST是包含所有顶点且边权重和最小的树。

### 问题定义

**目标**: 找到边集 $T \subseteq E$，使得：

1. $(V, T)$ 是树（连通且无环）
2. $\sum_{e \in T} w(e)$ 最小

### 应用场景

| 应用领域 | 具体应用 |
|---------|---------|
| **网络设计** | 通信网络、电力网络 |
| **聚类分析** | 数据聚类、图像分割 |
| **路由算法** | 网络路由优化 |
| **近似算法** | TSP问题的近似解 |

---

## 1. Kruskal算法

### 1.1 Kruskal原理

**Kruskal算法**按边权重从小到大排序，依次添加不形成环的边。

**算法步骤**:

1. 将所有边按权重排序
2. 初始化空边集
3. 依次考虑每条边，如果不形成环则加入
4. 重复直到有 $|V|-1$ 条边

```sql
-- MST数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'graph_edges') THEN
            RAISE WARNING '表 graph_edges 已存在，先删除';
            DROP TABLE graph_edges CASCADE;
        END IF;

        CREATE TABLE graph_edges (
            edge_id SERIAL PRIMARY KEY,
            from_node INTEGER NOT NULL,
            to_node INTEGER NOT NULL,
            weight NUMERIC NOT NULL
        );

        -- 插入图边数据
        INSERT INTO graph_edges (from_node, to_node, weight) VALUES
            (1, 2, 4), (1, 3, 2), (2, 3, 1),
            (2, 4, 5), (3, 4, 3), (3, 5, 6),
            (4, 5, 7);

        RAISE NOTICE '表 graph_edges 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 graph_edges 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- Kruskal算法实现（简化版）
WITH sorted_edges AS (
    SELECT
        edge_id,
        from_node,
        to_node,
        weight,
        ROW_NUMBER() OVER (ORDER BY weight) AS edge_rank
    FROM graph_edges
),
mst_edges AS (
    SELECT
        edge_id,
        from_node,
        to_node,
        weight,
        -- 检查是否形成环（简化：使用递归CTE）
        CASE
            WHEN from_node IN (SELECT to_node FROM graph_edges WHERE edge_id < se.edge_id)
                 AND to_node IN (SELECT from_node FROM graph_edges WHERE edge_id < se.edge_id)
            THEN 'Cycle'
            ELSE 'No cycle'
        END AS cycle_check
    FROM sorted_edges se
    WHERE edge_rank <= (SELECT COUNT(DISTINCT from_node) + COUNT(DISTINCT to_node) FROM graph_edges) / 2 - 1
)
SELECT
    edge_id,
    from_node,
    to_node,
    ROUND(weight::numeric, 2) AS weight,
    cycle_check
FROM mst_edges
WHERE cycle_check = 'No cycle'
ORDER BY weight;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    from_node,
    to_node,
    weight
FROM graph_edges
ORDER BY weight;
```

### 1.2 并查集

**并查集（Union-Find）**用于高效检测环。

```sql
-- 并查集实现（简化版）
WITH union_find AS (
    SELECT
        node_id,
        node_id AS parent,
        0 AS rank
    FROM (SELECT DISTINCT from_node AS node_id FROM graph_edges
          UNION SELECT DISTINCT to_node FROM graph_edges) nodes
),
find_root AS (
    SELECT
        node_id,
        CASE
            WHEN parent = node_id THEN node_id
            ELSE parent
        END AS root
    FROM union_find
)
SELECT * FROM find_root;
```

---

## 2. Prim算法

### 2.1 Prim原理

**Prim算法**从任意顶点开始，逐步扩展MST。

**算法步骤**:

1. 选择起始顶点
2. 选择连接已选顶点和未选顶点的最小权重边
3. 将新顶点加入已选集合
4. 重复直到所有顶点被选中

```sql
-- Prim算法实现
WITH prim_mst AS (
    SELECT
        1 AS start_node,
        ARRAY[1] AS selected_nodes,
        0 AS total_weight
    FROM generate_series(1, 1)
    UNION ALL
    SELECT
        start_node,
        selected_nodes || new_node,
        total_weight + min_edge_weight
    FROM (
        SELECT
            start_node,
            selected_nodes,
            to_node AS new_node,
            weight AS min_edge_weight
        FROM graph_edges
        WHERE from_node = ANY(selected_nodes)
          AND to_node != ALL(selected_nodes)
        ORDER BY weight
        LIMIT 1
    ) next_edge
    WHERE array_length(selected_nodes, 1) < (SELECT COUNT(DISTINCT from_node) FROM graph_edges)
)
SELECT
    selected_nodes,
    total_weight
FROM prim_mst
ORDER BY array_length(selected_nodes, 1) DESC
LIMIT 1;
```

---

## 3. 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|-----------|-----------|---------|
| **Kruskal** | $O(E \log E)$ | $O(V)$ | 稀疏图 |
| **Prim（数组）** | $O(V^2)$ | $O(V)$ | 稠密图 |
| **Prim（堆）** | $O(E \log V)$ | $O(V)$ | 稀疏图 |

---

## 4. PostgreSQL 18 并行最小生成树增强

**PostgreSQL 18** 显著增强了并行最小生成树计算能力，支持并行执行Kruskal算法、Prim算法和并查集操作，大幅提升大规模图最小生成树计算的性能。

### 4.1 并行最小生成树原理

PostgreSQL 18 的并行最小生成树通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描图边数据
2. **并行排序**：每个工作进程独立排序边
3. **并行并查集**：并行执行并查集操作
4. **结果合并**：主进程合并所有工作进程的计算结果

### 4.2 并行Kruskal算法

```sql
-- PostgreSQL 18 并行Kruskal算法（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'graph_edges') THEN
            RAISE WARNING '表 graph_edges 不存在，无法执行并行Kruskal算法';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行Kruskal算法';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行Kruskal算法准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行Kruskal算法：边排序和MST构建
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH sorted_edges AS (
    SELECT
        from_node,
        to_node,
        weight,
        ROW_NUMBER() OVER (ORDER BY weight) AS edge_rank
    FROM graph_edges
),
mst_edges AS (
    SELECT
        from_node,
        to_node,
        weight
    FROM sorted_edges
    WHERE edge_rank <= (SELECT COUNT(DISTINCT from_node) + COUNT(DISTINCT to_node) FROM graph_edges) / 2 - 1
)
SELECT
    from_node,
    to_node,
    weight
FROM mst_edges
ORDER BY weight;
```

### 4.3 并行Prim算法

```sql
-- PostgreSQL 18 并行Prim算法（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'graph_edges') THEN
            RAISE WARNING '表 graph_edges 不存在，无法执行并行Prim算法';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行Prim算法';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行Prim算法准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行Prim算法：最小权重边选择
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH candidate_edges AS (
    SELECT
        e.from_node,
        e.to_node,
        e.weight,
        CASE
            WHEN e.from_node IN (SELECT node FROM selected_nodes)
                 AND e.to_node NOT IN (SELECT node FROM selected_nodes) THEN true
            WHEN e.to_node IN (SELECT node FROM selected_nodes)
                 AND e.from_node NOT IN (SELECT node FROM selected_nodes) THEN true
            ELSE false
        END AS is_candidate
    FROM graph_edges e
    CROSS JOIN (SELECT ARRAY[1] AS selected_nodes) AS sn
)
SELECT
    from_node,
    to_node,
    weight
FROM candidate_edges
WHERE is_candidate = true
ORDER BY weight
LIMIT 10;
```

---

## 5. 实际应用案例

### 4.1 网络设计

```sql
-- 网络设计MST应用
WITH network_mst AS (
    SELECT
        from_node AS city1,
        to_node AS city2,
        weight AS cable_length
    FROM mst_result
)
SELECT
    city1,
    city2,
    ROUND(cable_length::numeric, 2) AS required_cable,
    SUM(cable_length) OVER () AS total_cable_length
FROM network_mst;
```

---

## 📚 参考资源

1. **Cormen, T.H., et al. (2009)**: "Introduction to Algorithms"
2. **Kruskal, J.B. (1956)**: "On the shortest spanning subtree"

## 📊 性能优化建议

1. **排序优化**: 使用索引加速边排序
2. **并查集优化**: 路径压缩和按秩合并
3. **并行处理**: 利用PostgreSQL并行查询

## 🎯 最佳实践

1. **算法选择**: 根据图密度选择算法
2. **数据结构**: 使用合适的数据结构
3. **验证**: 验证MST的正确性

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
