# PostgreSQL å›¾åµŒå…¥ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | å›¾ç®—æ³• | å›¾åµŒå…¥ | Node2Vec
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)
> **å‚è€ƒæ ‡å‡†**: Graph Embedding, Node2Vec, Graph Neural Networks

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å›¾åµŒå…¥ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å›¾åµŒå…¥ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å›¾åµŒå…¥æ¦‚è¿°](#å›¾åµŒå…¥æ¦‚è¿°)
    - [åµŒå…¥ç±»å‹](#åµŒå…¥ç±»å‹)
  - [1. Node2Vec](#1-node2vec)
    - [1.1 Node2VecåŸç†](#11-node2vecåŸç†)
    - [1.2 Node2Vecå®ç°](#12-node2vecå®ç°)
    - [1.3 Skip-gramè®­ç»ƒï¼ˆç®€åŒ–ç‰ˆï¼‰](#13-skip-gramè®­ç»ƒç®€åŒ–ç‰ˆ)
  - [2. Graph2Vec](#2-graph2vec)
    - [2.1 Graph2VecåŸç†](#21-graph2vecåŸç†)
    - [2.2 Graph2Vecå®ç°](#22-graph2vecå®ç°)
  - [3. åµŒå…¥è´¨é‡è¯„ä¼°](#3-åµŒå…¥è´¨é‡è¯„ä¼°)
    - [3.1 ç›¸ä¼¼åº¦è®¡ç®—](#31-ç›¸ä¼¼åº¦è®¡ç®—)
    - [3.2 é“¾æ¥é¢„æµ‹è¯„ä¼°](#32-é“¾æ¥é¢„æµ‹è¯„ä¼°)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## å›¾åµŒå…¥æ¦‚è¿°

**å›¾åµŒå…¥**å°†å›¾èŠ‚ç‚¹æˆ–æ•´ä¸ªå›¾æ˜ å°„åˆ°ä½ç»´å‘é‡ç©ºé—´ï¼Œç”¨äºå›¾åˆ†æå’Œæœºå™¨å­¦ä¹ ã€‚

### åµŒå…¥ç±»å‹

| ç±»å‹ | ç›®æ ‡ | åº”ç”¨ |
|------|------|------|
| **èŠ‚ç‚¹åµŒå…¥** | å°†èŠ‚ç‚¹æ˜ å°„åˆ°å‘é‡ | èŠ‚ç‚¹åˆ†ç±»ã€é“¾æ¥é¢„æµ‹ |
| **è¾¹åµŒå…¥** | å°†è¾¹æ˜ å°„åˆ°å‘é‡ | è¾¹åˆ†ç±» |
| **å›¾åµŒå…¥** | å°†æ•´ä¸ªå›¾æ˜ å°„åˆ°å‘é‡ | å›¾åˆ†ç±» |

---

## 1. Node2Vec

### 1.1 Node2VecåŸç†

**Node2Vec**ä½¿ç”¨éšæœºæ¸¸èµ°å’ŒSkip-gramå­¦ä¹ èŠ‚ç‚¹åµŒå…¥ã€‚

**ç®—æ³•æµç¨‹**ï¼š

1. ç”Ÿæˆéšæœºæ¸¸èµ°åºåˆ—
2. ä½¿ç”¨Skip-gramå­¦ä¹ èŠ‚ç‚¹è¡¨ç¤º
3. ä¼˜åŒ–ç›®æ ‡å‡½æ•°

**éšæœºæ¸¸èµ°ç­–ç•¥**ï¼š

- **BFSï¼ˆå¹¿åº¦ä¼˜å…ˆï¼‰**ï¼šæ¢ç´¢å±€éƒ¨é‚»åŸŸ
- **DFSï¼ˆæ·±åº¦ä¼˜å…ˆï¼‰**ï¼šæ¢ç´¢å…¨å±€ç»“æ„

### 1.2 Node2Vecå®ç°

```sql
-- Node2Vecå›¾æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'node2vec_graph') THEN
            DROP TABLE node2vec_graph, node_embeddings CASCADE;
        END IF;

        CREATE TABLE node2vec_graph (
            from_node INTEGER NOT NULL,
            to_node INTEGER NOT NULL,
            weight NUMERIC DEFAULT 1,
            PRIMARY KEY (from_node, to_node)
        );

        -- æ’å…¥ç¤ºä¾‹å›¾ï¼ˆç¤¾äº¤ç½‘ç»œï¼‰
        INSERT INTO node2vec_graph (from_node, to_node, weight) VALUES
            (1, 2, 1), (2, 1, 1),
            (2, 3, 1), (3, 2, 1),
            (3, 4, 1), (4, 3, 1),
            (4, 1, 1), (1, 4, 1),
            (1, 3, 1), (3, 1, 1);

        CREATE INDEX idx_from_node ON node2vec_graph(from_node);
        CREATE INDEX idx_to_node ON node2vec_graph(to_node);

        -- èŠ‚ç‚¹åµŒå…¥è¡¨ï¼ˆç®€åŒ–ï¼š2ç»´åµŒå…¥ï¼‰
        CREATE TABLE node_embeddings (
            node_id INTEGER PRIMARY KEY,
            embedding_dim1 NUMERIC DEFAULT (RANDOM() - 0.5),
            embedding_dim2 NUMERIC DEFAULT (RANDOM() - 0.5)
        );

        INSERT INTO node_embeddings (node_id)
        SELECT DISTINCT from_node FROM node2vec_graph
        UNION
        SELECT DISTINCT to_node FROM node2vec_graph;

        RAISE NOTICE 'Node2Vecå›¾æ•°æ®è¡¨åˆ›å»ºæˆåŠŸï¼Œå…± % ä¸ªèŠ‚ç‚¹', (SELECT COUNT(*) FROM node_embeddings);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- éšæœºæ¸¸èµ°ç”Ÿæˆï¼ˆå¸¦å‚æ•°på’Œqæ§åˆ¶BFS/DFSï¼‰
CREATE OR REPLACE FUNCTION generate_random_walk(
    p_start_node INTEGER,
    p_walk_length INTEGER DEFAULT 10,
    p_return_param NUMERIC DEFAULT 1.0,  -- på‚æ•°
    p_inout_param NUMERIC DEFAULT 1.0     -- qå‚æ•°
)
RETURNS INTEGER[] AS $$
DECLARE
    walk_path INTEGER[] := ARRAY[p_start_node];
    current_node INTEGER := p_start_node;
    prev_node INTEGER := NULL;
    next_node INTEGER;
    i INTEGER;
BEGIN
    FOR i IN 1..p_walk_length LOOP
        -- é€‰æ‹©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç®€åŒ–ï¼šå‡åŒ€éšæœºï¼‰
        SELECT to_node INTO next_node
        FROM node2vec_graph
        WHERE from_node = current_node
        ORDER BY RANDOM()
        LIMIT 1;

        IF next_node IS NULL THEN
            EXIT;  -- æ²¡æœ‰é‚»å±…ï¼Œåœæ­¢æ¸¸èµ°
        END IF;

        walk_path := walk_path || next_node;
        prev_node := current_node;
        current_node := next_node;
    END LOOP;

    RETURN walk_path;
END;
$$ LANGUAGE plpgsql;

-- ç”Ÿæˆå¤šä¸ªéšæœºæ¸¸èµ°
WITH random_walks AS (
    SELECT
        node_id AS start_node,
        generate_random_walk(node_id, 10) AS walk_sequence
    FROM node_embeddings
    CROSS JOIN generate_series(1, 5)  -- æ¯ä¸ªèŠ‚ç‚¹ç”Ÿæˆ5ä¸ªæ¸¸èµ°
)
SELECT
    start_node,
    walk_sequence,
    array_length(walk_sequence, 1) AS walk_length
FROM random_walks
ORDER BY start_node
LIMIT 20;
```

### 1.3 Skip-gramè®­ç»ƒï¼ˆç®€åŒ–ç‰ˆï¼‰

```sql
-- Skip-gramï¼šå­¦ä¹ èŠ‚ç‚¹å…±ç°å…³ç³»
WITH walk_contexts AS (
    SELECT
        unnest(walk_sequence) WITH ORDINALITY AS walk(node, position),
        walk_sequence
    FROM (
        SELECT generate_random_walk(1, 10) AS walk_sequence
        UNION ALL
        SELECT generate_random_walk(2, 10)
        UNION ALL
        SELECT generate_random_walk(3, 10)
    ) walks
),
node_cooccurrence AS (
    SELECT
        w1.node AS node1,
        w2.node AS node2,
        COUNT(*) AS cooccurrence_count
    FROM walk_contexts w1
    JOIN walk_contexts w2 ON w1.walk_sequence = w2.walk_sequence
        AND ABS(w1.position - w2.position) <= 2  -- çª—å£å¤§å°=2
        AND w1.node != w2.node
    GROUP BY w1.node, w2.node
)
SELECT
    node1,
    node2,
    cooccurrence_count,
    ROUND(cooccurrence_count::NUMERIC / SUM(cooccurrence_count) OVER (PARTITION BY node1), 4) AS cooccurrence_probability
FROM node_cooccurrence
ORDER BY node1, cooccurrence_count DESC;
```

---

## 2. Graph2Vec

### 2.1 Graph2VecåŸç†

**Graph2Vec**å­¦ä¹ æ•´ä¸ªå›¾çš„åµŒå…¥è¡¨ç¤ºã€‚

**ç®—æ³•**ï¼š

1. æå–å­å›¾ç‰¹å¾ï¼ˆWeisfeiler-Lehmanï¼‰
2. ä½¿ç”¨Doc2Vecå­¦ä¹ å›¾åµŒå…¥

### 2.2 Graph2Vecå®ç°

```sql
-- Graph2Vecï¼šå›¾ç‰¹å¾æå–
WITH graph_features AS (
    SELECT
        graph_id,
        -- æå–å›¾ç‰¹å¾ï¼ˆç®€åŒ–ï¼šåº¦åˆ†å¸ƒï¼‰
        ARRAY_AGG(degree ORDER BY node_id) AS degree_sequence,
        COUNT(*) AS node_count,
        (SELECT COUNT(*) FROM node2vec_graph) AS edge_count
    FROM (
        SELECT
            1 AS graph_id,
            from_node AS node_id,
            COUNT(*) AS degree
        FROM node2vec_graph
        GROUP BY from_node
    ) node_degrees
    GROUP BY graph_id
)
SELECT
    graph_id,
    node_count,
    edge_count,
    ROUND(edge_count::NUMERIC / NULLIF(node_count, 0), 2) AS avg_degree,
    degree_sequence
FROM graph_features;
```

---

## 3. åµŒå…¥è´¨é‡è¯„ä¼°

### 3.1 ç›¸ä¼¼åº¦è®¡ç®—

```sql
-- èŠ‚ç‚¹ç›¸ä¼¼åº¦ï¼šä½¿ç”¨åµŒå…¥å‘é‡è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
WITH node_similarity AS (
    SELECT
        n1.node_id AS node1,
        n2.node_id AS node2,
        -- ä½™å¼¦ç›¸ä¼¼åº¦
        (n1.embedding_dim1 * n2.embedding_dim1 + n1.embedding_dim2 * n2.embedding_dim2) /
        NULLIF(
            SQRT(POWER(n1.embedding_dim1, 2) + POWER(n1.embedding_dim2, 2)) *
            SQRT(POWER(n2.embedding_dim1, 2) + POWER(n2.embedding_dim2, 2)),
            0
        ) AS cosine_similarity
    FROM node_embeddings n1
    CROSS JOIN node_embeddings n2
    WHERE n1.node_id < n2.node_id
)
SELECT
    node1,
    node2,
    ROUND(cosine_similarity::numeric, 4) AS similarity,
    CASE
        WHEN cosine_similarity > 0.8 THEN 'Very similar'
        WHEN cosine_similarity > 0.5 THEN 'Similar'
        WHEN cosine_similarity > 0.0 THEN 'Somewhat similar'
        ELSE 'Dissimilar'
    END AS similarity_level
FROM node_similarity
ORDER BY cosine_similarity DESC
LIMIT 10;
```

### 3.2 é“¾æ¥é¢„æµ‹è¯„ä¼°

```sql
-- é“¾æ¥é¢„æµ‹ï¼šä½¿ç”¨åµŒå…¥é¢„æµ‹è¾¹
WITH predicted_links AS (
    SELECT
        n1.node_id AS node1,
        n2.node_id AS node2,
        -- ä½¿ç”¨åµŒå…¥ç›¸ä¼¼åº¦é¢„æµ‹é“¾æ¥
        (n1.embedding_dim1 * n2.embedding_dim1 + n1.embedding_dim2 * n2.embedding_dim2) /
        NULLIF(
            SQRT(POWER(n1.embedding_dim1, 2) + POWER(n1.embedding_dim2, 2)) *
            SQRT(POWER(n2.embedding_dim1, 2) + POWER(n2.embedding_dim2, 2)),
            0
        ) AS link_score,
        CASE
            WHEN EXISTS (
                SELECT 1 FROM node2vec_graph
                WHERE from_node = n1.node_id AND to_node = n2.node_id
            ) THEN TRUE
            ELSE FALSE
        END AS actual_link
    FROM node_embeddings n1
    CROSS JOIN node_embeddings n2
    WHERE n1.node_id < n2.node_id
)
SELECT
    COUNT(*) FILTER (WHERE link_score > 0.5 AND actual_link) AS true_positives,
    COUNT(*) FILTER (WHERE link_score > 0.5 AND NOT actual_link) AS false_positives,
    COUNT(*) FILTER (WHERE link_score <= 0.5 AND actual_link) AS false_negatives,
    COUNT(*) FILTER (WHERE link_score <= 0.5 AND NOT actual_link) AS true_negatives,
    ROUND(
        COUNT(*) FILTER (WHERE link_score > 0.5 AND actual_link)::NUMERIC /
        NULLIF(COUNT(*) FILTER (WHERE link_score > 0.5), 0),
        4
    ) AS precision,
    ROUND(
        COUNT(*) FILTER (WHERE link_score > 0.5 AND actual_link)::NUMERIC /
        NULLIF(COUNT(*) FILTER (WHERE actual_link), 0),
        4
    ) AS recall
FROM predicted_links;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Grover, A., Leskovec, J. (2016)**: "node2vec: Scalable Feature Learning for Networks"
2. **Narayanan, A., et al. (2017)**: "graph2vec: Learning Distributed Representations of Graphs"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¹¶è¡Œæ¸¸èµ°**ï¼šå¹¶è¡Œç”Ÿæˆå¤šä¸ªéšæœºæ¸¸èµ°
2. **è´Ÿé‡‡æ ·**ï¼šä½¿ç”¨è´Ÿé‡‡æ ·åŠ é€Ÿè®­ç»ƒ
3. **æ‰¹é‡æ›´æ–°**ï¼šæ‰¹é‡æ›´æ–°åµŒå…¥å‘é‡
4. **ç¼“å­˜ä¼˜åŒ–**ï¼šç¼“å­˜å¸¸ç”¨èŠ‚ç‚¹çš„åµŒå…¥

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **å‚æ•°è°ƒä¼˜**ï¼šè°ƒæ•´på’Œqå‚æ•°å¹³è¡¡BFS/DFS
2. **åµŒå…¥ç»´åº¦**ï¼šæ ¹æ®æ•°æ®è§„æ¨¡é€‰æ‹©åˆé€‚ç»´åº¦
3. **æ¸¸èµ°é•¿åº¦**ï¼šæ ¹æ®å›¾ç›´å¾„é€‰æ‹©æ¸¸èµ°é•¿åº¦
4. **è¯„ä¼°æŒ‡æ ‡**ï¼šä½¿ç”¨ä¸‹æ¸¸ä»»åŠ¡è¯„ä¼°åµŒå…¥è´¨é‡

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
