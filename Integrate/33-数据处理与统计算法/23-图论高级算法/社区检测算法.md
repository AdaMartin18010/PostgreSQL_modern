# PostgreSQL 社区检测算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 图算法 | 社区检测 | 模块度优化
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Community Detection, Modularity Optimization, Network Analysis

---

## 📋 目录

- [PostgreSQL 社区检测算法完整指南](#postgresql-社区检测算法完整指南)
  - [📋 目录](#-目录)
  - [社区检测概述](#社区检测概述)
  - [理论基础](#理论基础)
    - [社区检测问题定义](#社区检测问题定义)
    - [核心概念](#核心概念)
    - [算法分类](#算法分类)
    - [技术栈](#技术栈)
  - [1. 模块度优化](#1-模块度优化)
    - [1.1 模块度计算](#11-模块度计算)
    - [1.2 Louvain算法（简化版）](#12-louvain算法简化版)
  - [2. 实际应用案例](#2-实际应用案例)
    - [2.1 社交网络社区检测](#21-社交网络社区检测)
  - [📊 性能优化建议](#-性能优化建议)
    - [索引优化](#索引优化)
    - [物化视图](#物化视图)
  - [🎯 最佳实践](#-最佳实践)
    - [算法选择](#算法选择)
    - [参数调优](#参数调优)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 社区检测算法对比](#-社区检测算法对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：模块度计算慢](#问题1模块度计算慢)
    - [问题2：社区划分质量差](#问题2社区划分质量差)
  - [📚 参考资源](#-参考资源)

---

## 社区检测概述

**社区检测**识别网络中紧密连接的节点群组。

## 理论基础

### 社区检测问题定义

社区检测是在复杂网络中识别具有紧密内部连接和稀疏外部连接的节点群组的过程。

### 核心概念

1. **社区定义**：
   - **强社区**：社区内连接数 > 社区外连接数
   - **弱社区**：社区内连接数 > 社区内任意节点的外部连接数
   - **模块度**：衡量社区划分质量的指标

2. **检测方法**：
   - **模块度优化**：最大化模块度
   - **谱聚类**：基于图拉普拉斯矩阵
   - **标签传播**：基于标签传播算法

3. **评估指标**：
   - **模块度（Modularity）**：衡量社区划分质量
   - **模块度增益**：合并社区后的模块度变化
   - **社区数量**：检测到的社区数量

### 算法分类

1. **按优化目标分类**：
   - 模块度优化：Louvain、Leiden算法
   - 谱聚类：基于特征值分解
   - 标签传播：快速社区检测

2. **按算法类型分类**：
   - 贪心算法：Louvain算法
   - 层次聚类：层次社区检测
   - 随机游走：基于随机游走

### 技术栈

- **聚合函数**：COUNT、SUM、AVG
- **窗口函数**：ROW_NUMBER、LAG、LEAD
- **递归CTE**：层次社区检测
- **数组操作**：ARRAY_AGG、unnest

---

## 1. 模块度优化

### 1.1 模块度计算

**模块度（Modularity）**:
$$Q = \frac{1}{2m}\sum_{ij}\left(A_{ij} - \frac{k_i k_j}{2m}\right)\delta(c_i, c_j)$$

其中：

- $A_{ij}$ 是邻接矩阵
- $k_i$ 是节点 $i$ 的度
- $m$ 是边数
- $\delta(c_i, c_j)$ 是社区指示函数

```sql
-- 社区检测数据准备（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'community_graph') THEN
            DROP TABLE community_graph CASCADE;
        END IF;

        CREATE TABLE community_graph (
            from_node INTEGER NOT NULL,
            to_node INTEGER NOT NULL,
            weight NUMERIC DEFAULT 1,
            PRIMARY KEY (from_node, to_node)
        );

        -- 插入示例图数据（两个社区）
        INSERT INTO community_graph (from_node, to_node, weight) VALUES
            -- 社区1
            (1, 2, 1), (1, 3, 1), (2, 3, 1),
            (2, 4, 1), (3, 4, 1),
            -- 社区2
            (5, 6, 1), (5, 7, 1), (6, 7, 1),
            (6, 8, 1), (7, 8, 1),
            -- 社区间连接（稀疏）
            (4, 5, 1);

        CREATE INDEX idx_from_node ON community_graph(from_node);
        CREATE INDEX idx_to_node ON community_graph(to_node);

        RAISE NOTICE '表 community_graph 创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 模块度计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'community_graph') THEN
            RAISE WARNING '表 community_graph 不存在，无法计算模块度';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算模块度';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '模块度计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 模块度计算
WITH node_degrees AS (
    SELECT
        from_node AS node,
        SUM(weight) AS degree
    FROM community_graph
    GROUP BY from_node
    UNION ALL
    SELECT
        to_node AS node,
        SUM(weight) AS degree
    FROM community_graph
    GROUP BY to_node
),
total_degree AS (
    SELECT
        node,
        SUM(degree) AS total_degree
    FROM node_degrees
    GROUP BY node
),
total_edges AS (
    SELECT SUM(weight) / 2.0 AS m FROM community_graph
),
-- 假设社区划分（简化：手动指定）
node_communities AS (
    SELECT 1 AS node, 1 AS community
    UNION ALL SELECT 2, 1 UNION ALL SELECT 3, 1 UNION ALL SELECT 4, 1
    UNION ALL SELECT 5, 2 UNION ALL SELECT 6, 2 UNION ALL SELECT 7, 2 UNION ALL SELECT 8, 2
),
modularity_calculation AS (
    SELECT
        cg.from_node,
        cg.to_node,
        cg.weight AS A_ij,
        td1.total_degree AS k_i,
        td2.total_degree AS k_j,
        (SELECT m FROM total_edges) AS total_m,
        nc1.community AS c_i,
        nc2.community AS c_j,
        CASE WHEN nc1.community = nc2.community THEN 1 ELSE 0 END AS delta_c
    FROM community_graph cg
    JOIN total_degree td1 ON cg.from_node = td1.node
    JOIN total_degree td2 ON cg.to_node = td2.node
    JOIN node_communities nc1 ON cg.from_node = nc1.node
    JOIN node_communities nc2 ON cg.to_node = nc2.node
)
SELECT
    ROUND(SUM((A_ij - k_i * k_j / (2.0 * total_m)) * delta_c) / (2.0 * total_m)::numeric, 4) AS modularity
FROM modularity_calculation;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    from_node,
    COUNT(*) AS degree
FROM community_graph
GROUP BY from_node;
```

### 1.2 Louvain算法（简化版）

**Louvain算法**是高效的模块度优化算法。

```sql
-- Louvain算法：模块度增益计算
WITH node_communities AS (
    SELECT node, community FROM node_communities
),
modularity_gain AS (
    SELECT
        nc1.node AS node,
        nc1.community AS current_community,
        nc2.community AS new_community,
        -- 模块度增益计算（简化版）
        SUM(CASE WHEN nc2.community = nc1.community THEN 1 ELSE 0 END) AS gain
    FROM node_communities nc1
    CROSS JOIN node_communities nc2
    GROUP BY nc1.node, nc1.community, nc2.community
)
SELECT
    node,
    current_community,
    new_community,
    gain
FROM modularity_gain
WHERE gain > 0
ORDER BY node, gain DESC;
```

---

## 2. PostgreSQL 18 并行社区检测增强

**PostgreSQL 18** 显著增强了并行社区检测计算能力，支持并行执行模块度计算、Louvain算法和社区划分，大幅提升大规模网络社区检测的性能。

### 2.1 并行社区检测原理

PostgreSQL 18 的并行社区检测通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描图边数据
2. **并行模块度计算**：每个工作进程独立计算模块度
3. **并行社区优化**：并行执行社区划分优化
4. **结果合并**：主进程合并所有工作进程的计算结果

### 2.2 并行模块度计算

```sql
-- PostgreSQL 18 并行模块度计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'community_graph') THEN
            RAISE WARNING '表 community_graph 不存在，无法执行并行模块度计算';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'node_communities') THEN
            RAISE WARNING '表 node_communities 不存在，无法执行并行模块度计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行模块度计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行模块度计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行模块度：社区质量评估
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH community_edges AS (
    SELECT
        cg.from_node,
        cg.to_node,
        nc1.community AS from_community,
        nc2.community AS to_community,
        CASE WHEN nc1.community = nc2.community THEN 1 ELSE 0 END AS is_internal
    FROM community_graph cg
    JOIN node_communities nc1 ON cg.from_node = nc1.node
    JOIN node_communities nc2 ON cg.to_node = nc2.node
),
total_edges AS (
    SELECT COUNT(*) AS m FROM community_graph
),
node_degrees AS (
    SELECT
        from_node AS node,
        COUNT(*) AS degree
    FROM community_graph
    GROUP BY from_node
),
modularity_terms AS (
    SELECT
        from_community AS community,
        SUM(is_internal) AS internal_edges,
        SUM(degree) AS community_degree
    FROM community_edges ce
    JOIN node_degrees nd ON ce.from_node = nd.node
    CROSS JOIN total_edges te
    GROUP BY from_community
)
SELECT
    community,
    internal_edges,
    community_degree,
    ROUND((internal_edges::numeric / (SELECT m FROM total_edges) -
           POWER(community_degree::numeric / (2 * (SELECT m FROM total_edges)), 2))::numeric, 4) AS modularity_contribution
FROM modularity_terms
ORDER BY community;
```

### 2.3 并行Louvain算法

```sql
-- PostgreSQL 18 并行Louvain算法（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'community_graph') THEN
            RAISE WARNING '表 community_graph 不存在，无法执行并行Louvain算法';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行Louvain算法';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行Louvain算法准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行Louvain：模块度增益计算
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH node_community_edges AS (
    SELECT
        nc.node,
        nc.community AS current_community,
        cg.to_node,
        nc2.community AS neighbor_community,
        COUNT(*) AS edge_count
    FROM node_communities nc
    JOIN community_graph cg ON nc.node = cg.from_node
    JOIN node_communities nc2 ON cg.to_node = nc2.node
    GROUP BY nc.node, nc.community, nc2.community
),
modularity_gain AS (
    SELECT
        node,
        current_community,
        neighbor_community,
        edge_count,
        CASE
            WHEN neighbor_community = current_community THEN edge_count
            ELSE -edge_count
        END AS gain
    FROM node_community_edges
)
SELECT
    node,
    current_community,
    neighbor_community,
    gain
FROM modularity_gain
WHERE gain > 0
ORDER BY gain DESC
LIMIT 50;
```

---

## 3. 实际应用案例

### 2.1 社交网络社区检测

```sql
-- 社交网络社区检测应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建社交网络图
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'social_network') THEN
            DROP TABLE social_network CASCADE;
        END IF;

        CREATE TABLE social_network (
            user_id INTEGER NOT NULL,
            friend_id INTEGER NOT NULL,
            interaction_count INTEGER DEFAULT 1,
            PRIMARY KEY (user_id, friend_id)
        );

        -- 插入示例社交网络数据
        INSERT INTO social_network (user_id, friend_id, interaction_count) VALUES
            -- 社区1：工作同事
            (1, 2, 10), (1, 3, 8), (2, 3, 12),
            (2, 4, 9), (3, 4, 11),
            -- 社区2：大学同学
            (5, 6, 15), (5, 7, 13), (6, 7, 14),
            (6, 8, 12), (7, 8, 16),
            -- 社区间连接（较少）
            (4, 5, 2);

        CREATE INDEX idx_user_id ON social_network(user_id);
        CREATE INDEX idx_friend_id ON social_network(friend_id);

        RAISE NOTICE '社交网络数据表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '社交网络社区检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 社区检测：基于交互强度
WITH user_interactions AS (
    SELECT
        user_id,
        friend_id,
        interaction_count,
        SUM(interaction_count) OVER (PARTITION BY user_id) AS user_total_interactions
    FROM social_network
),
community_detection AS (
    SELECT
        ui1.user_id,
        ui1.friend_id,
        CASE
            WHEN ui1.interaction_count > ui1.user_total_interactions * 0.3 THEN 1
            ELSE 2
        END AS community_id
    FROM user_interactions ui1
)
SELECT
    community_id,
    COUNT(DISTINCT user_id) AS community_size,
    SUM(interaction_count) AS total_interactions
FROM community_detection cd
JOIN social_network sn ON cd.user_id = sn.user_id AND cd.friend_id = sn.friend_id
GROUP BY community_id
ORDER BY community_id;
```

---

## 📊 性能优化建议

### 索引优化

```sql
-- 创建关键索引
CREATE INDEX IF NOT EXISTS idx_from_node ON community_graph(from_node);
CREATE INDEX IF NOT EXISTS idx_to_node ON community_graph(to_node);
CREATE INDEX IF NOT EXISTS idx_from_to ON community_graph(from_node, to_node);
```

### 物化视图

```sql
-- 创建节点度的物化视图
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_node_degrees AS
SELECT
    from_node AS node,
    SUM(weight) AS degree
FROM community_graph
GROUP BY from_node;

CREATE UNIQUE INDEX ON mv_node_degrees(node);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_node_degrees;
```

---

## 🎯 最佳实践

### 算法选择

1. **Louvain算法**：适合大规模网络，速度快
2. **Leiden算法**：改进的Louvain算法，质量更高
3. **谱聚类**：适合小规模网络，质量高

### 参数调优

1. **分辨率参数**：调整社区大小
2. **迭代次数**：平衡质量和速度
3. **随机种子**：影响结果稳定性

### SQL实现注意事项

1. **错误处理**：使用DO块和EXCEPTION进行错误处理
2. **性能优化**：使用索引和物化视图优化性能
3. **内存管理**：注意大图的内存使用
4. **结果验证**：验证社区划分的质量

---

## 📈 社区检测算法对比

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优势 | 局限性 |
|------|-----------|-----------|---------|------|--------|
| Louvain | $O(n \log n)$ | $O(n)$ | 大规模网络 | 快速、高效 | 可能陷入局部最优 |
| Leiden | $O(n \log n)$ | $O(n)$ | 大规模网络 | 质量高 | 计算稍慢 |
| 谱聚类 | $O(n^3)$ | $O(n^2)$ | 小规模网络 | 质量高 | 计算慢 |

---

## 🔍 常见问题与解决方案

### 问题1：模块度计算慢

**原因**：

- 图规模大
- 未使用索引
- 计算复杂度高

**解决方案**：

- 使用索引优化
- 使用物化视图缓存
- 优化模块度计算

### 问题2：社区划分质量差

**原因**：

- 分辨率参数不当
- 算法选择不当
- 数据质量差

**解决方案**：

- 调整分辨率参数
- 尝试不同算法
- 提高数据质量

---

## 📚 参考资源

1. **Blondel, V.D., et al. (2008)**: "Fast unfolding of communities in large networks"
2. **Newman, M.E.J. (2006)**: "Modularity and community structure in networks"
3. **Traag, V.A., et al. (2019)**: "From Louvain to Leiden: guaranteeing well-connected communities"

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
