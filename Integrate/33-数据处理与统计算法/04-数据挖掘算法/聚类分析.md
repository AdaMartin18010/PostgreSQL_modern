# PostgreSQL èšç±»åˆ†æå®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | èšç±»åˆ†æ | ç”¨æˆ·åˆ†ç¾¤
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL èšç±»åˆ†æå®Œæ•´æŒ‡å—](#postgresql-èšç±»åˆ†æå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [èšç±»åˆ†ææ¦‚è¿°](#èšç±»åˆ†ææ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [èšç±»é—®é¢˜çš„æ•°å­¦å®šä¹‰](#èšç±»é—®é¢˜çš„æ•°å­¦å®šä¹‰)
      - [è·ç¦»åº¦é‡](#è·ç¦»åº¦é‡)
    - [æ ¸å¿ƒèšç±»ç®—æ³•](#æ ¸å¿ƒèšç±»ç®—æ³•)
  - [1. K-meansèšç±»](#1-k-meansèšç±»)
    - [1.1 K-meansç®—æ³•åŸç†](#11-k-meansç®—æ³•åŸç†)
      - [ç®—æ³•åŸç†](#ç®—æ³•åŸç†)
      - [åˆå§‹åŒ–æ–¹æ³•](#åˆå§‹åŒ–æ–¹æ³•)
    - [1.2 K-meanså®Œæ•´è¿­ä»£å®ç°](#12-k-meanså®Œæ•´è¿­ä»£å®ç°)
  - [2. DBSCANå¯†åº¦èšç±»](#2-dbscanå¯†åº¦èšç±»)
    - [2.1 DBSCANç®—æ³•åŸç†](#21-dbscanç®—æ³•åŸç†)
      - [2.1.1 ç®—æ³•åŸç†](#211-ç®—æ³•åŸç†)
    - [2.2 DBSCANç®—æ³•å®ç°](#22-dbscanç®—æ³•å®ç°)
  - [3. å±‚æ¬¡èšç±»](#3-å±‚æ¬¡èšç±»)
    - [3.1 å±‚æ¬¡èšç±»ç®—æ³•åŸç†](#31-å±‚æ¬¡èšç±»ç®—æ³•åŸç†)
      - [ç®—æ³•ç±»å‹](#ç®—æ³•ç±»å‹)
      - [é“¾æ¥å‡†åˆ™](#é“¾æ¥å‡†åˆ™)
    - [3.2 è·ç¦»çŸ©é˜µè®¡ç®—](#32-è·ç¦»çŸ©é˜µè®¡ç®—)
  - [4. èšç±»è¯„ä¼°æŒ‡æ ‡](#4-èšç±»è¯„ä¼°æŒ‡æ ‡)
    - [4.1 è½®å»“ç³»æ•°ï¼ˆSilhouette Coefficientï¼‰](#41-è½®å»“ç³»æ•°silhouette-coefficient)
    - [4.2 è½®å»“ç³»æ•°è®¡ç®—](#42-è½®å»“ç³»æ•°è®¡ç®—)
    - [4.3 å…¶ä»–è¯„ä¼°æŒ‡æ ‡](#43-å…¶ä»–è¯„ä¼°æŒ‡æ ‡)
      - [4.3.1 ç°‡å†…å¹³æ–¹å’Œï¼ˆWCSSï¼‰](#431-ç°‡å†…å¹³æ–¹å’Œwcss)
      - [4.3.2 ç°‡é—´å¹³æ–¹å’Œï¼ˆBCSSï¼‰](#432-ç°‡é—´å¹³æ–¹å’Œbcss)
      - [4.3.3 è½®å»“ç³»æ•°ã€WCSSã€BCSSç»¼åˆè¯„ä¼°](#433-è½®å»“ç³»æ•°wcssbcssç»¼åˆè¯„ä¼°)
  - [5. PostgreSQL 18 å¹¶è¡Œèšç±»å¢å¼º](#5-postgresql-18-å¹¶è¡Œèšç±»å¢å¼º)
    - [5.1 å¹¶è¡Œèšç±»åŸç†](#51-å¹¶è¡Œèšç±»åŸç†)
    - [5.2 å¹¶è¡Œ K-means èšç±»](#52-å¹¶è¡Œ-k-means-èšç±»)
    - [5.3 å¹¶è¡Œ DBSCAN èšç±»](#53-å¹¶è¡Œ-dbscan-èšç±»)
    - [5.4 å¹¶è¡Œå±‚æ¬¡èšç±»](#54-å¹¶è¡Œå±‚æ¬¡èšç±»)
  - [6. åŸºäºå‘é‡çš„èšç±»ï¼ˆpgvectorï¼‰](#6-åŸºäºå‘é‡çš„èšç±»pgvector)
    - [5.1 å‘é‡èšç±»æ¦‚è¿°](#51-å‘é‡èšç±»æ¦‚è¿°)
      - [å‘é‡èšç±»åŸç†](#å‘é‡èšç±»åŸç†)
      - [pgvectoræ‰©å±•å®‰è£…](#pgvectoræ‰©å±•å®‰è£…)
    - [5.2 å‘é‡K-meansèšç±»å®ç°](#52-å‘é‡k-meansèšç±»å®ç°)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1 ç”¨æˆ·åˆ†ç¾¤ï¼ˆRFMæ¨¡å‹ï¼‰](#71-ç”¨æˆ·åˆ†ç¾¤rfmæ¨¡å‹)
    - [7.2 å¸‚åœºç»†åˆ†](#72-å¸‚åœºç»†åˆ†)
    - [7.3 å¼‚å¸¸æ£€æµ‹](#73-å¼‚å¸¸æ£€æµ‹)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©)
    - [7.1 ç®—æ³•å¯¹æ¯”](#71-ç®—æ³•å¯¹æ¯”)
    - [7.2 ç®—æ³•é€‰æ‹©æŒ‡å—](#72-ç®—æ³•é€‰æ‹©æŒ‡å—)
    - [7.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#73-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æ•°æ®é¢„å¤„ç†](#81-æ•°æ®é¢„å¤„ç†)
    - [8.2 å‚æ•°è°ƒä¼˜](#82-å‚æ•°è°ƒä¼˜)
    - [8.3 ç»“æœéªŒè¯](#83-ç»“æœéªŒè¯)
    - [8.4 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#84-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
    - [8.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#85-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [8.6 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#86-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## èšç±»åˆ†ææ¦‚è¿°

**èšç±»åˆ†æï¼ˆCluster Analysisï¼‰**æ˜¯æ— ç›‘ç£å­¦ä¹ çš„æ ¸å¿ƒæ–¹æ³•ï¼Œæ—¨åœ¨å°†ç›¸ä¼¼çš„æ•°æ®ç‚¹åˆ†ç»„ï¼Œå‘ç°æ•°æ®ä¸­çš„æ½œåœ¨æ¨¡å¼ã€‚èšç±»åˆ†æå¹¿æ³›åº”ç”¨äºç”¨æˆ·åˆ†ç¾¤ã€å¸‚åœºç»†åˆ†ã€å¼‚å¸¸æ£€æµ‹ã€å›¾åƒåˆ†å‰²ç­‰é¢†åŸŸã€‚

### ç†è®ºåŸºç¡€

#### èšç±»é—®é¢˜çš„æ•°å­¦å®šä¹‰

ç»™å®šæ•°æ®é›† $D = \{x_1, x_2, ..., x_n\}$ï¼Œå…¶ä¸­ $x_i \in \mathbb{R}^d$ æ˜¯ $d$ ç»´ç‰¹å¾å‘é‡ã€‚

**èšç±»**ï¼šå°†æ•°æ®é›† $D$ åˆ’åˆ†ä¸º $k$ ä¸ªä¸ç›¸äº¤çš„å­é›†ï¼ˆç°‡ï¼‰$C_1, C_2, ..., C_k$ï¼Œä½¿å¾—ï¼š

- $\bigcup_{i=1}^k C_i = D$
- $C_i \cap C_j = \emptyset$ï¼ˆ$i \neq j$ï¼‰

**ç›®æ ‡å‡½æ•°**ï¼šæœ€å°åŒ–ç°‡å†…è·ç¦»ï¼Œæœ€å¤§åŒ–ç°‡é—´è·ç¦»ã€‚

#### è·ç¦»åº¦é‡

**æ¬§å‡ é‡Œå¾—è·ç¦»**ï¼š
$$d(x_i, x_j) = \sqrt{\sum_{l=1}^d (x_{il} - x_{jl})^2}$$

**æ›¼å“ˆé¡¿è·ç¦»**ï¼š
$$d(x_i, x_j) = \sum_{l=1}^d |x_{il} - x_{jl}|$$

**ä½™å¼¦ç›¸ä¼¼åº¦**ï¼š
$$\cos(\theta) = \frac{x_i \cdot x_j}{||x_i|| \cdot ||x_j||}$$

### æ ¸å¿ƒèšç±»ç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|--------|------|------|
| **K-means** | å¿«é€Ÿèšç±»ï¼Œçƒå½¢ç°‡ | $O(n \cdot k \cdot i \cdot d)$ | ç®€å•é«˜æ•ˆï¼Œæ”¶æ•›å¿« | éœ€è¦é¢„è®¾kï¼Œå¯¹åˆå§‹å€¼æ•æ„Ÿ |
| **å±‚æ¬¡èšç±»** | æ ‘çŠ¶èšç±»ï¼Œä»»æ„å½¢çŠ¶ | $O(n^2 \log n)$ | ä¸éœ€è¦é¢„è®¾kï¼Œå¯è§†åŒ–å¥½ | è®¡ç®—å¤æ‚åº¦é«˜ |
| **DBSCAN** | å¯†åº¦èšç±»ï¼Œå™ªå£°å¤„ç† | $O(n \log n)$ | è‡ªåŠ¨ç¡®å®šç°‡æ•°ï¼Œå¤„ç†å™ªå£° | å¯¹å‚æ•°æ•æ„Ÿ |
| **è°±èšç±»** | éå‡¸å½¢çŠ¶ç°‡ | $O(n^3)$ | å¤„ç†éå‡¸ç°‡ | è®¡ç®—å¤æ‚åº¦é«˜ |
| **é«˜æ–¯æ··åˆæ¨¡å‹** | æ¦‚ç‡èšç±» | $O(n \cdot k \cdot i \cdot d^2)$ | æ¦‚ç‡åˆ†é…ï¼Œè½¯èšç±» | å‡è®¾é«˜æ–¯åˆ†å¸ƒ |

---

## 1. K-meansèšç±»

### 1.1 K-meansç®—æ³•åŸç†

**K-meansç®—æ³•**æ˜¯æœ€ç»å…¸çš„èšç±»ç®—æ³•ï¼Œç”±MacQueenåœ¨1967å¹´æå‡ºã€‚

#### ç®—æ³•åŸç†

**ç›®æ ‡å‡½æ•°ï¼ˆWithin-Cluster Sum of Squares, WCSSï¼‰**ï¼š
$$J = \sum_{i=1}^k \sum_{x \in C_i} ||x - \mu_i||^2$$

å…¶ä¸­ï¼š

- $k$ æ˜¯ç°‡çš„æ•°é‡
- $C_i$ æ˜¯ç¬¬ $i$ ä¸ªç°‡
- $\mu_i = \frac{1}{|C_i|} \sum_{x \in C_i} x$ æ˜¯ç¬¬ $i$ ä¸ªç°‡çš„ä¸­å¿ƒï¼ˆè´¨å¿ƒï¼‰

**ç®—æ³•æ­¥éª¤**ï¼š

1. **åˆå§‹åŒ–**ï¼šéšæœºé€‰æ‹© $k$ ä¸ªåˆå§‹èšç±»ä¸­å¿ƒ $\mu_1, \mu_2, ..., \mu_k$
2. **åˆ†é…**ï¼šå°†æ¯ä¸ªæ•°æ®ç‚¹åˆ†é…åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
   $$C_i = \{x : ||x - \mu_i||^2 \leq ||x - \mu_j||^2, \forall j \neq i\}$$
3. **æ›´æ–°**ï¼šé‡æ–°è®¡ç®—æ¯ä¸ªç°‡çš„è´¨å¿ƒ
   $$\mu_i = \frac{1}{|C_i|} \sum_{x \in C_i} x$$
4. **é‡å¤**ï¼šé‡å¤æ­¥éª¤2-3ï¼Œç›´åˆ°è´¨å¿ƒä¸å†å˜åŒ–æˆ–è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°

**æ”¶æ•›æ€§**ï¼šK-meansç®—æ³•ä¿è¯æ”¶æ•›ï¼Œå› ä¸ºç›®æ ‡å‡½æ•° $J$ åœ¨æ¯æ¬¡è¿­ä»£ä¸­å•è°ƒé€’å‡ã€‚

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(n \cdot k \cdot i \cdot d)$ï¼Œå…¶ä¸­ï¼š

- $n$ æ˜¯æ•°æ®ç‚¹æ•°
- $k$ æ˜¯ç°‡æ•°
- $i$ æ˜¯è¿­ä»£æ¬¡æ•°ï¼ˆé€šå¸¸ $i < 100$ï¼‰
- $d$ æ˜¯ç‰¹å¾ç»´åº¦

**ç©ºé—´å¤æ‚åº¦**ï¼š$O(n \cdot d + k \cdot d)$

#### åˆå§‹åŒ–æ–¹æ³•

1. **éšæœºåˆå§‹åŒ–**ï¼šéšæœºé€‰æ‹© $k$ ä¸ªæ•°æ®ç‚¹ä½œä¸ºåˆå§‹ä¸­å¿ƒ
2. **K-means++**ï¼šé€‰æ‹©è·ç¦»å·²é€‰ä¸­å¿ƒæœ€è¿œçš„ç‚¹ï¼Œå‡å°‘å¯¹åˆå§‹å€¼çš„æ•æ„Ÿæ€§
3. **Forgyæ–¹æ³•**ï¼šéšæœºåˆ†é…æ•°æ®ç‚¹åˆ°ç°‡ï¼Œç„¶åè®¡ç®—åˆå§‹ä¸­å¿ƒ

### 1.2 K-meanså®Œæ•´è¿­ä»£å®ç°

```sql
-- K-meansèšç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒK-meansèšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒK-meansèšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'K-meansèšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- K-meanså®Œæ•´è¿­ä»£å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    max_iterations INTEGER := 100;
    convergence_threshold NUMERIC := 0.001;
    k_clusters INTEGER := 3;
    iteration_count INTEGER := 0;
    centers_changed BOOLEAN := TRUE;
BEGIN
    BEGIN
        -- æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹æ•°æ®';
            -- åˆ›å»ºç¤ºä¾‹æ•°æ®
            CREATE TABLE data_points (
                id SERIAL PRIMARY KEY,
                x NUMERIC NOT NULL,
                y NUMERIC NOT NULL
            );
            -- æ’å…¥ç¤ºä¾‹æ•°æ®ï¼ˆ3ä¸ªç°‡ï¼‰
            INSERT INTO data_points (x, y) VALUES
                (1, 1), (1.5, 1.2), (0.8, 1.1), (1.2, 0.9),
                (5, 5), (5.5, 5.2), (4.8, 5.1), (5.2, 4.9),
                (9, 9), (9.5, 9.2), (8.8, 9.1), (9.2, 8.9);
        END IF;

        -- åˆ›å»ºèšç±»ç»“æœè¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'kmeans_result') THEN
            DROP TABLE kmeans_result CASCADE;
        END IF;

        CREATE TABLE kmeans_result (
            id INTEGER PRIMARY KEY,
            x NUMERIC NOT NULL,
            y NUMERIC NOT NULL,
            cluster_id INTEGER NOT NULL,
            iteration INTEGER NOT NULL,
            distance_to_center NUMERIC
        );

        RAISE NOTICE 'å¼€å§‹K-meansèšç±»ï¼Œk=%, æœ€å¤§è¿­ä»£æ¬¡æ•°=%', k_clusters, max_iterations;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆå§‹åŒ–å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- K-meansè¿­ä»£ç®—æ³•ï¼šä½¿ç”¨é€’å½’CTEå®ç°å¤šè½®è¿­ä»£
WITH RECURSIVE kmeans_iterations AS (
    -- åˆå§‹è¿­ä»£ï¼šéšæœºåˆå§‹åŒ–èšç±»ä¸­å¿ƒï¼ˆK-means++æ”¹è¿›ï¼‰
    SELECT
        0 AS iteration,
        cluster_id,
        center_x,
        center_y
    FROM (
        WITH random_centers AS (
            SELECT DISTINCT ON (cluster_id)
                id,
                x AS center_x,
                y AS center_y,
                ROW_NUMBER() OVER (ORDER BY RANDOM()) AS cluster_id
            FROM data_points
            LIMIT 3  -- k=3
        )
        SELECT cluster_id, center_x, center_y FROM random_centers
    ) AS init_centers

    UNION ALL

    -- è¿­ä»£ï¼šåˆ†é…æ•°æ®ç‚¹åˆ°æœ€è¿‘ä¸­å¿ƒï¼Œç„¶åæ›´æ–°ä¸­å¿ƒ
    SELECT
        ki.iteration + 1 AS iteration,
        new_cluster_id AS cluster_id,
        new_center_x AS center_x,
        new_center_y AS center_y
    FROM kmeans_iterations ki
    CROSS JOIN LATERAL (
        WITH
        -- è®¡ç®—æ¯ä¸ªç‚¹åˆ°å„ä¸­å¿ƒçš„è·ç¦»
        distances AS (
            SELECT
                p.id,
                p.x,
                p.y,
                ki.cluster_id,
                SQRT(POWER(p.x - ki.center_x, 2) + POWER(p.y - ki.center_y, 2)) AS distance
            FROM data_points p
            CROSS JOIN (SELECT DISTINCT cluster_id FROM kmeans_iterations WHERE iteration = ki.iteration) AS clusters
            CROSS JOIN LATERAL (
                SELECT center_x, center_y
                FROM kmeans_iterations
                WHERE iteration = ki.iteration AND cluster_id = clusters.cluster_id
            ) AS c
        ),
        -- åˆ†é…æ¯ä¸ªç‚¹åˆ°æœ€è¿‘çš„ä¸­å¿ƒ
        assignments AS (
            SELECT DISTINCT ON (id)
                id,
                x,
                y,
                cluster_id,
                distance
            FROM distances
            ORDER BY id, distance
        ),
        -- è®¡ç®—æ–°çš„èšç±»ä¸­å¿ƒ
        new_centers AS (
            SELECT
                cluster_id AS new_cluster_id,
                AVG(x) AS new_center_x,
                AVG(y) AS new_center_y,
                COUNT(*) AS cluster_size
            FROM assignments
            GROUP BY cluster_id
        )
        SELECT new_cluster_id, new_center_x, new_center_y
        FROM new_centers
    ) AS updated_centers
    WHERE ki.iteration < 100  -- æœ€å¤§è¿­ä»£æ¬¡æ•°
      AND EXISTS (
          -- æ£€æŸ¥ä¸­å¿ƒæ˜¯å¦å˜åŒ–ï¼ˆæ”¶æ•›æ¡ä»¶ï¼‰
          SELECT 1 FROM kmeans_iterations ki2
          WHERE ki2.iteration = ki.iteration
            AND ABS(ki2.center_x - updated_centers.new_center_x) > 0.001
            AND ABS(ki2.center_y - updated_centers.new_center_y) > 0.001
      )
),
-- æå–æœ€ç»ˆèšç±»ç»“æœ
final_centers AS (
    SELECT DISTINCT ON (cluster_id)
        cluster_id,
        center_x,
        center_y,
        iteration
    FROM kmeans_iterations
    ORDER BY cluster_id, iteration DESC
),
final_assignments AS (
    SELECT DISTINCT ON (p.id)
        p.id,
        p.x,
        p.y,
        fc.cluster_id,
        SQRT(POWER(p.x - fc.center_x, 2) + POWER(p.y - fc.center_y, 2)) AS distance_to_center
    FROM data_points p
    CROSS JOIN final_centers fc
    ORDER BY p.id, SQRT(POWER(p.x - fc.center_x, 2) + POWER(p.y - fc.center_y, 2))
)
SELECT
    id,
    x,
    y,
    cluster_id,
    ROUND(distance_to_center::numeric, 4) AS distance_to_center,
    (SELECT MAX(iteration) FROM kmeans_iterations) AS total_iterations
FROM final_assignments
ORDER BY cluster_id, id;
```

---

## 2. DBSCANå¯†åº¦èšç±»

### 2.1 DBSCANç®—æ³•åŸç†

**DBSCANï¼ˆDensity-Based Spatial Clustering of Applications with Noiseï¼‰**æ˜¯ä¸€ç§åŸºäºå¯†åº¦çš„èšç±»ç®—æ³•ï¼Œèƒ½å¤Ÿå‘ç°ä»»æ„å½¢çŠ¶çš„ç°‡å¹¶è¯†åˆ«å™ªå£°ç‚¹ã€‚

#### 2.1.1 ç®—æ³•åŸç†

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š

1. **Îµ-é‚»åŸŸ**ï¼šç‚¹ $p$ çš„ Îµ-é‚»åŸŸ $N_\varepsilon(p) = \{q \in D : d(p,q) \leq \varepsilon\}$
2. **æ ¸å¿ƒç‚¹**ï¼šå¦‚æœ $|N_\varepsilon(p)| \geq MinPts$ï¼Œåˆ™ $p$ æ˜¯æ ¸å¿ƒç‚¹
3. **ç›´æ¥å¯†åº¦å¯è¾¾**ï¼šå¦‚æœ $q \in N_\varepsilon(p)$ ä¸” $p$ æ˜¯æ ¸å¿ƒç‚¹ï¼Œåˆ™ $q$ ä» $p$ ç›´æ¥å¯†åº¦å¯è¾¾
4. **å¯†åº¦å¯è¾¾**ï¼šå­˜åœ¨ç‚¹åºåˆ— $p_1, p_2, ..., p_n$ï¼Œä½¿å¾— $p_{i+1}$ ä» $p_i$ ç›´æ¥å¯†åº¦å¯è¾¾
5. **å¯†åº¦ç›¸è¿**ï¼šå¦‚æœå­˜åœ¨ç‚¹ $o$ï¼Œä½¿å¾— $p$ å’Œ $q$ éƒ½ä» $o$ å¯†åº¦å¯è¾¾ï¼Œåˆ™ $p$ å’Œ $q$ å¯†åº¦ç›¸è¿

**ç®—æ³•æ­¥éª¤**ï¼š

1. æ ‡è®°æ‰€æœ‰ç‚¹ä¸ºæœªè®¿é—®
2. å¯¹äºæ¯ä¸ªæœªè®¿é—®ç‚¹ $p$ï¼š
   - å¦‚æœ $p$ æ˜¯æ ¸å¿ƒç‚¹ï¼Œåˆ›å»ºæ–°ç°‡ $C$ï¼Œå°† $p$ çš„æ‰€æœ‰å¯†åº¦å¯è¾¾ç‚¹åŠ å…¥ $C$
   - å¦åˆ™æ ‡è®°ä¸ºå™ªå£°
3. é‡å¤ç›´åˆ°æ‰€æœ‰ç‚¹è¢«è®¿é—®

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(n \log n)$ï¼ˆä½¿ç”¨ç©ºé—´ç´¢å¼•ï¼‰æˆ– $O(n^2)$ï¼ˆæš´åŠ›æœç´¢ï¼‰

**ç©ºé—´å¤æ‚åº¦**ï¼š$O(n)$

**ä¼˜ç‚¹**ï¼š

- ä¸éœ€è¦é¢„è®¾ç°‡æ•°
- å¯ä»¥å‘ç°ä»»æ„å½¢çŠ¶çš„ç°‡
- èƒ½å¤Ÿè¯†åˆ«å™ªå£°ç‚¹

**ç¼ºç‚¹**ï¼š

- å¯¹å‚æ•° $\varepsilon$ å’Œ $MinPts$ æ•æ„Ÿ
- éš¾ä»¥å¤„ç†å¯†åº¦å·®å¼‚å¤§çš„æ•°æ®

### 2.2 DBSCANç®—æ³•å®ç°

```sql
-- DBSCANç®—æ³•å®ç°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    epsilon NUMERIC := 1.5;  -- Îµé‚»åŸŸåŠå¾„
    min_points INTEGER := 3;  -- æœ€å°ç‚¹æ•°
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨';
            RETURN;
        END IF;

        RAISE NOTICE 'å¼€å§‹DBSCANèšç±»ï¼ŒÎµ=%, MinPts=%', epsilon, min_points;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆå§‹åŒ–å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- DBSCANç®—æ³•ï¼šä½¿ç”¨é€’å½’CTEå®ç°å¯†åº¦è¿æ¥
WITH RECURSIVE
-- è®¡ç®—æ‰€æœ‰ç‚¹ä¹‹é—´çš„è·ç¦»
point_distances AS (
    SELECT
        p1.id AS point1_id,
        p2.id AS point2_id,
        SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) AS distance
    FROM data_points p1
    CROSS JOIN data_points p2
    WHERE p1.id != p2.id
),
-- æ‰¾åˆ°Îµ-é‚»åŸŸ
epsilon_neighborhoods AS (
    SELECT
        point1_id AS point_id,
        point2_id AS neighbor_id,
        distance
    FROM point_distances
    WHERE distance <= 1.5  -- Îµå€¼
),
-- è¯†åˆ«æ ¸å¿ƒç‚¹
core_points AS (
    SELECT
        point_id,
        COUNT(*) AS neighbor_count
    FROM epsilon_neighborhoods
    GROUP BY point_id
    HAVING COUNT(*) >= 3  -- MinPts
),
-- DBSCANèšç±»ï¼šä»æ ¸å¿ƒç‚¹æ‰©å±•
dbscan_clusters AS (
    -- èµ·å§‹ï¼šæ¯ä¸ªæ ¸å¿ƒç‚¹å¼€å§‹ä¸€ä¸ªæ–°ç°‡
    SELECT DISTINCT
        cp.point_id AS cluster_seed,
        cp.point_id AS current_point,
        DENSE_RANK() OVER (ORDER BY cp.point_id) AS cluster_id,
        0 AS depth
    FROM core_points cp

    UNION ALL

    -- é€’å½’ï¼šæ‰©å±•ç°‡ï¼ˆå¯†åº¦å¯è¾¾çš„ç‚¹ï¼‰
    SELECT
        dc.cluster_seed,
        en.neighbor_id AS current_point,
        dc.cluster_id,
        dc.depth + 1
    FROM dbscan_clusters dc
    JOIN epsilon_neighborhoods en ON dc.current_point = en.point_id
    WHERE dc.depth < 100  -- é™åˆ¶é€’å½’æ·±åº¦
      AND en.neighbor_id NOT IN (
          SELECT current_point FROM dbscan_clusters WHERE cluster_id = dc.cluster_id
      )
)
SELECT DISTINCT ON (current_point)
    current_point AS point_id,
    cluster_id,
    (SELECT x FROM data_points WHERE id = current_point) AS x,
    (SELECT y FROM data_points WHERE id = current_point) AS y
FROM dbscan_clusters
ORDER BY current_point, cluster_id;
```

## 3. å±‚æ¬¡èšç±»

### 3.1 å±‚æ¬¡èšç±»ç®—æ³•åŸç†

**å±‚æ¬¡èšç±»ï¼ˆHierarchical Clusteringï¼‰**é€šè¿‡æ„å»ºæ ‘çŠ¶ç»“æ„ï¼ˆæ ‘çŠ¶å›¾ï¼‰æ¥ç»„ç»‡æ•°æ®ï¼Œä¸éœ€è¦é¢„è®¾ç°‡æ•°ã€‚

#### ç®—æ³•ç±»å‹

1. **å‡èšèšç±»ï¼ˆAgglomerativeï¼‰**ï¼šè‡ªåº•å‘ä¸Šï¼Œä»å•ä¸ªç‚¹å¼€å§‹åˆå¹¶
2. **åˆ†è£‚èšç±»ï¼ˆDivisiveï¼‰**ï¼šè‡ªé¡¶å‘ä¸‹ï¼Œä»æ‰€æœ‰ç‚¹å¼€å§‹åˆ†è£‚

#### é“¾æ¥å‡†åˆ™

1. **å•é“¾æ¥ï¼ˆSingle Linkageï¼‰**ï¼š$d(C_i, C_j) = \min_{x \in C_i, y \in C_j} d(x,y)$
2. **å®Œå…¨é“¾æ¥ï¼ˆComplete Linkageï¼‰**ï¼š$d(C_i, C_j) = \max_{x \in C_i, y \in C_j} d(x,y)$
3. **å¹³å‡é“¾æ¥ï¼ˆAverage Linkageï¼‰**ï¼š$d(C_i, C_j) = \frac{1}{|C_i||C_j|} \sum_{x \in C_i} \sum_{y \in C_j} d(x,y)$
4. **Wardé“¾æ¥**ï¼šæœ€å°åŒ–åˆå¹¶åçš„ç°‡å†…å¹³æ–¹å’Œå¢é‡

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(n^2 \log n)$ï¼ˆå•é“¾æ¥ï¼‰æˆ– $O(n^3)$ï¼ˆå…¶ä»–é“¾æ¥ï¼‰

**ç©ºé—´å¤æ‚åº¦**ï¼š$O(n^2)$ï¼ˆè·ç¦»çŸ©é˜µï¼‰

### 3.2 è·ç¦»çŸ©é˜µè®¡ç®—

```sql
-- è·ç¦»çŸ©é˜µè®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—è·ç¦»çŸ©é˜µ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—è·ç¦»çŸ©é˜µ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è·ç¦»çŸ©é˜µè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    p1.id AS point1_id,
    p2.id AS point2_id,
    SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) AS distance
FROM data_points p1
CROSS JOIN data_points p2
WHERE p1.id < p2.id
ORDER BY distance;
```

---

## 4. èšç±»è¯„ä¼°æŒ‡æ ‡

### 4.1 è½®å»“ç³»æ•°ï¼ˆSilhouette Coefficientï¼‰

**è½®å»“ç³»æ•°**è¯„ä¼°èšç±»è´¨é‡ï¼Œè¡¡é‡æ•°æ®ç‚¹ä¸å…¶æ‰€å±ç°‡çš„ç›¸ä¼¼åº¦ç›¸å¯¹äºå…¶ä»–ç°‡çš„ç›¸ä¼¼åº¦ã€‚

**æ•°å­¦å®šä¹‰**ï¼š

å¯¹äºæ•°æ®ç‚¹ $i$ï¼š

- $a(i)$ï¼šç‚¹ $i$ åˆ°åŒç°‡å…¶ä»–ç‚¹çš„å¹³å‡è·ç¦»
- $b(i)$ï¼šç‚¹ $i$ åˆ°æœ€è¿‘å…¶ä»–ç°‡æ‰€æœ‰ç‚¹çš„å¹³å‡è·ç¦»

**è½®å»“ç³»æ•°**ï¼š
$$s(i) = \frac{b(i) - a(i)}{\max\{a(i), b(i)\}}$$

**æ•´ä½“è½®å»“ç³»æ•°**ï¼š
$$S = \frac{1}{n} \sum_{i=1}^n s(i)$$

**å–å€¼èŒƒå›´**ï¼š$[-1, 1]$

- $s(i) \approx 1$ï¼šç‚¹ $i$ è¢«å¾ˆå¥½åœ°åˆ†é…åˆ°ç°‡ä¸­
- $s(i) \approx 0$ï¼šç‚¹ $i$ åœ¨ä¸¤ä¸ªç°‡çš„è¾¹ç•Œä¸Š
- $s(i) \approx -1$ï¼šç‚¹ $i$ è¢«åˆ†é…åˆ°é”™è¯¯çš„ç°‡

### 4.2 è½®å»“ç³»æ•°è®¡ç®—

```sql
-- è½®å»“ç³»æ•°è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    avg_silhouette NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'clustered_points') THEN
            RAISE WARNING 'è¡¨ clustered_points ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—è½®å»“ç³»æ•°';
            RETURN;
        END IF;

        -- è®¡ç®—å¹³å‡è½®å»“ç³»æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
        WITH intra_cluster_distances AS (
            SELECT
                cluster_id,
                AVG(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))) AS avg_intra_distance
            FROM clustered_points p1
            JOIN clustered_points p2 ON p1.cluster_id = p2.cluster_id
            WHERE p1.id < p2.id
            GROUP BY cluster_id
        ),
        inter_cluster_distances AS (
            SELECT
                p1.cluster_id,
                AVG(SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2))) AS avg_inter_distance
            FROM clustered_points p1
            JOIN clustered_points p2 ON p1.cluster_id != p2.cluster_id
            GROUP BY p1.cluster_id
        )
        SELECT AVG((ic.avg_inter_distance - ia.avg_intra_distance) / NULLIF(GREATEST(ic.avg_inter_distance, ia.avg_intra_distance), 0))
        INTO avg_silhouette
        FROM intra_cluster_distances ia
        JOIN inter_cluster_distances ic ON ia.cluster_id = ic.cluster_id;

        RAISE NOTICE 'å¹³å‡è½®å»“ç³»æ•°: % (èŒƒå›´: -1åˆ°1ï¼Œè¶Šå¤§è¶Šå¥½)', avg_silhouette;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è½®å»“ç³»æ•°è®¡ç®—å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

### 4.3 å…¶ä»–è¯„ä¼°æŒ‡æ ‡

#### 4.3.1 ç°‡å†…å¹³æ–¹å’Œï¼ˆWCSSï¼‰

**WCSSï¼ˆWithin-Cluster Sum of Squaresï¼‰**ï¼š
$$WCSS = \sum_{i=1}^k \sum_{x \in C_i} ||x - \mu_i||^2$$

#### 4.3.2 ç°‡é—´å¹³æ–¹å’Œï¼ˆBCSSï¼‰

**BCSSï¼ˆBetween-Cluster Sum of Squaresï¼‰**ï¼š
$$BCSS = \sum_{i=1}^k |C_i| \cdot ||\mu_i - \mu||^2$$

å…¶ä¸­ $\mu$ æ˜¯å…¨å±€ä¸­å¿ƒã€‚

#### 4.3.3 è½®å»“ç³»æ•°ã€WCSSã€BCSSç»¼åˆè¯„ä¼°

```sql
-- ç»¼åˆèšç±»è¯„ä¼°
WITH cluster_stats AS (
    SELECT
        cluster_id,
        COUNT(*) AS cluster_size,
        AVG(x) AS center_x,
        AVG(y) AS center_y,
        -- WCSSï¼šç°‡å†…å¹³æ–¹å’Œ
        SUM(POWER(x - AVG(x) OVER (PARTITION BY cluster_id), 2) +
            POWER(y - AVG(y) OVER (PARTITION BY cluster_id), 2)) AS wcss
    FROM clustered_points
    GROUP BY cluster_id
),
global_stats AS (
    SELECT
        AVG(x) AS global_center_x,
        AVG(y) AS global_center_y
    FROM clustered_points
),
cluster_evaluation AS (
    SELECT
        cs.cluster_id,
        cs.cluster_size,
        cs.wcss,
        -- BCSSï¼šç°‡é—´å¹³æ–¹å’Œ
        cs.cluster_size * (
            POWER(cs.center_x - gs.global_center_x, 2) +
            POWER(cs.center_y - gs.global_center_y, 2)
        ) AS bcss,
        -- è½®å»“ç³»æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
        (SELECT AVG(silhouette_score) FROM (
            SELECT
                cp1.id,
                -- a(i)ï¼šåŒç°‡å¹³å‡è·ç¦»
                AVG(SQRT(POWER(cp1.x - cp2.x, 2) + POWER(cp1.y - cp2.y, 2))) AS a_i
            FROM clustered_points cp1
            JOIN clustered_points cp2 ON cp1.cluster_id = cp2.cluster_id
            WHERE cp1.id != cp2.id
            GROUP BY cp1.id
        ) AS intra_dist) AS avg_silhouette
    FROM cluster_stats cs
    CROSS JOIN global_stats gs
)
SELECT
    cluster_id,
    cluster_size,
    ROUND(wcss::numeric, 4) AS within_cluster_ss,
    ROUND(bcss::numeric, 4) AS between_cluster_ss,
    ROUND((bcss / NULLIF(wcss, 0))::numeric, 4) AS separation_ratio,
    ROUND(avg_silhouette::numeric, 4) AS avg_silhouette_score
FROM cluster_evaluation
ORDER BY cluster_id;
```

## 5. PostgreSQL 18 å¹¶è¡Œèšç±»å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œèšç±»èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œ K-meansã€DBSCAN å’Œå±‚æ¬¡èšç±»æ“ä½œï¼Œå¤§å¹…æå‡å¤§æ•°æ®é‡èšç±»æŸ¥è¯¢çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œèšç±»åŸç†

PostgreSQL 18 çš„å¹¶è¡Œèšç±»é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æè¡¨æ•°æ®
2. **å¹¶è¡Œè·ç¦»è®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—è·ç¦»çŸ©é˜µ
3. **å¹¶è¡Œèšç±»åˆ†é…**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡Œèšç±»åˆ†é…
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„èšç±»ç»“æœ

### 5.2 å¹¶è¡Œ K-means èšç±»

```sql
-- PostgreSQL 18 å¹¶è¡Œ K-means èšç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒK-meansèšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒK-meansèšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒK-meansèšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒK-meansèšç±»ï¼šè®¡ç®—è·ç¦»å’Œåˆ†é…èšç±»
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH initial_centers AS (
    SELECT
        ROW_NUMBER() OVER () AS cluster_id,
        x AS center_x,
        y AS center_y
    FROM (
        SELECT x, y FROM data_points ORDER BY RANDOM() LIMIT 3
    ) t
),
distances AS (
    SELECT
        d.id,
        d.x,
        d.y,
        c.cluster_id,
        SQRT(POWER(d.x - c.center_x, 2) + POWER(d.y - c.center_y, 2)) AS distance
    FROM data_points d
    CROSS JOIN initial_centers c
),
closest_clusters AS (
    SELECT
        id,
        x,
        y,
        cluster_id,
        ROW_NUMBER() OVER (PARTITION BY id ORDER BY distance) AS rn
    FROM distances
)
SELECT
    id,
    x,
    y,
    cluster_id
FROM closest_clusters
WHERE rn = 1
ORDER BY cluster_id, id;
```

### 5.3 å¹¶è¡Œ DBSCAN èšç±»

```sql
-- PostgreSQL 18 å¹¶è¡Œ DBSCAN èšç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒDBSCANèšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒDBSCANèšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒDBSCANèšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒDBSCANèšç±»ï¼šå¹¶è¡Œè®¡ç®—Îµ-é‚»åŸŸ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH point_distances AS (
    SELECT
        p1.id AS point_id,
        p2.id AS point2_id,
        SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) AS distance
    FROM data_points p1
    CROSS JOIN data_points p2
    WHERE p1.id != p2.id
),
epsilon_neighborhoods AS (
    SELECT
        point_id,
        point2_id AS neighbor_id,
        distance
    FROM point_distances
    WHERE distance <= 1.5  -- Îµå€¼
),
core_points AS (
    SELECT
        point_id,
        COUNT(*) AS neighbor_count
    FROM epsilon_neighborhoods
    GROUP BY point_id
    HAVING COUNT(*) >= 3  -- MinPts
)
SELECT
    point_id,
    neighbor_count,
    CASE
        WHEN neighbor_count >= 3 THEN 'Core Point'
        ELSE 'Border Point'
    END AS point_type
FROM core_points
ORDER BY neighbor_count DESC;
```

### 5.4 å¹¶è¡Œå±‚æ¬¡èšç±»

```sql
-- PostgreSQL 18 å¹¶è¡Œå±‚æ¬¡èšç±»ï¼šå¹¶è¡Œè®¡ç®—è·ç¦»çŸ©é˜µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå±‚æ¬¡èšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå±‚æ¬¡èšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå±‚æ¬¡èšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå±‚æ¬¡èšç±»ï¼šå¹¶è¡Œè®¡ç®—è·ç¦»çŸ©é˜µ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    p1.id AS point1_id,
    p2.id AS point2_id,
    SQRT(POWER(p1.x - p2.x, 2) + POWER(p1.y - p2.y, 2)) AS distance
FROM data_points p1
CROSS JOIN data_points p2
WHERE p1.id < p2.id
ORDER BY distance
LIMIT 100;  -- è¿”å›æœ€è¿‘çš„100å¯¹ç‚¹
```

## 6. åŸºäºå‘é‡çš„èšç±»ï¼ˆpgvectorï¼‰

### 5.1 å‘é‡èšç±»æ¦‚è¿°

**åŸºäºå‘é‡çš„èšç±»ï¼ˆVector-based Clusteringï¼‰**ï¼šä½¿ç”¨pgvectoræ‰©å±•è¿›è¡Œé«˜ç»´å‘é‡æ•°æ®çš„èšç±»ï¼Œç‰¹åˆ«é€‚ç”¨äºæ–‡æœ¬ã€å›¾åƒç­‰åµŒå…¥å‘é‡çš„èšç±»ã€‚

#### å‘é‡èšç±»åŸç†

**å‘é‡èšç±»**ï¼šå¯¹é«˜ç»´å‘é‡æ•°æ®è¿›è¡Œèšç±»ï¼Œé€šè¿‡å‘é‡ç›¸ä¼¼åº¦ï¼ˆå¦‚ä½™å¼¦ç›¸ä¼¼åº¦ï¼‰è¿›è¡Œåˆ†ç»„ã€‚

**å‘é‡èšç±»ä¼˜åŠ¿**ï¼š

- æ”¯æŒé«˜ç»´æ•°æ®
- è¯­ä¹‰ç›¸ä¼¼åº¦èšç±»
- å¯ä»¥ç»“åˆé¢„è®­ç»ƒæ¨¡å‹

#### pgvectoræ‰©å±•å®‰è£…

```sql
-- å®‰è£…pgvectoræ‰©å±•ï¼ˆéœ€è¦PostgreSQL 11+ï¼‰
DO $$
BEGIN
    BEGIN
        CREATE EXTENSION IF NOT EXISTS vector;
        RAISE NOTICE 'pgvectoræ‰©å±•å·²å¯ç”¨';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'pgvectoræ‰©å±•å®‰è£…å¤±è´¥: %ã€‚è¯·ç¡®ä¿å·²å®‰è£…pgvectoræ‰©å±•ã€‚', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 å‘é‡K-meansèšç±»å®ç°

**åˆ›å»ºå‘é‡æ•°æ®è¡¨**ï¼š

```sql
-- åˆ›å»ºå‘é‡æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data') THEN
            RAISE WARNING 'è¡¨ vector_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE vector_data CASCADE;
        END IF;

        -- åˆ›å»ºåŒ…å«å‘é‡çš„æ•°æ®è¡¨
        CREATE TABLE vector_data (
            id SERIAL PRIMARY KEY,
            data_label TEXT,
            -- ä½¿ç”¨vectorç±»å‹å­˜å‚¨128ç»´å‘é‡
            feature_vector vector(128),
            cluster_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        -- åˆ›å»ºå‘é‡ç›¸ä¼¼åº¦ç´¢å¼•ï¼ˆHNSWç´¢å¼•ï¼ŒPostgreSQL 18+ï¼‰
        CREATE INDEX idx_vector_data_vector
        ON vector_data
        USING hnsw (feature_vector vector_cosine_ops)
        WITH (m = 16, ef_construction = 64);

        RAISE NOTICE 'å‘é‡æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åˆ›å»ºå‘é‡æ•°æ®è¡¨å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**å‘é‡K-meansèšç±»**ï¼š

```sql
-- å‘é‡K-meansèšç±»ï¼šåŸºäºå‘é‡ç›¸ä¼¼åº¦çš„K-meansèšç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data') THEN
            RAISE WARNING 'è¡¨ vector_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå‘é‡èšç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå‘é‡K-meansèšç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å‘é‡èšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å‘é‡K-meansèšç±»ï¼šåˆå§‹åŒ–èšç±»ä¸­å¿ƒï¼ˆéšæœºé€‰æ‹©Kä¸ªç‚¹ï¼‰
WITH k_centers AS (
    SELECT
        id,
        feature_vector,
        ROW_NUMBER() OVER (ORDER BY RANDOM()) AS center_id
    FROM vector_data
    LIMIT 3  -- K=3
),
-- è®¡ç®—æ¯ä¸ªç‚¹åˆ°æœ€è¿‘èšç±»ä¸­å¿ƒçš„è·ç¦»
point_to_center_distances AS (
    SELECT
        vd.id,
        vd.feature_vector,
        kc.center_id,
        1 - (vd.feature_vector <=> kc.feature_vector) AS similarity
    FROM vector_data vd
    CROSS JOIN k_centers kc
),
-- åˆ†é…æ¯ä¸ªç‚¹åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
cluster_assignments AS (
    SELECT DISTINCT ON (id)
        id,
        center_id AS cluster_id,
        similarity
    FROM point_to_center_distances
    ORDER BY id, similarity DESC
)
-- æ›´æ–°èšç±»åˆ†é…
UPDATE vector_data vd
SET cluster_id = ca.cluster_id
FROM cluster_assignments ca
WHERE vd.id = ca.id;
```

**å‘é‡èšç±»ç»“æœåˆ†æ**ï¼š

```sql
-- å‘é‡èšç±»ç»“æœåˆ†æï¼šç»Ÿè®¡æ¯ä¸ªç°‡çš„ç‰¹å¾
WITH cluster_centroids AS (
    SELECT
        cluster_id,
        AVG(feature_vector) AS centroid_vector,
        COUNT(*) AS cluster_size
    FROM vector_data
    WHERE cluster_id IS NOT NULL
    GROUP BY cluster_id
),
cluster_statistics AS (
    SELECT
        vd.cluster_id,
        cc.cluster_size,
        AVG(1 - (vd.feature_vector <=> cc.centroid_vector)) AS avg_similarity,
        MIN(1 - (vd.feature_vector <=> cc.centroid_vector)) AS min_similarity,
        MAX(1 - (vd.feature_vector <=> cc.centroid_vector)) AS max_similarity
    FROM vector_data vd
    JOIN cluster_centroids cc ON vd.cluster_id = cc.cluster_id
    GROUP BY vd.cluster_id, cc.cluster_size
)
SELECT
    cluster_id,
    cluster_size,
    ROUND(avg_similarity::numeric, 4) AS avg_similarity,
    ROUND(min_similarity::numeric, 4) AS min_similarity,
    ROUND(max_similarity::numeric, 4) AS max_similarity,
    CASE
        WHEN avg_similarity > 0.8 THEN 'High Cohesion'
        WHEN avg_similarity > 0.6 THEN 'Medium Cohesion'
        ELSE 'Low Cohesion'
    END AS cohesion_level
FROM cluster_statistics
ORDER BY cluster_id;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1 ç”¨æˆ·åˆ†ç¾¤ï¼ˆRFMæ¨¡å‹ï¼‰

**ç”¨æˆ·åˆ†ç¾¤**æ ¹æ®ç”¨æˆ·è¡Œä¸ºç‰¹å¾è¿›è¡Œåˆ†ç¾¤ï¼Œç”¨äºç²¾å‡†è¥é”€å’Œä¸ªæ€§åŒ–æ¨èã€‚

**RFMæ¨¡å‹**ï¼šRecencyï¼ˆæœ€è¿‘è´­ä¹°æ—¶é—´ï¼‰ã€Frequencyï¼ˆè´­ä¹°é¢‘ç‡ï¼‰ã€Monetaryï¼ˆè´­ä¹°é‡‘é¢ï¼‰

```sql
-- ç”¨æˆ·åˆ†ç¾¤ï¼šåŸºäºRFMæ¨¡å‹çš„K-meansèšç±»
DO $$
BEGIN
    BEGIN
        -- åˆ›å»ºç”¨æˆ·ç‰¹å¾è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_features') THEN
            CREATE TABLE user_features (
                user_id INTEGER PRIMARY KEY,
                total_orders INTEGER NOT NULL,
                total_amount NUMERIC NOT NULL,
                last_visit_days INTEGER NOT NULL,
                avg_order_value NUMERIC NOT NULL
            );

            -- æ’å…¥ç¤ºä¾‹æ•°æ®
            INSERT INTO user_features (user_id, total_orders, total_amount, last_visit_days, avg_order_value) VALUES
                (1, 15, 5000, 5, 333.33),
                (2, 8, 2000, 30, 250.00),
                (3, 25, 10000, 2, 400.00),
                (4, 3, 500, 60, 166.67),
                (5, 12, 4500, 10, 375.00);
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç”¨æˆ·åˆ†ç¾¤ï¼ˆRFMæ¨¡å‹ï¼‰';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç”¨æˆ·åˆ†ç¾¤å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ­¥éª¤1ï¼šç‰¹å¾æ ‡å‡†åŒ–ï¼ˆZ-scoreæ ‡å‡†åŒ–ï¼‰
WITH normalized_features AS (
    SELECT
        user_id,
        total_orders,
        total_amount,
        last_visit_days,
        -- Z-scoreæ ‡å‡†åŒ–
        (total_orders - AVG(total_orders) OVER ()) / NULLIF(STDDEV(total_orders) OVER (), 0) AS norm_orders,
        (total_amount - AVG(total_amount) OVER ()) / NULLIF(STDDEV(total_amount) OVER (), 0) AS norm_amount,
        (last_visit_days - AVG(last_visit_days) OVER ()) / NULLIF(STDDEV(last_visit_days) OVER (), 0) AS norm_recency
    FROM user_features
),
-- æ­¥éª¤2ï¼šK-meansèšç±»ï¼ˆk=5ï¼Œå¯¹åº”5ä¸ªç”¨æˆ·ç¾¤ä½“ï¼‰
initial_clusters AS (
    SELECT
        user_id,
        norm_orders,
        norm_amount,
        norm_recency,
        -- ä½¿ç”¨NTILEè¿›è¡Œåˆå§‹èšç±»
        NTILE(5) OVER (ORDER BY norm_orders DESC, norm_amount DESC, norm_recency ASC) AS cluster_id
    FROM normalized_features
),
-- æ­¥éª¤3ï¼šè®¡ç®—èšç±»ä¸­å¿ƒ
cluster_centers AS (
    SELECT
        cluster_id,
        AVG(norm_orders) AS center_orders,
        AVG(norm_amount) AS center_amount,
        AVG(norm_recency) AS center_recency,
        COUNT(*) AS cluster_size
    FROM initial_clusters
    GROUP BY cluster_id
),
-- æ­¥éª¤4ï¼šé‡æ–°åˆ†é…ï¼ˆè¿­ä»£ä¸€æ¬¡ï¼‰
distances AS (
    SELECT
        ic.user_id,
        ic.norm_orders,
        ic.norm_amount,
        ic.norm_recency,
        cc.cluster_id,
        SQRT(
            POWER(ic.norm_orders - cc.center_orders, 2) +
            POWER(ic.norm_amount - cc.center_amount, 2) +
            POWER(ic.norm_recency - cc.center_recency, 2)
        ) AS distance
    FROM initial_clusters ic
    CROSS JOIN cluster_centers cc
),
final_clusters AS (
    SELECT DISTINCT ON (user_id)
        user_id,
        cluster_id,
        distance
    FROM distances
    ORDER BY user_id, distance
)
-- æ­¥éª¤5ï¼šè¾“å‡ºèšç±»ç»“æœå’Œç»Ÿè®¡ä¿¡æ¯
SELECT
    fc.cluster_id,
    cc.cluster_size,
    uf.user_id,
    uf.total_orders,
    uf.total_amount,
    uf.last_visit_days,
    ROUND(uf.avg_order_value::numeric, 2) AS avg_order_value,
    CASE
        WHEN fc.cluster_id = 1 THEN 'é«˜ä»·å€¼æ´»è·ƒç”¨æˆ·'
        WHEN fc.cluster_id = 2 THEN 'é«˜ä»·å€¼æµå¤±ç”¨æˆ·'
        WHEN fc.cluster_id = 3 THEN 'ä¸­ä»·å€¼ç”¨æˆ·'
        WHEN fc.cluster_id = 4 THEN 'ä½ä»·å€¼æ´»è·ƒç”¨æˆ·'
        ELSE 'ä½ä»·å€¼æµå¤±ç”¨æˆ·'
    END AS user_segment,
    ROUND(fc.distance::numeric, 4) AS distance_to_center
FROM final_clusters fc
JOIN user_features uf ON fc.user_id = uf.user_id
JOIN cluster_centers cc ON fc.cluster_id = cc.cluster_id
ORDER BY fc.cluster_id, uf.total_amount DESC;
```

### 7.2 å¸‚åœºç»†åˆ†

**åœºæ™¯**ï¼šæ ¹æ®å®¢æˆ·è´­ä¹°è¡Œä¸ºè¿›è¡Œå¸‚åœºç»†åˆ†ï¼Œåˆ¶å®šå·®å¼‚åŒ–è¥é”€ç­–ç•¥ã€‚

```sql
-- å¸‚åœºç»†åˆ†ï¼šåŸºäºè´­ä¹°è¡Œä¸ºçš„èšç±»åˆ†æ
WITH customer_features AS (
    SELECT
        customer_id,
        -- è´­ä¹°é¢‘ç‡
        COUNT(DISTINCT order_date) AS purchase_frequency,
        -- å¹³å‡è®¢å•é‡‘é¢
        AVG(order_amount) AS avg_order_value,
        -- äº§å“å¤šæ ·æ€§
        COUNT(DISTINCT product_id) AS product_diversity,
        -- æœ€è¿‘è´­ä¹°å¤©æ•°
        CURRENT_DATE - MAX(order_date) AS days_since_last_purchase
    FROM orders
    GROUP BY customer_id
),
normalized_features AS (
    SELECT
        customer_id,
        (purchase_frequency - AVG(purchase_frequency) OVER ()) / NULLIF(STDDEV(purchase_frequency) OVER (), 0) AS norm_frequency,
        (avg_order_value - AVG(avg_order_value) OVER ()) / NULLIF(STDDEV(avg_order_value) OVER (), 0) AS norm_value,
        (product_diversity - AVG(product_diversity) OVER ()) / NULLIF(STDDEV(product_diversity) OVER (), 0) AS norm_diversity,
        (days_since_last_purchase - AVG(days_since_last_purchase) OVER ()) / NULLIF(STDDEV(days_since_last_purchase) OVER (), 0) AS norm_recency
    FROM customer_features
)
-- ä½¿ç”¨K-meansè¿›è¡Œå¸‚åœºç»†åˆ†ï¼ˆk=4ï¼š4ä¸ªç»†åˆ†å¸‚åœºï¼‰
SELECT
    customer_id,
    NTILE(4) OVER (ORDER BY norm_frequency, norm_value, norm_diversity, norm_recency) AS market_segment
FROM normalized_features;
```

### 7.3 å¼‚å¸¸æ£€æµ‹

**åœºæ™¯**ï¼šä½¿ç”¨DBSCANè¯†åˆ«å¼‚å¸¸äº¤æ˜“æˆ–å¼‚å¸¸ç”¨æˆ·è¡Œä¸ºã€‚

```sql
-- å¼‚å¸¸æ£€æµ‹ï¼šä½¿ç”¨DBSCANè¯†åˆ«å¼‚å¸¸äº¤æ˜“
WITH transaction_features AS (
    SELECT
        transaction_id,
        amount,
        transaction_time,
        EXTRACT(HOUR FROM transaction_time) AS hour_of_day,
        EXTRACT(DOW FROM transaction_time) AS day_of_week
    FROM transactions
),
normalized_features AS (
    SELECT
        transaction_id,
        (amount - AVG(amount) OVER ()) / NULLIF(STDDEV(amount) OVER (), 0) AS norm_amount,
        (hour_of_day - AVG(hour_of_day) OVER ()) / NULLIF(STDDEV(hour_of_day) OVER (), 0) AS norm_hour,
        (day_of_week - AVG(day_of_week) OVER ()) / NULLIF(STDDEV(day_of_week) OVER (), 0) AS norm_day
    FROM transaction_features
)
-- DBSCANï¼šå¯†åº¦ä½çš„ç‚¹æ ‡è®°ä¸ºå¼‚å¸¸
SELECT
    transaction_id,
    amount,
    CASE
        WHEN cluster_id IS NULL THEN 'å¼‚å¸¸äº¤æ˜“'
        ELSE 'æ­£å¸¸äº¤æ˜“'
    END AS anomaly_status
FROM normalized_features nf
LEFT JOIN dbscan_result dr ON nf.transaction_id = dr.point_id;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©

### 7.1 ç®—æ³•å¯¹æ¯”

| ç‰¹æ€§ | K-means | DBSCAN | å±‚æ¬¡èšç±» |
|------|---------|--------|---------|
| **ç°‡å½¢çŠ¶** | çƒå½¢ | ä»»æ„å½¢çŠ¶ | ä»»æ„å½¢çŠ¶ |
| **é¢„è®¾ç°‡æ•°** | éœ€è¦ | ä¸éœ€è¦ | ä¸éœ€è¦ |
| **å™ªå£°å¤„ç†** | æ—  | æœ‰ | æ—  |
| **æ—¶é—´å¤æ‚åº¦** | $O(nki)$ | $O(n \log n)$ | $O(n^2 \log n)$ |
| **ç©ºé—´å¤æ‚åº¦** | $O(nd)$ | $O(n)$ | $O(n^2)$ |
| **é€‚ç”¨åœºæ™¯** | å¤§è§„æ¨¡æ•°æ®ï¼Œçƒå½¢ç°‡ | ä»»æ„å½¢çŠ¶ï¼Œå™ªå£°æ•°æ® | å°è§„æ¨¡æ•°æ®ï¼Œå¯è§†åŒ– |

### 7.2 ç®—æ³•é€‰æ‹©æŒ‡å—

**é€‰æ‹©K-meanså½“**ï¼š

- æ•°æ®è§„æ¨¡å¤§ï¼ˆ$n > 10000$ï¼‰
- ç°‡æ˜¯çƒå½¢çš„
- éœ€è¦å¿«é€Ÿç»“æœ
- ç°‡æ•°å·²çŸ¥æˆ–å¯ä¼°è®¡

**é€‰æ‹©DBSCANå½“**ï¼š

- ç°‡å½¢çŠ¶ä¸è§„åˆ™
- å­˜åœ¨å™ªå£°æ•°æ®
- ç°‡æ•°æœªçŸ¥
- éœ€è¦è¯†åˆ«å¼‚å¸¸ç‚¹

**é€‰æ‹©å±‚æ¬¡èšç±»å½“**ï¼š

- æ•°æ®è§„æ¨¡å°ï¼ˆ$n < 1000$ï¼‰
- éœ€è¦å¯è§†åŒ–æ ‘çŠ¶ç»“æ„
- éœ€è¦ä¸åŒç²’åº¦çš„èšç±»ç»“æœ
- ç°‡æ•°ä¸ç¡®å®š

### 7.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç‰¹å¾æ ‡å‡†åŒ–**ï¼šä½¿ç”¨Z-scoreæˆ–Min-Maxæ ‡å‡†åŒ–
2. **é™ç»´å¤„ç†**ï¼šå¯¹é«˜ç»´æ•°æ®ä½¿ç”¨PCAé™ç»´
3. **ç´¢å¼•ä¼˜åŒ–**ï¼šåœ¨ç‰¹å¾åˆ—ä¸Šåˆ›å»ºç´¢å¼•åŠ é€Ÿè·ç¦»è®¡ç®—
4. **å¹¶è¡Œå¤„ç†**ï¼šä½¿ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢
5. **é‡‡æ ·ç­–ç•¥**ï¼šå¯¹å¤§è§„æ¨¡æ•°æ®å…ˆé‡‡æ ·å†èšç±»

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ•°æ®é¢„å¤„ç†

1. **ç¼ºå¤±å€¼å¤„ç†**ï¼šåˆ é™¤æˆ–å¡«å……ç¼ºå¤±å€¼
2. **å¼‚å¸¸å€¼å¤„ç†**ï¼šä½¿ç”¨IQRæ–¹æ³•è¯†åˆ«å’Œå¤„ç†å¼‚å¸¸å€¼
3. **ç‰¹å¾é€‰æ‹©**ï¼šé€‰æ‹©ç›¸å…³æ€§é«˜çš„ç‰¹å¾
4. **ç‰¹å¾æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€ç‰¹å¾é‡çº²

### 8.2 å‚æ•°è°ƒä¼˜

**K-meanså‚æ•°**ï¼š

- $k$ï¼šä½¿ç”¨è‚˜éƒ¨æ³•åˆ™ï¼ˆElbow Methodï¼‰æˆ–è½®å»“ç³»æ•°é€‰æ‹©
- åˆå§‹åŒ–ï¼šä½¿ç”¨K-means++å‡å°‘è¿­ä»£æ¬¡æ•°

**DBSCANå‚æ•°**ï¼š

- $\varepsilon$ï¼šä½¿ç”¨k-distanceå›¾é€‰æ‹©
- $MinPts$ï¼šé€šå¸¸è®¾ä¸ºç»´åº¦+1

### 8.3 ç»“æœéªŒè¯

1. **å†…éƒ¨è¯„ä¼°**ï¼šè½®å»“ç³»æ•°ã€WCSSã€BCSS
2. **å¤–éƒ¨è¯„ä¼°**ï¼šå¦‚æœæœ‰æ ‡ç­¾ï¼Œä½¿ç”¨è°ƒæ•´å…°å¾·æŒ‡æ•°ï¼ˆARIï¼‰ã€æ ‡å‡†åŒ–äº’ä¿¡æ¯ï¼ˆNMIï¼‰
3. **å¯è§†åŒ–**ï¼šä½¿ç”¨æ•£ç‚¹å›¾ã€æ ‘çŠ¶å›¾å¯è§†åŒ–ç»“æœ
4. **ä¸šåŠ¡éªŒè¯**ï¼šç»“åˆå®é™…ä¸šåŠ¡åœºæ™¯éªŒè¯èšç±»ç»“æœ

### 8.4 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šK-meansç»“æœä¸ç¨³å®š

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨K-means++åˆå§‹åŒ–ï¼Œå¤šæ¬¡è¿è¡Œå–æœ€ä¼˜ç»“æœ

**é—®é¢˜2**ï¼šDBSCANå°†æ‰€æœ‰ç‚¹æ ‡è®°ä¸ºå™ªå£°

- **è§£å†³æ–¹æ¡ˆ**ï¼šå‡å°$\varepsilon$æˆ–$MinPts$å‚æ•°

**é—®é¢˜3**ï¼šèšç±»ç»“æœä¸ç¬¦åˆé¢„æœŸ

- **è§£å†³æ–¹æ¡ˆ**ï¼šæ£€æŸ¥ç‰¹å¾é€‰æ‹©ã€æ ‡å‡†åŒ–æ–¹æ³•ã€è·ç¦»åº¦é‡

**é—®é¢˜4**ï¼šè®¡ç®—æ—¶é—´è¿‡é•¿

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨é‡‡æ ·ã€é™ç»´ã€ç´¢å¼•ä¼˜åŒ–

### 8.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡èšç±»åˆ†æçš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«èšç±»è·ç¦»çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nèšç±»æŸ¥è¯¢å’Œæœ€è¿‘é‚»æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡èšç±»è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡è·ç¦»è®¡ç®—å’ŒK-meansè¿­ä»£

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - èšç±»åˆ†ææ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡K-meansèšç±»å’Œè·ç¦»çŸ©é˜µè®¡ç®—

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–èšç±»æŸ¥è¯¢**

```sql
-- ä¸ºèšç±»è·ç¦»åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_cluster_distances_skip_scan
ON cluster_results(cluster_id, distance_to_center DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªèšç±»è·ç¦»ä¸­å¿ƒæœ€è¿‘çš„å‰5ä¸ªç‚¹
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (cluster_id)
    cluster_id,
    point_id,
    distance_to_center
FROM cluster_results
ORDER BY cluster_id, distance_to_center ASC
LIMIT 50;
```

### 8.6 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜èšç±»ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„èšç±»ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜èšç±»ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS clustering_results_cache AS
WITH cluster_statistics AS (
    SELECT
        cluster_id,
        COUNT(*) AS cluster_size,
        AVG(distance_to_center) AS avg_distance,
        STDDEV(distance_to_center) AS stddev_distance,
        MIN(distance_to_center) AS min_distance,
        MAX(distance_to_center) AS max_distance,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ç°‡å†…å‡èšåº¦ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        AVG(POWER(distance_to_center, 2)) OVER (PARTITION BY cluster_id) AS wcss,  -- Within-Cluster Sum of Squares
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ç°‡é—´åˆ†ç¦»åº¦ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        AVG(AVG(distance_to_center)) OVER () AS overall_avg_distance
    FROM cluster_results
    GROUP BY cluster_id, distance_to_center
)
SELECT DISTINCT ON (cluster_id)
    cluster_id,
    cluster_size,
    ROUND(avg_distance::numeric, 4) AS avg_distance,
    ROUND(stddev_distance::numeric, 4) AS stddev_distance,
    ROUND(min_distance::numeric, 4) AS min_distance,
    ROUND(max_distance::numeric, 4) AS max_distance,
    ROUND(wcss::numeric, 6) AS within_cluster_sum_squares,
    CASE
        WHEN avg_distance < overall_avg_distance * 0.5 THEN 'Compact Cluster'
        WHEN avg_distance < overall_avg_distance THEN 'Medium Cluster'
        ELSE 'Loose Cluster'
    END AS cluster_compactness
FROM cluster_statistics
ORDER BY cluster_id;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_clustering_results_cache_cluster ON clustering_results_cache(cluster_id);
CREATE INDEX idx_clustering_results_cache_size ON clustering_results_cache(cluster_size DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY clustering_results_cache;
```

**2. å®æ—¶èšç±»ï¼šå¢é‡èšç±»æ›´æ–°**

**å®æ—¶èšç±»**ï¼šå¯¹äºæµå¼æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°èšç±»ç»“æœã€‚

```sql
-- å®æ—¶èšç±»ï¼šå¢é‡èšç±»æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'clustering_state') THEN
            CREATE TABLE clustering_state (
                cluster_id INTEGER PRIMARY KEY,
                centroid_x NUMERIC NOT NULL,
                centroid_y NUMERIC NOT NULL,
                cluster_size INTEGER DEFAULT 0,
                sum_distance NUMERIC DEFAULT 0,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_clustering_state_centroid ON clustering_state(centroid_x, centroid_y);

            RAISE NOTICE 'èšç±»çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡èšç±»æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡èšç±»æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°èšç±»ï¼šå®æ—¶èšç±»ï¼ˆä½¿ç”¨K-meanså¢é‡æ›´æ–°ï¼‰
WITH new_points AS (
    SELECT
        id,
        x,
        y
    FROM data_points
    WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM clustering_state)
),
nearest_clusters AS (
    SELECT
        np.id,
        np.x,
        np.y,
        cs.cluster_id,
        -- è®¡ç®—åˆ°æœ€è¿‘èšç±»ä¸­å¿ƒçš„è·ç¦»
        SQRT(POWER(np.x - cs.centroid_x, 2) + POWER(np.y - cs.centroid_y, 2)) AS distance,
        -- ä½¿ç”¨çª—å£å‡½æ•°æ‰¾åˆ°æœ€è¿‘çš„èšç±»ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        ROW_NUMBER() OVER (PARTITION BY np.id ORDER BY SQRT(POWER(np.x - cs.centroid_x, 2) + POWER(np.y - cs.centroid_y, 2))) AS cluster_rank
    FROM new_points np
    CROSS JOIN clustering_state cs
),
assigned_points AS (
    SELECT
        id,
        x,
        y,
        cluster_id,
        distance
    FROM nearest_clusters
    WHERE cluster_rank = 1
),
updated_clusters AS (
    SELECT
        COALESCE(cs.cluster_id, ap.cluster_id) AS cluster_id,
        COALESCE(cs.cluster_size, 0) + COUNT(*) AS new_cluster_size,
        -- æ›´æ–°è´¨å¿ƒï¼šåŠ æƒå¹³å‡ï¼ˆå¢é‡æ›´æ–°ï¼‰
        (COALESCE(cs.centroid_x * cs.cluster_size, 0) + SUM(ap.x)) /
        NULLIF(COALESCE(cs.cluster_size, 0) + COUNT(*), 0) AS new_centroid_x,
        (COALESCE(cs.centroid_y * cs.cluster_size, 0) + SUM(ap.y)) /
        NULLIF(COALESCE(cs.cluster_size, 0) + COUNT(*), 0) AS new_centroid_y,
        COALESCE(cs.sum_distance, 0) + SUM(ap.distance) AS new_sum_distance
    FROM clustering_state cs
    FULL OUTER JOIN assigned_points ap ON cs.cluster_id = ap.cluster_id
    GROUP BY cs.cluster_id, ap.cluster_id, cs.cluster_size, cs.centroid_x, cs.centroid_y, cs.sum_distance
)
-- æ›´æ–°æˆ–æ’å…¥èšç±»çŠ¶æ€
INSERT INTO clustering_state (cluster_id, centroid_x, centroid_y, cluster_size, sum_distance, last_updated)
SELECT
    cluster_id,
    new_centroid_x,
    new_centroid_y,
    new_cluster_size,
    new_sum_distance,
    NOW()
FROM updated_clusters
ON CONFLICT (cluster_id)
DO UPDATE SET
    centroid_x = EXCLUDED.centroid_x,
    centroid_y = EXCLUDED.centroid_y,
    cluster_size = EXCLUDED.cluster_size,
    sum_distance = EXCLUDED.sum_distance,
    last_updated = NOW();
```

**3. è‡ªé€‚åº”èšç±»ï¼šåŠ¨æ€Kå€¼é€‰æ‹©**

**è‡ªé€‚åº”èšç±»**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜Kå€¼ã€‚

```sql
-- è‡ªé€‚åº”èšç±»ï¼šåŠ¨æ€Kå€¼é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    total_points BIGINT;
    optimal_k INTEGER;
    silhouette_avg NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_points') THEN
            RAISE WARNING 'è¡¨ data_points ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè‡ªé€‚åº”èšç±»';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‚¹æ•°é‡
        SELECT COUNT(*) INTO total_points FROM data_points;

        -- ä½¿ç”¨ç»éªŒæ³•åˆ™ï¼šk â‰ˆ sqrt(n/2)
        optimal_k := GREATEST(2, LEAST(10, FLOOR(SQRT(total_points / 2.0))::INTEGER));

        RAISE NOTICE 'æ•°æ®ç‚¹æ•°é‡: %, æ¨èKå€¼: %', total_points, optimal_k;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è‡ªé€‚åº”èšç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è‡ªé€‚åº”Kå€¼é€‰æ‹©ï¼šä½¿ç”¨è‚˜éƒ¨æ³•åˆ™å’Œè½®å»“ç³»æ•°
WITH k_range AS (
    SELECT generate_series(2, 10) AS k_value
),
k_clustering_results AS (
    SELECT
        kr.k_value,
        -- ç®€åŒ–çš„WCSSè®¡ç®—ï¼ˆå®é™…éœ€è¦å®Œæ•´K-meansï¼‰
        (SELECT SUM(
            POWER(
                SQRT(POWER(dp.x - AVG(dp.x) OVER (PARTITION BY NTILE(kr.k_value) OVER (ORDER BY dp.x)), 2) +
                     POWER(dp.y - AVG(dp.y) OVER (PARTITION BY NTILE(kr.k_value) OVER (ORDER BY dp.x)), 2)),
                2
            )
        ) / NULLIF((SELECT COUNT(*) FROM data_points), 0)
        FROM data_points dp
        LIMIT 1
        ) AS wcss_approx
    FROM k_range kr
),
elbow_analysis AS (
    SELECT
        k_value,
        wcss_approx,
        LAG(wcss_approx) OVER (ORDER BY k_value) AS prev_wcss,
        wcss_approx - LAG(wcss_approx) OVER (ORDER BY k_value) AS wcss_decrease,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—WCSSä¸‹é™ç‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        (wcss_approx - LAG(wcss_approx) OVER (ORDER BY k_value)) /
        NULLIF(LAG(wcss_approx) OVER (ORDER BY k_value), 0) * 100 AS wcss_decrease_pct
    FROM k_clustering_results
)
SELECT
    k_value,
    ROUND(wcss_approx::numeric, 6) AS wcss,
    ROUND(COALESCE(wcss_decrease::numeric, 0), 6) AS wcss_decrease,
    ROUND(COALESCE(wcss_decrease_pct::numeric, 0), 2) AS wcss_decrease_pct,
    CASE
        WHEN wcss_decrease_pct < 5.0 THEN 'Elbow Point (Optimal K)'
        WHEN wcss_decrease_pct < 10.0 THEN 'Good K Value'
        ELSE 'Continue Increasing K'
    END AS k_selection_advice
FROM elbow_analysis
WHERE k_value >= 2
ORDER BY k_value;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **MacQueen, J. (1967)**: "Some Methods for Classification and Analysis of Multivariate Observations", *Proceedings of the 5th Berkeley Symposium*.

2. **Ester, M., et al. (1996)**: "A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise", *KDD*.

3. **Rousseeuw, P.J. (1987)**: "Silhouettes: A Graphical Aid to the Interpretation and Validation of Cluster Analysis", *Journal of Computational and Applied Mathematics*.

4. **Arthur, D., Vassilvitskii, S. (2007)**: "K-means++: The Advantages of Careful Seeding", *SODA*.

### åœ¨çº¿èµ„æº

- **scikit-learnæ–‡æ¡£**: <https://scikit-learn.org/stable/modules/clustering.html>
- **PostgreSQLå®˜æ–¹æ–‡æ¡£**: <https://www.postgresql.org/docs/>
- **èšç±»ç®—æ³•å¯è§†åŒ–**: <https://www.naftaliharis.com/scikit-learn/cluster/>

### ç›¸å…³ç®—æ³•

- **è°±èšç±»**ï¼šåŸºäºå›¾è®ºçš„èšç±»æ–¹æ³•
- **é«˜æ–¯æ··åˆæ¨¡å‹**ï¼šæ¦‚ç‡èšç±»æ–¹æ³•
- **æ¨¡ç³ŠC-means**ï¼šè½¯èšç±»æ–¹æ³•
- **Mean Shift**ï¼šåŸºäºå¯†åº¦çš„èšç±»æ–¹æ³•

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ”¹è¿›å®Œæˆ
