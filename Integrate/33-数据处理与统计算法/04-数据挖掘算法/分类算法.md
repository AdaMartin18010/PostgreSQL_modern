# PostgreSQL åˆ†ç±»ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | åˆ†ç±»ç®—æ³• | é¢„æµ‹åˆ†æ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL åˆ†ç±»ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-åˆ†ç±»ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [åˆ†ç±»ç®—æ³•æ¦‚è¿°](#åˆ†ç±»ç®—æ³•æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [åˆ†ç±»é—®é¢˜å®šä¹‰](#åˆ†ç±»é—®é¢˜å®šä¹‰)
      - [åˆ†ç±»ç®—æ³•åˆ†ç±»](#åˆ†ç±»ç®—æ³•åˆ†ç±»)
      - [åˆ†ç±»è¯„ä¼°æŒ‡æ ‡](#åˆ†ç±»è¯„ä¼°æŒ‡æ ‡)
    - [æ ¸å¿ƒåˆ†ç±»ç®—æ³•](#æ ¸å¿ƒåˆ†ç±»ç®—æ³•)
  - [1. æœ´ç´ è´å¶æ–¯åˆ†ç±»](#1-æœ´ç´ è´å¶æ–¯åˆ†ç±»)
    - [1.1 æœ´ç´ è´å¶æ–¯åŸç†](#11-æœ´ç´ è´å¶æ–¯åŸç†)
      - [è´å¶æ–¯å®šç†](#è´å¶æ–¯å®šç†)
      - [æœ´ç´ è´å¶æ–¯å‡è®¾](#æœ´ç´ è´å¶æ–¯å‡è®¾)
      - [åˆ†ç±»å†³ç­–](#åˆ†ç±»å†³ç­–)
      - [æ¦‚ç‡ä¼°è®¡](#æ¦‚ç‡ä¼°è®¡)
    - [1.2 æ¦‚ç‡è®¡ç®—å®ç°](#12-æ¦‚ç‡è®¡ç®—å®ç°)
  - [2. å†³ç­–æ ‘åˆ†ç±»](#2-å†³ç­–æ ‘åˆ†ç±»)
    - [2.1 å†³ç­–æ ‘åŸç†](#21-å†³ç­–æ ‘åŸç†)
      - [å†³ç­–æ ‘æ„å»º](#å†³ç­–æ ‘æ„å»º)
      - [ä¿¡æ¯ç†µï¼ˆEntropyï¼‰](#ä¿¡æ¯ç†µentropy)
      - [ä¿¡æ¯å¢ç›Šï¼ˆInformation Gainï¼‰](#ä¿¡æ¯å¢ç›Šinformation-gain)
      - [åŸºå°¼ç³»æ•°ï¼ˆGini Indexï¼‰](#åŸºå°¼ç³»æ•°gini-index)
    - [2.2 ä¿¡æ¯å¢ç›Šè®¡ç®—å®ç°](#22-ä¿¡æ¯å¢ç›Šè®¡ç®—å®ç°)
  - [3. KNNåˆ†ç±»](#3-knnåˆ†ç±»)
    - [3.1 KNNåŸç†](#31-knnåŸç†)
      - [ç®—æ³•æ­¥éª¤](#ç®—æ³•æ­¥éª¤)
      - [è·ç¦»åº¦é‡](#è·ç¦»åº¦é‡)
      - [Kå€¼é€‰æ‹©](#kå€¼é€‰æ‹©)
    - [3.2 KNNå®ç°](#32-knnå®ç°)
  - [4. åˆ†ç±»è¯„ä¼°](#4-åˆ†ç±»è¯„ä¼°)
    - [4.1 æ··æ·†çŸ©é˜µ](#41-æ··æ·†çŸ©é˜µ)
    - [4.2 å‡†ç¡®ç‡å’Œå¬å›ç‡å®ç°](#42-å‡†ç¡®ç‡å’Œå¬å›ç‡å®ç°)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 å®¢æˆ·åˆ†ç±»](#51-å®¢æˆ·åˆ†ç±»)
    - [5.2 é‚®ä»¶ spam åˆ†ç±»](#52-é‚®ä»¶-spam-åˆ†ç±»)
    - [5.3 äº§å“åˆ†ç±»](#53-äº§å“åˆ†ç±»)
    - [5.4 ç”¨æˆ·è¡Œä¸ºåˆ†ç±»](#54-ç”¨æˆ·è¡Œä¸ºåˆ†ç±»)
    - [5.5 åˆ†ç±»æ¨¡å‹è¯„ä¼°](#55-åˆ†ç±»æ¨¡å‹è¯„ä¼°)
  - [6. PostgreSQL 18å¹¶è¡Œåˆ†ç±»ç®—æ³•](#6-postgresql-18å¹¶è¡Œåˆ†ç±»ç®—æ³•)
    - [6.1 å¹¶è¡Œåˆ†ç±»ç®—æ³•æ¦‚è¿°](#61-å¹¶è¡Œåˆ†ç±»ç®—æ³•æ¦‚è¿°)
      - [å¹¶è¡Œåˆ†ç±»ç®—æ³•é…ç½®](#å¹¶è¡Œåˆ†ç±»ç®—æ³•é…ç½®)
      - [å¹¶è¡Œåˆ†ç±»ç®—æ³•å®ç°](#å¹¶è¡Œåˆ†ç±»ç®—æ³•å®ç°)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [7.1 åˆ†ç±»ç®—æ³•å¯¹æ¯”](#71-åˆ†ç±»ç®—æ³•å¯¹æ¯”)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#73-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æ•°æ®å‡†å¤‡](#81-æ•°æ®å‡†å¤‡)
    - [8.2 æ¨¡å‹è®­ç»ƒ](#82-æ¨¡å‹è®­ç»ƒ)
    - [8.3 æ¨¡å‹éƒ¨ç½²](#83-æ¨¡å‹éƒ¨ç½²)
    - [8.4 SQLå®ç°æ³¨æ„äº‹é¡¹](#84-sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## åˆ†ç±»ç®—æ³•æ¦‚è¿°

**åˆ†ç±»ï¼ˆClassificationï¼‰**æ˜¯ç›‘ç£å­¦ä¹ ä¸­çš„æ ¸å¿ƒä»»åŠ¡ï¼Œç”¨äºé¢„æµ‹æ•°æ®ç‚¹çš„ç±»åˆ«æ ‡ç­¾ã€‚PostgreSQLå¯ä»¥é€šè¿‡SQLå®ç°å¤šç§åˆ†ç±»ç®—æ³•ï¼Œè™½ç„¶æ€§èƒ½ä¸å¦‚ä¸“é—¨çš„æœºå™¨å­¦ä¹ åº“ï¼Œä½†åœ¨æŸäº›åœºæ™¯ä¸‹å¯ä»¥æä¾›ä¾¿æ·çš„åˆ†ç±»åŠŸèƒ½ã€‚

### ç†è®ºåŸºç¡€

#### åˆ†ç±»é—®é¢˜å®šä¹‰

**åˆ†ç±»é—®é¢˜**ï¼šç»™å®šè®­ç»ƒæ•°æ®é›†$D = \{(x_1, y_1), (x_2, y_2), ..., (x_n, y_n)\}$ï¼Œå…¶ä¸­$x_i$æ˜¯ç‰¹å¾å‘é‡ï¼Œ$y_i \in \{c_1, c_2, ..., c_k\}$æ˜¯ç±»åˆ«æ ‡ç­¾ï¼Œå­¦ä¹ ä¸€ä¸ªåˆ†ç±»å‡½æ•°$f: X \rightarrow Y$ï¼Œä½¿å¾—å¯¹äºæ–°çš„è¾“å…¥$x$ï¼Œèƒ½å¤Ÿé¢„æµ‹å…¶ç±»åˆ«$y = f(x)$ã€‚

**åˆ†ç±»ç›®æ ‡**ï¼šæœ€å°åŒ–åˆ†ç±»é”™è¯¯ç‡ï¼š
$$Error = \frac{1}{n}\sum_{i=1}^{n} I(f(x_i) \neq y_i)$$

å…¶ä¸­$I(\cdot)$æ˜¯æŒ‡ç¤ºå‡½æ•°ã€‚

#### åˆ†ç±»ç®—æ³•åˆ†ç±»

1. **æ¦‚ç‡åˆ†ç±»**ï¼šåŸºäºæ¦‚ç‡æ¨¡å‹ï¼ˆæœ´ç´ è´å¶æ–¯ï¼‰
2. **è§„åˆ™åˆ†ç±»**ï¼šåŸºäºå†³ç­–è§„åˆ™ï¼ˆå†³ç­–æ ‘ï¼‰
3. **è·ç¦»åˆ†ç±»**ï¼šåŸºäºè·ç¦»åº¦é‡ï¼ˆKNNï¼‰
4. **çº¿æ€§åˆ†ç±»**ï¼šåŸºäºçº¿æ€§æ¨¡å‹ï¼ˆé€»è¾‘å›å½’ï¼‰

#### åˆ†ç±»è¯„ä¼°æŒ‡æ ‡

**æ··æ·†çŸ©é˜µï¼ˆConfusion Matrixï¼‰**ï¼š

- **TPï¼ˆTrue Positiveï¼‰**ï¼šçœŸæ­£ä¾‹
- **TNï¼ˆTrue Negativeï¼‰**ï¼šçœŸè´Ÿä¾‹
- **FPï¼ˆFalse Positiveï¼‰**ï¼šå‡æ­£ä¾‹
- **FNï¼ˆFalse Negativeï¼‰**ï¼šå‡è´Ÿä¾‹

**å‡†ç¡®ç‡ï¼ˆAccuracyï¼‰**ï¼š
$$\text{Accuracy} = \frac{TP + TN}{TP + TN + FP + FN}$$

**ç²¾ç¡®ç‡ï¼ˆPrecisionï¼‰**ï¼š
$$\text{Precision} = \frac{TP}{TP + FP}$$

**å¬å›ç‡ï¼ˆRecallï¼‰**ï¼š
$$\text{Recall} = \frac{TP}{TP + FN}$$

**F1åˆ†æ•°ï¼ˆF1-Scoreï¼‰**ï¼š
$$\text{F1} = \frac{2 \times \text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}}$$

### æ ¸å¿ƒåˆ†ç±»ç®—æ³•

| ç®—æ³• | åŸç† | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¼˜åŠ¿ | åŠ£åŠ¿ |
|------|------|-----------|-----------|------|------|
| **æœ´ç´ è´å¶æ–¯** | è´å¶æ–¯å®šç† | $O(n)$ | $O(n)$ | ç®€å•å¿«é€Ÿã€é€‚åˆé«˜ç»´æ•°æ® | ç‰¹å¾ç‹¬ç«‹æ€§å‡è®¾ |
| **å†³ç­–æ ‘** | ä¿¡æ¯å¢ç›Š/åŸºå°¼ç³»æ•° | $O(n \log n)$ | $O(n)$ | å¯è§£é‡Šæ€§å¼ºã€å¤„ç†éçº¿æ€§ | å®¹æ˜“è¿‡æ‹Ÿåˆ |
| **KNN** | è·ç¦»åº¦é‡ | $O(n^2)$ | $O(n)$ | ç®€å•ç›´è§‚ã€æ— éœ€è®­ç»ƒ | è®¡ç®—é‡å¤§ã€å¯¹å™ªå£°æ•æ„Ÿ |
| **é€»è¾‘å›å½’** | é€»è¾‘å‡½æ•° | $O(n)$ | $O(1)$ | æ¦‚ç‡è¾“å‡ºã€å¯è§£é‡Š | çº¿æ€§è¾¹ç•Œé™åˆ¶ |

---

## 1. æœ´ç´ è´å¶æ–¯åˆ†ç±»

### 1.1 æœ´ç´ è´å¶æ–¯åŸç†

**æœ´ç´ è´å¶æ–¯ï¼ˆNaive Bayesï¼‰**æ˜¯åŸºäºè´å¶æ–¯å®šç†å’Œç‰¹å¾ç‹¬ç«‹æ€§å‡è®¾çš„åˆ†ç±»ç®—æ³•ã€‚

#### è´å¶æ–¯å®šç†

**è´å¶æ–¯å®šç†**ï¼š
$$P(Y|X) = \frac{P(X|Y) \times P(Y)}{P(X)}$$

å…¶ä¸­ï¼š

- $P(Y|X)$ï¼šåéªŒæ¦‚ç‡ï¼ˆç»™å®šç‰¹å¾$X$ï¼Œç±»åˆ«$Y$çš„æ¦‚ç‡ï¼‰
- $P(X|Y)$ï¼šä¼¼ç„¶æ¦‚ç‡ï¼ˆç»™å®šç±»åˆ«$Y$ï¼Œç‰¹å¾$X$çš„æ¦‚ç‡ï¼‰
- $P(Y)$ï¼šå…ˆéªŒæ¦‚ç‡ï¼ˆç±»åˆ«$Y$çš„æ¦‚ç‡ï¼‰
- $P(X)$ï¼šè¯æ®ï¼ˆç‰¹å¾$X$çš„æ¦‚ç‡ï¼‰

#### æœ´ç´ è´å¶æ–¯å‡è®¾

**ç‰¹å¾ç‹¬ç«‹æ€§å‡è®¾**ï¼šç»™å®šç±»åˆ«ï¼Œç‰¹å¾ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼š
$$P(X|Y) = P(x_1, x_2, ..., x_n|Y) = \prod_{i=1}^{n} P(x_i|Y)$$

#### åˆ†ç±»å†³ç­–

**æœ€å¤§åéªŒæ¦‚ç‡ï¼ˆMAPï¼‰å†³ç­–**ï¼š
$$\hat{y} = \arg\max_{y} P(Y=y|X) = \arg\max_{y} P(Y=y) \prod_{i=1}^{n} P(x_i|Y=y)$$

**å¯¹æ•°å½¢å¼**ï¼ˆé¿å…æ•°å€¼ä¸‹æº¢ï¼‰ï¼š
$$\hat{y} = \arg\max_{y} \left[\log P(Y=y) + \sum_{i=1}^{n} \log P(x_i|Y=y)\right]$$

#### æ¦‚ç‡ä¼°è®¡

**å…ˆéªŒæ¦‚ç‡**ï¼š
$$P(Y=c_k) = \frac{|\{i: y_i = c_k\}|}{n}$$

**æ¡ä»¶æ¦‚ç‡**ï¼ˆç¦»æ•£ç‰¹å¾ï¼‰ï¼š
$$P(x_i = v|Y=c_k) = \frac{|\{j: x_{j,i} = v \text{ and } y_j = c_k\}|}{|\{j: y_j = c_k\}|}$$

**æ¡ä»¶æ¦‚ç‡**ï¼ˆè¿ç»­ç‰¹å¾ï¼Œä½¿ç”¨é«˜æ–¯åˆ†å¸ƒï¼‰ï¼š
$$P(x_i|Y=c_k) = \frac{1}{\sqrt{2\pi\sigma_{k,i}^2}} \exp\left(-\frac{(x_i - \mu_{k,i})^2}{2\sigma_{k,i}^2}\right)$$

### 1.2 æ¦‚ç‡è®¡ç®—å®ç°

```sql
-- æœ´ç´ è´å¶æ–¯åˆ†ç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    total_count BIGINT;
    class_a_count BIGINT;
    class_b_count BIGINT;
    class_a_prob NUMERIC;
    class_b_prob NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'training_data') THEN
            RAISE WARNING 'è¡¨ training_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæœ´ç´ è´å¶æ–¯åˆ†ç±»';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO total_count FROM training_data;
        SELECT COUNT(*) INTO class_a_count FROM training_data WHERE class = 'A';
        SELECT COUNT(*) INTO class_b_count FROM training_data WHERE class = 'B';

        class_a_prob := class_a_count::NUMERIC / NULLIF(total_count, 0);
        class_b_prob := class_b_count::NUMERIC / NULLIF(total_count, 0);

        RAISE NOTICE 'å…ˆéªŒæ¦‚ç‡:';
        RAISE NOTICE '  P(A) = %', class_a_prob;
        RAISE NOTICE '  P(B) = %', class_b_prob;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æœ´ç´ è´å¶æ–¯åˆ†ç±»å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—æ¡ä»¶æ¦‚ç‡
WITH class_probs AS (
    SELECT
        class,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () AS prior_prob
    FROM training_data
    GROUP BY class
),
feature_probs AS (
    SELECT
        class,
        feature_value,
        COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER (PARTITION BY class) AS conditional_prob
    FROM training_data
    GROUP BY class, feature_value
)
SELECT
    cp.class,
    cp.prior_prob,
    fp.feature_value,
    fp.conditional_prob,
    cp.prior_prob * fp.conditional_prob AS posterior_prob
FROM class_probs cp
JOIN feature_probs fp ON cp.class = fp.class
ORDER BY cp.class, fp.feature_value;
```

---

## 2. å†³ç­–æ ‘åˆ†ç±»

### 2.1 å†³ç­–æ ‘åŸç†

**å†³ç­–æ ‘ï¼ˆDecision Treeï¼‰**é€šè¿‡ä¸€ç³»åˆ—è§„åˆ™å¯¹æ•°æ®è¿›è¡Œåˆ†ç±»ï¼Œæ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªç‰¹å¾æµ‹è¯•ï¼Œæ¯ä¸ªåˆ†æ”¯è¡¨ç¤ºæµ‹è¯•ç»“æœï¼Œæ¯ä¸ªå¶å­èŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªç±»åˆ«ã€‚

#### å†³ç­–æ ‘æ„å»º

**ç®—æ³•æ­¥éª¤**ï¼š

1. **é€‰æ‹©æœ€ä¼˜ç‰¹å¾**ï¼šä½¿ç”¨ä¿¡æ¯å¢ç›Šæˆ–åŸºå°¼ç³»æ•°
2. **åˆ†è£‚èŠ‚ç‚¹**ï¼šæ ¹æ®ç‰¹å¾å€¼å°†æ•°æ®åˆ†æˆå­é›†
3. **é€’å½’æ„å»º**ï¼šå¯¹æ¯ä¸ªå­é›†é€’å½’æ„å»ºå­æ ‘
4. **åœæ­¢æ¡ä»¶**ï¼šè¾¾åˆ°æœ€å¤§æ·±åº¦ã€æ ·æœ¬æ•°è¿‡å°‘ã€çº¯åº¦è¶³å¤Ÿé«˜

#### ä¿¡æ¯ç†µï¼ˆEntropyï¼‰

**ä¿¡æ¯ç†µ**è¡¡é‡æ•°æ®çš„ä¸ç¡®å®šæ€§ï¼š
$$H(D) = -\sum_{k=1}^{K} p_k \log_2 p_k$$

å…¶ä¸­$p_k$æ˜¯ç±»åˆ«$k$åœ¨æ•°æ®é›†$D$ä¸­çš„æ¯”ä¾‹ã€‚

#### ä¿¡æ¯å¢ç›Šï¼ˆInformation Gainï¼‰

**ä¿¡æ¯å¢ç›Š**è¡¡é‡ç‰¹å¾å¯¹åˆ†ç±»çš„è´¡çŒ®ï¼š
$$\text{IG}(D, A) = H(D) - \sum_{v=1}^{V} \frac{|D_v|}{|D|} H(D_v)$$

å…¶ä¸­ï¼š

- $A$ï¼šç‰¹å¾
- $V$ï¼šç‰¹å¾$A$çš„å–å€¼æ•°
- $D_v$ï¼šç‰¹å¾$A$å–å€¼ä¸º$v$çš„å­é›†

**é€‰æ‹©ç‰¹å¾**ï¼šé€‰æ‹©ä¿¡æ¯å¢ç›Šæœ€å¤§çš„ç‰¹å¾ã€‚

#### åŸºå°¼ç³»æ•°ï¼ˆGini Indexï¼‰

**åŸºå°¼ç³»æ•°**è¡¡é‡æ•°æ®çš„ä¸çº¯åº¦ï¼š
$$\text{Gini}(D) = 1 - \sum_{k=1}^{K} p_k^2$$

**åŸºå°¼å¢ç›Š**ï¼š
$$\text{Gini\_Gain}(D, A) = \text{Gini}(D) - \sum_{v=1}^{V} \frac{|D_v|}{|D|} \text{Gini}(D_v)$$

### 2.2 ä¿¡æ¯å¢ç›Šè®¡ç®—å®ç°

```sql
-- ä¿¡æ¯å¢ç›Šè®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    entropy_before NUMERIC;
    entropy_after NUMERIC;
    information_gain NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'training_data') THEN
            RAISE WARNING 'è¡¨ training_data ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ä¿¡æ¯å¢ç›Š';
            RETURN;
        END IF;

        -- è®¡ç®—åˆ†è£‚å‰çš„ç†µ
        WITH class_counts AS (
            SELECT
                class,
                COUNT(*)::NUMERIC / SUM(COUNT(*)) OVER () AS prob
            FROM training_data
            GROUP BY class
        )
        SELECT -SUM(prob * LN(NULLIF(prob, 0))) INTO entropy_before
        FROM class_counts;

        -- è®¡ç®—åˆ†è£‚åçš„åŠ æƒç†µï¼ˆç®€åŒ–ç‰ˆï¼‰
        WITH split_entropy AS (
            SELECT
                feature_value,
                -SUM((class_count::NUMERIC / NULLIF(total_count, 0)) * LN(NULLIF(class_count::NUMERIC / NULLIF(total_count, 0), 0))) AS entropy
            FROM (
                SELECT
                    feature_value,
                    class,
                    COUNT(*) AS class_count,
                    SUM(COUNT(*)) OVER (PARTITION BY feature_value) AS total_count
                FROM training_data
                GROUP BY feature_value, class
            ) AS split_counts
            GROUP BY feature_value
        )
        SELECT AVG(entropy) INTO entropy_after FROM split_entropy;

        information_gain := entropy_before - entropy_after;

        RAISE NOTICE 'ä¿¡æ¯å¢ç›Šè®¡ç®—:';
        RAISE NOTICE '  åˆ†è£‚å‰ç†µ: %', entropy_before;
        RAISE NOTICE '  åˆ†è£‚åç†µ: %', entropy_after;
        RAISE NOTICE '  ä¿¡æ¯å¢ç›Š: %', information_gain;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¿¡æ¯å¢ç›Šè®¡ç®—å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 3. KNNåˆ†ç±»

### 3.1 KNNåŸç†

**Kæœ€è¿‘é‚»ï¼ˆK-Nearest Neighbors, KNNï¼‰**æ˜¯ä¸€ç§åŸºäºå®ä¾‹çš„å­¦ä¹ ç®—æ³•ï¼Œé€šè¿‡è®¡ç®—å¾…åˆ†ç±»æ ·æœ¬ä¸è®­ç»ƒæ ·æœ¬çš„è·ç¦»ï¼Œé€‰æ‹©æœ€è¿‘çš„$K$ä¸ªæ ·æœ¬ï¼Œæ ¹æ®è¿™$K$ä¸ªæ ·æœ¬çš„ç±»åˆ«è¿›è¡ŒæŠ•ç¥¨å†³å®šåˆ†ç±»ç»“æœã€‚

#### ç®—æ³•æ­¥éª¤

1. **è®¡ç®—è·ç¦»**ï¼šè®¡ç®—å¾…åˆ†ç±»æ ·æœ¬ä¸æ‰€æœ‰è®­ç»ƒæ ·æœ¬çš„è·ç¦»
2. **é€‰æ‹©Kä¸ªæœ€è¿‘é‚»**ï¼šé€‰æ‹©è·ç¦»æœ€å°çš„$K$ä¸ªæ ·æœ¬
3. **æŠ•ç¥¨å†³ç­–**ï¼šæ ¹æ®$K$ä¸ªæœ€è¿‘é‚»çš„ç±»åˆ«è¿›è¡ŒæŠ•ç¥¨
4. **åˆ†ç±»ç»“æœ**ï¼šé€‰æ‹©å¾—ç¥¨æœ€å¤šçš„ç±»åˆ«

#### è·ç¦»åº¦é‡

**æ¬§æ°è·ç¦»ï¼ˆEuclidean Distanceï¼‰**ï¼š
$$d(x, y) = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2}$$

**æ›¼å“ˆé¡¿è·ç¦»ï¼ˆManhattan Distanceï¼‰**ï¼š
$$d(x, y) = \sum_{i=1}^{n} |x_i - y_i|$$

**é—µå¯å¤«æ–¯åŸºè·ç¦»ï¼ˆMinkowski Distanceï¼‰**ï¼š
$$d(x, y) = \left(\sum_{i=1}^{n} |x_i - y_i|^p\right)^{1/p}$$

#### Kå€¼é€‰æ‹©

- **Kå€¼å°**ï¼šæ¨¡å‹å¤æ‚ï¼Œå®¹æ˜“è¿‡æ‹Ÿåˆï¼Œå¯¹å™ªå£°æ•æ„Ÿ
- **Kå€¼å¤§**ï¼šæ¨¡å‹ç®€å•ï¼Œå¯èƒ½æ¬ æ‹Ÿåˆï¼Œè®¡ç®—é‡å¤§
- **ç»éªŒå€¼**ï¼šé€šå¸¸é€‰æ‹©$\sqrt{n}$ï¼ˆ$n$æ˜¯è®­ç»ƒæ ·æœ¬æ•°ï¼‰

### 3.2 KNNå®ç°

```sql
-- KNNåˆ†ç±»ï¼šè®¡ç®—è·ç¦»å¹¶åˆ†ç±»ï¼ˆç®€åŒ–å®ç°ï¼‰
WITH test_sample AS (
    SELECT 5.0 AS feature1, 3.0 AS feature2  -- å¾…åˆ†ç±»æ ·æœ¬
),
distances AS (
    SELECT
        ts.feature1,
        ts.feature2,
        td.id,
        td.class,
        SQRT(POWER(ts.feature1 - td.feature1, 2) +
             POWER(ts.feature2 - td.feature2, 2)) AS distance
    FROM test_sample ts
    CROSS JOIN training_data td
),
k_nearest AS (
    SELECT
        class,
        distance
    FROM distances
    ORDER BY distance
    LIMIT 5  -- K=5
),
class_votes AS (
    SELECT
        class,
        COUNT(*) AS vote_count
    FROM k_nearest
    GROUP BY class
)
SELECT
    class AS predicted_class,
    vote_count,
    vote_count::numeric / SUM(vote_count) OVER () AS confidence
FROM class_votes
ORDER BY vote_count DESC
LIMIT 1;
```

## 4. åˆ†ç±»è¯„ä¼°

### 4.1 æ··æ·†çŸ©é˜µ

**æ··æ·†çŸ©é˜µï¼ˆConfusion Matrixï¼‰**æ˜¯è¯„ä¼°åˆ†ç±»æ€§èƒ½çš„åŸºç¡€å·¥å…·ï¼Œå±•ç¤ºåˆ†ç±»ç»“æœçš„è¯¦ç»†æƒ…å†µã€‚

```sql
-- æ··æ·†çŸ©é˜µï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'predictions') THEN
            RAISE WARNING 'è¡¨ predictions ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—æ··æ·†çŸ©é˜µ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—æ··æ·†çŸ©é˜µ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ··æ·†çŸ©é˜µè®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    actual_class,
    predicted_class,
    COUNT(*) AS count
FROM predictions
GROUP BY actual_class, predicted_class
ORDER BY actual_class, predicted_class;
```

### 4.2 å‡†ç¡®ç‡å’Œå¬å›ç‡å®ç°

**å‡†ç¡®ç‡å’Œå¬å›ç‡**æ˜¯è¯„ä¼°åˆ†ç±»æ€§èƒ½çš„é‡è¦æŒ‡æ ‡ã€‚

```sql
-- å‡†ç¡®ç‡å’Œå¬å›ç‡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    true_positive BIGINT;
    false_positive BIGINT;
    false_negative BIGINT;
    precision_val NUMERIC;
    recall_val NUMERIC;
    f1_score NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'predictions') THEN
            RAISE WARNING 'è¡¨ predictions ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—å‡†ç¡®ç‡å’Œå¬å›ç‡';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO true_positive
        FROM predictions
        WHERE actual_class = 'positive' AND predicted_class = 'positive';

        SELECT COUNT(*) INTO false_positive
        FROM predictions
        WHERE actual_class = 'negative' AND predicted_class = 'positive';

        SELECT COUNT(*) INTO false_negative
        FROM predictions
        WHERE actual_class = 'positive' AND predicted_class = 'negative';

        precision_val := true_positive::NUMERIC / NULLIF(true_positive + false_positive, 0);
        recall_val := true_positive::NUMERIC / NULLIF(true_positive + false_negative, 0);
        f1_score := 2 * precision_val * recall_val / NULLIF(precision_val + recall_val, 0);

        RAISE NOTICE 'åˆ†ç±»æ€§èƒ½æŒ‡æ ‡:';
        RAISE NOTICE '  ç²¾ç¡®ç‡ (Precision): %', precision_val;
        RAISE NOTICE '  å¬å›ç‡ (Recall): %', recall_val;
        RAISE NOTICE '  F1åˆ†æ•°: %', f1_score;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å‡†ç¡®ç‡å’Œå¬å›ç‡è®¡ç®—å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 å®¢æˆ·åˆ†ç±»

**å®¢æˆ·åˆ†ç±»**æ ¹æ®å®¢æˆ·ç‰¹å¾è¿›è¡Œåˆ†ç±»ï¼Œè¯†åˆ«ä¸åŒçš„å®¢æˆ·ç¾¤ä½“ã€‚

```sql
-- å®¢æˆ·åˆ†ç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customers') THEN
            RAISE WARNING 'è¡¨ customers ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå®¢æˆ·åˆ†ç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®¢æˆ·åˆ†ç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·åˆ†ç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH customer_features AS (
    SELECT
        customer_id,
        total_orders,
        total_amount,
        avg_order_amount,
        last_order_days,
        CASE
            WHEN total_orders >= 10 AND total_amount >= 10000 THEN 'VIP'
            WHEN total_orders >= 5 AND total_amount >= 5000 THEN 'Regular'
            WHEN total_orders >= 1 THEN 'Occasional'
            ELSE 'New'
        END AS customer_segment
    FROM customers
)
SELECT
    customer_segment,
    COUNT(*) AS customer_count,
    AVG(total_orders) AS avg_orders,
    AVG(total_amount) AS avg_amount
FROM customer_features
GROUP BY customer_segment
ORDER BY avg_amount DESC;
```

### 5.2 é‚®ä»¶ spam åˆ†ç±»

**åœºæ™¯**ï¼šä½¿ç”¨æœ´ç´ è´å¶æ–¯åˆ†ç±»é‚®ä»¶æ˜¯å¦ä¸ºspamã€‚

```sql
-- é‚®ä»¶spamåˆ†ç±»ï¼šæœ´ç´ è´å¶æ–¯å®ç°
WITH email_features AS (
    SELECT
        email_id,
        CASE WHEN email_text LIKE '%free%' THEN 1 ELSE 0 END AS has_free,
        CASE WHEN email_text LIKE '%money%' THEN 1 ELSE 0 END AS has_money,
        CASE WHEN email_text LIKE '%click%' THEN 1 ELSE 0 END AS has_click,
        CASE WHEN email_text LIKE '%urgent%' THEN 1 ELSE 0 END AS has_urgent,
        is_spam
    FROM emails
),
class_probs AS (
    SELECT
        is_spam,
        COUNT(*)::numeric / SUM(COUNT(*)) OVER () AS prior_prob
    FROM email_features
    GROUP BY is_spam
),
feature_probs AS (
    SELECT
        is_spam,
        'has_free' AS feature,
        has_free AS feature_value,
        COUNT(*)::numeric / SUM(COUNT(*)) OVER (PARTITION BY is_spam) AS conditional_prob
    FROM email_features
    GROUP BY is_spam, has_free
    UNION ALL
    SELECT
        is_spam,
        'has_money' AS feature,
        has_money AS feature_value,
        COUNT(*)::numeric / SUM(COUNT(*)) OVER (PARTITION BY is_spam) AS conditional_prob
    FROM email_features
    GROUP BY is_spam, has_money
),
prediction AS (
    SELECT
        ef.email_id,
        cp.is_spam,
        cp.prior_prob,
        EXP(SUM(LN(NULLIF(fp.conditional_prob, 0)))) AS likelihood,
        cp.prior_prob * EXP(SUM(LN(NULLIF(fp.conditional_prob, 0)))) AS posterior_prob
    FROM email_features ef
    CROSS JOIN class_probs cp
    LEFT JOIN feature_probs fp ON cp.is_spam = fp.is_spam
        AND fp.feature_value = CASE
            WHEN fp.feature = 'has_free' THEN ef.has_free
            WHEN fp.feature = 'has_money' THEN ef.has_money
            ELSE 0
        END
    GROUP BY ef.email_id, cp.is_spam, cp.prior_prob
)
SELECT
    email_id,
    is_spam AS predicted_class,
    posterior_prob,
    ROW_NUMBER() OVER (PARTITION BY email_id ORDER BY posterior_prob DESC) AS rank
FROM prediction
WHERE rank = 1;
```

### 5.3 äº§å“åˆ†ç±»

**åœºæ™¯**ï¼šä½¿ç”¨å†³ç­–æ ‘è§„åˆ™å¯¹äº§å“è¿›è¡Œåˆ†ç±»ã€‚

```sql
-- äº§å“åˆ†ç±»ï¼šå†³ç­–æ ‘è§„åˆ™å®ç°
WITH product_features AS (
    SELECT
        product_id,
        price,
        weight,
        category,
        CASE
            WHEN price < 50 AND weight < 1 THEN 'Low-end Light'
            WHEN price < 50 AND weight >= 1 THEN 'Low-end Heavy'
            WHEN price >= 50 AND price < 200 AND weight < 1 THEN 'Mid-range Light'
            WHEN price >= 50 AND price < 200 AND weight >= 1 THEN 'Mid-range Heavy'
            WHEN price >= 200 AND weight < 1 THEN 'High-end Light'
            ELSE 'High-end Heavy'
        END AS predicted_category
    FROM products
)
SELECT
    predicted_category,
    COUNT(*) AS product_count,
    AVG(price) AS avg_price,
    AVG(weight) AS avg_weight
FROM product_features
GROUP BY predicted_category
ORDER BY avg_price DESC;
```

### 5.4 ç”¨æˆ·è¡Œä¸ºåˆ†ç±»

**åœºæ™¯**ï¼šä½¿ç”¨KNNåˆ†ç±»ç”¨æˆ·è¡Œä¸ºæ¨¡å¼ã€‚

```sql
-- ç”¨æˆ·è¡Œä¸ºåˆ†ç±»ï¼šKNNå®ç°
WITH user_features AS (
    SELECT
        user_id,
        login_frequency,
        page_views,
        purchase_count,
        user_segment
    FROM user_behavior
),
test_user AS (
    SELECT 10 AS login_frequency, 50 AS page_views, 2 AS purchase_count
),
distances AS (
    SELECT
        uf.user_id,
        uf.user_segment,
        SQRT(
            POWER(tu.login_frequency - uf.login_frequency, 2) +
            POWER(tu.page_views - uf.page_views, 2) +
            POWER(tu.purchase_count - uf.purchase_count, 2)
        ) AS distance
    FROM test_user tu
    CROSS JOIN user_features uf
),
k_nearest AS (
    SELECT
        user_segment,
        distance
    FROM distances
    ORDER BY distance
    LIMIT 5  -- K=5
),
segment_votes AS (
    SELECT
        user_segment,
        COUNT(*) AS vote_count,
        AVG(distance) AS avg_distance
    FROM k_nearest
    GROUP BY user_segment
)
SELECT
    user_segment AS predicted_segment,
    vote_count,
    ROUND(avg_distance::numeric, 2) AS avg_distance,
    vote_count::numeric / SUM(vote_count) OVER () AS confidence
FROM segment_votes
ORDER BY vote_count DESC
LIMIT 1;
```

### 5.5 åˆ†ç±»æ¨¡å‹è¯„ä¼°

**åœºæ™¯**ï¼šå…¨é¢è¯„ä¼°åˆ†ç±»æ¨¡å‹çš„æ€§èƒ½ã€‚

```sql
-- åˆ†ç±»æ¨¡å‹è¯„ä¼°ï¼šç»¼åˆè¯„ä¼°æŒ‡æ ‡
WITH classification_results AS (
    SELECT
        actual_class,
        predicted_class,
        COUNT(*) AS count
    FROM predictions
    GROUP BY actual_class, predicted_class
),
class_metrics AS (
    SELECT
        cr.actual_class,
        cr.predicted_class,
        cr.count,
        SUM(cr.count) OVER (PARTITION BY cr.actual_class) AS actual_total,
        SUM(cr.count) OVER (PARTITION BY cr.predicted_class) AS predicted_total,
        SUM(cr.count) OVER () AS grand_total
    FROM classification_results cr
),
metrics AS (
    SELECT
        actual_class,
        predicted_class,
        count,
        actual_total,
        predicted_total,
        grand_total,
        CASE WHEN actual_class = predicted_class THEN count ELSE 0 END AS correct_count,
        count::numeric / NULLIF(actual_total, 0) AS recall,
        count::numeric / NULLIF(predicted_total, 0) AS precision
    FROM class_metrics
)
SELECT
    actual_class,
    predicted_class,
    count,
    ROUND(recall::numeric, 4) AS recall,
    ROUND(precision::numeric, 4) AS precision,
    CASE
        WHEN actual_class = predicted_class THEN 'Correct'
        ELSE 'Incorrect'
    END AS classification_status
FROM metrics
ORDER BY actual_class, predicted_class;
```

---

## 6. PostgreSQL 18å¹¶è¡Œåˆ†ç±»ç®—æ³•

### 6.1 å¹¶è¡Œåˆ†ç±»ç®—æ³•æ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œåˆ†ç±»ç®—æ³•**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡åˆ†ç±»ç®—æ³•è®¡ç®—çš„æ€§èƒ½ã€‚

#### å¹¶è¡Œåˆ†ç±»ç®—æ³•é…ç½®

```sql
-- é…ç½®å¹¶è¡Œåˆ†ç±»ç®—æ³•å‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œåˆ†ç±»ç®—æ³•å‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œåˆ†ç±»ç®—æ³•é…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œåˆ†ç±»ç®—æ³•å®ç°

```sql
-- å¹¶è¡Œåˆ†ç±»ç®—æ³•ï¼šå¤§è§„æ¨¡æ•°æ®åˆ†ç±»ç»Ÿè®¡ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œåˆ†ç±»ç®—æ³•';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œåˆ†ç±»ç®—æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œæœ´ç´ è´å¶æ–¯åˆ†ç±»ç»Ÿè®¡
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_class_distribution AS (
    SELECT
        class_label,
        feature_value,
        COUNT(*) AS feature_count
    FROM training_data
    GROUP BY class_label, feature_value
),
parallel_class_stats AS (
    SELECT
        class_label,
        COUNT(*) AS class_total,
        SUM(feature_count) AS total_features
    FROM parallel_class_distribution
    GROUP BY class_label
),
parallel_probabilities AS (
    SELECT
        cd.class_label,
        cd.feature_value,
        cd.feature_count,
        cs.class_total,
        ROUND((cd.feature_count::numeric / cs.class_total)::numeric, 4) AS conditional_probability,
        ROUND((cs.class_total::numeric / (SELECT SUM(class_total) FROM parallel_class_stats))::numeric, 4) AS prior_probability
    FROM parallel_class_distribution cd
    JOIN parallel_class_stats cs ON cd.class_label = cs.class_label
)
SELECT
    class_label,
    feature_value,
    feature_count,
    class_total,
    conditional_probability,
    prior_probability
FROM parallel_probabilities
ORDER BY class_label, feature_value;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 7.1 åˆ†ç±»ç®—æ³•å¯¹æ¯”

| ç®—æ³• | è®­ç»ƒæ—¶é—´ | é¢„æµ‹æ—¶é—´ | å†…å­˜éœ€æ±‚ | å¯è§£é‡Šæ€§ | é€‚ç”¨åœºæ™¯ |
|------|---------|---------|---------|---------|---------|
| **æœ´ç´ è´å¶æ–¯** | å¿« | å¿« | ä½ | ä¸­ | æ–‡æœ¬åˆ†ç±»ã€é«˜ç»´æ•°æ® |
| **å†³ç­–æ ‘** | ä¸­ | å¿« | ä¸­ | é«˜ | è§„åˆ™æå–ã€ç‰¹å¾é€‰æ‹© |
| **KNN** | æ—  | æ…¢ | é«˜ | ä½ | å°æ•°æ®é›†ã€éçº¿æ€§æ•°æ® |
| **é€»è¾‘å›å½’** | å¿« | å¿« | ä½ | ä¸­ | çº¿æ€§å¯åˆ†æ•°æ®ã€æ¦‚ç‡è¾“å‡º |

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç‰¹å¾é€‰æ‹©**ï¼š
   - é€‰æ‹©ç›¸å…³ç‰¹å¾
   - å»é™¤å†—ä½™ç‰¹å¾
   - ç‰¹å¾æ ‡å‡†åŒ–

2. **æ•°æ®é¢„å¤„ç†**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼
   - å¤„ç†å¼‚å¸¸å€¼
   - æ•°æ®å¹³è¡¡ï¼ˆå¤„ç†ç±»åˆ«ä¸å¹³è¡¡ï¼‰

3. **ç®—æ³•é€‰æ‹©**ï¼š
   - å°æ•°æ®é›†ï¼šKNN
   - é«˜ç»´æ•°æ®ï¼šæœ´ç´ è´å¶æ–¯
   - éœ€è¦è§£é‡Šï¼šå†³ç­–æ ‘
   - çº¿æ€§æ•°æ®ï¼šé€»è¾‘å›å½’

4. **å‚æ•°è°ƒä¼˜**ï¼š
   - KNNï¼šé€‰æ‹©åˆé€‚çš„Kå€¼
   - å†³ç­–æ ‘ï¼šæ§åˆ¶æ ‘æ·±åº¦
   - æœ´ç´ è´å¶æ–¯ï¼šå¹³æ»‘å‚æ•°

### 7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šåˆ†ç±»å‡†ç¡®ç‡ä½

- **è§£å†³æ–¹æ¡ˆ**ï¼šç‰¹å¾å·¥ç¨‹ã€æ•°æ®æ¸…æ´—ã€ç®—æ³•é€‰æ‹©ã€å‚æ•°è°ƒä¼˜

**é—®é¢˜2**ï¼šè¿‡æ‹Ÿåˆ

- **è§£å†³æ–¹æ¡ˆ**ï¼šå¢åŠ è®­ç»ƒæ•°æ®ã€ç®€åŒ–æ¨¡å‹ã€æ­£åˆ™åŒ–ã€äº¤å‰éªŒè¯

**é—®é¢˜3**ï¼šç±»åˆ«ä¸å¹³è¡¡

- **è§£å†³æ–¹æ¡ˆ**ï¼šé‡é‡‡æ ·ã€ä»£ä»·æ•æ„Ÿå­¦ä¹ ã€è°ƒæ•´é˜ˆå€¼

**é—®é¢˜4**ï¼šè®¡ç®—æ—¶é—´è¿‡é•¿

- **è§£å†³æ–¹æ¡ˆ**ï¼šç‰¹å¾é€‰æ‹©ã€æ•°æ®é‡‡æ ·ã€ç®—æ³•ä¼˜åŒ–ã€å¹¶è¡Œå¤„ç†

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ•°æ®å‡†å¤‡

1. **ç‰¹å¾å·¥ç¨‹**ï¼š
   - é€‰æ‹©ç›¸å…³ç‰¹å¾
   - ç‰¹å¾æ ‡å‡†åŒ–
   - å¤„ç†ç¼ºå¤±å€¼

2. **æ•°æ®åˆ†å‰²**ï¼š
   - è®­ç»ƒé›†ï¼š70-80%
   - éªŒè¯é›†ï¼š10-15%
   - æµ‹è¯•é›†ï¼š10-15%

3. **æ•°æ®è´¨é‡**ï¼š
   - æ•°æ®æ¸…æ´—
   - å¼‚å¸¸å€¼å¤„ç†
   - æ•°æ®å¹³è¡¡

### 8.2 æ¨¡å‹è®­ç»ƒ

1. **ç®—æ³•é€‰æ‹©**ï¼š
   - æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©ç®—æ³•
   - è€ƒè™‘ä¸šåŠ¡éœ€æ±‚
   - å¹³è¡¡å‡†ç¡®ç‡å’Œå¯è§£é‡Šæ€§

2. **å‚æ•°è°ƒä¼˜**ï¼š
   - ä½¿ç”¨äº¤å‰éªŒè¯
   - ç½‘æ ¼æœç´¢
   - æ—©åœç­–ç•¥

3. **æ¨¡å‹è¯„ä¼°**ï¼š
   - ä½¿ç”¨å¤šä¸ªæŒ‡æ ‡
   - æ··æ·†çŸ©é˜µåˆ†æ
   - ç‰¹å¾é‡è¦æ€§åˆ†æ

### 8.3 æ¨¡å‹éƒ¨ç½²

1. **æ€§èƒ½ç›‘æ§**ï¼š
   - ç›‘æ§å‡†ç¡®ç‡
   - ç›‘æ§é¢„æµ‹å»¶è¿Ÿ
   - ç›‘æ§æ•°æ®æ¼‚ç§»

2. **æ¨¡å‹æ›´æ–°**ï¼š
   - å®šæœŸé‡æ–°è®­ç»ƒ
   - å¢é‡å­¦ä¹ 
   - A/Bæµ‹è¯•

3. **å¯è§£é‡Šæ€§**ï¼š
   - æä¾›é¢„æµ‹åŸå› 
   - ç‰¹å¾é‡è¦æ€§
   - å†³ç­–è·¯å¾„

### 8.4 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - åˆ›å»ºé€‚å½“ç´¢å¼•
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾
   - æ‰¹é‡å¤„ç†

2. **æ•°å€¼ç¨³å®šæ€§**ï¼š
   - ä½¿ç”¨å¯¹æ•°é¿å…ä¸‹æº¢
   - å¤„ç†é™¤é›¶é”™è¯¯
   - æ•°å€¼ç²¾åº¦æ§åˆ¶

3. **ä»£ç å¯è¯»æ€§**ï¼š
   - æ¸…æ™°çš„æ³¨é‡Š
   - æ¨¡å—åŒ–è®¾è®¡
   - é”™è¯¯å¤„ç†

### 8.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡åˆ†ç±»ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«åˆ†ç±»å¾—åˆ†çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nåˆ†ç±»æŸ¥è¯¢å’Œæ¦‚ç‡æ’åºæŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡åˆ†ç±»è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡æ¦‚ç‡è®¡ç®—å’ŒKNNè·ç¦»è®¡ç®—

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - åˆ†ç±»è®¡ç®—æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨6èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡æœ´ç´ è´å¶æ–¯å’Œå†³ç­–æ ‘åˆ†ç±»

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–åˆ†ç±»æŸ¥è¯¢**

```sql
-- ä¸ºåˆ†ç±»å¾—åˆ†åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_classification_scores_skip_scan
ON classification_results(class_label, prediction_score DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªç±»åˆ«é¢„æµ‹å¾—åˆ†æœ€é«˜çš„å‰5ä¸ªæ ·æœ¬
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (class_label)
    sample_id,
    class_label,
    prediction_score
FROM classification_results
ORDER BY class_label, prediction_score DESC
LIMIT 50;
```

### 8.6 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜åˆ†ç±»ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„åˆ†ç±»ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜åˆ†ç±»ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS classification_results_cache AS
WITH classification_metrics AS (
    SELECT
        class_label,
        COUNT(*) AS total_predictions,
        COUNT(*) FILTER (WHERE predicted_class = actual_class) AS correct_predictions,
        COUNT(*) FILTER (WHERE predicted_class != actual_class) AS incorrect_predictions,
        AVG(prediction_score) AS avg_confidence,
        STDDEV(prediction_score) AS stddev_confidence,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å‡†ç¡®ç‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        COUNT(*) FILTER (WHERE predicted_class = actual_class)::numeric /
        NULLIF(COUNT(*), 0) * 100 AS accuracy_pct,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ··æ·†çŸ©é˜µï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        COUNT(*) FILTER (WHERE predicted_class = 'Positive' AND actual_class = 'Positive') AS true_positive,
        COUNT(*) FILTER (WHERE predicted_class = 'Positive' AND actual_class = 'Negative') AS false_positive,
        COUNT(*) FILTER (WHERE predicted_class = 'Negative' AND actual_class = 'Positive') AS false_negative,
        COUNT(*) FILTER (WHERE predicted_class = 'Negative' AND actual_class = 'Negative') AS true_negative
    FROM classification_results
    WHERE predicted_class IS NOT NULL AND actual_class IS NOT NULL
    GROUP BY class_label
)
SELECT
    class_label,
    total_predictions,
    correct_predictions,
    incorrect_predictions,
    ROUND(avg_confidence::numeric, 4) AS avg_confidence,
    ROUND(stddev_confidence::numeric, 4) AS stddev_confidence,
    ROUND(accuracy_pct::numeric, 2) AS accuracy_pct,
    true_positive,
    false_positive,
    false_negative,
    true_negative,
    -- è®¡ç®—ç²¾ç¡®ç‡å’Œå¬å›ç‡
    ROUND((true_positive::numeric / NULLIF(true_positive + false_positive, 0) * 100)::numeric, 2) AS precision_pct,
    ROUND((true_positive::numeric / NULLIF(true_positive + false_negative, 0) * 100)::numeric, 2) AS recall_pct,
    -- è®¡ç®—F1åˆ†æ•°
    ROUND((
        2 * (true_positive::numeric / NULLIF(true_positive + false_positive, 0)) *
        (true_positive::numeric / NULLIF(true_positive + false_negative, 0)) /
        NULLIF((true_positive::numeric / NULLIF(true_positive + false_positive, 0)) +
               (true_positive::numeric / NULLIF(true_positive + false_negative, 0)), 0) * 100
    )::numeric, 2) AS f1_score_pct
FROM classification_metrics;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_classification_results_cache_label ON classification_results_cache(class_label);
CREATE INDEX idx_classification_results_cache_accuracy ON classification_results_cache(accuracy_pct DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY classification_results_cache;
```

**2. å®æ—¶åˆ†ç±»ï¼šå¢é‡æ¨¡å‹æ›´æ–°**

**å®æ—¶åˆ†ç±»**ï¼šå¯¹äºæµå¼æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°åˆ†ç±»æ¨¡å‹ã€‚

```sql
-- å®æ—¶åˆ†ç±»ï¼šå¢é‡æ¨¡å‹æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'classification_model_state') THEN
            CREATE TABLE classification_model_state (
                class_label VARCHAR(50) PRIMARY KEY,
                prior_probability NUMERIC NOT NULL,
                feature_means JSONB,  -- å­˜å‚¨æ¯ä¸ªç‰¹å¾çš„å‡å€¼
                feature_variances JSONB,  -- å­˜å‚¨æ¯ä¸ªç‰¹å¾çš„æ–¹å·®
                sample_count BIGINT DEFAULT 0,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_classification_model_state_label ON classification_model_state(class_label);
            CREATE INDEX idx_classification_model_state_updated ON classification_model_state(last_updated DESC);

            RAISE NOTICE 'åˆ†ç±»æ¨¡å‹çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡æ¨¡å‹æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡æ¨¡å‹æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°åˆ†ç±»æ¨¡å‹ï¼šå®æ—¶åˆ†ç±»ï¼ˆæœ´ç´ è´å¶æ–¯å¢é‡æ›´æ–°ï¼‰
WITH new_training_data AS (
    SELECT
        class_label,
        feature1,
        feature2,
        feature3
    FROM training_data
    WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM classification_model_state)
),
class_statistics AS (
    SELECT
        class_label,
        COUNT(*) AS new_sample_count,
        AVG(feature1) AS new_feature1_mean,
        AVG(feature2) AS new_feature2_mean,
        AVG(feature3) AS new_feature3_mean,
        VARIANCE(feature1) AS new_feature1_variance,
        VARIANCE(feature2) AS new_feature2_variance,
        VARIANCE(feature3) AS new_feature3_variance
    FROM new_training_data
    GROUP BY class_label
),
updated_models AS (
    SELECT
        COALESCE(cms.class_label, cs.class_label) AS class_label,
        COALESCE(cms.sample_count, 0) + cs.new_sample_count AS new_sample_count,
        -- æ›´æ–°å…ˆéªŒæ¦‚ç‡
        (COALESCE(cms.sample_count, 0) + cs.new_sample_count)::numeric /
        NULLIF((SELECT SUM(COALESCE(cms2.sample_count, 0) + cs2.new_sample_count)
                FROM classification_model_state cms2
                FULL OUTER JOIN class_statistics cs2 ON cms2.class_label = cs2.class_label), 0) AS new_prior_probability,
        -- æ›´æ–°ç‰¹å¾å‡å€¼ï¼ˆåŠ æƒå¹³å‡ï¼‰
        jsonb_build_object(
            'feature1', (COALESCE((cms.feature_means->>'feature1')::numeric, 0) * COALESCE(cms.sample_count, 0) +
                        cs.new_feature1_mean * cs.new_sample_count) /
                       NULLIF(COALESCE(cms.sample_count, 0) + cs.new_sample_count, 0),
            'feature2', (COALESCE((cms.feature_means->>'feature2')::numeric, 0) * COALESCE(cms.sample_count, 0) +
                        cs.new_feature2_mean * cs.new_sample_count) /
                       NULLIF(COALESCE(cms.sample_count, 0) + cs.new_sample_count, 0),
            'feature3', (COALESCE((cms.feature_means->>'feature3')::numeric, 0) * COALESCE(cms.sample_count, 0) +
                        cs.new_feature3_mean * cs.new_sample_count) /
                       NULLIF(COALESCE(cms.sample_count, 0) + cs.new_sample_count, 0)
        ) AS new_feature_means,
        jsonb_build_object(
            'feature1', cs.new_feature1_variance,
            'feature2', cs.new_feature2_variance,
            'feature3', cs.new_feature3_variance
        ) AS new_feature_variances
    FROM classification_model_state cms
    FULL OUTER JOIN class_statistics cs ON cms.class_label = cs.class_label
)
-- æ›´æ–°æˆ–æ’å…¥åˆ†ç±»æ¨¡å‹çŠ¶æ€
INSERT INTO classification_model_state (
    class_label,
    prior_probability,
    feature_means,
    feature_variances,
    sample_count,
    last_updated
)
SELECT
    class_label,
    new_prior_probability,
    new_feature_means,
    new_feature_variances,
    new_sample_count,
    NOW()
FROM updated_models
ON CONFLICT (class_label)
DO UPDATE SET
    prior_probability = EXCLUDED.prior_probability,
    feature_means = EXCLUDED.feature_means,
    feature_variances = EXCLUDED.feature_variances,
    sample_count = EXCLUDED.sample_count,
    last_updated = NOW();
```

**3. é›†æˆåˆ†ç±»ï¼šå¤šæ¨¡å‹æŠ•ç¥¨åˆ†ç±»**

**é›†æˆåˆ†ç±»**ï¼šç»„åˆå¤šä¸ªåˆ†ç±»æ¨¡å‹çš„é¢„æµ‹ç»“æœï¼Œæé«˜å‡†ç¡®æ€§ã€‚

```sql
-- é›†æˆåˆ†ç±»ï¼šå¤šæ¨¡å‹æŠ•ç¥¨åˆ†ç±»ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'classification_predictions') THEN
            RAISE WARNING 'è¡¨ classification_predictions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œé›†æˆåˆ†ç±»';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œé›†æˆåˆ†ç±»';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é›†æˆåˆ†ç±»å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- é›†æˆåˆ†ç±»ï¼šå¤šæ¨¡å‹æŠ•ç¥¨ï¼ˆåŠ æƒæŠ•ç¥¨ï¼‰
WITH model_predictions AS (
    SELECT
        sample_id,
        model_name,
        predicted_class,
        prediction_score,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ¯ä¸ªæ¨¡å‹çš„æƒé‡ï¼ˆåŸºäºå†å²å‡†ç¡®ç‡ï¼Œé¿å…é‡å¤è®¡ç®—ï¼‰
        prediction_score *
        CASE model_name
            WHEN 'NaiveBayes' THEN 0.4
            WHEN 'DecisionTree' THEN 0.3
            WHEN 'KNN' THEN 0.2
            WHEN 'LogisticRegression' THEN 0.1
            ELSE 0.0
        END AS weighted_score
    FROM classification_predictions
    WHERE prediction_score IS NOT NULL
),
ensemble_voting AS (
    SELECT
        sample_id,
        predicted_class,
        SUM(weighted_score) AS ensemble_score,
        COUNT(*) AS vote_count,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æŠ•ç¥¨ä¸€è‡´æ€§ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        COUNT(*) FILTER (WHERE predicted_class = MODE() WITHIN GROUP (ORDER BY predicted_class) OVER (PARTITION BY sample_id))::numeric /
        NULLIF(COUNT(*) OVER (PARTITION BY sample_id), 0) * 100 AS vote_consistency_pct
    FROM model_predictions
    GROUP BY sample_id, predicted_class
),
ensemble_results AS (
    SELECT DISTINCT ON (sample_id)
        sample_id,
        predicted_class AS ensemble_predicted_class,
        ROUND(ensemble_score::numeric, 4) AS ensemble_confidence,
        vote_count,
        ROUND(vote_consistency_pct::numeric, 2) AS vote_consistency,
        CASE
            WHEN ensemble_score > 0.8 AND vote_consistency_pct > 80 THEN 'High Confidence'
            WHEN ensemble_score > 0.6 AND vote_consistency_pct > 60 THEN 'Medium Confidence'
            ELSE 'Low Confidence'
        END AS confidence_level
    FROM ensemble_voting
    ORDER BY sample_id, ensemble_score DESC
)
SELECT
    sample_id,
    ensemble_predicted_class,
    ROUND(ensemble_confidence::numeric, 4) AS confidence,
    vote_count,
    ROUND(vote_consistency::numeric, 2) AS consistency_pct,
    confidence_level
FROM ensemble_results
ORDER BY ensemble_confidence DESC
LIMIT 50;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **Mitchell, T. M. (1997)**: "Machine Learning", *McGraw-Hill* - ç¬¬3ç«  å†³ç­–æ ‘å­¦ä¹ 

2. **Bishop, C. M. (2006)**: "Pattern Recognition and Machine Learning", *Springer* - ç¬¬4ç«  çº¿æ€§åˆ†ç±»æ¨¡å‹

3. **ã€Šæœºå™¨å­¦ä¹ ã€‹**ï¼ˆå‘¨å¿—å, 2016ï¼‰- ç¬¬4ç«  å†³ç­–æ ‘ã€ç¬¬7ç«  è´å¶æ–¯åˆ†ç±»å™¨

4. **ã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹**ï¼ˆæèˆª, 2012ï¼‰- ç¬¬5ç«  å†³ç­–æ ‘ã€ç¬¬4ç«  æœ´ç´ è´å¶æ–¯

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- **çª—å£å‡½æ•°**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **èšåˆå‡½æ•°**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **æ•°ç»„æ“ä½œ**: <https://www.postgresql.org/docs/current/functions-array.html>

### åœ¨çº¿èµ„æº

- **åˆ†ç±»ç®—æ³•**: <https://scikit-learn.org/stable/supervised_learning.html>
- **æœ´ç´ è´å¶æ–¯**: <https://en.wikipedia.org/wiki/Naive_Bayes_classifier>
- **å†³ç­–æ ‘**: <https://en.wikipedia.org/wiki/Decision_tree>
- **KNN**: <https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm>

### ç›¸å…³ç®—æ³•

- **èšç±»åˆ†æ**ï¼šæ— ç›‘ç£å­¦ä¹ 
- **å…³è”è§„åˆ™æŒ–æ˜**ï¼šå‘ç°å…³è”å…³ç³»
- **é€»è¾‘å›å½’**ï¼šçº¿æ€§åˆ†ç±»
- **æ”¯æŒå‘é‡æœº**ï¼šéçº¿æ€§åˆ†ç±»

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
