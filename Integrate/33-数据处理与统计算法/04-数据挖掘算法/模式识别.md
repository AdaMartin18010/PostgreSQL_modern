# PostgreSQL æ¨¡å¼è¯†åˆ«å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ¨¡å¼è¯†åˆ« | åºåˆ—åˆ†æ
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æ¨¡å¼è¯†åˆ«å®Œæ•´æŒ‡å—](#postgresql-æ¨¡å¼è¯†åˆ«å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¨¡å¼è¯†åˆ«æ¦‚è¿°](#æ¨¡å¼è¯†åˆ«æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æ¨¡å¼å®šä¹‰](#æ¨¡å¼å®šä¹‰)
      - [æ¨¡å¼è¯†åˆ«æ–¹æ³•](#æ¨¡å¼è¯†åˆ«æ–¹æ³•)
      - [æ”¯æŒåº¦å’Œç½®ä¿¡åº¦](#æ”¯æŒåº¦å’Œç½®ä¿¡åº¦)
    - [æ ¸å¿ƒæ¨¡å¼ç±»å‹](#æ ¸å¿ƒæ¨¡å¼ç±»å‹)
  - [1. åºåˆ—æ¨¡å¼è¯†åˆ«](#1-åºåˆ—æ¨¡å¼è¯†åˆ«)
    - [1.1 åºåˆ—æ¨¡å¼è¯†åˆ«åŸç†](#11-åºåˆ—æ¨¡å¼è¯†åˆ«åŸç†)
      - [åºåˆ—æ¨¡å¼å®šä¹‰](#åºåˆ—æ¨¡å¼å®šä¹‰)
      - [åºåˆ—æ¨¡å¼åŒ¹é…](#åºåˆ—æ¨¡å¼åŒ¹é…)
    - [1.2 åºåˆ—æ¨¡å¼æ£€æµ‹å®ç°](#12-åºåˆ—æ¨¡å¼æ£€æµ‹å®ç°)
    - [1.3 å¤šé˜¶åºåˆ—æ¨¡å¼](#13-å¤šé˜¶åºåˆ—æ¨¡å¼)
    - [1.4 åºåˆ—æ¨¡å¼ç½®ä¿¡åº¦è®¡ç®—](#14-åºåˆ—æ¨¡å¼ç½®ä¿¡åº¦è®¡ç®—)
  - [2. é¢‘ç¹æ¨¡å¼è¯†åˆ«](#2-é¢‘ç¹æ¨¡å¼è¯†åˆ«)
    - [2.1 é¢‘ç¹æ¨¡å¼è¯†åˆ«åŸç†](#21-é¢‘ç¹æ¨¡å¼è¯†åˆ«åŸç†)
      - [é¢‘ç¹é¡¹é›†å®šä¹‰](#é¢‘ç¹é¡¹é›†å®šä¹‰)
      - [AprioriåŸç†](#aprioriåŸç†)
    - [2.2 é¢‘ç¹é¡¹é›†è¯†åˆ«å®ç°](#22-é¢‘ç¹é¡¹é›†è¯†åˆ«å®ç°)
    - [2.3 å¤šç»´åº¦é¢‘ç¹æ¨¡å¼](#23-å¤šç»´åº¦é¢‘ç¹æ¨¡å¼)
  - [3. å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«](#3-å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«)
    - [3.1 å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«åŸç†](#31-å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«åŸç†)
      - [å‘¨æœŸæ¨¡å¼å®šä¹‰](#å‘¨æœŸæ¨¡å¼å®šä¹‰)
      - [å‘¨æœŸæ£€æµ‹æ–¹æ³•](#å‘¨æœŸæ£€æµ‹æ–¹æ³•)
    - [3.2 å‘¨æœŸæ£€æµ‹å®ç°](#32-å‘¨æœŸæ£€æµ‹å®ç°)
    - [3.3 å¤šå‘¨æœŸæ¨¡å¼æ£€æµ‹](#33-å¤šå‘¨æœŸæ¨¡å¼æ£€æµ‹)
    - [3.4 è‡ªç›¸å…³å‘¨æœŸæ£€æµ‹](#34-è‡ªç›¸å…³å‘¨æœŸæ£€æµ‹)
  - [4. å…³è”æ¨¡å¼è¯†åˆ«](#4-å…³è”æ¨¡å¼è¯†åˆ«)
    - [4.1 å…³è”æ¨¡å¼è¯†åˆ«åŸç†](#41-å…³è”æ¨¡å¼è¯†åˆ«åŸç†)
      - [å…³è”è§„åˆ™å®šä¹‰](#å…³è”è§„åˆ™å®šä¹‰)
    - [4.2 å…³è”æ¨¡å¼è¯†åˆ«å®ç°](#42-å…³è”æ¨¡å¼è¯†åˆ«å®ç°)
  - [5. PostgreSQL 18 å¹¶è¡Œæ¨¡å¼è¯†åˆ«å¢å¼º](#5-postgresql-18-å¹¶è¡Œæ¨¡å¼è¯†åˆ«å¢å¼º)
    - [5.1 å¹¶è¡Œæ¨¡å¼è¯†åˆ«åŸç†](#51-å¹¶è¡Œæ¨¡å¼è¯†åˆ«åŸç†)
    - [5.2 å¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«](#52-å¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«)
    - [5.3 å¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«](#53-å¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«)
    - [5.4 å¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«](#54-å¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 ç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«](#51-ç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«)
    - [5.2 è´­ç‰©ç¯®æ¨¡å¼è¯†åˆ«](#52-è´­ç‰©ç¯®æ¨¡å¼è¯†åˆ«)
    - [5.3 ç½‘ç«™å¯¼èˆªæ¨¡å¼è¯†åˆ«](#53-ç½‘ç«™å¯¼èˆªæ¨¡å¼è¯†åˆ«)
    - [5.4 æ—¶é—´åºåˆ—æ¨¡å¼è¯†åˆ«](#54-æ—¶é—´åºåˆ—æ¨¡å¼è¯†åˆ«)
  - [6. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#6-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [6.1 æ¨¡å¼è¯†åˆ«æ–¹æ³•å¯¹æ¯”](#61-æ¨¡å¼è¯†åˆ«æ–¹æ³•å¯¹æ¯”)
    - [6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#62-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#63-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 æ¨¡å¼è¯†åˆ«æ–¹æ³•é€‰æ‹©](#71-æ¨¡å¼è¯†åˆ«æ–¹æ³•é€‰æ‹©)
    - [7.2 æ¨¡å¼è¯†åˆ«æ³¨æ„äº‹é¡¹](#72-æ¨¡å¼è¯†åˆ«æ³¨æ„äº‹é¡¹)
    - [7.3 SQLå®ç°æ³¨æ„äº‹é¡¹](#73-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [7.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#74-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [7.5 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#75-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## æ¨¡å¼è¯†åˆ«æ¦‚è¿°

**æ¨¡å¼è¯†åˆ«ï¼ˆPattern Recognitionï¼‰**ç”¨äºè¯†åˆ«æ•°æ®ä¸­çš„é‡å¤æ¨¡å¼å’Œè§„å¾‹ï¼Œå¸¸ç”¨äºè¡Œä¸ºåˆ†æã€è¶‹åŠ¿é¢„æµ‹å’ŒçŸ¥è¯†å‘ç°ã€‚æ¨¡å¼è¯†åˆ«æ˜¯æ•°æ®æŒ–æ˜å’Œæœºå™¨å­¦ä¹ çš„é‡è¦åˆ†æ”¯ï¼Œèƒ½å¤Ÿä»å¤§é‡æ•°æ®ä¸­æå–æœ‰ä»·å€¼çš„ä¿¡æ¯ã€‚

### ç†è®ºåŸºç¡€

#### æ¨¡å¼å®šä¹‰

**æ¨¡å¼ï¼ˆPatternï¼‰**æ˜¯æŒ‡æ•°æ®ä¸­é‡å¤å‡ºç°çš„ã€æœ‰æ„ä¹‰çš„ç»“æ„æˆ–è§„å¾‹ã€‚æ¨¡å¼å¯ä»¥åˆ†ä¸ºï¼š

1. **åºåˆ—æ¨¡å¼ï¼ˆSequential Patternï¼‰**ï¼šæŒ‰æ—¶é—´é¡ºåºå‡ºç°çš„æ¨¡å¼
2. **é¢‘ç¹æ¨¡å¼ï¼ˆFrequent Patternï¼‰**ï¼šé¢‘ç¹å‡ºç°çš„æ¨¡å¼
3. **å‘¨æœŸæ¨¡å¼ï¼ˆPeriodic Patternï¼‰**ï¼šå‘¨æœŸæ€§é‡å¤çš„æ¨¡å¼
4. **å…³è”æ¨¡å¼ï¼ˆAssociation Patternï¼‰**ï¼šåŒæ—¶å‡ºç°çš„æ¨¡å¼

#### æ¨¡å¼è¯†åˆ«æ–¹æ³•

1. **ç»Ÿè®¡æ–¹æ³•**ï¼š
   - é¢‘ç‡åˆ†æ
   - ç›¸å…³æ€§åˆ†æ
   - èšç±»åˆ†æ

2. **åºåˆ—æ–¹æ³•**ï¼š
   - åºåˆ—åŒ¹é…
   - åºåˆ—æŒ–æ˜
   - é©¬å°”å¯å¤«é“¾

3. **é¢‘åŸŸæ–¹æ³•**ï¼š
   - å‚…é‡Œå¶å˜æ¢
   - å°æ³¢å˜æ¢
   - é¢‘è°±åˆ†æ

#### æ”¯æŒåº¦å’Œç½®ä¿¡åº¦

**æ”¯æŒåº¦ï¼ˆSupportï¼‰**ï¼šæ¨¡å¼å‡ºç°çš„é¢‘ç‡
$$Support(X) = \frac{|\{t \in T : X \subseteq t\}|}{|T|}$$

**ç½®ä¿¡åº¦ï¼ˆConfidenceï¼‰**ï¼šæ¨¡å¼çš„æ¡ä»¶æ¦‚ç‡
$$Confidence(X \rightarrow Y) = \frac{Support(X \cup Y)}{Support(X)}$$

### æ ¸å¿ƒæ¨¡å¼ç±»å‹

| æ¨¡å¼ç±»å‹ | ç”¨é€” | å¤æ‚åº¦ | æ•°å­¦è¡¨ç¤º |
|---------|------|--------|---------|
| **åºåˆ—æ¨¡å¼** | é¡ºåºæ¨¡å¼ | $O(n^2)$ | $P = \{p_1, p_2, \ldots, p_k\}$ |
| **é¢‘ç¹æ¨¡å¼** | é‡å¤æ¨¡å¼ | $O(n)$ | $Support(P) \geq \theta$ |
| **å‘¨æœŸæ¨¡å¼** | å‘¨æœŸæ€§è§„å¾‹ | $O(n \log n)$ | $P(t) = P(t + kT)$ |
| **å…³è”æ¨¡å¼** | å…³è”è§„åˆ™ | $O(2^n)$ | $X \rightarrow Y$ |

---

## 1. åºåˆ—æ¨¡å¼è¯†åˆ«

### 1.1 åºåˆ—æ¨¡å¼è¯†åˆ«åŸç†

**åºåˆ—æ¨¡å¼è¯†åˆ«ï¼ˆSequential Pattern Recognitionï¼‰**è¯†åˆ«æ•°æ®ä¸­æŒ‰æ—¶é—´é¡ºåºå‡ºç°çš„æ¨¡å¼ï¼Œç”¨äºåˆ†æè¡Œä¸ºåºåˆ—ã€äº‹ä»¶åºåˆ—ç­‰ã€‚

#### åºåˆ—æ¨¡å¼å®šä¹‰

**åºåˆ—æ¨¡å¼**æ˜¯ä¸€ä¸ªæœ‰åºçš„äº‹ä»¶åºåˆ—ï¼š
$$S = \langle e_1, e_2, \ldots, e_n \rangle$$

å…¶ä¸­$e_i$æ˜¯äº‹ä»¶ï¼Œ$n$æ˜¯åºåˆ—é•¿åº¦ã€‚

#### åºåˆ—æ¨¡å¼åŒ¹é…

**å­åºåˆ—åŒ¹é…**ï¼šåºåˆ—$S_1 = \langle a, b, c \rangle$æ˜¯åºåˆ—$S_2 = \langle a, x, b, y, c \rangle$çš„å­åºåˆ—ã€‚

**æ”¯æŒåº¦è®¡ç®—**ï¼šåºåˆ—æ¨¡å¼$P$åœ¨åºåˆ—æ•°æ®åº“$D$ä¸­çš„æ”¯æŒåº¦ï¼š
$$Support(P) = \frac{|\{S \in D : P \subseteq S\}|}{|D|}$$

### 1.2 åºåˆ—æ¨¡å¼æ£€æµ‹å®ç°

```sql
-- åºåˆ—æ¨¡å¼è¯†åˆ«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_actions') THEN
            RAISE WARNING 'è¡¨ user_actions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åºåˆ—æ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH action_sequences AS (
    SELECT
        user_id,
        action_type,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS prev_action,
        LEAD(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS next_action
    FROM user_actions
)
SELECT
    prev_action,
    action_type AS current_action,
    next_action,
    COUNT(*) AS pattern_count
FROM action_sequences
WHERE prev_action IS NOT NULL AND next_action IS NOT NULL
GROUP BY prev_action, action_type, next_action
HAVING COUNT(*) >= 10  -- æœ€å°æ”¯æŒåº¦
ORDER BY pattern_count DESC;
```

---

### 1.3 å¤šé˜¶åºåˆ—æ¨¡å¼

**å¤šé˜¶åºåˆ—æ¨¡å¼**è¯†åˆ«ä¸åŒé•¿åº¦çš„åºåˆ—æ¨¡å¼ã€‚

```sql
-- å¤šé˜¶åºåˆ—æ¨¡å¼è¯†åˆ«ï¼š2é˜¶ã€3é˜¶ã€4é˜¶æ¨¡å¼
WITH action_sequences AS (
    SELECT
        user_id,
        action_type,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY action_time) AS seq_num,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS prev_action,
        LAG(action_type, 2) OVER (PARTITION BY user_id ORDER BY action_time) AS prev2_action,
        LEAD(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS next_action
    FROM user_actions
),
patterns_2 AS (
    SELECT
        prev_action,
        action_type AS current_action,
        COUNT(*) AS pattern_count
    FROM action_sequences
    WHERE prev_action IS NOT NULL
    GROUP BY prev_action, action_type
    HAVING COUNT(*) >= 10
),
patterns_3 AS (
    SELECT
        prev2_action,
        prev_action,
        action_type AS current_action,
        COUNT(*) AS pattern_count
    FROM action_sequences
    WHERE prev2_action IS NOT NULL AND prev_action IS NOT NULL
    GROUP BY prev2_action, prev_action, action_type
    HAVING COUNT(*) >= 5
)
SELECT
    '2é˜¶æ¨¡å¼' AS pattern_type,
    prev_action || ' -> ' || current_action AS pattern,
    pattern_count
FROM patterns_2
UNION ALL
SELECT
    '3é˜¶æ¨¡å¼' AS pattern_type,
    prev2_action || ' -> ' || prev_action || ' -> ' || current_action AS pattern,
    pattern_count
FROM patterns_3
ORDER BY pattern_type, pattern_count DESC;
```

### 1.4 åºåˆ—æ¨¡å¼ç½®ä¿¡åº¦è®¡ç®—

**ç½®ä¿¡åº¦**è®¡ç®—åºåˆ—æ¨¡å¼çš„è½¬æ¢æ¦‚ç‡ã€‚

```sql
-- åºåˆ—æ¨¡å¼ç½®ä¿¡åº¦è®¡ç®—
WITH action_transitions AS (
    SELECT
        user_id,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS from_action,
        action_type AS to_action
    FROM user_actions
),
transition_stats AS (
    SELECT
        from_action,
        to_action,
        COUNT(*) AS transition_count
    FROM action_transitions
    WHERE from_action IS NOT NULL
    GROUP BY from_action, to_action
),
from_action_counts AS (
    SELECT
        from_action,
        SUM(transition_count) AS total_from_count
    FROM transition_stats
    GROUP BY from_action
)
SELECT
    ts.from_action,
    ts.to_action,
    ts.transition_count,
    ts.transition_count * 100.0 / NULLIF(fac.total_from_count, 0) AS confidence_pct,
    -- æ”¯æŒåº¦
    ts.transition_count * 100.0 / (SELECT COUNT(*) FROM action_transitions WHERE from_action IS NOT NULL) AS support_pct
FROM transition_stats ts
JOIN from_action_counts fac ON ts.from_action = fac.from_action
WHERE ts.transition_count >= 10
ORDER BY ts.from_action, confidence_pct DESC;
```

---

## 2. é¢‘ç¹æ¨¡å¼è¯†åˆ«

### 2.1 é¢‘ç¹æ¨¡å¼è¯†åˆ«åŸç†

**é¢‘ç¹æ¨¡å¼è¯†åˆ«ï¼ˆFrequent Pattern Recognitionï¼‰**è¯†åˆ«æ•°æ®ä¸­é¢‘ç¹å‡ºç°çš„æ¨¡å¼ï¼Œæ˜¯å…³è”è§„åˆ™æŒ–æ˜çš„åŸºç¡€ã€‚

#### é¢‘ç¹é¡¹é›†å®šä¹‰

**é¢‘ç¹é¡¹é›†ï¼ˆFrequent Itemsetï¼‰**æ˜¯æŒ‡æ”¯æŒåº¦å¤§äºç­‰äºæœ€å°æ”¯æŒåº¦é˜ˆå€¼çš„é¡¹é›†ï¼š
$$Support(I) \geq min\_support$$

å…¶ä¸­$I$æ˜¯é¡¹é›†ï¼Œ$min\_support$æ˜¯æœ€å°æ”¯æŒåº¦é˜ˆå€¼ã€‚

#### AprioriåŸç†

**AprioriåŸç†**ï¼šå¦‚æœä¸€ä¸ªé¡¹é›†æ˜¯é¢‘ç¹çš„ï¼Œé‚£ä¹ˆå®ƒçš„æ‰€æœ‰å­é›†ä¹Ÿæ˜¯é¢‘ç¹çš„ï¼›å¦‚æœä¸€ä¸ªé¡¹é›†ä¸æ˜¯é¢‘ç¹çš„ï¼Œé‚£ä¹ˆå®ƒçš„æ‰€æœ‰è¶…é›†ä¹Ÿä¸æ˜¯é¢‘ç¹çš„ã€‚

### 2.2 é¢‘ç¹é¡¹é›†è¯†åˆ«å®ç°

```sql
-- é¢‘ç¹æ¨¡å¼è¯†åˆ«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'events') THEN
            RAISE WARNING 'è¡¨ events ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é¢‘ç¹æ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT
    event_type,
    COUNT(*) AS frequency,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS frequency_pct
FROM events
GROUP BY event_type
HAVING COUNT(*) >= 100  -- æœ€å°æ”¯æŒåº¦
ORDER BY frequency DESC;
```

---

### 2.3 å¤šç»´åº¦é¢‘ç¹æ¨¡å¼

**å¤šç»´åº¦é¢‘ç¹æ¨¡å¼**è¯†åˆ«å¤šä¸ªç»´åº¦ä¸Šçš„é¢‘ç¹æ¨¡å¼ã€‚

```sql
-- å¤šç»´åº¦é¢‘ç¹æ¨¡å¼è¯†åˆ«ï¼šäº‹ä»¶ç±»å‹ã€æ—¶é—´ã€åœ°ç‚¹
WITH multi_dim_patterns AS (
    SELECT
        event_type,
        DATE_TRUNC('hour', event_time) AS event_hour,
        location,
        COUNT(*) AS pattern_count
    FROM events
    GROUP BY event_type, DATE_TRUNC('hour', event_time), location
)
SELECT
    event_type,
    event_hour,
    location,
    pattern_count,
    pattern_count * 100.0 / SUM(pattern_count) OVER () AS support_pct,
    -- é¢‘ç¹æ¨¡å¼åˆ¤æ–­
    CASE
        WHEN pattern_count >= 100 THEN 'é«˜é¢‘æ¨¡å¼'
        WHEN pattern_count >= 50 THEN 'ä¸­é¢‘æ¨¡å¼'
        WHEN pattern_count >= 10 THEN 'ä½é¢‘æ¨¡å¼'
        ELSE 'ç½•è§æ¨¡å¼'
    END AS frequency_level
FROM multi_dim_patterns
WHERE pattern_count >= 10
ORDER BY pattern_count DESC;
```

---

## 3. å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«

### 3.1 å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«åŸç†

**å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«ï¼ˆPeriodic Pattern Recognitionï¼‰**è¯†åˆ«æ•°æ®ä¸­å‘¨æœŸæ€§é‡å¤çš„æ¨¡å¼ï¼Œç”¨äºåˆ†ææ—¶é—´åºåˆ—çš„å‘¨æœŸæ€§è§„å¾‹ã€‚

#### å‘¨æœŸæ¨¡å¼å®šä¹‰

**å‘¨æœŸæ¨¡å¼**æ˜¯æŒ‡æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æ¨¡å¼ï¼š
$$P(t) = P(t + kT), \quad k \in \mathbb{Z}$$

å…¶ä¸­ï¼š

- $P(t)$ï¼šæ—¶é—´$t$çš„æ¨¡å¼
- $T$ï¼šå‘¨æœŸé•¿åº¦
- $k$ï¼šå‘¨æœŸå€æ•°

#### å‘¨æœŸæ£€æµ‹æ–¹æ³•

1. **è‡ªç›¸å…³åˆ†æ**ï¼šè®¡ç®—ä¸åŒæ»åçš„è‡ªç›¸å…³ç³»æ•°
2. **é¢‘åŸŸåˆ†æ**ï¼šä½¿ç”¨å‚…é‡Œå¶å˜æ¢æ£€æµ‹å‘¨æœŸ
3. **ç»Ÿè®¡æ–¹æ³•**ï¼šä½¿ç”¨æ–¹å·®åˆ†ææ£€æµ‹å‘¨æœŸæ€§

### 3.2 å‘¨æœŸæ£€æµ‹å®ç°

```sql
-- å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å‘¨æœŸæ€§æ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH daily_patterns AS (
    SELECT
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day,
        AVG(value) AS avg_value
    FROM time_series
    GROUP BY EXTRACT(DOW FROM timestamp), EXTRACT(HOUR FROM timestamp)
)
SELECT
    day_of_week,
    hour_of_day,
    avg_value,
    CASE
        WHEN avg_value > (SELECT AVG(avg_value) FROM daily_patterns) + (SELECT STDDEV(avg_value) FROM daily_patterns) THEN 'é«˜å³°'
        WHEN avg_value < (SELECT AVG(avg_value) FROM daily_patterns) - (SELECT STDDEV(avg_value) FROM daily_patterns) THEN 'ä½è°·'
        ELSE 'æ­£å¸¸'
    END AS pattern_type
FROM daily_patterns
ORDER BY day_of_week, hour_of_day;
```

---

### 3.3 å¤šå‘¨æœŸæ¨¡å¼æ£€æµ‹

**å¤šå‘¨æœŸæ¨¡å¼**æ£€æµ‹å¤šä¸ªå‘¨æœŸé•¿åº¦çš„æ¨¡å¼ã€‚

```sql
-- å¤šå‘¨æœŸæ¨¡å¼æ£€æµ‹ï¼šæ—¥å‘¨æœŸã€å‘¨å‘¨æœŸã€æœˆå‘¨æœŸ
WITH periodic_patterns AS (
    SELECT
        timestamp,
        value,
        EXTRACT(DAY FROM timestamp) AS day_of_month,
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day,
        EXTRACT(MONTH FROM timestamp) AS month_of_year
    FROM time_series
),
daily_pattern AS (
    SELECT
        hour_of_day,
        AVG(value) AS avg_value,
        STDDEV(value) AS stddev_value
    FROM periodic_patterns
    GROUP BY hour_of_day
),
weekly_pattern AS (
    SELECT
        day_of_week,
        AVG(value) AS avg_value,
        STDDEV(value) AS stddev_value
    FROM periodic_patterns
    GROUP BY day_of_week
),
monthly_pattern AS (
    SELECT
        day_of_month,
        AVG(value) AS avg_value,
        STDDEV(value) AS stddev_value
    FROM periodic_patterns
    GROUP BY day_of_month
)
SELECT
    'æ—¥å‘¨æœŸ' AS pattern_type,
    hour_of_day AS pattern_value,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM daily_pattern
UNION ALL
SELECT
    'å‘¨å‘¨æœŸ' AS pattern_type,
    day_of_week AS pattern_value,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM weekly_pattern
UNION ALL
SELECT
    'æœˆå‘¨æœŸ' AS pattern_type,
    day_of_month AS pattern_value,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM monthly_pattern
ORDER BY pattern_type, pattern_value;
```

### 3.4 è‡ªç›¸å…³å‘¨æœŸæ£€æµ‹

**è‡ªç›¸å…³åˆ†æ**ä½¿ç”¨è‡ªç›¸å…³å‡½æ•°æ£€æµ‹å‘¨æœŸã€‚

```sql
-- è‡ªç›¸å…³å‘¨æœŸæ£€æµ‹ï¼šæ£€æµ‹æ—¶é—´åºåˆ—çš„å‘¨æœŸé•¿åº¦
WITH time_series_indexed AS (
    SELECT
        timestamp,
        value,
        ROW_NUMBER() OVER (ORDER BY timestamp) AS t,
        AVG(value) OVER () AS mean_value
    FROM time_series
    WHERE value IS NOT NULL
),
autocorrelation AS (
    SELECT
        lag_k,
        -- è‡ªç›¸å…³ï¼šr_k = E[(y_t - mean)(y_{t+k} - mean)] / Var(y)
        AVG((t1.value - t1.mean_value) * (t2.value - t2.mean_value)) /
        NULLIF(VAR_POP(t1.value), 0) AS acf
    FROM time_series_indexed t1
    CROSS JOIN generate_series(1, 168) AS lag_k  -- æ£€æŸ¥168å°æ—¶ï¼ˆ1å‘¨ï¼‰
    JOIN time_series_indexed t2 ON t2.t = t1.t + lag_k
    WHERE t2.t IS NOT NULL
    GROUP BY lag_k
)
SELECT
    lag_k,
    ROUND(acf::numeric, 4) AS autocorrelation,
    -- å‘¨æœŸæ£€æµ‹ï¼šACFæ˜¾è‘—å¤§äº0çš„æ»å
    CASE
        WHEN ABS(acf) > 0.3 THEN 'å¼ºå‘¨æœŸ'
        WHEN ABS(acf) > 0.2 THEN 'ä¸­ç­‰å‘¨æœŸ'
        WHEN ABS(acf) > 0.1 THEN 'å¼±å‘¨æœŸ'
        ELSE 'æ— å‘¨æœŸ'
    END AS periodicity
FROM autocorrelation
ORDER BY ABS(acf) DESC;
```

---

## 4. å…³è”æ¨¡å¼è¯†åˆ«

### 4.1 å…³è”æ¨¡å¼è¯†åˆ«åŸç†

**å…³è”æ¨¡å¼è¯†åˆ«ï¼ˆAssociation Pattern Recognitionï¼‰**è¯†åˆ«æ•°æ®ä¸­åŒæ—¶å‡ºç°çš„æ¨¡å¼ï¼Œæ˜¯å…³è”è§„åˆ™æŒ–æ˜çš„åŸºç¡€ã€‚

#### å…³è”è§„åˆ™å®šä¹‰

**å…³è”è§„åˆ™**ï¼š$X \rightarrow Y$ï¼Œè¡¨ç¤ºå¦‚æœ$X$å‡ºç°ï¼Œåˆ™$Y$ä¹Ÿå¯èƒ½å‡ºç°ã€‚

**æ”¯æŒåº¦**ï¼š
$$Support(X \rightarrow Y) = Support(X \cup Y)$$

**ç½®ä¿¡åº¦**ï¼š
$$Confidence(X \rightarrow Y) = \frac{Support(X \cup Y)}{Support(X)}$$

### 4.2 å…³è”æ¨¡å¼è¯†åˆ«å®ç°

```sql
-- å…³è”æ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«åŒæ—¶å‡ºç°çš„äº‹ä»¶
WITH event_cooccurrence AS (
    SELECT
        e1.event_type AS event_a,
        e2.event_type AS event_b,
        COUNT(DISTINCT e1.session_id) AS cooccurrence_count
    FROM events e1
    JOIN events e2 ON e1.session_id = e2.session_id
        AND e1.event_type < e2.event_type  -- é¿å…é‡å¤
    GROUP BY e1.event_type, e2.event_type
),
event_counts AS (
    SELECT
        event_type,
        COUNT(DISTINCT session_id) AS event_count
    FROM events
    GROUP BY event_type
),
association_rules AS (
    SELECT
        ec.event_a,
        ec.event_b,
        ec.cooccurrence_count,
        ec.cooccurrence_count * 100.0 / NULLIF(ea.event_count, 0) AS confidence_ab,
        ec.cooccurrence_count * 100.0 / NULLIF(eb.event_count, 0) AS confidence_ba,
        ec.cooccurrence_count * 100.0 / (SELECT COUNT(DISTINCT session_id) FROM events) AS support
    FROM event_cooccurrence ec
    JOIN event_counts ea ON ec.event_a = ea.event_type
    JOIN event_counts eb ON ec.event_b = eb.event_type
)
SELECT
    event_a,
    event_b,
    cooccurrence_count,
    ROUND(confidence_ab::numeric, 2) AS confidence_ab_pct,
    ROUND(confidence_ba::numeric, 2) AS confidence_ba_pct,
    ROUND(support::numeric, 2) AS support_pct,
    -- å…³è”å¼ºåº¦
    CASE
        WHEN confidence_ab > 50 AND confidence_ba > 50 THEN 'å¼ºå…³è”'
        WHEN confidence_ab > 30 OR confidence_ba > 30 THEN 'ä¸­ç­‰å…³è”'
        ELSE 'å¼±å…³è”'
    END AS association_strength
FROM association_rules
WHERE cooccurrence_count >= 10
ORDER BY cooccurrence_count DESC;
```

---

## 5. PostgreSQL 18 å¹¶è¡Œæ¨¡å¼è¯†åˆ«å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œæ¨¡å¼è¯†åˆ«èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œåºåˆ—æ¨¡å¼ã€é¢‘ç¹æ¨¡å¼å’Œå‘¨æœŸæ¨¡å¼è¯†åˆ«ï¼Œå¤§å¹…æå‡å¤§æ•°æ®é‡æ¨¡å¼è¯†åˆ«æŸ¥è¯¢çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œæ¨¡å¼è¯†åˆ«åŸç†

PostgreSQL 18 çš„å¹¶è¡Œæ¨¡å¼è¯†åˆ«é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æè¡¨æ•°æ®
2. **å¹¶è¡Œæ¨¡å¼åŒ¹é…**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡Œæ¨¡å¼åŒ¹é…
3. **å¹¶è¡Œé¢‘ç‡è®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—æ¨¡å¼é¢‘ç‡
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„æ¨¡å¼è¯†åˆ«ç»“æœ

### 5.2 å¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«

```sql
-- PostgreSQL 18 å¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_actions') THEN
            RAISE WARNING 'è¡¨ user_actions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œåºåˆ—æ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«ç”¨æˆ·è¡Œä¸ºåºåˆ—æ¨¡å¼
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH user_sequences AS (
    SELECT
        user_id,
        action_type,
        action_time,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS prev_action,
        LEAD(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS next_action
    FROM user_actions
    WHERE action_time >= CURRENT_DATE - INTERVAL '30 days'
),
sequence_patterns AS (
    SELECT
        prev_action,
        action_type,
        next_action,
        COUNT(*) AS pattern_count
    FROM user_sequences
    WHERE prev_action IS NOT NULL AND next_action IS NOT NULL
    GROUP BY prev_action, action_type, next_action
)
SELECT
    prev_action || ' -> ' || action_type || ' -> ' || next_action AS sequence_pattern,
    pattern_count,
    ROUND(100.0 * pattern_count / SUM(pattern_count) OVER (), 2) AS pattern_percentage
FROM sequence_patterns
ORDER BY pattern_count DESC
LIMIT 20;
```

### 5.3 å¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«

```sql
-- PostgreSQL 18 å¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'transactions') THEN
            RAISE WARNING 'è¡¨ transactions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œé¢‘ç¹æ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«é¢‘ç¹å‡ºç°çš„é¡¹ç›®ç»„åˆ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH item_sets AS (
    SELECT
        transaction_id,
        ARRAY_AGG(item_id ORDER BY item_id) AS items
    FROM transactions
    GROUP BY transaction_id
),
frequent_patterns AS (
    SELECT
        items,
        COUNT(*) AS support_count,
        COUNT(*) * 100.0 / (SELECT COUNT(DISTINCT transaction_id) FROM transactions) AS support_percentage
    FROM item_sets
    GROUP BY items
    HAVING COUNT(*) >= 10  -- æœ€å°æ”¯æŒåº¦
)
SELECT
    items,
    support_count,
    ROUND(support_percentage::numeric, 2) AS support_percentage
FROM frequent_patterns
ORDER BY support_count DESC
LIMIT 20;
```

### 5.4 å¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«

```sql
-- PostgreSQL 18 å¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå‘¨æœŸæ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«æ—¶é—´åºåˆ—ä¸­çš„å‘¨æœŸæ¨¡å¼
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH periodic_patterns AS (
    SELECT
        timestamp,
        value,
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day
    FROM time_series
    WHERE timestamp >= CURRENT_DATE - INTERVAL '90 days'
),
daily_patterns AS (
    SELECT
        day_of_week,
        hour_of_day,
        AVG(value) AS avg_value,
        COUNT(*) AS pattern_count
    FROM periodic_patterns
    GROUP BY day_of_week, hour_of_day
)
SELECT
    day_of_week,
    hour_of_day,
    ROUND(avg_value::numeric, 2) AS avg_value,
    pattern_count,
    CASE
        WHEN avg_value > (SELECT AVG(avg_value) FROM daily_patterns) + (SELECT STDDEV(avg_value) FROM daily_patterns) THEN 'é«˜å³°'
        WHEN avg_value < (SELECT AVG(avg_value) FROM daily_patterns) - (SELECT STDDEV(avg_value) FROM daily_patterns) THEN 'ä½è°·'
        ELSE 'æ­£å¸¸'
    END AS pattern_type
FROM daily_patterns
ORDER BY day_of_week, hour_of_day;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 ç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«

**ç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«**è¯†åˆ«ç”¨æˆ·è¡Œä¸ºæ¨¡å¼ã€‚

```sql
-- ç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_sessions') THEN
            RAISE WARNING 'è¡¨ user_sessions ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH session_patterns AS (
    SELECT
        user_id,
        session_id,
        page_path,
        ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY visit_time) AS page_order
    FROM user_sessions
),
page_transitions AS (
    SELECT
        sp1.page_path AS from_page,
        sp2.page_path AS to_page,
        COUNT(*) AS transition_count
    FROM session_patterns sp1
    JOIN session_patterns sp2 ON sp1.session_id = sp2.session_id
        AND sp2.page_order = sp1.page_order + 1
    GROUP BY sp1.page_path, sp2.page_path
)
SELECT
    from_page,
    to_page,
    transition_count,
    transition_count * 100.0 / SUM(transition_count) OVER (PARTITION BY from_page) AS transition_probability
FROM page_transitions
WHERE transition_count >= 5  -- æœ€å°æ”¯æŒåº¦
ORDER BY from_page, transition_count DESC;
```

### 5.2 è´­ç‰©ç¯®æ¨¡å¼è¯†åˆ«

**åœºæ™¯**ï¼šè¯†åˆ«è´­ç‰©ç¯®ä¸­çš„å•†å“å…³è”æ¨¡å¼ã€‚

```sql
-- è´­ç‰©ç¯®æ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«ç»å¸¸ä¸€èµ·è´­ä¹°çš„å•†å“
WITH basket_items AS (
    SELECT
        order_id,
        product_id,
        product_name
    FROM order_items
),
item_cooccurrence AS (
    SELECT
        bi1.product_id AS product_a,
        bi1.product_name AS product_a_name,
        bi2.product_id AS product_b,
        bi2.product_name AS product_b_name,
        COUNT(DISTINCT bi1.order_id) AS cooccurrence_count
    FROM basket_items bi1
    JOIN basket_items bi2 ON bi1.order_id = bi2.order_id
        AND bi1.product_id < bi2.product_id
    GROUP BY bi1.product_id, bi1.product_name, bi2.product_id, bi2.product_name
),
product_counts AS (
    SELECT
        product_id,
        COUNT(DISTINCT order_id) AS product_count
    FROM basket_items
    GROUP BY product_id
),
association_patterns AS (
    SELECT
        ic.product_a,
        ic.product_a_name,
        ic.product_b,
        ic.product_b_name,
        ic.cooccurrence_count,
        ic.cooccurrence_count * 100.0 / NULLIF(pc_a.product_count, 0) AS confidence_ab,
        ic.cooccurrence_count * 100.0 / NULLIF(pc_b.product_count, 0) AS confidence_ba,
        ic.cooccurrence_count * 100.0 / (SELECT COUNT(DISTINCT order_id) FROM basket_items) AS support
    FROM item_cooccurrence ic
    JOIN product_counts pc_a ON ic.product_a = pc_a.product_id
    JOIN product_counts pc_b ON ic.product_b = pc_b.product_id
)
SELECT
    product_a_name,
    product_b_name,
    cooccurrence_count,
    ROUND(confidence_ab::numeric, 2) AS confidence_ab_pct,
    ROUND(confidence_ba::numeric, 2) AS confidence_ba_pct,
    ROUND(support::numeric, 2) AS support_pct,
    -- æ¨èè§„åˆ™
    CASE
        WHEN confidence_ab > 50 THEN product_a_name || ' -> ' || product_b_name
        WHEN confidence_ba > 50 THEN product_b_name || ' -> ' || product_a_name
        ELSE NULL
    END AS recommendation_rule
FROM association_patterns
WHERE cooccurrence_count >= 20
ORDER BY cooccurrence_count DESC;
```

### 5.3 ç½‘ç«™å¯¼èˆªæ¨¡å¼è¯†åˆ«

**åœºæ™¯**ï¼šè¯†åˆ«ç”¨æˆ·åœ¨ç½‘ç«™ä¸Šçš„å¯¼èˆªæ¨¡å¼ã€‚

```sql
-- ç½‘ç«™å¯¼èˆªæ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«å¸¸è§çš„é¡µé¢è®¿é—®è·¯å¾„
WITH page_sequences AS (
    SELECT
        session_id,
        page_path,
        ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY visit_time) AS page_order,
        LAG(page_path) OVER (PARTITION BY session_id ORDER BY visit_time) AS prev_page,
        LEAD(page_path) OVER (PARTITION BY session_id ORDER BY visit_time) AS next_page
    FROM page_views
),
navigation_patterns AS (
    SELECT
        prev_page,
        page_path AS current_page,
        next_page,
        COUNT(*) AS pattern_count,
        COUNT(DISTINCT session_id) AS session_count
    FROM page_sequences
    WHERE prev_page IS NOT NULL AND next_page IS NOT NULL
    GROUP BY prev_page, page_path, next_page
),
pattern_stats AS (
    SELECT
        prev_page,
        current_page,
        next_page,
        pattern_count,
        session_count,
        pattern_count * 100.0 / SUM(pattern_count) OVER (PARTITION BY prev_page, current_page) AS transition_probability
    FROM navigation_patterns
)
SELECT
    prev_page || ' -> ' || current_page || ' -> ' || next_page AS navigation_path,
    pattern_count,
    session_count,
    ROUND(transition_probability::numeric, 2) AS transition_probability_pct,
    -- æ¨¡å¼ç±»å‹
    CASE
        WHEN pattern_count >= 100 THEN 'å¸¸è§è·¯å¾„'
        WHEN pattern_count >= 50 THEN 'ä¸­ç­‰è·¯å¾„'
        WHEN pattern_count >= 10 THEN 'å°‘è§è·¯å¾„'
        ELSE 'ç½•è§è·¯å¾„'
    END AS pattern_type
FROM pattern_stats
WHERE pattern_count >= 10
ORDER BY pattern_count DESC;
```

### 5.4 æ—¶é—´åºåˆ—æ¨¡å¼è¯†åˆ«

**åœºæ™¯**ï¼šè¯†åˆ«æ—¶é—´åºåˆ—ä¸­çš„é‡å¤æ¨¡å¼ã€‚

```sql
-- æ—¶é—´åºåˆ—æ¨¡å¼è¯†åˆ«ï¼šè¯†åˆ«é‡å¤çš„æ—¶é—´åºåˆ—æ¨¡å¼
WITH time_series_windows AS (
    SELECT
        timestamp,
        value,
        -- åˆ›å»ºæ»‘åŠ¨çª—å£
        AVG(value) OVER (
            ORDER BY timestamp
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS window_avg,
        STDDEV(value) OVER (
            ORDER BY timestamp
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS window_stddev
    FROM time_series
    WHERE value IS NOT NULL
),
pattern_features AS (
    SELECT
        DATE_TRUNC('day', timestamp) AS pattern_date,
        AVG(window_avg) AS daily_avg,
        AVG(window_stddev) AS daily_stddev,
        MIN(value) AS daily_min,
        MAX(value) AS daily_max,
        COUNT(*) AS daily_count
    FROM time_series_windows
    GROUP BY DATE_TRUNC('day', timestamp)
),
pattern_clusters AS (
    SELECT
        pattern_date,
        daily_avg,
        daily_stddev,
        daily_min,
        daily_max,
        -- æ¨¡å¼åˆ†ç±»
        CASE
            WHEN daily_avg > AVG(daily_avg) OVER () + STDDEV(daily_avg) OVER () THEN 'é«˜å³°æ¨¡å¼'
            WHEN daily_avg < AVG(daily_avg) OVER () - STDDEV(daily_avg) OVER () THEN 'ä½è°·æ¨¡å¼'
            WHEN daily_stddev > AVG(daily_stddev) OVER () + STDDEV(daily_stddev) OVER () THEN 'æ³¢åŠ¨æ¨¡å¼'
            ELSE 'æ­£å¸¸æ¨¡å¼'
        END AS pattern_type
    FROM pattern_features
)
SELECT
    pattern_date,
    ROUND(daily_avg::numeric, 2) AS daily_avg,
    ROUND(daily_stddev::numeric, 2) AS daily_stddev,
    ROUND(daily_min::numeric, 2) AS daily_min,
    ROUND(daily_max::numeric, 2) AS daily_max,
    pattern_type,
    COUNT(*) OVER (PARTITION BY pattern_type) AS pattern_type_count
FROM pattern_clusters
ORDER BY pattern_date;
```

---

## 6. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 6.1 æ¨¡å¼è¯†åˆ«æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|-----------|-----------|---------|------|------|
| **åºåˆ—æ¨¡å¼** | $O(n^2)$ | $O(n)$ | é¡ºåºæ•°æ® | æ•è·é¡ºåºå…³ç³» | è®¡ç®—å¤æ‚ |
| **é¢‘ç¹æ¨¡å¼** | $O(n)$ | $O(k)$ | é¡¹é›†æ•°æ® | ç®€å•å¿«é€Ÿ | å¿½ç•¥é¡ºåº |
| **å‘¨æœŸæ¨¡å¼** | $O(n \log n)$ | $O(n)$ | æ—¶é—´åºåˆ— | æ£€æµ‹å‘¨æœŸæ€§ | éœ€è¦æ’åº |
| **å…³è”æ¨¡å¼** | $O(2^n)$ | $O(2^n)$ | å…³è”æ•°æ® | å‘ç°å…³è” | ç»„åˆçˆ†ç‚¸ |

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è®¡ç®—ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨çª—å£å‡½æ•°å‡å°‘é‡å¤è®¡ç®—
   - é‡‡æ ·è®¡ç®—
   - å¹¶è¡Œå¤„ç†

2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - åˆ›å»ºç´¢å¼•åŠ é€Ÿè¿æ¥
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾
   - é™åˆ¶æ•°æ®èŒƒå›´

3. **ç®—æ³•ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨å‰ªæç­–ç•¥
   - å¢é‡è®¡ç®—
   - è¿‘ä¼¼æ–¹æ³•

### 6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šæ¨¡å¼æ•°é‡è¿‡å¤š

- **è§£å†³æ–¹æ¡ˆ**ï¼šæé«˜æœ€å°æ”¯æŒåº¦ã€ä½¿ç”¨æ¨¡å¼å‹ç¼©ã€é™åˆ¶æ¨¡å¼é•¿åº¦

**é—®é¢˜2**ï¼šè®¡ç®—æ€§èƒ½é—®é¢˜

- **è§£å†³æ–¹æ¡ˆ**ï¼šä¼˜åŒ–SQLæŸ¥è¯¢ã€ä½¿ç”¨ç´¢å¼•ã€é‡‡æ ·è®¡ç®—

**é—®é¢˜3**ï¼šæ¨¡å¼è´¨é‡ä¸é«˜

- **è§£å†³æ–¹æ¡ˆ**ï¼šè°ƒæ•´æ”¯æŒåº¦å’Œç½®ä¿¡åº¦ã€ä½¿ç”¨æ¨¡å¼è¯„ä¼°æŒ‡æ ‡ã€ç»“åˆä¸šåŠ¡è§„åˆ™

**é—®é¢˜4**ï¼šå‘¨æœŸæ€§æ£€æµ‹ä¸å‡†ç¡®

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å¤šç§æ–¹æ³•éªŒè¯ã€è€ƒè™‘å¤šä¸ªå‘¨æœŸã€å¤„ç†å™ªå£°

---

## 7. æœ€ä½³å®è·µ

### 7.1 æ¨¡å¼è¯†åˆ«æ–¹æ³•é€‰æ‹©

1. **æ•°æ®ç±»å‹**ï¼š
   - åºåˆ—æ•°æ®ï¼šä½¿ç”¨åºåˆ—æ¨¡å¼
   - é¡¹é›†æ•°æ®ï¼šä½¿ç”¨é¢‘ç¹æ¨¡å¼
   - æ—¶é—´åºåˆ—ï¼šä½¿ç”¨å‘¨æœŸæ¨¡å¼
   - å…³è”æ•°æ®ï¼šä½¿ç”¨å…³è”æ¨¡å¼

2. **ä¸šåŠ¡éœ€æ±‚**ï¼š
   - è¡Œä¸ºåˆ†æï¼šåºåˆ—æ¨¡å¼
   - æ¨èç³»ç»Ÿï¼šå…³è”æ¨¡å¼
   - è¶‹åŠ¿é¢„æµ‹ï¼šå‘¨æœŸæ¨¡å¼
   - å¼‚å¸¸æ£€æµ‹ï¼šé¢‘ç¹æ¨¡å¼

3. **è®¡ç®—èµ„æº**ï¼š
   - å®æ—¶åˆ†æï¼šä½¿ç”¨ç®€å•æ–¹æ³•
   - æ‰¹é‡åˆ†æï¼šå¯ä»¥ä½¿ç”¨å¤æ‚æ–¹æ³•

### 7.2 æ¨¡å¼è¯†åˆ«æ³¨æ„äº‹é¡¹

1. **æ•°æ®è´¨é‡**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼
   - å»é™¤å™ªå£°
   - éªŒè¯æ•°æ®ä¸€è‡´æ€§

2. **å‚æ•°é€‰æ‹©**ï¼š
   - æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©æ”¯æŒåº¦
   - ä½¿ç”¨éªŒè¯é›†è°ƒä¼˜
   - è€ƒè™‘è¯¯æŠ¥å’Œæ¼æŠ¥

3. **ç»“æœè§£é‡Š**ï¼š
   - ç»“åˆä¸šåŠ¡èƒŒæ™¯
   - åˆ†ææ¨¡å¼æ„ä¹‰
   - éªŒè¯æ¨¡å¼æœ‰æ•ˆæ€§

### 7.3 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼š
   - ä¼˜åŒ–è¿æ¥æŸ¥è¯¢
   - åˆ›å»ºé€‚å½“ç´¢å¼•
   - ä½¿ç”¨çª—å£å‡½æ•°

2. **å‡†ç¡®æ€§**ï¼š
   - å¤„ç†NULLå€¼
   - é¿å…é‡å¤è®¡ç®—
   - éªŒè¯è®¡ç®—ç»“æœ

3. **å¯ç»´æŠ¤æ€§**ï¼š
   - ä½¿ç”¨æ¸…æ™°çš„å˜é‡å
   - æ·»åŠ æ³¨é‡Š
   - æ¨¡å—åŒ–è®¾è®¡

### 7.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡æ¨¡å¼è¯†åˆ«çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«æ¨¡å¼å¾—åˆ†çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Næ¨¡å¼æŸ¥è¯¢å’Œé¢‘ç¹æ¨¡å¼æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡æ¨¡å¼è¯†åˆ«è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡åºåˆ—åŒ¹é…å’Œå‘¨æœŸæ¨¡å¼æ£€æµ‹

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - æ¨¡å¼è¯†åˆ«æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡åºåˆ—æ¨¡å¼è¯†åˆ«å’Œé¢‘ç¹æ¨¡å¼æŒ–æ˜

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–æ¨¡å¼è¯†åˆ«æŸ¥è¯¢**

```sql
-- ä¸ºæ¨¡å¼å¾—åˆ†åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_pattern_scores_skip_scan
ON pattern_results(pattern_type, support_count DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ”¯æŒåº¦æœ€é«˜çš„å‰10ä¸ªæ¨¡å¼
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (pattern_type)
    pattern_type,
    pattern_sequence,
    support_count,
    confidence_score
FROM pattern_results
WHERE support_count >= 100  -- æœ€å°æ”¯æŒåº¦é˜ˆå€¼
ORDER BY pattern_type, support_count DESC
LIMIT 50;
```

### 7.5 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜æ¨¡å¼è¯†åˆ«ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„æ¨¡å¼è¯†åˆ«ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜æ¨¡å¼è¯†åˆ«ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS pattern_recognition_cache AS
WITH frequent_patterns AS (
    SELECT
        pattern_sequence,
        pattern_type,
        COUNT(DISTINCT sequence_id) AS support_count,
        COUNT(*) AS occurrence_count,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ”¯æŒåº¦ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        COUNT(DISTINCT sequence_id)::numeric / NULLIF((SELECT COUNT(DISTINCT sequence_id) FROM user_sequences), 0) * 100 AS support_pct,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ç½®ä¿¡åº¦ï¼ˆç®€åŒ–ç‰ˆï¼Œé¿å…é‡å¤è®¡ç®—ï¼‰
        COUNT(*)::numeric / NULLIF(COUNT(*) OVER (PARTITION BY SUBSTRING(pattern_sequence, 1, POSITION(',' IN pattern_sequence) - 1)), 0) * 100 AS confidence_pct
    FROM pattern_occurrences
    WHERE pattern_sequence IS NOT NULL
    GROUP BY pattern_sequence, pattern_type
    HAVING COUNT(DISTINCT sequence_id) >= 50  -- æœ€å°æ”¯æŒåº¦é˜ˆå€¼
)
SELECT
    pattern_sequence,
    pattern_type,
    support_count,
    occurrence_count,
    ROUND(support_pct::numeric, 2) AS support_pct,
    ROUND(confidence_pct::numeric, 2) AS confidence_pct,
    CASE
        WHEN support_pct >= 50 THEN 'Very Frequent Pattern'
        WHEN support_pct >= 20 THEN 'Frequent Pattern'
        WHEN support_pct >= 10 THEN 'Moderate Pattern'
        ELSE 'Rare Pattern'
    END AS frequency_category
FROM frequent_patterns
ORDER BY support_count DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_pattern_recognition_cache_type_support ON pattern_recognition_cache(pattern_type, support_count DESC);
CREATE INDEX idx_pattern_recognition_cache_frequency ON pattern_recognition_cache(frequency_category, support_pct DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY pattern_recognition_cache;
```

**2. å®æ—¶æ¨¡å¼è¯†åˆ«ï¼šå¢é‡æ¨¡å¼æ›´æ–°**

**å®æ—¶æ¨¡å¼è¯†åˆ«**ï¼šå¯¹äºæµå¼æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°æ¨¡å¼è¯†åˆ«ç»“æœã€‚

```sql
-- å®æ—¶æ¨¡å¼è¯†åˆ«ï¼šå¢é‡æ¨¡å¼æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'pattern_state') THEN
            CREATE TABLE pattern_state (
                pattern_hash VARCHAR(200) PRIMARY KEY,
                pattern_sequence TEXT NOT NULL,
                pattern_type VARCHAR(50) NOT NULL,
                support_count BIGINT DEFAULT 0,
                occurrence_count BIGINT DEFAULT 0,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_pattern_state_type_support ON pattern_state(pattern_type, support_count DESC);
            CREATE INDEX idx_pattern_state_updated ON pattern_state(last_updated DESC);

            RAISE NOTICE 'æ¨¡å¼çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡æ¨¡å¼æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡æ¨¡å¼æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°æ¨¡å¼ç»Ÿè®¡ï¼šå®æ—¶æ¨¡å¼è¯†åˆ«
WITH new_sequences AS (
    SELECT
        sequence_id,
        action_sequence,
        created_at
    FROM user_sequences
    WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM pattern_state)
      AND action_sequence IS NOT NULL
),
pattern_occurrences AS (
    SELECT
        MD5(action_sequence) AS pattern_hash,
        action_sequence AS pattern_sequence,
        CASE
            WHEN array_length(string_to_array(action_sequence, ','), 1) = 2 THEN '2-Order Pattern'
            WHEN array_length(string_to_array(action_sequence, ','), 1) = 3 THEN '3-Order Pattern'
            WHEN array_length(string_to_array(action_sequence, ','), 1) >= 4 THEN 'High-Order Pattern'
            ELSE 'Single Pattern'
        END AS pattern_type,
        COUNT(DISTINCT sequence_id) AS new_support_count,
        COUNT(*) AS new_occurrence_count
    FROM new_sequences
    GROUP BY action_sequence
),
updated_patterns AS (
    SELECT
        COALESCE(ps.pattern_hash, po.pattern_hash) AS pattern_hash,
        COALESCE(ps.pattern_sequence, po.pattern_sequence) AS pattern_sequence,
        COALESCE(ps.pattern_type, po.pattern_type) AS pattern_type,
        COALESCE(ps.support_count, 0) + po.new_support_count AS new_support_count,
        COALESCE(ps.occurrence_count, 0) + po.new_occurrence_count AS new_occurrence_count
    FROM pattern_state ps
    FULL OUTER JOIN pattern_occurrences po ON ps.pattern_hash = po.pattern_hash
)
-- æ›´æ–°æˆ–æ’å…¥æ¨¡å¼çŠ¶æ€
INSERT INTO pattern_state (
    pattern_hash,
    pattern_sequence,
    pattern_type,
    support_count,
    occurrence_count,
    last_updated
)
SELECT
    pattern_hash,
    pattern_sequence,
    pattern_type,
    new_support_count,
    new_occurrence_count,
    NOW()
FROM updated_patterns
WHERE new_support_count >= 10  -- æœ€å°æ”¯æŒåº¦é˜ˆå€¼
ON CONFLICT (pattern_hash)
DO UPDATE SET
    support_count = EXCLUDED.support_count,
    occurrence_count = EXCLUDED.occurrence_count,
    last_updated = NOW();
```

**3. æ™ºèƒ½æ¨¡å¼è¯†åˆ«ï¼šè‡ªé€‚åº”æ¨¡å¼é€‰æ‹©**

**æ™ºèƒ½æ¨¡å¼è¯†åˆ«**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ¨¡å¼è¯†åˆ«ç­–ç•¥ã€‚

```sql
-- æ™ºèƒ½æ¨¡å¼è¯†åˆ«ï¼šè‡ªé€‚åº”æ¨¡å¼é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    total_sequences BIGINT;
    avg_sequence_length NUMERIC;
    pattern_strategy VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_sequences') THEN
            RAISE WARNING 'è¡¨ user_sequences ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½æ¨¡å¼è¯†åˆ«';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        SELECT COUNT(*) INTO total_sequences FROM user_sequences;
        SELECT AVG(array_length(string_to_array(action_sequence, ','), 1)) INTO avg_sequence_length
        FROM user_sequences WHERE action_sequence IS NOT NULL;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”è°ƒæ•´ç­–ç•¥
        IF total_sequences < 10000 AND avg_sequence_length < 5 THEN
            pattern_strategy := 'Full Pattern Mining';  -- å°æ•°æ®é›†ä½¿ç”¨å®Œæ•´æ¨¡å¼æŒ–æ˜
        ELSIF total_sequences < 100000 AND avg_sequence_length < 10 THEN
            pattern_strategy := 'Sampling Pattern Mining';  -- ä¸­ç­‰æ•°æ®é›†ä½¿ç”¨é‡‡æ ·æ¨¡å¼æŒ–æ˜
        ELSE
            pattern_strategy := 'Incremental Pattern Mining';  -- å¤§æ•°æ®é›†ä½¿ç”¨å¢é‡æ¨¡å¼æŒ–æ˜
        END IF;

        RAISE NOTICE 'æ€»åºåˆ—æ•°: %, å¹³å‡åºåˆ—é•¿åº¦: %, é€‰æ‹©ç­–ç•¥: %',
            total_sequences, avg_sequence_length, pattern_strategy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½æ¨¡å¼è¯†åˆ«å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ™ºèƒ½æ¨¡å¼è¯†åˆ«ï¼šæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„æ¨¡å¼æŒ–æ˜æ–¹å¼
WITH adaptive_pattern_mining AS (
    SELECT
        pattern_sequence,
        pattern_type,
        COUNT(DISTINCT sequence_id) AS support_count,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ¨¡å¼é‡è¦æ€§ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN (SELECT COUNT(*) FROM user_sequences) < 10000 THEN
                COUNT(DISTINCT sequence_id)::numeric / NULLIF((SELECT COUNT(*) FROM user_sequences), 0) * 100
            ELSE
                COUNT(DISTINCT sequence_id)::numeric / NULLIF((SELECT COUNT(*) FROM user_sequences) * 0.1, 0) * 100  -- é‡‡æ ·10%
        END AS importance_score
    FROM pattern_occurrences
    GROUP BY pattern_sequence, pattern_type
    HAVING COUNT(DISTINCT sequence_id) >=
        CASE
            WHEN (SELECT COUNT(*) FROM user_sequences) < 10000 THEN 10
            WHEN (SELECT COUNT(*) FROM user_sequences) < 100000 THEN 50
            ELSE 100
        END  -- è‡ªé€‚åº”æœ€å°æ”¯æŒåº¦é˜ˆå€¼
)
SELECT
    pattern_sequence,
    pattern_type,
    support_count,
    ROUND(importance_score::numeric, 2) AS importance_pct,
    CASE
        WHEN importance_score >= 30 THEN 'Highly Important Pattern'
        WHEN importance_score >= 15 THEN 'Important Pattern'
        WHEN importance_score >= 5 THEN 'Moderate Pattern'
        ELSE 'Minor Pattern'
    END AS importance_level
FROM adaptive_pattern_mining
ORDER BY importance_score DESC
LIMIT 50;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **ã€Šæ•°æ®æŒ–æ˜ï¼šæ¦‚å¿µä¸æŠ€æœ¯ã€‹**ï¼ˆHan, J., et al., 2011ï¼‰- æ¨¡å¼è¯†åˆ«æ–¹æ³•

2. **ã€Šåºåˆ—æ¨¡å¼æŒ–æ˜ã€‹**ï¼ˆAgrawal, R., & Srikant, R., 1995ï¼‰- åºåˆ—æ¨¡å¼æŒ–æ˜

3. **ã€Šå…³è”è§„åˆ™æŒ–æ˜ã€‹**ï¼ˆAgrawal, R., et al., 1993ï¼‰- å…³è”æ¨¡å¼æŒ–æ˜

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- **çª—å£å‡½æ•°**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **èšåˆå‡½æ•°**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **æ•°ç»„å‡½æ•°**: <https://www.postgresql.org/docs/current/functions-array.html>

### åœ¨çº¿èµ„æº

- **æ¨¡å¼è¯†åˆ«**: <https://en.wikipedia.org/wiki/Pattern_recognition>
- **åºåˆ—æ¨¡å¼æŒ–æ˜**: <https://en.wikipedia.org/wiki/Sequential_pattern_mining>
- **å…³è”è§„åˆ™**: <https://en.wikipedia.org/wiki/Association_rule_learning>

### ç›¸å…³ç®—æ³•

- **å…³è”è§„åˆ™æŒ–æ˜**ï¼šé¢‘ç¹æ¨¡å¼å’Œå…³è”è§„åˆ™
- **åºåˆ—æ¨¡å¼æŒ–æ˜**ï¼šåºåˆ—æ¨¡å¼è¯†åˆ«
- **å‘¨æœŸæ€§åˆ†æ**ï¼šå‘¨æœŸæ¨¡å¼æ£€æµ‹
- **èšç±»åˆ†æ**ï¼šåŸºäºèšç±»çš„æ¨¡å¼è¯†åˆ«

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
