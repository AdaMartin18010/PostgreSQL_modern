# PostgreSQL 模式识别完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 模式识别 | 序列分析
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 模式识别完整指南](#postgresql-模式识别完整指南)
  - [📋 目录](#-目录)
  - [模式识别概述](#模式识别概述)
    - [理论基础](#理论基础)
      - [模式定义](#模式定义)
      - [模式识别方法](#模式识别方法)
      - [支持度和置信度](#支持度和置信度)
    - [核心模式类型](#核心模式类型)
  - [1. 序列模式识别](#1-序列模式识别)
    - [1.1 序列模式识别原理](#11-序列模式识别原理)
      - [序列模式定义](#序列模式定义)
      - [序列模式匹配](#序列模式匹配)
    - [1.2 序列模式检测实现](#12-序列模式检测实现)
    - [1.3 多阶序列模式](#13-多阶序列模式)
    - [1.4 序列模式置信度计算](#14-序列模式置信度计算)
  - [2. 频繁模式识别](#2-频繁模式识别)
    - [2.1 频繁模式识别原理](#21-频繁模式识别原理)
      - [频繁项集定义](#频繁项集定义)
      - [Apriori原理](#apriori原理)
    - [2.2 频繁项集识别实现](#22-频繁项集识别实现)
    - [2.3 多维度频繁模式](#23-多维度频繁模式)
  - [3. 周期性模式识别](#3-周期性模式识别)
    - [3.1 周期性模式识别原理](#31-周期性模式识别原理)
      - [周期模式定义](#周期模式定义)
      - [周期检测方法](#周期检测方法)
    - [3.2 周期检测实现](#32-周期检测实现)
    - [3.3 多周期模式检测](#33-多周期模式检测)
    - [3.4 自相关周期检测](#34-自相关周期检测)
  - [4. 关联模式识别](#4-关联模式识别)
    - [4.1 关联模式识别原理](#41-关联模式识别原理)
      - [关联规则定义](#关联规则定义)
    - [4.2 关联模式识别实现](#42-关联模式识别实现)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 用户行为模式识别](#51-用户行为模式识别)
    - [5.2 购物篮模式识别](#52-购物篮模式识别)
    - [5.3 网站导航模式识别](#53-网站导航模式识别)
    - [5.4 时间序列模式识别](#54-时间序列模式识别)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 模式识别方法对比](#61-模式识别方法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 模式识别方法选择](#71-模式识别方法选择)
    - [7.2 模式识别注意事项](#72-模式识别注意事项)
    - [7.3 SQL实现注意事项](#73-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 模式识别概述

**模式识别（Pattern Recognition）**用于识别数据中的重复模式和规律，常用于行为分析、趋势预测和知识发现。模式识别是数据挖掘和机器学习的重要分支，能够从大量数据中提取有价值的信息。

### 理论基础

#### 模式定义

**模式（Pattern）**是指数据中重复出现的、有意义的结构或规律。模式可以分为：

1. **序列模式（Sequential Pattern）**：按时间顺序出现的模式
2. **频繁模式（Frequent Pattern）**：频繁出现的模式
3. **周期模式（Periodic Pattern）**：周期性重复的模式
4. **关联模式（Association Pattern）**：同时出现的模式

#### 模式识别方法

1. **统计方法**：
   - 频率分析
   - 相关性分析
   - 聚类分析

2. **序列方法**：
   - 序列匹配
   - 序列挖掘
   - 马尔可夫链

3. **频域方法**：
   - 傅里叶变换
   - 小波变换
   - 频谱分析

#### 支持度和置信度

**支持度（Support）**：模式出现的频率
$$Support(X) = \frac{|\{t \in T : X \subseteq t\}|}{|T|}$$

**置信度（Confidence）**：模式的条件概率
$$Confidence(X \rightarrow Y) = \frac{Support(X \cup Y)}{Support(X)}$$

### 核心模式类型

| 模式类型 | 用途 | 复杂度 | 数学表示 |
|---------|------|--------|---------|
| **序列模式** | 顺序模式 | $O(n^2)$ | $P = \{p_1, p_2, \ldots, p_k\}$ |
| **频繁模式** | 重复模式 | $O(n)$ | $Support(P) \geq \theta$ |
| **周期模式** | 周期性规律 | $O(n \log n)$ | $P(t) = P(t + kT)$ |
| **关联模式** | 关联规则 | $O(2^n)$ | $X \rightarrow Y$ |

---

## 1. 序列模式识别

### 1.1 序列模式识别原理

**序列模式识别（Sequential Pattern Recognition）**识别数据中按时间顺序出现的模式，用于分析行为序列、事件序列等。

#### 序列模式定义

**序列模式**是一个有序的事件序列：
$$S = \langle e_1, e_2, \ldots, e_n \rangle$$

其中$e_i$是事件，$n$是序列长度。

#### 序列模式匹配

**子序列匹配**：序列$S_1 = \langle a, b, c \rangle$是序列$S_2 = \langle a, x, b, y, c \rangle$的子序列。

**支持度计算**：序列模式$P$在序列数据库$D$中的支持度：
$$Support(P) = \frac{|\{S \in D : P \subseteq S\}|}{|D|}$$

### 1.2 序列模式检测实现

```sql
-- 序列模式识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_actions') THEN
            RAISE WARNING '表 user_actions 不存在，无法执行序列模式识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行序列模式识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '序列模式识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH action_sequences AS (
    SELECT
        user_id,
        action_type,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS prev_action,
        LEAD(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS next_action
    FROM user_actions
)
SELECT
    prev_action,
    action_type AS current_action,
    next_action,
    COUNT(*) AS pattern_count
FROM action_sequences
WHERE prev_action IS NOT NULL AND next_action IS NOT NULL
GROUP BY prev_action, action_type, next_action
HAVING COUNT(*) >= 10  -- 最小支持度
ORDER BY pattern_count DESC;
```

---

### 1.3 多阶序列模式

**多阶序列模式**识别不同长度的序列模式。

```sql
-- 多阶序列模式识别：2阶、3阶、4阶模式
WITH action_sequences AS (
    SELECT
        user_id,
        action_type,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY action_time) AS seq_num,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS prev_action,
        LAG(action_type, 2) OVER (PARTITION BY user_id ORDER BY action_time) AS prev2_action,
        LEAD(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS next_action
    FROM user_actions
),
patterns_2 AS (
    SELECT
        prev_action,
        action_type AS current_action,
        COUNT(*) AS pattern_count
    FROM action_sequences
    WHERE prev_action IS NOT NULL
    GROUP BY prev_action, action_type
    HAVING COUNT(*) >= 10
),
patterns_3 AS (
    SELECT
        prev2_action,
        prev_action,
        action_type AS current_action,
        COUNT(*) AS pattern_count
    FROM action_sequences
    WHERE prev2_action IS NOT NULL AND prev_action IS NOT NULL
    GROUP BY prev2_action, prev_action, action_type
    HAVING COUNT(*) >= 5
)
SELECT
    '2阶模式' AS pattern_type,
    prev_action || ' -> ' || current_action AS pattern,
    pattern_count
FROM patterns_2
UNION ALL
SELECT
    '3阶模式' AS pattern_type,
    prev2_action || ' -> ' || prev_action || ' -> ' || current_action AS pattern,
    pattern_count
FROM patterns_3
ORDER BY pattern_type, pattern_count DESC;
```

### 1.4 序列模式置信度计算

**置信度**计算序列模式的转换概率。

```sql
-- 序列模式置信度计算
WITH action_transitions AS (
    SELECT
        user_id,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS from_action,
        action_type AS to_action
    FROM user_actions
),
transition_stats AS (
    SELECT
        from_action,
        to_action,
        COUNT(*) AS transition_count
    FROM action_transitions
    WHERE from_action IS NOT NULL
    GROUP BY from_action, to_action
),
from_action_counts AS (
    SELECT
        from_action,
        SUM(transition_count) AS total_from_count
    FROM transition_stats
    GROUP BY from_action
)
SELECT
    ts.from_action,
    ts.to_action,
    ts.transition_count,
    ts.transition_count * 100.0 / NULLIF(fac.total_from_count, 0) AS confidence_pct,
    -- 支持度
    ts.transition_count * 100.0 / (SELECT COUNT(*) FROM action_transitions WHERE from_action IS NOT NULL) AS support_pct
FROM transition_stats ts
JOIN from_action_counts fac ON ts.from_action = fac.from_action
WHERE ts.transition_count >= 10
ORDER BY ts.from_action, confidence_pct DESC;
```

---

## 2. 频繁模式识别

### 2.1 频繁模式识别原理

**频繁模式识别（Frequent Pattern Recognition）**识别数据中频繁出现的模式，是关联规则挖掘的基础。

#### 频繁项集定义

**频繁项集（Frequent Itemset）**是指支持度大于等于最小支持度阈值的项集：
$$Support(I) \geq min\_support$$

其中$I$是项集，$min\_support$是最小支持度阈值。

#### Apriori原理

**Apriori原理**：如果一个项集是频繁的，那么它的所有子集也是频繁的；如果一个项集不是频繁的，那么它的所有超集也不是频繁的。

### 2.2 频繁项集识别实现

```sql
-- 频繁模式识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'events') THEN
            RAISE WARNING '表 events 不存在，无法执行频繁模式识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行频繁模式识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '频繁模式识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT
    event_type,
    COUNT(*) AS frequency,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS frequency_pct
FROM events
GROUP BY event_type
HAVING COUNT(*) >= 100  -- 最小支持度
ORDER BY frequency DESC;
```

---

### 2.3 多维度频繁模式

**多维度频繁模式**识别多个维度上的频繁模式。

```sql
-- 多维度频繁模式识别：事件类型、时间、地点
WITH multi_dim_patterns AS (
    SELECT
        event_type,
        DATE_TRUNC('hour', event_time) AS event_hour,
        location,
        COUNT(*) AS pattern_count
    FROM events
    GROUP BY event_type, DATE_TRUNC('hour', event_time), location
)
SELECT
    event_type,
    event_hour,
    location,
    pattern_count,
    pattern_count * 100.0 / SUM(pattern_count) OVER () AS support_pct,
    -- 频繁模式判断
    CASE
        WHEN pattern_count >= 100 THEN '高频模式'
        WHEN pattern_count >= 50 THEN '中频模式'
        WHEN pattern_count >= 10 THEN '低频模式'
        ELSE '罕见模式'
    END AS frequency_level
FROM multi_dim_patterns
WHERE pattern_count >= 10
ORDER BY pattern_count DESC;
```

---

## 3. 周期性模式识别

### 3.1 周期性模式识别原理

**周期性模式识别（Periodic Pattern Recognition）**识别数据中周期性重复的模式，用于分析时间序列的周期性规律。

#### 周期模式定义

**周期模式**是指满足以下条件的模式：
$$P(t) = P(t + kT), \quad k \in \mathbb{Z}$$

其中：

- $P(t)$：时间$t$的模式
- $T$：周期长度
- $k$：周期倍数

#### 周期检测方法

1. **自相关分析**：计算不同滞后的自相关系数
2. **频域分析**：使用傅里叶变换检测周期
3. **统计方法**：使用方差分析检测周期性

### 3.2 周期检测实现

```sql
-- 周期性模式识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行周期性模式识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行周期性模式识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '周期性模式识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH daily_patterns AS (
    SELECT
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day,
        AVG(value) AS avg_value
    FROM time_series
    GROUP BY EXTRACT(DOW FROM timestamp), EXTRACT(HOUR FROM timestamp)
)
SELECT
    day_of_week,
    hour_of_day,
    avg_value,
    CASE
        WHEN avg_value > (SELECT AVG(avg_value) FROM daily_patterns) + (SELECT STDDEV(avg_value) FROM daily_patterns) THEN '高峰'
        WHEN avg_value < (SELECT AVG(avg_value) FROM daily_patterns) - (SELECT STDDEV(avg_value) FROM daily_patterns) THEN '低谷'
        ELSE '正常'
    END AS pattern_type
FROM daily_patterns
ORDER BY day_of_week, hour_of_day;
```

---

### 3.3 多周期模式检测

**多周期模式**检测多个周期长度的模式。

```sql
-- 多周期模式检测：日周期、周周期、月周期
WITH periodic_patterns AS (
    SELECT
        timestamp,
        value,
        EXTRACT(DAY FROM timestamp) AS day_of_month,
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day,
        EXTRACT(MONTH FROM timestamp) AS month_of_year
    FROM time_series
),
daily_pattern AS (
    SELECT
        hour_of_day,
        AVG(value) AS avg_value,
        STDDEV(value) AS stddev_value
    FROM periodic_patterns
    GROUP BY hour_of_day
),
weekly_pattern AS (
    SELECT
        day_of_week,
        AVG(value) AS avg_value,
        STDDEV(value) AS stddev_value
    FROM periodic_patterns
    GROUP BY day_of_week
),
monthly_pattern AS (
    SELECT
        day_of_month,
        AVG(value) AS avg_value,
        STDDEV(value) AS stddev_value
    FROM periodic_patterns
    GROUP BY day_of_month
)
SELECT
    '日周期' AS pattern_type,
    hour_of_day AS pattern_value,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM daily_pattern
UNION ALL
SELECT
    '周周期' AS pattern_type,
    day_of_week AS pattern_value,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM weekly_pattern
UNION ALL
SELECT
    '月周期' AS pattern_type,
    day_of_month AS pattern_value,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM monthly_pattern
ORDER BY pattern_type, pattern_value;
```

### 3.4 自相关周期检测

**自相关分析**使用自相关函数检测周期。

```sql
-- 自相关周期检测：检测时间序列的周期长度
WITH time_series_indexed AS (
    SELECT
        timestamp,
        value,
        ROW_NUMBER() OVER (ORDER BY timestamp) AS t,
        AVG(value) OVER () AS mean_value
    FROM time_series
    WHERE value IS NOT NULL
),
autocorrelation AS (
    SELECT
        lag_k,
        -- 自相关：r_k = E[(y_t - mean)(y_{t+k} - mean)] / Var(y)
        AVG((t1.value - t1.mean_value) * (t2.value - t2.mean_value)) /
        NULLIF(VAR_POP(t1.value), 0) AS acf
    FROM time_series_indexed t1
    CROSS JOIN generate_series(1, 168) AS lag_k  -- 检查168小时（1周）
    JOIN time_series_indexed t2 ON t2.t = t1.t + lag_k
    WHERE t2.t IS NOT NULL
    GROUP BY lag_k
)
SELECT
    lag_k,
    ROUND(acf::numeric, 4) AS autocorrelation,
    -- 周期检测：ACF显著大于0的滞后
    CASE
        WHEN ABS(acf) > 0.3 THEN '强周期'
        WHEN ABS(acf) > 0.2 THEN '中等周期'
        WHEN ABS(acf) > 0.1 THEN '弱周期'
        ELSE '无周期'
    END AS periodicity
FROM autocorrelation
ORDER BY ABS(acf) DESC;
```

---

## 4. 关联模式识别

### 4.1 关联模式识别原理

**关联模式识别（Association Pattern Recognition）**识别数据中同时出现的模式，是关联规则挖掘的基础。

#### 关联规则定义

**关联规则**：$X \rightarrow Y$，表示如果$X$出现，则$Y$也可能出现。

**支持度**：
$$Support(X \rightarrow Y) = Support(X \cup Y)$$

**置信度**：
$$Confidence(X \rightarrow Y) = \frac{Support(X \cup Y)}{Support(X)}$$

### 4.2 关联模式识别实现

```sql
-- 关联模式识别：识别同时出现的事件
WITH event_cooccurrence AS (
    SELECT
        e1.event_type AS event_a,
        e2.event_type AS event_b,
        COUNT(DISTINCT e1.session_id) AS cooccurrence_count
    FROM events e1
    JOIN events e2 ON e1.session_id = e2.session_id
        AND e1.event_type < e2.event_type  -- 避免重复
    GROUP BY e1.event_type, e2.event_type
),
event_counts AS (
    SELECT
        event_type,
        COUNT(DISTINCT session_id) AS event_count
    FROM events
    GROUP BY event_type
),
association_rules AS (
    SELECT
        ec.event_a,
        ec.event_b,
        ec.cooccurrence_count,
        ec.cooccurrence_count * 100.0 / NULLIF(ea.event_count, 0) AS confidence_ab,
        ec.cooccurrence_count * 100.0 / NULLIF(eb.event_count, 0) AS confidence_ba,
        ec.cooccurrence_count * 100.0 / (SELECT COUNT(DISTINCT session_id) FROM events) AS support
    FROM event_cooccurrence ec
    JOIN event_counts ea ON ec.event_a = ea.event_type
    JOIN event_counts eb ON ec.event_b = eb.event_type
)
SELECT
    event_a,
    event_b,
    cooccurrence_count,
    ROUND(confidence_ab::numeric, 2) AS confidence_ab_pct,
    ROUND(confidence_ba::numeric, 2) AS confidence_ba_pct,
    ROUND(support::numeric, 2) AS support_pct,
    -- 关联强度
    CASE
        WHEN confidence_ab > 50 AND confidence_ba > 50 THEN '强关联'
        WHEN confidence_ab > 30 OR confidence_ba > 30 THEN '中等关联'
        ELSE '弱关联'
    END AS association_strength
FROM association_rules
WHERE cooccurrence_count >= 10
ORDER BY cooccurrence_count DESC;
```

---

## 5. PostgreSQL 18 并行模式识别增强

**PostgreSQL 18** 显著增强了并行模式识别能力，支持并行执行序列模式、频繁模式和周期模式识别，大幅提升大数据量模式识别查询的性能。

### 5.1 并行模式识别原理

PostgreSQL 18 的并行模式识别通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描表数据
2. **并行模式匹配**：每个工作进程独立执行模式匹配
3. **并行频率计算**：每个工作进程独立计算模式频率
4. **结果合并**：主进程合并所有工作进程的模式识别结果

### 5.2 并行序列模式识别

```sql
-- PostgreSQL 18 并行序列模式识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_actions') THEN
            RAISE WARNING '表 user_actions 不存在，无法执行并行序列模式识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行序列模式识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行序列模式识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行序列模式识别：识别用户行为序列模式
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH user_sequences AS (
    SELECT
        user_id,
        action_type,
        action_time,
        LAG(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS prev_action,
        LEAD(action_type) OVER (PARTITION BY user_id ORDER BY action_time) AS next_action
    FROM user_actions
    WHERE action_time >= CURRENT_DATE - INTERVAL '30 days'
),
sequence_patterns AS (
    SELECT
        prev_action,
        action_type,
        next_action,
        COUNT(*) AS pattern_count
    FROM user_sequences
    WHERE prev_action IS NOT NULL AND next_action IS NOT NULL
    GROUP BY prev_action, action_type, next_action
)
SELECT
    prev_action || ' -> ' || action_type || ' -> ' || next_action AS sequence_pattern,
    pattern_count,
    ROUND(100.0 * pattern_count / SUM(pattern_count) OVER (), 2) AS pattern_percentage
FROM sequence_patterns
ORDER BY pattern_count DESC
LIMIT 20;
```

### 5.3 并行频繁模式识别

```sql
-- PostgreSQL 18 并行频繁模式识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'transactions') THEN
            RAISE WARNING '表 transactions 不存在，无法执行并行频繁模式识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行频繁模式识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行频繁模式识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行频繁模式识别：识别频繁出现的项目组合
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH item_sets AS (
    SELECT
        transaction_id,
        ARRAY_AGG(item_id ORDER BY item_id) AS items
    FROM transactions
    GROUP BY transaction_id
),
frequent_patterns AS (
    SELECT
        items,
        COUNT(*) AS support_count,
        COUNT(*) * 100.0 / (SELECT COUNT(DISTINCT transaction_id) FROM transactions) AS support_percentage
    FROM item_sets
    GROUP BY items
    HAVING COUNT(*) >= 10  -- 最小支持度
)
SELECT
    items,
    support_count,
    ROUND(support_percentage::numeric, 2) AS support_percentage
FROM frequent_patterns
ORDER BY support_count DESC
LIMIT 20;
```

### 5.4 并行周期模式识别

```sql
-- PostgreSQL 18 并行周期模式识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行并行周期模式识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行周期模式识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行周期模式识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行周期模式识别：识别时间序列中的周期模式
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH periodic_patterns AS (
    SELECT
        timestamp,
        value,
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day
    FROM time_series
    WHERE timestamp >= CURRENT_DATE - INTERVAL '90 days'
),
daily_patterns AS (
    SELECT
        day_of_week,
        hour_of_day,
        AVG(value) AS avg_value,
        COUNT(*) AS pattern_count
    FROM periodic_patterns
    GROUP BY day_of_week, hour_of_day
)
SELECT
    day_of_week,
    hour_of_day,
    ROUND(avg_value::numeric, 2) AS avg_value,
    pattern_count,
    CASE
        WHEN avg_value > (SELECT AVG(avg_value) FROM daily_patterns) + (SELECT STDDEV(avg_value) FROM daily_patterns) THEN '高峰'
        WHEN avg_value < (SELECT AVG(avg_value) FROM daily_patterns) - (SELECT STDDEV(avg_value) FROM daily_patterns) THEN '低谷'
        ELSE '正常'
    END AS pattern_type
FROM daily_patterns
ORDER BY day_of_week, hour_of_day;
```

---

## 6. 实际应用案例

### 5.1 用户行为模式识别

**用户行为模式识别**识别用户行为模式。

```sql
-- 用户行为模式识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_sessions') THEN
            RAISE WARNING '表 user_sessions 不存在，无法执行用户行为模式识别';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行用户行为模式识别';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '用户行为模式识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH session_patterns AS (
    SELECT
        user_id,
        session_id,
        page_path,
        ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY visit_time) AS page_order
    FROM user_sessions
),
page_transitions AS (
    SELECT
        sp1.page_path AS from_page,
        sp2.page_path AS to_page,
        COUNT(*) AS transition_count
    FROM session_patterns sp1
    JOIN session_patterns sp2 ON sp1.session_id = sp2.session_id
        AND sp2.page_order = sp1.page_order + 1
    GROUP BY sp1.page_path, sp2.page_path
)
SELECT
    from_page,
    to_page,
    transition_count,
    transition_count * 100.0 / SUM(transition_count) OVER (PARTITION BY from_page) AS transition_probability
FROM page_transitions
WHERE transition_count >= 5  -- 最小支持度
ORDER BY from_page, transition_count DESC;
```

### 5.2 购物篮模式识别

**场景**：识别购物篮中的商品关联模式。

```sql
-- 购物篮模式识别：识别经常一起购买的商品
WITH basket_items AS (
    SELECT
        order_id,
        product_id,
        product_name
    FROM order_items
),
item_cooccurrence AS (
    SELECT
        bi1.product_id AS product_a,
        bi1.product_name AS product_a_name,
        bi2.product_id AS product_b,
        bi2.product_name AS product_b_name,
        COUNT(DISTINCT bi1.order_id) AS cooccurrence_count
    FROM basket_items bi1
    JOIN basket_items bi2 ON bi1.order_id = bi2.order_id
        AND bi1.product_id < bi2.product_id
    GROUP BY bi1.product_id, bi1.product_name, bi2.product_id, bi2.product_name
),
product_counts AS (
    SELECT
        product_id,
        COUNT(DISTINCT order_id) AS product_count
    FROM basket_items
    GROUP BY product_id
),
association_patterns AS (
    SELECT
        ic.product_a,
        ic.product_a_name,
        ic.product_b,
        ic.product_b_name,
        ic.cooccurrence_count,
        ic.cooccurrence_count * 100.0 / NULLIF(pc_a.product_count, 0) AS confidence_ab,
        ic.cooccurrence_count * 100.0 / NULLIF(pc_b.product_count, 0) AS confidence_ba,
        ic.cooccurrence_count * 100.0 / (SELECT COUNT(DISTINCT order_id) FROM basket_items) AS support
    FROM item_cooccurrence ic
    JOIN product_counts pc_a ON ic.product_a = pc_a.product_id
    JOIN product_counts pc_b ON ic.product_b = pc_b.product_id
)
SELECT
    product_a_name,
    product_b_name,
    cooccurrence_count,
    ROUND(confidence_ab::numeric, 2) AS confidence_ab_pct,
    ROUND(confidence_ba::numeric, 2) AS confidence_ba_pct,
    ROUND(support::numeric, 2) AS support_pct,
    -- 推荐规则
    CASE
        WHEN confidence_ab > 50 THEN product_a_name || ' -> ' || product_b_name
        WHEN confidence_ba > 50 THEN product_b_name || ' -> ' || product_a_name
        ELSE NULL
    END AS recommendation_rule
FROM association_patterns
WHERE cooccurrence_count >= 20
ORDER BY cooccurrence_count DESC;
```

### 5.3 网站导航模式识别

**场景**：识别用户在网站上的导航模式。

```sql
-- 网站导航模式识别：识别常见的页面访问路径
WITH page_sequences AS (
    SELECT
        session_id,
        page_path,
        ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY visit_time) AS page_order,
        LAG(page_path) OVER (PARTITION BY session_id ORDER BY visit_time) AS prev_page,
        LEAD(page_path) OVER (PARTITION BY session_id ORDER BY visit_time) AS next_page
    FROM page_views
),
navigation_patterns AS (
    SELECT
        prev_page,
        page_path AS current_page,
        next_page,
        COUNT(*) AS pattern_count,
        COUNT(DISTINCT session_id) AS session_count
    FROM page_sequences
    WHERE prev_page IS NOT NULL AND next_page IS NOT NULL
    GROUP BY prev_page, page_path, next_page
),
pattern_stats AS (
    SELECT
        prev_page,
        current_page,
        next_page,
        pattern_count,
        session_count,
        pattern_count * 100.0 / SUM(pattern_count) OVER (PARTITION BY prev_page, current_page) AS transition_probability
    FROM navigation_patterns
)
SELECT
    prev_page || ' -> ' || current_page || ' -> ' || next_page AS navigation_path,
    pattern_count,
    session_count,
    ROUND(transition_probability::numeric, 2) AS transition_probability_pct,
    -- 模式类型
    CASE
        WHEN pattern_count >= 100 THEN '常见路径'
        WHEN pattern_count >= 50 THEN '中等路径'
        WHEN pattern_count >= 10 THEN '少见路径'
        ELSE '罕见路径'
    END AS pattern_type
FROM pattern_stats
WHERE pattern_count >= 10
ORDER BY pattern_count DESC;
```

### 5.4 时间序列模式识别

**场景**：识别时间序列中的重复模式。

```sql
-- 时间序列模式识别：识别重复的时间序列模式
WITH time_series_windows AS (
    SELECT
        timestamp,
        value,
        -- 创建滑动窗口
        AVG(value) OVER (
            ORDER BY timestamp
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS window_avg,
        STDDEV(value) OVER (
            ORDER BY timestamp
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS window_stddev
    FROM time_series
    WHERE value IS NOT NULL
),
pattern_features AS (
    SELECT
        DATE_TRUNC('day', timestamp) AS pattern_date,
        AVG(window_avg) AS daily_avg,
        AVG(window_stddev) AS daily_stddev,
        MIN(value) AS daily_min,
        MAX(value) AS daily_max,
        COUNT(*) AS daily_count
    FROM time_series_windows
    GROUP BY DATE_TRUNC('day', timestamp)
),
pattern_clusters AS (
    SELECT
        pattern_date,
        daily_avg,
        daily_stddev,
        daily_min,
        daily_max,
        -- 模式分类
        CASE
            WHEN daily_avg > AVG(daily_avg) OVER () + STDDEV(daily_avg) OVER () THEN '高峰模式'
            WHEN daily_avg < AVG(daily_avg) OVER () - STDDEV(daily_avg) OVER () THEN '低谷模式'
            WHEN daily_stddev > AVG(daily_stddev) OVER () + STDDEV(daily_stddev) OVER () THEN '波动模式'
            ELSE '正常模式'
        END AS pattern_type
    FROM pattern_features
)
SELECT
    pattern_date,
    ROUND(daily_avg::numeric, 2) AS daily_avg,
    ROUND(daily_stddev::numeric, 2) AS daily_stddev,
    ROUND(daily_min::numeric, 2) AS daily_min,
    ROUND(daily_max::numeric, 2) AS daily_max,
    pattern_type,
    COUNT(*) OVER (PARTITION BY pattern_type) AS pattern_type_count
FROM pattern_clusters
ORDER BY pattern_date;
```

---

## 6. 算法性能对比与优化

### 6.1 模式识别方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|-----------|-----------|---------|------|------|
| **序列模式** | $O(n^2)$ | $O(n)$ | 顺序数据 | 捕获顺序关系 | 计算复杂 |
| **频繁模式** | $O(n)$ | $O(k)$ | 项集数据 | 简单快速 | 忽略顺序 |
| **周期模式** | $O(n \log n)$ | $O(n)$ | 时间序列 | 检测周期性 | 需要排序 |
| **关联模式** | $O(2^n)$ | $O(2^n)$ | 关联数据 | 发现关联 | 组合爆炸 |

### 6.2 性能优化建议

1. **计算优化**：
   - 使用窗口函数减少重复计算
   - 采样计算
   - 并行处理

2. **查询优化**：
   - 创建索引加速连接
   - 使用物化视图
   - 限制数据范围

3. **算法优化**：
   - 使用剪枝策略
   - 增量计算
   - 近似方法

### 6.3 常见问题与解决方案

**问题1**：模式数量过多

- **解决方案**：提高最小支持度、使用模式压缩、限制模式长度

**问题2**：计算性能问题

- **解决方案**：优化SQL查询、使用索引、采样计算

**问题3**：模式质量不高

- **解决方案**：调整支持度和置信度、使用模式评估指标、结合业务规则

**问题4**：周期性检测不准确

- **解决方案**：使用多种方法验证、考虑多个周期、处理噪声

---

## 7. 最佳实践

### 7.1 模式识别方法选择

1. **数据类型**：
   - 序列数据：使用序列模式
   - 项集数据：使用频繁模式
   - 时间序列：使用周期模式
   - 关联数据：使用关联模式

2. **业务需求**：
   - 行为分析：序列模式
   - 推荐系统：关联模式
   - 趋势预测：周期模式
   - 异常检测：频繁模式

3. **计算资源**：
   - 实时分析：使用简单方法
   - 批量分析：可以使用复杂方法

### 7.2 模式识别注意事项

1. **数据质量**：
   - 处理缺失值
   - 去除噪声
   - 验证数据一致性

2. **参数选择**：
   - 根据业务需求选择支持度
   - 使用验证集调优
   - 考虑误报和漏报

3. **结果解释**：
   - 结合业务背景
   - 分析模式意义
   - 验证模式有效性

### 7.3 SQL实现注意事项

1. **性能考虑**：
   - 优化连接查询
   - 创建适当索引
   - 使用窗口函数

2. **准确性**：
   - 处理NULL值
   - 避免重复计算
   - 验证计算结果

3. **可维护性**：
   - 使用清晰的变量名
   - 添加注释
   - 模块化设计

---

## 📚 参考资源

### 学术文献

1. **《数据挖掘：概念与技术》**（Han, J., et al., 2011）- 模式识别方法

2. **《序列模式挖掘》**（Agrawal, R., & Srikant, R., 1995）- 序列模式挖掘

3. **《关联规则挖掘》**（Agrawal, R., et al., 1993）- 关联模式挖掘

### PostgreSQL官方文档

- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **数组函数**: <https://www.postgresql.org/docs/current/functions-array.html>

### 在线资源

- **模式识别**: <https://en.wikipedia.org/wiki/Pattern_recognition>
- **序列模式挖掘**: <https://en.wikipedia.org/wiki/Sequential_pattern_mining>
- **关联规则**: <https://en.wikipedia.org/wiki/Association_rule_learning>

### 相关算法

- **关联规则挖掘**：频繁模式和关联规则
- **序列模式挖掘**：序列模式识别
- **周期性分析**：周期模式检测
- **聚类分析**：基于聚类的模式识别

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
