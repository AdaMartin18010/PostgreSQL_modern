# PostgreSQL 统计分布分析完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 统计分布 | 概率分析
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 统计分布分析完整指南](#postgresql-统计分布分析完整指南)
  - [📋 目录](#-目录)
  - [统计分布分析概述](#统计分布分析概述)
    - [理论基础](#理论基础)
      - [概率分布定义](#概率分布定义)
      - [分布特征](#分布特征)
      - [分布类型分类](#分布类型分类)
    - [核心分布类型](#核心分布类型)
  - [1. 正态分布分析](#1-正态分布分析)
    - [1.1 正态分布原理](#11-正态分布原理)
      - [正态分布定义](#正态分布定义)
      - [正态分布特性](#正态分布特性)
      - [正态性检验方法](#正态性检验方法)
    - [1.2 正态性检验实现](#12-正态性检验实现)
    - [1.3 正态分布分位数分析](#13-正态分布分位数分析)
  - [2. 泊松分布分析](#2-泊松分布分析)
    - [2.1 泊松分布原理](#21-泊松分布原理)
      - [泊松分布定义](#泊松分布定义)
      - [泊松分布特性](#泊松分布特性)
    - [2.2 泊松分布拟合实现](#22-泊松分布拟合实现)
    - [2.3 泊松分布理论概率计算](#23-泊松分布理论概率计算)
  - [3. 二项分布分析](#3-二项分布分析)
    - [3.1 二项分布原理](#31-二项分布原理)
      - [二项分布定义](#二项分布定义)
      - [二项分布特性](#二项分布特性)
    - [3.2 二项分布拟合实现](#32-二项分布拟合实现)
    - [3.3 二项分布理论概率计算](#33-二项分布理论概率计算)
  - [4. 其他分布分析](#4-其他分布分析)
    - [4.1 指数分布分析](#41-指数分布分析)
      - [指数分布定义](#指数分布定义)
    - [4.2 均匀分布分析](#42-均匀分布分析)
      - [均匀分布定义](#均匀分布定义)
  - [5. 分布拟合检验](#5-分布拟合检验)
    - [5.1 分布拟合检验原理](#51-分布拟合检验原理)
      - [卡方拟合优度检验](#卡方拟合优度检验)
    - [5.2 卡方检验实现](#52-卡方检验实现)
    - [5.3 Kolmogorov-Smirnov检验](#53-kolmogorov-smirnov检验)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 数据质量分布分析](#61-数据质量分布分析)
    - [6.2 用户行为分布分析](#62-用户行为分布分析)
    - [6.3 产品质量分布分析](#63-产品质量分布分析)
    - [6.4 销售金额分布分析](#64-销售金额分布分析)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 分布分析方法对比](#71-分布分析方法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 分布选择](#81-分布选择)
    - [8.2 参数估计](#82-参数估计)
    - [8.3 SQL实现注意事项](#83-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 统计分布分析概述

**统计分布分析（Statistical Distribution Analysis）**用于分析数据的概率分布特征，帮助理解数据规律、进行假设检验和预测分析。统计分布是概率论和统计学的基础，对于数据分析和建模至关重要。

### 理论基础

#### 概率分布定义

**概率分布**描述随机变量取值的概率规律。对于离散随机变量，概率分布函数为：
$$P(X = x_i) = p_i$$

对于连续随机变量，概率密度函数（PDF）为：
$$f(x) = \frac{dF(x)}{dx}$$

其中$F(x)$是累积分布函数（CDF）。

#### 分布特征

**分布特征量**：

1. **均值（Mean）**：$\mu = E[X] = \int x f(x) dx$
2. **方差（Variance）**：$\sigma^2 = E[(X-\mu)^2] = E[X^2] - \mu^2$
3. **标准差（Standard Deviation）**：$\sigma = \sqrt{\sigma^2}$
4. **偏度（Skewness）**：$S = E[(\frac{X-\mu}{\sigma})^3]$
5. **峰度（Kurtosis）**：$K = E[(\frac{X-\mu}{\sigma})^4] - 3$

#### 分布类型分类

1. **离散分布**：
   - 二项分布（Binomial）
   - 泊松分布（Poisson）
   - 几何分布（Geometric）
   - 负二项分布（Negative Binomial）

2. **连续分布**：
   - 正态分布（Normal）
   - 指数分布（Exponential）
   - 均匀分布（Uniform）
   - 卡方分布（Chi-square）
   - t分布（t-distribution）
   - F分布（F-distribution）

### 核心分布类型

| 分布类型 | 概率密度函数 | 参数 | 均值 | 方差 | 用途 |
|---------|------------|------|------|------|------|
| **正态分布** | $f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$ | $\mu, \sigma$ | $\mu$ | $\sigma^2$ | 连续数据 |
| **泊松分布** | $P(X=k) = \frac{\lambda^k e^{-\lambda}}{k!}$ | $\lambda$ | $\lambda$ | $\lambda$ | 计数数据 |
| **二项分布** | $P(X=k) = \binom{n}{k} p^k (1-p)^{n-k}$ | $n, p$ | $np$ | $np(1-p)$ | 二分类数据 |
| **指数分布** | $f(x) = \lambda e^{-\lambda x}$ | $\lambda$ | $\frac{1}{\lambda}$ | $\frac{1}{\lambda^2}$ | 等待时间 |
| **均匀分布** | $f(x) = \frac{1}{b-a}$ | $a, b$ | $\frac{a+b}{2}$ | $\frac{(b-a)^2}{12}$ | 等概率事件 |

---

## 1. 正态分布分析

### 1.1 正态分布原理

**正态分布（Normal Distribution）**是最重要的连续概率分布，也称为高斯分布（Gaussian Distribution）。

#### 正态分布定义

**正态分布概率密度函数**：
$$f(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$

其中：

- $\mu$：均值（位置参数）
- $\sigma$：标准差（形状参数）

#### 正态分布特性

1. **对称性**：关于均值$\mu$对称
2. **68-95-99.7规则**：
   - 68%的数据在$\mu \pm \sigma$范围内
   - 95%的数据在$\mu \pm 2\sigma$范围内
   - 99.7%的数据在$\mu \pm 3\sigma$范围内
3. **中心极限定理**：大量独立随机变量的和近似正态分布

#### 正态性检验方法

1. **描述性统计**：偏度、峰度
2. **图形检验**：Q-Q图、直方图
3. **统计检验**：Shapiro-Wilk检验、Kolmogorov-Smirnov检验

### 1.2 正态性检验实现

```sql
-- 正态性检验（带错误处理和性能测试）
DO $$
DECLARE
    mean_val NUMERIC;
    stddev_val NUMERIC;
    skewness_val NUMERIC;
    kurtosis_val NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'measurements') THEN
            RAISE WARNING '表 measurements 不存在，无法执行正态性检验';
            RETURN;
        END IF;

        -- 计算均值和标准差
        SELECT AVG(value), STDDEV(value) INTO mean_val, stddev_val
        FROM measurements
        WHERE value IS NOT NULL;

        -- 计算偏度（简化版）
        SELECT AVG(POWER((value - mean_val) / NULLIF(stddev_val, 0), 3)) INTO skewness_val
        FROM measurements
        WHERE value IS NOT NULL;

        -- 计算峰度（简化版）
        SELECT AVG(POWER((value - mean_val) / NULLIF(stddev_val, 0), 4)) - 3 INTO kurtosis_val
        FROM measurements
        WHERE value IS NOT NULL;

        RAISE NOTICE '正态性检验结果:';
        RAISE NOTICE '  均值: %', mean_val;
        RAISE NOTICE '  标准差: %', stddev_val;
        RAISE NOTICE '  偏度: % (接近0表示对称)', skewness_val;
        RAISE NOTICE '  峰度: % (接近0表示正态)', kurtosis_val;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '正态性检验失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查看数据分布
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    CASE
        WHEN value < AVG(value) OVER () - 2 * STDDEV(value) OVER () THEN '低于-2σ'
        WHEN value < AVG(value) OVER () - STDDEV(value) OVER () THEN '-2σ到-1σ'
        WHEN value < AVG(value) OVER () THEN '-1σ到均值'
        WHEN value < AVG(value) OVER () + STDDEV(value) OVER () THEN '均值到+1σ'
        WHEN value < AVG(value) OVER () + 2 * STDDEV(value) OVER () THEN '+1σ到+2σ'
        ELSE '高于+2σ'
    END AS distribution_range,
    COUNT(*) AS count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS percentage
FROM measurements
WHERE value IS NOT NULL
GROUP BY distribution_range
ORDER BY MIN(value);
```

---

### 1.3 正态分布分位数分析

**分位数分析**分析数据在正态分布中的位置。

```sql
-- 正态分布分位数分析（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH stats AS (
    SELECT
        AVG(value) AS mean,
        STDDEV(value) AS stddev
    FROM measurements
    WHERE value IS NOT NULL
),
percentiles AS (
    SELECT
        value,
        PERCENT_RANK() OVER (ORDER BY value) AS percentile_rank
    FROM measurements
    WHERE value IS NOT NULL
)
SELECT
    p.value,
    ROUND(p.percentile_rank * 100, 2) AS percentile,
    -- Z-score
    ROUND((p.value - s.mean) / NULLIF(s.stddev, 0), 4) AS z_score,
    -- 理论正态分布分位数（使用逆误差函数近似）
    CASE
        WHEN p.percentile_rank < 0.5 THEN
            s.mean + s.stddev * SQRT(2) * ERF_INV(2 * p.percentile_rank - 1)
        ELSE
            s.mean + s.stddev * SQRT(2) * ERF_INV(2 * p.percentile_rank - 1)
    END AS theoretical_quantile
FROM percentiles p
CROSS JOIN stats s
ORDER BY p.value;
```

---

## 2. 泊松分布分析

### 2.1 泊松分布原理

**泊松分布（Poisson Distribution）**是离散概率分布，用于描述单位时间内随机事件发生的次数。

#### 泊松分布定义

**泊松分布概率质量函数**：
$$P(X=k) = \frac{\lambda^k e^{-\lambda}}{k!}$$

其中：

- $\lambda$：平均发生率（参数）
- $k$：事件发生次数

#### 泊松分布特性

1. **均值等于方差**：$E[X] = Var(X) = \lambda$
2. **无记忆性**：事件发生相互独立
3. **适用条件**：
   - 事件在固定时间/空间内发生
   - 事件发生概率小
   - 事件发生相互独立

### 2.2 泊松分布拟合实现

```sql
-- 泊松分布拟合（带错误处理和性能测试）
DO $$
DECLARE
    lambda_val NUMERIC;
    total_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'events') THEN
            RAISE WARNING '表 events 不存在，无法执行泊松分布拟合';
            RETURN;
        END IF;

        -- 计算泊松参数λ（均值）
        SELECT AVG(event_count), COUNT(*) INTO lambda_val, total_count
        FROM events
        WHERE event_count IS NOT NULL;

        RAISE NOTICE '泊松分布拟合结果:';
        RAISE NOTICE '  参数λ (均值): %', lambda_val;
        RAISE NOTICE '  总记录数: %', total_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '泊松分布拟合失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查看事件计数分布
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    event_count,
    COUNT(*) AS observed_count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS observed_percentage
FROM events
WHERE event_count IS NOT NULL
GROUP BY event_count
ORDER BY event_count;
```

---

### 2.3 泊松分布理论概率计算

**理论概率计算**计算泊松分布的理论概率。

```sql
-- 泊松分布理论概率计算（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH poisson_params AS (
    SELECT AVG(event_count) AS lambda FROM events WHERE event_count IS NOT NULL
),
factorial AS (
    -- 计算阶乘（简化版，使用递归CTE）
    SELECT
        n,
        CASE
            WHEN n = 0 THEN 1
            WHEN n = 1 THEN 1
            ELSE NULL  -- 需要更复杂的阶乘计算
        END AS fact
    FROM generate_series(0, 20) AS n
),
poisson_prob AS (
    SELECT
        k,
        -- 泊松概率：P(X=k) = λ^k * e^(-λ) / k!
        POWER(pp.lambda, k) * EXP(-pp.lambda) / NULLIF(f.fact, 0) AS theoretical_prob
    FROM generate_series(0, 20) AS k
    CROSS JOIN poisson_params pp
    LEFT JOIN factorial f ON k = f.n
)
SELECT
    k,
    ROUND(theoretical_prob::numeric, 6) AS theoretical_probability
FROM poisson_prob
WHERE theoretical_prob IS NOT NULL
ORDER BY k;
```

---

## 3. 二项分布分析

### 3.1 二项分布原理

**二项分布（Binomial Distribution）**是离散概率分布，描述$n$次独立试验中成功次数的概率分布。

#### 二项分布定义

**二项分布概率质量函数**：
$$P(X=k) = \binom{n}{k} p^k (1-p)^{n-k}$$

其中：

- $n$：试验次数
- $p$：每次试验成功概率
- $k$：成功次数
- $\binom{n}{k} = \frac{n!}{k!(n-k)!}$：组合数

#### 二项分布特性

1. **均值**：$E[X] = np$
2. **方差**：$Var(X) = np(1-p)$
3. **适用条件**：
   - 固定试验次数$n$
   - 每次试验成功概率$p$固定
   - 试验相互独立

### 3.2 二项分布拟合实现

```sql
-- 二项分布拟合（带错误处理和性能测试）
DO $$
DECLARE
    n_val INTEGER;
    p_val NUMERIC;
    success_count BIGINT;
    total_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'trials') THEN
            RAISE WARNING '表 trials 不存在，无法执行二项分布拟合';
            RETURN;
        END IF;

        -- 计算二项分布参数
        SELECT COUNT(*) FILTER (WHERE success = true), COUNT(*) INTO success_count, total_count
        FROM trials;

        n_val := 1;  -- 每次试验次数
        p_val := success_count::NUMERIC / NULLIF(total_count, 0);

        RAISE NOTICE '二项分布拟合结果:';
        RAISE NOTICE '  试验次数n: %', n_val;
        RAISE NOTICE '  成功概率p: %', p_val;
        RAISE NOTICE '  成功次数: %', success_count;
        RAISE NOTICE '  总次数: %', total_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '二项分布拟合失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 查看成功/失败分布
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    success,
    COUNT(*) AS count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS percentage
FROM trials
GROUP BY success;
```

---

### 3.3 二项分布理论概率计算

**理论概率计算**计算二项分布的理论概率。

```sql
-- 二项分布理论概率计算（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH binomial_params AS (
    SELECT
        COUNT(*) AS n,
        COUNT(*) FILTER (WHERE success = true)::numeric / COUNT(*) AS p
    FROM trials
),
binomial_prob AS (
    SELECT
        k,
        -- 二项概率：P(X=k) = C(n,k) * p^k * (1-p)^(n-k)
        -- 简化版：使用近似计算
        POWER(bp.p, k) * POWER(1 - bp.p, bp.n - k) AS theoretical_prob
    FROM generate_series(0, (SELECT n FROM binomial_params)) AS k
    CROSS JOIN binomial_params bp
    WHERE k <= bp.n
)
SELECT
    k,
    ROUND(theoretical_prob::numeric, 6) AS theoretical_probability
FROM binomial_prob
ORDER BY k;
```

---

## 4. 其他分布分析

### 4.1 指数分布分析

**指数分布（Exponential Distribution）**用于描述等待时间或寿命。

#### 指数分布定义

**指数分布概率密度函数**：
$$f(x) = \lambda e^{-\lambda x}, \quad x \geq 0$$

其中$\lambda$是速率参数。

```sql
-- 指数分布拟合（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH exp_params AS (
    SELECT
        1.0 / AVG(waiting_time) AS lambda
    FROM waiting_times
    WHERE waiting_time > 0
)
SELECT
    lambda,
    -- 理论均值
    1.0 / lambda AS theoretical_mean,
    -- 理论方差
    1.0 / POWER(lambda, 2) AS theoretical_variance
FROM exp_params;
```

### 4.2 均匀分布分析

**均匀分布（Uniform Distribution）**描述等概率事件。

#### 均匀分布定义

**均匀分布概率密度函数**：
$$f(x) = \frac{1}{b-a}, \quad a \leq x \leq b$$

```sql
-- 均匀分布拟合
WITH uniform_params AS (
    SELECT
        MIN(value) AS a,
        MAX(value) AS b
    FROM uniform_data
    WHERE value IS NOT NULL
)
SELECT
    a,
    b,
    -- 理论均值
    (a + b) / 2.0 AS theoretical_mean,
    -- 理论方差
    POWER(b - a, 2) / 12.0 AS theoretical_variance
FROM uniform_params;
```

---

## 5. 分布拟合检验

### 5.1 分布拟合检验原理

**分布拟合检验**检验观测数据是否符合某个理论分布。

#### 卡方拟合优度检验

**卡方统计量**：
$$\chi^2 = \sum_{i=1}^{k} \frac{(O_i - E_i)^2}{E_i}$$

其中：

- $O_i$：观测频数
- $E_i$：理论频数
- $k$：类别数

### 5.2 卡方检验实现

```sql
-- 卡方检验（带错误处理和性能测试）
DO $$
DECLARE
    chi_square NUMERIC := 0;
    expected_count NUMERIC;
    observed_count NUMERIC;
    total_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data') THEN
            RAISE WARNING '表 data 不存在，无法执行卡方检验';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO total_count FROM data WHERE value IS NOT NULL;

        -- 计算卡方统计量（简化版）
        FOR observed_count, expected_count IN
            SELECT
                COUNT(*) AS obs,
                total_count::NUMERIC / COUNT(DISTINCT value) AS exp
            FROM data
            WHERE value IS NOT NULL
            GROUP BY value
        LOOP
            chi_square := chi_square + POWER(observed_count - expected_count, 2) / NULLIF(expected_count, 0);
        END LOOP;

        RAISE NOTICE '卡方检验结果:';
        RAISE NOTICE '  卡方统计量: %', chi_square;
        RAISE NOTICE '  总记录数: %', total_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '卡方检验失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

### 5.3 Kolmogorov-Smirnov检验

**K-S检验**检验样本是否来自某个理论分布。

```sql
-- K-S检验（简化版）
WITH empirical_cdf AS (
    SELECT
        value,
        ROW_NUMBER() OVER (ORDER BY value) AS rn,
        COUNT(*) OVER () AS n
    FROM measurements
    WHERE value IS NOT NULL
),
stats AS (
    SELECT AVG(value) AS mean, STDDEV(value) AS stddev
    FROM measurements
    WHERE value IS NOT NULL
),
ks_stat AS (
    SELECT
        ec.value,
        ec.rn::numeric / ec.n AS empirical_cdf,
        -- 理论正态分布CDF（使用误差函数）
        0.5 * (1 + ERF((ec.value - s.mean) / (s.stddev * SQRT(2)))) AS theoretical_cdf,
        ABS(ec.rn::numeric / ec.n - 0.5 * (1 + ERF((ec.value - s.mean) / (s.stddev * SQRT(2))))) AS ks_diff
    FROM empirical_cdf ec
    CROSS JOIN stats s
)
SELECT
    MAX(ks_diff) AS ks_statistic,
    -- K-S检验临界值（简化版，需要查表）
    CASE
        WHEN COUNT(*) > 50 THEN 1.36 / SQRT(COUNT(*)::numeric)
        ELSE NULL
    END AS critical_value_0_05
FROM ks_stat;
```

---

## 6. 实际应用案例

### 6.1 数据质量分布分析

**数据质量分布分析**分析数据质量指标的分布。

```sql
-- 数据质量分布分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'quality_metrics') THEN
            RAISE WARNING '表 quality_metrics 不存在，无法执行数据质量分布分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行数据质量分布分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '数据质量分布分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stats AS (
    SELECT
        AVG(metric_value) AS mean,
        STDDEV(metric_value) AS stddev
    FROM quality_metrics
    WHERE metric_value IS NOT NULL
)
SELECT
    CASE
        WHEN metric_value < s.mean - 3 * s.stddev THEN '异常低值 (<-3σ)'
        WHEN metric_value < s.mean - 2 * s.stddev THEN '偏低 (-3σ到-2σ)'
        WHEN metric_value < s.mean - s.stddev THEN '正常偏低 (-2σ到-1σ)'
        WHEN metric_value < s.mean + s.stddev THEN '正常 (-1σ到+1σ)'
        WHEN metric_value < s.mean + 2 * s.stddev THEN '正常偏高 (+1σ到+2σ)'
        WHEN metric_value < s.mean + 3 * s.stddev THEN '偏高 (+2σ到+3σ)'
        ELSE '异常高值 (>+3σ)'
    END AS distribution_category,
    COUNT(*) AS count,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS percentage
FROM quality_metrics
CROSS JOIN stats s
WHERE metric_value IS NOT NULL
GROUP BY distribution_category
ORDER BY MIN(metric_value);
```

### 6.2 用户行为分布分析

**场景**：分析用户行为的分布特征。

```sql
-- 用户行为分布分析：页面访问次数分布
WITH user_visits AS (
    SELECT
        user_id,
        COUNT(*) AS visit_count
    FROM page_views
    GROUP BY user_id
),
visit_distribution AS (
    SELECT
        visit_count,
        COUNT(*) AS user_count,
        COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS percentage
    FROM user_visits
    GROUP BY visit_count
),
poisson_fit AS (
    SELECT
        AVG(visit_count) AS lambda
    FROM user_visits
)
SELECT
    vd.visit_count,
    vd.user_count AS observed_count,
    ROUND(vd.percentage, 2) AS observed_percentage,
    -- 泊松分布理论频数
    ROUND(
        POWER(pf.lambda, vd.visit_count) * EXP(-pf.lambda) /
        NULLIF(
            (SELECT factorial FROM generate_series(1, vd.visit_count) AS factorial),
            1
        ) * (SELECT COUNT(*) FROM user_visits),
        2
    ) AS theoretical_count
FROM visit_distribution vd
CROSS JOIN poisson_fit pf
ORDER BY vd.visit_count;
```

### 6.3 产品质量分布分析

**场景**：分析产品质量指标的分布。

```sql
-- 产品质量分布分析：缺陷数量分布
WITH defect_stats AS (
    SELECT
        product_id,
        COUNT(*) AS defect_count
    FROM defects
    GROUP BY product_id
),
distribution_analysis AS (
    SELECT
        defect_count,
        COUNT(*) AS product_count,
        AVG(defect_count) OVER () AS mean_defects,
        STDDEV(defect_count) OVER () AS stddev_defects
    FROM defect_stats
    GROUP BY defect_count
)
SELECT
    defect_count,
    product_count,
    ROUND(product_count * 100.0 / SUM(product_count) OVER (), 2) AS percentage,
    -- Z-score
    ROUND(
        (defect_count - mean_defects) / NULLIF(stddev_defects, 0),
        2
    ) AS z_score,
    -- 正态分布判断
    CASE
        WHEN ABS((defect_count - mean_defects) / NULLIF(stddev_defects, 0)) > 3 THEN '异常'
        WHEN ABS((defect_count - mean_defects) / NULLIF(stddev_defects, 0)) > 2 THEN '异常偏高'
        ELSE '正常'
    END AS normality_assessment
FROM distribution_analysis
ORDER BY defect_count;
```

### 6.4 销售金额分布分析

**场景**：分析销售金额的分布特征。

```sql
-- 销售金额分布分析：金额分布和正态性检验
WITH sales_distribution AS (
    SELECT
        order_id,
        total_amount,
        -- 分组到标准差区间
        CASE
            WHEN total_amount < AVG(total_amount) OVER () - 3 * STDDEV(total_amount) OVER () THEN '<-3σ'
            WHEN total_amount < AVG(total_amount) OVER () - 2 * STDDEV(total_amount) OVER () THEN '-3σ to -2σ'
            WHEN total_amount < AVG(total_amount) OVER () - STDDEV(total_amount) OVER () THEN '-2σ to -1σ'
            WHEN total_amount < AVG(total_amount) OVER () THEN '-1σ to mean'
            WHEN total_amount < AVG(total_amount) OVER () + STDDEV(total_amount) OVER () THEN 'mean to +1σ'
            WHEN total_amount < AVG(total_amount) OVER () + 2 * STDDEV(total_amount) OVER () THEN '+1σ to +2σ'
            WHEN total_amount < AVG(total_amount) OVER () + 3 * STDDEV(total_amount) OVER () THEN '+2σ to +3σ'
            ELSE '>+3σ'
        END AS sigma_range
    FROM orders
    WHERE total_amount IS NOT NULL AND total_amount > 0
),
range_stats AS (
    SELECT
        sigma_range,
        COUNT(*) AS order_count,
        COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS percentage,
        AVG(total_amount) AS avg_amount,
        MIN(total_amount) AS min_amount,
        MAX(total_amount) AS max_amount
    FROM sales_distribution
    GROUP BY sigma_range
)
SELECT
    sigma_range,
    order_count,
    ROUND(percentage, 2) AS percentage,
    ROUND(avg_amount::numeric, 2) AS avg_amount,
    ROUND(min_amount::numeric, 2) AS min_amount,
    ROUND(max_amount::numeric, 2) AS max_amount,
    -- 理论正态分布百分比（68-95-99.7规则）
    CASE
        WHEN sigma_range IN ('-1σ to mean', 'mean to +1σ') THEN 68.0
        WHEN sigma_range IN ('-2σ to -1σ', '+1σ to +2σ') THEN 13.5
        WHEN sigma_range IN ('-3σ to -2σ', '+2σ to +3σ') THEN 2.35
        ELSE 0.15
    END AS theoretical_percentage
FROM range_stats
ORDER BY
    CASE sigma_range
        WHEN '<-3σ' THEN 1
        WHEN '-3σ to -2σ' THEN 2
        WHEN '-2σ to -1σ' THEN 3
        WHEN '-1σ to mean' THEN 4
        WHEN 'mean to +1σ' THEN 5
        WHEN '+1σ to +2σ' THEN 6
        WHEN '+2σ to +3σ' THEN 7
        ELSE 8
    END;
```

---

## 7. PostgreSQL 18并行统计分布分析

### 7.1 并行统计分布分析概述

**PostgreSQL 18并行统计分布分析**：利用PostgreSQL 18的并行查询能力，显著提升大规模统计分布分析的性能。

#### 并行统计分布分析配置

```sql
-- 配置并行统计分布分析参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行聚合成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行统计分布分析参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行统计分布分析配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 并行统计分布分析实现

```sql
-- 并行统计分布分析：大规模数据分布特征计算（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行统计分布分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行统计分布分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行分布特征统计
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    column_name,
    COUNT(*) AS sample_size,
    ROUND(AVG(column_value)::numeric, 4) AS mean,
    ROUND(STDDEV(column_value)::numeric, 4) AS stddev,
    ROUND(MIN(column_value)::numeric, 4) AS min_value,
    ROUND(MAX(column_value)::numeric, 4) AS max_value,
    ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY column_value)::numeric, 4) AS q1,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY column_value)::numeric, 4) AS median,
    ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY column_value)::numeric, 4) AS q3,
    -- 偏度近似计算
    ROUND((3 * (AVG(column_value) - PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY column_value)) /
           NULLIF(STDDEV(column_value), 0))::numeric, 4) AS skewness_approx
FROM data_table
GROUP BY column_name
ORDER BY column_name;
```

---

## 8. 算法性能对比与优化

### 8.1 分布分析方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|-----------|-----------|---------|------|------|
| **正态性检验** | $O(n)$ | $O(1)$ | 连续数据 | 简单快速 | 假设严格 |
| **卡方检验** | $O(k)$ | $O(k)$ | 离散数据 | 通用性强 | 需要分组 |
| **K-S检验** | $O(n \log n)$ | $O(n)$ | 连续数据 | 精确 | 计算复杂 |
| **分布拟合** | $O(n)$ | $O(1)$ | 参数估计 | 参数估计 | 需要假设分布 |

### 8.2 性能优化建议

1. **计算优化**：
   - 使用窗口函数减少重复计算
   - 缓存统计值
   - 使用物化视图

2. **查询优化**：
   - 创建索引加速排序
   - 使用分区表
   - 限制数据范围

3. **算法优化**：
   - 使用近似方法
   - 采样计算
   - 并行处理

### 8.3 常见问题与解决方案

**问题1**：分布检验不准确

- **解决方案**：增加样本量、检查数据质量、使用多种检验方法

**问题2**：计算复杂度过高

- **解决方案**：使用近似方法、采样计算、优化算法

**问题3**：分布假设不合理

- **解决方案**：数据探索、尝试多种分布、使用非参数方法

**问题4**：理论概率计算困难

- **解决方案**：使用PostgreSQL内置函数、近似计算、查表法

---

## 9. 最佳实践

### 9.1 分布选择

1. **数据探索**：
   - 可视化数据分布
   - 计算描述性统计
   - 检查数据特征

2. **分布假设**：
   - 根据数据特征选择分布
   - 考虑业务背景
   - 验证分布假设

3. **检验方法**：
   - 使用多种检验方法
   - 结合图形和统计检验
   - 考虑样本量

### 9.2 参数估计

1. **估计方法**：
   - 最大似然估计
   - 矩估计
   - 贝叶斯估计

2. **参数验证**：
   - 检查参数合理性
   - 验证估计精度
   - 比较不同方法

### 9.3 SQL实现注意事项

1. **性能考虑**：
   - 优化聚合查询
   - 使用窗口函数
   - 创建适当索引

2. **准确性**：
   - 处理数值精度
   - 避免除零错误
   - 验证计算结果

3. **可维护性**：
   - 使用清晰的变量名
   - 添加注释
   - 模块化设计

### 9.4 PostgreSQL 18 新特性应用（增强）

**PostgreSQL 18**引入了多项增强功能，可以显著提升统计分布分析的性能：

1. **Skip Scan优化**：
   - 对于包含分布值的索引，Skip Scan可以跳过不必要的索引扫描
   - 特别适用于Top-N分布值查询和分位数查询

2. **异步I/O增强**：
   - 对于大规模统计分布分析计算，异步I/O可以显著提升性能
   - 适用于批量分布拟合和多分布比较

3. **并行查询增强**：
   - 统计分布分析支持更好的并行执行
   - 适用于大规模分位数计算和分布检验

**示例：使用Skip Scan优化分布分析查询**

```sql
-- 为分布值创建Skip Scan优化索引
CREATE INDEX IF NOT EXISTS idx_distribution_values_skip_scan
ON distribution_data(variable_name, value DESC);

-- Skip Scan优化查询：查找每个变量分布值最高的前10个数据点
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (variable_name)
    variable_name,
    sample_id,
    value
FROM distribution_data
ORDER BY variable_name, value DESC
LIMIT 50;
```

### 9.5 高级优化技巧（增强）

**1. 使用物化视图缓存分布分析结果**

对于频繁使用的分布分析结果，使用物化视图缓存：

```sql
-- 创建物化视图缓存分布分析结果
CREATE MATERIALIZED VIEW IF NOT EXISTS distribution_analysis_cache AS
WITH distribution_statistics AS (
    SELECT
        variable_name,
        COUNT(*) AS sample_count,
        AVG(value) AS mean_value,
        STDDEV(value) AS stddev_value,
        VARIANCE(value) AS variance_value,
        PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY value) AS p5_value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS q1_value,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) AS median_value,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) AS q3_value,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY value) AS p95_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        -- 使用窗口函数计算偏度和峰度（避免重复计算）
        AVG(POWER((value - AVG(value) OVER (PARTITION BY variable_name)) /
            NULLIF(STDDEV(value) OVER (PARTITION BY variable_name), 0), 3)) AS skewness_value,
        AVG(POWER((value - AVG(value) OVER (PARTITION BY variable_name)) /
            NULLIF(STDDEV(value) OVER (PARTITION BY variable_name), 0), 4)) - 3 AS kurtosis_value
    FROM distribution_data
    WHERE value IS NOT NULL
    GROUP BY variable_name
)
SELECT
    variable_name,
    sample_count,
    ROUND(mean_value::numeric, 4) AS mean,
    ROUND(stddev_value::numeric, 4) AS stddev,
    ROUND(variance_value::numeric, 6) AS variance,
    ROUND(p5_value::numeric, 4) AS p5,
    ROUND(q1_value::numeric, 4) AS q1,
    ROUND(median_value::numeric, 4) AS median,
    ROUND(q3_value::numeric, 4) AS q3,
    ROUND(p95_value::numeric, 4) AS p95,
    min_value,
    max_value,
    ROUND(skewness_value::numeric, 4) AS skewness,
    ROUND(kurtosis_value::numeric, 4) AS kurtosis,
    CASE
        WHEN ABS(skewness_value) < 0.5 AND ABS(kurtosis_value) < 0.5 THEN 'Normal Distribution'
        WHEN ABS(skewness_value) >= 1.0 THEN 'Highly Skewed'
        WHEN kurtosis_value > 1.0 THEN 'Heavy Tailed'
        ELSE 'Non-Normal Distribution'
    END AS distribution_type
FROM distribution_statistics;

-- 创建索引加速物化视图查询
CREATE INDEX idx_distribution_analysis_cache_variable ON distribution_analysis_cache(variable_name);
CREATE INDEX idx_distribution_analysis_cache_type ON distribution_analysis_cache(distribution_type);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY distribution_analysis_cache;
```

**2. 实时分布分析：增量分布更新**

**实时分布分析**：对于实时数据，使用增量方法更新分布分析结果。

```sql
-- 实时分布分析：增量分布更新（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'distribution_state') THEN
            CREATE TABLE distribution_state (
                variable_name VARCHAR(100) PRIMARY KEY,
                sample_count BIGINT DEFAULT 0,
                sum_value NUMERIC DEFAULT 0,
                sum_squared_value NUMERIC DEFAULT 0,
                sum_cubed_value NUMERIC DEFAULT 0,
                sum_fourth_value NUMERIC DEFAULT 0,
                min_value NUMERIC,
                max_value NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_distribution_state_variable ON distribution_state(variable_name);
            CREATE INDEX idx_distribution_state_updated ON distribution_state(last_updated DESC);

            RAISE NOTICE '分布状态表创建成功';
        END IF;

        RAISE NOTICE '开始执行增量分布更新';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '增量分布更新准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 增量更新分布统计：实时分布分析
WITH new_samples AS (
    SELECT
        variable_name,
        value
    FROM distribution_data
    WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM distribution_state)
      AND value IS NOT NULL
),
updated_distributions AS (
    SELECT
        COALESCE(ds.variable_name, ns.variable_name) AS variable_name,
        COALESCE(ds.sample_count, 0) + COUNT(*) AS new_sample_count,
        COALESCE(ds.sum_value, 0) + SUM(ns.value) AS new_sum_value,
        COALESCE(ds.sum_squared_value, 0) + SUM(POWER(ns.value, 2)) AS new_sum_squared_value,
        COALESCE(ds.sum_cubed_value, 0) + SUM(POWER(ns.value, 3)) AS new_sum_cubed_value,
        COALESCE(ds.sum_fourth_value, 0) + SUM(POWER(ns.value, 4)) AS new_sum_fourth_value,
        LEAST(COALESCE(ds.min_value, ns.value), MIN(ns.value)) AS new_min_value,
        GREATEST(COALESCE(ds.max_value, ns.value), MAX(ns.value)) AS new_max_value
    FROM distribution_state ds
    FULL OUTER JOIN new_samples ns ON ds.variable_name = ns.variable_name
    GROUP BY ds.variable_name, ns.variable_name, ds.sample_count, ds.sum_value,
             ds.sum_squared_value, ds.sum_cubed_value, ds.sum_fourth_value, ds.min_value, ds.max_value
)
-- 更新或插入分布状态
INSERT INTO distribution_state (
    variable_name,
    sample_count,
    sum_value,
    sum_squared_value,
    sum_cubed_value,
    sum_fourth_value,
    min_value,
    max_value,
    last_updated
)
SELECT
    variable_name,
    new_sample_count,
    new_sum_value,
    new_sum_squared_value,
    new_sum_cubed_value,
    new_sum_fourth_value,
    new_min_value,
    new_max_value,
    NOW()
FROM updated_distributions
ON CONFLICT (variable_name)
DO UPDATE SET
    sample_count = EXCLUDED.sample_count,
    sum_value = EXCLUDED.sum_value,
    sum_squared_value = EXCLUDED.sum_squared_value,
    sum_cubed_value = EXCLUDED.sum_cubed_value,
    sum_fourth_value = EXCLUDED.sum_fourth_value,
    min_value = EXCLUDED.min_value,
    max_value = EXCLUDED.max_value,
    last_updated = NOW();
```

**3. 多分布比较：分布拟合优度分析**

**多分布比较**：比较数据与多种理论分布的拟合优度。

```sql
-- 多分布比较：分布拟合优度分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'distribution_data') THEN
            RAISE WARNING '表 distribution_data 不存在，无法执行多分布比较';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多分布比较';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多分布比较准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 多分布比较：计算数据与多种分布的拟合优度
WITH distribution_statistics AS (
    SELECT
        variable_name,
        AVG(value) AS mean_value,
        STDDEV(value) AS stddev_value,
        VARIANCE(value) AS variance_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        COUNT(*) AS sample_count
    FROM distribution_data
    WHERE value IS NOT NULL
    GROUP BY variable_name
),
normal_distribution_fit AS (
    SELECT
        ds.variable_name,
        'Normal' AS distribution_type,
        -- 正态分布拟合：使用均值和标准差
        ds.mean_value AS fit_mean,
        ds.stddev_value AS fit_stddev,
        -- 使用窗口函数计算卡方统计量（简化版，避免重复计算）
        SUM(POWER(
            (dd.value - ds.mean_value) / NULLIF(ds.stddev_value, 0), 2
        )) OVER (PARTITION BY ds.variable_name) / ds.sample_count AS chi_square_stat
    FROM distribution_statistics ds
    JOIN distribution_data dd ON ds.variable_name = dd.variable_name
    WHERE dd.value IS NOT NULL
),
poisson_distribution_fit AS (
    SELECT
        ds.variable_name,
        'Poisson' AS distribution_type,
        ds.mean_value AS fit_lambda,  -- 泊松分布的λ参数等于均值
        NULL::NUMERIC AS fit_stddev,
        -- 泊松分布拟合：λ = mean
        SUM(POWER(
            dd.value - ds.mean_value, 2
        )) OVER (PARTITION BY ds.variable_name) / ds.sample_count AS chi_square_stat
    FROM distribution_statistics ds
    JOIN distribution_data dd ON ds.variable_name = dd.variable_name
    WHERE dd.value IS NOT NULL
      AND dd.value >= 0  -- 泊松分布要求非负整数
)
SELECT DISTINCT ON (variable_name)
    variable_name,
    distribution_type,
    ROUND(fit_mean::numeric, 4) AS fit_parameter_mean,
    ROUND(fit_stddev::numeric, 4) AS fit_parameter_stddev,
    ROUND(fit_lambda::numeric, 4) AS fit_parameter_lambda,
    ROUND(chi_square_stat::numeric, 6) AS chi_square_statistic,
    CASE
        WHEN chi_square_stat < 1.0 THEN 'Excellent Fit'
        WHEN chi_square_stat < 2.0 THEN 'Good Fit'
        WHEN chi_square_stat < 3.0 THEN 'Moderate Fit'
        ELSE 'Poor Fit'
    END AS fit_quality
FROM (
    SELECT * FROM normal_distribution_fit
    UNION ALL
    SELECT * FROM poisson_distribution_fit
) AS distribution_fits
ORDER BY variable_name, chi_square_stat ASC;
```

---

## 📚 参考资源

### 学术文献

1. **《概率论与数理统计》**（茆诗松等, 2011）- 统计分布理论

2. **《统计推断》**（Casella, G. & Berger, R. L., 2002）- 分布检验

3. **《应用回归分析》**（何晓群, 2015）- 分布应用

### PostgreSQL官方文档

- **数学函数**: <https://www.postgresql.org/docs/current/functions-math.html>
- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>

### 在线资源

- **统计分布**: <https://en.wikipedia.org/wiki/Probability_distribution>
- **正态分布**: <https://en.wikipedia.org/wiki/Normal_distribution>
- **分布检验**: <https://www.statsmodels.org/stable/stats.html>

### 相关算法

- **描述性统计**：分布特征计算
- **假设检验算法**：分布检验方法
- **时间序列分析**：时间序列分布分析
- **异常检测算法**：基于分布的异常检测

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
