# PostgreSQL 描述性统计完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 统计分析 | 描述性统计
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 描述性统计完整指南](#postgresql-描述性统计完整指南)
  - [📋 目录](#-目录)
  - [描述性统计概述](#描述性统计概述)
    - [理论基础](#理论基础)
      - [统计量的分类](#统计量的分类)
      - [统计量的性质](#统计量的性质)
    - [核心统计指标](#核心统计指标)
  - [1. 中心趋势度量](#1-中心趋势度量)
    - [1.1 均值（Mean）](#11-均值mean)
      - [数学定义](#数学定义)
      - [性质](#性质)
      - [适用场景](#适用场景)
      - [局限性](#局限性)
    - [1.2 中位数（Median）](#12-中位数median)
      - [数学定义](#数学定义-1)
      - [性质](#性质-1)
      - [适用场景](#适用场景-1)
      - [与均值的比较](#与均值的比较)
    - [1.3 众数（Mode）](#13-众数mode)
      - [数学定义](#数学定义-2)
      - [性质](#性质-2)
      - [适用场景](#适用场景-2)
      - [其他中心趋势度量](#其他中心趋势度量)
  - [2. 离散程度度量](#2-离散程度度量)
    - [2.1 标准差（Standard Deviation）](#21-标准差standard-deviation)
      - [数学定义](#数学定义-3)
      - [性质](#性质-3)
      - [适用场景](#适用场景-3)
    - [2.2 方差（Variance）](#22-方差variance)
    - [2.3 极差（Range）](#23-极差range)
      - [数学定义](#数学定义-4)
      - [性质](#性质-4)
      - [适用场景](#适用场景-4)
    - [2.4 四分位距（IQR）](#24-四分位距iqr)
      - [数学定义](#数学定义-5)
      - [性质](#性质-5)
      - [适用场景](#适用场景-5)
    - [2.5 变异系数（CV）](#25-变异系数cv)
      - [数学定义](#数学定义-6)
      - [性质](#性质-6)
      - [适用场景](#适用场景-6)
  - [3. 分布形状度量](#3-分布形状度量)
    - [3.1 偏度（Skewness）](#31-偏度skewness)
      - [数学定义](#数学定义-7)
      - [偏度的解释](#偏度的解释)
      - [偏度的程度](#偏度的程度)
      - [适用场景](#适用场景-7)
    - [3.2 峰度（Kurtosis）](#32-峰度kurtosis)
      - [数学定义](#数学定义-8)
      - [峰度的解释](#峰度的解释)
      - [峰度的程度](#峰度的程度)
      - [适用场景](#适用场景-8)
  - [4. 综合统计报告](#4-综合统计报告)
    - [4.1 完整描述性统计报告](#41-完整描述性统计报告)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 电商销售数据分析](#51-电商销售数据分析)
    - [5.2 用户行为分析](#52-用户行为分析)
    - [5.3 产品质量分析](#53-产品质量分析)
    - [5.4 金融数据分析](#54-金融数据分析)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 统计量选择指南](#61-统计量选择指南)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 统计量选择](#71-统计量选择)
    - [7.2 异常值处理](#72-异常值处理)
    - [7.3 报告格式](#73-报告格式)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 描述性统计概述

**描述性统计（Descriptive Statistics）**是统计学的基础，用于描述和总结数据的基本特征，包括中心趋势、离散程度和分布形状。描述性统计不涉及推断或假设检验，而是对数据进行客观的描述和总结。

### 理论基础

#### 统计量的分类

1. **中心趋势度量（Measures of Central Tendency）**：
   - 描述数据的"中心"或"典型"值
   - 包括均值、中位数、众数、几何平均数、调和平均数

2. **离散程度度量（Measures of Dispersion）**：
   - 描述数据的"分散"或"变异"程度
   - 包括方差、标准差、极差、四分位距、变异系数

3. **分布形状度量（Measures of Distribution Shape）**：
   - 描述数据分布的"形状"特征
   - 包括偏度、峰度

4. **位置度量（Measures of Position）**：
   - 描述数据在分布中的位置
   - 包括分位数、百分位数、z分数

#### 统计量的性质

- **稳健性（Robustness）**：统计量对异常值的敏感程度
  - 稳健统计量：中位数、四分位距
  - 非稳健统计量：均值、标准差

- **有效性（Efficiency）**：统计量利用数据信息的程度
  - 均值比中位数更有效（在正态分布下）

- **一致性（Consistency）**：样本量增大时统计量收敛到总体参数

### 核心统计指标

| 指标类型 | 指标名称 | SQL函数 | 数学公式 | 稳健性 | 用途 |
|---------|---------|---------|---------|--------|------|
| **中心趋势** | 均值 | AVG() | $\bar{x} = \frac{1}{n}\sum_{i=1}^{n}x_i$ | 低 | 数据的平均水平 |
| | 中位数 | PERCENTILE_CONT(0.5) | $Q_2$ | 高 | 数据的中间值 |
| | 众数 | MODE() | 最频繁值 | 中 | 数据中出现最频繁的值 |
| | 几何平均数 | 自定义 | $\sqrt[n]{\prod_{i=1}^{n}x_i}$ | 低 | 增长率、比率数据 |
| **离散程度** | 标准差 | STDDEV() | $s = \sqrt{\frac{1}{n-1}\sum(x_i-\bar{x})^2}$ | 低 | 数据的离散程度 |
| | 方差 | VARIANCE() | $s^2 = \frac{1}{n-1}\sum(x_i-\bar{x})^2$ | 低 | 标准差的平方 |
| | 极差 | MAX() - MIN() | $R = x_{max} - x_{min}$ | 低 | 最大值与最小值的差 |
| | 四分位距 | PERCENTILE_CONT(0.75) - PERCENTILE_CONT(0.25) | $IQR = Q_3 - Q_1$ | 高 | 中间50%数据的范围 |
| | 变异系数 | STDDEV() / AVG() | $CV = \frac{s}{\bar{x}}$ | 低 | 相对离散程度 |
| **分布形状** | 偏度 | 自定义函数 | $\frac{n}{(n-1)(n-2)}\sum(\frac{x_i-\bar{x}}{s})^3$ | 中 | 分布的对称性 |
| | 峰度 | 自定义函数 | $\frac{n(n+1)}{(n-1)(n-2)(n-3)}\sum(\frac{x_i-\bar{x}}{s})^4 - 3$ | 中 | 分布的尖锐程度 |

---

## 1. 中心趋势度量

### 1.1 均值（Mean）

**均值（算术平均数）**是所有数据的平均值，是最常用的中心趋势度量。

#### 数学定义

**样本均值**：
$$\bar{x} = \frac{1}{n}\sum_{i=1}^{n}x_i = \frac{x_1 + x_2 + ... + x_n}{n}$$

**总体均值**：
$$\mu = \frac{1}{N}\sum_{i=1}^{N}x_i$$

#### 性质

1. **无偏性**：样本均值是总体均值的无偏估计
2. **最小方差**：在所有线性无偏估计量中，均值具有最小方差
3. **对异常值敏感**：一个极端值会显著影响均值
4. **线性性质**：$E[aX + b] = aE[X] + b$

#### 适用场景

- 数据近似正态分布
- 需要充分利用所有数据信息
- 数据中没有极端异常值

#### 局限性

- 对异常值敏感
- 不适用于偏态分布
- 不适用于分类数据

```sql
-- 计算均值（带错误处理和性能测试）
DO $$
DECLARE
    mean_value NUMERIC;
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算均值';
            RETURN;
        END IF;

        -- 检查列是否存在
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        -- 计算行数
        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count = 0 THEN
            RAISE WARNING '表 sales 中没有有效数据';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算均值，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算均值准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算均值
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT AVG(amount) AS mean_amount
FROM sales
WHERE amount IS NOT NULL;

-- 结果示例：
-- mean_amount: 1250.50
```

### 1.2 中位数（Median）

**中位数**是将数据排序后位于中间的值，是稳健的中心趋势度量。

#### 数学定义

对于有序数据 $x_{(1)} \leq x_{(2)} \leq ... \leq x_{(n)}$：

**中位数**：
$$
Q_2 = \begin{cases}
x_{((n+1)/2)} & \text{如果 } n \text{ 是奇数} \\
\frac{x_{(n/2)} + x_{(n/2+1)}}{2} & \text{如果 } n \text{ 是偶数}
\end{cases}
$$

#### 性质

1. **稳健性**：对异常值不敏感
2. **分位数性质**：中位数是第50百分位数
3. **最小绝对偏差**：中位数最小化 $\sum_{i=1}^{n}|x_i - m|$

#### 适用场景

- 数据有异常值或偏态分布
- 需要稳健的中心趋势度量
- 序数数据或区间数据

#### 与均值的比较

| 特性 | 均值 | 中位数 |
|------|------|--------|
| **稳健性** | 低 | 高 |
| **效率** | 高（正态分布） | 中 |
| **计算复杂度** | $O(n)$ | $O(n \log n)$ |
| **对异常值** | 敏感 | 不敏感 |

```sql
-- 计算中位数（带错误处理和性能测试）
DO $$
DECLARE
    median_value NUMERIC;
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算中位数';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count = 0 THEN
            RAISE WARNING '表 sales 中没有有效数据';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算中位数，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算中位数准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算中位数（使用PERCENTILE_CONT）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount
FROM sales
WHERE amount IS NOT NULL;

-- 结果示例：
-- median_amount: 1200.00
```

### 1.3 众数（Mode）

**众数**是数据中出现最频繁的值，是唯一适用于分类数据的中心趋势度量。

#### 数学定义

**众数**：
$$\text{Mode} = \arg\max_{x} f(x)$$

其中 $f(x)$ 是值 $x$ 的频率。

#### 性质

1. **唯一性**：数据可能有多个众数（多峰分布）或没有众数
2. **适用性**：唯一适用于分类数据的中心趋势度量
3. **不受极端值影响**：只取决于频率，不受数值大小影响

#### 适用场景

- 分类数据（名义数据）
- 需要知道最常见的值
- 数据有明显的峰值

#### 其他中心趋势度量

**几何平均数（Geometric Mean）**：
$$G = \sqrt[n]{\prod_{i=1}^{n}x_i} = (x_1 \cdot x_2 \cdot ... \cdot x_n)^{1/n}$$

适用于增长率、比率数据。

**调和平均数（Harmonic Mean）**：
$$H = \frac{n}{\sum_{i=1}^{n}\frac{1}{x_i}}$$

适用于速度、效率等倒数关系的数据。

```sql
-- 计算众数（带错误处理和性能测试）
DO $$
DECLARE
    mode_value NUMERIC;
    mode_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算众数';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算众数';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算众数准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算众数（使用GROUP BY和COUNT）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT amount AS mode_amount, COUNT(*) AS frequency
FROM sales
WHERE amount IS NOT NULL
GROUP BY amount
ORDER BY COUNT(*) DESC
LIMIT 1;

-- 结果示例：
-- mode_amount: 1000.00, frequency: 150
```

---

## 2. 离散程度度量

### 2.1 标准差（Standard Deviation）

**标准差**衡量数据的离散程度，是方差的平方根，与原始数据具有相同的量纲。

#### 数学定义

**样本标准差**：
$$s = \sqrt{\frac{1}{n-1}\sum_{i=1}^{n}(x_i - \bar{x})^2}$$

**总体标准差**：
$$\sigma = \sqrt{\frac{1}{N}\sum_{i=1}^{N}(x_i - \mu)^2}$$

#### 性质

1. **量纲**：与原始数据具有相同的量纲
2. **非负性**：$s \geq 0$，当且仅当所有数据相等时 $s = 0$
3. **切比雪夫不等式**：至少 $(1 - 1/k^2)$ 的数据落在 $[\bar{x} - ks, \bar{x} + ks]$ 内
4. **经验法则**（正态分布）：
   - 68%的数据在 $[\bar{x} - s, \bar{x} + s]$ 内
   - 95%的数据在 $[\bar{x} - 2s, \bar{x} + 2s]$ 内
   - 99.7%的数据在 $[\bar{x} - 3s, \bar{x} + 3s]$ 内

#### 适用场景

- 数据近似正态分布
- 需要与均值相同量纲的离散度量
- 进行统计推断（t检验、置信区间等）

```sql
-- 计算标准差（带错误处理和性能测试）
DO $$
DECLARE
    stddev_value NUMERIC;
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算标准差';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count < 2 THEN
            RAISE WARNING '数据行数不足（需要至少2行）';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算标准差，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算标准差准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算标准差（样本标准差）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT STDDEV(amount) AS stddev_amount
FROM sales
WHERE amount IS NOT NULL;

-- 性能测试：计算标准差（总体标准差）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT STDDEV_POP(amount) AS stddev_pop_amount
FROM sales
WHERE amount IS NOT NULL;

-- 结果示例：
-- stddev_amount: 250.75 (样本标准差)
-- stddev_pop_amount: 250.50 (总体标准差)
```

### 2.2 方差（Variance）

**方差**是标准差的平方。

```sql
-- 计算方差（带错误处理和性能测试）
DO $$
DECLARE
    variance_value NUMERIC;
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算方差';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count < 2 THEN
            RAISE WARNING '数据行数不足（需要至少2行）';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算方差，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算方差准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算方差（样本方差）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT VARIANCE(amount) AS variance_amount
FROM sales
WHERE amount IS NOT NULL;

-- 性能测试：计算方差（总体方差）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT VAR_POP(amount) AS var_pop_amount
FROM sales
WHERE amount IS NOT NULL;

-- 结果示例：
-- variance_amount: 62875.56 (样本方差)
-- var_pop_amount: 62850.25 (总体方差)
```

### 2.3 极差（Range）

**极差**是最大值与最小值的差，是最简单的离散程度度量。

#### 数学定义

**极差**：
$$R = x_{max} - x_{min}$$

#### 性质

1. **简单性**：计算最简单
2. **不稳健**：对异常值非常敏感
3. **信息量少**：只使用两个数据点

#### 适用场景

- 快速了解数据范围
- 数据量小且无异常值
- 作为初步探索性分析

### 2.4 四分位距（IQR）

**四分位距（Interquartile Range, IQR）**是第75百分位数与第25百分位数的差，是稳健的离散程度度量。

#### 数学定义

**四分位距**：
$$IQR = Q_3 - Q_1$$

其中：

- $Q_1$（第一四分位数）：第25百分位数
- $Q_3$（第三四分位数）：第75百分位数

#### 性质

1. **稳健性**：对异常值不敏感
2. **中间50%数据**：IQR包含中间50%的数据
3. **异常值检测**：使用 $Q_1 - 1.5 \times IQR$ 和 $Q_3 + 1.5 \times IQR$ 检测异常值

#### 适用场景

- 数据有异常值或偏态分布
- 需要稳健的离散度量
- 异常值检测

### 2.5 变异系数（CV）

**变异系数（Coefficient of Variation, CV）**是标准差与均值的比值，是相对离散程度度量。

#### 数学定义

**变异系数**：
$$CV = \frac{s}{\bar{x}} \times 100\%$$

#### 性质

1. **无量纲**：相对度量，便于不同量级数据比较
2. **相对性**：表示标准差占均值的百分比
3. **适用性**：仅当均值不为0时使用

#### 适用场景

- 比较不同量级数据的离散程度
- 均值不为0的比率数据
- 风险评估（CV越大，风险越高）

```sql
-- 计算极差（带错误处理和性能测试）
DO $$
DECLARE
    range_value NUMERIC;
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算极差';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count = 0 THEN
            RAISE WARNING '表 sales 中没有有效数据';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算极差，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算极差准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算极差
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT MAX(amount) - MIN(amount) AS range_amount
FROM sales
WHERE amount IS NOT NULL;

-- 结果示例：
-- range_amount: 2000.00
```

---

## 3. 分布形状度量

### 3.1 偏度（Skewness）

**偏度**衡量分布的对称性，描述数据分布的偏斜方向和程度。

#### 数学定义

**样本偏度**（Pearson偏度）：
$$g_1 = \frac{n}{(n-1)(n-2)} \sum_{i=1}^{n} \left(\frac{x_i - \bar{x}}{s}\right)^3$$

**总体偏度**：
$$\gamma_1 = E\left[\left(\frac{X - \mu}{\sigma}\right)^3\right]$$

#### 偏度的解释

- **$g_1 > 0$**：正偏（右偏），右尾较长，均值 > 中位数
- **$g_1 < 0$**：负偏（左偏），左尾较长，均值 < 中位数
- **$g_1 = 0$**：对称分布（如正态分布）

#### 偏度的程度

- **$|g_1| < 0.5$**：近似对称
- **$0.5 \leq |g_1| < 1$**：中等偏斜
- **$|g_1| \geq 1$**：高度偏斜

#### 适用场景

- 检查数据分布的正态性
- 选择适当的统计方法
- 理解数据的分布特征

```sql
-- 计算偏度（带错误处理和性能测试）
DO $$
DECLARE
    skewness_value NUMERIC;
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算偏度';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count < 3 THEN
            RAISE WARNING '数据行数不足（需要至少3行）';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算偏度，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算偏度准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算偏度（使用自定义公式）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stats AS (
    SELECT
        AVG(amount) AS mean_val,
        STDDEV(amount) AS stddev_val,
        COUNT(*) AS n
    FROM sales
    WHERE amount IS NOT NULL
)
SELECT
    (n / ((n - 1) * (n - 2))) * SUM(POWER((amount - mean_val) / stddev_val, 3)) AS skewness
FROM sales, stats
WHERE amount IS NOT NULL;

-- 结果示例：
-- skewness: 0.25 (正偏，右尾较长)
-- skewness: -0.25 (负偏，左尾较长)
-- skewness: 0.00 (对称分布)
```

### 3.2 峰度（Kurtosis）

**峰度**衡量分布的尖锐程度，描述数据分布的尾部厚度。

#### 数学定义

**样本峰度**（超额峰度）：
$$g_2 = \frac{n(n+1)}{(n-1)(n-2)(n-3)} \sum_{i=1}^{n} \left(\frac{x_i - \bar{x}}{s}\right)^4 - \frac{3(n-1)^2}{(n-2)(n-3)}$$

**总体峰度**：
$$\gamma_2 = E\left[\left(\frac{X - \mu}{\sigma}\right)^4\right] - 3$$

注意：减去3是为了使正态分布的峰度为0。

#### 峰度的解释

- **$g_2 > 0$**：尖峰分布（Leptokurtic），尾部较厚，数据集中
- **$g_2 < 0$**：平峰分布（Platykurtic），尾部较薄，数据分散
- **$g_2 = 0$**：正态分布（Mesokurtic）

#### 峰度的程度

- **$|g_2| < 0.5$**：近似正态
- **$0.5 \leq |g_2| < 1$**：中等偏离正态
- **$|g_2| \geq 1$**：显著偏离正态

#### 适用场景

- 检查数据分布的正态性
- 风险评估（厚尾分布风险更高）
- 选择适当的统计方法

```sql
-- 计算峰度（带错误处理和性能测试）
DO $$
DECLARE
    kurtosis_value NUMERIC;
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法计算峰度';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count < 4 THEN
            RAISE WARNING '数据行数不足（需要至少4行）';
            RETURN;
        END IF;

        RAISE NOTICE '开始计算峰度，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算峰度准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：计算峰度（使用自定义公式）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stats AS (
    SELECT
        AVG(amount) AS mean_val,
        STDDEV(amount) AS stddev_val,
        COUNT(*) AS n
    FROM sales
    WHERE amount IS NOT NULL
)
SELECT
    ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * SUM(POWER((amount - mean_val) / stddev_val, 4)) -
    (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3)) AS kurtosis
FROM sales, stats
WHERE amount IS NOT NULL;

-- 结果示例：
-- kurtosis: > 0 (尖峰分布，数据集中)
-- kurtosis: < 0 (平峰分布，数据分散)
-- kurtosis: 0 (正态分布)
```

---

## 4. 综合统计报告

### 4.1 完整描述性统计报告

```sql
-- 生成完整描述性统计报告（带错误处理和性能测试）
DO $$
DECLARE
    row_count BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法生成统计报告';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'sales' AND column_name = 'amount'
        ) THEN
            RAISE WARNING '列 amount 不存在';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO row_count FROM sales WHERE amount IS NOT NULL;
        IF row_count = 0 THEN
            RAISE WARNING '表 sales 中没有有效数据';
            RETURN;
        END IF;

        RAISE NOTICE '开始生成完整描述性统计报告，数据行数: %', row_count;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '生成统计报告准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：生成完整描述性统计报告
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    -- 中心趋势
    AVG(amount) AS mean,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median,
    MODE() WITHIN GROUP (ORDER BY amount) AS mode,

    -- 离散程度
    STDDEV(amount) AS stddev,
    VARIANCE(amount) AS variance,
    MAX(amount) - MIN(amount) AS range_val,
    MIN(amount) AS min_val,
    MAX(amount) AS max_val,

    -- 分位数
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3,
    PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY amount) AS p90,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY amount) AS p95,
    PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY amount) AS p99,

    -- 计数
    COUNT(*) AS count,
    COUNT(DISTINCT amount) AS distinct_count
FROM sales
WHERE amount IS NOT NULL;
```

---

## 5. 实际应用案例

### 5.1 电商销售数据分析

**业务场景**: 分析电商平台的销售数据，生成销售统计报告，支持业务决策。

```sql
-- 电商销售数据分析（带完整错误处理和性能测试）
DO $$
DECLARE
    report_count INT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法生成销售分析报告';
            RETURN;
        END IF;

        -- 检查必需的列
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'order_amount'
        ) THEN
            RAISE WARNING '列 order_amount 不存在';
            RETURN;
        END IF;

        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'order_date'
        ) THEN
            RAISE WARNING '列 order_date 不存在';
            RETURN;
        END IF;

        RAISE NOTICE '开始生成电商销售数据分析报告';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '生成销售分析报告准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 性能测试：按日期分组的销售统计
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('day', order_date) AS sale_date,
    COUNT(*) AS order_count,
    COUNT(DISTINCT customer_id) AS customer_count,
    SUM(order_amount) AS total_amount,
    AVG(order_amount) AS avg_amount,
    STDDEV(order_amount) AS stddev_amount,
    MIN(order_amount) AS min_amount,
    MAX(order_amount) AS max_amount,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY order_amount) AS median_amount
FROM orders
WHERE order_date >= CURRENT_DATE - INTERVAL '30 days'
  AND order_amount IS NOT NULL
GROUP BY DATE_TRUNC('day', order_date)
ORDER BY sale_date DESC;
```

### 5.2 用户行为分析

**场景**：分析用户访问时长、页面浏览量等行为指标。

```sql
-- 用户行为分析：访问时长统计
WITH user_behavior AS (
    SELECT
        user_id,
        session_duration_seconds,
        page_views,
        bounce_rate
    FROM user_sessions
    WHERE session_date >= CURRENT_DATE - INTERVAL '7 days'
),
behavior_stats AS (
    SELECT
        COUNT(*) AS user_count,
        -- 访问时长统计
        AVG(session_duration_seconds) AS mean_duration,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY session_duration_seconds) AS median_duration,
        STDDEV(session_duration_seconds) AS stddev_duration,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY session_duration_seconds) AS q1_duration,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY session_duration_seconds) AS q3_duration,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY session_duration_seconds) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY session_duration_seconds) AS iqr_duration,
        -- 页面浏览量统计
        AVG(page_views) AS mean_page_views,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY page_views) AS median_page_views,
        STDDEV(page_views) AS stddev_page_views,
        -- 偏度和峰度（简化计算）
        AVG(POWER((session_duration_seconds - AVG(session_duration_seconds) OVER ()) /
            NULLIF(STDDEV(session_duration_seconds) OVER (), 0), 3)) AS skewness_duration,
        AVG(POWER((session_duration_seconds - AVG(session_duration_seconds) OVER ()) /
            NULLIF(STDDEV(session_duration_seconds) OVER (), 0), 4)) - 3 AS kurtosis_duration
    FROM user_behavior
)
SELECT
    user_count,
    ROUND(mean_duration::numeric, 2) AS mean_duration_sec,
    ROUND(median_duration::numeric, 2) AS median_duration_sec,
    ROUND(stddev_duration::numeric, 2) AS stddev_duration_sec,
    ROUND(iqr_duration::numeric, 2) AS iqr_duration_sec,
    ROUND(mean_page_views::numeric, 2) AS mean_page_views,
    ROUND(median_page_views::numeric, 2) AS median_page_views,
    ROUND(stddev_page_views::numeric, 2) AS stddev_page_views,
    ROUND(skewness_duration::numeric, 4) AS duration_skewness,
    ROUND(kurtosis_duration::numeric, 4) AS duration_kurtosis,
    CASE
        WHEN ABS(skewness_duration) > 1 THEN '高度偏斜分布'
        WHEN ABS(skewness_duration) > 0.5 THEN '中等偏斜分布'
        ELSE '近似对称分布'
    END AS distribution_shape
FROM behavior_stats;
```

### 5.3 产品质量分析

**场景**：分析产品质量指标，识别异常批次。

```sql
-- 产品质量分析：使用描述性统计识别异常
WITH product_quality AS (
    SELECT
        batch_id,
        product_weight,
        defect_rate,
        test_score
    FROM quality_measurements
    WHERE measurement_date >= CURRENT_DATE - INTERVAL '30 days'
),
batch_statistics AS (
    SELECT
        batch_id,
        COUNT(*) AS sample_size,
        AVG(product_weight) AS mean_weight,
        STDDEV(product_weight) AS stddev_weight,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY product_weight) AS median_weight,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY product_weight) AS q1_weight,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY product_weight) AS q3_weight,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY product_weight) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY product_weight) AS iqr_weight,
        AVG(defect_rate) AS mean_defect_rate,
        AVG(test_score) AS mean_test_score
    FROM product_quality
    GROUP BY batch_id
),
outlier_detection AS (
    SELECT
        batch_id,
        sample_size,
        mean_weight,
        stddev_weight,
        median_weight,
        iqr_weight,
        q1_weight,
        q3_weight,
        mean_defect_rate,
        mean_test_score,
        -- 使用IQR方法检测异常
        CASE
            WHEN mean_weight < q1_weight - 1.5 * iqr_weight OR
                 mean_weight > q3_weight + 1.5 * iqr_weight THEN '异常批次'
            ELSE '正常批次'
        END AS batch_status
    FROM batch_statistics
)
SELECT
    batch_id,
    sample_size,
    ROUND(mean_weight::numeric, 4) AS mean_weight,
    ROUND(stddev_weight::numeric, 4) AS stddev_weight,
    ROUND(median_weight::numeric, 4) AS median_weight,
    ROUND(iqr_weight::numeric, 4) AS iqr_weight,
    ROUND(mean_defect_rate::numeric, 4) AS defect_rate,
    ROUND(mean_test_score::numeric, 2) AS test_score,
    batch_status
FROM outlier_detection
ORDER BY
    CASE WHEN batch_status = '异常批次' THEN 0 ELSE 1 END,
    mean_defect_rate DESC;
```

### 5.4 金融数据分析

**场景**：分析股票收益率、风险评估等金融指标。

```sql
-- 金融数据分析：收益率统计和风险评估
WITH stock_returns AS (
    SELECT
        stock_code,
        trade_date,
        daily_return,
        volume,
        price
    FROM stock_daily_data
    WHERE trade_date >= CURRENT_DATE - INTERVAL '90 days'
),
return_statistics AS (
    SELECT
        stock_code,
        COUNT(*) AS trading_days,
        -- 收益率统计
        AVG(daily_return) AS mean_return,
        STDDEV(daily_return) AS stddev_return,
        VARIANCE(daily_return) AS variance_return,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY daily_return) AS median_return,
        PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY daily_return) AS p5_return,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY daily_return) AS p95_return,
        MIN(daily_return) AS min_return,
        MAX(daily_return) AS max_return,
        -- 变异系数（风险指标）
        STDDEV(daily_return) / NULLIF(ABS(AVG(daily_return)), 0) AS coefficient_of_variation,
        -- 偏度和峰度
        AVG(POWER((daily_return - AVG(daily_return) OVER (PARTITION BY stock_code)) /
            NULLIF(STDDEV(daily_return) OVER (PARTITION BY stock_code), 0), 3)) AS skewness,
        AVG(POWER((daily_return - AVG(daily_return) OVER (PARTITION BY stock_code)) /
            NULLIF(STDDEV(daily_return) OVER (PARTITION BY stock_code), 0), 4)) - 3 AS kurtosis
    FROM stock_returns
    GROUP BY stock_code
)
SELECT
    stock_code,
    trading_days,
    ROUND(mean_return::numeric, 6) AS mean_return_pct,
    ROUND(stddev_return::numeric, 6) AS stddev_return_pct,
    ROUND(variance_return::numeric, 8) AS variance_return,
    ROUND(median_return::numeric, 6) AS median_return_pct,
    ROUND(p5_return::numeric, 6) AS p5_return_pct,
    ROUND(p95_return::numeric, 6) AS p95_return_pct,
    ROUND(coefficient_of_variation::numeric, 4) AS cv_risk,
    ROUND(skewness::numeric, 4) AS return_skewness,
    ROUND(kurtosis::numeric, 4) AS return_kurtosis,
    CASE
        WHEN coefficient_of_variation > 2 THEN '高风险'
        WHEN coefficient_of_variation > 1 THEN '中等风险'
        ELSE '低风险'
    END AS risk_level,
    CASE
        WHEN kurtosis > 3 THEN '厚尾分布（极端事件概率高）'
        WHEN kurtosis < -1 THEN '薄尾分布'
        ELSE '近似正态分布'
    END AS tail_risk
FROM return_statistics
ORDER BY mean_return DESC;
```

---

## 6. PostgreSQL 18并行描述性统计

### 6.1 并行描述性统计概述

**PostgreSQL 18并行描述性统计**：利用PostgreSQL 18的并行查询能力，显著提升大规模描述性统计计算的性能。

#### 并行描述性统计配置

```sql
-- 配置并行描述性统计参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行聚合成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行描述性统计参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行描述性统计配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 并行描述性统计实现

```sql
-- 并行描述性统计：大规模数据综合统计（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行描述性统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行描述性统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行综合描述性统计
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    column_name,
    COUNT(*) AS count,
    ROUND(AVG(column_value)::numeric, 4) AS mean,
    ROUND(STDDEV(column_value)::numeric, 4) AS stddev,
    ROUND(MIN(column_value)::numeric, 4) AS min_value,
    ROUND(MAX(column_value)::numeric, 4) AS max_value,
    ROUND(PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY column_value)::numeric, 4) AS q1,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY column_value)::numeric, 4) AS median,
    ROUND(PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY column_value)::numeric, 4) AS q3
FROM data_table
GROUP BY column_name
ORDER BY column_name;
```

---

## 7. 算法性能对比与优化

### 7.1 统计量选择指南

| 数据特征 | 推荐中心趋势 | 推荐离散度量 | 原因 |
|---------|------------|------------|------|
| **正态分布** | 均值 | 标准差 | 充分利用信息 |
| **偏态分布** | 中位数 | IQR | 稳健性 |
| **有异常值** | 中位数 | IQR | 不受异常值影响 |
| **分类数据** | 众数 | - | 唯一适用 |
| **比率数据** | 几何平均数 | 变异系数 | 相对度量 |

### 7.2 性能优化建议

1. **索引优化**：在分组字段和排序字段上创建索引
2. **并行计算**：利用PostgreSQL并行聚合加速计算
3. **物化视图**：对于频繁查询的统计结果，使用物化视图缓存
4. **采样策略**：对于超大规模数据，使用随机采样进行初步分析

### 7.3 常见问题与解决方案

**问题1**：均值和中位数差异很大

- **原因**：数据偏态分布或有异常值
- **解决方案**：使用中位数和IQR，或处理异常值

**问题2**：标准差很大

- **原因**：数据离散程度高或存在异常值
- **解决方案**：检查异常值，使用IQR或稳健统计量

**问题3**：偏度接近0但峰度很大

- **原因**：数据对称但尾部较厚
- **解决方案**：注意极端事件的风险，使用稳健方法

---

## 8. 最佳实践

### 7.1 统计量选择

1. **中心趋势**：
   - 正态分布：使用均值
   - 偏态分布：使用中位数
   - 分类数据：使用众数

2. **离散程度**：
   - 正态分布：使用标准差
   - 偏态分布：使用IQR
   - 不同量级：使用变异系数

3. **分布形状**：
   - 检查偏度和峰度
   - 决定是否使用参数方法

### 8.2 异常值处理

1. **识别方法**：
   - IQR方法：$Q_1 - 1.5 \times IQR$ 和 $Q_3 + 1.5 \times IQR$
   - Z-score方法：$|z| > 3$
   - 百分位数方法：< 1% 或 > 99%

2. **处理方法**：
   - 删除异常值（如果确认是错误）
   - 使用稳健统计量（中位数、IQR）
   - 数据变换（对数变换）

### 8.3 报告格式

1. **基本统计量**：
   - 样本量（n）
   - 均值、中位数、标准差
   - 最小值、最大值、四分位数

2. **分布特征**：
   - 偏度、峰度
   - 分布形状描述

3. **可视化**：
   - 直方图、箱线图
   - Q-Q图（正态性检验）

### 8.4 SQL实现注意事项

1. **NULL值处理**：使用 `WHERE column IS NOT NULL` 过滤
2. **除零错误**：使用 `NULLIF()` 函数
3. **精度问题**：使用 `NUMERIC` 类型保持精度
4. **性能考虑**：对于大规模数据，考虑采样或并行处理

### 8.5 PostgreSQL 18 新特性应用（增强）

**PostgreSQL 18**引入了多项增强功能，可以显著提升描述性统计计算的性能：

1. **Skip Scan优化**：
   - 对于包含统计值的索引，Skip Scan可以跳过不必要的索引扫描
   - 特别适用于Top-N统计查询和分位数查询

2. **异步I/O增强**：
   - 对于大规模描述性统计计算，异步I/O可以显著提升性能
   - 适用于批量统计计算和多维度分析

3. **并行查询增强**：
   - 描述性统计计算支持更好的并行执行
   - 适用于大规模聚合统计和分组统计

**示例：使用Skip Scan优化统计查询**

```sql
-- 为统计值创建Skip Scan优化索引
CREATE INDEX IF NOT EXISTS idx_statistical_values_skip_scan
ON statistical_data(variable_name, value DESC);

-- Skip Scan优化查询：查找每个变量的最大值
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (variable_name)
    variable_name,
    value AS max_value,
    sample_id
FROM statistical_data
ORDER BY variable_name, value DESC;
```

### 8.6 高级优化技巧（增强）

**1. 使用物化视图缓存描述性统计结果**

对于频繁使用的描述性统计结果，使用物化视图缓存：

```sql
-- 创建物化视图缓存描述性统计结果
CREATE MATERIALIZED VIEW IF NOT EXISTS descriptive_statistics_cache AS
WITH statistical_summary AS (
    SELECT
        variable_name,
        COUNT(*) AS sample_count,
        COUNT(*) FILTER (WHERE value IS NOT NULL) AS valid_count,
        -- 中心趋势
        AVG(value) AS mean_value,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) AS median_value,
        MODE() WITHIN GROUP (ORDER BY value) AS mode_value,
        -- 离散程度
        STDDEV(value) AS stddev_value,
        VARIANCE(value) AS variance_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        MAX(value) - MIN(value) AS range_value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS q1_value,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) AS q3_value,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS iqr_value,
        -- 使用窗口函数计算变异系数（避免重复计算）
        CASE
            WHEN AVG(value) != 0 THEN STDDEV(value) / ABS(AVG(value))
            ELSE NULL
        END AS coefficient_of_variation
    FROM statistical_data
    WHERE value IS NOT NULL
    GROUP BY variable_name
)
SELECT
    variable_name,
    sample_count,
    valid_count,
    ROUND(mean_value::numeric, 4) AS mean,
    ROUND(median_value::numeric, 4) AS median,
    mode_value,
    ROUND(stddev_value::numeric, 4) AS stddev,
    ROUND(variance_value::numeric, 6) AS variance,
    min_value,
    max_value,
    range_value,
    ROUND(q1_value::numeric, 4) AS q1,
    ROUND(q3_value::numeric, 4) AS q3,
    ROUND(iqr_value::numeric, 4) AS iqr,
    ROUND(coefficient_of_variation::numeric, 4) AS cv
FROM statistical_summary;

-- 创建索引加速物化视图查询
CREATE INDEX idx_descriptive_statistics_cache_variable ON descriptive_statistics_cache(variable_name);
CREATE INDEX idx_descriptive_statistics_cache_mean ON descriptive_statistics_cache(mean DESC);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY descriptive_statistics_cache;
```

**2. 实时统计监控：增量描述性统计更新**

**实时统计监控**：使用增量方法实时更新描述性统计。

```sql
-- 实时统计监控：增量描述性统计更新（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'statistical_state') THEN
            CREATE TABLE statistical_state (
                variable_name VARCHAR(100) PRIMARY KEY,
                sample_count BIGINT DEFAULT 0,
                sum_value NUMERIC DEFAULT 0,
                sum_squared_value NUMERIC DEFAULT 0,
                min_value NUMERIC,
                max_value NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_statistical_state_variable ON statistical_state(variable_name);
            CREATE INDEX idx_statistical_state_updated ON statistical_state(last_updated DESC);

            RAISE NOTICE '统计状态表创建成功';
        END IF;

        RAISE NOTICE '开始执行增量描述性统计更新';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '增量描述性统计更新准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 增量更新描述性统计：实时统计监控
WITH new_samples AS (
    SELECT
        variable_name,
        value
    FROM statistical_data
    WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM statistical_state)
      AND value IS NOT NULL
),
updated_statistics AS (
    SELECT
        COALESCE(ss.variable_name, ns.variable_name) AS variable_name,
        COALESCE(ss.sample_count, 0) + COUNT(*) AS new_sample_count,
        COALESCE(ss.sum_value, 0) + SUM(ns.value) AS new_sum_value,
        COALESCE(ss.sum_squared_value, 0) + SUM(POWER(ns.value, 2)) AS new_sum_squared_value,
        LEAST(COALESCE(ss.min_value, ns.value), MIN(ns.value)) AS new_min_value,
        GREATEST(COALESCE(ss.max_value, ns.value), MAX(ns.value)) AS new_max_value
    FROM statistical_state ss
    FULL OUTER JOIN new_samples ns ON ss.variable_name = ns.variable_name
    GROUP BY ss.variable_name, ns.variable_name, ss.sample_count, ss.sum_value, ss.sum_squared_value, ss.min_value, ss.max_value
)
-- 更新或插入统计状态
INSERT INTO statistical_state (
    variable_name,
    sample_count,
    sum_value,
    sum_squared_value,
    min_value,
    max_value,
    last_updated
)
SELECT
    variable_name,
    new_sample_count,
    new_sum_value,
    new_sum_squared_value,
    new_min_value,
    new_max_value,
    NOW()
FROM updated_statistics
ON CONFLICT (variable_name)
DO UPDATE SET
    sample_count = EXCLUDED.sample_count,
    sum_value = EXCLUDED.sum_value,
    sum_squared_value = EXCLUDED.sum_squared_value,
    min_value = EXCLUDED.min_value,
    max_value = EXCLUDED.max_value,
    last_updated = NOW();
```

**3. 异常值检测：基于描述性统计的异常检测**

**异常值检测**：使用描述性统计方法检测异常值。

```sql
-- 异常值检测：基于描述性统计的异常检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'statistical_data') THEN
            RAISE WARNING '表 statistical_data 不存在，无法执行异常值检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行异常值检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '异常值检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 异常值检测：使用IQR方法和Z-score方法
WITH statistical_summary AS (
    SELECT
        variable_name,
        AVG(value) AS mean_value,
        STDDEV(value) AS stddev_value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS q1_value,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) AS q3_value,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS iqr_value
    FROM statistical_data
    WHERE value IS NOT NULL
    GROUP BY variable_name
),
anomaly_detection AS (
    SELECT
        sd.sample_id,
        sd.variable_name,
        sd.value,
        ss.mean_value,
        ss.stddev_value,
        ss.q1_value,
        ss.q3_value,
        ss.iqr_value,
        -- Z-score方法
        CASE
            WHEN ss.stddev_value > 0 THEN
                ABS((sd.value - ss.mean_value) / ss.stddev_value)
            ELSE NULL
        END AS z_score,
        -- IQR方法
        CASE
            WHEN sd.value < ss.q1_value - 1.5 * ss.iqr_value OR
                 sd.value > ss.q3_value + 1.5 * ss.iqr_value THEN TRUE
            ELSE FALSE
        END AS is_iqr_outlier
    FROM statistical_data sd
    JOIN statistical_summary ss ON sd.variable_name = ss.variable_name
    WHERE sd.value IS NOT NULL
)
SELECT
    sample_id,
    variable_name,
    ROUND(value::numeric, 4) AS value,
    ROUND(mean_value::numeric, 4) AS mean_value,
    ROUND(stddev_value::numeric, 4) AS stddev_value,
    ROUND(z_score::numeric, 4) AS z_score,
    is_iqr_outlier,
    CASE
        WHEN z_score > 3 THEN 'Extreme Outlier (Z-score > 3)'
        WHEN z_score > 2 THEN 'Moderate Outlier (Z-score > 2)'
        WHEN is_iqr_outlier THEN 'IQR Outlier'
        ELSE 'Normal'
    END AS anomaly_status,
    CASE
        WHEN z_score > 3 OR is_iqr_outlier THEN 'Critical Alert'
        WHEN z_score > 2 THEN 'Warning Alert'
        ELSE 'Normal'
    END AS alert_level
FROM anomaly_detection
WHERE z_score > 2 OR is_iqr_outlier = TRUE
ORDER BY z_score DESC NULLS LAST
LIMIT 50;
```

---

## 📚 参考资源

### 学术文献

1. **Pearson, K. (1895)**: "Contributions to the Mathematical Theory of Evolution", *Philosophical Transactions of the Royal Society*.

2. **Fisher, R.A. (1925)**: "Statistical Methods for Research Workers", Oliver and Boyd.

3. **《统计学》**（贾俊平，2018）- 第3章 数据的描述性统计

4. **《统计学习方法》**（李航，2012）- 第1章 统计学习及监督学习概论

5. **《数据挖掘：概念与技术》**（Han, Kamber, Pei, 2012）- Chapter 2: Getting to Know Your Data

### PostgreSQL官方文档

- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **统计函数**: <https://www.postgresql.org/docs/current/functions-math.html>

### 在线资源

- **R语言描述性统计**: <https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary>
- **Python pandas描述性统计**: <https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html>
- **统计可视化**: <https://seeing-theory.brown.edu/>

### 相关算法

- **推断性统计**：假设检验、置信区间
- **探索性数据分析（EDA）**：数据可视化、模式识别
- **异常检测**：基于统计量的异常值识别
- **数据质量评估**：使用描述性统计评估数据质量

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
