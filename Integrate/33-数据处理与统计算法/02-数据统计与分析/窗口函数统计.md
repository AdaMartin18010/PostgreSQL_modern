# PostgreSQL 窗口函数统计完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 窗口函数 | 排名分析
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 窗口函数统计完整指南](#postgresql-窗口函数统计完整指南)
  - [📋 目录](#-目录)
  - [窗口函数统计概述](#窗口函数统计概述)
    - [理论基础](#理论基础)
      - [窗口函数定义](#窗口函数定义)
      - [窗口框架（Window Frame）](#窗口框架window-frame)
      - [窗口函数分类](#窗口函数分类)
    - [核心窗口函数](#核心窗口函数)
  - [1. 排名函数](#1-排名函数)
    - [1.1 排名函数原理](#11-排名函数原理)
      - [ROW\_NUMBER()](#row_number)
      - [RANK()](#rank)
      - [DENSE\_RANK()](#dense_rank)
      - [PERCENT\_RANK()](#percent_rank)
      - [CUME\_DIST()](#cume_dist)
    - [1.2 排名函数实现](#12-排名函数实现)
  - [2. 窗口聚合](#2-窗口聚合)
    - [2.1 窗口聚合原理](#21-窗口聚合原理)
      - [窗口框架类型](#窗口框架类型)
    - [2.2 窗口聚合实现](#22-窗口聚合实现)
  - [3. 偏移函数](#3-偏移函数)
    - [3.1 偏移函数原理](#31-偏移函数原理)
      - [LAG()](#lag)
      - [LEAD()](#lead)
      - [FIRST\_VALUE()](#first_value)
      - [LAST\_VALUE()](#last_value)
      - [NTH\_VALUE()](#nth_value)
    - [3.2 偏移函数实现](#32-偏移函数实现)
  - [4. 窗口框架详解](#4-窗口框架详解)
    - [4.1 ROWS框架](#41-rows框架)
    - [4.2 RANGE框架](#42-range框架)
    - [4.3 GROUPS框架](#43-groups框架)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 销售趋势分析](#51-销售趋势分析)
    - [5.2 员工排名分析](#52-员工排名分析)
    - [5.3 客户行为分析](#53-客户行为分析)
    - [5.4 市场份额分析](#54-市场份额分析)
    - [5.5 时间序列平滑](#55-时间序列平滑)
  - [6. PostgreSQL 18并行窗口函数](#6-postgresql-18并行窗口函数)
    - [6.1 并行窗口函数概述](#61-并行窗口函数概述)
      - [并行窗口函数配置](#并行窗口函数配置)
      - [并行窗口函数实现](#并行窗口函数实现)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 窗口函数性能](#71-窗口函数性能)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 窗口函数选择](#81-窗口函数选择)
    - [8.2 窗口框架选择](#82-窗口框架选择)
    - [8.3 SQL实现注意事项](#83-sql实现注意事项)
    - [8.4 PostgreSQL 18 新特性应用（增强）](#84-postgresql-18-新特性应用增强)
    - [8.5 高级优化技巧（增强）](#85-高级优化技巧增强)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 窗口函数统计概述

**窗口函数（Window Functions）**是PostgreSQL中强大的分析工具，允许在查询结果集的"窗口"上执行计算，而不会将行合并成单个输出行。窗口函数在数据分析、排名、趋势分析等场景中非常有用。

### 理论基础

#### 窗口函数定义

**窗口函数**对一组相关的行（窗口）执行计算，返回每行的结果，而不是将行合并。

**基本语法**：

```sql
function_name([arguments]) OVER (
    [PARTITION BY partition_expression]
    [ORDER BY sort_expression [ASC|DESC]]
    [frame_clause]
)
```

#### 窗口框架（Window Frame）

**窗口框架**定义窗口函数计算的行范围：

1. **ROWS**：基于行的物理位置
   - `ROWS BETWEEN n PRECEDING AND m FOLLOWING`
   - `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`
   - `ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING`

2. **RANGE**：基于值的范围
   - `RANGE BETWEEN n PRECEDING AND m FOLLOWING`
   - `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

3. **GROUPS**（PostgreSQL 11+）：基于组
   - `GROUPS BETWEEN n PRECEDING AND m FOLLOWING`

#### 窗口函数分类

1. **排名函数**：ROW_NUMBER、RANK、DENSE_RANK、PERCENT_RANK、CUME_DIST
2. **聚合函数**：SUM、AVG、COUNT、MAX、MIN等（OVER子句）
3. **偏移函数**：LAG、LEAD、FIRST_VALUE、LAST_VALUE、NTH_VALUE
4. **分布函数**：PERCENT_RANK、CUME_DIST

### 核心窗口函数

| 函数类型 | 函数名称 | 用途 | 是否支持框架 |
|---------|---------|------|------------|
| **排名** | ROW_NUMBER(), RANK(), DENSE_RANK() | 排名分析 | 否 |
| **排名** | PERCENT_RANK(), CUME_DIST() | 百分比排名 | 否 |
| **聚合** | SUM(), AVG(), COUNT() OVER | 窗口聚合 | 是 |
| **偏移** | LAG(), LEAD() | 前后值比较 | 否 |
| **偏移** | FIRST_VALUE(), LAST_VALUE(), NTH_VALUE() | 首尾值 | 是 |

---

## 1. 排名函数

### 1.1 排名函数原理

**排名函数**为结果集中的每一行分配一个排名，根据ORDER BY子句指定的排序规则。

#### ROW_NUMBER()

**ROW_NUMBER()**为每一行分配唯一的连续整数，即使值相同也分配不同序号。

**特点**：总是产生连续的数字，没有并列。

#### RANK()

**RANK()**为相同值的行分配相同的排名，下一个排名会跳过相应的位置。

**示例**：如果有两个第1名，下一个排名是第3名。

#### DENSE_RANK()

**DENSE_RANK()**为相同值的行分配相同的排名，但下一个排名是连续的。

**示例**：如果有两个第1名，下一个排名是第2名。

#### PERCENT_RANK()

**PERCENT_RANK()**计算行的相对排名，范围[0, 1]：
$$\text{PERCENT_RANK} = \frac{\text{RANK} - 1}{\text{总行数} - 1}$$

#### CUME_DIST()

**CUME_DIST()**计算累积分布，范围(0, 1]：
$$\text{CUME_DIST} = \frac{\text{小于等于当前值的行数}}{\text{总行数}}$$

### 1.2 排名函数实现

```sql
-- 排名函数（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'employees') THEN
            RAISE WARNING '表 employees 不存在';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行排名函数统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '排名函数准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 完整排名函数示例
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    name,
    salary,
    department,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_number,
    RANK() OVER (ORDER BY salary DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS dense_rank,
    PERCENT_RANK() OVER (ORDER BY salary DESC) AS percent_rank,
    CUME_DIST() OVER (ORDER BY salary DESC) AS cume_dist,
    -- 按部门分组排名
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_row_number,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank
FROM employees
ORDER BY salary DESC;
```

---

## 2. 窗口聚合

### 2.1 窗口聚合原理

**窗口聚合函数**在窗口框架内执行聚合计算，与普通聚合函数不同，窗口聚合不会将行合并。

#### 窗口框架类型

1. **ROWS**：基于行的物理位置
   - `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW`：当前行和前2行
   - `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`：从开始到当前行
   - `ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING`：从当前行到结束

2. **RANGE**：基于值的范围
   - `RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW`：7天内的值

3. **GROUPS**：基于组（PostgreSQL 11+）
   - `GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING`：前一组和后一组

### 2.2 窗口聚合实现

```sql
-- 窗口聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行窗口聚合统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '窗口聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 移动平均和累计和
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    amount,
    -- 7日移动平均（ROWS）
    AVG(amount) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg_7_rows,
    -- 7日移动和
    SUM(amount) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_sum_7,
    -- 累计和
    SUM(amount) OVER (ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,
    -- 累计平均
    AVG(amount) OVER (ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_avg,
    -- 总体统计
    SUM(amount) OVER () AS total_sum,
    AVG(amount) OVER () AS overall_avg,
    COUNT(*) OVER () AS total_count
FROM sales
ORDER BY date;
```

---

## 3. 偏移函数

### 3.1 偏移函数原理

**偏移函数**访问当前行之前或之后的行，用于比较和趋势分析。

#### LAG()

**LAG(column, offset, default)**返回当前行之前第offset行的值。

**用途**：计算与前一行/前N行的差值、增长率等。

#### LEAD()

**LEAD(column, offset, default)**返回当前行之后第offset行的值。

**用途**：计算与后一行/后N行的差值、预测等。

#### FIRST_VALUE()

**FIRST_VALUE(column)**返回窗口框架内的第一个值。

#### LAST_VALUE()

**LAST_VALUE(column)**返回窗口框架内的最后一个值。

#### NTH_VALUE()

**NTH_VALUE(column, n)**返回窗口框架内的第n个值。

### 3.2 偏移函数实现

```sql
-- 偏移函数：前后值比较和趋势分析
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    amount,
    -- 前一日值
    LAG(amount, 1) OVER (ORDER BY date) AS prev_amount,
    -- 前7日值
    LAG(amount, 7) OVER (ORDER BY date) AS prev_7days_amount,
    -- 后一日值
    LEAD(amount, 1) OVER (ORDER BY date) AS next_amount,
    -- 日环比增长率
    (amount - LAG(amount, 1) OVER (ORDER BY date)) * 100.0 /
        NULLIF(LAG(amount, 1) OVER (ORDER BY date), 0) AS day_over_day_growth,
    -- 周同比增长率
    (amount - LAG(amount, 7) OVER (ORDER BY date)) * 100.0 /
        NULLIF(LAG(amount, 7) OVER (ORDER BY date), 0) AS week_over_week_growth,
    -- 窗口内第一个值
    FIRST_VALUE(amount) OVER (ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS first_value,
    -- 窗口内最后一个值
    LAST_VALUE(amount) OVER (ORDER BY date ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS last_value
FROM sales
ORDER BY date;
```

---

## 4. 窗口框架详解

### 4.1 ROWS框架

**ROWS框架**基于行的物理位置定义窗口。

```sql
-- ROWS框架示例（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    date,
    amount,
    -- 当前行和前2行
    SUM(amount) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS sum_3rows,
    -- 当前行和后2行
    SUM(amount) OVER (ORDER BY date ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS sum_next_3rows,
    -- 前后各1行
    AVG(amount) OVER (ORDER BY date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS avg_3rows
FROM sales
ORDER BY date;
```

### 4.2 RANGE框架

**RANGE框架**基于值的范围定义窗口。

```sql
-- RANGE框架示例：基于日期范围（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    date,
    amount,
    -- 7天内的累计和
    SUM(amount) OVER (
        ORDER BY date
        RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW
    ) AS sum_7days,
    -- 30天内的移动平均
    AVG(amount) OVER (
        ORDER BY date
        RANGE BETWEEN INTERVAL '30 days' PRECEDING AND CURRENT ROW
    ) AS avg_30days
FROM sales
ORDER BY date;
```

### 4.3 GROUPS框架

**GROUPS框架**（PostgreSQL 11+）基于组定义窗口。

```sql
-- GROUPS框架示例（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    date,
    amount,
    -- 前一组和后一组
    AVG(amount) OVER (
        ORDER BY date
        GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS avg_neighbor_groups
FROM sales
ORDER BY date;
```

---

## 5. 实际应用案例

### 5.1 销售趋势分析

**场景**：分析销售数据的趋势和变化。

```sql
-- 销售趋势分析：使用窗口函数
WITH sales_trends AS (
    SELECT
        date,
        amount,
        -- 移动平均
        AVG(amount) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS moving_avg_7,
        -- 日环比
        LAG(amount, 1) OVER (ORDER BY date) AS prev_day,
        -- 周同比
        LAG(amount, 7) OVER (ORDER BY date) AS prev_week,
        -- 月同比
        LAG(amount, 30) OVER (ORDER BY date) AS prev_month,
        -- 累计和
        SUM(amount) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS cumulative_sum
    FROM sales
)
SELECT
    date,
    amount,
    ROUND(moving_avg_7::numeric, 2) AS moving_avg_7,
    prev_day,
    prev_week,
    prev_month,
    cumulative_sum,
    -- 增长率
    ROUND((amount - prev_day) * 100.0 / NULLIF(prev_day, 0), 2) AS day_growth_pct,
    ROUND((amount - prev_week) * 100.0 / NULLIF(prev_week, 0), 2) AS week_growth_pct
FROM sales_trends
ORDER BY date;
```

### 5.2 员工排名分析

**场景**：分析员工在不同维度的排名。

```sql
-- 员工排名分析：多维度排名
SELECT
    employee_id,
    name,
    department,
    salary,
    -- 全局排名
    RANK() OVER (ORDER BY salary DESC) AS global_rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS global_dense_rank,
    PERCENT_RANK() OVER (ORDER BY salary DESC) AS global_percent_rank,
    -- 部门内排名
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank,
    -- 部门内百分比排名
    PERCENT_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_percent_rank,
    -- 部门内累计分布
    CUME_DIST() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_cume_dist
FROM employees
ORDER BY department, salary DESC;
```

### 5.3 客户行为分析

**场景**：分析客户购买行为的模式和趋势。

```sql
-- 客户行为分析：使用窗口函数
WITH customer_behavior AS (
    SELECT
        customer_id,
        order_date,
        order_amount,
        -- 客户累计消费
        SUM(order_amount) OVER (
            PARTITION BY customer_id
            ORDER BY order_date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS cumulative_spend,
        -- 客户订单数
        ROW_NUMBER() OVER (
            PARTITION BY customer_id
            ORDER BY order_date
        ) AS order_number,
        -- 距离上次购买天数
        order_date - LAG(order_date, 1) OVER (
            PARTITION BY customer_id
            ORDER BY order_date
        ) AS days_since_last_order,
        -- 客户平均订单金额
        AVG(order_amount) OVER (PARTITION BY customer_id) AS avg_order_amount
    FROM orders
)
SELECT
    customer_id,
    order_date,
    order_amount,
    cumulative_spend,
    order_number,
    days_since_last_order,
    avg_order_amount,
    CASE
        WHEN days_since_last_order IS NULL THEN 'New customer'
        WHEN days_since_last_order <= 30 THEN 'Active'
        WHEN days_since_last_order <= 90 THEN 'At risk'
        ELSE 'Churned'
    END AS customer_status
FROM customer_behavior
ORDER BY customer_id, order_date;
```

### 5.4 市场份额分析

**场景**：分析产品在市场上的份额和排名。

```sql
-- 市场份额分析：使用窗口函数
WITH market_share AS (
    SELECT
        product_id,
        product_name,
        category,
        sales_amount,
        -- 类别内排名
        RANK() OVER (PARTITION BY category ORDER BY sales_amount DESC) AS category_rank,
        -- 类别内市场份额
        sales_amount * 100.0 / SUM(sales_amount) OVER (PARTITION BY category) AS category_market_share,
        -- 总体排名
        RANK() OVER (ORDER BY sales_amount DESC) AS overall_rank,
        -- 总体市场份额
        sales_amount * 100.0 / SUM(sales_amount) OVER () AS overall_market_share,
        -- 累计市场份额
        SUM(sales_amount) OVER (
            ORDER BY sales_amount DESC
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) * 100.0 / SUM(sales_amount) OVER () AS cumulative_market_share
    FROM product_sales
)
SELECT
    product_id,
    product_name,
    category,
    sales_amount,
    category_rank,
    ROUND(category_market_share::numeric, 2) AS category_market_share_pct,
    overall_rank,
    ROUND(overall_market_share::numeric, 2) AS overall_market_share_pct,
    ROUND(cumulative_market_share::numeric, 2) AS cumulative_market_share_pct
FROM market_share
ORDER BY overall_rank;
```

### 5.5 时间序列平滑

**场景**：使用窗口函数对时间序列数据进行平滑处理。

```sql
-- 时间序列平滑：移动平均和指数加权
WITH time_series AS (
    SELECT
        date,
        value,
        -- 简单移动平均（SMA）
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS sma_7,
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS sma_30,
        -- 加权移动平均（WMA）- 简化实现
        (
            value * 7 +
            LAG(value, 1, value) OVER (ORDER BY date) * 6 +
            LAG(value, 2, value) OVER (ORDER BY date) * 5 +
            LAG(value, 3, value) OVER (ORDER BY date) * 4 +
            LAG(value, 4, value) OVER (ORDER BY date) * 3 +
            LAG(value, 5, value) OVER (ORDER BY date) * 2 +
            LAG(value, 6, value) OVER (ORDER BY date) * 1
        ) / 28.0 AS wma_7,
        -- 累计平均
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS cumulative_avg
    FROM time_series_data
)
SELECT
    date,
    value,
    ROUND(sma_7::numeric, 2) AS sma_7,
    ROUND(sma_30::numeric, 2) AS sma_30,
    ROUND(wma_7::numeric, 2) AS wma_7,
    ROUND(cumulative_avg::numeric, 2) AS cumulative_avg
FROM time_series
ORDER BY date;
```

---

## 6. PostgreSQL 18并行窗口函数

### 6.1 并行窗口函数概述

**PostgreSQL 18并行窗口函数**：利用PostgreSQL 18的并行查询能力，显著提升大规模窗口函数计算的性能。

#### 并行窗口函数配置

```sql
-- 配置并行窗口函数参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行聚合成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行窗口函数参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行窗口函数配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 并行窗口函数实现

```sql
-- 并行窗口函数：大规模数据排名和聚合（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行窗口函数计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行窗口函数准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行窗口排名和移动平均
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    category,
    product_id,
    sales_amount,
    ROW_NUMBER() OVER (PARTITION BY category ORDER BY sales_amount DESC) AS rank_in_category,
    RANK() OVER (PARTITION BY category ORDER BY sales_amount DESC) AS rank_with_ties,
    AVG(sales_amount) OVER (
        PARTITION BY category
        ORDER BY sales_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7days,
    SUM(sales_amount) OVER (
        PARTITION BY category
        ORDER BY sales_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_sales
FROM sales_data
WHERE sales_date >= CURRENT_DATE - INTERVAL '1 year'
ORDER BY category, sales_amount DESC;
```

---

## 7. 算法性能对比与优化

### 7.1 窗口函数性能

| 窗口函数类型 | 性能 | 内存需求 | 适用场景 |
|------------|------|---------|---------|
| **排名函数** | 快 | 低 | 排名分析 |
| **窗口聚合** | 中 | 中 | 移动平均、累计和 |
| **偏移函数** | 快 | 低 | 前后值比较 |
| **RANGE框架** | 慢 | 高 | 基于值的范围 |

### 7.2 性能优化建议

1. **索引优化**：
   - 在PARTITION BY和ORDER BY列上创建索引
   - 使用覆盖索引减少回表

2. **窗口框架优化**：
   - 优先使用ROWS框架（性能更好）
   - 避免过大的窗口框架
   - 使用有界窗口（BETWEEN ... AND ...）

3. **查询优化**：
   - 使用LIMIT限制结果集
   - 避免不必要的窗口函数嵌套
   - 考虑使用物化视图

4. **内存管理**：
   - 监控work_mem使用
   - 对于大窗口，考虑分批处理

### 7.3 常见问题与解决方案

**问题1**：窗口函数性能慢

- **解决方案**：创建索引、优化窗口框架、使用ROWS替代RANGE

**问题2**：窗口框架理解困难

- **解决方案**：理解ROWS/RANGE/GROUPS的区别、使用简单框架、逐步测试

**问题3**：NULL值处理

- **解决方案**：使用COALESCE、NULLS FIRST/LAST、处理默认值

**问题4**：分区性能差

- **解决方案**：优化PARTITION BY列、创建分区索引、减少分区数

---

## 8. 最佳实践

### 8.1 窗口函数选择

1. **排名需求**：
   - 唯一排名：ROW_NUMBER
   - 允许并列：RANK或DENSE_RANK
   - 百分比排名：PERCENT_RANK

2. **聚合需求**：
   - 移动平均：AVG + ROWS框架
   - 累计和：SUM + UNBOUNDED PRECEDING
   - 总体统计：聚合函数 + OVER()

3. **比较需求**：
   - 前后值：LAG/LEAD
   - 首尾值：FIRST_VALUE/LAST_VALUE
   - 第N值：NTH_VALUE

### 8.2 窗口框架选择

1. **ROWS框架**：
   - 基于行的物理位置
   - 性能最好
   - 适合固定行数的窗口

2. **RANGE框架**：
   - 基于值的范围
   - 适合时间序列
   - 性能较慢

3. **GROUPS框架**：
   - 基于组
   - PostgreSQL 11+
   - 适合分组数据

### 8.3 SQL实现注意事项

1. **ORDER BY**：
   - 排名函数必须使用ORDER BY
   - 窗口聚合建议使用ORDER BY
   - 确保排序稳定

2. **PARTITION BY**：
   - 用于分组计算
   - 可以多列分区
   - 影响性能

3. **窗口框架**：
   - 默认框架：ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
   - 明确指定框架避免歧义
   - 注意边界情况

4. **性能测试**：
   - 使用EXPLAIN (ANALYZE, BUFFERS, TIMING)分析
   - 监控执行时间
   - 优化慢查询

### 8.4 PostgreSQL 18 新特性应用（增强）

**PostgreSQL 18**引入了多项增强功能，可以显著提升窗口函数统计的性能：

1. **Skip Scan优化**：
   - 对于包含窗口函数排序键的索引，Skip Scan可以跳过不必要的索引扫描
   - 特别适用于Top-N排名查询和窗口框架查询

2. **异步I/O增强**：
   - 对于大规模窗口函数计算，异步I/O可以显著提升性能
   - 适用于批量窗口函数计算和复杂窗口框架

3. **并行查询增强**：
   - 窗口函数计算支持更好的并行执行（有限支持，因为窗口函数的并行化限制）
   - 适用于独立窗口函数计算和聚合窗口函数

**示例：使用Skip Scan优化窗口函数查询**

```sql
-- 为窗口函数排序键创建Skip Scan优化索引
CREATE INDEX IF NOT EXISTS idx_window_stats_skip_scan
ON sales_data(customer_id, sale_date DESC, amount DESC);

-- Skip Scan优化查询：查找每个客户最近购买金额最高的前5个订单
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    customer_id,
    order_id,
    sale_date,
    amount,
    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY sale_date DESC, amount DESC) AS purchase_rank
FROM sales_data
WHERE ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY sale_date DESC, amount DESC) <= 5
ORDER BY customer_id, sale_date DESC, amount DESC
LIMIT 50;
```

### 8.5 高级优化技巧（增强）

**1. 使用物化视图缓存窗口函数统计结果**

对于频繁使用的窗口函数统计结果，使用物化视图缓存：

```sql
-- 创建物化视图缓存窗口函数统计结果
CREATE MATERIALIZED VIEW IF NOT EXISTS window_statistics_cache AS
WITH ranked_sales AS (
    SELECT
        customer_id,
        order_id,
        sale_date,
        amount,
        category,
        -- 使用窗口函数计算排名和累计值（避免重复计算）
        ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY sale_date DESC) AS purchase_rank,
        SUM(amount) OVER (PARTITION BY customer_id ORDER BY sale_date DESC) AS cumulative_spending,
        AVG(amount) OVER (PARTITION BY customer_id ORDER BY sale_date DESC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg_3,
        LAG(amount, 1) OVER (PARTITION BY customer_id ORDER BY sale_date DESC) AS prev_amount,
        LEAD(amount, 1) OVER (PARTITION BY customer_id ORDER BY sale_date DESC) AS next_amount
    FROM sales_data
    WHERE sale_date >= CURRENT_DATE - INTERVAL '90 days'
)
SELECT
    customer_id,
    order_id,
    sale_date,
    amount,
    category,
    purchase_rank,
    ROUND(cumulative_spending::numeric, 2) AS cumulative_spending,
    ROUND(moving_avg_3::numeric, 2) AS moving_avg_3,
    prev_amount,
    next_amount,
    -- 使用窗口函数计算变化率（避免重复计算）
    CASE
        WHEN prev_amount > 0 THEN
            ROUND(((amount - prev_amount) / prev_amount * 100)::numeric, 2)
        ELSE NULL
    END AS amount_change_pct
FROM ranked_sales
WHERE purchase_rank <= 10;  -- 只保留每个客户的前10个订单

-- 创建索引加速物化视图查询
CREATE INDEX idx_window_statistics_cache_customer_rank ON window_statistics_cache(customer_id, purchase_rank);
CREATE INDEX idx_window_statistics_cache_date ON window_statistics_cache(sale_date DESC);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY window_statistics_cache;
```

**2. 实时窗口统计：增量窗口函数更新**

**实时窗口统计**：对于实时数据，使用增量方法更新窗口函数结果。

```sql
-- 实时窗口统计：增量窗口函数更新（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'window_statistics_state') THEN
            CREATE TABLE window_statistics_state (
                customer_id INTEGER NOT NULL,
                window_type VARCHAR(50) NOT NULL,  -- 'cumulative', 'moving_avg', 'rank'
                window_value NUMERIC,
                window_metadata JSONB,  -- 存储窗口相关的元数据
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (customer_id, window_type)
            );

            CREATE INDEX idx_window_statistics_state_customer ON window_statistics_state(customer_id, window_type);
            CREATE INDEX idx_window_statistics_state_updated ON window_statistics_state(last_updated DESC);

            RAISE NOTICE '窗口统计状态表创建成功';
        END IF;

        RAISE NOTICE '开始执行增量窗口函数更新';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '增量窗口函数更新准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 增量更新窗口统计：实时窗口统计
WITH new_sales AS (
    SELECT
        customer_id,
        order_id,
        sale_date,
        amount
    FROM sales_data
    WHERE sale_date > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM window_statistics_state)
      AND sale_date <= CURRENT_DATE
),
customer_cumulative_stats AS (
    SELECT
        customer_id,
        'cumulative' AS window_type,
        SUM(amount) OVER (PARTITION BY customer_id ORDER BY sale_date) AS cumulative_value,
        jsonb_build_object(
            'last_order_date', MAX(sale_date) OVER (PARTITION BY customer_id),
            'order_count', COUNT(*) OVER (PARTITION BY customer_id)
        ) AS window_metadata
    FROM new_sales
    WHERE sale_date = (SELECT MAX(sale_date) FROM new_sales WHERE new_sales.customer_id = customer_id)
)
-- 更新或插入窗口统计状态
INSERT INTO window_statistics_state (customer_id, window_type, window_value, window_metadata, last_updated)
SELECT DISTINCT ON (customer_id, window_type)
    customer_id,
    window_type,
    cumulative_value,
    window_metadata,
    NOW()
FROM customer_cumulative_stats
ON CONFLICT (customer_id, window_type)
DO UPDATE SET
    window_value = EXCLUDED.window_value,
    window_metadata = EXCLUDED.window_metadata,
    last_updated = NOW();
```

**3. 高级窗口分析：复杂窗口框架应用**

**高级窗口分析**：使用复杂窗口框架进行高级分析。

```sql
-- 高级窗口分析：复杂窗口框架应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_data') THEN
            RAISE WARNING '表 sales_data 不存在，无法执行高级窗口分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行高级窗口分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '高级窗口分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 高级窗口分析：使用多种窗口框架
WITH advanced_window_analysis AS (
    SELECT
        customer_id,
        order_id,
        sale_date,
        amount,
        category,
        -- ROWS框架：基于行的移动平均（固定行数）
        AVG(amount) OVER (
            PARTITION BY customer_id
            ORDER BY sale_date DESC
            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ) AS moving_avg_3_rows,
        -- RANGE框架：基于值的移动平均（固定值范围）
        AVG(amount) OVER (
            PARTITION BY customer_id
            ORDER BY sale_date DESC
            RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW
        ) AS moving_avg_7_days,
        -- GROUPS框架：基于组的移动平均（固定组数）
        AVG(amount) OVER (
            PARTITION BY customer_id
            ORDER BY sale_date DESC
            GROUPS BETWEEN 1 PRECEDING AND CURRENT ROW
        ) AS moving_avg_group,
        -- 累计值：从开始到当前
        SUM(amount) OVER (
            PARTITION BY customer_id
            ORDER BY sale_date DESC
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS cumulative_total,
        -- 累计值：从当前到结束
        SUM(amount) OVER (
            PARTITION BY customer_id
            ORDER BY sale_date DESC
            ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
        ) AS remaining_total,
        -- 使用窗口函数计算百分比排名（避免重复计算）
        PERCENT_RANK() OVER (
            PARTITION BY customer_id
            ORDER BY amount DESC
        ) AS amount_percent_rank,
        -- 使用窗口函数计算累计分布（避免重复计算）
        CUME_DIST() OVER (
            PARTITION BY customer_id
            ORDER BY amount DESC
        ) AS amount_cume_dist
    FROM sales_data
    WHERE sale_date >= CURRENT_DATE - INTERVAL '90 days'
)
SELECT
    customer_id,
    order_id,
    sale_date,
    ROUND(amount::numeric, 2) AS amount,
    category,
    ROUND(moving_avg_3_rows::numeric, 2) AS moving_avg_3_rows,
    ROUND(moving_avg_7_days::numeric, 2) AS moving_avg_7_days,
    ROUND(moving_avg_group::numeric, 2) AS moving_avg_group,
    ROUND(cumulative_total::numeric, 2) AS cumulative_total,
    ROUND(remaining_total::numeric, 2) AS remaining_total,
    ROUND(amount_percent_rank::numeric, 4) AS amount_percent_rank,
    ROUND(amount_cume_dist::numeric, 4) AS amount_cume_dist
FROM advanced_window_analysis
ORDER BY customer_id, sale_date DESC
LIMIT 100;
```

---

## 📚 参考资源

### 学术文献

1. **《数据库系统概念》**（Silberschatz et al., 2019）- 第5章 SQL

2. **《SQL权威指南》**（Date, C. J., 2003）- 窗口函数

3. **PostgreSQL官方文档** - 窗口函数

### PostgreSQL官方文档

- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **窗口函数语法**: <https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS>
- **窗口函数列表**: <https://www.postgresql.org/docs/current/functions-window.html>

### 在线资源

- **窗口函数教程**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **窗口函数示例**: <https://www.postgresqltutorial.com/postgresql-window-function/>
- **性能优化**: <https://www.postgresql.org/docs/current/performance-tips.html>

### 相关算法

- **分组统计分析**：GROUP BY和窗口函数的结合
- **时间序列分析**：窗口函数在时间序列中的应用
- **排序算法**：窗口函数中的排序操作
- **聚合统计分析**：窗口聚合和普通聚合

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
