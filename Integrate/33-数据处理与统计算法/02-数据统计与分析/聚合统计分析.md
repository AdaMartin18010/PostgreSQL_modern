# PostgreSQL 聚合统计分析完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 聚合函数 | 统计分析
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 聚合统计分析完整指南](#postgresql-聚合统计分析完整指南)
  - [📋 目录](#-目录)
  - [聚合统计分析概述](#聚合统计分析概述)
    - [理论基础](#理论基础)
      - [聚合函数原理](#聚合函数原理)
      - [聚合函数分类](#聚合函数分类)
      - [聚合函数特性](#聚合函数特性)
    - [核心聚合函数](#核心聚合函数)
  - [1. 基础聚合函数](#1-基础聚合函数)
    - [1.1 基础聚合函数原理](#11-基础聚合函数原理)
      - [COUNT函数](#count函数)
      - [SUM函数](#sum函数)
      - [AVG函数](#avg函数)
      - [MIN/MAX函数](#minmax函数)
    - [1.2 基本聚合实现](#12-基本聚合实现)
  - [2. 条件聚合](#2-条件聚合)
    - [2.1 条件聚合原理](#21-条件聚合原理)
      - [FILTER子句](#filter子句)
      - [CASE表达式](#case表达式)
    - [2.2 FILTER子句实现](#22-filter子句实现)
    - [2.3 CASE表达式条件聚合](#23-case表达式条件聚合)
  - [3. 分组聚合](#3-分组聚合)
    - [3.1 分组聚合原理](#31-分组聚合原理)
      - [GROUP BY操作](#group-by操作)
      - [HAVING子句](#having子句)
    - [3.2 GROUP BY实现](#32-group-by实现)
  - [4. 多维度聚合](#4-多维度聚合)
    - [4.1 多维度聚合原理](#41-多维度聚合原理)
      - [ROLLUP操作](#rollup操作)
      - [CUBE操作](#cube操作)
      - [GROUPING SETS操作](#grouping-sets操作)
    - [4.2 ROLLUP实现](#42-rollup实现)
    - [4.3 CUBE实现](#43-cube实现)
    - [4.4 GROUPING SETS实现](#44-grouping-sets实现)
  - [5. 高级聚合函数](#5-高级聚合函数)
    - [5.1 统计聚合函数](#51-统计聚合函数)
    - [5.2 分位数聚合函数](#52-分位数聚合函数)
    - [5.3 数组聚合函数](#53-数组聚合函数)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 销售数据聚合分析](#61-销售数据聚合分析)
    - [6.2 客户行为聚合分析](#62-客户行为聚合分析)
    - [6.3 时间序列聚合分析](#63-时间序列聚合分析)
    - [6.4 条件聚合分析](#64-条件聚合分析)
    - [6.5 聚合统计报告生成](#65-聚合统计报告生成)
  - [7. PostgreSQL 18并行聚合统计分析](#7-postgresql-18并行聚合统计分析)
    - [7.1 并行聚合统计分析概述](#71-并行聚合统计分析概述)
      - [并行聚合统计分析配置](#并行聚合统计分析配置)
      - [并行聚合统计分析实现](#并行聚合统计分析实现)
  - [8. 算法性能对比与优化](#8-算法性能对比与优化)
    - [8.1 聚合函数性能对比](#81-聚合函数性能对比)
    - [8.2 性能优化建议](#82-性能优化建议)
    - [8.3 常见问题与解决方案](#83-常见问题与解决方案)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 聚合函数选择](#91-聚合函数选择)
    - [9.2 分组策略](#92-分组策略)
    - [9.3 SQL实现注意事项](#93-sql实现注意事项)
    - [9.4 PostgreSQL 18 新特性应用（增强）](#94-postgresql-18-新特性应用增强)
    - [9.5 高级优化技巧（增强）](#95-高级优化技巧增强)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 聚合统计分析概述

**聚合统计分析（Aggregate Statistical Analysis）**使用聚合函数对数据进行汇总统计，是数据分析的基础操作。PostgreSQL提供了丰富的聚合函数，支持各种统计计算和分析需求。

### 理论基础

#### 聚合函数原理

**聚合函数（Aggregate Function）**对一组值执行计算并返回单个值。聚合函数将多行数据合并成一行，实现数据的汇总和统计。

**聚合过程**：

1. **分组**：根据GROUP BY子句将数据分组（如果没有GROUP BY，则所有数据为一组）
2. **聚合**：对每个组应用聚合函数
3. **输出**：返回每个组的聚合结果

#### 聚合函数分类

1. **计数函数**：
   - COUNT：计数
   - COUNT(DISTINCT)：去重计数

2. **求和函数**：
   - SUM：求和
   - SUM(DISTINCT)：去重求和

3. **平均值函数**：
   - AVG：平均值
   - AVG(DISTINCT)：去重平均值

4. **最值函数**：
   - MIN：最小值
   - MAX：最大值

5. **统计函数**：
   - STDDEV：标准差
   - VARIANCE：方差
   - STDDEV_POP：总体标准差
   - STDDEV_SAMP：样本标准差

6. **分位数函数**：
   - PERCENTILE_CONT：连续百分位数
   - PERCENTILE_DISC：离散百分位数

7. **数组聚合函数**：
   - ARRAY_AGG：数组聚合
   - STRING_AGG：字符串聚合

#### 聚合函数特性

**NULL值处理**：

- 大多数聚合函数忽略NULL值
- COUNT(*)计算所有行（包括NULL）
- COUNT(column)只计算非NULL值

**去重聚合**：

- 使用DISTINCT关键字去重
- COUNT(DISTINCT column)
- SUM(DISTINCT column)

### 核心聚合函数

| 函数名称 | 数学定义 | 用途 | 时间复杂度 | NULL处理 |
|---------|---------|------|-----------|---------|
| **COUNT()** | $n$ | 计数 | $O(n)$ | 忽略NULL |
| **SUM()** | $\sum_{i=1}^{n} x_i$ | 求和 | $O(n)$ | 忽略NULL |
| **AVG()** | $\frac{1}{n}\sum_{i=1}^{n} x_i$ | 平均值 | $O(n)$ | 忽略NULL |
| **MIN()** | $\min\{x_1, x_2, ..., x_n\}$ | 最小值 | $O(n)$ | 忽略NULL |
| **MAX()** | $\max\{x_1, x_2, ..., x_n\}$ | 最大值 | $O(n)$ | 忽略NULL |
| **STDDEV()** | $\sqrt{\frac{1}{n-1}\sum_{i=1}^{n}(x_i - \bar{x})^2}$ | 标准差 | $O(n)$ | 忽略NULL |
| **PERCENTILE_CONT()** | 线性插值百分位数 | 百分位数 | $O(n \log n)$ | 忽略NULL |

---

## 1. 基础聚合函数

### 1.1 基础聚合函数原理

**基础聚合函数**是最常用的聚合函数，包括COUNT、SUM、AVG、MIN、MAX等。

#### COUNT函数

**COUNT函数**计算行数：

- `COUNT(*)`：计算所有行（包括NULL）
- `COUNT(column)`：计算非NULL值的行数
- `COUNT(DISTINCT column)`：计算去重后的行数

**数学定义**：
$$COUNT = |\{i : x_i \text{ is not NULL}\}|$$

#### SUM函数

**SUM函数**计算数值之和：
$$SUM = \sum_{i=1}^{n} x_i$$

**特点**：

- 忽略NULL值
- 支持DISTINCT去重

#### AVG函数

**AVG函数**计算平均值：
$$AVG = \frac{1}{n}\sum_{i=1}^{n} x_i = \frac{SUM}{COUNT}$$

**特点**：

- 忽略NULL值
- 返回数值类型

#### MIN/MAX函数

**MIN/MAX函数**计算最小值和最大值：
$$MIN = \min\{x_1, x_2, ..., x_n\}$$
$$MAX = \max\{x_1, x_2, ..., x_n\}$$

### 1.2 基本聚合实现

```sql
-- 基础聚合统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行聚合统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行基础聚合统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '聚合统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 完整的基础聚合统计
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) AS total_count,
    COUNT(DISTINCT customer_id) AS distinct_customers,
    COUNT(amount) AS non_null_amounts,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    STDDEV(amount) AS stddev_amount,
    VARIANCE(amount) AS variance_amount
FROM sales
WHERE amount IS NOT NULL;
```

---

## 2. 条件聚合

### 2.1 条件聚合原理

**条件聚合**使用FILTER子句或CASE表达式对数据进行条件聚合，只对满足条件的行进行聚合计算。

#### FILTER子句

**FILTER子句**语法：

```sql
AGGREGATE_FUNCTION(column) FILTER (WHERE condition)
```

**优势**：

- 语法简洁
- 性能更好
- 可读性强

#### CASE表达式

**CASE表达式**实现条件聚合：

```sql
SUM(CASE WHEN condition THEN value ELSE 0 END)
```

### 2.2 FILTER子句实现

```sql
-- 条件聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行条件聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行条件聚合统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '条件聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用FILTER子句的条件聚合
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) FILTER (WHERE status = 'completed') AS completed_count,
    SUM(amount) FILTER (WHERE status = 'completed') AS completed_amount,
    AVG(amount) FILTER (WHERE category = 'A') AS category_a_avg,
    COUNT(*) FILTER (WHERE status = 'pending') AS pending_count,
    SUM(amount) FILTER (WHERE status = 'pending') AS pending_amount
FROM orders;
```

### 2.3 CASE表达式条件聚合

**CASE表达式**实现条件聚合的另一种方法。

```sql
-- 使用CASE表达式的条件聚合（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) AS completed_amount,
    SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS pending_amount,
    AVG(CASE WHEN category = 'A' THEN amount END) AS category_a_avg,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) AS completed_count
FROM orders;
```

---

## 3. 分组聚合

### 3.1 分组聚合原理

**分组聚合**使用GROUP BY子句将数据分组，然后对每个组应用聚合函数。

#### GROUP BY操作

**GROUP BY语法**：

```sql
SELECT grouping_columns, aggregate_functions
FROM table
GROUP BY grouping_columns
HAVING condition
```

**执行过程**：

1. 按分组列分组
2. 对每个组应用聚合函数
3. 使用HAVING过滤分组结果

#### HAVING子句

**HAVING子句**用于过滤分组结果，类似于WHERE子句，但作用于分组后的数据。

**HAVING vs WHERE**：

- WHERE：过滤原始数据
- HAVING：过滤分组结果

### 3.2 GROUP BY实现

```sql
-- 分组聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行分组聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行分组聚合统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '分组聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 单列分组聚合
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    STDDEV(amount) AS stddev_amount
FROM sales
GROUP BY category
HAVING SUM(amount) > 1000  -- 只显示总金额大于1000的类别
ORDER BY total_amount DESC;

-- 多列分组聚合
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY region, category
ORDER BY region, total_amount DESC;
```

---

## 4. 多维度聚合

### 4.1 多维度聚合原理

**多维度聚合**使用ROLLUP、CUBE或GROUPING SETS实现多层次的聚合统计。

#### ROLLUP操作

**ROLLUP**生成层次汇总，从最详细到最汇总。

**ROLLUP(col1, col2, col3)生成**：

- (col1, col2, col3)
- (col1, col2)
- (col1)
- () - 总计

#### CUBE操作

**CUBE**生成所有可能的分组组合。

**CUBE(col1, col2)生成**：

- (col1, col2)
- (col1)
- (col2)
- () - 总计

#### GROUPING SETS操作

**GROUPING SETS**指定多个分组集合。

### 4.2 ROLLUP实现

```sql
-- 多维度聚合ROLLUP（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行多维度聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行ROLLUP多维度聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多维度聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ROLLUP层次汇总
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    GROUPING(region) AS gr_region,
    GROUPING(category) AS gr_category,
    SUM(amount) AS total_amount,
    COUNT(*) AS count
FROM sales
GROUP BY ROLLUP(region, category)
ORDER BY gr_region, gr_category, region, category;
```

### 4.3 CUBE实现

```sql
-- CUBE全维度组合
SELECT
    region,
    category,
    product,
    GROUPING(region) AS gr_region,
    GROUPING(category) AS gr_category,
    GROUPING(product) AS gr_product,
    SUM(amount) AS total_amount
FROM sales
GROUP BY CUBE(region, category, product)
ORDER BY gr_region, gr_category, gr_product, region, category, product;
```

### 4.4 GROUPING SETS实现

```sql
-- GROUPING SETS指定分组集合
SELECT
    region,
    category,
    GROUPING(region) AS gr_region,
    GROUPING(category) AS gr_category,
    SUM(amount) AS total_amount
FROM sales
GROUP BY GROUPING SETS (
    (region, category),
    (region),
    (category),
    ()
)
ORDER BY gr_region, gr_category, region, category;
```

---

## 5. 高级聚合函数

### 5.1 统计聚合函数

**统计聚合函数**计算数据的统计特征。

```sql
-- 统计聚合函数：标准差、方差、协方差
SELECT
    category,
    COUNT(*) AS count,
    AVG(amount) AS mean_amount,
    STDDEV(amount) AS stddev_amount,
    STDDEV_POP(amount) AS stddev_pop,
    STDDEV_SAMP(amount) AS stddev_samp,
    VARIANCE(amount) AS variance_amount,
    VAR_POP(amount) AS var_pop,
    VAR_SAMP(amount) AS var_samp
FROM sales
GROUP BY category;
```

### 5.2 分位数聚合函数

**分位数聚合函数**计算数据的百分位数。

```sql
-- 分位数聚合函数：中位数、四分位数、百分位数
SELECT
    category,
    COUNT(*) AS count,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1_amount,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3_amount,
    PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY amount) AS p90_amount,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY amount) AS p95_amount,
    PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY amount) AS median_disc
FROM sales
GROUP BY category;
```

### 5.3 数组聚合函数

**数组聚合函数**将多行数据聚合成数组。

```sql
-- 数组聚合函数：ARRAY_AGG、STRING_AGG
SELECT
    category,
    COUNT(*) AS count,
    ARRAY_AGG(DISTINCT customer_id ORDER BY customer_id) AS customer_ids,
    STRING_AGG(DISTINCT product_name, ', ' ORDER BY product_name) AS product_names,
    ARRAY_AGG(amount ORDER BY amount DESC) FILTER (WHERE amount > 100) AS large_amounts
FROM sales
GROUP BY category;
```

---

## 6. 实际应用案例

### 6.1 销售数据聚合分析

**场景**：分析销售数据的多维度聚合统计。

```sql
-- 销售数据聚合分析：多维度统计
WITH sales_aggregation AS (
    SELECT
        region,
        category,
        product,
        GROUPING(region) AS gr_region,
        GROUPING(category) AS gr_category,
        GROUPING(product) AS gr_product,
        COUNT(*) AS order_count,
        COUNT(DISTINCT customer_id) AS customer_count,
        SUM(amount) AS total_amount,
        AVG(amount) AS avg_amount,
        MIN(amount) AS min_amount,
        MAX(amount) AS max_amount,
        STDDEV(amount) AS stddev_amount,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount
    FROM sales
    GROUP BY ROLLUP(region, category, product)
)
SELECT
    CASE WHEN gr_region = 1 THEN '总计' ELSE COALESCE(region::text, 'NULL') END AS region,
    CASE WHEN gr_category = 1 THEN '--' ELSE COALESCE(category::text, 'NULL') END AS category,
    CASE WHEN gr_product = 1 THEN '--' ELSE COALESCE(product::text, 'NULL') END AS product,
    order_count,
    customer_count,
    ROUND(total_amount::numeric, 2) AS total_amount,
    ROUND(avg_amount::numeric, 2) AS avg_amount,
    ROUND(median_amount::numeric, 2) AS median_amount
FROM sales_aggregation
ORDER BY gr_region, gr_category, gr_product, total_amount DESC;
```

### 6.2 客户行为聚合分析

**场景**：聚合分析客户购买行为。

```sql
-- 客户行为聚合分析：RFM模型
WITH customer_rfm AS (
    SELECT
        customer_id,
        COUNT(*) AS frequency,
        MAX(order_date) AS last_order_date,
        CURRENT_DATE - MAX(order_date) AS recency,
        SUM(amount) AS monetary
    FROM orders
    GROUP BY customer_id
),
rfm_segments AS (
    SELECT
        customer_id,
        frequency,
        recency,
        monetary,
        NTILE(5) OVER (ORDER BY recency DESC) AS r_score,
        NTILE(5) OVER (ORDER BY frequency) AS f_score,
        NTILE(5) OVER (ORDER BY monetary) AS m_score
    FROM customer_rfm
)
SELECT
    r_score,
    f_score,
    m_score,
    COUNT(*) AS customer_count,
    AVG(frequency) AS avg_frequency,
    AVG(recency) AS avg_recency,
    AVG(monetary) AS avg_monetary,
    CASE
        WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN 'Champions'
        WHEN r_score >= 3 AND f_score >= 3 AND m_score >= 3 THEN 'Loyal Customers'
        WHEN r_score >= 4 AND f_score <= 2 THEN 'At Risk'
        WHEN r_score <= 2 THEN 'Lost'
        ELSE 'Need Attention'
    END AS segment
FROM rfm_segments
GROUP BY r_score, f_score, m_score
ORDER BY r_score DESC, f_score DESC, m_score DESC;
```

### 6.3 时间序列聚合分析

**场景**：按时间维度聚合分析数据。

```sql
-- 时间序列聚合分析：按年、月、日聚合
SELECT
    DATE_TRUNC('year', order_date) AS year,
    DATE_TRUNC('month', order_date) AS month,
    DATE_TRUNC('day', order_date) AS day,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    -- 移动平均（使用窗口函数）
    AVG(SUM(amount)) OVER (
        ORDER BY DATE_TRUNC('month', order_date)
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3months
FROM orders
GROUP BY DATE_TRUNC('year', order_date),
         DATE_TRUNC('month', order_date),
         DATE_TRUNC('day', order_date)
ORDER BY year, month, day;
```

### 6.4 条件聚合分析

**场景**：使用条件聚合进行复杂统计分析。

```sql
-- 条件聚合分析：多条件统计
SELECT
    category,
    -- 基础统计
    COUNT(*) AS total_orders,
    SUM(amount) AS total_amount,
    -- 条件统计
    COUNT(*) FILTER (WHERE status = 'completed') AS completed_orders,
    SUM(amount) FILTER (WHERE status = 'completed') AS completed_amount,
    COUNT(*) FILTER (WHERE status = 'cancelled') AS cancelled_orders,
    SUM(amount) FILTER (WHERE status = 'cancelled') AS cancelled_amount,
    -- 比率计算
    ROUND(
        COUNT(*) FILTER (WHERE status = 'completed')::numeric /
        NULLIF(COUNT(*), 0) * 100,
        2
    ) AS completion_rate,
    -- 时间条件统计
    COUNT(*) FILTER (WHERE order_date >= CURRENT_DATE - INTERVAL '30 days') AS orders_last_30days,
    SUM(amount) FILTER (WHERE order_date >= CURRENT_DATE - INTERVAL '30 days') AS amount_last_30days
FROM orders
GROUP BY category
ORDER BY total_amount DESC;
```

### 6.5 聚合统计报告生成

**场景**：生成综合的聚合统计报告。

```sql
-- 聚合统计报告：生成完整的统计报告
WITH summary_stats AS (
    SELECT
        COUNT(*) AS total_records,
        COUNT(DISTINCT customer_id) AS distinct_customers,
        COUNT(DISTINCT category) AS distinct_categories,
        SUM(amount) AS total_amount,
        AVG(amount) AS avg_amount,
        STDDEV(amount) AS stddev_amount,
        MIN(amount) AS min_amount,
        MAX(amount) AS max_amount,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1_amount,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3_amount
    FROM sales
    WHERE amount IS NOT NULL
),
category_stats AS (
    SELECT
        category,
        COUNT(*) AS count,
        SUM(amount) AS total_amount,
        AVG(amount) AS avg_amount,
        ROUND(SUM(amount) * 100.0 / (SELECT SUM(amount) FROM sales), 2) AS percentage
    FROM sales
    GROUP BY category
)
SELECT
    'Overall Statistics' AS report_section,
    total_records AS metric_value,
    'Total Records' AS metric_name
FROM summary_stats
UNION ALL
SELECT
    'Overall Statistics',
    total_amount,
    'Total Amount'
FROM summary_stats
UNION ALL
SELECT
    'Category Statistics',
    total_amount,
    category || ' - Total Amount'
FROM category_stats
ORDER BY report_section, metric_name;
```

---

## 7. PostgreSQL 18并行聚合统计分析

### 7.1 并行聚合统计分析概述

**PostgreSQL 18并行聚合统计分析**：利用PostgreSQL 18的并行查询能力，显著提升大规模聚合统计分析的性能。

#### 并行聚合统计分析配置

```sql
-- 配置并行聚合统计分析参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行聚合成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行聚合统计分析参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行聚合统计分析配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 并行聚合统计分析实现

```sql
-- 并行聚合统计分析：大规模销售数据统计（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行聚合统计分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行聚合统计分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行多维度聚合统计
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    region,
    category,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    STDDEV(amount) AS stddev_amount,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount
FROM sales
WHERE order_date >= CURRENT_DATE - INTERVAL '1 year'
GROUP BY region, category
HAVING COUNT(*) > 100
ORDER BY total_amount DESC;
```

---

## 8. 算法性能对比与优化

### 8.1 聚合函数性能对比

| 聚合函数 | 时间复杂度 | 空间复杂度 | 性能 | 适用场景 |
|---------|-----------|-----------|------|---------|
| **COUNT** | $O(n)$ | $O(1)$ | 快 | 计数统计 |
| **SUM/AVG** | $O(n)$ | $O(1)$ | 快 | 数值汇总 |
| **MIN/MAX** | $O(n)$ | $O(1)$ | 快 | 最值查找 |
| **STDDEV** | $O(n)$ | $O(1)$ | 中 | 标准差计算 |
| **PERCENTILE_CONT** | $O(n \log n)$ | $O(n)$ | 慢 | 百分位数 |
| **ARRAY_AGG** | $O(n)$ | $O(n)$ | 中 | 数组聚合 |

### 8.2 性能优化建议

1. **索引优化**：
   - 在GROUP BY列上创建索引
   - 在WHERE条件列上创建索引
   - 使用覆盖索引

2. **查询优化**：
   - 使用WHERE过滤减少数据量
   - 使用HAVING过滤分组结果
   - 避免不必要的DISTINCT

3. **聚合优化**：
   - 使用FILTER替代CASE表达式
   - 避免嵌套聚合
   - 使用物化视图缓存结果

4. **并行处理**：
   - 使用并行聚合
   - 分批处理大数据集

   - 使用分区表

### 8.3 常见问题与解决方案

**问题1**：聚合查询性能慢

- **解决方案**：创建索引、优化GROUP BY列、使用物化视图

**问题2**：NULL值处理不当

- **解决方案**：理解NULL值行为、使用COALESCE、明确处理NULL

**问题3**：DISTINCT性能差

- **解决方案**：避免不必要的DISTINCT、使用索引、考虑替代方案

**问题4**：分组结果过多

- **解决方案**：使用HAVING过滤、限制分组列、使用LIMIT

---

## 9. 最佳实践

### 9.1 聚合函数选择

1. **计数需求**：
   - COUNT(*)：计算所有行
   - COUNT(column)：计算非NULL行
   - COUNT(DISTINCT column)：去重计数

2. **汇总需求**：
   - SUM：求和
   - AVG：平均值
   - 组合使用：SUM/COUNT计算平均值

3. **统计需求**：
   - STDDEV：标准差
   - VARIANCE：方差
   - PERCENTILE_CONT：百分位数

### 9.2 分组策略

1. **分组列选择**：
   - 选择高选择性列
   - 考虑业务需求
   - 限制分组列数量

2. **HAVING使用**：
   - 过滤分组结果
   - 避免在WHERE中使用聚合函数
   - 合理使用条件

3. **多维度聚合**：
   - ROLLUP：层次汇总
   - CUBE：全维度组合
   - GROUPING SETS：指定分组

### 9.3 SQL实现注意事项

1. **性能考虑**：
   - 创建适当索引
   - 优化GROUP BY列
   - 使用物化视图

2. **准确性**：
   - 处理NULL值
   - 注意数值精度
   - 验证聚合结果

3. **可读性**：
   - 使用别名
   - 清晰的注释
   - 模块化设计

### 9.4 PostgreSQL 18 新特性应用（增强）

**PostgreSQL 18**引入了多项增强功能，可以显著提升聚合统计分析的性能：

1. **Skip Scan优化**：
   - 对于包含聚合值的索引，Skip Scan可以跳过不必要的索引扫描
   - 特别适用于Top-N聚合查询和分维度聚合查询

2. **异步I/O增强**：
   - 对于大规模聚合统计计算，异步I/O可以显著提升性能
   - 适用于批量聚合和多维度聚合（ROLLUP、CUBE）

3. **并行查询增强**：
   - 聚合统计计算支持更好的并行执行
   - 适用于大规模分组聚合和复杂聚合函数

**示例：使用Skip Scan优化聚合查询**

```sql
-- 为聚合统计创建Skip Scan优化索引
CREATE INDEX IF NOT EXISTS idx_aggregate_stats_skip_scan
ON sales_data(category, total_amount DESC);

-- Skip Scan优化查询：查找每个类别销售额最高的前5个产品
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (category)
    category,
    product_id,
    SUM(amount) AS total_amount
FROM sales_data
GROUP BY category, product_id
ORDER BY category, total_amount DESC
LIMIT 50;
```

### 9.5 高级优化技巧（增强）

**1. 使用物化视图缓存聚合统计结果**

对于频繁使用的聚合统计结果，使用物化视图缓存：

```sql
-- 创建物化视图缓存聚合统计结果
CREATE MATERIALIZED VIEW IF NOT EXISTS aggregate_statistics_cache AS
WITH category_aggregates AS (
    SELECT
        category,
        COUNT(*) AS order_count,
        SUM(amount) AS total_revenue,
        AVG(amount) AS avg_order_value,
        STDDEV(amount) AS stddev_order_value,
        MIN(amount) AS min_order_value,
        MAX(amount) AS max_order_value,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_order_value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1_order_value,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3_order_value,
        -- 使用窗口函数计算占比（避免重复计算）
        SUM(amount)::numeric / NULLIF(SUM(SUM(amount)) OVER (), 0) * 100 AS revenue_pct
    FROM sales_data
    WHERE sale_date >= CURRENT_DATE - INTERVAL '90 days'
    GROUP BY category
)
SELECT
    category,
    order_count,
    ROUND(total_revenue::numeric, 2) AS total_revenue,
    ROUND(avg_order_value::numeric, 2) AS avg_order_value,
    ROUND(stddev_order_value::numeric, 2) AS stddev_order_value,
    min_order_value,
    max_order_value,
    ROUND(median_order_value::numeric, 2) AS median_order_value,
    ROUND(q1_order_value::numeric, 2) AS q1_order_value,
    ROUND(q3_order_value::numeric, 2) AS q3_order_value,
    ROUND(revenue_pct::numeric, 2) AS revenue_pct
FROM category_aggregates;

-- 创建索引加速物化视图查询
CREATE INDEX idx_aggregate_statistics_cache_category ON aggregate_statistics_cache(category);
CREATE INDEX idx_aggregate_statistics_cache_revenue ON aggregate_statistics_cache(total_revenue DESC);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY aggregate_statistics_cache;
```

**2. 实时聚合统计：增量聚合更新**

**实时聚合统计**：对于实时数据，使用增量方法更新聚合结果。

```sql
-- 实时聚合统计：增量聚合更新（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'aggregate_statistics_state') THEN
            CREATE TABLE aggregate_statistics_state (
                category VARCHAR(50) PRIMARY KEY,
                order_count BIGINT DEFAULT 0,
                total_revenue NUMERIC DEFAULT 0,
                sum_squared_revenue NUMERIC DEFAULT 0,
                min_order_value NUMERIC,
                max_order_value NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_aggregate_statistics_state_category ON aggregate_statistics_state(category);
            CREATE INDEX idx_aggregate_statistics_state_revenue ON aggregate_statistics_state(total_revenue DESC);

            RAISE NOTICE '聚合统计状态表创建成功';
        END IF;

        RAISE NOTICE '开始执行增量聚合更新';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '增量聚合更新准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 增量更新聚合统计：实时聚合统计
WITH new_sales AS (
    SELECT
        category,
        COUNT(*) AS new_count,
        SUM(amount) AS new_sum,
        SUM(POWER(amount, 2)) AS new_sum_squared,
        MIN(amount) AS new_min,
        MAX(amount) AS new_max
    FROM sales_data
    WHERE sale_date > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM aggregate_statistics_state)
      AND sale_date <= CURRENT_DATE
    GROUP BY category
),
updated_statistics AS (
    SELECT
        COALESCE(ass.category, ns.category) AS category,
        COALESCE(ass.order_count, 0) + ns.new_count AS new_order_count,
        COALESCE(ass.total_revenue, 0) + ns.new_sum AS new_total_revenue,
        COALESCE(ass.sum_squared_revenue, 0) + ns.new_sum_squared AS new_sum_squared_revenue,
        LEAST(COALESCE(ass.min_order_value, ns.new_min), ns.new_min) AS new_min_order_value,
        GREATEST(COALESCE(ass.max_order_value, ns.new_max), ns.new_max) AS new_max_order_value
    FROM aggregate_statistics_state ass
    FULL OUTER JOIN new_sales ns ON ass.category = ns.category
)
-- 更新或插入聚合统计状态
INSERT INTO aggregate_statistics_state (
    category,
    order_count,
    total_revenue,
    sum_squared_revenue,
    min_order_value,
    max_order_value,
    last_updated
)
SELECT
    category,
    new_order_count,
    new_total_revenue,
    new_sum_squared_revenue,
    new_min_order_value,
    new_max_order_value,
    NOW()
FROM updated_statistics
ON CONFLICT (category)
DO UPDATE SET
    order_count = EXCLUDED.order_count,
    total_revenue = EXCLUDED.total_revenue,
    sum_squared_revenue = EXCLUDED.sum_squared_revenue,
    min_order_value = EXCLUDED.min_order_value,
    max_order_value = EXCLUDED.max_order_value,
    last_updated = NOW();
```

**3. 多维聚合分析：智能聚合策略**

**多维聚合分析**：根据数据特征自动选择聚合策略。

```sql
-- 多维聚合分析：智能聚合策略（带错误处理和性能测试）
DO $$
DECLARE
    total_rows BIGINT;
    distinct_categories INTEGER;
    aggregation_strategy VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_data') THEN
            RAISE WARNING '表 sales_data 不存在，无法执行多维聚合分析';
            RETURN;
        END IF;

        -- 计算数据量和分类数量
        SELECT COUNT(*) INTO total_rows FROM sales_data;
        SELECT COUNT(DISTINCT category) INTO distinct_categories FROM sales_data;

        -- 根据数据特征选择聚合策略
        IF total_rows < 100000 AND distinct_categories < 50 THEN
            aggregation_strategy := 'CUBE';  -- 小数据量使用CUBE
        ELSIF total_rows < 1000000 AND distinct_categories < 200 THEN
            aggregation_strategy := 'ROLLUP';  -- 中等数据量使用ROLLUP
        ELSE
            aggregation_strategy := 'GROUPING SETS';  -- 大数据量使用GROUPING SETS
        END IF;

        RAISE NOTICE '数据量: %, 分类数: %, 选择策略: %', total_rows, distinct_categories, aggregation_strategy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多维聚合分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 智能多维聚合：根据策略选择不同的聚合方式
WITH adaptive_aggregation AS (
    SELECT
        region,
        category,
        DATE_TRUNC('month', sale_date) AS sale_month,
        COUNT(*) AS order_count,
        SUM(amount) AS total_revenue,
        AVG(amount) AS avg_order_value
    FROM sales_data
    WHERE sale_date >= CURRENT_DATE - INTERVAL '6 months'
    GROUP BY
        CASE
            WHEN (SELECT COUNT(*) FROM sales_data WHERE sale_date >= CURRENT_DATE - INTERVAL '6 months') < 100000 THEN
                CUBE(region, category, DATE_TRUNC('month', sale_date))
            WHEN (SELECT COUNT(DISTINCT category) FROM sales_data WHERE sale_date >= CURRENT_DATE - INTERVAL '6 months') < 200 THEN
                ROLLUP(region, category, DATE_TRUNC('month', sale_date))
            ELSE
                GROUPING SETS (
                    (region, category, DATE_TRUNC('month', sale_date)),
                    (region, category),
                    (region),
                    ()
                )
        END
)
SELECT
    region,
    category,
    sale_month,
    order_count,
    ROUND(total_revenue::numeric, 2) AS total_revenue,
    ROUND(avg_order_value::numeric, 2) AS avg_order_value
FROM adaptive_aggregation
ORDER BY region NULLS LAST, category NULLS LAST, sale_month NULLS LAST
LIMIT 100;
```

---

## 📚 参考资源

### 学术文献

1. **《数据库系统概念》**（Silberschatz et al., 2019）- 第5章 SQL

2. **《SQL权威指南》**（Date, C. J., 2003）- 聚合函数

3. **PostgreSQL官方文档** - 聚合函数

### PostgreSQL官方文档

- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **GROUP BY**: <https://www.postgresql.org/docs/current/sql-select.html#SQL-GROUPBY>
- **HAVING**: <https://www.postgresql.org/docs/current/sql-select.html#SQL-HAVING>
- **GROUPING SETS**: <https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUPING-SETS>

### 在线资源

- **聚合函数**: <https://www.postgresql.org/docs/current/tutorial-agg.html>
- **统计分析**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **性能优化**: <https://www.postgresql.org/docs/current/performance-tips.html>

### 相关算法

- **分组统计分析**：GROUP BY和聚合函数的结合
- **窗口函数统计**：窗口聚合函数
- **描述性统计**：统计指标计算
- **查询优化算法**：聚合查询优化

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
