# PostgreSQL 分组统计分析完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | GROUP BY | 多维分析
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 分组统计分析完整指南](#postgresql-分组统计分析完整指南)
  - [📋 目录](#-目录)
  - [分组统计分析概述](#分组统计分析概述)
    - [理论基础](#理论基础)
      - [分组操作原理](#分组操作原理)
      - [GROUP BY操作](#group-by操作)
      - [GROUPING SETS](#grouping-sets)
      - [CUBE操作](#cube操作)
      - [ROLLUP操作](#rollup操作)
    - [核心分组功能](#核心分组功能)
  - [1. GROUP BY基础](#1-group-by基础)
    - [1.1 GROUP BY原理](#11-group-by原理)
      - [分组过程](#分组过程)
      - [聚合函数](#聚合函数)
    - [1.2 GROUP BY基础实现](#12-group-by基础实现)
    - [1.3 HAVING子句](#13-having子句)
  - [2. GROUPING SETS](#2-grouping-sets)
    - [2.1 GROUPING SETS原理](#21-grouping-sets原理)
      - [语法](#语法)
      - [GROUPING函数](#grouping函数)
    - [2.2 GROUPING SETS实现](#22-grouping-sets实现)
  - [3. CUBE操作](#3-cube操作)
    - [3.1 CUBE原理](#31-cube原理)
    - [3.2 CUBE实现](#32-cube实现)
  - [4. ROLLUP操作](#4-rollup操作)
    - [4.1 ROLLUP原理](#41-rollup原理)
    - [4.2 ROLLUP实现](#42-rollup实现)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 销售多维分析](#51-销售多维分析)
    - [5.2 时间序列层次汇总](#52-时间序列层次汇总)
    - [5.3 地理层次分析](#53-地理层次分析)
    - [5.4 多维度交叉分析](#54-多维度交叉分析)
    - [5.5 分组统计性能优化](#55-分组统计性能优化)
  - [6. PostgreSQL 18并行分组统计分析](#6-postgresql-18并行分组统计分析)
    - [6.1 并行分组统计分析概述](#61-并行分组统计分析概述)
      - [并行分组统计分析配置](#并行分组统计分析配置)
      - [并行分组统计分析实现](#并行分组统计分析实现)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 分组操作对比](#71-分组操作对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 分组列选择](#81-分组列选择)
    - [8.2 聚合函数使用](#82-聚合函数使用)
    - [8.3 分组操作选择](#83-分组操作选择)
    - [8.4 SQL实现注意事项](#84-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 分组统计分析概述

**分组统计分析（Grouped Statistical Analysis）**是数据分析中的核心操作，通过GROUP BY及其扩展功能（GROUPING SETS、CUBE、ROLLUP）实现多维数据的分组、聚合和汇总分析。

### 理论基础

#### 分组操作原理

**分组操作（Grouping）**将数据按照指定的列值分组，然后对每个组应用聚合函数。

**数学定义**：

- 数据集：$D = \{r_1, r_2, ..., r_n\}$
- 分组列：$G = \{g_1, g_2, ..., g_k\}$
- 分组函数：$f: D \rightarrow \{G_1, G_2, ..., G_m\}$，其中$G_i = \{r_j : r_j[g_1, ..., g_k] = v_i\}$

**聚合函数**：

- 对每个分组$G_i$应用聚合函数$agg$：$agg(G_i) = \{agg_1(G_i), agg_2(G_i), ...\}$

#### GROUP BY操作

**基本语法**：

```sql
SELECT grouping_columns, aggregate_functions
FROM table
GROUP BY grouping_columns
```

**执行过程**：

1. **分组**：按分组列的值将数据分成多个组
2. **聚合**：对每个组应用聚合函数
3. **输出**：返回每个组的聚合结果

**时间复杂度**：$O(n \log n)$（需要排序或哈希）

#### GROUPING SETS

**GROUPING SETS**允许在单个查询中指定多个分组集合，等价于多个GROUP BY查询的UNION ALL。

**语法**：

```sql
GROUP BY GROUPING SETS ((col1), (col2), (col1, col2))
```

**等价于**：

```sql
GROUP BY col1
UNION ALL
GROUP BY col2
UNION ALL
GROUP BY col1, col2
```

#### CUBE操作

**CUBE**生成所有可能的分组组合，包括空分组（总计）。

**对于n列，CUBE生成$2^n$个分组组合**。

**示例**：CUBE(col1, col2)生成：

- (col1, col2)
- (col1)
- (col2)
- () - 总计

#### ROLLUP操作

**ROLLUP**生成层次汇总，从最详细到最汇总。

**ROLLUP(col1, col2, col3)生成**：

- (col1, col2, col3)
- (col1, col2)
- (col1)
- () - 总计

**特点**：层次结构，适合时间序列和地理层次数据。

### 核心分组功能

| 功能 | 用途 | 时间复杂度 | 空间复杂度 | 分组数 |
|------|------|-----------|-----------|--------|
| **GROUP BY** | 单维度分组 | $O(n \log n)$ | $O(n)$ | 1 |
| **GROUPING SETS** | 多维度组合 | $O(n \log n)$ | $O(n)$ | $k$（指定） |
| **CUBE** | 全维度组合 | $O(n \log n)$ | $O(n)$ | $2^n$ |
| **ROLLUP** | 层次汇总 | $O(n \log n)$ | $O(n)$ | $n+1$ |

---

## 1. GROUP BY基础

### 1.1 GROUP BY原理

**GROUP BY**是SQL中最基本的分组操作，按照指定的列对数据进行分组，然后对每个组应用聚合函数。

#### 分组过程

1. **数据扫描**：扫描表中的所有行
2. **分组**：根据分组列的值将行分配到不同的组
3. **聚合**：对每个组应用聚合函数（COUNT、SUM、AVG等）
4. **输出**：返回每个组的聚合结果

#### 聚合函数

**常用聚合函数**：

- **COUNT**：计数
- **SUM**：求和
- **AVG**：平均值
- **MAX/MIN**：最大值/最小值
- **STDDEV**：标准差
- **VARIANCE**：方差

### 1.2 GROUP BY基础实现

```sql
-- GROUP BY基础分组（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行GROUP BY分组统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '分组统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 单列分组
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total,
    AVG(amount) AS avg_amount,
    MAX(amount) AS max_amount,
    MIN(amount) AS min_amount
FROM sales
GROUP BY category
ORDER BY total DESC;

-- 多列分组
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total
FROM sales
GROUP BY region, category
ORDER BY region, total DESC;
```

### 1.3 HAVING子句

**HAVING子句**用于过滤分组结果，类似于WHERE子句，但作用于分组后的数据。

```sql
-- HAVING子句：过滤分组结果
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total
FROM sales
GROUP BY category
HAVING SUM(amount) > 10000  -- 只显示总金额大于10000的类别
ORDER BY total DESC;
```

---

## 2. GROUPING SETS

### 2.1 GROUPING SETS原理

**GROUPING SETS**允许在单个查询中指定多个分组集合，避免使用多个UNION ALL查询。

#### 语法

```sql
GROUP BY GROUPING SETS (
    (col1, col2),
    (col1),
    (col2),
    ()
)
```

**等价于**：

```sql
GROUP BY col1, col2
UNION ALL
GROUP BY col1
UNION ALL
GROUP BY col2
UNION ALL
SELECT ... (总计)
```

#### GROUPING函数

**GROUPING函数**用于识别哪些列被聚合（NULL值表示该列被聚合）。

```sql
SELECT
    region,
    category,
    GROUPING(region) AS gr_region,
    GROUPING(category) AS gr_category,
    SUM(amount) AS total
FROM sales
GROUP BY GROUPING SETS (
    (region, category),
    (region),
    ()
);
```

### 2.2 GROUPING SETS实现

```sql
-- GROUPING SETS多维度分组（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行GROUPING SETS多维度分组';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'GROUPING SETS准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- GROUPING SETS示例
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    GROUPING(region) AS gr_region,
    GROUPING(category) AS gr_category,
    SUM(amount) AS total,
    COUNT(*) AS count
FROM sales
GROUP BY GROUPING SETS (
    (region, category),  -- 按地区和类别分组
    (region),            -- 按地区分组
    ()                   -- 总计
)
ORDER BY gr_region, gr_category, region, category;
```

---

## 3. CUBE操作

### 3.1 CUBE原理

**CUBE**生成所有可能的分组组合，包括空分组（总计）。

**对于n列，CUBE生成$2^n$个分组组合**。

**CUBE(col1, col2, col3)生成**：

- (col1, col2, col3)
- (col1, col2)
- (col1, col3)
- (col2, col3)
- (col1)
- (col2)
- (col3)
- () - 总计

### 3.2 CUBE实现

```sql
-- CUBE操作：生成所有分组组合
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    product,
    GROUPING(region) AS gr_region,
    GROUPING(category) AS gr_category,
    GROUPING(product) AS gr_product,
    SUM(amount) AS total
FROM sales
GROUP BY CUBE(region, category, product)
ORDER BY gr_region, gr_category, gr_product, region, category, product;
```

---

## 4. ROLLUP操作

### 4.1 ROLLUP原理

**ROLLUP**生成层次汇总，从最详细到最汇总，适合时间序列和地理层次数据。

**ROLLUP(col1, col2, col3)生成**：

- (col1, col2, col3) - 最详细
- (col1, col2) - 中间层次
- (col1) - 较高层次
- () - 总计

**特点**：层次结构，从左到右逐步汇总。

### 4.2 ROLLUP实现

```sql
-- ROLLUP操作：层次汇总
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    year,
    quarter,
    month,
    GROUPING(year) AS gr_year,
    GROUPING(quarter) AS gr_quarter,
    GROUPING(month) AS gr_month,
    SUM(amount) AS total
FROM sales
GROUP BY ROLLUP(year, quarter, month)
ORDER BY year, quarter, month;
```

---

## 5. 实际应用案例

### 5.1 销售多维分析

**场景**：分析销售数据的多维统计。

```sql
-- 销售多维分析：使用GROUPING SETS
WITH sales_analysis AS (
    SELECT
        region,
        category,
        product,
        GROUPING(region) AS gr_region,
        GROUPING(category) AS gr_category,
        GROUPING(product) AS gr_product,
        SUM(amount) AS total_sales,
        COUNT(*) AS order_count,
        AVG(amount) AS avg_amount
    FROM sales
    GROUP BY GROUPING SETS (
        (region, category, product),  -- 最详细
        (region, category),            -- 按地区和类别
        (region),                      -- 按地区
        ()                             -- 总计
    )
)
SELECT
    CASE
        WHEN gr_region = 1 THEN '总计'
        ELSE COALESCE(region::text, 'NULL')
    END AS region,
    CASE
        WHEN gr_category = 1 THEN '--'
        ELSE COALESCE(category::text, 'NULL')
    END AS category,
    CASE
        WHEN gr_product = 1 THEN '--'
        ELSE COALESCE(product::text, 'NULL')
    END AS product,
    total_sales,
    order_count,
    ROUND(avg_amount::numeric, 2) AS avg_amount
FROM sales_analysis
ORDER BY gr_region, gr_category, gr_product, region, category, product;
```

### 5.2 时间序列层次汇总

**场景**：按时间层次汇总数据。

```sql
-- 时间序列层次汇总：使用ROLLUP
SELECT
    year,
    quarter,
    month,
    GROUPING(year) AS gr_year,
    GROUPING(quarter) AS gr_quarter,
    GROUPING(month) AS gr_month,
    SUM(amount) AS total_sales,
    COUNT(*) AS order_count,
    CASE
        WHEN GROUPING(year) = 1 THEN '总计'
        WHEN GROUPING(quarter) = 1 THEN year::text || '年总计'
        WHEN GROUPING(month) = 1 THEN year::text || '年Q' || quarter::text || '总计'
        ELSE year::text || '年Q' || quarter::text || '月' || month::text
    END AS period_label
FROM sales
GROUP BY ROLLUP(year, quarter, month)
ORDER BY year NULLS LAST, quarter NULLS LAST, month NULLS LAST;
```

### 5.3 地理层次分析

**场景**：按地理层次分析数据。

```sql
-- 地理层次分析：使用ROLLUP
SELECT
    country,
    province,
    city,
    GROUPING(country) AS gr_country,
    GROUPING(province) AS gr_province,
    GROUPING(city) AS gr_city,
    SUM(amount) AS total_sales,
    COUNT(*) AS customer_count,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY ROLLUP(country, province, city)
ORDER BY country NULLS LAST, province NULLS LAST, city NULLS LAST;
```

### 5.4 多维度交叉分析

**场景**：使用CUBE进行多维度交叉分析。

```sql
-- 多维度交叉分析：使用CUBE
SELECT
    region,
    category,
    product_type,
    GROUPING(region) AS gr_region,
    GROUPING(category) AS gr_category,
    GROUPING(product_type) AS gr_product_type,
    SUM(amount) AS total_sales,
    COUNT(*) AS order_count
FROM sales
GROUP BY CUBE(region, category, product_type)
HAVING SUM(amount) > 1000  -- 过滤小金额
ORDER BY gr_region, gr_category, gr_product_type, total_sales DESC;
```

### 5.5 分组统计性能优化

**场景**：优化分组统计查询的性能。

```sql
-- 分组统计性能优化：使用索引和物化视图
-- 创建索引优化分组查询
CREATE INDEX IF NOT EXISTS idx_sales_region_category
ON sales(region, category);

CREATE INDEX IF NOT EXISTS idx_sales_date
ON sales(year, quarter, month);

-- 使用物化视图缓存分组结果
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_sales_summary AS
SELECT
    region,
    category,
    year,
    quarter,
    SUM(amount) AS total_sales,
    COUNT(*) AS order_count,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY region, category, year, quarter;

-- 创建索引加速物化视图查询
CREATE INDEX IF NOT EXISTS idx_mv_sales_summary
ON mv_sales_summary(region, category, year, quarter);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary;
```

---

## 6. PostgreSQL 18并行分组统计分析

### 6.1 并行分组统计分析概述

**PostgreSQL 18并行分组统计分析**：利用PostgreSQL 18的并行查询能力，显著提升大规模分组统计分析的性能。

#### 并行分组统计分析配置

```sql
-- 配置并行分组统计分析参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行聚合成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行分组统计分析参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行分组统计分析配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 并行分组统计分析实现

```sql
-- 并行分组统计分析：大规模多维度分组统计（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行分组统计分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行分组统计分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行多维度分组统计
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    region,
    category,
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    STDDEV(amount) AS stddev_amount
FROM sales
WHERE order_date >= CURRENT_DATE - INTERVAL '1 year'
GROUP BY region, category, DATE_TRUNC('month', order_date)
HAVING COUNT(*) > 10
ORDER BY month DESC, total_amount DESC;
```

---

## 7. 算法性能对比与优化

### 7.1 分组操作对比

| 操作 | 分组数 | 适用场景 | 性能 | 内存需求 |
|------|--------|---------|------|----------|
| **GROUP BY** | 1 | 单维度分组 | 快 | 低 |
| **GROUPING SETS** | $k$（指定） | 多维度组合 | 中 | 中 |
| **CUBE** | $2^n$ | 全维度组合 | 慢 | 高 |
| **ROLLUP** | $n+1$ | 层次汇总 | 中 | 中 |

### 7.2 性能优化建议

1. **索引优化**：
   - 在分组列上创建索引
   - 使用复合索引支持多列分组
   - 考虑覆盖索引

2. **查询优化**：
   - 使用HAVING过滤分组结果
   - 避免不必要的CUBE操作
   - 使用物化视图缓存结果

3. **内存管理**：
   - 监控work_mem使用
   - 对于大数据集，考虑分批处理
   - 使用LIMIT限制结果集

4. **算法选择**：
   - 单维度：使用GROUP BY
   - 多维度组合：使用GROUPING SETS
   - 全维度：使用CUBE（谨慎使用）
   - 层次汇总：使用ROLLUP

### 7.3 常见问题与解决方案

**问题1**：CUBE操作性能差

- **解决方案**：减少分组列数、使用GROUPING SETS替代、使用物化视图

**问题2**：分组结果过多

- **解决方案**：使用HAVING过滤、使用LIMIT限制、优化分组列选择

**问题3**：内存不足

- **解决方案**：增加work_mem、分批处理、使用物化视图

**问题4**：GROUPING函数使用错误

- **解决方案**：理解GROUPING函数含义、正确使用NULL值判断

---

## 8. 最佳实践

### 8.1 分组列选择

1. **选择高选择性列**：
   - 选择唯一值多的列
   - 避免低选择性列（如性别）

2. **考虑业务需求**：
   - 根据分析需求选择分组列
   - 考虑层次结构

3. **性能考虑**：
   - 限制分组列数量
   - 使用索引优化

### 8.2 聚合函数使用

1. **选择合适的聚合函数**：
   - COUNT：计数
   - SUM：求和
   - AVG：平均值
   - MAX/MIN：最值

2. **处理NULL值**：
   - COUNT(*)：包含NULL
   - COUNT(column)：排除NULL
   - 使用COALESCE处理NULL

3. **精度考虑**：
   - 使用ROUND控制小数位数
   - 注意数值精度

### 8.3 分组操作选择

1. **GROUP BY**：单维度分组
2. **GROUPING SETS**：多维度组合，灵活控制
3. **CUBE**：全维度组合，谨慎使用
4. **ROLLUP**：层次汇总，适合时间序列

### 8.4 SQL实现注意事项

1. **SELECT子句**：
   - 只能包含分组列和聚合函数
   - 不能包含非分组列（除非使用聚合函数）

2. **ORDER BY**：
   - 可以使用分组列和聚合函数
   - 使用GROUPING函数排序

3. **HAVING vs WHERE**：
   - WHERE：过滤原始数据
   - HAVING：过滤分组结果

4. **性能测试**：
   - 使用EXPLAIN (ANALYZE, BUFFERS, TIMING)分析
   - 监控执行时间和内存使用

---

## 📚 参考资源

### 学术文献

1. **《数据库系统概念》**（Silberschatz et al., 2019）- 第5章 SQL

2. **《SQL权威指南》**（Date, C. J., 2003）- GROUP BY和聚合函数

3. **PostgreSQL官方文档** - GROUP BY、GROUPING SETS、CUBE、ROLLUP

### PostgreSQL官方文档

- **GROUP BY**: <https://www.postgresql.org/docs/current/sql-select.html#SQL-GROUPBY>
- **GROUPING SETS**: <https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUPING-SETS>
- **CUBE和ROLLUP**: <https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUPING-SETS>
- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>

### 在线资源

- **SQL分组操作**: <https://www.postgresql.org/docs/current/tutorial-agg.html>
- **多维分析**: <https://www.postgresql.org/docs/current/tutorial-advanced.html>
- **性能优化**: <https://www.postgresql.org/docs/current/performance-tips.html>

### 相关算法

- **描述性统计**：分组统计的基础
- **窗口函数统计**：分组统计的扩展
- **聚合统计分析**：分组统计的应用
- **查询优化算法**：分组查询优化

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
