# PostgreSQL æµå¼èšåˆç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æµå¤„ç† | å®æ—¶è®¡ç®— | æ»‘åŠ¨çª—å£
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
> **å‚è€ƒæ ‡å‡†**: Stream Processing, Real-time Analytics, Window Functions

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æµå¼èšåˆç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æµå¼èšåˆç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æµå¼å¤„ç†æ¦‚è¿°](#æµå¼å¤„ç†æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [çª—å£ç±»å‹](#çª—å£ç±»å‹)
    - [æ—¶é—´è¯­ä¹‰](#æ—¶é—´è¯­ä¹‰)
  - [1. æ»šåŠ¨çª—å£](#1-æ»šåŠ¨çª—å£)
    - [1.1 å›ºå®šçª—å£](#11-å›ºå®šçª—å£)
    - [1.2 æ—¶é—´çª—å£](#12-æ—¶é—´çª—å£)
  - [2. æ»‘åŠ¨çª—å£](#2-æ»‘åŠ¨çª—å£)
    - [2.1 æ»‘åŠ¨çª—å£èšåˆ](#21-æ»‘åŠ¨çª—å£èšåˆ)
    - [2.2 å¢é‡æ›´æ–°](#22-å¢é‡æ›´æ–°)
  - [3. ä¼šè¯çª—å£](#3-ä¼šè¯çª—å£)
    - [3.1 ä¼šè¯è¯†åˆ«](#31-ä¼šè¯è¯†åˆ«)
  - [4. æ°´ä½çº¿å¤„ç†](#4-æ°´ä½çº¿å¤„ç†)
    - [4.1 äº‹ä»¶æ—¶é—´](#41-äº‹ä»¶æ—¶é—´)
  - [5. å¤æ‚åº¦åˆ†æ](#5-å¤æ‚åº¦åˆ†æ)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [6.1 å®æ—¶ç›‘æ§](#61-å®æ—¶ç›‘æ§)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## æµå¼å¤„ç†æ¦‚è¿°

**æµå¼å¤„ç†**æ˜¯å¯¹è¿ç»­æ•°æ®æµè¿›è¡Œå®æ—¶è®¡ç®—å’Œåˆ†æçš„æŠ€æœ¯ã€‚

### ç†è®ºåŸºç¡€

æµå¼å¤„ç†çš„æ ¸å¿ƒæ˜¯**çª—å£ï¼ˆWindowï¼‰**æ¦‚å¿µï¼Œå°†æ— é™æµæ•°æ®åˆ’åˆ†ä¸ºæœ‰é™çš„æ—¶é—´æ®µè¿›è¡Œå¤„ç†ã€‚

### çª—å£ç±»å‹

| çª—å£ç±»å‹ | ç‰¹ç‚¹ | åº”ç”¨åœºæ™¯ |
|---------|------|---------|
| **æ»šåŠ¨çª—å£** | å›ºå®šå¤§å°ï¼Œä¸é‡å  | å®šæœŸæŠ¥è¡¨ |
| **æ»‘åŠ¨çª—å£** | å›ºå®šå¤§å°ï¼Œæœ‰é‡å  | ç§»åŠ¨å¹³å‡ |
| **ä¼šè¯çª—å£** | åŠ¨æ€å¤§å°ï¼ŒåŸºäºæ´»åŠ¨ | ç”¨æˆ·ä¼šè¯åˆ†æ |

### æ—¶é—´è¯­ä¹‰

- **å¤„ç†æ—¶é—´ï¼ˆProcessing Timeï¼‰**: æ•°æ®è¢«å¤„ç†çš„æ—¶é—´
- **äº‹ä»¶æ—¶é—´ï¼ˆEvent Timeï¼‰**: äº‹ä»¶å®é™…å‘ç”Ÿçš„æ—¶é—´

---

## 1. æ»šåŠ¨çª—å£

### 1.1 å›ºå®šçª—å£

**å›ºå®šçª—å£**å°†æ•°æ®æµåˆ’åˆ†ä¸ºå›ºå®šå¤§å°çš„ä¸é‡å çª—å£ã€‚

```sql
-- æµå¼æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data') THEN
            RAISE WARNING 'è¡¨ stream_data å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE stream_data CASCADE;
        END IF;

        CREATE TABLE stream_data (
            event_id SERIAL PRIMARY KEY,
            event_time TIMESTAMP NOT NULL,
            value NUMERIC NOT NULL,
            category VARCHAR(20) NOT NULL
        );

        -- æ’å…¥æµå¼æ•°æ®
        INSERT INTO stream_data (event_time, value, category) VALUES
            ('2024-01-01 10:00:00', 10, 'A'),
            ('2024-01-01 10:01:00', 15, 'A'),
            ('2024-01-01 10:02:00', 20, 'B'),
            ('2024-01-01 10:03:00', 25, 'B'),
            ('2024-01-01 10:04:00', 30, 'A');

        RAISE NOTICE 'è¡¨ stream_data åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ stream_data å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æ»šåŠ¨çª—å£èšåˆï¼ˆ5åˆ†é’Ÿçª—å£ï¼‰
WITH windowed_data AS (
    SELECT
        DATE_TRUNC('minute', event_time) AS window_start,
        DATE_TRUNC('minute', event_time) + INTERVAL '5 minutes' AS window_end,
        category,
        value
    FROM stream_data
),
window_aggregates AS (
    SELECT
        window_start,
        window_end,
        category,
        COUNT(*) AS event_count,
        SUM(value) AS total_value,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value
    FROM windowed_data
    GROUP BY window_start, window_end, category
)
SELECT
    window_start,
    window_end,
    category,
    event_count,
    ROUND(total_value::numeric, 2) AS total_value,
    ROUND(avg_value::numeric, 2) AS avg_value
FROM window_aggregates
ORDER BY window_start, category;
```

### 1.2 æ—¶é—´çª—å£

**æ—¶é—´çª—å£**åŸºäºæ—¶é—´æˆ³è¿›è¡Œçª—å£åˆ’åˆ†ã€‚

```sql
-- æ—¶é—´çª—å£èšåˆï¼ˆä½¿ç”¨date_binï¼‰
WITH time_windows AS (
    SELECT
        date_bin('5 minutes', event_time, '2024-01-01 10:00:00') AS window_start,
        category,
        value
    FROM stream_data
)
SELECT
    window_start,
    category,
    COUNT(*) AS count,
    SUM(value) AS sum_value,
    AVG(value) AS avg_value
FROM time_windows
GROUP BY window_start, category
ORDER BY window_start, category;
```

---

## 2. æ»‘åŠ¨çª—å£

### 2.1 æ»‘åŠ¨çª—å£èšåˆ

**æ»‘åŠ¨çª—å£**æœ‰é‡å ï¼Œæ¯ä¸ªæ—¶é—´ç‚¹éƒ½æœ‰å¯¹åº”çš„çª—å£ã€‚

```sql
-- æ»‘åŠ¨çª—å£èšåˆï¼ˆçª—å£å¤§å°5åˆ†é’Ÿï¼Œæ»‘åŠ¨1åˆ†é’Ÿï¼‰
WITH sliding_windows AS (
    SELECT
        event_time,
        category,
        value,
        -- è®¡ç®—æ¯ä¸ªäº‹ä»¶æ‰€å±çš„æ»‘åŠ¨çª—å£
        date_bin('1 minute', event_time, '2024-01-01 10:00:00') AS window_start
    FROM stream_data
),
window_aggregates AS (
    SELECT
        window_start,
        category,
        COUNT(*) AS event_count,
        SUM(value) AS total_value,
        AVG(value) AS avg_value
    FROM sliding_windows
    GROUP BY window_start, category
)
SELECT
    window_start,
    category,
    event_count,
    ROUND(total_value::numeric, 2) AS total_value,
    ROUND(avg_value::numeric, 2) AS moving_avg
FROM window_aggregates
ORDER BY window_start, category;
```

### 2.2 å¢é‡æ›´æ–°

**å¢é‡æ›´æ–°**åªå¤„ç†æ–°æ•°æ®ï¼Œæé«˜æ•ˆç‡ã€‚

```sql
-- å¢é‡æ»‘åŠ¨çª—å£æ›´æ–°
WITH new_events AS (
    SELECT * FROM stream_data
    WHERE event_time > (SELECT MAX(last_processed_time) FROM window_state)
),
updated_windows AS (
    SELECT
        window_start,
        category,
        -- åˆå¹¶æ—§çª—å£çŠ¶æ€å’Œæ–°äº‹ä»¶
        COALESCE(old_count, 0) + new_count AS total_count,
        COALESCE(old_sum, 0) + new_sum AS total_sum
    FROM window_state ws
    FULL OUTER JOIN (
        SELECT
            date_bin('1 minute', event_time, '2024-01-01 10:00:00') AS window_start,
            category,
            COUNT(*) AS new_count,
            SUM(value) AS new_sum
        FROM new_events
        GROUP BY window_start, category
    ) ne USING (window_start, category)
)
SELECT * FROM updated_windows;
```

---

## 3. ä¼šè¯çª—å£

### 3.1 ä¼šè¯è¯†åˆ«

**ä¼šè¯çª—å£**åŸºäºæ´»åŠ¨é—´éš”åŠ¨æ€åˆ’åˆ†çª—å£ã€‚

```sql
-- ä¼šè¯çª—å£è¯†åˆ«
WITH session_identification AS (
    SELECT
        event_time,
        category,
        value,
        event_time - LAG(event_time) OVER (PARTITION BY category ORDER BY event_time) AS time_gap,
        CASE
            WHEN event_time - LAG(event_time) OVER (PARTITION BY category ORDER BY event_time) > INTERVAL '5 minutes'
                 OR LAG(event_time) OVER (PARTITION BY category ORDER BY event_time) IS NULL
            THEN 1
            ELSE 0
        END AS session_start
    FROM stream_data
),
session_ids AS (
    SELECT
        event_time,
        category,
        value,
        SUM(session_start) OVER (PARTITION BY category ORDER BY event_time) AS session_id
    FROM session_identification
)
SELECT
    category,
    session_id,
    MIN(event_time) AS session_start,
    MAX(event_time) AS session_end,
    COUNT(*) AS event_count,
    SUM(value) AS session_total
FROM session_ids
GROUP BY category, session_id
ORDER BY category, session_start;
```

---

## 4. æ°´ä½çº¿å¤„ç†

### 4.1 äº‹ä»¶æ—¶é—´

**äº‹ä»¶æ—¶é—´**å¤„ç†åŸºäºäº‹ä»¶å®é™…å‘ç”Ÿæ—¶é—´ã€‚

```sql
-- äº‹ä»¶æ—¶é—´çª—å£å¤„ç†
WITH event_time_windows AS (
    SELECT
        event_time AS event_ts,
        processing_time AS processing_ts,
        category,
        value,
        date_bin('5 minutes', event_time, '2024-01-01 10:00:00') AS event_window
    FROM stream_data
),
watermark AS (
    SELECT
        MAX(event_time) - INTERVAL '1 minute' AS current_watermark
    FROM stream_data
),
completed_windows AS (
    SELECT
        event_window,
        category,
        COUNT(*) AS count,
        SUM(value) AS sum_value
    FROM event_time_windows
    WHERE event_time <= (SELECT current_watermark FROM watermark)
    GROUP BY event_window, category
)
SELECT
    event_window,
    category,
    count,
    ROUND(sum_value::numeric, 2) AS sum_value
FROM completed_windows
ORDER BY event_window, category;
```

---

## 5. å¤æ‚åº¦åˆ†æ

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
|------|-----------|-----------|
| **æ»šåŠ¨çª—å£** | $O(n)$ | $O(w)$ |
| **æ»‘åŠ¨çª—å£** | $O(nw)$ | $O(w)$ |
| **ä¼šè¯çª—å£** | $O(n \log n)$ | $O(n)$ |

å…¶ä¸­ $n$ æ˜¯äº‹ä»¶æ•°ï¼Œ$w$ æ˜¯çª—å£å¤§å°ã€‚

---

## 6. PostgreSQL 18 å¹¶è¡Œæµå¼èšåˆå¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œæµå¼èšåˆè®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œæ»šåŠ¨çª—å£ã€æ»‘åŠ¨çª—å£å’Œä¼šè¯çª—å£èšåˆï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡æµå¼æ•°æ®å¤„ç†çš„æ€§èƒ½ã€‚

### 6.1 å¹¶è¡Œæµå¼èšåˆåŸç†

PostgreSQL 18 çš„å¹¶è¡Œæµå¼èšåˆé€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«ææµå¼æ•°æ®
2. **å¹¶è¡Œçª—å£åˆ’åˆ†**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹åˆ’åˆ†æ—¶é—´çª—å£
3. **å¹¶è¡Œçª—å£èšåˆ**ï¼šå¹¶è¡Œæ‰§è¡Œçª—å£å†…èšåˆè®¡ç®—
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„èšåˆç»“æœ

### 6.2 å¹¶è¡Œæ»šåŠ¨çª—å£èšåˆ

```sql
-- PostgreSQL 18 å¹¶è¡Œæ»šåŠ¨çª—å£èšåˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data') THEN
            RAISE WARNING 'è¡¨ stream_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæ»šåŠ¨çª—å£èšåˆ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæ»šåŠ¨çª—å£èšåˆ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ»šåŠ¨çª—å£èšåˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œæ»šåŠ¨çª—å£ï¼š5åˆ†é’Ÿçª—å£èšåˆ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date_bin('5 minutes', event_time, '2024-01-01 00:00:00') AS window_start,
    category,
    COUNT(*) AS event_count,
    SUM(value) AS total_value,
    AVG(value) AS avg_value,
    MAX(value) AS max_value,
    MIN(value) AS min_value
FROM stream_data
WHERE event_time >= CURRENT_DATE - INTERVAL '1 day'
GROUP BY window_start, category
ORDER BY window_start, category;
```

### 6.3 å¹¶è¡Œæ»‘åŠ¨çª—å£èšåˆ

```sql
-- PostgreSQL 18 å¹¶è¡Œæ»‘åŠ¨çª—å£èšåˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data') THEN
            RAISE WARNING 'è¡¨ stream_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæ»‘åŠ¨çª—å£èšåˆ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæ»‘åŠ¨çª—å£èšåˆ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ»‘åŠ¨çª—å£èšåˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œæ»‘åŠ¨çª—å£ï¼šç§»åŠ¨å¹³å‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    event_time,
    category,
    value,
    AVG(value) OVER (
        PARTITION BY category
        ORDER BY event_time
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS moving_avg_5,
    AVG(value) OVER (
        PARTITION BY category
        ORDER BY event_time
        ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
    ) AS moving_avg_10
FROM stream_data
WHERE event_time >= CURRENT_DATE - INTERVAL '1 day'
ORDER BY event_time, category;
```

### 6.4 å¹¶è¡Œä¼šè¯çª—å£èšåˆ

```sql
-- PostgreSQL 18 å¹¶è¡Œä¼šè¯çª—å£èšåˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data') THEN
            RAISE WARNING 'è¡¨ stream_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œä¼šè¯çª—å£èšåˆ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œä¼šè¯çª—å£èšåˆ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œä¼šè¯çª—å£èšåˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œä¼šè¯çª—å£ï¼šä¼šè¯è¯†åˆ«å’Œèšåˆ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH session_windows AS (
    SELECT
        event_time,
        category,
        value,
        SUM(CASE WHEN time_gap > INTERVAL '5 minutes' OR time_gap IS NULL THEN 1 ELSE 0 END)
            OVER (PARTITION BY category ORDER BY event_time) AS session_id
    FROM (
        SELECT
            event_time,
            category,
            value,
            event_time - LAG(event_time) OVER (PARTITION BY category ORDER BY event_time) AS time_gap
        FROM stream_data
        WHERE event_time >= CURRENT_DATE - INTERVAL '1 day'
    ) AS with_gaps
)
SELECT
    category,
    session_id,
    COUNT(*) AS session_events,
    SUM(value) AS session_total,
    AVG(value) AS session_avg,
    MIN(event_time) AS session_start,
    MAX(event_time) AS session_end
FROM session_windows
GROUP BY category, session_id
ORDER BY category, session_id;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 6.1 å®æ—¶ç›‘æ§

```sql
-- å®æ—¶ç›‘æ§æµå¼èšåˆ
WITH real_time_metrics AS (
    SELECT
        date_bin('1 minute', event_time, NOW()) AS time_window,
        category,
        COUNT(*) AS event_rate,
        AVG(value) AS avg_value,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY value) AS p95_value
    FROM stream_data
    WHERE event_time >= NOW() - INTERVAL '10 minutes'
    GROUP BY time_window, category
)
SELECT
    time_window,
    category,
    event_rate,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(p95_value::numeric, 2) AS p95_value
FROM real_time_metrics
ORDER BY time_window DESC, category;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Akidau, T., et al. (2015)**: "The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost"
2. **Carbone, P., et al. (2015)**: "Apache Flink: Stream and Batch Processing"

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**: åœ¨æ—¶é—´å­—æ®µä¸Šåˆ›å»ºç´¢å¼•
2. **ç‰©åŒ–è§†å›¾**: ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜çª—å£ç»“æœ
3. **å¹¶è¡Œå¤„ç†**: åˆ©ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢

## ğŸ¯ æœ€ä½³å®è·µ

1. **çª—å£å¤§å°**: æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©çª—å£å¤§å°
2. **å»¶è¿Ÿå¤„ç†**: å¤„ç†ä¹±åºå’Œå»¶è¿Ÿæ•°æ®
3. **çŠ¶æ€ç®¡ç†**: æœ‰æ•ˆç®¡ç†çª—å£çŠ¶æ€
4. **ç›‘æ§**: ç›‘æ§æµå¤„ç†æ€§èƒ½

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
