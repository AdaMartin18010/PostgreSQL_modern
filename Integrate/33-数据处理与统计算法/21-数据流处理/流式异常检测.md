# PostgreSQL æµå¼å¼‚å¸¸æ£€æµ‹ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æµå¤„ç† | å¼‚å¸¸æ£€æµ‹ | å®æ—¶ç›‘æ§
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
> **å‚è€ƒæ ‡å‡†**: Stream Anomaly Detection, Concept Drift, Real-time Monitoring

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æµå¼å¼‚å¸¸æ£€æµ‹ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æµå¼å¼‚å¸¸æ£€æµ‹ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æµå¼å¼‚å¸¸æ£€æµ‹æ¦‚è¿°](#æµå¼å¼‚å¸¸æ£€æµ‹æ¦‚è¿°)
    - [æ£€æµ‹æ–¹æ³•](#æ£€æµ‹æ–¹æ³•)
  - [1. ç»Ÿè®¡å¼‚å¸¸æ£€æµ‹](#1-ç»Ÿè®¡å¼‚å¸¸æ£€æµ‹)
    - [1.1 Z-scoreæ–¹æ³•](#11-z-scoreæ–¹æ³•)
    - [1.2 IQRæ–¹æ³•](#12-iqræ–¹æ³•)
  - [2. æ¦‚å¿µæ¼‚ç§»æ£€æµ‹](#2-æ¦‚å¿µæ¼‚ç§»æ£€æµ‹)
    - [2.1 åˆ†å¸ƒå˜åŒ–æ£€æµ‹](#21-åˆ†å¸ƒå˜åŒ–æ£€æµ‹)
    - [2.2 è‡ªé€‚åº”é˜ˆå€¼](#22-è‡ªé€‚åº”é˜ˆå€¼)
  - [3. æ—¶é—´åºåˆ—å¼‚å¸¸æ£€æµ‹](#3-æ—¶é—´åºåˆ—å¼‚å¸¸æ£€æµ‹)
    - [3.1 è¶‹åŠ¿å¼‚å¸¸æ£€æµ‹](#31-è¶‹åŠ¿å¼‚å¸¸æ£€æµ‹)
  - [4. PostgreSQL 18 å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹å¢å¼º](#4-postgresql-18-å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹å¢å¼º)
    - [4.1 å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹åŸç†](#41-å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹åŸç†)
    - [4.2 å¹¶è¡ŒZ-scoreå¼‚å¸¸æ£€æµ‹](#42-å¹¶è¡Œz-scoreå¼‚å¸¸æ£€æµ‹)
    - [4.3 å¹¶è¡Œæ¦‚å¿µæ¼‚ç§»æ£€æµ‹](#43-å¹¶è¡Œæ¦‚å¿µæ¼‚ç§»æ£€æµ‹)
  - [5. æ€§èƒ½ä¼˜åŒ–](#5-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 å¢é‡æ›´æ–°](#41-å¢é‡æ›´æ–°)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## æµå¼å¼‚å¸¸æ£€æµ‹æ¦‚è¿°

**æµå¼å¼‚å¸¸æ£€æµ‹**å®æ—¶è¯†åˆ«æ•°æ®æµä¸­çš„å¼‚å¸¸æ¨¡å¼ï¼Œç”¨äºç›‘æ§ã€é¢„è­¦å’Œæ•…éšœæ£€æµ‹ã€‚

### æ£€æµ‹æ–¹æ³•

| æ–¹æ³• | åŸç† | é€‚ç”¨åœºæ™¯ |
|------|------|---------|
| **ç»Ÿè®¡æ–¹æ³•** | Z-scoreã€IQR | å•å˜é‡å¼‚å¸¸ |
| **æ—¶é—´åºåˆ—** | ç§»åŠ¨å¹³å‡ã€æŒ‡æ•°å¹³æ»‘ | è¶‹åŠ¿å¼‚å¸¸ |
| **æ¦‚å¿µæ¼‚ç§»** | åˆ†å¸ƒå˜åŒ–æ£€æµ‹ | æ•°æ®åˆ†å¸ƒå˜åŒ– |

---

## 1. ç»Ÿè®¡å¼‚å¸¸æ£€æµ‹

### 1.1 Z-scoreæ–¹æ³•

**Z-score**åŸºäºæ ‡å‡†å·®è¯†åˆ«å¼‚å¸¸å€¼ã€‚

$$z = \frac{x - \mu}{\sigma}$$

```sql
-- æµæ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data') THEN
            DROP TABLE stream_data CASCADE;
        END IF;

        CREATE TABLE stream_data (
            event_id SERIAL PRIMARY KEY,
            event_time TIMESTAMP NOT NULL,
            value NUMERIC NOT NULL,
            metric_name VARCHAR(50) DEFAULT 'default_metric'
        );

        -- æ’å…¥ç¤ºä¾‹æµæ•°æ®ï¼ˆæ­£å¸¸å€¼ + å¼‚å¸¸å€¼ï¼‰
        INSERT INTO stream_data (event_time, value)
        SELECT
            '2024-01-01 10:00:00'::TIMESTAMP + (i * INTERVAL '1 second'),
            CASE
                WHEN i BETWEEN 50 AND 55 THEN 100.0 + (RANDOM() - 0.5) * 10  -- å¼‚å¸¸å€¼
                ELSE 10.0 + (RANDOM() - 0.5) * 2  -- æ­£å¸¸å€¼
            END
        FROM generate_series(1, 100) i;

        CREATE INDEX idx_stream_time ON stream_data(event_time);

        RAISE NOTICE 'æµæ•°æ®è¡¨åˆ›å»ºæˆåŠŸï¼Œå…± % æ¡è®°å½•', (SELECT COUNT(*) FROM stream_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æµå¼å¼‚å¸¸æ£€æµ‹ï¼ˆåŸºäºZ-scoreï¼Œæ»‘åŠ¨çª—å£ï¼‰
WITH stream_stats AS (
    SELECT
        event_id,
        event_time,
        value,
        AVG(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS moving_avg,
        STDDEV(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS moving_std,
        COUNT(*) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS window_size
    FROM stream_data
    WHERE event_time >= NOW() - INTERVAL '1 hour'
),
z_scores AS (
    SELECT
        event_id,
        event_time,
        value,
        moving_avg,
        moving_std,
        (value - moving_avg) / NULLIF(moving_std, 0) AS z_score,
        window_size
    FROM stream_stats
    WHERE window_size >= 10  -- è‡³å°‘10ä¸ªæ ·æœ¬
)
SELECT
    event_id,
    event_time,
    ROUND(value::numeric, 2) AS value,
    ROUND(moving_avg::numeric, 2) AS moving_avg,
    ROUND(moving_std::numeric, 2) AS moving_std,
    ROUND(z_score::numeric, 4) AS z_score,
    CASE
        WHEN ABS(z_score) > 3 THEN 'Severe Anomaly'
        WHEN ABS(z_score) > 2 THEN 'Moderate Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM z_scores
ORDER BY event_time;
```

### 1.2 IQRæ–¹æ³•

**IQRï¼ˆå››åˆ†ä½è·ï¼‰æ–¹æ³•**åŸºäºå››åˆ†ä½æ•°è¯†åˆ«å¼‚å¸¸å€¼ã€‚

```sql
-- IQRå¼‚å¸¸æ£€æµ‹
WITH quartiles AS (
    SELECT
        event_time,
        value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS q3
    FROM stream_data
    WHERE event_time >= NOW() - INTERVAL '1 hour'
),
iqr_bounds AS (
    SELECT
        event_time,
        value,
        q1,
        q3,
        q3 - q1 AS iqr,
        q1 - 1.5 * (q3 - q1) AS lower_bound,
        q3 + 1.5 * (q3 - q1) AS upper_bound
    FROM quartiles
)
SELECT
    event_time,
    ROUND(value::numeric, 2) AS value,
    ROUND(lower_bound::numeric, 2) AS lower_bound,
    ROUND(upper_bound::numeric, 2) AS upper_bound,
    CASE
        WHEN value < lower_bound OR value > upper_bound THEN 'Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM iqr_bounds
ORDER BY event_time;
```

---

## 2. æ¦‚å¿µæ¼‚ç§»æ£€æµ‹

### 2.1 åˆ†å¸ƒå˜åŒ–æ£€æµ‹

**æ¦‚å¿µæ¼‚ç§»**æ£€æµ‹æ•°æ®åˆ†å¸ƒçš„å˜åŒ–ã€‚

```sql
-- æ¦‚å¿µæ¼‚ç§»æ£€æµ‹ï¼šæ¯”è¾ƒä¸¤ä¸ªæ—¶é—´çª—å£çš„åˆ†å¸ƒ
WITH window1_stats AS (
    SELECT
        AVG(value) AS mean1,
        STDDEV(value) AS std1,
        COUNT(*) AS count1
    FROM stream_data
    WHERE event_time BETWEEN NOW() - INTERVAL '1 hour' AND NOW() - INTERVAL '30 minutes'
),
window2_stats AS (
    SELECT
        AVG(value) AS mean2,
        STDDEV(value) AS std2,
        COUNT(*) AS count2
    FROM stream_data
    WHERE event_time >= NOW() - INTERVAL '30 minutes'
),
drift_detection AS (
    SELECT
        w1.mean1,
        w2.mean2,
        w1.std1,
        w2.std2,
        ABS(w1.mean1 - w2.mean2) AS mean_drift,
        ABS(w1.std1 - w2.std2) AS std_drift,
        -- Kolmogorov-Smirnovç»Ÿè®¡é‡ï¼ˆç®€åŒ–ï¼‰
        ABS(w1.mean1 - w2.mean2) / NULLIF((w1.std1 + w2.std2) / 2, 0) AS ks_statistic
    FROM window1_stats w1
    CROSS JOIN window2_stats w2
)
SELECT
    ROUND(mean1::numeric, 2) AS window1_mean,
    ROUND(mean2::numeric, 2) AS window2_mean,
    ROUND(mean_drift::numeric, 2) AS mean_drift,
    ROUND(ks_statistic::numeric, 4) AS ks_statistic,
    CASE
        WHEN ks_statistic > 2.0 THEN 'Significant drift detected âœ“'
        WHEN ks_statistic > 1.0 THEN 'Moderate drift'
        ELSE 'No significant drift'
    END AS drift_status
FROM drift_detection;
```

### 2.2 è‡ªé€‚åº”é˜ˆå€¼

**è‡ªé€‚åº”é˜ˆå€¼**æ ¹æ®æ•°æ®åˆ†å¸ƒåŠ¨æ€è°ƒæ•´å¼‚å¸¸é˜ˆå€¼ã€‚

```sql
-- è‡ªé€‚åº”é˜ˆå€¼ï¼šåŸºäºå†å²æ•°æ®åŠ¨æ€è°ƒæ•´
WITH adaptive_thresholds AS (
    SELECT
        event_time,
        value,
        AVG(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 99 PRECEDING AND CURRENT ROW
        ) AS adaptive_mean,
        STDDEV(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 99 PRECEDING AND CURRENT ROW
        ) AS adaptive_std,
        -- è‡ªé€‚åº”é˜ˆå€¼ï¼šå‡å€¼ Â± k*æ ‡å‡†å·®ï¼ˆkæ ¹æ®å†å²å¼‚å¸¸ç‡è°ƒæ•´ï¼‰
        AVG(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 99 PRECEDING AND CURRENT ROW
        ) - 2.5 * STDDEV(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 99 PRECEDING AND CURRENT ROW
        ) AS lower_threshold,
        AVG(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 99 PRECEDING AND CURRENT ROW
        ) + 2.5 * STDDEV(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 99 PRECEDING AND CURRENT ROW
        ) AS upper_threshold
    FROM stream_data
    WHERE event_time >= NOW() - INTERVAL '1 hour'
)
SELECT
    event_time,
    ROUND(value::numeric, 2) AS value,
    ROUND(lower_threshold::numeric, 2) AS lower_threshold,
    ROUND(upper_threshold::numeric, 2) AS upper_threshold,
    CASE
        WHEN value < lower_threshold OR value > upper_threshold THEN 'Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM adaptive_thresholds
ORDER BY event_time;
```

---

## 3. æ—¶é—´åºåˆ—å¼‚å¸¸æ£€æµ‹

### 3.1 è¶‹åŠ¿å¼‚å¸¸æ£€æµ‹

```sql
-- è¶‹åŠ¿å¼‚å¸¸æ£€æµ‹ï¼šæ£€æµ‹åç¦»è¶‹åŠ¿çš„ç‚¹
WITH trend_analysis AS (
    SELECT
        event_time,
        value,
        -- çº¿æ€§è¶‹åŠ¿ï¼ˆä½¿ç”¨çº¿æ€§å›å½’ï¼‰
        REGR_SLOPE(value, EXTRACT(EPOCH FROM event_time)) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS trend_slope,
        REGR_INTERCEPT(value, EXTRACT(EPOCH FROM event_time)) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS trend_intercept,
        -- é¢„æµ‹å€¼
        REGR_INTERCEPT(value, EXTRACT(EPOCH FROM event_time)) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) +
        REGR_SLOPE(value, EXTRACT(EPOCH FROM event_time)) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) * EXTRACT(EPOCH FROM event_time) AS predicted_value
    FROM stream_data
    WHERE event_time >= NOW() - INTERVAL '1 hour'
),
residuals AS (
    SELECT
        event_time,
        value,
        predicted_value,
        value - predicted_value AS residual,
        STDDEV(value - predicted_value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS residual_std
    FROM trend_analysis
)
SELECT
    event_time,
    ROUND(value::numeric, 2) AS value,
    ROUND(predicted_value::numeric, 2) AS predicted,
    ROUND(residual::numeric, 2) AS residual,
    CASE
        WHEN ABS(residual) > 3 * residual_std THEN 'Trend Anomaly'
        ELSE 'Normal'
    END AS anomaly_status
FROM residuals
ORDER BY event_time;
```

---

## 4. PostgreSQL 18 å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œç»Ÿè®¡å¼‚å¸¸æ£€æµ‹ã€æ¦‚å¿µæ¼‚ç§»æ£€æµ‹å’Œæ—¶é—´åºåˆ—å¼‚å¸¸æ£€æµ‹ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡æµå¼å¼‚å¸¸æ£€æµ‹çš„æ€§èƒ½ã€‚

### 4.1 å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹åŸç†

PostgreSQL 18 çš„å¹¶è¡Œæµå¼å¼‚å¸¸æ£€æµ‹é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«ææµå¼æ•°æ®
2. **å¹¶è¡Œç»Ÿè®¡è®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡
3. **å¹¶è¡Œå¼‚å¸¸è¯†åˆ«**ï¼šå¹¶è¡Œæ‰§è¡Œå¼‚å¸¸æ£€æµ‹å’Œæ ‡è®°
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„æ£€æµ‹ç»“æœ

### 4.2 å¹¶è¡ŒZ-scoreå¼‚å¸¸æ£€æµ‹

```sql
-- PostgreSQL 18 å¹¶è¡ŒZ-scoreå¼‚å¸¸æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data') THEN
            RAISE WARNING 'è¡¨ stream_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒZ-scoreå¼‚å¸¸æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒZ-scoreå¼‚å¸¸æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒZ-scoreå¼‚å¸¸æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒZ-scoreè®¡ç®—å’Œå¼‚å¸¸æ ‡è®°
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH stream_stats AS (
    SELECT
        event_id,
        event_time,
        value,
        AVG(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS moving_avg,
        STDDEV(value) OVER (
            ORDER BY event_time
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS moving_stddev
    FROM stream_data
    WHERE event_time >= CURRENT_DATE - INTERVAL '1 day'
),
z_score_calc AS (
    SELECT
        event_id,
        event_time,
        value,
        moving_avg,
        moving_stddev,
        CASE
            WHEN moving_stddev > 0 THEN (value - moving_avg) / moving_stddev
            ELSE 0
        END AS z_score
    FROM stream_stats
)
SELECT
    event_id,
    event_time,
    ROUND(value::numeric, 2) AS value,
    ROUND(z_score::numeric, 4) AS z_score,
    CASE
        WHEN ABS(z_score) > 3 THEN 'Anomaly âœ“'
        WHEN ABS(z_score) > 2 THEN 'Suspicious'
        ELSE 'Normal'
    END AS anomaly_status
FROM z_score_calc
ORDER BY event_time;
```

### 4.3 å¹¶è¡Œæ¦‚å¿µæ¼‚ç§»æ£€æµ‹

```sql
-- PostgreSQL 18 å¹¶è¡Œæ¦‚å¿µæ¼‚ç§»æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data') THEN
            RAISE WARNING 'è¡¨ stream_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæ¦‚å¿µæ¼‚ç§»æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæ¦‚å¿µæ¼‚ç§»æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ¦‚å¿µæ¼‚ç§»æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œåˆ†å¸ƒå˜åŒ–æ£€æµ‹
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH window_comparison AS (
    SELECT
        AVG(value) FILTER (WHERE event_time >= NOW() - INTERVAL '1 hour' AND event_time < NOW() - INTERVAL '30 minutes') AS window1_mean,
        AVG(value) FILTER (WHERE event_time >= NOW() - INTERVAL '30 minutes') AS window2_mean,
        STDDEV(value) FILTER (WHERE event_time >= NOW() - INTERVAL '1 hour' AND event_time < NOW() - INTERVAL '30 minutes') AS window1_std,
        STDDEV(value) FILTER (WHERE event_time >= NOW() - INTERVAL '30 minutes') AS window2_std
    FROM stream_data
)
SELECT
    ROUND(window1_mean::numeric, 4) AS window1_mean,
    ROUND(window2_mean::numeric, 4) AS window2_mean,
    ROUND(ABS(window1_mean - window2_mean)::numeric, 4) AS mean_drift,
    CASE
        WHEN ABS(window1_mean - window2_mean) > 2 * GREATEST(window1_std, window2_std) THEN 'Significant drift detected âœ“'
        ELSE 'No significant drift'
    END AS drift_status
FROM window_comparison;
```

---

## 5. æ€§èƒ½ä¼˜åŒ–

### 4.1 å¢é‡æ›´æ–°

```sql
-- å¢é‡æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
CREATE OR REPLACE FUNCTION update_stream_stats()
RETURNS TRIGGER AS $$
BEGIN
    -- æ›´æ–°ç‰©åŒ–è§†å›¾æˆ–ç»Ÿè®¡è¡¨
    REFRESH MATERIALIZED VIEW CONCURRENTLY stream_stats_view;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
CREATE MATERIALIZED VIEW IF NOT EXISTS stream_stats_view AS
SELECT
    metric_name,
    AVG(value) AS mean_value,
    STDDEV(value) AS std_value,
    MIN(value) AS min_value,
    MAX(value) AS max_value,
    COUNT(*) AS sample_count
FROM stream_data
WHERE event_time >= NOW() - INTERVAL '1 hour'
GROUP BY metric_name;

CREATE UNIQUE INDEX idx_stream_stats ON stream_stats_view(metric_name);
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Chandola, V., et al. (2009)**: "Anomaly Detection: A Survey"
2. **Gama, J., et al. (2014)**: "A Survey on Concept Drift Adaptation"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **æ»‘åŠ¨çª—å£**ï¼šä½¿ç”¨æ»‘åŠ¨çª—å£å‡å°‘è®¡ç®—é‡
2. **å¢é‡æ›´æ–°**ï¼šå¢é‡æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
3. **å¹¶è¡Œå¤„ç†**ï¼šå¹¶è¡Œå¤„ç†å¤šä¸ªæŒ‡æ ‡
4. **ç¼“å­˜ä¼˜åŒ–**ï¼šç¼“å­˜å¸¸ç”¨ç»Ÿè®¡ä¿¡æ¯

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **é˜ˆå€¼é€‰æ‹©**ï¼šæ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚é˜ˆå€¼
2. **çª—å£å¤§å°**ï¼šå¹³è¡¡æ•æ„Ÿåº¦å’Œç¨³å®šæ€§
3. **å¤šæŒ‡æ ‡èåˆ**ï¼šç»“åˆå¤šä¸ªæŒ‡æ ‡æé«˜å‡†ç¡®æ€§
4. **è¯¯æŠ¥å¤„ç†**ï¼šè®¾ç½®æœ€å°å¼‚å¸¸æŒç»­æ—¶é—´å‡å°‘è¯¯æŠ¥

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
