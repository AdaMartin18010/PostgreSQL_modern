# PostgreSQL æµå¼è¿æ¥ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æµå¤„ç† | æµå¼è¿æ¥ | å®æ—¶è®¡ç®—
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
> **å‚è€ƒæ ‡å‡†**: Stream Processing, Stream Joins, Real-time Analytics

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æµå¼è¿æ¥ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æµå¼è¿æ¥ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æµå¼è¿æ¥æ¦‚è¿°](#æµå¼è¿æ¥æ¦‚è¿°)
    - [è¿æ¥ç±»å‹](#è¿æ¥ç±»å‹)
  - [1. æµ-æµè¿æ¥](#1-æµ-æµè¿æ¥)
    - [1.1 æ—¶é—´çª—å£è¿æ¥](#11-æ—¶é—´çª—å£è¿æ¥)
    - [1.2 æ»‘åŠ¨çª—å£è¿æ¥](#12-æ»‘åŠ¨çª—å£è¿æ¥)
  - [2. æµ-è¡¨è¿æ¥](#2-æµ-è¡¨è¿æ¥)
    - [2.1 é™æ€è¡¨è¿æ¥](#21-é™æ€è¡¨è¿æ¥)
    - [2.2 æ—¶æ€è¡¨è¿æ¥](#22-æ—¶æ€è¡¨è¿æ¥)
  - [3. æ—¶é—´çª—å£è¿æ¥](#3-æ—¶é—´çª—å£è¿æ¥)
    - [3.1 æ»šåŠ¨çª—å£è¿æ¥](#31-æ»šåŠ¨çª—å£è¿æ¥)
    - [3.2 æ»‘åŠ¨çª—å£è¿æ¥](#32-æ»‘åŠ¨çª—å£è¿æ¥)
  - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 ç´¢å¼•ä¼˜åŒ–](#41-ç´¢å¼•ä¼˜åŒ–)
    - [4.2 ç‰©åŒ–è§†å›¾ç¼“å­˜](#42-ç‰©åŒ–è§†å›¾ç¼“å­˜)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## æµå¼è¿æ¥æ¦‚è¿°

**æµå¼è¿æ¥**åœ¨æµæ•°æ®ä¹‹é—´æˆ–æµä¸é™æ€è¡¨ä¹‹é—´è¿›è¡Œè¿æ¥æ“ä½œï¼Œæ”¯æŒå®æ—¶æ•°æ®å¤„ç†ã€‚

### è¿æ¥ç±»å‹

| è¿æ¥ç±»å‹ | æè¿° | åº”ç”¨åœºæ™¯ |
|---------|------|---------|
| **æµ-æµè¿æ¥** | ä¸¤ä¸ªæµä¹‹é—´çš„è¿æ¥ | å®æ—¶äº‹ä»¶å…³è” |
| **æµ-è¡¨è¿æ¥** | æµä¸é™æ€è¡¨çš„è¿æ¥ | æ•°æ®ä¸°å¯ŒåŒ– |
| **æ—¶é—´çª—å£è¿æ¥** | åŸºäºæ—¶é—´çª—å£çš„è¿æ¥ | æ—¶é—´åºåˆ—åˆ†æ |

---

## 1. æµ-æµè¿æ¥

### 1.1 æ—¶é—´çª—å£è¿æ¥

**æ—¶é—´çª—å£è¿æ¥**åœ¨æ—¶é—´çª—å£å†…åŒ¹é…æµæ•°æ®ã€‚

```sql
-- æµæ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stream_data_1') THEN
            DROP TABLE stream_data_1, stream_data_2 CASCADE;
        END IF;

        CREATE TABLE stream_data_1 (
            event_id SERIAL PRIMARY KEY,
            event_time TIMESTAMP NOT NULL,
            key VARCHAR(50) NOT NULL,
            value NUMERIC NOT NULL
        );

        CREATE TABLE stream_data_2 (
            event_id SERIAL PRIMARY KEY,
            event_time TIMESTAMP NOT NULL,
            key VARCHAR(50) NOT NULL,
            value NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹æµæ•°æ®
        INSERT INTO stream_data_1 (event_time, key, value) VALUES
            ('2024-01-01 10:00:00', 'A', 10),
            ('2024-01-01 10:00:30', 'B', 20),
            ('2024-01-01 10:01:00', 'A', 15);

        INSERT INTO stream_data_2 (event_time, key, value) VALUES
            ('2024-01-01 10:00:10', 'A', 100),
            ('2024-01-01 10:00:45', 'B', 200),
            ('2024-01-01 10:01:15', 'A', 150);

        CREATE INDEX idx_stream1_time ON stream_data_1(event_time, key);
        CREATE INDEX idx_stream2_time ON stream_data_2(event_time, key);

        RAISE NOTICE 'æµæ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æµ-æµè¿æ¥ï¼šæ—¶é—´çª—å£è¿æ¥ï¼ˆ1åˆ†é’Ÿçª—å£ï¼‰
WITH stream1 AS (
    SELECT
        event_time,
        key,
        value AS value1
    FROM stream_data_1
    WHERE event_time >= NOW() - INTERVAL '1 hour'
),
stream2 AS (
    SELECT
        event_time,
        key,
        value AS value2
    FROM stream_data_2
    WHERE event_time >= NOW() - INTERVAL '1 hour'
),
time_window_join AS (
    SELECT
        s1.event_time AS event_time1,
        s2.event_time AS event_time2,
        s1.key,
        s1.value1,
        s2.value2,
        ABS(EXTRACT(EPOCH FROM (s1.event_time - s2.event_time))) AS time_diff_seconds
    FROM stream1 s1
    JOIN stream2 s2 ON s1.key = s2.key
        AND ABS(EXTRACT(EPOCH FROM (s1.event_time - s2.event_time))) <= 60  -- 1åˆ†é’Ÿçª—å£
)
SELECT
    event_time1,
    event_time2,
    key,
    ROUND(value1::numeric, 2) AS value1,
    ROUND(value2::numeric, 2) AS value2,
    ROUND(time_diff_seconds::numeric, 2) AS time_diff_seconds
FROM time_window_join
ORDER BY event_time1;
```

### 1.2 æ»‘åŠ¨çª—å£è¿æ¥

**æ»‘åŠ¨çª—å£è¿æ¥**ä½¿ç”¨æ»‘åŠ¨æ—¶é—´çª—å£åŒ¹é…æ•°æ®ã€‚

```sql
-- æ»‘åŠ¨çª—å£è¿æ¥ï¼šä½¿ç”¨LATERAL JOIN
SELECT
    s1.event_time,
    s1.key,
    s1.value AS value1,
    s2.value AS value2,
    s2.event_time AS matched_time
FROM stream_data_1 s1
CROSS JOIN LATERAL (
    SELECT
        event_time,
        value
    FROM stream_data_2 s2
    WHERE s2.key = s1.key
      AND s2.event_time BETWEEN s1.event_time - INTERVAL '30 seconds'
                            AND s1.event_time + INTERVAL '30 seconds'
    ORDER BY ABS(EXTRACT(EPOCH FROM (s2.event_time - s1.event_time)))
    LIMIT 1
) s2
ORDER BY s1.event_time;
```

---

## 2. æµ-è¡¨è¿æ¥

### 2.1 é™æ€è¡¨è¿æ¥

**æµ-è¡¨è¿æ¥**å°†æµæ•°æ®ä¸é™æ€è¡¨ï¼ˆç»´åº¦è¡¨ï¼‰è¿æ¥ã€‚

```sql
-- åˆ›å»ºé™æ€ç»´åº¦è¡¨
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'dimension_table') THEN
            DROP TABLE dimension_table CASCADE;
        END IF;

        CREATE TABLE dimension_table (
            key VARCHAR(50) PRIMARY KEY,
            category VARCHAR(50) NOT NULL,
            description TEXT,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        INSERT INTO dimension_table (key, category, description) VALUES
            ('A', 'Category1', 'Description A'),
            ('B', 'Category2', 'Description B'),
            ('C', 'Category1', 'Description C');

        RAISE NOTICE 'ç»´åº¦è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æµ-è¡¨è¿æ¥ï¼šä¸°å¯Œæµæ•°æ®
SELECT
    s.event_time,
    s.key,
    s.value,
    d.category,
    d.description,
    s.value * 1.1 AS enriched_value  -- åŸºäºç±»åˆ«çš„è®¡ç®—
FROM stream_data_1 s
LEFT JOIN dimension_table d ON s.key = d.key
WHERE s.event_time >= NOW() - INTERVAL '1 hour'
ORDER BY s.event_time;
```

### 2.2 æ—¶æ€è¡¨è¿æ¥

**æ—¶æ€è¡¨è¿æ¥**è¿æ¥æµæ•°æ®ä¸æ—¶æ€è¡¨ï¼ˆéšæ—¶é—´å˜åŒ–çš„è¡¨ï¼‰ã€‚

```sql
-- åˆ›å»ºæ—¶æ€è¡¨ï¼ˆç‰ˆæœ¬åŒ–è¡¨ï¼‰
CREATE TABLE temporal_dimension (
    key VARCHAR(50) NOT NULL,
    valid_from TIMESTAMP NOT NULL,
    valid_to TIMESTAMP,
    category VARCHAR(50) NOT NULL,
    PRIMARY KEY (key, valid_from)
);

INSERT INTO temporal_dimension (key, valid_from, valid_to, category) VALUES
    ('A', '2024-01-01', '2024-01-15', 'Category1'),
    ('A', '2024-01-15', NULL, 'Category2'),  -- å½“å‰ç‰ˆæœ¬
    ('B', '2024-01-01', NULL, 'Category2');

-- æ—¶æ€è¡¨è¿æ¥ï¼šæ ¹æ®æ—¶é—´åŒ¹é…ç‰ˆæœ¬
SELECT
    s.event_time,
    s.key,
    s.value,
    td.category AS historical_category
FROM stream_data_1 s
JOIN temporal_dimension td ON s.key = td.key
    AND s.event_time >= td.valid_from
    AND (td.valid_to IS NULL OR s.event_time < td.valid_to)
ORDER BY s.event_time;
```

---

## 3. æ—¶é—´çª—å£è¿æ¥

### 3.1 æ»šåŠ¨çª—å£è¿æ¥

**æ»šåŠ¨çª—å£è¿æ¥**ä½¿ç”¨ä¸é‡å çš„æ—¶é—´çª—å£ã€‚

```sql
-- æ»šåŠ¨çª—å£è¿æ¥ï¼šæŒ‰åˆ†é’Ÿçª—å£
WITH windowed_stream1 AS (
    SELECT
        DATE_TRUNC('minute', event_time) AS window_start,
        key,
        AVG(value) AS avg_value1,
        COUNT(*) AS count1
    FROM stream_data_1
    WHERE event_time >= NOW() - INTERVAL '1 hour'
    GROUP BY DATE_TRUNC('minute', event_time), key
),
windowed_stream2 AS (
    SELECT
        DATE_TRUNC('minute', event_time) AS window_start,
        key,
        AVG(value) AS avg_value2,
        COUNT(*) AS count2
    FROM stream_data_2
    WHERE event_time >= NOW() - INTERVAL '1 hour'
    GROUP BY DATE_TRUNC('minute', event_time), key
)
SELECT
    ws1.window_start,
    ws1.key,
    ROUND(ws1.avg_value1::numeric, 2) AS avg_value1,
    ROUND(ws2.avg_value2::numeric, 2) AS avg_value2,
    ws1.count1,
    ws2.count2
FROM windowed_stream1 ws1
JOIN windowed_stream2 ws2 ON ws1.window_start = ws2.window_start
    AND ws1.key = ws2.key
ORDER BY ws1.window_start;
```

### 3.2 æ»‘åŠ¨çª—å£è¿æ¥

**æ»‘åŠ¨çª—å£è¿æ¥**ä½¿ç”¨é‡å çš„æ—¶é—´çª—å£ã€‚

```sql
-- æ»‘åŠ¨çª—å£è¿æ¥ï¼š30ç§’çª—å£ï¼Œ10ç§’æ»‘åŠ¨
WITH sliding_windows AS (
    SELECT
        generate_series(
            DATE_TRUNC('second', MIN(event_time)),
            DATE_TRUNC('second', MAX(event_time)),
            INTERVAL '10 seconds'
        ) AS window_start
    FROM stream_data_1
    WHERE event_time >= NOW() - INTERVAL '1 hour'
),
windowed_data AS (
    SELECT
        sw.window_start,
        sw.window_start + INTERVAL '30 seconds' AS window_end,
        s1.key,
        AVG(s1.value) AS avg_value1,
        AVG(s2.value) AS avg_value2
    FROM sliding_windows sw
    LEFT JOIN stream_data_1 s1 ON s1.event_time >= sw.window_start
        AND s1.event_time < sw.window_start + INTERVAL '30 seconds'
    LEFT JOIN stream_data_2 s2 ON s2.event_time >= sw.window_start
        AND s2.event_time < sw.window_start + INTERVAL '30 seconds'
        AND s2.key = s1.key
    GROUP BY sw.window_start, s1.key
)
SELECT
    window_start,
    window_end,
    key,
    ROUND(avg_value1::numeric, 2) AS avg_value1,
    ROUND(avg_value2::numeric, 2) AS avg_value2
FROM windowed_data
WHERE avg_value1 IS NOT NULL
ORDER BY window_start;
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå¤åˆç´¢å¼•ä¼˜åŒ–æ—¶é—´çª—å£è¿æ¥
CREATE INDEX IF NOT EXISTS idx_stream1_time_key
ON stream_data_1(event_time, key)
INCLUDE (value);

CREATE INDEX IF NOT EXISTS idx_stream2_time_key
ON stream_data_2(event_time, key)
INCLUDE (value);

-- åˆ†æç´¢å¼•ä½¿ç”¨æƒ…å†µ
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    s1.event_time,
    s1.key,
    s1.value AS value1,
    s2.value AS value2
FROM stream_data_1 s1
JOIN stream_data_2 s2 ON s1.key = s2.key
    AND ABS(EXTRACT(EPOCH FROM (s1.event_time - s2.event_time))) <= 60
WHERE s1.event_time >= NOW() - INTERVAL '1 hour';
```

### 4.2 ç‰©åŒ–è§†å›¾ç¼“å­˜

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜çª—å£è¿æ¥ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS stream_join_cache AS
SELECT
    DATE_TRUNC('minute', s1.event_time) AS window_start,
    s1.key,
    AVG(s1.value) AS avg_value1,
    AVG(s2.value) AS avg_value2,
    COUNT(*) AS join_count
FROM stream_data_1 s1
JOIN stream_data_2 s2 ON s1.key = s2.key
    AND ABS(EXTRACT(EPOCH FROM (s1.event_time - s2.event_time))) <= 60
WHERE s1.event_time >= NOW() - INTERVAL '1 hour'
GROUP BY DATE_TRUNC('minute', s1.event_time), s1.key;

CREATE UNIQUE INDEX idx_stream_join_cache ON stream_join_cache(window_start, key);

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY stream_join_cache;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Akidau, T., et al. (2015)**: "The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale, Unbounded, Out-of-Order Data Processing"
2. **Carbone, P., et al. (2015)**: "Apache Flink: Stream and Batch Processing in a Single Engine"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **æ—¶é—´çª—å£å¤§å°**ï¼šæ ¹æ®æ•°æ®ç‰¹æ€§é€‰æ‹©åˆé€‚çª—å£å¤§å°
2. **ç´¢å¼•ä¼˜åŒ–**ï¼šåœ¨æ—¶é—´å’Œé”®åˆ—ä¸Šåˆ›å»ºç´¢å¼•
3. **å¹¶è¡Œå¤„ç†**ï¼šåˆ©ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢
4. **ç¼“å­˜ç­–ç•¥**ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å¸¸ç”¨è¿æ¥ç»“æœ

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **çª—å£é€‰æ‹©**ï¼šæ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©æ»šåŠ¨æˆ–æ»‘åŠ¨çª—å£
2. **å»¶è¿Ÿå¤„ç†**ï¼šè®¾ç½®åˆç†çš„æ°´ä½çº¿å¤„ç†å»¶è¿Ÿæ•°æ®
3. **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§è¿æ¥æ“ä½œçš„å»¶è¿Ÿå’Œååé‡
4. **é”™è¯¯å¤„ç†**ï¼šå¤„ç†æ—¶é—´çª—å£ä¸åŒ¹é…çš„æƒ…å†µ

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
