# PostgreSQL 安全聚合算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数据安全 | 安全聚合 | 同态加密
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Secure Aggregation, Homomorphic Encryption, Secure Multi-party Computation

---

## 📋 目录

- [PostgreSQL 安全聚合算法完整指南](#postgresql-安全聚合算法完整指南)
  - [📋 目录](#-目录)
  - [安全聚合概述](#安全聚合概述)
    - [核心需求](#核心需求)
  - [1. 安全多方计算](#1-安全多方计算)
    - [1.1 SMC原理](#11-smc原理)
    - [1.2 秘密共享实现](#12-秘密共享实现)
  - [2. 同态加密基础](#2-同态加密基础)
    - [2.1 同态加密原理](#21-同态加密原理)
    - [2.2 加法同态实现](#22-加法同态实现)
    - [2.3 安全聚合协议](#23-安全聚合协议)
  - [3. 差分隐私聚合](#3-差分隐私聚合)
    - [3.1 差分隐私原理](#31-差分隐私原理)
    - [3.2 拉普拉斯机制](#32-拉普拉斯机制)
  - [4. 复杂度分析](#4-复杂度分析)
    - [4.1 时间复杂度](#41-时间复杂度)
    - [4.2 通信复杂度](#42-通信复杂度)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 多方数据聚合](#51-多方数据聚合)
    - [5.2 隐私保护统计查询](#52-隐私保护统计查询)
    - [5.3 联邦学习数据聚合](#53-联邦学习数据聚合)
  - [📊 性能优化建议](#-性能优化建议)
    - [方案选择](#方案选择)
    - [批量处理优化](#批量处理优化)
    - [并行计算](#并行计算)
    - [缓存优化](#缓存优化)
  - [🎯 最佳实践](#-最佳实践)
    - [密钥管理](#密钥管理)
    - [噪声校准](#噪声校准)
    - [性能监控](#性能监控)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 安全聚合方法对比](#-安全聚合方法对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：秘密共享计算慢](#问题1秘密共享计算慢)
    - [问题2：同态加密开销大](#问题2同态加密开销大)
    - [问题3：差分隐私噪声过大](#问题3差分隐私噪声过大)
  - [📚 参考资源](#-参考资源)

---

## 安全聚合概述

**安全聚合**在保护数据隐私的前提下进行聚合计算，确保在计算过程中不泄露原始数据。

### 核心需求

| 需求 | 描述 | 实现方式 |
|------|------|---------|
| **隐私保护** | 不泄露原始数据 | 加密、差分隐私 |
| **正确性** | 聚合结果准确 | 同态加密、安全多方计算 |
| **性能** | 计算效率可接受 | 优化算法、并行计算 |

---

## 1. 安全多方计算

### 1.1 SMC原理

**安全多方计算（Secure Multi-party Computation, SMC）**允许多方在不泄露各自输入的情况下计算函数。

**安全模型**：

- **半诚实模型**：参与者遵循协议但可能记录信息
- **恶意模型**：参与者可能偏离协议

**基本协议**：

1. **秘密共享**：将数据分割成多个份额
2. **安全计算**：在份额上执行计算
3. **结果重构**：合并份额得到结果

### 1.2 秘密共享实现

```sql
-- 安全聚合数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'secure_aggregation_data') THEN
            DROP TABLE secure_aggregation_data CASCADE;
        END IF;

        CREATE TABLE secure_aggregation_data (
            party_id INTEGER NOT NULL,
            secret_value NUMERIC NOT NULL,
            share_1 NUMERIC NOT NULL,
            share_2 NUMERIC NOT NULL,
            share_3 NUMERIC NOT NULL,
            PRIMARY KEY (party_id)
        );

        -- 插入示例数据（使用秘密共享）
        -- 秘密共享：s = s1 + s2 + s3 (mod p)
        INSERT INTO secure_aggregation_data (party_id, secret_value, share_1, share_2, share_3) VALUES
            (1, 100, 30, 40, 30),  -- 100 = 30 + 40 + 30
            (2, 200, 60, 70, 70),  -- 200 = 60 + 70 + 70
            (3, 150, 50, 50, 50);  -- 150 = 50 + 50 + 50

        RAISE NOTICE '安全聚合数据表创建成功，共 % 条记录', (SELECT COUNT(*) FROM secure_aggregation_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 安全聚合：在份额上计算
WITH secure_sum AS (
    SELECT
        SUM(share_1) AS sum_share_1,
        SUM(share_2) AS sum_share_2,
        SUM(share_3) AS sum_share_3
    FROM secure_aggregation_data
),
reconstructed_sum AS (
    SELECT
        sum_share_1 + sum_share_2 + sum_share_3 AS total_sum
    FROM secure_sum
)
SELECT
    ROUND(total_sum::numeric, 2) AS secure_aggregated_sum,
    (SELECT SUM(secret_value) FROM secure_aggregation_data) AS actual_sum,
    CASE
        WHEN ABS(total_sum - (SELECT SUM(secret_value) FROM secure_aggregation_data)) < 0.01
        THEN 'Match'
        ELSE 'Mismatch'
    END AS verification
FROM reconstructed_sum;
```

---

## 2. 同态加密基础

### 2.1 同态加密原理

**同态加密（Homomorphic Encryption）**允许在密文上直接进行计算。

**性质**：

- **加法同态**：$E(a) \oplus E(b) = E(a + b)$
- **乘法同态**：$E(a) \otimes E(b) = E(a \times b)$
- **全同态**：支持任意计算

### 2.2 加法同态实现

```sql
-- 同态加密聚合（简化版：使用Paillier加密思想）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'homomorphic_data') THEN
            DROP TABLE homomorphic_data CASCADE;
        END IF;

        CREATE TABLE homomorphic_data (
            party_id INTEGER NOT NULL,
            plaintext_value NUMERIC NOT NULL,
            -- 简化：使用模运算模拟加密
            encrypted_value NUMERIC NOT NULL,  -- E(x) = (g^x * r^n) mod n²
            PRIMARY KEY (party_id)
        );

        -- 插入数据（简化加密：E(x) = x mod large_prime）
        INSERT INTO homomorphic_data (party_id, plaintext_value, encrypted_value) VALUES
            (1, 100, 100),
            (2, 200, 200),
            (3, 150, 150);

        RAISE NOTICE '同态加密数据表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 同态加密求和：SUM(E(x)) = E(SUM(x))
WITH homomorphic_sum AS (
    SELECT
        SUM(encrypted_value) AS encrypted_sum
    FROM homomorphic_data
)
SELECT
    encrypted_sum AS encrypted_result,
    (SELECT SUM(plaintext_value) FROM homomorphic_data) AS decrypted_result,
    CASE
        WHEN encrypted_sum = (SELECT SUM(plaintext_value) FROM homomorphic_data)
        THEN 'Homomorphic property verified'
        ELSE 'Error in homomorphic computation'
    END AS verification
FROM homomorphic_sum;
```

### 2.3 安全聚合协议

**安全聚合协议**：

1. **密钥生成**：生成公钥和私钥
2. **数据加密**：各方使用公钥加密数据
3. **聚合计算**：在密文上执行聚合
4. **结果解密**：使用私钥解密结果

```sql
-- 安全聚合协议实现
CREATE OR REPLACE FUNCTION secure_aggregate_sum(
    p_table_name TEXT,
    p_value_column TEXT
)
RETURNS NUMERIC AS $$
DECLARE
    encrypted_sum NUMERIC;
    decrypted_sum NUMERIC;
    sql_query TEXT;
BEGIN
    -- 构建动态SQL查询
    sql_query := format('
        SELECT SUM(%I)
        FROM %I
    ', p_value_column, p_table_name);

    EXECUTE sql_query INTO encrypted_sum;

    -- 解密（简化：假设加密是恒等映射）
    decrypted_sum := encrypted_sum;

    RETURN decrypted_sum;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '安全聚合失败: %', SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 使用安全聚合函数
SELECT secure_aggregate_sum('homomorphic_data', 'encrypted_value') AS secure_sum;
```

---

## 3. 差分隐私聚合

### 3.1 差分隐私原理

**差分隐私（Differential Privacy）**通过添加噪声保护隐私。

**定义**：对于相邻数据集 $D$ 和 $D'$（相差一条记录），机制 $M$ 满足 $\epsilon$-差分隐私，如果：
$$P[M(D) \in S] \leq e^{\epsilon} \cdot P[M(D') \in S]$$

### 3.2 拉普拉斯机制

**拉普拉斯机制**：$M(x) = f(x) + \text{Lap}(\Delta f / \epsilon)$

```sql
-- 差分隐私聚合
WITH laplace_noise AS (
    SELECT
        party_id,
        secret_value,
        -- 拉普拉斯噪声：Lap(Δf/ε)
        secret_value + (
            -1.0 * (1.0 / 0.1) * LN(1.0 - 2.0 * ABS(RANDOM() - 0.5))
        ) * SIGN(RANDOM() - 0.5) AS noisy_value
    FROM secure_aggregation_data
),
differentially_private_sum AS (
    SELECT
        SUM(noisy_value) AS dp_sum,
        SUM(secret_value) AS true_sum
    FROM laplace_noise
)
SELECT
    ROUND(dp_sum::numeric, 2) AS differentially_private_sum,
    ROUND(true_sum::numeric, 2) AS true_sum,
    ROUND(ABS(dp_sum - true_sum)::numeric, 2) AS privacy_error
FROM differentially_private_sum;
```

---

## 4. 复杂度分析

### 4.1 时间复杂度

| 方法 | 时间复杂度 | 说明 |
|------|-----------|------|
| **秘密共享** | $O(n)$ | n个参与者 |
| **同态加密** | $O(n \log n)$ | 加密操作 |
| **差分隐私** | $O(n)$ | 添加噪声 |

### 4.2 通信复杂度

| 方法 | 通信轮数 | 通信量 |
|------|---------|--------|
| **秘密共享** | $O(1)$ | $O(n)$ |
| **同态加密** | $O(1)$ | $O(n)$ |
| **安全多方计算** | $O(d)$ | $O(n^2)$（d是电路深度） |

---

## 5. PostgreSQL 18 并行安全聚合增强

**PostgreSQL 18** 显著增强了并行安全聚合计算能力，支持并行执行秘密共享、同态加密和差分隐私聚合，大幅提升大规模安全聚合处理的性能。

### 5.1 并行安全聚合原理

PostgreSQL 18 的并行安全聚合通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描多方数据
2. **并行份额计算**：每个工作进程独立计算秘密份额
3. **并行安全聚合**：并行执行安全聚合操作
4. **结果合并**：主进程合并所有工作进程的计算结果

### 5.2 并行秘密共享聚合

```sql
-- PostgreSQL 18 并行秘密共享聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'secure_aggregation_data') THEN
            RAISE WARNING '表 secure_aggregation_data 不存在，无法执行并行秘密共享聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行秘密共享聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行秘密共享聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行份额聚合
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH share_aggregation AS (
    SELECT
        SUM(share_1) AS aggregated_share_1,
        SUM(share_2) AS aggregated_share_2,
        SUM(share_3) AS aggregated_share_3
    FROM secure_aggregation_data
)
SELECT
    aggregated_share_1 + aggregated_share_2 + aggregated_share_3 AS reconstructed_sum,
    ROUND((aggregated_share_1 + aggregated_share_2 + aggregated_share_3)::numeric, 4) AS secure_aggregate
FROM share_aggregation;
```

### 5.3 并行差分隐私聚合

```sql
-- PostgreSQL 18 并行差分隐私聚合（带错误处理和性能测试）
DO $$
DECLARE
    epsilon NUMERIC := 1.0;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multi_party_data') THEN
            RAISE WARNING '表 multi_party_data 不存在，无法执行并行差分隐私聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行差分隐私聚合，ε=%', epsilon;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行差分隐私聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行差分隐私聚合
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH private_aggregation AS (
    SELECT
        SUM(data_value) AS true_sum,
        COUNT(*) AS true_count,
        -- 简化：假设噪声已添加
        SUM(data_value) + (RANDOM() - 0.5) * 2 * (1.0 / 1.0) AS private_sum
    FROM multi_party_data
)
SELECT
    ROUND(true_sum::numeric, 2) AS true_aggregate,
    ROUND(private_sum::numeric, 2) AS private_aggregate,
    ROUND(ABS(true_sum - private_sum)::numeric, 2) AS privacy_cost
FROM private_aggregation;
```

---

## 6. 实际应用案例

### 5.1 多方数据聚合

```sql
-- 多方数据安全聚合应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建多方数据表
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multi_party_data') THEN
            DROP TABLE multi_party_data CASCADE;
        END IF;

        CREATE TABLE multi_party_data (
            party_id INTEGER NOT NULL,
            data_value NUMERIC NOT NULL,
            share_1 NUMERIC NOT NULL,
            share_2 NUMERIC NOT NULL,
            share_3 NUMERIC NOT NULL,
            PRIMARY KEY (party_id)
        );

        -- 插入示例多方数据（使用秘密共享）
        INSERT INTO multi_party_data (party_id, data_value, share_1, share_2, share_3) VALUES
            (1, 100, 30, 40, 30),
            (2, 200, 60, 70, 70),
            (3, 150, 50, 50, 50),
            (4, 300, 100, 100, 100);

        RAISE NOTICE '多方数据表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多方数据聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 安全多方聚合：在份额上计算
WITH secure_aggregation AS (
    SELECT
        SUM(share_1) AS sum_share_1,
        SUM(share_2) AS sum_share_2,
        SUM(share_3) AS sum_share_3
    FROM multi_party_data
),
reconstructed_result AS (
    SELECT
        sum_share_1 + sum_share_2 + sum_share_3 AS secure_sum,
        (SELECT SUM(data_value) FROM multi_party_data) AS true_sum
    FROM secure_aggregation
)
SELECT
    ROUND(secure_sum::numeric, 2) AS secure_aggregated_sum,
    ROUND(true_sum::numeric, 2) AS true_sum,
    CASE
        WHEN ABS(secure_sum - true_sum) < 0.01 THEN 'Match ✓'
        ELSE 'Mismatch ✗'
    END AS verification
FROM reconstructed_result;
```

### 5.2 隐私保护统计查询

```sql
-- 隐私保护统计查询应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'secure_aggregation_data') THEN
            RAISE WARNING '表 secure_aggregation_data 不存在，无法进行隐私保护统计查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行隐私保护统计查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '隐私保护统计查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 差分隐私聚合统计
WITH private_statistics AS (
    SELECT
        party_id,
        secret_value,
        -- 拉普拉斯噪声：Lap(Δf/ε)
        secret_value + (
            -1.0 * (1.0 / 0.1) * LN(1.0 - 2.0 * ABS(RANDOM() - 0.5))
        ) * SIGN(RANDOM() - 0.5) AS noisy_value
    FROM secure_aggregation_data
),
aggregated_stats AS (
    SELECT
        COUNT(*) AS private_count,
        SUM(noisy_value) AS private_sum,
        AVG(noisy_value) AS private_avg,
        MIN(noisy_value) AS private_min,
        MAX(noisy_value) AS private_max
    FROM private_statistics
),
true_stats AS (
    SELECT
        COUNT(*) AS true_count,
        SUM(secret_value) AS true_sum,
        AVG(secret_value) AS true_avg,
        MIN(secret_value) AS true_min,
        MAX(secret_value) AS true_max
    FROM secure_aggregation_data
)
SELECT
    ROUND(private_count::numeric, 2) AS private_count,
    ROUND(true_count::numeric, 2) AS true_count,
    ROUND(private_sum::numeric, 2) AS private_sum,
    ROUND(true_sum::numeric, 2) AS true_sum,
    ROUND(private_avg::numeric, 2) AS private_avg,
    ROUND(true_avg::numeric, 2) AS true_avg,
    ROUND(ABS(private_sum - true_sum)::numeric, 2) AS privacy_error
FROM aggregated_stats, true_stats;
```

### 5.3 联邦学习数据聚合

```sql
-- 联邦学习数据聚合应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建联邦学习数据表
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'federated_learning_data') THEN
            DROP TABLE federated_learning_data CASCADE;
        END IF;

        CREATE TABLE federated_learning_data (
            client_id INTEGER NOT NULL,
            model_parameter NUMERIC NOT NULL,
            encrypted_parameter NUMERIC NOT NULL,
            PRIMARY KEY (client_id)
        );

        -- 插入示例联邦学习数据
        INSERT INTO federated_learning_data (client_id, model_parameter, encrypted_parameter) VALUES
            (1, 0.5, 0.5),
            (2, 0.6, 0.6),
            (3, 0.4, 0.4),
            (4, 0.7, 0.7);

        RAISE NOTICE '联邦学习数据表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '联邦学习数据聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 联邦学习安全聚合：在加密参数上计算平均值
WITH federated_aggregation AS (
    SELECT
        AVG(encrypted_parameter) AS aggregated_parameter,
        AVG(model_parameter) AS true_average
    FROM federated_learning_data
)
SELECT
    ROUND(aggregated_parameter::numeric, 4) AS secure_average,
    ROUND(true_average::numeric, 4) AS true_average,
    CASE
        WHEN ABS(aggregated_parameter - true_average) < 0.01 THEN 'Match ✓'
        ELSE 'Mismatch ✗'
    END AS verification
FROM federated_aggregation;
```

---

## 📊 性能优化建议

### 方案选择

```sql
-- 根据隐私需求选择方案
-- 1. 秘密共享：适合多方计算，通信开销大
-- 2. 同态加密：适合单方聚合，计算开销大
-- 3. 差分隐私：适合统计查询，隐私保证强
```

### 批量处理优化

```sql
-- 批量加密：使用事务批量处理
BEGIN;
UPDATE secure_aggregation_data
SET share_1 = data_value * 0.3,
    share_2 = data_value * 0.4,
    share_3 = data_value * 0.3
WHERE share_1 IS NULL;
COMMIT;
```

### 并行计算

```sql
-- 并行聚合：使用并行查询
SET max_parallel_workers_per_gather = 4;
SELECT
    party_id,
    SUM(share_1) OVER () AS total_share_1,
    SUM(share_2) OVER () AS total_share_2,
    SUM(share_3) OVER () AS total_share_3
FROM secure_aggregation_data;
```

### 缓存优化

```sql
-- 缓存加密密钥和中间结果
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_secure_aggregation AS
SELECT
    SUM(share_1) AS sum_share_1,
    SUM(share_2) AS sum_share_2,
    SUM(share_3) AS sum_share_3
FROM secure_aggregation_data;

-- 定期刷新
REFRESH MATERIALIZED VIEW mv_secure_aggregation;
```

---

## 🎯 最佳实践

### 密钥管理

1. **密钥生成**：使用安全的随机数生成器
2. **密钥分发**：安全分发密钥给各方
3. **密钥存储**：安全存储密钥
4. **密钥轮换**：定期轮换密钥

### 噪声校准

1. **ε值选择**：根据隐私需求选择合适的ε值
2. **δ值选择**：对于(ε,δ)-DP，选择合适的δ值
3. **敏感度计算**：准确计算查询敏感度
4. **噪声验证**：验证噪声添加正确性

### 性能监控

1. **加密性能**：监控加密解密性能
2. **聚合性能**：监控聚合计算性能
3. **通信开销**：监控通信开销
4. **资源使用**：监控CPU和内存使用

### SQL实现注意事项

1. **错误处理**：使用DO块和EXCEPTION进行错误处理
2. **数值精度**：注意数值精度和舍入误差
3. **随机数生成**：使用安全的随机数生成器
4. **性能优化**：优化加密和聚合性能

---

## 📈 安全聚合方法对比

| 方法 | 隐私保护 | 计算复杂度 | 通信复杂度 | 适用场景 | 优势 | 局限性 |
|------|---------|-----------|-----------|---------|------|--------|
| 秘密共享 | 高 | $O(n)$ | $O(n)$ | 多方计算 | 安全性高 | 通信开销大 |
| 同态加密 | 高 | $O(n \log n)$ | $O(n)$ | 单方聚合 | 计算效率高 | 计算开销大 |
| 差分隐私 | 最高 | $O(n)$ | $O(1)$ | 统计查询 | 隐私保证强 | 噪声影响精度 |

---

## 🔍 常见问题与解决方案

### 问题1：秘密共享计算慢

**原因**：

- 数据量大
- 份额计算复杂
- 未使用并行计算

**解决方案**：

- 使用并行计算
- 优化份额计算算法
- 使用物化视图缓存

### 问题2：同态加密开销大

**原因**：

- 加密操作复杂
- 数据量大
- 未使用批量处理

**解决方案**：

- 使用批量加密
- 优化加密算法
- 使用专用硬件加速

### 问题3：差分隐私噪声过大

**原因**：

- ε值过小
- 敏感度过大
- 数据量过小

**解决方案**：

- 适当增加ε值
- 降低查询敏感度
- 增加数据量

---

## 📚 参考资源

1. **Cramer, R., Damgård, I., Nielsen, J.B. (2015)**: "Secure Multiparty Computation"
2. **Gentry, C. (2009)**: "Fully Homomorphic Encryption Using Ideal Lattices"
3. **Dwork, C., Roth, A. (2014)**: "The Algorithmic Foundations of Differential Privacy"
4. **Boneh, D., et al. (2013)**: "Homomorphic Encryption"

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
