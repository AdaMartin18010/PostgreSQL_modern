# PostgreSQL 图聚类算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 图聚类 | 社区检测
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)

---

## 📋 目录

- [PostgreSQL 图聚类算法完整指南](#postgresql-图聚类算法完整指南)
  - [📋 目录](#-目录)
  - [图聚类算法概述](#图聚类算法概述)
    - [理论基础](#理论基础)
      - [图聚类问题定义](#图聚类问题定义)
      - [聚类算法分类](#聚类算法分类)
      - [聚类质量评估](#聚类质量评估)
    - [核心聚类方法](#核心聚类方法)
  - [1. 模块度优化](#1-模块度优化)
    - [1.1 模块度原理](#11-模块度原理)
      - [模块度定义](#模块度定义)
      - [模块度公式](#模块度公式)
    - [1.2 模块度计算实现](#12-模块度计算实现)
    - [1.3 模块度优化](#13-模块度优化)
  - [2. 社区检测](#2-社区检测)
    - [2.1 社区检测原理](#21-社区检测原理)
      - [社区定义](#社区定义)
      - [检测方法](#检测方法)
    - [2.2 简单社区检测实现](#22-简单社区检测实现)
    - [2.3 标签传播算法](#23-标签传播算法)
  - [3. 聚类评估](#3-聚类评估)
    - [3.1 聚类评估原理](#31-聚类评估原理)
      - [评估指标](#评估指标)
      - [评估方法](#评估方法)
    - [3.2 聚类质量评估实现](#32-聚类质量评估实现)
    - [3.3 聚类对比分析](#33-聚类对比分析)
  - [4. 图聚类优化策略](#4-图聚类优化策略)
    - [4.1 索引优化](#41-索引优化)
    - [4.2 算法优化](#42-算法优化)
    - [4.3 性能优化](#43-性能优化)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 推荐系统社区检测](#51-推荐系统社区检测)
    - [5.2 社交网络社区发现](#52-社交网络社区发现)
    - [5.3 知识图谱聚类](#53-知识图谱聚类)
    - [5.4 生物网络分析](#54-生物网络分析)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 聚类算法对比](#61-聚类算法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 算法选择](#71-算法选择)
    - [7.2 参数调优](#72-参数调优)
    - [7.3 性能优化](#73-性能优化)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 图聚类算法概述

**图聚类算法（Graph Clustering Algorithm）**用于识别图中的社区结构，将紧密连接的节点分组，是图分析和社交网络分析的重要工具。

### 理论基础

#### 图聚类问题定义

**图聚类问题**：给定图$G = (V, E)$，将节点划分为$k$个社区：
$$C = \{C_1, C_2, \ldots, C_k\} \text{ such that } \bigcup_{i=1}^{k} C_i = V \text{ and } C_i \cap C_j = \emptyset$$

**聚类目标**：最大化社区内部连接，最小化社区间连接。

#### 聚类算法分类

图聚类算法分类：

1. **基于模块度**：
   - 模块度优化
   - Louvain算法
   - 时间复杂度：$O(V \log V)$

2. **基于标签传播**：
   - 标签传播算法（LPA）
   - 时间复杂度：$O(V + E)$

3. **基于谱聚类**：
   - 谱聚类算法
   - 时间复杂度：$O(V^3)$

#### 聚类质量评估

**聚类质量评估指标**：

1. **模块度（Modularity）**：$Q \in [-1, 1]$，越大越好
2. **轮廓系数（Silhouette Coefficient）**：$s \in [-1, 1]$，越大越好
3. **社区内密度**：社区内部边的比例

### 核心聚类方法

| 方法 | 数学定义 | 用途 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **模块度优化** | $Q = \sum_{i} \left(\frac{e_{ii}}{m} - \left(\frac{d_i}{2m}\right)^2\right)$ | 社区质量评估 | $O(V^2)$ | $O(V^2)$ | 社区检测 |
| **Louvain算法** | 迭代模块度优化 | 社区检测 | $O(V \log V)$ | $O(V + E)$ | 大规模图 |
| **标签传播** | 节点标签传播 | 快速聚类 | $O(V + E)$ | $O(V)$ | 快速聚类 |

---

## 1. 模块度优化

### 1.1 模块度原理

**模块度（Modularity）**是衡量社区划分质量的经典指标。

#### 模块度定义

**模块度**：模块度$Q$衡量社区划分的质量：
$$Q = \sum_{i=1}^{k} \left(\frac{e_{ii}}{m} - \left(\frac{d_i}{2m}\right)^2\right)$$

其中：

- $e_{ii}$：社区$i$内部的边数
- $m$：总边数
- $d_i$：社区$i$中节点的总度数

#### 模块度公式

**模块度范围**：$Q \in [-1, 1]$

- $Q > 0$：社区结构明显
- $Q = 0$：随机连接
- $Q < 0$：社区结构不明显

### 1.2 模块度计算实现

**模块度计算**的实现和使用。

```sql
-- 模块度计算（带错误处理和性能测试）
DO $$
DECLARE
    modularity_score NUMERIC;
    total_edges BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法计算模块度';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'node_communities') THEN
            RAISE WARNING '表 node_communities 不存在，无法计算模块度';
            RETURN;
        END IF;

        SELECT COUNT(*) INTO total_edges FROM edges;

        WITH community_edges AS (
            SELECT
                nc1.community_id,
                COUNT(*) AS internal_edges,
                (SELECT COUNT(*) FROM node_communities WHERE community_id = nc1.community_id) AS community_size
            FROM edges e
            JOIN node_communities nc1 ON e.source_id = nc1.node_id
            JOIN node_communities nc2 ON e.target_id = nc2.node_id
            WHERE nc1.community_id = nc2.community_id
            GROUP BY nc1.community_id
        )
        SELECT
            SUM(internal_edges::NUMERIC / NULLIF(total_edges, 0) - POWER(community_size::NUMERIC / NULLIF((SELECT COUNT(*) FROM node_communities), 0), 2))
        INTO modularity_score
        FROM community_edges;

        RAISE NOTICE '模块度: % (范围: -1到1，越大越好)', modularity_score;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '模块度计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

### 1.3 模块度优化

**模块度优化**：通过调整社区划分优化模块度。

```sql
-- 模块度优化（带错误处理）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '模块度优化需要迭代算法';
        -- 实际实现需要多次迭代调整社区划分
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '模块度优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 2. 社区检测

### 2.1 社区检测原理

**社区检测（Community Detection）**是识别图中社区结构的算法。

#### 社区定义

**社区**：社区$C$是图$G$的一个子图，满足：

- 社区内部连接密集
- 社区间连接稀疏

#### 检测方法

**检测方法**：

1. **基于模块度**：优化模块度值
2. **基于标签传播**：节点标签传播
3. **基于连通性**：使用连通分量

### 2.2 简单社区检测实现

**简单社区检测**的实现和使用。

```sql
-- 社区检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行社区检测';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行社区检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行社区检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '社区检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE communities AS (
    SELECT
        id AS node_id,
        id AS community_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        c.community_id
    FROM communities c
    JOIN edges e ON c.node_id = e.source_id
    WHERE (
        SELECT COUNT(*)
        FROM edges e2
        WHERE e2.source_id = e.target_id
          AND e2.target_id IN (SELECT node_id FROM communities WHERE community_id = c.community_id)
    ) > (
        SELECT COUNT(*)
        FROM edges e3
        WHERE e3.source_id = e.target_id
          AND e3.target_id NOT IN (SELECT node_id FROM communities WHERE community_id = c.community_id)
    )
)
SELECT
    community_id,
    COUNT(DISTINCT node_id) AS community_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members
FROM communities
GROUP BY community_id
ORDER BY community_size DESC;
```

---

### 2.3 标签传播算法

**标签传播算法（Label Propagation Algorithm, LPA）**：快速社区检测算法。

```sql
-- 标签传播算法（简化版，带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行标签传播算法';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行标签传播算法';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行标签传播算法';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '标签传播算法准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 标签传播算法：节点采用邻居中出现最多的标签
WITH RECURSIVE label_propagation AS (
    -- 初始化：每个节点使用自己的ID作为标签
    SELECT
        id AS node_id,
        id AS label
    FROM nodes
    UNION ALL
    -- 迭代：节点采用邻居中出现最多的标签
    SELECT
        n.id AS node_id,
        MODE() WITHIN GROUP (ORDER BY lp.label) AS label
    FROM nodes n
    JOIN edges e ON n.id = e.source_id OR n.id = e.target_id
    JOIN label_propagation lp ON (e.source_id = lp.node_id AND n.id = e.target_id) OR
                                  (e.target_id = lp.node_id AND n.id = e.source_id)
    GROUP BY n.id
    HAVING COUNT(*) > 0
    LIMIT 10  -- 限制迭代次数
)
SELECT DISTINCT ON (node_id)
    node_id,
    label AS community_id
FROM label_propagation
ORDER BY node_id, label;
```

---

## 3. 聚类评估

### 3.1 聚类评估原理

**聚类评估（Clustering Evaluation）**是评估聚类结果质量的算法。

#### 评估指标

**评估指标**：

1. **模块度**：$Q \in [-1, 1]$
2. **轮廓系数**：$s \in [-1, 1]$
3. **社区内密度**：$\rho = \frac{2e_{in}}{n(n-1)}$

#### 评估方法

**评估方法**：

1. **内部评估**：基于图结构评估
2. **外部评估**：与已知标签对比
3. **稳定性评估**：多次运行的一致性

### 3.2 聚类质量评估实现

**聚类质量评估**的实现和使用。

```sql
-- 聚类质量评估（带错误处理和性能测试）
DO $$
DECLARE
    avg_cluster_size NUMERIC;
    cluster_count INTEGER;
    total_nodes BIGINT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'node_communities') THEN
            RAISE WARNING '表 node_communities 不存在，无法评估聚类质量';
            RETURN;
        END IF;

        SELECT
            COUNT(DISTINCT community_id),
            COUNT(DISTINCT node_id),
            AVG(community_size)
        INTO cluster_count, total_nodes, avg_cluster_size
        FROM (
            SELECT
                community_id,
                COUNT(*) AS community_size
            FROM node_communities
            GROUP BY community_id
        ) AS cluster_sizes;

        RAISE NOTICE '聚类质量评估:';
        RAISE NOTICE '  聚类数量: %', cluster_count;
        RAISE NOTICE '  总节点数: %', total_nodes;
        RAISE NOTICE '  平均聚类大小: %', avg_cluster_size;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '聚类质量评估失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT
    community_id,
    COUNT(*) AS community_size,
    COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS size_percentage
FROM node_communities
GROUP BY community_id
ORDER BY community_size DESC;
```

---

### 3.3 聚类对比分析

**聚类对比分析**：对比不同聚类方法的结果。

```sql
-- 聚类对比分析（带错误处理）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '聚类对比分析需要多种聚类方法的结果';
        -- 实际实现需要运行多种聚类算法并对比结果
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '聚类对比分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 4. 图聚类优化策略

### 4.1 索引优化

**索引优化**：为图聚类查询创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 边表索引：加速邻居查找
        CREATE INDEX IF NOT EXISTS idx_edges_source_target
        ON edges(source_id, target_id);

        CREATE INDEX IF NOT EXISTS idx_edges_target_source
        ON edges(target_id, source_id);

        -- 社区表索引
        CREATE INDEX IF NOT EXISTS idx_node_communities_node_community
        ON node_communities(node_id, community_id);

        RAISE NOTICE '图聚类索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 算法优化

**算法优化**：优化聚类算法实现。

```sql
-- 算法优化：使用物化视图缓存聚类结果
CREATE MATERIALIZED VIEW IF NOT EXISTS community_assignments_cache AS
SELECT
    node_id,
    community_id
FROM node_communities;

CREATE INDEX IF NOT EXISTS idx_community_assignments_cache_node_community
ON community_assignments_cache(node_id, community_id);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY community_assignments_cache;
```

### 4.3 性能优化

**性能优化**：使用并行查询和批量处理。

```sql
-- 性能优化（带错误处理）
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        SET work_mem = '512MB';
        RAISE NOTICE '性能优化配置已设置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. 实际应用案例

### 5.1 推荐系统社区检测

**推荐系统社区检测**识别用户社区用于推荐。

```sql
-- 推荐系统社区检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_interactions') THEN
            RAISE WARNING '表 user_interactions 不存在，无法执行推荐系统社区检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行推荐系统社区检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '推荐系统社区检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 推荐系统社区检测：基于用户相似度构建图并检测社区
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH user_similarity AS (
    SELECT
        u1.user_id AS user1,
        u2.user_id AS user2,
        COUNT(DISTINCT u1.item_id) AS common_items,
        COUNT(DISTINCT u1.item_id)::NUMERIC /
        SQRT(COUNT(DISTINCT u1.item_id) OVER (PARTITION BY u1.user_id) *
             COUNT(DISTINCT u2.item_id) OVER (PARTITION BY u2.user_id)) AS jaccard_similarity
    FROM user_interactions u1
    JOIN user_interactions u2 ON u1.item_id = u2.item_id
    WHERE u1.user_id < u2.user_id
    GROUP BY u1.user_id, u2.user_id
    HAVING COUNT(DISTINCT u1.item_id) >= 5  -- 最小相似度阈值
),
user_graph AS (
    SELECT user1 AS source_id, user2 AS target_id FROM user_similarity
    UNION
    SELECT user2 AS source_id, user1 AS target_id FROM user_similarity
),
user_communities AS (
    SELECT
        user1 AS user_id,
        user1 AS community_id
    FROM user_similarity
    UNION
    SELECT
        user2,
        uc.community_id
    FROM user_communities uc
    JOIN user_similarity us ON uc.user_id = us.user1
    WHERE us.user2 NOT IN (SELECT user_id FROM user_communities WHERE community_id = uc.community_id)
)
SELECT
    community_id,
    COUNT(DISTINCT user_id) AS community_size,
    array_agg(DISTINCT user_id ORDER BY user_id) AS members
FROM user_communities
GROUP BY community_id
HAVING COUNT(DISTINCT user_id) > 1
ORDER BY community_size DESC;
```

### 5.2 社交网络社区发现

**社交网络社区发现**：发现社交网络中的用户社区。

```sql
-- 社交网络社区发现（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'social_network') THEN
            RAISE WARNING '表 social_network 不存在，无法执行社交网络社区发现';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行社交网络社区发现';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '社交网络社区发现准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 社交网络社区发现：基于好友关系检测社区
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE social_communities AS (
    SELECT
        user_id AS node_id,
        user_id AS community_id
    FROM users
    UNION
    SELECT
        sn.friend_id,
        sc.community_id
    FROM social_communities sc
    JOIN social_network sn ON sc.node_id = sn.user_id
    WHERE sn.friend_id NOT IN (
        SELECT node_id FROM social_communities WHERE community_id = sc.community_id
    )
    AND (
        -- 社区检测条件：与社区内节点有足够连接
        SELECT COUNT(*)
        FROM social_network sn2
        WHERE sn2.user_id = sn.friend_id
          AND sn2.friend_id IN (SELECT node_id FROM social_communities WHERE community_id = sc.community_id)
    ) >= 2  -- 至少与2个社区成员连接
)
SELECT
    community_id,
    COUNT(DISTINCT node_id) AS community_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members
FROM social_communities
GROUP BY community_id
HAVING COUNT(DISTINCT node_id) > 1
ORDER BY community_size DESC;
```

### 5.3 知识图谱聚类

**知识图谱聚类**：对知识图谱中的实体进行聚类。

```sql
-- 知识图谱聚类（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'knowledge_graph') THEN
            RAISE WARNING '表 knowledge_graph 不存在，无法执行知识图谱聚类';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行知识图谱聚类';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '知识图谱聚类准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 知识图谱聚类：基于实体关系聚类
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH entity_relations AS (
    SELECT
        source_entity_id,
        target_entity_id,
        relation_type,
        -- 关系权重（简化版）
        CASE relation_type
            WHEN 'is_a' THEN 2.0
            WHEN 'part_of' THEN 1.5
            WHEN 'related_to' THEN 1.0
            ELSE 0.5
        END AS relation_weight
    FROM knowledge_graph
),
entity_similarity AS (
    SELECT
        e1.source_entity_id AS entity1,
        e2.source_entity_id AS entity2,
        COUNT(*) AS common_relations,
        SUM(e1.relation_weight + e2.relation_weight) AS similarity_score
    FROM entity_relations e1
    JOIN entity_relations e2 ON e1.target_entity_id = e2.target_entity_id
    WHERE e1.source_entity_id < e2.source_entity_id
    GROUP BY e1.source_entity_id, e2.source_entity_id
    HAVING COUNT(*) >= 3  -- 至少3个共同关系
),
entity_communities AS (
    SELECT
        entity1 AS entity_id,
        entity1 AS community_id
    FROM entity_similarity
    UNION
    SELECT
        entity2,
        ec.community_id
    FROM entity_communities ec
    JOIN entity_similarity es ON ec.entity_id = es.entity1
    WHERE es.entity2 NOT IN (SELECT entity_id FROM entity_communities WHERE community_id = ec.community_id)
)
SELECT
    community_id,
    COUNT(DISTINCT entity_id) AS community_size,
    array_agg(DISTINCT entity_id ORDER BY entity_id) AS entities
FROM entity_communities
GROUP BY community_id
ORDER BY community_size DESC;
```

### 5.4 生物网络分析

**生物网络分析**：分析生物网络中的功能模块。

```sql
-- 生物网络分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'protein_interactions') THEN
            RAISE WARNING '表 protein_interactions 不存在，无法执行生物网络分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行生物网络分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '生物网络分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 生物网络分析：识别蛋白质功能模块
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE protein_modules AS (
    SELECT
        protein_id AS node_id,
        protein_id AS module_id
    FROM proteins
    UNION
    SELECT
        pi.protein2_id,
        pm.module_id
    FROM protein_modules pm
    JOIN protein_interactions pi ON pm.node_id = pi.protein1_id
    WHERE pi.protein2_id NOT IN (
        SELECT node_id FROM protein_modules WHERE module_id = pm.module_id
    )
    AND (
        -- 模块检测条件：与模块内蛋白质有足够相互作用
        SELECT COUNT(*)
        FROM protein_interactions pi2
        WHERE pi2.protein1_id = pi.protein2_id
          AND pi2.protein2_id IN (SELECT node_id FROM protein_modules WHERE module_id = pm.module_id)
    ) >= 2  -- 至少与2个模块成员相互作用
)
SELECT
    module_id,
    COUNT(DISTINCT node_id) AS module_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS proteins
FROM protein_modules
GROUP BY module_id
HAVING COUNT(DISTINCT node_id) > 1
ORDER BY module_size DESC;
```

---

## 6. 算法性能对比与优化

### 6.1 聚类算法对比

| 算法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **模块度优化** | $Q = \sum_{i} \left(\frac{e_{ii}}{m} - \left(\frac{d_i}{2m}\right)^2\right)$ | $O(V^2)$ | $O(V^2)$ | 社区检测 | 质量高 | 性能慢 |
| **Louvain算法** | 迭代模块度优化 | $O(V \log V)$ | $O(V + E)$ | 大规模图 | 快速、质量高 | 实现复杂 |
| **标签传播** | 节点标签传播 | $O(V + E)$ | $O(V)$ | 快速聚类 | 快速 | 质量中等 |

### 6.2 性能优化建议

1. **索引优化**：
   - 为边表创建索引
   - 为社区表创建索引

2. **算法优化**：
   - 使用Louvain算法（如果支持）
   - 使用物化视图缓存结果

3. **查询优化**：
   - 限制搜索范围
   - 使用并行查询

### 6.3 常见问题与解决方案

**问题1**：聚类算法性能慢

- **解决方案**：使用标签传播算法、创建索引、并行查询

**问题2**：聚类质量低

- **解决方案**：使用模块度优化、调整参数、多次运行

**问题3**：大规模图内存不足

- **解决方案**：分批处理、使用流式处理、优化数据结构

**问题4**：社区数量不确定

- **解决方案**：使用模块度优化、调整阈值、评估指标

---

## 7. 最佳实践

### 7.1 算法选择

1. **快速聚类**：使用标签传播算法
2. **高质量聚类**：使用模块度优化
3. **大规模图**：使用Louvain算法

### 7.2 参数调优

1. **相似度阈值**：根据应用场景调整
2. **社区大小**：设置最小和最大社区大小
3. **迭代次数**：限制迭代次数避免无限循环

### 7.3 性能优化

1. **索引优化**：为常用查询创建索引
2. **结果缓存**：使用物化视图缓存结果
3. **并行查询**：启用并行查询处理大规模数据

### 7.4 SQL实现注意事项

1. **递归深度**：注意PostgreSQL的递归深度限制
2. **性能考虑**：避免在大图上使用复杂算法
3. **结果验证**：验证聚类结果的合理性
4. **错误处理**：处理NULL值和边界情况

---

## 📚 参考资源

### 学术文献

- 《复杂网络》（Complex Networks）- 社区检测理论
- 《图论》（Graph Theory）- 图聚类算法

### PostgreSQL官方文档

- [递归查询](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE)
- [聚合函数](https://www.postgresql.org/docs/current/functions-aggregate.html)

### 在线资源

- PostgreSQL图聚类算法实现
- 社区检测算法详解
- 图分析最佳实践

### 相关算法

- [图遍历算法](./图遍历算法.md) - 图遍历
- [最短路径算法](./最短路径算法.md) - 最短路径查找
- [连通性分析](./连通性分析.md) - 连通性检测

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
