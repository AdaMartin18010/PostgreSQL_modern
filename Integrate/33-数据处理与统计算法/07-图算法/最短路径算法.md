# PostgreSQL æœ€çŸ­è·¯å¾„ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æœ€çŸ­è·¯å¾„ | Dijkstraç®—æ³•
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æœ€çŸ­è·¯å¾„ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æœ€çŸ­è·¯å¾„ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æœ€çŸ­è·¯å¾„ç®—æ³•æ¦‚è¿°](#æœ€çŸ­è·¯å¾„ç®—æ³•æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æœ€çŸ­è·¯å¾„é—®é¢˜å®šä¹‰](#æœ€çŸ­è·¯å¾„é—®é¢˜å®šä¹‰)
      - [æœ€çŸ­è·¯å¾„ç®—æ³•åˆ†ç±»](#æœ€çŸ­è·¯å¾„ç®—æ³•åˆ†ç±»)
      - [ç®—æ³•é€‰æ‹©ç­–ç•¥](#ç®—æ³•é€‰æ‹©ç­–ç•¥)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. Dijkstraç®—æ³•](#1-dijkstraç®—æ³•)
    - [1.1 Dijkstraç®—æ³•åŸç†](#11-dijkstraç®—æ³•åŸç†)
      - [Dijkstraç®—æ³•å®šä¹‰](#dijkstraç®—æ³•å®šä¹‰)
      - [ç®—æ³•æ­¥éª¤](#ç®—æ³•æ­¥éª¤)
    - [1.2 é€’å½’å®ç°](#12-é€’å½’å®ç°)
    - [1.3 ä¼˜åŒ–å®ç°](#13-ä¼˜åŒ–å®ç°)
  - [2. Floyd-Warshallç®—æ³•](#2-floyd-warshallç®—æ³•)
    - [2.1 Floyd-Warshallç®—æ³•åŸç†](#21-floyd-warshallç®—æ³•åŸç†)
      - [ç®—æ³•å®šä¹‰](#ç®—æ³•å®šä¹‰)
      - [åŠ¨æ€è§„åˆ’](#åŠ¨æ€è§„åˆ’)
    - [2.2 å…¨å¯¹æœ€çŸ­è·¯å¾„å®ç°](#22-å…¨å¯¹æœ€çŸ­è·¯å¾„å®ç°)
    - [2.3 è·¯å¾„é‡å»º](#23-è·¯å¾„é‡å»º)
  - [3. è·¯å¾„æƒé‡è®¡ç®—](#3-è·¯å¾„æƒé‡è®¡ç®—)
    - [3.1 è·¯å¾„æƒé‡è®¡ç®—åŸç†](#31-è·¯å¾„æƒé‡è®¡ç®—åŸç†)
      - [æƒé‡å®šä¹‰](#æƒé‡å®šä¹‰)
      - [æƒé‡ç±»å‹](#æƒé‡ç±»å‹)
    - [3.2 åŠ æƒè·¯å¾„æŸ¥æ‰¾å®ç°](#32-åŠ æƒè·¯å¾„æŸ¥æ‰¾å®ç°)
    - [3.3 å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–](#33-å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–)
  - [4. æœ€çŸ­è·¯å¾„ä¼˜åŒ–ç­–ç•¥](#4-æœ€çŸ­è·¯å¾„ä¼˜åŒ–ç­–ç•¥)
    - [4.1 ç´¢å¼•ä¼˜åŒ–](#41-ç´¢å¼•ä¼˜åŒ–)
    - [4.2 ç®—æ³•ä¼˜åŒ–](#42-ç®—æ³•ä¼˜åŒ–)
    - [4.3 æ€§èƒ½ä¼˜åŒ–](#43-æ€§èƒ½ä¼˜åŒ–)
  - [5. PostgreSQL 18 å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—å¢å¼º](#5-postgresql-18-å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—å¢å¼º)
    - [5.1 å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—åŸç†](#51-å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—åŸç†)
    - [5.2 å¹¶è¡ŒDijkstraç®—æ³•](#52-å¹¶è¡Œdijkstraç®—æ³•)
    - [5.3 å¹¶è¡ŒFloyd-Warshallç®—æ³•](#53-å¹¶è¡Œfloyd-warshallç®—æ³•)
    - [5.4 å¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—](#54-å¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 è·¯ç”±è§„åˆ’](#51-è·¯ç”±è§„åˆ’)
    - [5.2 ç½‘ç»œåˆ†æ](#52-ç½‘ç»œåˆ†æ)
    - [5.3 ç‰©æµä¼˜åŒ–](#53-ç‰©æµä¼˜åŒ–)
    - [5.4 ç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„](#54-ç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [6.1 æœ€çŸ­è·¯å¾„ç®—æ³•å¯¹æ¯”](#61-æœ€çŸ­è·¯å¾„ç®—æ³•å¯¹æ¯”)
    - [6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#62-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#63-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [7.1 ç®—æ³•é€‰æ‹©](#71-ç®—æ³•é€‰æ‹©)
    - [7.2 æ•°æ®ç»“æ„è®¾è®¡](#72-æ•°æ®ç»“æ„è®¾è®¡)
    - [7.3 æ€§èƒ½ä¼˜åŒ–](#73-æ€§èƒ½ä¼˜åŒ–)
    - [7.4 SQLå®ç°æ³¨æ„äº‹é¡¹](#74-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [7.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨](#75-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨)
    - [7.6 é«˜çº§ä¼˜åŒ–æŠ€å·§](#76-é«˜çº§ä¼˜åŒ–æŠ€å·§)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## æœ€çŸ­è·¯å¾„ç®—æ³•æ¦‚è¿°

**æœ€çŸ­è·¯å¾„ç®—æ³•ï¼ˆShortest Path Algorithmï¼‰**ç”¨äºæŸ¥æ‰¾å›¾ä¸­ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œæ˜¯å›¾è®ºä¸­çš„ç»å…¸é—®é¢˜ï¼Œå¹¿æ³›åº”ç”¨äºè·¯å¾„è§„åˆ’ã€ç½‘ç»œåˆ†æã€ç‰©æµä¼˜åŒ–ç­‰é¢†åŸŸã€‚

### ç†è®ºåŸºç¡€

#### æœ€çŸ­è·¯å¾„é—®é¢˜å®šä¹‰

**æœ€çŸ­è·¯å¾„é—®é¢˜**ï¼šç»™å®šåŠ æƒå›¾$G = (V, E, w)$ï¼Œå…¶ä¸­$w: E \to \mathbb{R}$æ˜¯æƒé‡å‡½æ•°ï¼Œæ‰¾åˆ°ä»èŠ‚ç‚¹$s$åˆ°èŠ‚ç‚¹$t$çš„è·¯å¾„$P$ï¼Œä½¿å¾—ï¼š
$$w(P) = \sum_{(u,v) \in P} w(u,v)$$
æœ€å°ã€‚

**æœ€çŸ­è·¯å¾„**ï¼š$\text{shortest\_path}(s, t) = \arg\min_{P} w(P)$

#### æœ€çŸ­è·¯å¾„ç®—æ³•åˆ†ç±»

æœ€çŸ­è·¯å¾„ç®—æ³•åˆ†ç±»ï¼š

1. **å•æºæœ€çŸ­è·¯å¾„**ï¼š
   - **Dijkstraç®—æ³•**ï¼šéè´Ÿæƒé‡å›¾
   - **Bellman-Fordç®—æ³•**ï¼šå…è®¸è´Ÿæƒé‡
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(V^2)$æˆ–$O(E \log V)$

2. **å…¨å¯¹æœ€çŸ­è·¯å¾„**ï¼š
   - **Floyd-Warshallç®—æ³•**ï¼šæ‰€æœ‰èŠ‚ç‚¹å¯¹
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(V^3)$

3. **å¯å‘å¼æœç´¢**ï¼š
   - **A*ç®—æ³•**ï¼šä½¿ç”¨å¯å‘å¼å‡½æ•°
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(V + E)$ï¼ˆæœ€ä¼˜æƒ…å†µï¼‰

#### ç®—æ³•é€‰æ‹©ç­–ç•¥

é€‰æ‹©ç®—æ³•çš„è€ƒè™‘å› ç´ ï¼š

1. **å›¾ç±»å‹**ï¼šæœ‰å‘å›¾ã€æ— å‘å›¾
2. **æƒé‡ç±»å‹**ï¼šéè´Ÿæƒé‡ã€å…è®¸è´Ÿæƒé‡
3. **æŸ¥è¯¢ç±»å‹**ï¼šå•æºæŸ¥è¯¢ã€å…¨å¯¹æŸ¥è¯¢
4. **æ€§èƒ½è¦æ±‚**ï¼šå®æ—¶æŸ¥è¯¢ã€æ‰¹é‡æŸ¥è¯¢

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | æ•°å­¦å®šä¹‰ | ç”¨é€” | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|---------|------|-----------|-----------|---------|
| **Dijkstra** | $\min_{P} \sum_{(u,v) \in P} w(u,v)$ | å•æºæœ€çŸ­è·¯å¾„ | $O(V^2)$ | $O(V)$ | éè´Ÿæƒé‡å›¾ |
| **Floyd-Warshall** | $\min_{k} d[i][k] + d[k][j]$ | å…¨å¯¹æœ€çŸ­è·¯å¾„ | $O(V^3)$ | $O(V^2)$ | å°è§„æ¨¡å›¾ |
| **A*** | $f(n) = g(n) + h(n)$ | å¯å‘å¼æœç´¢ | $O(V + E)$ | $O(V)$ | æœ‰å¯å‘å¼å‡½æ•° |

---

## 1. Dijkstraç®—æ³•

### 1.1 Dijkstraç®—æ³•åŸç†

**Dijkstraç®—æ³•ï¼ˆDijkstra's Algorithmï¼‰**æ˜¯è§£å†³å•æºæœ€çŸ­è·¯å¾„é—®é¢˜çš„ç»å…¸ç®—æ³•ã€‚

#### Dijkstraç®—æ³•å®šä¹‰

**Dijkstraç®—æ³•**ï¼šç»™å®šèµ·å§‹èŠ‚ç‚¹$s$ï¼Œç»´æŠ¤è·ç¦»é›†åˆ$d[v]$è¡¨ç¤ºä»$s$åˆ°$v$çš„æœ€çŸ­è·ç¦»ï¼Œé€æ­¥æ‰©å±•æ‰¾åˆ°æœ€çŸ­è·¯å¾„ã€‚

**ç®—æ³•æ­¥éª¤**ï¼š

1. åˆå§‹åŒ–ï¼š$d[s] = 0$ï¼Œ$d[v] = \infty$ï¼ˆ$v \neq s$ï¼‰
2. é€‰æ‹©æœªè®¿é—®èŠ‚ç‚¹$u$ï¼Œä½¿å¾—$d[u]$æœ€å°
3. æ ‡è®°$u$ä¸ºå·²è®¿é—®
4. æ›´æ–°ç›¸é‚»èŠ‚ç‚¹ï¼š$d[v] = \min(d[v], d[u] + w(u,v))$
5. é‡å¤æ­¥éª¤2-4ç›´åˆ°æ‰€æœ‰èŠ‚ç‚¹è®¿é—®

#### ç®—æ³•æ­¥éª¤

**Dijkstraç®—æ³•ä¼ªä»£ç **ï¼š

```
Dijkstra(G, s):
    d[s] = 0
    for each v in V:
        d[v] = infinity
    S = empty set
    while S != V:
        u = node with minimum d[u] not in S
        S = S union {u}
        for each neighbor v of u:
            if d[v] > d[u] + w(u,v):
                d[v] = d[u] + w(u,v)
```

### 1.2 é€’å½’å®ç°

**é€’å½’Dijkstra**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- Dijkstraç®—æ³•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒDijkstraç®—æ³•';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒDijkstraç®—æ³•';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒDijkstraç®—æ³•ï¼Œä»èŠ‚ç‚¹ % åˆ°èŠ‚ç‚¹ %', start_node_id, end_node_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Dijkstraç®—æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE dijkstra AS (
    SELECT
        start_node_id AS current_node,
        0 AS total_distance,
        ARRAY[start_node_id] AS path
    UNION ALL
    SELECT
        e.target_id,
        d.total_distance + e.weight,
        d.path || e.target_id
    FROM dijkstra d
    JOIN edges e ON d.current_node = e.source_id
    WHERE e.target_id != ALL(d.path)
      AND d.total_distance + e.weight < (
          SELECT COALESCE(MIN(total_distance), 999999)
          FROM dijkstra
          WHERE current_node = e.target_id
      )
)
SELECT
    current_node AS target_node,
    MIN(total_distance) AS shortest_distance,
    (SELECT path FROM dijkstra
     WHERE current_node = d.current_node
       AND total_distance = MIN(d.total_distance)
     LIMIT 1) AS shortest_path
FROM dijkstra d
WHERE current_node = end_node_id
GROUP BY current_node;
```

---

### 1.3 ä¼˜åŒ–å®ç°

**ä¼˜åŒ–Dijkstra**ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„æ•°æ®ç»“æ„ï¼ˆPostgreSQLä¸­é€šè¿‡ä¼˜åŒ–æŸ¥è¯¢å®ç°ï¼‰ã€‚

```sql
-- ä¼˜åŒ–Dijkstraï¼šä½¿ç”¨ç´¢å¼•å’Œé™åˆ¶æ¡ä»¶ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    start_node_id INTEGER := 1;
    max_distance NUMERIC := 1000;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œä¼˜åŒ–Dijkstra';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œä¼˜åŒ–Dijkstra';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œä¼˜åŒ–Dijkstraï¼Œæœ€å¤§è·ç¦»é™åˆ¶: %', max_distance;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¼˜åŒ–Dijkstraå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä¼˜åŒ–Dijkstraï¼šæ·»åŠ è·ç¦»é™åˆ¶å’Œæ—©æœŸç»ˆæ­¢
WITH RECURSIVE dijkstra_optimized AS (
    SELECT
        start_node_id AS current_node,
        0 AS total_distance,
        ARRAY[start_node_id] AS path
    UNION ALL
    SELECT
        e.target_id,
        d.total_distance + e.weight,
        d.path || e.target_id
    FROM dijkstra_optimized d
    JOIN edges e ON d.current_node = e.source_id
    WHERE e.target_id != ALL(d.path)
      AND d.total_distance + e.weight < max_distance
      AND d.total_distance + e.weight < (
          SELECT COALESCE(MIN(total_distance), 999999)
          FROM dijkstra_optimized
          WHERE current_node = e.target_id
      )
)
SELECT DISTINCT ON (current_node)
    current_node,
    total_distance,
    path
FROM dijkstra_optimized
ORDER BY current_node, total_distance;
```

---

## 2. Floyd-Warshallç®—æ³•

### 2.1 Floyd-Warshallç®—æ³•åŸç†

**Floyd-Warshallç®—æ³•ï¼ˆFloyd-Warshall Algorithmï¼‰**æ˜¯è§£å†³å…¨å¯¹æœ€çŸ­è·¯å¾„é—®é¢˜çš„åŠ¨æ€è§„åˆ’ç®—æ³•ã€‚

#### ç®—æ³•å®šä¹‰

**Floyd-Warshallç®—æ³•**ï¼šä½¿ç”¨åŠ¨æ€è§„åˆ’è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚

**åŠ¨æ€è§„åˆ’çŠ¶æ€**ï¼š$d[i][j][k]$è¡¨ç¤ºä»èŠ‚ç‚¹$i$åˆ°èŠ‚ç‚¹$j$ï¼Œåªä½¿ç”¨èŠ‚ç‚¹$\{1, 2, \ldots, k\}$ä½œä¸ºä¸­é—´èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚

**çŠ¶æ€è½¬ç§»æ–¹ç¨‹**ï¼š
$$d[i][j][k] = \min(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1])$$

#### åŠ¨æ€è§„åˆ’

**Floyd-Warshallç®—æ³•ä¼ªä»£ç **ï¼š

```
Floyd-Warshall(G):
    for k = 1 to V:
        for i = 1 to V:
            for j = 1 to V:
                d[i][j] = min(d[i][j], d[i][k] + d[k][j])
```

### 2.2 å…¨å¯¹æœ€çŸ­è·¯å¾„å®ç°

**å…¨å¯¹æœ€çŸ­è·¯å¾„**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- Floyd-Warshallç®—æ³•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒFloyd-Warshallç®—æ³•';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒFloyd-Warshallç®—æ³•';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Floyd-Warshallç®—æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE floyd_warshall AS (
    -- åˆå§‹åŒ–ï¼šç›´æ¥è¿æ¥çš„è¾¹
    SELECT
        source_id AS i,
        target_id AS j,
        weight AS distance
    FROM edges
    UNION
    -- è‡ªèº«è·ç¦»ä¸º0
    SELECT DISTINCT
        id AS i,
        id AS j,
        0 AS distance
    FROM nodes
    UNION ALL
    -- é€’å½’ï¼šé€šè¿‡ä¸­é—´èŠ‚ç‚¹kæ›´æ–°è·ç¦»
    SELECT
        fw1.i,
        fw2.j,
        LEAST(fw1.distance, fw1.distance + fw2.distance)
    FROM floyd_warshall fw1
    JOIN floyd_warshall fw2 ON fw1.j = fw2.i
    WHERE fw1.distance + fw2.distance < fw1.distance
)
SELECT
    i AS from_node,
    j AS to_node,
    MIN(distance) AS shortest_distance
FROM floyd_warshall
GROUP BY i, j
ORDER BY i, j;
```

---

### 2.3 è·¯å¾„é‡å»º

**è·¯å¾„é‡å»º**ï¼šé‡å»ºFloyd-Warshallç®—æ³•æ‰¾åˆ°çš„æœ€çŸ­è·¯å¾„ã€‚

```sql
-- è·¯å¾„é‡å»ºï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        RAISE NOTICE 'è·¯å¾„é‡å»ºéœ€è¦å­˜å‚¨ä¸­é—´èŠ‚ç‚¹ä¿¡æ¯';
        -- å®é™…å®ç°éœ€è¦ä¿®æ”¹ç®—æ³•ä»¥å­˜å‚¨è·¯å¾„ä¿¡æ¯
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è·¯å¾„é‡å»ºå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 3. è·¯å¾„æƒé‡è®¡ç®—

### 3.1 è·¯å¾„æƒé‡è®¡ç®—åŸç†

**è·¯å¾„æƒé‡è®¡ç®—ï¼ˆPath Weight Calculationï¼‰**æ˜¯è®¡ç®—å¸¦æƒé‡è·¯å¾„çš„æ€»æƒé‡ã€‚

#### æƒé‡å®šä¹‰

**è·¯å¾„æƒé‡**ï¼šè·¯å¾„$P = \{v_1, v_2, \ldots, v_k\}$çš„æƒé‡ä¸ºï¼š
$$w(P) = \sum_{i=1}^{k-1} w(v_i, v_{i+1})$$

#### æƒé‡ç±»å‹

**æƒé‡ç±»å‹**ï¼š

1. **è·ç¦»æƒé‡**ï¼šç‰©ç†è·ç¦»
2. **æ—¶é—´æƒé‡**ï¼šæ—¶é—´æˆæœ¬
3. **æˆæœ¬æƒé‡**ï¼šç»æµæˆæœ¬
4. **ç»„åˆæƒé‡**ï¼šå¤šç§æƒé‡çš„ç»„åˆ

### 3.2 åŠ æƒè·¯å¾„æŸ¥æ‰¾å®ç°

**åŠ æƒè·¯å¾„æŸ¥æ‰¾**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- åŠ æƒè·¯å¾„æŸ¥æ‰¾ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒåŠ æƒè·¯å¾„æŸ¥æ‰¾';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒåŠ æƒè·¯å¾„æŸ¥æ‰¾';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åŠ æƒè·¯å¾„æŸ¥æ‰¾å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE weighted_paths AS (
    SELECT
        start_node_id AS current_node,
        0 AS total_weight,
        ARRAY[start_node_id] AS path
    UNION ALL
    SELECT
        e.target_id,
        wp.total_weight + e.weight,
        wp.path || e.target_id
    FROM weighted_paths wp
    JOIN edges e ON wp.current_node = e.source_id
    WHERE e.target_id != ALL(wp.path)
      AND wp.total_weight + e.weight < (
          SELECT COALESCE(MIN(total_weight), 999999)
          FROM weighted_paths
          WHERE current_node = e.target_id
      )
)
SELECT
    current_node,
    MIN(total_weight) AS min_weight,
    (SELECT path FROM weighted_paths
     WHERE current_node = wp.current_node
       AND total_weight = MIN(wp.total_weight)
     LIMIT 1) AS shortest_path
FROM weighted_paths wp
WHERE current_node = end_node_id
GROUP BY current_node;
```

---

### 3.3 å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–

**å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–**ï¼šè€ƒè™‘å¤šä¸ªç›®æ ‡çš„è·¯å¾„ä¼˜åŒ–ã€‚

```sql
-- å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–ï¼šåŒæ—¶è€ƒè™‘è·ç¦»å’Œæ—¶é—´
WITH RECURSIVE multi_objective_paths AS (
    SELECT
        start_node_id AS current_node,
        0 AS total_distance,
        0 AS total_time,
        ARRAY[start_node_id] AS path
    UNION ALL
    SELECT
        e.target_id,
        mop.total_distance + e.distance,
        mop.total_time + e.time_cost,
        mop.path || e.target_id
    FROM multi_objective_paths mop
    JOIN edges e ON mop.current_node = e.source_id
    WHERE e.target_id != ALL(mop.path)
      AND mop.total_distance + e.distance < 1000  -- è·ç¦»é™åˆ¶
      AND mop.total_time + e.time_cost < 120  -- æ—¶é—´é™åˆ¶ï¼ˆåˆ†é’Ÿï¼‰
)
SELECT DISTINCT ON (current_node)
    current_node,
    total_distance,
    total_time,
    total_distance + total_time * 10 AS combined_score,  -- ç»„åˆè¯„åˆ†
    path
FROM multi_objective_paths
WHERE current_node = end_node_id
ORDER BY current_node, combined_score;
```

---

## 4. æœ€çŸ­è·¯å¾„ä¼˜åŒ–ç­–ç•¥

### 4.1 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºæœ€çŸ­è·¯å¾„æŸ¥è¯¢åˆ›å»ºåˆé€‚çš„ç´¢å¼•ã€‚

```sql
-- ç´¢å¼•ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        -- è¾¹è¡¨ç´¢å¼•ï¼šåŠ é€Ÿé‚»æ¥èŠ‚ç‚¹æŸ¥æ‰¾
        CREATE INDEX IF NOT EXISTS idx_edges_source_target_weight
        ON edges(source_id, target_id, weight);

        CREATE INDEX IF NOT EXISTS idx_edges_target_source_weight
        ON edges(target_id, source_id, weight);

        RAISE NOTICE 'æœ€çŸ­è·¯å¾„ç´¢å¼•åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç´¢å¼•åˆ›å»ºå¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 ç®—æ³•ä¼˜åŒ–

**ç®—æ³•ä¼˜åŒ–**ï¼šä¼˜åŒ–ç®—æ³•å®ç°æé«˜æ€§èƒ½ã€‚

```sql
-- ç®—æ³•ä¼˜åŒ–ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ä¸­é—´ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS shortest_paths_cache AS
WITH RECURSIVE dijkstra_cache AS (
    -- é¢„è®¡ç®—å¸¸ç”¨è·¯å¾„ï¼ˆç¤ºä¾‹ï¼‰
    SELECT
        source_id,
        target_id,
        weight AS distance,
        ARRAY[source_id, target_id] AS path
    FROM edges
    UNION ALL
    SELECT
        spc.source_id,
        e.target_id,
        spc.distance + e.weight,
        spc.path || e.target_id
    FROM shortest_paths_cache spc
    JOIN edges e ON spc.target_id = e.source_id
    WHERE array_length(spc.path, 1) < 5  -- é™åˆ¶è·¯å¾„é•¿åº¦
)
SELECT DISTINCT ON (source_id, target_id)
    source_id,
    target_id,
    distance,
    path
FROM dijkstra_cache
ORDER BY source_id, target_id, distance;

CREATE INDEX IF NOT EXISTS idx_shortest_paths_cache_source_target
ON shortest_paths_cache(source_id, target_id);
```

### 4.3 æ€§èƒ½ä¼˜åŒ–

**æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢å’Œæ‰¹é‡å¤„ç†ã€‚

```sql
-- æ€§èƒ½ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        SET work_mem = '512MB';
        RAISE NOTICE 'æ€§èƒ½ä¼˜åŒ–é…ç½®å·²è®¾ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ€§èƒ½ä¼˜åŒ–å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. PostgreSQL 18 å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡ŒDijkstraç®—æ³•ã€Floyd-Warshallç®—æ³•å’Œè·¯å¾„æƒé‡è®¡ç®—ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡å›¾æœ€çŸ­è·¯å¾„è®¡ç®—çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—åŸç†

PostgreSQL 18 çš„å¹¶è¡Œæœ€çŸ­è·¯å¾„è®¡ç®—é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æå›¾æ•°æ®
2. **å¹¶è¡Œè·¯å¾„æ¢ç´¢**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ¢ç´¢éƒ¨åˆ†è·¯å¾„
3. **å¹¶è¡Œæƒé‡è®¡ç®—**ï¼šå¹¶è¡Œæ‰§è¡Œè·¯å¾„æƒé‡è®¡ç®—
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è®¡ç®—ç»“æœ

### 5.2 å¹¶è¡ŒDijkstraç®—æ³•

```sql
-- PostgreSQL 18 å¹¶è¡ŒDijkstraç®—æ³•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒDijkstraç®—æ³•';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒDijkstraç®—æ³•';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒDijkstraç®—æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒDijkstraç®—æ³•ï¼šå•æºæœ€çŸ­è·¯å¾„
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE dijkstra_paths AS (
    SELECT
        1 AS start_node,
        start_node AS current_node,
        0 AS distance,
        ARRAY[start_node] AS path
    UNION ALL
    SELECT
        dp.start_node,
        e.target_id,
        dp.distance + e.weight,
        dp.path || e.target_id
    FROM dijkstra_paths dp
    JOIN edges e ON dp.current_node = e.source_id
    WHERE e.target_id != ALL(dp.path)
      AND dp.distance + e.weight < (
          SELECT COALESCE(MIN(distance), 999999)
          FROM dijkstra_paths dp2
          WHERE dp2.current_node = e.target_id
      )
)
SELECT DISTINCT ON (current_node)
    current_node,
    MIN(distance) AS shortest_distance,
    (SELECT path FROM dijkstra_paths dp3
     WHERE dp3.current_node = dp.current_node
       AND dp3.distance = MIN(dp.distance)
     LIMIT 1) AS shortest_path
FROM dijkstra_paths dp
GROUP BY current_node
ORDER BY current_node;
```

### 5.3 å¹¶è¡ŒFloyd-Warshallç®—æ³•

```sql
-- PostgreSQL 18 å¹¶è¡ŒFloyd-Warshallç®—æ³•ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒFloyd-Warshallç®—æ³•';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒFloyd-Warshallç®—æ³•';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒFloyd-Warshallç®—æ³•å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒFloyd-Warshallç®—æ³•ï¼šå…¨å¯¹æœ€çŸ­è·¯å¾„
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH all_pairs AS (
    SELECT
        source_id AS from_node,
        target_id AS to_node,
        weight AS distance
    FROM edges
    UNION
    SELECT
        node_id AS from_node,
        node_id AS to_node,
        0 AS distance
    FROM (SELECT DISTINCT source_id AS node_id FROM edges
          UNION
          SELECT DISTINCT target_id FROM edges) nodes
),
floyd_warshall AS (
    SELECT
        from_node,
        to_node,
        distance,
        CASE
            WHEN from_node = to_node THEN 0
            ELSE distance
        END AS shortest_distance
    FROM all_pairs
)
SELECT
    from_node,
    to_node,
    MIN(shortest_distance) AS shortest_path_distance
FROM floyd_warshall
GROUP BY from_node, to_node
ORDER BY from_node, to_node
LIMIT 100;
```

### 5.4 å¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—

```sql
-- PostgreSQL 18 å¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œè·¯å¾„æƒé‡è®¡ç®—ï¼šåŠ æƒè·¯å¾„æŸ¥æ‰¾
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE weighted_paths AS (
    SELECT
        1 AS start_node,
        start_node AS current_node,
        0 AS total_weight,
        ARRAY[start_node] AS path
    UNION ALL
    SELECT
        wp.start_node,
        e.target_id,
        wp.total_weight + e.weight,
        wp.path || e.target_id
    FROM weighted_paths wp
    JOIN edges e ON wp.current_node = e.source_id
    WHERE e.target_id != ALL(wp.path)
      AND wp.total_weight + e.weight < 1000  -- æƒé‡é™åˆ¶
)
SELECT DISTINCT ON (current_node)
    current_node,
    MIN(total_weight) AS min_weight,
    (SELECT path FROM weighted_paths wp2
     WHERE wp2.current_node = wp.current_node
       AND wp2.total_weight = MIN(wp.total_weight)
     LIMIT 1) AS optimal_path
FROM weighted_paths wp
GROUP BY current_node
ORDER BY current_node;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 è·¯ç”±è§„åˆ’

**è·¯ç”±è§„åˆ’**è§„åˆ’æœ€ä¼˜è·¯å¾„ã€‚

```sql
-- è·¯ç”±è§„åˆ’ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    origin_id INTEGER := 1;
    destination_id INTEGER := 20;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'routes') THEN
            RAISE WARNING 'è¡¨ routes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè·¯ç”±è§„åˆ’';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œè·¯ç”±è§„åˆ’ï¼Œä»èŠ‚ç‚¹ % åˆ°èŠ‚ç‚¹ %', origin_id, destination_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è·¯ç”±è§„åˆ’å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è·¯ç”±è§„åˆ’ï¼šä½¿ç”¨Dijkstraç®—æ³•è§„åˆ’æœ€ä¼˜è·¯å¾„
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE route_planning AS (
    SELECT
        origin_id AS current_location,
        0 AS total_time,
        ARRAY[origin_id] AS route
    UNION ALL
    SELECT
        r.to_location,
        rp.total_time + r.travel_time,
        rp.route || r.to_location
    FROM route_planning rp
    JOIN routes r ON rp.current_location = r.from_location
    WHERE r.to_location != ALL(rp.route)
      AND rp.total_time + r.travel_time < (
          SELECT COALESCE(MIN(total_time), 999999)
          FROM route_planning
          WHERE current_location = r.to_location
      )
)
SELECT DISTINCT ON (current_location)
    current_location,
    total_time AS shortest_time,
    route AS optimal_route
FROM route_planning
WHERE current_location = destination_id
ORDER BY current_location, total_time;
```

### 5.2 ç½‘ç»œåˆ†æ

**ç½‘ç»œåˆ†æ**ï¼šåˆ†æç½‘ç»œä¸­çš„æœ€çŸ­è·¯å¾„ã€‚

```sql
-- ç½‘ç»œåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'network_nodes') THEN
            RAISE WARNING 'è¡¨ network_nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç½‘ç»œåˆ†æ';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'network_links') THEN
            RAISE WARNING 'è¡¨ network_links ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç½‘ç»œåˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç½‘ç»œåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç½‘ç»œåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç½‘ç»œåˆ†æï¼šè®¡ç®—æ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼ˆFloyd-Warshallç®€åŒ–ç‰ˆï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE floyd_warshall AS (
    SELECT
        source_id AS i,
        target_id AS j,
        weight AS distance
    FROM network_links
    UNION
    SELECT DISTINCT
        id AS i,
        id AS j,
        0 AS distance
    FROM network_nodes
    UNION ALL
    SELECT
        fw1.i,
        fw2.j,
        LEAST(fw1.distance, fw1.distance + fw2.distance)
    FROM floyd_warshall fw1
    JOIN floyd_warshall fw2 ON fw1.j = fw2.i
    WHERE fw1.distance + fw2.distance < fw1.distance
)
SELECT DISTINCT ON (i, j)
    i AS from_node,
    j AS to_node,
    distance AS shortest_distance
FROM floyd_warshall
ORDER BY i, j, distance;
```

### 5.3 ç‰©æµä¼˜åŒ–

**ç‰©æµä¼˜åŒ–**ï¼šä¼˜åŒ–ç‰©æµé…é€è·¯å¾„ã€‚

```sql
-- ç‰©æµä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    warehouse_id INTEGER := 1;
    customer_id INTEGER := 50;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'delivery_routes') THEN
            RAISE WARNING 'è¡¨ delivery_routes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç‰©æµä¼˜åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç‰©æµä¼˜åŒ–ï¼Œä»ä»“åº“ % åˆ°å®¢æˆ· %', warehouse_id, customer_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç‰©æµä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç‰©æµä¼˜åŒ–ï¼šè€ƒè™‘è·ç¦»ã€æ—¶é—´å’Œæˆæœ¬çš„è·¯å¾„ä¼˜åŒ–
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE delivery_optimization AS (
    SELECT
        warehouse_id AS current_location,
        0 AS total_distance,
        0 AS total_time,
        0 AS total_cost,
        ARRAY[warehouse_id] AS route
    UNION ALL
    SELECT
        dr.to_location,
        do_opt.total_distance + dr.distance,
        do_opt.total_time + dr.travel_time,
        do_opt.total_cost + dr.cost,
        do_opt.route || dr.to_location
    FROM delivery_optimization do_opt
    JOIN delivery_routes dr ON do_opt.current_location = dr.from_location
    WHERE dr.to_location != ALL(do_opt.route)
      AND do_opt.total_distance + dr.distance < 500  -- è·ç¦»é™åˆ¶ï¼ˆå…¬é‡Œï¼‰
      AND do_opt.total_time + dr.travel_time < 480  -- æ—¶é—´é™åˆ¶ï¼ˆåˆ†é’Ÿï¼‰
)
SELECT DISTINCT ON (current_location)
    current_location,
    total_distance,
    total_time,
    total_cost,
    total_distance * 0.5 + total_time * 0.3 + total_cost AS optimization_score,
    route
FROM delivery_optimization
WHERE current_location = customer_id
ORDER BY current_location, optimization_score;
```

### 5.4 ç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„

**ç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„**ï¼šè®¡ç®—ç¤¾äº¤ç½‘ç»œä¸­ç”¨æˆ·ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚

```sql
-- ç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    user1_id INTEGER := 1;
    user2_id INTEGER := 100;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'social_connections') THEN
            RAISE WARNING 'è¡¨ social_connections ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„ï¼Œä»ç”¨æˆ· % åˆ°ç”¨æˆ· %', user1_id, user2_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç¤¾äº¤ç½‘ç»œæœ€çŸ­è·¯å¾„ï¼šè®¡ç®—ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´çš„æœ€çŸ­è¿æ¥è·¯å¾„ï¼ˆBFSï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE social_paths AS (
    SELECT
        user1_id AS current_user,
        ARRAY[user1_id] AS path,
        0 AS degrees_of_separation
    UNION ALL
    SELECT
        sc.user2_id,
        sp.path || sc.user2_id,
        sp.degrees_of_separation + 1
    FROM social_paths sp
    JOIN social_connections sc ON sp.current_user = sc.user1_id
    WHERE sc.user2_id != ALL(sp.path)
      AND sp.degrees_of_separation < 6  -- 6åº¦åˆ†éš”ç†è®º
)
SELECT DISTINCT ON (current_user)
    current_user,
    degrees_of_separation,
    path
FROM social_paths
WHERE current_user = user2_id
ORDER BY current_user, degrees_of_separation;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 6.1 æœ€çŸ­è·¯å¾„ç®—æ³•å¯¹æ¯”

| ç®—æ³• | æ•°å­¦å®šä¹‰ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|-----------|-----------|---------|------|------|
| **Dijkstra** | $\min_{P} \sum_{(u,v) \in P} w(u,v)$ | $O(V^2)$ | $O(V)$ | å•æºã€éè´Ÿæƒé‡ | ç²¾ç¡®ã€é«˜æ•ˆ | ä¸æ”¯æŒè´Ÿæƒé‡ |
| **Floyd-Warshall** | $\min_{k} d[i][k] + d[k][j]$ | $O(V^3)$ | $O(V^2)$ | å…¨å¯¹æœ€çŸ­è·¯å¾„ | ç®€å• | æ€§èƒ½æ…¢ |
| **A*** | $f(n) = g(n) + h(n)$ | $O(V + E)$ | $O(V)$ | æœ‰å¯å‘å¼å‡½æ•° | å¿«é€Ÿ | éœ€è¦å¯å‘å¼å‡½æ•° |

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**ï¼š
   - ä¸ºè¾¹è¡¨åˆ›å»ºå¤åˆç´¢å¼•
   - ä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ›å»ºç´¢å¼•

2. **ç®—æ³•ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨è·ç¦»é™åˆ¶æå‰ç»ˆæ­¢
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ

3. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - é™åˆ¶æœç´¢èŒƒå›´
   - ä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢

### 6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šDijkstraç®—æ³•æ€§èƒ½æ…¢

- **è§£å†³æ–¹æ¡ˆ**ï¼šåˆ›å»ºç´¢å¼•ã€é™åˆ¶æœç´¢èŒƒå›´ã€ä½¿ç”¨ä¼˜åŒ–å®ç°

**é—®é¢˜2**ï¼šè´Ÿæƒé‡è¾¹

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨Bellman-Fordç®—æ³•ï¼ˆéœ€è¦è‡ªå®šä¹‰å®ç°ï¼‰

**é—®é¢˜3**ï¼šå¤§è§„æ¨¡å›¾è®¡ç®—

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨Floyd-Warshallã€åˆ†æ‰¹å¤„ç†ã€å¹¶è¡Œè®¡ç®—

**é—®é¢˜4**ï¼šè·¯å¾„é‡å»ºå›°éš¾

- **è§£å†³æ–¹æ¡ˆ**ï¼šåœ¨ç®—æ³•ä¸­å­˜å‚¨è·¯å¾„ä¿¡æ¯ã€ä½¿ç”¨è·¯å¾„è¡¨

---

## 8. æœ€ä½³å®è·µ

### 7.1 ç®—æ³•é€‰æ‹©

1. **å•æºæœ€çŸ­è·¯å¾„**ï¼šä½¿ç”¨Dijkstraç®—æ³•
2. **å…¨å¯¹æœ€çŸ­è·¯å¾„**ï¼šå°å›¾ç”¨Floyd-Warshallï¼Œå¤§å›¾ç”¨å¤šæ¬¡Dijkstra
3. **æœ‰å¯å‘å¼å‡½æ•°**ï¼šä½¿ç”¨A*ç®—æ³•

### 7.2 æ•°æ®ç»“æ„è®¾è®¡

1. **èŠ‚ç‚¹è¡¨**ï¼šåŒ…å«èŠ‚ç‚¹IDå’Œå±æ€§
2. **è¾¹è¡¨**ï¼šåŒ…å«æºèŠ‚ç‚¹ã€ç›®æ ‡èŠ‚ç‚¹å’Œæƒé‡
3. **ç´¢å¼•**ï¼šä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ›å»ºç´¢å¼•

### 7.3 æ€§èƒ½ä¼˜åŒ–

1. **ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºè¾¹è¡¨åˆ›å»ºå¤åˆç´¢å¼•
2. **ç®—æ³•ä¼˜åŒ–**ï¼šä½¿ç”¨è·ç¦»é™åˆ¶ã€æ—©æœŸç»ˆæ­¢
3. **ç¼“å­˜ä¼˜åŒ–**ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ

### 7.4 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é€’å½’æ·±åº¦**ï¼šæ³¨æ„PostgreSQLçš„é€’å½’æ·±åº¦é™åˆ¶
2. **æ€§èƒ½è€ƒè™‘**ï¼šé¿å…åœ¨å¤§å›¾ä¸Šä½¿ç”¨Floyd-Warshall
3. **æƒé‡å¤„ç†**ï¼šç¡®ä¿æƒé‡éè´Ÿï¼ˆDijkstraï¼‰
4. **é”™è¯¯å¤„ç†**ï¼šå¤„ç†NULLå€¼å’Œè¾¹ç•Œæƒ…å†µ

### 7.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡æœ€çŸ­è·¯å¾„ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«è·¯å¾„æƒé‡çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Kæœ€çŸ­è·¯å¾„æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡å›¾çš„æœ€çŸ­è·¯å¾„è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡è·¯å¾„è®¡ç®—å’Œå¤šæºæœ€çŸ­è·¯å¾„

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - æœ€çŸ­è·¯å¾„è®¡ç®—æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆéœ€è¦è°¨æ…ä½¿ç”¨ï¼Œå› ä¸ºé€’å½’CTEçš„å¹¶è¡ŒåŒ–é™åˆ¶ï¼‰
   - é€‚ç”¨äºç‹¬ç«‹çš„æœ€çŸ­è·¯å¾„è®¡ç®—

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–æœ€çŸ­è·¯å¾„æŸ¥è¯¢**

```sql
-- ä¸ºè·¯å¾„æƒé‡åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_edges_weight_skip_scan
ON edges(source_id, weight ASC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾å‰10æ¡æœ€çŸ­è·¯å¾„
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE shortest_paths AS (
    SELECT
        source_id AS current_node,
        target_id AS next_node,
        weight AS path_weight,
        ARRAY[source_id, target_id] AS path,
        1 AS path_length
    FROM edges
    WHERE source_id = 1

    UNION ALL

    SELECT
        sp.next_node AS current_node,
        e.target_id AS next_node,
        sp.path_weight + e.weight AS path_weight,
        sp.path || e.target_id,
        sp.path_length + 1
    FROM shortest_paths sp
    JOIN edges e ON sp.next_node = e.source_id
    WHERE e.target_id != ALL(sp.path)
      AND sp.path_length < 5
)
SELECT DISTINCT ON (next_node)
    next_node,
    path_weight,
    path,
    path_length
FROM shortest_paths
ORDER BY next_node, path_weight, path_length
LIMIT 10;
```

### 7.6 é«˜çº§ä¼˜åŒ–æŠ€å·§

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å¸¸ç”¨è·¯å¾„ç»“æœ**

å¯¹äºé¢‘ç¹æŸ¥è¯¢çš„æœ€çŸ­è·¯å¾„ï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜å¸¸ç”¨æœ€çŸ­è·¯å¾„
CREATE MATERIALIZED VIEW IF NOT EXISTS shortest_paths_cache AS
WITH popular_paths AS (
    SELECT DISTINCT source_id, target_id
    FROM route_queries  -- å‡è®¾æœ‰è·¯å¾„æŸ¥è¯¢æ—¥å¿—è¡¨
    WHERE query_count > 100  -- æŸ¥è¯¢æ¬¡æ•°è¶…è¿‡100çš„è·¯å¾„
)
SELECT
    pp.source_id,
    pp.target_id,
    -- ä½¿ç”¨Dijkstraç®—æ³•è®¡ç®—æœ€çŸ­è·¯å¾„ï¼ˆç®€åŒ–ç‰ˆï¼‰
    (SELECT MIN(total_distance)
     FROM shortest_path_computation
     WHERE source_id = pp.source_id AND target_id = pp.target_id
     LIMIT 1) AS shortest_distance
FROM popular_paths pp;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_shortest_paths_cache_source_target
ON shortest_paths_cache(source_id, target_id);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY shortest_paths_cache;
```

**2. å®æ—¶å¯¼èˆªç³»ç»Ÿï¼šå¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–**

**å®æ—¶å¯¼èˆªç³»ç»Ÿ**ï¼šç»¼åˆè€ƒè™‘è·ç¦»ã€æ—¶é—´ã€æˆæœ¬å’Œå®æ—¶äº¤é€šçŠ¶å†µçš„æœ€ä¼˜è·¯å¾„è§„åˆ’ã€‚

```sql
-- å®æ—¶å¯¼èˆªç³»ç»Ÿï¼šå¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'road_network') THEN
            CREATE TABLE road_network (
                from_location INTEGER NOT NULL,
                to_location INTEGER NOT NULL,
                distance_km NUMERIC(10, 2) NOT NULL,
                travel_time_minutes INTEGER NOT NULL,
                cost NUMERIC(10, 2) NOT NULL,
                traffic_level INTEGER,  -- 1-5, 5ä¸ºæœ€æ‹¥å µ
                road_type VARCHAR(20),  -- 'highway', 'city_road', 'local_road'
                PRIMARY KEY (from_location, to_location)
            );

            CREATE INDEX idx_road_network_from ON road_network(from_location, travel_time_minutes);
            CREATE INDEX idx_road_network_traffic ON road_network(traffic_level);

            RAISE NOTICE 'é“è·¯ç½‘ç»œè¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®æ—¶å¯¼èˆªç³»ç»Ÿè·¯å¾„ä¼˜åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®æ—¶å¯¼èˆªç³»ç»Ÿå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–ï¼šç»¼åˆè€ƒè™‘è·ç¦»ã€æ—¶é—´ã€æˆæœ¬å’Œäº¤é€šçŠ¶å†µ
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE navigation_paths AS (
    SELECT
        origin_location AS current_location,
        0 AS total_distance,
        0 AS total_time,
        0 AS total_cost,
        ARRAY[origin_location] AS path,
        -- ç»¼åˆè¯„åˆ†ï¼šè·ç¦»æƒé‡0.3ï¼Œæ—¶é—´æƒé‡0.4ï¼Œæˆæœ¬æƒé‡0.2ï¼Œäº¤é€šæƒé‡0.1
        (0 * 0.3 + 0 * 0.4 + 0 * 0.2 + 5 * 0.1) AS optimization_score
    FROM road_network
    WHERE from_location = 1  -- èµ·å§‹ä½ç½®

    UNION ALL

    SELECT
        rn.to_location AS current_location,
        np.total_distance + rn.distance_km AS total_distance,
        np.total_time + rn.travel_time_minutes AS total_time,
        np.total_cost + rn.cost AS total_cost,
        np.path || rn.to_location,
        -- ç»¼åˆè¯„åˆ†è®¡ç®—ï¼ˆè€ƒè™‘å®æ—¶äº¤é€šçŠ¶å†µï¼‰
        (np.total_distance + rn.distance_km) * 0.3 +
        (np.total_time + rn.travel_time_minutes * (1 + rn.traffic_level * 0.2)) * 0.4 +
        (np.total_cost + rn.cost) * 0.2 +
        rn.traffic_level * 0.1 AS optimization_score
    FROM navigation_paths np
    JOIN road_network rn ON np.current_location = rn.from_location
    WHERE rn.to_location != ALL(np.path)
      AND np.total_time + rn.travel_time_minutes * (1 + rn.traffic_level * 0.2) < 120  -- æ—¶é—´é™åˆ¶ï¼ˆåˆ†é’Ÿï¼‰
),
optimal_paths AS (
    SELECT DISTINCT ON (current_location)
        current_location,
        total_distance,
        total_time,
        total_cost,
        optimization_score,
        path
    FROM navigation_paths
    WHERE current_location = destination_location
    ORDER BY current_location, optimization_score ASC
)
SELECT
    current_location,
    ROUND(total_distance::numeric, 2) AS total_distance_km,
    total_time AS total_time_minutes,
    ROUND(total_cost::numeric, 2) AS total_cost,
    ROUND(optimization_score::numeric, 2) AS optimization_score,
    path AS optimal_route
FROM optimal_paths
ORDER BY optimization_score ASC
LIMIT 5;  -- Top 5æœ€ä¼˜è·¯å¾„
```

**3. ç‰©æµé…é€ä¼˜åŒ–ï¼šTSPé—®é¢˜çš„è¿‘ä¼¼è§£**

**ç‰©æµé…é€ä¼˜åŒ–**ï¼šè§£å†³æ—…è¡Œå•†é—®é¢˜ï¼ˆTSPï¼‰çš„è¿‘ä¼¼è§£ï¼Œä¼˜åŒ–é…é€è·¯å¾„ã€‚

```sql
-- ç‰©æµé…é€ä¼˜åŒ–ï¼šTSPé—®é¢˜çš„è¿‘ä¼¼è§£ï¼ˆæœ€è¿‘é‚»ç®—æ³•ï¼Œå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    warehouse_id INTEGER := 1;
    customer_ids INTEGER[] := ARRAY[2, 3, 4, 5, 6];
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'delivery_locations') THEN
            RAISE WARNING 'è¡¨ delivery_locations ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç‰©æµé…é€ä¼˜åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç‰©æµé…é€ä¼˜åŒ–ï¼Œä»“åº“ID: %, å®¢æˆ·ID: %', warehouse_id, customer_ids;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç‰©æµé…é€ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- TSPæœ€è¿‘é‚»ç®—æ³•ï¼šä»ä»“åº“å¼€å§‹ï¼Œæ¯æ¬¡é€‰æ‹©æœ€è¿‘çš„æœªè®¿é—®å®¢æˆ·
WITH RECURSIVE tsp_path AS (
    -- èµ·å§‹ï¼šä»ä»“åº“åˆ°æœ€è¿‘çš„å®¢æˆ·
    SELECT
        warehouse_id AS current_location,
        warehouse_id AS from_location,
        customer_id AS to_location,
        distance AS segment_distance,
        ARRAY[warehouse_id, customer_id] AS route,
        1 AS step,
        customer_ids - ARRAY[customer_id] AS remaining_customers
    FROM (
        SELECT DISTINCT
            customer_id,
            distance
        FROM delivery_locations
        WHERE from_location = warehouse_id
          AND customer_id = ANY(customer_ids)
        ORDER BY distance ASC
        LIMIT 1
    ) AS first_customer

    UNION ALL

    -- é€’å½’ï¼šä»å½“å‰ä½ç½®åˆ°æœ€è¿‘çš„æœªè®¿é—®å®¢æˆ·
    SELECT
        tsp.to_location AS current_location,
        tsp.to_location AS from_location,
        dl.customer_id AS to_location,
        dl.distance AS segment_distance,
        tsp.route || dl.customer_id,
        tsp.step + 1,
        tsp.remaining_customers - ARRAY[dl.customer_id]
    FROM tsp_path tsp
    JOIN LATERAL (
        SELECT
            customer_id,
            distance
        FROM delivery_locations
        WHERE from_location = tsp.to_location
          AND customer_id = ANY(tsp.remaining_customers)
        ORDER BY distance ASC
        LIMIT 1
    ) AS dl ON true
    WHERE array_length(tsp.remaining_customers, 1) > 0
),
-- æœ€åï¼šä»æœ€åä¸€ä¸ªå®¢æˆ·è¿”å›ä»“åº“
complete_route AS (
    SELECT
        route || warehouse_id AS full_route,
        SUM(segment_distance) + (
            SELECT distance
            FROM delivery_locations
            WHERE from_location = (SELECT route[array_length(route, 1)] FROM tsp_path ORDER BY step DESC LIMIT 1)
              AND to_location = warehouse_id
            LIMIT 1
        ) AS total_distance
    FROM tsp_path
    GROUP BY route
)
SELECT
    full_route AS delivery_route,
    ROUND(total_distance::numeric, 2) AS total_distance_km,
    array_length(full_route, 1) - 1 AS delivery_stops
FROM complete_route
ORDER BY total_distance ASC
LIMIT 1;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

- ã€Šç®—æ³•å¯¼è®ºã€‹ï¼ˆIntroduction to Algorithmsï¼‰- æœ€çŸ­è·¯å¾„ç®—æ³•ç†è®º
- ã€Šå›¾è®ºã€‹ï¼ˆGraph Theoryï¼‰- å›¾è®ºåŸºç¡€

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- [é€’å½’æŸ¥è¯¢](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE)
- [ç´¢å¼•ä¼˜åŒ–](https://www.postgresql.org/docs/current/indexes.html)

### åœ¨çº¿èµ„æº

- PostgreSQLæœ€çŸ­è·¯å¾„ç®—æ³•å®ç°
- Dijkstraç®—æ³•è¯¦è§£
- è·¯å¾„è§„åˆ’æœ€ä½³å®è·µ

### ç›¸å…³ç®—æ³•

- [å›¾éå†ç®—æ³•](./å›¾éå†ç®—æ³•.md) - å›¾éå†
- [è¿é€šæ€§åˆ†æ](./è¿é€šæ€§åˆ†æ.md) - è¿é€šæ€§æ£€æµ‹
- [å›¾èšç±»ç®—æ³•](./å›¾èšç±»ç®—æ³•.md) - å›¾èšç±»

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
