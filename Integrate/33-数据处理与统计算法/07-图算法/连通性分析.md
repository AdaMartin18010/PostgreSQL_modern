# PostgreSQL è¿é€šæ€§åˆ†æå®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | è¿é€šæ€§åˆ†æ | å¼ºè¿é€šåˆ†é‡
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL è¿é€šæ€§åˆ†æå®Œæ•´æŒ‡å—](#postgresql-è¿é€šæ€§åˆ†æå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [è¿é€šæ€§åˆ†ææ¦‚è¿°](#è¿é€šæ€§åˆ†ææ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [è¿é€šæ€§é—®é¢˜å®šä¹‰](#è¿é€šæ€§é—®é¢˜å®šä¹‰)
      - [è¿é€šæ€§ç±»å‹](#è¿é€šæ€§ç±»å‹)
      - [è¿é€šæ€§ç®—æ³•åˆ†ç±»](#è¿é€šæ€§ç®—æ³•åˆ†ç±»)
    - [æ ¸å¿ƒè¿é€šæ€§æ¦‚å¿µ](#æ ¸å¿ƒè¿é€šæ€§æ¦‚å¿µ)
  - [1. è¿é€šåˆ†é‡æ£€æµ‹](#1-è¿é€šåˆ†é‡æ£€æµ‹)
    - [1.1 è¿é€šåˆ†é‡æ£€æµ‹åŸç†](#11-è¿é€šåˆ†é‡æ£€æµ‹åŸç†)
      - [è¿é€šåˆ†é‡å®šä¹‰](#è¿é€šåˆ†é‡å®šä¹‰)
      - [æ£€æµ‹æ–¹æ³•](#æ£€æµ‹æ–¹æ³•)
    - [1.2 æ— å‘å›¾è¿é€šåˆ†é‡å®ç°](#12-æ— å‘å›¾è¿é€šåˆ†é‡å®ç°)
    - [1.3 è¿é€šåˆ†é‡ç»Ÿè®¡](#13-è¿é€šåˆ†é‡ç»Ÿè®¡)
  - [2. å¼ºè¿é€šåˆ†é‡](#2-å¼ºè¿é€šåˆ†é‡)
    - [2.1 å¼ºè¿é€šåˆ†é‡åŸç†](#21-å¼ºè¿é€šåˆ†é‡åŸç†)
      - [å¼ºè¿é€šåˆ†é‡å®šä¹‰](#å¼ºè¿é€šåˆ†é‡å®šä¹‰)
      - [Kosarajuç®—æ³•](#kosarajuç®—æ³•)
    - [2.2 æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡å®ç°](#22-æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡å®ç°)
    - [2.3 å¼ºè¿é€šåˆ†é‡åº”ç”¨](#23-å¼ºè¿é€šåˆ†é‡åº”ç”¨)
  - [3. å¼±è¿é€šåˆ†é‡](#3-å¼±è¿é€šåˆ†é‡)
    - [3.1 å¼±è¿é€šåˆ†é‡åŸç†](#31-å¼±è¿é€šåˆ†é‡åŸç†)
      - [å¼±è¿é€šåˆ†é‡å®šä¹‰](#å¼±è¿é€šåˆ†é‡å®šä¹‰)
    - [3.2 æœ‰å‘å›¾å¼±è¿é€šåˆ†é‡å®ç°](#32-æœ‰å‘å›¾å¼±è¿é€šåˆ†é‡å®ç°)
    - [3.3 å¼±è¿é€šåˆ†é‡åº”ç”¨](#33-å¼±è¿é€šåˆ†é‡åº”ç”¨)
  - [4. è¿é€šæ€§ä¼˜åŒ–ç­–ç•¥](#4-è¿é€šæ€§ä¼˜åŒ–ç­–ç•¥)
    - [4.1 ç´¢å¼•ä¼˜åŒ–](#41-ç´¢å¼•ä¼˜åŒ–)
    - [4.2 ç®—æ³•ä¼˜åŒ–](#42-ç®—æ³•ä¼˜åŒ–)
    - [4.3 æ€§èƒ½ä¼˜åŒ–](#43-æ€§èƒ½ä¼˜åŒ–)
  - [5. PostgreSQL 18 å¹¶è¡Œè¿é€šæ€§åˆ†æå¢å¼º](#5-postgresql-18-å¹¶è¡Œè¿é€šæ€§åˆ†æå¢å¼º)
    - [5.1 å¹¶è¡Œè¿é€šæ€§åˆ†æåŸç†](#51-å¹¶è¡Œè¿é€šæ€§åˆ†æåŸç†)
    - [5.2 å¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹](#52-å¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹)
    - [5.3 å¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹](#53-å¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹)
    - [5.4 å¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹](#54-å¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ](#51-ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ)
    - [5.2 ç½‘ç»œæ‹“æ‰‘åˆ†æ](#52-ç½‘ç»œæ‹“æ‰‘åˆ†æ)
    - [5.3 ä¾èµ–å…³ç³»åˆ†æ](#53-ä¾èµ–å…³ç³»åˆ†æ)
    - [5.4 å­¤ç«‹èŠ‚ç‚¹æ£€æµ‹](#54-å­¤ç«‹èŠ‚ç‚¹æ£€æµ‹)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [6.1 è¿é€šæ€§ç®—æ³•å¯¹æ¯”](#61-è¿é€šæ€§ç®—æ³•å¯¹æ¯”)
    - [6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#62-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#63-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [7.1 ç®—æ³•é€‰æ‹©](#71-ç®—æ³•é€‰æ‹©)
    - [7.2 æ•°æ®ç»“æ„è®¾è®¡](#72-æ•°æ®ç»“æ„è®¾è®¡)
    - [7.3 æ€§èƒ½ä¼˜åŒ–](#73-æ€§èƒ½ä¼˜åŒ–)
    - [7.4 SQLå®ç°æ³¨æ„äº‹é¡¹](#74-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [7.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨](#75-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨)
    - [7.6 é«˜çº§ä¼˜åŒ–æŠ€å·§](#76-é«˜çº§ä¼˜åŒ–æŠ€å·§)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## è¿é€šæ€§åˆ†ææ¦‚è¿°

**è¿é€šæ€§åˆ†æï¼ˆConnectivity Analysisï¼‰**ç”¨äºåˆ†æå›¾ä¸­èŠ‚ç‚¹çš„è¿é€šæ€§ï¼Œè¯†åˆ«è¿é€šåˆ†é‡å’Œå­¤ç«‹èŠ‚ç‚¹ï¼Œæ˜¯å›¾åˆ†æçš„åŸºç¡€æ“ä½œã€‚

### ç†è®ºåŸºç¡€

#### è¿é€šæ€§é—®é¢˜å®šä¹‰

**è¿é€šæ€§é—®é¢˜**ï¼šç»™å®šå›¾$G = (V, E)$ï¼Œè¯†åˆ«æ‰€æœ‰è¿é€šåˆ†é‡ï¼š
$$C = \{C_1, C_2, \ldots, C_k\} \text{ such that } \bigcup_{i=1}^{k} C_i = V$$

å…¶ä¸­æ¯ä¸ªè¿é€šåˆ†é‡$C_i$æ˜¯ä¸€ä¸ªæœ€å¤§è¿é€šå­å›¾ã€‚

#### è¿é€šæ€§ç±»å‹

**è¿é€šæ€§ç±»å‹**ï¼š

1. **æ— å‘å›¾è¿é€šåˆ†é‡**ï¼šèŠ‚ç‚¹ä¹‹é—´ç›¸äº’å¯è¾¾
2. **æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡**ï¼šèŠ‚ç‚¹ä¹‹é—´åŒå‘å¯è¾¾
3. **æœ‰å‘å›¾å¼±è¿é€šåˆ†é‡**ï¼šå¿½ç•¥æ–¹å‘åè¿é€š

#### è¿é€šæ€§ç®—æ³•åˆ†ç±»

è¿é€šæ€§ç®—æ³•åˆ†ç±»ï¼š

1. **DFS/BFSéå†**ï¼š
   - ä½¿ç”¨DFSæˆ–BFSéå†è¯†åˆ«è¿é€šåˆ†é‡
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(V + E)$

2. **å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰**ï¼š
   - ä½¿ç”¨å¹¶æŸ¥é›†æ•°æ®ç»“æ„
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(E \times \alpha(V))$ï¼ˆ$\alpha$æ˜¯åé˜¿å…‹æ›¼å‡½æ•°ï¼‰

3. **Kosarajuç®—æ³•**ï¼š
   - ç”¨äºå¼ºè¿é€šåˆ†é‡æ£€æµ‹
   - æ—¶é—´å¤æ‚åº¦ï¼š$O(V + E)$

### æ ¸å¿ƒè¿é€šæ€§æ¦‚å¿µ

| æ¦‚å¿µ | æ•°å­¦å®šä¹‰ | å®šä¹‰ | ç”¨é€” | æ—¶é—´å¤æ‚åº¦ |
|------|---------|------|------|-----------|
| **è¿é€šåˆ†é‡** | $C = \{v \mid \exists \text{ path from } u \text{ to } v\}$ | ç›¸äº’å¯è¾¾çš„èŠ‚ç‚¹é›†åˆ | è¯†åˆ«å­å›¾ | $O(V + E)$ |
| **å¼ºè¿é€š** | $u \leftrightarrow v$ï¼ˆåŒå‘å¯è¾¾ï¼‰ | åŒå‘å¯è¾¾ | æœ‰å‘å›¾åˆ†æ | $O(V + E)$ |
| **å¼±è¿é€š** | $u \sim v$ï¼ˆå¿½ç•¥æ–¹å‘å¯è¾¾ï¼‰ | å¿½ç•¥æ–¹å‘å¯è¾¾ | æœ‰å‘å›¾åˆ†æ | $O(V + E)$ |

---

## 1. è¿é€šåˆ†é‡æ£€æµ‹

### 1.1 è¿é€šåˆ†é‡æ£€æµ‹åŸç†

**è¿é€šåˆ†é‡æ£€æµ‹ï¼ˆConnected Component Detectionï¼‰**æ˜¯è¯†åˆ«å›¾ä¸­æ‰€æœ‰è¿é€šåˆ†é‡çš„ç®—æ³•ã€‚

#### è¿é€šåˆ†é‡å®šä¹‰

**è¿é€šåˆ†é‡**ï¼šè¿é€šåˆ†é‡$C$æ˜¯å›¾$G$çš„ä¸€ä¸ªæœ€å¤§è¿é€šå­å›¾ï¼Œæ»¡è¶³ï¼š

- å¯¹äºä»»æ„$u, v \in C$ï¼Œå­˜åœ¨è·¯å¾„ä»$u$åˆ°$v$
- ä¸å­˜åœ¨æ›´å¤§çš„è¿é€šå­å›¾åŒ…å«$C$

#### æ£€æµ‹æ–¹æ³•

**æ£€æµ‹æ–¹æ³•**ï¼š

1. **DFSéå†**ï¼šä»æ¯ä¸ªæœªè®¿é—®èŠ‚ç‚¹å¼€å§‹DFS
2. **BFSéå†**ï¼šä»æ¯ä¸ªæœªè®¿é—®èŠ‚ç‚¹å¼€å§‹BFS
3. **å¹¶æŸ¥é›†**ï¼šä½¿ç”¨å¹¶æŸ¥é›†åˆå¹¶è¿é€šèŠ‚ç‚¹

### 1.2 æ— å‘å›¾è¿é€šåˆ†é‡å®ç°

**æ— å‘å›¾è¿é€šåˆ†é‡**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- è¿é€šåˆ†é‡æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œè¿é€šåˆ†é‡æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è¿é€šåˆ†é‡æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM connected_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

### 1.3 è¿é€šåˆ†é‡ç»Ÿè®¡

**è¿é€šåˆ†é‡ç»Ÿè®¡**ï¼šç»Ÿè®¡è¿é€šåˆ†é‡çš„æ•°é‡å’Œå¤§å°ã€‚

```sql
-- è¿é€šåˆ†é‡ç»Ÿè®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè¿é€šåˆ†é‡ç»Ÿè®¡';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè¿é€šåˆ†é‡ç»Ÿè®¡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œè¿é€šåˆ†é‡ç»Ÿè®¡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è¿é€šåˆ†é‡ç»Ÿè®¡å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è¿é€šåˆ†é‡ç»Ÿè®¡ï¼šç»Ÿè®¡æ¯ä¸ªè¿é€šåˆ†é‡çš„å¤§å°å’Œç‰¹å¾
WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
),
component_stats AS (
    SELECT
        component_id,
        COUNT(DISTINCT node_id) AS component_size,
        array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
    FROM connected_components
    GROUP BY component_id
)
SELECT
    component_id,
    component_size,
    CASE
        WHEN component_size = 1 THEN 'Isolated'
        WHEN component_size < 5 THEN 'Small'
        WHEN component_size < 20 THEN 'Medium'
        ELSE 'Large'
    END AS component_type,
    nodes
FROM component_stats
ORDER BY component_size DESC;
```

---

## 2. å¼ºè¿é€šåˆ†é‡

### 2.1 å¼ºè¿é€šåˆ†é‡åŸç†

**å¼ºè¿é€šåˆ†é‡ï¼ˆStrongly Connected Component, SCCï¼‰**æ˜¯æœ‰å‘å›¾ä¸­çš„æœ€å¤§å¼ºè¿é€šå­å›¾ã€‚

#### å¼ºè¿é€šåˆ†é‡å®šä¹‰

**å¼ºè¿é€šåˆ†é‡**ï¼šæœ‰å‘å›¾$G$ä¸­çš„å¼ºè¿é€šåˆ†é‡$C$æ»¡è¶³ï¼š

- å¯¹äºä»»æ„$u, v \in C$ï¼Œå­˜åœ¨è·¯å¾„ä»$u$åˆ°$v$ï¼Œä¹Ÿå­˜åœ¨è·¯å¾„ä»$v$åˆ°$u$
- ä¸å­˜åœ¨æ›´å¤§çš„å¼ºè¿é€šå­å›¾åŒ…å«$C$

#### Kosarajuç®—æ³•

**Kosarajuç®—æ³•**ï¼š

1. å¯¹å›¾$G$è¿›è¡ŒDFSï¼Œè®°å½•å®Œæˆæ—¶é—´
2. æ„å»ºè½¬ç½®å›¾$G^T$
3. æŒ‰å®Œæˆæ—¶é—´é™åºå¯¹$G^T$è¿›è¡ŒDFS

### 2.2 æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡å®ç°

**æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- å¼ºè¿é€šåˆ†é‡æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¼ºè¿é€šåˆ†é‡æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE forward_reachable AS (
    SELECT
        id AS node_id,
        id AS root_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        fr.root_id
    FROM forward_reachable fr
    JOIN edges e ON fr.node_id = e.source_id
),
backward_reachable AS (
    SELECT
        id AS node_id,
        id AS root_id
    FROM nodes
    UNION
    SELECT
        e.source_id,
        br.root_id
    FROM backward_reachable br
    JOIN edges e ON br.node_id = e.target_id
)
SELECT
    fr.root_id AS component_id,
    COUNT(DISTINCT fr.node_id) AS component_size
FROM forward_reachable fr
JOIN backward_reachable br ON fr.node_id = br.node_id AND fr.root_id = br.root_id
GROUP BY fr.root_id
ORDER BY component_size DESC;
```

---

### 2.3 å¼ºè¿é€šåˆ†é‡åº”ç”¨

**å¼ºè¿é€šåˆ†é‡åº”ç”¨**ï¼šåˆ†ææœ‰å‘å›¾ä¸­çš„å¼ºè¿é€šç»“æ„ã€‚

```sql
-- å¼ºè¿é€šåˆ†é‡åº”ç”¨ï¼šåˆ†ææœ‰å‘å›¾çš„å¼ºè¿é€šç»“æ„ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_graph') THEN
            RAISE WARNING 'è¡¨ directed_graph ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¼ºè¿é€šåˆ†é‡åº”ç”¨';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¼ºè¿é€šåˆ†é‡åº”ç”¨';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¼ºè¿é€šåˆ†é‡åº”ç”¨å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¼ºè¿é€šåˆ†é‡åº”ç”¨ï¼šè¯†åˆ«æœ‰å‘å›¾ä¸­çš„å¾ªç¯ä¾èµ–
WITH RECURSIVE forward_reachable AS (
    SELECT
        node_id,
        node_id AS root_id
    FROM graph_nodes
    UNION
    SELECT
        dg.target_id,
        fr.root_id
    FROM forward_reachable fr
    JOIN directed_graph dg ON fr.node_id = dg.source_id
),
backward_reachable AS (
    SELECT
        node_id,
        node_id AS root_id
    FROM graph_nodes
    UNION
    SELECT
        dg.source_id,
        br.root_id
    FROM backward_reachable br
    JOIN directed_graph dg ON br.node_id = dg.target_id
),
strongly_connected AS (
    SELECT DISTINCT
        fr.root_id AS scc_id,
        fr.node_id
    FROM forward_reachable fr
    JOIN backward_reachable br ON fr.node_id = br.node_id AND fr.root_id = br.root_id
)
SELECT
    scc_id,
    COUNT(DISTINCT node_id) AS scc_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members
FROM strongly_connected
GROUP BY scc_id
HAVING COUNT(DISTINCT node_id) > 1  -- åªæ˜¾ç¤ºéå•èŠ‚ç‚¹çš„å¼ºè¿é€šåˆ†é‡
ORDER BY scc_size DESC;
```

---

## 3. å¼±è¿é€šåˆ†é‡

### 3.1 å¼±è¿é€šåˆ†é‡åŸç†

**å¼±è¿é€šåˆ†é‡ï¼ˆWeakly Connected Componentï¼‰**æ˜¯æœ‰å‘å›¾ä¸­å¿½ç•¥æ–¹å‘åçš„è¿é€šåˆ†é‡ã€‚

#### å¼±è¿é€šåˆ†é‡å®šä¹‰

**å¼±è¿é€šåˆ†é‡**ï¼šæœ‰å‘å›¾$G$çš„å¼±è¿é€šåˆ†é‡æ˜¯å°†$G$è½¬æ¢ä¸ºæ— å‘å›¾åçš„è¿é€šåˆ†é‡ã€‚

**æ£€æµ‹æ–¹æ³•**ï¼šå°†æœ‰å‘å›¾è½¬æ¢ä¸ºæ— å‘å›¾ï¼Œç„¶åä½¿ç”¨æ— å‘å›¾è¿é€šåˆ†é‡æ£€æµ‹ç®—æ³•ã€‚

### 3.2 æœ‰å‘å›¾å¼±è¿é€šåˆ†é‡å®ç°

**æœ‰å‘å›¾å¼±è¿é€šåˆ†é‡**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- å¼±è¿é€šåˆ†é‡æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¼±è¿é€šåˆ†é‡æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE weak_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        wc.component_id
    FROM weak_components wc
    JOIN edges e ON wc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        wc.component_id
    FROM weak_components wc
    JOIN edges e ON wc.node_id = e.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM weak_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

### 3.3 å¼±è¿é€šåˆ†é‡åº”ç”¨

**å¼±è¿é€šåˆ†é‡åº”ç”¨**ï¼šåˆ†ææœ‰å‘å›¾çš„å¼±è¿é€šç»“æ„ã€‚

```sql
-- å¼±è¿é€šåˆ†é‡åº”ç”¨ï¼šåˆ†ææœ‰å‘å›¾çš„å¼±è¿é€šç»“æ„ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_graph') THEN
            RAISE WARNING 'è¡¨ directed_graph ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¼±è¿é€šåˆ†é‡åº”ç”¨';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¼±è¿é€šåˆ†é‡åº”ç”¨';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¼±è¿é€šåˆ†é‡åº”ç”¨å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¼±è¿é€šåˆ†é‡åº”ç”¨ï¼šå°†æœ‰å‘å›¾è½¬æ¢ä¸ºæ— å‘å›¾åæ£€æµ‹è¿é€šåˆ†é‡
WITH RECURSIVE weak_components AS (
    SELECT
        node_id,
        node_id AS component_id
    FROM graph_nodes
    UNION
    -- å¿½ç•¥æ–¹å‘ï¼šåŒæ—¶è€ƒè™‘æ­£å‘å’Œåå‘è¾¹
    SELECT
        dg.target_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_graph dg ON wc.node_id = dg.source_id
    UNION
    SELECT
        dg.source_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_graph dg ON wc.node_id = dg.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members
FROM weak_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

## 4. è¿é€šæ€§ä¼˜åŒ–ç­–ç•¥

### 4.1 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºè¿é€šæ€§æŸ¥è¯¢åˆ›å»ºåˆé€‚çš„ç´¢å¼•ã€‚

```sql
-- ç´¢å¼•ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        -- è¾¹è¡¨ç´¢å¼•ï¼šåŠ é€Ÿé‚»æ¥èŠ‚ç‚¹æŸ¥æ‰¾
        CREATE INDEX IF NOT EXISTS idx_edges_source_target
        ON edges(source_id, target_id);

        CREATE INDEX IF NOT EXISTS idx_edges_target_source
        ON edges(target_id, source_id);

        RAISE NOTICE 'è¿é€šæ€§åˆ†æç´¢å¼•åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç´¢å¼•åˆ›å»ºå¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 ç®—æ³•ä¼˜åŒ–

**ç®—æ³•ä¼˜åŒ–**ï¼šä¼˜åŒ–è¿é€šæ€§æ£€æµ‹ç®—æ³•ã€‚

```sql
-- ç®—æ³•ä¼˜åŒ–ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜è¿é€šåˆ†é‡ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS connected_components_cache AS
WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
)
SELECT DISTINCT ON (node_id)
    node_id,
    component_id
FROM connected_components
ORDER BY node_id, component_id;

CREATE INDEX IF NOT EXISTS idx_connected_components_cache_node_component
ON connected_components_cache(node_id, component_id);

-- åˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY connected_components_cache;
```

### 4.3 æ€§èƒ½ä¼˜åŒ–

**æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢å’Œæ‰¹é‡å¤„ç†ã€‚

```sql
-- æ€§èƒ½ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        SET work_mem = '512MB';
        RAISE NOTICE 'æ€§èƒ½ä¼˜åŒ–é…ç½®å·²è®¾ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ€§èƒ½ä¼˜åŒ–å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. PostgreSQL 18 å¹¶è¡Œè¿é€šæ€§åˆ†æå¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œè¿é€šæ€§åˆ†æèƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œè¿é€šåˆ†é‡æ£€æµ‹ã€å¼ºè¿é€šåˆ†é‡æ£€æµ‹å’Œå¼±è¿é€šåˆ†é‡æ£€æµ‹ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡å›¾è¿é€šæ€§åˆ†æçš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œè¿é€šæ€§åˆ†æåŸç†

PostgreSQL 18 çš„å¹¶è¡Œè¿é€šæ€§åˆ†æé€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æå›¾æ•°æ®
2. **å¹¶è¡Œéå†**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹æ‰§è¡Œå›¾éå†
3. **å¹¶è¡Œåˆ†é‡è¯†åˆ«**ï¼šå¹¶è¡Œè¯†åˆ«è¿é€šåˆ†é‡
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„åˆ†æç»“æœ

### 5.2 å¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹

```sql
-- PostgreSQL 18 å¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œè¿é€šåˆ†é‡æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œæ— å‘å›¾è¿é€šåˆ†é‡æ£€æµ‹
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM connected_components
GROUP BY component_id
ORDER BY component_size DESC;
```

### 5.3 å¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹

```sql
-- PostgreSQL 18 å¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_edges') THEN
            RAISE WARNING 'è¡¨ directed_edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå¼ºè¿é€šåˆ†é‡æ£€æµ‹ï¼šKosarajuç®—æ³•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE dfs_forward AS (
    SELECT
        source_id AS start_node,
        source_id AS current_node,
        ARRAY[source_id] AS visited
    UNION ALL
    SELECT
        df.start_node,
        de.target_id,
        df.visited || de.target_id
    FROM dfs_forward df
    JOIN directed_edges de ON df.current_node = de.source_id
    WHERE de.target_id != ALL(df.visited)
),
dfs_backward AS (
    SELECT
        source_id AS start_node,
        source_id AS current_node,
        ARRAY[source_id] AS visited
    FROM dfs_forward
    WHERE current_node IN (SELECT MAX(current_node) FROM dfs_forward GROUP BY start_node)
    UNION ALL
    SELECT
        db.start_node,
        de.source_id,
        db.visited || de.source_id
    FROM dfs_backward db
    JOIN directed_edges de ON db.current_node = de.target_id
    WHERE de.source_id != ALL(db.visited)
)
SELECT
    start_node AS component_id,
    COUNT(DISTINCT current_node) AS component_size,
    array_agg(DISTINCT current_node ORDER BY current_node) AS nodes
FROM dfs_backward
GROUP BY start_node
ORDER BY component_size DESC;
```

### 5.4 å¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹

```sql
-- PostgreSQL 18 å¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_edges') THEN
            RAISE WARNING 'è¡¨ directed_edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå¼±è¿é€šåˆ†é‡æ£€æµ‹ï¼šå¿½ç•¥æ–¹å‘
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE weak_components AS (
    SELECT
        source_id AS node_id,
        source_id AS component_id
    FROM directed_edges
    UNION
    SELECT
        target_id,
        source_id AS component_id
    FROM directed_edges
    UNION
    SELECT
        de.target_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_edges de ON wc.node_id = de.source_id
    UNION
    SELECT
        de.source_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_edges de ON wc.node_id = de.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM weak_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ

**ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ**åˆ†æç¤¾äº¤ç½‘ç»œçš„è¿é€šæ€§ã€‚

```sql
-- ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users') THEN
            RAISE WARNING 'è¡¨ users ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'friendships') THEN
            RAISE WARNING 'è¡¨ friendships ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æï¼šè¯†åˆ«ç”¨æˆ·ç¤¾åŒº
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE social_components AS (
    SELECT
        user_id AS node_id,
        user_id AS component_id
    FROM users
    UNION
    SELECT
        f.friend_id,
        sc.component_id
    FROM social_components sc
    JOIN friendships f ON sc.node_id = f.user_id
    UNION
    SELECT
        f.user_id,
        sc.component_id
    FROM social_components sc
    JOIN friendships f ON sc.node_id = f.friend_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS community_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members,
    CASE
        WHEN COUNT(DISTINCT node_id) = 1 THEN 'Isolated User'
        WHEN COUNT(DISTINCT node_id) < 10 THEN 'Small Community'
        WHEN COUNT(DISTINCT node_id) < 100 THEN 'Medium Community'
        ELSE 'Large Community'
    END AS community_type
FROM social_components
GROUP BY component_id
ORDER BY community_size DESC;
```

### 5.2 ç½‘ç»œæ‹“æ‰‘åˆ†æ

**ç½‘ç»œæ‹“æ‰‘åˆ†æ**ï¼šåˆ†æç½‘ç»œè®¾å¤‡çš„è¿é€šæ€§ã€‚

```sql
-- ç½‘ç»œæ‹“æ‰‘åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'network_devices') THEN
            RAISE WARNING 'è¡¨ network_devices ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç½‘ç»œæ‹“æ‰‘åˆ†æ';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'network_links') THEN
            RAISE WARNING 'è¡¨ network_links ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç½‘ç»œæ‹“æ‰‘åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç½‘ç»œæ‹“æ‰‘åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç½‘ç»œæ‹“æ‰‘åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç½‘ç»œæ‹“æ‰‘åˆ†æï¼šè¯†åˆ«ç½‘ç»œä¸­çš„è¿é€šå­ç½‘
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE network_components AS (
    SELECT
        device_id AS node_id,
        device_id AS component_id
    FROM network_devices
    UNION
    SELECT
        nl.device2_id,
        nc.component_id
    FROM network_components nc
    JOIN network_links nl ON nc.node_id = nl.device1_id
    UNION
    SELECT
        nl.device1_id,
        nc.component_id
    FROM network_components nc
    JOIN network_links nl ON nc.node_id = nl.device2_id
)
SELECT
    component_id AS subnet_id,
    COUNT(DISTINCT node_id) AS subnet_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS devices,
    CASE
        WHEN COUNT(DISTINCT node_id) = 1 THEN 'Isolated Device'
        ELSE 'Connected Subnet'
    END AS subnet_type
FROM network_components
GROUP BY component_id
ORDER BY subnet_size DESC;
```

### 5.3 ä¾èµ–å…³ç³»åˆ†æ

**ä¾èµ–å…³ç³»åˆ†æ**ï¼šåˆ†æä»»åŠ¡æˆ–æ¨¡å—ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚

```sql
-- ä¾èµ–å…³ç³»åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'task_dependencies') THEN
            RAISE WARNING 'è¡¨ task_dependencies ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œä¾èµ–å…³ç³»åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œä¾èµ–å…³ç³»åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¾èµ–å…³ç³»åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä¾èµ–å…³ç³»åˆ†æï¼šè¯†åˆ«å¼ºè¿é€šåˆ†é‡ï¼ˆå¾ªç¯ä¾èµ–ï¼‰
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE forward_deps AS (
    SELECT
        task_id,
        task_id AS root_id
    FROM tasks
    UNION
    SELECT
        td.depends_on_task_id,
        fd.root_id
    FROM forward_deps fd
    JOIN task_dependencies td ON fd.task_id = td.task_id
),
backward_deps AS (
    SELECT
        task_id,
        task_id AS root_id
    FROM tasks
    UNION
    SELECT
        td.task_id,
        bd.root_id
    FROM backward_deps bd
    JOIN task_dependencies td ON bd.task_id = td.depends_on_task_id
),
circular_dependencies AS (
    SELECT DISTINCT
        fd.root_id AS scc_id,
        fd.task_id
    FROM forward_deps fd
    JOIN backward_deps bd ON fd.task_id = bd.task_id AND fd.root_id = bd.root_id
)
SELECT
    scc_id,
    COUNT(DISTINCT task_id) AS cycle_size,
    array_agg(DISTINCT task_id ORDER BY task_id) AS tasks_in_cycle
FROM circular_dependencies
GROUP BY scc_id
HAVING COUNT(DISTINCT task_id) > 1  -- åªæ˜¾ç¤ºå¾ªç¯ä¾èµ–
ORDER BY cycle_size DESC;
```

### 5.4 å­¤ç«‹èŠ‚ç‚¹æ£€æµ‹

**å­¤ç«‹èŠ‚ç‚¹æ£€æµ‹**ï¼šæ£€æµ‹å›¾ä¸­çš„å­¤ç«‹èŠ‚ç‚¹ã€‚

```sql
-- å­¤ç«‹èŠ‚ç‚¹æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING 'è¡¨ nodes ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå­¤ç«‹èŠ‚ç‚¹æ£€æµ‹';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING 'è¡¨ edges ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå­¤ç«‹èŠ‚ç‚¹æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå­¤ç«‹èŠ‚ç‚¹æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å­¤ç«‹èŠ‚ç‚¹æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å­¤ç«‹èŠ‚ç‚¹æ£€æµ‹ï¼šè¯†åˆ«æ²¡æœ‰è¿æ¥çš„èŠ‚ç‚¹
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH connected_nodes AS (
    SELECT DISTINCT source_id AS node_id FROM edges
    UNION
    SELECT DISTINCT target_id FROM edges
)
SELECT
    n.id AS isolated_node_id,
    n.name,
    n.properties
FROM nodes n
LEFT JOIN connected_nodes cn ON n.id = cn.node_id
WHERE cn.node_id IS NULL
ORDER BY n.id;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 6.1 è¿é€šæ€§ç®—æ³•å¯¹æ¯”

| ç®—æ³• | æ•°å­¦å®šä¹‰ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|-----------|-----------|---------|------|------|
| **DFS/BFSéå†** | ä½¿ç”¨éå†è¯†åˆ«è¿é€šåˆ†é‡ | $O(V + E)$ | $O(V)$ | é€šç”¨ | ç®€å•ã€é«˜æ•ˆ | éœ€è¦å¤šæ¬¡éå† |
| **å¹¶æŸ¥é›†** | Union-Findæ•°æ®ç»“æ„ | $O(E \times \alpha(V))$ | $O(V)$ | åŠ¨æ€å›¾ | é«˜æ•ˆ | å®ç°å¤æ‚ |
| **Kosaraju** | å¼ºè¿é€šåˆ†é‡æ£€æµ‹ | $O(V + E)$ | $O(V)$ | æœ‰å‘å›¾ | ç²¾ç¡® | éœ€è¦ä¸¤æ¬¡DFS |

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**ï¼š
   - ä¸ºè¾¹è¡¨åˆ›å»ºç´¢å¼•
   - ä¸ºèŠ‚ç‚¹è¡¨åˆ›å»ºç´¢å¼•

2. **ç®—æ³•ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨å¹¶æŸ¥é›†ï¼ˆå¦‚æœæ”¯æŒï¼‰
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ

3. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - é™åˆ¶æœç´¢èŒƒå›´
   - ä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢

### 6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šè¿é€šæ€§æ£€æµ‹æ€§èƒ½æ…¢

- **è§£å†³æ–¹æ¡ˆ**ï¼šåˆ›å»ºç´¢å¼•ã€ä½¿ç”¨ç‰©åŒ–è§†å›¾ã€å¹¶è¡ŒæŸ¥è¯¢

**é—®é¢˜2**ï¼šå¼ºè¿é€šåˆ†é‡æ£€æµ‹å¤æ‚

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨Kosarajuç®—æ³•ã€ä¼˜åŒ–å®ç°

**é—®é¢˜3**ï¼šå¤§è§„æ¨¡å›¾å†…å­˜ä¸è¶³

- **è§£å†³æ–¹æ¡ˆ**ï¼šåˆ†æ‰¹å¤„ç†ã€ä½¿ç”¨æµå¼å¤„ç†ã€ä¼˜åŒ–æ•°æ®ç»“æ„

**é—®é¢˜4**ï¼šå­¤ç«‹èŠ‚ç‚¹è¯†åˆ«å›°éš¾

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨LEFT JOINã€å•ç‹¬æŸ¥è¯¢

---

## 8. æœ€ä½³å®è·µ

### 7.1 ç®—æ³•é€‰æ‹©

1. **æ— å‘å›¾è¿é€šåˆ†é‡**ï¼šä½¿ç”¨DFS/BFS
2. **æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡**ï¼šä½¿ç”¨Kosarajuç®—æ³•
3. **æœ‰å‘å›¾å¼±è¿é€šåˆ†é‡**ï¼šè½¬æ¢ä¸ºæ— å‘å›¾åä½¿ç”¨DFS/BFS

### 7.2 æ•°æ®ç»“æ„è®¾è®¡

1. **èŠ‚ç‚¹è¡¨**ï¼šåŒ…å«èŠ‚ç‚¹IDå’Œå±æ€§
2. **è¾¹è¡¨**ï¼šåŒ…å«æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹
3. **ç´¢å¼•**ï¼šä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ›å»ºç´¢å¼•

### 7.3 æ€§èƒ½ä¼˜åŒ–

1. **ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºè¾¹è¡¨åˆ›å»ºç´¢å¼•
2. **ç»“æœç¼“å­˜**ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ
3. **å¹¶è¡ŒæŸ¥è¯¢**ï¼šå¯ç”¨å¹¶è¡ŒæŸ¥è¯¢å¤„ç†å¤§è§„æ¨¡æ•°æ®

### 7.4 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é€’å½’æ·±åº¦**ï¼šæ³¨æ„PostgreSQLçš„é€’å½’æ·±åº¦é™åˆ¶
2. **æ€§èƒ½è€ƒè™‘**ï¼šé¿å…åœ¨å¤§å›¾ä¸Šä½¿ç”¨å¤æ‚ç®—æ³•
3. **å¾ªç¯æ£€æµ‹**ï¼šä½¿ç”¨è·¯å¾„æ•°ç»„æ£€æµ‹å¾ªç¯
4. **é”™è¯¯å¤„ç†**ï¼šå¤„ç†NULLå€¼å’Œè¾¹ç•Œæƒ…å†µ

### 7.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡è¿é€šæ€§åˆ†æçš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«è¿é€šåˆ†é‡çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Kè¿é€šåˆ†é‡æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡è¿é€šæ€§åˆ†æï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡è¿é€šåˆ†é‡æ£€æµ‹å’Œå¤§è§„æ¨¡å›¾åˆ†æ

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - è¿é€šæ€§åˆ†ææ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆæœ‰é™æ”¯æŒï¼Œå› ä¸ºé€’å½’CTEçš„å¹¶è¡ŒåŒ–é™åˆ¶ï¼‰
   - é€‚ç”¨äºç‹¬ç«‹è¿é€šåˆ†é‡æ£€æµ‹

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–è¿é€šåˆ†é‡æŸ¥è¯¢**

```sql
-- ä¸ºè¿é€šåˆ†é‡åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_connected_components_skip_scan
ON node_components(component_id, node_count DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾èŠ‚ç‚¹æ•°æœ€å¤šçš„å‰10ä¸ªè¿é€šåˆ†é‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    component_id,
    node_count,
    nodes
FROM node_components
ORDER BY node_count DESC
LIMIT 10;
```

### 7.6 é«˜çº§ä¼˜åŒ–æŠ€å·§

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜è¿é€šåˆ†é‡ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„è¿é€šåˆ†é‡ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜è¿é€šåˆ†é‡ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS connected_components_cache AS
WITH RECURSIVE component_detection AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cd.component_id
    FROM component_detection cd
    JOIN edges e ON cd.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cd.component_id
    FROM component_detection cd
    JOIN edges e ON cd.node_id = e.target_id
),
component_statistics AS (
    SELECT
        component_id,
        COUNT(DISTINCT node_id) AS node_count,
        array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
    FROM component_detection
    GROUP BY component_id
)
SELECT
    component_id,
    node_count,
    nodes
FROM component_statistics;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_connected_components_cache_size ON connected_components_cache(node_count DESC);
CREATE INDEX idx_connected_components_cache_component ON connected_components_cache(component_id);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY connected_components_cache;
```

**2. ç¤¾äº¤ç½‘ç»œåˆ†æï¼šç¤¾åŒºè¿é€šæ€§åˆ†æ**

**ç¤¾äº¤ç½‘ç»œåˆ†æ**ï¼šåˆ†æç¤¾äº¤ç½‘ç»œä¸­çš„ç¤¾åŒºè¿é€šæ€§ã€‚

```sql
-- ç¤¾äº¤ç½‘ç»œåˆ†æï¼šç¤¾åŒºè¿é€šæ€§åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'social_connections') THEN
            CREATE TABLE social_connections (
                connection_id SERIAL PRIMARY KEY,
                user1_id INTEGER NOT NULL,
                user2_id INTEGER NOT NULL,
                connection_type VARCHAR(20),  -- 'friend', 'follow', 'mention'
                connection_strength INTEGER DEFAULT 1,
                created_at TIMESTAMPTZ DEFAULT NOW(),
                UNIQUE(user1_id, user2_id)
            );

            CREATE INDEX idx_social_connections_user1 ON social_connections(user1_id);
            CREATE INDEX idx_social_connections_user2 ON social_connections(user2_id);
            CREATE INDEX idx_social_connections_type ON social_connections(connection_type);

            RAISE NOTICE 'ç¤¾äº¤è¿æ¥è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æï¼šè¯†åˆ«ç¤¾åŒºå’Œå­¤ç«‹ç”¨æˆ·
WITH RECURSIVE social_components AS (
    -- èµ·å§‹ï¼šæ¯ä¸ªç”¨æˆ·ä½œä¸ºä¸€ä¸ªè¿é€šåˆ†é‡
    SELECT DISTINCT
        user1_id AS user_id,
        user1_id AS component_id
    FROM social_connections

    UNION

    -- é€’å½’ï¼šé€šè¿‡è¿æ¥æ‰©å±•è¿é€šåˆ†é‡
    SELECT
        sc2.user2_id,
        soc.component_id
    FROM social_components soc
    JOIN social_connections sc2 ON soc.user_id = sc2.user1_id
    UNION
    SELECT
        sc3.user1_id,
        soc.component_id
    FROM social_components soc
    JOIN social_connections sc3 ON soc.user_id = sc3.user2_id
),
community_statistics AS (
    SELECT
        component_id AS community_id,
        COUNT(DISTINCT user_id) AS community_size,
        array_agg(DISTINCT user_id ORDER BY user_id) AS community_members,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ç¤¾åŒºæ’åï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        DENSE_RANK() OVER (ORDER BY COUNT(DISTINCT user_id) DESC) AS community_rank
    FROM social_components
    GROUP BY component_id
),
community_metrics AS (
    SELECT
        cs.community_id,
        cs.community_size,
        cs.community_members,
        cs.community_rank,
        -- è®¡ç®—ç¤¾åŒºå†…éƒ¨è¿æ¥æ•°
        COUNT(*) AS internal_connections,
        -- è®¡ç®—ç¤¾åŒºå¯†åº¦
        CASE
            WHEN cs.community_size > 1 THEN
                COUNT(*)::numeric / (cs.community_size * (cs.community_size - 1) / 2)
            ELSE 0
        END AS community_density
    FROM community_statistics cs
    LEFT JOIN social_connections sc ON
        sc.user1_id = ANY(cs.community_members) AND
        sc.user2_id = ANY(cs.community_members)
    GROUP BY cs.community_id, cs.community_size, cs.community_members, cs.community_rank
)
SELECT
    community_id,
    community_size,
    community_rank,
    internal_connections,
    ROUND(community_density::numeric, 4) AS density,
    CASE
        WHEN community_size = 1 THEN 'Isolated User'
        WHEN community_size >= 10 AND community_density > 0.5 THEN 'Strong Community'
        WHEN community_size >= 5 AND community_density > 0.3 THEN 'Medium Community'
        WHEN community_size >= 3 THEN 'Weak Community'
        ELSE 'Small Group'
    END AS community_type,
    community_members[1:10] AS top_members  -- å‰10ä¸ªæˆå‘˜
FROM community_metrics
ORDER BY community_rank
LIMIT 20;
```

**3. ä¾èµ–å…³ç³»åˆ†æï¼šå¾ªç¯ä¾èµ–æ£€æµ‹**

**ä¾èµ–å…³ç³»åˆ†æ**ï¼šæ£€æµ‹ä»»åŠ¡ã€æ¨¡å—æˆ–æœåŠ¡ä¹‹é—´çš„å¾ªç¯ä¾èµ–ã€‚

```sql
-- ä¾èµ–å…³ç³»åˆ†æï¼šå¾ªç¯ä¾èµ–æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'task_dependencies') THEN
            CREATE TABLE task_dependencies (
                dependency_id SERIAL PRIMARY KEY,
                task_id INTEGER NOT NULL,
                depends_on_task_id INTEGER NOT NULL,
                dependency_type VARCHAR(20),  -- 'required', 'optional', 'blocking'
                FOREIGN KEY (task_id) REFERENCES tasks(task_id),
                FOREIGN KEY (depends_on_task_id) REFERENCES tasks(task_id),
                CHECK (task_id != depends_on_task_id)
            );

            CREATE INDEX idx_task_dependencies_task ON task_dependencies(task_id);
            CREATE INDEX idx_task_dependencies_depends ON task_dependencies(depends_on_task_id);

            RAISE NOTICE 'ä»»åŠ¡ä¾èµ–è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¾ªç¯ä¾èµ–æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¾ªç¯ä¾èµ–æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¾ªç¯ä¾èµ–æ£€æµ‹ï¼šä½¿ç”¨å¼ºè¿é€šåˆ†é‡ç®—æ³•
WITH RECURSIVE forward_paths AS (
    SELECT
        task_id AS from_task,
        task_id AS to_task,
        ARRAY[task_id] AS path,
        0 AS path_length
    FROM tasks
    UNION
    SELECT
        fp.from_task,
        td.depends_on_task_id,
        fp.path || td.depends_on_task_id,
        fp.path_length + 1
    FROM forward_paths fp
    JOIN task_dependencies td ON fp.to_task = td.task_id
    WHERE td.depends_on_task_id != ALL(fp.path)
      AND fp.path_length < 20
),
backward_paths AS (
    SELECT
        task_id AS from_task,
        task_id AS to_task,
        ARRAY[task_id] AS path,
        0 AS path_length
    FROM tasks
    UNION
    SELECT
        bp.from_task,
        td.task_id,
        bp.path || td.task_id,
        bp.path_length + 1
    FROM backward_paths bp
    JOIN task_dependencies td ON bp.to_task = td.depends_on_task_id
    WHERE td.task_id != ALL(bp.path)
      AND bp.path_length < 20
),
circular_dependencies AS (
    SELECT DISTINCT
        fp.from_task AS cycle_root,
        fp.to_task AS cycle_node,
        fp.path AS forward_path,
        bp.path AS backward_path
    FROM forward_paths fp
    JOIN backward_paths bp ON fp.from_task = bp.from_task AND fp.to_task = bp.to_task
    WHERE fp.from_task != fp.to_task
      AND fp.path_length > 0
      AND bp.path_length > 0
)
SELECT
    cycle_root,
    cycle_node,
    forward_path || array_reverse(backward_path[2:]) AS cycle_path,
    array_length(forward_path, 1) + array_length(backward_path, 1) - 1 AS cycle_length,
    CASE
        WHEN array_length(forward_path, 1) + array_length(backward_path, 1) - 1 <= 3 THEN 'Critical Cycle'
        WHEN array_length(forward_path, 1) + array_length(backward_path, 1) - 1 <= 5 THEN 'Important Cycle'
        ELSE 'Minor Cycle'
    END AS cycle_severity
FROM circular_dependencies
ORDER BY cycle_length ASC, cycle_root
LIMIT 20;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

- ã€Šç®—æ³•å¯¼è®ºã€‹ï¼ˆIntroduction to Algorithmsï¼‰- è¿é€šæ€§ç®—æ³•ç†è®º
- ã€Šå›¾è®ºã€‹ï¼ˆGraph Theoryï¼‰- å›¾è®ºåŸºç¡€

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- [é€’å½’æŸ¥è¯¢](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE)
- [ç´¢å¼•ä¼˜åŒ–](https://www.postgresql.org/docs/current/indexes.html)

### åœ¨çº¿èµ„æº

- PostgreSQLè¿é€šæ€§åˆ†ææŒ‡å—
- å›¾ç®—æ³•å®ç°å‚è€ƒ
- è¿é€šæ€§åˆ†ææœ€ä½³å®è·µ

### ç›¸å…³ç®—æ³•

- [å›¾éå†ç®—æ³•](./å›¾éå†ç®—æ³•.md) - å›¾éå†
- [æœ€çŸ­è·¯å¾„ç®—æ³•](./æœ€çŸ­è·¯å¾„ç®—æ³•.md) - æœ€çŸ­è·¯å¾„æŸ¥æ‰¾
- [å›¾èšç±»ç®—æ³•](./å›¾èšç±»ç®—æ³•.md) - å›¾èšç±»

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
