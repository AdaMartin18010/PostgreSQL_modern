# PostgreSQL 连通性分析完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 连通性分析 | 强连通分量
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 连通性分析完整指南](#postgresql-连通性分析完整指南)
  - [📋 目录](#-目录)
  - [连通性分析概述](#连通性分析概述)
    - [理论基础](#理论基础)
      - [连通性问题定义](#连通性问题定义)
      - [连通性类型](#连通性类型)
      - [连通性算法分类](#连通性算法分类)
    - [核心连通性概念](#核心连通性概念)
  - [1. 连通分量检测](#1-连通分量检测)
    - [1.1 连通分量检测原理](#11-连通分量检测原理)
      - [连通分量定义](#连通分量定义)
      - [检测方法](#检测方法)
    - [1.2 无向图连通分量实现](#12-无向图连通分量实现)
    - [1.3 连通分量统计](#13-连通分量统计)
  - [2. 强连通分量](#2-强连通分量)
    - [2.1 强连通分量原理](#21-强连通分量原理)
      - [强连通分量定义](#强连通分量定义)
      - [Kosaraju算法](#kosaraju算法)
    - [2.2 有向图强连通分量实现](#22-有向图强连通分量实现)
    - [2.3 强连通分量应用](#23-强连通分量应用)
  - [3. 弱连通分量](#3-弱连通分量)
    - [3.1 弱连通分量原理](#31-弱连通分量原理)
      - [弱连通分量定义](#弱连通分量定义)
    - [3.2 有向图弱连通分量实现](#32-有向图弱连通分量实现)
    - [3.3 弱连通分量应用](#33-弱连通分量应用)
  - [4. 连通性优化策略](#4-连通性优化策略)
    - [4.1 索引优化](#41-索引优化)
    - [4.2 算法优化](#42-算法优化)
    - [4.3 性能优化](#43-性能优化)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 社交网络连通性分析](#51-社交网络连通性分析)
    - [5.2 网络拓扑分析](#52-网络拓扑分析)
    - [5.3 依赖关系分析](#53-依赖关系分析)
    - [5.4 孤立节点检测](#54-孤立节点检测)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 连通性算法对比](#61-连通性算法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 算法选择](#71-算法选择)
    - [7.2 数据结构设计](#72-数据结构设计)
    - [7.3 性能优化](#73-性能优化)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 连通性分析概述

**连通性分析（Connectivity Analysis）**用于分析图中节点的连通性，识别连通分量和孤立节点，是图分析的基础操作。

### 理论基础

#### 连通性问题定义

**连通性问题**：给定图$G = (V, E)$，识别所有连通分量：
$$C = \{C_1, C_2, \ldots, C_k\} \text{ such that } \bigcup_{i=1}^{k} C_i = V$$

其中每个连通分量$C_i$是一个最大连通子图。

#### 连通性类型

**连通性类型**：

1. **无向图连通分量**：节点之间相互可达
2. **有向图强连通分量**：节点之间双向可达
3. **有向图弱连通分量**：忽略方向后连通

#### 连通性算法分类

连通性算法分类：

1. **DFS/BFS遍历**：
   - 使用DFS或BFS遍历识别连通分量
   - 时间复杂度：$O(V + E)$

2. **并查集（Union-Find）**：
   - 使用并查集数据结构
   - 时间复杂度：$O(E \times \alpha(V))$（$\alpha$是反阿克曼函数）

3. **Kosaraju算法**：
   - 用于强连通分量检测
   - 时间复杂度：$O(V + E)$

### 核心连通性概念

| 概念 | 数学定义 | 定义 | 用途 | 时间复杂度 |
|------|---------|------|------|-----------|
| **连通分量** | $C = \{v \mid \exists \text{ path from } u \text{ to } v\}$ | 相互可达的节点集合 | 识别子图 | $O(V + E)$ |
| **强连通** | $u \leftrightarrow v$（双向可达） | 双向可达 | 有向图分析 | $O(V + E)$ |
| **弱连通** | $u \sim v$（忽略方向可达） | 忽略方向可达 | 有向图分析 | $O(V + E)$ |

---

## 1. 连通分量检测

### 1.1 连通分量检测原理

**连通分量检测（Connected Component Detection）**是识别图中所有连通分量的算法。

#### 连通分量定义

**连通分量**：连通分量$C$是图$G$的一个最大连通子图，满足：

- 对于任意$u, v \in C$，存在路径从$u$到$v$
- 不存在更大的连通子图包含$C$

#### 检测方法

**检测方法**：

1. **DFS遍历**：从每个未访问节点开始DFS
2. **BFS遍历**：从每个未访问节点开始BFS
3. **并查集**：使用并查集合并连通节点

### 1.2 无向图连通分量实现

**无向图连通分量**的实现和使用。

```sql
-- 连通分量检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行连通分量检测';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行连通分量检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行连通分量检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '连通分量检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM connected_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

### 1.3 连通分量统计

**连通分量统计**：统计连通分量的数量和大小。

```sql
-- 连通分量统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行连通分量统计';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行连通分量统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行连通分量统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '连通分量统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 连通分量统计：统计每个连通分量的大小和特征
WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
),
component_stats AS (
    SELECT
        component_id,
        COUNT(DISTINCT node_id) AS component_size,
        array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
    FROM connected_components
    GROUP BY component_id
)
SELECT
    component_id,
    component_size,
    CASE
        WHEN component_size = 1 THEN 'Isolated'
        WHEN component_size < 5 THEN 'Small'
        WHEN component_size < 20 THEN 'Medium'
        ELSE 'Large'
    END AS component_type,
    nodes
FROM component_stats
ORDER BY component_size DESC;
```

---

## 2. 强连通分量

### 2.1 强连通分量原理

**强连通分量（Strongly Connected Component, SCC）**是有向图中的最大强连通子图。

#### 强连通分量定义

**强连通分量**：有向图$G$中的强连通分量$C$满足：

- 对于任意$u, v \in C$，存在路径从$u$到$v$，也存在路径从$v$到$u$
- 不存在更大的强连通子图包含$C$

#### Kosaraju算法

**Kosaraju算法**：

1. 对图$G$进行DFS，记录完成时间
2. 构建转置图$G^T$
3. 按完成时间降序对$G^T$进行DFS

### 2.2 有向图强连通分量实现

**有向图强连通分量**的实现和使用。

```sql
-- 强连通分量检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行强连通分量检测';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行强连通分量检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行强连通分量检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '强连通分量检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE forward_reachable AS (
    SELECT
        id AS node_id,
        id AS root_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        fr.root_id
    FROM forward_reachable fr
    JOIN edges e ON fr.node_id = e.source_id
),
backward_reachable AS (
    SELECT
        id AS node_id,
        id AS root_id
    FROM nodes
    UNION
    SELECT
        e.source_id,
        br.root_id
    FROM backward_reachable br
    JOIN edges e ON br.node_id = e.target_id
)
SELECT
    fr.root_id AS component_id,
    COUNT(DISTINCT fr.node_id) AS component_size
FROM forward_reachable fr
JOIN backward_reachable br ON fr.node_id = br.node_id AND fr.root_id = br.root_id
GROUP BY fr.root_id
ORDER BY component_size DESC;
```

---

### 2.3 强连通分量应用

**强连通分量应用**：分析有向图中的强连通结构。

```sql
-- 强连通分量应用：分析有向图的强连通结构（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_graph') THEN
            RAISE WARNING '表 directed_graph 不存在，无法执行强连通分量应用';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行强连通分量应用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '强连通分量应用准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 强连通分量应用：识别有向图中的循环依赖
WITH RECURSIVE forward_reachable AS (
    SELECT
        node_id,
        node_id AS root_id
    FROM graph_nodes
    UNION
    SELECT
        dg.target_id,
        fr.root_id
    FROM forward_reachable fr
    JOIN directed_graph dg ON fr.node_id = dg.source_id
),
backward_reachable AS (
    SELECT
        node_id,
        node_id AS root_id
    FROM graph_nodes
    UNION
    SELECT
        dg.source_id,
        br.root_id
    FROM backward_reachable br
    JOIN directed_graph dg ON br.node_id = dg.target_id
),
strongly_connected AS (
    SELECT DISTINCT
        fr.root_id AS scc_id,
        fr.node_id
    FROM forward_reachable fr
    JOIN backward_reachable br ON fr.node_id = br.node_id AND fr.root_id = br.root_id
)
SELECT
    scc_id,
    COUNT(DISTINCT node_id) AS scc_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members
FROM strongly_connected
GROUP BY scc_id
HAVING COUNT(DISTINCT node_id) > 1  -- 只显示非单节点的强连通分量
ORDER BY scc_size DESC;
```

---

## 3. 弱连通分量

### 3.1 弱连通分量原理

**弱连通分量（Weakly Connected Component）**是有向图中忽略方向后的连通分量。

#### 弱连通分量定义

**弱连通分量**：有向图$G$的弱连通分量是将$G$转换为无向图后的连通分量。

**检测方法**：将有向图转换为无向图，然后使用无向图连通分量检测算法。

### 3.2 有向图弱连通分量实现

**有向图弱连通分量**的实现和使用。

```sql
-- 弱连通分量检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行弱连通分量检测';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行弱连通分量检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行弱连通分量检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '弱连通分量检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE weak_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        wc.component_id
    FROM weak_components wc
    JOIN edges e ON wc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        wc.component_id
    FROM weak_components wc
    JOIN edges e ON wc.node_id = e.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM weak_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

### 3.3 弱连通分量应用

**弱连通分量应用**：分析有向图的弱连通结构。

```sql
-- 弱连通分量应用：分析有向图的弱连通结构（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_graph') THEN
            RAISE WARNING '表 directed_graph 不存在，无法执行弱连通分量应用';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行弱连通分量应用';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '弱连通分量应用准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 弱连通分量应用：将有向图转换为无向图后检测连通分量
WITH RECURSIVE weak_components AS (
    SELECT
        node_id,
        node_id AS component_id
    FROM graph_nodes
    UNION
    -- 忽略方向：同时考虑正向和反向边
    SELECT
        dg.target_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_graph dg ON wc.node_id = dg.source_id
    UNION
    SELECT
        dg.source_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_graph dg ON wc.node_id = dg.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members
FROM weak_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

## 4. 连通性优化策略

### 4.1 索引优化

**索引优化**：为连通性查询创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 边表索引：加速邻接节点查找
        CREATE INDEX IF NOT EXISTS idx_edges_source_target
        ON edges(source_id, target_id);

        CREATE INDEX IF NOT EXISTS idx_edges_target_source
        ON edges(target_id, source_id);

        RAISE NOTICE '连通性分析索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 算法优化

**算法优化**：优化连通性检测算法。

```sql
-- 算法优化：使用物化视图缓存连通分量结果
CREATE MATERIALIZED VIEW IF NOT EXISTS connected_components_cache AS
WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
)
SELECT DISTINCT ON (node_id)
    node_id,
    component_id
FROM connected_components
ORDER BY node_id, component_id;

CREATE INDEX IF NOT EXISTS idx_connected_components_cache_node_component
ON connected_components_cache(node_id, component_id);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY connected_components_cache;
```

### 4.3 性能优化

**性能优化**：使用并行查询和批量处理。

```sql
-- 性能优化（带错误处理）
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        SET work_mem = '512MB';
        RAISE NOTICE '性能优化配置已设置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. PostgreSQL 18 并行连通性分析增强

**PostgreSQL 18** 显著增强了并行连通性分析能力，支持并行执行连通分量检测、强连通分量检测和弱连通分量检测，大幅提升大规模图连通性分析的性能。

### 5.1 并行连通性分析原理

PostgreSQL 18 的并行连通性分析通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描图数据
2. **并行遍历**：每个工作进程独立执行图遍历
3. **并行分量识别**：并行识别连通分量
4. **结果合并**：主进程合并所有工作进程的分析结果

### 5.2 并行连通分量检测

```sql
-- PostgreSQL 18 并行连通分量检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行并行连通分量检测';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行并行连通分量检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行连通分量检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行连通分量检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行无向图连通分量检测
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE connected_components AS (
    SELECT
        id AS node_id,
        id AS component_id
    FROM nodes
    UNION
    SELECT
        e.target_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.source_id
    UNION
    SELECT
        e.source_id,
        cc.component_id
    FROM connected_components cc
    JOIN edges e ON cc.node_id = e.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM connected_components
GROUP BY component_id
ORDER BY component_size DESC;
```

### 5.3 并行强连通分量检测

```sql
-- PostgreSQL 18 并行强连通分量检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_edges') THEN
            RAISE WARNING '表 directed_edges 不存在，无法执行并行强连通分量检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行强连通分量检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行强连通分量检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行强连通分量检测：Kosaraju算法
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE dfs_forward AS (
    SELECT
        source_id AS start_node,
        source_id AS current_node,
        ARRAY[source_id] AS visited
    UNION ALL
    SELECT
        df.start_node,
        de.target_id,
        df.visited || de.target_id
    FROM dfs_forward df
    JOIN directed_edges de ON df.current_node = de.source_id
    WHERE de.target_id != ALL(df.visited)
),
dfs_backward AS (
    SELECT
        source_id AS start_node,
        source_id AS current_node,
        ARRAY[source_id] AS visited
    FROM dfs_forward
    WHERE current_node IN (SELECT MAX(current_node) FROM dfs_forward GROUP BY start_node)
    UNION ALL
    SELECT
        db.start_node,
        de.source_id,
        db.visited || de.source_id
    FROM dfs_backward db
    JOIN directed_edges de ON db.current_node = de.target_id
    WHERE de.source_id != ALL(db.visited)
)
SELECT
    start_node AS component_id,
    COUNT(DISTINCT current_node) AS component_size,
    array_agg(DISTINCT current_node ORDER BY current_node) AS nodes
FROM dfs_backward
GROUP BY start_node
ORDER BY component_size DESC;
```

### 5.4 并行弱连通分量检测

```sql
-- PostgreSQL 18 并行弱连通分量检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'directed_edges') THEN
            RAISE WARNING '表 directed_edges 不存在，无法执行并行弱连通分量检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行弱连通分量检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行弱连通分量检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行弱连通分量检测：忽略方向
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE weak_components AS (
    SELECT
        source_id AS node_id,
        source_id AS component_id
    FROM directed_edges
    UNION
    SELECT
        target_id,
        source_id AS component_id
    FROM directed_edges
    UNION
    SELECT
        de.target_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_edges de ON wc.node_id = de.source_id
    UNION
    SELECT
        de.source_id,
        wc.component_id
    FROM weak_components wc
    JOIN directed_edges de ON wc.node_id = de.target_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS component_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS nodes
FROM weak_components
GROUP BY component_id
ORDER BY component_size DESC;
```

---

## 6. 实际应用案例

### 5.1 社交网络连通性分析

**社交网络连通性分析**分析社交网络的连通性。

```sql
-- 社交网络连通性分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users') THEN
            RAISE WARNING '表 users 不存在，无法执行社交网络连通性分析';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'friendships') THEN
            RAISE WARNING '表 friendships 不存在，无法执行社交网络连通性分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行社交网络连通性分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '社交网络连通性分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 社交网络连通性分析：识别用户社区
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE social_components AS (
    SELECT
        user_id AS node_id,
        user_id AS component_id
    FROM users
    UNION
    SELECT
        f.friend_id,
        sc.component_id
    FROM social_components sc
    JOIN friendships f ON sc.node_id = f.user_id
    UNION
    SELECT
        f.user_id,
        sc.component_id
    FROM social_components sc
    JOIN friendships f ON sc.node_id = f.friend_id
)
SELECT
    component_id,
    COUNT(DISTINCT node_id) AS community_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS members,
    CASE
        WHEN COUNT(DISTINCT node_id) = 1 THEN 'Isolated User'
        WHEN COUNT(DISTINCT node_id) < 10 THEN 'Small Community'
        WHEN COUNT(DISTINCT node_id) < 100 THEN 'Medium Community'
        ELSE 'Large Community'
    END AS community_type
FROM social_components
GROUP BY component_id
ORDER BY community_size DESC;
```

### 5.2 网络拓扑分析

**网络拓扑分析**：分析网络设备的连通性。

```sql
-- 网络拓扑分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'network_devices') THEN
            RAISE WARNING '表 network_devices 不存在，无法执行网络拓扑分析';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'network_links') THEN
            RAISE WARNING '表 network_links 不存在，无法执行网络拓扑分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行网络拓扑分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '网络拓扑分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 网络拓扑分析：识别网络中的连通子网
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE network_components AS (
    SELECT
        device_id AS node_id,
        device_id AS component_id
    FROM network_devices
    UNION
    SELECT
        nl.device2_id,
        nc.component_id
    FROM network_components nc
    JOIN network_links nl ON nc.node_id = nl.device1_id
    UNION
    SELECT
        nl.device1_id,
        nc.component_id
    FROM network_components nc
    JOIN network_links nl ON nc.node_id = nl.device2_id
)
SELECT
    component_id AS subnet_id,
    COUNT(DISTINCT node_id) AS subnet_size,
    array_agg(DISTINCT node_id ORDER BY node_id) AS devices,
    CASE
        WHEN COUNT(DISTINCT node_id) = 1 THEN 'Isolated Device'
        ELSE 'Connected Subnet'
    END AS subnet_type
FROM network_components
GROUP BY component_id
ORDER BY subnet_size DESC;
```

### 5.3 依赖关系分析

**依赖关系分析**：分析任务或模块之间的依赖关系。

```sql
-- 依赖关系分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'task_dependencies') THEN
            RAISE WARNING '表 task_dependencies 不存在，无法执行依赖关系分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行依赖关系分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '依赖关系分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 依赖关系分析：识别强连通分量（循环依赖）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE forward_deps AS (
    SELECT
        task_id,
        task_id AS root_id
    FROM tasks
    UNION
    SELECT
        td.depends_on_task_id,
        fd.root_id
    FROM forward_deps fd
    JOIN task_dependencies td ON fd.task_id = td.task_id
),
backward_deps AS (
    SELECT
        task_id,
        task_id AS root_id
    FROM tasks
    UNION
    SELECT
        td.task_id,
        bd.root_id
    FROM backward_deps bd
    JOIN task_dependencies td ON bd.task_id = td.depends_on_task_id
),
circular_dependencies AS (
    SELECT DISTINCT
        fd.root_id AS scc_id,
        fd.task_id
    FROM forward_deps fd
    JOIN backward_deps bd ON fd.task_id = bd.task_id AND fd.root_id = bd.root_id
)
SELECT
    scc_id,
    COUNT(DISTINCT task_id) AS cycle_size,
    array_agg(DISTINCT task_id ORDER BY task_id) AS tasks_in_cycle
FROM circular_dependencies
GROUP BY scc_id
HAVING COUNT(DISTINCT task_id) > 1  -- 只显示循环依赖
ORDER BY cycle_size DESC;
```

### 5.4 孤立节点检测

**孤立节点检测**：检测图中的孤立节点。

```sql
-- 孤立节点检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行孤立节点检测';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行孤立节点检测';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行孤立节点检测';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '孤立节点检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 孤立节点检测：识别没有连接的节点
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH connected_nodes AS (
    SELECT DISTINCT source_id AS node_id FROM edges
    UNION
    SELECT DISTINCT target_id FROM edges
)
SELECT
    n.id AS isolated_node_id,
    n.name,
    n.properties
FROM nodes n
LEFT JOIN connected_nodes cn ON n.id = cn.node_id
WHERE cn.node_id IS NULL
ORDER BY n.id;
```

---

## 7. 算法性能对比与优化

### 6.1 连通性算法对比

| 算法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **DFS/BFS遍历** | 使用遍历识别连通分量 | $O(V + E)$ | $O(V)$ | 通用 | 简单、高效 | 需要多次遍历 |
| **并查集** | Union-Find数据结构 | $O(E \times \alpha(V))$ | $O(V)$ | 动态图 | 高效 | 实现复杂 |
| **Kosaraju** | 强连通分量检测 | $O(V + E)$ | $O(V)$ | 有向图 | 精确 | 需要两次DFS |

### 6.2 性能优化建议

1. **索引优化**：
   - 为边表创建索引
   - 为节点表创建索引

2. **算法优化**：
   - 使用并查集（如果支持）
   - 使用物化视图缓存结果

3. **查询优化**：
   - 限制搜索范围
   - 使用并行查询

### 6.3 常见问题与解决方案

**问题1**：连通性检测性能慢

- **解决方案**：创建索引、使用物化视图、并行查询

**问题2**：强连通分量检测复杂

- **解决方案**：使用Kosaraju算法、优化实现

**问题3**：大规模图内存不足

- **解决方案**：分批处理、使用流式处理、优化数据结构

**问题4**：孤立节点识别困难

- **解决方案**：使用LEFT JOIN、单独查询

---

## 8. 最佳实践

### 7.1 算法选择

1. **无向图连通分量**：使用DFS/BFS
2. **有向图强连通分量**：使用Kosaraju算法
3. **有向图弱连通分量**：转换为无向图后使用DFS/BFS

### 7.2 数据结构设计

1. **节点表**：包含节点ID和属性
2. **边表**：包含源节点和目标节点
3. **索引**：为常用查询创建索引

### 7.3 性能优化

1. **索引优化**：为边表创建索引
2. **结果缓存**：使用物化视图缓存结果
3. **并行查询**：启用并行查询处理大规模数据

### 7.4 SQL实现注意事项

1. **递归深度**：注意PostgreSQL的递归深度限制
2. **性能考虑**：避免在大图上使用复杂算法
3. **循环检测**：使用路径数组检测循环
4. **错误处理**：处理NULL值和边界情况

---

## 📚 参考资源

### 学术文献

- 《算法导论》（Introduction to Algorithms）- 连通性算法理论
- 《图论》（Graph Theory）- 图论基础

### PostgreSQL官方文档

- [递归查询](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE)
- [索引优化](https://www.postgresql.org/docs/current/indexes.html)

### 在线资源

- PostgreSQL连通性分析指南
- 图算法实现参考
- 连通性分析最佳实践

### 相关算法

- [图遍历算法](./图遍历算法.md) - 图遍历
- [最短路径算法](./最短路径算法.md) - 最短路径查找
- [图聚类算法](./图聚类算法.md) - 图聚类

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
