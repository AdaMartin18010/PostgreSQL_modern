# PostgreSQL 图遍历算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 图遍历 | 递归CTE
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 图遍历算法完整指南](#postgresql-图遍历算法完整指南)
  - [📋 目录](#-目录)
  - [图遍历算法概述](#图遍历算法概述)
    - [理论基础](#理论基础)
      - [图遍历问题定义](#图遍历问题定义)
      - [遍历算法分类](#遍历算法分类)
      - [遍历策略选择](#遍历策略选择)
    - [核心遍历算法](#核心遍历算法)
  - [1. 深度优先搜索](#1-深度优先搜索)
    - [1.1 深度优先搜索原理](#11-深度优先搜索原理)
      - [DFS定义](#dfs定义)
      - [DFS算法](#dfs算法)
    - [1.2 递归DFS实现](#12-递归dfs实现)
    - [1.3 迭代DFS实现](#13-迭代dfs实现)
    - [1.4 DFS应用场景](#14-dfs应用场景)
  - [2. 广度优先搜索](#2-广度优先搜索)
    - [2.1 广度优先搜索原理](#21-广度优先搜索原理)
      - [BFS定义](#bfs定义)
      - [BFS算法](#bfs算法)
    - [2.2 递归BFS实现](#22-递归bfs实现)
    - [2.3 迭代BFS实现](#23-迭代bfs实现)
    - [2.4 BFS应用场景](#24-bfs应用场景)
  - [3. 路径查找](#3-路径查找)
    - [3.1 路径查找原理](#31-路径查找原理)
      - [路径定义](#路径定义)
      - [路径查找方法](#路径查找方法)
    - [3.2 查找所有路径实现](#32-查找所有路径实现)
    - [3.3 查找最短路径](#33-查找最短路径)
  - [4. 图遍历优化策略](#4-图遍历优化策略)
    - [4.1 索引优化](#41-索引优化)
    - [4.2 深度限制优化](#42-深度限制优化)
    - [4.3 循环检测优化](#43-循环检测优化)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 组织架构遍历](#51-组织架构遍历)
    - [5.2 社交网络分析](#52-社交网络分析)
    - [5.3 依赖关系分析](#53-依赖关系分析)
    - [5.4 知识图谱遍历](#54-知识图谱遍历)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 遍历算法对比](#61-遍历算法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 算法选择](#71-算法选择)
    - [7.2 数据结构设计](#72-数据结构设计)
    - [7.3 性能优化](#73-性能优化)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 图遍历算法概述

**图遍历算法（Graph Traversal Algorithm）**用于遍历图中的所有节点，是图算法的基础。PostgreSQL可以使用递归CTE实现图遍历算法。

### 理论基础

#### 图遍历问题定义

**图遍历问题**：给定图$G = (V, E)$，其中$V$是节点集合，$E$是边集合，遍历所有节点：
$$T = \{v_1, v_2, \ldots, v_n\} \text{ such that } \forall v_i \in V, v_i \in T$$

**遍历目标**：

1. **访问所有节点**：确保每个节点都被访问
2. **避免重复访问**：每个节点只访问一次
3. **路径记录**：记录遍历路径

#### 遍历算法分类

图遍历算法分类：

1. **深度优先搜索（DFS）**：
   - 优先访问深层节点
   - 使用栈（递归）实现
   - 时间复杂度：$O(V + E)$
   - 空间复杂度：$O(V)$（递归栈）

2. **广度优先搜索（BFS）**：
   - 优先访问浅层节点
   - 使用队列实现
   - 时间复杂度：$O(V + E)$
   - 空间复杂度：$O(V)$（队列）

3. **路径查找**：
   - 查找两个节点之间的路径
   - 可以使用DFS或BFS
   - 时间复杂度：$O(V + E)$

#### 遍历策略选择

选择遍历策略的考虑因素：

1. **目标节点位置**：浅层用BFS，深层用DFS
2. **路径需求**：需要最短路径用BFS
3. **内存限制**：内存受限用DFS（递归深度限制）

### 核心遍历算法

| 算法 | 数学定义 | 用途 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **DFS** | 深度优先遍历 | 深度优先搜索 | $O(V + E)$ | $O(V)$ | 拓扑排序、连通性检测 |
| **BFS** | 广度优先遍历 | 广度优先搜索 | $O(V + E)$ | $O(V)$ | 最短路径、层级遍历 |
| **路径查找** | $P = \{v_1, v_2, \ldots, v_k\} \mid (v_i, v_{i+1}) \in E$ | 查找路径 | $O(V + E)$ | $O(V)$ | 路径规划、可达性分析 |

---

## 1. 深度优先搜索

### 1.1 深度优先搜索原理

**深度优先搜索（Depth-First Search, DFS）**是一种图遍历算法，优先访问深层节点。

#### DFS定义

**DFS**：从起始节点开始，尽可能深地访问节点，直到无法继续，然后回溯。

**DFS算法**：

1. 访问起始节点
2. 标记节点为已访问
3. 递归访问未访问的相邻节点
4. 回溯到上一个节点

#### DFS算法

**DFS伪代码**：

```
DFS(G, v):
    visited[v] = true
    for each neighbor u of v:
        if not visited[u]:
            DFS(G, u)
```

### 1.2 递归DFS实现

**递归DFS**的实现和使用。

```sql
-- 深度优先搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行深度优先搜索';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行深度优先搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行深度优先搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '深度优先搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE dfs AS (
    -- 起始节点
    SELECT
        id,
        ARRAY[id] AS path,
        0 AS depth
    FROM nodes
    WHERE id = 1  -- 起始节点ID

    UNION ALL

    -- 递归：访问相邻节点
    SELECT
        e.target_id,
        d.path || e.target_id,
        d.depth + 1
    FROM dfs d
    JOIN edges e ON d.id = e.source_id
    WHERE e.target_id != ALL(d.path)  -- 避免循环
      AND d.depth < 10  -- 最大深度限制
)
SELECT * FROM dfs ORDER BY depth, id;
```

---

### 1.3 迭代DFS实现

**迭代DFS**：使用显式栈实现DFS（PostgreSQL中通过递归CTE模拟）。

```sql
-- 迭代DFS（使用递归CTE模拟栈，带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行迭代DFS';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行迭代DFS';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行迭代DFS';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '迭代DFS准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 迭代DFS：使用递归CTE模拟栈
WITH RECURSIVE dfs_stack AS (
    SELECT
        id AS current_node,
        ARRAY[id] AS visited,
        ARRAY[id] AS path,
        0 AS depth
    FROM nodes
    WHERE id = 1
    UNION ALL
    SELECT
        e.target_id,
        ds.visited || e.target_id,
        ds.path || e.target_id,
        ds.depth + 1
    FROM dfs_stack ds
    JOIN edges e ON ds.current_node = e.source_id
    WHERE e.target_id != ALL(ds.visited)
      AND ds.depth < 10
)
SELECT DISTINCT ON (current_node)
    current_node,
    path,
    depth
FROM dfs_stack
ORDER BY current_node, depth;
```

### 1.4 DFS应用场景

**DFS应用场景**：

- 拓扑排序
- 连通性检测
- 环检测
- 路径查找

---

## 2. 广度优先搜索

### 2.1 广度优先搜索原理

**广度优先搜索（Breadth-First Search, BFS）**是一种图遍历算法，优先访问浅层节点。

#### BFS定义

**BFS**：从起始节点开始，逐层访问节点，先访问距离起始节点近的节点。

**BFS算法**：

1. 将起始节点加入队列
2. 从队列中取出节点并访问
3. 将未访问的相邻节点加入队列
4. 重复步骤2-3直到队列为空

#### BFS算法

**BFS伪代码**：

```
BFS(G, v):
    queue = [v]
    visited[v] = true
    while queue is not empty:
        u = queue.dequeue()
        for each neighbor w of u:
            if not visited[w]:
                visited[w] = true
                queue.enqueue(w)
```

### 2.2 递归BFS实现

**递归BFS**的实现和使用。

```sql
-- 广度优先搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行广度优先搜索';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行广度优先搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行广度优先搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '广度优先搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE bfs AS (
    SELECT
        id,
        ARRAY[id] AS path,
        0 AS level
    FROM nodes
    WHERE id = 1

    UNION ALL

    SELECT
        e.target_id,
        b.path || e.target_id,
        b.level + 1
    FROM bfs b
    JOIN edges e ON b.id = e.source_id
    WHERE e.target_id != ALL(b.path)
      AND b.level < 10
)
SELECT
    id,
    path,
    level
FROM bfs
WHERE level = (
    SELECT MIN(level)
    FROM bfs
    WHERE id = bfs.id
)
ORDER BY level, id;
```

---

### 2.3 迭代BFS实现

**迭代BFS**：使用递归CTE模拟队列实现BFS。

```sql
-- 迭代BFS（使用递归CTE模拟队列，带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行迭代BFS';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行迭代BFS';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行迭代BFS';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '迭代BFS准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 迭代BFS：按层级访问节点
WITH RECURSIVE bfs_levels AS (
    SELECT
        id AS node_id,
        0 AS level,
        ARRAY[id] AS visited
    FROM nodes
    WHERE id = 1
    UNION ALL
    SELECT
        e.target_id,
        bl.level + 1,
        bl.visited || e.target_id
    FROM bfs_levels bl
    JOIN edges e ON bl.node_id = e.source_id
    WHERE e.target_id != ALL(bl.visited)
      AND bl.level < 10
)
SELECT DISTINCT ON (node_id)
    node_id,
    level
FROM bfs_levels
ORDER BY node_id, level;
```

### 2.4 BFS应用场景

**BFS应用场景**：

- 最短路径查找
- 层级遍历
- 社交网络分析
- 最短距离计算

---

## 3. 路径查找

### 3.1 路径查找原理

**路径查找（Path Finding）**是查找两个节点之间路径的算法。

#### 路径定义

**路径**：路径$P = \{v_1, v_2, \ldots, v_k\}$满足：

- $v_1 = s$（起始节点）
- $v_k = t$（目标节点）
- $(v_i, v_{i+1}) \in E$（相邻节点之间有边）

#### 路径查找方法

**路径查找方法**：

1. **DFS路径查找**：使用DFS查找路径
2. **BFS路径查找**：使用BFS查找最短路径
3. **所有路径查找**：查找所有可能的路径

### 3.2 查找所有路径实现

**查找所有路径**的实现和使用。

```sql
-- 路径查找（带错误处理和性能测试）
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法执行路径查找';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法执行路径查找';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行路径查找，从节点 % 到节点 %', start_node_id, end_node_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '路径查找准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH RECURSIVE paths AS (
    SELECT
        start_node_id AS current_node,
        ARRAY[start_node_id] AS path,
        0 AS depth
    UNION ALL
    SELECT
        e.target_id,
        p.path || e.target_id,
        p.depth + 1
    FROM paths p
    JOIN edges e ON p.current_node = e.source_id
    WHERE e.target_id != ALL(p.path)
      AND p.depth < 20
      AND e.target_id != end_node_id OR p.depth = 0
)
SELECT
    path,
    depth AS path_length
FROM paths
WHERE path[array_length(path, 1)] = end_node_id
ORDER BY path_length, path;
```

---

### 3.3 查找最短路径

**查找最短路径**：使用BFS查找最短路径。

```sql
-- 查找最短路径（带错误处理和性能测试）
DO $$
DECLARE
    start_node_id INTEGER := 1;
    end_node_id INTEGER := 10;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'nodes') THEN
            RAISE WARNING '表 nodes 不存在，无法查找最短路径';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'edges') THEN
            RAISE WARNING '表 edges 不存在，无法查找最短路径';
            RETURN;
        END IF;
        RAISE NOTICE '开始查找最短路径，从节点 % 到节点 %', start_node_id, end_node_id;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '最短路径查找准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 最短路径查找：使用BFS
WITH RECURSIVE shortest_paths AS (
    SELECT
        start_node_id AS current_node,
        ARRAY[start_node_id] AS path,
        0 AS path_length
    UNION ALL
    SELECT
        e.target_id,
        sp.path || e.target_id,
        sp.path_length + 1
    FROM shortest_paths sp
    JOIN edges e ON sp.current_node = e.source_id
    WHERE e.target_id != ALL(sp.path)
      AND sp.path_length < 20
)
SELECT DISTINCT ON (current_node)
    current_node,
    path,
    path_length
FROM shortest_paths
WHERE current_node = end_node_id
ORDER BY current_node, path_length;
```

---

## 4. 图遍历优化策略

### 4.1 索引优化

**索引优化**：为图遍历创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 边表索引：加速邻接节点查找
        CREATE INDEX IF NOT EXISTS idx_edges_source_target
        ON edges(source_id, target_id);

        CREATE INDEX IF NOT EXISTS idx_edges_target_source
        ON edges(target_id, source_id);

        -- 节点表索引
        CREATE INDEX IF NOT EXISTS idx_nodes_id
        ON nodes(id);

        RAISE NOTICE '图遍历索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.2 深度限制优化

**深度限制优化**：限制递归深度避免无限循环。

```sql
-- 深度限制优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 设置递归深度限制
        SET max_stack_depth = 100;
        RAISE NOTICE '递归深度限制已设置为100';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '深度限制设置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.3 循环检测优化

**循环检测优化**：检测和避免循环路径。

```sql
-- 循环检测优化：使用路径数组检测循环
-- 在递归CTE中使用 path 数组检查节点是否已访问
-- WHERE e.target_id != ALL(d.path)  -- 避免循环
```

---

## 5. 实际应用案例

### 5.1 组织架构遍历

**组织架构遍历**遍历组织架构树。

```sql
-- 组织架构遍历（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'organizations') THEN
            RAISE WARNING '表 organizations 不存在，无法执行组织架构遍历';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行组织架构遍历';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '组织架构遍历准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 组织架构遍历：使用DFS遍历树形结构
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE org_tree AS (
    SELECT
        org_id,
        name,
        parent_id,
        1 AS level,
        ARRAY[org_id] AS path,
        name AS full_path
    FROM organizations
    WHERE parent_id IS NULL

    UNION ALL

    SELECT
        o.org_id,
        o.name,
        o.parent_id,
        ot.level + 1,
        ot.path || o.org_id,
        ot.full_path || ' > ' || o.name
    FROM organizations o
    JOIN org_tree ot ON o.parent_id = ot.org_id
)
SELECT
    org_id,
    name,
    parent_id,
    level,
    full_path
FROM org_tree
ORDER BY path;
```

### 5.2 社交网络分析

**社交网络分析**：分析社交网络中的连接关系。

```sql
-- 社交网络分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'social_network') THEN
            RAISE WARNING '表 social_network 不存在，无法执行社交网络分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行社交网络分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '社交网络分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 社交网络分析：查找用户的朋友网络（BFS）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE friend_network AS (
    SELECT
        user_id AS current_user,
        0 AS degree,
        ARRAY[user_id] AS visited
    FROM users
    WHERE user_id = 1
    UNION ALL
    SELECT
        sn.friend_id,
        fn.degree + 1,
        fn.visited || sn.friend_id
    FROM friend_network fn
    JOIN social_network sn ON fn.current_user = sn.user_id
    WHERE sn.friend_id != ALL(fn.visited)
      AND fn.degree < 3  -- 3度好友
)
SELECT DISTINCT ON (current_user)
    current_user,
    degree
FROM friend_network
ORDER BY current_user, degree;
```

### 5.3 依赖关系分析

**依赖关系分析**：分析任务或模块之间的依赖关系。

```sql
-- 依赖关系分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'task_dependencies') THEN
            RAISE WARNING '表 task_dependencies 不存在，无法执行依赖关系分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行依赖关系分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '依赖关系分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 依赖关系分析：查找任务的所有依赖（DFS）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE task_deps AS (
    SELECT
        task_id AS current_task,
        ARRAY[task_id] AS dependency_path,
        0 AS depth
    FROM tasks
    WHERE task_id = 1
    UNION ALL
    SELECT
        td.depends_on_task_id,
        tdp.dependency_path || td.depends_on_task_id,
        tdp.depth + 1
    FROM task_deps tdp
    JOIN task_dependencies td ON tdp.current_task = td.task_id
    WHERE td.depends_on_task_id != ALL(tdp.dependency_path)
      AND tdp.depth < 10
)
SELECT DISTINCT ON (current_task)
    current_task,
    dependency_path,
    depth
FROM task_deps
ORDER BY current_task, depth;
```

### 5.4 知识图谱遍历

**知识图谱遍历**：遍历知识图谱中的实体关系。

```sql
-- 知识图谱遍历（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'knowledge_graph') THEN
            RAISE WARNING '表 knowledge_graph 不存在，无法执行知识图谱遍历';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行知识图谱遍历';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '知识图谱遍历准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 知识图谱遍历：查找实体之间的关系路径
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH RECURSIVE entity_paths AS (
    SELECT
        entity_id AS current_entity,
        ARRAY[entity_id] AS path,
        ARRAY[relation_type] AS relations,
        0 AS depth
    FROM knowledge_graph
    WHERE entity_id = 1
    UNION ALL
    SELECT
        kg.target_entity_id,
        ep.path || kg.target_entity_id,
        ep.relations || kg.relation_type,
        ep.depth + 1
    FROM entity_paths ep
    JOIN knowledge_graph kg ON ep.current_entity = kg.source_entity_id
    WHERE kg.target_entity_id != ALL(ep.path)
      AND ep.depth < 5
)
SELECT DISTINCT ON (current_entity)
    current_entity,
    path,
    relations,
    depth
FROM entity_paths
ORDER BY current_entity, depth;
```

---

## 6. 算法性能对比与优化

### 6.1 遍历算法对比

| 算法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **DFS** | 深度优先遍历 | $O(V + E)$ | $O(V)$ | 拓扑排序、连通性 | 内存效率高 | 可能不是最短路径 |
| **BFS** | 广度优先遍历 | $O(V + E)$ | $O(V)$ | 最短路径、层级遍历 | 找到最短路径 | 内存占用较大 |
| **路径查找** | 查找路径 | $O(V + E)$ | $O(V)$ | 路径规划 | 灵活 | 性能取决于图大小 |

### 6.2 性能优化建议

1. **索引优化**：
   - 为边表创建索引
   - 为节点表创建索引

2. **深度限制**：
   - 设置最大递归深度
   - 避免无限循环

3. **循环检测**：
   - 使用路径数组检测循环
   - 避免重复访问节点

### 6.3 常见问题与解决方案

**问题1**：递归深度过大

- **解决方案**：设置max_stack_depth、限制递归深度

**问题2**：性能慢

- **解决方案**：创建索引、优化查询、限制搜索范围

**问题3**：循环路径

- **解决方案**：使用路径数组检测循环、避免重复访问

**问题4**：内存不足

- **解决方案**：限制深度、分批处理、优化数据结构

---

## 7. 最佳实践

### 7.1 算法选择

1. **最短路径**：使用BFS
2. **拓扑排序**：使用DFS
3. **路径查找**：根据需求选择DFS或BFS

### 7.2 数据结构设计

1. **节点表**：包含节点ID和属性
2. **边表**：包含源节点、目标节点和权重
3. **索引**：为常用查询创建索引

### 7.3 性能优化

1. **索引优化**：为边表创建索引
2. **深度限制**：设置合理的深度限制
3. **循环检测**：使用路径数组检测循环

### 7.4 SQL实现注意事项

1. **递归深度**：注意PostgreSQL的递归深度限制
2. **性能考虑**：避免在大图上使用复杂遍历
3. **循环检测**：始终检测和避免循环
4. **错误处理**：处理NULL值和边界情况

---

## 📚 参考资源

### 学术文献

- 《算法导论》（Introduction to Algorithms）- 图遍历算法理论
- 《图论》（Graph Theory）- 图论基础

### PostgreSQL官方文档

- [递归查询](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE)
- [递归CTE](https://www.postgresql.org/docs/current/tutorial-window.html)

### 在线资源

- PostgreSQL递归查询指南
- 图算法实现参考
- 图遍历最佳实践

### 相关算法

- [最短路径算法](./最短路径算法.md) - 最短路径查找
- [连通性分析](./连通性分析.md) - 连通性检测
- [图聚类算法](./图聚类算法.md) - 图聚类

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
