# PostgreSQL è¶‹åŠ¿åˆ†æå®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | è¶‹åŠ¿åˆ†æ | è¶‹åŠ¿è¯†åˆ«
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL è¶‹åŠ¿åˆ†æå®Œæ•´æŒ‡å—](#postgresql-è¶‹åŠ¿åˆ†æå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [è¶‹åŠ¿åˆ†ææ¦‚è¿°](#è¶‹åŠ¿åˆ†ææ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [è¶‹åŠ¿å®šä¹‰](#è¶‹åŠ¿å®šä¹‰)
      - [è¶‹åŠ¿ç±»å‹](#è¶‹åŠ¿ç±»å‹)
      - [è¶‹åŠ¿æ£€æµ‹æ–¹æ³•](#è¶‹åŠ¿æ£€æµ‹æ–¹æ³•)
    - [æ ¸å¿ƒè¶‹åŠ¿ç±»å‹](#æ ¸å¿ƒè¶‹åŠ¿ç±»å‹)
  - [1. çº¿æ€§è¶‹åŠ¿åˆ†æ](#1-çº¿æ€§è¶‹åŠ¿åˆ†æ)
    - [1.1 çº¿æ€§è¶‹åŠ¿åŸç†](#11-çº¿æ€§è¶‹åŠ¿åŸç†)
      - [çº¿æ€§å›å½’æ¨¡å‹](#çº¿æ€§å›å½’æ¨¡å‹)
      - [æœ€å°äºŒä¹˜ä¼°è®¡](#æœ€å°äºŒä¹˜ä¼°è®¡)
      - [è¶‹åŠ¿åˆ¤æ–­](#è¶‹åŠ¿åˆ¤æ–­)
    - [1.2 è¶‹åŠ¿æ–œç‡è®¡ç®—å®ç°](#12-è¶‹åŠ¿æ–œç‡è®¡ç®—å®ç°)
    - [1.3 è¶‹åŠ¿æ˜¾è‘—æ€§æ£€éªŒ](#13-è¶‹åŠ¿æ˜¾è‘—æ€§æ£€éªŒ)
    - [1.4 è¶‹åŠ¿é¢„æµ‹](#14-è¶‹åŠ¿é¢„æµ‹)
  - [2. éçº¿æ€§è¶‹åŠ¿åˆ†æ](#2-éçº¿æ€§è¶‹åŠ¿åˆ†æ)
    - [2.1 éçº¿æ€§è¶‹åŠ¿åŸç†](#21-éçº¿æ€§è¶‹åŠ¿åŸç†)
      - [å¤šé¡¹å¼è¶‹åŠ¿](#å¤šé¡¹å¼è¶‹åŠ¿)
      - [æŒ‡æ•°è¶‹åŠ¿](#æŒ‡æ•°è¶‹åŠ¿)
      - [å¯¹æ•°è¶‹åŠ¿](#å¯¹æ•°è¶‹åŠ¿)
    - [2.2 å¤šé¡¹å¼è¶‹åŠ¿å®ç°](#22-å¤šé¡¹å¼è¶‹åŠ¿å®ç°)
    - [2.3 ç§»åŠ¨å¹³å‡è¶‹åŠ¿è¯†åˆ«](#23-ç§»åŠ¨å¹³å‡è¶‹åŠ¿è¯†åˆ«)
    - [2.4 åˆ†æ®µè¶‹åŠ¿åˆ†æ](#24-åˆ†æ®µè¶‹åŠ¿åˆ†æ)
  - [3. è¶‹åŠ¿å¼ºåº¦åˆ†æ](#3-è¶‹åŠ¿å¼ºåº¦åˆ†æ)
    - [3.1 è¶‹åŠ¿å¼ºåº¦åŸç†](#31-è¶‹åŠ¿å¼ºåº¦åŸç†)
      - [å†³å®šç³»æ•°ï¼ˆRÂ²ï¼‰](#å†³å®šç³»æ•°r)
      - [è¶‹åŠ¿å¼ºåº¦åˆ¤æ–­](#è¶‹åŠ¿å¼ºåº¦åˆ¤æ–­)
    - [3.2 è¶‹åŠ¿å¼ºåº¦è®¡ç®—å®ç°](#32-è¶‹åŠ¿å¼ºåº¦è®¡ç®—å®ç°)
    - [3.3 Mann-Kendallè¶‹åŠ¿æ£€éªŒ](#33-mann-kendallè¶‹åŠ¿æ£€éªŒ)
  - [4. å®é™…åº”ç”¨æ¡ˆä¾‹](#4-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [4.1 ä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æ](#41-ä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æ)
    - [4.2 é”€å”®è¶‹åŠ¿åˆ†æ](#42-é”€å”®è¶‹åŠ¿åˆ†æ)
    - [4.3 ç”¨æˆ·å¢é•¿è¶‹åŠ¿åˆ†æ](#43-ç”¨æˆ·å¢é•¿è¶‹åŠ¿åˆ†æ)
    - [4.4 ç½‘ç«™æµé‡è¶‹åŠ¿åˆ†æ](#44-ç½‘ç«™æµé‡è¶‹åŠ¿åˆ†æ)
  - [5. PostgreSQL 18å¹¶è¡Œè¶‹åŠ¿åˆ†æ](#5-postgresql-18å¹¶è¡Œè¶‹åŠ¿åˆ†æ)
    - [5.1 å¹¶è¡Œè¶‹åŠ¿åˆ†ææ¦‚è¿°](#51-å¹¶è¡Œè¶‹åŠ¿åˆ†ææ¦‚è¿°)
      - [å¹¶è¡Œè¶‹åŠ¿åˆ†æé…ç½®](#å¹¶è¡Œè¶‹åŠ¿åˆ†æé…ç½®)
      - [å¹¶è¡Œè¶‹åŠ¿åˆ†æå®ç°](#å¹¶è¡Œè¶‹åŠ¿åˆ†æå®ç°)
  - [6. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#6-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [6.1 è¶‹åŠ¿åˆ†ææ–¹æ³•å¯¹æ¯”](#61-è¶‹åŠ¿åˆ†ææ–¹æ³•å¯¹æ¯”)
    - [6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#62-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#63-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 è¶‹åŠ¿åˆ†ææ–¹æ³•é€‰æ‹©](#71-è¶‹åŠ¿åˆ†ææ–¹æ³•é€‰æ‹©)
    - [7.2 è¶‹åŠ¿åˆ†ææ³¨æ„äº‹é¡¹](#72-è¶‹åŠ¿åˆ†ææ³¨æ„äº‹é¡¹)
    - [7.3 SQLå®ç°æ³¨æ„äº‹é¡¹](#73-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [7.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#74-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [7.5 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#75-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## è¶‹åŠ¿åˆ†ææ¦‚è¿°

**è¶‹åŠ¿åˆ†æï¼ˆTrend Analysisï¼‰**è¯†åˆ«æ—¶é—´åºåˆ—æ•°æ®çš„é•¿æœŸè¶‹åŠ¿ï¼Œç”¨äºç†è§£æ•°æ®çš„å˜åŒ–æ–¹å‘ã€é¢„æµ‹æœªæ¥èµ°åŠ¿å’Œåˆ¶å®šå†³ç­–ã€‚è¶‹åŠ¿æ˜¯æ—¶é—´åºåˆ—æ•°æ®ä¸­æœ€é‡è¦çš„ç»„æˆéƒ¨åˆ†ä¹‹ä¸€ï¼Œåæ˜ äº†æ•°æ®çš„é•¿æœŸå˜åŒ–è§„å¾‹ã€‚

### ç†è®ºåŸºç¡€

#### è¶‹åŠ¿å®šä¹‰

**è¶‹åŠ¿ï¼ˆTrendï¼‰**æ˜¯æ—¶é—´åºåˆ—æ•°æ®ä¸­é•¿æœŸçš„ã€ç³»ç»Ÿçš„ã€ééšæœºçš„å˜åŒ–ã€‚åœ¨æ—¶é—´åºåˆ—åˆ†è§£æ¨¡å‹ä¸­ï¼š
$$Y_t = T_t + S_t + C_t + I_t$$

å…¶ä¸­ï¼š

- $T_t$ï¼šè¶‹åŠ¿æˆåˆ†ï¼ˆTrendï¼‰
- $S_t$ï¼šå­£èŠ‚æˆåˆ†ï¼ˆSeasonalï¼‰
- $C_t$ï¼šå¾ªç¯æˆåˆ†ï¼ˆCyclicalï¼‰
- $I_t$ï¼šä¸è§„åˆ™æˆåˆ†ï¼ˆIrregularï¼‰

#### è¶‹åŠ¿ç±»å‹

1. **çº¿æ€§è¶‹åŠ¿**ï¼š$T_t = a + bt$
   - ä¸Šå‡è¶‹åŠ¿ï¼š$b > 0$
   - ä¸‹é™è¶‹åŠ¿ï¼š$b < 0$
   - å¹³ç¨³è¶‹åŠ¿ï¼š$b \approx 0$

2. **éçº¿æ€§è¶‹åŠ¿**ï¼š
   - å¤šé¡¹å¼è¶‹åŠ¿ï¼š$T_t = a + b_1t + b_2t^2 + \cdots$
   - æŒ‡æ•°è¶‹åŠ¿ï¼š$T_t = ae^{bt}$
   - å¯¹æ•°è¶‹åŠ¿ï¼š$T_t = a + b\ln(t)$

3. **åˆ†æ®µè¶‹åŠ¿**ï¼šä¸åŒæ—¶é—´æ®µæœ‰ä¸åŒçš„è¶‹åŠ¿

#### è¶‹åŠ¿æ£€æµ‹æ–¹æ³•

1. **ç»Ÿè®¡æ–¹æ³•**ï¼š
   - çº¿æ€§å›å½’
   - ç§»åŠ¨å¹³å‡
   - Mann-Kendallæ£€éªŒ

2. **å›¾å½¢æ–¹æ³•**ï¼š
   - æ•£ç‚¹å›¾
   - æ—¶é—´åºåˆ—å›¾
   - æ®‹å·®å›¾

3. **æ•°å€¼æ–¹æ³•**ï¼š
   - å·®åˆ†æ³•
   - æ»¤æ³¢æ³•
   - å°æ³¢å˜æ¢

### æ ¸å¿ƒè¶‹åŠ¿ç±»å‹

| è¶‹åŠ¿ç±»å‹ | ç‰¹å¾ | è¯†åˆ«æ–¹æ³• | æ•°å­¦è¡¨ç¤º |
|---------|------|---------|---------|
| **ä¸Šå‡è¶‹åŠ¿** | æŒç»­å¢é•¿ | çº¿æ€§å›å½’æ–œç‡>0 | $b > 0$ |
| **ä¸‹é™è¶‹åŠ¿** | æŒç»­ä¸‹é™ | çº¿æ€§å›å½’æ–œç‡<0 | $b < 0$ |
| **å¹³ç¨³è¶‹åŠ¿** | æ— æ˜æ˜¾å˜åŒ– | çº¿æ€§å›å½’æ–œç‡â‰ˆ0 | $b \approx 0$ |
| **éçº¿æ€§è¶‹åŠ¿** | æ›²çº¿å˜åŒ– | å¤šé¡¹å¼å›å½’ | $T_t = f(t)$ |
| **åˆ†æ®µè¶‹åŠ¿** | å¤šæ®µä¸åŒè¶‹åŠ¿ | åˆ†æ®µå›å½’ | $T_t = f_i(t)$ |

---

## 1. çº¿æ€§è¶‹åŠ¿åˆ†æ

### 1.1 çº¿æ€§è¶‹åŠ¿åŸç†

**çº¿æ€§è¶‹åŠ¿åˆ†æï¼ˆLinear Trend Analysisï¼‰**ä½¿ç”¨çº¿æ€§å›å½’æ¨¡å‹è¯†åˆ«å’Œé‡åŒ–æ—¶é—´åºåˆ—çš„çº¿æ€§è¶‹åŠ¿ã€‚

#### çº¿æ€§å›å½’æ¨¡å‹

**ç®€å•çº¿æ€§å›å½’æ¨¡å‹**ï¼š
$$Y_t = \alpha + \beta t + \epsilon_t$$

å…¶ä¸­ï¼š

- $Y_t$ï¼šæ—¶é—´$t$çš„è§‚æµ‹å€¼
- $\alpha$ï¼šæˆªè·ï¼ˆInterceptï¼‰
- $\beta$ï¼šæ–œç‡ï¼ˆSlopeï¼‰
- $t$ï¼šæ—¶é—´å˜é‡
- $\epsilon_t$ï¼šè¯¯å·®é¡¹

#### æœ€å°äºŒä¹˜ä¼°è®¡

**å‚æ•°ä¼°è®¡**ï¼š
$$\hat{\beta} = \frac{\sum_{i=1}^{n}(t_i - \bar{t})(Y_i - \bar{Y})}{\sum_{i=1}^{n}(t_i - \bar{t})^2}$$

$$\hat{\alpha} = \bar{Y} - \hat{\beta}\bar{t}$$

å…¶ä¸­ï¼š

- $\bar{t} = \frac{1}{n}\sum_{i=1}^{n}t_i$
- $\bar{Y} = \frac{1}{n}\sum_{i=1}^{n}Y_i$

#### è¶‹åŠ¿åˆ¤æ–­

- **ä¸Šå‡è¶‹åŠ¿**ï¼š$\hat{\beta} > 0$ä¸”ç»Ÿè®¡æ˜¾è‘—
- **ä¸‹é™è¶‹åŠ¿**ï¼š$\hat{\beta} < 0$ä¸”ç»Ÿè®¡æ˜¾è‘—
- **å¹³ç¨³è¶‹åŠ¿**ï¼š$\hat{\beta} \approx 0$æˆ–ç»Ÿè®¡ä¸æ˜¾è‘—

### 1.2 è¶‹åŠ¿æ–œç‡è®¡ç®—å®ç°

```sql
-- çº¿æ€§è¶‹åŠ¿åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    slope NUMERIC;
    intercept NUMERIC;
    correlation NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œçº¿æ€§è¶‹åŠ¿åˆ†æ';
            RETURN;
        END IF;

        WITH stats AS (
            SELECT
                COUNT(*) AS n,
                AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
                AVG(value) AS avg_y,
                SUM(EXTRACT(EPOCH FROM date) * value) AS sum_xy,
                SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2,
                SUM(value * value) AS sum_y2
            FROM time_series
            WHERE value IS NOT NULL
        )
        SELECT
            (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope_val,
            avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept_val,
            (sum_xy - n * avg_x * avg_y) / NULLIF(SQRT((sum_x2 - n * avg_x * avg_x) * (sum_y2 - n * avg_y * avg_y)), 0) AS corr_val
        INTO slope, intercept, correlation
        FROM stats;

        RAISE NOTICE 'çº¿æ€§è¶‹åŠ¿åˆ†æç»“æœ:';
        RAISE NOTICE '  æ–œç‡: %', slope;
        RAISE NOTICE '  æˆªè·: %', intercept;
        RAISE NOTICE '  ç›¸å…³ç³»æ•°: %', correlation;
        RAISE NOTICE '  è¶‹åŠ¿æ–¹å‘: %', CASE WHEN slope > 0 THEN 'ä¸Šå‡' WHEN slope < 0 THEN 'ä¸‹é™' ELSE 'å¹³ç¨³' END;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'çº¿æ€§è¶‹åŠ¿åˆ†æå¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¯è§†åŒ–è¶‹åŠ¿
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH regression AS (
    SELECT
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept
    FROM (
        SELECT
            COUNT(*) AS n,
            AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
            AVG(value) AS avg_y,
            SUM(EXTRACT(EPOCH FROM date) * value) AS sum_xy,
            SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2
        FROM time_series
        WHERE value IS NOT NULL
    ) AS stats
)
SELECT
    ts.date,
    ts.value AS actual_value,
    r.slope * EXTRACT(EPOCH FROM ts.date) + r.intercept AS trend_value,
    ts.value - (r.slope * EXTRACT(EPOCH FROM ts.date) + r.intercept) AS residual
FROM time_series ts
CROSS JOIN regression r
WHERE ts.value IS NOT NULL
ORDER BY ts.date;
```

---

### 1.3 è¶‹åŠ¿æ˜¾è‘—æ€§æ£€éªŒ

**æ˜¾è‘—æ€§æ£€éªŒ**æ£€éªŒè¶‹åŠ¿æ˜¯å¦ç»Ÿè®¡æ˜¾è‘—ã€‚

```sql
-- è¶‹åŠ¿æ˜¾è‘—æ€§æ£€éªŒï¼ˆtæ£€éªŒï¼‰
WITH regression AS (
    SELECT
        COUNT(*) AS n,
        AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
        AVG(value) AS avg_y,
        SUM(EXTRACT(EPOCH FROM date) * value) AS sum_xy,
        SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2,
        SUM(value * value) AS sum_y2
    FROM time_series
    WHERE value IS NOT NULL
),
coefficients AS (
    SELECT
        n,
        avg_x,
        avg_y,
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept,
        sum_x2 - n * avg_x * avg_x AS ssx
    FROM regression
),
residuals AS (
    SELECT
        POWER(ts.value - (c.slope * EXTRACT(EPOCH FROM ts.date) + c.intercept), 2) AS residual_sq
    FROM time_series ts
    CROSS JOIN coefficients c
    WHERE ts.value IS NOT NULL
),
stats AS (
    SELECT
        c.slope,
        c.intercept,
        c.ssx,
        SQRT(SUM(r.residual_sq) / NULLIF(c.n - 2, 0)) AS se_residual,
        SUM(r.residual_sq) / NULLIF(c.n - 2, 0) AS mse
    FROM coefficients c
    CROSS JOIN residuals r
    GROUP BY c.slope, c.intercept, c.ssx, c.n
)
SELECT
    slope,
    intercept,
    -- tç»Ÿè®¡é‡
    slope / NULLIF(se_residual / SQRT(ssx), 0) AS t_statistic,
    -- æ˜¾è‘—æ€§åˆ¤æ–­ï¼ˆç®€åŒ–ç‰ˆï¼Œéœ€è¦æŸ¥tåˆ†å¸ƒè¡¨ï¼‰
    CASE
        WHEN ABS(slope / NULLIF(se_residual / SQRT(ssx), 0)) > 2.576 THEN 'é«˜åº¦æ˜¾è‘— (p<0.01)'
        WHEN ABS(slope / NULLIF(se_residual / SQRT(ssx), 0)) > 1.96 THEN 'æ˜¾è‘— (p<0.05)'
        WHEN ABS(slope / NULLIF(se_residual / SQRT(ssx), 0)) > 1.645 THEN 'å¼±æ˜¾è‘— (p<0.10)'
        ELSE 'ä¸æ˜¾è‘—'
    END AS significance
FROM stats;
```

### 1.4 è¶‹åŠ¿é¢„æµ‹

**è¶‹åŠ¿é¢„æµ‹**åŸºäºçº¿æ€§è¶‹åŠ¿é¢„æµ‹æœªæ¥å€¼ã€‚

```sql
-- åŸºäºçº¿æ€§è¶‹åŠ¿çš„é¢„æµ‹
WITH regression AS (
    SELECT
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept
    FROM (
        SELECT
            COUNT(*) AS n,
            AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
            AVG(value) AS avg_y,
            SUM(EXTRACT(EPOCH FROM date) * value) AS sum_xy,
            SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2
        FROM time_series
        WHERE value IS NOT NULL
    ) AS stats
),
future_dates AS (
    SELECT
        generate_series(
            (SELECT MAX(date) FROM time_series) + INTERVAL '1 day',
            (SELECT MAX(date) FROM time_series) + INTERVAL '30 days',
            INTERVAL '1 day'
        )::date AS forecast_date
)
SELECT
    fd.forecast_date,
    r.slope * EXTRACT(EPOCH FROM fd.forecast_date) + r.intercept AS forecast_value,
    -- é¢„æµ‹åŒºé—´ï¼ˆç®€åŒ–ç‰ˆï¼Œéœ€è¦è®¡ç®—æ ‡å‡†è¯¯å·®ï¼‰
    (r.slope * EXTRACT(EPOCH FROM fd.forecast_date) + r.intercept) * 0.9 AS lower_bound,
    (r.slope * EXTRACT(EPOCH FROM fd.forecast_date) + r.intercept) * 1.1 AS upper_bound
FROM future_dates fd
CROSS JOIN regression r
ORDER BY fd.forecast_date;
```

---

## 2. éçº¿æ€§è¶‹åŠ¿åˆ†æ

### 2.1 éçº¿æ€§è¶‹åŠ¿åŸç†

**éçº¿æ€§è¶‹åŠ¿åˆ†æï¼ˆNonlinear Trend Analysisï¼‰**è¯†åˆ«å’Œé‡åŒ–æ—¶é—´åºåˆ—çš„éçº¿æ€§è¶‹åŠ¿æ¨¡å¼ã€‚

#### å¤šé¡¹å¼è¶‹åŠ¿

**å¤šé¡¹å¼å›å½’æ¨¡å‹**ï¼š
$$Y_t = \alpha + \beta_1 t + \beta_2 t^2 + \cdots + \beta_k t^k + \epsilon_t$$

å…¶ä¸­$k$æ˜¯å¤šé¡¹å¼çš„é˜¶æ•°ã€‚

#### æŒ‡æ•°è¶‹åŠ¿

**æŒ‡æ•°è¶‹åŠ¿æ¨¡å‹**ï¼š
$$Y_t = \alpha e^{\beta t + \epsilon_t}$$

å¯¹æ•°å˜æ¢åï¼š
$$\ln(Y_t) = \ln(\alpha) + \beta t + \epsilon_t$$

#### å¯¹æ•°è¶‹åŠ¿

**å¯¹æ•°è¶‹åŠ¿æ¨¡å‹**ï¼š
$$Y_t = \alpha + \beta \ln(t) + \epsilon_t$$

### 2.2 å¤šé¡¹å¼è¶‹åŠ¿å®ç°

```sql
-- éçº¿æ€§è¶‹åŠ¿åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œéçº¿æ€§è¶‹åŠ¿åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œéçº¿æ€§è¶‹åŠ¿åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'éçº¿æ€§è¶‹åŠ¿åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨ç§»åŠ¨å¹³å‡è¯†åˆ«éçº¿æ€§è¶‹åŠ¿
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS trend_30,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 89 PRECEDING AND CURRENT ROW
    ) AS trend_90
FROM time_series
ORDER BY date;
```

---

### 2.3 ç§»åŠ¨å¹³å‡è¶‹åŠ¿è¯†åˆ«

**ç§»åŠ¨å¹³å‡**ç”¨äºè¯†åˆ«éçº¿æ€§è¶‹åŠ¿ã€‚

```sql
-- å¤šç§ç§»åŠ¨å¹³å‡è¯†åˆ«è¶‹åŠ¿
WITH time_series_indexed AS (
    SELECT
        date,
        value,
        ROW_NUMBER() OVER (ORDER BY date) AS time_index
    FROM time_series
    WHERE value IS NOT NULL
)
SELECT
    date,
    value,
    -- ç®€å•ç§»åŠ¨å¹³å‡ï¼ˆSMAï¼‰
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS sma_7,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS sma_30,
    -- æŒ‡æ•°ç§»åŠ¨å¹³å‡ï¼ˆEMAï¼‰
    -- ç®€åŒ–ç‰ˆEMAè®¡ç®—
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS ema_approx,
    -- è¶‹åŠ¿æ–¹å‘
    CASE
        WHEN AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) > AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) THEN 'ä¸Šå‡'
        WHEN AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) < AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) THEN 'ä¸‹é™'
        ELSE 'å¹³ç¨³'
    END AS trend_direction
FROM time_series_indexed
ORDER BY date;
```

### 2.4 åˆ†æ®µè¶‹åŠ¿åˆ†æ

**åˆ†æ®µè¶‹åŠ¿**è¯†åˆ«ä¸åŒæ—¶é—´æ®µçš„è¶‹åŠ¿å˜åŒ–ã€‚

```sql
-- åˆ†æ®µè¶‹åŠ¿åˆ†æï¼šè¯†åˆ«è¶‹åŠ¿è½¬æŠ˜ç‚¹
WITH time_series_indexed AS (
    SELECT
        date,
        value,
        ROW_NUMBER() OVER (ORDER BY date) AS time_index
    FROM time_series
    WHERE value IS NOT NULL
),
rolling_slopes AS (
    SELECT
        date,
        value,
        time_index,
        -- è®¡ç®—æ»šåŠ¨æ–œç‡ï¼ˆä½¿ç”¨æœ€è¿‘30ä¸ªç‚¹ï¼‰
        (
            AVG(value * time_index) OVER (
                ORDER BY date
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            ) -
            AVG(value) OVER (
                ORDER BY date
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            ) *
            AVG(time_index) OVER (
                ORDER BY date
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            )
        ) / NULLIF(
            AVG(time_index * time_index) OVER (
                ORDER BY date
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            ) -
            POWER(
                AVG(time_index) OVER (
                    ORDER BY date
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ), 2
            ),
            0
        ) AS rolling_slope
    FROM time_series_indexed
),
trend_segments AS (
    SELECT
        date,
        value,
        rolling_slope,
        LAG(rolling_slope) OVER (ORDER BY date) AS prev_slope,
        -- è¯†åˆ«è¶‹åŠ¿è½¬æŠ˜ç‚¹
        CASE
            WHEN rolling_slope > 0 AND LAG(rolling_slope) OVER (ORDER BY date) <= 0 THEN 'ä¸Šå‡å¼€å§‹'
            WHEN rolling_slope < 0 AND LAG(rolling_slope) OVER (ORDER BY date) >= 0 THEN 'ä¸‹é™å¼€å§‹'
            WHEN rolling_slope > 0 THEN 'ä¸Šå‡è¶‹åŠ¿'
            WHEN rolling_slope < 0 THEN 'ä¸‹é™è¶‹åŠ¿'
            ELSE 'å¹³ç¨³'
        END AS trend_segment
    FROM rolling_slopes
)
SELECT
    date,
    value,
    ROUND(rolling_slope::numeric, 6) AS slope,
    trend_segment
FROM trend_segments
ORDER BY date;
```

---

## 3. è¶‹åŠ¿å¼ºåº¦åˆ†æ

### 3.1 è¶‹åŠ¿å¼ºåº¦åŸç†

**è¶‹åŠ¿å¼ºåº¦åˆ†æï¼ˆTrend Strength Analysisï¼‰**è¯„ä¼°è¶‹åŠ¿çš„å¼ºåº¦å’Œå¯é æ€§ï¼Œå¸®åŠ©åˆ¤æ–­è¶‹åŠ¿æ˜¯å¦å€¼å¾—å…³æ³¨ã€‚

#### å†³å®šç³»æ•°ï¼ˆRÂ²ï¼‰

**RÂ²ï¼ˆå†³å®šç³»æ•°ï¼‰**è¡¡é‡è¶‹åŠ¿å¯¹æ•°æ®å˜å¼‚çš„è§£é‡Šç¨‹åº¦ï¼š
$$R^2 = 1 - \frac{SS_{res}}{SS_{tot}}$$

å…¶ä¸­ï¼š

- $SS_{res} = \sum_{i=1}^{n}(Y_i - \hat{Y}_i)^2$ï¼šæ®‹å·®å¹³æ–¹å’Œ
- $SS_{tot} = \sum_{i=1}^{n}(Y_i - \bar{Y})^2$ï¼šæ€»å¹³æ–¹å’Œ

#### è¶‹åŠ¿å¼ºåº¦åˆ¤æ–­

- **å¼ºè¶‹åŠ¿**ï¼š$R^2 > 0.7$
- **ä¸­ç­‰è¶‹åŠ¿**ï¼š$0.4 < R^2 \leq 0.7$
- **å¼±è¶‹åŠ¿**ï¼š$0.1 < R^2 \leq 0.4$
- **æ— è¶‹åŠ¿**ï¼š$R^2 \leq 0.1$

### 3.2 è¶‹åŠ¿å¼ºåº¦è®¡ç®—å®ç°

```sql
-- è¶‹åŠ¿å¼ºåº¦åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    r_squared NUMERIC;
    trend_strength TEXT;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè¶‹åŠ¿å¼ºåº¦åˆ†æ';
            RETURN;
        END IF;

        WITH regression AS (
            SELECT
                (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
                avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept,
                avg_y AS mean_y
            FROM (
                SELECT
                    COUNT(*) AS n,
                    AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
                    AVG(value) AS avg_y,
                    SUM(EXTRACT(EPOCH FROM date) * value) AS sum_xy,
                    SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2
                FROM time_series
                WHERE value IS NOT NULL
            ) AS stats
        ),
        residuals AS (
            SELECT
                POWER(ts.value - (r.slope * EXTRACT(EPOCH FROM ts.date) + r.intercept), 2) AS residual_sq,
                POWER(ts.value - r.mean_y, 2) AS total_sq
            FROM time_series ts
            CROSS JOIN regression r
            WHERE ts.value IS NOT NULL
        )
        SELECT
            1 - SUM(residual_sq) / NULLIF(SUM(total_sq), 0) INTO r_squared
        FROM residuals;

        trend_strength := CASE
            WHEN r_squared > 0.7 THEN 'å¼ºè¶‹åŠ¿'
            WHEN r_squared > 0.4 THEN 'ä¸­ç­‰è¶‹åŠ¿'
            WHEN r_squared > 0.1 THEN 'å¼±è¶‹åŠ¿'
            ELSE 'æ— è¶‹åŠ¿'
        END;

        RAISE NOTICE 'è¶‹åŠ¿å¼ºåº¦åˆ†æç»“æœ:';
        RAISE NOTICE '  RÂ²: %', r_squared;
        RAISE NOTICE '  è¶‹åŠ¿å¼ºåº¦: %', trend_strength;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è¶‹åŠ¿å¼ºåº¦åˆ†æå¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

### 3.3 Mann-Kendallè¶‹åŠ¿æ£€éªŒ

**M-Kæ£€éªŒ**éå‚æ•°è¶‹åŠ¿æ£€éªŒæ–¹æ³•ã€‚

```sql
-- Mann-Kendallè¶‹åŠ¿æ£€éªŒï¼ˆç®€åŒ–ç‰ˆï¼‰
WITH time_series_ordered AS (
    SELECT
        date,
        value,
        ROW_NUMBER() OVER (ORDER BY date) AS i
    FROM time_series
    WHERE value IS NOT NULL
),
pairs AS (
    SELECT
        t1.i AS i,
        t2.i AS j,
        CASE
            WHEN t2.value > t1.value THEN 1
            WHEN t2.value < t1.value THEN -1
            ELSE 0
        END AS sign
    FROM time_series_ordered t1
    CROSS JOIN time_series_ordered t2
    WHERE t2.i > t1.i
),
mk_statistic AS (
    SELECT
        SUM(sign) AS s,
        COUNT(*) AS n
    FROM pairs
),
mk_test AS (
    SELECT
        s,
        n,
        -- Mann-Kendallç»Ÿè®¡é‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
        CASE
            WHEN s > 0 THEN 'ä¸Šå‡è¶‹åŠ¿'
            WHEN s < 0 THEN 'ä¸‹é™è¶‹åŠ¿'
            ELSE 'æ— è¶‹åŠ¿'
        END AS trend_direction,
        -- æ ‡å‡†åŒ–ç»Ÿè®¡é‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
        s / NULLIF(SQRT(n * (n - 1) * (2 * n + 5) / 18.0), 0) AS z_statistic
    FROM mk_statistic
)
SELECT
    trend_direction,
    ROUND(z_statistic::numeric, 4) AS z_score,
    CASE
        WHEN ABS(z_statistic) > 2.576 THEN 'é«˜åº¦æ˜¾è‘— (p<0.01)'
        WHEN ABS(z_statistic) > 1.96 THEN 'æ˜¾è‘— (p<0.05)'
        WHEN ABS(z_statistic) > 1.645 THEN 'å¼±æ˜¾è‘— (p<0.10)'
        ELSE 'ä¸æ˜¾è‘—'
    END AS significance
FROM mk_test;
```

---

## 4. å®é™…åº”ç”¨æ¡ˆä¾‹

### 4.1 ä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æ

**ä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æ**åˆ†æä¸šåŠ¡æŒ‡æ ‡çš„è¶‹åŠ¿å˜åŒ–ã€‚

```sql
-- ä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_metrics') THEN
            RAISE WARNING 'è¡¨ business_metrics ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¸šåŠ¡æŒ‡æ ‡è¶‹åŠ¿åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH daily_metrics AS (
    SELECT
        DATE_TRUNC('day', metric_date) AS date,
        metric_name,
        AVG(metric_value) AS daily_avg
    FROM business_metrics
    GROUP BY DATE_TRUNC('day', metric_date), metric_name
),
trend_analysis AS (
    SELECT
        metric_name,
        date,
        daily_avg,
        AVG(daily_avg) OVER (
            PARTITION BY metric_name
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS short_trend,
        AVG(daily_avg) OVER (
            PARTITION BY metric_name
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS long_trend
    FROM daily_metrics
)
SELECT
    metric_name,
    date,
    daily_avg,
    short_trend,
    long_trend,
    CASE
        WHEN daily_avg > short_trend * 1.1 THEN 'å¿«é€Ÿä¸Šå‡'
        WHEN daily_avg > short_trend THEN 'ä¸Šå‡'
        WHEN daily_avg < short_trend * 0.9 THEN 'å¿«é€Ÿä¸‹é™'
        WHEN daily_avg < short_trend THEN 'ä¸‹é™'
        ELSE 'å¹³ç¨³'
    END AS trend_direction
FROM trend_analysis
ORDER BY metric_name, date;
```

### 4.2 é”€å”®è¶‹åŠ¿åˆ†æ

**åœºæ™¯**ï¼šåˆ†æé”€å”®æ•°æ®çš„é•¿æœŸè¶‹åŠ¿å’Œå­£èŠ‚æ€§å˜åŒ–ã€‚

```sql
-- é”€å”®è¶‹åŠ¿åˆ†æï¼šè¯†åˆ«é•¿æœŸè¶‹åŠ¿å’ŒçŸ­æœŸæ³¢åŠ¨
WITH sales_trend AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        SUM(order_amount) AS monthly_sales,
        COUNT(*) AS order_count
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date)
),
regression AS (
    SELECT
        COUNT(*) AS n,
        AVG(EXTRACT(EPOCH FROM month)) AS avg_x,
        AVG(monthly_sales) AS avg_y,
        SUM(EXTRACT(EPOCH FROM month) * monthly_sales) AS sum_xy,
        SUM(EXTRACT(EPOCH FROM month) * EXTRACT(EPOCH FROM month)) AS sum_x2
    FROM sales_trend
),
trend_values AS (
    SELECT
        st.month,
        st.monthly_sales,
        st.order_count,
        -- çº¿æ€§è¶‹åŠ¿
        r.avg_y + (r.sum_xy - r.n * r.avg_x * r.avg_y) / NULLIF(r.sum_x2 - r.n * r.avg_x * r.avg_x, 0) *
        (EXTRACT(EPOCH FROM st.month) - r.avg_x) AS trend_value,
        -- è¶‹åŠ¿æ–œç‡
        (r.sum_xy - r.n * r.avg_x * r.avg_y) / NULLIF(r.sum_x2 - r.n * r.avg_x * r.avg_x, 0) AS slope
    FROM sales_trend st
    CROSS JOIN regression r
)
SELECT
    month,
    monthly_sales,
    order_count,
    ROUND(trend_value::numeric, 2) AS trend_value,
    ROUND((monthly_sales - trend_value)::numeric, 2) AS detrended_value,
    ROUND(slope::numeric, 6) AS monthly_slope,
    -- è¶‹åŠ¿æ–¹å‘
    CASE
        WHEN slope > 0 THEN 'ä¸Šå‡è¶‹åŠ¿'
        WHEN slope < 0 THEN 'ä¸‹é™è¶‹åŠ¿'
        ELSE 'å¹³ç¨³è¶‹åŠ¿'
    END AS trend_direction,
    -- å¢é•¿ç‡
    ROUND(
        (slope * 2592000) / NULLIF(LAG(monthly_sales) OVER (ORDER BY month), 0) * 100,
        2
    ) AS month_over_month_growth
FROM trend_values
ORDER BY month;
```

### 4.3 ç”¨æˆ·å¢é•¿è¶‹åŠ¿åˆ†æ

**åœºæ™¯**ï¼šåˆ†æç”¨æˆ·æ³¨å†Œå’Œæ´»è·ƒç”¨æˆ·çš„å¢é•¿è¶‹åŠ¿ã€‚

```sql
-- ç”¨æˆ·å¢é•¿è¶‹åŠ¿åˆ†æï¼šè¯†åˆ«å¢é•¿é˜¶æ®µå’Œå¢é•¿ç‡å˜åŒ–
WITH daily_users AS (
    SELECT
        DATE_TRUNC('day', registration_date) AS date,
        COUNT(*) AS new_users
    FROM users
    GROUP BY DATE_TRUNC('day', registration_date)
),
cumulative_users AS (
    SELECT
        date,
        new_users,
        SUM(new_users) OVER (ORDER BY date) AS total_users,
        -- 7æ—¥ç§»åŠ¨å¹³å‡
        AVG(new_users) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS ma_7,
        -- 30æ—¥ç§»åŠ¨å¹³å‡
        AVG(new_users) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS ma_30
    FROM daily_users
),
growth_metrics AS (
    SELECT
        date,
        new_users,
        total_users,
        ROUND(ma_7::numeric, 2) AS ma_7,
        ROUND(ma_30::numeric, 2) AS ma_30,
        -- å¢é•¿ç‡
        CASE
            WHEN LAG(total_users) OVER (ORDER BY date) > 0 THEN
                (total_users - LAG(total_users) OVER (ORDER BY date)) /
                NULLIF(LAG(total_users) OVER (ORDER BY date), 0) * 100
            ELSE NULL
        END AS daily_growth_rate,
        -- è¶‹åŠ¿åˆ¤æ–­
        CASE
            WHEN ma_7 > ma_30 * 1.1 THEN 'åŠ é€Ÿå¢é•¿'
            WHEN ma_7 > ma_30 THEN 'ç¨³å®šå¢é•¿'
            WHEN ma_7 < ma_30 * 0.9 THEN 'å¢é•¿æ”¾ç¼“'
            WHEN ma_7 < ma_30 THEN 'ä¸‹é™'
            ELSE 'å¹³ç¨³'
        END AS growth_trend
    FROM cumulative_users
)
SELECT
    date,
    new_users,
    total_users,
    ma_7,
    ma_30,
    ROUND(COALESCE(daily_growth_rate, 0)::numeric, 2) AS growth_rate_pct,
    growth_trend
FROM growth_metrics
ORDER BY date;
```

### 4.4 ç½‘ç«™æµé‡è¶‹åŠ¿åˆ†æ

**åœºæ™¯**ï¼šåˆ†æç½‘ç«™è®¿é—®é‡çš„è¶‹åŠ¿å’Œå¼‚å¸¸æ£€æµ‹ã€‚

```sql
-- ç½‘ç«™æµé‡è¶‹åŠ¿åˆ†æï¼šè¯†åˆ«æµé‡è¶‹åŠ¿å’Œå¼‚å¸¸
WITH daily_traffic AS (
    SELECT
        DATE_TRUNC('day', visit_time) AS date,
        COUNT(*) AS page_views,
        COUNT(DISTINCT user_id) AS unique_visitors,
        COUNT(DISTINCT session_id) AS sessions
    FROM page_views
    GROUP BY DATE_TRUNC('day', visit_time)
),
traffic_trend AS (
    SELECT
        date,
        page_views,
        unique_visitors,
        sessions,
        -- çº¿æ€§è¶‹åŠ¿
        AVG(page_views) OVER () +
        (ROW_NUMBER() OVER (ORDER BY date) - AVG(ROW_NUMBER() OVER (ORDER BY date)) OVER ()) *
        (AVG(page_views * ROW_NUMBER() OVER (ORDER BY date)) OVER () -
         AVG(page_views) OVER () * AVG(ROW_NUMBER() OVER (ORDER BY date)) OVER ()) /
        NULLIF(
            AVG(POWER(ROW_NUMBER() OVER (ORDER BY date), 2)) OVER () -
            POWER(AVG(ROW_NUMBER() OVER (ORDER BY date)) OVER (), 2),
            0
        ) AS trend_value,
        -- æ ‡å‡†å·®
        STDDEV(page_views) OVER () AS stddev_pv
    FROM daily_traffic
)
SELECT
    date,
    page_views,
    unique_visitors,
    sessions,
    ROUND(trend_value::numeric, 2) AS trend_value,
    ROUND((page_views - trend_value)::numeric, 2) AS deviation,
    -- å¼‚å¸¸æ£€æµ‹
    CASE
        WHEN ABS(page_views - trend_value) > 3 * stddev_pv THEN 'å¼‚å¸¸'
        WHEN ABS(page_views - trend_value) > 2 * stddev_pv THEN 'å¼‚å¸¸åé«˜'
        ELSE 'æ­£å¸¸'
    END AS anomaly_status,
    -- è¶‹åŠ¿æ–¹å‘
    CASE
        WHEN page_views > trend_value * 1.1 THEN 'æ˜¾è‘—é«˜äºè¶‹åŠ¿'
        WHEN page_views > trend_value THEN 'é«˜äºè¶‹åŠ¿'
        WHEN page_views < trend_value * 0.9 THEN 'æ˜¾è‘—ä½äºè¶‹åŠ¿'
        WHEN page_views < trend_value THEN 'ä½äºè¶‹åŠ¿'
        ELSE 'ç¬¦åˆè¶‹åŠ¿'
    END AS trend_status
FROM traffic_trend
ORDER BY date;
```

---

## 5. PostgreSQL 18å¹¶è¡Œè¶‹åŠ¿åˆ†æ

### 5.1 å¹¶è¡Œè¶‹åŠ¿åˆ†ææ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œè¶‹åŠ¿åˆ†æ**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡è¶‹åŠ¿åˆ†æçš„æ€§èƒ½ã€‚

#### å¹¶è¡Œè¶‹åŠ¿åˆ†æé…ç½®

```sql
-- é…ç½®å¹¶è¡Œè¶‹åŠ¿åˆ†æå‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œè¶‹åŠ¿åˆ†æå‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œè¶‹åŠ¿åˆ†æé…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œè¶‹åŠ¿åˆ†æå®ç°

```sql
-- å¹¶è¡Œè¶‹åŠ¿åˆ†æï¼šå¤§è§„æ¨¡æ—¶é—´åºåˆ—è¶‹åŠ¿è¯†åˆ«ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œè¶‹åŠ¿åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œè¶‹åŠ¿åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œçº¿æ€§è¶‹åŠ¿åˆ†æ
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_time_series AS (
    SELECT
        time_series_id,
        timestamp,
        value,
        ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp) AS time_index
    FROM time_series_data
    WHERE timestamp >= CURRENT_DATE - INTERVAL '1 year'
),
parallel_trend_stats AS (
    SELECT
        time_series_id,
        AVG(time_index) AS avg_time,
        AVG(value) AS avg_value,
        AVG(time_index * value) AS avg_time_value,
        AVG(time_index * time_index) AS avg_time_squared,
        COUNT(*) AS n
    FROM parallel_time_series
    GROUP BY time_series_id
),
parallel_trend_coefficients AS (
    SELECT
        time_series_id,
        (avg_time_value - avg_time * avg_value) / NULLIF(avg_time_squared - avg_time * avg_time, 0) AS slope,
        avg_value - (avg_time_value - avg_time * avg_value) / NULLIF(avg_time_squared - avg_time * avg_time, 0) * avg_time AS intercept
    FROM parallel_trend_stats
)
SELECT
    time_series_id,
    ROUND(slope::numeric, 4) AS trend_slope,
    ROUND(intercept::numeric, 4) AS trend_intercept,
    CASE
        WHEN slope > 0.1 THEN 'Strong Upward'
        WHEN slope > 0 THEN 'Upward'
        WHEN slope < -0.1 THEN 'Strong Downward'
        WHEN slope < 0 THEN 'Downward'
        ELSE 'Stable'
    END AS trend_direction
FROM parallel_trend_coefficients
ORDER BY ABS(slope) DESC;
```

---

## 6. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 6.1 è¶‹åŠ¿åˆ†ææ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|-----------|-----------|---------|------|------|
| **çº¿æ€§å›å½’** | $O(n)$ | $O(1)$ | çº¿æ€§è¶‹åŠ¿ | ç®€å•å¿«é€Ÿã€å¯è§£é‡Šæ€§å¼º | å‡è®¾ä¸¥æ ¼ |
| **ç§»åŠ¨å¹³å‡** | $O(n)$ | $O(w)$ | å¹³æ»‘è¶‹åŠ¿ | ç®€å•ç›´è§‚ | æ»åæ€§ |
| **å¤šé¡¹å¼å›å½’** | $O(nk^2)$ | $O(k)$ | éçº¿æ€§è¶‹åŠ¿ | çµæ´» | è¿‡æ‹Ÿåˆé£é™© |
| **M-Kæ£€éªŒ** | $O(n^2)$ | $O(1)$ | éå‚æ•°æ£€éªŒ | æ— éœ€å‡è®¾ | è®¡ç®—å¤æ‚ |

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è®¡ç®—ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨çª—å£å‡½æ•°å‡å°‘é‡å¤è®¡ç®—
   - ç¼“å­˜å›å½’ç³»æ•°
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾

2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - åˆ›å»ºæ—¶é—´ç´¢å¼•
   - ä½¿ç”¨åˆ†åŒºè¡¨
   - é™åˆ¶æ—¶é—´èŒƒå›´

3. **ç®—æ³•ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨å¢é‡è®¡ç®—
   - é‡‡æ ·è®¡ç®—
   - å¹¶è¡Œå¤„ç†

### 6.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šè¶‹åŠ¿æ£€æµ‹ä¸å‡†ç¡®

- **è§£å†³æ–¹æ¡ˆ**ï¼šå¢åŠ æ•°æ®é‡ã€å»é™¤å¼‚å¸¸å€¼ã€ä½¿ç”¨å¤šç§æ–¹æ³•éªŒè¯

**é—®é¢˜2**ï¼šéçº¿æ€§è¶‹åŠ¿è¯†åˆ«å›°éš¾

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å¤šé¡¹å¼å›å½’ã€ç§»åŠ¨å¹³å‡ã€åˆ†æ®µåˆ†æ

**é—®é¢˜3**ï¼šè¶‹åŠ¿é¢„æµ‹è¯¯å·®å¤§

- **è§£å†³æ–¹æ¡ˆ**ï¼šç»“åˆå­£èŠ‚æ€§å’Œå‘¨æœŸæ€§ã€ä½¿ç”¨æ›´å¤æ‚çš„æ¨¡å‹ã€å®šæœŸæ›´æ–°

**é—®é¢˜4**ï¼šè®¡ç®—æ€§èƒ½é—®é¢˜

- **è§£å†³æ–¹æ¡ˆ**ï¼šä¼˜åŒ–SQLæŸ¥è¯¢ã€ä½¿ç”¨ç´¢å¼•ã€åˆ†æ‰¹å¤„ç†

---

## 7. æœ€ä½³å®è·µ

### 7.1 è¶‹åŠ¿åˆ†ææ–¹æ³•é€‰æ‹©

1. **æ•°æ®æ¢ç´¢**ï¼š
   - å¯è§†åŒ–æ—¶é—´åºåˆ—
   - æ£€æŸ¥æ•°æ®è´¨é‡
   - è¯†åˆ«å¼‚å¸¸å€¼

2. **æ–¹æ³•é€‰æ‹©**ï¼š
   - çº¿æ€§è¶‹åŠ¿ï¼šä½¿ç”¨çº¿æ€§å›å½’
   - éçº¿æ€§è¶‹åŠ¿ï¼šä½¿ç”¨ç§»åŠ¨å¹³å‡æˆ–å¤šé¡¹å¼å›å½’
   - éå‚æ•°ï¼šä½¿ç”¨M-Kæ£€éªŒ

3. **ç»“æœéªŒè¯**ï¼š
   - æ£€æŸ¥RÂ²å€¼
   - åˆ†ææ®‹å·®
   - ä½¿ç”¨å¤šç§æ–¹æ³•å¯¹æ¯”

### 7.2 è¶‹åŠ¿åˆ†ææ³¨æ„äº‹é¡¹

1. **æ•°æ®è´¨é‡**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼
   - è¯†åˆ«å¼‚å¸¸å€¼
   - æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§

2. **æ—¶é—´èŒƒå›´**ï¼š
   - é€‰æ‹©åˆé€‚çš„æ—¶é—´çª—å£
   - è€ƒè™‘æ•°æ®å˜åŒ–
   - é¿å…è¿‡çŸ­æˆ–è¿‡é•¿

3. **è¶‹åŠ¿è§£é‡Š**ï¼š
   - ç»“åˆä¸šåŠ¡èƒŒæ™¯
   - è€ƒè™‘å¤–éƒ¨å› ç´ 
   - è°¨æ…é¢„æµ‹

### 7.3 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼š
   - ä¼˜åŒ–çª—å£å‡½æ•°
   - åˆ›å»ºæ—¶é—´ç´¢å¼•
   - ä½¿ç”¨åˆ†åŒºè¡¨

2. **å‡†ç¡®æ€§**ï¼š
   - å¤„ç†æ•°å€¼ç²¾åº¦
   - é¿å…é™¤é›¶é”™è¯¯
   - éªŒè¯è®¡ç®—ç»“æœ

3. **å¯ç»´æŠ¤æ€§**ï¼š
   - ä½¿ç”¨æ¸…æ™°çš„å˜é‡å
   - æ·»åŠ æ³¨é‡Š
   - æ¨¡å—åŒ–è®¾è®¡

### 7.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡è¶‹åŠ¿åˆ†æçš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«æ—¶é—´æˆ³çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nè¶‹åŠ¿æŸ¥è¯¢å’Œå¤šæ—¶é—´åºåˆ—è¶‹åŠ¿å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡è¶‹åŠ¿åˆ†æè®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡çº¿æ€§å›å½’å’Œå¤šæ—¶é—´åºåˆ—è¶‹åŠ¿è¯†åˆ«

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - è¶‹åŠ¿åˆ†ææ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡æ—¶é—´åºåˆ—è¶‹åŠ¿åˆ†æå’Œå¤šæŒ‡æ ‡è¶‹åŠ¿å¯¹æ¯”

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–è¶‹åŠ¿åˆ†ææŸ¥è¯¢**

```sql
-- ä¸ºè¶‹åŠ¿åˆ†æåˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_trend_analysis_skip_scan
ON time_series(time_series_id, timestamp DESC, value DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªæ—¶é—´åºåˆ—æœ€æ–°æ—¶é—´ç‚¹çš„è¶‹åŠ¿æ–¹å‘
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (time_series_id)
    time_series_id,
    timestamp,
    value,
    CASE
        WHEN (value - LAG(value) OVER (PARTITION BY time_series_id ORDER BY timestamp)) > 0 THEN 'Upward'
        WHEN (value - LAG(value) OVER (PARTITION BY time_series_id ORDER BY timestamp)) < 0 THEN 'Downward'
        ELSE 'Stable'
    END AS trend_direction
FROM time_series
ORDER BY time_series_id, timestamp DESC
LIMIT 50;
```

### 7.5 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜è¶‹åŠ¿åˆ†æç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„è¶‹åŠ¿åˆ†æç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜è¶‹åŠ¿åˆ†æç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS trend_analysis_cache AS
WITH trend_statistics AS (
    SELECT
        time_series_id,
        timestamp,
        value,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—è¶‹åŠ¿æ–œç‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        (AVG(value * ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp)) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) - AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) * AVG(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp)) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        )) / NULLIF(AVG(POWER(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp), 2)) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) - POWER(AVG(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp)) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ), 2), 0) AS trend_slope,
        AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS trend_value,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—è¶‹åŠ¿å¼ºåº¦ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CORR(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp), value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS trend_correlation
    FROM time_series
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '90 days'
)
SELECT
    time_series_id,
    timestamp,
    value,
    ROUND(trend_slope::numeric, 4) AS trend_slope,
    ROUND(trend_value::numeric, 4) AS trend_value,
    ROUND(trend_correlation::numeric, 4) AS trend_correlation,
    CASE
        WHEN trend_slope > 0.1 AND trend_correlation > 0.7 THEN 'Strong Upward'
        WHEN trend_slope > 0 THEN 'Upward'
        WHEN trend_slope < -0.1 AND trend_correlation < -0.7 THEN 'Strong Downward'
        WHEN trend_slope < 0 THEN 'Downward'
        ELSE 'Stable'
    END AS trend_status
FROM trend_statistics
ORDER BY time_series_id, timestamp DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_trend_analysis_cache_ts_time ON trend_analysis_cache(time_series_id, timestamp DESC);
CREATE INDEX idx_trend_analysis_cache_trend ON trend_analysis_cache(trend_status, trend_slope DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY trend_analysis_cache;
```

**2. å®æ—¶è¶‹åŠ¿åˆ†æï¼šå¢é‡è¶‹åŠ¿æ›´æ–°**

**å®æ—¶è¶‹åŠ¿åˆ†æ**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°è¶‹åŠ¿åˆ†æç»“æœã€‚

```sql
-- å®æ—¶è¶‹åŠ¿åˆ†æï¼šå¢é‡è¶‹åŠ¿æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'trend_analysis_state') THEN
            CREATE TABLE trend_analysis_state (
                time_series_id VARCHAR(100) NOT NULL,
                window_size INTEGER NOT NULL,
                sum_x NUMERIC DEFAULT 0,
                sum_y NUMERIC DEFAULT 0,
                sum_xy NUMERIC DEFAULT 0,
                sum_x2 NUMERIC DEFAULT 0,
                count_samples BIGINT DEFAULT 0,
                last_slope NUMERIC,
                last_correlation NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (time_series_id, window_size)
            );

            CREATE INDEX idx_trend_analysis_state_ts_time ON trend_analysis_state(time_series_id, last_updated DESC);
            CREATE INDEX idx_trend_analysis_state_updated ON trend_analysis_state(last_updated DESC);

            RAISE NOTICE 'è¶‹åŠ¿åˆ†æçŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡è¶‹åŠ¿åˆ†ææ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡è¶‹åŠ¿åˆ†ææ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°è¶‹åŠ¿åˆ†æç»Ÿè®¡ï¼šå®æ—¶è¶‹åŠ¿åˆ†æ
WITH new_trend_data AS (
    SELECT
        time_series_id,
        ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp) AS x,
        value AS y,
        timestamp
    FROM time_series
    WHERE timestamp > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM trend_analysis_state)
      AND timestamp <= CURRENT_TIMESTAMP
),
updated_trend_stats AS (
    SELECT
        COALESCE(tas.time_series_id, ntd.time_series_id) AS time_series_id,
        30 AS window_size,
        COALESCE(tas.sum_x, 0) + SUM(ntd.x) AS new_sum_x,
        COALESCE(tas.sum_y, 0) + SUM(ntd.y) AS new_sum_y,
        COALESCE(tas.sum_xy, 0) + SUM(ntd.x * ntd.y) AS new_sum_xy,
        COALESCE(tas.sum_x2, 0) + SUM(ntd.x * ntd.x) AS new_sum_x2,
        COALESCE(tas.count_samples, 0) + COUNT(*) AS new_count_samples
    FROM trend_analysis_state tas
    FULL OUTER JOIN new_trend_data ntd ON tas.time_series_id = ntd.time_series_id AND tas.window_size = 30
    GROUP BY tas.time_series_id, ntd.time_series_id, tas.sum_x, tas.sum_y, tas.sum_xy, tas.sum_x2, tas.count_samples
),
trend_coefficients AS (
    SELECT
        time_series_id,
        window_size,
        new_sum_x,
        new_sum_y,
        new_sum_xy,
        new_sum_x2,
        new_count_samples,
        -- è®¡ç®—è¶‹åŠ¿æ–œç‡
        (new_sum_xy - new_count_samples * (new_sum_x / new_count_samples) * (new_sum_y / new_count_samples)) /
        NULLIF(new_sum_x2 - new_count_samples * POWER(new_sum_x / new_count_samples, 2), 0) AS new_slope,
        -- è®¡ç®—ç›¸å…³ç³»æ•°
        (new_sum_xy - new_count_samples * (new_sum_x / new_count_samples) * (new_sum_y / new_count_samples)) /
        NULLIF(SQRT((new_sum_x2 - new_count_samples * POWER(new_sum_x / new_count_samples, 2)) *
                    (SUM(POWER(ntd.y, 2)) OVER (PARTITION BY ntd.time_series_id) - new_count_samples * POWER(new_sum_y / new_count_samples, 2))), 0) AS new_correlation
    FROM updated_trend_stats
    LEFT JOIN new_trend_data ntd USING (time_series_id)
    WHERE new_count_samples >= 30  -- è‡³å°‘éœ€è¦30ä¸ªæ ·æœ¬
)
-- æ›´æ–°æˆ–æ’å…¥è¶‹åŠ¿åˆ†æçŠ¶æ€
INSERT INTO trend_analysis_state (
    time_series_id,
    window_size,
    sum_x,
    sum_y,
    sum_xy,
    sum_x2,
    count_samples,
    last_slope,
    last_correlation,
    last_updated
)
SELECT
    time_series_id,
    window_size,
    new_sum_x,
    new_sum_y,
    new_sum_xy,
    new_sum_x2,
    new_count_samples,
    new_slope,
    new_correlation,
    NOW()
FROM trend_coefficients
ON CONFLICT (time_series_id, window_size)
DO UPDATE SET
    sum_x = EXCLUDED.sum_x,
    sum_y = EXCLUDED.sum_y,
    sum_xy = EXCLUDED.sum_xy,
    sum_x2 = EXCLUDED.sum_x2,
    count_samples = EXCLUDED.count_samples,
    last_slope = EXCLUDED.last_slope,
    last_correlation = EXCLUDED.last_correlation,
    last_updated = NOW();
```

**3. æ™ºèƒ½è¶‹åŠ¿åˆ†æï¼šè‡ªé€‚åº”è¶‹åŠ¿æ£€æµ‹**

**æ™ºèƒ½è¶‹åŠ¿åˆ†æ**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜è¶‹åŠ¿æ£€æµ‹æ–¹æ³•ã€‚

```sql
-- æ™ºèƒ½è¶‹åŠ¿åˆ†æï¼šè‡ªé€‚åº”è¶‹åŠ¿æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    data_linearity NUMERIC;
    data_stationarity NUMERIC;
    recommended_method VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½è¶‹åŠ¿åˆ†æ';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        WITH trend_stats AS (
            SELECT
                AVG(value * ROW_NUMBER() OVER (ORDER BY timestamp)) -
                AVG(value) * AVG(ROW_NUMBER() OVER (ORDER BY timestamp)) AS covariance,
                STDDEV(value) * STDDEV(ROW_NUMBER() OVER (ORDER BY timestamp)) AS stddev_product,
                STDDEV(value) / NULLIF(AVG(value), 0) AS coefficient_of_variation
            FROM time_series
            WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '90 days'
        )
        SELECT
            ABS(covariance / NULLIF(stddev_product, 0)),
            coefficient_of_variation
        INTO data_linearity, data_stationarity
        FROM trend_stats;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©è¶‹åŠ¿æ£€æµ‹æ–¹æ³•
        IF data_linearity > 0.8 AND data_stationarity < 0.3 THEN
            recommended_method := 'LINEAR_REGRESSION';  -- é«˜çº¿æ€§ä½æ³¢åŠ¨ï¼šçº¿æ€§å›å½’
        ELSIF data_linearity > 0.5 AND data_stationarity < 0.5 THEN
            recommended_method := 'MOVING_AVERAGE';  -- ä¸­çº¿æ€§ä¸­æ³¢åŠ¨ï¼šç§»åŠ¨å¹³å‡
        ELSE
            recommended_method := 'MANN_KENDALL';  -- ä½çº¿æ€§é«˜æ³¢åŠ¨ï¼šéå‚æ•°æ–¹æ³•
        END IF;

        RAISE NOTICE 'æ•°æ®çº¿æ€§åº¦: %, æ•°æ®å¹³ç¨³åº¦: %, æ¨èæ–¹æ³•: %',
            data_linearity, data_stationarity, recommended_method;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½è¶‹åŠ¿åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ™ºèƒ½è¶‹åŠ¿åˆ†æï¼šæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„è¶‹åŠ¿æ£€æµ‹æ–¹æ³•
WITH data_characteristics AS (
    SELECT
        time_series_id,
        ABS(CORR(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp), value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 89 PRECEDING AND CURRENT ROW
        )) AS linearity,
        STDDEV(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 89 PRECEDING AND CURRENT ROW
        ) / NULLIF(AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 89 PRECEDING AND CURRENT ROW
        ), 0) AS stationarity
    FROM time_series
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '90 days'
),
adaptive_trend_analysis AS (
    SELECT
        time_series_id,
        timestamp,
        value,
        linearity,
        stationarity,
        CASE
            WHEN linearity > 0.8 AND stationarity < 0.3 THEN 'LINEAR_REGRESSION'
            WHEN linearity > 0.5 AND stationarity < 0.5 THEN 'MOVING_AVERAGE'
            ELSE 'MANN_KENDALL'
        END AS recommended_method,
        -- æ ¹æ®æ¨èæ–¹æ³•è®¡ç®—è¶‹åŠ¿ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN linearity > 0.8 AND stationarity < 0.3 THEN
                (AVG(value * ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp)) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ) - AVG(value) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ) * AVG(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp)) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                )) / NULLIF(AVG(POWER(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp), 2)) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ) - POWER(AVG(ROW_NUMBER() OVER (PARTITION BY time_series_id ORDER BY timestamp)) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ), 2), 0)
            ELSE NULL
        END AS linear_slope,
        CASE
            WHEN linearity > 0.5 AND stationarity < 0.5 THEN
                AVG(value) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ) - LAG(AVG(value) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                )) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                )
            ELSE NULL
        END AS moving_avg_trend
    FROM time_series
    JOIN data_characteristics USING (time_series_id)
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '90 days'
)
SELECT
    time_series_id,
    timestamp,
    value,
    ROUND(linearity::numeric, 4) AS linearity,
    ROUND(stationarity::numeric, 4) AS stationarity,
    recommended_method,
    ROUND(COALESCE(linear_slope, moving_avg_trend, 0)::numeric, 4) AS trend_value,
    CASE
        WHEN recommended_method = 'LINEAR_REGRESSION' AND linear_slope > 0 THEN 'Upward'
        WHEN recommended_method = 'LINEAR_REGRESSION' AND linear_slope < 0 THEN 'Downward'
        WHEN recommended_method = 'MOVING_AVERAGE' AND moving_avg_trend > 0 THEN 'Upward'
        WHEN recommended_method = 'MOVING_AVERAGE' AND moving_avg_trend < 0 THEN 'Downward'
        ELSE 'Stable'
    END AS trend_direction
FROM adaptive_trend_analysis
ORDER BY time_series_id, timestamp DESC
LIMIT 100;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **ã€Šæ—¶é—´åºåˆ—åˆ†æã€‹**ï¼ˆHamilton, J. D., 1994ï¼‰- è¶‹åŠ¿åˆ†æç†è®º

2. **ã€Šåº”ç”¨æ—¶é—´åºåˆ—åˆ†æã€‹**ï¼ˆç‹ç‡•, 2015ï¼‰- è¶‹åŠ¿æ£€æµ‹æ–¹æ³•

3. **ã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹**ï¼ˆæèˆª, 2012ï¼‰- å›å½’åˆ†ææ–¹æ³•

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- **çª—å£å‡½æ•°**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **èšåˆå‡½æ•°**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **æ•°å­¦å‡½æ•°**: <https://www.postgresql.org/docs/current/functions-math.html>

### åœ¨çº¿èµ„æº

- **è¶‹åŠ¿åˆ†æ**: <https://en.wikipedia.org/wiki/Trend_analysis>
- **çº¿æ€§å›å½’**: <https://en.wikipedia.org/wiki/Linear_regression>
- **Mann-Kendallæ£€éªŒ**: <https://en.wikipedia.org/wiki/Mann%E2%80%93Kendall_trend_test>

### ç›¸å…³ç®—æ³•

- **æ—¶é—´åºåˆ—é¢„æµ‹**ï¼šåŸºäºè¶‹åŠ¿çš„é¢„æµ‹
- **æ—¶é—´åºåˆ—åˆ†è§£**ï¼šè¶‹åŠ¿æˆåˆ†æå–
- **å¼‚å¸¸æ£€æµ‹ç®—æ³•**ï¼šåŸºäºè¶‹åŠ¿çš„å¼‚å¸¸æ£€æµ‹
- **å‘¨æœŸæ€§åˆ†æ**ï¼šè¶‹åŠ¿ä¸å‘¨æœŸç»“åˆ

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
