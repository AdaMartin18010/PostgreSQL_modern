# PostgreSQL 滑动窗口计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 滑动窗口 | 移动平均
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 滑动窗口计算完整指南](#postgresql-滑动窗口计算完整指南)
  - [📋 目录](#-目录)
  - [滑动窗口计算概述](#滑动窗口计算概述)
    - [理论基础](#理论基础)
      - [窗口函数定义](#窗口函数定义)
      - [窗口框架类型](#窗口框架类型)
      - [滑动窗口数学定义](#滑动窗口数学定义)
    - [核心窗口功能](#核心窗口功能)
  - [1. 移动平均](#1-移动平均)
    - [1.1 移动平均原理](#11-移动平均原理)
      - [简单移动平均（SMA）](#简单移动平均sma)
      - [加权移动平均（WMA）](#加权移动平均wma)
      - [移动平均特性](#移动平均特性)
    - [1.2 简单移动平均实现](#12-简单移动平均实现)
    - [1.3 加权移动平均实现](#13-加权移动平均实现)
    - [1.4 多周期移动平均对比](#14-多周期移动平均对比)
  - [2. 指数移动平均](#2-指数移动平均)
    - [2.1 指数移动平均原理](#21-指数移动平均原理)
      - [EMA数学定义](#ema数学定义)
      - [平滑系数选择](#平滑系数选择)
      - [EMA特性](#ema特性)
    - [2.2 EMA计算实现](#22-ema计算实现)
    - [2.3 双EMA（DEMA）实现](#23-双emadema实现)
  - [3. 滚动统计](#3-滚动统计)
    - [3.1 滚动统计原理](#31-滚动统计原理)
      - [滚动统计指标](#滚动统计指标)
    - [3.2 滚动统计指标实现](#32-滚动统计指标实现)
    - [3.3 滚动分位数计算](#33-滚动分位数计算)
    - [3.4 滚动相关性计算](#34-滚动相关性计算)
  - [4. 累积统计](#4-累积统计)
    - [4.1 累积统计原理](#41-累积统计原理)
      - [累积统计类型](#累积统计类型)
    - [4.2 累积统计实现](#42-累积统计实现)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 趋势分析](#51-趋势分析)
    - [5.2 股票价格技术分析](#52-股票价格技术分析)
    - [5.3 网站流量平滑分析](#53-网站流量平滑分析)
    - [5.4 销售数据滚动分析](#54-销售数据滚动分析)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 窗口计算方法对比](#61-窗口计算方法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 窗口大小选择](#71-窗口大小选择)
    - [7.2 窗口函数使用注意事项](#72-窗口函数使用注意事项)
    - [7.3 SQL实现注意事项](#73-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 滑动窗口计算概述

**滑动窗口计算（Sliding Window Calculation）**在固定大小的窗口内进行统计计算，用于平滑处理、趋势分析和数据聚合。滑动窗口是时间序列分析中的核心技术之一，能够有效去除噪声、识别趋势和检测异常。

### 理论基础

#### 窗口函数定义

**窗口函数（Window Function）**对一组相关的行进行计算，这些行被称为"窗口"（Window）。窗口函数不会将多行合并为一行，而是为每一行返回一个值。

**窗口函数语法**：

```sql
function_name([arguments])
OVER (
    [PARTITION BY partition_expression]
    [ORDER BY sort_expression]
    [frame_clause]
)
```

#### 窗口框架类型

1. **ROWS框架**：基于行数
   - `ROWS BETWEEN n PRECEDING AND m FOLLOWING`
   - `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

2. **RANGE框架**：基于值范围
   - `RANGE BETWEEN n PRECEDING AND m FOLLOWING`
   - `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

3. **GROUPS框架**：基于组数（PostgreSQL 11+）
   - `GROUPS BETWEEN n PRECEDING AND m FOLLOWING`

#### 滑动窗口数学定义

对于时间序列$\{y_t\}$，窗口大小为$w$的滑动窗口统计量为：
$$S_t = f(y_{t-w+1}, y_{t-w+2}, \ldots, y_t)$$

其中$f$是统计函数（如均值、标准差等）。

### 核心窗口功能

| 功能 | 用途 | 复杂度 | 数学表示 |
|------|------|--------|----------|
| **移动平均** | 平滑处理 | $O(n)$ | $\bar{y}_t = \frac{1}{w}\sum_{i=0}^{w-1}y_{t-i}$ |
| **指数移动平均** | 加权平滑 | $O(n)$ | $EMA_t = \alpha y_t + (1-\alpha)EMA_{t-1}$ |
| **滚动统计** | 窗口统计 | $O(n)$ | $S_t = f(y_{t-w+1}, \ldots, y_t)$ |
| **累积统计** | 累积计算 | $O(n)$ | $C_t = f(y_1, \ldots, y_t)$ |

---

## 1. 移动平均

### 1.1 移动平均原理

**移动平均（Moving Average, MA）**是时间序列分析中最常用的平滑技术，通过计算固定窗口内的平均值来平滑数据。

#### 简单移动平均（SMA）

**简单移动平均**：
$$SMA_t = \frac{1}{w}\sum_{i=0}^{w-1}y_{t-i}$$

其中：

- $w$：窗口大小
- $y_t$：时间$t$的观测值

#### 加权移动平均（WMA）

**加权移动平均**：
$$WMA_t = \frac{\sum_{i=0}^{w-1}w_i y_{t-i}}{\sum_{i=0}^{w-1}w_i}$$

其中$w_i$是权重，通常$w_i > w_{i+1}$（近期数据权重更大）。

#### 移动平均特性

1. **平滑效果**：窗口越大，平滑效果越强
2. **滞后性**：窗口越大，滞后性越明显
3. **去噪能力**：有效去除随机波动

### 1.2 简单移动平均实现

```sql
-- 简单移动平均（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行简单移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '移动平均准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS moving_avg_30
FROM time_series
ORDER BY date;
```

---

### 1.3 加权移动平均实现

**加权移动平均**给近期数据更高权重。

```sql
-- 加权移动平均（线性权重递减）
WITH weighted_ma AS (
    SELECT
        date,
        value,
        -- 加权移动平均：权重为 w, w-1, w-2, ..., 1
        SUM(value * (window_size - offset + 1)) OVER (
            ORDER BY date
            ROWS BETWEEN window_size - 1 PRECEDING AND CURRENT ROW
        ) / NULLIF(
            SUM(window_size - offset + 1) OVER (
                ORDER BY date
                ROWS BETWEEN window_size - 1 PRECEDING AND CURRENT ROW
            ),
            0
        ) AS weighted_ma
    FROM (
        SELECT
            date,
            value,
            7 AS window_size,
            ROW_NUMBER() OVER (ORDER BY date) -
            ROW_NUMBER() OVER (ORDER BY date) + 1 AS offset
        FROM time_series
        WHERE value IS NOT NULL
    ) AS ts
)
SELECT
    date,
    value,
    ROUND(weighted_ma::numeric, 2) AS weighted_ma_7
FROM weighted_ma
ORDER BY date;
```

### 1.4 多周期移动平均对比

**多周期移动平均**对比不同窗口大小的效果。

```sql
-- 多周期移动平均对比
SELECT
    date,
    value,
    -- 短期移动平均（7天）
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma_7,
    -- 中期移动平均（30天）
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS ma_30,
    -- 长期移动平均（90天）
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 89 PRECEDING AND CURRENT ROW
    ) AS ma_90,
    -- 趋势判断
    CASE
        WHEN AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) > AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) THEN '上升趋势'
        WHEN AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) < AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) THEN '下降趋势'
        ELSE '平稳'
    END AS trend_direction
FROM time_series
WHERE value IS NOT NULL
ORDER BY date;
```

---

## 2. 指数移动平均

### 2.1 指数移动平均原理

**指数移动平均（Exponential Moving Average, EMA）**使用指数加权，给近期数据更高权重。

#### EMA数学定义

**EMA递推公式**：
$$EMA_t = \alpha y_t + (1-\alpha)EMA_{t-1}$$

其中：

- $\alpha$：平滑系数（$0 < \alpha \leq 1$）
- $EMA_0 = y_1$：初始值

#### 平滑系数选择

**平滑系数与窗口大小的关系**：
$$\alpha = \frac{2}{w+1}$$

其中$w$是等效窗口大小。

#### EMA特性

1. **响应速度快**：对近期数据敏感
2. **权重递减**：权重按指数递减
3. **无滞后性**：相比SMA滞后性更小

### 2.2 EMA计算实现

```sql
-- 指数移动平均（带错误处理和性能测试）
DO $$
DECLARE
    alpha NUMERIC := 0.3;  -- 平滑系数
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行指数移动平均';
            RETURN;
        END IF;

        RAISE NOTICE '开始执行指数移动平均，平滑系数: %', alpha;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '指数移动平均准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH ema_calc AS (
    SELECT
        date,
        value,
        value AS ema,
        0.3 AS alpha
    FROM time_series
    WHERE date = (SELECT MIN(date) FROM time_series)
    UNION ALL
    SELECT
        t.date,
        t.value,
        e.ema * (1 - e.alpha) + t.value * e.alpha AS ema,
        e.alpha
    FROM time_series t
    JOIN ema_calc e ON t.date = e.date + INTERVAL '1 day'
)
SELECT * FROM ema_calc ORDER BY date;
```

---

### 2.3 双EMA（DEMA）实现

**双EMA**使用两个EMA的差值来减少滞后。

```sql
-- 双EMA（DEMA）计算
WITH ema_calc AS (
    SELECT
        date,
        value,
        -- 第一个EMA
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS ema1,
        -- 第二个EMA（对第一个EMA再计算EMA）
        AVG(AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS ema2
    FROM time_series
    WHERE value IS NOT NULL
)
SELECT
    date,
    value,
    ROUND(ema1::numeric, 2) AS ema1,
    ROUND(ema2::numeric, 2) AS ema2,
    -- DEMA = 2*EMA1 - EMA2
    ROUND((2 * ema1 - ema2)::numeric, 2) AS dema
FROM ema_calc
ORDER BY date;
```

---

## 3. 滚动统计

### 3.1 滚动统计原理

**滚动统计（Rolling Statistics）**计算窗口内的多种统计指标，用于分析数据的分布特征和变化趋势。

#### 滚动统计指标

1. **中心趋势**：均值、中位数、众数
2. **离散程度**：标准差、方差、极差
3. **分位数**：四分位数、百分位数
4. **极值**：最小值、最大值

### 3.2 滚动统计指标实现

```sql
-- 滚动统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行滚动统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行滚动统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '滚动统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_avg_30,
    STDDEV(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_stddev_30,
    MIN(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_min_30,
    MAX(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_max_30
FROM time_series
ORDER BY date;
```

---

### 3.3 滚动分位数计算

**滚动分位数**计算窗口内的分位数。

```sql
-- 滚动分位数计算
SELECT
    date,
    value,
    -- 滚动中位数（50%分位数）
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_median_30,
    -- 滚动25%分位数
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_q1_30,
    -- 滚动75%分位数
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_q3_30,
    -- 滚动四分位距（IQR）
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) - PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_iqr_30
FROM time_series
WHERE value IS NOT NULL
ORDER BY date;
```

### 3.4 滚动相关性计算

**滚动相关性**计算两个时间序列的滚动相关性。

```sql
-- 滚动相关性计算
WITH time_series_joined AS (
    SELECT
        ts1.date,
        ts1.value AS value1,
        ts2.value AS value2
    FROM time_series ts1
    JOIN time_series ts2 ON ts1.date = ts2.date
    WHERE ts1.value IS NOT NULL AND ts2.value IS NOT NULL
),
rolling_stats AS (
    SELECT
        date,
        value1,
        value2,
        AVG(value1) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS avg1,
        AVG(value2) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS avg2,
        STDDEV(value1) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS stddev1,
        STDDEV(value2) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS stddev2
    FROM time_series_joined
)
SELECT
    date,
    value1,
    value2,
    -- 滚动协方差
    AVG((value1 - avg1) * (value2 - avg2)) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_covariance_30,
    -- 滚动相关系数
    AVG((value1 - avg1) * (value2 - avg2)) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) / NULLIF(stddev1 * stddev2, 0) AS rolling_correlation_30
FROM rolling_stats
ORDER BY date;
```

---

## 4. 累积统计

### 4.1 累积统计原理

**累积统计（Cumulative Statistics）**从序列开始到当前点的统计量，用于分析数据的累积效应。

#### 累积统计类型

1. **累积和**：$C_t = \sum_{i=1}^{t}y_i$
2. **累积平均**：$\bar{C}_t = \frac{1}{t}\sum_{i=1}^{t}y_i$
3. **累积最大值/最小值**
4. **累积标准差**

### 4.2 累积统计实现

```sql
-- 累积统计计算
SELECT
    date,
    value,
    -- 累积和
    SUM(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_sum,
    -- 累积平均
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_avg,
    -- 累积最大值
    MAX(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_max,
    -- 累积最小值
    MIN(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_min,
    -- 累积标准差
    STDDEV(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_stddev
FROM time_series
WHERE value IS NOT NULL
ORDER BY date;
```

---

## 5. 实际应用案例

### 5.1 趋势分析

**趋势分析**使用滑动窗口分析趋势。

```sql
-- 趋势分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行趋势分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行趋势分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH daily_sales AS (
    SELECT
        DATE_TRUNC('day', sale_date) AS date,
        SUM(amount) AS daily_amount
    FROM sales
    GROUP BY DATE_TRUNC('day', sale_date)
)
SELECT
    date,
    daily_amount,
    AVG(daily_amount) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    daily_amount - LAG(daily_amount, 1) OVER (ORDER BY date) AS day_over_day_change,
    (daily_amount - LAG(daily_amount, 7) OVER (ORDER BY date)) / NULLIF(LAG(daily_amount, 7) OVER (ORDER BY date), 0) * 100 AS week_over_week_change_pct
FROM daily_sales
ORDER BY date;
```

### 5.2 股票价格技术分析

**场景**：使用移动平均线进行股票技术分析。

```sql
-- 股票价格技术分析：移动平均线策略
WITH daily_prices AS (
    SELECT
        DATE_TRUNC('day', trade_time) AS date,
        AVG(close_price) AS close_price,
        MAX(high_price) AS high_price,
        MIN(low_price) AS low_price,
        SUM(volume) AS volume
    FROM stock_trades
    GROUP BY DATE_TRUNC('day', trade_time)
),
technical_indicators AS (
    SELECT
        date,
        close_price,
        high_price,
        low_price,
        volume,
        -- 短期移动平均（5日）
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS ma_5,
        -- 中期移动平均（20日）
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS ma_20,
        -- 长期移动平均（60日）
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 59 PRECEDING AND CURRENT ROW
        ) AS ma_60,
        -- 布林带
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS bollinger_mid,
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) + 2 * STDDEV(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS bollinger_upper,
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) - 2 * STDDEV(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS bollinger_lower
    FROM daily_prices
)
SELECT
    date,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(ma_5::numeric, 2) AS ma_5,
    ROUND(ma_20::numeric, 2) AS ma_20,
    ROUND(ma_60::numeric, 2) AS ma_60,
    ROUND(bollinger_upper::numeric, 2) AS bollinger_upper,
    ROUND(bollinger_mid::numeric, 2) AS bollinger_mid,
    ROUND(bollinger_lower::numeric, 2) AS bollinger_lower,
    -- 交易信号
    CASE
        WHEN ma_5 > ma_20 AND LAG(ma_5) OVER (ORDER BY date) <= LAG(ma_20) OVER (ORDER BY date) THEN '买入信号'
        WHEN ma_5 < ma_20 AND LAG(ma_5) OVER (ORDER BY date) >= LAG(ma_20) OVER (ORDER BY date) THEN '卖出信号'
        WHEN close_price > bollinger_upper THEN '超买'
        WHEN close_price < bollinger_lower THEN '超卖'
        ELSE '持有'
    END AS trading_signal
FROM technical_indicators
ORDER BY date;
```

### 5.3 网站流量平滑分析

**场景**：使用滑动窗口平滑网站流量数据，识别真实趋势。

```sql
-- 网站流量平滑分析：去除噪声，识别趋势
WITH hourly_traffic AS (
    SELECT
        DATE_TRUNC('hour', visit_time) AS hour,
        COUNT(*) AS page_views,
        COUNT(DISTINCT user_id) AS unique_visitors
    FROM page_views
    GROUP BY DATE_TRUNC('hour', visit_time)
),
smoothed_traffic AS (
    SELECT
        hour,
        page_views,
        unique_visitors,
        -- 3小时移动平均
        AVG(page_views) OVER (
            ORDER BY hour
            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ) AS smoothed_pv_3h,
        -- 24小时移动平均
        AVG(page_views) OVER (
            ORDER BY hour
            ROWS BETWEEN 23 PRECEDING AND CURRENT ROW
        ) AS smoothed_pv_24h,
        -- 滚动标准差（波动性）
        STDDEV(page_views) OVER (
            ORDER BY hour
            ROWS BETWEEN 23 PRECEDING AND CURRENT ROW
        ) AS volatility_24h
    FROM hourly_traffic
)
SELECT
    hour,
    page_views,
    unique_visitors,
    ROUND(smoothed_pv_3h::numeric, 2) AS smoothed_pv_3h,
    ROUND(smoothed_pv_24h::numeric, 2) AS smoothed_pv_24h,
    ROUND(volatility_24h::numeric, 2) AS volatility_24h,
    -- 异常检测
    CASE
        WHEN ABS(page_views - smoothed_pv_24h) > 3 * volatility_24h THEN '异常'
        WHEN ABS(page_views - smoothed_pv_24h) > 2 * volatility_24h THEN '异常偏高'
        ELSE '正常'
    END AS anomaly_status
FROM smoothed_traffic
ORDER BY hour;
```

### 5.4 销售数据滚动分析

**场景**：使用滚动统计分析销售数据的趋势和波动。

```sql
-- 销售数据滚动分析：多维度统计
WITH daily_sales AS (
    SELECT
        DATE_TRUNC('day', order_date) AS date,
        SUM(order_amount) AS daily_sales,
        COUNT(*) AS order_count,
        AVG(order_amount) AS avg_order_value
    FROM orders
    GROUP BY DATE_TRUNC('day', order_date)
),
rolling_analysis AS (
    SELECT
        date,
        daily_sales,
        order_count,
        avg_order_value,
        -- 7日滚动统计
        AVG(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_avg_7,
        STDDEV(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_stddev_7,
        MIN(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_min_7,
        MAX(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_max_7,
        -- 30日滚动统计
        AVG(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS rolling_avg_30,
        -- 增长率
        (daily_sales - LAG(daily_sales, 7) OVER (ORDER BY date)) /
        NULLIF(LAG(daily_sales, 7) OVER (ORDER BY date), 0) * 100 AS week_over_week_growth
    FROM daily_sales
)
SELECT
    date,
    ROUND(daily_sales::numeric, 2) AS daily_sales,
    order_count,
    ROUND(avg_order_value::numeric, 2) AS avg_order_value,
    ROUND(rolling_avg_7::numeric, 2) AS rolling_avg_7,
    ROUND(rolling_stddev_7::numeric, 2) AS rolling_stddev_7,
    ROUND(rolling_min_7::numeric, 2) AS rolling_min_7,
    ROUND(rolling_max_7::numeric, 2) AS rolling_max_7,
    ROUND(rolling_avg_30::numeric, 2) AS rolling_avg_30,
    ROUND(COALESCE(week_over_week_growth, 0)::numeric, 2) AS wow_growth_pct,
    -- 趋势判断
    CASE
        WHEN daily_sales > rolling_avg_7 * 1.2 THEN '显著高于平均'
        WHEN daily_sales > rolling_avg_7 THEN '高于平均'
        WHEN daily_sales < rolling_avg_7 * 0.8 THEN '显著低于平均'
        WHEN daily_sales < rolling_avg_7 THEN '低于平均'
        ELSE '接近平均'
    END AS performance_status
FROM rolling_analysis
ORDER BY date;
```

---

## 6. 算法性能对比与优化

### 6.1 窗口计算方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|-----------|-----------|---------|------|------|
| **简单移动平均** | $O(n)$ | $O(w)$ | 平滑处理 | 简单直观 | 滞后性 |
| **指数移动平均** | $O(n)$ | $O(1)$ | 快速响应 | 无滞后性 | 参数选择 |
| **滚动统计** | $O(n)$ | $O(w)$ | 统计分析 | 功能全面 | 计算复杂 |
| **累积统计** | $O(n)$ | $O(1)$ | 累积分析 | 简单高效 | 受历史影响 |

### 6.2 性能优化建议

1. **计算优化**：
   - 使用窗口函数而非自连接
   - 创建时间索引
   - 使用物化视图

2. **查询优化**：
   - 限制窗口大小
   - 使用分区表
   - 并行处理

3. **算法优化**：
   - 增量计算
   - 采样计算
   - 近似方法

### 6.3 常见问题与解决方案

**问题1**：窗口大小选择困难

- **解决方案**：根据数据特征选择、使用多种窗口对比、考虑业务周期

**问题2**：计算性能问题

- **解决方案**：优化窗口函数、创建索引、使用物化视图

**问题3**：边界处理问题

- **解决方案**：使用`NULL`处理、扩展数据范围、使用`FIRST_VALUE`/`LAST_VALUE`

**问题4**：EMA初始值选择

- **解决方案**：使用第一个值、使用SMA初始化、使用自定义初始值

---

## 7. 最佳实践

### 7.1 窗口大小选择

1. **数据特征**：
   - 高频数据：小窗口
   - 低频数据：大窗口
   - 周期性数据：窗口大小等于周期

2. **业务需求**：
   - 快速响应：小窗口
   - 平滑处理：大窗口
   - 趋势分析：中等窗口

3. **经验法则**：
   - 短期趋势：5-10个周期
   - 中期趋势：20-30个周期
   - 长期趋势：60-90个周期

### 7.2 窗口函数使用注意事项

1. **性能考虑**：
   - 避免过大的窗口
   - 使用索引加速排序
   - 考虑分区

2. **准确性**：
   - 处理NULL值
   - 检查边界条件
   - 验证计算结果

3. **可维护性**：
   - 使用清晰的窗口定义
   - 添加注释
   - 模块化设计

### 7.3 SQL实现注意事项

1. **窗口框架**：
   - 明确指定框架范围
   - 理解ROWS vs RANGE
   - 处理边界情况

2. **排序**：
   - 确保排序唯一性
   - 使用稳定的排序键
   - 考虑NULL值处理

3. **分区**：
   - 合理使用PARTITION BY
   - 避免过度分区
   - 考虑分区性能

---

## 📚 参考资源

### 学术文献

1. **《时间序列分析》**（Hamilton, J. D., 1994）- 滑动窗口理论

2. **《应用时间序列分析》**（王燕, 2015）- 移动平均方法

3. **《金融时间序列分析》**（Tsay, R. S., 2005）- 技术指标分析

### PostgreSQL官方文档

- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **窗口函数语法**: <https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS>
- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>

### 在线资源

- **移动平均**: <https://en.wikipedia.org/wiki/Moving_average>
- **指数移动平均**: <https://en.wikipedia.org/wiki/Exponential_smoothing>
- **窗口函数**: <https://www.postgresqltutorial.com/postgresql-window-function/>

### 相关算法

- **时间序列预测**：基于移动平均的预测
- **趋势分析**：使用滑动窗口识别趋势
- **异常检测算法**：基于滚动统计的异常检测
- **周期性分析**：滑动窗口周期性检测

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
