# PostgreSQL 滑动窗口计算完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 滑动窗口 | 移动平均
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 滑动窗口计算完整指南](#postgresql-滑动窗口计算完整指南)
  - [📋 目录](#-目录)
  - [滑动窗口计算概述](#滑动窗口计算概述)
    - [理论基础](#理论基础)
      - [窗口函数定义](#窗口函数定义)
      - [窗口框架类型](#窗口框架类型)
      - [滑动窗口数学定义](#滑动窗口数学定义)
    - [核心窗口功能](#核心窗口功能)
  - [1. 移动平均](#1-移动平均)
    - [1.1 移动平均原理](#11-移动平均原理)
      - [简单移动平均（SMA）](#简单移动平均sma)
      - [加权移动平均（WMA）](#加权移动平均wma)
      - [移动平均特性](#移动平均特性)
    - [1.2 简单移动平均实现](#12-简单移动平均实现)
    - [1.3 加权移动平均实现](#13-加权移动平均实现)
    - [1.4 多周期移动平均对比](#14-多周期移动平均对比)
  - [2. 指数移动平均](#2-指数移动平均)
    - [2.1 指数移动平均原理](#21-指数移动平均原理)
      - [EMA数学定义](#ema数学定义)
      - [平滑系数选择](#平滑系数选择)
      - [EMA特性](#ema特性)
    - [2.2 EMA计算实现](#22-ema计算实现)
    - [2.3 双EMA（DEMA）实现](#23-双emadema实现)
  - [3. 滚动统计](#3-滚动统计)
    - [3.1 滚动统计原理](#31-滚动统计原理)
      - [滚动统计指标](#滚动统计指标)
    - [3.2 滚动统计指标实现](#32-滚动统计指标实现)
    - [3.3 滚动分位数计算](#33-滚动分位数计算)
    - [3.4 滚动相关性计算](#34-滚动相关性计算)
  - [4. 累积统计](#4-累积统计)
    - [4.1 累积统计原理](#41-累积统计原理)
      - [累积统计类型](#累积统计类型)
    - [4.2 累积统计实现](#42-累积统计实现)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 趋势分析](#51-趋势分析)
    - [5.2 股票价格技术分析](#52-股票价格技术分析)
    - [5.3 网站流量平滑分析](#53-网站流量平滑分析)
    - [5.4 销售数据滚动分析](#54-销售数据滚动分析)
  - [6. PostgreSQL 18并行滑动窗口计算](#6-postgresql-18并行滑动窗口计算)
    - [6.1 并行滑动窗口计算概述](#61-并行滑动窗口计算概述)
      - [并行滑动窗口计算配置](#并行滑动窗口计算配置)
      - [并行滑动窗口计算实现](#并行滑动窗口计算实现)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 窗口计算方法对比](#71-窗口计算方法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 窗口大小选择](#81-窗口大小选择)
    - [8.2 窗口函数使用注意事项](#82-窗口函数使用注意事项)
    - [8.3 SQL实现注意事项](#83-sql实现注意事项)
    - [8.4 PostgreSQL 18 新特性应用（增强）](#84-postgresql-18-新特性应用增强)
    - [8.5 高级优化技巧（增强）](#85-高级优化技巧增强)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 滑动窗口计算概述

**滑动窗口计算（Sliding Window Calculation）**在固定大小的窗口内进行统计计算，用于平滑处理、趋势分析和数据聚合。滑动窗口是时间序列分析中的核心技术之一，能够有效去除噪声、识别趋势和检测异常。

### 理论基础

#### 窗口函数定义

**窗口函数（Window Function）**对一组相关的行进行计算，这些行被称为"窗口"（Window）。窗口函数不会将多行合并为一行，而是为每一行返回一个值。

**窗口函数语法**：

```sql
function_name([arguments])
OVER (
    [PARTITION BY partition_expression]
    [ORDER BY sort_expression]
    [frame_clause]
)
```

#### 窗口框架类型

1. **ROWS框架**：基于行数
   - `ROWS BETWEEN n PRECEDING AND m FOLLOWING`
   - `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

2. **RANGE框架**：基于值范围
   - `RANGE BETWEEN n PRECEDING AND m FOLLOWING`
   - `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`

3. **GROUPS框架**：基于组数（PostgreSQL 11+）
   - `GROUPS BETWEEN n PRECEDING AND m FOLLOWING`

#### 滑动窗口数学定义

对于时间序列$\{y_t\}$，窗口大小为$w$的滑动窗口统计量为：
$$S_t = f(y_{t-w+1}, y_{t-w+2}, \ldots, y_t)$$

其中$f$是统计函数（如均值、标准差等）。

### 核心窗口功能

| 功能 | 用途 | 复杂度 | 数学表示 |
|------|------|--------|----------|
| **移动平均** | 平滑处理 | $O(n)$ | $\bar{y}_t = \frac{1}{w}\sum_{i=0}^{w-1}y_{t-i}$ |
| **指数移动平均** | 加权平滑 | $O(n)$ | $EMA_t = \alpha y_t + (1-\alpha)EMA_{t-1}$ |
| **滚动统计** | 窗口统计 | $O(n)$ | $S_t = f(y_{t-w+1}, \ldots, y_t)$ |
| **累积统计** | 累积计算 | $O(n)$ | $C_t = f(y_1, \ldots, y_t)$ |

---

## 1. 移动平均

### 1.1 移动平均原理

**移动平均（Moving Average, MA）**是时间序列分析中最常用的平滑技术，通过计算固定窗口内的平均值来平滑数据。

#### 简单移动平均（SMA）

**简单移动平均**：
$$SMA_t = \frac{1}{w}\sum_{i=0}^{w-1}y_{t-i}$$

其中：

- $w$：窗口大小
- $y_t$：时间$t$的观测值

#### 加权移动平均（WMA）

**加权移动平均**：
$$WMA_t = \frac{\sum_{i=0}^{w-1}w_i y_{t-i}}{\sum_{i=0}^{w-1}w_i}$$

其中$w_i$是权重，通常$w_i > w_{i+1}$（近期数据权重更大）。

#### 移动平均特性

1. **平滑效果**：窗口越大，平滑效果越强
2. **滞后性**：窗口越大，滞后性越明显
3. **去噪能力**：有效去除随机波动

### 1.2 简单移动平均实现

```sql
-- 简单移动平均（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行简单移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '移动平均准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS moving_avg_30
FROM time_series
ORDER BY date;
```

---

### 1.3 加权移动平均实现

**加权移动平均**给近期数据更高权重。

```sql
-- 加权移动平均（线性权重递减）
WITH weighted_ma AS (
    SELECT
        date,
        value,
        -- 加权移动平均：权重为 w, w-1, w-2, ..., 1
        SUM(value * (window_size - offset + 1)) OVER (
            ORDER BY date
            ROWS BETWEEN window_size - 1 PRECEDING AND CURRENT ROW
        ) / NULLIF(
            SUM(window_size - offset + 1) OVER (
                ORDER BY date
                ROWS BETWEEN window_size - 1 PRECEDING AND CURRENT ROW
            ),
            0
        ) AS weighted_ma
    FROM (
        SELECT
            date,
            value,
            7 AS window_size,
            ROW_NUMBER() OVER (ORDER BY date) -
            ROW_NUMBER() OVER (ORDER BY date) + 1 AS offset
        FROM time_series
        WHERE value IS NOT NULL
    ) AS ts
)
SELECT
    date,
    value,
    ROUND(weighted_ma::numeric, 2) AS weighted_ma_7
FROM weighted_ma
ORDER BY date;
```

### 1.4 多周期移动平均对比

**多周期移动平均**对比不同窗口大小的效果。

```sql
-- 多周期移动平均对比
SELECT
    date,
    value,
    -- 短期移动平均（7天）
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma_7,
    -- 中期移动平均（30天）
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS ma_30,
    -- 长期移动平均（90天）
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 89 PRECEDING AND CURRENT ROW
    ) AS ma_90,
    -- 趋势判断
    CASE
        WHEN AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) > AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) THEN '上升趋势'
        WHEN AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) < AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) THEN '下降趋势'
        ELSE '平稳'
    END AS trend_direction
FROM time_series
WHERE value IS NOT NULL
ORDER BY date;
```

---

## 2. 指数移动平均

### 2.1 指数移动平均原理

**指数移动平均（Exponential Moving Average, EMA）**使用指数加权，给近期数据更高权重。

#### EMA数学定义

**EMA递推公式**：
$$EMA_t = \alpha y_t + (1-\alpha)EMA_{t-1}$$

其中：

- $\alpha$：平滑系数（$0 < \alpha \leq 1$）
- $EMA_0 = y_1$：初始值

#### 平滑系数选择

**平滑系数与窗口大小的关系**：
$$\alpha = \frac{2}{w+1}$$

其中$w$是等效窗口大小。

#### EMA特性

1. **响应速度快**：对近期数据敏感
2. **权重递减**：权重按指数递减
3. **无滞后性**：相比SMA滞后性更小

### 2.2 EMA计算实现

```sql
-- 指数移动平均（带错误处理和性能测试）
DO $$
DECLARE
    alpha NUMERIC := 0.3;  -- 平滑系数
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行指数移动平均';
            RETURN;
        END IF;

        RAISE NOTICE '开始执行指数移动平均，平滑系数: %', alpha;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '指数移动平均准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH ema_calc AS (
    SELECT
        date,
        value,
        value AS ema,
        0.3 AS alpha
    FROM time_series
    WHERE date = (SELECT MIN(date) FROM time_series)
    UNION ALL
    SELECT
        t.date,
        t.value,
        e.ema * (1 - e.alpha) + t.value * e.alpha AS ema,
        e.alpha
    FROM time_series t
    JOIN ema_calc e ON t.date = e.date + INTERVAL '1 day'
)
SELECT * FROM ema_calc ORDER BY date;
```

---

### 2.3 双EMA（DEMA）实现

**双EMA**使用两个EMA的差值来减少滞后。

```sql
-- 双EMA（DEMA）计算
WITH ema_calc AS (
    SELECT
        date,
        value,
        -- 第一个EMA
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS ema1,
        -- 第二个EMA（对第一个EMA再计算EMA）
        AVG(AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )) OVER (
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS ema2
    FROM time_series
    WHERE value IS NOT NULL
)
SELECT
    date,
    value,
    ROUND(ema1::numeric, 2) AS ema1,
    ROUND(ema2::numeric, 2) AS ema2,
    -- DEMA = 2*EMA1 - EMA2
    ROUND((2 * ema1 - ema2)::numeric, 2) AS dema
FROM ema_calc
ORDER BY date;
```

---

## 3. 滚动统计

### 3.1 滚动统计原理

**滚动统计（Rolling Statistics）**计算窗口内的多种统计指标，用于分析数据的分布特征和变化趋势。

#### 滚动统计指标

1. **中心趋势**：均值、中位数、众数
2. **离散程度**：标准差、方差、极差
3. **分位数**：四分位数、百分位数
4. **极值**：最小值、最大值

### 3.2 滚动统计指标实现

```sql
-- 滚动统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行滚动统计';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行滚动统计';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '滚动统计准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_avg_30,
    STDDEV(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_stddev_30,
    MIN(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_min_30,
    MAX(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_max_30
FROM time_series
ORDER BY date;
```

---

### 3.3 滚动分位数计算

**滚动分位数**计算窗口内的分位数。

```sql
-- 滚动分位数计算
SELECT
    date,
    value,
    -- 滚动中位数（50%分位数）
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_median_30,
    -- 滚动25%分位数
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_q1_30,
    -- 滚动75%分位数
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_q3_30,
    -- 滚动四分位距（IQR）
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) - PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_iqr_30
FROM time_series
WHERE value IS NOT NULL
ORDER BY date;
```

### 3.4 滚动相关性计算

**滚动相关性**计算两个时间序列的滚动相关性。

```sql
-- 滚动相关性计算
WITH time_series_joined AS (
    SELECT
        ts1.date,
        ts1.value AS value1,
        ts2.value AS value2
    FROM time_series ts1
    JOIN time_series ts2 ON ts1.date = ts2.date
    WHERE ts1.value IS NOT NULL AND ts2.value IS NOT NULL
),
rolling_stats AS (
    SELECT
        date,
        value1,
        value2,
        AVG(value1) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS avg1,
        AVG(value2) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS avg2,
        STDDEV(value1) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS stddev1,
        STDDEV(value2) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS stddev2
    FROM time_series_joined
)
SELECT
    date,
    value1,
    value2,
    -- 滚动协方差
    AVG((value1 - avg1) * (value2 - avg2)) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS rolling_covariance_30,
    -- 滚动相关系数
    AVG((value1 - avg1) * (value2 - avg2)) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) / NULLIF(stddev1 * stddev2, 0) AS rolling_correlation_30
FROM rolling_stats
ORDER BY date;
```

---

## 4. 累积统计

### 4.1 累积统计原理

**累积统计（Cumulative Statistics）**从序列开始到当前点的统计量，用于分析数据的累积效应。

#### 累积统计类型

1. **累积和**：$C_t = \sum_{i=1}^{t}y_i$
2. **累积平均**：$\bar{C}_t = \frac{1}{t}\sum_{i=1}^{t}y_i$
3. **累积最大值/最小值**
4. **累积标准差**

### 4.2 累积统计实现

```sql
-- 累积统计计算
SELECT
    date,
    value,
    -- 累积和
    SUM(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_sum,
    -- 累积平均
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_avg,
    -- 累积最大值
    MAX(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_max,
    -- 累积最小值
    MIN(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_min,
    -- 累积标准差
    STDDEV(value) OVER (
        ORDER BY date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_stddev
FROM time_series
WHERE value IS NOT NULL
ORDER BY date;
```

---

## 5. 实际应用案例

### 5.1 趋势分析

**趋势分析**使用滑动窗口分析趋势。

```sql
-- 趋势分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行趋势分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行趋势分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH daily_sales AS (
    SELECT
        DATE_TRUNC('day', sale_date) AS date,
        SUM(amount) AS daily_amount
    FROM sales
    GROUP BY DATE_TRUNC('day', sale_date)
)
SELECT
    date,
    daily_amount,
    AVG(daily_amount) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    daily_amount - LAG(daily_amount, 1) OVER (ORDER BY date) AS day_over_day_change,
    (daily_amount - LAG(daily_amount, 7) OVER (ORDER BY date)) / NULLIF(LAG(daily_amount, 7) OVER (ORDER BY date), 0) * 100 AS week_over_week_change_pct
FROM daily_sales
ORDER BY date;
```

### 5.2 股票价格技术分析

**场景**：使用移动平均线进行股票技术分析。

```sql
-- 股票价格技术分析：移动平均线策略
WITH daily_prices AS (
    SELECT
        DATE_TRUNC('day', trade_time) AS date,
        AVG(close_price) AS close_price,
        MAX(high_price) AS high_price,
        MIN(low_price) AS low_price,
        SUM(volume) AS volume
    FROM stock_trades
    GROUP BY DATE_TRUNC('day', trade_time)
),
technical_indicators AS (
    SELECT
        date,
        close_price,
        high_price,
        low_price,
        volume,
        -- 短期移动平均（5日）
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS ma_5,
        -- 中期移动平均（20日）
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS ma_20,
        -- 长期移动平均（60日）
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 59 PRECEDING AND CURRENT ROW
        ) AS ma_60,
        -- 布林带
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS bollinger_mid,
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) + 2 * STDDEV(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS bollinger_upper,
        AVG(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) - 2 * STDDEV(close_price) OVER (
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS bollinger_lower
    FROM daily_prices
)
SELECT
    date,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(ma_5::numeric, 2) AS ma_5,
    ROUND(ma_20::numeric, 2) AS ma_20,
    ROUND(ma_60::numeric, 2) AS ma_60,
    ROUND(bollinger_upper::numeric, 2) AS bollinger_upper,
    ROUND(bollinger_mid::numeric, 2) AS bollinger_mid,
    ROUND(bollinger_lower::numeric, 2) AS bollinger_lower,
    -- 交易信号
    CASE
        WHEN ma_5 > ma_20 AND LAG(ma_5) OVER (ORDER BY date) <= LAG(ma_20) OVER (ORDER BY date) THEN '买入信号'
        WHEN ma_5 < ma_20 AND LAG(ma_5) OVER (ORDER BY date) >= LAG(ma_20) OVER (ORDER BY date) THEN '卖出信号'
        WHEN close_price > bollinger_upper THEN '超买'
        WHEN close_price < bollinger_lower THEN '超卖'
        ELSE '持有'
    END AS trading_signal
FROM technical_indicators
ORDER BY date;
```

### 5.3 网站流量平滑分析

**场景**：使用滑动窗口平滑网站流量数据，识别真实趋势。

```sql
-- 网站流量平滑分析：去除噪声，识别趋势
WITH hourly_traffic AS (
    SELECT
        DATE_TRUNC('hour', visit_time) AS hour,
        COUNT(*) AS page_views,
        COUNT(DISTINCT user_id) AS unique_visitors
    FROM page_views
    GROUP BY DATE_TRUNC('hour', visit_time)
),
smoothed_traffic AS (
    SELECT
        hour,
        page_views,
        unique_visitors,
        -- 3小时移动平均
        AVG(page_views) OVER (
            ORDER BY hour
            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ) AS smoothed_pv_3h,
        -- 24小时移动平均
        AVG(page_views) OVER (
            ORDER BY hour
            ROWS BETWEEN 23 PRECEDING AND CURRENT ROW
        ) AS smoothed_pv_24h,
        -- 滚动标准差（波动性）
        STDDEV(page_views) OVER (
            ORDER BY hour
            ROWS BETWEEN 23 PRECEDING AND CURRENT ROW
        ) AS volatility_24h
    FROM hourly_traffic
)
SELECT
    hour,
    page_views,
    unique_visitors,
    ROUND(smoothed_pv_3h::numeric, 2) AS smoothed_pv_3h,
    ROUND(smoothed_pv_24h::numeric, 2) AS smoothed_pv_24h,
    ROUND(volatility_24h::numeric, 2) AS volatility_24h,
    -- 异常检测
    CASE
        WHEN ABS(page_views - smoothed_pv_24h) > 3 * volatility_24h THEN '异常'
        WHEN ABS(page_views - smoothed_pv_24h) > 2 * volatility_24h THEN '异常偏高'
        ELSE '正常'
    END AS anomaly_status
FROM smoothed_traffic
ORDER BY hour;
```

### 5.4 销售数据滚动分析

**场景**：使用滚动统计分析销售数据的趋势和波动。

```sql
-- 销售数据滚动分析：多维度统计
WITH daily_sales AS (
    SELECT
        DATE_TRUNC('day', order_date) AS date,
        SUM(order_amount) AS daily_sales,
        COUNT(*) AS order_count,
        AVG(order_amount) AS avg_order_value
    FROM orders
    GROUP BY DATE_TRUNC('day', order_date)
),
rolling_analysis AS (
    SELECT
        date,
        daily_sales,
        order_count,
        avg_order_value,
        -- 7日滚动统计
        AVG(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_avg_7,
        STDDEV(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_stddev_7,
        MIN(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_min_7,
        MAX(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS rolling_max_7,
        -- 30日滚动统计
        AVG(daily_sales) OVER (
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS rolling_avg_30,
        -- 增长率
        (daily_sales - LAG(daily_sales, 7) OVER (ORDER BY date)) /
        NULLIF(LAG(daily_sales, 7) OVER (ORDER BY date), 0) * 100 AS week_over_week_growth
    FROM daily_sales
)
SELECT
    date,
    ROUND(daily_sales::numeric, 2) AS daily_sales,
    order_count,
    ROUND(avg_order_value::numeric, 2) AS avg_order_value,
    ROUND(rolling_avg_7::numeric, 2) AS rolling_avg_7,
    ROUND(rolling_stddev_7::numeric, 2) AS rolling_stddev_7,
    ROUND(rolling_min_7::numeric, 2) AS rolling_min_7,
    ROUND(rolling_max_7::numeric, 2) AS rolling_max_7,
    ROUND(rolling_avg_30::numeric, 2) AS rolling_avg_30,
    ROUND(COALESCE(week_over_week_growth, 0)::numeric, 2) AS wow_growth_pct,
    -- 趋势判断
    CASE
        WHEN daily_sales > rolling_avg_7 * 1.2 THEN '显著高于平均'
        WHEN daily_sales > rolling_avg_7 THEN '高于平均'
        WHEN daily_sales < rolling_avg_7 * 0.8 THEN '显著低于平均'
        WHEN daily_sales < rolling_avg_7 THEN '低于平均'
        ELSE '接近平均'
    END AS performance_status
FROM rolling_analysis
ORDER BY date;
```

---

## 6. PostgreSQL 18并行滑动窗口计算

### 6.1 并行滑动窗口计算概述

**PostgreSQL 18并行滑动窗口计算**：利用PostgreSQL 18的并行查询能力，显著提升大规模滑动窗口计算的性能。

#### 并行滑动窗口计算配置

```sql
-- 配置并行滑动窗口计算参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行聚合成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行滑动窗口计算参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行滑动窗口计算配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 并行滑动窗口计算实现

```sql
-- 并行滑动窗口计算：大规模时间序列移动平均（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行滑动窗口计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行滑动窗口计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行多窗口移动平均
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    time_series_id,
    timestamp,
    value,
    AVG(value) OVER (
        PARTITION BY time_series_id
        ORDER BY timestamp
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma_7,
    AVG(value) OVER (
        PARTITION BY time_series_id
        ORDER BY timestamp
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS ma_30,
    STDDEV(value) OVER (
        PARTITION BY time_series_id
        ORDER BY timestamp
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS stddev_7
FROM time_series_data
WHERE timestamp >= CURRENT_DATE - INTERVAL '1 year'
ORDER BY time_series_id, timestamp DESC;
```

---

## 7. 算法性能对比与优化

### 7.1 窗口计算方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|-----------|-----------|---------|------|------|
| **简单移动平均** | $O(n)$ | $O(w)$ | 平滑处理 | 简单直观 | 滞后性 |
| **指数移动平均** | $O(n)$ | $O(1)$ | 快速响应 | 无滞后性 | 参数选择 |
| **滚动统计** | $O(n)$ | $O(w)$ | 统计分析 | 功能全面 | 计算复杂 |
| **累积统计** | $O(n)$ | $O(1)$ | 累积分析 | 简单高效 | 受历史影响 |

### 7.2 性能优化建议

1. **计算优化**：
   - 使用窗口函数而非自连接
   - 创建时间索引
   - 使用物化视图

2. **查询优化**：
   - 限制窗口大小
   - 使用分区表
   - 并行处理

3. **算法优化**：
   - 增量计算
   - 采样计算
   - 近似方法

### 7.3 常见问题与解决方案

**问题1**：窗口大小选择困难

- **解决方案**：根据数据特征选择、使用多种窗口对比、考虑业务周期

**问题2**：计算性能问题

- **解决方案**：优化窗口函数、创建索引、使用物化视图

**问题3**：边界处理问题

- **解决方案**：使用`NULL`处理、扩展数据范围、使用`FIRST_VALUE`/`LAST_VALUE`

**问题4**：EMA初始值选择

- **解决方案**：使用第一个值、使用SMA初始化、使用自定义初始值

---

## 8. 最佳实践

### 8.1 窗口大小选择

1. **数据特征**：
   - 高频数据：小窗口
   - 低频数据：大窗口
   - 周期性数据：窗口大小等于周期

2. **业务需求**：
   - 快速响应：小窗口
   - 平滑处理：大窗口
   - 趋势分析：中等窗口

3. **经验法则**：
   - 短期趋势：5-10个周期
   - 中期趋势：20-30个周期
   - 长期趋势：60-90个周期

### 8.2 窗口函数使用注意事项

1. **性能考虑**：
   - 避免过大的窗口
   - 使用索引加速排序
   - 考虑分区

2. **准确性**：
   - 处理NULL值
   - 检查边界条件
   - 验证计算结果

3. **可维护性**：
   - 使用清晰的窗口定义
   - 添加注释
   - 模块化设计

### 8.3 SQL实现注意事项

1. **窗口框架**：
   - 明确指定框架范围
   - 理解ROWS vs RANGE
   - 处理边界情况

2. **排序**：
   - 确保排序唯一性
   - 使用稳定的排序键
   - 考虑NULL值处理

3. **分区**：
   - 合理使用PARTITION BY
   - 避免过度分区
   - 考虑分区性能

### 8.4 PostgreSQL 18 新特性应用（增强）

**PostgreSQL 18**引入了多项增强功能，可以显著提升滑动窗口计算的性能：

1. **Skip Scan优化**：
   - 对于包含时间戳的索引，Skip Scan可以跳过不必要的索引扫描
   - 特别适用于Top-N滑动窗口查询和多窗口移动平均查询

2. **异步I/O增强**：
   - 对于大规模滑动窗口计算，异步I/O可以显著提升性能
   - 适用于批量移动平均和多窗口滚动统计

3. **并行查询增强**：
   - 滑动窗口计算支持更好的并行执行（已在6节详细说明）
   - 适用于大规模时间序列滑动窗口分析

**示例：使用Skip Scan优化滑动窗口查询**

```sql
-- 为滑动窗口计算创建Skip Scan优化索引
CREATE INDEX IF NOT EXISTS idx_sliding_window_skip_scan
ON time_series(time_series_id, timestamp DESC, value DESC);

-- Skip Scan优化查询：查找每个时间序列最新时间点的前5个最高值
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (time_series_id)
    time_series_id,
    timestamp,
    value,
    AVG(value) OVER (
        PARTITION BY time_series_id
        ORDER BY timestamp
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS ma_7
FROM time_series
ORDER BY time_series_id, timestamp DESC
LIMIT 50;
```

### 8.5 高级优化技巧（增强）

**1. 使用物化视图缓存滑动窗口计算结果**

对于频繁使用的滑动窗口计算结果，使用物化视图缓存：

```sql
-- 创建物化视图缓存滑动窗口计算结果
CREATE MATERIALIZED VIEW IF NOT EXISTS sliding_window_cache AS
WITH window_statistics AS (
    SELECT
        time_series_id,
        timestamp,
        value,
        -- 多个窗口大小同时计算（避免重复扫描）
        AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS ma_7,
        AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS ma_30,
        STDDEV(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS stddev_7,
        -- 使用窗口函数计算趋势（避免重复计算）
        CASE
            WHEN LAG(AVG(value) OVER (
                PARTITION BY time_series_id
                ORDER BY timestamp
                ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
            )) OVER (
                PARTITION BY time_series_id
                ORDER BY timestamp
            ) > 0 THEN
                (AVG(value) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
                ) - LAG(AVG(value) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
                )) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                )) / LAG(AVG(value) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
                )) OVER (
                    PARTITION BY time_series_id
                    ORDER BY timestamp
                ) * 100
            ELSE NULL
        END AS ma_7_change_pct
    FROM time_series
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '90 days'
)
SELECT
    time_series_id,
    timestamp,
    value,
    ROUND(ma_7::numeric, 4) AS ma_7,
    ROUND(ma_30::numeric, 4) AS ma_30,
    ROUND(stddev_7::numeric, 4) AS stddev_7,
    ROUND(ma_7_change_pct::numeric, 2) AS ma_7_change_pct,
    CASE
        WHEN ma_7_change_pct > 10 THEN 'Significant Increase'
        WHEN ma_7_change_pct > 5 THEN 'Moderate Increase'
        WHEN ma_7_change_pct < -10 THEN 'Significant Decrease'
        WHEN ma_7_change_pct < -5 THEN 'Moderate Decrease'
        ELSE 'Stable'
    END AS trend_status
FROM window_statistics
ORDER BY time_series_id, timestamp DESC;

-- 创建索引加速物化视图查询
CREATE INDEX idx_sliding_window_cache_ts_time ON sliding_window_cache(time_series_id, timestamp DESC);
CREATE INDEX idx_sliding_window_cache_trend ON sliding_window_cache(trend_status, ma_7_change_pct DESC);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY sliding_window_cache;
```

**2. 实时滑动窗口计算：增量窗口更新**

**实时滑动窗口计算**：对于实时数据，使用增量方法更新滑动窗口结果。

```sql
-- 实时滑动窗口计算：增量窗口更新（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sliding_window_state') THEN
            CREATE TABLE sliding_window_state (
                time_series_id VARCHAR(100) NOT NULL,
                window_type VARCHAR(50) NOT NULL,  -- 'ma_7', 'ma_30', 'ema'
                window_size INTEGER NOT NULL,
                last_timestamp TIMESTAMPTZ NOT NULL,
                window_values NUMERIC[] DEFAULT '{}',
                current_value NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (time_series_id, window_type, window_size)
            );

            CREATE INDEX idx_sliding_window_state_ts_time ON sliding_window_state(time_series_id, last_timestamp DESC);
            CREATE INDEX idx_sliding_window_state_updated ON sliding_window_state(last_updated DESC);

            RAISE NOTICE '滑动窗口状态表创建成功';
        END IF;

        RAISE NOTICE '开始执行增量滑动窗口更新';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '增量滑动窗口更新准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 增量更新滑动窗口：实时滑动窗口计算
WITH new_time_series_data AS (
    SELECT
        time_series_id,
        timestamp,
        value
    FROM time_series
    WHERE timestamp > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM sliding_window_state)
      AND timestamp <= CURRENT_TIMESTAMP
),
updated_windows AS (
    SELECT
        COALESCE(sws.time_series_id, ntsd.time_series_id) AS time_series_id,
        'ma_7' AS window_type,
        7 AS window_size,
        MAX(ntsd.timestamp) AS new_last_timestamp,
        ARRAY_AGG(ntsd.value ORDER BY ntsd.timestamp DESC) || COALESCE(sws.window_values, '{}') AS new_window_values,
        -- 保持窗口大小，移除最旧的值
        (
            SELECT ARRAY_AGG(val ORDER BY idx)
            FROM (
                SELECT val, row_number() OVER (ORDER BY idx DESC) AS rn
                FROM unnest(ARRAY_AGG(ntsd.value ORDER BY ntsd.timestamp DESC) || COALESCE(sws.window_values, '{}')) WITH ORDINALITY AS t(val, idx)
            ) AS ranked
            WHERE rn <= 7
        ) AS trimmed_window_values,
        AVG(ntsd.value) AS new_current_value
    FROM sliding_window_state sws
    FULL OUTER JOIN new_time_series_data ntsd ON sws.time_series_id = ntsd.time_series_id AND sws.window_type = 'ma_7' AND sws.window_size = 7
    GROUP BY sws.time_series_id, ntsd.time_series_id, sws.window_values
)
-- 更新或插入滑动窗口状态
INSERT INTO sliding_window_state (
    time_series_id,
    window_type,
    window_size,
    last_timestamp,
    window_values,
    current_value,
    last_updated
)
SELECT
    time_series_id,
    window_type,
    window_size,
    new_last_timestamp,
    trimmed_window_values,
    new_current_value,
    NOW()
FROM updated_windows
ON CONFLICT (time_series_id, window_type, window_size)
DO UPDATE SET
    last_timestamp = EXCLUDED.last_timestamp,
    window_values = EXCLUDED.window_values,
    current_value = EXCLUDED.current_value,
    last_updated = NOW();
```

**3. 智能滑动窗口：自适应窗口大小选择**

**智能滑动窗口**：根据数据特征自动选择最优窗口大小。

```sql
-- 智能滑动窗口：自适应窗口大小选择（带错误处理和性能测试）
DO $$
DECLARE
    data_volatility NUMERIC;
    data_frequency NUMERIC;
    recommended_window_size INTEGER;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行智能滑动窗口';
            RETURN;
        END IF;

        -- 计算数据特征
        SELECT
            STDDEV(value) / NULLIF(AVG(value), 0),
            COUNT(*) / EXTRACT(EPOCH FROM (MAX(timestamp) - MIN(timestamp))) * 86400  -- 每天的数据点
        INTO data_volatility, data_frequency
        FROM time_series
        WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '30 days';

        -- 根据数据特征自适应选择窗口大小
        IF data_volatility > 0.5 AND data_frequency > 24 THEN
            recommended_window_size := 3;  -- 高波动高频率：小窗口
        ELSIF data_volatility > 0.3 AND data_frequency > 12 THEN
            recommended_window_size := 7;  -- 中波动中频率：中窗口
        ELSE
            recommended_window_size := 30;  -- 低波动低频率：大窗口
        END IF;

        RAISE NOTICE '数据波动率: %, 数据频率: %, 推荐窗口大小: %',
            data_volatility, data_frequency, recommended_window_size;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '智能滑动窗口准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 智能滑动窗口：根据策略选择不同的窗口大小
WITH data_characteristics AS (
    SELECT
        time_series_id,
        STDDEV(value) / NULLIF(AVG(value), 0) AS volatility,
        COUNT(*) / EXTRACT(EPOCH FROM (MAX(timestamp) - MIN(timestamp))) * 86400 AS frequency
    FROM time_series
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '30 days'
    GROUP BY time_series_id
),
adaptive_windows AS (
    SELECT
        time_series_id,
        timestamp,
        value,
        CASE
            WHEN volatility > 0.5 AND frequency > 24 THEN 3
            WHEN volatility > 0.3 AND frequency > 12 THEN 7
            ELSE 30
        END AS adaptive_window_size,
        -- 使用窗口函数计算自适应移动平均（避免重复计算）
        AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN
                CASE
                    WHEN volatility > 0.5 AND frequency > 24 THEN 2
                    WHEN volatility > 0.3 AND frequency > 12 THEN 6
                    ELSE 29
                END PRECEDING AND CURRENT ROW
        ) AS adaptive_ma
    FROM time_series
    JOIN data_characteristics USING (time_series_id)
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '30 days'
)
SELECT
    time_series_id,
    timestamp,
    value,
    adaptive_window_size,
    ROUND(adaptive_ma::numeric, 4) AS adaptive_ma,
    -- 使用窗口函数计算趋势（避免重复计算）
    CASE
        WHEN adaptive_ma > LAG(adaptive_ma) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
        ) THEN 'Upward'
        WHEN adaptive_ma < LAG(adaptive_ma) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
        ) THEN 'Downward'
        ELSE 'Stable'
    END AS trend_direction
FROM adaptive_windows
ORDER BY time_series_id, timestamp DESC
LIMIT 100;
```

---

## 📚 参考资源

### 学术文献

1. **《时间序列分析》**（Hamilton, J. D., 1994）- 滑动窗口理论

2. **《应用时间序列分析》**（王燕, 2015）- 移动平均方法

3. **《金融时间序列分析》**（Tsay, R. S., 2005）- 技术指标分析

### PostgreSQL官方文档

- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **窗口函数语法**: <https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS>
- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>

### 在线资源

- **移动平均**: <https://en.wikipedia.org/wiki/Moving_average>
- **指数移动平均**: <https://en.wikipedia.org/wiki/Exponential_smoothing>
- **窗口函数**: <https://www.postgresqltutorial.com/postgresql-window-function/>

### 相关算法

- **时间序列预测**：基于移动平均的预测
- **趋势分析**：使用滑动窗口识别趋势
- **异常检测算法**：基于滚动统计的异常检测
- **周期性分析**：滑动窗口周期性检测

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
