# PostgreSQL 周期性分析完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 周期性分析 | 季节分解
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 周期性分析完整指南](#postgresql-周期性分析完整指南)
  - [📋 目录](#-目录)
  - [周期性分析概述](#周期性分析概述)
    - [理论基础](#理论基础)
      - [周期性定义](#周期性定义)
      - [周期类型](#周期类型)
      - [周期性检测方法](#周期性检测方法)
    - [核心周期类型](#核心周期类型)
  - [1. 日周期分析](#1-日周期分析)
    - [1.1 日周期原理](#11-日周期原理)
      - [日周期特征](#日周期特征)
      - [日周期检测](#日周期检测)
    - [1.2 小时模式分析实现](#12-小时模式分析实现)
    - [1.3 日周期强度分析](#13-日周期强度分析)
    - [1.4 时段模式分析](#14-时段模式分析)
  - [2. 周周期分析](#2-周周期分析)
    - [2.1 周周期原理](#21-周周期原理)
      - [周周期特征](#周周期特征)
      - [周周期检测](#周周期检测)
    - [2.2 星期模式分析实现](#22-星期模式分析实现)
    - [2.3 工作日vs周末分析](#23-工作日vs周末分析)
    - [2.4 周内趋势分析](#24-周内趋势分析)
  - [3. 月周期分析](#3-月周期分析)
    - [3.1 月周期原理](#31-月周期原理)
      - [月周期特征](#月周期特征)
    - [3.2 月份模式分析实现](#32-月份模式分析实现)
    - [3.3 月初/月中/月末分析](#33-月初月中月末分析)
  - [4. 季节分解](#4-季节分解)
    - [4.1 季节分解原理](#41-季节分解原理)
      - [分解模型](#分解模型)
      - [分解方法](#分解方法)
    - [4.2 季节性分解实现](#42-季节性分解实现)
    - [4.3 季节指数计算](#43-季节指数计算)
  - [5. 自相关分析](#5-自相关分析)
    - [5.1 自相关函数（ACF）](#51-自相关函数acf)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 多周期综合分析](#61-多周期综合分析)
    - [6.2 网站流量周期性分析](#62-网站流量周期性分析)
    - [6.3 销售数据季节性分析](#63-销售数据季节性分析)
    - [6.4 用户行为周期性分析](#64-用户行为周期性分析)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 周期性检测方法对比](#71-周期性检测方法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 周期分析方法选择](#81-周期分析方法选择)
    - [8.2 周期性分析注意事项](#82-周期性分析注意事项)
    - [8.3 SQL实现注意事项](#83-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 周期性分析概述

**周期性分析（Periodicity Analysis）**识别时间序列数据中的周期性规律，用于理解数据的周期性模式、预测未来走势和优化业务决策。周期性是时间序列数据的重要特征之一，反映了数据在固定时间间隔内的重复模式。

### 理论基础

#### 周期性定义

**周期性（Periodicity）**是指时间序列数据在固定时间间隔内重复出现的模式。在时间序列分解模型中：
$$Y_t = T_t + S_t + C_t + I_t$$

其中：

- $T_t$：趋势成分（Trend）
- $S_t$：季节成分（Seasonal）- 固定周期的周期性模式
- $C_t$：循环成分（Cyclical）- 非固定周期的周期性模式
- $I_t$：不规则成分（Irregular）

#### 周期类型

1. **日周期（Daily Cycle）**：24小时内的重复模式
   - 小时模式：一天内不同小时的变化
   - 分钟模式：一小时内不同分钟的变化

2. **周周期（Weekly Cycle）**：7天内的重复模式
   - 工作日vs周末
   - 星期几模式

3. **月周期（Monthly Cycle）**：一个月内的重复模式
   - 月初、月中、月末模式
   - 日期模式（如发薪日）

4. **季节周期（Seasonal Cycle）**：一年内的重复模式
   - 季度模式
   - 月份模式
   - 节假日模式

#### 周期性检测方法

1. **时域方法**：
   - 自相关函数（ACF）
   - 偏自相关函数（PACF）
   - 周期图分析

2. **频域方法**：
   - 傅里叶变换
   - 功率谱密度
   - 小波变换

3. **统计方法**：
   - 方差分析（ANOVA）
   - Kruskal-Wallis检验
   - 周期回归

### 核心周期类型

| 周期类型 | 周期长度 | 用途 | 复杂度 | 数学表示 |
|---------|---------|------|--------|----------|
| **日周期** | 24小时 | 日内模式 | $O(n)$ | $S_{d,h} = f(h)$ |
| **周周期** | 7天 | 周内模式 | $O(n)$ | $S_{w,d} = f(d)$ |
| **月周期** | 28-31天 | 月内模式 | $O(n)$ | $S_{m,d} = f(d)$ |
| **季节周期** | 365天 | 季节性模式 | $O(n)$ | $S_{y,m} = f(m)$ |

---

## 1. 日周期分析

### 1.1 日周期原理

**日周期分析（Daily Cycle Analysis）**识别一天内的周期性模式，通常以小时为单位进行分析。

#### 日周期特征

1. **小时模式**：不同小时的数据分布
2. **分钟模式**：不同分钟的数据分布
3. **时段模式**：早晨、中午、晚上等时段

#### 日周期检测

**自相关分析**：
$$r_k = \frac{\sum_{t=1}^{n-k}(y_t - \bar{y})(y_{t+k} - \bar{y})}{\sum_{t=1}^{n}(y_t - \bar{y})^2}$$

其中$k$是滞后阶数，$r_{24}$表示24小时周期的自相关。

### 1.2 小时模式分析实现

```sql
-- 日周期分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行日周期分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行日周期分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '日周期分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    EXTRACT(HOUR FROM timestamp) AS hour_of_day,
    COUNT(*) AS count,
    AVG(value) AS avg_value,
    STDDEV(value) AS stddev_value,
    MIN(value) AS min_value,
    MAX(value) AS max_value
FROM metrics
GROUP BY EXTRACT(HOUR FROM timestamp)
ORDER BY hour_of_day;
```

---

### 1.3 日周期强度分析

**周期强度**评估日周期的显著程度。

```sql
-- 日周期强度分析：使用方差分析
WITH hourly_stats AS (
    SELECT
        EXTRACT(HOUR FROM timestamp) AS hour,
        value,
        AVG(value) OVER () AS overall_mean,
        AVG(value) OVER (PARTITION BY EXTRACT(HOUR FROM timestamp)) AS hour_mean
    FROM metrics
    WHERE value IS NOT NULL
),
anova_stats AS (
    SELECT
        -- 组间平方和（SSB）
        SUM(POWER(hour_mean - overall_mean, 2)) AS ssb,
        -- 组内平方和（SSW）
        SUM(POWER(value - hour_mean, 2)) AS ssw,
        COUNT(DISTINCT hour) AS k,
        COUNT(*) AS n
    FROM hourly_stats
)
SELECT
    ssb,
    ssw,
    -- F统计量
    (ssb / NULLIF(k - 1, 0)) / NULLIF(ssw / NULLIF(n - k, 0), 0) AS f_statistic,
    -- 周期强度（R²）
    1 - ssw / NULLIF(ssb + ssw, 0) AS periodicity_strength
FROM anova_stats;
```

### 1.4 时段模式分析

**时段模式**识别一天中的不同时段特征。

```sql
-- 时段模式分析：早晨、中午、晚上等时段
SELECT
    CASE
        WHEN EXTRACT(HOUR FROM timestamp) BETWEEN 6 AND 11 THEN '早晨 (6-11)'
        WHEN EXTRACT(HOUR FROM timestamp) BETWEEN 12 AND 17 THEN '中午 (12-17)'
        WHEN EXTRACT(HOUR FROM timestamp) BETWEEN 18 AND 22 THEN '晚上 (18-22)'
        ELSE '深夜 (23-5)'
    END AS time_period,
    COUNT(*) AS count,
    AVG(value) AS avg_value,
    STDDEV(value) AS stddev_value,
    MIN(value) AS min_value,
    MAX(value) AS max_value,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) AS median_value
FROM metrics
WHERE value IS NOT NULL
GROUP BY time_period
ORDER BY
    CASE time_period
        WHEN '早晨 (6-11)' THEN 1
        WHEN '中午 (12-17)' THEN 2
        WHEN '晚上 (18-22)' THEN 3
        ELSE 4
    END;
```

---

## 2. 周周期分析

### 2.1 周周期原理

**周周期分析（Weekly Cycle Analysis）**识别一周内的周期性模式，通常以天为单位进行分析。

#### 周周期特征

1. **工作日vs周末**：工作日和周末的差异
2. **星期几模式**：不同星期几的特征
3. **周内趋势**：一周内的变化趋势

#### 周周期检测

**星期模式分析**：
$$S_d = \frac{1}{n}\sum_{i=1}^{n}y_{d,i}$$

其中$d$是星期几（0-6），$n$是该星期几的总数。

### 2.2 星期模式分析实现

```sql
-- 周周期分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行周周期分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行周周期分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '周周期分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    EXTRACT(DOW FROM sale_date) AS day_of_week,
    CASE EXTRACT(DOW FROM sale_date)
        WHEN 0 THEN 'Sunday'
        WHEN 1 THEN 'Monday'
        WHEN 2 THEN 'Tuesday'
        WHEN 3 THEN 'Wednesday'
        WHEN 4 THEN 'Thursday'
        WHEN 5 THEN 'Friday'
        WHEN 6 THEN 'Saturday'
    END AS day_name,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY EXTRACT(DOW FROM sale_date)
ORDER BY day_of_week;
```

---

### 2.3 工作日vs周末分析

**工作日vs周末**对比分析工作日和周末的差异。

```sql
-- 工作日vs周末分析
WITH day_classification AS (
    SELECT
        sale_date,
        amount,
        CASE
            WHEN EXTRACT(DOW FROM sale_date) IN (0, 6) THEN '周末'
            ELSE '工作日'
        END AS day_type,
        EXTRACT(DOW FROM sale_date) AS day_of_week
    FROM sales
)
SELECT
    day_type,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    STDDEV(amount) AS stddev_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount
FROM day_classification
GROUP BY day_type
ORDER BY day_type;
```

### 2.4 周内趋势分析

**周内趋势**分析一周内的变化趋势。

```sql
-- 周内趋势分析：识别周内的高峰和低谷
WITH weekly_pattern AS (
    SELECT
        EXTRACT(DOW FROM sale_date) AS day_of_week,
        CASE EXTRACT(DOW FROM sale_date)
            WHEN 0 THEN 'Sunday'
            WHEN 1 THEN 'Monday'
            WHEN 2 THEN 'Tuesday'
            WHEN 3 THEN 'Wednesday'
            WHEN 4 THEN 'Thursday'
            WHEN 5 THEN 'Friday'
            WHEN 6 THEN 'Saturday'
        END AS day_name,
        AVG(amount) AS avg_amount,
        COUNT(*) AS count
    FROM sales
    GROUP BY EXTRACT(DOW FROM sale_date)
),
trend_analysis AS (
    SELECT
        day_of_week,
        day_name,
        avg_amount,
        LAG(avg_amount) OVER (ORDER BY day_of_week) AS prev_day_avg,
        LEAD(avg_amount) OVER (ORDER BY day_of_week) AS next_day_avg
    FROM weekly_pattern
)
SELECT
    day_of_week,
    day_name,
    ROUND(avg_amount::numeric, 2) AS avg_amount,
    -- 趋势方向
    CASE
        WHEN avg_amount > COALESCE(prev_day_avg, avg_amount) AND
             avg_amount > COALESCE(next_day_avg, avg_amount) THEN '高峰'
        WHEN avg_amount < COALESCE(prev_day_avg, avg_amount) AND
             avg_amount < COALESCE(next_day_avg, avg_amount) THEN '低谷'
        WHEN avg_amount > COALESCE(prev_day_avg, avg_amount) THEN '上升'
        ELSE '下降'
    END AS trend_direction,
    -- 变化率
    ROUND(
        (avg_amount - COALESCE(prev_day_avg, avg_amount)) /
        NULLIF(COALESCE(prev_day_avg, avg_amount), 0) * 100,
        2
    ) AS change_rate_pct
FROM trend_analysis
ORDER BY day_of_week;
```

---

## 3. 月周期分析

### 3.1 月周期原理

**月周期分析（Monthly Cycle Analysis）**识别一个月内的周期性模式，通常以天为单位进行分析。

#### 月周期特征

1. **月初、月中、月末模式**：不同时间段的变化
2. **日期模式**：特定日期（如发薪日）的特征
3. **工作日数量**：不同月份工作日数量的影响

### 3.2 月份模式分析实现

```sql
-- 月周期分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行月周期分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行月周期分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '月周期分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    EXTRACT(DAY FROM sale_date) AS day_of_month,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY EXTRACT(DAY FROM sale_date)
ORDER BY day_of_month;
```

---

### 3.3 月初/月中/月末分析

**月初/月中/月末**分析不同时间段的变化模式。

```sql
-- 月初/月中/月末分析
WITH monthly_segments AS (
    SELECT
        sale_date,
        amount,
        EXTRACT(DAY FROM sale_date) AS day_of_month,
        CASE
            WHEN EXTRACT(DAY FROM sale_date) <= 10 THEN '月初 (1-10)'
            WHEN EXTRACT(DAY FROM sale_date) <= 20 THEN '月中 (11-20)'
            ELSE '月末 (21-31)'
        END AS month_segment
    FROM sales
)
SELECT
    month_segment,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    STDDEV(amount) AS stddev_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount
FROM monthly_segments
GROUP BY month_segment
ORDER BY
    CASE month_segment
        WHEN '月初 (1-10)' THEN 1
        WHEN '月中 (11-20)' THEN 2
        ELSE 3
    END;
```

---

## 4. 季节分解

### 4.1 季节分解原理

**季节分解（Seasonal Decomposition）**将时间序列分解为趋势、季节性和残差成分，用于理解数据的结构和预测。

#### 分解模型

**加法模型**：
$$Y_t = T_t + S_t + I_t$$

**乘法模型**：
$$Y_t = T_t \times S_t \times I_t$$

其中：

- $T_t$：趋势成分
- $S_t$：季节成分
- $I_t$：残差成分

#### 分解方法

1. **移动平均法**：使用移动平均提取趋势
2. **X-13ARIMA-SEATS**：官方季节调整方法
3. **STL分解**：使用LOESS的季节和趋势分解

### 4.2 季节性分解实现

```sql
-- 季节分解（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING '表 time_series 不存在，无法执行季节分解';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行季节分解';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '季节分解准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH monthly_data AS (
    SELECT
        DATE_TRUNC('month', date) AS month,
        AVG(value) AS monthly_avg
    FROM time_series
    GROUP BY DATE_TRUNC('month', date)
),
trend AS (
    SELECT
        month,
        monthly_avg,
        AVG(monthly_avg) OVER (
            ORDER BY month
            ROWS BETWEEN 5 PRECEDING AND 5 FOLLOWING
        ) AS trend_value
    FROM monthly_data
),
seasonal AS (
    SELECT
        EXTRACT(MONTH FROM month) AS month_num,
        AVG(monthly_avg - trend_value) AS seasonal_component
    FROM trend
    GROUP BY EXTRACT(MONTH FROM month)
)
SELECT
    t.month,
    t.monthly_avg AS original_value,
    t.trend_value,
    s.seasonal_component,
    t.monthly_avg - t.trend_value - s.seasonal_component AS residual
FROM trend t
JOIN seasonal s ON EXTRACT(MONTH FROM t.month) = s.month_num
ORDER BY t.month;
```

---

### 4.3 季节指数计算

**季节指数**量化季节性的强度。

```sql
-- 季节指数计算：量化每个月的季节性强度
WITH monthly_data AS (
    SELECT
        DATE_TRUNC('month', date) AS month,
        EXTRACT(MONTH FROM date) AS month_num,
        AVG(value) AS monthly_avg
    FROM time_series
    GROUP BY DATE_TRUNC('month', date), EXTRACT(MONTH FROM date)
),
overall_stats AS (
    SELECT
        AVG(monthly_avg) AS overall_mean
    FROM monthly_data
),
seasonal_indices AS (
    SELECT
        month_num,
        AVG(monthly_avg) AS avg_monthly_value,
        AVG(monthly_avg) / NULLIF(o.overall_mean, 0) AS seasonal_index
    FROM monthly_data
    CROSS JOIN overall_stats o
    GROUP BY month_num, o.overall_mean
)
SELECT
    month_num,
    CASE month_num
        WHEN 1 THEN 'January'
        WHEN 2 THEN 'February'
        WHEN 3 THEN 'March'
        WHEN 4 THEN 'April'
        WHEN 5 THEN 'May'
        WHEN 6 THEN 'June'
        WHEN 7 THEN 'July'
        WHEN 8 THEN 'August'
        WHEN 9 THEN 'September'
        WHEN 10 THEN 'October'
        WHEN 11 THEN 'November'
        WHEN 12 THEN 'December'
    END AS month_name,
    ROUND(avg_monthly_value::numeric, 2) AS avg_value,
    ROUND(seasonal_index::numeric, 4) AS seasonal_index,
    -- 季节强度判断
    CASE
        WHEN seasonal_index > 1.2 THEN '强旺季'
        WHEN seasonal_index > 1.1 THEN '旺季'
        WHEN seasonal_index > 0.9 THEN '正常'
        WHEN seasonal_index > 0.8 THEN '淡季'
        ELSE '强淡季'
    END AS seasonal_strength
FROM seasonal_indices
ORDER BY month_num;
```

---

## 5. 自相关分析

### 5.1 自相关函数（ACF）

**自相关函数**检测时间序列的周期性。

```sql
-- 自相关函数（ACF）计算：检测周期性
WITH time_series_indexed AS (
    SELECT
        date,
        value,
        AVG(value) OVER () AS mean_value,
        ROW_NUMBER() OVER (ORDER BY date) AS t
    FROM time_series
    WHERE value IS NOT NULL
),
acf_calculation AS (
    SELECT
        lag_k,
        -- 自相关：r_k = E[(y_t - mean)(y_{t+k} - mean)] / Var(y)
        AVG((t1.value - t1.mean_value) * (t2.value - t2.mean_value)) /
        NULLIF(VAR_POP(t1.value), 0) AS autocorrelation
    FROM time_series_indexed t1
    CROSS JOIN generate_series(0, 48) AS lag_k  -- 检查48个滞后
    JOIN time_series_indexed t2 ON t2.t = t1.t + lag_k
    WHERE t2.t IS NOT NULL
    GROUP BY lag_k
)
SELECT
    lag_k,
    ROUND(autocorrelation::numeric, 4) AS acf,
    -- 周期检测：ACF显著大于0的滞后
    CASE
        WHEN ABS(autocorrelation) > 0.2 THEN '显著'
        WHEN ABS(autocorrelation) > 0.1 THEN '弱显著'
        ELSE '不显著'
    END AS significance
FROM acf_calculation
ORDER BY lag_k;
```

---

## 6. 实际应用案例

### 6.1 多周期综合分析

**多周期综合分析**同时分析多个周期模式。

```sql
-- 多周期综合分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING '表 metrics 不存在，无法执行多周期综合分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多周期综合分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多周期综合分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT
    EXTRACT(DOW FROM timestamp) AS day_of_week,
    EXTRACT(HOUR FROM timestamp) AS hour_of_day,
    COUNT(*) AS count,
    AVG(value) AS avg_value,
    STDDEV(value) AS stddev_value
FROM metrics
GROUP BY EXTRACT(DOW FROM timestamp), EXTRACT(HOUR FROM timestamp)
ORDER BY day_of_week, hour_of_day;
```

### 6.2 网站流量周期性分析

**场景**：分析网站访问量的周期性模式。

```sql
-- 网站流量周期性分析：识别访问高峰时段
WITH hourly_traffic AS (
    SELECT
        DATE_TRUNC('hour', visit_time) AS hour,
        EXTRACT(DOW FROM visit_time) AS day_of_week,
        EXTRACT(HOUR FROM visit_time) AS hour_of_day,
        COUNT(*) AS page_views,
        COUNT(DISTINCT user_id) AS unique_visitors
    FROM page_views
    GROUP BY DATE_TRUNC('hour', visit_time), EXTRACT(DOW FROM visit_time), EXTRACT(HOUR FROM visit_time)
),
periodic_patterns AS (
    SELECT
        day_of_week,
        CASE day_of_week
            WHEN 0 THEN 'Sunday'
            WHEN 1 THEN 'Monday'
            WHEN 2 THEN 'Tuesday'
            WHEN 3 THEN 'Wednesday'
            WHEN 4 THEN 'Thursday'
            WHEN 5 THEN 'Friday'
            WHEN 6 THEN 'Saturday'
        END AS day_name,
        hour_of_day,
        AVG(page_views) AS avg_page_views,
        AVG(unique_visitors) AS avg_unique_visitors,
        STDDEV(page_views) AS stddev_page_views
    FROM hourly_traffic
    GROUP BY day_of_week, hour_of_day
)
SELECT
    day_name,
    hour_of_day,
    ROUND(avg_page_views::numeric, 2) AS avg_page_views,
    ROUND(avg_unique_visitors::numeric, 2) AS avg_unique_visitors,
    ROUND(stddev_page_views::numeric, 2) AS stddev_page_views,
    -- 高峰时段识别
    CASE
        WHEN avg_page_views > AVG(avg_page_views) OVER () + STDDEV(avg_page_views) OVER () THEN '高峰'
        WHEN avg_page_views < AVG(avg_page_views) OVER () - STDDEV(avg_page_views) OVER () THEN '低谷'
        ELSE '正常'
    END AS traffic_level
FROM periodic_patterns
ORDER BY day_of_week, hour_of_day;
```

### 6.3 销售数据季节性分析

**场景**：分析销售数据的季节性模式。

```sql
-- 销售数据季节性分析：识别销售旺季和淡季
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        EXTRACT(MONTH FROM order_date) AS month_num,
        EXTRACT(QUARTER FROM order_date) AS quarter,
        SUM(order_amount) AS monthly_sales,
        COUNT(*) AS order_count
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date), EXTRACT(MONTH FROM order_date), EXTRACT(QUARTER FROM order_date)
),
seasonal_analysis AS (
    SELECT
        month_num,
        quarter,
        CASE month_num
            WHEN 1 THEN 'January'
            WHEN 2 THEN 'February'
            WHEN 3 THEN 'March'
            WHEN 4 THEN 'April'
            WHEN 5 THEN 'May'
            WHEN 6 THEN 'June'
            WHEN 7 THEN 'July'
            WHEN 8 THEN 'August'
            WHEN 9 THEN 'September'
            WHEN 10 THEN 'October'
            WHEN 11 THEN 'November'
            WHEN 12 THEN 'December'
        END AS month_name,
        AVG(monthly_sales) AS avg_monthly_sales,
        AVG(order_count) AS avg_order_count,
        STDDEV(monthly_sales) AS stddev_monthly_sales
    FROM monthly_sales
    GROUP BY month_num, quarter
),
overall_stats AS (
    SELECT
        AVG(avg_monthly_sales) AS overall_avg_sales
    FROM seasonal_analysis
)
SELECT
    sa.month_num,
    sa.month_name,
    sa.quarter,
    ROUND(sa.avg_monthly_sales::numeric, 2) AS avg_monthly_sales,
    ROUND(sa.avg_order_count::numeric, 2) AS avg_order_count,
    ROUND((sa.avg_monthly_sales / NULLIF(os.overall_avg_sales, 0))::numeric, 4) AS seasonal_index,
    -- 季节强度
    CASE
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 1.2 THEN '强旺季'
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 1.1 THEN '旺季'
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 0.9 THEN '正常'
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 0.8 THEN '淡季'
        ELSE '强淡季'
    END AS seasonal_category
FROM seasonal_analysis sa
CROSS JOIN overall_stats os
ORDER BY sa.month_num;
```

### 6.4 用户行为周期性分析

**场景**：分析用户行为的周期性模式。

```sql
-- 用户行为周期性分析：识别用户活跃时段
WITH user_activity AS (
    SELECT
        DATE_TRUNC('hour', activity_time) AS hour,
        EXTRACT(DOW FROM activity_time) AS day_of_week,
        EXTRACT(HOUR FROM activity_time) AS hour_of_day,
        user_id,
        COUNT(*) AS activity_count
    FROM user_activities
    GROUP BY DATE_TRUNC('hour', activity_time), EXTRACT(DOW FROM activity_time), EXTRACT(HOUR FROM activity_time), user_id
),
periodic_activity AS (
    SELECT
        day_of_week,
        hour_of_day,
        AVG(activity_count) AS avg_activity,
        COUNT(DISTINCT user_id) AS active_users,
        STDDEV(activity_count) AS stddev_activity
    FROM user_activity
    GROUP BY day_of_week, hour_of_day
)
SELECT
    CASE day_of_week
        WHEN 0 THEN 'Sunday'
        WHEN 1 THEN 'Monday'
        WHEN 2 THEN 'Tuesday'
        WHEN 3 THEN 'Wednesday'
        WHEN 4 THEN 'Thursday'
        WHEN 5 THEN 'Friday'
        WHEN 6 THEN 'Saturday'
    END AS day_name,
    hour_of_day,
    ROUND(avg_activity::numeric, 2) AS avg_activity,
    active_users,
    ROUND(stddev_activity::numeric, 2) AS stddev_activity,
    -- 活跃度等级
    CASE
        WHEN avg_activity > AVG(avg_activity) OVER () + STDDEV(avg_activity) OVER () THEN '高活跃'
        WHEN avg_activity > AVG(avg_activity) OVER () THEN '中活跃'
        WHEN avg_activity > AVG(avg_activity) OVER () - STDDEV(avg_activity) OVER () THEN '低活跃'
        ELSE '极低活跃'
    END AS activity_level
FROM periodic_activity
ORDER BY day_of_week, hour_of_day;
```

---

## 7. 算法性能对比与优化

### 7.1 周期性检测方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|-----------|-----------|---------|------|------|
| **分组统计** | $O(n)$ | $O(k)$ | 固定周期 | 简单快速 | 需要已知周期 |
| **自相关分析** | $O(nk)$ | $O(k)$ | 周期检测 | 自动检测 | 计算复杂 |
| **方差分析** | $O(n)$ | $O(k)$ | 周期验证 | 统计显著 | 需要分组 |
| **季节分解** | $O(n \log n)$ | $O(n)$ | 季节调整 | 功能全面 | 计算复杂 |

### 7.2 性能优化建议

1. **计算优化**：
   - 使用聚合函数而非窗口函数
   - 创建时间索引
   - 使用物化视图

2. **查询优化**：
   - 限制时间范围
   - 使用分区表
   - 并行处理

3. **算法优化**：
   - 采样计算
   - 近似方法
   - 增量计算

### 7.3 常见问题与解决方案

**问题1**：周期检测不准确

- **解决方案**：增加数据量、使用多种方法验证、去除异常值

**问题2**：多周期叠加难以分离

- **解决方案**：使用季节分解、分别分析各周期、使用频域方法

**问题3**：周期长度变化

- **解决方案**：使用滑动窗口、动态周期检测、分段分析

**问题4**：计算性能问题

- **解决方案**：优化SQL查询、使用索引、分批处理

---

## 8. 最佳实践

### 8.1 周期分析方法选择

1. **数据探索**：
   - 可视化时间序列
   - 检查数据质量
   - 识别明显周期

2. **方法选择**：
   - 已知周期：使用分组统计
   - 未知周期：使用自相关分析
   - 季节调整：使用季节分解

3. **结果验证**：
   - 使用统计检验
   - 可视化验证
   - 业务验证

### 8.2 周期性分析注意事项

1. **数据质量**：
   - 处理缺失值
   - 识别异常值
   - 检查数据一致性

2. **周期选择**：
   - 根据业务背景选择
   - 考虑数据特征
   - 验证周期合理性

3. **结果解释**：
   - 结合业务背景
   - 考虑外部因素
   - 谨慎预测

### 8.3 SQL实现注意事项

1. **性能考虑**：
   - 优化聚合查询
   - 创建时间索引
   - 使用分区表

2. **准确性**：
   - 处理时区问题
   - 处理边界情况
   - 验证计算结果

3. **可维护性**：
   - 使用清晰的变量名
   - 添加注释
   - 模块化设计

---

## 📚 参考资源

### 学术文献

1. **《时间序列分析》**（Hamilton, J. D., 1994）- 周期性分析理论

2. **《应用时间序列分析》**（王燕, 2015）- 季节分解方法

3. **《金融时间序列分析》**（Tsay, R. S., 2005）- 周期性检测

### PostgreSQL官方文档

- **日期时间函数**: <https://www.postgresql.org/docs/current/functions-datetime.html>
- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>

### 在线资源

- **周期性分析**: <https://en.wikipedia.org/wiki/Periodic_function>
- **季节分解**: <https://en.wikipedia.org/wiki/Seasonal_adjustment>
- **自相关函数**: <https://en.wikipedia.org/wiki/Autocorrelation>

### 相关算法

- **时间序列预测**：基于周期性的预测
- **趋势分析**：趋势与周期结合
- **异常检测算法**：基于周期性的异常检测
- **滑动窗口计算**：周期性窗口分析

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
