# PostgreSQL å‘¨æœŸæ€§åˆ†æå®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | å‘¨æœŸæ€§åˆ†æ | å­£èŠ‚åˆ†è§£
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å‘¨æœŸæ€§åˆ†æå®Œæ•´æŒ‡å—](#postgresql-å‘¨æœŸæ€§åˆ†æå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å‘¨æœŸæ€§åˆ†ææ¦‚è¿°](#å‘¨æœŸæ€§åˆ†ææ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [å‘¨æœŸæ€§å®šä¹‰](#å‘¨æœŸæ€§å®šä¹‰)
      - [å‘¨æœŸç±»å‹](#å‘¨æœŸç±»å‹)
      - [å‘¨æœŸæ€§æ£€æµ‹æ–¹æ³•](#å‘¨æœŸæ€§æ£€æµ‹æ–¹æ³•)
    - [æ ¸å¿ƒå‘¨æœŸç±»å‹](#æ ¸å¿ƒå‘¨æœŸç±»å‹)
  - [1. æ—¥å‘¨æœŸåˆ†æ](#1-æ—¥å‘¨æœŸåˆ†æ)
    - [1.1 æ—¥å‘¨æœŸåŸç†](#11-æ—¥å‘¨æœŸåŸç†)
      - [æ—¥å‘¨æœŸç‰¹å¾](#æ—¥å‘¨æœŸç‰¹å¾)
      - [æ—¥å‘¨æœŸæ£€æµ‹](#æ—¥å‘¨æœŸæ£€æµ‹)
    - [1.2 å°æ—¶æ¨¡å¼åˆ†æå®ç°](#12-å°æ—¶æ¨¡å¼åˆ†æå®ç°)
    - [1.3 æ—¥å‘¨æœŸå¼ºåº¦åˆ†æ](#13-æ—¥å‘¨æœŸå¼ºåº¦åˆ†æ)
    - [1.4 æ—¶æ®µæ¨¡å¼åˆ†æ](#14-æ—¶æ®µæ¨¡å¼åˆ†æ)
  - [2. å‘¨å‘¨æœŸåˆ†æ](#2-å‘¨å‘¨æœŸåˆ†æ)
    - [2.1 å‘¨å‘¨æœŸåŸç†](#21-å‘¨å‘¨æœŸåŸç†)
      - [å‘¨å‘¨æœŸç‰¹å¾](#å‘¨å‘¨æœŸç‰¹å¾)
      - [å‘¨å‘¨æœŸæ£€æµ‹](#å‘¨å‘¨æœŸæ£€æµ‹)
    - [2.2 æ˜ŸæœŸæ¨¡å¼åˆ†æå®ç°](#22-æ˜ŸæœŸæ¨¡å¼åˆ†æå®ç°)
    - [2.3 å·¥ä½œæ—¥vså‘¨æœ«åˆ†æ](#23-å·¥ä½œæ—¥vså‘¨æœ«åˆ†æ)
    - [2.4 å‘¨å†…è¶‹åŠ¿åˆ†æ](#24-å‘¨å†…è¶‹åŠ¿åˆ†æ)
  - [3. æœˆå‘¨æœŸåˆ†æ](#3-æœˆå‘¨æœŸåˆ†æ)
    - [3.1 æœˆå‘¨æœŸåŸç†](#31-æœˆå‘¨æœŸåŸç†)
      - [æœˆå‘¨æœŸç‰¹å¾](#æœˆå‘¨æœŸç‰¹å¾)
    - [3.2 æœˆä»½æ¨¡å¼åˆ†æå®ç°](#32-æœˆä»½æ¨¡å¼åˆ†æå®ç°)
    - [3.3 æœˆåˆ/æœˆä¸­/æœˆæœ«åˆ†æ](#33-æœˆåˆæœˆä¸­æœˆæœ«åˆ†æ)
  - [4. å­£èŠ‚åˆ†è§£](#4-å­£èŠ‚åˆ†è§£)
    - [4.1 å­£èŠ‚åˆ†è§£åŸç†](#41-å­£èŠ‚åˆ†è§£åŸç†)
      - [åˆ†è§£æ¨¡å‹](#åˆ†è§£æ¨¡å‹)
      - [åˆ†è§£æ–¹æ³•](#åˆ†è§£æ–¹æ³•)
    - [4.2 å­£èŠ‚æ€§åˆ†è§£å®ç°](#42-å­£èŠ‚æ€§åˆ†è§£å®ç°)
    - [4.3 å­£èŠ‚æŒ‡æ•°è®¡ç®—](#43-å­£èŠ‚æŒ‡æ•°è®¡ç®—)
  - [5. è‡ªç›¸å…³åˆ†æ](#5-è‡ªç›¸å…³åˆ†æ)
    - [5.1 è‡ªç›¸å…³å‡½æ•°ï¼ˆACFï¼‰](#51-è‡ªç›¸å…³å‡½æ•°acf)
  - [6. å®é™…åº”ç”¨æ¡ˆä¾‹](#6-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [6.1 å¤šå‘¨æœŸç»¼åˆåˆ†æ](#61-å¤šå‘¨æœŸç»¼åˆåˆ†æ)
    - [6.2 ç½‘ç«™æµé‡å‘¨æœŸæ€§åˆ†æ](#62-ç½‘ç«™æµé‡å‘¨æœŸæ€§åˆ†æ)
    - [6.3 é”€å”®æ•°æ®å­£èŠ‚æ€§åˆ†æ](#63-é”€å”®æ•°æ®å­£èŠ‚æ€§åˆ†æ)
    - [6.4 ç”¨æˆ·è¡Œä¸ºå‘¨æœŸæ€§åˆ†æ](#64-ç”¨æˆ·è¡Œä¸ºå‘¨æœŸæ€§åˆ†æ)
  - [7. PostgreSQL 18å¹¶è¡Œå‘¨æœŸæ€§åˆ†æ](#7-postgresql-18å¹¶è¡Œå‘¨æœŸæ€§åˆ†æ)
    - [7.1 å¹¶è¡Œå‘¨æœŸæ€§åˆ†ææ¦‚è¿°](#71-å¹¶è¡Œå‘¨æœŸæ€§åˆ†ææ¦‚è¿°)
      - [å¹¶è¡Œå‘¨æœŸæ€§åˆ†æé…ç½®](#å¹¶è¡Œå‘¨æœŸæ€§åˆ†æé…ç½®)
      - [å¹¶è¡Œå‘¨æœŸæ€§åˆ†æå®ç°](#å¹¶è¡Œå‘¨æœŸæ€§åˆ†æå®ç°)
  - [8. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#8-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [8.1 å‘¨æœŸæ€§æ£€æµ‹æ–¹æ³•å¯¹æ¯”](#81-å‘¨æœŸæ€§æ£€æµ‹æ–¹æ³•å¯¹æ¯”)
    - [8.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#82-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [8.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#83-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
    - [9.1 å‘¨æœŸåˆ†ææ–¹æ³•é€‰æ‹©](#91-å‘¨æœŸåˆ†ææ–¹æ³•é€‰æ‹©)
    - [9.2 å‘¨æœŸæ€§åˆ†ææ³¨æ„äº‹é¡¹](#92-å‘¨æœŸæ€§åˆ†ææ³¨æ„äº‹é¡¹)
    - [9.3 SQLå®ç°æ³¨æ„äº‹é¡¹](#93-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [9.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#94-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [9.5 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#95-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## å‘¨æœŸæ€§åˆ†ææ¦‚è¿°

**å‘¨æœŸæ€§åˆ†æï¼ˆPeriodicity Analysisï¼‰**è¯†åˆ«æ—¶é—´åºåˆ—æ•°æ®ä¸­çš„å‘¨æœŸæ€§è§„å¾‹ï¼Œç”¨äºç†è§£æ•°æ®çš„å‘¨æœŸæ€§æ¨¡å¼ã€é¢„æµ‹æœªæ¥èµ°åŠ¿å’Œä¼˜åŒ–ä¸šåŠ¡å†³ç­–ã€‚å‘¨æœŸæ€§æ˜¯æ—¶é—´åºåˆ—æ•°æ®çš„é‡è¦ç‰¹å¾ä¹‹ä¸€ï¼Œåæ˜ äº†æ•°æ®åœ¨å›ºå®šæ—¶é—´é—´éš”å†…çš„é‡å¤æ¨¡å¼ã€‚

### ç†è®ºåŸºç¡€

#### å‘¨æœŸæ€§å®šä¹‰

**å‘¨æœŸæ€§ï¼ˆPeriodicityï¼‰**æ˜¯æŒ‡æ—¶é—´åºåˆ—æ•°æ®åœ¨å›ºå®šæ—¶é—´é—´éš”å†…é‡å¤å‡ºç°çš„æ¨¡å¼ã€‚åœ¨æ—¶é—´åºåˆ—åˆ†è§£æ¨¡å‹ä¸­ï¼š
$$Y_t = T_t + S_t + C_t + I_t$$

å…¶ä¸­ï¼š

- $T_t$ï¼šè¶‹åŠ¿æˆåˆ†ï¼ˆTrendï¼‰
- $S_t$ï¼šå­£èŠ‚æˆåˆ†ï¼ˆSeasonalï¼‰- å›ºå®šå‘¨æœŸçš„å‘¨æœŸæ€§æ¨¡å¼
- $C_t$ï¼šå¾ªç¯æˆåˆ†ï¼ˆCyclicalï¼‰- éå›ºå®šå‘¨æœŸçš„å‘¨æœŸæ€§æ¨¡å¼
- $I_t$ï¼šä¸è§„åˆ™æˆåˆ†ï¼ˆIrregularï¼‰

#### å‘¨æœŸç±»å‹

1. **æ—¥å‘¨æœŸï¼ˆDaily Cycleï¼‰**ï¼š24å°æ—¶å†…çš„é‡å¤æ¨¡å¼
   - å°æ—¶æ¨¡å¼ï¼šä¸€å¤©å†…ä¸åŒå°æ—¶çš„å˜åŒ–
   - åˆ†é’Ÿæ¨¡å¼ï¼šä¸€å°æ—¶å†…ä¸åŒåˆ†é’Ÿçš„å˜åŒ–

2. **å‘¨å‘¨æœŸï¼ˆWeekly Cycleï¼‰**ï¼š7å¤©å†…çš„é‡å¤æ¨¡å¼
   - å·¥ä½œæ—¥vså‘¨æœ«
   - æ˜ŸæœŸå‡ æ¨¡å¼

3. **æœˆå‘¨æœŸï¼ˆMonthly Cycleï¼‰**ï¼šä¸€ä¸ªæœˆå†…çš„é‡å¤æ¨¡å¼
   - æœˆåˆã€æœˆä¸­ã€æœˆæœ«æ¨¡å¼
   - æ—¥æœŸæ¨¡å¼ï¼ˆå¦‚å‘è–ªæ—¥ï¼‰

4. **å­£èŠ‚å‘¨æœŸï¼ˆSeasonal Cycleï¼‰**ï¼šä¸€å¹´å†…çš„é‡å¤æ¨¡å¼
   - å­£åº¦æ¨¡å¼
   - æœˆä»½æ¨¡å¼
   - èŠ‚å‡æ—¥æ¨¡å¼

#### å‘¨æœŸæ€§æ£€æµ‹æ–¹æ³•

1. **æ—¶åŸŸæ–¹æ³•**ï¼š
   - è‡ªç›¸å…³å‡½æ•°ï¼ˆACFï¼‰
   - åè‡ªç›¸å…³å‡½æ•°ï¼ˆPACFï¼‰
   - å‘¨æœŸå›¾åˆ†æ

2. **é¢‘åŸŸæ–¹æ³•**ï¼š
   - å‚…é‡Œå¶å˜æ¢
   - åŠŸç‡è°±å¯†åº¦
   - å°æ³¢å˜æ¢

3. **ç»Ÿè®¡æ–¹æ³•**ï¼š
   - æ–¹å·®åˆ†æï¼ˆANOVAï¼‰
   - Kruskal-Wallisæ£€éªŒ
   - å‘¨æœŸå›å½’

### æ ¸å¿ƒå‘¨æœŸç±»å‹

| å‘¨æœŸç±»å‹ | å‘¨æœŸé•¿åº¦ | ç”¨é€” | å¤æ‚åº¦ | æ•°å­¦è¡¨ç¤º |
|---------|---------|------|--------|----------|
| **æ—¥å‘¨æœŸ** | 24å°æ—¶ | æ—¥å†…æ¨¡å¼ | $O(n)$ | $S_{d,h} = f(h)$ |
| **å‘¨å‘¨æœŸ** | 7å¤© | å‘¨å†…æ¨¡å¼ | $O(n)$ | $S_{w,d} = f(d)$ |
| **æœˆå‘¨æœŸ** | 28-31å¤© | æœˆå†…æ¨¡å¼ | $O(n)$ | $S_{m,d} = f(d)$ |
| **å­£èŠ‚å‘¨æœŸ** | 365å¤© | å­£èŠ‚æ€§æ¨¡å¼ | $O(n)$ | $S_{y,m} = f(m)$ |

---

## 1. æ—¥å‘¨æœŸåˆ†æ

### 1.1 æ—¥å‘¨æœŸåŸç†

**æ—¥å‘¨æœŸåˆ†æï¼ˆDaily Cycle Analysisï¼‰**è¯†åˆ«ä¸€å¤©å†…çš„å‘¨æœŸæ€§æ¨¡å¼ï¼Œé€šå¸¸ä»¥å°æ—¶ä¸ºå•ä½è¿›è¡Œåˆ†æã€‚

#### æ—¥å‘¨æœŸç‰¹å¾

1. **å°æ—¶æ¨¡å¼**ï¼šä¸åŒå°æ—¶çš„æ•°æ®åˆ†å¸ƒ
2. **åˆ†é’Ÿæ¨¡å¼**ï¼šä¸åŒåˆ†é’Ÿçš„æ•°æ®åˆ†å¸ƒ
3. **æ—¶æ®µæ¨¡å¼**ï¼šæ—©æ™¨ã€ä¸­åˆã€æ™šä¸Šç­‰æ—¶æ®µ

#### æ—¥å‘¨æœŸæ£€æµ‹

**è‡ªç›¸å…³åˆ†æ**ï¼š
$$r_k = \frac{\sum_{t=1}^{n-k}(y_t - \bar{y})(y_{t+k} - \bar{y})}{\sum_{t=1}^{n}(y_t - \bar{y})^2}$$

å…¶ä¸­$k$æ˜¯æ»åé˜¶æ•°ï¼Œ$r_{24}$è¡¨ç¤º24å°æ—¶å‘¨æœŸçš„è‡ªç›¸å…³ã€‚

### 1.2 å°æ—¶æ¨¡å¼åˆ†æå®ç°

```sql
-- æ—¥å‘¨æœŸåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING 'è¡¨ metrics ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ—¥å‘¨æœŸåˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œæ—¥å‘¨æœŸåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ—¥å‘¨æœŸåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    EXTRACT(HOUR FROM timestamp) AS hour_of_day,
    COUNT(*) AS count,
    AVG(value) AS avg_value,
    STDDEV(value) AS stddev_value,
    MIN(value) AS min_value,
    MAX(value) AS max_value
FROM metrics
GROUP BY EXTRACT(HOUR FROM timestamp)
ORDER BY hour_of_day;
```

---

### 1.3 æ—¥å‘¨æœŸå¼ºåº¦åˆ†æ

**å‘¨æœŸå¼ºåº¦**è¯„ä¼°æ—¥å‘¨æœŸçš„æ˜¾è‘—ç¨‹åº¦ã€‚

```sql
-- æ—¥å‘¨æœŸå¼ºåº¦åˆ†æï¼šä½¿ç”¨æ–¹å·®åˆ†æ
WITH hourly_stats AS (
    SELECT
        EXTRACT(HOUR FROM timestamp) AS hour,
        value,
        AVG(value) OVER () AS overall_mean,
        AVG(value) OVER (PARTITION BY EXTRACT(HOUR FROM timestamp)) AS hour_mean
    FROM metrics
    WHERE value IS NOT NULL
),
anova_stats AS (
    SELECT
        -- ç»„é—´å¹³æ–¹å’Œï¼ˆSSBï¼‰
        SUM(POWER(hour_mean - overall_mean, 2)) AS ssb,
        -- ç»„å†…å¹³æ–¹å’Œï¼ˆSSWï¼‰
        SUM(POWER(value - hour_mean, 2)) AS ssw,
        COUNT(DISTINCT hour) AS k,
        COUNT(*) AS n
    FROM hourly_stats
)
SELECT
    ssb,
    ssw,
    -- Fç»Ÿè®¡é‡
    (ssb / NULLIF(k - 1, 0)) / NULLIF(ssw / NULLIF(n - k, 0), 0) AS f_statistic,
    -- å‘¨æœŸå¼ºåº¦ï¼ˆRÂ²ï¼‰
    1 - ssw / NULLIF(ssb + ssw, 0) AS periodicity_strength
FROM anova_stats;
```

### 1.4 æ—¶æ®µæ¨¡å¼åˆ†æ

**æ—¶æ®µæ¨¡å¼**è¯†åˆ«ä¸€å¤©ä¸­çš„ä¸åŒæ—¶æ®µç‰¹å¾ã€‚

```sql
-- æ—¶æ®µæ¨¡å¼åˆ†æï¼šæ—©æ™¨ã€ä¸­åˆã€æ™šä¸Šç­‰æ—¶æ®µ
SELECT
    CASE
        WHEN EXTRACT(HOUR FROM timestamp) BETWEEN 6 AND 11 THEN 'æ—©æ™¨ (6-11)'
        WHEN EXTRACT(HOUR FROM timestamp) BETWEEN 12 AND 17 THEN 'ä¸­åˆ (12-17)'
        WHEN EXTRACT(HOUR FROM timestamp) BETWEEN 18 AND 22 THEN 'æ™šä¸Š (18-22)'
        ELSE 'æ·±å¤œ (23-5)'
    END AS time_period,
    COUNT(*) AS count,
    AVG(value) AS avg_value,
    STDDEV(value) AS stddev_value,
    MIN(value) AS min_value,
    MAX(value) AS max_value,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) AS median_value
FROM metrics
WHERE value IS NOT NULL
GROUP BY time_period
ORDER BY
    CASE time_period
        WHEN 'æ—©æ™¨ (6-11)' THEN 1
        WHEN 'ä¸­åˆ (12-17)' THEN 2
        WHEN 'æ™šä¸Š (18-22)' THEN 3
        ELSE 4
    END;
```

---

## 2. å‘¨å‘¨æœŸåˆ†æ

### 2.1 å‘¨å‘¨æœŸåŸç†

**å‘¨å‘¨æœŸåˆ†æï¼ˆWeekly Cycle Analysisï¼‰**è¯†åˆ«ä¸€å‘¨å†…çš„å‘¨æœŸæ€§æ¨¡å¼ï¼Œé€šå¸¸ä»¥å¤©ä¸ºå•ä½è¿›è¡Œåˆ†æã€‚

#### å‘¨å‘¨æœŸç‰¹å¾

1. **å·¥ä½œæ—¥vså‘¨æœ«**ï¼šå·¥ä½œæ—¥å’Œå‘¨æœ«çš„å·®å¼‚
2. **æ˜ŸæœŸå‡ æ¨¡å¼**ï¼šä¸åŒæ˜ŸæœŸå‡ çš„ç‰¹å¾
3. **å‘¨å†…è¶‹åŠ¿**ï¼šä¸€å‘¨å†…çš„å˜åŒ–è¶‹åŠ¿

#### å‘¨å‘¨æœŸæ£€æµ‹

**æ˜ŸæœŸæ¨¡å¼åˆ†æ**ï¼š
$$S_d = \frac{1}{n}\sum_{i=1}^{n}y_{d,i}$$

å…¶ä¸­$d$æ˜¯æ˜ŸæœŸå‡ ï¼ˆ0-6ï¼‰ï¼Œ$n$æ˜¯è¯¥æ˜ŸæœŸå‡ çš„æ€»æ•°ã€‚

### 2.2 æ˜ŸæœŸæ¨¡å¼åˆ†æå®ç°

```sql
-- å‘¨å‘¨æœŸåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING 'è¡¨ sales ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå‘¨å‘¨æœŸåˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå‘¨å‘¨æœŸåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å‘¨å‘¨æœŸåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    EXTRACT(DOW FROM sale_date) AS day_of_week,
    CASE EXTRACT(DOW FROM sale_date)
        WHEN 0 THEN 'Sunday'
        WHEN 1 THEN 'Monday'
        WHEN 2 THEN 'Tuesday'
        WHEN 3 THEN 'Wednesday'
        WHEN 4 THEN 'Thursday'
        WHEN 5 THEN 'Friday'
        WHEN 6 THEN 'Saturday'
    END AS day_name,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY EXTRACT(DOW FROM sale_date)
ORDER BY day_of_week;
```

---

### 2.3 å·¥ä½œæ—¥vså‘¨æœ«åˆ†æ

**å·¥ä½œæ—¥vså‘¨æœ«**å¯¹æ¯”åˆ†æå·¥ä½œæ—¥å’Œå‘¨æœ«çš„å·®å¼‚ã€‚

```sql
-- å·¥ä½œæ—¥vså‘¨æœ«åˆ†æ
WITH day_classification AS (
    SELECT
        sale_date,
        amount,
        CASE
            WHEN EXTRACT(DOW FROM sale_date) IN (0, 6) THEN 'å‘¨æœ«'
            ELSE 'å·¥ä½œæ—¥'
        END AS day_type,
        EXTRACT(DOW FROM sale_date) AS day_of_week
    FROM sales
)
SELECT
    day_type,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    STDDEV(amount) AS stddev_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount
FROM day_classification
GROUP BY day_type
ORDER BY day_type;
```

### 2.4 å‘¨å†…è¶‹åŠ¿åˆ†æ

**å‘¨å†…è¶‹åŠ¿**åˆ†æä¸€å‘¨å†…çš„å˜åŒ–è¶‹åŠ¿ã€‚

```sql
-- å‘¨å†…è¶‹åŠ¿åˆ†æï¼šè¯†åˆ«å‘¨å†…çš„é«˜å³°å’Œä½è°·
WITH weekly_pattern AS (
    SELECT
        EXTRACT(DOW FROM sale_date) AS day_of_week,
        CASE EXTRACT(DOW FROM sale_date)
            WHEN 0 THEN 'Sunday'
            WHEN 1 THEN 'Monday'
            WHEN 2 THEN 'Tuesday'
            WHEN 3 THEN 'Wednesday'
            WHEN 4 THEN 'Thursday'
            WHEN 5 THEN 'Friday'
            WHEN 6 THEN 'Saturday'
        END AS day_name,
        AVG(amount) AS avg_amount,
        COUNT(*) AS count
    FROM sales
    GROUP BY EXTRACT(DOW FROM sale_date)
),
trend_analysis AS (
    SELECT
        day_of_week,
        day_name,
        avg_amount,
        LAG(avg_amount) OVER (ORDER BY day_of_week) AS prev_day_avg,
        LEAD(avg_amount) OVER (ORDER BY day_of_week) AS next_day_avg
    FROM weekly_pattern
)
SELECT
    day_of_week,
    day_name,
    ROUND(avg_amount::numeric, 2) AS avg_amount,
    -- è¶‹åŠ¿æ–¹å‘
    CASE
        WHEN avg_amount > COALESCE(prev_day_avg, avg_amount) AND
             avg_amount > COALESCE(next_day_avg, avg_amount) THEN 'é«˜å³°'
        WHEN avg_amount < COALESCE(prev_day_avg, avg_amount) AND
             avg_amount < COALESCE(next_day_avg, avg_amount) THEN 'ä½è°·'
        WHEN avg_amount > COALESCE(prev_day_avg, avg_amount) THEN 'ä¸Šå‡'
        ELSE 'ä¸‹é™'
    END AS trend_direction,
    -- å˜åŒ–ç‡
    ROUND(
        (avg_amount - COALESCE(prev_day_avg, avg_amount)) /
        NULLIF(COALESCE(prev_day_avg, avg_amount), 0) * 100,
        2
    ) AS change_rate_pct
FROM trend_analysis
ORDER BY day_of_week;
```

---

## 3. æœˆå‘¨æœŸåˆ†æ

### 3.1 æœˆå‘¨æœŸåŸç†

**æœˆå‘¨æœŸåˆ†æï¼ˆMonthly Cycle Analysisï¼‰**è¯†åˆ«ä¸€ä¸ªæœˆå†…çš„å‘¨æœŸæ€§æ¨¡å¼ï¼Œé€šå¸¸ä»¥å¤©ä¸ºå•ä½è¿›è¡Œåˆ†æã€‚

#### æœˆå‘¨æœŸç‰¹å¾

1. **æœˆåˆã€æœˆä¸­ã€æœˆæœ«æ¨¡å¼**ï¼šä¸åŒæ—¶é—´æ®µçš„å˜åŒ–
2. **æ—¥æœŸæ¨¡å¼**ï¼šç‰¹å®šæ—¥æœŸï¼ˆå¦‚å‘è–ªæ—¥ï¼‰çš„ç‰¹å¾
3. **å·¥ä½œæ—¥æ•°é‡**ï¼šä¸åŒæœˆä»½å·¥ä½œæ—¥æ•°é‡çš„å½±å“

### 3.2 æœˆä»½æ¨¡å¼åˆ†æå®ç°

```sql
-- æœˆå‘¨æœŸåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING 'è¡¨ sales ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæœˆå‘¨æœŸåˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œæœˆå‘¨æœŸåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æœˆå‘¨æœŸåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    EXTRACT(DAY FROM sale_date) AS day_of_month,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY EXTRACT(DAY FROM sale_date)
ORDER BY day_of_month;
```

---

### 3.3 æœˆåˆ/æœˆä¸­/æœˆæœ«åˆ†æ

**æœˆåˆ/æœˆä¸­/æœˆæœ«**åˆ†æä¸åŒæ—¶é—´æ®µçš„å˜åŒ–æ¨¡å¼ã€‚

```sql
-- æœˆåˆ/æœˆä¸­/æœˆæœ«åˆ†æ
WITH monthly_segments AS (
    SELECT
        sale_date,
        amount,
        EXTRACT(DAY FROM sale_date) AS day_of_month,
        CASE
            WHEN EXTRACT(DAY FROM sale_date) <= 10 THEN 'æœˆåˆ (1-10)'
            WHEN EXTRACT(DAY FROM sale_date) <= 20 THEN 'æœˆä¸­ (11-20)'
            ELSE 'æœˆæœ« (21-31)'
        END AS month_segment
    FROM sales
)
SELECT
    month_segment,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    STDDEV(amount) AS stddev_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount
FROM monthly_segments
GROUP BY month_segment
ORDER BY
    CASE month_segment
        WHEN 'æœˆåˆ (1-10)' THEN 1
        WHEN 'æœˆä¸­ (11-20)' THEN 2
        ELSE 3
    END;
```

---

## 4. å­£èŠ‚åˆ†è§£

### 4.1 å­£èŠ‚åˆ†è§£åŸç†

**å­£èŠ‚åˆ†è§£ï¼ˆSeasonal Decompositionï¼‰**å°†æ—¶é—´åºåˆ—åˆ†è§£ä¸ºè¶‹åŠ¿ã€å­£èŠ‚æ€§å’Œæ®‹å·®æˆåˆ†ï¼Œç”¨äºç†è§£æ•°æ®çš„ç»“æ„å’Œé¢„æµ‹ã€‚

#### åˆ†è§£æ¨¡å‹

**åŠ æ³•æ¨¡å‹**ï¼š
$$Y_t = T_t + S_t + I_t$$

**ä¹˜æ³•æ¨¡å‹**ï¼š
$$Y_t = T_t \times S_t \times I_t$$

å…¶ä¸­ï¼š

- $T_t$ï¼šè¶‹åŠ¿æˆåˆ†
- $S_t$ï¼šå­£èŠ‚æˆåˆ†
- $I_t$ï¼šæ®‹å·®æˆåˆ†

#### åˆ†è§£æ–¹æ³•

1. **ç§»åŠ¨å¹³å‡æ³•**ï¼šä½¿ç”¨ç§»åŠ¨å¹³å‡æå–è¶‹åŠ¿
2. **X-13ARIMA-SEATS**ï¼šå®˜æ–¹å­£èŠ‚è°ƒæ•´æ–¹æ³•
3. **STLåˆ†è§£**ï¼šä½¿ç”¨LOESSçš„å­£èŠ‚å’Œè¶‹åŠ¿åˆ†è§£

### 4.2 å­£èŠ‚æ€§åˆ†è§£å®ç°

```sql
-- å­£èŠ‚åˆ†è§£ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå­£èŠ‚åˆ†è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå­£èŠ‚åˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å­£èŠ‚åˆ†è§£å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH monthly_data AS (
    SELECT
        DATE_TRUNC('month', date) AS month,
        AVG(value) AS monthly_avg
    FROM time_series
    GROUP BY DATE_TRUNC('month', date)
),
trend AS (
    SELECT
        month,
        monthly_avg,
        AVG(monthly_avg) OVER (
            ORDER BY month
            ROWS BETWEEN 5 PRECEDING AND 5 FOLLOWING
        ) AS trend_value
    FROM monthly_data
),
seasonal AS (
    SELECT
        EXTRACT(MONTH FROM month) AS month_num,
        AVG(monthly_avg - trend_value) AS seasonal_component
    FROM trend
    GROUP BY EXTRACT(MONTH FROM month)
)
SELECT
    t.month,
    t.monthly_avg AS original_value,
    t.trend_value,
    s.seasonal_component,
    t.monthly_avg - t.trend_value - s.seasonal_component AS residual
FROM trend t
JOIN seasonal s ON EXTRACT(MONTH FROM t.month) = s.month_num
ORDER BY t.month;
```

---

### 4.3 å­£èŠ‚æŒ‡æ•°è®¡ç®—

**å­£èŠ‚æŒ‡æ•°**é‡åŒ–å­£èŠ‚æ€§çš„å¼ºåº¦ã€‚

```sql
-- å­£èŠ‚æŒ‡æ•°è®¡ç®—ï¼šé‡åŒ–æ¯ä¸ªæœˆçš„å­£èŠ‚æ€§å¼ºåº¦
WITH monthly_data AS (
    SELECT
        DATE_TRUNC('month', date) AS month,
        EXTRACT(MONTH FROM date) AS month_num,
        AVG(value) AS monthly_avg
    FROM time_series
    GROUP BY DATE_TRUNC('month', date), EXTRACT(MONTH FROM date)
),
overall_stats AS (
    SELECT
        AVG(monthly_avg) AS overall_mean
    FROM monthly_data
),
seasonal_indices AS (
    SELECT
        month_num,
        AVG(monthly_avg) AS avg_monthly_value,
        AVG(monthly_avg) / NULLIF(o.overall_mean, 0) AS seasonal_index
    FROM monthly_data
    CROSS JOIN overall_stats o
    GROUP BY month_num, o.overall_mean
)
SELECT
    month_num,
    CASE month_num
        WHEN 1 THEN 'January'
        WHEN 2 THEN 'February'
        WHEN 3 THEN 'March'
        WHEN 4 THEN 'April'
        WHEN 5 THEN 'May'
        WHEN 6 THEN 'June'
        WHEN 7 THEN 'July'
        WHEN 8 THEN 'August'
        WHEN 9 THEN 'September'
        WHEN 10 THEN 'October'
        WHEN 11 THEN 'November'
        WHEN 12 THEN 'December'
    END AS month_name,
    ROUND(avg_monthly_value::numeric, 2) AS avg_value,
    ROUND(seasonal_index::numeric, 4) AS seasonal_index,
    -- å­£èŠ‚å¼ºåº¦åˆ¤æ–­
    CASE
        WHEN seasonal_index > 1.2 THEN 'å¼ºæ—ºå­£'
        WHEN seasonal_index > 1.1 THEN 'æ—ºå­£'
        WHEN seasonal_index > 0.9 THEN 'æ­£å¸¸'
        WHEN seasonal_index > 0.8 THEN 'æ·¡å­£'
        ELSE 'å¼ºæ·¡å­£'
    END AS seasonal_strength
FROM seasonal_indices
ORDER BY month_num;
```

---

## 5. è‡ªç›¸å…³åˆ†æ

### 5.1 è‡ªç›¸å…³å‡½æ•°ï¼ˆACFï¼‰

**è‡ªç›¸å…³å‡½æ•°**æ£€æµ‹æ—¶é—´åºåˆ—çš„å‘¨æœŸæ€§ã€‚

```sql
-- è‡ªç›¸å…³å‡½æ•°ï¼ˆACFï¼‰è®¡ç®—ï¼šæ£€æµ‹å‘¨æœŸæ€§
WITH time_series_indexed AS (
    SELECT
        date,
        value,
        AVG(value) OVER () AS mean_value,
        ROW_NUMBER() OVER (ORDER BY date) AS t
    FROM time_series
    WHERE value IS NOT NULL
),
acf_calculation AS (
    SELECT
        lag_k,
        -- è‡ªç›¸å…³ï¼šr_k = E[(y_t - mean)(y_{t+k} - mean)] / Var(y)
        AVG((t1.value - t1.mean_value) * (t2.value - t2.mean_value)) /
        NULLIF(VAR_POP(t1.value), 0) AS autocorrelation
    FROM time_series_indexed t1
    CROSS JOIN generate_series(0, 48) AS lag_k  -- æ£€æŸ¥48ä¸ªæ»å
    JOIN time_series_indexed t2 ON t2.t = t1.t + lag_k
    WHERE t2.t IS NOT NULL
    GROUP BY lag_k
)
SELECT
    lag_k,
    ROUND(autocorrelation::numeric, 4) AS acf,
    -- å‘¨æœŸæ£€æµ‹ï¼šACFæ˜¾è‘—å¤§äº0çš„æ»å
    CASE
        WHEN ABS(autocorrelation) > 0.2 THEN 'æ˜¾è‘—'
        WHEN ABS(autocorrelation) > 0.1 THEN 'å¼±æ˜¾è‘—'
        ELSE 'ä¸æ˜¾è‘—'
    END AS significance
FROM acf_calculation
ORDER BY lag_k;
```

---

## 6. å®é™…åº”ç”¨æ¡ˆä¾‹

### 6.1 å¤šå‘¨æœŸç»¼åˆåˆ†æ

**å¤šå‘¨æœŸç»¼åˆåˆ†æ**åŒæ—¶åˆ†æå¤šä¸ªå‘¨æœŸæ¨¡å¼ã€‚

```sql
-- å¤šå‘¨æœŸç»¼åˆåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING 'è¡¨ metrics ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¤šå‘¨æœŸç»¼åˆåˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¤šå‘¨æœŸç»¼åˆåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¤šå‘¨æœŸç»¼åˆåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SELECT
    EXTRACT(DOW FROM timestamp) AS day_of_week,
    EXTRACT(HOUR FROM timestamp) AS hour_of_day,
    COUNT(*) AS count,
    AVG(value) AS avg_value,
    STDDEV(value) AS stddev_value
FROM metrics
GROUP BY EXTRACT(DOW FROM timestamp), EXTRACT(HOUR FROM timestamp)
ORDER BY day_of_week, hour_of_day;
```

### 6.2 ç½‘ç«™æµé‡å‘¨æœŸæ€§åˆ†æ

**åœºæ™¯**ï¼šåˆ†æç½‘ç«™è®¿é—®é‡çš„å‘¨æœŸæ€§æ¨¡å¼ã€‚

```sql
-- ç½‘ç«™æµé‡å‘¨æœŸæ€§åˆ†æï¼šè¯†åˆ«è®¿é—®é«˜å³°æ—¶æ®µ
WITH hourly_traffic AS (
    SELECT
        DATE_TRUNC('hour', visit_time) AS hour,
        EXTRACT(DOW FROM visit_time) AS day_of_week,
        EXTRACT(HOUR FROM visit_time) AS hour_of_day,
        COUNT(*) AS page_views,
        COUNT(DISTINCT user_id) AS unique_visitors
    FROM page_views
    GROUP BY DATE_TRUNC('hour', visit_time), EXTRACT(DOW FROM visit_time), EXTRACT(HOUR FROM visit_time)
),
periodic_patterns AS (
    SELECT
        day_of_week,
        CASE day_of_week
            WHEN 0 THEN 'Sunday'
            WHEN 1 THEN 'Monday'
            WHEN 2 THEN 'Tuesday'
            WHEN 3 THEN 'Wednesday'
            WHEN 4 THEN 'Thursday'
            WHEN 5 THEN 'Friday'
            WHEN 6 THEN 'Saturday'
        END AS day_name,
        hour_of_day,
        AVG(page_views) AS avg_page_views,
        AVG(unique_visitors) AS avg_unique_visitors,
        STDDEV(page_views) AS stddev_page_views
    FROM hourly_traffic
    GROUP BY day_of_week, hour_of_day
)
SELECT
    day_name,
    hour_of_day,
    ROUND(avg_page_views::numeric, 2) AS avg_page_views,
    ROUND(avg_unique_visitors::numeric, 2) AS avg_unique_visitors,
    ROUND(stddev_page_views::numeric, 2) AS stddev_page_views,
    -- é«˜å³°æ—¶æ®µè¯†åˆ«
    CASE
        WHEN avg_page_views > AVG(avg_page_views) OVER () + STDDEV(avg_page_views) OVER () THEN 'é«˜å³°'
        WHEN avg_page_views < AVG(avg_page_views) OVER () - STDDEV(avg_page_views) OVER () THEN 'ä½è°·'
        ELSE 'æ­£å¸¸'
    END AS traffic_level
FROM periodic_patterns
ORDER BY day_of_week, hour_of_day;
```

### 6.3 é”€å”®æ•°æ®å­£èŠ‚æ€§åˆ†æ

**åœºæ™¯**ï¼šåˆ†æé”€å”®æ•°æ®çš„å­£èŠ‚æ€§æ¨¡å¼ã€‚

```sql
-- é”€å”®æ•°æ®å­£èŠ‚æ€§åˆ†æï¼šè¯†åˆ«é”€å”®æ—ºå­£å’Œæ·¡å­£
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        EXTRACT(MONTH FROM order_date) AS month_num,
        EXTRACT(QUARTER FROM order_date) AS quarter,
        SUM(order_amount) AS monthly_sales,
        COUNT(*) AS order_count
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date), EXTRACT(MONTH FROM order_date), EXTRACT(QUARTER FROM order_date)
),
seasonal_analysis AS (
    SELECT
        month_num,
        quarter,
        CASE month_num
            WHEN 1 THEN 'January'
            WHEN 2 THEN 'February'
            WHEN 3 THEN 'March'
            WHEN 4 THEN 'April'
            WHEN 5 THEN 'May'
            WHEN 6 THEN 'June'
            WHEN 7 THEN 'July'
            WHEN 8 THEN 'August'
            WHEN 9 THEN 'September'
            WHEN 10 THEN 'October'
            WHEN 11 THEN 'November'
            WHEN 12 THEN 'December'
        END AS month_name,
        AVG(monthly_sales) AS avg_monthly_sales,
        AVG(order_count) AS avg_order_count,
        STDDEV(monthly_sales) AS stddev_monthly_sales
    FROM monthly_sales
    GROUP BY month_num, quarter
),
overall_stats AS (
    SELECT
        AVG(avg_monthly_sales) AS overall_avg_sales
    FROM seasonal_analysis
)
SELECT
    sa.month_num,
    sa.month_name,
    sa.quarter,
    ROUND(sa.avg_monthly_sales::numeric, 2) AS avg_monthly_sales,
    ROUND(sa.avg_order_count::numeric, 2) AS avg_order_count,
    ROUND((sa.avg_monthly_sales / NULLIF(os.overall_avg_sales, 0))::numeric, 4) AS seasonal_index,
    -- å­£èŠ‚å¼ºåº¦
    CASE
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 1.2 THEN 'å¼ºæ—ºå­£'
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 1.1 THEN 'æ—ºå­£'
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 0.9 THEN 'æ­£å¸¸'
        WHEN sa.avg_monthly_sales > os.overall_avg_sales * 0.8 THEN 'æ·¡å­£'
        ELSE 'å¼ºæ·¡å­£'
    END AS seasonal_category
FROM seasonal_analysis sa
CROSS JOIN overall_stats os
ORDER BY sa.month_num;
```

### 6.4 ç”¨æˆ·è¡Œä¸ºå‘¨æœŸæ€§åˆ†æ

**åœºæ™¯**ï¼šåˆ†æç”¨æˆ·è¡Œä¸ºçš„å‘¨æœŸæ€§æ¨¡å¼ã€‚

```sql
-- ç”¨æˆ·è¡Œä¸ºå‘¨æœŸæ€§åˆ†æï¼šè¯†åˆ«ç”¨æˆ·æ´»è·ƒæ—¶æ®µ
WITH user_activity AS (
    SELECT
        DATE_TRUNC('hour', activity_time) AS hour,
        EXTRACT(DOW FROM activity_time) AS day_of_week,
        EXTRACT(HOUR FROM activity_time) AS hour_of_day,
        user_id,
        COUNT(*) AS activity_count
    FROM user_activities
    GROUP BY DATE_TRUNC('hour', activity_time), EXTRACT(DOW FROM activity_time), EXTRACT(HOUR FROM activity_time), user_id
),
periodic_activity AS (
    SELECT
        day_of_week,
        hour_of_day,
        AVG(activity_count) AS avg_activity,
        COUNT(DISTINCT user_id) AS active_users,
        STDDEV(activity_count) AS stddev_activity
    FROM user_activity
    GROUP BY day_of_week, hour_of_day
)
SELECT
    CASE day_of_week
        WHEN 0 THEN 'Sunday'
        WHEN 1 THEN 'Monday'
        WHEN 2 THEN 'Tuesday'
        WHEN 3 THEN 'Wednesday'
        WHEN 4 THEN 'Thursday'
        WHEN 5 THEN 'Friday'
        WHEN 6 THEN 'Saturday'
    END AS day_name,
    hour_of_day,
    ROUND(avg_activity::numeric, 2) AS avg_activity,
    active_users,
    ROUND(stddev_activity::numeric, 2) AS stddev_activity,
    -- æ´»è·ƒåº¦ç­‰çº§
    CASE
        WHEN avg_activity > AVG(avg_activity) OVER () + STDDEV(avg_activity) OVER () THEN 'é«˜æ´»è·ƒ'
        WHEN avg_activity > AVG(avg_activity) OVER () THEN 'ä¸­æ´»è·ƒ'
        WHEN avg_activity > AVG(avg_activity) OVER () - STDDEV(avg_activity) OVER () THEN 'ä½æ´»è·ƒ'
        ELSE 'æä½æ´»è·ƒ'
    END AS activity_level
FROM periodic_activity
ORDER BY day_of_week, hour_of_day;
```

---

## 7. PostgreSQL 18å¹¶è¡Œå‘¨æœŸæ€§åˆ†æ

### 7.1 å¹¶è¡Œå‘¨æœŸæ€§åˆ†ææ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œå‘¨æœŸæ€§åˆ†æ**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡å‘¨æœŸæ€§åˆ†æçš„æ€§èƒ½ã€‚

#### å¹¶è¡Œå‘¨æœŸæ€§åˆ†æé…ç½®

```sql
-- é…ç½®å¹¶è¡Œå‘¨æœŸæ€§åˆ†æå‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œå‘¨æœŸæ€§åˆ†æå‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå‘¨æœŸæ€§åˆ†æé…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œå‘¨æœŸæ€§åˆ†æå®ç°

```sql
-- å¹¶è¡Œå‘¨æœŸæ€§åˆ†æï¼šå¤§è§„æ¨¡æ—¶é—´åºåˆ—å‘¨æœŸæ£€æµ‹ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œå‘¨æœŸæ€§åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå‘¨æœŸæ€§åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œå¤šå‘¨æœŸåˆ†æ
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_time_series AS (
    SELECT
        time_series_id,
        timestamp,
        value,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day,
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(DAY FROM timestamp) AS day_of_month
    FROM time_series_data
    WHERE timestamp >= CURRENT_DATE - INTERVAL '1 year'
),
parallel_hourly_pattern AS (
    SELECT
        time_series_id,
        hour_of_day,
        AVG(value) AS avg_hourly_value,
        COUNT(*) AS sample_count
    FROM parallel_time_series
    GROUP BY time_series_id, hour_of_day
),
parallel_weekly_pattern AS (
    SELECT
        time_series_id,
        day_of_week,
        AVG(value) AS avg_daily_value,
        COUNT(*) AS sample_count
    FROM parallel_time_series
    GROUP BY time_series_id, day_of_week
)
SELECT
    'Hourly Pattern' AS pattern_type,
    time_series_id,
    hour_of_day,
    ROUND(avg_hourly_value::numeric, 2) AS avg_value,
    sample_count
FROM parallel_hourly_pattern
UNION ALL
SELECT
    'Weekly Pattern' AS pattern_type,
    time_series_id,
    day_of_week,
    ROUND(avg_daily_value::numeric, 2) AS avg_value,
    sample_count
FROM parallel_weekly_pattern
ORDER BY pattern_type, time_series_id, hour_of_day, day_of_week;
```

---

## 8. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 8.1 å‘¨æœŸæ€§æ£€æµ‹æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|-----------|-----------|---------|------|------|
| **åˆ†ç»„ç»Ÿè®¡** | $O(n)$ | $O(k)$ | å›ºå®šå‘¨æœŸ | ç®€å•å¿«é€Ÿ | éœ€è¦å·²çŸ¥å‘¨æœŸ |
| **è‡ªç›¸å…³åˆ†æ** | $O(nk)$ | $O(k)$ | å‘¨æœŸæ£€æµ‹ | è‡ªåŠ¨æ£€æµ‹ | è®¡ç®—å¤æ‚ |
| **æ–¹å·®åˆ†æ** | $O(n)$ | $O(k)$ | å‘¨æœŸéªŒè¯ | ç»Ÿè®¡æ˜¾è‘— | éœ€è¦åˆ†ç»„ |
| **å­£èŠ‚åˆ†è§£** | $O(n \log n)$ | $O(n)$ | å­£èŠ‚è°ƒæ•´ | åŠŸèƒ½å…¨é¢ | è®¡ç®—å¤æ‚ |

### 8.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **è®¡ç®—ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨èšåˆå‡½æ•°è€Œéçª—å£å‡½æ•°
   - åˆ›å»ºæ—¶é—´ç´¢å¼•
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾

2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - é™åˆ¶æ—¶é—´èŒƒå›´
   - ä½¿ç”¨åˆ†åŒºè¡¨
   - å¹¶è¡Œå¤„ç†

3. **ç®—æ³•ä¼˜åŒ–**ï¼š
   - é‡‡æ ·è®¡ç®—
   - è¿‘ä¼¼æ–¹æ³•
   - å¢é‡è®¡ç®—

### 8.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šå‘¨æœŸæ£€æµ‹ä¸å‡†ç¡®

- **è§£å†³æ–¹æ¡ˆ**ï¼šå¢åŠ æ•°æ®é‡ã€ä½¿ç”¨å¤šç§æ–¹æ³•éªŒè¯ã€å»é™¤å¼‚å¸¸å€¼

**é—®é¢˜2**ï¼šå¤šå‘¨æœŸå åŠ éš¾ä»¥åˆ†ç¦»

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å­£èŠ‚åˆ†è§£ã€åˆ†åˆ«åˆ†æå„å‘¨æœŸã€ä½¿ç”¨é¢‘åŸŸæ–¹æ³•

**é—®é¢˜3**ï¼šå‘¨æœŸé•¿åº¦å˜åŒ–

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æ»‘åŠ¨çª—å£ã€åŠ¨æ€å‘¨æœŸæ£€æµ‹ã€åˆ†æ®µåˆ†æ

**é—®é¢˜4**ï¼šè®¡ç®—æ€§èƒ½é—®é¢˜

- **è§£å†³æ–¹æ¡ˆ**ï¼šä¼˜åŒ–SQLæŸ¥è¯¢ã€ä½¿ç”¨ç´¢å¼•ã€åˆ†æ‰¹å¤„ç†

---

## 9. æœ€ä½³å®è·µ

### 9.1 å‘¨æœŸåˆ†ææ–¹æ³•é€‰æ‹©

1. **æ•°æ®æ¢ç´¢**ï¼š
   - å¯è§†åŒ–æ—¶é—´åºåˆ—
   - æ£€æŸ¥æ•°æ®è´¨é‡
   - è¯†åˆ«æ˜æ˜¾å‘¨æœŸ

2. **æ–¹æ³•é€‰æ‹©**ï¼š
   - å·²çŸ¥å‘¨æœŸï¼šä½¿ç”¨åˆ†ç»„ç»Ÿè®¡
   - æœªçŸ¥å‘¨æœŸï¼šä½¿ç”¨è‡ªç›¸å…³åˆ†æ
   - å­£èŠ‚è°ƒæ•´ï¼šä½¿ç”¨å­£èŠ‚åˆ†è§£

3. **ç»“æœéªŒè¯**ï¼š
   - ä½¿ç”¨ç»Ÿè®¡æ£€éªŒ
   - å¯è§†åŒ–éªŒè¯
   - ä¸šåŠ¡éªŒè¯

### 9.2 å‘¨æœŸæ€§åˆ†ææ³¨æ„äº‹é¡¹

1. **æ•°æ®è´¨é‡**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼
   - è¯†åˆ«å¼‚å¸¸å€¼
   - æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§

2. **å‘¨æœŸé€‰æ‹©**ï¼š
   - æ ¹æ®ä¸šåŠ¡èƒŒæ™¯é€‰æ‹©
   - è€ƒè™‘æ•°æ®ç‰¹å¾
   - éªŒè¯å‘¨æœŸåˆç†æ€§

3. **ç»“æœè§£é‡Š**ï¼š
   - ç»“åˆä¸šåŠ¡èƒŒæ™¯
   - è€ƒè™‘å¤–éƒ¨å› ç´ 
   - è°¨æ…é¢„æµ‹

### 9.3 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼š
   - ä¼˜åŒ–èšåˆæŸ¥è¯¢
   - åˆ›å»ºæ—¶é—´ç´¢å¼•
   - ä½¿ç”¨åˆ†åŒºè¡¨

2. **å‡†ç¡®æ€§**ï¼š
   - å¤„ç†æ—¶åŒºé—®é¢˜
   - å¤„ç†è¾¹ç•Œæƒ…å†µ
   - éªŒè¯è®¡ç®—ç»“æœ

3. **å¯ç»´æŠ¤æ€§**ï¼š
   - ä½¿ç”¨æ¸…æ™°çš„å˜é‡å
   - æ·»åŠ æ³¨é‡Š
   - æ¨¡å—åŒ–è®¾è®¡

### 9.4 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡å‘¨æœŸæ€§åˆ†æçš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«æ—¶é—´æˆ³çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nå‘¨æœŸæ€§æŸ¥è¯¢å’Œå¤šå‘¨æœŸå¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡å‘¨æœŸæ€§åˆ†æè®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡å‘¨æœŸæ£€æµ‹å’Œå¤šå‘¨æœŸåˆ†è§£

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - å‘¨æœŸæ€§åˆ†ææ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨7èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡æ—¶é—´åºåˆ—å‘¨æœŸæ€§åˆ†æå’Œå¤šæŒ‡æ ‡å‘¨æœŸå¯¹æ¯”

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–å‘¨æœŸæ€§åˆ†ææŸ¥è¯¢**

```sql
-- ä¸ºå‘¨æœŸæ€§åˆ†æåˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_periodicity_analysis_skip_scan
ON metrics(metric_name, EXTRACT(HOUR FROM timestamp), timestamp DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªæŒ‡æ ‡æ¯ä¸ªå°æ—¶çš„æœ€æ–°å€¼
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (metric_name, EXTRACT(HOUR FROM timestamp))
    metric_name,
    EXTRACT(HOUR FROM timestamp) AS hour_of_day,
    timestamp,
    value
FROM metrics
ORDER BY metric_name, EXTRACT(HOUR FROM timestamp), timestamp DESC
LIMIT 50;
```

### 9.5 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å‘¨æœŸæ€§åˆ†æç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„å‘¨æœŸæ€§åˆ†æç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜å‘¨æœŸæ€§åˆ†æç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS periodicity_analysis_cache AS
WITH periodicity_statistics AS (
    SELECT
        metric_name,
        EXTRACT(HOUR FROM timestamp) AS hour_of_day,
        EXTRACT(DOW FROM timestamp) AS day_of_week,
        EXTRACT(DAY FROM timestamp) AS day_of_month,
        EXTRACT(MONTH FROM timestamp) AS month_of_year,
        COUNT(*) AS sample_count,
        AVG(value) AS avg_value,
        STDDEV(value) AS stddev_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å‘¨æœŸå¼ºåº¦ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CORR(EXTRACT(HOUR FROM timestamp)::numeric, value) OVER (
            PARTITION BY metric_name
        ) AS hourly_correlation,
        CORR(EXTRACT(DOW FROM timestamp)::numeric, value) OVER (
            PARTITION BY metric_name
        ) AS weekly_correlation
    FROM metrics
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '90 days'
    GROUP BY metric_name,
             EXTRACT(HOUR FROM timestamp),
             EXTRACT(DOW FROM timestamp),
             EXTRACT(DAY FROM timestamp),
             EXTRACT(MONTH FROM timestamp)
)
SELECT
    metric_name,
    hour_of_day,
    day_of_week,
    day_of_month,
    month_of_year,
    sample_count,
    ROUND(avg_value::numeric, 4) AS avg_value,
    ROUND(stddev_value::numeric, 4) AS stddev_value,
    min_value,
    max_value,
    ROUND(hourly_correlation::numeric, 4) AS hourly_correlation,
    ROUND(weekly_correlation::numeric, 4) AS weekly_correlation,
    CASE
        WHEN ABS(hourly_correlation) > 0.7 THEN 'Strong Hourly Pattern'
        WHEN ABS(weekly_correlation) > 0.7 THEN 'Strong Weekly Pattern'
        WHEN ABS(hourly_correlation) > 0.5 OR ABS(weekly_correlation) > 0.5 THEN 'Moderate Pattern'
        ELSE 'Weak Pattern'
    END AS periodicity_strength
FROM periodicity_statistics
ORDER BY metric_name, hour_of_day, day_of_week;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_periodicity_cache_metric_hour ON periodicity_analysis_cache(metric_name, hour_of_day);
CREATE INDEX idx_periodicity_cache_strength ON periodicity_analysis_cache(periodicity_strength, ABS(hourly_correlation) DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY periodicity_analysis_cache;
```

**2. å®æ—¶å‘¨æœŸæ€§åˆ†æï¼šå¢é‡å‘¨æœŸæ›´æ–°**

**å®æ—¶å‘¨æœŸæ€§åˆ†æ**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°å‘¨æœŸæ€§åˆ†æç»“æœã€‚

```sql
-- å®æ—¶å‘¨æœŸæ€§åˆ†æï¼šå¢é‡å‘¨æœŸæ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'periodicity_analysis_state') THEN
            CREATE TABLE periodicity_analysis_state (
                metric_name VARCHAR(100) NOT NULL,
                period_type VARCHAR(20) NOT NULL,  -- 'hourly', 'daily', 'weekly', 'monthly'
                period_value INTEGER NOT NULL,  -- hour (0-23), day (1-31), etc.
                sum_value NUMERIC DEFAULT 0,
                sum_squared_value NUMERIC DEFAULT 0,
                count_samples BIGINT DEFAULT 0,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (metric_name, period_type, period_value)
            );

            CREATE INDEX idx_periodicity_state_metric_period ON periodicity_analysis_state(metric_name, period_type, period_value);
            CREATE INDEX idx_periodicity_state_updated ON periodicity_analysis_state(last_updated DESC);

            RAISE NOTICE 'å‘¨æœŸæ€§åˆ†æçŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡å‘¨æœŸæ€§åˆ†ææ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡å‘¨æœŸæ€§åˆ†ææ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°å‘¨æœŸæ€§ç»Ÿè®¡ï¼šå®æ—¶å‘¨æœŸæ€§åˆ†æ
WITH new_periodicity_data AS (
    SELECT
        metric_name,
        'hourly' AS period_type,
        EXTRACT(HOUR FROM timestamp)::INTEGER AS period_value,
        value
    FROM metrics
    WHERE timestamp > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM periodicity_analysis_state)
      AND timestamp <= CURRENT_TIMESTAMP
),
updated_periodicity_stats AS (
    SELECT
        COALESCE(pas.metric_name, npd.metric_name) AS metric_name,
        COALESCE(pas.period_type, npd.period_type) AS period_type,
        COALESCE(pas.period_value, npd.period_value) AS period_value,
        COALESCE(pas.sum_value, 0) + SUM(npd.value) AS new_sum_value,
        COALESCE(pas.sum_squared_value, 0) + SUM(POWER(npd.value, 2)) AS new_sum_squared_value,
        COALESCE(pas.count_samples, 0) + COUNT(*) AS new_count_samples
    FROM periodicity_analysis_state pas
    FULL OUTER JOIN new_periodicity_data npd ON pas.metric_name = npd.metric_name
                                                AND pas.period_type = npd.period_type
                                                AND pas.period_value = npd.period_value
    GROUP BY pas.metric_name, npd.metric_name, pas.period_type, npd.period_type,
             pas.period_value, npd.period_value, pas.sum_value, pas.sum_squared_value, pas.count_samples
)
-- æ›´æ–°æˆ–æ’å…¥å‘¨æœŸæ€§åˆ†æçŠ¶æ€
INSERT INTO periodicity_analysis_state (
    metric_name,
    period_type,
    period_value,
    sum_value,
    sum_squared_value,
    count_samples,
    last_updated
)
SELECT
    metric_name,
    period_type,
    period_value,
    new_sum_value,
    new_sum_squared_value,
    new_count_samples,
    NOW()
FROM updated_periodicity_stats
ON CONFLICT (metric_name, period_type, period_value)
DO UPDATE SET
    sum_value = EXCLUDED.sum_value,
    sum_squared_value = EXCLUDED.sum_squared_value,
    count_samples = EXCLUDED.count_samples,
    last_updated = NOW();
```

**3. æ™ºèƒ½å‘¨æœŸæ€§åˆ†æï¼šè‡ªé€‚åº”å‘¨æœŸæ£€æµ‹**

**æ™ºèƒ½å‘¨æœŸæ€§åˆ†æ**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜å‘¨æœŸæ£€æµ‹æ–¹æ³•ã€‚

```sql
-- æ™ºèƒ½å‘¨æœŸæ€§åˆ†æï¼šè‡ªé€‚åº”å‘¨æœŸæ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    data_regularity NUMERIC;
    data_variance NUMERIC;
    recommended_method VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'metrics') THEN
            RAISE WARNING 'è¡¨ metrics ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½å‘¨æœŸæ€§åˆ†æ';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        WITH periodicity_features AS (
            SELECT
                STDDEV(value) / NULLIF(AVG(value), 0) AS coefficient_of_variation,
                COUNT(DISTINCT EXTRACT(HOUR FROM timestamp)) AS unique_hours,
                COUNT(*) / EXTRACT(EPOCH FROM (MAX(timestamp) - MIN(timestamp))) * 86400 AS data_frequency
            FROM metrics
            WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '30 days'
        )
        SELECT
            coefficient_of_variation,
            CASE WHEN unique_hours = 24 THEN 1.0 ELSE 0.0 END AS regularity_score
        INTO data_variance, data_regularity
        FROM periodicity_features;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©å‘¨æœŸæ£€æµ‹æ–¹æ³•
        IF data_regularity > 0.8 AND data_variance < 0.5 THEN
            recommended_method := 'FOURIER_TRANSFORM';  -- é«˜è§„å¾‹æ€§ä½æ–¹å·®ï¼šå‚…é‡Œå¶å˜æ¢
        ELSIF data_regularity > 0.5 AND data_variance < 1.0 THEN
            recommended_method := 'AUTOCORRELATION';  -- ä¸­è§„å¾‹æ€§ä¸­æ–¹å·®ï¼šè‡ªç›¸å…³åˆ†æ
        ELSE
            recommended_method := 'STATISTICAL_ANALYSIS';  -- ä½è§„å¾‹æ€§é«˜æ–¹å·®ï¼šç»Ÿè®¡åˆ†æ
        END IF;

        RAISE NOTICE 'æ•°æ®è§„å¾‹æ€§: %, æ•°æ®æ–¹å·®: %, æ¨èæ–¹æ³•: %',
            data_regularity, data_variance, recommended_method;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½å‘¨æœŸæ€§åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ™ºèƒ½å‘¨æœŸæ€§åˆ†æï¼šæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„å‘¨æœŸæ£€æµ‹æ–¹æ³•
WITH data_characteristics AS (
    SELECT
        metric_name,
        STDDEV(value) / NULLIF(AVG(value), 0) AS coefficient_of_variation,
        COUNT(DISTINCT EXTRACT(HOUR FROM timestamp)) AS unique_hours,
        COUNT(*) / EXTRACT(EPOCH FROM (MAX(timestamp) - MIN(timestamp))) * 86400 AS data_frequency
    FROM metrics
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '30 days'
    GROUP BY metric_name
),
adaptive_periodicity_analysis AS (
    SELECT
        m.metric_name,
        m.timestamp,
        m.value,
        dc.coefficient_of_variation,
        dc.unique_hours,
        CASE
            WHEN dc.unique_hours = 24 AND dc.coefficient_of_variation < 0.5 THEN 'FOURIER_TRANSFORM'
            WHEN dc.unique_hours >= 20 AND dc.coefficient_of_variation < 1.0 THEN 'AUTOCORRELATION'
            ELSE 'STATISTICAL_ANALYSIS'
        END AS recommended_method,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å‘¨æœŸå¼ºåº¦ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN dc.unique_hours = 24 AND dc.coefficient_of_variation < 0.5 THEN
                CORR(EXTRACT(HOUR FROM m.timestamp)::numeric, m.value) OVER (
                    PARTITION BY m.metric_name
                )
            ELSE NULL
        END AS periodicity_correlation
    FROM metrics m
    JOIN data_characteristics dc ON m.metric_name = dc.metric_name
    WHERE m.timestamp >= CURRENT_TIMESTAMP - INTERVAL '30 days'
)
SELECT
    metric_name,
    recommended_method,
    ROUND(AVG(COALESCE(periodicity_correlation, 0))::numeric, 4) AS avg_periodicity_strength,
    COUNT(*) AS sample_count
FROM adaptive_periodicity_analysis
GROUP BY metric_name, recommended_method
ORDER BY avg_periodicity_strength DESC NULLS LAST
LIMIT 50;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **ã€Šæ—¶é—´åºåˆ—åˆ†æã€‹**ï¼ˆHamilton, J. D., 1994ï¼‰- å‘¨æœŸæ€§åˆ†æç†è®º

2. **ã€Šåº”ç”¨æ—¶é—´åºåˆ—åˆ†æã€‹**ï¼ˆç‹ç‡•, 2015ï¼‰- å­£èŠ‚åˆ†è§£æ–¹æ³•

3. **ã€Šé‡‘èæ—¶é—´åºåˆ—åˆ†æã€‹**ï¼ˆTsay, R. S., 2005ï¼‰- å‘¨æœŸæ€§æ£€æµ‹

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- **æ—¥æœŸæ—¶é—´å‡½æ•°**: <https://www.postgresql.org/docs/current/functions-datetime.html>
- **èšåˆå‡½æ•°**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **çª—å£å‡½æ•°**: <https://www.postgresql.org/docs/current/tutorial-window.html>

### åœ¨çº¿èµ„æº

- **å‘¨æœŸæ€§åˆ†æ**: <https://en.wikipedia.org/wiki/Periodic_function>
- **å­£èŠ‚åˆ†è§£**: <https://en.wikipedia.org/wiki/Seasonal_adjustment>
- **è‡ªç›¸å…³å‡½æ•°**: <https://en.wikipedia.org/wiki/Autocorrelation>

### ç›¸å…³ç®—æ³•

- **æ—¶é—´åºåˆ—é¢„æµ‹**ï¼šåŸºäºå‘¨æœŸæ€§çš„é¢„æµ‹
- **è¶‹åŠ¿åˆ†æ**ï¼šè¶‹åŠ¿ä¸å‘¨æœŸç»“åˆ
- **å¼‚å¸¸æ£€æµ‹ç®—æ³•**ï¼šåŸºäºå‘¨æœŸæ€§çš„å¼‚å¸¸æ£€æµ‹
- **æ»‘åŠ¨çª—å£è®¡ç®—**ï¼šå‘¨æœŸæ€§çª—å£åˆ†æ

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
