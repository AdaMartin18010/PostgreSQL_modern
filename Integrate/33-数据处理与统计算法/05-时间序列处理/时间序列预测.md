# PostgreSQL æ—¶é—´åºåˆ—é¢„æµ‹å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ—¶é—´åºåˆ—é¢„æµ‹ | è¶‹åŠ¿é¢„æµ‹
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æ—¶é—´åºåˆ—é¢„æµ‹å®Œæ•´æŒ‡å—](#postgresql-æ—¶é—´åºåˆ—é¢„æµ‹å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ—¶é—´åºåˆ—é¢„æµ‹æ¦‚è¿°](#æ—¶é—´åºåˆ—é¢„æµ‹æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æ—¶é—´åºåˆ—çš„ç»„æˆ](#æ—¶é—´åºåˆ—çš„ç»„æˆ)
      - [é¢„æµ‹æ–¹æ³•åˆ†ç±»](#é¢„æµ‹æ–¹æ³•åˆ†ç±»)
      - [é¢„æµ‹ç²¾åº¦è¯„ä¼°](#é¢„æµ‹ç²¾åº¦è¯„ä¼°)
    - [æ ¸å¿ƒé¢„æµ‹æ–¹æ³•](#æ ¸å¿ƒé¢„æµ‹æ–¹æ³•)
  - [1. çº¿æ€§è¶‹åŠ¿é¢„æµ‹](#1-çº¿æ€§è¶‹åŠ¿é¢„æµ‹)
    - [1.1 çº¿æ€§å›å½’é¢„æµ‹](#11-çº¿æ€§å›å½’é¢„æµ‹)
  - [2. æŒ‡æ•°å¹³æ»‘é¢„æµ‹](#2-æŒ‡æ•°å¹³æ»‘é¢„æµ‹)
    - [2.1 å•æŒ‡æ•°å¹³æ»‘åŸç†](#21-å•æŒ‡æ•°å¹³æ»‘åŸç†)
      - [æ•°å­¦å®šä¹‰](#æ•°å­¦å®šä¹‰)
      - [å‚æ•°é€‰æ‹©](#å‚æ•°é€‰æ‹©)
      - [åˆå§‹å€¼é€‰æ‹©](#åˆå§‹å€¼é€‰æ‹©)
    - [2.2 å•æŒ‡æ•°å¹³æ»‘å®ç°](#22-å•æŒ‡æ•°å¹³æ»‘å®ç°)
  - [3. ç§»åŠ¨å¹³å‡é¢„æµ‹](#3-ç§»åŠ¨å¹³å‡é¢„æµ‹)
    - [3.1 ç§»åŠ¨å¹³å‡åŸç†](#31-ç§»åŠ¨å¹³å‡åŸç†)
      - [æ•°å­¦å®šä¹‰](#æ•°å­¦å®šä¹‰-1)
      - [åŠ æƒç§»åŠ¨å¹³å‡ï¼ˆWeighted Moving Average, WMAï¼‰](#åŠ æƒç§»åŠ¨å¹³å‡weighted-moving-average-wma)
      - [æŒ‡æ•°åŠ æƒç§»åŠ¨å¹³å‡ï¼ˆExponentially Weighted Moving Average, EWMAï¼‰](#æŒ‡æ•°åŠ æƒç§»åŠ¨å¹³å‡exponentially-weighted-moving-average-ewma)
      - [çª—å£å¤§å°é€‰æ‹©](#çª—å£å¤§å°é€‰æ‹©)
    - [3.2 ç§»åŠ¨å¹³å‡é¢„æµ‹å®ç°](#32-ç§»åŠ¨å¹³å‡é¢„æµ‹å®ç°)
  - [4. é«˜çº§é¢„æµ‹æ–¹æ³•](#4-é«˜çº§é¢„æµ‹æ–¹æ³•)
    - [4.1 Holt-Wintersæ–¹æ³•](#41-holt-wintersæ–¹æ³•)
      - [åŠ æ³•æ¨¡å‹](#åŠ æ³•æ¨¡å‹)
    - [4.2 ARIMAæ¨¡å‹æ¦‚å¿µ](#42-arimaæ¨¡å‹æ¦‚å¿µ)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 é”€å”®é¢„æµ‹](#51-é”€å”®é¢„æµ‹)
    - [5.2 éœ€æ±‚é¢„æµ‹](#52-éœ€æ±‚é¢„æµ‹)
    - [5.3 åº“å­˜ä¼˜åŒ–](#53-åº“å­˜ä¼˜åŒ–)
    - [5.4 é¢„æµ‹ç²¾åº¦è¯„ä¼°](#54-é¢„æµ‹ç²¾åº¦è¯„ä¼°)
    - [5.5 å­£èŠ‚æ€§é¢„æµ‹](#55-å­£èŠ‚æ€§é¢„æµ‹)
  - [6. PostgreSQL 18å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹](#6-postgresql-18å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹)
    - [6.1 å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹æ¦‚è¿°](#61-å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹æ¦‚è¿°)
      - [å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹é…ç½®](#å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹é…ç½®)
      - [å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹å®ç°](#å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹å®ç°)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [7.1 é¢„æµ‹æ–¹æ³•å¯¹æ¯”](#71-é¢„æµ‹æ–¹æ³•å¯¹æ¯”)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#73-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æ•°æ®å‡†å¤‡](#81-æ•°æ®å‡†å¤‡)
    - [8.2 æ¨¡å‹é€‰æ‹©](#82-æ¨¡å‹é€‰æ‹©)
    - [8.3 é¢„æµ‹ç›‘æ§](#83-é¢„æµ‹ç›‘æ§)
    - [8.4 SQLå®ç°æ³¨æ„äº‹é¡¹](#84-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [8.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#85-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [8.6 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#86-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## æ—¶é—´åºåˆ—é¢„æµ‹æ¦‚è¿°

**æ—¶é—´åºåˆ—é¢„æµ‹ï¼ˆTime Series Forecastingï¼‰**æ˜¯åŸºäºå†å²æ•°æ®é¢„æµ‹æœªæ¥å€¼çš„é‡è¦æŠ€æœ¯ï¼Œå¹¿æ³›åº”ç”¨äºé”€å”®é¢„æµ‹ã€éœ€æ±‚è§„åˆ’ã€åº“å­˜ç®¡ç†ã€é‡‘èåˆ†æç­‰é¢†åŸŸã€‚PostgreSQLå¯ä»¥é€šè¿‡SQLå®ç°å¤šç§é¢„æµ‹ç®—æ³•ã€‚

### ç†è®ºåŸºç¡€

#### æ—¶é—´åºåˆ—çš„ç»„æˆ

æ—¶é—´åºåˆ—é€šå¸¸å¯ä»¥åˆ†è§£ä¸ºä»¥ä¸‹ç»„æˆéƒ¨åˆ†ï¼š

$$Y_t = T_t + S_t + C_t + I_t$$

å…¶ä¸­ï¼š

- **$T_t$ï¼ˆTrendï¼‰**ï¼šé•¿æœŸè¶‹åŠ¿ï¼Œæ•°æ®çš„é•¿æœŸå˜åŒ–æ–¹å‘
- **$S_t$ï¼ˆSeasonalityï¼‰**ï¼šå­£èŠ‚æ€§ï¼Œå‘¨æœŸæ€§çš„é‡å¤æ¨¡å¼
- **$C_t$ï¼ˆCyclicalï¼‰**ï¼šå‘¨æœŸæ€§ï¼Œéå›ºå®šå‘¨æœŸçš„æ³¢åŠ¨
- **$I_t$ï¼ˆIrregularï¼‰**ï¼šä¸è§„åˆ™æ³¢åŠ¨ï¼Œéšæœºå™ªå£°

#### é¢„æµ‹æ–¹æ³•åˆ†ç±»

1. **å®šæ€§æ–¹æ³•**ï¼šåŸºäºä¸“å®¶åˆ¤æ–­ã€å¸‚åœºè°ƒç ”
2. **å®šé‡æ–¹æ³•**ï¼š
   - **æ—¶é—´åºåˆ—æ–¹æ³•**ï¼šåŸºäºå†å²æ•°æ®æ¨¡å¼ï¼ˆARIMAã€æŒ‡æ•°å¹³æ»‘ç­‰ï¼‰
   - **å› æœæ–¹æ³•**ï¼šè€ƒè™‘å¤–éƒ¨å› ç´ ï¼ˆå›å½’åˆ†æã€æœºå™¨å­¦ä¹ ï¼‰

#### é¢„æµ‹ç²¾åº¦è¯„ä¼°

**å¸¸ç”¨è¯„ä¼°æŒ‡æ ‡**ï¼š

- **MAEï¼ˆMean Absolute Errorï¼‰**ï¼š$\frac{1}{n}\sum_{i=1}^{n}|y_i - \hat{y}_i|$
- **RMSEï¼ˆRoot Mean Squared Errorï¼‰**ï¼š$\sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y}_i)^2}$
- **MAPEï¼ˆMean Absolute Percentage Errorï¼‰**ï¼š$\frac{100}{n}\sum_{i=1}^{n}\left|\frac{y_i - \hat{y}_i}{y_i}\right|$

### æ ¸å¿ƒé¢„æµ‹æ–¹æ³•

| æ–¹æ³• | ç”¨é€” | å¤æ‚åº¦ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|--------|------|------|
| **çº¿æ€§å›å½’** | è¶‹åŠ¿é¢„æµ‹ | $O(n)$ | ç®€å•ã€å¯è§£é‡Š | å‡è®¾çº¿æ€§å…³ç³» |
| **æŒ‡æ•°å¹³æ»‘** | çŸ­æœŸé¢„æµ‹ | $O(n)$ | è‡ªé€‚åº”ã€å¹³æ»‘ | ä¸å¤„ç†è¶‹åŠ¿å’Œå­£èŠ‚æ€§ |
| **ç§»åŠ¨å¹³å‡** | å¹³æ»‘é¢„æµ‹ | $O(n \cdot w)$ | ç®€å•ã€ç¨³å¥ | æ»åã€ä¸é¢„æµ‹è¶‹åŠ¿ |
| **ARIMA** | å¤æ‚æ—¶é—´åºåˆ— | $O(n^2)$ | å¤„ç†è¶‹åŠ¿å’Œå­£èŠ‚æ€§ | å‚æ•°è°ƒä¼˜å¤æ‚ |
| **Holt-Winters** | è¶‹åŠ¿+å­£èŠ‚æ€§ | $O(n)$ | å¤„ç†è¶‹åŠ¿å’Œå­£èŠ‚æ€§ | å‚æ•°æ•æ„Ÿ |

---

## 1. çº¿æ€§è¶‹åŠ¿é¢„æµ‹

### 1.1 çº¿æ€§å›å½’é¢„æµ‹

**çº¿æ€§è¶‹åŠ¿é¢„æµ‹**ä½¿ç”¨çº¿æ€§å›å½’é¢„æµ‹æœªæ¥å€¼ã€‚

```sql
-- çº¿æ€§è¶‹åŠ¿é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    slope NUMERIC;
    intercept NUMERIC;
    n_val BIGINT;
    avg_x NUMERIC;
    avg_y NUMERIC;
    sum_xy NUMERIC;
    sum_x2 NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œçº¿æ€§è¶‹åŠ¿é¢„æµ‹';
            RETURN;
        END IF;

        SELECT
            COUNT(*),
            AVG(EXTRACT(EPOCH FROM date)),
            AVG(value),
            SUM(EXTRACT(EPOCH FROM date) * value),
            SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date))
        INTO n_val, avg_x, avg_y, sum_xy, sum_x2
        FROM time_series
        WHERE value IS NOT NULL;

        slope := (sum_xy - n_val * avg_x * avg_y) / NULLIF(sum_x2 - n_val * avg_x * avg_x, 0);
        intercept := avg_y - slope * avg_x;

        RAISE NOTICE 'çº¿æ€§å›å½’å‚æ•°:';
        RAISE NOTICE '  æ–œç‡: %', slope;
        RAISE NOTICE '  æˆªè·: %', intercept;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'çº¿æ€§è¶‹åŠ¿é¢„æµ‹å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- é¢„æµ‹æœªæ¥å€¼
WITH regression AS (
    SELECT
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept
    FROM (
        SELECT
            COUNT(*) AS n,
            AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
            AVG(value) AS avg_y,
            SUM(EXTRACT(EPOCH FROM date) * value) AS sum_xy,
            SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2
        FROM time_series
        WHERE value IS NOT NULL
    ) AS stats
),
future_dates AS (
    SELECT generate_series(
        (SELECT MAX(date) FROM time_series) + INTERVAL '1 day',
        (SELECT MAX(date) FROM time_series) + INTERVAL '30 days',
        '1 day'::interval
    )::date AS date
)
SELECT
    fd.date,
    r.slope * EXTRACT(EPOCH FROM fd.date) + r.intercept AS predicted_value
FROM future_dates fd
CROSS JOIN regression r
ORDER BY fd.date;
```

---

## 2. æŒ‡æ•°å¹³æ»‘é¢„æµ‹

### 2.1 å•æŒ‡æ•°å¹³æ»‘åŸç†

**å•æŒ‡æ•°å¹³æ»‘ï¼ˆSimple Exponential Smoothing, SESï¼‰**é€‚ç”¨äºæ²¡æœ‰æ˜æ˜¾è¶‹åŠ¿å’Œå­£èŠ‚æ€§çš„æ—¶é—´åºåˆ—ã€‚

#### æ•°å­¦å®šä¹‰

**å¹³æ»‘å…¬å¼**ï¼š
$$S_t = \alpha Y_t + (1-\alpha) S_{t-1}$$

å…¶ä¸­ï¼š

- $S_t$ æ˜¯æ—¶åˆ» $t$ çš„å¹³æ»‘å€¼
- $Y_t$ æ˜¯æ—¶åˆ» $t$ çš„è§‚æµ‹å€¼
- $\alpha \in [0,1]$ æ˜¯å¹³æ»‘å‚æ•°ï¼ˆå¹³æ»‘ç³»æ•°ï¼‰

**é¢„æµ‹å…¬å¼**ï¼š
$$\hat{Y}_{t+h} = S_t$$

å…¶ä¸­ $h$ æ˜¯é¢„æµ‹æ­¥é•¿ã€‚

#### å‚æ•°é€‰æ‹©

- **$\alpha$ æ¥è¿‘1**ï¼šå¯¹è¿‘æœŸæ•°æ®æƒé‡é«˜ï¼Œå“åº”å¿«ï¼Œä½†æ³¢åŠ¨å¤§
- **$\alpha$ æ¥è¿‘0**ï¼šå¯¹å†å²æ•°æ®æƒé‡é«˜ï¼Œå¹³æ»‘æ•ˆæœå¥½ï¼Œä½†å“åº”æ…¢
- **$\alpha$ çš„é€‰æ‹©**ï¼šé€šå¸¸é€šè¿‡äº¤å‰éªŒè¯æˆ–æœ€å°åŒ–é¢„æµ‹è¯¯å·®ç¡®å®š

#### åˆå§‹å€¼é€‰æ‹©

- **$S_1 = Y_1$**ï¼šä½¿ç”¨ç¬¬ä¸€ä¸ªè§‚æµ‹å€¼
- **$S_1 = \bar{Y}$**ï¼šä½¿ç”¨å‰å‡ ä¸ªè§‚æµ‹å€¼çš„å‡å€¼

### 2.2 å•æŒ‡æ•°å¹³æ»‘å®ç°

```sql
-- å•æŒ‡æ•°å¹³æ»‘é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    alpha NUMERIC := 0.3;
    last_value NUMERIC;
    last_smoothed NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒæŒ‡æ•°å¹³æ»‘é¢„æµ‹';
            RETURN;
        END IF;

        SELECT value INTO last_value
        FROM time_series
        ORDER BY date DESC
        LIMIT 1;

        RAISE NOTICE 'æŒ‡æ•°å¹³æ»‘é¢„æµ‹ï¼Œå¹³æ»‘ç³»æ•°: %, æœ€åå€¼: %', alpha, last_value;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŒ‡æ•°å¹³æ»‘é¢„æµ‹å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH smoothed_values AS (
    SELECT
        date,
        value,
        value AS smoothed,
        0.3 AS alpha
    FROM time_series
    WHERE date = (SELECT MIN(date) FROM time_series)
    UNION ALL
    SELECT
        t.date,
        t.value,
        s.smoothed * (1 - s.alpha) + t.value * s.alpha AS smoothed,
        s.alpha
    FROM time_series t
    JOIN smoothed_values s ON t.date = s.date + INTERVAL '1 day'
)
SELECT * FROM smoothed_values ORDER BY date;
```

---

## 3. ç§»åŠ¨å¹³å‡é¢„æµ‹

### 3.1 ç§»åŠ¨å¹³å‡åŸç†

**ç§»åŠ¨å¹³å‡ï¼ˆMoving Average, MAï¼‰**é€šè¿‡è®¡ç®—æœ€è¿‘ $w$ ä¸ªè§‚æµ‹å€¼çš„å¹³å‡å€¼æ¥é¢„æµ‹æœªæ¥å€¼ã€‚

#### æ•°å­¦å®šä¹‰

**ç®€å•ç§»åŠ¨å¹³å‡ï¼ˆSimple Moving Average, SMAï¼‰**ï¼š
$$MA_t = \frac{1}{w}\sum_{i=t-w+1}^{t} Y_i$$

**é¢„æµ‹å…¬å¼**ï¼š
$$\hat{Y}_{t+h} = MA_t$$

#### åŠ æƒç§»åŠ¨å¹³å‡ï¼ˆWeighted Moving Average, WMAï¼‰

**åŠ æƒç§»åŠ¨å¹³å‡**ï¼š
$$WMA_t = \frac{\sum_{i=t-w+1}^{t} w_i Y_i}{\sum_{i=t-w+1}^{t} w_i}$$

å…¶ä¸­ $w_i$ æ˜¯æƒé‡ï¼Œé€šå¸¸è¿‘æœŸæ•°æ®æƒé‡æ›´å¤§ã€‚

#### æŒ‡æ•°åŠ æƒç§»åŠ¨å¹³å‡ï¼ˆExponentially Weighted Moving Average, EWMAï¼‰

**æŒ‡æ•°åŠ æƒç§»åŠ¨å¹³å‡**ï¼š
$$EWMA_t = \alpha Y_t + (1-\alpha) EWMA_{t-1}$$

è¿™ä¸å•æŒ‡æ•°å¹³æ»‘ç›¸åŒã€‚

#### çª—å£å¤§å°é€‰æ‹©

- **å°çª—å£ï¼ˆ$w=3-5$ï¼‰**ï¼šå“åº”å¿«ï¼Œä½†æ³¢åŠ¨å¤§
- **å¤§çª—å£ï¼ˆ$w=10-20$ï¼‰**ï¼šå¹³æ»‘æ•ˆæœå¥½ï¼Œä½†æ»åæ˜æ˜¾
- **é€‰æ‹©åŸåˆ™**ï¼šå¹³è¡¡å“åº”é€Ÿåº¦å’Œå¹³æ»‘æ•ˆæœ

### 3.2 ç§»åŠ¨å¹³å‡é¢„æµ‹å®ç°

```sql
-- ç§»åŠ¨å¹³å‡é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    window_size INTEGER := 7;
    last_avg NUMERIC;
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨å¹³å‡é¢„æµ‹';
            RETURN;
        END IF;

        SELECT AVG(value) INTO last_avg
        FROM (
            SELECT value
            FROM time_series
            ORDER BY date DESC
            LIMIT window_size
        ) AS recent_values;

        RAISE NOTICE 'ç§»åŠ¨å¹³å‡é¢„æµ‹ï¼Œçª—å£å¤§å°: %, é¢„æµ‹å€¼: %', window_size, last_avg;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç§»åŠ¨å¹³å‡é¢„æµ‹å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH recent_avg AS (
    SELECT AVG(value) AS avg_value
    FROM (
        SELECT value
        FROM time_series
        ORDER BY date DESC
        LIMIT 7
    ) AS recent
),
future_dates AS (
    SELECT generate_series(
        (SELECT MAX(date) FROM time_series) + INTERVAL '1 day',
        (SELECT MAX(date) FROM time_series) + INTERVAL '7 days',
        '1 day'::interval
    )::date AS date
)
SELECT
    fd.date,
    ra.avg_value AS predicted_value
FROM future_dates fd
CROSS JOIN recent_avg ra
ORDER BY fd.date;
```

---

## 4. é«˜çº§é¢„æµ‹æ–¹æ³•

### 4.1 Holt-Wintersæ–¹æ³•

**Holt-Wintersæ–¹æ³•**æ‰©å±•æŒ‡æ•°å¹³æ»‘ï¼Œå¤„ç†è¶‹åŠ¿å’Œå­£èŠ‚æ€§ã€‚

#### åŠ æ³•æ¨¡å‹

**æ°´å¹³ï¼ˆLevelï¼‰**ï¼š
$$L_t = \alpha \frac{Y_t}{S_{t-s}} + (1-\alpha)(L_{t-1} + T_{t-1})$$

**è¶‹åŠ¿ï¼ˆTrendï¼‰**ï¼š
$$T_t = \beta(L_t - L_{t-1}) + (1-\beta)T_{t-1}$$

**å­£èŠ‚æ€§ï¼ˆSeasonalï¼‰**ï¼š
$$S_t = \gamma \frac{Y_t}{L_t} + (1-\gamma)S_{t-s}$$

**é¢„æµ‹**ï¼š
$$\hat{Y}_{t+h} = (L_t + h \cdot T_t) \cdot S_{t-s+h}$$

å…¶ä¸­ $s$ æ˜¯å­£èŠ‚å‘¨æœŸé•¿åº¦ã€‚

### 4.2 ARIMAæ¨¡å‹æ¦‚å¿µ

**ARIMAï¼ˆAutoRegressive Integrated Moving Averageï¼‰**æ˜¯ç»å…¸çš„æ—¶é—´åºåˆ—é¢„æµ‹æ¨¡å‹ã€‚

**ARIMA(p,d,q)æ¨¡å‹**ï¼š

- **AR(p)**ï¼šè‡ªå›å½’é¡¹ï¼Œä½¿ç”¨å‰ $p$ ä¸ªå€¼
- **I(d)**ï¼šå·®åˆ†é¡¹ï¼Œä½¿åºåˆ—å¹³ç¨³
- **MA(q)**ï¼šç§»åŠ¨å¹³å‡é¡¹ï¼Œä½¿ç”¨å‰ $q$ ä¸ªè¯¯å·®

**æ³¨æ„**ï¼šå®Œæ•´çš„ARIMAå®ç°éœ€è¦å¤æ‚çš„å‚æ•°ä¼°è®¡ï¼ŒPostgreSQLä¸­å¯ä»¥ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬æˆ–è°ƒç”¨å¤–éƒ¨å·¥å…·ã€‚

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 é”€å”®é¢„æµ‹

**é”€å”®é¢„æµ‹**é¢„æµ‹æœªæ¥é”€å”®è¶‹åŠ¿ï¼Œæ”¯æŒåº“å­˜ç®¡ç†å’Œä¸šåŠ¡è§„åˆ’ã€‚

```sql
-- é”€å”®é¢„æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING 'è¡¨ sales ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œé”€å”®é¢„æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œé”€å”®é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é”€å”®é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

WITH daily_sales AS (
    SELECT
        DATE_TRUNC('day', sale_date) AS date,
        SUM(amount) AS daily_amount
    FROM sales
    GROUP BY DATE_TRUNC('day', sale_date)
),
regression AS (
    SELECT
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept
    FROM (
        SELECT
            COUNT(*) AS n,
            AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
            AVG(daily_amount) AS avg_y,
            SUM(EXTRACT(EPOCH FROM date) * daily_amount) AS sum_xy,
            SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2
        FROM daily_sales
    ) AS stats
),
future_dates AS (
    SELECT generate_series(
        (SELECT MAX(date) FROM daily_sales) + INTERVAL '1 day',
        (SELECT MAX(date) FROM daily_sales) + INTERVAL '30 days',
        '1 day'::interval
    )::date AS date
)
SELECT
    fd.date,
    GREATEST(0, r.slope * EXTRACT(EPOCH FROM fd.date) + r.intercept) AS predicted_sales
FROM future_dates fd
CROSS JOIN regression r
ORDER BY fd.date;
```

### 5.2 éœ€æ±‚é¢„æµ‹

**åœºæ™¯**ï¼šé¢„æµ‹äº§å“éœ€æ±‚é‡ï¼Œä¼˜åŒ–åº“å­˜ç®¡ç†ã€‚

```sql
-- éœ€æ±‚é¢„æµ‹ï¼šä½¿ç”¨å¤šç§æ–¹æ³•é¢„æµ‹äº§å“éœ€æ±‚
WITH demand_history AS (
    SELECT
        product_id,
        date,
        demand_quantity
    FROM product_demand
    WHERE date >= CURRENT_DATE - INTERVAL '90 days'
    ORDER BY product_id, date
),
-- æ–¹æ³•1ï¼šçº¿æ€§è¶‹åŠ¿é¢„æµ‹
linear_forecast AS (
    SELECT
        product_id,
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept,
        MAX(date) AS last_date
    FROM (
        SELECT
            product_id,
            COUNT(*) AS n,
            AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
            AVG(demand_quantity) AS avg_y,
            SUM(EXTRACT(EPOCH FROM date) * demand_quantity) AS sum_xy,
            SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2
        FROM demand_history
        GROUP BY product_id
    ) AS stats
),
-- æ–¹æ³•2ï¼šæŒ‡æ•°å¹³æ»‘é¢„æµ‹
exponential_smoothing AS (
    SELECT DISTINCT ON (product_id)
        product_id,
        demand_quantity AS last_smoothed,
        date AS last_date
    FROM (
        SELECT
            product_id,
            date,
            demand_quantity,
            0.3 AS alpha,
            LAG(demand_quantity * 0.3 + LAG(demand_quantity, 1) OVER (PARTITION BY product_id ORDER BY date) * 0.7, 1)
            OVER (PARTITION BY product_id ORDER BY date) AS smoothed
        FROM demand_history
    ) AS smoothed_data
    ORDER BY product_id, date DESC
),
-- æ–¹æ³•3ï¼šç§»åŠ¨å¹³å‡é¢„æµ‹
moving_average AS (
    SELECT
        product_id,
        AVG(demand_quantity) AS ma_value,
        MAX(date) AS last_date
    FROM (
        SELECT
            product_id,
            date,
            demand_quantity,
            ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY date DESC) AS rn
        FROM demand_history
    ) AS ranked
    WHERE rn <= 7  -- 7å¤©ç§»åŠ¨å¹³å‡
    GROUP BY product_id
),
-- ç”Ÿæˆæœªæ¥7å¤©çš„é¢„æµ‹
future_dates AS (
    SELECT
        product_id,
        generate_series(
            last_date + INTERVAL '1 day',
            last_date + INTERVAL '7 days',
            '1 day'::interval
        )::date AS forecast_date
    FROM (
        SELECT DISTINCT product_id, MAX(date) AS last_date
        FROM demand_history
        GROUP BY product_id
    ) AS max_dates
),
-- ç»¼åˆé¢„æµ‹ç»“æœ
forecast_results AS (
    SELECT
        fd.product_id,
        fd.forecast_date,
        -- çº¿æ€§é¢„æµ‹
        GREATEST(0, lf.slope * EXTRACT(EPOCH FROM fd.forecast_date) + lf.intercept) AS linear_forecast,
        -- æŒ‡æ•°å¹³æ»‘é¢„æµ‹
        es.last_smoothed AS exponential_forecast,
        -- ç§»åŠ¨å¹³å‡é¢„æµ‹
        ma.ma_value AS moving_avg_forecast,
        -- ç»¼åˆé¢„æµ‹ï¼ˆç®€å•å¹³å‡ï¼‰
        (
            GREATEST(0, lf.slope * EXTRACT(EPOCH FROM fd.forecast_date) + lf.intercept) +
            es.last_smoothed +
            ma.ma_value
        ) / 3.0 AS ensemble_forecast
    FROM future_dates fd
    LEFT JOIN linear_forecast lf ON fd.product_id = lf.product_id
    LEFT JOIN exponential_smoothing es ON fd.product_id = es.product_id
    LEFT JOIN moving_average ma ON fd.product_id = ma.product_id
)
SELECT
    product_id,
    forecast_date,
    ROUND(linear_forecast::numeric, 2) AS linear_forecast,
    ROUND(exponential_forecast::numeric, 2) AS exponential_forecast,
    ROUND(moving_avg_forecast::numeric, 2) AS moving_avg_forecast,
    ROUND(ensemble_forecast::numeric, 2) AS ensemble_forecast
FROM forecast_results
ORDER BY product_id, forecast_date;
```

### 5.3 åº“å­˜ä¼˜åŒ–

**åœºæ™¯**ï¼šåŸºäºéœ€æ±‚é¢„æµ‹ä¼˜åŒ–åº“å­˜æ°´å¹³ã€‚

```sql
-- åº“å­˜ä¼˜åŒ–ï¼šåŸºäºé¢„æµ‹éœ€æ±‚è®¡ç®—å®‰å…¨åº“å­˜
WITH demand_forecast AS (
    -- ä½¿ç”¨ç§»åŠ¨å¹³å‡é¢„æµ‹æœªæ¥30å¤©éœ€æ±‚
    SELECT
        product_id,
        AVG(demand_quantity) AS forecasted_daily_demand,
        STDDEV(demand_quantity) AS demand_stddev,
        MAX(date) AS last_date
    FROM (
        SELECT
            product_id,
            date,
            demand_quantity,
            ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY date DESC) AS rn
        FROM product_demand
        WHERE date >= CURRENT_DATE - INTERVAL '30 days'
    ) AS recent_demand
    WHERE rn <= 30
    GROUP BY product_id
),
lead_time_stats AS (
    SELECT
        product_id,
        AVG(lead_time_days) AS avg_lead_time,
        STDDEV(lead_time_days) AS lead_time_stddev
    FROM supplier_orders
    WHERE order_date >= CURRENT_DATE - INTERVAL '90 days'
    GROUP BY product_id
),
safety_stock AS (
    SELECT
        df.product_id,
        df.forecasted_daily_demand,
        df.demand_stddev,
        lt.avg_lead_time,
        lt.lead_time_stddev,
        -- å®‰å…¨åº“å­˜ = Z * sqrt(lead_time * demand_variance + demand_mean^2 * lead_time_variance)
        -- Z = 1.65 (95%æœåŠ¡æ°´å¹³)
        1.65 * SQRT(
            lt.avg_lead_time * POWER(df.demand_stddev, 2) +
            POWER(df.forecasted_daily_demand, 2) * POWER(lt.lead_time_stddev, 2)
        ) AS safety_stock_quantity,
        -- å†è®¢è´§ç‚¹ = lead_time_demand + safety_stock
        lt.avg_lead_time * df.forecasted_daily_demand +
        1.65 * SQRT(
            lt.avg_lead_time * POWER(df.demand_stddev, 2) +
            POWER(df.forecasted_daily_demand, 2) * POWER(lt.lead_time_stddev, 2)
        ) AS reorder_point
    FROM demand_forecast df
    LEFT JOIN lead_time_stats lt ON df.product_id = lt.product_id
)
SELECT
    product_id,
    ROUND(forecasted_daily_demand::numeric, 2) AS forecasted_daily_demand,
    ROUND(avg_lead_time::numeric, 1) AS avg_lead_time_days,
    ROUND(safety_stock_quantity::numeric, 0) AS safety_stock_quantity,
    ROUND(reorder_point::numeric, 0) AS reorder_point,
    CASE
        WHEN reorder_point > 0 THEN 'éœ€è¦è¡¥è´§'
        ELSE 'åº“å­˜å……è¶³'
    END AS inventory_status
FROM safety_stock
ORDER BY safety_stock_quantity DESC;
```

### 5.4 é¢„æµ‹ç²¾åº¦è¯„ä¼°

**åœºæ™¯**ï¼šè¯„ä¼°ä¸åŒé¢„æµ‹æ–¹æ³•çš„å‡†ç¡®æ€§ã€‚

```sql
-- é¢„æµ‹ç²¾åº¦è¯„ä¼°ï¼šæ¯”è¾ƒä¸åŒæ–¹æ³•çš„é¢„æµ‹è¯¯å·®
WITH historical_data AS (
    SELECT
        date,
        value
    FROM time_series
    WHERE date >= CURRENT_DATE - INTERVAL '60 days'
    ORDER BY date
),
-- è®­ç»ƒé›†ï¼ˆå‰45å¤©ï¼‰
training_data AS (
    SELECT *
    FROM historical_data
    WHERE date <= (SELECT MAX(date) - INTERVAL '15 days' FROM historical_data)
),
-- æµ‹è¯•é›†ï¼ˆå15å¤©ï¼‰
test_data AS (
    SELECT *
    FROM historical_data
    WHERE date > (SELECT MAX(date) - INTERVAL '15 days' FROM historical_data)
),
-- çº¿æ€§å›å½’æ¨¡å‹
linear_model AS (
    SELECT
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept
    FROM (
        SELECT
            COUNT(*) AS n,
            AVG(EXTRACT(EPOCH FROM date)) AS avg_x,
            AVG(value) AS avg_y,
            SUM(EXTRACT(EPOCH FROM date) * value) AS sum_xy,
            SUM(EXTRACT(EPOCH FROM date) * EXTRACT(EPOCH FROM date)) AS sum_x2
        FROM training_data
    ) AS stats
),
-- ç§»åŠ¨å¹³å‡æ¨¡å‹ï¼ˆä½¿ç”¨è®­ç»ƒé›†æœ€å7å¤©ï¼‰
ma_model AS (
    SELECT AVG(value) AS ma_value
    FROM (
        SELECT value
        FROM training_data
        ORDER BY date DESC
        LIMIT 7
    ) AS recent
),
-- é¢„æµ‹å’Œè¯„ä¼°
predictions AS (
    SELECT
        td.date,
        td.value AS actual_value,
        -- çº¿æ€§é¢„æµ‹
        lm.slope * EXTRACT(EPOCH FROM td.date) + lm.intercept AS linear_pred,
        -- ç§»åŠ¨å¹³å‡é¢„æµ‹
        mam.ma_value AS ma_pred
    FROM test_data td
    CROSS JOIN linear_model lm
    CROSS JOIN ma_model mam
),
evaluation AS (
    SELECT
        COUNT(*) AS n,
        -- çº¿æ€§å›å½’è¯¯å·®
        AVG(ABS(actual_value - linear_pred)) AS linear_mae,
        SQRT(AVG(POWER(actual_value - linear_pred, 2))) AS linear_rmse,
        AVG(ABS((actual_value - linear_pred) / NULLIF(actual_value, 0))) * 100 AS linear_mape,
        -- ç§»åŠ¨å¹³å‡è¯¯å·®
        AVG(ABS(actual_value - ma_pred)) AS ma_mae,
        SQRT(AVG(POWER(actual_value - ma_pred, 2))) AS ma_rmse,
        AVG(ABS((actual_value - ma_pred) / NULLIF(actual_value, 0))) * 100 AS ma_mape
    FROM predictions
)
SELECT
    n AS test_samples,
    ROUND(linear_mae::numeric, 4) AS linear_mae,
    ROUND(linear_rmse::numeric, 4) AS linear_rmse,
    ROUND(linear_mape::numeric, 2) AS linear_mape_pct,
    ROUND(ma_mae::numeric, 4) AS ma_mae,
    ROUND(ma_rmse::numeric, 4) AS ma_rmse,
    ROUND(ma_mape::numeric, 2) AS ma_mape_pct,
    CASE
        WHEN linear_mae < ma_mae THEN 'çº¿æ€§å›å½’æ›´ä¼˜'
        ELSE 'ç§»åŠ¨å¹³å‡æ›´ä¼˜'
    END AS best_method
FROM evaluation;
```

### 5.5 å­£èŠ‚æ€§é¢„æµ‹

**åœºæ™¯**ï¼šè€ƒè™‘å­£èŠ‚æ€§çš„é”€å”®é¢„æµ‹ã€‚

```sql
-- å­£èŠ‚æ€§é¢„æµ‹ï¼šè€ƒè™‘å‘¨æœŸæ€§æ¨¡å¼
WITH sales_data AS (
    SELECT
        DATE_TRUNC('month', sale_date) AS month,
        SUM(amount) AS monthly_sales
    FROM sales
    WHERE sale_date >= CURRENT_DATE - INTERVAL '24 months'
    GROUP BY DATE_TRUNC('month', sale_date)
    ORDER BY month
),
seasonal_indices AS (
    SELECT
        EXTRACT(MONTH FROM month) AS month_num,
        AVG(monthly_sales) AS avg_monthly_sales,
        (AVG(monthly_sales) / (SELECT AVG(monthly_sales) FROM sales_data)) AS seasonal_index
    FROM sales_data
    GROUP BY EXTRACT(MONTH FROM month)
),
trend_model AS (
    SELECT
        (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) AS slope,
        avg_y - (sum_xy - n * avg_x * avg_y) / NULLIF(sum_x2 - n * avg_x * avg_x, 0) * avg_x AS intercept
    FROM (
        SELECT
            COUNT(*) AS n,
            AVG(EXTRACT(EPOCH FROM month)) AS avg_x,
            AVG(monthly_sales) AS avg_y,
            SUM(EXTRACT(EPOCH FROM month) * monthly_sales) AS sum_xy,
            SUM(EXTRACT(EPOCH FROM month) * EXTRACT(EPOCH FROM month)) AS sum_x2
        FROM sales_data
    ) AS stats
),
future_months AS (
    SELECT generate_series(
        (SELECT MAX(month) FROM sales_data) + INTERVAL '1 month',
        (SELECT MAX(month) FROM sales_data) + INTERVAL '12 months',
        '1 month'::interval
    )::date AS forecast_month
),
seasonal_forecast AS (
    SELECT
        fm.forecast_month,
        EXTRACT(MONTH FROM fm.forecast_month) AS month_num,
        tm.slope * EXTRACT(EPOCH FROM fm.forecast_month) + tm.intercept AS trend_value,
        si.seasonal_index,
        (tm.slope * EXTRACT(EPOCH FROM fm.forecast_month) + tm.intercept) * si.seasonal_index AS seasonal_forecast
    FROM future_months fm
    CROSS JOIN trend_model tm
    JOIN seasonal_indices si ON EXTRACT(MONTH FROM fm.forecast_month) = si.month_num
)
SELECT
    forecast_month,
    ROUND(trend_value::numeric, 2) AS trend_forecast,
    ROUND(seasonal_index::numeric, 4) AS seasonal_index,
    ROUND(seasonal_forecast::numeric, 2) AS seasonal_adjusted_forecast
FROM seasonal_forecast
ORDER BY forecast_month;
```

---

## 6. PostgreSQL 18å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹

### 6.1 å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹æ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡æ—¶é—´åºåˆ—é¢„æµ‹çš„æ€§èƒ½ã€‚

#### å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹é…ç½®

```sql
-- é…ç½®å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹å‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹å‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹é…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹å®ç°

```sql
-- å¹¶è¡Œç§»åŠ¨å¹³å‡é¢„æµ‹ï¼šå¤§è§„æ¨¡æ—¶é—´åºåˆ—é¢„æµ‹ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ—¶é—´åºåˆ—é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œç§»åŠ¨å¹³å‡é¢„æµ‹
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_historical AS (
    SELECT
        time_series_id,
        timestamp,
        value
    FROM time_series_data
    WHERE timestamp >= CURRENT_DATE - INTERVAL '1 year'
),
parallel_ma AS (
    SELECT
        time_series_id,
        timestamp,
        value,
        AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS ma_7,
        AVG(value) OVER (
            PARTITION BY time_series_id
            ORDER BY timestamp
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS ma_30
    FROM parallel_historical
)
SELECT
    time_series_id,
    timestamp,
    ROUND(value::numeric, 2) AS actual_value,
    ROUND(ma_7::numeric, 2) AS ma_7_forecast,
    ROUND(ma_30::numeric, 2) AS ma_30_forecast,
    CASE
        WHEN ma_7 > ma_30 THEN 'Upward Trend'
        WHEN ma_7 < ma_30 THEN 'Downward Trend'
        ELSE 'Sideways'
    END AS trend
FROM parallel_ma
WHERE ma_7 IS NOT NULL AND ma_30 IS NOT NULL
ORDER BY time_series_id, timestamp DESC;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 7.1 é¢„æµ‹æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é¢„æµ‹ç²¾åº¦ |
|------|---------|------|------|---------|
| **çº¿æ€§å›å½’** | æœ‰æ˜æ˜¾è¶‹åŠ¿ | ç®€å•ã€å¯è§£é‡Š | å‡è®¾çº¿æ€§å…³ç³» | ä¸­ç­‰ |
| **å•æŒ‡æ•°å¹³æ»‘** | æ— è¶‹åŠ¿æ— å­£èŠ‚æ€§ | è‡ªé€‚åº”ã€å¹³æ»‘ | ä¸å¤„ç†è¶‹åŠ¿ | ä¸­ç­‰ |
| **ç§»åŠ¨å¹³å‡** | çŸ­æœŸé¢„æµ‹ | ç®€å•ã€ç¨³å¥ | æ»åæ˜æ˜¾ | è¾ƒä½ |
| **Holt-Winters** | æœ‰è¶‹åŠ¿å’Œå­£èŠ‚æ€§ | å¤„ç†å¤æ‚æ¨¡å¼ | å‚æ•°æ•æ„Ÿ | è¾ƒé«˜ |
| **ARIMA** | å¤æ‚æ—¶é—´åºåˆ— | ç†è®ºåŸºç¡€å¼º | å‚æ•°è°ƒä¼˜å¤æ‚ | é«˜ |

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **æ•°æ®é¢„å¤„ç†**ï¼šå¤„ç†ç¼ºå¤±å€¼ã€å¼‚å¸¸å€¼ã€å¹³ç¨³åŒ–
2. **ç‰¹å¾å·¥ç¨‹**ï¼šåˆ›å»ºæ»åç‰¹å¾ã€ç§»åŠ¨å¹³å‡ç‰¹å¾
3. **æ¨¡å‹ç»„åˆ**ï¼šä½¿ç”¨é›†æˆæ–¹æ³•æé«˜é¢„æµ‹ç²¾åº¦
4. **å‚æ•°è°ƒä¼˜**ï¼šä½¿ç”¨äº¤å‰éªŒè¯é€‰æ‹©æœ€ä¼˜å‚æ•°
5. **å®æ—¶æ›´æ–°**ï¼šå®šæœŸé‡æ–°è®­ç»ƒæ¨¡å‹

### 7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šé¢„æµ‹å€¼æ»å

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æ›´çŸ­çš„çª—å£ã€å¢åŠ è¶‹åŠ¿é¡¹ã€ä½¿ç”¨ARIMA

**é—®é¢˜2**ï¼šå­£èŠ‚æ€§æ¨¡å¼ä¸æ˜æ˜¾

- **è§£å†³æ–¹æ¡ˆ**ï¼šå¢åŠ æ•°æ®é‡ã€ä½¿ç”¨Holt-Wintersã€æ£€æŸ¥å‘¨æœŸé•¿åº¦

**é—®é¢˜3**ï¼šé¢„æµ‹è¯¯å·®å¤§

- **è§£å†³æ–¹æ¡ˆ**ï¼šæ£€æŸ¥æ•°æ®è´¨é‡ã€å°è¯•ä¸åŒæ–¹æ³•ã€ä½¿ç”¨é›†æˆé¢„æµ‹

**é—®é¢˜4**ï¼šæ•°æ®ä¸å¹³ç¨³

- **è§£å†³æ–¹æ¡ˆ**ï¼šå·®åˆ†å¤„ç†ã€å¯¹æ•°å˜æ¢ã€åˆ†æ®µå»ºæ¨¡

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ•°æ®å‡†å¤‡

1. **æ•°æ®è´¨é‡**ï¼š
   - å¤„ç†ç¼ºå¤±å€¼ï¼šæ’å€¼ã€åˆ é™¤æˆ–å¡«å……
   - å¤„ç†å¼‚å¸¸å€¼ï¼šè¯†åˆ«å’Œå¤„ç†æç«¯å€¼
   - æ•°æ®æ¸…æ´—ï¼šå»é™¤å™ªå£°å’Œé”™è¯¯æ•°æ®

2. **æ•°æ®æ¢ç´¢**ï¼š
   - å¯è§†åŒ–æ—¶é—´åºåˆ—å›¾
   - æ£€æŸ¥è¶‹åŠ¿ã€å­£èŠ‚æ€§ã€å‘¨æœŸæ€§
   - åˆ†æè‡ªç›¸å…³å’Œåè‡ªç›¸å…³

3. **æ•°æ®åˆ†å‰²**ï¼š
   - è®­ç»ƒé›†ï¼š70-80%
   - éªŒè¯é›†ï¼š10-15%
   - æµ‹è¯•é›†ï¼š10-15%

### 8.2 æ¨¡å‹é€‰æ‹©

1. **æ•°æ®ç‰¹å¾**ï¼š
   - æœ‰è¶‹åŠ¿ï¼šä½¿ç”¨çº¿æ€§å›å½’æˆ–Holt-Winters
   - æœ‰å­£èŠ‚æ€§ï¼šä½¿ç”¨Holt-Wintersæˆ–ARIMA
   - å¹³ç¨³åºåˆ—ï¼šä½¿ç”¨ARIMAæˆ–æŒ‡æ•°å¹³æ»‘

2. **é¢„æµ‹æ­¥é•¿**ï¼š
   - çŸ­æœŸï¼ˆ1-7å¤©ï¼‰ï¼šç§»åŠ¨å¹³å‡ã€æŒ‡æ•°å¹³æ»‘
   - ä¸­æœŸï¼ˆ1-3ä¸ªæœˆï¼‰ï¼šçº¿æ€§å›å½’ã€Holt-Winters
   - é•¿æœŸï¼ˆ3ä¸ªæœˆä»¥ä¸Šï¼‰ï¼šè¶‹åŠ¿å¤–æ¨ã€å› æœæ¨¡å‹

3. **æ¨¡å‹è¯„ä¼°**ï¼š
   - ä½¿ç”¨å¤šä¸ªè¯„ä¼°æŒ‡æ ‡ï¼ˆMAEã€RMSEã€MAPEï¼‰
   - äº¤å‰éªŒè¯è¯„ä¼°æ³›åŒ–èƒ½åŠ›
   - æ¯”è¾ƒä¸åŒæ–¹æ³•çš„é¢„æµ‹ç²¾åº¦

### 8.3 é¢„æµ‹ç›‘æ§

1. **é¢„æµ‹æ›´æ–°**ï¼š
   - å®šæœŸé‡æ–°è®­ç»ƒæ¨¡å‹
   - ç›‘æ§é¢„æµ‹è¯¯å·®
   - è°ƒæ•´æ¨¡å‹å‚æ•°

2. **å¼‚å¸¸æ£€æµ‹**ï¼š
   - ç›‘æ§é¢„æµ‹å€¼ä¸å®é™…å€¼çš„åå·®
   - è®¾ç½®é¢„è­¦é˜ˆå€¼
   - åŠæ—¶è°ƒæ•´é¢„æµ‹ç­–ç•¥

### 8.4 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ—¶é—´å¤„ç†**ï¼š
   - ä½¿ç”¨ `DATE_TRUNC()` ç»Ÿä¸€æ—¶é—´ç²’åº¦
   - å¤„ç†æ—¶åŒºå’Œå¤ä»¤æ—¶
   - ç¡®ä¿æ—¶é—´åºåˆ—è¿ç»­

2. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - åœ¨æ—¶é—´åˆ—ä¸Šåˆ›å»ºç´¢å¼•
   - ä½¿ç”¨çª—å£å‡½æ•°ä¼˜åŒ–è®¡ç®—
   - è€ƒè™‘ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ

3. **æ•°å€¼ç¨³å®šæ€§**ï¼š
   - ä½¿ç”¨NUMERICç±»å‹ä¿æŒç²¾åº¦
   - æ³¨æ„é™¤é›¶é”™è¯¯
   - å¤„ç†æº¢å‡ºé—®é¢˜

### 8.5 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡æ—¶é—´åºåˆ—é¢„æµ‹çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«æ—¶é—´æˆ³çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Né¢„æµ‹æŸ¥è¯¢å’Œå¤šæ—¶é—´åºåˆ—é¢„æµ‹å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡æ—¶é—´åºåˆ—é¢„æµ‹è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡é¢„æµ‹å’Œå¤šæ¨¡å‹é¢„æµ‹å¯¹æ¯”

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - æ—¶é—´åºåˆ—é¢„æµ‹æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨6èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡æ—¶é—´åºåˆ—é¢„æµ‹å’Œå¤šæŒ‡æ ‡é¢„æµ‹åˆ†æ

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–æ—¶é—´åºåˆ—é¢„æµ‹æŸ¥è¯¢**

```sql
-- ä¸ºæ—¶é—´åºåˆ—é¢„æµ‹åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_time_series_prediction_skip_scan
ON time_series(series_id, date DESC, value DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªæ—¶é—´åºåˆ—æœ€æ–°æ—¥æœŸçš„é¢„æµ‹å€¼
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (series_id)
    series_id,
    date,
    value,
    predicted_value
FROM (
    SELECT
        series_id,
        date,
        value,
        AVG(value) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS predicted_value
    FROM time_series
) AS predictions
ORDER BY series_id, date DESC
LIMIT 50;
```

### 8.6 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜é¢„æµ‹ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„é¢„æµ‹ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜é¢„æµ‹ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS time_series_prediction_cache AS
WITH prediction_models AS (
    SELECT
        series_id,
        date,
        value,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å¤šç§é¢„æµ‹æ–¹æ³•ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        AVG(value) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS ma_30_prediction,
        -- æŒ‡æ•°å¹³æ»‘é¢„æµ‹
        EXP(SUM(LN(value)) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) / 30) AS geometric_mean_prediction,
        -- çº¿æ€§è¶‹åŠ¿é¢„æµ‹
        (AVG(value * ROW_NUMBER() OVER (PARTITION BY series_id ORDER BY date)) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) - AVG(value) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) * AVG(ROW_NUMBER() OVER (PARTITION BY series_id ORDER BY date)) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        )) / NULLIF(AVG(POWER(ROW_NUMBER() OVER (PARTITION BY series_id ORDER BY date), 2)) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) - POWER(AVG(ROW_NUMBER() OVER (PARTITION BY series_id ORDER BY date)) OVER (
            PARTITION BY series_id
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ), 2), 0) AS trend_slope
    FROM time_series
    WHERE date >= CURRENT_DATE - INTERVAL '90 days'
),
prediction_accuracy AS (
    SELECT
        series_id,
        date,
        value,
        ma_30_prediction,
        geometric_mean_prediction,
        trend_slope,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—é¢„æµ‹è¯¯å·®ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        ABS(value - LAG(ma_30_prediction) OVER (
            PARTITION BY series_id
            ORDER BY date
        )) AS ma_prediction_error,
        ABS(value - LAG(geometric_mean_prediction) OVER (
            PARTITION BY series_id
            ORDER BY date
        )) AS geometric_prediction_error
    FROM prediction_models
)
SELECT
    series_id,
    date,
    value,
    ROUND(ma_30_prediction::numeric, 4) AS ma_30_prediction,
    ROUND(geometric_mean_prediction::numeric, 4) AS geometric_mean_prediction,
    ROUND(trend_slope::numeric, 4) AS trend_slope,
    ROUND(ma_prediction_error::numeric, 4) AS ma_prediction_error,
    ROUND(geometric_prediction_error::numeric, 4) AS geometric_prediction_error,
    CASE
        WHEN ma_prediction_error < geometric_prediction_error THEN 'MA_Better'
        WHEN geometric_prediction_error < ma_prediction_error THEN 'Geometric_Better'
        ELSE 'Equal'
    END AS best_method
FROM prediction_accuracy
ORDER BY series_id, date DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_time_series_prediction_cache_series_date ON time_series_prediction_cache(series_id, date DESC);
CREATE INDEX idx_time_series_prediction_cache_method ON time_series_prediction_cache(best_method, ma_prediction_error);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY time_series_prediction_cache;
```

**2. å®æ—¶æ—¶é—´åºåˆ—é¢„æµ‹ï¼šå¢é‡é¢„æµ‹æ›´æ–°**

**å®æ—¶æ—¶é—´åºåˆ—é¢„æµ‹**ï¼šå¯¹äºå®æ—¶æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•æ›´æ–°é¢„æµ‹ç»“æœã€‚

```sql
-- å®æ—¶æ—¶é—´åºåˆ—é¢„æµ‹ï¼šå¢é‡é¢„æµ‹æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_prediction_state') THEN
            CREATE TABLE time_series_prediction_state (
                series_id VARCHAR(100) NOT NULL,
                prediction_method VARCHAR(50) NOT NULL,  -- 'MA', 'EMA', 'Linear'
                window_size INTEGER NOT NULL,
                sum_values NUMERIC DEFAULT 0,
                sum_squared_values NUMERIC DEFAULT 0,
                count_samples BIGINT DEFAULT 0,
                last_value NUMERIC,
                last_prediction NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (series_id, prediction_method, window_size)
            );

            CREATE INDEX idx_time_series_prediction_state_series ON time_series_prediction_state(series_id, last_updated DESC);
            CREATE INDEX idx_time_series_prediction_state_updated ON time_series_prediction_state(last_updated DESC);

            RAISE NOTICE 'æ—¶é—´åºåˆ—é¢„æµ‹çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡æ—¶é—´åºåˆ—é¢„æµ‹æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡æ—¶é—´åºåˆ—é¢„æµ‹æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°æ—¶é—´åºåˆ—é¢„æµ‹ç»Ÿè®¡ï¼šå®æ—¶æ—¶é—´åºåˆ—é¢„æµ‹
WITH new_time_series_data AS (
    SELECT
        series_id,
        date,
        value
    FROM time_series
    WHERE date > (SELECT COALESCE(MAX(last_updated)::date, '1970-01-01') FROM time_series_prediction_state)
      AND date <= CURRENT_DATE
),
updated_prediction_stats AS (
    SELECT
        COALESCE(tsps.series_id, ntsd.series_id) AS series_id,
        'MA' AS prediction_method,
        30 AS window_size,
        COALESCE(tsps.sum_values, 0) + SUM(ntsd.value) AS new_sum_values,
        COALESCE(tsps.sum_squared_values, 0) + SUM(POWER(ntsd.value, 2)) AS new_sum_squared_values,
        COALESCE(tsps.count_samples, 0) + COUNT(*) AS new_count_samples,
        MAX(ntsd.value) AS new_last_value,
        (COALESCE(tsps.sum_values, 0) + SUM(ntsd.value)) /
        NULLIF(COALESCE(tsps.count_samples, 0) + COUNT(*), 0) AS new_last_prediction
    FROM time_series_prediction_state tsps
    FULL OUTER JOIN new_time_series_data ntsd ON tsps.series_id = ntsd.series_id
                                                 AND tsps.prediction_method = 'MA'
                                                 AND tsps.window_size = 30
    GROUP BY tsps.series_id, ntsd.series_id, tsps.sum_values, tsps.sum_squared_values, tsps.count_samples
)
-- æ›´æ–°æˆ–æ’å…¥æ—¶é—´åºåˆ—é¢„æµ‹çŠ¶æ€
INSERT INTO time_series_prediction_state (
    series_id,
    prediction_method,
    window_size,
    sum_values,
    sum_squared_values,
    count_samples,
    last_value,
    last_prediction,
    last_updated
)
SELECT
    series_id,
    prediction_method,
    window_size,
    new_sum_values,
    new_sum_squared_values,
    new_count_samples,
    new_last_value,
    new_last_prediction,
    NOW()
FROM updated_prediction_stats
ON CONFLICT (series_id, prediction_method, window_size)
DO UPDATE SET
    sum_values = EXCLUDED.sum_values,
    sum_squared_values = EXCLUDED.sum_squared_values,
    count_samples = EXCLUDED.count_samples,
    last_value = EXCLUDED.last_value,
    last_prediction = EXCLUDED.last_prediction,
    last_updated = NOW();
```

**3. æ™ºèƒ½æ—¶é—´åºåˆ—é¢„æµ‹ï¼šè‡ªé€‚åº”é¢„æµ‹æ–¹æ³•é€‰æ‹©**

**æ™ºèƒ½æ—¶é—´åºåˆ—é¢„æµ‹**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜é¢„æµ‹æ–¹æ³•ã€‚

```sql
-- æ™ºèƒ½æ—¶é—´åºåˆ—é¢„æµ‹ï¼šè‡ªé€‚åº”é¢„æµ‹æ–¹æ³•é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    data_trend_strength NUMERIC;
    data_seasonality_strength NUMERIC;
    recommended_method VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series') THEN
            RAISE WARNING 'è¡¨ time_series ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½æ—¶é—´åºåˆ—é¢„æµ‹';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        WITH time_series_features AS (
            SELECT
                CORR(ROW_NUMBER() OVER (ORDER BY date)::numeric, value) AS trend_correlation,
                CORR(EXTRACT(DAY FROM date)::numeric, value) AS seasonality_correlation
            FROM time_series
            WHERE date >= CURRENT_DATE - INTERVAL '90 days'
        )
        SELECT
            ABS(trend_correlation),
            ABS(seasonality_correlation)
        INTO data_trend_strength, data_seasonality_strength
        FROM time_series_features;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©é¢„æµ‹æ–¹æ³•
        IF data_trend_strength > 0.7 AND data_seasonality_strength > 0.5 THEN
            recommended_method := 'HOLT_WINTERS';  -- å¼ºè¶‹åŠ¿å¼ºå­£èŠ‚æ€§ï¼šHolt-Winters
        ELSIF data_trend_strength > 0.5 THEN
            recommended_method := 'LINEAR_REGRESSION';  -- å¼ºè¶‹åŠ¿ï¼šçº¿æ€§å›å½’
        ELSIF data_seasonality_strength > 0.5 THEN
            recommended_method := 'SEASONAL_MA';  -- å¼ºå­£èŠ‚æ€§ï¼šå­£èŠ‚æ€§ç§»åŠ¨å¹³å‡
        ELSE
            recommended_method := 'SIMPLE_MA';  -- å¼±è¶‹åŠ¿å¼±å­£èŠ‚æ€§ï¼šç®€å•ç§»åŠ¨å¹³å‡
        END IF;

        RAISE NOTICE 'è¶‹åŠ¿å¼ºåº¦: %, å­£èŠ‚æ€§å¼ºåº¦: %, æ¨èæ–¹æ³•: %',
            data_trend_strength, data_seasonality_strength, recommended_method;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½æ—¶é—´åºåˆ—é¢„æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ™ºèƒ½æ—¶é—´åºåˆ—é¢„æµ‹ï¼šæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„é¢„æµ‹æ–¹æ³•
WITH time_series_characteristics AS (
    SELECT
        series_id,
        CORR(ROW_NUMBER() OVER (PARTITION BY series_id ORDER BY date)::numeric, value) AS trend_correlation,
        CORR(EXTRACT(DAY FROM date)::numeric, value) AS seasonality_correlation
    FROM time_series
    WHERE date >= CURRENT_DATE - INTERVAL '90 days'
    GROUP BY series_id
),
adaptive_prediction AS (
    SELECT
        ts.series_id,
        ts.date,
        ts.value,
        tsc.trend_correlation,
        tsc.seasonality_correlation,
        CASE
            WHEN ABS(tsc.trend_correlation) > 0.7 AND ABS(tsc.seasonality_correlation) > 0.5 THEN 'HOLT_WINTERS'
            WHEN ABS(tsc.trend_correlation) > 0.5 THEN 'LINEAR_REGRESSION'
            WHEN ABS(tsc.seasonality_correlation) > 0.5 THEN 'SEASONAL_MA'
            ELSE 'SIMPLE_MA'
        END AS recommended_method,
        -- æ ¹æ®æ¨èæ–¹æ³•è®¡ç®—é¢„æµ‹å€¼ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN ABS(tsc.trend_correlation) > 0.7 AND ABS(tsc.seasonality_correlation) > 0.5 THEN
                AVG(ts.value) OVER (
                    PARTITION BY ts.series_id
                    ORDER BY ts.date
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ) * (1 + tsc.trend_correlation * 0.1)  -- ç®€åŒ–çš„Holt-Winters
            WHEN ABS(tsc.trend_correlation) > 0.5 THEN
                AVG(ts.value) OVER (
                    PARTITION BY ts.series_id
                    ORDER BY ts.date
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                ) + tsc.trend_correlation * 10  -- ç®€åŒ–çš„çº¿æ€§å›å½’
            ELSE
                AVG(ts.value) OVER (
                    PARTITION BY ts.series_id
                    ORDER BY ts.date
                    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
                )  -- ç®€å•ç§»åŠ¨å¹³å‡
        END AS predicted_value
    FROM time_series ts
    JOIN time_series_characteristics tsc ON ts.series_id = tsc.series_id
    WHERE ts.date >= CURRENT_DATE - INTERVAL '30 days'
)
SELECT
    series_id,
    date,
    value,
    ROUND(ABS(trend_correlation)::numeric, 4) AS trend_strength,
    ROUND(ABS(seasonality_correlation)::numeric, 4) AS seasonality_strength,
    recommended_method,
    ROUND(predicted_value::numeric, 4) AS predicted_value,
    ROUND(ABS(value - predicted_value)::numeric, 4) AS prediction_error
FROM adaptive_prediction
ORDER BY series_id, date DESC
LIMIT 100;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **Box, G.E.P., Jenkins, G.M. (1976)**: "Time Series Analysis: Forecasting and Control", 3rd Edition, Prentice Hall.

2. **Holt, C.C. (2004)**: "Forecasting seasonals and trends by exponentially weighted moving averages", *International Journal of Forecasting*.

3. **Hyndman, R.J., Athanasopoulos, G. (2021)**: "Forecasting: principles and practice", 3rd Edition, OTexts.

4. **ã€Šæ—¶é—´åºåˆ—åˆ†æã€‹**ï¼ˆç‹ç‡•ï¼Œ2013ï¼‰- åº”ç”¨æ—¶é—´åºåˆ—åˆ†æ

### åœ¨çº¿èµ„æº

- **PostgreSQLæ—¶é—´åºåˆ—å‡½æ•°**: <https://www.postgresql.org/docs/current/functions-datetime.html>
- **Python statsmodels**: <https://www.statsmodels.org/stable/tsa.html>
- **R forecaståŒ…**: <https://pkg.robjhyndman.com/forecast/>

### ç›¸å…³ç®—æ³•

- **è¶‹åŠ¿åˆ†æ**ï¼šè¯†åˆ«æ—¶é—´åºåˆ—è¶‹åŠ¿
- **å‘¨æœŸæ€§åˆ†æ**ï¼šæ£€æµ‹å‘¨æœŸæ€§æ¨¡å¼
- **æ»‘åŠ¨çª—å£è®¡ç®—**ï¼šç§»åŠ¨ç»Ÿè®¡é‡
- **ARIMAæ¨¡å‹**ï¼šè‡ªå›å½’ç§¯åˆ†ç§»åŠ¨å¹³å‡æ¨¡å‹
- **çŠ¶æ€ç©ºé—´æ¨¡å‹**ï¼šåŠ¨æ€çº¿æ€§æ¨¡å‹
