# PostgreSQL æ—¥å¿—åˆ†æç»¼åˆæ¡ˆä¾‹

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ—¥å¿—åˆ†æ | æ—¶é—´åºåˆ—
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æ—¥å¿—åˆ†æç»¼åˆæ¡ˆä¾‹](#postgresql-æ—¥å¿—åˆ†æç»¼åˆæ¡ˆä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¡ˆä¾‹æ¦‚è¿°](#æ¡ˆä¾‹æ¦‚è¿°)
  - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [æ—¥å¿—åˆ†æé—®é¢˜å®šä¹‰](#æ—¥å¿—åˆ†æé—®é¢˜å®šä¹‰)
    - [æ ¸å¿ƒåˆ†æç»´åº¦](#æ ¸å¿ƒåˆ†æç»´åº¦)
    - [åˆ†ææ–¹æ³•åˆ†ç±»](#åˆ†ææ–¹æ³•åˆ†ç±»)
    - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
  - [1. æ•°æ®å‡†å¤‡](#1-æ•°æ®å‡†å¤‡)
  - [2. é”™è¯¯æ—¥å¿—åˆ†æ](#2-é”™è¯¯æ—¥å¿—åˆ†æ)
  - [3. è®¿é—®æ¨¡å¼åˆ†æ](#3-è®¿é—®æ¨¡å¼åˆ†æ)
  - [4. æ€§èƒ½åˆ†æ](#4-æ€§èƒ½åˆ†æ)
  - [5. å¼‚å¸¸æ£€æµ‹](#5-å¼‚å¸¸æ£€æµ‹)
  - [6. å®‰å…¨åˆ†æ](#6-å®‰å…¨åˆ†æ)
  - [7. æœåŠ¡å¥åº·åº¦åˆ†æ](#7-æœåŠ¡å¥åº·åº¦åˆ†æ)
  - [8. æµé‡åˆ†æ](#8-æµé‡åˆ†æ)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [ç´¢å¼•ä¼˜åŒ–](#ç´¢å¼•ä¼˜åŒ–)
    - [åˆ†åŒºè¡¨](#åˆ†åŒºè¡¨)
    - [ç‰©åŒ–è§†å›¾](#ç‰©åŒ–è§†å›¾)
    - [å½’æ¡£ç­–ç•¥](#å½’æ¡£ç­–ç•¥)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [æ—¥å¿—æ ¼å¼](#æ—¥å¿—æ ¼å¼)
    - [å®æ—¶ç›‘æ§](#å®æ—¶ç›‘æ§)
    - [åˆ†æç­–ç•¥](#åˆ†æç­–ç•¥)
    - [æ•°æ®ç®¡ç†](#æ•°æ®ç®¡ç†)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“ˆ åˆ†ææ–¹æ³•å¯¹æ¯”](#-åˆ†ææ–¹æ³•å¯¹æ¯”)
  - [ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
    - [é—®é¢˜1ï¼šæ—¥å¿—æ•°æ®é‡å¤§ï¼ŒæŸ¥è¯¢æ…¢](#é—®é¢˜1æ—¥å¿—æ•°æ®é‡å¤§æŸ¥è¯¢æ…¢)
    - [é—®é¢˜2ï¼šå¼‚å¸¸æ£€æµ‹è¯¯æŠ¥ç‡é«˜](#é—®é¢˜2å¼‚å¸¸æ£€æµ‹è¯¯æŠ¥ç‡é«˜)
    - [é—®é¢˜3ï¼šå®æ—¶ç›‘æ§å»¶è¿Ÿ](#é—®é¢˜3å®æ—¶ç›‘æ§å»¶è¿Ÿ)

---

## æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ¡ˆä¾‹ç»¼åˆè¿ç”¨æ—¶é—´åºåˆ—åˆ†æã€èšåˆç®—æ³•ã€å¼‚å¸¸æ£€æµ‹ç­‰æŠ€æœ¯ï¼Œå¯¹åº”ç”¨æ—¥å¿—è¿›è¡Œå…¨é¢åˆ†æã€‚

## ç†è®ºåŸºç¡€

### æ—¥å¿—åˆ†æé—®é¢˜å®šä¹‰

æ—¥å¿—åˆ†ææ˜¯é€šè¿‡å¯¹åº”ç”¨ç³»ç»Ÿäº§ç”Ÿçš„æ—¥å¿—æ•°æ®è¿›è¡Œæ”¶é›†ã€è§£æã€å­˜å‚¨å’Œåˆ†æï¼Œä»¥ç›‘æ§ç³»ç»Ÿè¿è¡ŒçŠ¶æ€ã€è¯Šæ–­é—®é¢˜ã€ä¼˜åŒ–æ€§èƒ½å’Œä¿éšœå®‰å…¨çš„è¿‡ç¨‹ã€‚

### æ ¸å¿ƒåˆ†æç»´åº¦

1. **é”™è¯¯æ—¥å¿—åˆ†æ**ï¼š
   - é”™è¯¯ç±»å‹ç»Ÿè®¡
   - é”™è¯¯é¢‘ç‡åˆ†æ
   - é”™è¯¯è¶‹åŠ¿åˆ†æ
   - é”™è¯¯å½±å“è¯„ä¼°

2. **è®¿é—®æ¨¡å¼åˆ†æ**ï¼š
   - è®¿é—®é‡ç»Ÿè®¡
   - è®¿é—®æ—¶é—´åˆ†å¸ƒ
   - ç«¯ç‚¹è®¿é—®åˆ†æ
   - ç”¨æˆ·è¡Œä¸ºåˆ†æ

3. **æ€§èƒ½åˆ†æ**ï¼š
   - å“åº”æ—¶é—´åˆ†æ
   - ååé‡åˆ†æ
   - æ€§èƒ½è¶‹åŠ¿åˆ†æ
   - æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

4. **å¼‚å¸¸æ£€æµ‹**ï¼š
   - å“åº”æ—¶é—´å¼‚å¸¸
   - é”™è¯¯ç‡å¼‚å¸¸
   - è®¿é—®é‡å¼‚å¸¸
   - å®‰å…¨å¼‚å¸¸

### åˆ†ææ–¹æ³•åˆ†ç±»

1. **ç»Ÿè®¡åˆ†ææ–¹æ³•**ï¼šèšåˆç»Ÿè®¡ã€ç™¾åˆ†ä½æ•°ã€åˆ†å¸ƒåˆ†æ
2. **æ—¶é—´åºåˆ—åˆ†æ**ï¼šè¶‹åŠ¿åˆ†æã€å‘¨æœŸæ€§åˆ†æã€ç§»åŠ¨å¹³å‡
3. **å¼‚å¸¸æ£€æµ‹æ–¹æ³•**ï¼šIQRæ–¹æ³•ã€Z-scoreæ–¹æ³•ã€é˜ˆå€¼æ£€æµ‹
4. **å…³è”åˆ†ææ–¹æ³•**ï¼šç«¯ç‚¹å…³è”ã€ç”¨æˆ·å…³è”ã€æ—¶é—´å…³è”

### æŠ€æœ¯æ ˆ

- **æ—¶é—´åºåˆ—åˆ†æ**ï¼šDATE_TRUNCã€æ»‘åŠ¨çª—å£ã€ç§»åŠ¨å¹³å‡
- **èšåˆç®—æ³•**ï¼šCOUNTã€SUMã€AVGã€GROUP BY
- **çª—å£å‡½æ•°**ï¼šROW_NUMBERã€RANKã€LAGã€LEAD
- **ç»Ÿè®¡åˆ†æ**ï¼šç™¾åˆ†ä½æ•°ã€æ ‡å‡†å·®ã€ç›¸å…³æ€§
- **å¼‚å¸¸æ£€æµ‹**ï¼šIQRã€Z-scoreã€é˜ˆå€¼æ£€æµ‹

---

## 1. æ•°æ®å‡†å¤‡

```sql
-- åˆ›å»ºæ—¥å¿—æ•°æ®è¡¨ç»“æ„ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE application_logs CASCADE;
        END IF;

        CREATE TABLE application_logs (
            log_id SERIAL PRIMARY KEY,
            timestamp TIMESTAMP NOT NULL,
            log_level VARCHAR(20) NOT NULL,
            service_name VARCHAR(50) NOT NULL,
            endpoint VARCHAR(200),
            status_code INTEGER,
            response_time_ms NUMERIC(10, 2),
            error_message TEXT,
            user_id INTEGER,
            ip_address INET
        );

        -- æ’å…¥ç¤ºä¾‹æ—¥å¿—æ•°æ®
        INSERT INTO application_logs (timestamp, log_level, service_name, endpoint, status_code, response_time_ms, user_id, ip_address) VALUES
            ('2024-01-01 10:00:00', 'INFO', 'api-service', '/api/users', 200, 45.5, 1, '192.168.1.1'),
            ('2024-01-01 10:00:05', 'INFO', 'api-service', '/api/products', 200, 32.1, 2, '192.168.1.2'),
            ('2024-01-01 10:00:10', 'ERROR', 'api-service', '/api/orders', 500, 1200.0, NULL, '192.168.1.3'),
            ('2024-01-01 10:00:15', 'INFO', 'api-service', '/api/users', 200, 38.7, 3, '192.168.1.1'),
            ('2024-01-01 10:00:20', 'WARN', 'api-service', '/api/products', 404, 25.3, NULL, '192.168.1.4'),
            ('2024-01-01 10:00:25', 'INFO', 'api-service', '/api/orders', 200, 67.2, 4, '192.168.1.5'),
            ('2024-01-01 10:00:30', 'ERROR', 'api-service', '/api/users', 500, 1500.0, 5, '192.168.1.6'),
            ('2024-01-01 10:00:35', 'INFO', 'api-service', '/api/products', 200, 29.8, 1, '192.168.1.1'),
            ('2024-01-01 10:00:40', 'INFO', 'api-service', '/api/orders', 200, 55.4, 2, '192.168.1.2'),
            ('2024-01-01 10:00:45', 'INFO', 'api-service', '/api/users', 200, 42.1, 3, '192.168.1.3');

        RAISE NOTICE 'æ—¥å¿—æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

---

## 2. é”™è¯¯æ—¥å¿—åˆ†æ

```sql
-- é”™è¯¯æ—¥å¿—åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œé”™è¯¯æ—¥å¿—åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œé”™è¯¯æ—¥å¿—åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é”™è¯¯æ—¥å¿—åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- é”™è¯¯æ—¥å¿—ç»Ÿè®¡
SELECT
    log_level,
    COUNT(*) AS log_count,
    COUNT(*) FILTER (WHERE status_code >= 500) AS error_count,
    COUNT(DISTINCT endpoint) AS affected_endpoints,
    AVG(response_time_ms) AS avg_response_time,
    MAX(response_time_ms) AS max_response_time
FROM application_logs
WHERE log_level IN ('ERROR', 'WARN')
GROUP BY log_level
ORDER BY log_count DESC;

-- é”™è¯¯ç«¯ç‚¹æ’è¡Œ
SELECT
    endpoint,
    COUNT(*) AS error_count,
    COUNT(DISTINCT DATE_TRUNC('hour', timestamp)) AS error_hours,
    AVG(response_time_ms) AS avg_response_time,
    MAX(response_time_ms) AS max_response_time,
    ARRAY_AGG(DISTINCT status_code ORDER BY status_code) AS status_codes
FROM application_logs
WHERE log_level = 'ERROR'
GROUP BY endpoint
ORDER BY error_count DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    endpoint,
    COUNT(*) AS error_count
FROM application_logs
WHERE log_level = 'ERROR'
GROUP BY endpoint;
```

---

## 3. è®¿é—®æ¨¡å¼åˆ†æ

```sql
-- è®¿é—®æ¨¡å¼åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œè®¿é—®æ¨¡å¼åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œè®¿é—®æ¨¡å¼åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è®¿é—®æ¨¡å¼åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æŒ‰å°æ—¶ç»Ÿè®¡è®¿é—®é‡
SELECT
    DATE_TRUNC('hour', timestamp) AS hour,
    COUNT(*) AS request_count,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(DISTINCT ip_address) AS unique_ips,
    COUNT(*) FILTER (WHERE status_code >= 200 AND status_code < 300) AS success_count,
    COUNT(*) FILTER (WHERE status_code >= 400) AS error_count,
    AVG(response_time_ms) AS avg_response_time
FROM application_logs
GROUP BY DATE_TRUNC('hour', timestamp)
ORDER BY hour;

-- ç«¯ç‚¹è®¿é—®ç»Ÿè®¡
SELECT
    endpoint,
    COUNT(*) AS total_requests,
    COUNT(DISTINCT user_id) AS unique_users,
    AVG(response_time_ms) AS avg_response_time,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms) AS p95_response_time,
    COUNT(*) FILTER (WHERE status_code >= 200 AND status_code < 300) AS success_count,
    COUNT(*) FILTER (WHERE status_code >= 400) AS error_count,
    ROUND((COUNT(*) FILTER (WHERE status_code >= 200 AND status_code < 300)::numeric / COUNT(*) * 100)::numeric, 2) AS success_rate
FROM application_logs
WHERE endpoint IS NOT NULL
GROUP BY endpoint
ORDER BY total_requests DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('hour', timestamp) AS hour,
    COUNT(*) AS request_count
FROM application_logs
GROUP BY DATE_TRUNC('hour', timestamp);
```

---

## 4. æ€§èƒ½åˆ†æ

```sql
-- æ€§èƒ½åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œæ€§èƒ½åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œæ€§èƒ½åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ€§èƒ½åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å“åº”æ—¶é—´åˆ†æ
WITH response_time_stats AS (
    SELECT
        endpoint,
        response_time_ms,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY response_time_ms) OVER (PARTITION BY endpoint) AS median_time,
        AVG(response_time_ms) OVER (PARTITION BY endpoint) AS avg_time,
        STDDEV(response_time_ms) OVER (PARTITION BY endpoint) AS stddev_time
    FROM application_logs
    WHERE response_time_ms IS NOT NULL
)
SELECT
    endpoint,
    COUNT(*) AS request_count,
    ROUND(AVG(response_time_ms)::numeric, 2) AS avg_response_time,
    ROUND(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY response_time_ms)::numeric, 2) AS median_response_time,
    ROUND(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms)::numeric, 2) AS p95_response_time,
    ROUND(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY response_time_ms)::numeric, 2) AS p99_response_time,
    ROUND(STDDEV(response_time_ms)::numeric, 2) AS stddev_response_time,
    COUNT(*) FILTER (WHERE response_time_ms > avg_time + 2 * stddev_time) AS slow_requests
FROM application_logs
WHERE response_time_ms IS NOT NULL
GROUP BY endpoint
ORDER BY avg_response_time DESC;

-- æ€§èƒ½è¶‹åŠ¿åˆ†æï¼ˆç§»åŠ¨å¹³å‡ï¼‰
WITH hourly_performance AS (
    SELECT
        DATE_TRUNC('hour', timestamp) AS hour,
        AVG(response_time_ms) AS avg_response_time
    FROM application_logs
    WHERE response_time_ms IS NOT NULL
    GROUP BY DATE_TRUNC('hour', timestamp)
)
SELECT
    hour,
    ROUND(avg_response_time::numeric, 2) AS avg_response_time,
    ROUND(AVG(avg_response_time) OVER (
        ORDER BY hour
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    )::numeric, 2) AS moving_avg_3hours
FROM hourly_performance
ORDER BY hour;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    endpoint,
    AVG(response_time_ms) AS avg_response_time
FROM application_logs
WHERE response_time_ms IS NOT NULL
GROUP BY endpoint;
```

---

## 5. å¼‚å¸¸æ£€æµ‹

```sql
-- å¼‚å¸¸æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå¼‚å¸¸æ£€æµ‹';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå¼‚å¸¸æ£€æµ‹';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¼‚å¸¸æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨IQRæ–¹æ³•æ£€æµ‹å¼‚å¸¸å“åº”æ—¶é—´
WITH response_time_stats AS (
    SELECT
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY response_time_ms) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY response_time_ms) AS q3,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY response_time_ms) AS median,
        AVG(response_time_ms) AS mean
    FROM application_logs
    WHERE response_time_ms IS NOT NULL
),
outlier_detection AS (
    SELECT
        al.log_id,
        al.timestamp,
        al.endpoint,
        al.response_time_ms,
        rts.mean,
        rts.median,
        rts.q1,
        rts.q3,
        rts.q3 - rts.q1 AS iqr,
        rts.q1 - 1.5 * (rts.q3 - rts.q1) AS lower_bound,
        rts.q3 + 1.5 * (rts.q3 - rts.q1) AS upper_bound
    FROM application_logs al
    CROSS JOIN response_time_stats rts
    WHERE al.response_time_ms IS NOT NULL
)
SELECT
    log_id,
    timestamp,
    endpoint,
    ROUND(response_time_ms::numeric, 2) AS response_time_ms,
    ROUND(mean::numeric, 2) AS mean_response_time,
    ROUND(median::numeric, 2) AS median_response_time,
    ROUND(lower_bound::numeric, 2) AS lower_bound,
    ROUND(upper_bound::numeric, 2) AS upper_bound,
    CASE
        WHEN response_time_ms < lower_bound THEN 'Lower Outlier'
        WHEN response_time_ms > upper_bound THEN 'Upper Outlier'
        ELSE 'Normal'
    END AS anomaly_status
FROM outlier_detection
WHERE response_time_ms < lower_bound OR response_time_ms > upper_bound
ORDER BY response_time_ms DESC;

-- é”™è¯¯ç‡å¼‚å¸¸æ£€æµ‹
WITH hourly_error_rates AS (
    SELECT
        DATE_TRUNC('hour', timestamp) AS hour,
        COUNT(*) FILTER (WHERE status_code >= 500)::numeric / COUNT(*) AS error_rate
    FROM application_logs
    GROUP BY DATE_TRUNC('hour', timestamp)
),
error_rate_stats AS (
    SELECT
        AVG(error_rate) AS mean_error_rate,
        STDDEV(error_rate) AS stddev_error_rate
    FROM hourly_error_rates
)
SELECT
    her.hour,
    ROUND(her.error_rate::numeric, 4) AS error_rate,
    ROUND(ers.mean_error_rate::numeric, 4) AS mean_error_rate,
    ROUND((ers.mean_error_rate + 2 * ers.stddev_error_rate)::numeric, 4) AS threshold,
    CASE
        WHEN her.error_rate > ers.mean_error_rate + 2 * ers.stddev_error_rate THEN 'High Error Rate'
        ELSE 'Normal'
    END AS anomaly_status
FROM hourly_error_rates her
CROSS JOIN error_rate_stats ers
WHERE her.error_rate > ers.mean_error_rate + 2 * ers.stddev_error_rate
ORDER BY her.hour;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY response_time_ms) AS q3
FROM application_logs
WHERE response_time_ms IS NOT NULL;
```

---

## 6. å®‰å…¨åˆ†æ

```sql
-- å®‰å…¨åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå®‰å…¨åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå®‰å…¨åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®‰å…¨åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- IPåœ°å€å¼‚å¸¸æ£€æµ‹
WITH ip_stats AS (
    SELECT
        ip_address,
        COUNT(*) AS request_count,
        COUNT(DISTINCT endpoint) AS unique_endpoints,
        COUNT(*) FILTER (WHERE status_code >= 400) AS error_count,
        COUNT(*) FILTER (WHERE status_code >= 500) AS server_error_count,
        AVG(response_time_ms) AS avg_response_time
    FROM application_logs
    WHERE ip_address IS NOT NULL
    GROUP BY ip_address
)
SELECT
    ip_address,
    request_count,
    unique_endpoints,
    error_count,
    server_error_count,
    ROUND(avg_response_time::numeric, 2) AS avg_response_time,
    ROUND((error_count::numeric / NULLIF(request_count, 0) * 100)::numeric, 2) AS error_rate,
    CASE
        WHEN error_rate > 50 OR server_error_count > 10 THEN 'Suspicious'
        WHEN request_count > 1000 AND unique_endpoints > 20 THEN 'High Activity'
        ELSE 'Normal'
    END AS security_status
FROM ip_stats
ORDER BY error_rate DESC, request_count DESC;

-- ç”¨æˆ·è¡Œä¸ºå¼‚å¸¸æ£€æµ‹
WITH user_behavior AS (
    SELECT
        user_id,
        COUNT(*) AS request_count,
        COUNT(DISTINCT endpoint) AS unique_endpoints,
        COUNT(DISTINCT DATE_TRUNC('hour', timestamp)) AS active_hours,
        COUNT(*) FILTER (WHERE status_code >= 400) AS error_count,
        AVG(response_time_ms) AS avg_response_time
    FROM application_logs
    WHERE user_id IS NOT NULL
    GROUP BY user_id
)
SELECT
    user_id,
    request_count,
    unique_endpoints,
    active_hours,
    error_count,
    ROUND(avg_response_time::numeric, 2) AS avg_response_time,
    CASE
        WHEN error_count > 50 THEN 'High Error Rate'
        WHEN request_count > 10000 THEN 'Very Active'
        WHEN unique_endpoints > 50 THEN 'Wide Access'
        ELSE 'Normal'
    END AS behavior_status
FROM user_behavior
ORDER BY error_count DESC, request_count DESC;
```

---

## 7. æœåŠ¡å¥åº·åº¦åˆ†æ

```sql
-- æœåŠ¡å¥åº·åº¦åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡ŒæœåŠ¡å¥åº·åº¦åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡ŒæœåŠ¡å¥åº·åº¦åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æœåŠ¡å¥åº·åº¦åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æœåŠ¡å¥åº·åº¦è¯„åˆ†
WITH service_metrics AS (
    SELECT
        service_name,
        COUNT(*) AS total_requests,
        COUNT(*) FILTER (WHERE status_code >= 200 AND status_code < 300) AS success_count,
        COUNT(*) FILTER (WHERE status_code >= 400 AND status_code < 500) AS client_error_count,
        COUNT(*) FILTER (WHERE status_code >= 500) AS server_error_count,
        AVG(response_time_ms) AS avg_response_time,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms) AS p95_response_time
    FROM application_logs
    GROUP BY service_name
)
SELECT
    service_name,
    total_requests,
    success_count,
    client_error_count,
    server_error_count,
    ROUND(avg_response_time::numeric, 2) AS avg_response_time,
    ROUND(p95_response_time::numeric, 2) AS p95_response_time,
    ROUND((success_count::numeric / NULLIF(total_requests, 0) * 100)::numeric, 2) AS success_rate,
    CASE
        WHEN success_rate >= 99 AND avg_response_time < 100 THEN 100
        WHEN success_rate >= 95 AND avg_response_time < 200 THEN 80
        WHEN success_rate >= 90 AND avg_response_time < 500 THEN 60
        WHEN success_rate >= 80 THEN 40
        ELSE 20
    END AS health_score,
    CASE
        WHEN success_rate >= 99 AND avg_response_time < 100 THEN 'Excellent'
        WHEN success_rate >= 95 AND avg_response_time < 200 THEN 'Good'
        WHEN success_rate >= 90 AND avg_response_time < 500 THEN 'Fair'
        WHEN success_rate >= 80 THEN 'Poor'
        ELSE 'Critical'
    END AS health_status
FROM service_metrics
ORDER BY health_score DESC;

-- ç«¯ç‚¹å¥åº·åº¦åˆ†æ
WITH endpoint_metrics AS (
    SELECT
        endpoint,
        COUNT(*) AS total_requests,
        COUNT(*) FILTER (WHERE status_code >= 200 AND status_code < 300) AS success_count,
        COUNT(*) FILTER (WHERE status_code >= 500) AS error_count,
        AVG(response_time_ms) AS avg_response_time,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms) AS p95_response_time
    FROM application_logs
    WHERE endpoint IS NOT NULL
    GROUP BY endpoint
)
SELECT
    endpoint,
    total_requests,
    success_count,
    error_count,
    ROUND(avg_response_time::numeric, 2) AS avg_response_time,
    ROUND(p95_response_time::numeric, 2) AS p95_response_time,
    ROUND((success_count::numeric / NULLIF(total_requests, 0) * 100)::numeric, 2) AS success_rate,
    ROUND((error_count::numeric / NULLIF(total_requests, 0) * 100)::numeric, 2) AS error_rate,
    CASE
        WHEN success_rate >= 99 AND avg_response_time < 100 THEN 'Healthy'
        WHEN success_rate >= 95 AND avg_response_time < 200 THEN 'Warning'
        WHEN success_rate >= 90 THEN 'Degraded'
        ELSE 'Unhealthy'
    END AS health_status
FROM endpoint_metrics
ORDER BY error_rate DESC, avg_response_time DESC;
```

---

## 8. æµé‡åˆ†æ

```sql
-- æµé‡åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'application_logs') THEN
            RAISE WARNING 'è¡¨ application_logs ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œæµé‡åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œæµé‡åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æµé‡åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æµé‡è¶‹åŠ¿åˆ†æ
WITH hourly_traffic AS (
    SELECT
        DATE_TRUNC('hour', timestamp) AS hour,
        COUNT(*) AS request_count,
        COUNT(DISTINCT user_id) AS unique_users,
        COUNT(DISTINCT ip_address) AS unique_ips,
        AVG(response_time_ms) AS avg_response_time
    FROM application_logs
    GROUP BY DATE_TRUNC('hour', timestamp)
)
SELECT
    hour,
    request_count,
    unique_users,
    unique_ips,
    ROUND(avg_response_time::numeric, 2) AS avg_response_time,
    LAG(request_count) OVER (ORDER BY hour) AS prev_hour_count,
    CASE
        WHEN LAG(request_count) OVER (ORDER BY hour) > 0 THEN
            ROUND(((request_count - LAG(request_count) OVER (ORDER BY hour))::numeric / LAG(request_count) OVER (ORDER BY hour) * 100)::numeric, 2)
        ELSE NULL
    END AS traffic_change_percent
FROM hourly_traffic
ORDER BY hour;

-- æµé‡å³°å€¼åˆ†æ
WITH hourly_traffic AS (
    SELECT
        DATE_TRUNC('hour', timestamp) AS hour,
        COUNT(*) AS request_count
    FROM application_logs
    GROUP BY DATE_TRUNC('hour', timestamp)
),
traffic_stats AS (
    SELECT
        AVG(request_count) AS avg_traffic,
        STDDEV(request_count) AS stddev_traffic,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY request_count) AS p95_traffic
    FROM hourly_traffic
)
SELECT
    ht.hour,
    ht.request_count,
    ROUND(ts.avg_traffic::numeric, 0) AS avg_traffic,
    ROUND(ts.p95_traffic::numeric, 0) AS p95_traffic,
    CASE
        WHEN ht.request_count > ts.p95_traffic THEN 'Peak'
        WHEN ht.request_count > ts.avg_traffic + ts.stddev_traffic THEN 'High'
        WHEN ht.request_count < ts.avg_traffic - ts.stddev_traffic THEN 'Low'
        ELSE 'Normal'
    END AS traffic_level
FROM hourly_traffic ht
CROSS JOIN traffic_stats ts
ORDER BY ht.request_count DESC;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå…³é”®ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_logs_timestamp ON application_logs(timestamp);
CREATE INDEX IF NOT EXISTS idx_logs_level ON application_logs(log_level);
CREATE INDEX IF NOT EXISTS idx_logs_endpoint ON application_logs(endpoint);
CREATE INDEX IF NOT EXISTS idx_logs_service ON application_logs(service_name);
CREATE INDEX IF NOT EXISTS idx_logs_status ON application_logs(status_code);
CREATE INDEX IF NOT EXISTS idx_logs_user ON application_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_logs_ip ON application_logs(ip_address);
```

### åˆ†åŒºè¡¨

```sql
-- æŒ‰æ—¶é—´åˆ†åŒºæ—¥å¿—è¡¨ï¼ˆPostgreSQL 10+ï¼‰
CREATE TABLE application_logs_partitioned (
    LIKE application_logs INCLUDING ALL
) PARTITION BY RANGE (timestamp);

CREATE TABLE logs_2024_01 PARTITION OF application_logs_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE logs_2024_02 PARTITION OF application_logs_partitioned
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

### ç‰©åŒ–è§†å›¾

```sql
-- åˆ›å»ºå¸¸ç”¨æŠ¥è¡¨çš„ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_hourly_logs AS
SELECT
    DATE_TRUNC('hour', timestamp) AS hour,
    log_level,
    COUNT(*) AS log_count,
    COUNT(DISTINCT endpoint) AS unique_endpoints,
    AVG(response_time_ms) AS avg_response_time
FROM application_logs
GROUP BY DATE_TRUNC('hour', timestamp), log_level;

CREATE UNIQUE INDEX ON mv_hourly_logs(hour, log_level);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_hourly_logs;
```

### å½’æ¡£ç­–ç•¥

```sql
-- å½’æ¡£å†å²æ—¥å¿—ï¼ˆä¿ç•™æœ€è¿‘3ä¸ªæœˆï¼‰
CREATE TABLE application_logs_archive (LIKE application_logs INCLUDING ALL);

INSERT INTO application_logs_archive
SELECT * FROM application_logs
WHERE timestamp < CURRENT_DATE - INTERVAL '3 months';

DELETE FROM application_logs
WHERE timestamp < CURRENT_DATE - INTERVAL '3 months';
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### æ—¥å¿—æ ¼å¼

1. **ç»Ÿä¸€æ ¼å¼**ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ—¥å¿—æ ¼å¼ï¼ˆJSONã€ç»“æ„åŒ–æ—¥å¿—ï¼‰
2. **å…³é”®å­—æ®µ**ï¼šåŒ…å«æ—¶é—´æˆ³ã€æ—¥å¿—çº§åˆ«ã€æœåŠ¡åã€ç«¯ç‚¹ã€çŠ¶æ€ç ç­‰
3. **ä¸Šä¸‹æ–‡ä¿¡æ¯**ï¼šåŒ…å«ç”¨æˆ·IDã€IPåœ°å€ã€è¯·æ±‚IDç­‰ä¸Šä¸‹æ–‡ä¿¡æ¯
4. **é”™è¯¯ä¿¡æ¯**ï¼šåŒ…å«è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œå †æ ˆè·Ÿè¸ª

### å®æ—¶ç›‘æ§

1. **é”™è¯¯ç›‘æ§**ï¼šå®æ—¶ç›‘æ§é”™è¯¯æ—¥å¿—å’Œå¼‚å¸¸æƒ…å†µ
2. **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶ç›‘æ§å“åº”æ—¶é—´å’Œååé‡
3. **å‘Šè­¦æœºåˆ¶**ï¼šè®¾ç½®å¼‚å¸¸å‘Šè­¦é˜ˆå€¼å’Œé€šçŸ¥æœºåˆ¶
4. **ä»ªè¡¨æ¿**ï¼šåˆ›å»ºå®æ—¶ç›‘æ§ä»ªè¡¨æ¿

### åˆ†æç­–ç•¥

1. **åˆ†å±‚åˆ†æ**ï¼šä»å®è§‚åˆ°å¾®è§‚é€æ­¥æ·±å…¥
2. **æ—¶é—´åºåˆ—åˆ†æ**ï¼šåˆ†æè¶‹åŠ¿å’Œå‘¨æœŸæ€§
3. **å¼‚å¸¸æ£€æµ‹**ï¼šè¯†åˆ«å¼‚å¸¸æ¨¡å¼å’Œå¼‚å¸¸è¡Œä¸º
4. **å…³è”åˆ†æ**ï¼šåˆ†æä¸åŒç»´åº¦ä¹‹é—´çš„å…³è”å…³ç³»

### æ•°æ®ç®¡ç†

1. **æ•°æ®ä¿ç•™**ï¼šåˆç†è®¾ç½®æ—¥å¿—ä¿ç•™æœŸé™
2. **æ•°æ®å½’æ¡£**ï¼šå®šæœŸå½’æ¡£å†å²æ—¥å¿—
3. **æ•°æ®å‹ç¼©**ï¼šå¯¹å½’æ¡£æ•°æ®è¿›è¡Œå‹ç¼©
4. **æ•°æ®æ¸…ç†**ï¼šå®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨DOå—è¿›è¡Œé”™è¯¯å¤„ç†
2. **NULLå€¼å¤„ç†**ï¼šä½¿ç”¨COALESCEå’ŒNULLIFå¤„ç†NULLå€¼
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨ç´¢å¼•å’Œåˆ†åŒºè¡¨ä¼˜åŒ–æ€§èƒ½
4. **æŸ¥è¯¢ä¼˜åŒ–**ï¼šä¼˜åŒ–å¤æ‚æŸ¥è¯¢è¯­å¥

---

## ğŸ“ˆ åˆ†ææ–¹æ³•å¯¹æ¯”

| åˆ†ææ–¹æ³• | é€‚ç”¨åœºæ™¯ | ä¼˜åŠ¿ | å±€é™æ€§ |
|---------|---------|------|--------|
| ç»Ÿè®¡åˆ†ææ–¹æ³• | ç°çŠ¶äº†è§£ã€è¶‹åŠ¿åˆ†æ | ç®€å•ç›´è§‚ã€æ˜“äºç†è§£ | æ— æ³•é¢„æµ‹æœªæ¥ |
| æ—¶é—´åºåˆ—åˆ†æ | è¶‹åŠ¿é¢„æµ‹ã€å‘¨æœŸæ€§åˆ†æ | å‘ç°è§„å¾‹ã€é¢„æµ‹è¶‹åŠ¿ | éœ€è¦è¶³å¤Ÿå†å²æ•°æ® |
| å¼‚å¸¸æ£€æµ‹æ–¹æ³• | é—®é¢˜å‘ç°ã€å®‰å…¨ç›‘æ§ | åŠæ—¶å‘ç°å¼‚å¸¸ | å¯èƒ½äº§ç”Ÿè¯¯æŠ¥ |
| å…³è”åˆ†ææ–¹æ³• | é—®é¢˜å®šä½ã€æ ¹å› åˆ†æ | å‘ç°å…³è”å…³ç³» | éœ€è¦å¤§é‡æ•°æ® |

---

## ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šæ—¥å¿—æ•°æ®é‡å¤§ï¼ŒæŸ¥è¯¢æ…¢

**åŸå› **ï¼š

- æ•°æ®é‡è¿‡å¤§
- ç¼ºå°‘ç´¢å¼•
- å…¨è¡¨æ‰«æ

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨åˆ†åŒºè¡¨
- åˆ›å»ºåˆé€‚çš„ç´¢å¼•
- ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ
- å®šæœŸå½’æ¡£å†å²æ•°æ®

### é—®é¢˜2ï¼šå¼‚å¸¸æ£€æµ‹è¯¯æŠ¥ç‡é«˜

**åŸå› **ï¼š

- é˜ˆå€¼è®¾ç½®ä¸åˆç†
- æ•°æ®è´¨é‡å·®
- ç®—æ³•é€‰æ‹©ä¸å½“

**è§£å†³æ–¹æ¡ˆ**ï¼š

- è°ƒæ•´å¼‚å¸¸æ£€æµ‹é˜ˆå€¼
- æé«˜æ•°æ®è´¨é‡
- ä½¿ç”¨å¤šç§å¼‚å¸¸æ£€æµ‹æ–¹æ³•
- ç»“åˆä¸šåŠ¡çŸ¥è¯†

### é—®é¢˜3ï¼šå®æ—¶ç›‘æ§å»¶è¿Ÿ

**åŸå› **ï¼š

- æ•°æ®å†™å…¥å»¶è¿Ÿ
- æŸ¥è¯¢æ€§èƒ½å·®
- ç½‘ç»œå»¶è¿Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä¼˜åŒ–æ•°æ®å†™å…¥æµç¨‹
- ä½¿ç”¨æµå¼å¤„ç†
- ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
- ä½¿ç”¨ç¼“å­˜

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
