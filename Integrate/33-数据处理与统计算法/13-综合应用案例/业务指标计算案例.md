# PostgreSQL 业务指标计算综合案例

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 业务指标 | KPI计算
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 业务指标计算综合案例](#postgresql-业务指标计算综合案例)
  - [📋 目录](#-目录)
  - [案例概述](#案例概述)
  - [理论基础](#理论基础)
    - [业务指标计算问题定义](#业务指标计算问题定义)
    - [核心指标分类](#核心指标分类)
    - [计算方法分类](#计算方法分类)
    - [技术栈](#技术栈)
  - [1. 数据准备](#1-数据准备)
  - [2. 收入指标](#2-收入指标)
  - [3. 用户指标](#3-用户指标)
  - [4. 运营指标](#4-运营指标)
  - [5. 综合仪表板](#5-综合仪表板)
  - [6. 增长率分析](#6-增长率分析)
  - [7. 客户获取成本（CAC）分析](#7-客户获取成本cac分析)
  - [8. ROI分析](#8-roi分析)
  - [9. PostgreSQL 18 并行业务指标计算增强](#9-postgresql-18-并行业务指标计算增强)
    - [9.1 并行业务指标计算原理](#91-并行业务指标计算原理)
    - [9.2 并行收入指标计算](#92-并行收入指标计算)
    - [9.3 并行用户指标计算](#93-并行用户指标计算)
    - [9.4 并行运营指标计算](#94-并行运营指标计算)
  - [📊 性能优化建议](#-性能优化建议)
    - [索引优化](#索引优化)
    - [物化视图](#物化视图)
    - [分区表](#分区表)
  - [🎯 最佳实践](#-最佳实践)
    - [指标定义](#指标定义)
    - [数据质量](#数据质量)
    - [计算策略](#计算策略)
    - [可视化展示](#可视化展示)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 指标分类对比](#-指标分类对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：指标计算不准确](#问题1指标计算不准确)
    - [问题2：指标计算性能慢](#问题2指标计算性能慢)
    - [问题3：指标口径不一致](#问题3指标口径不一致)

---

## 案例概述

本案例综合运用聚合算法、窗口函数、时间序列分析等技术，计算各类业务关键指标（KPI）。

## 理论基础

### 业务指标计算问题定义

业务指标（KPI，Key Performance Indicator）是衡量业务绩效的关键指标，通过量化的方式反映业务运营状况、发展趋势和问题所在。

### 核心指标分类

1. **收入指标**：
   - 总收入（GMV）
   - 净收入（Revenue）
   - 平均订单价值（AOV）
   - 收入增长率

2. **用户指标**：
   - 用户总数
   - 活跃用户（DAU/MAU）
   - 新增用户
   - 用户留存率
   - 用户生命周期价值（LTV）

3. **运营指标**：
   - 订单转化率
   - 客户获取成本（CAC）
   - 客户留存成本
   - 运营效率

4. **财务指标**：
   - 毛利率
   - 净利率
   - 现金流
   - 投资回报率（ROI）

### 计算方法分类

1. **聚合计算**：SUM、AVG、COUNT、MAX、MIN
2. **比率计算**：转化率、留存率、增长率
3. **趋势分析**：同比增长、环比增长、移动平均
4. **对比分析**：与目标对比、与历史对比、与行业对比

### 技术栈

- **聚合算法**：SUM、AVG、COUNT、GROUP BY、FILTER
- **窗口函数**：LAG、LEAD、ROW_NUMBER、RANK
- **时间序列分析**：DATE_TRUNC、滑动窗口、移动平均
- **关联分析**：JOIN、CTE、子查询
- **统计分析**：百分位数、标准差、相关性

---

## 1. 数据准备

```sql
-- 创建业务数据表结构（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 创建订单表
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            DROP TABLE business_orders CASCADE;
        END IF;

        CREATE TABLE business_orders (
            order_id SERIAL PRIMARY KEY,
            user_id INTEGER NOT NULL,
            order_date DATE NOT NULL,
            order_amount NUMERIC(10, 2) NOT NULL,
            order_status VARCHAR(20) NOT NULL,
            channel VARCHAR(50)
        );

        -- 创建用户表
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_users') THEN
            DROP TABLE business_users CASCADE;
        END IF;

        CREATE TABLE business_users (
            user_id SERIAL PRIMARY KEY,
            registration_date DATE NOT NULL,
            user_type VARCHAR(20) NOT NULL
        );

        -- 插入示例数据
        INSERT INTO business_users (registration_date, user_type) VALUES
            ('2023-01-01', 'premium'),
            ('2023-02-01', 'standard'),
            ('2023-03-01', 'premium'),
            ('2023-04-01', 'standard'),
            ('2023-05-01', 'premium');

        INSERT INTO business_orders (user_id, order_date, order_amount, order_status, channel) VALUES
            (1, '2024-01-01', 1000.00, 'completed', 'web'),
            (1, '2024-01-15', 500.00, 'completed', 'mobile'),
            (2, '2024-01-05', 800.00, 'completed', 'web'),
            (2, '2024-01-20', 600.00, 'pending', 'mobile'),
            (3, '2024-01-10', 1200.00, 'completed', 'web'),
            (4, '2024-01-12', 400.00, 'completed', 'mobile'),
            (5, '2024-01-18', 900.00, 'completed', 'web'),
            (1, '2024-02-01', 750.00, 'completed', 'web'),
            (2, '2024-02-05', 550.00, 'completed', 'mobile'),
            (3, '2024-02-10', 1100.00, 'completed', 'web');

        RAISE NOTICE '业务数据表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;
```

---

## 2. 收入指标

```sql
-- 收入指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            RAISE WARNING '表 business_orders 不存在，无法计算收入指标';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算收入指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '收入指标计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 总收入（GMV）
SELECT
    'Total Revenue (GMV)' AS metric_name,
    SUM(order_amount) FILTER (WHERE order_status = 'completed') AS metric_value,
    'CNY' AS unit
FROM business_orders;

-- 月度收入趋势
SELECT
    DATE_TRUNC('month', order_date) AS month,
    SUM(order_amount) FILTER (WHERE order_status = 'completed') AS monthly_revenue,
    COUNT(*) FILTER (WHERE order_status = 'completed') AS order_count,
    AVG(order_amount) FILTER (WHERE order_status = 'completed') AS avg_order_value,
    SUM(order_amount) FILTER (WHERE order_status = 'completed') -
    LAG(SUM(order_amount) FILTER (WHERE order_status = 'completed')) OVER (ORDER BY DATE_TRUNC('month', order_date)) AS revenue_growth
FROM business_orders
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month;

-- 渠道收入分析
SELECT
    channel,
    SUM(order_amount) FILTER (WHERE order_status = 'completed') AS channel_revenue,
    COUNT(*) FILTER (WHERE order_status = 'completed') AS order_count,
    AVG(order_amount) FILTER (WHERE order_status = 'completed') AS avg_order_value,
    ROUND((SUM(order_amount) FILTER (WHERE order_status = 'completed')::numeric /
           NULLIF(SUM(SUM(order_amount) FILTER (WHERE order_status = 'completed')) OVER (), 0) * 100)::numeric, 2) AS revenue_percentage
FROM business_orders
GROUP BY channel
ORDER BY channel_revenue DESC;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('month', order_date) AS month,
    SUM(order_amount) FILTER (WHERE order_status = 'completed') AS monthly_revenue
FROM business_orders
GROUP BY DATE_TRUNC('month', order_date);
```

---

## 3. 用户指标

```sql
-- 用户指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_users') THEN
            RAISE WARNING '表 business_users 不存在，无法计算用户指标';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算用户指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '用户指标计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 用户总数和活跃用户
SELECT
    'Total Users' AS metric_name,
    COUNT(*) AS metric_value,
    'users' AS unit
FROM business_users
UNION ALL
SELECT
    'Active Users (Last 30 Days)',
    COUNT(DISTINCT bo.user_id),
    'users'
FROM business_orders bo
WHERE bo.order_date >= CURRENT_DATE - INTERVAL '30 days'
    AND bo.order_status = 'completed';

-- 用户价值分析
WITH user_value AS (
    SELECT
        bu.user_id,
        bu.user_type,
        COUNT(DISTINCT bo.order_id) FILTER (WHERE bo.order_status = 'completed') AS order_count,
        SUM(bo.order_amount) FILTER (WHERE bo.order_status = 'completed') AS total_value,
        AVG(bo.order_amount) FILTER (WHERE bo.order_status = 'completed') AS avg_order_value
    FROM business_users bu
    LEFT JOIN business_orders bo ON bu.user_id = bo.user_id
    GROUP BY bu.user_id, bu.user_type
)
SELECT
    user_type,
    COUNT(*) AS user_count,
    ROUND(AVG(order_count)::numeric, 2) AS avg_orders_per_user,
    ROUND(AVG(total_value)::numeric, 2) AS avg_user_value,
    ROUND(SUM(total_value)::numeric, 2) AS total_user_value
FROM user_value
GROUP BY user_type
ORDER BY avg_user_value DESC;

-- 用户留存率（简化版）
WITH user_first_order AS (
    SELECT
        user_id,
        MIN(order_date) AS first_order_date
    FROM business_orders
    WHERE order_status = 'completed'
    GROUP BY user_id
),
retention_analysis AS (
    SELECT
        DATE_TRUNC('month', ufo.first_order_date) AS cohort_month,
        COUNT(DISTINCT ufo.user_id) AS cohort_size,
        COUNT(DISTINCT CASE WHEN bo.order_date >= ufo.first_order_date + INTERVAL '1 month'
            AND bo.order_date < ufo.first_order_date + INTERVAL '2 months' THEN bo.user_id END) AS month_1_retained,
        COUNT(DISTINCT CASE WHEN bo.order_date >= ufo.first_order_date + INTERVAL '2 months'
            AND bo.order_date < ufo.first_order_date + INTERVAL '3 months' THEN bo.user_id END) AS month_2_retained
    FROM user_first_order ufo
    LEFT JOIN business_orders bo ON ufo.user_id = bo.user_id AND bo.order_status = 'completed'
    GROUP BY DATE_TRUNC('month', ufo.first_order_date)
)
SELECT
    cohort_month,
    cohort_size,
    month_1_retained,
    ROUND((month_1_retained::numeric / NULLIF(cohort_size, 0) * 100)::numeric, 2) AS month_1_retention_rate,
    month_2_retained,
    ROUND((month_2_retained::numeric / NULLIF(cohort_size, 0) * 100)::numeric, 2) AS month_2_retention_rate
FROM retention_analysis
ORDER BY cohort_month;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    user_id,
    COUNT(DISTINCT order_id) AS order_count,
    SUM(order_amount) AS total_value
FROM business_orders
WHERE order_status = 'completed'
GROUP BY user_id;
```

---

## 4. 运营指标

```sql
-- 运营指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            RAISE WARNING '表 business_orders 不存在，无法计算运营指标';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算运营指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '运营指标计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 订单转化率
SELECT
    'Order Conversion Rate' AS metric_name,
    ROUND((COUNT(*) FILTER (WHERE order_status = 'completed')::numeric / COUNT(*) * 100)::numeric, 2) AS metric_value,
    '%' AS unit
FROM business_orders;

-- 平均订单价值（AOV）
SELECT
    'Average Order Value (AOV)' AS metric_name,
    ROUND(AVG(order_amount) FILTER (WHERE order_status = 'completed')::numeric, 2) AS metric_value,
    'CNY' AS unit
FROM business_orders;

-- 客户生命周期价值（LTV）简化版
WITH user_lifetime_value AS (
    SELECT
        user_id,
        COUNT(DISTINCT order_id) FILTER (WHERE order_status = 'completed') AS total_orders,
        SUM(order_amount) FILTER (WHERE order_status = 'completed') AS lifetime_value,
        MIN(order_date) FILTER (WHERE order_status = 'completed') AS first_order_date,
        MAX(order_date) FILTER (WHERE order_status = 'completed') AS last_order_date
    FROM business_orders
    GROUP BY user_id
)
SELECT
    'Average Customer Lifetime Value' AS metric_name,
    ROUND(AVG(lifetime_value)::numeric, 2) AS metric_value,
    'CNY' AS unit
FROM user_lifetime_value
WHERE lifetime_value > 0;

-- 月度运营指标汇总
SELECT
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) AS total_orders,
    COUNT(*) FILTER (WHERE order_status = 'completed') AS completed_orders,
    ROUND((COUNT(*) FILTER (WHERE order_status = 'completed')::numeric / COUNT(*) * 100)::numeric, 2) AS conversion_rate,
    ROUND(AVG(order_amount) FILTER (WHERE order_status = 'completed')::numeric, 2) AS avg_order_value,
    COUNT(DISTINCT user_id) FILTER (WHERE order_status = 'completed') AS unique_customers
FROM business_orders
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) FILTER (WHERE order_status = 'completed') AS completed_orders,
    AVG(order_amount) FILTER (WHERE order_status = 'completed') AS avg_order_value
FROM business_orders
GROUP BY DATE_TRUNC('month', order_date);
```

---

## 5. 综合仪表板

```sql
-- 综合业务指标仪表板（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            RAISE WARNING '表 business_orders 不存在，无法生成综合仪表板';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成综合业务指标仪表板';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '综合仪表板生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 综合业务指标仪表板
WITH revenue_metrics AS (
    SELECT
        SUM(order_amount) FILTER (WHERE order_status = 'completed') AS total_revenue,
        AVG(order_amount) FILTER (WHERE order_status = 'completed') AS avg_order_value,
        COUNT(*) FILTER (WHERE order_status = 'completed') AS total_orders
    FROM business_orders
),
user_metrics AS (
    SELECT
        COUNT(DISTINCT bu.user_id) AS total_users,
        COUNT(DISTINCT bo.user_id) FILTER (WHERE bo.order_status = 'completed' AND bo.order_date >= CURRENT_DATE - INTERVAL '30 days') AS active_users_30d
    FROM business_users bu
    LEFT JOIN business_orders bo ON bu.user_id = bo.user_id
),
operational_metrics AS (
    SELECT
        COUNT(*) FILTER (WHERE order_status = 'completed')::numeric / COUNT(*) * 100 AS conversion_rate,
        COUNT(DISTINCT user_id) FILTER (WHERE order_status = 'completed') AS paying_customers
    FROM business_orders
)
SELECT
    'Revenue' AS category,
    'Total Revenue' AS metric_name,
    ROUND(rm.total_revenue::numeric, 2) AS metric_value,
    'CNY' AS unit
FROM revenue_metrics rm
UNION ALL
SELECT
    'Revenue',
    'Average Order Value',
    ROUND(rm.avg_order_value::numeric, 2),
    'CNY'
FROM revenue_metrics rm
UNION ALL
SELECT
    'Revenue',
    'Total Orders',
    rm.total_orders,
    'orders'
FROM revenue_metrics rm
UNION ALL
SELECT
    'Users',
    'Total Users',
    um.total_users,
    'users'
FROM user_metrics um
UNION ALL
SELECT
    'Users',
    'Active Users (30d)',
    um.active_users_30d,
    'users'
FROM user_metrics um
UNION ALL
SELECT
    'Operations',
    'Conversion Rate',
    ROUND(om.conversion_rate::numeric, 2),
    '%'
FROM operational_metrics om
UNION ALL
SELECT
    'Operations',
    'Paying Customers',
    om.paying_customers,
    'users'
FROM operational_metrics om
ORDER BY category, metric_name;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    SUM(order_amount) FILTER (WHERE order_status = 'completed') AS total_revenue,
    COUNT(*) FILTER (WHERE order_status = 'completed') AS total_orders
FROM business_orders;
```

---

## 6. 增长率分析

```sql
-- 增长率分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            RAISE WARNING '表 business_orders 不存在，无法进行增长率分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行增长率分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '增长率分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 月度收入增长率（环比）
WITH monthly_revenue AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        SUM(order_amount) FILTER (WHERE order_status = 'completed') AS revenue
    FROM business_orders
    GROUP BY DATE_TRUNC('month', order_date)
)
SELECT
    month,
    ROUND(revenue::numeric, 2) AS revenue,
    LAG(revenue) OVER (ORDER BY month) AS prev_month_revenue,
    ROUND(((revenue - LAG(revenue) OVER (ORDER BY month))::numeric /
           NULLIF(LAG(revenue) OVER (ORDER BY month), 0) * 100)::numeric, 2) AS month_over_month_growth,
    ROUND((revenue - LAG(revenue, 12) OVER (ORDER BY month))::numeric /
          NULLIF(LAG(revenue, 12) OVER (ORDER BY month), 0) * 100, 2) AS year_over_year_growth
FROM monthly_revenue
ORDER BY month;

-- 用户增长率
WITH monthly_users AS (
    SELECT
        DATE_TRUNC('month', registration_date) AS month,
        COUNT(*) AS new_users
    FROM business_users
    GROUP BY DATE_TRUNC('month', registration_date)
)
SELECT
    month,
    new_users,
    LAG(new_users) OVER (ORDER BY month) AS prev_month_users,
    ROUND(((new_users - LAG(new_users) OVER (ORDER BY month))::numeric /
           NULLIF(LAG(new_users) OVER (ORDER BY month), 0) * 100)::numeric, 2) AS user_growth_rate
FROM monthly_users
ORDER BY month;
```

---

## 7. 客户获取成本（CAC）分析

```sql
-- 客户获取成本分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 添加营销成本表（如果不存在）
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'marketing_costs') THEN
            CREATE TABLE marketing_costs (
                cost_id SERIAL PRIMARY KEY,
                cost_date DATE NOT NULL,
                channel VARCHAR(50) NOT NULL,
                cost_amount NUMERIC(10, 2) NOT NULL
            );

            -- 插入示例数据
            INSERT INTO marketing_costs (cost_date, channel, cost_amount) VALUES
                ('2024-01-01', 'web', 5000.00),
                ('2024-01-01', 'mobile', 3000.00),
                ('2024-02-01', 'web', 6000.00),
                ('2024-02-01', 'mobile', 3500.00);

            RAISE NOTICE '已创建营销成本表';
        END IF;

        RAISE NOTICE '开始进行客户获取成本分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '客户获取成本分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 客户获取成本（CAC）计算
WITH new_users_by_channel AS (
    SELECT
        DATE_TRUNC('month', bu.registration_date) AS month,
        bo.channel,
        COUNT(DISTINCT bu.user_id) AS new_users
    FROM business_users bu
    LEFT JOIN business_orders bo ON bu.user_id = bo.user_id
        AND bo.order_date >= bu.registration_date
        AND bo.order_date < bu.registration_date + INTERVAL '1 month'
    GROUP BY DATE_TRUNC('month', bu.registration_date), bo.channel
),
marketing_costs_by_channel AS (
    SELECT
        DATE_TRUNC('month', cost_date) AS month,
        channel,
        SUM(cost_amount) AS total_cost
    FROM marketing_costs
    GROUP BY DATE_TRUNC('month', cost_date), channel
)
SELECT
    COALESCE(nuc.month, mcc.month) AS month,
    COALESCE(nuc.channel, mcc.channel) AS channel,
    COALESCE(nuc.new_users, 0) AS new_users,
    COALESCE(mcc.total_cost, 0) AS total_cost,
    CASE
        WHEN COALESCE(nuc.new_users, 0) > 0 THEN
            ROUND((COALESCE(mcc.total_cost, 0) / nuc.new_users)::numeric, 2)
        ELSE NULL
    END AS cac_per_user
FROM new_users_by_channel nuc
FULL OUTER JOIN marketing_costs_by_channel mcc
    ON nuc.month = mcc.month AND nuc.channel = mcc.channel
ORDER BY month, channel;
```

---

## 8. ROI分析

```sql
-- ROI分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'marketing_costs') THEN
            RAISE WARNING '表 marketing_costs 不存在，无法进行ROI分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行ROI分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ROI分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 营销ROI分析
WITH channel_revenue AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        channel,
        SUM(order_amount) FILTER (WHERE order_status = 'completed') AS revenue
    FROM business_orders
    GROUP BY DATE_TRUNC('month', order_date), channel
),
channel_costs AS (
    SELECT
        DATE_TRUNC('month', cost_date) AS month,
        channel,
        SUM(cost_amount) AS total_cost
    FROM marketing_costs
    GROUP BY DATE_TRUNC('month', cost_date), channel
)
SELECT
    COALESCE(cr.month, cc.month) AS month,
    COALESCE(cr.channel, cc.channel) AS channel,
    COALESCE(cr.revenue, 0) AS revenue,
    COALESCE(cc.total_cost, 0) AS cost,
    COALESCE(cr.revenue, 0) - COALESCE(cc.total_cost, 0) AS profit,
    CASE
        WHEN COALESCE(cc.total_cost, 0) > 0 THEN
            ROUND(((COALESCE(cr.revenue, 0) - COALESCE(cc.total_cost, 0)) / cc.total_cost * 100)::numeric, 2)
        ELSE NULL
    END AS roi_percentage
FROM channel_revenue cr
FULL OUTER JOIN channel_costs cc
    ON cr.month = cc.month AND cr.channel = cc.channel
ORDER BY month, channel;
```

---

## 9. PostgreSQL 18 并行业务指标计算增强

**PostgreSQL 18** 显著增强了并行业务指标计算能力，支持并行执行收入指标、用户指标和运营指标计算，大幅提升大规模业务指标计算的性能。

### 9.1 并行业务指标计算原理

PostgreSQL 18 的并行业务指标计算通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描业务数据
2. **并行聚合**：每个工作进程独立计算部分指标
3. **并行计算**：每个工作进程独立计算增长率、转化率等
4. **结果合并**：主进程合并所有工作进程的计算结果

### 9.2 并行收入指标计算

```sql
-- PostgreSQL 18 并行收入指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            RAISE WARNING '表 business_orders 不存在，无法执行并行收入指标计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行收入指标计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行收入指标计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行收入指标计算：总收入、平均订单价值、订单数量
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('month', order_date) AS month,
    SUM(order_amount) FILTER (WHERE order_status = 'completed') AS total_revenue,
    AVG(order_amount) FILTER (WHERE order_status = 'completed') AS avg_order_value,
    COUNT(*) FILTER (WHERE order_status = 'completed') AS total_orders,
    COUNT(DISTINCT user_id) FILTER (WHERE order_status = 'completed') AS paying_customers
FROM business_orders
WHERE order_date >= CURRENT_DATE - INTERVAL '12 months'
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month DESC;
```

### 9.3 并行用户指标计算

```sql
-- PostgreSQL 18 并行用户指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_users') THEN
            RAISE WARNING '表 business_users 不存在，无法执行并行用户指标计算';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            RAISE WARNING '表 business_orders 不存在，无法执行并行用户指标计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行用户指标计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行用户指标计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行用户指标计算：活跃用户、留存率
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH daily_active_users AS (
    SELECT
        DATE_TRUNC('day', order_date) AS activity_date,
        COUNT(DISTINCT user_id) AS dau
    FROM business_orders
    WHERE order_status = 'completed'
      AND order_date >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY DATE_TRUNC('day', order_date)
),
user_retention AS (
    SELECT
        DATE_TRUNC('day', first_order_date) AS cohort_date,
        COUNT(DISTINCT user_id) AS new_users,
        COUNT(DISTINCT CASE WHEN order_date >= first_order_date + INTERVAL '7 days' THEN user_id END) AS retained_users_7d
    FROM (
        SELECT
            user_id,
            MIN(order_date) AS first_order_date,
            order_date
        FROM business_orders
        WHERE order_status = 'completed'
        GROUP BY user_id, order_date
    ) user_first_orders
    GROUP BY DATE_TRUNC('day', first_order_date)
)
SELECT
    dau.activity_date,
    dau.dau,
    ur.new_users,
    ur.retained_users_7d,
    ROUND(100.0 * ur.retained_users_7d / NULLIF(ur.new_users, 0), 2) AS retention_rate_7d
FROM daily_active_users dau
LEFT JOIN user_retention ur ON dau.activity_date = ur.cohort_date
ORDER BY dau.activity_date DESC;
```

### 9.4 并行运营指标计算

```sql
-- PostgreSQL 18 并行运营指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'business_orders') THEN
            RAISE WARNING '表 business_orders 不存在，无法执行并行运营指标计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行运营指标计算';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行运营指标计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行运营指标计算：转化率、客户获取成本
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH conversion_metrics AS (
    SELECT
        DATE_TRUNC('day', order_date) AS metric_date,
        COUNT(*) AS total_visits,
        COUNT(*) FILTER (WHERE order_status = 'completed') AS completed_orders,
        COUNT(DISTINCT user_id) FILTER (WHERE order_status = 'completed') AS paying_customers
    FROM business_orders
    WHERE order_date >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY DATE_TRUNC('day', order_date)
)
SELECT
    metric_date,
    total_visits,
    completed_orders,
    paying_customers,
    ROUND(100.0 * completed_orders / NULLIF(total_visits, 0), 2) AS conversion_rate,
    ROUND(100.0 * paying_customers / NULLIF(total_visits, 0), 2) AS customer_acquisition_rate
FROM conversion_metrics
ORDER BY metric_date DESC;
```

---

## 📊 性能优化建议

### 索引优化

```sql
-- 创建关键索引
CREATE INDEX IF NOT EXISTS idx_orders_date ON business_orders(order_date);
CREATE INDEX IF NOT EXISTS idx_orders_user ON business_orders(user_id);
CREATE INDEX IF NOT EXISTS idx_orders_status ON business_orders(order_status);
CREATE INDEX IF NOT EXISTS idx_orders_channel ON business_orders(channel);
CREATE INDEX IF NOT EXISTS idx_users_registration ON business_users(registration_date);
```

### 物化视图

```sql
-- 创建常用指标的物化视图
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_monthly_revenue AS
SELECT
    DATE_TRUNC('month', order_date) AS month,
    SUM(order_amount) FILTER (WHERE order_status = 'completed') AS revenue,
    COUNT(*) FILTER (WHERE order_status = 'completed') AS order_count,
    AVG(order_amount) FILTER (WHERE order_status = 'completed') AS avg_order_value
FROM business_orders
GROUP BY DATE_TRUNC('month', order_date);

CREATE UNIQUE INDEX ON mv_monthly_revenue(month);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_monthly_revenue;
```

### 分区表

```sql
-- 按时间分区订单表（PostgreSQL 10+）
CREATE TABLE business_orders_partitioned (
    LIKE business_orders INCLUDING ALL
) PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024_q1 PARTITION OF business_orders_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');
CREATE TABLE orders_2024_q2 PARTITION OF business_orders_partitioned
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');
```

---

## 🎯 最佳实践

### 指标定义

1. **明确计算方式**：明确定义每个指标的计算公式
2. **统一口径**：确保指标计算口径一致
3. **文档化**：将指标定义文档化
4. **版本管理**：管理指标定义的版本

### 数据质量

1. **数据准确性**：确保数据准确无误
2. **数据完整性**：确保数据完整无缺失
3. **数据一致性**：确保跨表数据一致
4. **数据时效性**：及时更新数据

### 计算策略

1. **实时计算**：对关键指标进行实时计算
2. **批量计算**：对历史指标进行批量计算
3. **增量计算**：使用增量计算提高效率
4. **缓存结果**：缓存常用指标结果

### 可视化展示

1. **仪表板**：创建业务指标仪表板
2. **图表展示**：使用图表展示趋势
3. **告警机制**：设置指标异常告警
4. **定期报告**：定期生成指标报告

### SQL实现注意事项

1. **错误处理**：使用DO块进行错误处理
2. **NULL值处理**：使用COALESCE和NULLIF处理NULL值
3. **性能优化**：使用索引和物化视图优化性能
4. **数据类型转换**：注意数据类型转换和精度

---

## 📈 指标分类对比

| 指标类型 | 典型指标 | 计算方法 | 更新频率 |
|---------|---------|---------|---------|
| 收入指标 | GMV、Revenue、AOV | 聚合计算 | 实时/日度 |
| 用户指标 | DAU、MAU、留存率 | 去重统计、比率计算 | 日度/周度 |
| 运营指标 | 转化率、CAC、LTV | 比率计算、复合计算 | 日度/周度 |
| 财务指标 | 毛利率、净利率、ROI | 复合计算 | 月度/季度 |

---

## 🔍 常见问题与解决方案

### 问题1：指标计算不准确

**原因**：

- 数据质量问题
- 计算公式错误
- 时间窗口选择不当

**解决方案**：

- 提高数据质量
- 仔细检查计算公式
- 选择合适的时间窗口
- 与业务人员确认

### 问题2：指标计算性能慢

**原因**：

- 数据量大
- 缺少索引
- 复杂计算

**解决方案**：

- 使用物化视图缓存结果
- 创建合适的索引
- 优化查询语句
- 使用分区表

### 问题3：指标口径不一致

**原因**：

- 指标定义不明确
- 计算逻辑不同
- 数据来源不同

**解决方案**：

- 明确指标定义
- 统一计算逻辑
- 统一数据来源
- 建立指标字典

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
