# PostgreSQL ç”µå•†æ•°æ®åˆ†æç»¼åˆæ¡ˆä¾‹

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ç”µå•†åˆ†æ | ç»¼åˆåº”ç”¨
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL ç”µå•†æ•°æ®åˆ†æç»¼åˆæ¡ˆä¾‹](#postgresql-ç”µå•†æ•°æ®åˆ†æç»¼åˆæ¡ˆä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¡ˆä¾‹æ¦‚è¿°](#æ¡ˆä¾‹æ¦‚è¿°)
  - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [ç”µå•†æ•°æ®åˆ†æé—®é¢˜å®šä¹‰](#ç”µå•†æ•°æ®åˆ†æé—®é¢˜å®šä¹‰)
    - [æ ¸å¿ƒåˆ†æç»´åº¦](#æ ¸å¿ƒåˆ†æç»´åº¦)
    - [åˆ†ææ–¹æ³•åˆ†ç±»](#åˆ†ææ–¹æ³•åˆ†ç±»)
    - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
  - [1. æ•°æ®å‡†å¤‡](#1-æ•°æ®å‡†å¤‡)
  - [2. é”€å”®åˆ†æ](#2-é”€å”®åˆ†æ)
  - [3. ç”¨æˆ·è¡Œä¸ºåˆ†æ](#3-ç”¨æˆ·è¡Œä¸ºåˆ†æ)
  - [4. å•†å“åˆ†æ](#4-å•†å“åˆ†æ)
  - [5. ç»¼åˆæŠ¥è¡¨](#5-ç»¼åˆæŠ¥è¡¨)
  - [6. åº“å­˜åˆ†æ](#6-åº“å­˜åˆ†æ)
  - [7. ä¿ƒé”€æ•ˆæœåˆ†æ](#7-ä¿ƒé”€æ•ˆæœåˆ†æ)
  - [8. å®¢æˆ·æµå¤±åˆ†æ](#8-å®¢æˆ·æµå¤±åˆ†æ)
  - [9. å•†å“å…³è”åˆ†æ](#9-å•†å“å…³è”åˆ†æ)
  - [ğŸ“Š PostgreSQL 18å¹¶è¡Œç”µå•†æ•°æ®åˆ†æ](#-postgresql-18å¹¶è¡Œç”µå•†æ•°æ®åˆ†æ)
    - [å¹¶è¡Œç”µå•†æ•°æ®åˆ†ææ¦‚è¿°](#å¹¶è¡Œç”µå•†æ•°æ®åˆ†ææ¦‚è¿°)
      - [å¹¶è¡Œç”µå•†æ•°æ®åˆ†æé…ç½®](#å¹¶è¡Œç”µå•†æ•°æ®åˆ†æé…ç½®)
      - [å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå®ç°](#å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå®ç°)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [ç´¢å¼•ä¼˜åŒ–](#ç´¢å¼•ä¼˜åŒ–)
    - [åˆ†åŒºè¡¨](#åˆ†åŒºè¡¨)
    - [ç‰©åŒ–è§†å›¾](#ç‰©åŒ–è§†å›¾)
    - [æŸ¥è¯¢ä¼˜åŒ–](#æŸ¥è¯¢ä¼˜åŒ–)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [æ•°æ®è´¨é‡](#æ•°æ®è´¨é‡)
    - [åˆ†æç­–ç•¥](#åˆ†æç­–ç•¥)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [ç›‘æ§ä¸ç»´æŠ¤](#ç›‘æ§ä¸ç»´æŠ¤)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨](#postgresql-18-æ–°ç‰¹æ€§åº”ç”¨)
    - [10. å®æ—¶æ¨èç³»ç»Ÿæ¡ˆä¾‹](#10-å®æ—¶æ¨èç³»ç»Ÿæ¡ˆä¾‹)
    - [11. ä»·æ ¼å¼¹æ€§åˆ†ææ¡ˆä¾‹](#11-ä»·æ ¼å¼¹æ€§åˆ†ææ¡ˆä¾‹)
    - [12. é«˜çº§ä¼˜åŒ–æŠ€å·§](#12-é«˜çº§ä¼˜åŒ–æŠ€å·§)
  - [ğŸ“ˆ åˆ†ææ–¹æ³•å¯¹æ¯”](#-åˆ†ææ–¹æ³•å¯¹æ¯”)
  - [ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
    - [é—®é¢˜1ï¼šæŸ¥è¯¢æ€§èƒ½æ…¢](#é—®é¢˜1æŸ¥è¯¢æ€§èƒ½æ…¢)
    - [é—®é¢˜2ï¼šæ•°æ®ä¸ä¸€è‡´](#é—®é¢˜2æ•°æ®ä¸ä¸€è‡´)
    - [é—®é¢˜3ï¼šåˆ†æç»“æœä¸å‡†ç¡®](#é—®é¢˜3åˆ†æç»“æœä¸å‡†ç¡®)

---

## æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ¡ˆä¾‹ç»¼åˆè¿ç”¨å¤šç§SQLç®—æ³•å’ŒæŠ€æœ¯ï¼Œå¯¹ç”µå•†æ•°æ®è¿›è¡Œå…¨é¢åˆ†æï¼ŒåŒ…æ‹¬é”€å”®ç»Ÿè®¡ã€ç”¨æˆ·è¡Œä¸ºã€å•†å“åˆ†æç­‰ã€‚

## ç†è®ºåŸºç¡€

### ç”µå•†æ•°æ®åˆ†æé—®é¢˜å®šä¹‰

ç”µå•†æ•°æ®åˆ†ææ˜¯é€šè¿‡å¯¹ç”µå•†å¹³å°äº§ç”Ÿçš„æµ·é‡æ•°æ®è¿›è¡Œæ”¶é›†ã€å¤„ç†ã€åˆ†æå’ŒæŒ–æ˜ï¼Œä»¥å‘ç°ä¸šåŠ¡è§„å¾‹ã€ä¼˜åŒ–è¿è¥ç­–ç•¥ã€æå‡ç”¨æˆ·ä½“éªŒå’Œå¢åŠ æ”¶å…¥çš„è¿‡ç¨‹ã€‚

### æ ¸å¿ƒåˆ†æç»´åº¦

1. **é”€å”®åˆ†æ**ï¼š
   - é”€å”®é¢ç»Ÿè®¡ï¼ˆæ€»é‡ã€è¶‹åŠ¿ã€å¯¹æ¯”ï¼‰
   - è®¢å•åˆ†æï¼ˆæ•°é‡ã€é¢‘ç‡ã€ä»·å€¼ï¼‰
   - é”€å”®æ¸ é“åˆ†æ
   - é”€å”®åœ°åŸŸåˆ†æ

2. **ç”¨æˆ·åˆ†æ**ï¼š
   - ç”¨æˆ·ä»·å€¼åˆ†æï¼ˆRFMæ¨¡å‹ï¼‰
   - ç”¨æˆ·è¡Œä¸ºåˆ†æï¼ˆæµè§ˆã€è´­ä¹°ã€å¤è´­ï¼‰
   - ç”¨æˆ·ç•™å­˜åˆ†æ
   - ç”¨æˆ·åˆ†ç¾¤åˆ†æ

3. **å•†å“åˆ†æ**ï¼š
   - å•†å“é”€å”®æ’è¡Œ
   - å•†å“ç±»åˆ«åˆ†æ
   - åº“å­˜åˆ†æ
   - å•†å“å…³è”åˆ†æ

4. **è¿è¥åˆ†æ**ï¼š
   - ä¿ƒé”€æ•ˆæœåˆ†æ
   - è½¬åŒ–ç‡åˆ†æ
   - å®¢æˆ·æµå¤±åˆ†æ
   - è¿è¥æ•ˆç‡åˆ†æ

### åˆ†ææ–¹æ³•åˆ†ç±»

1. **æè¿°æ€§åˆ†æ**ï¼šç»Ÿè®¡æ±‡æ€»ã€è¶‹åŠ¿åˆ†æã€å¯¹æ¯”åˆ†æ
2. **è¯Šæ–­æ€§åˆ†æ**ï¼šåŸå› åˆ†æã€å…³è”åˆ†æã€å¼‚å¸¸æ£€æµ‹
3. **é¢„æµ‹æ€§åˆ†æ**ï¼šè¶‹åŠ¿é¢„æµ‹ã€éœ€æ±‚é¢„æµ‹ã€æµå¤±é¢„æµ‹
4. **è§„èŒƒæ€§åˆ†æ**ï¼šä¼˜åŒ–å»ºè®®ã€ç­–ç•¥æ¨èã€å†³ç­–æ”¯æŒ

### æŠ€æœ¯æ ˆ

- **èšåˆç®—æ³•**ï¼šSUMã€AVGã€COUNTã€GROUP BY
- **çª—å£å‡½æ•°**ï¼šROW_NUMBERã€RANKã€LAGã€LEAD
- **æ—¶é—´åºåˆ—åˆ†æ**ï¼šDATE_TRUNCã€æ»‘åŠ¨çª—å£ã€ç§»åŠ¨å¹³å‡
- **å…³è”åˆ†æ**ï¼šJOINã€å­æŸ¥è¯¢ã€CTE
- **ç»Ÿè®¡åˆ†æ**ï¼šç™¾åˆ†ä½æ•°ã€æ ‡å‡†å·®ã€ç›¸å…³æ€§

---

## 1. æ•°æ®å‡†å¤‡

```sql
-- åˆ›å»ºç”µå•†æ•°æ®åº“è¡¨ç»“æ„ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        -- åˆ›å»ºç”¨æˆ·è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users') THEN
            DROP TABLE users CASCADE;
        END IF;

        CREATE TABLE users (
            user_id SERIAL PRIMARY KEY,
            username VARCHAR(50) NOT NULL,
            email VARCHAR(100) UNIQUE,
            registration_date DATE NOT NULL,
            city VARCHAR(50)
        );

        -- åˆ›å»ºå•†å“è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            DROP TABLE products CASCADE;
        END IF;

        CREATE TABLE products (
            product_id SERIAL PRIMARY KEY,
            product_name VARCHAR(100) NOT NULL,
            category VARCHAR(50) NOT NULL,
            price NUMERIC(10, 2) NOT NULL,
            stock_quantity INTEGER NOT NULL
        );

        -- åˆ›å»ºè®¢å•è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            DROP TABLE orders CASCADE;
        END IF;

        CREATE TABLE orders (
            order_id SERIAL PRIMARY KEY,
            user_id INTEGER NOT NULL,
            order_date DATE NOT NULL,
            total_amount NUMERIC(10, 2) NOT NULL,
            status VARCHAR(20) NOT NULL,
            FOREIGN KEY (user_id) REFERENCES users(user_id)
        );

        -- åˆ›å»ºè®¢å•æ˜ç»†è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            DROP TABLE order_items CASCADE;
        END IF;

        CREATE TABLE order_items (
            item_id SERIAL PRIMARY KEY,
            order_id INTEGER NOT NULL,
            product_id INTEGER NOT NULL,
            quantity INTEGER NOT NULL,
            unit_price NUMERIC(10, 2) NOT NULL,
            FOREIGN KEY (order_id) REFERENCES orders(order_id),
            FOREIGN KEY (product_id) REFERENCES products(product_id)
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO users (username, email, registration_date, city) VALUES
            ('user1', 'user1@example.com', '2023-01-15', 'Beijing'),
            ('user2', 'user2@example.com', '2023-02-20', 'Shanghai'),
            ('user3', 'user3@example.com', '2023-03-10', 'Guangzhou'),
            ('user4', 'user4@example.com', '2023-04-05', 'Shenzhen'),
            ('user5', 'user5@example.com', '2023-05-12', 'Beijing');

        INSERT INTO products (product_name, category, price, stock_quantity) VALUES
            ('Laptop', 'Electronics', 5999.00, 50),
            ('Smartphone', 'Electronics', 3999.00, 100),
            ('Tablet', 'Electronics', 2999.00, 30),
            ('Headphones', 'Electronics', 299.00, 200),
            ('Keyboard', 'Electronics', 199.00, 150);

        INSERT INTO orders (user_id, order_date, total_amount, status) VALUES
            (1, '2024-01-01', 9998.00, 'completed'),
            (1, '2024-01-15', 299.00, 'completed'),
            (2, '2024-01-05', 3999.00, 'completed'),
            (2, '2024-01-20', 2999.00, 'pending'),
            (3, '2024-01-10', 5999.00, 'completed'),
            (4, '2024-01-12', 199.00, 'completed'),
            (5, '2024-01-18', 3298.00, 'completed');

        INSERT INTO order_items (order_id, product_id, quantity, unit_price) VALUES
            (1, 1, 1, 5999.00), (1, 2, 1, 3999.00),
            (2, 4, 1, 299.00),
            (3, 2, 1, 3999.00),
            (4, 3, 1, 2999.00),
            (5, 1, 1, 5999.00),
            (6, 5, 1, 199.00),
            (7, 2, 1, 3999.00), (7, 4, 1, 299.00);

        RAISE NOTICE 'ç”µå•†æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

---

## 2. é”€å”®åˆ†æ

```sql
-- é”€å”®åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œé”€å”®åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œé”€å”®åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é”€å”®åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æœˆåº¦é”€å”®ç»Ÿè®¡
SELECT
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) AS order_count,
    COUNT(DISTINCT user_id) AS unique_customers,
    SUM(total_amount) AS total_revenue,
    AVG(total_amount) AS avg_order_value,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY total_amount) AS median_order_value
FROM orders
WHERE status = 'completed'
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month;

-- é”€å”®è¶‹åŠ¿åˆ†æï¼ˆç§»åŠ¨å¹³å‡ï¼‰
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        SUM(total_amount) AS monthly_revenue
    FROM orders
    WHERE status = 'completed'
    GROUP BY DATE_TRUNC('month', order_date)
)
SELECT
    month,
    monthly_revenue,
    AVG(monthly_revenue) OVER (
        ORDER BY month
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3months
FROM monthly_sales
ORDER BY month;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('month', order_date) AS month,
    SUM(total_amount) AS total_revenue
FROM orders
WHERE status = 'completed'
GROUP BY DATE_TRUNC('month', order_date);
```

---

## 3. ç”¨æˆ·è¡Œä¸ºåˆ†æ

```sql
-- ç”¨æˆ·è¡Œä¸ºåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œç”¨æˆ·è¡Œä¸ºåˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œç”¨æˆ·è¡Œä¸ºåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç”¨æˆ·è¡Œä¸ºåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç”¨æˆ·ä»·å€¼åˆ†æï¼ˆRFMæ¨¡å‹ç®€åŒ–ç‰ˆï¼‰
WITH user_metrics AS (
    SELECT
        u.user_id,
        u.username,
        COUNT(DISTINCT o.order_id) AS frequency,
        SUM(o.total_amount) AS monetary_value,
        MAX(o.order_date) AS last_order_date,
        CURRENT_DATE - MAX(o.order_date) AS recency_days
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.username
)
SELECT
    user_id,
    username,
    frequency,
    ROUND(monetary_value::numeric, 2) AS monetary_value,
    recency_days,
    CASE
        WHEN recency_days <= 30 THEN 'Active'
        WHEN recency_days <= 90 THEN 'At Risk'
        ELSE 'Inactive'
    END AS customer_segment
FROM user_metrics
ORDER BY monetary_value DESC NULLS LAST;

-- ç”¨æˆ·è´­ä¹°è¡Œä¸ºåˆ†æ
WITH user_purchase_patterns AS (
    SELECT
        u.user_id,
        u.username,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent,
        AVG(o.total_amount) AS avg_order_value,
        COUNT(DISTINCT oi.product_id) AS unique_products_purchased,
        COUNT(oi.item_id) AS total_items_purchased
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY u.user_id, u.username
)
SELECT
    user_id,
    username,
    total_orders,
    ROUND(total_spent::numeric, 2) AS total_spent,
    ROUND(avg_order_value::numeric, 2) AS avg_order_value,
    unique_products_purchased,
    total_items_purchased,
    ROUND((total_spent / NULLIF(total_orders, 0))::numeric, 2) AS value_per_order
FROM user_purchase_patterns
ORDER BY total_spent DESC NULLS LAST;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    u.user_id,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_amount) AS total_spent
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
GROUP BY u.user_id;
```

---

## 4. å•†å“åˆ†æ

```sql
-- å•†å“åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING 'è¡¨ order_items ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå•†å“åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå•†å“åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å•†å“åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å•†å“é”€å”®æ’è¡Œ
SELECT
    p.product_id,
    p.product_name,
    p.category,
    COUNT(DISTINCT oi.order_id) AS order_count,
    SUM(oi.quantity) AS total_quantity_sold,
    SUM(oi.quantity * oi.unit_price) AS total_revenue,
    AVG(oi.unit_price) AS avg_price,
    RANK() OVER (ORDER BY SUM(oi.quantity * oi.unit_price) DESC) AS revenue_rank
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
GROUP BY p.product_id, p.product_name, p.category
ORDER BY total_revenue DESC NULLS LAST;

-- ç±»åˆ«é”€å”®åˆ†æ
SELECT
    p.category,
    COUNT(DISTINCT p.product_id) AS product_count,
    COUNT(DISTINCT oi.order_id) AS order_count,
    SUM(oi.quantity) AS total_quantity_sold,
    SUM(oi.quantity * oi.unit_price) AS category_revenue,
    AVG(oi.unit_price) AS avg_category_price,
    ROUND((SUM(oi.quantity * oi.unit_price) / NULLIF(SUM(SUM(oi.quantity * oi.unit_price)) OVER (), 0) * 100)::numeric, 2) AS revenue_percentage
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
GROUP BY p.category
ORDER BY category_revenue DESC NULLS LAST;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    p.category,
    SUM(oi.quantity * oi.unit_price) AS category_revenue
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY p.category;
```

---

## 5. ç»¼åˆæŠ¥è¡¨

```sql
-- ç»¼åˆæŠ¥è¡¨ç”Ÿæˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•ç”Ÿæˆç»¼åˆæŠ¥è¡¨';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹ç”Ÿæˆç»¼åˆæŠ¥è¡¨';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç»¼åˆæŠ¥è¡¨ç”Ÿæˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç”µå•†æ•°æ®ç»¼åˆæŠ¥è¡¨
WITH sales_summary AS (
    SELECT
        COUNT(DISTINCT o.order_id) AS total_orders,
        COUNT(DISTINCT o.user_id) AS total_customers,
        SUM(o.total_amount) AS total_revenue,
        AVG(o.total_amount) AS avg_order_value
    FROM orders o
    WHERE o.status = 'completed'
),
product_summary AS (
    SELECT
        COUNT(DISTINCT p.product_id) AS total_products,
        COUNT(DISTINCT p.category) AS total_categories,
        SUM(oi.quantity) AS total_items_sold
    FROM products p
    LEFT JOIN order_items oi ON p.product_id = oi.product_id
    LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
),
user_summary AS (
    SELECT
        COUNT(*) AS total_users,
        COUNT(*) FILTER (WHERE EXISTS (
            SELECT 1 FROM orders WHERE user_id = users.user_id AND status = 'completed'
        )) AS active_users
    FROM users
)
SELECT
    'Sales Metrics' AS metric_category,
    ss.total_orders AS metric_value,
    'Total Orders' AS metric_name
FROM sales_summary ss
UNION ALL
SELECT
    'Sales Metrics',
    ss.total_customers,
    'Total Customers'
FROM sales_summary ss
UNION ALL
SELECT
    'Sales Metrics',
    ROUND(ss.total_revenue::numeric, 2),
    'Total Revenue'
FROM sales_summary ss
UNION ALL
SELECT
    'Product Metrics',
    ps.total_products,
    'Total Products'
FROM product_summary ps
UNION ALL
SELECT
    'Product Metrics',
    ps.total_items_sold,
    'Total Items Sold'
FROM product_summary ps
UNION ALL
SELECT
    'User Metrics',
    us.total_users,
    'Total Users'
FROM user_summary us
UNION ALL
SELECT
    'User Metrics',
    us.active_users,
    'Active Users'
FROM user_summary us
ORDER BY metric_category, metric_name;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_amount) AS total_revenue
FROM orders
WHERE status = 'completed';
```

---

## 6. åº“å­˜åˆ†æ

```sql
-- åº“å­˜åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING 'è¡¨ products ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œåº“å­˜åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œåº“å­˜åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åº“å­˜åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åº“å­˜å‘¨è½¬ç‡åˆ†æ
WITH product_sales AS (
    SELECT
        p.product_id,
        p.product_name,
        p.category,
        p.stock_quantity,
        COALESCE(SUM(oi.quantity), 0) AS total_sold,
        COALESCE(COUNT(DISTINCT o.order_id), 0) AS order_count
    FROM products p
    LEFT JOIN order_items oi ON p.product_id = oi.product_id
    LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
    GROUP BY p.product_id, p.product_name, p.category, p.stock_quantity
)
SELECT
    product_id,
    product_name,
    category,
    stock_quantity,
    total_sold,
    order_count,
    CASE
        WHEN stock_quantity = 0 THEN 'Out of Stock'
        WHEN stock_quantity < 10 THEN 'Low Stock'
        WHEN stock_quantity < 50 THEN 'Normal Stock'
        ELSE 'High Stock'
    END AS stock_status,
    CASE
        WHEN total_sold > 0 THEN ROUND((total_sold::numeric / NULLIF(stock_quantity + total_sold, 0) * 100)::numeric, 2)
        ELSE 0
    END AS turnover_rate
FROM product_sales
ORDER BY turnover_rate DESC NULLS LAST;

-- åº“å­˜é¢„è­¦åˆ†æ
SELECT
    p.product_id,
    p.product_name,
    p.category,
    p.stock_quantity,
    COALESCE(SUM(oi.quantity), 0) AS total_sold,
    CASE
        WHEN p.stock_quantity = 0 THEN 'Critical: Out of Stock'
        WHEN p.stock_quantity < 10 AND COALESCE(SUM(oi.quantity), 0) > 0 THEN 'Warning: Low Stock'
        WHEN p.stock_quantity >= 100 AND COALESCE(SUM(oi.quantity), 0) = 0 THEN 'Info: Overstocked'
        ELSE 'Normal'
    END AS alert_level
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
GROUP BY p.product_id, p.product_name, p.category, p.stock_quantity
HAVING p.stock_quantity = 0 OR (p.stock_quantity < 10 AND COALESCE(SUM(oi.quantity), 0) > 0) OR (p.stock_quantity >= 100 AND COALESCE(SUM(oi.quantity), 0) = 0)
ORDER BY
    CASE alert_level
        WHEN 'Critical: Out of Stock' THEN 1
        WHEN 'Warning: Low Stock' THEN 2
        WHEN 'Info: Overstocked' THEN 3
        ELSE 4
    END,
    total_sold DESC;
```

---

## 7. ä¿ƒé”€æ•ˆæœåˆ†æ

```sql
-- ä¿ƒé”€æ•ˆæœåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        -- æ·»åŠ ä¿ƒé”€å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public'
            AND table_name = 'orders'
            AND column_name = 'promotion_id'
        ) THEN
            ALTER TABLE orders ADD COLUMN promotion_id INTEGER;
            ALTER TABLE orders ADD COLUMN discount_amount NUMERIC(10, 2) DEFAULT 0;
            RAISE NOTICE 'å·²æ·»åŠ ä¿ƒé”€å­—æ®µ';
        END IF;

        -- æ›´æ–°ç¤ºä¾‹æ•°æ®
        UPDATE orders SET promotion_id = 1, discount_amount = 100.00 WHERE order_id IN (1, 3);
        UPDATE orders SET promotion_id = 2, discount_amount = 50.00 WHERE order_id IN (2, 5);

        RAISE NOTICE 'å¼€å§‹è¿›è¡Œä¿ƒé”€æ•ˆæœåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¿ƒé”€æ•ˆæœåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä¿ƒé”€æ´»åŠ¨æ•ˆæœåˆ†æ
SELECT
    promotion_id,
    COUNT(DISTINCT order_id) AS order_count,
    COUNT(DISTINCT user_id) AS unique_customers,
    SUM(total_amount) AS total_revenue,
    SUM(discount_amount) AS total_discount,
    SUM(total_amount + discount_amount) AS gross_revenue,
    AVG(total_amount) AS avg_order_value,
    SUM(total_amount) / NULLIF(COUNT(DISTINCT user_id), 0) AS revenue_per_customer
FROM orders
WHERE status = 'completed' AND promotion_id IS NOT NULL
GROUP BY promotion_id
ORDER BY total_revenue DESC;

-- ä¿ƒé”€ROIåˆ†æ
WITH promotion_stats AS (
    SELECT
        promotion_id,
        COUNT(DISTINCT order_id) AS order_count,
        SUM(total_amount) AS net_revenue,
        SUM(discount_amount) AS total_discount,
        SUM(total_amount + discount_amount) AS gross_revenue
    FROM orders
    WHERE status = 'completed' AND promotion_id IS NOT NULL
    GROUP BY promotion_id
)
SELECT
    promotion_id,
    order_count,
    ROUND(net_revenue::numeric, 2) AS net_revenue,
    ROUND(total_discount::numeric, 2) AS total_discount,
    ROUND(gross_revenue::numeric, 2) AS gross_revenue,
    CASE
        WHEN total_discount > 0 THEN ROUND((net_revenue / total_discount)::numeric, 2)
        ELSE NULL
    END AS roi_ratio,
    CASE
        WHEN total_discount > 0 AND net_revenue > total_discount THEN 'Profitable'
        WHEN total_discount > 0 AND net_revenue <= total_discount THEN 'Loss'
        ELSE 'Neutral'
    END AS profitability
FROM promotion_stats
ORDER BY roi_ratio DESC NULLS LAST;
```

---

## 8. å®¢æˆ·æµå¤±åˆ†æ

```sql
-- å®¢æˆ·æµå¤±åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå®¢æˆ·æµå¤±åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå®¢æˆ·æµå¤±åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·æµå¤±åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å®¢æˆ·æµå¤±è¯†åˆ«
WITH user_last_order AS (
    SELECT
        u.user_id,
        u.username,
        u.registration_date,
        MAX(o.order_date) AS last_order_date,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent,
        CURRENT_DATE - MAX(o.order_date) AS days_since_last_order
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.username, u.registration_date
)
SELECT
    user_id,
    username,
    registration_date,
    last_order_date,
    total_orders,
    ROUND(total_spent::numeric, 2) AS total_spent,
    days_since_last_order,
    CASE
        WHEN days_since_last_order IS NULL THEN 'Never Purchased'
        WHEN days_since_last_order <= 30 THEN 'Active'
        WHEN days_since_last_order <= 60 THEN 'At Risk'
        WHEN days_since_last_order <= 90 THEN 'Churning'
        ELSE 'Churned'
    END AS churn_status,
    CASE
        WHEN days_since_last_order IS NULL THEN 0
        WHEN days_since_last_order <= 30 THEN 1
        WHEN days_since_last_order <= 60 THEN 2
        WHEN days_since_last_order <= 90 THEN 3
        ELSE 4
    END AS churn_score
FROM user_last_order
ORDER BY days_since_last_order DESC NULLS LAST;

-- æµå¤±å®¢æˆ·ç‰¹å¾åˆ†æ
WITH user_churn AS (
    SELECT
        u.user_id,
        u.city,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent,
        MAX(o.order_date) AS last_order_date,
        CURRENT_DATE - MAX(o.order_date) AS days_since_last_order,
        CASE
            WHEN CURRENT_DATE - MAX(o.order_date) > 90 THEN 'Churned'
            ELSE 'Active'
        END AS churn_status
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.city
)
SELECT
    churn_status,
    COUNT(*) AS customer_count,
    ROUND(AVG(total_orders)::numeric, 2) AS avg_orders,
    ROUND(AVG(total_spent)::numeric, 2) AS avg_spent,
    ROUND(AVG(days_since_last_order)::numeric, 0) AS avg_days_since_last_order
FROM user_churn
GROUP BY churn_status
ORDER BY churn_status;
```

---

## 9. å•†å“å…³è”åˆ†æ

```sql
-- å•†å“å…³è”åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING 'è¡¨ order_items ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå•†å“å…³è”åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå•†å“å…³è”åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å•†å“å…³è”åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å•†å“å…±ç°åˆ†æï¼ˆä¸€èµ·è´­ä¹°çš„å•†å“å¯¹ï¼‰
WITH product_pairs AS (
    SELECT DISTINCT
        oi1.product_id AS product1_id,
        p1.product_name AS product1_name,
        oi2.product_id AS product2_id,
        p2.product_name AS product2_name,
        oi1.order_id
    FROM order_items oi1
    INNER JOIN order_items oi2 ON oi1.order_id = oi2.order_id
    INNER JOIN products p1 ON oi1.product_id = p1.product_id
    INNER JOIN products p2 ON oi2.product_id = p2.product_id
    WHERE oi1.product_id < oi2.product_id
)
SELECT
    product1_id,
    product1_name,
    product2_id,
    product2_name,
    COUNT(DISTINCT order_id) AS co_occurrence_count,
    ROUND((COUNT(DISTINCT order_id)::numeric / NULLIF((
        SELECT COUNT(DISTINCT order_id) FROM order_items WHERE product_id = product1_id
    ), 0) * 100)::numeric, 2) AS support_percentage
FROM product_pairs
GROUP BY product1_id, product1_name, product2_id, product2_name
HAVING COUNT(DISTINCT order_id) > 0
ORDER BY co_occurrence_count DESC;

-- å•†å“æ¨èï¼ˆåŸºäºå…³è”è§„åˆ™ï¼‰
WITH product_frequency AS (
    SELECT
        product_id,
        COUNT(DISTINCT order_id) AS order_count
    FROM order_items
    GROUP BY product_id
),
product_pairs AS (
    SELECT DISTINCT
        oi1.product_id AS product1_id,
        oi2.product_id AS product2_id,
        COUNT(DISTINCT oi1.order_id) AS pair_count
    FROM order_items oi1
    INNER JOIN order_items oi2 ON oi1.order_id = oi2.order_id
    WHERE oi1.product_id <> oi2.product_id
    GROUP BY oi1.product_id, oi2.product_id
)
SELECT
    pp.product1_id,
    p1.product_name AS product1_name,
    pp.product2_id,
    p2.product_name AS product2_name,
    pp.pair_count,
    pf1.order_count AS product1_total_orders,
    pf2.order_count AS product2_total_orders,
    ROUND((pp.pair_count::numeric / NULLIF(pf1.order_count, 0) * 100)::numeric, 2) AS confidence_percentage
FROM product_pairs pp
INNER JOIN products p1 ON pp.product1_id = p1.product_id
INNER JOIN products p2 ON pp.product2_id = p2.product_id
INNER JOIN product_frequency pf1 ON pp.product1_id = pf1.product_id
INNER JOIN product_frequency pf2 ON pp.product2_id = pf2.product_id
WHERE pp.pair_count >= 1
ORDER BY confidence_percentage DESC, pp.pair_count DESC;
```

---

## ğŸ“Š PostgreSQL 18å¹¶è¡Œç”µå•†æ•°æ®åˆ†æ

### å¹¶è¡Œç”µå•†æ•°æ®åˆ†ææ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œç”µå•†æ•°æ®åˆ†æ**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡ç”µå•†æ•°æ®åˆ†æçš„æ€§èƒ½ã€‚

#### å¹¶è¡Œç”µå•†æ•°æ®åˆ†æé…ç½®

```sql
-- é…ç½®å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œç”µå•†æ•°æ®åˆ†æé…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå®ç°

```sql
-- å¹¶è¡Œé”€å”®åˆ†æï¼šå¤§è§„æ¨¡é”€å”®æ•°æ®ç»Ÿè®¡ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œç”µå•†æ•°æ®åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œå¤šç»´åº¦é”€å”®åˆ†æ
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    DATE_TRUNC('month', order_date) AS month,
    region,
    category,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    COUNT(DISTINCT customer_id) AS unique_customers
FROM orders
WHERE order_date >= CURRENT_DATE - INTERVAL '1 year'
GROUP BY DATE_TRUNC('month', order_date), region, category
ORDER BY month DESC, total_amount DESC;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå…³é”®ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_orders_date ON orders(order_date);
CREATE INDEX IF NOT EXISTS idx_orders_user ON orders(user_id);
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_order_items_order ON order_items(order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_product ON order_items(product_id);
CREATE INDEX IF NOT EXISTS idx_products_category ON products(category);
```

### åˆ†åŒºè¡¨

```sql
-- æŒ‰æ—¶é—´åˆ†åŒºè®¢å•è¡¨ï¼ˆPostgreSQL 10+ï¼‰
CREATE TABLE orders_partitioned (
    LIKE orders INCLUDING ALL
) PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024_q1 PARTITION OF orders_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');
CREATE TABLE orders_2024_q2 PARTITION OF orders_partitioned
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');
```

### ç‰©åŒ–è§†å›¾

```sql
-- åˆ›å»ºå¸¸ç”¨æŠ¥è¡¨çš„ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_daily_sales AS
SELECT
    DATE_TRUNC('day', order_date) AS sale_date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_revenue,
    COUNT(DISTINCT user_id) AS unique_customers
FROM orders
WHERE status = 'completed'
GROUP BY DATE_TRUNC('day', order_date);

CREATE UNIQUE INDEX ON mv_daily_sales(sale_date);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_daily_sales;
```

### æŸ¥è¯¢ä¼˜åŒ–

1. **ä½¿ç”¨EXPLAIN (ANALYZE, BUFFERS, TIMING)**ï¼šå®šæœŸåˆ†ææŸ¥è¯¢è®¡åˆ’
2. **é¿å…å…¨è¡¨æ‰«æ**ï¼šç¡®ä¿WHEREå­å¥ä½¿ç”¨ç´¢å¼•
3. **é™åˆ¶ç»“æœé›†**ï¼šä½¿ç”¨LIMITé™åˆ¶è¿”å›è¡Œæ•°
4. **æ‰¹é‡å¤„ç†**ï¼šå¯¹å¤§é‡æ•°æ®ä½¿ç”¨æ‰¹é‡æ“ä½œ

---

## ğŸ¯ æœ€ä½³å®è·µ

### æ•°æ®è´¨é‡

1. **æ•°æ®å®Œæ•´æ€§**ï¼šç¡®ä¿å¤–é”®çº¦æŸå’Œæ•°æ®å®Œæ•´æ€§
2. **æ•°æ®å‡†ç¡®æ€§**ï¼šå®šæœŸéªŒè¯æ•°æ®å‡†ç¡®æ€§
3. **æ•°æ®ä¸€è‡´æ€§**ï¼šç¡®ä¿è·¨è¡¨æ•°æ®ä¸€è‡´æ€§
4. **æ•°æ®æ—¶æ•ˆæ€§**ï¼šåŠæ—¶æ›´æ–°æ•°æ®

### åˆ†æç­–ç•¥

1. **åˆ†å±‚åˆ†æ**ï¼šä»å®è§‚åˆ°å¾®è§‚é€æ­¥æ·±å…¥
2. **å¯¹æ¯”åˆ†æ**ï¼šä¸å†å²æ•°æ®ã€è¡Œä¸šæ ‡å‡†å¯¹æ¯”
3. **å¤šç»´åº¦åˆ†æ**ï¼šä»æ—¶é—´ã€åœ°åŸŸã€ç”¨æˆ·ã€å•†å“ç­‰å¤šç»´åº¦åˆ†æ
4. **å¼‚å¸¸æ£€æµ‹**ï¼šè¯†åˆ«å¼‚å¸¸æ•°æ®å’Œå¼‚å¸¸æ¨¡å¼

### æ€§èƒ½ä¼˜åŒ–

1. **ç´¢å¼•è®¾è®¡**ï¼šæ ¹æ®æŸ¥è¯¢æ¨¡å¼è®¾è®¡ç´¢å¼•
2. **åˆ†åŒºç­–ç•¥**ï¼šå¯¹å¤§æ•°æ®é‡è¡¨è¿›è¡Œåˆ†åŒº
3. **ç‰©åŒ–è§†å›¾**ï¼šç¼“å­˜å¸¸ç”¨æŸ¥è¯¢ç»“æœ
4. **æŸ¥è¯¢ä¼˜åŒ–**ï¼šä¼˜åŒ–SQLæŸ¥è¯¢è¯­å¥

### ç›‘æ§ä¸ç»´æŠ¤

1. **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§æŸ¥è¯¢æ€§èƒ½å’Œç³»ç»Ÿèµ„æº
2. **å®šæœŸæ›´æ–°**ï¼šå®šæœŸæ›´æ–°ç»Ÿè®¡ä¿¡æ¯å’Œç‰©åŒ–è§†å›¾
3. **æ•°æ®å½’æ¡£**ï¼šå½’æ¡£å†å²æ•°æ®
4. **å¤‡ä»½ç­–ç•¥**ï¼šå®šæœŸå¤‡ä»½é‡è¦æ•°æ®

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨DOå—è¿›è¡Œé”™è¯¯å¤„ç†
2. **NULLå€¼å¤„ç†**ï¼šä½¿ç”¨COALESCEå’ŒNULLIFå¤„ç†NULLå€¼
3. **æ•°æ®ç±»å‹è½¬æ¢**ï¼šæ³¨æ„æ•°æ®ç±»å‹è½¬æ¢å’Œç²¾åº¦
4. **æ€§èƒ½æµ‹è¯•**ï¼šä½¿ç”¨EXPLAIN (ANALYZE, BUFFERS, TIMING)æµ‹è¯•æ€§èƒ½

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡ç”µå•†æ•°æ®åˆ†æçš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«æ’åºçš„åˆ†ææŸ¥è¯¢ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-NæŸ¥è¯¢å’Œåˆ†é¡µæŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡ç”µå•†æ•°æ®çš„åˆ†æï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡åˆ†æå’Œå¤§è§„æ¨¡èšåˆæ“ä½œ

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - ç”µå•†æ•°æ®åˆ†ææ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œ
   - é€‚ç”¨äºå¤§è§„æ¨¡æ•°æ®èšåˆå’Œå¤šç»´åº¦åˆ†æ

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–Topå•†å“æŸ¥è¯¢**

```sql
-- ä¸ºå•†å“é”€å”®åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_product_sales_skip_scan
ON order_items(product_id, quantity DESC, unit_price DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾é”€é‡æœ€é«˜çš„å‰10ä¸ªå•†å“
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    p.product_id,
    p.product_name,
    SUM(oi.quantity) AS total_quantity,
    SUM(oi.quantity * oi.unit_price) AS total_revenue
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY p.product_id, p.product_name
ORDER BY total_quantity DESC
LIMIT 10;
```

### 10. å®æ—¶æ¨èç³»ç»Ÿæ¡ˆä¾‹

**å®æ—¶æ¨èç³»ç»Ÿ**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºæ•°æ®ï¼Œå®æ—¶ç”Ÿæˆä¸ªæ€§åŒ–å•†å“æ¨èã€‚

```sql
-- å®æ—¶æ¨èç³»ç»Ÿï¼šåŸºäºååŒè¿‡æ»¤çš„å•†å“æ¨èï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        -- åˆ›å»ºç”¨æˆ·æµè§ˆè¡Œä¸ºè¡¨
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_behaviors') THEN
            CREATE TABLE user_behaviors (
                behavior_id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL,
                product_id INTEGER NOT NULL,
                behavior_type VARCHAR(20) NOT NULL,  -- 'view', 'cart', 'purchase'
                behavior_time TIMESTAMP NOT NULL,
                duration_seconds INTEGER,
                FOREIGN KEY (user_id) REFERENCES users(user_id),
                FOREIGN KEY (product_id) REFERENCES products(product_id)
            );

            CREATE INDEX idx_user_behaviors_user_product ON user_behaviors(user_id, product_id);
            CREATE INDEX idx_user_behaviors_time ON user_behaviors(behavior_time DESC);

            RAISE NOTICE 'ç”¨æˆ·è¡Œä¸ºè¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå®æ—¶æ¨èç³»ç»Ÿåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®æ—¶æ¨èç³»ç»Ÿå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å®æ—¶æ¨èï¼šåŸºäºç”¨æˆ·ç›¸ä¼¼åº¦çš„å•†å“æ¨è
WITH user_product_matrix AS (
    -- æ„å»ºç”¨æˆ·-å•†å“çŸ©é˜µï¼ˆè¡Œä¸ºå¾—åˆ†ï¼‰
    SELECT
        user_id,
        product_id,
        SUM(CASE
            WHEN behavior_type = 'purchase' THEN 5
            WHEN behavior_type = 'cart' THEN 3
            WHEN behavior_type = 'view' THEN 1
            ELSE 0
        END) AS behavior_score
    FROM user_behaviors
    WHERE behavior_time > NOW() - INTERVAL '30 days'  -- æœ€è¿‘30å¤©çš„è¡Œä¸º
    GROUP BY user_id, product_id
),
user_similarity AS (
    -- è®¡ç®—ç”¨æˆ·ç›¸ä¼¼åº¦ï¼ˆä½™å¼¦ç›¸ä¼¼åº¦ç®€åŒ–ç‰ˆï¼‰
    SELECT
        u1.user_id AS user1_id,
        u2.user_id AS user2_id,
        COUNT(*) AS common_products,
        SUM(u1.behavior_score * u2.behavior_score) AS dot_product,
        SQRT(SUM(POWER(u1.behavior_score, 2))) AS norm1,
        SQRT(SUM(POWER(u2.behavior_score, 2))) AS norm2
    FROM user_product_matrix u1
    JOIN user_product_matrix u2 ON u1.product_id = u2.product_id
    WHERE u1.user_id < u2.user_id
    GROUP BY u1.user_id, u2.user_id
    HAVING COUNT(*) >= 3  -- è‡³å°‘3ä¸ªå…±åŒå•†å“
),
similar_users AS (
    -- ä¸ºæ¯ä¸ªç”¨æˆ·æ‰¾å‡ºæœ€ç›¸ä¼¼çš„ç”¨æˆ·
    SELECT
        user1_id AS user_id,
        user2_id AS similar_user_id,
        CASE
            WHEN norm1 > 0 AND norm2 > 0 THEN
                dot_product / (norm1 * norm2)
            ELSE 0
        END AS similarity_score
    FROM user_similarity
    WHERE norm1 > 0 AND norm2 > 0
),
recommendations AS (
    -- åŸºäºç›¸ä¼¼ç”¨æˆ·çš„å•†å“æ¨è
    SELECT DISTINCT
        su.user_id,
        upm.product_id,
        p.product_name,
        p.category,
        p.price,
        SUM(su.similarity_score * upm.behavior_score) AS recommendation_score
    FROM similar_users su
    JOIN user_product_matrix upm ON su.similar_user_id = upm.user_id
    JOIN products p ON upm.product_id = p.product_id
    WHERE upm.product_id NOT IN (
        -- æ’é™¤ç”¨æˆ·å·²ç»è´­ä¹°çš„å•†å“
        SELECT DISTINCT product_id
        FROM user_product_matrix
        WHERE user_id = su.user_id AND behavior_score >= 5
    )
    GROUP BY su.user_id, upm.product_id, p.product_name, p.category, p.price
)
SELECT
    user_id,
    product_id,
    product_name,
    category,
    price,
    ROUND(recommendation_score::numeric, 4) AS recommendation_score
FROM recommendations
ORDER BY user_id, recommendation_score DESC
LIMIT 100;  -- æ¯ä¸ªç”¨æˆ·æ¨èå‰100ä¸ªå•†å“
```

### 11. ä»·æ ¼å¼¹æ€§åˆ†ææ¡ˆä¾‹

**ä»·æ ¼å¼¹æ€§åˆ†æ**ï¼šåˆ†æå•†å“ä»·æ ¼å˜åŠ¨å¯¹é”€é‡çš„å½±å“ã€‚

```sql
-- ä»·æ ¼å¼¹æ€§åˆ†æï¼šåˆ†æå•†å“ä»·æ ¼å˜åŠ¨å¯¹é”€é‡çš„å½±å“ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'product_price_history') THEN
            CREATE TABLE product_price_history (
                date DATE NOT NULL,
                product_id INTEGER NOT NULL,
                price NUMERIC(10, 2) NOT NULL,
                sales_quantity INTEGER NOT NULL,
                PRIMARY KEY (date, product_id),
                FOREIGN KEY (product_id) REFERENCES products(product_id)
            );

            CREATE INDEX idx_price_history_product_date ON product_price_history(product_id, date);

            RAISE NOTICE 'å•†å“ä»·æ ¼å†å²è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œä»·æ ¼å¼¹æ€§åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä»·æ ¼å¼¹æ€§åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä»·æ ¼å¼¹æ€§åˆ†æï¼šè®¡ç®—ä»·æ ¼å˜åŠ¨å¯¹é”€é‡çš„å½±å“
WITH price_changes AS (
    SELECT
        date,
        product_id,
        price,
        sales_quantity,
        LAG(price) OVER (PARTITION BY product_id ORDER BY date) AS prev_price,
        LAG(sales_quantity) OVER (PARTITION BY product_id ORDER BY date) AS prev_quantity,
        -- ä»·æ ¼å˜åŠ¨ç‡
        CASE
            WHEN LAG(price) OVER (PARTITION BY product_id ORDER BY date) > 0 THEN
                (price - LAG(price) OVER (PARTITION BY product_id ORDER BY date)) /
                LAG(price) OVER (PARTITION BY product_id ORDER BY date)
            ELSE NULL
        END AS price_change_rate,
        -- é”€é‡å˜åŠ¨ç‡
        CASE
            WHEN LAG(sales_quantity) OVER (PARTITION BY product_id ORDER BY date) > 0 THEN
                (sales_quantity - LAG(sales_quantity) OVER (PARTITION BY product_id ORDER BY date)) /
                LAG(sales_quantity) OVER (PARTITION BY product_id ORDER BY date)
            ELSE NULL
        END AS quantity_change_rate
    FROM product_price_history
),
price_elasticity AS (
    -- è®¡ç®—ä»·æ ¼å¼¹æ€§ï¼ˆä»·æ ¼å¼¹æ€§ = é”€é‡å˜åŠ¨ç‡ / ä»·æ ¼å˜åŠ¨ç‡ï¼‰
    SELECT
        product_id,
        COUNT(*) AS observations,
        AVG(price_change_rate) AS avg_price_change,
        AVG(quantity_change_rate) AS avg_quantity_change,
        CASE
            WHEN AVG(price_change_rate) != 0 THEN
                AVG(quantity_change_rate) / AVG(price_change_rate)
            ELSE NULL
        END AS price_elasticity,
        -- ç›¸å…³æ€§åˆ†æ
        CORR(price_change_rate, quantity_change_rate) AS price_quantity_correlation
    FROM price_changes
    WHERE price_change_rate IS NOT NULL
      AND quantity_change_rate IS NOT NULL
      AND price_change_rate != 0
    GROUP BY product_id
    HAVING COUNT(*) >= 5  -- è‡³å°‘5ä¸ªè§‚å¯Ÿç‚¹
)
SELECT
    p.product_id,
    p.product_name,
    p.category,
    pe.observations,
    ROUND(pe.avg_price_change::numeric, 4) AS avg_price_change_pct,
    ROUND(pe.avg_quantity_change::numeric, 4) AS avg_quantity_change_pct,
    ROUND(pe.price_elasticity::numeric, 4) AS price_elasticity_coefficient,
    ROUND(pe.price_quantity_correlation::numeric, 4) AS correlation,
    CASE
        WHEN pe.price_elasticity < -1 THEN 'å¼¹æ€§éœ€æ±‚ï¼ˆä»·æ ¼æ•æ„Ÿï¼‰'  -- ä»·æ ¼å¼¹æ€§å°äº-1
        WHEN pe.price_elasticity BETWEEN -1 AND 0 THEN 'éå¼¹æ€§éœ€æ±‚ï¼ˆä»·æ ¼ä¸æ•æ„Ÿï¼‰'  -- ä»·æ ¼å¼¹æ€§åœ¨-1å’Œ0ä¹‹é—´
        WHEN pe.price_elasticity > 0 THEN 'å¼‚å¸¸ï¼ˆä»·æ ¼ä¸é”€é‡åŒå‘å˜åŠ¨ï¼‰'
        ELSE 'æ•°æ®ä¸è¶³'
    END AS demand_type,
    CASE
        WHEN pe.price_elasticity < -1 THEN 'å»ºè®®é™ä»·ä¿ƒé”€'  -- å¼¹æ€§éœ€æ±‚ï¼Œé™ä»·å¯ä»¥æ˜¾è‘—æå‡é”€é‡
        WHEN pe.price_elasticity BETWEEN -1 AND 0 THEN 'å¯ä»¥é€‚å½“æä»·'  -- éå¼¹æ€§éœ€æ±‚ï¼Œæä»·ä¸å½±å“é”€é‡
        ELSE 'éœ€è¦è¿›ä¸€æ­¥åˆ†æ'
    END AS pricing_strategy
FROM price_elasticity pe
JOIN products p ON pe.product_id = p.product_id
WHERE pe.price_elasticity IS NOT NULL
ORDER BY ABS(pe.price_elasticity) DESC
LIMIT 20;  -- Top 20ä»·æ ¼å¼¹æ€§æœ€å¤§çš„å•†å“
```

### 12. é«˜çº§ä¼˜åŒ–æŠ€å·§

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å¸¸ç”¨åˆ†æç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„åˆ†æç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜å¸¸ç”¨åˆ†æç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS ecommerce_analytics_cache AS
SELECT
    DATE_TRUNC('day', o.order_date) AS order_day,
    COUNT(DISTINCT o.user_id) AS daily_active_users,
    COUNT(*) AS daily_orders,
    SUM(o.total_amount) AS daily_revenue,
    AVG(o.total_amount) AS avg_order_value,
    COUNT(DISTINCT oi.product_id) AS unique_products_sold
FROM orders o
LEFT JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.status = 'completed'
GROUP BY DATE_TRUNC('day', o.order_date);

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_ecommerce_cache_day ON ecommerce_analytics_cache(order_day DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾ï¼ˆæ¯å¤©åˆ·æ–°ä¸€æ¬¡ï¼‰
REFRESH MATERIALIZED VIEW CONCURRENTLY ecommerce_analytics_cache;
```

**2. ä½¿ç”¨éƒ¨åˆ†ç´¢å¼•ä¼˜åŒ–ç‰¹å®šåˆ†æåœºæ™¯**

ä¸ºç‰¹å®šåˆ†æåœºæ™¯åˆ›å»ºéƒ¨åˆ†ç´¢å¼•ï¼š

```sql
-- ä¸ºå·²å®Œæˆè®¢å•åˆ›å»ºéƒ¨åˆ†ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_completed_orders_date
ON orders(order_date DESC)
WHERE status = 'completed';

-- ä¸ºæ´»è·ƒç”¨æˆ·åˆ›å»ºéƒ¨åˆ†ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_active_users_orders
ON orders(user_id, order_date DESC)
WHERE order_date > NOW() - INTERVAL '90 days';
```

---

## ğŸ“ˆ åˆ†ææ–¹æ³•å¯¹æ¯”

| åˆ†ææ–¹æ³• | é€‚ç”¨åœºæ™¯ | ä¼˜åŠ¿ | å±€é™æ€§ |
|---------|---------|------|--------|
| æè¿°æ€§åˆ†æ | ç°çŠ¶äº†è§£ã€è¶‹åŠ¿åˆ†æ | ç®€å•ç›´è§‚ã€æ˜“äºç†è§£ | æ— æ³•é¢„æµ‹æœªæ¥ |
| è¯Šæ–­æ€§åˆ†æ | é—®é¢˜å®šä½ã€åŸå› åˆ†æ | æ·±å…¥æŒ–æ˜ã€å‘ç°è§„å¾‹ | éœ€è¦å¤§é‡æ•°æ® |
| é¢„æµ‹æ€§åˆ†æ | è¶‹åŠ¿é¢„æµ‹ã€éœ€æ±‚é¢„æµ‹ | æå‰é¢„è­¦ã€æ”¯æŒå†³ç­– | å‡†ç¡®æ€§æœ‰é™ |
| è§„èŒƒæ€§åˆ†æ | ä¼˜åŒ–å»ºè®®ã€ç­–ç•¥æ¨è | æä¾›è¡ŒåŠ¨æ–¹æ¡ˆ | éœ€è¦é¢†åŸŸçŸ¥è¯† |

---

## ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šæŸ¥è¯¢æ€§èƒ½æ…¢

**åŸå› **ï¼š

- ç¼ºå°‘ç´¢å¼•
- å…¨è¡¨æ‰«æ
- å¤æ‚JOINæ“ä½œ

**è§£å†³æ–¹æ¡ˆ**ï¼š

- åˆ›å»ºåˆé€‚çš„ç´¢å¼•
- ä¼˜åŒ–WHEREå­å¥
- ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ

### é—®é¢˜2ï¼šæ•°æ®ä¸ä¸€è‡´

**åŸå› **ï¼š

- ç¼ºå°‘å¤–é”®çº¦æŸ
- æ•°æ®æ›´æ–°ä¸åŒæ­¥
- æ•°æ®è´¨é‡é—®é¢˜

**è§£å†³æ–¹æ¡ˆ**ï¼š

- æ·»åŠ å¤–é”®çº¦æŸ
- ä½¿ç”¨äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
- å®šæœŸæ•°æ®è´¨é‡æ£€æŸ¥

### é—®é¢˜3ï¼šåˆ†æç»“æœä¸å‡†ç¡®

**åŸå› **ï¼š

- æ•°æ®ç¼ºå¤±
- è®¡ç®—é”™è¯¯
- ç†è§£åå·®

**è§£å†³æ–¹æ¡ˆ**ï¼š

- æ•°æ®æ¸…æ´—å’ŒéªŒè¯
- ä»”ç»†æ£€æŸ¥è®¡ç®—å…¬å¼
- ä¸ä¸šåŠ¡äººå‘˜ç¡®è®¤

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
