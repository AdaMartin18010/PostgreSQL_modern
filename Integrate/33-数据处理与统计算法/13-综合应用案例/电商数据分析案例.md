# PostgreSQL ç”µå•†æ•°æ®åˆ†æç»¼åˆæ¡ˆä¾‹

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | ç”µå•†åˆ†æ | ç»¼åˆåº”ç”¨
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL ç”µå•†æ•°æ®åˆ†æç»¼åˆæ¡ˆä¾‹](#postgresql-ç”µå•†æ•°æ®åˆ†æç»¼åˆæ¡ˆä¾‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¡ˆä¾‹æ¦‚è¿°](#æ¡ˆä¾‹æ¦‚è¿°)
  - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [ç”µå•†æ•°æ®åˆ†æé—®é¢˜å®šä¹‰](#ç”µå•†æ•°æ®åˆ†æé—®é¢˜å®šä¹‰)
    - [æ ¸å¿ƒåˆ†æç»´åº¦](#æ ¸å¿ƒåˆ†æç»´åº¦)
    - [åˆ†ææ–¹æ³•åˆ†ç±»](#åˆ†ææ–¹æ³•åˆ†ç±»)
    - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
  - [1. æ•°æ®å‡†å¤‡](#1-æ•°æ®å‡†å¤‡)
  - [2. é”€å”®åˆ†æ](#2-é”€å”®åˆ†æ)
  - [3. ç”¨æˆ·è¡Œä¸ºåˆ†æ](#3-ç”¨æˆ·è¡Œä¸ºåˆ†æ)
  - [4. å•†å“åˆ†æ](#4-å•†å“åˆ†æ)
  - [5. ç»¼åˆæŠ¥è¡¨](#5-ç»¼åˆæŠ¥è¡¨)
  - [6. åº“å­˜åˆ†æ](#6-åº“å­˜åˆ†æ)
  - [7. ä¿ƒé”€æ•ˆæœåˆ†æ](#7-ä¿ƒé”€æ•ˆæœåˆ†æ)
  - [8. å®¢æˆ·æµå¤±åˆ†æ](#8-å®¢æˆ·æµå¤±åˆ†æ)
  - [9. å•†å“å…³è”åˆ†æ](#9-å•†å“å…³è”åˆ†æ)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [ç´¢å¼•ä¼˜åŒ–](#ç´¢å¼•ä¼˜åŒ–)
    - [åˆ†åŒºè¡¨](#åˆ†åŒºè¡¨)
    - [ç‰©åŒ–è§†å›¾](#ç‰©åŒ–è§†å›¾)
    - [æŸ¥è¯¢ä¼˜åŒ–](#æŸ¥è¯¢ä¼˜åŒ–)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)
    - [æ•°æ®è´¨é‡](#æ•°æ®è´¨é‡)
    - [åˆ†æç­–ç•¥](#åˆ†æç­–ç•¥)
    - [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
    - [ç›‘æ§ä¸ç»´æŠ¤](#ç›‘æ§ä¸ç»´æŠ¤)
    - [SQLå®ç°æ³¨æ„äº‹é¡¹](#sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“ˆ åˆ†ææ–¹æ³•å¯¹æ¯”](#-åˆ†ææ–¹æ³•å¯¹æ¯”)
  - [ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
    - [é—®é¢˜1ï¼šæŸ¥è¯¢æ€§èƒ½æ…¢](#é—®é¢˜1æŸ¥è¯¢æ€§èƒ½æ…¢)
    - [é—®é¢˜2ï¼šæ•°æ®ä¸ä¸€è‡´](#é—®é¢˜2æ•°æ®ä¸ä¸€è‡´)
    - [é—®é¢˜3ï¼šåˆ†æç»“æœä¸å‡†ç¡®](#é—®é¢˜3åˆ†æç»“æœä¸å‡†ç¡®)

---

## æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ¡ˆä¾‹ç»¼åˆè¿ç”¨å¤šç§SQLç®—æ³•å’ŒæŠ€æœ¯ï¼Œå¯¹ç”µå•†æ•°æ®è¿›è¡Œå…¨é¢åˆ†æï¼ŒåŒ…æ‹¬é”€å”®ç»Ÿè®¡ã€ç”¨æˆ·è¡Œä¸ºã€å•†å“åˆ†æç­‰ã€‚

## ç†è®ºåŸºç¡€

### ç”µå•†æ•°æ®åˆ†æé—®é¢˜å®šä¹‰

ç”µå•†æ•°æ®åˆ†ææ˜¯é€šè¿‡å¯¹ç”µå•†å¹³å°äº§ç”Ÿçš„æµ·é‡æ•°æ®è¿›è¡Œæ”¶é›†ã€å¤„ç†ã€åˆ†æå’ŒæŒ–æ˜ï¼Œä»¥å‘ç°ä¸šåŠ¡è§„å¾‹ã€ä¼˜åŒ–è¿è¥ç­–ç•¥ã€æå‡ç”¨æˆ·ä½“éªŒå’Œå¢åŠ æ”¶å…¥çš„è¿‡ç¨‹ã€‚

### æ ¸å¿ƒåˆ†æç»´åº¦

1. **é”€å”®åˆ†æ**ï¼š
   - é”€å”®é¢ç»Ÿè®¡ï¼ˆæ€»é‡ã€è¶‹åŠ¿ã€å¯¹æ¯”ï¼‰
   - è®¢å•åˆ†æï¼ˆæ•°é‡ã€é¢‘ç‡ã€ä»·å€¼ï¼‰
   - é”€å”®æ¸ é“åˆ†æ
   - é”€å”®åœ°åŸŸåˆ†æ

2. **ç”¨æˆ·åˆ†æ**ï¼š
   - ç”¨æˆ·ä»·å€¼åˆ†æï¼ˆRFMæ¨¡å‹ï¼‰
   - ç”¨æˆ·è¡Œä¸ºåˆ†æï¼ˆæµè§ˆã€è´­ä¹°ã€å¤è´­ï¼‰
   - ç”¨æˆ·ç•™å­˜åˆ†æ
   - ç”¨æˆ·åˆ†ç¾¤åˆ†æ

3. **å•†å“åˆ†æ**ï¼š
   - å•†å“é”€å”®æ’è¡Œ
   - å•†å“ç±»åˆ«åˆ†æ
   - åº“å­˜åˆ†æ
   - å•†å“å…³è”åˆ†æ

4. **è¿è¥åˆ†æ**ï¼š
   - ä¿ƒé”€æ•ˆæœåˆ†æ
   - è½¬åŒ–ç‡åˆ†æ
   - å®¢æˆ·æµå¤±åˆ†æ
   - è¿è¥æ•ˆç‡åˆ†æ

### åˆ†ææ–¹æ³•åˆ†ç±»

1. **æè¿°æ€§åˆ†æ**ï¼šç»Ÿè®¡æ±‡æ€»ã€è¶‹åŠ¿åˆ†æã€å¯¹æ¯”åˆ†æ
2. **è¯Šæ–­æ€§åˆ†æ**ï¼šåŸå› åˆ†æã€å…³è”åˆ†æã€å¼‚å¸¸æ£€æµ‹
3. **é¢„æµ‹æ€§åˆ†æ**ï¼šè¶‹åŠ¿é¢„æµ‹ã€éœ€æ±‚é¢„æµ‹ã€æµå¤±é¢„æµ‹
4. **è§„èŒƒæ€§åˆ†æ**ï¼šä¼˜åŒ–å»ºè®®ã€ç­–ç•¥æ¨èã€å†³ç­–æ”¯æŒ

### æŠ€æœ¯æ ˆ

- **èšåˆç®—æ³•**ï¼šSUMã€AVGã€COUNTã€GROUP BY
- **çª—å£å‡½æ•°**ï¼šROW_NUMBERã€RANKã€LAGã€LEAD
- **æ—¶é—´åºåˆ—åˆ†æ**ï¼šDATE_TRUNCã€æ»‘åŠ¨çª—å£ã€ç§»åŠ¨å¹³å‡
- **å…³è”åˆ†æ**ï¼šJOINã€å­æŸ¥è¯¢ã€CTE
- **ç»Ÿè®¡åˆ†æ**ï¼šç™¾åˆ†ä½æ•°ã€æ ‡å‡†å·®ã€ç›¸å…³æ€§

---

## 1. æ•°æ®å‡†å¤‡

```sql
-- åˆ›å»ºç”µå•†æ•°æ®åº“è¡¨ç»“æ„ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        -- åˆ›å»ºç”¨æˆ·è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users') THEN
            DROP TABLE users CASCADE;
        END IF;

        CREATE TABLE users (
            user_id SERIAL PRIMARY KEY,
            username VARCHAR(50) NOT NULL,
            email VARCHAR(100) UNIQUE,
            registration_date DATE NOT NULL,
            city VARCHAR(50)
        );

        -- åˆ›å»ºå•†å“è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            DROP TABLE products CASCADE;
        END IF;

        CREATE TABLE products (
            product_id SERIAL PRIMARY KEY,
            product_name VARCHAR(100) NOT NULL,
            category VARCHAR(50) NOT NULL,
            price NUMERIC(10, 2) NOT NULL,
            stock_quantity INTEGER NOT NULL
        );

        -- åˆ›å»ºè®¢å•è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            DROP TABLE orders CASCADE;
        END IF;

        CREATE TABLE orders (
            order_id SERIAL PRIMARY KEY,
            user_id INTEGER NOT NULL,
            order_date DATE NOT NULL,
            total_amount NUMERIC(10, 2) NOT NULL,
            status VARCHAR(20) NOT NULL,
            FOREIGN KEY (user_id) REFERENCES users(user_id)
        );

        -- åˆ›å»ºè®¢å•æ˜ç»†è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            DROP TABLE order_items CASCADE;
        END IF;

        CREATE TABLE order_items (
            item_id SERIAL PRIMARY KEY,
            order_id INTEGER NOT NULL,
            product_id INTEGER NOT NULL,
            quantity INTEGER NOT NULL,
            unit_price NUMERIC(10, 2) NOT NULL,
            FOREIGN KEY (order_id) REFERENCES orders(order_id),
            FOREIGN KEY (product_id) REFERENCES products(product_id)
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO users (username, email, registration_date, city) VALUES
            ('user1', 'user1@example.com', '2023-01-15', 'Beijing'),
            ('user2', 'user2@example.com', '2023-02-20', 'Shanghai'),
            ('user3', 'user3@example.com', '2023-03-10', 'Guangzhou'),
            ('user4', 'user4@example.com', '2023-04-05', 'Shenzhen'),
            ('user5', 'user5@example.com', '2023-05-12', 'Beijing');

        INSERT INTO products (product_name, category, price, stock_quantity) VALUES
            ('Laptop', 'Electronics', 5999.00, 50),
            ('Smartphone', 'Electronics', 3999.00, 100),
            ('Tablet', 'Electronics', 2999.00, 30),
            ('Headphones', 'Electronics', 299.00, 200),
            ('Keyboard', 'Electronics', 199.00, 150);

        INSERT INTO orders (user_id, order_date, total_amount, status) VALUES
            (1, '2024-01-01', 9998.00, 'completed'),
            (1, '2024-01-15', 299.00, 'completed'),
            (2, '2024-01-05', 3999.00, 'completed'),
            (2, '2024-01-20', 2999.00, 'pending'),
            (3, '2024-01-10', 5999.00, 'completed'),
            (4, '2024-01-12', 199.00, 'completed'),
            (5, '2024-01-18', 3298.00, 'completed');

        INSERT INTO order_items (order_id, product_id, quantity, unit_price) VALUES
            (1, 1, 1, 5999.00), (1, 2, 1, 3999.00),
            (2, 4, 1, 299.00),
            (3, 2, 1, 3999.00),
            (4, 3, 1, 2999.00),
            (5, 1, 1, 5999.00),
            (6, 5, 1, 199.00),
            (7, 2, 1, 3999.00), (7, 4, 1, 299.00);

        RAISE NOTICE 'ç”µå•†æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

---

## 2. é”€å”®åˆ†æ

```sql
-- é”€å”®åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œé”€å”®åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œé”€å”®åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é”€å”®åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æœˆåº¦é”€å”®ç»Ÿè®¡
SELECT
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) AS order_count,
    COUNT(DISTINCT user_id) AS unique_customers,
    SUM(total_amount) AS total_revenue,
    AVG(total_amount) AS avg_order_value,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY total_amount) AS median_order_value
FROM orders
WHERE status = 'completed'
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month;

-- é”€å”®è¶‹åŠ¿åˆ†æï¼ˆç§»åŠ¨å¹³å‡ï¼‰
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', order_date) AS month,
        SUM(total_amount) AS monthly_revenue
    FROM orders
    WHERE status = 'completed'
    GROUP BY DATE_TRUNC('month', order_date)
)
SELECT
    month,
    monthly_revenue,
    AVG(monthly_revenue) OVER (
        ORDER BY month
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3months
FROM monthly_sales
ORDER BY month;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    DATE_TRUNC('month', order_date) AS month,
    SUM(total_amount) AS total_revenue
FROM orders
WHERE status = 'completed'
GROUP BY DATE_TRUNC('month', order_date);
```

---

## 3. ç”¨æˆ·è¡Œä¸ºåˆ†æ

```sql
-- ç”¨æˆ·è¡Œä¸ºåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œç”¨æˆ·è¡Œä¸ºåˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œç”¨æˆ·è¡Œä¸ºåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç”¨æˆ·è¡Œä¸ºåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç”¨æˆ·ä»·å€¼åˆ†æï¼ˆRFMæ¨¡å‹ç®€åŒ–ç‰ˆï¼‰
WITH user_metrics AS (
    SELECT
        u.user_id,
        u.username,
        COUNT(DISTINCT o.order_id) AS frequency,
        SUM(o.total_amount) AS monetary_value,
        MAX(o.order_date) AS last_order_date,
        CURRENT_DATE - MAX(o.order_date) AS recency_days
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.username
)
SELECT
    user_id,
    username,
    frequency,
    ROUND(monetary_value::numeric, 2) AS monetary_value,
    recency_days,
    CASE
        WHEN recency_days <= 30 THEN 'Active'
        WHEN recency_days <= 90 THEN 'At Risk'
        ELSE 'Inactive'
    END AS customer_segment
FROM user_metrics
ORDER BY monetary_value DESC NULLS LAST;

-- ç”¨æˆ·è´­ä¹°è¡Œä¸ºåˆ†æ
WITH user_purchase_patterns AS (
    SELECT
        u.user_id,
        u.username,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent,
        AVG(o.total_amount) AS avg_order_value,
        COUNT(DISTINCT oi.product_id) AS unique_products_purchased,
        COUNT(oi.item_id) AS total_items_purchased
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY u.user_id, u.username
)
SELECT
    user_id,
    username,
    total_orders,
    ROUND(total_spent::numeric, 2) AS total_spent,
    ROUND(avg_order_value::numeric, 2) AS avg_order_value,
    unique_products_purchased,
    total_items_purchased,
    ROUND((total_spent / NULLIF(total_orders, 0))::numeric, 2) AS value_per_order
FROM user_purchase_patterns
ORDER BY total_spent DESC NULLS LAST;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    u.user_id,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(o.total_amount) AS total_spent
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
GROUP BY u.user_id;
```

---

## 4. å•†å“åˆ†æ

```sql
-- å•†å“åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING 'è¡¨ order_items ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå•†å“åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå•†å“åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å•†å“åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å•†å“é”€å”®æ’è¡Œ
SELECT
    p.product_id,
    p.product_name,
    p.category,
    COUNT(DISTINCT oi.order_id) AS order_count,
    SUM(oi.quantity) AS total_quantity_sold,
    SUM(oi.quantity * oi.unit_price) AS total_revenue,
    AVG(oi.unit_price) AS avg_price,
    RANK() OVER (ORDER BY SUM(oi.quantity * oi.unit_price) DESC) AS revenue_rank
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
GROUP BY p.product_id, p.product_name, p.category
ORDER BY total_revenue DESC NULLS LAST;

-- ç±»åˆ«é”€å”®åˆ†æ
SELECT
    p.category,
    COUNT(DISTINCT p.product_id) AS product_count,
    COUNT(DISTINCT oi.order_id) AS order_count,
    SUM(oi.quantity) AS total_quantity_sold,
    SUM(oi.quantity * oi.unit_price) AS category_revenue,
    AVG(oi.unit_price) AS avg_category_price,
    ROUND((SUM(oi.quantity * oi.unit_price) / NULLIF(SUM(SUM(oi.quantity * oi.unit_price)) OVER (), 0) * 100)::numeric, 2) AS revenue_percentage
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
GROUP BY p.category
ORDER BY category_revenue DESC NULLS LAST;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    p.category,
    SUM(oi.quantity * oi.unit_price) AS category_revenue
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY p.category;
```

---

## 5. ç»¼åˆæŠ¥è¡¨

```sql
-- ç»¼åˆæŠ¥è¡¨ç”Ÿæˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•ç”Ÿæˆç»¼åˆæŠ¥è¡¨';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹ç”Ÿæˆç»¼åˆæŠ¥è¡¨';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç»¼åˆæŠ¥è¡¨ç”Ÿæˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç”µå•†æ•°æ®ç»¼åˆæŠ¥è¡¨
WITH sales_summary AS (
    SELECT
        COUNT(DISTINCT o.order_id) AS total_orders,
        COUNT(DISTINCT o.user_id) AS total_customers,
        SUM(o.total_amount) AS total_revenue,
        AVG(o.total_amount) AS avg_order_value
    FROM orders o
    WHERE o.status = 'completed'
),
product_summary AS (
    SELECT
        COUNT(DISTINCT p.product_id) AS total_products,
        COUNT(DISTINCT p.category) AS total_categories,
        SUM(oi.quantity) AS total_items_sold
    FROM products p
    LEFT JOIN order_items oi ON p.product_id = oi.product_id
    LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
),
user_summary AS (
    SELECT
        COUNT(*) AS total_users,
        COUNT(*) FILTER (WHERE EXISTS (
            SELECT 1 FROM orders WHERE user_id = users.user_id AND status = 'completed'
        )) AS active_users
    FROM users
)
SELECT
    'Sales Metrics' AS metric_category,
    ss.total_orders AS metric_value,
    'Total Orders' AS metric_name
FROM sales_summary ss
UNION ALL
SELECT
    'Sales Metrics',
    ss.total_customers,
    'Total Customers'
FROM sales_summary ss
UNION ALL
SELECT
    'Sales Metrics',
    ROUND(ss.total_revenue::numeric, 2),
    'Total Revenue'
FROM sales_summary ss
UNION ALL
SELECT
    'Product Metrics',
    ps.total_products,
    'Total Products'
FROM product_summary ps
UNION ALL
SELECT
    'Product Metrics',
    ps.total_items_sold,
    'Total Items Sold'
FROM product_summary ps
UNION ALL
SELECT
    'User Metrics',
    us.total_users,
    'Total Users'
FROM user_summary us
UNION ALL
SELECT
    'User Metrics',
    us.active_users,
    'Active Users'
FROM user_summary us
ORDER BY metric_category, metric_name;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(DISTINCT order_id) AS total_orders,
    SUM(total_amount) AS total_revenue
FROM orders
WHERE status = 'completed';
```

---

## 6. åº“å­˜åˆ†æ

```sql
-- åº“å­˜åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING 'è¡¨ products ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œåº“å­˜åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œåº“å­˜åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åº“å­˜åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åº“å­˜å‘¨è½¬ç‡åˆ†æ
WITH product_sales AS (
    SELECT
        p.product_id,
        p.product_name,
        p.category,
        p.stock_quantity,
        COALESCE(SUM(oi.quantity), 0) AS total_sold,
        COALESCE(COUNT(DISTINCT o.order_id), 0) AS order_count
    FROM products p
    LEFT JOIN order_items oi ON p.product_id = oi.product_id
    LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
    GROUP BY p.product_id, p.product_name, p.category, p.stock_quantity
)
SELECT
    product_id,
    product_name,
    category,
    stock_quantity,
    total_sold,
    order_count,
    CASE
        WHEN stock_quantity = 0 THEN 'Out of Stock'
        WHEN stock_quantity < 10 THEN 'Low Stock'
        WHEN stock_quantity < 50 THEN 'Normal Stock'
        ELSE 'High Stock'
    END AS stock_status,
    CASE
        WHEN total_sold > 0 THEN ROUND((total_sold::numeric / NULLIF(stock_quantity + total_sold, 0) * 100)::numeric, 2)
        ELSE 0
    END AS turnover_rate
FROM product_sales
ORDER BY turnover_rate DESC NULLS LAST;

-- åº“å­˜é¢„è­¦åˆ†æ
SELECT
    p.product_id,
    p.product_name,
    p.category,
    p.stock_quantity,
    COALESCE(SUM(oi.quantity), 0) AS total_sold,
    CASE
        WHEN p.stock_quantity = 0 THEN 'Critical: Out of Stock'
        WHEN p.stock_quantity < 10 AND COALESCE(SUM(oi.quantity), 0) > 0 THEN 'Warning: Low Stock'
        WHEN p.stock_quantity >= 100 AND COALESCE(SUM(oi.quantity), 0) = 0 THEN 'Info: Overstocked'
        ELSE 'Normal'
    END AS alert_level
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id AND o.status = 'completed'
GROUP BY p.product_id, p.product_name, p.category, p.stock_quantity
HAVING p.stock_quantity = 0 OR (p.stock_quantity < 10 AND COALESCE(SUM(oi.quantity), 0) > 0) OR (p.stock_quantity >= 100 AND COALESCE(SUM(oi.quantity), 0) = 0)
ORDER BY
    CASE alert_level
        WHEN 'Critical: Out of Stock' THEN 1
        WHEN 'Warning: Low Stock' THEN 2
        WHEN 'Info: Overstocked' THEN 3
        ELSE 4
    END,
    total_sold DESC;
```

---

## 7. ä¿ƒé”€æ•ˆæœåˆ†æ

```sql
-- ä¿ƒé”€æ•ˆæœåˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        -- æ·»åŠ ä¿ƒé”€å­—æ®µï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = 'public'
            AND table_name = 'orders'
            AND column_name = 'promotion_id'
        ) THEN
            ALTER TABLE orders ADD COLUMN promotion_id INTEGER;
            ALTER TABLE orders ADD COLUMN discount_amount NUMERIC(10, 2) DEFAULT 0;
            RAISE NOTICE 'å·²æ·»åŠ ä¿ƒé”€å­—æ®µ';
        END IF;

        -- æ›´æ–°ç¤ºä¾‹æ•°æ®
        UPDATE orders SET promotion_id = 1, discount_amount = 100.00 WHERE order_id IN (1, 3);
        UPDATE orders SET promotion_id = 2, discount_amount = 50.00 WHERE order_id IN (2, 5);

        RAISE NOTICE 'å¼€å§‹è¿›è¡Œä¿ƒé”€æ•ˆæœåˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¿ƒé”€æ•ˆæœåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä¿ƒé”€æ´»åŠ¨æ•ˆæœåˆ†æ
SELECT
    promotion_id,
    COUNT(DISTINCT order_id) AS order_count,
    COUNT(DISTINCT user_id) AS unique_customers,
    SUM(total_amount) AS total_revenue,
    SUM(discount_amount) AS total_discount,
    SUM(total_amount + discount_amount) AS gross_revenue,
    AVG(total_amount) AS avg_order_value,
    SUM(total_amount) / NULLIF(COUNT(DISTINCT user_id), 0) AS revenue_per_customer
FROM orders
WHERE status = 'completed' AND promotion_id IS NOT NULL
GROUP BY promotion_id
ORDER BY total_revenue DESC;

-- ä¿ƒé”€ROIåˆ†æ
WITH promotion_stats AS (
    SELECT
        promotion_id,
        COUNT(DISTINCT order_id) AS order_count,
        SUM(total_amount) AS net_revenue,
        SUM(discount_amount) AS total_discount,
        SUM(total_amount + discount_amount) AS gross_revenue
    FROM orders
    WHERE status = 'completed' AND promotion_id IS NOT NULL
    GROUP BY promotion_id
)
SELECT
    promotion_id,
    order_count,
    ROUND(net_revenue::numeric, 2) AS net_revenue,
    ROUND(total_discount::numeric, 2) AS total_discount,
    ROUND(gross_revenue::numeric, 2) AS gross_revenue,
    CASE
        WHEN total_discount > 0 THEN ROUND((net_revenue / total_discount)::numeric, 2)
        ELSE NULL
    END AS roi_ratio,
    CASE
        WHEN total_discount > 0 AND net_revenue > total_discount THEN 'Profitable'
        WHEN total_discount > 0 AND net_revenue <= total_discount THEN 'Loss'
        ELSE 'Neutral'
    END AS profitability
FROM promotion_stats
ORDER BY roi_ratio DESC NULLS LAST;
```

---

## 8. å®¢æˆ·æµå¤±åˆ†æ

```sql
-- å®¢æˆ·æµå¤±åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå®¢æˆ·æµå¤±åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå®¢æˆ·æµå¤±åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å®¢æˆ·æµå¤±åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å®¢æˆ·æµå¤±è¯†åˆ«
WITH user_last_order AS (
    SELECT
        u.user_id,
        u.username,
        u.registration_date,
        MAX(o.order_date) AS last_order_date,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent,
        CURRENT_DATE - MAX(o.order_date) AS days_since_last_order
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.username, u.registration_date
)
SELECT
    user_id,
    username,
    registration_date,
    last_order_date,
    total_orders,
    ROUND(total_spent::numeric, 2) AS total_spent,
    days_since_last_order,
    CASE
        WHEN days_since_last_order IS NULL THEN 'Never Purchased'
        WHEN days_since_last_order <= 30 THEN 'Active'
        WHEN days_since_last_order <= 60 THEN 'At Risk'
        WHEN days_since_last_order <= 90 THEN 'Churning'
        ELSE 'Churned'
    END AS churn_status,
    CASE
        WHEN days_since_last_order IS NULL THEN 0
        WHEN days_since_last_order <= 30 THEN 1
        WHEN days_since_last_order <= 60 THEN 2
        WHEN days_since_last_order <= 90 THEN 3
        ELSE 4
    END AS churn_score
FROM user_last_order
ORDER BY days_since_last_order DESC NULLS LAST;

-- æµå¤±å®¢æˆ·ç‰¹å¾åˆ†æ
WITH user_churn AS (
    SELECT
        u.user_id,
        u.city,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(o.total_amount) AS total_spent,
        MAX(o.order_date) AS last_order_date,
        CURRENT_DATE - MAX(o.order_date) AS days_since_last_order,
        CASE
            WHEN CURRENT_DATE - MAX(o.order_date) > 90 THEN 'Churned'
            ELSE 'Active'
        END AS churn_status
    FROM users u
    LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed'
    GROUP BY u.user_id, u.city
)
SELECT
    churn_status,
    COUNT(*) AS customer_count,
    ROUND(AVG(total_orders)::numeric, 2) AS avg_orders,
    ROUND(AVG(total_spent)::numeric, 2) AS avg_spent,
    ROUND(AVG(days_since_last_order)::numeric, 0) AS avg_days_since_last_order
FROM user_churn
GROUP BY churn_status
ORDER BY churn_status;
```

---

## 9. å•†å“å…³è”åˆ†æ

```sql
-- å•†å“å…³è”åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING 'è¡¨ order_items ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå•†å“å…³è”åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå•†å“å…³è”åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å•†å“å…³è”åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å•†å“å…±ç°åˆ†æï¼ˆä¸€èµ·è´­ä¹°çš„å•†å“å¯¹ï¼‰
WITH product_pairs AS (
    SELECT DISTINCT
        oi1.product_id AS product1_id,
        p1.product_name AS product1_name,
        oi2.product_id AS product2_id,
        p2.product_name AS product2_name,
        oi1.order_id
    FROM order_items oi1
    INNER JOIN order_items oi2 ON oi1.order_id = oi2.order_id
    INNER JOIN products p1 ON oi1.product_id = p1.product_id
    INNER JOIN products p2 ON oi2.product_id = p2.product_id
    WHERE oi1.product_id < oi2.product_id
)
SELECT
    product1_id,
    product1_name,
    product2_id,
    product2_name,
    COUNT(DISTINCT order_id) AS co_occurrence_count,
    ROUND((COUNT(DISTINCT order_id)::numeric / NULLIF((
        SELECT COUNT(DISTINCT order_id) FROM order_items WHERE product_id = product1_id
    ), 0) * 100)::numeric, 2) AS support_percentage
FROM product_pairs
GROUP BY product1_id, product1_name, product2_id, product2_name
HAVING COUNT(DISTINCT order_id) > 0
ORDER BY co_occurrence_count DESC;

-- å•†å“æ¨èï¼ˆåŸºäºå…³è”è§„åˆ™ï¼‰
WITH product_frequency AS (
    SELECT
        product_id,
        COUNT(DISTINCT order_id) AS order_count
    FROM order_items
    GROUP BY product_id
),
product_pairs AS (
    SELECT DISTINCT
        oi1.product_id AS product1_id,
        oi2.product_id AS product2_id,
        COUNT(DISTINCT oi1.order_id) AS pair_count
    FROM order_items oi1
    INNER JOIN order_items oi2 ON oi1.order_id = oi2.order_id
    WHERE oi1.product_id <> oi2.product_id
    GROUP BY oi1.product_id, oi2.product_id
)
SELECT
    pp.product1_id,
    p1.product_name AS product1_name,
    pp.product2_id,
    p2.product_name AS product2_name,
    pp.pair_count,
    pf1.order_count AS product1_total_orders,
    pf2.order_count AS product2_total_orders,
    ROUND((pp.pair_count::numeric / NULLIF(pf1.order_count, 0) * 100)::numeric, 2) AS confidence_percentage
FROM product_pairs pp
INNER JOIN products p1 ON pp.product1_id = p1.product_id
INNER JOIN products p2 ON pp.product2_id = p2.product_id
INNER JOIN product_frequency pf1 ON pp.product1_id = pf1.product_id
INNER JOIN product_frequency pf2 ON pp.product2_id = pf2.product_id
WHERE pp.pair_count >= 1
ORDER BY confidence_percentage DESC, pp.pair_count DESC;
```

---

## ğŸ“Š PostgreSQL 18å¹¶è¡Œç”µå•†æ•°æ®åˆ†æ

### å¹¶è¡Œç”µå•†æ•°æ®åˆ†ææ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œç”µå•†æ•°æ®åˆ†æ**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡ç”µå•†æ•°æ®åˆ†æçš„æ€§èƒ½ã€‚

#### å¹¶è¡Œç”µå•†æ•°æ®åˆ†æé…ç½®

```sql
-- é…ç½®å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œç”µå•†æ•°æ®åˆ†æé…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå®ç°

```sql
-- å¹¶è¡Œé”€å”®åˆ†æï¼šå¤§è§„æ¨¡é”€å”®æ•°æ®ç»Ÿè®¡ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œç”µå•†æ•°æ®åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œç”µå•†æ•°æ®åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œå¤šç»´åº¦é”€å”®åˆ†æ
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    DATE_TRUNC('month', order_date) AS month,
    region,
    category,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    COUNT(DISTINCT customer_id) AS unique_customers
FROM orders
WHERE order_date >= CURRENT_DATE - INTERVAL '1 year'
GROUP BY DATE_TRUNC('month', order_date), region, category
ORDER BY month DESC, total_amount DESC;
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå…³é”®ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_orders_date ON orders(order_date);
CREATE INDEX IF NOT EXISTS idx_orders_user ON orders(user_id);
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_order_items_order ON order_items(order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_product ON order_items(product_id);
CREATE INDEX IF NOT EXISTS idx_products_category ON products(category);
```

### åˆ†åŒºè¡¨

```sql
-- æŒ‰æ—¶é—´åˆ†åŒºè®¢å•è¡¨ï¼ˆPostgreSQL 10+ï¼‰
CREATE TABLE orders_partitioned (
    LIKE orders INCLUDING ALL
) PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024_q1 PARTITION OF orders_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');
CREATE TABLE orders_2024_q2 PARTITION OF orders_partitioned
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');
```

### ç‰©åŒ–è§†å›¾

```sql
-- åˆ›å»ºå¸¸ç”¨æŠ¥è¡¨çš„ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_daily_sales AS
SELECT
    DATE_TRUNC('day', order_date) AS sale_date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_revenue,
    COUNT(DISTINCT user_id) AS unique_customers
FROM orders
WHERE status = 'completed'
GROUP BY DATE_TRUNC('day', order_date);

CREATE UNIQUE INDEX ON mv_daily_sales(sale_date);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_daily_sales;
```

### æŸ¥è¯¢ä¼˜åŒ–

1. **ä½¿ç”¨EXPLAIN (ANALYZE, BUFFERS, TIMING)**ï¼šå®šæœŸåˆ†ææŸ¥è¯¢è®¡åˆ’
2. **é¿å…å…¨è¡¨æ‰«æ**ï¼šç¡®ä¿WHEREå­å¥ä½¿ç”¨ç´¢å¼•
3. **é™åˆ¶ç»“æœé›†**ï¼šä½¿ç”¨LIMITé™åˆ¶è¿”å›è¡Œæ•°
4. **æ‰¹é‡å¤„ç†**ï¼šå¯¹å¤§é‡æ•°æ®ä½¿ç”¨æ‰¹é‡æ“ä½œ

---

## ğŸ¯ æœ€ä½³å®è·µ

### æ•°æ®è´¨é‡

1. **æ•°æ®å®Œæ•´æ€§**ï¼šç¡®ä¿å¤–é”®çº¦æŸå’Œæ•°æ®å®Œæ•´æ€§
2. **æ•°æ®å‡†ç¡®æ€§**ï¼šå®šæœŸéªŒè¯æ•°æ®å‡†ç¡®æ€§
3. **æ•°æ®ä¸€è‡´æ€§**ï¼šç¡®ä¿è·¨è¡¨æ•°æ®ä¸€è‡´æ€§
4. **æ•°æ®æ—¶æ•ˆæ€§**ï¼šåŠæ—¶æ›´æ–°æ•°æ®

### åˆ†æç­–ç•¥

1. **åˆ†å±‚åˆ†æ**ï¼šä»å®è§‚åˆ°å¾®è§‚é€æ­¥æ·±å…¥
2. **å¯¹æ¯”åˆ†æ**ï¼šä¸å†å²æ•°æ®ã€è¡Œä¸šæ ‡å‡†å¯¹æ¯”
3. **å¤šç»´åº¦åˆ†æ**ï¼šä»æ—¶é—´ã€åœ°åŸŸã€ç”¨æˆ·ã€å•†å“ç­‰å¤šç»´åº¦åˆ†æ
4. **å¼‚å¸¸æ£€æµ‹**ï¼šè¯†åˆ«å¼‚å¸¸æ•°æ®å’Œå¼‚å¸¸æ¨¡å¼

### æ€§èƒ½ä¼˜åŒ–

1. **ç´¢å¼•è®¾è®¡**ï¼šæ ¹æ®æŸ¥è¯¢æ¨¡å¼è®¾è®¡ç´¢å¼•
2. **åˆ†åŒºç­–ç•¥**ï¼šå¯¹å¤§æ•°æ®é‡è¡¨è¿›è¡Œåˆ†åŒº
3. **ç‰©åŒ–è§†å›¾**ï¼šç¼“å­˜å¸¸ç”¨æŸ¥è¯¢ç»“æœ
4. **æŸ¥è¯¢ä¼˜åŒ–**ï¼šä¼˜åŒ–SQLæŸ¥è¯¢è¯­å¥

### ç›‘æ§ä¸ç»´æŠ¤

1. **æ€§èƒ½ç›‘æ§**ï¼šç›‘æ§æŸ¥è¯¢æ€§èƒ½å’Œç³»ç»Ÿèµ„æº
2. **å®šæœŸæ›´æ–°**ï¼šå®šæœŸæ›´æ–°ç»Ÿè®¡ä¿¡æ¯å’Œç‰©åŒ–è§†å›¾
3. **æ•°æ®å½’æ¡£**ï¼šå½’æ¡£å†å²æ•°æ®
4. **å¤‡ä»½ç­–ç•¥**ï¼šå®šæœŸå¤‡ä»½é‡è¦æ•°æ®

### SQLå®ç°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨DOå—è¿›è¡Œé”™è¯¯å¤„ç†
2. **NULLå€¼å¤„ç†**ï¼šä½¿ç”¨COALESCEå’ŒNULLIFå¤„ç†NULLå€¼
3. **æ•°æ®ç±»å‹è½¬æ¢**ï¼šæ³¨æ„æ•°æ®ç±»å‹è½¬æ¢å’Œç²¾åº¦
4. **æ€§èƒ½æµ‹è¯•**ï¼šä½¿ç”¨EXPLAIN (ANALYZE, BUFFERS, TIMING)æµ‹è¯•æ€§èƒ½

---

## ğŸ“ˆ åˆ†ææ–¹æ³•å¯¹æ¯”

| åˆ†ææ–¹æ³• | é€‚ç”¨åœºæ™¯ | ä¼˜åŠ¿ | å±€é™æ€§ |
|---------|---------|------|--------|
| æè¿°æ€§åˆ†æ | ç°çŠ¶äº†è§£ã€è¶‹åŠ¿åˆ†æ | ç®€å•ç›´è§‚ã€æ˜“äºç†è§£ | æ— æ³•é¢„æµ‹æœªæ¥ |
| è¯Šæ–­æ€§åˆ†æ | é—®é¢˜å®šä½ã€åŸå› åˆ†æ | æ·±å…¥æŒ–æ˜ã€å‘ç°è§„å¾‹ | éœ€è¦å¤§é‡æ•°æ® |
| é¢„æµ‹æ€§åˆ†æ | è¶‹åŠ¿é¢„æµ‹ã€éœ€æ±‚é¢„æµ‹ | æå‰é¢„è­¦ã€æ”¯æŒå†³ç­– | å‡†ç¡®æ€§æœ‰é™ |
| è§„èŒƒæ€§åˆ†æ | ä¼˜åŒ–å»ºè®®ã€ç­–ç•¥æ¨è | æä¾›è¡ŒåŠ¨æ–¹æ¡ˆ | éœ€è¦é¢†åŸŸçŸ¥è¯† |

---

## ğŸ” å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šæŸ¥è¯¢æ€§èƒ½æ…¢

**åŸå› **ï¼š

- ç¼ºå°‘ç´¢å¼•
- å…¨è¡¨æ‰«æ
- å¤æ‚JOINæ“ä½œ

**è§£å†³æ–¹æ¡ˆ**ï¼š

- åˆ›å»ºåˆé€‚çš„ç´¢å¼•
- ä¼˜åŒ–WHEREå­å¥
- ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ

### é—®é¢˜2ï¼šæ•°æ®ä¸ä¸€è‡´

**åŸå› **ï¼š

- ç¼ºå°‘å¤–é”®çº¦æŸ
- æ•°æ®æ›´æ–°ä¸åŒæ­¥
- æ•°æ®è´¨é‡é—®é¢˜

**è§£å†³æ–¹æ¡ˆ**ï¼š

- æ·»åŠ å¤–é”®çº¦æŸ
- ä½¿ç”¨äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
- å®šæœŸæ•°æ®è´¨é‡æ£€æŸ¥

### é—®é¢˜3ï¼šåˆ†æç»“æœä¸å‡†ç¡®

**åŸå› **ï¼š

- æ•°æ®ç¼ºå¤±
- è®¡ç®—é”™è¯¯
- ç†è§£åå·®

**è§£å†³æ–¹æ¡ˆ**ï¼š

- æ•°æ®æ¸…æ´—å’ŒéªŒè¯
- ä»”ç»†æ£€æŸ¥è®¡ç®—å…¬å¼
- ä¸ä¸šåŠ¡äººå‘˜ç¡®è®¤

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
