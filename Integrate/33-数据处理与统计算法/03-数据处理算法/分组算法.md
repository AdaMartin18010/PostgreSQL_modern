# PostgreSQL 分组算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 分组算法 | 多维分析
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 分组算法完整指南](#postgresql-分组算法完整指南)
  - [📋 目录](#-目录)
  - [分组算法概述](#分组算法概述)
    - [理论基础](#理论基础)
      - [分组问题定义](#分组问题定义)
      - [分组算法分类](#分组算法分类)
      - [分组算法复杂度](#分组算法复杂度)
    - [核心分组功能](#核心分组功能)
  - [1. GROUP BY分组](#1-group-by分组)
    - [1.1 GROUP BY分组原理](#11-group-by分组原理)
      - [分组过程](#分组过程)
      - [分组策略](#分组策略)
      - [分组键选择](#分组键选择)
    - [1.2 单列分组实现](#12-单列分组实现)
    - [1.3 多列分组实现](#13-多列分组实现)
    - [1.4 HAVING子句过滤](#14-having子句过滤)
    - [1.5 分组性能优化](#15-分组性能优化)
    - [1.6 PostgreSQL 18 并行分组增强](#16-postgresql-18-并行分组增强)
      - [并行分组原理](#并行分组原理)
      - [并行分组实现](#并行分组实现)
      - [并行多列分组](#并行多列分组)
  - [2. GROUPING SETS](#2-grouping-sets)
    - [2.1 GROUPING SETS原理](#21-grouping-sets原理)
      - [GROUPING SETS语法](#grouping-sets语法)
      - [GROUPING函数](#grouping函数)
    - [2.2 GROUPING SETS实现](#22-grouping-sets实现)
    - [2.3 GROUPING函数使用](#23-grouping函数使用)
    - [2.4 PostgreSQL 18 并行 GROUPING SETS](#24-postgresql-18-并行-grouping-sets)
  - [3. ROLLUP分组](#3-rollup分组)
    - [3.1 ROLLUP分组原理](#31-rollup分组原理)
      - [ROLLUP语法](#rollup语法)
      - [ROLLUP层次结构](#rollup层次结构)
    - [3.2 ROLLUP层次汇总实现](#32-rollup层次汇总实现)
    - [3.3 多级ROLLUP](#33-多级rollup)
    - [3.4 PostgreSQL 18 并行 ROLLUP](#34-postgresql-18-并行-rollup)
  - [4. CUBE分组](#4-cube分组)
    - [4.1 CUBE分组原理](#41-cube分组原理)
      - [CUBE语法](#cube语法)
      - [CUBE组合数量](#cube组合数量)
      - [CUBE vs ROLLUP](#cube-vs-rollup)
    - [4.2 CUBE全维度组合实现](#42-cube全维度组合实现)
    - [4.3 部分CUBE](#43-部分cube)
    - [4.4 PostgreSQL 18 并行 CUBE](#44-postgresql-18-并行-cube)
  - [5. 高级分组技术](#5-高级分组技术)
    - [5.1 分组与窗口函数结合](#51-分组与窗口函数结合)
    - [5.2 分组与CTE结合](#52-分组与cte结合)
    - [5.3 分组与JSON聚合](#53-分组与json聚合)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 多维度报表](#61-多维度报表)
    - [6.2 销售数据多维分析](#62-销售数据多维分析)
    - [6.3 用户行为分组分析](#63-用户行为分组分析)
    - [6.4 产品分组分析](#64-产品分组分析)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 分组方法对比](#71-分组方法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 分组策略选择](#81-分组策略选择)
    - [8.2 分组注意事项](#82-分组注意事项)
    - [8.3 SQL实现注意事项](#83-sql实现注意事项)
    - [8.4 PostgreSQL 18 新特性应用（增强）](#84-postgresql-18-新特性应用增强)
    - [8.5 高级优化技巧（增强）](#85-高级优化技巧增强)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 分组算法概述

**分组算法（Grouping Algorithm）**用于将数据按照指定列进行分组，是数据分析和聚合的基础操作。PostgreSQL支持多种分组方式，从简单的单列分组到复杂的多维分组。

### 理论基础

#### 分组问题定义

**分组问题**是将数据集$D = \{d_1, d_2, \ldots, d_n\}$按照分组键$K = \{k_1, k_2, \ldots, k_m\}$划分为多个子集：
$$G = \{G_1, G_2, \ldots, G_k\} \text{ where } G_i = \{d_j : K(d_j) = k_i\}$$

其中$K(d_j)$是记录$d_j$的分组键值。

#### 分组算法分类

1. **单列分组**：按照单个列分组
2. **多列分组**：按照多个列组合分组
3. **多维分组**：使用GROUPING SETS指定多个分组组合
4. **层次分组**：使用ROLLUP进行层次汇总
5. **全维度分组**：使用CUBE生成所有组合

#### 分组算法复杂度

- **排序分组**：$O(n \log n)$（使用排序）
- **哈希分组**：$O(n)$（使用哈希表）
- **混合分组**：根据数据分布选择策略

### 核心分组功能

| 功能              | 用途         | 时间复杂度            | 空间复杂度        | 适用场景     |
| ----------------- | ------------ | --------------------- | ----------------- | ------------ |
| **GROUP BY**      | 单维度分组    | $O(n \log n)$         | $O(n)$            | 简单分组     |
| **GROUPING SETS** | 多维度组合    | $O(n \log n)$         | $O(n)$            | 多维分析     |
| **ROLLUP**        | 层次汇总      | $O(n \log n)$         | $O(n)$            | 层次报表     |
| **CUBE**          | 全维度组合    | $O(2^m \cdot n \log n)$ | $O(2^m \cdot n)$ | 全维度分析   |

其中$m$是分组列的个数。

---

## 1. GROUP BY分组

### 1.1 GROUP BY分组原理

**GROUP BY分组**是最基本的分组操作，将数据按照指定列的值进行分组。

#### 分组过程

1. **排序/哈希**：按照分组列排序或构建哈希表
2. **分组**：将相同分组键值的记录归为一组
3. **聚合**：对每组应用聚合函数
4. **输出**：返回分组结果

#### 分组策略

PostgreSQL查询优化器会根据以下因素选择分组策略：

1. **数据量**：小数据集使用排序，大数据集使用哈希
2. **分组列数量**：单列倾向于哈希，多列倾向于排序
3. **内存限制**：内存不足时使用外部排序

#### 分组键选择

**分组键**应该满足：

- 基数适中（不是太高也不是太低）
- 有索引支持（可选）
- 数据类型适合比较

### 1.2 单列分组实现

```sql
-- 单列分组（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行单列分组';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行单列分组';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '单列分组准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount
FROM sales
GROUP BY category
ORDER BY total_amount DESC;
```

### 1.3 多列分组实现

**多列分组**按照多个列的组合进行分组，分组键是多个列的组合值。

```sql
-- 多列分组（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行多列分组';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多列分组';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多列分组准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount
FROM sales
GROUP BY region, category
ORDER BY region, total_amount DESC;
```

### 1.4 HAVING子句过滤

**HAVING子句**对分组结果进行过滤。

```sql
-- HAVING子句过滤：过滤分组结果（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY region, category
HAVING COUNT(*) >= 10
   AND SUM(amount) > 10000
ORDER BY total_amount DESC;
```

### 1.5 分组性能优化

**分组性能优化**使用索引和统计信息。

```sql
-- 创建索引优化分组（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_sales_region_category
    ON sales(region, category);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

-- 更新统计信息（带错误处理）
DO $$
BEGIN
    ANALYZE sales;
    RAISE NOTICE '统计信息更新成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '更新统计信息失败: %', SQLERRM;
END $$;

-- 分析分组查询性能（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount
FROM sales
GROUP BY region, category
ORDER BY region, total_amount DESC;
```

### 1.6 PostgreSQL 18 并行分组增强

**PostgreSQL 18** 显著增强了并行分组能力，支持并行执行 GROUP BY、GROUPING SETS、ROLLUP 和 CUBE 操作，大幅提升大数据量分组查询的性能。

#### 并行分组原理

PostgreSQL 18 的并行分组通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描表数据
2. **并行分组**：每个工作进程独立执行分组操作
3. **并行聚合**：每个工作进程计算部分聚合结果
4. **结果合并**：主进程合并所有工作进程的分组结果

#### 并行分组实现

```sql
-- PostgreSQL 18 并行分组：启用并行执行
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;

-- 并行单列分组（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行并行分组';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行单列分组';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行分组准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY category
ORDER BY total_amount DESC;
```

#### 并行多列分组

```sql
-- PostgreSQL 18 并行多列分组（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行并行多列分组';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行多列分组';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行多列分组准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY region, category
ORDER BY region, total_amount DESC;
```

---

## 2. GROUPING SETS

### 2.1 GROUPING SETS原理

**GROUPING SETS**允许在单个查询中指定多个分组维度组合，生成多个分组结果集的并集。

#### GROUPING SETS语法

```sql
GROUP BY GROUPING SETS (
    (col1, col2),  -- 组合1
    (col1),        -- 组合2
    (col2),        -- 组合3
    ()             -- 总计
)
```

#### GROUPING函数

**GROUPING函数**用于识别哪些列在分组中被聚合（NULL值）：
$$GROUPING(col) = \begin{cases} 1 & \text{if col is aggregated} \\ 0 & \text{if col is grouped} \end{cases}$$

### 2.2 GROUPING SETS实现

```sql
-- GROUPING SETS多维度组合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行GROUPING SETS';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行GROUPING SETS多维度组合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'GROUPING SETS准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    SUM(amount) AS total_amount
FROM sales
GROUP BY GROUPING SETS (
    (region, category),
    (region),
    (category),
    ()
)
ORDER BY region NULLS LAST, category NULLS LAST;
```

### 2.3 GROUPING函数使用

**GROUPING函数**识别聚合列。

```sql
-- GROUPING函数：识别哪些列被聚合（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    region,
    category,
    GROUPING(region) AS is_region_aggregated,
    GROUPING(category) AS is_category_aggregated,
    SUM(amount) AS total_amount
FROM sales
GROUP BY GROUPING SETS (
    (region, category),
    (region),
    (category),
    ()
)
ORDER BY
    GROUPING(region),
    GROUPING(category),
    region NULLS LAST,
    category NULLS LAST;
```

### 2.4 PostgreSQL 18 并行 GROUPING SETS

**PostgreSQL 18** 支持并行执行 GROUPING SETS，大幅提升多维分组查询的性能。

```sql
-- PostgreSQL 18 并行 GROUPING SETS（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行并行GROUPING SETS';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行GROUPING SETS';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行GROUPING SETS准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    GROUPING(region) AS is_region_aggregated,
    GROUPING(category) AS is_category_aggregated,
    SUM(amount) AS total_amount,
    COUNT(*) AS count
FROM sales
GROUP BY GROUPING SETS (
    (region, category),
    (region),
    (category),
    ()
)
ORDER BY
    GROUPING(region),
    GROUPING(category),
    region NULLS LAST,
    category NULLS LAST;
```

---

## 3. ROLLUP分组

### 3.1 ROLLUP分组原理

**ROLLUP分组**进行层次汇总，从最细粒度到最粗粒度，生成层次化的分组结果。

#### ROLLUP语法

```sql
GROUP BY ROLLUP(col1, col2, col3)
```

等价于：

```sql
GROUP BY GROUPING SETS (
    (col1, col2, col3),  -- 最细粒度
    (col1, col2),        -- 中间粒度1
    (col1),              -- 中间粒度2
    ()                   -- 总计
)
```

#### ROLLUP层次结构

对于$n$个列，ROLLUP生成$n+1$个分组级别：

- Level $n$：所有列分组
- Level $n-1$：前$n-1$列分组
- ...
- Level $1$：第1列分组
- Level $0$：总计

### 3.2 ROLLUP层次汇总实现

```sql
-- ROLLUP层次汇总（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行ROLLUP';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行ROLLUP层次汇总';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ROLLUP准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    SUM(amount) AS total_amount
FROM sales
GROUP BY ROLLUP(region, category)
ORDER BY region NULLS LAST, category NULLS LAST;
```

### 3.3 多级ROLLUP

**多级ROLLUP**处理多个层次。

```sql
-- 多级ROLLUP：时间层次汇总
SELECT
    DATE_TRUNC('year', sale_date) AS year,
    DATE_TRUNC('month', sale_date) AS month,
    region,
    SUM(amount) AS total_amount
FROM sales
GROUP BY ROLLUP(
    DATE_TRUNC('year', sale_date),
    DATE_TRUNC('month', sale_date),
    region
)
ORDER BY
    year NULLS LAST,
    month NULLS LAST,
    region NULLS LAST;
```

### 3.4 PostgreSQL 18 并行 ROLLUP

**PostgreSQL 18** 支持并行执行 ROLLUP 操作，显著提升层次汇总查询的性能。

```sql
-- PostgreSQL 18 并行 ROLLUP（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行并行ROLLUP';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行ROLLUP';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行ROLLUP准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    SUM(amount) AS total_amount,
    COUNT(*) AS count
FROM sales
GROUP BY ROLLUP(region, category)
ORDER BY region NULLS LAST, category NULLS LAST;
```

---

## 4. CUBE分组

### 4.1 CUBE分组原理

**CUBE分组**生成所有可能的维度组合，包括所有子集和总计。

#### CUBE语法

```sql
GROUP BY CUBE(col1, col2)
```

等价于：

```sql
GROUP BY GROUPING SETS (
    (col1, col2),  -- 两列组合
    (col1),        -- 第1列
    (col2),        -- 第2列
    ()             -- 总计
)
```

#### CUBE组合数量

对于$n$个列，CUBE生成$2^n$个分组组合：
$$|\text{CUBE}(n)| = 2^n$$

#### CUBE vs ROLLUP

- **ROLLUP**：生成层次结构（$n+1$个组合）
- **CUBE**：生成所有组合（$2^n$个组合）

### 4.2 CUBE全维度组合实现

```sql
-- CUBE全维度组合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行CUBE';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行CUBE全维度组合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'CUBE准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    SUM(amount) AS total_amount
FROM sales
GROUP BY CUBE(region, category)
ORDER BY region NULLS LAST, category NULLS LAST;
```

### 4.3 部分CUBE

**部分CUBE**只生成部分组合。

```sql
-- 部分CUBE：只生成部分组合
SELECT
    region,
    category,
    product_type,
    SUM(amount) AS total_amount
FROM sales
GROUP BY CUBE(region, category, product_type)
HAVING
    -- 只保留有意义的组合
    (region IS NOT NULL OR category IS NOT NULL OR product_type IS NOT NULL)
ORDER BY
    GROUPING(region),
    GROUPING(category),
    GROUPING(product_type),
    region NULLS LAST,
    category NULLS LAST,
    product_type NULLS LAST;
```

### 4.4 PostgreSQL 18 并行 CUBE

**PostgreSQL 18** 支持并行执行 CUBE 操作，大幅提升全维度组合查询的性能。

```sql
-- PostgreSQL 18 并行 CUBE（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行并行CUBE';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行CUBE';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行CUBE准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    SUM(amount) AS total_amount,
    COUNT(*) AS count,
    GROUPING(region) AS g_region,
    GROUPING(category) AS g_category
FROM sales
GROUP BY CUBE(region, category)
ORDER BY region NULLS LAST, category NULLS LAST;
```

---

## 5. 高级分组技术

### 5.1 分组与窗口函数结合

**分组与窗口函数**结合使用。

```sql
-- 分组与窗口函数：计算分组内排名
SELECT
    region,
    category,
    product_id,
    amount,
    SUM(amount) OVER (PARTITION BY region, category) AS group_total,
    RANK() OVER (PARTITION BY region, category ORDER BY amount DESC) AS rank_in_group
FROM sales
WHERE sale_date >= '2024-01-01'
ORDER BY region, category, rank_in_group;
```

### 5.2 分组与CTE结合

**分组与CTE**结合使用。

```sql
-- 分组与CTE：复杂分组查询
WITH monthly_sales AS (
    SELECT
        DATE_TRUNC('month', sale_date) AS month,
        region,
        category,
        SUM(amount) AS total_amount
    FROM sales
    WHERE sale_date >= '2024-01-01'
    GROUP BY DATE_TRUNC('month', sale_date), region, category
),
region_totals AS (
    SELECT
        region,
        SUM(total_amount) AS region_total
    FROM monthly_sales
    GROUP BY region
)
SELECT
    ms.month,
    ms.region,
    ms.category,
    ms.total_amount,
    rt.region_total,
    ROUND(100.0 * ms.total_amount / rt.region_total, 2) AS percentage
FROM monthly_sales ms
JOIN region_totals rt ON ms.region = rt.region
ORDER BY ms.month, ms.region, ms.total_amount DESC;
```

### 5.3 分组与JSON聚合

**分组与JSON聚合**生成JSON结果。

```sql
-- 分组与JSON聚合：生成JSON结果
SELECT
    region,
    category,
    json_agg(
        json_build_object(
            'product_id', product_id,
            'amount', amount,
            'sale_date', sale_date
        ) ORDER BY amount DESC
    ) AS products
FROM sales
GROUP BY region, category
ORDER BY region, category;
```

---

## 6. 实际应用案例

### 6.1 多维度报表

**多维度报表**使用分组生成多维度报表。

```sql
-- 多维度报表（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行多维度报表';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多维度报表';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多维度报表准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    DATE_TRUNC('month', sale_date) AS month,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY GROUPING SETS (
    (region, category, DATE_TRUNC('month', sale_date)),
    (region, category),
    (region),
    ()
)
ORDER BY region NULLS LAST, category NULLS LAST, month NULLS LAST;
```

### 6.2 销售数据多维分析

**场景**：分析销售数据的多维度统计。

```sql
-- 销售数据多维分析：使用CUBE生成全维度分析
WITH sales_analysis AS (
    SELECT
        region,
        category,
        DATE_TRUNC('quarter', sale_date) AS quarter,
        COUNT(*) AS order_count,
        SUM(amount) AS total_amount,
        AVG(amount) AS avg_amount,
        MIN(amount) AS min_amount,
        MAX(amount) AS max_amount,
        GROUPING(region) AS g_region,
        GROUPING(category) AS g_category,
        GROUPING(DATE_TRUNC('quarter', sale_date)) AS g_quarter
    FROM sales
    WHERE sale_date >= '2024-01-01'
    GROUP BY CUBE(region, category, DATE_TRUNC('quarter', sale_date))
)
SELECT
    CASE
        WHEN g_region = 1 THEN 'ALL REGIONS'
        ELSE region::text
    END AS region_display,
    CASE
        WHEN g_category = 1 THEN 'ALL CATEGORIES'
        ELSE category::text
    END AS category_display,
    CASE
        WHEN g_quarter = 1 THEN 'ALL QUARTERS'
        ELSE quarter::text
    END AS quarter_display,
    order_count,
    ROUND(total_amount::numeric, 2) AS total_amount,
    ROUND(avg_amount::numeric, 2) AS avg_amount,
    ROUND(min_amount::numeric, 2) AS min_amount,
    ROUND(max_amount::numeric, 2) AS max_amount
FROM sales_analysis
ORDER BY
    g_region,
    g_category,
    g_quarter,
    region NULLS LAST,
    category NULLS LAST,
    quarter NULLS LAST;
```

### 6.3 用户行为分组分析

**场景**：分析用户行为的分组统计。

```sql
-- 用户行为分组分析：分析用户活跃度
WITH user_activity AS (
    SELECT
        user_id,
        DATE_TRUNC('day', activity_time) AS activity_date,
        activity_type,
        COUNT(*) AS activity_count
    FROM user_activities
    WHERE activity_time >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY user_id, DATE_TRUNC('day', activity_time), activity_type
),
user_daily_summary AS (
    SELECT
        user_id,
        activity_date,
        SUM(activity_count) AS total_activities,
        COUNT(DISTINCT activity_type) AS activity_types
    FROM user_activity
    GROUP BY user_id, activity_date
),
user_segments AS (
    SELECT
        user_id,
        AVG(total_activities) AS avg_daily_activities,
        COUNT(*) AS active_days,
        CASE
            WHEN AVG(total_activities) >= 20 THEN 'High'
            WHEN AVG(total_activities) >= 10 THEN 'Medium'
            ELSE 'Low'
        END AS activity_segment
    FROM user_daily_summary
    GROUP BY user_id
)
SELECT
    activity_segment,
    COUNT(*) AS user_count,
    ROUND(AVG(avg_daily_activities)::numeric, 2) AS avg_activities,
    ROUND(AVG(active_days)::numeric, 2) AS avg_active_days
FROM user_segments
GROUP BY activity_segment
ORDER BY
    CASE activity_segment
        WHEN 'High' THEN 1
        WHEN 'Medium' THEN 2
        WHEN 'Low' THEN 3
    END;
```

### 6.4 产品分组分析

**场景**：分析产品的分组统计。

```sql
-- 产品分组分析：分析产品销售情况
WITH product_sales AS (
    SELECT
        p.category,
        p.brand,
        p.product_id,
        p.name,
        COUNT(o.order_id) AS order_count,
        SUM(o.quantity) AS total_quantity,
        SUM(o.amount) AS total_amount,
        AVG(o.amount) AS avg_amount
    FROM products p
    LEFT JOIN order_items o ON p.product_id = o.product_id
    WHERE o.order_date >= '2024-01-01'
    GROUP BY p.category, p.brand, p.product_id, p.name
),
category_brand_summary AS (
    SELECT
        category,
        brand,
        COUNT(DISTINCT product_id) AS product_count,
        SUM(order_count) AS total_orders,
        SUM(total_quantity) AS total_quantity,
        SUM(total_amount) AS total_amount
    FROM product_sales
    GROUP BY category, brand
)
SELECT
    category,
    brand,
    product_count,
    total_orders,
    total_quantity,
    ROUND(total_amount::numeric, 2) AS total_amount,
    ROUND(total_amount::numeric / NULLIF(product_count, 0), 2) AS avg_amount_per_product
FROM category_brand_summary
ORDER BY category, total_amount DESC;
```

---

## 7. 算法性能对比与优化

### 7.1 分组方法对比

| 方法              | 组合数量              | 时间复杂度                    | 空间复杂度            | 适用场景     | 优点         | 缺点           |
| ----------------- | --------------------- | ----------------------------- | --------------------- | ------------ | ------------ | -------------- |
| **GROUP BY**      | 1                     | $O(n \log n)$                 | $O(n)$                | 简单分组     | 简单高效     | 单一维度       |
| **GROUPING SETS** | $k$ (指定)            | $O(k \cdot n \log n)$         | $O(k \cdot n)$        | 多维分析     | 灵活可控     | 需要手动指定   |
| **ROLLUP**        | $m+1$                 | $O((m+1) \cdot n \log n)$     | $O((m+1) \cdot n)$    | 层次报表     | 自动层次     | 固定层次结构   |
| **CUBE**          | $2^m$                 | $O(2^m \cdot n \log n)$       | $O(2^m \cdot n)$      | 全维度分析   | 完整组合     | 组合数指数增长 |

其中$m$是分组列的个数，$k$是GROUPING SETS的组合数。

### 7.2 性能优化建议

1. **索引优化**：
   - 在分组列上创建索引
   - 使用复合索引支持多列分组
   - 定期更新统计信息

2. **查询优化**：
   - 使用WHERE子句减少数据量
   - 避免不必要的CUBE操作
   - 使用GROUPING SETS替代CUBE（如果不需要所有组合）

3. **内存优化**：
   - 监控分组操作的内存使用
   - 调整work_mem参数
   - 使用分区表减少数据量

### 7.3 常见问题与解决方案

**问题1**：分组查询性能慢

- **解决方案**：创建索引、优化查询、使用分区表、调整work_mem

**问题2**：CUBE组合数过多

- **解决方案**：使用GROUPING SETS指定需要的组合、限制分组列数量

**问题3**：分组结果不准确

- **解决方案**：检查NULL值处理、验证分组键、检查聚合函数

**问题4**：内存不足

- **解决方案**：增加work_mem、使用分区表、优化查询减少数据量

---

## 8. 最佳实践

### 8.1 分组策略选择

1. **简单分组**：
   - 使用GROUP BY
   - 创建单列或复合索引
   - 适合单维度分析

2. **多维分析**：
   - 使用GROUPING SETS
   - 指定需要的组合
   - 适合灵活的多维分析

3. **层次报表**：
   - 使用ROLLUP
   - 按层次顺序排列列
   - 适合时间、地理等层次结构

4. **全维度分析**：
   - 使用CUBE
   - 限制分组列数量（建议≤4列）
   - 适合探索性数据分析

### 8.2 分组注意事项

1. **分组键选择**：
   - 选择基数适中的列
   - 避免高基数列（如ID）
   - 考虑NULL值处理

2. **聚合函数**：
   - 使用适当的聚合函数
   - 注意NULL值处理
   - 考虑性能影响

3. **结果排序**：
   - 使用ORDER BY排序结果
   - 注意NULL值位置（NULLS FIRST/LAST）
   - 考虑GROUPING函数

### 8.3 SQL实现注意事项

1. **性能考虑**：
   - 创建适当索引
   - 优化查询计划
   - 监控内存使用

2. **准确性**：
   - 处理NULL值
   - 验证分组结果
   - 检查聚合函数

3. **可维护性**：
   - 使用清晰的列名
   - 添加注释
   - 模块化设计

### 8.4 PostgreSQL 18 新特性应用（增强）

**PostgreSQL 18**引入了多项增强功能，可以显著提升分组算法的性能：

1. **Skip Scan优化**：
   - 对于包含分组键的索引，Skip Scan可以跳过不必要的索引扫描
   - 特别适用于Top-N分组查询和分组键范围查询

2. **异步I/O增强**：
   - 对于大规模分组计算，异步I/O可以显著提升性能
   - 适用于批量分组和复杂多维分组（GROUPING SETS、CUBE）

3. **并行查询增强**：
   - 分组计算支持更好的并行执行（已在各节详细说明）
   - 适用于大规模GROUP BY、ROLLUP、CUBE操作

**示例：使用Skip Scan优化分组查询**

```sql
-- 为分组键创建Skip Scan优化索引
CREATE INDEX IF NOT EXISTS idx_grouping_keys_skip_scan
ON sales_data(category, sale_date DESC, amount DESC);

-- Skip Scan优化查询：查找每个类别最新日期的前5个订单
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (category)
    category,
    sale_date,
    order_id,
    amount
FROM sales_data
ORDER BY category, sale_date DESC, amount DESC
LIMIT 50;
```

### 8.5 高级优化技巧（增强）

**1. 使用物化视图缓存多维分组结果**

对于频繁使用的多维分组结果，使用物化视图缓存：

```sql
-- 创建物化视图缓存多维分组结果
CREATE MATERIALIZED VIEW IF NOT EXISTS multidimensional_groups_cache AS
SELECT
    region,
    category,
    DATE_TRUNC('month', sale_date) AS sale_month,
    COUNT(*) AS order_count,
    SUM(amount) AS total_revenue,
    AVG(amount) AS avg_order_value,
    COUNT(DISTINCT customer_id) AS unique_customers,
    -- 使用窗口函数计算占比（避免重复计算）
    SUM(amount)::numeric / NULLIF(SUM(SUM(amount)) OVER (PARTITION BY region, category), 0) * 100 AS revenue_pct
FROM sales_data
WHERE sale_date >= CURRENT_DATE - INTERVAL '12 months'
GROUP BY region, category, DATE_TRUNC('month', sale_date);

-- 创建索引加速物化视图查询
CREATE INDEX idx_multidimensional_groups_cache_keys ON multidimensional_groups_cache(region, category, sale_month DESC);
CREATE INDEX idx_multidimensional_groups_cache_revenue ON multidimensional_groups_cache(total_revenue DESC);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY multidimensional_groups_cache;
```

**2. 实时多维分析：增量分组更新**

**实时多维分析**：对于实时数据，使用增量方法更新分组结果。

```sql
-- 实时多维分析：增量分组更新（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'grouping_state') THEN
            CREATE TABLE grouping_state (
                group_key VARCHAR(200) PRIMARY KEY,
                group_type VARCHAR(50) NOT NULL,  -- 'simple', 'rollup', 'cube'
                count_value BIGINT DEFAULT 0,
                sum_value NUMERIC DEFAULT 0,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_grouping_state_type ON grouping_state(group_type, sum_value DESC);
            CREATE INDEX idx_grouping_state_updated ON grouping_state(last_updated DESC);

            RAISE NOTICE '分组状态表创建成功';
        END IF;

        RAISE NOTICE '开始执行增量分组更新';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '增量分组更新准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 增量更新分组结果：实时多维分析
WITH new_sales AS (
    SELECT
        region || '|' || category || '|' || DATE_TRUNC('month', sale_date)::text AS group_key,
        'simple' AS group_type,
        COUNT(*) AS new_count,
        SUM(amount) AS new_sum
    FROM sales_data
    WHERE sale_date > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM grouping_state)
      AND sale_date <= CURRENT_DATE
    GROUP BY region, category, DATE_TRUNC('month', sale_date)
),
updated_groups AS (
    SELECT
        COALESCE(gs.group_key, ns.group_key) AS group_key,
        COALESCE(gs.group_type, ns.group_type) AS group_type,
        COALESCE(gs.count_value, 0) + ns.new_count AS new_count,
        COALESCE(gs.sum_value, 0) + ns.new_sum AS new_sum
    FROM grouping_state gs
    FULL OUTER JOIN new_sales ns ON gs.group_key = ns.group_key AND gs.group_type = ns.group_type
)
-- 更新或插入分组状态
INSERT INTO grouping_state (group_key, group_type, count_value, sum_value, last_updated)
SELECT
    group_key,
    group_type,
    new_count,
    new_sum,
    NOW()
FROM updated_groups
ON CONFLICT (group_key)
DO UPDATE SET
    count_value = EXCLUDED.count_value,
    sum_value = EXCLUDED.sum_value,
    last_updated = NOW();
```

**3. 动态多维分析：自适应分组策略**

**动态多维分析**：根据数据特征自动调整分组策略。

```sql
-- 动态多维分析：自适应分组策略（带错误处理和性能测试）
DO $$
DECLARE
    total_rows BIGINT;
    distinct_groups BIGINT;
    grouping_strategy VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_data') THEN
            RAISE WARNING '表 sales_data 不存在，无法执行动态多维分析';
            RETURN;
        END IF;

        -- 计算数据量和分组数量
        SELECT COUNT(*) INTO total_rows FROM sales_data;
        SELECT COUNT(DISTINCT (region, category)) INTO distinct_groups FROM sales_data;

        -- 根据数据特征选择分组策略
        IF total_rows < 100000 AND distinct_groups < 1000 THEN
            grouping_strategy := 'CUBE';  -- 小数据量使用CUBE
        ELSIF total_rows < 1000000 AND distinct_groups < 10000 THEN
            grouping_strategy := 'ROLLUP';  -- 中等数据量使用ROLLUP
        ELSE
            grouping_strategy := 'GROUPING SETS';  -- 大数据量使用GROUPING SETS
        END IF;

        RAISE NOTICE '数据量: %, 分组数: %, 选择策略: %', total_rows, distinct_groups, grouping_strategy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '动态多维分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 动态分组：根据策略选择不同的分组方式
WITH adaptive_grouping AS (
    SELECT
        region,
        category,
        DATE_TRUNC('month', sale_date) AS sale_month,
        COUNT(*) AS order_count,
        SUM(amount) AS total_revenue
    FROM sales_data
    WHERE sale_date >= CURRENT_DATE - INTERVAL '6 months'
    GROUP BY
        CASE
            WHEN (SELECT COUNT(*) FROM sales_data WHERE sale_date >= CURRENT_DATE - INTERVAL '6 months') < 100000 THEN
                CUBE(region, category, DATE_TRUNC('month', sale_date))
            WHEN (SELECT COUNT(DISTINCT (region, category)) FROM sales_data WHERE sale_date >= CURRENT_DATE - INTERVAL '6 months') < 10000 THEN
                ROLLUP(region, category, DATE_TRUNC('month', sale_date))
            ELSE
                GROUPING SETS (
                    (region, category, DATE_TRUNC('month', sale_date)),
                    (region, category),
                    (region),
                    ()
                )
        END
)
SELECT
    region,
    category,
    sale_month,
    order_count,
    ROUND(total_revenue::numeric, 2) AS total_revenue
FROM adaptive_grouping
ORDER BY region NULLS LAST, category NULLS LAST, sale_month NULLS LAST
LIMIT 100;
```

---

## 📚 参考资源

### 学术文献

1. **《数据库系统概念》**（Silberschatz, A., et al., 2019）- 分组算法

2. **《PostgreSQL即学即用》**（Obe, R., & Hsu, L., 2017）- PostgreSQL分组

3. **《SQL权威指南》**（Date, C. J., 2015）- SQL分组操作

### PostgreSQL官方文档

- **GROUP BY**: <https://www.postgresql.org/docs/current/tutorial-agg.html>
- **GROUPING SETS**: <https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUPING-SETS>
- **ROLLUP/CUBE**: <https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-GROUPING-SETS>

### 在线资源

- **分组算法**: <https://en.wikipedia.org/wiki/Group_by_(SQL)>
- **多维分析**: <https://en.wikipedia.org/wiki/OLAP_cube>

### 相关算法

- **聚合算法**：分组后的聚合操作
- **排序算法**：分组前的排序操作
- **搜索算法**：分组前的过滤操作

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
