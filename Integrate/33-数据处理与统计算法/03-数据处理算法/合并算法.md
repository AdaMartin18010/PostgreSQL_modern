# PostgreSQL 合并算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 合并算法 | 数据整合
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 合并算法完整指南](#postgresql-合并算法完整指南)
  - [📋 目录](#-目录)
  - [合并算法概述](#合并算法概述)
    - [核心合并功能](#核心合并功能)
  - [1. UNION合并](#1-union合并)
    - [1.1 UNION去重合并](#11-union去重合并)
    - [1.2 UNION ALL保留重复](#12-union-all保留重复)
  - [2. JOIN合并](#2-join合并)
    - [2.1 INNER JOIN](#21-inner-join)
    - [2.2 LEFT JOIN](#22-left-join)
  - [3. MERGE合并](#3-merge合并)
    - [3.1 UPSERT操作](#31-upsert操作)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 多表数据整合](#41-多表数据整合)

---

## 合并算法概述

**合并算法**用于将多个数据集合并，PostgreSQL支持多种合并方式。

### 核心合并功能

| 功能 | 用途 | 复杂度 |
|------|------|--------|
| **UNION** | 垂直合并 | O(n+m) |
| **JOIN** | 水平合并 | O(n*m) |
| **MERGE** | 更新合并 | O(n+m) |

---

## 1. UNION合并

### 1.1 UNION去重合并

**UNION合并**合并两个查询结果，自动去重。

```sql
-- UNION去重合并（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders_2023') THEN
            RAISE WARNING '表 orders_2023 不存在，无法执行UNION合并';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders_2024') THEN
            RAISE WARNING '表 orders_2024 不存在，无法执行UNION合并';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行UNION去重合并';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'UNION合并准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT customer_id, order_date, amount
FROM orders_2023
UNION
SELECT customer_id, order_date, amount
FROM orders_2024
ORDER BY order_date DESC;
```

### 1.2 UNION ALL保留重复

**UNION ALL合并**合并两个查询结果，保留重复。

```sql
-- UNION ALL保留重复合并（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders_2023') THEN
            RAISE WARNING '表 orders_2023 不存在，无法执行UNION ALL合并';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders_2024') THEN
            RAISE WARNING '表 orders_2024 不存在，无法执行UNION ALL合并';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行UNION ALL保留重复合并';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'UNION ALL合并准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT customer_id, order_date, amount
FROM orders_2023
UNION ALL
SELECT customer_id, order_date, amount
FROM orders_2024
ORDER BY order_date DESC;
```

---

## 2. JOIN合并

### 2.1 INNER JOIN

**INNER JOIN**合并两个表的交集。

```sql
-- INNER JOIN合并（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行INNER JOIN';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customers') THEN
            RAISE WARNING '表 customers 不存在，无法执行INNER JOIN';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行INNER JOIN合并';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'INNER JOIN准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    o.order_id,
    o.order_date,
    o.amount,
    c.customer_name,
    c.email
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id;
```

### 2.2 LEFT JOIN

**LEFT JOIN**保留左表所有记录。

```sql
-- LEFT JOIN合并（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行LEFT JOIN';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customers') THEN
            RAISE WARNING '表 customers 不存在，无法执行LEFT JOIN';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行LEFT JOIN合并';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'LEFT JOIN准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    o.order_id,
    o.order_date,
    o.amount,
    c.customer_name,
    c.email
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id;
```

---

## 3. MERGE合并

### 3.1 UPSERT操作

**MERGE/UPSERT**合并插入和更新操作。

```sql
-- MERGE UPSERT操作（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行MERGE操作';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products_update') THEN
            RAISE WARNING '表 products_update 不存在，无法执行MERGE操作';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行MERGE UPSERT操作';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'MERGE操作准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- PostgreSQL 15+支持MERGE
MERGE INTO products AS p
USING products_update AS u
ON p.product_id = u.product_id
WHEN MATCHED THEN
    UPDATE SET
        name = u.name,
        price = u.price,
        updated_at = CURRENT_TIMESTAMP
WHEN NOT MATCHED THEN
    INSERT (product_id, name, price, created_at)
    VALUES (u.product_id, u.name, u.price, CURRENT_TIMESTAMP);
```

---

## 4. 实际应用案例

### 4.1 多表数据整合

**多表数据整合**合并多个表的数据。

```sql
-- 多表数据整合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行多表整合';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customers') THEN
            RAISE WARNING '表 customers 不存在，无法执行多表整合';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行多表整合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多表数据整合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多表整合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    o.order_id,
    o.order_date,
    c.customer_name,
    p.product_name,
    oi.quantity,
    oi.amount
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id
ORDER BY o.order_date DESC;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
