# PostgreSQL 排序算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 排序算法 | 查询优化
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 排序算法完整指南](#postgresql-排序算法完整指南)
  - [📋 目录](#-目录)
  - [排序算法概述](#排序算法概述)
    - [核心排序功能](#核心排序功能)
  - [1. ORDER BY排序](#1-order-by排序)
    - [1.1 基础排序](#11-基础排序)
    - [1.2 多列排序](#12-多列排序)
  - [2. 窗口函数排序](#2-窗口函数排序)
    - [2.1 分区内排序](#21-分区内排序)
  - [3. 索引排序优化](#3-索引排序优化)
    - [3.1 利用索引排序](#31-利用索引排序)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 Top N查询](#41-top-n查询)

---

## 排序算法概述

**排序算法**用于对查询结果进行排序，PostgreSQL支持多种排序方式。

### 核心排序功能

| 功能 | 用途 | 复杂度 |
|------|------|--------|
| **ORDER BY** | 基础排序 | O(n log n) |
| **窗口排序** | 分区内排序 | O(n log n) |
| **索引排序** | 利用索引排序 | O(n) |

---

## 1. ORDER BY排序

### 1.1 基础排序

**ORDER BY**用于对查询结果进行排序。

```sql
-- 基础排序（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行排序';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行基础排序';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '排序准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM products
ORDER BY price DESC, name ASC
LIMIT 100;
```

### 1.2 多列排序

**多列排序**按照多个列的顺序进行排序。

```sql
-- 多列排序（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行多列排序';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多列排序';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多列排序准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM orders
ORDER BY order_date DESC, customer_id ASC, amount DESC;
```

---

## 2. 窗口函数排序

### 2.1 分区内排序

**窗口函数排序**在分区内进行排序。

```sql
-- 分区内排序（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行窗口排序';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行窗口函数排序';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '窗口排序准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    category,
    product_name,
    sales_amount,
    ROW_NUMBER() OVER (PARTITION BY category ORDER BY sales_amount DESC) AS rank_in_category
FROM sales
ORDER BY category, rank_in_category;
```

---

## 3. 索引排序优化

### 3.1 利用索引排序

**索引排序**利用索引的有序性避免显式排序。

```sql
-- 创建排序索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法创建索引';
            RETURN;
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'products' AND indexname = 'idx_products_price_name') THEN
            RAISE WARNING '索引 idx_products_price_name 已存在';
        ELSE
            CREATE INDEX idx_products_price_name ON products(price DESC, name ASC);
            RAISE NOTICE '索引 idx_products_price_name 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 products 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_products_price_name 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建索引失败: %', SQLERRM;
    END;
END $$;

-- 使用索引排序（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行索引排序查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行索引排序查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引排序查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM products
ORDER BY price DESC, name ASC
LIMIT 100;
```

---

## 4. 实际应用案例

### 4.1 Top N查询

**Top N查询**获取排序后的前N条记录。

```sql
-- Top N查询（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行Top N查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行Top N查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Top N查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    product_id,
    SUM(amount) AS total_sales
FROM sales
GROUP BY product_id
ORDER BY total_sales DESC
LIMIT 10;
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
