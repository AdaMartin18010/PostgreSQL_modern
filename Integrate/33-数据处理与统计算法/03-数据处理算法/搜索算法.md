# PostgreSQL 搜索算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 搜索算法 | 查询优化
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 搜索算法完整指南](#postgresql-搜索算法完整指南)
  - [📋 目录](#-目录)
  - [搜索算法概述](#搜索算法概述)
    - [理论基础](#理论基础)
      - [搜索问题定义](#搜索问题定义)
      - [搜索算法分类](#搜索算法分类)
      - [搜索性能](#搜索性能)
    - [核心搜索功能](#核心搜索功能)
  - [1. 精确搜索](#1-精确搜索)
    - [1.1 精确搜索原理](#11-精确搜索原理)
      - [等值搜索](#等值搜索)
      - [IN搜索](#in搜索)
      - [索引优化](#索引优化)
    - [1.2 等值搜索实现](#12-等值搜索实现)
    - [1.2 IN子句搜索](#12-in子句搜索)
    - [1.3 多列等值搜索](#13-多列等值搜索)
    - [1.4 索引使用分析](#14-索引使用分析)
  - [2. 范围搜索](#2-范围搜索)
    - [2.1 范围搜索原理](#21-范围搜索原理)
      - [BETWEEN搜索语法](#between搜索语法)
      - [比较搜索](#比较搜索)
      - [范围搜索索引优化](#范围搜索索引优化)
    - [2.2 BETWEEN搜索实现](#22-between搜索实现)
    - [2.3 多范围搜索](#23-多范围搜索)
    - [2.4 范围搜索优化](#24-范围搜索优化)
  - [3. 模糊搜索](#3-模糊搜索)
    - [3.1 模糊搜索原理](#31-模糊搜索原理)
      - [LIKE操作符语法](#like操作符语法)
      - [正则表达式](#正则表达式)
      - [模糊搜索索引优化](#模糊搜索索引优化)
    - [3.2 LIKE搜索实现](#32-like搜索实现)
    - [3.2 正则表达式搜索](#32-正则表达式搜索)
    - [3.3 LIKE性能优化](#33-like性能优化)
    - [3.4 正则表达式高级用法](#34-正则表达式高级用法)
  - [4. 全文搜索](#4-全文搜索)
    - [4.1 全文搜索原理](#41-全文搜索原理)
      - [全文搜索组件](#全文搜索组件)
      - [全文搜索过程](#全文搜索过程)
      - [全文搜索操作符](#全文搜索操作符)
    - [4.2 tsvector搜索实现](#42-tsvector搜索实现)
    - [4.3 全文搜索相关性排序](#43-全文搜索相关性排序)
    - [4.4 全文搜索高亮](#44-全文搜索高亮)
  - [5. PostgreSQL 18并行搜索增强](#5-postgresql-18并行搜索增强)
    - [5.1 并行搜索概述](#51-并行搜索概述)
      - [并行搜索原理](#并行搜索原理)
    - [5.2 并行搜索配置](#52-并行搜索配置)
    - [5.3 并行搜索实现示例](#53-并行搜索实现示例)
  - [6. 高级搜索技术](#6-高级搜索技术)
    - [6.1 多条件组合搜索](#61-多条件组合搜索)
    - [6.2 子查询搜索](#62-子查询搜索)
    - [6.3 EXISTS搜索](#63-exists搜索)
  - [7. 实际应用案例](#7-实际应用案例)
    - [7.1 组合搜索](#71-组合搜索)
    - [7.2 电商商品搜索](#72-电商商品搜索)
    - [7.3 用户搜索功能](#73-用户搜索功能)
    - [7.4 日志搜索分析](#74-日志搜索分析)
  - [8. 算法性能对比与优化](#8-算法性能对比与优化)
    - [8.1 搜索方法对比](#81-搜索方法对比)
    - [8.2 性能优化建议](#82-性能优化建议)
    - [8.3 常见问题与解决方案](#83-常见问题与解决方案)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 搜索策略选择](#91-搜索策略选择)
    - [9.2 搜索注意事项](#92-搜索注意事项)
    - [9.3 SQL实现注意事项](#93-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 搜索算法概述

**搜索算法（Search Algorithm）**用于在数据集中查找特定记录，是数据库查询的核心操作之一。PostgreSQL支持多种搜索方式，从简单的等值匹配到复杂的全文搜索。

### 理论基础

#### 搜索问题定义

**搜索问题**是在数据集$D = \{d_1, d_2, \ldots, d_n\}$中查找满足条件$C$的记录：
$$S = \{d_i \in D : C(d_i) = \text{true}\}$$

其中$C$是搜索条件（谓词）。

#### 搜索算法分类

1. **精确搜索**：
   - 等值搜索：$d.column = value$
   - IN搜索：$d.column \in \{v_1, v_2, \ldots, v_k\}$

2. **范围搜索**：
   - BETWEEN搜索：$value_1 \leq d.column \leq value_2$
   - 比较搜索：$d.column <, >, \leq, \geq value$

3. **模式搜索**：
   - LIKE搜索：模式匹配
   - 正则表达式搜索：正则匹配

4. **全文搜索**：
   - tsvector搜索：基于倒排索引
   - 语义搜索：基于向量相似度

#### 搜索性能

**搜索复杂度**：

- **索引搜索**：$O(\log n)$（B-Tree索引）
- **哈希搜索**：$O(1)$（哈希索引）
- **全表扫描**：$O(n)$（无索引）
- **全文搜索**：$O(\log n)$（GIN索引）

### 核心搜索功能

| 功能 | 用途 | 复杂度 | 索引类型 |
| ---- | ---- | ------ | -------- |
| **精确搜索** | 等值匹配 | $O(\log n)$ | B-Tree/Hash |
| **范围搜索** | 区间匹配 | $O(\log n)$ | B-Tree |
| **模糊搜索** | 模式匹配 | $O(n)$ | 无/Trigram |
| **全文搜索** | 文本搜索 | $O(\log n)$ | GIN/GiST |

---

## 1. 精确搜索

### 1.1 精确搜索原理

**精确搜索（Exact Search）**使用等值条件进行精确匹配，是最常用的搜索方式。

#### 等值搜索

**等值搜索**使用等号（`=`）进行精确匹配：
$$d.column = value$$

#### IN搜索

**IN搜索**检查值是否在集合中：
$$d.column \in \{v_1, v_2, \ldots, v_k\}$$

#### 索引优化

**B-Tree索引**：等值搜索的最佳索引类型，时间复杂度$O(\log n)$。

**Hash索引**：仅支持等值搜索，时间复杂度$O(1)$，但不支持范围查询。

### 1.2 等值搜索实现

```sql
-- 等值搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users') THEN
            RAISE WARNING '表 users 不存在，无法执行等值搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行等值搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '等值搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM users
WHERE id = 123;
```

### 1.2 IN子句搜索

**IN子句搜索**在多个值中查找。

```sql
-- IN子句搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行IN子句搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行IN子句搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'IN子句搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM products
WHERE category_id IN (1, 2, 3, 4, 5);
```

---

### 1.3 多列等值搜索

**多列等值搜索**使用多个条件组合。

```sql
-- 多列等值搜索：组合多个等值条件（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    name,
    category,
    price,
    status
FROM products
WHERE category = 'electronics'
  AND status = 'active'
  AND price = 999.99
ORDER BY id;
```

### 1.4 索引使用分析

**索引使用分析**检查搜索是否使用了索引。

```sql
-- 索引使用分析：检查搜索性能（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM users
WHERE email = 'user@example.com';

-- 如果没有索引，创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

-- 再次分析（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM users
WHERE email = 'user@example.com';
```

---

## 2. 范围搜索

### 2.1 范围搜索原理

**范围搜索（Range Search）**在指定范围内查找数据，支持区间查询和比较查询。

#### BETWEEN搜索语法

**BETWEEN搜索**语法：
$$value_1 \leq d.column \leq value_2$$

等价于：
$$d.column \geq value_1 \text{ AND } d.column \leq value_2$$

#### 比较搜索

**比较搜索**使用比较运算符：

- `>`：大于
- `<`：小于
- `>=`：大于等于
- `<=`：小于等于
- `<>`或`!=`：不等于

#### 范围搜索索引优化

**B-Tree索引**：范围搜索的最佳索引类型，支持范围扫描。

### 2.2 BETWEEN搜索实现

```sql
-- BETWEEN范围搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行范围搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行BETWEEN范围搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '范围搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND amount BETWEEN 100 AND 1000;
```

---

### 2.3 多范围搜索

**多范围搜索**使用多个范围条件。

```sql
-- 多范围搜索：组合多个范围条件（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    name,
    price,
    stock_quantity,
    created_date
FROM products
WHERE price BETWEEN 100 AND 500
  AND stock_quantity BETWEEN 10 AND 100
  AND created_date BETWEEN '2024-01-01' AND '2024-12-31'
ORDER BY price DESC;
```

### 2.4 范围搜索优化

**范围搜索优化**使用索引和分区。

```sql
-- 范围搜索优化：创建范围索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_orders_date_amount
    ON orders(order_date, amount);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

-- 使用索引的范围搜索（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31'
  AND amount BETWEEN 100 AND 1000;
```

---

## 3. 模糊搜索

### 3.1 模糊搜索原理

**模糊搜索（Fuzzy Search）**使用模式匹配查找数据，支持通配符和正则表达式。

#### LIKE操作符语法

**LIKE操作符**支持通配符：

- `%`：匹配任意字符序列（包括空）
- `_`：匹配单个字符
- `\`：转义字符

#### 正则表达式

**正则表达式**使用POSIX正则表达式语法：

- `~`：匹配正则表达式
- `~*`：不区分大小写匹配
- `!~`：不匹配正则表达式
- `!~*`：不区分大小写不匹配

#### 模糊搜索索引优化

**Trigram索引**：使用`pg_trgm`扩展加速LIKE搜索。

### 3.2 LIKE搜索实现

```sql
-- LIKE模糊搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行LIKE搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行LIKE模糊搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'LIKE搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM products
WHERE name LIKE '%keyword%';
```

### 3.2 正则表达式搜索

**正则表达式搜索**使用正则表达式进行模式匹配。

```sql
-- 正则表达式搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'users') THEN
            RAISE WARNING '表 users 不存在，无法执行正则表达式搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行正则表达式搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '正则表达式搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM users
WHERE email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
```

---

### 3.3 LIKE性能优化

**Trigram索引**加速LIKE搜索。

```sql
-- 启用pg_trgm扩展
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 创建Trigram索引
CREATE INDEX IF NOT EXISTS idx_products_name_trgm
ON products USING GIN (name gin_trgm_ops);

-- 使用Trigram索引的LIKE搜索
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM products
WHERE name LIKE '%keyword%';
```

### 3.4 正则表达式高级用法

**正则表达式**实现复杂模式匹配。

```sql
-- 正则表达式高级用法：复杂模式匹配
SELECT
    id,
    email,
    phone,
    address
FROM users
WHERE
    -- 邮箱格式验证
    email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    -- 手机号格式验证（中国）
    AND phone ~ '^1[3-9]\d{9}$'
    -- 地址包含特定关键词
    AND address ~* '(北京|上海|广州|深圳)'
ORDER BY id;
```

---

## 4. 全文搜索

### 4.1 全文搜索原理

**全文搜索（Full-Text Search）**用于在文本数据中查找关键词，支持词法分析和相关性排序。

#### 全文搜索组件

1. **tsvector**：文本向量，存储词位（lexemes）
2. **tsquery**：查询向量，存储搜索条件
3. **操作符**：`@@`用于匹配

#### 全文搜索过程

1. **文档解析**：将文本解析为词位
2. **词位标准化**：去除停用词、词干提取
3. **索引构建**：构建倒排索引（GIN/GiST）
4. **查询匹配**：使用tsquery匹配tsvector

#### 全文搜索操作符

- `&`：AND操作
- `|`：OR操作
- `!`：NOT操作
- `:`：短语搜索

### 4.2 tsvector搜索实现

```sql
-- 创建全文搜索索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法创建全文搜索索引';
            RETURN;
        END IF;

        IF EXISTS (SELECT 1 FROM pg_indexes WHERE tablename = 'articles' AND indexname = 'idx_articles_content_gin') THEN
            RAISE WARNING '索引 idx_articles_content_gin 已存在';
        ELSE
            CREATE INDEX idx_articles_content_gin ON articles USING GIN (to_tsvector('english', content));
            RAISE NOTICE '全文搜索索引 idx_articles_content_gin 创建成功';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE EXCEPTION '表 articles 不存在';
        WHEN duplicate_table THEN
            RAISE WARNING '索引 idx_articles_content_gin 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建全文搜索索引失败: %', SQLERRM;
    END;
END $$;

-- 全文搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'articles') THEN
            RAISE WARNING '表 articles 不存在，无法执行全文搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行全文搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '全文搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM articles
WHERE to_tsvector('english', content) @@ to_tsquery('english', 'keyword & search');
```

---

### 4.3 全文搜索相关性排序

**相关性排序**使用ts_rank函数。

```sql
-- 全文搜索相关性排序：按相关性排序结果
SELECT
    id,
    title,
    content,
    ts_rank(to_tsvector('english', content), query) AS rank,
    ts_rank_cd(to_tsvector('english', content), query) AS rank_cd
FROM articles,
     to_tsquery('english', 'keyword & search') AS query
WHERE to_tsvector('english', content) @@ query
ORDER BY rank DESC
LIMIT 10;
```

### 4.4 全文搜索高亮

**高亮显示**使用ts_headline函数。

```sql
-- 全文搜索高亮：高亮显示匹配的文本
SELECT
    id,
    title,
    ts_headline(
        'english',
        content,
        to_tsquery('english', 'keyword & search'),
        'StartSel=<mark>, StopSel=</mark>'
    ) AS highlighted_content
FROM articles
WHERE to_tsvector('english', content) @@ to_tsquery('english', 'keyword & search')
LIMIT 10;
```

---

## 5. PostgreSQL 18并行搜索增强

### 5.1 并行搜索概述

**PostgreSQL 18并行搜索增强**：PostgreSQL 18对并行查询进行了重大改进，特别是在搜索操作方面，可以显著提升大规模数据搜索的性能。

#### 并行搜索原理

**并行搜索（Parallel Search）**：将搜索操作分布到多个工作进程并行执行，最后合并结果。

**并行搜索优势**：

- 充分利用多核CPU资源
- 大幅提升大规模数据搜索性能
- 支持多种搜索方式并行执行

### 5.2 并行搜索配置

**配置并行参数**：

```sql
-- 配置并行搜索参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行搜索成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行搜索参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行搜索配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.3 并行搜索实现示例

**大规模数据并行搜索**：

```sql
-- 并行搜索：大规模数据全文搜索（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行搜索查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行全文搜索
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    id,
    title,
    content,
    ts_rank(to_tsvector('english', content), to_tsquery('english', 'search query')) AS rank
FROM documents
WHERE to_tsvector('english', content) @@ to_tsquery('english', 'search query')
ORDER BY rank DESC
LIMIT 100;
```

**并行范围搜索**：

```sql
-- 并行范围搜索（PostgreSQL 18+）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT *
FROM orders
WHERE order_date BETWEEN CURRENT_DATE - INTERVAL '1 year' AND CURRENT_DATE
  AND amount BETWEEN 100 AND 10000
ORDER BY order_date DESC;
```

---

## 6. 高级搜索技术

### 6.1 多条件组合搜索

**多条件组合**使用AND/OR组合多个条件。

```sql
-- 多条件组合搜索：使用AND/OR组合
SELECT
    id,
    name,
    category,
    price,
    rating,
    status
FROM products
WHERE (
    category = 'electronics' OR category = 'computers'
) AND (
    price BETWEEN 100 AND 1000
) AND (
    rating >= 4.0 OR status = 'featured'
) AND (
    name LIKE '%keyword%' OR description LIKE '%keyword%'
)
ORDER BY rating DESC, price ASC
LIMIT 20;
```

### 6.2 子查询搜索

**子查询搜索**使用子查询作为搜索条件。

```sql
-- 子查询搜索：使用子查询作为搜索条件
SELECT
    p.id,
    p.name,
    p.price,
    p.category
FROM products p
WHERE p.category_id IN (
    SELECT id FROM categories WHERE parent_id = 1
)
AND p.price > (
    SELECT AVG(price) FROM products WHERE category_id = p.category_id
)
ORDER BY p.price DESC;
```

### 6.3 EXISTS搜索

**EXISTS搜索**检查子查询是否存在结果。

```sql
-- EXISTS搜索：检查相关记录是否存在
SELECT
    c.id,
    c.name,
    c.email
FROM customers c
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.id
      AND o.status = 'completed'
      AND o.amount > 1000
)
ORDER BY c.id;
```

---

## 7. 实际应用案例

### 7.1 组合搜索

**组合搜索**结合多种搜索条件。

```sql
-- 组合搜索（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行组合搜索';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行组合搜索';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '组合搜索准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT *
FROM products
WHERE category_id IN (1, 2, 3)
  AND price BETWEEN 100 AND 500
  AND name LIKE '%keyword%'
ORDER BY price DESC
LIMIT 20;
```

### 7.2 电商商品搜索

**场景**：实现电商平台的商品搜索功能。

```sql
-- 电商商品搜索：多维度搜索商品
WITH search_params AS (
    SELECT
        'electronics' AS category_filter,
        ARRAY[1, 2, 3] AS brand_ids,
        100.0 AS min_price,
        1000.0 AS max_price,
        'laptop' AS keyword,
        4.0 AS min_rating
),
filtered_products AS (
    SELECT
        p.id,
        p.name,
        p.category,
        p.brand_id,
        p.price,
        p.rating,
        p.stock_quantity,
        p.description,
        -- 全文搜索相关性
        ts_rank(
            to_tsvector('english', p.name || ' ' || COALESCE(p.description, '')),
            to_tsquery('english', (SELECT keyword FROM search_params))
        ) AS search_rank
    FROM products p
    CROSS JOIN search_params sp
    WHERE
        -- 类别过滤
        p.category = sp.category_filter
        -- 品牌过滤
        AND p.brand_id = ANY(sp.brand_ids)
        -- 价格范围
        AND p.price BETWEEN sp.min_price AND sp.max_price
        -- 评分过滤
        AND p.rating >= sp.min_rating
        -- 库存过滤
        AND p.stock_quantity > 0
        -- 全文搜索
        AND (
            to_tsvector('english', p.name || ' ' || COALESCE(p.description, '')) @@
            to_tsquery('english', sp.keyword)
            OR p.name ILIKE '%' || sp.keyword || '%'
        )
)
SELECT
    id,
    name,
    category,
    brand_id,
    price,
    rating,
    stock_quantity,
    ROUND(search_rank::numeric, 4) AS relevance_score
FROM filtered_products
ORDER BY search_rank DESC, rating DESC, price ASC
LIMIT 20;
```

### 7.3 用户搜索功能

**场景**：实现用户搜索和管理功能。

```sql
-- 用户搜索功能：多条件用户搜索
WITH search_criteria AS (
    SELECT
        'john' AS name_keyword,
        'active' AS status_filter,
        '2020-01-01'::date AS min_registration_date,
        100 AS min_order_count
),
user_search AS (
    SELECT
        u.id,
        u.name,
        u.email,
        u.phone,
        u.status,
        u.registration_date,
        COUNT(o.id) AS order_count,
        SUM(o.amount) AS total_spent,
        -- 名称匹配度
        CASE
            WHEN u.name ILIKE (SELECT name_keyword FROM search_criteria) THEN 10
            WHEN u.name ILIKE '%' || (SELECT name_keyword FROM search_criteria) || '%' THEN 5
            ELSE 0
        END AS name_match_score
    FROM users u
    LEFT JOIN orders o ON u.id = o.customer_id AND o.status = 'completed'
    CROSS JOIN search_criteria sc
    WHERE
        -- 名称搜索
        (
            u.name ILIKE '%' || sc.name_keyword || '%'
            OR u.email ILIKE '%' || sc.name_keyword || '%'
        )
        -- 状态过滤
        AND u.status = sc.status_filter
        -- 注册时间过滤
        AND u.registration_date >= sc.min_registration_date
    GROUP BY u.id, u.name, u.email, u.phone, u.status, u.registration_date
    HAVING COUNT(o.id) >= sc.min_order_count
)
SELECT
    id,
    name,
    email,
    phone,
    status,
    registration_date,
    order_count,
    ROUND(total_spent::numeric, 2) AS total_spent,
    name_match_score
FROM user_search
ORDER BY name_match_score DESC, total_spent DESC
LIMIT 50;
```

### 7.4 日志搜索分析

**场景**：搜索和分析系统日志。

```sql
-- 日志搜索分析：搜索和分析日志
WITH log_search AS (
    SELECT
        log_id,
        timestamp,
        level,
        message,
        source,
        -- 错误日志搜索
        CASE
            WHEN level IN ('ERROR', 'FATAL') THEN 'error'
            WHEN level = 'WARNING' THEN 'warning'
            ELSE 'info'
        END AS log_category,
        -- 关键词匹配
        CASE
            WHEN message ~* 'timeout|connection.*failed|error' THEN true
            ELSE false
        END AS has_error_keywords
    FROM system_logs
    WHERE
        timestamp >= NOW() - INTERVAL '24 hours'
        AND (
            -- 级别过滤
            level IN ('ERROR', 'WARNING', 'FATAL')
            -- 关键词搜索
            OR message ~* 'timeout|connection.*failed|error|exception'
            -- 来源过滤
            OR source LIKE '%database%'
        )
)
SELECT
    log_category,
    COUNT(*) AS log_count,
    COUNT(*) FILTER (WHERE has_error_keywords) AS error_keyword_count,
    MIN(timestamp) AS first_occurrence,
    MAX(timestamp) AS last_occurrence
FROM log_search
GROUP BY log_category
ORDER BY log_count DESC;
```

---

## 8. 算法性能对比与优化

### 8.1 搜索方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
| ---- | ---------- | ---------- | -------- | ---- | ---- |
| **等值搜索** | $O(\log n)$ | $O(n)$ | 精确匹配 | 快速准确 | 需要索引 |
| **范围搜索** | $O(\log n)$ | $O(n)$ | 区间查询 | 支持范围 | 需要B-Tree索引 |
| **LIKE搜索** | $O(n)$ | $O(1)$ | 模式匹配 | 简单灵活 | 性能较差 |
| **全文搜索** | $O(\log n)$ | $O(n)$ | 文本搜索 | 相关性排序 | 需要GIN索引 |

### 8.2 性能优化建议

1. **索引优化**：
   - 创建适当的索引
   - 使用复合索引
   - 定期更新统计信息

2. **查询优化**：
   - 避免全表扫描
   - 使用索引提示
   - 优化WHERE子句顺序

3. **搜索优化**：
   - 使用Trigram索引加速LIKE
   - 使用GIN索引加速全文搜索
   - 限制结果集大小

### 8.3 常见问题与解决方案

**问题1**：搜索性能慢

- **解决方案**：创建索引、优化查询、使用分区表

**问题2**：LIKE搜索无法使用索引

- **解决方案**：使用Trigram索引、使用全文搜索、优化模式

**问题3**：全文搜索不准确

- **解决方案**：调整分词器、使用自定义词典、优化查询

**问题4**：多条件搜索复杂

- **解决方案**：使用组合索引、优化条件顺序、使用物化视图

---

## 9. 最佳实践

### 9.1 搜索策略选择

1. **精确搜索**：
   - 使用等值搜索
   - 创建B-Tree或Hash索引
   - 适合主键和外键

2. **范围搜索**：
   - 使用BETWEEN或比较运算符
   - 创建B-Tree索引
   - 适合数值和日期

3. **模式搜索**：
   - 使用LIKE或正则表达式
   - 创建Trigram索引
   - 适合文本搜索

4. **全文搜索**：
   - 使用tsvector和tsquery
   - 创建GIN索引
   - 适合文档搜索

### 9.2 搜索注意事项

1. **索引使用**：
   - 确保搜索列有索引
   - 避免函数索引
   - 定期更新统计信息

2. **查询优化**：
   - 优化WHERE子句顺序
   - 使用LIMIT限制结果
   - 避免不必要的排序

3. **性能监控**：
   - 使用EXPLAIN分析
   - 监控慢查询
   - 优化索引使用

### 9.3 SQL实现注意事项

1. **性能考虑**：
   - 创建适当索引
   - 优化查询计划
   - 使用分区表

2. **准确性**：
   - 处理NULL值
   - 注意数据类型
   - 验证搜索结果

3. **可维护性**：
   - 使用清晰的变量名
   - 添加注释
   - 模块化设计

---

## 📚 参考资源

### 学术文献

1. **《数据库系统概念》**（Silberschatz, A., et al., 2019）- 搜索算法

2. **《PostgreSQL即学即用》**（Obe, R., & Hsu, L., 2017）- PostgreSQL搜索

3. **《全文搜索引擎原理与实践》**（Lucene开发团队）- 全文搜索

### PostgreSQL官方文档

- **查询**: <https://www.postgresql.org/docs/current/tutorial-select.html>
- **索引**: <https://www.postgresql.org/docs/current/indexes.html>
- **全文搜索**: <https://www.postgresql.org/docs/current/textsearch.html>
- **模式匹配**: <https://www.postgresql.org/docs/current/functions-matching.html>

### 在线资源

- **搜索算法**: <https://en.wikipedia.org/wiki/Search_algorithm>
- **全文搜索**: <https://en.wikipedia.org/wiki/Full-text_search>
- **正则表达式**: <https://en.wikipedia.org/wiki/Regular_expression>

### 相关算法

- **查询优化算法**：搜索查询优化
- **索引算法**：搜索索引优化
- **排序算法**：搜索结果排序
- **聚合算法**：搜索结果聚合

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
