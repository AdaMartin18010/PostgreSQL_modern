# PostgreSQL 聚合算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 聚合算法 | 数据汇总
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 聚合算法完整指南](#postgresql-聚合算法完整指南)
  - [📋 目录](#-目录)
  - [聚合算法概述](#聚合算法概述)
    - [理论基础](#理论基础)
      - [聚合操作定义](#聚合操作定义)
      - [聚合函数分类](#聚合函数分类)
      - [聚合执行过程](#聚合执行过程)
    - [核心聚合函数](#核心聚合函数)
  - [1. 基础聚合函数](#1-基础聚合函数)
    - [1.1 基础聚合函数原理](#11-基础聚合函数原理)
      - [COUNT函数](#count函数)
      - [SUM函数](#sum函数)
      - [AVG函数](#avg函数)
      - [MIN/MAX函数](#minmax函数)
    - [1.2 COUNT聚合实现](#12-count聚合实现)
    - [1.2 SUM聚合](#12-sum聚合)
    - [1.3 统计聚合函数](#13-统计聚合函数)
    - [1.4 数组聚合函数](#14-数组聚合函数)
  - [2. 分组聚合](#2-分组聚合)
    - [2.1 分组聚合原理](#21-分组聚合原理)
      - [GROUP BY执行过程](#group-by执行过程)
      - [GROUP BY数学定义](#group-by数学定义)
    - [2.2 GROUP BY聚合实现](#22-group-by聚合实现)
    - [2.3 多列分组](#23-多列分组)
    - [2.4 HAVING子句](#24-having子句)
  - [3. 条件聚合](#3-条件聚合)
    - [3.1 条件聚合原理](#31-条件聚合原理)
      - [FILTER子句](#filter子句)
      - [CASE表达式](#case表达式)
    - [3.2 FILTER子句实现](#32-filter子句实现)
    - [3.3 多条件聚合](#33-多条件聚合)
    - [3.4 CASE表达式聚合](#34-case表达式聚合)
  - [4. 窗口聚合](#4-窗口聚合)
    - [4.1 窗口聚合原理](#41-窗口聚合原理)
      - [窗口函数语法](#窗口函数语法)
      - [窗口框架](#窗口框架)
    - [4.2 窗口函数聚合实现](#42-窗口函数聚合实现)
    - [4.3 分区聚合](#43-分区聚合)
  - [5. 高级聚合技术](#5-高级聚合技术)
    - [5.1 ROLLUP聚合](#51-rollup聚合)
    - [5.2 CUBE聚合](#52-cube聚合)
    - [5.3 GROUPING SETS](#53-grouping-sets)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 多维度聚合](#61-多维度聚合)
    - [6.2 销售报表聚合](#62-销售报表聚合)
    - [6.3 客户RFM分析](#63-客户rfm分析)
    - [6.4 时间序列聚合分析](#64-时间序列聚合分析)
  - [7. PostgreSQL 18并行聚合增强](#7-postgresql-18并行聚合增强)
    - [7.1 并行聚合概述](#71-并行聚合概述)
      - [并行聚合原理](#并行聚合原理)
      - [并行聚合条件](#并行聚合条件)
    - [7.2 并行聚合配置](#72-并行聚合配置)
    - [7.3 并行聚合实现示例](#73-并行聚合实现示例)
    - [7.4 并行聚合性能优化](#74-并行聚合性能优化)
  - [8. 算法性能对比与优化](#8-算法性能对比与优化)
    - [8.1 聚合方法对比](#81-聚合方法对比)
    - [8.2 性能优化建议](#82-性能优化建议)
    - [8.3 常见问题与解决方案](#83-常见问题与解决方案)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 聚合函数选择](#91-聚合函数选择)
    - [9.2 聚合注意事项](#92-聚合注意事项)
    - [9.3 SQL实现注意事项](#93-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 聚合算法概述

**聚合算法（Aggregation Algorithm）**用于对数据进行汇总统计，是数据库查询的核心操作之一。
PostgreSQL提供了丰富的聚合函数，支持多种聚合模式和优化策略。

### 理论基础

#### 聚合操作定义

**聚合操作（Aggregation）**是将一组值聚合成单个值的操作。聚合函数$f$将集合$S = \{x_1, x_2, \ldots, x_n\}$映射为单个值：
$$f(S) = y$$

#### 聚合函数分类

1. **标量聚合函数**：
   - 计数函数：`COUNT(*)`, `COUNT(DISTINCT column)`
   - 求和函数：`SUM(column)`
   - 平均函数：`AVG(column)`
   - 极值函数：`MIN(column)`, `MAX(column)`

2. **统计聚合函数**：
   - 标准差：`STDDEV(column)`, `STDDEV_POP(column)`, `STDDEV_SAMP(column)`
   - 方差：`VARIANCE(column)`, `VAR_POP(column)`, `VAR_SAMP(column)`
   - 分位数：`PERCENTILE_CONT(fraction)`, `PERCENTILE_DISC(fraction)`

3. **数组聚合函数**：
   - `ARRAY_AGG(column)`：聚合为数组
   - `STRING_AGG(column, delimiter)`：聚合为字符串

#### 聚合执行过程

1. **分组阶段**：根据`GROUP BY`子句分组
2. **过滤阶段**：应用`HAVING`子句过滤
3. **聚合阶段**：对每组应用聚合函数
4. **排序阶段**：根据`ORDER BY`排序

### 核心聚合函数

| 函数名称 | 用途 | 复杂度 | 数学表示 |
|---------|------|--------|---------|
| **COUNT()** | 计数 | $O(n)$ | $\|S\|$ |
| **SUM()** | 求和 | $O(n)$ | $\sum_{i=1}^{n}x_i$ |
| **AVG()** | 平均值 | $O(n)$ | $\bar{x} = \frac{1}{n}\sum_{i=1}^{n}x_i$ |
| **MIN()** | 最小值 | $O(n)$ | $\min(S)$ |
| **MAX()** | 最大值 | $O(n)$ | $\max(S)$ |
| **STDDEV()** | 标准差 | $O(n)$ | $\sigma = \sqrt{\frac{1}{n}\sum_{i=1}^{n}(x_i - \bar{x})^2}$ |
| **PERCENTILE_CONT()** | 百分位数 | $O(n \log n)$ | $P_p = \text{quantile}(S, p)$ |

---

## 1. 基础聚合函数

### 1.1 基础聚合函数原理

**基础聚合函数**是最常用的聚合函数，包括计数、求和、平均值、极值等。

#### COUNT函数

**COUNT函数**计算记录数量：

- `COUNT(*)`：计算所有行数（包括NULL）
- `COUNT(column)`：计算非NULL值的数量
- `COUNT(DISTINCT column)`：计算不同值的数量

#### SUM函数

**SUM函数**计算数值总和：
$$SUM(S) = \sum_{i=1}^{n}x_i$$

#### AVG函数

**AVG函数**计算平均值：
$$AVG(S) = \frac{1}{n}\sum_{i=1}^{n}x_i = \frac{SUM(S)}{COUNT(S)}$$

#### MIN/MAX函数

**MIN/MAX函数**计算极值：

- `MIN(S) = \min\{x_1, x_2, \ldots, x_n\}`
- `MAX(S) = \max\{x_1, x_2, \ldots, x_n\}`

### 1.2 COUNT聚合实现

```sql
-- COUNT聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行COUNT聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行COUNT聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'COUNT聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) AS total_orders,
    COUNT(DISTINCT customer_id) AS distinct_customers
FROM orders;
```

### 1.2 SUM聚合

**SUM聚合**用于计算数值总和。

```sql
-- SUM聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行SUM聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行SUM聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'SUM聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    SUM(amount) AS total_amount,
    SUM(quantity) AS total_quantity
FROM sales
WHERE amount IS NOT NULL;
```

---

### 1.3 统计聚合函数

**统计聚合函数**计算统计量。

```sql
-- 统计聚合函数：标准差、方差、分位数（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    category,
    COUNT(*) AS count,
    AVG(amount) AS avg_amount,
    STDDEV(amount) AS stddev_amount,
    VARIANCE(amount) AS variance_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    -- 中位数
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) AS median_amount,
    -- 四分位数
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1_amount,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3_amount
FROM sales
WHERE amount IS NOT NULL
GROUP BY category
ORDER BY avg_amount DESC;
```

### 1.4 数组聚合函数

**数组聚合函数**将多行聚合成数组或字符串。

```sql
-- 数组聚合函数：ARRAY_AGG和STRING_AGG（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    category,
    COUNT(*) AS product_count,
    -- 聚合为数组
    ARRAY_AGG(product_name ORDER BY amount DESC) AS top_products,
    -- 聚合为字符串
    STRING_AGG(product_name, ', ' ORDER BY amount DESC) AS product_list,
    -- 限制数组大小
    ARRAY_AGG(product_name ORDER BY amount DESC) FILTER (WHERE ROW_NUMBER() OVER (PARTITION BY category ORDER BY amount DESC) <= 5) AS top_5_products
FROM products
GROUP BY category
ORDER BY product_count DESC;
```

---

## 2. 分组聚合

### 2.1 分组聚合原理

**分组聚合（Grouped Aggregation）**使用`GROUP BY`子句将数据分组，然后对每组应用聚合函数。

#### GROUP BY执行过程

1. **分组阶段**：根据分组键将数据分组
2. **聚合阶段**：对每组应用聚合函数
3. **过滤阶段**：使用`HAVING`子句过滤组
4. **排序阶段**：使用`ORDER BY`排序结果

#### GROUP BY数学定义

对于分组键$G$和聚合函数$f$：
$$f(S) = \{f(S_g) : g \in G\}$$

其中$S_g$是键值为$g$的子集。

### 2.2 GROUP BY聚合实现

```sql
-- GROUP BY聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行GROUP BY聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行GROUP BY聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'GROUP BY聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount
FROM sales
GROUP BY category
ORDER BY total_amount DESC;
```

---

### 2.3 多列分组

**多列分组**使用多个列进行分组。

```sql
-- 多列分组：按多个维度分组（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    region,
    category,
    DATE_TRUNC('month', sale_date) AS sale_month,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    COUNT(DISTINCT customer_id) AS unique_customers
FROM sales
GROUP BY region, category, DATE_TRUNC('month', sale_date)
ORDER BY region, category, sale_month;
```

### 2.4 HAVING子句

**HAVING子句**过滤分组结果。

```sql
-- HAVING子句：过滤聚合结果（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    category,
    COUNT(*) AS product_count,
    AVG(price) AS avg_price,
    SUM(sales_count) AS total_sales
FROM products
GROUP BY category
HAVING COUNT(*) >= 10  -- 至少10个产品
   AND AVG(price) > 100  -- 平均价格大于100
ORDER BY total_sales DESC;
```

---

## 3. 条件聚合

### 3.1 条件聚合原理

**条件聚合（Conditional Aggregation）**只对满足条件的行进行聚合，可以使用`FILTER`子句或`CASE`表达式。

#### FILTER子句

**FILTER子句**语法：

```sql
AGGREGATE_FUNCTION(column) FILTER (WHERE condition)
```

#### CASE表达式

**CASE表达式**语法：

```sql
SUM(CASE WHEN condition THEN column ELSE 0 END)
```

### 3.2 FILTER子句实现

```sql
-- FILTER条件聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法执行FILTER聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行FILTER条件聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'FILTER聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) FILTER (WHERE status = 'completed') AS completed_count,
    SUM(amount) FILTER (WHERE status = 'completed') AS completed_amount,
    COUNT(*) FILTER (WHERE status = 'pending') AS pending_count,
    SUM(amount) FILTER (WHERE status = 'pending') AS pending_amount
FROM orders;
```

---

### 3.3 多条件聚合

**多条件聚合**使用多个FILTER子句。

```sql
-- 多条件聚合：使用多个FILTER子句
SELECT
    DATE_TRUNC('month', order_date) AS order_month,
    -- 不同状态的订单统计
    COUNT(*) FILTER (WHERE status = 'completed') AS completed_count,
    SUM(amount) FILTER (WHERE status = 'completed') AS completed_amount,
    COUNT(*) FILTER (WHERE status = 'pending') AS pending_count,
    SUM(amount) FILTER (WHERE status = 'pending') AS pending_amount,
    COUNT(*) FILTER (WHERE status = 'cancelled') AS cancelled_count,
    SUM(amount) FILTER (WHERE status = 'cancelled') AS cancelled_amount,
    -- 总统计
    COUNT(*) AS total_count,
    SUM(amount) AS total_amount,
    -- 完成率
    COUNT(*) FILTER (WHERE status = 'completed')::numeric / COUNT(*) * 100 AS completion_rate
FROM orders
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY order_month;
```

### 3.4 CASE表达式聚合

**CASE表达式**实现条件聚合。

```sql
-- CASE表达式聚合：实现条件聚合
SELECT
    customer_id,
    COUNT(*) AS total_orders,
    SUM(CASE WHEN amount > 1000 THEN 1 ELSE 0 END) AS high_value_orders,
    SUM(CASE WHEN amount > 1000 THEN amount ELSE 0 END) AS high_value_amount,
    AVG(CASE WHEN amount > 1000 THEN amount ELSE NULL END) AS avg_high_value_amount
FROM orders
GROUP BY customer_id
HAVING COUNT(*) >= 5
ORDER BY high_value_amount DESC;
```

---

## 4. 窗口聚合

### 4.1 窗口聚合原理

**窗口聚合（Window Aggregation）**使用窗口函数在窗口内进行聚合，不会将多行合并为一行。

#### 窗口函数语法

```sql
AGGREGATE_FUNCTION(column) OVER (
    [PARTITION BY partition_expression]
    [ORDER BY sort_expression]
    [frame_clause]
)
```

#### 窗口框架

**窗口框架**定义窗口范围：

- `ROWS BETWEEN n PRECEDING AND m FOLLOWING`
- `RANGE BETWEEN n PRECEDING AND m FOLLOWING`
- `GROUPS BETWEEN n PRECEDING AND m FOLLOWING`

### 4.2 窗口函数聚合实现

```sql
-- 窗口函数聚合（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行窗口聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行窗口函数聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '窗口聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    amount,
    SUM(amount) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_sum_7,
    AVG(amount) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg_7,
    SUM(amount) OVER (ORDER BY date) AS cumulative_sum
FROM (
    SELECT DATE_TRUNC('day', sale_date) AS date, SUM(amount) AS amount
    FROM sales
    GROUP BY DATE_TRUNC('day', sale_date)
) AS daily_sales
ORDER BY date;
```

---

### 4.3 分区聚合

**分区聚合**使用PARTITION BY分组。

```sql
-- 分区聚合：按分区进行聚合
SELECT
    customer_id,
    order_date,
    amount,
    -- 每个客户的累计金额
    SUM(amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS customer_cumulative,
    -- 每个客户的总金额
    SUM(amount) OVER (PARTITION BY customer_id) AS customer_total,
    -- 每个客户的平均金额
    AVG(amount) OVER (PARTITION BY customer_id) AS customer_avg,
    -- 每个客户的订单排名
    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date) AS order_rank
FROM orders
ORDER BY customer_id, order_date;
```

---

## 5. 高级聚合技术

### 5.1 ROLLUP聚合

**ROLLUP**生成层次汇总。

```sql
-- ROLLUP聚合：生成层次汇总
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
GROUP BY ROLLUP(region, category)
ORDER BY region NULLS LAST, category NULLS LAST;
```

### 5.2 CUBE聚合

**CUBE**生成所有可能的组合汇总。

```sql
-- CUBE聚合：生成所有组合汇总
SELECT
    region,
    category,
    DATE_TRUNC('month', sale_date) AS sale_month,
    COUNT(*) AS count,
    SUM(amount) AS total_amount
FROM sales
GROUP BY CUBE(region, category, DATE_TRUNC('month', sale_date))
ORDER BY region NULLS LAST, category NULLS LAST, sale_month NULLS LAST;
```

### 5.3 GROUPING SETS

**GROUPING SETS**指定多个分组集合。

```sql
-- GROUPING SETS：指定多个分组集合
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount
FROM sales
GROUP BY GROUPING SETS (
    (region),
    (category),
    (region, category),
    ()
)
ORDER BY region NULLS LAST, category NULLS LAST;
```

---

## 6. 实际应用案例

### 6.1 多维度聚合

**多维度聚合**使用ROLLUP进行层次汇总。

```sql
-- 多维度聚合ROLLUP（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING '表 sales 不存在，无法执行多维度聚合';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多维度聚合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '多维度聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    region,
    category,
    COUNT(*) AS count,
    SUM(amount) AS total_amount
FROM sales
GROUP BY ROLLUP(region, category)
ORDER BY region, category;
```

### 6.2 销售报表聚合

**场景**：生成多维度销售报表。

```sql
-- 销售报表聚合：多维度分析
WITH sales_summary AS (
    SELECT
        DATE_TRUNC('month', sale_date) AS sale_month,
        region,
        category,
        product_id,
        COUNT(*) AS order_count,
        SUM(amount) AS total_amount,
        AVG(amount) AS avg_amount,
        COUNT(DISTINCT customer_id) AS unique_customers
    FROM sales
    GROUP BY DATE_TRUNC('month', sale_date), region, category, product_id
),
monthly_summary AS (
    SELECT
        sale_month,
        COUNT(*) AS total_orders,
        SUM(total_amount) AS monthly_revenue,
        SUM(unique_customers) AS monthly_customers,
        AVG(avg_amount) AS avg_order_value
    FROM sales_summary
    GROUP BY sale_month
),
category_summary AS (
    SELECT
        category,
        COUNT(*) AS product_count,
        SUM(total_amount) AS category_revenue,
        AVG(avg_amount) AS category_avg_price
    FROM sales_summary
    GROUP BY category
)
SELECT
    '月度汇总' AS summary_type,
    sale_month::text AS dimension,
    total_orders AS metric_value
FROM monthly_summary
UNION ALL
SELECT
    '类别汇总' AS summary_type,
    category AS dimension,
    product_count AS metric_value
FROM category_summary
ORDER BY summary_type, dimension;
```

### 6.3 客户RFM分析

**场景**：使用聚合进行客户RFM分析。

```sql
-- 客户RFM分析：Recency, Frequency, Monetary
WITH customer_rfm AS (
    SELECT
        customer_id,
        -- Recency：最近购买时间（天数）
        EXTRACT(DAY FROM (NOW() - MAX(order_date))) AS recency_days,
        -- Frequency：购买频率（订单数）
        COUNT(*) AS frequency,
        -- Monetary：总消费金额
        SUM(amount) AS monetary
    FROM orders
    WHERE status = 'completed'
    GROUP BY customer_id
),
rfm_scores AS (
    SELECT
        customer_id,
        recency_days,
        frequency,
        monetary,
        -- RFM评分（1-5分）
        NTILE(5) OVER (ORDER BY recency_days DESC) AS r_score,  -- 最近购买时间越近分数越高
        NTILE(5) OVER (ORDER BY frequency) AS f_score,
        NTILE(5) OVER (ORDER BY monetary) AS m_score
    FROM customer_rfm
),
customer_segments AS (
    SELECT
        customer_id,
        r_score,
        f_score,
        m_score,
        r_score || f_score || m_score AS rfm_code,
        CASE
            WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN '重要价值客户'
            WHEN r_score >= 3 AND f_score >= 3 THEN '重要发展客户'
            WHEN r_score >= 4 AND f_score < 3 THEN '重要保持客户'
            WHEN r_score < 3 AND f_score >= 4 THEN '重要挽留客户'
            WHEN r_score >= 3 AND f_score < 3 AND m_score >= 3 THEN '一般价值客户'
            ELSE '一般客户'
        END AS customer_segment
    FROM rfm_scores
)
SELECT
    customer_segment,
    COUNT(*) AS customer_count,
    ROUND(AVG(r_score)::numeric, 2) AS avg_r_score,
    ROUND(AVG(f_score)::numeric, 2) AS avg_f_score,
    ROUND(AVG(m_score)::numeric, 2) AS avg_m_score,
    ROUND(SUM(monetary)::numeric, 2) AS total_revenue
FROM customer_segments cs
JOIN customer_rfm cr ON cs.customer_id = cr.customer_id
GROUP BY customer_segment
ORDER BY total_revenue DESC;
```

### 6.4 时间序列聚合分析

**场景**：对时间序列数据进行多粒度聚合。

```sql
-- 时间序列聚合分析：多粒度时间聚合
WITH time_series_data AS (
    SELECT
        timestamp,
        value,
        DATE_TRUNC('hour', timestamp) AS hour,
        DATE_TRUNC('day', timestamp) AS day,
        DATE_TRUNC('week', timestamp) AS week,
        DATE_TRUNC('month', timestamp) AS month
    FROM metrics
    WHERE timestamp >= NOW() - INTERVAL '30 days'
),
multi_granularity_agg AS (
    SELECT
        'hour' AS granularity,
        hour AS time_period,
        COUNT(*) AS data_points,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        STDDEV(value) AS stddev_value
    FROM time_series_data
    GROUP BY hour

    UNION ALL

    SELECT
        'day' AS granularity,
        day AS time_period,
        COUNT(*) AS data_points,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        STDDEV(value) AS stddev_value
    FROM time_series_data
    GROUP BY day

    UNION ALL

    SELECT
        'week' AS granularity,
        week AS time_period,
        COUNT(*) AS data_points,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        STDDEV(value) AS stddev_value
    FROM time_series_data
    GROUP BY week

    UNION ALL

    SELECT
        'month' AS granularity,
        month AS time_period,
        COUNT(*) AS data_points,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        STDDEV(value) AS stddev_value
    FROM time_series_data
    GROUP BY month
)
SELECT
    granularity,
    time_period,
    data_points,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(min_value::numeric, 2) AS min_value,
    ROUND(max_value::numeric, 2) AS max_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM multi_granularity_agg
ORDER BY granularity, time_period;
```

---

## 7. PostgreSQL 18并行聚合增强

### 7.1 并行聚合概述

**PostgreSQL 18并行聚合增强**：PostgreSQL 18对并行查询进行了重大改进，特别是在聚合操作方面，可以显著提升大规模数据聚合的性能。

#### 并行聚合原理

**并行聚合（Parallel Aggregation）**：将聚合操作分布到多个工作进程并行执行，最后合并结果。

**并行聚合优势**：

- 充分利用多核CPU资源
- 大幅提升大规模数据聚合性能
- 支持多种聚合函数并行执行

#### 并行聚合条件

PostgreSQL会自动选择并行聚合，需要满足以下条件：

1. **数据量足够大**：通常需要超过`min_parallel_table_scan_size`阈值
2. **聚合函数支持并行**：大多数聚合函数都支持并行
3. **系统资源充足**：有足够的并行工作进程可用

### 7.2 并行聚合配置

**配置并行参数**：

```sql
-- 配置并行查询参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数（建议为CPU核心数）
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值（默认8MB）
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行索引扫描阈值（默认512KB）
        SET min_parallel_index_scan_size = '512KB';

        RAISE NOTICE '并行查询参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行查询配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 7.3 并行聚合实现示例

**大规模数据并行聚合**：

```sql
-- 并行聚合：大规模销售数据统计（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行聚合查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行聚合准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行聚合查询：按地区和产品类别统计销售
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    region,
    product_category,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    STDDEV(amount) AS stddev_amount
FROM sales_orders
WHERE order_date >= CURRENT_DATE - INTERVAL '1 year'
GROUP BY region, product_category
HAVING COUNT(*) > 100
ORDER BY total_amount DESC;
```

**并行窗口聚合**：

```sql
-- 并行窗口聚合：计算移动平均（PostgreSQL 18+）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    date,
    region,
    sales_amount,
    AVG(sales_amount) OVER (
        PARTITION BY region
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7days,
    SUM(sales_amount) OVER (
        PARTITION BY region
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS moving_sum_30days
FROM daily_sales
WHERE date >= CURRENT_DATE - INTERVAL '90 days'
ORDER BY region, date;
```

### 7.4 并行聚合性能优化

**优化建议**：

1. **索引优化**：
   - 在分组列上创建索引
   - 使用复合索引覆盖查询

2. **分区优化**：
   - 使用分区表提高并行度
   - 分区裁剪减少扫描数据量

3. **参数调优**：
   - 根据数据量调整`min_parallel_table_scan_size`
   - 根据CPU核心数设置`max_parallel_workers_per_gather`

**性能对比示例**：

```sql
-- 性能对比：串行 vs 并行聚合
-- 串行聚合（禁用并行）
SET max_parallel_workers_per_gather = 0;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT region, COUNT(*), SUM(amount)
FROM sales_orders
GROUP BY region;

-- 并行聚合（启用并行，4个工作进程）
SET max_parallel_workers_per_gather = 4;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT region, COUNT(*), SUM(amount)
FROM sales_orders
GROUP BY region;
```

---

## 8. 算法性能对比与优化

### 8.1 聚合方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|-----------|-----------|---------|------|------|
| **基础聚合** | $O(n)$ | $O(1)$ | 简单统计 | 简单快速 | 功能有限 |
| **分组聚合** | $O(n \log n)$ | $O(k)$ | 分组统计 | 功能强大 | 需要排序 |
| **窗口聚合** | $O(n \log n)$ | $O(n)$ | 窗口统计 | 保留原行 | 计算复杂 |
| **ROLLUP/CUBE** | $O(nk)$ | $O(k)$ | 多维汇总 | 多维度 | 结果量大 |

### 8.2 性能优化建议

1. **计算优化**：
   - 使用索引加速分组
   - 避免不必要的排序
   - 使用物化视图

2. **查询优化**：
   - 限制数据范围
   - 使用分区表
   - 并行聚合

3. **算法优化**：
   - 使用哈希聚合
   - 增量聚合
   - 采样计算

### 8.3 常见问题与解决方案

**问题1**：聚合性能慢

- **解决方案**：创建索引、使用分区表、优化GROUP BY

**问题2**：NULL值处理

- **解决方案**：使用COALESCE、FILTER子句、明确NULL处理

**问题3**：内存不足

- **解决方案**：限制分组数量、使用磁盘排序、分批处理

**问题4**：结果不准确

- **解决方案**：检查数据类型、处理NULL值、验证计算逻辑

---

## 9. 最佳实践

### 9.1 聚合函数选择

1. **统计需求**：
   - 计数：使用COUNT
   - 求和：使用SUM
   - 平均值：使用AVG
   - 极值：使用MIN/MAX

2. **分组需求**：
   - 简单分组：使用GROUP BY
   - 层次汇总：使用ROLLUP
   - 多维汇总：使用CUBE
   - 自定义组合：使用GROUPING SETS

3. **窗口需求**：
   - 移动窗口：使用ROWS框架
   - 值域窗口：使用RANGE框架
   - 组窗口：使用GROUPS框架

### 9.2 聚合注意事项

1. **NULL值处理**：
   - COUNT(*)包含NULL
   - COUNT(column)排除NULL
   - SUM/AVG排除NULL
   - 使用COALESCE处理NULL

2. **数据类型**：
   - 注意数值精度
   - 避免溢出
   - 使用适当的数据类型

3. **性能考虑**：
   - 创建分组列索引
   - 使用分区表
   - 限制结果集大小

### 9.3 SQL实现注意事项

1. **性能考虑**：
   - 优化GROUP BY
   - 使用索引
   - 避免不必要的排序

2. **准确性**：
   - 处理NULL值
   - 验证计算结果
   - 注意数据类型

3. **可维护性**：
   - 使用清晰的别名
   - 添加注释
   - 模块化设计

---

## 📚 参考资源

### 学术文献

1. **《数据库系统概念》**（Silberschatz, A., et al., 2019）- 聚合查询

2. **《SQL权威指南》**（Groff, J. R., et al., 2008）- SQL聚合函数

3. **《PostgreSQL即学即用》**（Obe, R., & Hsu, L., 2017）- PostgreSQL聚合

### PostgreSQL官方文档

- **聚合函数**: <https://www.postgresql.org/docs/current/functions-aggregate.html>
- **窗口函数**: <https://www.postgresql.org/docs/current/tutorial-window.html>
- **GROUP BY**: <https://www.postgresql.org/docs/current/sql-select.html#SQL-GROUPBY>

### 在线资源

- **SQL聚合**: <https://en.wikipedia.org/wiki/Aggregate_function>
- **GROUP BY**: <https://en.wikipedia.org/wiki/Group_by_(SQL)>
- **窗口函数**: <https://en.wikipedia.org/wiki/Window_function_(SQL)>

### 相关算法

- **分组统计分析**：分组聚合应用
- **窗口函数统计**：窗口聚合应用
- **聚合统计分析**：统计聚合应用
- **时间序列聚合**：时间聚合应用

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成
