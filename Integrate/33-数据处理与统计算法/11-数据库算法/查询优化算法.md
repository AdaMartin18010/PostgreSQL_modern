# PostgreSQL æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æŸ¥è¯¢ä¼˜åŒ– | æ‰§è¡Œè®¡åˆ’
> **éš¾åº¦çº§åˆ«**: â­â­â­â­â­ (ä¸“å®¶çº§)

---

## ðŸ“‹ ç›®å½•

- [PostgreSQL æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ðŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æŸ¥è¯¢ä¼˜åŒ–æ¦‚è¿°](#æŸ¥è¯¢ä¼˜åŒ–æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æŸ¥è¯¢ä¼˜åŒ–å™¨æž¶æž„](#æŸ¥è¯¢ä¼˜åŒ–å™¨æž¶æž„)
      - [æˆæœ¬æ¨¡åž‹](#æˆæœ¬æ¨¡åž‹)
      - [ä¼˜åŒ–ç­–ç•¥](#ä¼˜åŒ–ç­–ç•¥)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. æŸ¥è¯¢è®¡åˆ’åˆ†æž](#1-æŸ¥è¯¢è®¡åˆ’åˆ†æž)
    - [1.1 æ‰§è¡Œè®¡åˆ’ç»“æž„](#11-æ‰§è¡Œè®¡åˆ’ç»“æž„)
      - [è®¡åˆ’èŠ‚ç‚¹ç±»åž‹](#è®¡åˆ’èŠ‚ç‚¹ç±»åž‹)
      - [EXPLAINè¾“å‡ºè§£è¯»](#explainè¾“å‡ºè§£è¯»)
    - [1.2 æ‰§è¡Œè®¡åˆ’ç»Ÿè®¡](#12-æ‰§è¡Œè®¡åˆ’ç»Ÿè®¡)
  - [2. æŸ¥è¯¢é‡å†™](#2-æŸ¥è¯¢é‡å†™)
    - [2.1 æŸ¥è¯¢é‡å†™è§„åˆ™](#21-æŸ¥è¯¢é‡å†™è§„åˆ™)
      - [å¸¸è§é‡å†™è§„åˆ™](#å¸¸è§é‡å†™è§„åˆ™)
    - [2.2 æŸ¥è¯¢ç®€åŒ–å®žçŽ°](#22-æŸ¥è¯¢ç®€åŒ–å®žçŽ°)
  - [3. æˆæœ¬ä¼°ç®—](#3-æˆæœ¬ä¼°ç®—)
    - [3.1 æˆæœ¬ä¼°ç®—åŽŸç†](#31-æˆæœ¬ä¼°ç®—åŽŸç†)
      - [æ‰«ææˆæœ¬](#æ‰«ææˆæœ¬)
      - [è¿žæŽ¥æˆæœ¬](#è¿žæŽ¥æˆæœ¬)
      - [é€‰æ‹©æ€§ä¼°ç®—](#é€‰æ‹©æ€§ä¼°ç®—)
    - [3.2 æŸ¥è¯¢æˆæœ¬åˆ†æžå®žçŽ°](#32-æŸ¥è¯¢æˆæœ¬åˆ†æžå®žçŽ°)
  - [4. è¿žæŽ¥é¡ºåºä¼˜åŒ–](#4-è¿žæŽ¥é¡ºåºä¼˜åŒ–)
    - [4.1 è¿žæŽ¥é¡ºåºé—®é¢˜](#41-è¿žæŽ¥é¡ºåºé—®é¢˜)
      - [é—®é¢˜å®šä¹‰](#é—®é¢˜å®šä¹‰)
      - [è¿žæŽ¥é¡ºåºé€‰æ‹©ç­–ç•¥](#è¿žæŽ¥é¡ºåºé€‰æ‹©ç­–ç•¥)
    - [4.2 ç´¢å¼•é€‰æ‹©ä¼˜åŒ–](#42-ç´¢å¼•é€‰æ‹©ä¼˜åŒ–)
      - [ç´¢å¼•é€‰æ‹©åŽŸåˆ™](#ç´¢å¼•é€‰æ‹©åŽŸåˆ™)
      - [ç´¢å¼•ä½¿ç”¨æ¡ä»¶](#ç´¢å¼•ä½¿ç”¨æ¡ä»¶)
  - [5. PostgreSQL 18 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–å¢žå¼º](#5-postgresql-18-å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–å¢žå¼º)
    - [5.1 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–åŽŸç†](#51-å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–åŽŸç†)
    - [5.2 å¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ](#52-å¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ)
    - [5.3 å¹¶è¡ŒèšåˆæŸ¥è¯¢ä¼˜åŒ–](#53-å¹¶è¡ŒèšåˆæŸ¥è¯¢ä¼˜åŒ–)
    - [5.4 å¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–](#54-å¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–)
  - [6. å®žé™…åº”ç”¨æ¡ˆä¾‹](#6-å®žé™…åº”ç”¨æ¡ˆä¾‹)
    - [6.1 æ…¢æŸ¥è¯¢ä¼˜åŒ–](#61-æ…¢æŸ¥è¯¢ä¼˜åŒ–)
  - [ðŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ðŸŽ¯ æœ€ä½³å®žè·µ](#-æœ€ä½³å®žè·µ)
    - [7.1 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢žå¼ºï¼‰](#71-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢žå¼º)
    - [7.2 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢žå¼ºï¼‰](#72-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢žå¼º)

---

## æŸ¥è¯¢ä¼˜åŒ–æ¦‚è¿°

**æŸ¥è¯¢ä¼˜åŒ–ï¼ˆQuery Optimizationï¼‰**æ˜¯æ•°æ®åº“ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£å°†ç”¨æˆ·æäº¤çš„SQLæŸ¥è¯¢è½¬æ¢ä¸ºé«˜æ•ˆçš„æ‰§è¡Œè®¡åˆ’ã€‚
PostgreSQLä½¿ç”¨åŸºäºŽæˆæœ¬çš„æŸ¥è¯¢ä¼˜åŒ–å™¨ï¼ˆCost-Based Optimizerï¼‰ï¼Œé€šè¿‡è¯„ä¼°ä¸åŒæ‰§è¡Œè®¡åˆ’çš„æˆæœ¬æ¥é€‰æ‹©æœ€ä¼˜æ–¹æ¡ˆã€‚

### ç†è®ºåŸºç¡€

#### æŸ¥è¯¢ä¼˜åŒ–å™¨æž¶æž„

PostgreSQLæŸ¥è¯¢ä¼˜åŒ–å™¨çš„å·¥ä½œæµç¨‹ï¼š

1. **æŸ¥è¯¢è§£æžï¼ˆParsingï¼‰**ï¼šå°†SQLæ–‡æœ¬è§£æžä¸ºæŸ¥è¯¢æ ‘ï¼ˆQuery Treeï¼‰
2. **æŸ¥è¯¢é‡å†™ï¼ˆRewritingï¼‰**ï¼šåº”ç”¨é‡å†™è§„åˆ™ä¼˜åŒ–æŸ¥è¯¢ç»“æž„
3. **è®¡åˆ’ç”Ÿæˆï¼ˆPlanningï¼‰**ï¼šç”Ÿæˆå€™é€‰æ‰§è¡Œè®¡åˆ’
4. **æˆæœ¬ä¼°ç®—ï¼ˆCost Estimationï¼‰**ï¼šä¼°ç®—æ¯ä¸ªè®¡åˆ’çš„æ‰§è¡Œæˆæœ¬
5. **è®¡åˆ’é€‰æ‹©ï¼ˆPlan Selectionï¼‰**ï¼šé€‰æ‹©æˆæœ¬æœ€ä½Žçš„æ‰§è¡Œè®¡åˆ’

#### æˆæœ¬æ¨¡åž‹

PostgreSQLä½¿ç”¨ä»¥ä¸‹æˆæœ¬å‚æ•°ï¼š

- **seq_page_cost**ï¼šé¡ºåºæ‰«æä¸€é¡µçš„æˆæœ¬ï¼ˆé»˜è®¤1.0ï¼‰
- **random_page_cost**ï¼šéšæœºè®¿é—®ä¸€é¡µçš„æˆæœ¬ï¼ˆé»˜è®¤4.0ï¼‰
- **cpu_tuple_cost**ï¼šå¤„ç†ä¸€ä¸ªå…ƒç»„çš„CPUæˆæœ¬ï¼ˆé»˜è®¤0.01ï¼‰
- **cpu_index_tuple_cost**ï¼šå¤„ç†ä¸€ä¸ªç´¢å¼•å…ƒç»„çš„CPUæˆæœ¬ï¼ˆé»˜è®¤0.005ï¼‰
- **cpu_operator_cost**ï¼šæ‰§è¡Œä¸€ä¸ªæ“ä½œç¬¦çš„CPUæˆæœ¬ï¼ˆé»˜è®¤0.0025ï¼‰

**æ€»æˆæœ¬å…¬å¼**ï¼š
$$Cost = (pages\_read \times page\_cost) + (tuples\_processed \times cpu\_cost)$$

#### ä¼˜åŒ–ç­–ç•¥

1. **åŸºäºŽè§„åˆ™ä¼˜åŒ–ï¼ˆRBOï¼‰**ï¼šåº”ç”¨é¢„å®šä¹‰çš„ä¼˜åŒ–è§„åˆ™
2. **åŸºäºŽæˆæœ¬ä¼˜åŒ–ï¼ˆCBOï¼‰**ï¼šè¯„ä¼°ä¸åŒè®¡åˆ’çš„æˆæœ¬
3. **åŠ¨æ€è§„åˆ’**ï¼šä½¿ç”¨åŠ¨æ€è§„åˆ’é¿å…é‡å¤è®¡ç®—
4. **å¯å‘å¼å‰ªæž**ï¼šä½¿ç”¨å¯å‘å¼æ–¹æ³•å‡å°‘æœç´¢ç©ºé—´

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ | è¯´æ˜Ž |
|------|------|--------|------|
| **è®¡åˆ’æžšä¸¾** | ç”Ÿæˆæ‰§è¡Œè®¡åˆ’ | $O(n!)$ | ç†è®ºä¸Šï¼Œå®žé™…ä½¿ç”¨å‰ªæž |
| **åŠ¨æ€è§„åˆ’** | é¿å…é‡å¤è®¡ç®— | $O(2^n)$ | ä¼˜åŒ–è®¡åˆ’æžšä¸¾ |
| **æˆæœ¬ä¼°ç®—** | è¯„ä¼°è®¡åˆ’æˆæœ¬ | $O(n)$ | åŸºäºŽç»Ÿè®¡ä¿¡æ¯ |
| **æŸ¥è¯¢é‡å†™** | ä¼˜åŒ–æŸ¥è¯¢ç»“æž„ | $O(n)$ | åº”ç”¨é‡å†™è§„åˆ™ |
| **è¿žæŽ¥é¡ºåºä¼˜åŒ–** | ä¼˜åŒ–JOINé¡ºåº | $O(n!)$ | ä½¿ç”¨åŠ¨æ€è§„åˆ’å‰ªæž |
| **ç´¢å¼•é€‰æ‹©** | é€‰æ‹©æœ€ä¼˜ç´¢å¼• | $O(m)$ | $m$æ˜¯ç´¢å¼•æ•°é‡ |

---

## 1. æŸ¥è¯¢è®¡åˆ’åˆ†æž

### 1.1 æ‰§è¡Œè®¡åˆ’ç»“æž„

PostgreSQLçš„æ‰§è¡Œè®¡åˆ’æ˜¯ä¸€ä¸ªæ ‘å½¢ç»“æž„ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªæ“ä½œï¼ˆå¦‚æ‰«æã€è¿žæŽ¥ã€æŽ’åºç­‰ï¼‰ã€‚

#### è®¡åˆ’èŠ‚ç‚¹ç±»åž‹

1. **æ‰«æèŠ‚ç‚¹ï¼ˆScan Nodesï¼‰**ï¼š
   - **Seq Scan**ï¼šé¡ºåºæ‰«æ
   - **Index Scan**ï¼šç´¢å¼•æ‰«æ
   - **Index Only Scan**ï¼šä»…ç´¢å¼•æ‰«æ
   - **Bitmap Heap Scan**ï¼šä½å›¾å †æ‰«æ

2. **è¿žæŽ¥èŠ‚ç‚¹ï¼ˆJoin Nodesï¼‰**ï¼š
   - **Nested Loop Join**ï¼šåµŒå¥—å¾ªçŽ¯è¿žæŽ¥
   - **Hash Join**ï¼šå“ˆå¸Œè¿žæŽ¥
   - **Merge Join**ï¼šå½’å¹¶è¿žæŽ¥

3. **æŽ’åºèŠ‚ç‚¹ï¼ˆSort Nodesï¼‰**ï¼š
   - **Sort**ï¼šæŽ’åºæ“ä½œ
   - **Limit**ï¼šé™åˆ¶ç»“æžœæ•°é‡

4. **èšåˆèŠ‚ç‚¹ï¼ˆAggregate Nodesï¼‰**ï¼š
   - **Aggregate**ï¼šèšåˆæ“ä½œ
   - **Group Aggregate**ï¼šåˆ†ç»„èšåˆ

#### EXPLAINè¾“å‡ºè§£è¯»

**å…³é”®å­—æ®µ**ï¼š

- **cost**ï¼šé¢„ä¼°æˆæœ¬ï¼ˆå¯åŠ¨æˆæœ¬..æ€»æˆæœ¬ï¼‰
- **rows**ï¼šé¢„ä¼°è¿”å›žè¡Œæ•°
- **width**ï¼šé¢„ä¼°è¡Œå®½åº¦ï¼ˆå­—èŠ‚ï¼‰
- **actual time**ï¼šå®žé™…æ‰§è¡Œæ—¶é—´ï¼ˆå¯åŠ¨æ—¶é—´..æ€»æ—¶é—´ï¼‰
- **actual rows**ï¼šå®žé™…è¿”å›žè¡Œæ•°
- **buffers**ï¼šç¼“å†²åŒºä½¿ç”¨æƒ…å†µ

### 1.2 æ‰§è¡Œè®¡åˆ’ç»Ÿè®¡

```sql
-- åˆ›å»ºæŸ¥è¯¢è®¡åˆ’ç»Ÿè®¡è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING 'è¡¨ query_plan_stats å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE query_plan_stats CASCADE;
        END IF;

        CREATE TABLE query_plan_stats (
            query_id VARCHAR(100) PRIMARY KEY,
            query_text TEXT NOT NULL,
            execution_time_ms NUMERIC(10, 2) NOT NULL,
            plan_rows BIGINT NOT NULL,
            plan_width INTEGER NOT NULL,
            total_cost NUMERIC(10, 2) NOT NULL,
            actual_rows BIGINT,
            actual_time_ms NUMERIC(10, 2)
        );

        INSERT INTO query_plan_stats (query_id, query_text, execution_time_ms, plan_rows, plan_width, total_cost, actual_rows, actual_time_ms) VALUES
            ('Q001', 'SELECT * FROM users WHERE email = $1', 125.5, 1, 200, 25.5, 1, 120.3),
            ('Q002', 'SELECT * FROM orders WHERE date > $1', 2500.0, 10000, 300, 500.0, 50000, 2800.0),
            ('Q003', 'SELECT COUNT(*) FROM products', 50.2, 1, 4, 10.2, 1, 45.8);

        RAISE NOTICE 'è¡¨ query_plan_stats åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ query_plan_stats å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æ‰§è¡Œè®¡åˆ’åˆ†æžï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING 'è¡¨ query_plan_stats ä¸å­˜åœ¨ï¼Œæ— æ³•åˆ†æžæ‰§è¡Œè®¡åˆ’';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹åˆ†æžæ‰§è¡Œè®¡åˆ’';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ‰§è¡Œè®¡åˆ’åˆ†æžå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åˆ†æžæŸ¥è¯¢è®¡åˆ’å‡†ç¡®æ€§
SELECT
    query_id,
    LEFT(query_text, 50) AS query_preview,
    plan_rows AS estimated_rows,
    actual_rows,
    CASE
        WHEN actual_rows = 0 THEN NULL
        ELSE ROUND(ABS(plan_rows - actual_rows)::numeric / NULLIF(actual_rows, 0), 4)
    END AS estimation_error,
    total_cost AS estimated_cost,
    actual_time_ms,
    CASE
        WHEN actual_rows IS NULL OR actual_rows = 0 THEN 'No data'
        WHEN ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 10 THEN 'Poor estimation'
        WHEN ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 2 THEN 'Moderate estimation'
        ELSE 'Good estimation'
    END AS estimation_quality,
    CASE
        WHEN actual_time_ms > 1000 THEN 'Slow query'
        WHEN actual_time_ms > 100 THEN 'Moderate'
        ELSE 'Fast'
    END AS performance_category
FROM query_plan_stats
ORDER BY actual_time_ms DESC NULLS LAST;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    query_id,
    AVG(execution_time_ms) AS avg_execution_time
FROM query_plan_stats
GROUP BY query_id;
```

---

## 2. æŸ¥è¯¢é‡å†™

### 2.1 æŸ¥è¯¢é‡å†™è§„åˆ™

**æŸ¥è¯¢é‡å†™ï¼ˆQuery Rewritingï¼‰**åœ¨è®¡åˆ’ç”Ÿæˆä¹‹å‰ä¼˜åŒ–æŸ¥è¯¢ç»“æž„ï¼Œåº”ç”¨å„ç§é‡å†™è§„åˆ™ã€‚

#### å¸¸è§é‡å†™è§„åˆ™

1. **å¸¸é‡æŠ˜å ï¼ˆConstant Foldingï¼‰**ï¼š
   - `WHERE x > 5 + 3` â†’ `WHERE x > 8`
   - åœ¨ç¼–è¯‘æ—¶è®¡ç®—å¸¸é‡è¡¨è¾¾å¼

2. **è°“è¯ä¸‹æŽ¨ï¼ˆPredicate Pushdownï¼‰**ï¼š
   - å°†WHEREæ¡ä»¶å°½å¯èƒ½ä¸‹æŽ¨åˆ°å­æŸ¥è¯¢
   - å‡å°‘éœ€è¦å¤„ç†çš„æ•°æ®é‡

3. **å­æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - **EXISTSä¼˜åŒ–**ï¼šå°†ç›¸å…³å­æŸ¥è¯¢è½¬æ¢ä¸ºEXISTS
   - **INä¼˜åŒ–**ï¼šå°†INè½¬æ¢ä¸ºJOINæˆ–EXISTS
   - **æ ‡é‡å­æŸ¥è¯¢ä¼˜åŒ–**ï¼šå°†æ ‡é‡å­æŸ¥è¯¢è½¬æ¢ä¸ºJOIN

4. **JOINé¡ºåºä¼˜åŒ–**ï¼š
   - é‡æ–°æŽ’åˆ—JOINé¡ºåº
   - å°†é€‰æ‹©æ€§é«˜çš„æ¡ä»¶æ”¾åœ¨å‰é¢

5. **æŠ•å½±ä¸‹æŽ¨ï¼ˆProjection Pushdownï¼‰**ï¼š
   - åªé€‰æ‹©éœ€è¦çš„åˆ—
   - å‡å°‘æ•°æ®ä¼ è¾“é‡

6. **åŽ»é‡ä¼˜åŒ–**ï¼š
   - `DISTINCT` + `ORDER BY` ä¼˜åŒ–
   - ä½¿ç”¨ç´¢å¼•é¿å…æŽ’åº

### 2.2 æŸ¥è¯¢ç®€åŒ–å®žçŽ°

```sql
-- æŸ¥è¯¢é‡å†™å»ºè®®ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING 'è¡¨ query_plan_stats ä¸å­˜åœ¨ï¼Œæ— æ³•ç”ŸæˆæŸ¥è¯¢é‡å†™å»ºè®®';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹ç”ŸæˆæŸ¥è¯¢é‡å†™å»ºè®®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢é‡å†™å»ºè®®ç”Ÿæˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è¯†åˆ«å¯ä¼˜åŒ–çš„æŸ¥è¯¢æ¨¡å¼
WITH query_patterns AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        CASE
            WHEN query_text LIKE '%SELECT *%' THEN 'Avoid SELECT *'
            WHEN query_text LIKE '%LIKE ''%''%' THEN 'Consider full-text search'
            WHEN query_text LIKE '%NOT IN%' THEN 'Consider NOT EXISTS'
            WHEN query_text LIKE '%OR%' AND execution_time_ms > 500 THEN 'Consider UNION'
            ELSE NULL
        END AS optimization_pattern,
        CASE
            WHEN plan_rows::numeric / NULLIF(actual_rows, 0) > 10 OR
                 actual_rows::numeric / NULLIF(plan_rows, 0) > 10 THEN TRUE
            ELSE FALSE
        END AS needs_statistics_update
    FROM query_plan_stats
)
SELECT
    query_id,
    LEFT(query_text, 60) AS query_preview,
    execution_time_ms,
    optimization_pattern,
    needs_statistics_update,
    CASE
        WHEN optimization_pattern IS NOT NULL THEN 'Rewrite recommended'
        WHEN needs_statistics_update THEN 'Update statistics'
        ELSE 'No optimization needed'
    END AS recommendation
FROM query_patterns
WHERE optimization_pattern IS NOT NULL OR needs_statistics_update
ORDER BY execution_time_ms DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) FILTER (WHERE query_text LIKE '%SELECT *%') AS select_star_queries,
    COUNT(*) FILTER (WHERE execution_time_ms > 1000) AS slow_queries
FROM query_plan_stats;
```

---

## 3. æˆæœ¬ä¼°ç®—

### 3.1 æˆæœ¬ä¼°ç®—åŽŸç†

**æˆæœ¬ä¼°ç®—ï¼ˆCost Estimationï¼‰**æ˜¯æŸ¥è¯¢ä¼˜åŒ–å™¨çš„æ ¸å¿ƒï¼Œéœ€è¦å‡†ç¡®ä¼°ç®—ä¸åŒæ‰§è¡Œè®¡åˆ’çš„æˆæœ¬ã€‚

#### æ‰«ææˆæœ¬

**é¡ºåºæ‰«ææˆæœ¬**ï¼š
$$Cost_{seq} = pages \times seq\_page\_cost + tuples \times cpu\_tuple\_cost$$

**ç´¢å¼•æ‰«ææˆæœ¬**ï¼š
$$Cost_{index} = index\_pages \times random\_page\_cost + tuples \times cpu\_index\_tuple\_cost + heap\_pages \times random\_page\_cost$$

#### è¿žæŽ¥æˆæœ¬

**åµŒå¥—å¾ªçŽ¯è¿žæŽ¥**ï¼š
$$Cost_{nested\_loop} = Cost_{outer} + rows_{outer} \times Cost_{inner}$$

**å“ˆå¸Œè¿žæŽ¥**ï¼š
$$Cost_{hash\_join} = Cost_{outer} + Cost_{inner} + Cost_{hash\_build} + Cost_{hash\_probe}$$

**å½’å¹¶è¿žæŽ¥**ï¼š
$$Cost_{merge\_join} = Cost_{outer} + Cost_{inner} + Cost_{sort\_outer} + Cost_{sort\_inner}$$

#### é€‰æ‹©æ€§ä¼°ç®—

**é€‰æ‹©æ€§ï¼ˆSelectivityï¼‰**ï¼šæ»¡è¶³æ¡ä»¶çš„è¡Œæ•°å æ€»è¡Œæ•°çš„æ¯”ä¾‹

**ç­‰å€¼æ¡ä»¶é€‰æ‹©æ€§**ï¼š
$$sel = \frac{1}{distinct\_values}$$

**èŒƒå›´æ¡ä»¶é€‰æ‹©æ€§**ï¼š
$$sel = \frac{high\_key - constant}{high\_key - low\_key}$$

**å¤šæ¡ä»¶ç»„åˆ**ï¼š

- **ANDæ¡ä»¶**ï¼š$sel_{and} = sel_1 \times sel_2 \times ...$
- **ORæ¡ä»¶**ï¼š$sel_{or} = sel_1 + sel_2 - sel_1 \times sel_2$

### 3.2 æŸ¥è¯¢æˆæœ¬åˆ†æžå®žçŽ°

```sql
-- æŸ¥è¯¢æˆæœ¬åˆ†æžï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING 'è¡¨ query_plan_stats ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œæˆæœ¬åˆ†æž';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡ŒæŸ¥è¯¢æˆæœ¬åˆ†æž';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŸ¥è¯¢æˆæœ¬åˆ†æžå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åˆ†æžæŸ¥è¯¢æˆæœ¬
SELECT
    query_id,
    LEFT(query_text, 50) AS query_preview,
    total_cost AS estimated_cost,
    actual_time_ms,
    plan_rows AS estimated_rows,
    actual_rows,
    CASE
        WHEN actual_rows = 0 THEN NULL
        ELSE ROUND((total_cost / NULLIF(actual_rows, 0))::numeric, 4)
    END AS cost_per_row,
    CASE
        WHEN actual_time_ms > 1000 THEN 'High cost'
        WHEN actual_time_ms > 100 THEN 'Medium cost'
        ELSE 'Low cost'
    END AS cost_category,
    CASE
        WHEN actual_rows IS NOT NULL AND ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 5 THEN
            'Consider ANALYZE to update statistics'
        WHEN actual_time_ms > 1000 THEN
            'Consider query optimization or indexing'
        ELSE 'Query is efficient'
    END AS optimization_suggestion
FROM query_plan_stats
ORDER BY actual_time_ms DESC NULLS LAST;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    AVG(total_cost) AS avg_estimated_cost,
    AVG(actual_time_ms) AS avg_actual_time
FROM query_plan_stats
WHERE actual_time_ms IS NOT NULL;
```

---

## 4. è¿žæŽ¥é¡ºåºä¼˜åŒ–

### 4.1 è¿žæŽ¥é¡ºåºé—®é¢˜

**è¿žæŽ¥é¡ºåºä¼˜åŒ–**æ˜¯æŸ¥è¯¢ä¼˜åŒ–ä¸­æœ€å¤æ‚çš„é—®é¢˜ä¹‹ä¸€ï¼Œå› ä¸ºè¿žæŽ¥é¡ºåºçš„æ•°é‡æ˜¯é˜¶ä¹˜çº§çš„ã€‚

#### é—®é¢˜å®šä¹‰

ç»™å®š $n$ ä¸ªè¡¨éœ€è¦è¿žæŽ¥ï¼Œå¯èƒ½çš„è¿žæŽ¥é¡ºåºæœ‰ $n!$ ç§ã€‚

**åŠ¨æ€è§„åˆ’ç®—æ³•**ï¼š

- ä½¿ç”¨åŠ¨æ€è§„åˆ’é¿å…é‡å¤è®¡ç®—
- æ—¶é—´å¤æ‚åº¦ï¼š$O(2^n)$ï¼ˆä»ç„¶æ˜¯æŒ‡æ•°çº§ï¼Œä½†æ¯”$O(n!)$å¥½ï¼‰

#### è¿žæŽ¥é¡ºåºé€‰æ‹©ç­–ç•¥

1. **æœ€å°æˆæœ¬ä¼˜å…ˆ**ï¼šé€‰æ‹©æˆæœ¬æœ€ä½Žçš„è¿žæŽ¥é¡ºåº
2. **é€‰æ‹©æ€§ä¼˜å…ˆ**ï¼šå…ˆè¿žæŽ¥é€‰æ‹©æ€§é«˜çš„è¡¨
3. **å¤§å°ä¼˜å…ˆ**ï¼šå…ˆè¿žæŽ¥å°è¡¨ï¼Œå‡å°‘ä¸­é—´ç»“æžœ

### 4.2 ç´¢å¼•é€‰æ‹©ä¼˜åŒ–

**ç´¢å¼•é€‰æ‹©**æ˜¯æŸ¥è¯¢ä¼˜åŒ–çš„é‡è¦çŽ¯èŠ‚ï¼Œé€‰æ‹©åˆé€‚çš„ç´¢å¼•å¯ä»¥å¤§å¹…æå‡æŸ¥è¯¢æ€§èƒ½ã€‚

#### ç´¢å¼•é€‰æ‹©åŽŸåˆ™

1. **ç­‰å€¼æŸ¥è¯¢**ï¼šä½¿ç”¨B-treeç´¢å¼•
2. **èŒƒå›´æŸ¥è¯¢**ï¼šä½¿ç”¨B-treeç´¢å¼•
3. **å…¨æ–‡æœç´¢**ï¼šä½¿ç”¨GINæˆ–GiSTç´¢å¼•
4. **æ•°ç»„æŸ¥è¯¢**ï¼šä½¿ç”¨GINç´¢å¼•
5. **å¤šåˆ—æŸ¥è¯¢**ï¼šè€ƒè™‘å¤åˆç´¢å¼•

#### ç´¢å¼•ä½¿ç”¨æ¡ä»¶

- WHEREå­å¥ä¸­çš„åˆ—
- JOINæ¡ä»¶ä¸­çš„åˆ—
- ORDER BYå­å¥ä¸­çš„åˆ—
- GROUP BYå­å¥ä¸­çš„åˆ—

## 5. PostgreSQL 18 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–å¢žå¼º

**PostgreSQL 18** æ˜¾è‘—å¢žå¼ºäº†å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œè®¡åˆ’ç”Ÿæˆã€å¹¶è¡Œæˆæœ¬ä¼°ç®—å’Œå¹¶è¡ŒæŸ¥è¯¢é‡å†™ï¼Œå¤§å¹…æå‡å¤æ‚æŸ¥è¯¢çš„ä¼˜åŒ–å’Œæ‰§è¡Œæ€§èƒ½ã€‚

### 5.1 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–åŽŸç†

PostgreSQL 18 çš„å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–é€šè¿‡ä»¥ä¸‹æ–¹å¼å®žçŽ°ï¼š

1. **å¹¶è¡Œè®¡åˆ’ç”Ÿæˆ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œç”Ÿæˆå€™é€‰æ‰§è¡Œè®¡åˆ’
2. **å¹¶è¡Œæˆæœ¬ä¼°ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹ä¼°ç®—è®¡åˆ’æˆæœ¬
3. **å¹¶è¡ŒæŸ¥è¯¢é‡å†™**ï¼šå¹¶è¡Œåº”ç”¨æŸ¥è¯¢é‡å†™è§„åˆ™
4. **æœ€ä¼˜è®¡åˆ’é€‰æ‹©**ï¼šä¸»è¿›ç¨‹é€‰æ‹©æˆæœ¬æœ€ä½Žçš„æ‰§è¡Œè®¡åˆ’

### 5.2 å¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ

```sql
-- PostgreSQL 18 å¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING 'è¡¨ orders ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customers') THEN
            RAISE WARNING 'è¡¨ customers ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ç”Ÿæˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒæŸ¥è¯¢è®¡åˆ’ï¼šå¤šè¡¨è¿žæŽ¥æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE, COSTS, SETTINGS)
SELECT
    o.order_id,
    o.order_date,
    o.amount,
    c.customer_name,
    c.email
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01'
ORDER BY o.order_date DESC
LIMIT 100;
```

### 5.3 å¹¶è¡ŒèšåˆæŸ¥è¯¢ä¼˜åŒ–

```sql
-- PostgreSQL 18 å¹¶è¡ŒèšåˆæŸ¥è¯¢ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales') THEN
            RAISE WARNING 'è¡¨ sales ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡ŒèšåˆæŸ¥è¯¢ä¼˜åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡ŒèšåˆæŸ¥è¯¢ä¼˜åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡ŒèšåˆæŸ¥è¯¢ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡ŒèšåˆæŸ¥è¯¢ï¼šåˆ†ç»„èšåˆç»Ÿè®¡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE, COSTS, SETTINGS)
SELECT
    region,
    category,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY region, category
ORDER BY total_amount DESC;
```

### 5.4 å¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–

```sql
-- PostgreSQL 18 å¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING 'è¡¨ products ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING 'è¡¨ order_items ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå­æŸ¥è¯¢ä¼˜åŒ–ï¼šç›¸å…³å­æŸ¥è¯¢è½¬æ¢ä¸ºJOIN
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE, COSTS, SETTINGS)
SELECT
    p.product_id,
    p.product_name,
    p.price,
    COALESCE(oi.total_sales, 0) AS total_sales
FROM products p
LEFT JOIN (
    SELECT
        product_id,
        SUM(quantity * price) AS total_sales
    FROM order_items
    GROUP BY product_id
) oi ON p.product_id = oi.product_id
ORDER BY total_sales DESC
LIMIT 20;
```

---

## 6. å®žé™…åº”ç”¨æ¡ˆä¾‹

### 6.1 æ…¢æŸ¥è¯¢ä¼˜åŒ–

**æ…¢æŸ¥è¯¢ä¼˜åŒ–**è¯†åˆ«å’Œä¼˜åŒ–æ…¢æŸ¥è¯¢ï¼Œæå‡æ•°æ®åº“æ•´ä½“æ€§èƒ½ã€‚

```sql
-- æ…¢æŸ¥è¯¢ä¼˜åŒ–ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING 'è¡¨ query_plan_stats ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œæ…¢æŸ¥è¯¢ä¼˜åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œæ…¢æŸ¥è¯¢ä¼˜åŒ–åˆ†æž';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ…¢æŸ¥è¯¢ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è¯†åˆ«æ…¢æŸ¥è¯¢å¹¶æä¾›ä¼˜åŒ–å»ºè®®
WITH slow_queries AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        total_cost,
        CASE
            WHEN query_text LIKE '%JOIN%' AND execution_time_ms > 500 THEN 'Consider index on join columns'
            WHEN query_text LIKE '%WHERE%' AND execution_time_ms > 500 THEN 'Check WHERE clause indexes'
            WHEN query_text LIKE '%ORDER BY%' AND execution_time_ms > 500 THEN 'Consider index on ORDER BY columns'
            WHEN query_text LIKE '%GROUP BY%' AND execution_time_ms > 500 THEN 'Consider index on GROUP BY columns'
            ELSE 'Review query structure'
        END AS optimization_hint
    FROM query_plan_stats
    WHERE execution_time_ms > 100
)
SELECT
    query_id,
    LEFT(query_text, 80) AS query_preview,
    execution_time_ms,
    ROUND((plan_rows::numeric / NULLIF(actual_rows, 0))::numeric, 2) AS estimation_ratio,
    optimization_hint,
    CASE
        WHEN execution_time_ms > 5000 THEN 'Critical - Immediate optimization needed'
        WHEN execution_time_ms > 1000 THEN 'High priority'
        ELSE 'Medium priority'
    END AS priority
FROM slow_queries
ORDER BY execution_time_ms DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) AS slow_query_count,
    AVG(execution_time_ms) AS avg_execution_time
FROM query_plan_stats
WHERE execution_time_ms > 100;
```

---

## ðŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç»Ÿè®¡ä¿¡æ¯**: å®šæœŸæ›´æ–°è¡¨ç»Ÿè®¡ä¿¡æ¯
2. **ç´¢å¼•**: ä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ›å»ºç´¢å¼•
3. **æŸ¥è¯¢é‡å†™**: ä¼˜åŒ–æŸ¥è¯¢ç»“æž„
4. **ç›‘æŽ§**: æŒç»­ç›‘æŽ§æŸ¥è¯¢æ€§èƒ½

## ðŸŽ¯ æœ€ä½³å®žè·µ

1. **æ‰§è¡Œè®¡åˆ’**: å®šæœŸåˆ†æžæ‰§è¡Œè®¡åˆ’
2. **å‚æ•°åŒ–**: ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
3. **é¿å…å…¨è¡¨æ‰«æ**: ç¡®ä¿æœ‰é€‚å½“çš„ç´¢å¼•
4. **æ‰¹é‡æ“ä½œ**: ä¼˜åŒ–æ‰¹é‡æ“ä½œ

### 7.1 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢žå¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢žå¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡æŸ¥è¯¢ä¼˜åŒ–ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºŽåŒ…å«å¤šåˆ—çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºŽTop-NæŸ¥è¯¢å’ŒèŒƒå›´æŸ¥è¯¢ä¼˜åŒ–

2. **å¼‚æ­¥I/Oå¢žå¼º**ï¼š
   - å¯¹äºŽå¤§è§„æ¨¡æŸ¥è¯¢ä¼˜åŒ–è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºŽæ‰¹é‡æŸ¥è¯¢åˆ†æžå’Œæ‰§è¡Œè®¡åˆ’å¯¹æ¯”

3. **å¹¶è¡ŒæŸ¥è¯¢å¢žå¼º**ï¼š
   - æŸ¥è¯¢ä¼˜åŒ–æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜Žï¼‰
   - é€‚ç”¨äºŽå¤§è§„æ¨¡æŸ¥è¯¢ä¼˜åŒ–å’Œå¤šæŸ¥è¯¢å¹¶è¡Œåˆ†æž

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–æŸ¥è¯¢ä¼˜åŒ–åˆ†æž**

```sql
-- ä¸ºæŸ¥è¯¢ä¼˜åŒ–åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_query_optimization_skip_scan
ON query_plan_stats(query_id, execution_time_ms DESC, total_cost DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ‰§è¡Œæ—¶é—´æœ€é•¿çš„å‰10ä¸ªæŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (query_id)
    query_id,
    LEFT(query_text, 80) AS query_preview,
    execution_time_ms,
    total_cost,
    plan_rows,
    actual_rows
FROM query_plan_stats
ORDER BY query_id, execution_time_ms DESC
LIMIT 50;
```

### 7.2 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢žå¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜æŸ¥è¯¢ä¼˜åŒ–ç»“æžœ**

å¯¹äºŽé¢‘ç¹ä½¿ç”¨çš„æŸ¥è¯¢ä¼˜åŒ–ç»“æžœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜æŸ¥è¯¢ä¼˜åŒ–ç»“æžœ
CREATE MATERIALIZED VIEW IF NOT EXISTS query_optimization_cache AS
WITH query_statistics AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        total_cost,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æŸ¥è¯¢æ•ˆçŽ‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN plan_rows > 0 THEN actual_rows::numeric / NULLIF(plan_rows, 0)
            ELSE NULL
        END AS estimation_ratio,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æŸ¥è¯¢æˆæœ¬æ•ˆçŽ‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN execution_time_ms > 0 THEN total_cost / NULLIF(execution_time_ms, 0)
            ELSE NULL
        END AS cost_efficiency,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æŸ¥è¯¢ç±»åž‹ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN query_text LIKE '%JOIN%' THEN 'JOIN'
            WHEN query_text LIKE '%WHERE%' THEN 'FILTER'
            WHEN query_text LIKE '%ORDER BY%' THEN 'SORT'
            WHEN query_text LIKE '%GROUP BY%' THEN 'AGGREGATE'
            ELSE 'OTHER'
        END AS query_type
    FROM query_plan_stats
),
optimization_recommendations AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        total_cost,
        ROUND(estimation_ratio::numeric, 2) AS estimation_ratio,
        ROUND(cost_efficiency::numeric, 4) AS cost_efficiency,
        query_type,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ä¼˜åŒ–å»ºè®®ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN estimation_ratio > 10 THEN 'Consider updating statistics'
            WHEN estimation_ratio < 0.1 THEN 'Consider reviewing query'
            WHEN cost_efficiency < 0.1 THEN 'Consider adding indexes'
            WHEN execution_time_ms > 5000 THEN 'Critical - Immediate optimization needed'
            WHEN execution_time_ms > 1000 THEN 'High priority optimization'
            ELSE 'Monitor'
        END AS optimization_priority,
        CASE
            WHEN query_type = 'JOIN' AND execution_time_ms > 500 THEN 'Consider index on join columns'
            WHEN query_type = 'FILTER' AND execution_time_ms > 500 THEN 'Check WHERE clause indexes'
            WHEN query_type = 'SORT' AND execution_time_ms > 500 THEN 'Consider index on ORDER BY columns'
            WHEN query_type = 'AGGREGATE' AND execution_time_ms > 500 THEN 'Consider index on GROUP BY columns'
            ELSE 'Review query structure'
        END AS optimization_hint
    FROM query_statistics
)
SELECT
    query_id,
    LEFT(query_text, 100) AS query_preview,
    execution_time_ms,
    plan_rows,
    actual_rows,
    total_cost,
    estimation_ratio,
    cost_efficiency,
    query_type,
    optimization_priority,
    optimization_hint
FROM optimization_recommendations
ORDER BY execution_time_ms DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_query_optimization_cache_priority ON query_optimization_cache(optimization_priority, execution_time_ms DESC);
CREATE INDEX idx_query_optimization_cache_type ON query_optimization_cache(query_type, execution_time_ms DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY query_optimization_cache;
```

**2. å®žæ—¶æŸ¥è¯¢ä¼˜åŒ–ï¼šå¢žé‡æŸ¥è¯¢åˆ†æž**

**å®žæ—¶æŸ¥è¯¢ä¼˜åŒ–**ï¼šå¯¹äºŽå®žæ—¶æŸ¥è¯¢ï¼Œä½¿ç”¨å¢žé‡æ–¹æ³•åˆ†æžæŸ¥è¯¢æ€§èƒ½ã€‚

```sql
-- å®žæ—¶æŸ¥è¯¢ä¼˜åŒ–ï¼šå¢žé‡æŸ¥è¯¢åˆ†æžï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_optimization_state') THEN
            CREATE TABLE query_optimization_state (
                query_id VARCHAR(100) PRIMARY KEY,
                query_text TEXT NOT NULL,
                total_executions BIGINT DEFAULT 0,
                total_execution_time_ms NUMERIC DEFAULT 0,
                avg_execution_time_ms NUMERIC,
                min_execution_time_ms NUMERIC,
                max_execution_time_ms NUMERIC,
                total_cost NUMERIC DEFAULT 0,
                avg_cost NUMERIC,
                last_execution_time TIMESTAMPTZ,
                last_updated TIMESTAMPTZ DEFAULT NOW()
            );

            CREATE INDEX idx_query_optimization_state_exec_time ON query_optimization_state(avg_execution_time_ms DESC);
            CREATE INDEX idx_query_optimization_state_updated ON query_optimization_state(last_updated DESC);

            RAISE NOTICE 'æŸ¥è¯¢ä¼˜åŒ–çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢žé‡æŸ¥è¯¢ä¼˜åŒ–åˆ†æž';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢žé‡æŸ¥è¯¢ä¼˜åŒ–åˆ†æžå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢žé‡æ›´æ–°æŸ¥è¯¢ä¼˜åŒ–ç»Ÿè®¡ï¼šå®žæ—¶æŸ¥è¯¢ä¼˜åŒ–
WITH new_query_stats AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        total_cost,
        NOW() AS execution_time
    FROM query_plan_stats
    WHERE query_id NOT IN (SELECT query_id FROM query_optimization_state)
       OR execution_time_ms > (SELECT COALESCE(MAX(last_execution_time), '1970-01-01') FROM query_optimization_state WHERE query_id = query_plan_stats.query_id)
),
updated_query_stats AS (
    SELECT
        COALESCE(qos.query_id, nqs.query_id) AS query_id,
        COALESCE(qos.query_text, nqs.query_text) AS query_text,
        COALESCE(qos.total_executions, 0) + COUNT(*) AS new_total_executions,
        COALESCE(qos.total_execution_time_ms, 0) + SUM(nqs.execution_time_ms) AS new_total_execution_time_ms,
        (COALESCE(qos.total_execution_time_ms, 0) + SUM(nqs.execution_time_ms)) /
        NULLIF(COALESCE(qos.total_executions, 0) + COUNT(*), 0) AS new_avg_execution_time_ms,
        LEAST(COALESCE(qos.min_execution_time_ms, nqs.execution_time_ms), MIN(nqs.execution_time_ms)) AS new_min_execution_time_ms,
        GREATEST(COALESCE(qos.max_execution_time_ms, nqs.execution_time_ms), MAX(nqs.execution_time_ms)) AS new_max_execution_time_ms,
        (COALESCE(qos.total_cost, 0) + SUM(nqs.total_cost)) /
        NULLIF(COALESCE(qos.total_executions, 0) + COUNT(*), 0) AS new_avg_cost,
        MAX(nqs.execution_time) AS new_last_execution_time
    FROM query_optimization_state qos
    FULL OUTER JOIN new_query_stats nqs ON qos.query_id = nqs.query_id
    GROUP BY qos.query_id, nqs.query_id, qos.query_text, nqs.query_text,
             qos.total_executions, qos.total_execution_time_ms, qos.min_execution_time_ms,
             qos.max_execution_time_ms, qos.total_cost
)
-- æ›´æ–°æˆ–æ’å…¥æŸ¥è¯¢ä¼˜åŒ–çŠ¶æ€
INSERT INTO query_optimization_state (
    query_id,
    query_text,
    total_executions,
    total_execution_time_ms,
    avg_execution_time_ms,
    min_execution_time_ms,
    max_execution_time_ms,
    total_cost,
    avg_cost,
    last_execution_time,
    last_updated
)
SELECT
    query_id,
    query_text,
    new_total_executions,
    new_total_execution_time_ms,
    new_avg_execution_time_ms,
    new_min_execution_time_ms,
    new_max_execution_time_ms,
    new_total_executions * new_avg_cost AS new_total_cost,
    new_avg_cost,
    new_last_execution_time,
    NOW()
FROM updated_query_stats
ON CONFLICT (query_id)
DO UPDATE SET
    query_text = EXCLUDED.query_text,
    total_executions = EXCLUDED.total_executions,
    total_execution_time_ms = EXCLUDED.total_execution_time_ms,
    avg_execution_time_ms = EXCLUDED.avg_execution_time_ms,
    min_execution_time_ms = EXCLUDED.min_execution_time_ms,
    max_execution_time_ms = EXCLUDED.max_execution_time_ms,
    total_cost = EXCLUDED.total_cost,
    avg_cost = EXCLUDED.avg_cost,
    last_execution_time = EXCLUDED.last_execution_time,
    last_updated = NOW();
```

**3. æ™ºèƒ½æŸ¥è¯¢ä¼˜åŒ–ï¼šè‡ªé€‚åº”ä¼˜åŒ–ç­–ç•¥**

**æ™ºèƒ½æŸ¥è¯¢ä¼˜åŒ–**ï¼šæ ¹æ®æŸ¥è¯¢ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ä¼˜åŒ–ç­–ç•¥ã€‚

```sql
-- æ™ºèƒ½æŸ¥è¯¢ä¼˜åŒ–ï¼šè‡ªé€‚åº”ä¼˜åŒ–ç­–ç•¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    query_complexity NUMERIC;
    query_frequency NUMERIC;
    recommended_strategy VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING 'è¡¨ query_plan_stats ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½æŸ¥è¯¢ä¼˜åŒ–';
            RETURN;
        END IF;

        -- è®¡ç®—æŸ¥è¯¢ç‰¹å¾
        SELECT
            AVG(LENGTH(query_text)),
            COUNT(*) / EXTRACT(EPOCH FROM (MAX(last_execution_time) - MIN(last_execution_time))) * 86400  -- æ¯å¤©æ‰§è¡Œæ¬¡æ•°
        INTO query_complexity, query_frequency
        FROM query_optimization_state
        WHERE last_execution_time >= CURRENT_TIMESTAMP - INTERVAL '30 days';

        -- æ ¹æ®æŸ¥è¯¢ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©ä¼˜åŒ–ç­–ç•¥
        IF query_complexity > 500 AND query_frequency > 100 THEN
            recommended_strategy := 'AGGRESSIVE_OPTIMIZATION';  -- é«˜å¤æ‚åº¦é«˜é¢‘çŽ‡ï¼šæ¿€è¿›ä¼˜åŒ–
        ELSIF query_complexity > 200 AND query_frequency > 50 THEN
            recommended_strategy := 'MODERATE_OPTIMIZATION';  -- ä¸­å¤æ‚åº¦ä¸­é¢‘çŽ‡ï¼šä¸­ç­‰ä¼˜åŒ–
        ELSE
            recommended_strategy := 'CONSERVATIVE_OPTIMIZATION';  -- ä½Žå¤æ‚åº¦ä½Žé¢‘çŽ‡ï¼šä¿å®ˆä¼˜åŒ–
        END IF;

        RAISE NOTICE 'æŸ¥è¯¢å¤æ‚åº¦: %, æŸ¥è¯¢é¢‘çŽ‡: %, æŽ¨èç­–ç•¥: %',
            query_complexity, query_frequency, recommended_strategy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½æŸ¥è¯¢ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ™ºèƒ½æŸ¥è¯¢ä¼˜åŒ–ï¼šæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„ä¼˜åŒ–æ–¹å¼
WITH query_characteristics AS (
    SELECT
        query_id,
        query_text,
        LENGTH(query_text) AS query_length,
        total_executions,
        avg_execution_time_ms,
        total_executions / EXTRACT(EPOCH FROM (NOW() - MIN(last_execution_time) OVER ())) * 86400 AS daily_frequency,
        CASE
            WHEN query_text LIKE '%JOIN%' THEN 1 ELSE 0 END +
        CASE WHEN query_text LIKE '%WHERE%' THEN 1 ELSE 0 END +
        CASE WHEN query_text LIKE '%ORDER BY%' THEN 1 ELSE 0 END +
        CASE WHEN query_text LIKE '%GROUP BY%' THEN 1 ELSE 0 END AS query_complexity_score
    FROM query_optimization_state
    WHERE last_execution_time >= CURRENT_TIMESTAMP - INTERVAL '30 days'
),
adaptive_optimization AS (
    SELECT
        query_id,
        query_text,
        query_length,
        total_executions,
        avg_execution_time_ms,
        daily_frequency,
        query_complexity_score,
        CASE
            WHEN query_complexity_score > 3 AND daily_frequency > 100 THEN 'AGGRESSIVE_OPTIMIZATION'
            WHEN query_complexity_score > 2 AND daily_frequency > 50 THEN 'MODERATE_OPTIMIZATION'
            ELSE 'CONSERVATIVE_OPTIMIZATION'
        END AS recommended_strategy,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ä¼˜åŒ–ä¼˜å…ˆçº§ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        ROW_NUMBER() OVER (
            ORDER BY
                CASE
                    WHEN query_complexity_score > 3 AND daily_frequency > 100 THEN avg_execution_time_ms * daily_frequency
                    WHEN query_complexity_score > 2 AND daily_frequency > 50 THEN avg_execution_time_ms * daily_frequency * 0.5
                    ELSE avg_execution_time_ms * daily_frequency * 0.1
                END DESC
        ) AS optimization_priority
    FROM query_characteristics
)
SELECT
    query_id,
    LEFT(query_text, 100) AS query_preview,
    query_length,
    total_executions,
    ROUND(avg_execution_time_ms::numeric, 2) AS avg_execution_time_ms,
    ROUND(daily_frequency::numeric, 2) AS daily_frequency,
    query_complexity_score,
    recommended_strategy,
    optimization_priority,
    CASE
        WHEN recommended_strategy = 'AGGRESSIVE_OPTIMIZATION' THEN 'Create indexes, optimize joins, consider materialized views'
        WHEN recommended_strategy = 'MODERATE_OPTIMIZATION' THEN 'Review indexes, optimize query structure'
        ELSE 'Monitor and review periodically'
    END AS optimization_actions
FROM adaptive_optimization
WHERE optimization_priority <= 50
ORDER BY optimization_priority
LIMIT 50;
```

---

**æœ€åŽæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
