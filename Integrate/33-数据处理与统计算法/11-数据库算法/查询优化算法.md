# PostgreSQL 查询优化算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 查询优化 | 执行计划
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)

---

## 📋 目录

- [PostgreSQL 查询优化算法完整指南](#postgresql-查询优化算法完整指南)
  - [📋 目录](#-目录)
  - [查询优化概述](#查询优化概述)
    - [理论基础](#理论基础)
      - [查询优化器架构](#查询优化器架构)
      - [成本模型](#成本模型)
      - [优化策略](#优化策略)
    - [核心算法](#核心算法)
  - [1. 查询计划分析](#1-查询计划分析)
    - [1.1 执行计划结构](#11-执行计划结构)
      - [计划节点类型](#计划节点类型)
      - [EXPLAIN输出解读](#explain输出解读)
    - [1.2 执行计划统计](#12-执行计划统计)
  - [2. 查询重写](#2-查询重写)
    - [2.1 查询重写规则](#21-查询重写规则)
      - [常见重写规则](#常见重写规则)
    - [2.2 查询简化实现](#22-查询简化实现)
  - [3. 成本估算](#3-成本估算)
    - [3.1 成本估算原理](#31-成本估算原理)
      - [扫描成本](#扫描成本)
      - [连接成本](#连接成本)
      - [选择性估算](#选择性估算)
    - [3.2 查询成本分析实现](#32-查询成本分析实现)
  - [4. 连接顺序优化](#4-连接顺序优化)
    - [4.1 连接顺序问题](#41-连接顺序问题)
      - [问题定义](#问题定义)
      - [连接顺序选择策略](#连接顺序选择策略)
    - [4.2 索引选择优化](#42-索引选择优化)
      - [索引选择原则](#索引选择原则)
      - [索引使用条件](#索引使用条件)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 慢查询优化](#51-慢查询优化)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 查询优化概述

**查询优化（Query Optimization）**是数据库系统的核心组件，负责将用户提交的SQL查询转换为高效的执行计划。PostgreSQL使用基于成本的查询优化器（Cost-Based Optimizer），通过评估不同执行计划的成本来选择最优方案。

### 理论基础

#### 查询优化器架构

PostgreSQL查询优化器的工作流程：

1. **查询解析（Parsing）**：将SQL文本解析为查询树（Query Tree）
2. **查询重写（Rewriting）**：应用重写规则优化查询结构
3. **计划生成（Planning）**：生成候选执行计划
4. **成本估算（Cost Estimation）**：估算每个计划的执行成本
5. **计划选择（Plan Selection）**：选择成本最低的执行计划

#### 成本模型

PostgreSQL使用以下成本参数：

- **seq_page_cost**：顺序扫描一页的成本（默认1.0）
- **random_page_cost**：随机访问一页的成本（默认4.0）
- **cpu_tuple_cost**：处理一个元组的CPU成本（默认0.01）
- **cpu_index_tuple_cost**：处理一个索引元组的CPU成本（默认0.005）
- **cpu_operator_cost**：执行一个操作符的CPU成本（默认0.0025）

**总成本公式**：
$$Cost = (pages\_read \times page\_cost) + (tuples\_processed \times cpu\_cost)$$

#### 优化策略

1. **基于规则优化（RBO）**：应用预定义的优化规则
2. **基于成本优化（CBO）**：评估不同计划的成本
3. **动态规划**：使用动态规划避免重复计算
4. **启发式剪枝**：使用启发式方法减少搜索空间

### 核心算法

| 算法 | 用途 | 复杂度 | 说明 |
|------|------|--------|------|
| **计划枚举** | 生成执行计划 | $O(n!)$ | 理论上，实际使用剪枝 |
| **动态规划** | 避免重复计算 | $O(2^n)$ | 优化计划枚举 |
| **成本估算** | 评估计划成本 | $O(n)$ | 基于统计信息 |
| **查询重写** | 优化查询结构 | $O(n)$ | 应用重写规则 |
| **连接顺序优化** | 优化JOIN顺序 | $O(n!)$ | 使用动态规划剪枝 |
| **索引选择** | 选择最优索引 | $O(m)$ | $m$是索引数量 |

---

## 1. 查询计划分析

### 1.1 执行计划结构

PostgreSQL的执行计划是一个树形结构，每个节点代表一个操作（如扫描、连接、排序等）。

#### 计划节点类型

1. **扫描节点（Scan Nodes）**：
   - **Seq Scan**：顺序扫描
   - **Index Scan**：索引扫描
   - **Index Only Scan**：仅索引扫描
   - **Bitmap Heap Scan**：位图堆扫描

2. **连接节点（Join Nodes）**：
   - **Nested Loop Join**：嵌套循环连接
   - **Hash Join**：哈希连接
   - **Merge Join**：归并连接

3. **排序节点（Sort Nodes）**：
   - **Sort**：排序操作
   - **Limit**：限制结果数量

4. **聚合节点（Aggregate Nodes）**：
   - **Aggregate**：聚合操作
   - **Group Aggregate**：分组聚合

#### EXPLAIN输出解读

**关键字段**：

- **cost**：预估成本（启动成本..总成本）
- **rows**：预估返回行数
- **width**：预估行宽度（字节）
- **actual time**：实际执行时间（启动时间..总时间）
- **actual rows**：实际返回行数
- **buffers**：缓冲区使用情况

### 1.2 执行计划统计

```sql
-- 创建查询计划统计表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 已存在，先删除';
            DROP TABLE query_plan_stats CASCADE;
        END IF;

        CREATE TABLE query_plan_stats (
            query_id VARCHAR(100) PRIMARY KEY,
            query_text TEXT NOT NULL,
            execution_time_ms NUMERIC(10, 2) NOT NULL,
            plan_rows BIGINT NOT NULL,
            plan_width INTEGER NOT NULL,
            total_cost NUMERIC(10, 2) NOT NULL,
            actual_rows BIGINT,
            actual_time_ms NUMERIC(10, 2)
        );

        INSERT INTO query_plan_stats (query_id, query_text, execution_time_ms, plan_rows, plan_width, total_cost, actual_rows, actual_time_ms) VALUES
            ('Q001', 'SELECT * FROM users WHERE email = $1', 125.5, 1, 200, 25.5, 1, 120.3),
            ('Q002', 'SELECT * FROM orders WHERE date > $1', 2500.0, 10000, 300, 500.0, 50000, 2800.0),
            ('Q003', 'SELECT COUNT(*) FROM products', 50.2, 1, 4, 10.2, 1, 45.8);

        RAISE NOTICE '表 query_plan_stats 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 query_plan_stats 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 执行计划分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法分析执行计划';
            RETURN;
        END IF;
        RAISE NOTICE '开始分析执行计划';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '执行计划分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 分析查询计划准确性
SELECT
    query_id,
    LEFT(query_text, 50) AS query_preview,
    plan_rows AS estimated_rows,
    actual_rows,
    CASE
        WHEN actual_rows = 0 THEN NULL
        ELSE ROUND(ABS(plan_rows - actual_rows)::numeric / NULLIF(actual_rows, 0), 4)
    END AS estimation_error,
    total_cost AS estimated_cost,
    actual_time_ms,
    CASE
        WHEN actual_rows IS NULL OR actual_rows = 0 THEN 'No data'
        WHEN ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 10 THEN 'Poor estimation'
        WHEN ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 2 THEN 'Moderate estimation'
        ELSE 'Good estimation'
    END AS estimation_quality,
    CASE
        WHEN actual_time_ms > 1000 THEN 'Slow query'
        WHEN actual_time_ms > 100 THEN 'Moderate'
        ELSE 'Fast'
    END AS performance_category
FROM query_plan_stats
ORDER BY actual_time_ms DESC NULLS LAST;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    query_id,
    AVG(execution_time_ms) AS avg_execution_time
FROM query_plan_stats
GROUP BY query_id;
```

---

## 2. 查询重写

### 2.1 查询重写规则

**查询重写（Query Rewriting）**在计划生成之前优化查询结构，应用各种重写规则。

#### 常见重写规则

1. **常量折叠（Constant Folding）**：
   - `WHERE x > 5 + 3` → `WHERE x > 8`
   - 在编译时计算常量表达式

2. **谓词下推（Predicate Pushdown）**：
   - 将WHERE条件尽可能下推到子查询
   - 减少需要处理的数据量

3. **子查询优化**：
   - **EXISTS优化**：将相关子查询转换为EXISTS
   - **IN优化**：将IN转换为JOIN或EXISTS
   - **标量子查询优化**：将标量子查询转换为JOIN

4. **JOIN顺序优化**：
   - 重新排列JOIN顺序
   - 将选择性高的条件放在前面

5. **投影下推（Projection Pushdown）**：
   - 只选择需要的列
   - 减少数据传输量

6. **去重优化**：
   - `DISTINCT` + `ORDER BY` 优化
   - 使用索引避免排序

### 2.2 查询简化实现

```sql
-- 查询重写建议（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法生成查询重写建议';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成查询重写建议';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询重写建议生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 识别可优化的查询模式
WITH query_patterns AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        CASE
            WHEN query_text LIKE '%SELECT *%' THEN 'Avoid SELECT *'
            WHEN query_text LIKE '%LIKE ''%''%' THEN 'Consider full-text search'
            WHEN query_text LIKE '%NOT IN%' THEN 'Consider NOT EXISTS'
            WHEN query_text LIKE '%OR%' AND execution_time_ms > 500 THEN 'Consider UNION'
            ELSE NULL
        END AS optimization_pattern,
        CASE
            WHEN plan_rows::numeric / NULLIF(actual_rows, 0) > 10 OR
                 actual_rows::numeric / NULLIF(plan_rows, 0) > 10 THEN TRUE
            ELSE FALSE
        END AS needs_statistics_update
    FROM query_plan_stats
)
SELECT
    query_id,
    LEFT(query_text, 60) AS query_preview,
    execution_time_ms,
    optimization_pattern,
    needs_statistics_update,
    CASE
        WHEN optimization_pattern IS NOT NULL THEN 'Rewrite recommended'
        WHEN needs_statistics_update THEN 'Update statistics'
        ELSE 'No optimization needed'
    END AS recommendation
FROM query_patterns
WHERE optimization_pattern IS NOT NULL OR needs_statistics_update
ORDER BY execution_time_ms DESC;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) FILTER (WHERE query_text LIKE '%SELECT *%') AS select_star_queries,
    COUNT(*) FILTER (WHERE execution_time_ms > 1000) AS slow_queries
FROM query_plan_stats;
```

---

## 3. 成本估算

### 3.1 成本估算原理

**成本估算（Cost Estimation）**是查询优化器的核心，需要准确估算不同执行计划的成本。

#### 扫描成本

**顺序扫描成本**：
$$Cost_{seq} = pages \times seq\_page\_cost + tuples \times cpu\_tuple\_cost$$

**索引扫描成本**：
$$Cost_{index} = index\_pages \times random\_page\_cost + tuples \times cpu\_index\_tuple\_cost + heap\_pages \times random\_page\_cost$$

#### 连接成本

**嵌套循环连接**：
$$Cost_{nested\_loop} = Cost_{outer} + rows_{outer} \times Cost_{inner}$$

**哈希连接**：
$$Cost_{hash\_join} = Cost_{outer} + Cost_{inner} + Cost_{hash\_build} + Cost_{hash\_probe}$$

**归并连接**：
$$Cost_{merge\_join} = Cost_{outer} + Cost_{inner} + Cost_{sort\_outer} + Cost_{sort\_inner}$$

#### 选择性估算

**选择性（Selectivity）**：满足条件的行数占总行数的比例

**等值条件选择性**：
$$sel = \frac{1}{distinct\_values}$$

**范围条件选择性**：
$$sel = \frac{high\_key - constant}{high\_key - low\_key}$$

**多条件组合**：

- **AND条件**：$sel_{and} = sel_1 \times sel_2 \times ...$
- **OR条件**：$sel_{or} = sel_1 + sel_2 - sel_1 \times sel_2$

### 3.2 查询成本分析实现

```sql
-- 查询成本分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法进行成本分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行查询成本分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询成本分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 分析查询成本
SELECT
    query_id,
    LEFT(query_text, 50) AS query_preview,
    total_cost AS estimated_cost,
    actual_time_ms,
    plan_rows AS estimated_rows,
    actual_rows,
    CASE
        WHEN actual_rows = 0 THEN NULL
        ELSE ROUND((total_cost / NULLIF(actual_rows, 0))::numeric, 4)
    END AS cost_per_row,
    CASE
        WHEN actual_time_ms > 1000 THEN 'High cost'
        WHEN actual_time_ms > 100 THEN 'Medium cost'
        ELSE 'Low cost'
    END AS cost_category,
    CASE
        WHEN actual_rows IS NOT NULL AND ABS(plan_rows - actual_rows) / NULLIF(actual_rows, 0) > 5 THEN
            'Consider ANALYZE to update statistics'
        WHEN actual_time_ms > 1000 THEN
            'Consider query optimization or indexing'
        ELSE 'Query is efficient'
    END AS optimization_suggestion
FROM query_plan_stats
ORDER BY actual_time_ms DESC NULLS LAST;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    AVG(total_cost) AS avg_estimated_cost,
    AVG(actual_time_ms) AS avg_actual_time
FROM query_plan_stats
WHERE actual_time_ms IS NOT NULL;
```

---

## 4. 连接顺序优化

### 4.1 连接顺序问题

**连接顺序优化**是查询优化中最复杂的问题之一，因为连接顺序的数量是阶乘级的。

#### 问题定义

给定 $n$ 个表需要连接，可能的连接顺序有 $n!$ 种。

**动态规划算法**：

- 使用动态规划避免重复计算
- 时间复杂度：$O(2^n)$（仍然是指数级，但比$O(n!)$好）

#### 连接顺序选择策略

1. **最小成本优先**：选择成本最低的连接顺序
2. **选择性优先**：先连接选择性高的表
3. **大小优先**：先连接小表，减少中间结果

### 4.2 索引选择优化

**索引选择**是查询优化的重要环节，选择合适的索引可以大幅提升查询性能。

#### 索引选择原则

1. **等值查询**：使用B-tree索引
2. **范围查询**：使用B-tree索引
3. **全文搜索**：使用GIN或GiST索引
4. **数组查询**：使用GIN索引
5. **多列查询**：考虑复合索引

#### 索引使用条件

- WHERE子句中的列
- JOIN条件中的列
- ORDER BY子句中的列
- GROUP BY子句中的列

## 5. 实际应用案例

### 5.1 慢查询优化

**慢查询优化**识别和优化慢查询，提升数据库整体性能。

```sql
-- 慢查询优化示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'query_plan_stats') THEN
            RAISE WARNING '表 query_plan_stats 不存在，无法进行慢查询优化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行慢查询优化分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '慢查询优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 识别慢查询并提供优化建议
WITH slow_queries AS (
    SELECT
        query_id,
        query_text,
        execution_time_ms,
        plan_rows,
        actual_rows,
        total_cost,
        CASE
            WHEN query_text LIKE '%JOIN%' AND execution_time_ms > 500 THEN 'Consider index on join columns'
            WHEN query_text LIKE '%WHERE%' AND execution_time_ms > 500 THEN 'Check WHERE clause indexes'
            WHEN query_text LIKE '%ORDER BY%' AND execution_time_ms > 500 THEN 'Consider index on ORDER BY columns'
            WHEN query_text LIKE '%GROUP BY%' AND execution_time_ms > 500 THEN 'Consider index on GROUP BY columns'
            ELSE 'Review query structure'
        END AS optimization_hint
    FROM query_plan_stats
    WHERE execution_time_ms > 100
)
SELECT
    query_id,
    LEFT(query_text, 80) AS query_preview,
    execution_time_ms,
    ROUND((plan_rows::numeric / NULLIF(actual_rows, 0))::numeric, 2) AS estimation_ratio,
    optimization_hint,
    CASE
        WHEN execution_time_ms > 5000 THEN 'Critical - Immediate optimization needed'
        WHEN execution_time_ms > 1000 THEN 'High priority'
        ELSE 'Medium priority'
    END AS priority
FROM slow_queries
ORDER BY execution_time_ms DESC;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) AS slow_query_count,
    AVG(execution_time_ms) AS avg_execution_time
FROM query_plan_stats
WHERE execution_time_ms > 100;
```

---

## 📊 性能优化建议

1. **统计信息**: 定期更新表统计信息
2. **索引**: 为常用查询创建索引
3. **查询重写**: 优化查询结构
4. **监控**: 持续监控查询性能

## 🎯 最佳实践

1. **执行计划**: 定期分析执行计划
2. **参数化**: 使用参数化查询
3. **避免全表扫描**: 确保有适当的索引
4. **批量操作**: 优化批量操作

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
