# PostgreSQL 金融时间序列分析完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 时间序列 | 金融分析
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 金融时间序列分析完整指南](#postgresql-金融时间序列分析完整指南)
  - [📋 目录](#-目录)
  - [金融时间序列分析概述](#金融时间序列分析概述)
    - [理论基础](#理论基础)
      - [金融时间序列问题定义](#金融时间序列问题定义)
      - [分析方法分类](#分析方法分类)
      - [分析方法选择](#分析方法选择)
    - [核心分析方法](#核心分析方法)
  - [1. 移动平均](#1-移动平均)
    - [1.1 移动平均原理](#11-移动平均原理)
      - [移动平均定义](#移动平均定义)
      - [移动平均类型](#移动平均类型)
    - [1.2 简单移动平均实现](#12-简单移动平均实现)
    - [1.3 指数移动平均实现](#13-指数移动平均实现)
    - [1.4 加权移动平均](#14-加权移动平均)
  - [2. 技术指标](#2-技术指标)
    - [2.1 技术指标原理](#21-技术指标原理)
      - [技术指标定义](#技术指标定义)
      - [技术指标分类](#技术指标分类)
    - [2.2 MACD指标实现](#22-macd指标实现)
    - [2.3 RSI指标实现](#23-rsi指标实现)
    - [2.4 布林带指标](#24-布林带指标)
  - [3. 趋势分析](#3-趋势分析)
    - [3.1 趋势分析原理](#31-趋势分析原理)
      - [趋势定义](#趋势定义)
      - [趋势识别方法](#趋势识别方法)
    - [3.2 趋势识别实现](#32-趋势识别实现)
    - [3.3 趋势强度分析](#33-趋势强度分析)
  - [4. PostgreSQL 18并行金融时间序列分析](#4-postgresql-18并行金融时间序列分析)
    - [4.1 并行金融时间序列分析概述](#41-并行金融时间序列分析概述)
      - [并行金融时间序列分析配置](#并行金融时间序列分析配置)
      - [并行金融时间序列分析实现](#并行金融时间序列分析实现)
  - [5. 金融时间序列优化策略](#5-金融时间序列优化策略)
    - [5.1 索引优化](#51-索引优化)
    - [5.2 窗口函数优化](#52-窗口函数优化)
    - [5.3 批量计算优化](#53-批量计算优化)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 交易信号生成](#61-交易信号生成)
    - [6.2 趋势跟踪策略](#62-趋势跟踪策略)
    - [6.3 均值回归策略](#63-均值回归策略)
    - [6.4 技术指标组合策略](#64-技术指标组合策略)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 分析方法对比](#71-分析方法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 分析方法选择](#81-分析方法选择)
    - [8.2 参数调优](#82-参数调优)
    - [8.3 数据质量](#83-数据质量)
    - [8.4 SQL实现注意事项](#84-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 金融时间序列分析概述

**金融时间序列分析（Financial Time Series Analysis）**用于识别价格趋势、预测未来走势和生成交易信号，是技术分析的核心。

### 理论基础

#### 金融时间序列问题定义

**金融时间序列问题**：给定价格序列$P = \{P_1, P_2, \ldots, P_T\}$，分析：

1. **趋势识别**：识别上升、下降或横盘趋势
2. **信号生成**：生成买卖信号
3. **预测**：预测未来价格走势

#### 分析方法分类

金融时间序列分析方法分类：

1. **移动平均（Moving Average）**：
   - 简单移动平均（SMA）
   - 指数移动平均（EMA）
   - 加权移动平均（WMA）
   - 时间复杂度：$O(n)$

2. **技术指标（Technical Indicators）**：
   - MACD（移动平均收敛散度）
   - RSI（相对强弱指标）
   - 布林带（Bollinger Bands）
   - 时间复杂度：$O(n)$

3. **趋势分析（Trend Analysis）**：
   - 趋势识别
   - 趋势强度
   - 趋势反转
   - 时间复杂度：$O(n)$

#### 分析方法选择

选择分析方法的考虑因素：

1. **市场类型**：趋势市场用移动平均，震荡市场用RSI
2. **时间周期**：短期用快速指标，长期用慢速指标
3. **交易风格**：趋势跟踪用移动平均，均值回归用布林带

### 核心分析方法

| 方法 | 数学定义 | 用途 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **移动平均** | $\text{MA}_t = \frac{1}{n}\sum_{i=0}^{n-1} P_{t-i}$ | 平滑价格波动 | $O(n)$ | $O(1)$ | 趋势识别 |
| **MACD** | $\text{MACD} = \text{EMA}_{12} - \text{EMA}_{26}$ | 识别趋势变化 | $O(n)$ | $O(1)$ | 趋势分析 |
| **RSI** | $\text{RSI} = 100 - \frac{100}{1 + \text{RS}}$ | 衡量价格动量 | $O(n)$ | $O(1)$ | 超买超卖 |
| **趋势分析** | 基于价格和移动平均 | 判断市场方向 | $O(n)$ | $O(1)$ | 趋势跟踪 |

---

## 1. 移动平均

### 1.1 移动平均原理

**移动平均（Moving Average）**是平滑价格波动、识别趋势的重要工具。

#### 移动平均定义

**简单移动平均（SMA）**：计算$n$期内的平均价格：
$$\text{SMA}_t = \frac{1}{n}\sum_{i=0}^{n-1} P_{t-i}$$

**指数移动平均（EMA）**：给予近期价格更高权重：
$$\text{EMA}_t = \alpha P_t + (1 - \alpha) \text{EMA}_{t-1}$$

其中$\alpha = \frac{2}{n+1}$是平滑系数。

#### 移动平均类型

**移动平均类型**：

1. **SMA**：等权重平均
2. **EMA**：指数加权平均
3. **WMA**：线性加权平均

### 1.2 简单移动平均实现

**简单移动平均**的实现和使用。

```sql
-- 创建价格数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 已存在，先删除';
            DROP TABLE price_data CASCADE;
        END IF;

        CREATE TABLE price_data (
            date DATE NOT NULL,
            symbol VARCHAR(10) NOT NULL,
            close_price NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (date, symbol)
        );

        -- 插入示例数据
        INSERT INTO price_data (date, symbol, close_price) VALUES
            ('2024-01-01', 'AAPL', 150.00), ('2024-01-02', 'AAPL', 152.00),
            ('2024-01-03', 'AAPL', 151.00), ('2024-01-04', 'AAPL', 153.00),
            ('2024-01-05', 'AAPL', 155.00), ('2024-01-06', 'AAPL', 154.00),
            ('2024-01-07', 'AAPL', 156.00), ('2024-01-08', 'AAPL', 157.00),
            ('2024-01-09', 'AAPL', 158.00), ('2024-01-10', 'AAPL', 159.00);

        RAISE NOTICE '表 price_data 创建成功，已插入10条数据';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 price_data 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算简单移动平均（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算简单移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '移动平均计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算5日和10日移动平均
SELECT
    date,
    symbol,
    close_price,
    AVG(close_price) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
    ) AS sma_5,
    AVG(close_price) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
    ) AS sma_10
FROM price_data
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    close_price,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS sma_5
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

### 1.3 指数移动平均实现

**指数移动平均**的实现和使用。

```sql
-- 指数移动平均计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算指数移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算指数移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '指数移动平均计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算EMA（使用递归CTE）
WITH RECURSIVE ema_calculation AS (
    SELECT
        date,
        symbol,
        close_price,
        close_price AS ema_5,
        ROW_NUMBER() OVER (PARTITION BY symbol ORDER BY date) AS rn
    FROM price_data
    WHERE (symbol, date) IN (
        SELECT symbol, MIN(date) FROM price_data GROUP BY symbol
    )

    UNION ALL

    SELECT
        pd.date,
        pd.symbol,
        pd.close_price,
        CASE
            WHEN ec.rn < 5 THEN
                (pd.close_price * 2.0 / 6.0) + (ec.ema_5 * 4.0 / 6.0)
            ELSE
                (pd.close_price * 2.0 / 6.0) + (ec.ema_5 * 4.0 / 6.0)
        END AS ema_5,
        ec.rn + 1
    FROM ema_calculation ec
    JOIN price_data pd ON pd.symbol = ec.symbol
        AND pd.date = (
            SELECT MIN(date) FROM price_data
            WHERE symbol = ec.symbol AND date > ec.date
        )
    WHERE ec.rn < 20
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(ema_5::numeric, 2) AS ema_5
FROM ema_calculation
ORDER BY symbol, date;

-- 性能测试（简化版）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    close_price,
    close_price AS ema_approx
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date
LIMIT 10;
```

---

### 1.4 加权移动平均

**加权移动平均（WMA）**：给予近期价格更高权重。

```sql
-- 加权移动平均（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算加权移动平均';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算加权移动平均';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '加权移动平均计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 加权移动平均：使用线性权重
WITH weighted_ma AS (
    SELECT
        date,
        symbol,
        close_price,
        -- 5日加权移动平均：权重为5,4,3,2,1
        (
            close_price * 5 +
            LAG(close_price, 1) OVER (PARTITION BY symbol ORDER BY date) * 4 +
            LAG(close_price, 2) OVER (PARTITION BY symbol ORDER BY date) * 3 +
            LAG(close_price, 3) OVER (PARTITION BY symbol ORDER BY date) * 2 +
            LAG(close_price, 4) OVER (PARTITION BY symbol ORDER BY date) * 1
        ) / 15.0 AS wma_5
    FROM price_data
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(wma_5::numeric, 2) AS wma_5
FROM weighted_ma
WHERE wma_5 IS NOT NULL
ORDER BY symbol, date;
```

---

## 2. 技术指标

### 2.1 技术指标原理

**技术指标（Technical Indicators）**是基于价格和成交量计算的指标，用于识别交易信号。

#### 技术指标定义

**技术指标**：从价格序列$P$和成交量序列$V$计算的指标：
$$I_t = f(P_{t-k}, \ldots, P_t, V_{t-k}, \ldots, V_t)$$

其中$f$是指标计算函数。

#### 技术指标分类

**技术指标分类**：

1. **趋势指标**：MACD、移动平均
2. **动量指标**：RSI、随机指标
3. **波动率指标**：布林带、ATR

### 2.2 MACD指标实现

**MACD指标**的实现和使用。

```sql
-- MACD指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算MACD';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算MACD指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'MACD计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算MACD（简化版：使用SMA代替EMA）
WITH price_series AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        ) AS ema_12,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 25 PRECEDING AND CURRENT ROW
        ) AS ema_26
    FROM price_data
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(ema_12::numeric, 2) AS ema_12,
    ROUND(ema_26::numeric, 2) AS ema_26,
    ROUND((ema_12 - ema_26)::numeric, 2) AS macd_line,
    ROUND(AVG(ema_12 - ema_26) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 8 PRECEDING AND CURRENT ROW
    )::numeric, 2) AS signal_line,
    ROUND(((ema_12 - ema_26) - AVG(ema_12 - ema_26) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 8 PRECEDING AND CURRENT ROW
    ))::numeric, 2) AS histogram
FROM price_series
WHERE ema_26 IS NOT NULL
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS ema_12
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

### 2.3 RSI指标实现

**RSI指标**的实现和使用。

```sql
-- RSI指标计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算RSI';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算RSI指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'RSI计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算RSI（14日周期）
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS price_change
    FROM price_data
),
gains_losses AS (
    SELECT
        date,
        symbol,
        close_price,
        CASE WHEN price_change > 0 THEN price_change ELSE 0 END AS gain,
        CASE WHEN price_change < 0 THEN ABS(price_change) ELSE 0 END AS loss
    FROM price_changes
),
avg_gains_losses AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(gain) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
        ) AS avg_gain,
        AVG(loss) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
        ) AS avg_loss
    FROM gains_losses
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(avg_gain::numeric, 4) AS avg_gain,
    ROUND(avg_loss::numeric, 4) AS avg_loss,
    CASE
        WHEN avg_loss = 0 THEN 100
        ELSE ROUND((100 - (100 / (1 + avg_gain / NULLIF(avg_loss, 0))))::numeric, 2)
    END AS rsi
FROM avg_gains_losses
WHERE avg_gain IS NOT NULL AND avg_loss IS NOT NULL
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    close_price - LAG(close_price) OVER (ORDER BY date) AS price_change
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

---

### 2.4 布林带指标

**布林带（Bollinger Bands）**：衡量价格波动范围。

```sql
-- 布林带指标（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法计算布林带';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算布林带指标';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '布林带计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 布林带：中轨（SMA）、上轨（SMA + 2*STD）、下轨（SMA - 2*STD）
WITH bollinger_bands AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS middle_band,
        STDDEV(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS std_dev
    FROM price_data
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(middle_band::numeric, 2) AS middle_band,
    ROUND((middle_band + 2 * std_dev)::numeric, 2) AS upper_band,
    ROUND((middle_band - 2 * std_dev)::numeric, 2) AS lower_band,
    ROUND(((close_price - middle_band) / NULLIF(std_dev, 0))::numeric, 2) AS bollinger_percent
FROM bollinger_bands
WHERE middle_band IS NOT NULL AND std_dev IS NOT NULL
ORDER BY symbol, date;
```

---

## 3. 趋势分析

### 3.1 趋势分析原理

**趋势分析（Trend Analysis）**识别价格趋势的方向和强度。

#### 趋势定义

**趋势**：价格在一段时间内的总体方向：

- **上升趋势**：价格持续上涨
- **下降趋势**：价格持续下跌
- **横盘趋势**：价格在一定范围内波动

#### 趋势识别方法

**趋势识别方法**：

1. **移动平均交叉**：短期均线上穿长期均线
2. **价格突破**：价格突破关键阻力位或支撑位
3. **趋势线**：连接价格高点或低点

### 3.2 趋势识别实现

**趋势识别**的实现和使用。

```sql
-- 趋势识别（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法识别趋势';
            RETURN;
        END IF;
        RAISE NOTICE '开始识别趋势';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势识别准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 识别趋势（基于移动平均交叉）
WITH moving_averages AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS sma_5,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
        ) AS sma_10
    FROM price_data
),
trend_signals AS (
    SELECT
        date,
        symbol,
        close_price,
        sma_5,
        sma_10,
        CASE
            WHEN sma_5 > sma_10 AND LAG(sma_5) OVER (PARTITION BY symbol ORDER BY date) <= LAG(sma_10) OVER (PARTITION BY symbol ORDER BY date) THEN 'Bullish Cross'
            WHEN sma_5 < sma_10 AND LAG(sma_5) OVER (PARTITION BY symbol ORDER BY date) >= LAG(sma_10) OVER (PARTITION BY symbol ORDER BY date) THEN 'Bearish Cross'
            WHEN sma_5 > sma_10 THEN 'Uptrend'
            WHEN sma_5 < sma_10 THEN 'Downtrend'
            ELSE 'Sideways'
        END AS trend
    FROM moving_averages
    WHERE sma_5 IS NOT NULL AND sma_10 IS NOT NULL
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(sma_5::numeric, 2) AS sma_5,
    ROUND(sma_10::numeric, 2) AS sma_10,
    trend
FROM trend_signals
ORDER BY symbol, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS sma_5,
    AVG(close_price) OVER (ORDER BY date ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS sma_10
FROM price_data
WHERE symbol = 'AAPL'
ORDER BY date;
```

---

### 3.3 趋势强度分析

**趋势强度分析**：量化趋势的强度。

```sql
-- 趋势强度分析（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法分析趋势强度';
            RETURN;
        END IF;
        RAISE NOTICE '开始分析趋势强度';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势强度分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 趋势强度：基于价格与移动平均的距离
WITH trend_strength AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS sma_20,
        STDDEV(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS std_dev
    FROM price_data
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(sma_20::numeric, 2) AS sma_20,
    CASE
        WHEN close_price > sma_20 THEN 'Uptrend'
        WHEN close_price < sma_20 THEN 'Downtrend'
        ELSE 'Sideways'
    END AS trend_direction,
    ROUND(ABS(close_price - sma_20) / NULLIF(std_dev, 0)::numeric, 2) AS trend_strength,
    CASE
        WHEN ABS(close_price - sma_20) / NULLIF(std_dev, 0) > 2 THEN 'Strong'
        WHEN ABS(close_price - sma_20) / NULLIF(std_dev, 0) > 1 THEN 'Moderate'
        ELSE 'Weak'
    END AS strength_level
FROM trend_strength
WHERE sma_20 IS NOT NULL AND std_dev IS NOT NULL
ORDER BY symbol, date;
```

---

## 4. PostgreSQL 18并行金融时间序列分析

### 4.1 并行金融时间序列分析概述

**PostgreSQL 18并行金融时间序列分析**：利用PostgreSQL 18的并行查询能力，显著提升大规模金融时间序列分析的性能。

#### 并行金融时间序列分析配置

```sql
-- 配置并行金融时间序列分析参数（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 设置并行工作进程数
        SET max_parallel_workers_per_gather = 4;

        -- 设置并行表扫描阈值
        SET min_parallel_table_scan_size = '8MB';

        -- 设置并行聚合成本阈值
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '并行金融时间序列分析参数已配置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行金融时间序列分析配置失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### 并行金融时间序列分析实现

```sql
-- 并行金融时间序列分析：大规模价格数据技术指标计算（PostgreSQL 18+）
DO $$
BEGIN
    BEGIN
        -- 启用并行查询
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE '开始执行并行金融时间序列分析';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行金融时间序列分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 并行移动平均和技术指标计算
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_price_data AS (
    SELECT
        date,
        symbol,
        close_price
    FROM price_data
    WHERE date >= CURRENT_DATE - INTERVAL '1 year'
),
parallel_indicators AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS sma_20,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 49 PRECEDING AND CURRENT ROW
        ) AS sma_50,
        STDDEV(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS stddev_20
    FROM parallel_price_data
)
SELECT
    symbol,
    date,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(sma_20::numeric, 2) AS sma_20,
    ROUND(sma_50::numeric, 2) AS sma_50,
    ROUND(stddev_20::numeric, 2) AS stddev_20,
    CASE
        WHEN sma_20 > sma_50 THEN 'Bullish'
        WHEN sma_20 < sma_50 THEN 'Bearish'
        ELSE 'Neutral'
    END AS trend_signal
FROM parallel_indicators
WHERE sma_20 IS NOT NULL AND sma_50 IS NOT NULL
ORDER BY symbol, date DESC;
```

---

## 5. 金融时间序列优化策略

### 5.1 索引优化

**索引优化**：为时间序列查询创建合适的索引。

```sql
-- 索引优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 价格表索引
        CREATE INDEX IF NOT EXISTS idx_price_data_date_symbol
        ON price_data(date, symbol);

        CREATE INDEX IF NOT EXISTS idx_price_data_symbol_date
        ON price_data(symbol, date);

        RAISE NOTICE '金融时间序列分析索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '索引创建失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 窗口函数优化

**窗口函数优化**：使用物化视图缓存技术指标。

```sql
-- 窗口函数优化：使用物化视图缓存技术指标
CREATE MATERIALIZED VIEW IF NOT EXISTS technical_indicators_cache AS
SELECT
    date,
    symbol,
    close_price,
    AVG(close_price) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
    ) AS sma_20,
    AVG(close_price) OVER (
        PARTITION BY symbol
        ORDER BY date
        ROWS BETWEEN 49 PRECEDING AND CURRENT ROW
    ) AS sma_50
FROM price_data;

CREATE INDEX IF NOT EXISTS idx_technical_indicators_cache_date_symbol
ON technical_indicators_cache(date, symbol);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY technical_indicators_cache;
```

### 5.3 批量计算优化

**批量计算优化**：使用批量操作提高性能。

```sql
-- 批量计算优化（带错误处理）
DO $$
BEGIN
    BEGIN
        SET work_mem = '512MB';
        SET max_parallel_workers_per_gather = 4;
        RAISE NOTICE '批量计算优化配置已设置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '批量计算优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 6. 实际应用案例

### 6.1 交易信号生成

**交易信号生成**基于技术指标生成买卖信号。

```sql
-- 交易信号生成示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法生成交易信号';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成交易信号';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '交易信号生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 生成交易信号（基于MACD和RSI）
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH macd_data AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS ema_12,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 25 PRECEDING AND CURRENT ROW) AS ema_26
    FROM price_data
),
macd_signals AS (
    SELECT
        date,
        symbol,
        close_price,
        (ema_12 - ema_26) AS macd_line,
        AVG(ema_12 - ema_26) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS signal_line
    FROM macd_data
    WHERE ema_26 IS NOT NULL
),
rsi_data AS (
    SELECT
        date,
        symbol,
        AVG(CASE WHEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) > 0
            THEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) ELSE 0 END)
        OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS avg_gain,
        AVG(CASE WHEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) < 0
            THEN ABS(close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) ELSE 0 END)
        OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS avg_loss
    FROM price_data
),
rsi_values AS (
    SELECT
        date,
        symbol,
        CASE
            WHEN avg_loss = 0 THEN 100
            ELSE 100 - (100 / (1 + avg_gain / NULLIF(avg_loss, 0)))
        END AS rsi
    FROM rsi_data
    WHERE avg_gain IS NOT NULL AND avg_loss IS NOT NULL
),
trading_signals AS (
    SELECT
        ms.date,
        ms.symbol,
        ms.close_price,
        ms.macd_line,
        ms.signal_line,
        rv.rsi,
        CASE
            WHEN ms.macd_line > ms.signal_line AND LAG(ms.macd_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date) <= LAG(ms.signal_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date)
                AND rv.rsi < 70 THEN 'BUY'
            WHEN ms.macd_line < ms.signal_line AND LAG(ms.macd_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date) >= LAG(ms.signal_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date)
                AND rv.rsi > 30 THEN 'SELL'
            ELSE 'HOLD'
        END AS signal
    FROM macd_signals ms
    JOIN rsi_values rv ON ms.date = rv.date AND ms.symbol = rv.symbol
)
SELECT
    date,
    symbol,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(macd_line::numeric, 2) AS macd,
    ROUND(signal_line::numeric, 2) AS signal,
    ROUND(rsi::numeric, 2) AS rsi,
    signal AS trading_signal
FROM trading_signals
WHERE signal != 'HOLD'
ORDER BY symbol, date;
```

### 6.2 趋势跟踪策略

**趋势跟踪策略**：基于趋势的交易策略。

```sql
-- 趋势跟踪策略（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法执行趋势跟踪策略';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行趋势跟踪策略';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势跟踪策略准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 趋势跟踪策略：基于移动平均交叉
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH moving_averages AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS sma_5,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS sma_20
    FROM price_data
),
trend_signals AS (
    SELECT
        date,
        symbol,
        close_price,
        sma_5,
        sma_20,
        CASE
            WHEN sma_5 > sma_20 AND LAG(sma_5) OVER (PARTITION BY symbol ORDER BY date) <= LAG(sma_20) OVER (PARTITION BY symbol ORDER BY date) THEN 'BUY'
            WHEN sma_5 < sma_20 AND LAG(sma_5) OVER (PARTITION BY symbol ORDER BY date) >= LAG(sma_20) OVER (PARTITION BY symbol ORDER BY date) THEN 'SELL'
            ELSE 'HOLD'
        END AS signal
    FROM moving_averages
    WHERE sma_5 IS NOT NULL AND sma_20 IS NOT NULL
)
SELECT
    date,
    symbol,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(sma_5::numeric, 2) AS sma_5,
    ROUND(sma_20::numeric, 2) AS sma_20,
    signal AS trading_signal
FROM trend_signals
WHERE signal != 'HOLD'
ORDER BY symbol, date;
```

### 6.3 均值回归策略

**均值回归策略**：基于价格偏离均值的交易策略。

```sql
-- 均值回归策略（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法执行均值回归策略';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行均值回归策略';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '均值回归策略准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 均值回归策略：基于布林带
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH bollinger_bands AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS middle_band,
        STDDEV(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS std_dev
    FROM price_data
),
mean_reversion_signals AS (
    SELECT
        date,
        symbol,
        close_price,
        middle_band,
        middle_band + 2 * std_dev AS upper_band,
        middle_band - 2 * std_dev AS lower_band,
        CASE
            WHEN close_price <= middle_band - 2 * std_dev THEN 'BUY'
            WHEN close_price >= middle_band + 2 * std_dev THEN 'SELL'
            ELSE 'HOLD'
        END AS signal
    FROM bollinger_bands
    WHERE middle_band IS NOT NULL AND std_dev IS NOT NULL
)
SELECT
    date,
    symbol,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(middle_band::numeric, 2) AS middle_band,
    ROUND((middle_band + 2 * std_dev)::numeric, 2) AS upper_band,
    ROUND((middle_band - 2 * std_dev)::numeric, 2) AS lower_band,
    signal AS trading_signal
FROM mean_reversion_signals
WHERE signal != 'HOLD'
ORDER BY symbol, date;
```

### 6.4 技术指标组合策略

**技术指标组合策略**：结合多个技术指标的交易策略。

```sql
-- 技术指标组合策略（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'price_data') THEN
            RAISE WARNING '表 price_data 不存在，无法执行技术指标组合策略';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行技术指标组合策略';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '技术指标组合策略准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 技术指标组合策略：MACD + RSI + 移动平均
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH macd_data AS (
    SELECT
        date,
        symbol,
        close_price,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 11 PRECEDING AND CURRENT ROW) AS ema_12,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 25 PRECEDING AND CURRENT ROW) AS ema_26
    FROM price_data
),
macd_signals AS (
    SELECT
        date,
        symbol,
        close_price,
        (ema_12 - ema_26) AS macd_line,
        AVG(ema_12 - ema_26) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS signal_line
    FROM macd_data
    WHERE ema_26 IS NOT NULL
),
rsi_data AS (
    SELECT
        date,
        symbol,
        AVG(CASE WHEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) > 0
            THEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) ELSE 0 END)
        OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS avg_gain,
        AVG(CASE WHEN close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) < 0
            THEN ABS(close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) ELSE 0 END)
        OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS avg_loss
    FROM price_data
),
rsi_values AS (
    SELECT
        date,
        symbol,
        CASE
            WHEN avg_loss = 0 THEN 100
            ELSE 100 - (100 / (1 + avg_gain / NULLIF(avg_loss, 0)))
        END AS rsi
    FROM rsi_data
    WHERE avg_gain IS NOT NULL AND avg_loss IS NOT NULL
),
ma_signals AS (
    SELECT
        date,
        symbol,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS sma_5,
        AVG(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN 19 PRECEDING AND CURRENT ROW) AS sma_20
    FROM price_data
),
combined_signals AS (
    SELECT
        ms.date,
        ms.symbol,
        ms.close_price,
        ms.macd_line,
        ms.signal_line,
        rv.rsi,
        mas.sma_5,
        mas.sma_20,
        -- 组合信号：MACD金叉 + RSI < 70 + SMA5 > SMA20
        CASE
            WHEN ms.macd_line > ms.signal_line
                AND LAG(ms.macd_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date) <= LAG(ms.signal_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date)
                AND rv.rsi < 70
                AND mas.sma_5 > mas.sma_20 THEN 'BUY'
            WHEN ms.macd_line < ms.signal_line
                AND LAG(ms.macd_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date) >= LAG(ms.signal_line) OVER (PARTITION BY ms.symbol ORDER BY ms.date)
                AND rv.rsi > 30
                AND mas.sma_5 < mas.sma_20 THEN 'SELL'
            ELSE 'HOLD'
        END AS signal
    FROM macd_signals ms
    JOIN rsi_values rv ON ms.date = rv.date AND ms.symbol = rv.symbol
    JOIN ma_signals mas ON ms.date = mas.date AND ms.symbol = mas.symbol
)
SELECT
    date,
    symbol,
    ROUND(close_price::numeric, 2) AS close_price,
    ROUND(macd_line::numeric, 2) AS macd,
    ROUND(signal_line::numeric, 2) AS signal,
    ROUND(rsi::numeric, 2) AS rsi,
    ROUND(sma_5::numeric, 2) AS sma_5,
    ROUND(sma_20::numeric, 2) AS sma_20,
    signal AS trading_signal
FROM combined_signals
WHERE signal != 'HOLD'
ORDER BY symbol, date;
```

---

## 7. 算法性能对比与优化

### 7.1 分析方法对比

| 方法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **移动平均** | $\text{MA}_t = \frac{1}{n}\sum_{i=0}^{n-1} P_{t-i}$ | $O(n)$ | $O(1)$ | 趋势识别 | 简单、直观 | 滞后性 |
| **MACD** | $\text{MACD} = \text{EMA}_{12} - \text{EMA}_{26}$ | $O(n)$ | $O(1)$ | 趋势分析 | 敏感 | 假信号多 |
| **RSI** | $\text{RSI} = 100 - \frac{100}{1 + \text{RS}}$ | $O(n)$ | $O(1)$ | 超买超卖 | 标准化 | 需要参数调优 |
| **趋势分析** | 基于价格和移动平均 | $O(n)$ | $O(1)$ | 趋势跟踪 | 直观 | 滞后性 |

### 7.2 性能优化建议

1. **索引优化**：
   - 在(date, symbol)上创建复合索引
   - 为常用查询创建索引

2. **窗口函数优化**：
   - 使用窗口函数优化计算
   - 使用物化视图缓存结果

3. **批量处理**：
   - 批量计算多个指标
   - 使用并行查询

### 7.3 常见问题与解决方案

**问题1**：技术指标滞后

- **解决方案**：使用快速指标、调整参数、结合多个指标

**问题2**：假信号多

- **解决方案**：组合多个指标、添加过滤条件、回测验证

**问题3**：计算性能慢

- **解决方案**：使用物化视图、创建索引、优化窗口函数

**问题4**：参数选择困难

- **解决方案**：回测优化、市场适应、动态调整

---

## 8. 最佳实践

### 8.1 分析方法选择

1. **趋势市场**：使用移动平均和MACD
2. **震荡市场**：使用RSI和布林带
3. **趋势跟踪**：使用移动平均交叉
4. **均值回归**：使用布林带

### 8.2 参数调优

1. **移动平均周期**：根据时间周期选择（5、10、20、50、200）
2. **RSI周期**：常用14日
3. **MACD参数**：常用12、26、9

### 8.3 数据质量

1. **数据完整性**：确保数据完整
2. **异常值处理**：识别和处理异常值
3. **数据更新**：实时更新数据

### 8.4 SQL实现注意事项

1. **窗口函数**：充分利用窗口函数
2. **性能优化**：使用索引和物化视图
3. **信号过滤**：添加信号过滤条件
4. **错误处理**：处理NULL值和边界情况

---

## 📚 参考资源

### 学术文献

- 《技术分析》（Technical Analysis）- 技术指标理论
- 《量化交易》（Quantitative Trading）- 交易策略

### PostgreSQL官方文档

- [窗口函数](https://www.postgresql.org/docs/current/tutorial-window.html)
- [时间序列函数](https://www.postgresql.org/docs/current/functions-datetime.html)

### 在线资源

- PostgreSQL金融时间序列分析指南
- 技术指标详解
- 交易策略最佳实践

### 相关算法

- [收益率计算](./收益率计算.md) - 收益率计算
- [风险评估算法](./风险评估算法.md) - 风险评估
- [投资组合优化](./投资组合优化.md) - 投资组合优化

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
