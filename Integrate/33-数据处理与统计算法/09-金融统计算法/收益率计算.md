# PostgreSQL æ”¶ç›Šç‡è®¡ç®—å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | é‡‘èè®¡ç®— | æ”¶ç›Šç‡
> **éš¾åº¦çº§åˆ«**: â­â­â­ (ä¸­çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æ”¶ç›Šç‡è®¡ç®—å®Œæ•´æŒ‡å—](#postgresql-æ”¶ç›Šç‡è®¡ç®—å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ”¶ç›Šç‡è®¡ç®—æ¦‚è¿°](#æ”¶ç›Šç‡è®¡ç®—æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æ”¶ç›Šç‡é—®é¢˜å®šä¹‰](#æ”¶ç›Šç‡é—®é¢˜å®šä¹‰)
      - [æ”¶ç›Šç‡ç±»å‹åˆ†ç±»](#æ”¶ç›Šç‡ç±»å‹åˆ†ç±»)
      - [æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•é€‰æ‹©](#æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•é€‰æ‹©)
    - [æ ¸å¿ƒæŒ‡æ ‡](#æ ¸å¿ƒæŒ‡æ ‡)
  - [1. ç®€å•æ”¶ç›Šç‡](#1-ç®€å•æ”¶ç›Šç‡)
    - [1.1 ç®€å•æ”¶ç›Šç‡åŸç†](#11-ç®€å•æ”¶ç›Šç‡åŸç†)
      - [ç®€å•æ”¶ç›Šç‡å®šä¹‰](#ç®€å•æ”¶ç›Šç‡å®šä¹‰)
      - [ç®€å•æ”¶ç›Šç‡å…¬å¼](#ç®€å•æ”¶ç›Šç‡å…¬å¼)
    - [1.2 æ—¥æ”¶ç›Šç‡è®¡ç®—å®ç°](#12-æ—¥æ”¶ç›Šç‡è®¡ç®—å®ç°)
    - [1.3 å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡](#13-å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡)
    - [1.4 å¤šæœŸç®€å•æ”¶ç›Šç‡](#14-å¤šæœŸç®€å•æ”¶ç›Šç‡)
  - [2. å¯¹æ•°æ”¶ç›Šç‡](#2-å¯¹æ•°æ”¶ç›Šç‡)
    - [2.1 å¯¹æ•°æ”¶ç›Šç‡åŸç†](#21-å¯¹æ•°æ”¶ç›Šç‡åŸç†)
      - [å¯¹æ•°æ”¶ç›Šç‡å®šä¹‰](#å¯¹æ•°æ”¶ç›Šç‡å®šä¹‰)
      - [å¯¹æ•°æ”¶ç›Šç‡ä¼˜åŠ¿](#å¯¹æ•°æ”¶ç›Šç‡ä¼˜åŠ¿)
    - [2.2 å¯¹æ•°æ”¶ç›Šç‡è®¡ç®—å®ç°](#22-å¯¹æ•°æ”¶ç›Šç‡è®¡ç®—å®ç°)
    - [2.3 å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡](#23-å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡)
  - [3. ç´¯è®¡æ”¶ç›Šç‡](#3-ç´¯è®¡æ”¶ç›Šç‡)
    - [3.1 ç´¯è®¡æ”¶ç›Šç‡åŸç†](#31-ç´¯è®¡æ”¶ç›Šç‡åŸç†)
      - [ç´¯è®¡æ”¶ç›Šç‡å®šä¹‰](#ç´¯è®¡æ”¶ç›Šç‡å®šä¹‰)
      - [ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—](#ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—)
    - [3.2 ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—å®ç°](#32-ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—å®ç°)
    - [3.3 ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£](#33-ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£)
  - [4. å¹´åŒ–æ”¶ç›Šç‡](#4-å¹´åŒ–æ”¶ç›Šç‡)
    - [4.1 å¹´åŒ–æ”¶ç›Šç‡åŸç†](#41-å¹´åŒ–æ”¶ç›Šç‡åŸç†)
      - [å¹´åŒ–æ”¶ç›Šç‡å®šä¹‰](#å¹´åŒ–æ”¶ç›Šç‡å®šä¹‰)
      - [å¹´åŒ–æ”¶ç›Šç‡å…¬å¼](#å¹´åŒ–æ”¶ç›Šç‡å…¬å¼)
    - [4.2 å¹´åŒ–æ”¶ç›Šç‡è®¡ç®—å®ç°](#42-å¹´åŒ–æ”¶ç›Šç‡è®¡ç®—å®ç°)
    - [4.3 ä¸åŒæœŸé™å¹´åŒ–](#43-ä¸åŒæœŸé™å¹´åŒ–)
  - [5. æ”¶ç›Šç‡è®¡ç®—ä¼˜åŒ–ç­–ç•¥](#5-æ”¶ç›Šç‡è®¡ç®—ä¼˜åŒ–ç­–ç•¥)
    - [5.1 ç´¢å¼•ä¼˜åŒ–](#51-ç´¢å¼•ä¼˜åŒ–)
    - [5.2 çª—å£å‡½æ•°ä¼˜åŒ–](#52-çª—å£å‡½æ•°ä¼˜åŒ–)
    - [5.3 æ‰¹é‡è®¡ç®—ä¼˜åŒ–](#53-æ‰¹é‡è®¡ç®—ä¼˜åŒ–)
  - [6. PostgreSQL 18 å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—å¢å¼º](#6-postgresql-18-å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—å¢å¼º)
    - [6.1 å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—åŸç†](#61-å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—åŸç†)
    - [6.2 å¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—](#62-å¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—)
    - [6.3 å¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—](#63-å¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—)
    - [6.4 å¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—](#64-å¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [6.1 æŠ•èµ„ç»„åˆæ”¶ç›Šç‡åˆ†æ](#61-æŠ•èµ„ç»„åˆæ”¶ç›Šç‡åˆ†æ)
    - [6.2 è‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æ](#62-è‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æ)
    - [6.3 åŸºé‡‘ä¸šç»©è¯„ä¼°](#63-åŸºé‡‘ä¸šç»©è¯„ä¼°)
    - [6.4 èµ„äº§é…ç½®æ”¶ç›Šç‡è®¡ç®—](#64-èµ„äº§é…ç½®æ”¶ç›Šç‡è®¡ç®—)
  - [8. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#8-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [7.1 æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•å¯¹æ¯”](#71-æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•å¯¹æ¯”)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#73-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [9. æœ€ä½³å®è·µ](#9-æœ€ä½³å®è·µ)
    - [8.1 è®¡ç®—æ–¹æ³•é€‰æ‹©](#81-è®¡ç®—æ–¹æ³•é€‰æ‹©)
    - [8.2 æ•°æ®è´¨é‡ä¿è¯](#82-æ•°æ®è´¨é‡ä¿è¯)
    - [8.3 ç²¾åº¦æ§åˆ¶](#83-ç²¾åº¦æ§åˆ¶)
    - [8.4 SQLå®ç°æ³¨æ„äº‹é¡¹](#84-sqlå®ç°æ³¨æ„äº‹é¡¹)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [PostgreSQLå®˜æ–¹æ–‡æ¡£](#postgresqlå®˜æ–¹æ–‡æ¡£)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## æ”¶ç›Šç‡è®¡ç®—æ¦‚è¿°

**æ”¶ç›Šç‡è®¡ç®—ï¼ˆReturn Calculationï¼‰**æ˜¯è¡¡é‡æŠ•èµ„ç›ˆåˆ©èƒ½åŠ›çš„åŸºç¡€æŒ‡æ ‡ï¼Œæ˜¯é‡‘èåˆ†æå’ŒæŠ•èµ„å†³ç­–çš„æ ¸å¿ƒã€‚

### ç†è®ºåŸºç¡€

#### æ”¶ç›Šç‡é—®é¢˜å®šä¹‰

**æ”¶ç›Šç‡é—®é¢˜**ï¼šç»™å®šèµ„äº§ä»·æ ¼åºåˆ—$P = \{P_0, P_1, \ldots, P_T\}$ï¼Œè®¡ç®—æ”¶ç›Šç‡åºåˆ—$R = \{r_1, r_2, \ldots, r_T\}$ï¼š
$$r_t = f(P_t, P_{t-1})$$

å…¶ä¸­$f$æ˜¯æ”¶ç›Šç‡è®¡ç®—å‡½æ•°ã€‚

#### æ”¶ç›Šç‡ç±»å‹åˆ†ç±»

æ”¶ç›Šç‡ç±»å‹åˆ†ç±»ï¼š

1. **ç®€å•æ”¶ç›Šç‡ï¼ˆSimple Returnï¼‰**ï¼š
   - å…¬å¼ï¼š$r_t = \frac{P_t - P_{t-1}}{P_{t-1}}$
   - ç‰¹ç‚¹ï¼šç›´è§‚ã€æ˜“äºç†è§£
   - é€‚ç”¨ï¼šå•æœŸæ”¶ç›Šè®¡ç®—

2. **å¯¹æ•°æ”¶ç›Šç‡ï¼ˆLog Returnï¼‰**ï¼š
   - å…¬å¼ï¼š$r_t = \ln\left(\frac{P_t}{P_{t-1}}\right)$
   - ç‰¹ç‚¹ï¼šæ—¶é—´å¯åŠ æ€§ã€å¯¹ç§°æ€§
   - é€‚ç”¨ï¼šæ—¶é—´åºåˆ—åˆ†æã€å¤šæœŸæ”¶ç›Š

3. **ç´¯è®¡æ”¶ç›Šç‡ï¼ˆCumulative Returnï¼‰**ï¼š
   - å…¬å¼ï¼š$R_T = \prod_{t=1}^{T}(1 + r_t) - 1$
   - ç‰¹ç‚¹ï¼šå¤šæœŸæ”¶ç›Šæ±‡æ€»
   - é€‚ç”¨ï¼šæŠ•èµ„ç»„åˆè¯„ä¼°

4. **å¹´åŒ–æ”¶ç›Šç‡ï¼ˆAnnualized Returnï¼‰**ï¼š
   - å…¬å¼ï¼š$r_{annual} = (1 + r)^{n} - 1$ï¼ˆ$n$ä¸ºå¹´åŒ–å€æ•°ï¼‰
   - ç‰¹ç‚¹ï¼šæ ‡å‡†åŒ–æ¯”è¾ƒ
   - é€‚ç”¨ï¼šä¸åŒæœŸé™æ”¶ç›Šæ¯”è¾ƒ

#### æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•é€‰æ‹©

é€‰æ‹©è®¡ç®—æ–¹æ³•çš„è€ƒè™‘å› ç´ ï¼š

1. **è®¡ç®—ç›®çš„**ï¼šå•æœŸæ”¶ç›Šç”¨ç®€å•æ”¶ç›Šç‡ï¼Œå¤šæœŸæ”¶ç›Šç”¨å¯¹æ•°æ”¶ç›Šç‡
2. **æ•°æ®ç‰¹æ€§**ï¼šä»·æ ¼æ•°æ®ç”¨ç®€å•æ”¶ç›Šç‡ï¼Œæ”¶ç›Šç‡æ•°æ®ç”¨å¯¹æ•°æ”¶ç›Šç‡
3. **åˆ†æéœ€æ±‚**ï¼šæ—¶é—´åºåˆ—åˆ†æç”¨å¯¹æ•°æ”¶ç›Šç‡ï¼ŒæŠ•èµ„è¯„ä¼°ç”¨ç´¯è®¡æ”¶ç›Šç‡

### æ ¸å¿ƒæŒ‡æ ‡

| æŒ‡æ ‡ | æ•°å­¦å®šä¹‰ | å…¬å¼ | ç”¨é€” | æ—¶é—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|---------|------|------|-----------|---------|
| **ç®€å•æ”¶ç›Šç‡** | $r_t = \frac{P_t - P_{t-1}}{P_{t-1}}$ | $(P_t - P_{t-1}) / P_{t-1}$ | åŸºç¡€æ”¶ç›Šè®¡ç®— | $O(1)$ | å•æœŸæ”¶ç›Š |
| **å¯¹æ•°æ”¶ç›Šç‡** | $r_t = \ln\left(\frac{P_t}{P_{t-1}}\right)$ | $\ln(P_t / P_{t-1})$ | æ—¶é—´åºåˆ—åˆ†æ | $O(1)$ | å¤šæœŸæ”¶ç›Š |
| **ç´¯è®¡æ”¶ç›Šç‡** | $R_T = \prod_{t=1}^{T}(1 + r_t) - 1$ | $\Pi(1 + r_i) - 1$ | å¤šæœŸæ”¶ç›Š | $O(n)$ | æŠ•èµ„è¯„ä¼° |
| **å¹´åŒ–æ”¶ç›Šç‡** | $r_{annual} = (1 + r)^{n} - 1$ | $(1 + r)^n - 1$ | æ ‡å‡†åŒ–æ¯”è¾ƒ | $O(1)$ | æ”¶ç›Šæ¯”è¾ƒ |

---

## 1. ç®€å•æ”¶ç›Šç‡

### 1.1 ç®€å•æ”¶ç›Šç‡åŸç†

**ç®€å•æ”¶ç›Šç‡ï¼ˆSimple Returnï¼‰**æ˜¯æœ€ç›´è§‚çš„æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•ã€‚

#### ç®€å•æ”¶ç›Šç‡å®šä¹‰

**ç®€å•æ”¶ç›Šç‡**ï¼šèµ„äº§ä»æ—¶åˆ»$t-1$åˆ°æ—¶åˆ»$t$çš„æ”¶ç›Šç‡ï¼š
$$r_t = \frac{P_t - P_{t-1}}{P_{t-1}} = \frac{P_t}{P_{t-1}} - 1$$

**æ€§è´¨**ï¼š

- $r_t \in [-1, +\infty)$
- $r_t = 0$ï¼šä»·æ ¼ä¸å˜
- $r_t > 0$ï¼šä»·æ ¼ä¸Šæ¶¨
- $r_t < 0$ï¼šä»·æ ¼ä¸‹è·Œ

#### ç®€å•æ”¶ç›Šç‡å…¬å¼

**å¤šæœŸç®€å•æ”¶ç›Šç‡**ï¼šä»æ—¶åˆ»$0$åˆ°æ—¶åˆ»$T$çš„æ€»æ”¶ç›Šç‡ï¼š
$$R_T = \prod_{t=1}^{T}(1 + r_t) - 1$$

### 1.2 æ—¥æ”¶ç›Šç‡è®¡ç®—å®ç°

**æ—¥æ”¶ç›Šç‡**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- åˆ›å»ºè‚¡ç¥¨ä»·æ ¼è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE stock_prices CASCADE;
        END IF;

        CREATE TABLE stock_prices (
            date DATE NOT NULL,
            symbol VARCHAR(10) NOT NULL,
            close_price NUMERIC(10, 2) NOT NULL,
            PRIMARY KEY (date, symbol)
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO stock_prices (date, symbol, close_price) VALUES
            ('2024-01-01', 'AAPL', 150.00),
            ('2024-01-02', 'AAPL', 152.50),
            ('2024-01-03', 'AAPL', 151.00),
            ('2024-01-04', 'AAPL', 153.75),
            ('2024-01-05', 'AAPL', 155.00),
            ('2024-01-01', 'GOOGL', 2800.00),
            ('2024-01-02', 'GOOGL', 2820.00),
            ('2024-01-03', 'GOOGL', 2810.00),
            ('2024-01-04', 'GOOGL', 2835.00),
            ('2024-01-05', 'GOOGL', 2850.00);

        RAISE NOTICE 'è¡¨ stock_prices åˆ›å»ºæˆåŠŸï¼Œå·²æ’å…¥10æ¡æ•°æ®';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ stock_prices å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- è®¡ç®—æ—¥æ”¶ç›Šç‡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—æ”¶ç›Šç‡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—æ—¥æ”¶ç›Šç‡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—æ—¥æ”¶ç›Šç‡
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
    FROM stock_prices
)
SELECT
    date,
    symbol,
    close_price,
    prev_price,
    CASE
        WHEN prev_price IS NULL THEN NULL
        WHEN prev_price = 0 THEN NULL
        ELSE ROUND(((close_price - prev_price) / prev_price * 100)::numeric, 4)
    END AS daily_return_pct
FROM price_changes
WHERE prev_price IS NOT NULL
ORDER BY symbol, date;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    symbol,
    close_price,
    LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
FROM stock_prices
ORDER BY symbol, date;
```

---

### 1.3 å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡

**å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡**ï¼šè®¡ç®—ä¸åŒå‘¨æœŸçš„æ”¶ç›Šç‡ã€‚

```sql
-- å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å‘¨æ”¶ç›Šç‡å’Œæœˆæ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å‘¨æ”¶ç›Šç‡ï¼šä½¿ç”¨æ¯å‘¨æœ€åä¸€ä¸ªäº¤æ˜“æ—¥
WITH weekly_prices AS (
    SELECT
        DATE_TRUNC('week', date) AS week_start,
        symbol,
        LAST_VALUE(close_price) OVER (
            PARTITION BY symbol, DATE_TRUNC('week', date)
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS week_end_price,
        FIRST_VALUE(close_price) OVER (
            PARTITION BY symbol, DATE_TRUNC('week', date)
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS week_start_price
    FROM stock_prices
),
weekly_returns AS (
    SELECT DISTINCT
        week_start,
        symbol,
        week_start_price,
        week_end_price,
        CASE
            WHEN week_start_price = 0 THEN NULL
            ELSE (week_end_price - week_start_price) / week_start_price
        END AS weekly_return
    FROM weekly_prices
)
SELECT
    week_start,
    symbol,
    week_start_price,
    week_end_price,
    ROUND(weekly_return::numeric, 6) AS weekly_return,
    ROUND((weekly_return * 100)::numeric, 2) AS weekly_return_pct
FROM weekly_returns
WHERE weekly_return IS NOT NULL
ORDER BY symbol, week_start;

-- æœˆæ”¶ç›Šç‡ï¼šä½¿ç”¨æ¯æœˆæœ€åä¸€ä¸ªäº¤æ˜“æ—¥
WITH monthly_prices AS (
    SELECT
        DATE_TRUNC('month', date) AS month_start,
        symbol,
        LAST_VALUE(close_price) OVER (
            PARTITION BY symbol, DATE_TRUNC('month', date)
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS month_end_price,
        FIRST_VALUE(close_price) OVER (
            PARTITION BY symbol, DATE_TRUNC('month', date)
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS month_start_price
    FROM stock_prices
),
monthly_returns AS (
    SELECT DISTINCT
        month_start,
        symbol,
        month_start_price,
        month_end_price,
        CASE
            WHEN month_start_price = 0 THEN NULL
            ELSE (month_end_price - month_start_price) / month_start_price
        END AS monthly_return
    FROM monthly_prices
)
SELECT
    month_start,
    symbol,
    month_start_price,
    month_end_price,
    ROUND(monthly_return::numeric, 6) AS monthly_return,
    ROUND((monthly_return * 100)::numeric, 2) AS monthly_return_pct
FROM monthly_returns
WHERE monthly_return IS NOT NULL
ORDER BY symbol, month_start;
```

### 1.4 å¤šæœŸç®€å•æ”¶ç›Šç‡

**å¤šæœŸç®€å•æ”¶ç›Šç‡**ï¼šè®¡ç®—å¤šæœŸçš„æ€»æ”¶ç›Šç‡ã€‚

```sql
-- å¤šæœŸç®€å•æ”¶ç›Šç‡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    start_date DATE := '2024-01-01';
    end_date DATE := '2024-01-05';
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—å¤šæœŸç®€å•æ”¶ç›Šç‡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—å¤šæœŸç®€å•æ”¶ç›Šç‡ï¼Œä» % åˆ° %', start_date, end_date;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¤šæœŸç®€å•æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¤šæœŸç®€å•æ”¶ç›Šç‡ï¼šè®¡ç®—æŒ‡å®šæœŸé—´çš„æ€»æ”¶ç›Šç‡
WITH period_prices AS (
    SELECT
        symbol,
        FIRST_VALUE(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) FILTER (WHERE date = start_date) AS start_price,
        LAST_VALUE(close_price) OVER (
            PARTITION BY symbol
            ORDER BY date
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) FILTER (WHERE date = end_date) AS end_price
    FROM stock_prices
    WHERE date BETWEEN start_date AND end_date
)
SELECT DISTINCT
    symbol,
    start_price,
    end_price,
    CASE
        WHEN start_price = 0 THEN NULL
        ELSE (end_price - start_price) / start_price
    END AS period_return
FROM period_prices
WHERE start_price IS NOT NULL AND end_price IS NOT NULL
ORDER BY symbol;
```

---

## 2. å¯¹æ•°æ”¶ç›Šç‡

### 2.1 å¯¹æ•°æ”¶ç›Šç‡åŸç†

**å¯¹æ•°æ”¶ç›Šç‡ï¼ˆLog Returnï¼‰**ä½¿ç”¨è‡ªç„¶å¯¹æ•°è®¡ç®—æ”¶ç›Šç‡ï¼Œå…·æœ‰æ—¶é—´å¯åŠ æ€§ã€‚

#### å¯¹æ•°æ”¶ç›Šç‡å®šä¹‰

**å¯¹æ•°æ”¶ç›Šç‡**ï¼šèµ„äº§ä»æ—¶åˆ»$t-1$åˆ°æ—¶åˆ»$t$çš„å¯¹æ•°æ”¶ç›Šç‡ï¼š
$$r_t = \ln\left(\frac{P_t}{P_{t-1}}\right) = \ln(P_t) - \ln(P_{t-1})$$

**æ€§è´¨**ï¼š

- $r_t \in (-\infty, +\infty)$
- **æ—¶é—´å¯åŠ æ€§**ï¼š$r_{0,T} = \sum_{t=1}^{T} r_t$
- **å¯¹ç§°æ€§**ï¼š$r_t$å’Œ$-r_t$å¯¹ç§°
- **è¿‘ä¼¼æ€§**ï¼šå½“$r_t$è¾ƒå°æ—¶ï¼Œ$\ln(1 + r_t) \approx r_t$

#### å¯¹æ•°æ”¶ç›Šç‡ä¼˜åŠ¿

**å¯¹æ•°æ”¶ç›Šç‡ä¼˜åŠ¿**ï¼š

1. **æ—¶é—´å¯åŠ æ€§**ï¼šå¤šæœŸå¯¹æ•°æ”¶ç›Šç‡ç­‰äºå„æœŸå¯¹æ•°æ”¶ç›Šç‡ä¹‹å’Œ
2. **ç»Ÿè®¡æ€§è´¨**ï¼šæ›´æ¥è¿‘æ­£æ€åˆ†å¸ƒ
3. **è®¡ç®—ä¾¿åˆ©**ï¼šå¤šæœŸæ”¶ç›Šè®¡ç®—æ›´ç®€å•

### 2.2 å¯¹æ•°æ”¶ç›Šç‡è®¡ç®—å®ç°

**å¯¹æ•°æ”¶ç›Šç‡**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- å¯¹æ•°æ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¯¹æ•°æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
    FROM stock_prices
)
SELECT
    date,
    symbol,
    close_price,
    prev_price,
    CASE
        WHEN prev_price IS NULL THEN NULL
        WHEN prev_price <= 0 THEN NULL
        ELSE ROUND(LN(close_price / prev_price)::numeric, 6)
    END AS log_return
FROM price_changes
WHERE prev_price IS NOT NULL AND prev_price > 0
ORDER BY symbol, date;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    symbol,
    CASE
        WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) > 0 THEN
            LN(close_price / LAG(close_price) OVER (PARTITION BY symbol ORDER BY date))
        ELSE NULL
    END AS log_return
FROM stock_prices
ORDER BY symbol, date;
```

---

### 2.3 å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡

**å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡**ï¼šåˆ©ç”¨æ—¶é—´å¯åŠ æ€§è®¡ç®—å¤šæœŸæ”¶ç›Šã€‚

```sql
-- å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡ï¼šåˆ©ç”¨æ—¶é—´å¯åŠ æ€§
WITH log_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        LN(close_price / NULLIF(LAG(close_price) OVER (PARTITION BY symbol ORDER BY date), 0)) AS log_return
    FROM stock_prices
    WHERE LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) > 0
),
cumulative_log_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        log_return,
        SUM(log_return) OVER (PARTITION BY symbol ORDER BY date) AS cumulative_log_return,
        EXP(SUM(log_return) OVER (PARTITION BY symbol ORDER BY date)) - 1 AS cumulative_return
    FROM log_returns
    WHERE log_return IS NOT NULL
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(log_return::numeric, 6) AS log_return,
    ROUND(cumulative_log_return::numeric, 6) AS cumulative_log_return,
    ROUND(cumulative_return::numeric, 6) AS cumulative_return,
    ROUND((cumulative_return * 100)::numeric, 2) AS cumulative_return_pct
FROM cumulative_log_returns
ORDER BY symbol, date;
```

---

## 3. ç´¯è®¡æ”¶ç›Šç‡

### 3.1 ç´¯è®¡æ”¶ç›Šç‡åŸç†

**ç´¯è®¡æ”¶ç›Šç‡ï¼ˆCumulative Returnï¼‰**è®¡ç®—å¤šæœŸæŠ•èµ„çš„æ€»ä½“æ”¶ç›Šã€‚

#### ç´¯è®¡æ”¶ç›Šç‡å®šä¹‰

**ç´¯è®¡æ”¶ç›Šç‡**ï¼šä»æ—¶åˆ»$0$åˆ°æ—¶åˆ»$T$çš„ç´¯è®¡æ”¶ç›Šç‡ï¼š
$$R_T = \prod_{t=1}^{T}(1 + r_t) - 1$$

**å¯¹æ•°å½¢å¼**ï¼šä½¿ç”¨å¯¹æ•°æ”¶ç›Šç‡æ—¶ï¼š
$$R_T = \exp\left(\sum_{t=1}^{T} r_t\right) - 1$$

#### ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—

**è®¡ç®—æ–¹æ³•**ï¼š

1. **ç®€å•æ”¶ç›Šç‡ç´¯è®¡**ï¼š$R_T = \prod_{t=1}^{T}(1 + r_t) - 1$
2. **å¯¹æ•°æ”¶ç›Šç‡ç´¯è®¡**ï¼š$R_T = \exp\left(\sum_{t=1}^{T} r_t\right) - 1$

### 3.2 ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—å®ç°

**ç´¯è®¡æ”¶ç›Šç‡**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ç´¯è®¡æ”¶ç›Šç‡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—ç´¯è®¡æ”¶ç›Šç‡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç´¯è®¡æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—ç´¯è®¡æ”¶ç›Šç‡ï¼ˆä½¿ç”¨ç®€å•æ”¶ç›Šç‡ï¼‰
WITH daily_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) IS NULL THEN NULL
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END AS daily_return
    FROM stock_prices
),
cumulative_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        daily_return,
        EXP(SUM(LN(1 + COALESCE(daily_return, 0))) OVER (PARTITION BY symbol ORDER BY date)) - 1 AS cumulative_return
    FROM daily_returns
    WHERE daily_return IS NOT NULL
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(COALESCE(daily_return, 0)::numeric, 6) AS daily_return,
    ROUND(cumulative_return::numeric, 6) AS cumulative_return,
    ROUND((cumulative_return * 100)::numeric, 2) AS cumulative_return_pct
FROM cumulative_returns
ORDER BY symbol, date;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    symbol,
    EXP(SUM(LN(1 + COALESCE(
        (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
        NULLIF(LAG(close_price) OVER (PARTITION BY symbol ORDER BY date), 0),
        0
    ))) OVER (PARTITION BY symbol ORDER BY date)) - 1 AS cumulative_return
FROM stock_prices
ORDER BY symbol, date;
```

---

### 3.3 ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£

**ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£**ï¼šåˆ†æå„æœŸå¯¹ç´¯è®¡æ”¶ç›Šçš„è´¡çŒ®ã€‚

```sql
-- ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç´¯è®¡æ”¶ç›Šç‡åˆ†è§£ï¼šåˆ†æå„æœŸè´¡çŒ®
WITH daily_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END AS daily_return
    FROM stock_prices
),
cumulative_analysis AS (
    SELECT
        date,
        symbol,
        close_price,
        daily_return,
        EXP(SUM(LN(1 + COALESCE(daily_return, 0))) OVER (PARTITION BY symbol ORDER BY date)) - 1 AS cumulative_return,
        ROW_NUMBER() OVER (PARTITION BY symbol ORDER BY date) AS period_num
    FROM daily_returns
    WHERE daily_return IS NOT NULL
)
SELECT
    date,
    symbol,
    ROUND(daily_return::numeric, 6) AS daily_return,
    ROUND((daily_return * 100)::numeric, 2) AS daily_return_pct,
    ROUND(cumulative_return::numeric, 6) AS cumulative_return,
    ROUND((cumulative_return * 100)::numeric, 2) AS cumulative_return_pct,
    period_num
FROM cumulative_analysis
ORDER BY symbol, date;
```

---

## 4. å¹´åŒ–æ”¶ç›Šç‡

### 4.1 å¹´åŒ–æ”¶ç›Šç‡åŸç†

**å¹´åŒ–æ”¶ç›Šç‡ï¼ˆAnnualized Returnï¼‰**å°†ä¸åŒæœŸé™çš„æ”¶ç›Šç‡æ ‡å‡†åŒ–ä¸ºå¹´åº¦æ”¶ç›Šç‡ï¼Œä¾¿äºæ¯”è¾ƒã€‚

#### å¹´åŒ–æ”¶ç›Šç‡å®šä¹‰

**å¹´åŒ–æ”¶ç›Šç‡**ï¼šå°†æœŸé—´æ”¶ç›Šç‡$r$å¹´åŒ–ä¸ºå¹´åº¦æ”¶ç›Šç‡ï¼š
$$r_{annual} = (1 + r)^{n} - 1$$

å…¶ä¸­$n$æ˜¯å¹´åŒ–å€æ•°ï¼ˆå¦‚252ä¸ªäº¤æ˜“æ—¥ã€12ä¸ªæœˆç­‰ï¼‰ã€‚

#### å¹´åŒ–æ”¶ç›Šç‡å…¬å¼

**å¹´åŒ–å…¬å¼**ï¼š

- **æ—¥æ”¶ç›Šç‡å¹´åŒ–**ï¼š$r_{annual} = (1 + r_{daily})^{252} - 1$
- **æœˆæ”¶ç›Šç‡å¹´åŒ–**ï¼š$r_{annual} = (1 + r_{monthly})^{12} - 1$
- **å¯¹æ•°æ”¶ç›Šç‡å¹´åŒ–**ï¼š$r_{annual} = r_{log} \times 252$

### 4.2 å¹´åŒ–æ”¶ç›Šç‡è®¡ç®—å®ç°

**å¹´åŒ–æ”¶ç›Šç‡**çš„å®ç°å’Œä½¿ç”¨ã€‚

```sql
-- å¹´åŒ–æ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—å¹´åŒ–æ”¶ç›Šç‡';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—å¹´åŒ–æ”¶ç›Šç‡';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹´åŒ–æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—å¹´åŒ–æ”¶ç›Šç‡
WITH period_stats AS (
    SELECT
        symbol,
        MIN(date) AS start_date,
        MAX(date) AS end_date,
        COUNT(*) - 1 AS trading_days,
        FIRST_VALUE(close_price) OVER (PARTITION BY symbol ORDER BY date) AS start_price,
        LAST_VALUE(close_price) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS end_price
    FROM stock_prices
    GROUP BY symbol
),
total_return AS (
    SELECT
        symbol,
        start_date,
        end_date,
        trading_days,
        start_price,
        end_price,
        CASE
            WHEN start_price = 0 THEN NULL
            ELSE (end_price - start_price) / start_price
        END AS total_return,
        -- å‡è®¾ä¸€å¹´252ä¸ªäº¤æ˜“æ—¥
        252.0 AS trading_days_per_year
    FROM period_stats
)
SELECT
    symbol,
    start_date,
    end_date,
    trading_days,
    start_price,
    end_price,
    ROUND(total_return::numeric, 6) AS total_return,
    ROUND((total_return * 100)::numeric, 2) AS total_return_pct,
    CASE
        WHEN trading_days = 0 THEN NULL
        ELSE ROUND((POWER(1 + total_return, trading_days_per_year / trading_days) - 1)::numeric, 6)
    END AS annualized_return,
    ROUND((POWER(1 + total_return, trading_days_per_year / NULLIF(trading_days, 0)) - 1) * 100, 2) AS annualized_return_pct
FROM total_return
WHERE total_return IS NOT NULL
ORDER BY symbol;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    symbol,
    COUNT(*) AS trading_days,
    MIN(close_price) AS min_price,
    MAX(close_price) AS max_price
FROM stock_prices
GROUP BY symbol;
```

---

### 4.3 ä¸åŒæœŸé™å¹´åŒ–

**ä¸åŒæœŸé™å¹´åŒ–**ï¼šå¤„ç†ä¸åŒæœŸé™çš„æ”¶ç›Šç‡å¹´åŒ–ã€‚

```sql
-- ä¸åŒæœŸé™å¹´åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•è®¡ç®—ä¸åŒæœŸé™å¹´åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è®¡ç®—ä¸åŒæœŸé™å¹´åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ä¸åŒæœŸé™å¹´åŒ–è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä¸åŒæœŸé™å¹´åŒ–ï¼šæ—¥ã€å‘¨ã€æœˆæ”¶ç›Šç‡å¹´åŒ–
WITH period_returns AS (
    SELECT
        symbol,
        -- æ—¥æ”¶ç›Šç‡
        AVG(CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END) AS avg_daily_return,
        -- å‘¨æ”¶ç›Šç‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
        AVG(CASE
            WHEN LAG(close_price, 5) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price, 5) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price, 5) OVER (PARTITION BY symbol ORDER BY date)
        END) AS avg_weekly_return,
        -- æœˆæ”¶ç›Šç‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
        AVG(CASE
            WHEN LAG(close_price, 20) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price, 20) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price, 20) OVER (PARTITION BY symbol ORDER BY date)
        END) AS avg_monthly_return
    FROM stock_prices
    GROUP BY symbol
)
SELECT
    symbol,
    ROUND(avg_daily_return::numeric, 6) AS avg_daily_return,
    ROUND((POWER(1 + COALESCE(avg_daily_return, 0), 252) - 1)::numeric, 6) AS annualized_from_daily,
    ROUND(avg_weekly_return::numeric, 6) AS avg_weekly_return,
    ROUND((POWER(1 + COALESCE(avg_weekly_return, 0), 52) - 1)::numeric, 6) AS annualized_from_weekly,
    ROUND(avg_monthly_return::numeric, 6) AS avg_monthly_return,
    ROUND((POWER(1 + COALESCE(avg_monthly_return, 0), 12) - 1)::numeric, 6) AS annualized_from_monthly
FROM period_returns
ORDER BY symbol;
```

---

## 5. æ”¶ç›Šç‡è®¡ç®—ä¼˜åŒ–ç­–ç•¥

### 5.1 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºæ”¶ç›Šç‡è®¡ç®—åˆ›å»ºåˆé€‚çš„ç´¢å¼•ã€‚

```sql
-- ç´¢å¼•ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        -- ä»·æ ¼è¡¨ç´¢å¼•ï¼šåŠ é€Ÿæ—¶é—´åºåˆ—æŸ¥è¯¢
        CREATE INDEX IF NOT EXISTS idx_stock_prices_date_symbol
        ON stock_prices(date, symbol);

        CREATE INDEX IF NOT EXISTS idx_stock_prices_symbol_date
        ON stock_prices(symbol, date);

        RAISE NOTICE 'æ”¶ç›Šç‡è®¡ç®—ç´¢å¼•åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç´¢å¼•åˆ›å»ºå¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 çª—å£å‡½æ•°ä¼˜åŒ–

**çª—å£å‡½æ•°ä¼˜åŒ–**ï¼šä½¿ç”¨çª—å£å‡½æ•°ä¼˜åŒ–æ”¶ç›Šç‡è®¡ç®—ã€‚

```sql
-- çª—å£å‡½æ•°ä¼˜åŒ–ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜æ”¶ç›Šç‡
CREATE MATERIALIZED VIEW IF NOT EXISTS daily_returns_cache AS
SELECT
    date,
    symbol,
    close_price,
    LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price,
    CASE
        WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
        ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
             LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
    END AS daily_return
FROM stock_prices;

CREATE INDEX IF NOT EXISTS idx_daily_returns_cache_date_symbol
ON daily_returns_cache(date, symbol);

-- åˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_returns_cache;
```

### 5.3 æ‰¹é‡è®¡ç®—ä¼˜åŒ–

**æ‰¹é‡è®¡ç®—ä¼˜åŒ–**ï¼šä½¿ç”¨æ‰¹é‡æ“ä½œæé«˜æ€§èƒ½ã€‚

```sql
-- æ‰¹é‡è®¡ç®—ä¼˜åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        SET work_mem = '512MB';
        RAISE NOTICE 'work_memå·²è®¾ç½®ä¸º512MB';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ‰¹é‡è®¡ç®—ä¼˜åŒ–å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 6. PostgreSQL 18 å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œç®€å•æ”¶ç›Šç‡ã€å¯¹æ•°æ”¶ç›Šç‡å’Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—ï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡é‡‘èæ•°æ®æ”¶ç›Šç‡è®¡ç®—çš„æ€§èƒ½ã€‚

### 6.1 å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—åŸç†

PostgreSQL 18 çš„å¹¶è¡Œæ”¶ç›Šç‡è®¡ç®—é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æä»·æ ¼æ•°æ®
2. **å¹¶è¡Œè®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—æ”¶ç›Šç‡
3. **å¹¶è¡Œèšåˆ**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—ç´¯è®¡æ”¶ç›Šç‡
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è®¡ç®—ç»“æœ

### 6.2 å¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—

```sql
-- PostgreSQL 18 å¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œç®€å•æ”¶ç›Šç‡è®¡ç®—ï¼šæ—¥æ”¶ç›Šç‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
    FROM stock_prices
)
SELECT
    date,
    symbol,
    close_price,
    prev_price,
    CASE
        WHEN prev_price IS NULL OR prev_price <= 0 THEN NULL
        ELSE ROUND(((close_price - prev_price) / prev_price)::numeric, 6)
    END AS simple_return
FROM price_changes
WHERE prev_price IS NOT NULL AND prev_price > 0
ORDER BY symbol, date;
```

### 6.3 å¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—

```sql
-- PostgreSQL 18 å¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå¯¹æ•°æ”¶ç›Šç‡è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH price_changes AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price
    FROM stock_prices
)
SELECT
    date,
    symbol,
    close_price,
    prev_price,
    CASE
        WHEN prev_price IS NULL OR prev_price <= 0 THEN NULL
        ELSE ROUND(LN(close_price / prev_price)::numeric, 6)
    END AS log_return
FROM price_changes
WHERE prev_price IS NOT NULL AND prev_price > 0
ORDER BY symbol, date;
```

### 6.4 å¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—

```sql
-- PostgreSQL 18 å¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œç´¯è®¡æ”¶ç›Šç‡è®¡ç®—ï¼šä½¿ç”¨å¯¹æ•°æ”¶ç›Šç‡çš„å¯åŠ æ€§
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH log_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) > 0 THEN
                LN(close_price / LAG(close_price) OVER (PARTITION BY symbol ORDER BY date))
            ELSE NULL
        END AS log_return
    FROM stock_prices
),
cumulative_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        log_return,
        SUM(log_return) OVER (PARTITION BY symbol ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_log_return
    FROM log_returns
    WHERE log_return IS NOT NULL
)
SELECT
    date,
    symbol,
    close_price,
    ROUND(log_return::numeric, 6) AS log_return,
    ROUND(cumulative_log_return::numeric, 6) AS cumulative_log_return,
    ROUND((EXP(cumulative_log_return) - 1)::numeric, 6) AS cumulative_simple_return
FROM cumulative_returns
ORDER BY symbol, date;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 6.1 æŠ•èµ„ç»„åˆæ”¶ç›Šç‡åˆ†æ

**æŠ•èµ„ç»„åˆæ”¶ç›Šç‡åˆ†æ**è®¡ç®—å¤šåªè‚¡ç¥¨ç»„åˆçš„æ•´ä½“æ”¶ç›Šã€‚

```sql
-- æŠ•èµ„ç»„åˆæ”¶ç›Šç‡åˆ†æç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'portfolio_weights') THEN
            RAISE WARNING 'è¡¨ portfolio_weights ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE portfolio_weights (
                symbol VARCHAR(10) PRIMARY KEY,
                weight NUMERIC(5, 4) NOT NULL CHECK (weight >= 0 AND weight <= 1)
            );

            INSERT INTO portfolio_weights (symbol, weight) VALUES
                ('AAPL', 0.4),
                ('GOOGL', 0.6);

            RAISE NOTICE 'è¡¨ portfolio_weights åˆ›å»ºæˆåŠŸ';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»º';
            RETURN;
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒæŠ•èµ„ç»„åˆæ”¶ç›Šç‡åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æŠ•èµ„ç»„åˆåˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è®¡ç®—æŠ•èµ„ç»„åˆæ—¥æ”¶ç›Šç‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH daily_returns AS (
    SELECT
        date,
        symbol,
        close_price,
        LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) AS prev_price,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) IS NULL THEN NULL
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END AS daily_return
    FROM stock_prices
),
portfolio_returns AS (
    SELECT
        dr.date,
        SUM(dr.daily_return * pw.weight) AS portfolio_return
    FROM daily_returns dr
    JOIN portfolio_weights pw ON dr.symbol = pw.symbol
    WHERE dr.daily_return IS NOT NULL
    GROUP BY dr.date
)
SELECT
    date,
    ROUND(portfolio_return::numeric, 6) AS portfolio_daily_return,
    ROUND((portfolio_return * 100)::numeric, 4) AS portfolio_daily_return_pct,
    ROUND(EXP(SUM(LN(1 + portfolio_return)) OVER (ORDER BY date)) - 1, 6) AS cumulative_return,
    ROUND((EXP(SUM(LN(1 + portfolio_return)) OVER (ORDER BY date)) - 1) * 100, 2) AS cumulative_return_pct
FROM portfolio_returns
ORDER BY date;
```

### 6.2 è‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æ

**è‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æ**ï¼šå¯¹æ¯”å¤šåªè‚¡ç¥¨çš„æ”¶ç›Šç‡è¡¨ç°ã€‚

```sql
-- è‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'stock_prices') THEN
            RAISE WARNING 'è¡¨ stock_prices ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œè‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œè‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- è‚¡ç¥¨æ”¶ç›Šç‡å¯¹æ¯”ï¼šè®¡ç®—å„è‚¡ç¥¨çš„æ”¶ç›Šç‡ç»Ÿè®¡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH daily_returns AS (
    SELECT
        date,
        symbol,
        CASE
            WHEN LAG(close_price) OVER (PARTITION BY symbol ORDER BY date) = 0 THEN NULL
            ELSE (close_price - LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)) /
                 LAG(close_price) OVER (PARTITION BY symbol ORDER BY date)
        END AS daily_return
    FROM stock_prices
),
return_stats AS (
    SELECT
        symbol,
        COUNT(*) AS trading_days,
        AVG(daily_return) AS mean_return,
        STDDEV(daily_return) AS std_return,
        MIN(daily_return) AS min_return,
        MAX(daily_return) AS max_return,
        PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY daily_return) AS percentile_5,
        PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY daily_return) AS percentile_95
    FROM daily_returns
    WHERE daily_return IS NOT NULL
    GROUP BY symbol
),
cumulative_returns AS (
    SELECT DISTINCT
        symbol,
        EXP(SUM(LN(1 + COALESCE(daily_return, 0))) OVER (PARTITION BY symbol ORDER BY date)) - 1 AS cumulative_return
    FROM daily_returns
    WHERE daily_return IS NOT NULL
    ORDER BY symbol, date DESC
    LIMIT 1000
)
SELECT
    rs.symbol,
    rs.trading_days,
    ROUND(rs.mean_return::numeric, 6) AS mean_daily_return,
    ROUND((rs.mean_return * 252)::numeric, 6) AS annualized_return,
    ROUND(rs.std_return::numeric, 6) AS daily_volatility,
    ROUND((rs.std_return * SQRT(252))::numeric, 6) AS annualized_volatility,
    ROUND(cr.cumulative_return::numeric, 6) AS total_return,
    ROUND(rs.min_return::numeric, 6) AS worst_day,
    ROUND(rs.max_return::numeric, 6) AS best_day
FROM return_stats rs
LEFT JOIN (
    SELECT DISTINCT ON (symbol)
        symbol,
        cumulative_return
    FROM cumulative_returns
) cr ON rs.symbol = cr.symbol
ORDER BY annualized_return DESC;
```

### 6.3 åŸºé‡‘ä¸šç»©è¯„ä¼°

**åŸºé‡‘ä¸šç»©è¯„ä¼°**ï¼šè¯„ä¼°åŸºé‡‘çš„æ”¶ç›Šç‡è¡¨ç°ã€‚

```sql
-- åŸºé‡‘ä¸šç»©è¯„ä¼°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'fund_nav') THEN
            RAISE WARNING 'è¡¨ fund_nav ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE fund_nav (
                date DATE NOT NULL,
                fund_code VARCHAR(10) NOT NULL,
                nav NUMERIC(10, 4) NOT NULL,
                PRIMARY KEY (date, fund_code)
            );

            INSERT INTO fund_nav (date, fund_code, nav) VALUES
                ('2024-01-01', 'FUND001', 1.0000),
                ('2024-01-02', 'FUND001', 1.0100),
                ('2024-01-03', 'FUND001', 1.0080),
                ('2024-01-04', 'FUND001', 1.0120),
                ('2024-01-05', 'FUND001', 1.0150);

            RAISE NOTICE 'è¡¨ fund_nav åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒåŸºé‡‘ä¸šç»©è¯„ä¼°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'åŸºé‡‘ä¸šç»©è¯„ä¼°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åŸºé‡‘ä¸šç»©è¯„ä¼°ï¼šè®¡ç®—åŸºé‡‘æ”¶ç›Šç‡å’Œæ’å
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH fund_returns AS (
    SELECT
        date,
        fund_code,
        nav,
        CASE
            WHEN LAG(nav) OVER (PARTITION BY fund_code ORDER BY date) = 0 THEN NULL
            ELSE (nav - LAG(nav) OVER (PARTITION BY fund_code ORDER BY date)) /
                 LAG(nav) OVER (PARTITION BY fund_code ORDER BY date)
        END AS daily_return
    FROM fund_nav
),
fund_performance AS (
    SELECT
        fund_code,
        COUNT(*) AS trading_days,
        AVG(daily_return) AS mean_return,
        STDDEV(daily_return) AS std_return,
        EXP(SUM(LN(1 + COALESCE(daily_return, 0))) OVER (PARTITION BY fund_code ORDER BY date)) - 1 AS cumulative_return
    FROM fund_returns
    WHERE daily_return IS NOT NULL
    GROUP BY fund_code
),
fund_rankings AS (
    SELECT
        fund_code,
        trading_days,
        ROUND((mean_return * 252)::numeric, 6) AS annualized_return,
        ROUND((std_return * SQRT(252))::numeric, 6) AS annualized_volatility,
        ROUND(cumulative_return::numeric, 6) AS total_return,
        CASE
            WHEN std_return = 0 THEN NULL
            ELSE ROUND((mean_return / std_return * SQRT(252))::numeric, 4)
        END AS sharpe_ratio,
        RANK() OVER (ORDER BY (mean_return * 252) DESC) AS return_rank,
        RANK() OVER (ORDER BY CASE WHEN std_return = 0 THEN NULL ELSE (mean_return / std_return * SQRT(252)) END DESC) AS sharpe_rank
    FROM fund_performance
)
SELECT
    fund_code,
    annualized_return,
    annualized_volatility,
    total_return,
    sharpe_ratio,
    return_rank,
    sharpe_rank
FROM fund_rankings
ORDER BY sharpe_rank;
```

### 6.4 èµ„äº§é…ç½®æ”¶ç›Šç‡è®¡ç®—

**èµ„äº§é…ç½®æ”¶ç›Šç‡è®¡ç®—**ï¼šè®¡ç®—ä¸åŒèµ„äº§ç±»åˆ«çš„æ”¶ç›Šç‡ã€‚

```sql
-- èµ„äº§é…ç½®æ”¶ç›Šç‡è®¡ç®—ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_prices') THEN
            RAISE WARNING 'è¡¨ asset_prices ä¸å­˜åœ¨ï¼Œåˆ›å»ºç¤ºä¾‹è¡¨';

            CREATE TABLE asset_prices (
                date DATE NOT NULL,
                asset_class VARCHAR(20) NOT NULL,
                asset_code VARCHAR(10) NOT NULL,
                price NUMERIC(10, 2) NOT NULL,
                PRIMARY KEY (date, asset_class, asset_code)
            );

            INSERT INTO asset_prices (date, asset_class, asset_code, price) VALUES
                ('2024-01-01', 'Stock', 'AAPL', 150.00),
                ('2024-01-02', 'Stock', 'AAPL', 152.00),
                ('2024-01-01', 'Bond', 'BOND001', 100.00),
                ('2024-01-02', 'Bond', 'BOND001', 100.50);

            RAISE NOTICE 'è¡¨ asset_prices åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œèµ„äº§é…ç½®æ”¶ç›Šç‡è®¡ç®—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'èµ„äº§é…ç½®æ”¶ç›Šç‡è®¡ç®—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- èµ„äº§é…ç½®æ”¶ç›Šç‡ï¼šæŒ‰èµ„äº§ç±»åˆ«è®¡ç®—æ”¶ç›Šç‡
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH asset_returns AS (
    SELECT
        date,
        asset_class,
        asset_code,
        price,
        CASE
            WHEN LAG(price) OVER (PARTITION BY asset_class, asset_code ORDER BY date) = 0 THEN NULL
            ELSE (price - LAG(price) OVER (PARTITION BY asset_class, asset_code ORDER BY date)) /
                 LAG(price) OVER (PARTITION BY asset_class, asset_code ORDER BY date)
        END AS daily_return
    FROM asset_prices
),
class_returns AS (
    SELECT
        date,
        asset_class,
        AVG(daily_return) AS class_daily_return
    FROM asset_returns
    WHERE daily_return IS NOT NULL
    GROUP BY date, asset_class
),
class_performance AS (
    SELECT
        asset_class,
        COUNT(*) AS trading_days,
        AVG(class_daily_return) AS mean_return,
        STDDEV(class_daily_return) AS std_return,
        EXP(SUM(LN(1 + COALESCE(class_daily_return, 0))) OVER (PARTITION BY asset_class ORDER BY date)) - 1 AS cumulative_return
    FROM class_returns
    GROUP BY asset_class
)
SELECT
    asset_class,
    trading_days,
    ROUND((mean_return * 252)::numeric, 6) AS annualized_return,
    ROUND((std_return * SQRT(252))::numeric, 6) AS annualized_volatility,
    ROUND(cumulative_return::numeric, 6) AS total_return,
    CASE
        WHEN std_return = 0 THEN NULL
        ELSE ROUND((mean_return / std_return * SQRT(252))::numeric, 4)
    END AS sharpe_ratio
FROM class_performance
ORDER BY annualized_return DESC;
```

---

## 8. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 7.1 æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | æ•°å­¦å®šä¹‰ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|-----------|-----------|---------|------|------|
| **ç®€å•æ”¶ç›Šç‡** | $r_t = \frac{P_t - P_{t-1}}{P_{t-1}}$ | $O(1)$ | $O(1)$ | å•æœŸæ”¶ç›Š | ç›´è§‚ã€ç®€å• | å¤šæœŸè®¡ç®—å¤æ‚ |
| **å¯¹æ•°æ”¶ç›Šç‡** | $r_t = \ln\left(\frac{P_t}{P_{t-1}}\right)$ | $O(1)$ | $O(1)$ | æ—¶é—´åºåˆ— | æ—¶é—´å¯åŠ æ€§ | éœ€è¦æ­£ä»·æ ¼ |
| **ç´¯è®¡æ”¶ç›Šç‡** | $R_T = \prod_{t=1}^{T}(1 + r_t) - 1$ | $O(n)$ | $O(1)$ | å¤šæœŸæ”¶ç›Š | å‡†ç¡® | è®¡ç®—å¤æ‚ |
| **å¹´åŒ–æ”¶ç›Šç‡** | $r_{annual} = (1 + r)^{n} - 1$ | $O(1)$ | $O(1)$ | æ”¶ç›Šæ¯”è¾ƒ | æ ‡å‡†åŒ– | éœ€è¦æœŸé™ä¿¡æ¯ |

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**ï¼š
   - åœ¨(date, symbol)ä¸Šåˆ›å»ºå¤åˆç´¢å¼•
   - ä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ›å»ºç´¢å¼•

2. **çª—å£å‡½æ•°ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨çª—å£å‡½æ•°é¿å…è‡ªè¿æ¥
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æœ

3. **æ‰¹é‡å¤„ç†**ï¼š
   - æ‰¹é‡è®¡ç®—å¤šä¸ªèµ„äº§çš„æ”¶ç›Šç‡
   - ä½¿ç”¨å¹¶è¡ŒæŸ¥è¯¢

### 7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šé™¤é›¶é”™è¯¯

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨NULLIFå¤„ç†é›¶å€¼ã€æ£€æŸ¥ä»·æ ¼æœ‰æ•ˆæ€§

**é—®é¢˜2**ï¼šç¼ºå¤±å€¼å¤„ç†

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨LAGå‡½æ•°ã€å¡«å……ç¼ºå¤±å€¼ã€è·³è¿‡ç¼ºå¤±æ•°æ®

**é—®é¢˜3**ï¼šç²¾åº¦é—®é¢˜

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨NUMERICç±»å‹ã€æ§åˆ¶å°æ•°ä½æ•°ã€é¿å…æµ®ç‚¹è¯¯å·®

**é—®é¢˜4**ï¼šæ€§èƒ½æ…¢

- **è§£å†³æ–¹æ¡ˆ**ï¼šåˆ›å»ºç´¢å¼•ã€ä½¿ç”¨ç‰©åŒ–è§†å›¾ã€ä¼˜åŒ–çª—å£å‡½æ•°

---

## 9. æœ€ä½³å®è·µ

### 8.1 è®¡ç®—æ–¹æ³•é€‰æ‹©

1. **å•æœŸæ”¶ç›Š**ï¼šä½¿ç”¨ç®€å•æ”¶ç›Šç‡
2. **å¤šæœŸæ”¶ç›Š**ï¼šä½¿ç”¨å¯¹æ•°æ”¶ç›Šç‡
3. **æŠ•èµ„è¯„ä¼°**ï¼šä½¿ç”¨ç´¯è®¡æ”¶ç›Šç‡
4. **æ”¶ç›Šæ¯”è¾ƒ**ï¼šä½¿ç”¨å¹´åŒ–æ”¶ç›Šç‡

### 8.2 æ•°æ®è´¨é‡ä¿è¯

1. **ä»·æ ¼éªŒè¯**ï¼šç¡®ä¿ä»·æ ¼ä¸ºæ­£æ•°
2. **ç¼ºå¤±å€¼å¤„ç†**ï¼šåˆç†å¤„ç†ç¼ºå¤±æ•°æ®
3. **å¼‚å¸¸å€¼æ£€æµ‹**ï¼šè¯†åˆ«å’Œå¤„ç†å¼‚å¸¸å€¼

### 8.3 ç²¾åº¦æ§åˆ¶

1. **æ•°æ®ç±»å‹**ï¼šä½¿ç”¨NUMERICç±»å‹
2. **å°æ•°ä½æ•°**ï¼šç»Ÿä¸€å°æ•°ä½æ•°
3. **èˆå…¥è§„åˆ™**ï¼šç»Ÿä¸€èˆå…¥è§„åˆ™

### 8.4 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **è¾¹ç•Œæ£€æŸ¥**ï¼šæ£€æŸ¥é™¤é›¶å’Œè´Ÿæ•°æƒ…å†µ
2. **NULLå¤„ç†**ï¼šæ­£ç¡®å¤„ç†NULLå€¼
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨ç´¢å¼•å’Œç‰©åŒ–è§†å›¾
4. **é”™è¯¯å¤„ç†**ï¼šæ·»åŠ é”™è¯¯å¤„ç†é€»è¾‘

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

- ã€Šé‡‘èè®¡é‡å­¦ã€‹ï¼ˆFinancial Econometricsï¼‰- æ”¶ç›Šç‡è®¡ç®—ç†è®º
- ã€ŠæŠ•èµ„å­¦ã€‹ï¼ˆInvestmentsï¼‰- æ”¶ç›Šç‡åˆ†ææ–¹æ³•

### PostgreSQLå®˜æ–¹æ–‡æ¡£

- [çª—å£å‡½æ•°](https://www.postgresql.org/docs/current/tutorial-window.html)
- [æ•°å­¦å‡½æ•°](https://www.postgresql.org/docs/current/functions-math.html)
- [èšåˆå‡½æ•°](https://www.postgresql.org/docs/current/functions-aggregate.html)

### åœ¨çº¿èµ„æº

- PostgreSQLé‡‘èè®¡ç®—æŒ‡å—
- æ”¶ç›Šç‡è®¡ç®—æ–¹æ³•è¯¦è§£
- é‡‘èæ•°æ®åˆ†ææœ€ä½³å®è·µ

### ç›¸å…³ç®—æ³•

- [é£é™©è¯„ä¼°ç®—æ³•](./é£é™©è¯„ä¼°ç®—æ³•.md) - é£é™©è¯„ä¼°
- [æŠ•èµ„ç»„åˆä¼˜åŒ–](./æŠ•èµ„ç»„åˆä¼˜åŒ–.md) - æŠ•èµ„ç»„åˆä¼˜åŒ–
- [é‡‘èæ—¶é—´åºåˆ—åˆ†æ](./é‡‘èæ—¶é—´åºåˆ—åˆ†æ.md) - æ—¶é—´åºåˆ—åˆ†æ

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
