# PostgreSQL 投资组合优化完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 投资组合 | 优化算法
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)

---

## 📋 目录

- [PostgreSQL 投资组合优化完整指南](#postgresql-投资组合优化完整指南)
  - [📋 目录](#-目录)
  - [投资组合优化概述](#投资组合优化概述)
    - [理论基础](#理论基础)
      - [投资组合优化问题定义](#投资组合优化问题定义)
      - [优化方法分类](#优化方法分类)
      - [优化目标选择](#优化目标选择)
    - [核心优化方法](#核心优化方法)
  - [1. 均值-方差优化](#1-均值-方差优化)
    - [1.1 均值-方差优化原理](#11-均值-方差优化原理)
      - [Markowitz模型](#markowitz模型)
      - [有效前沿](#有效前沿)
    - [1.2 有效前沿计算实现](#12-有效前沿计算实现)
    - [1.3 最优组合选择](#13-最优组合选择)
  - [2. 风险平价](#2-风险平价)
    - [2.1 风险平价原理](#21-风险平价原理)
      - [风险平价定义](#风险平价定义)
      - [风险贡献](#风险贡献)
    - [2.2 风险平价权重实现](#22-风险平价权重实现)
    - [2.3 风险平价优化](#23-风险平价优化)
  - [3. 最小方差组合](#3-最小方差组合)
    - [3.1 最小方差组合原理](#31-最小方差组合原理)
      - [最小方差问题](#最小方差问题)
      - [优化方法](#优化方法)
    - [3.2 最小方差权重实现](#32-最小方差权重实现)
    - [3.3 约束最小方差](#33-约束最小方差)
  - [4. 投资组合优化策略](#4-投资组合优化策略)
    - [4.1 协方差矩阵优化](#41-协方差矩阵优化)
    - [4.2 权重约束优化](#42-权重约束优化)
    - [4.3 性能优化](#43-性能优化)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 多资产组合优化](#51-多资产组合优化)
    - [5.2 动态再平衡策略](#52-动态再平衡策略)
    - [5.3 因子投资组合优化](#53-因子投资组合优化)
    - [5.4 风险预算组合优化](#54-风险预算组合优化)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 优化方法对比](#61-优化方法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 优化方法选择](#71-优化方法选择)
    - [7.2 约束条件设置](#72-约束条件设置)
    - [7.3 参数调优](#73-参数调优)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 投资组合优化概述

**投资组合优化（Portfolio Optimization）**通过数学方法找到最优资产配置，平衡收益和风险，是现代投资组合理论的核心。

### 理论基础

#### 投资组合优化问题定义

**投资组合优化问题**：给定$n$个资产，找到权重向量$\mathbf{w} = (w_1, w_2, \ldots, w_n)$，使得：
$$\max_{\mathbf{w}} f(\mathbf{w}) \text{ subject to } \sum_{i=1}^{n} w_i = 1, w_i \geq 0$$

其中$f(\mathbf{w})$是目标函数（如夏普比率、收益、风险等）。

#### 优化方法分类

投资组合优化方法分类：

1. **均值-方差优化（Markowitz）**：
   - 目标：最大化夏普比率
   - 约束：权重和为1，权重非负
   - 时间复杂度：$O(n^3)$

2. **风险平价（Risk Parity）**：
   - 目标：等风险贡献
   - 约束：权重和为1
   - 时间复杂度：$O(n^2)$

3. **最小方差组合（Minimum Variance）**：
   - 目标：最小化组合方差
   - 约束：权重和为1，权重非负
   - 时间复杂度：$O(n^3)$

#### 优化目标选择

选择优化目标的考虑因素：

1. **风险偏好**：风险厌恶用最小方差，风险中性用均值-方差
2. **市场环境**：牛市用均值-方差，熊市用最小方差
3. **资产数量**：少资产用均值-方差，多资产用风险平价

### 核心优化方法

| 方法 | 数学定义 | 目标 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|---------|------|-----------|-----------|---------|
| **均值-方差** | $\max \frac{\mathbf{w}^T \boldsymbol{\mu} - R_f}{\sqrt{\mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}}}$ | 最大化夏普比率 | $O(n^3)$ | $O(n^2)$ | 标准优化 |
| **风险平价** | $\min \sum_{i,j} (RC_i - RC_j)^2$ | 等风险贡献 | $O(n^2)$ | $O(n^2)$ | 多资产组合 |
| **最小方差** | $\min \mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}$ | 最小化组合方差 | $O(n^3)$ | $O(n^2)$ | 风险最小化 |

---

## 1. 均值-方差优化

### 1.1 均值-方差优化原理

**均值-方差优化（Mean-Variance Optimization）**是Markowitz投资组合理论的核心。

#### Markowitz模型

**Markowitz模型**：在给定风险水平下最大化收益，或在给定收益水平下最小化风险：
$$\max_{\mathbf{w}} \mathbf{w}^T \boldsymbol{\mu} - \lambda \mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}$$

其中：

- $\boldsymbol{\mu}$：期望收益率向量
- $\boldsymbol{\Sigma}$：协方差矩阵
- $\lambda$：风险厌恶系数

#### 有效前沿

**有效前沿（Efficient Frontier）**：所有有效投资组合的集合，即在给定风险水平下收益最高的组合。

### 1.2 有效前沿计算实现

**有效前沿**的实现和使用。

```sql
-- 创建资产收益率数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 已存在，先删除';
            DROP TABLE asset_returns CASCADE;
        END IF;

        CREATE TABLE asset_returns (
            date DATE NOT NULL,
            asset VARCHAR(10) NOT NULL,
            return_rate NUMERIC(10, 6) NOT NULL,
            PRIMARY KEY (date, asset)
        );

        -- 插入示例数据
        INSERT INTO asset_returns (date, asset, return_rate) VALUES
            ('2024-01-01', 'A', 0.02), ('2024-01-02', 'A', -0.01),
            ('2024-01-03', 'A', 0.015), ('2024-01-01', 'B', 0.01),
            ('2024-01-02', 'B', 0.02), ('2024-01-03', 'B', -0.005),
            ('2024-01-01', 'C', 0.005), ('2024-01-02', 'C', 0.01),
            ('2024-01-03', 'C', 0.008);

        RAISE NOTICE '表 asset_returns 创建成功，已插入9条数据';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 asset_returns 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 计算资产统计信息（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 不存在，无法计算有效前沿';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算有效前沿';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '有效前沿计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算资产均值和协方差矩阵
WITH asset_stats AS (
    SELECT
        asset,
        AVG(return_rate) AS mean_return,
        STDDEV(return_rate) AS std_return,
        COUNT(*) AS n_obs
    FROM asset_returns
    GROUP BY asset
),
covariance_matrix AS (
    SELECT
        a1.asset AS asset1,
        a2.asset AS asset2,
        AVG((a1.return_rate - s1.mean_return) * (a2.return_rate - s2.mean_return)) AS covariance
    FROM asset_returns a1
    JOIN asset_returns a2 ON a1.date = a2.date
    JOIN asset_stats s1 ON a1.asset = s1.asset
    JOIN asset_stats s2 ON a2.asset = s2.asset
    GROUP BY a1.asset, a2.asset
)
SELECT
    asset1,
    asset2,
    ROUND(covariance::numeric, 6) AS covariance,
    CASE
        WHEN asset1 = asset2 THEN ROUND(SQRT(covariance)::numeric, 6)
        ELSE NULL
    END AS volatility
FROM covariance_matrix
ORDER BY asset1, asset2;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    asset,
    AVG(return_rate) AS mean_return,
    STDDEV(return_rate) AS std_return
FROM asset_returns
GROUP BY asset;
```

---

### 1.3 最优组合选择

**最优组合选择**：从有效前沿中选择最优组合。

```sql
-- 最优组合选择：最大化夏普比率（带错误处理和性能测试）
DO $$
DECLARE
    risk_free_rate NUMERIC := 0.03;  -- 年化无风险利率3%
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 不存在，无法选择最优组合';
            RETURN;
        END IF;
        RAISE NOTICE '开始选择最优组合，无风险利率: %', risk_free_rate;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '最优组合选择准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 最优组合选择：计算不同权重组合的夏普比率
WITH asset_stats AS (
    SELECT
        asset,
        AVG(return_rate) AS mean_return,
        STDDEV(return_rate) AS std_return
    FROM asset_returns
    GROUP BY asset
),
weight_combinations AS (
    SELECT
        a1.asset AS asset1,
        a2.asset AS asset2,
        0.5 AS weight1,
        0.5 AS weight2
    FROM asset_stats a1
    CROSS JOIN asset_stats a2
    WHERE a1.asset < a2.asset
),
portfolio_stats AS (
    SELECT
        wc.asset1,
        wc.asset2,
        wc.weight1,
        wc.weight2,
        as1.mean_return * wc.weight1 + as2.mean_return * wc.weight2 AS portfolio_return,
        SQRT(POWER(as1.std_return * wc.weight1, 2) + POWER(as2.std_return * wc.weight2, 2)) AS portfolio_volatility,
        risk_free_rate / 252.0 AS risk_free_rate_daily
    FROM weight_combinations wc
    JOIN asset_stats as1 ON wc.asset1 = as1.asset
    JOIN asset_stats as2 ON wc.asset2 = as2.asset
)
SELECT
    asset1,
    asset2,
    weight1,
    weight2,
    ROUND(portfolio_return::numeric, 6) AS portfolio_return,
    ROUND(portfolio_volatility::numeric, 6) AS portfolio_volatility,
    CASE
        WHEN portfolio_volatility = 0 THEN NULL
        ELSE ROUND(((portfolio_return - risk_free_rate_daily) / portfolio_volatility * SQRT(252.0))::numeric, 4)
    END AS sharpe_ratio
FROM portfolio_stats
ORDER BY sharpe_ratio DESC NULLS LAST
LIMIT 10;
```

---

## 2. 风险平价

### 2.1 风险平价原理

**风险平价（Risk Parity）**使各资产对组合风险的贡献相等。

#### 风险平价定义

**风险平价**：各资产的风险贡献相等：
$$RC_i = w_i \times \frac{\partial \sigma_p}{\partial w_i} = \text{constant}$$

其中$RC_i$是资产$i$的风险贡献。

#### 风险贡献

**风险贡献**：资产$i$对组合风险的贡献：
$$RC_i = w_i \times \frac{(\boldsymbol{\Sigma} \mathbf{w})_i}{\sigma_p}$$

### 2.2 风险平价权重实现

**风险平价权重**的实现和使用。

```sql
-- 风险平价权重计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 不存在，无法计算风险平价权重';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算风险平价权重';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '风险平价计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算风险平价权重（简化版：基于波动率倒数）
WITH asset_volatility AS (
    SELECT
        asset,
        STDDEV(return_rate) AS volatility
    FROM asset_returns
    GROUP BY asset
),
inverse_volatility AS (
    SELECT
        asset,
        volatility,
        1.0 / NULLIF(volatility, 0) AS inv_vol
    FROM asset_volatility
),
total_inv_vol AS (
    SELECT SUM(inv_vol) AS total_inv_vol
    FROM inverse_volatility
)
SELECT
    iv.asset,
    ROUND(iv.volatility::numeric, 6) AS volatility,
    ROUND((iv.inv_vol / tiv.total_inv_vol)::numeric, 4) AS risk_parity_weight
FROM inverse_volatility iv
CROSS JOIN total_inv_vol tiv
ORDER BY iv.asset;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    asset,
    STDDEV(return_rate) AS volatility
FROM asset_returns
GROUP BY asset;
```

---

### 2.3 风险平价优化

**风险平价优化**：迭代优化风险平价权重。

```sql
-- 风险平价优化（简化版，带错误处理）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '风险平价优化需要迭代算法';
        -- 实际实现需要多次迭代调整权重
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '风险平价优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 3. 最小方差组合

### 3.1 最小方差组合原理

**最小方差组合（Minimum Variance Portfolio）**在给定约束下最小化组合方差。

#### 最小方差问题

**最小方差问题**：
$$\min_{\mathbf{w}} \mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w} \text{ subject to } \sum_{i=1}^{n} w_i = 1, w_i \geq 0$$

#### 优化方法

**优化方法**：

1. **拉格朗日乘数法**：求解约束优化问题
2. **二次规划**：使用二次规划求解器
3. **简化方法**：使用波动率倒数作为权重

### 3.2 最小方差权重实现

**最小方差权重**的实现和使用。

```sql
-- 最小方差组合计算（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 不存在，无法计算最小方差组合';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算最小方差组合';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '最小方差组合计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算最小方差组合（简化版：等权重作为基准）
WITH asset_stats AS (
    SELECT
        asset,
        AVG(return_rate) AS mean_return,
        STDDEV(return_rate) AS std_return,
        VARIANCE(return_rate) AS variance
    FROM asset_returns
    GROUP BY asset
),
equal_weight_portfolio AS (
    SELECT
        COUNT(*) AS n_assets,
        1.0 / COUNT(*) AS equal_weight
    FROM asset_stats
),
portfolio_variance AS (
    SELECT
        SUM(variance * ew.equal_weight * ew.equal_weight) AS portfolio_var
    FROM asset_stats
    CROSS JOIN equal_weight_portfolio ew
)
SELECT
    n_assets,
    ROUND(equal_weight::numeric, 4) AS equal_weight,
    ROUND(SQRT(portfolio_var)::numeric, 6) AS portfolio_volatility
FROM equal_weight_portfolio
CROSS JOIN portfolio_variance;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    asset,
    VARIANCE(return_rate) AS variance
FROM asset_returns
GROUP BY asset;
```

---

### 3.3 约束最小方差

**约束最小方差**：添加约束条件的最小方差组合。

```sql
-- 约束最小方差（带错误处理和性能测试）
DO $$
DECLARE
    min_weight NUMERIC := 0.1;  -- 最小权重10%
    max_weight NUMERIC := 0.5;  -- 最大权重50%
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 不存在，无法计算约束最小方差';
            RETURN;
        END IF;
        RAISE NOTICE '开始计算约束最小方差，最小权重: %, 最大权重: %', min_weight, max_weight;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '约束最小方差计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 约束最小方差：使用波动率倒数作为权重（简化版）
WITH asset_volatility AS (
    SELECT
        asset,
        STDDEV(return_rate) AS volatility
    FROM asset_returns
    GROUP BY asset
),
inverse_volatility AS (
    SELECT
        asset,
        volatility,
        1.0 / NULLIF(volatility, 0) AS inv_vol
    FROM asset_volatility
),
normalized_weights AS (
    SELECT
        asset,
        inv_vol,
        inv_vol / SUM(inv_vol) OVER () AS raw_weight,
        -- 应用约束
        GREATEST(min_weight, LEAST(max_weight, inv_vol / SUM(inv_vol) OVER ())) AS constrained_weight
    FROM inverse_volatility
),
rebalanced_weights AS (
    SELECT
        asset,
        constrained_weight,
        constrained_weight / SUM(constrained_weight) OVER () AS final_weight
    FROM normalized_weights
)
SELECT
    asset,
    ROUND(volatility::numeric, 6) AS volatility,
    ROUND(final_weight::numeric, 4) AS optimal_weight
FROM rebalanced_weights
JOIN asset_volatility USING (asset)
ORDER BY asset;
```

---

## 4. 投资组合优化策略

### 4.1 协方差矩阵优化

**协方差矩阵优化**：优化协方差矩阵的计算和存储。

```sql
-- 协方差矩阵优化：使用物化视图缓存协方差矩阵
CREATE MATERIALIZED VIEW IF NOT EXISTS covariance_matrix_cache AS
WITH asset_stats AS (
    SELECT
        asset,
        AVG(return_rate) AS mean_return
    FROM asset_returns
    GROUP BY asset
)
SELECT
    a1.asset AS asset1,
    a2.asset AS asset2,
    AVG((a1.return_rate - s1.mean_return) * (a2.return_rate - s2.mean_return)) AS covariance
FROM asset_returns a1
JOIN asset_returns a2 ON a1.date = a2.date
JOIN asset_stats s1 ON a1.asset = s1.asset
JOIN asset_stats s2 ON a2.asset = s2.asset
GROUP BY a1.asset, a2.asset;

CREATE INDEX IF NOT EXISTS idx_covariance_matrix_cache_asset1_asset2
ON covariance_matrix_cache(asset1, asset2);

-- 刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY covariance_matrix_cache;
```

### 4.2 权重约束优化

**权重约束优化**：优化权重约束的处理。

```sql
-- 权重约束优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 创建权重约束表
        CREATE TABLE IF NOT EXISTS weight_constraints (
            asset VARCHAR(10) PRIMARY KEY,
            min_weight NUMERIC(5, 4) DEFAULT 0,
            max_weight NUMERIC(5, 4) DEFAULT 1,
            CHECK (min_weight >= 0 AND max_weight <= 1 AND min_weight <= max_weight)
        );

        RAISE NOTICE '权重约束表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '权重约束优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 4.3 性能优化

**性能优化**：使用并行查询和批量处理。

```sql
-- 性能优化（带错误处理）
DO $$
BEGIN
    BEGIN
        SET max_parallel_workers_per_gather = 4;
        SET work_mem = '1GB';
        RAISE NOTICE '性能优化配置已设置';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '性能优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. 实际应用案例

### 5.1 多资产组合优化

**多资产组合优化**综合考虑多个资产的收益和风险。

```sql
-- 多资产组合优化示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'optimization_results') THEN
            RAISE WARNING '表 optimization_results 不存在，创建示例表';

            CREATE TABLE optimization_results (
                optimization_id SERIAL PRIMARY KEY,
                asset VARCHAR(10) NOT NULL,
                weight NUMERIC(5, 4) NOT NULL,
                expected_return NUMERIC(10, 6),
                portfolio_volatility NUMERIC(10, 6),
                sharpe_ratio NUMERIC(10, 4),
                created_at TIMESTAMP DEFAULT NOW()
            );

            RAISE NOTICE '表 optimization_results 创建成功';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 不存在，请先创建';
            RETURN;
        END IF;

        RAISE NOTICE '开始执行多资产组合优化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '组合优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 计算优化后的组合指标
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH asset_stats AS (
    SELECT
        asset,
        AVG(return_rate) AS mean_return,
        STDDEV(return_rate) AS std_return
    FROM asset_returns
    GROUP BY asset
),
optimized_weights AS (
    SELECT
        asset,
        CASE asset
            WHEN 'A' THEN 0.3
            WHEN 'B' THEN 0.4
            WHEN 'C' THEN 0.3
        END AS weight
    FROM asset_stats
),
portfolio_stats AS (
    SELECT
        SUM(as_stats.mean_return * ow.weight) AS portfolio_return,
        SQRT(SUM(POWER(as_stats.std_return * ow.weight, 2))) AS portfolio_volatility,
        0.03 / 252.0 AS risk_free_rate
    FROM asset_stats as_stats
    JOIN optimized_weights ow ON as_stats.asset = ow.asset
)
SELECT
    ROUND(portfolio_return::numeric, 6) AS expected_return,
    ROUND(portfolio_volatility::numeric, 6) AS portfolio_volatility,
    ROUND(((portfolio_return - risk_free_rate) / NULLIF(portfolio_volatility, 0) * SQRT(252.0))::numeric, 4) AS sharpe_ratio
FROM portfolio_stats;
```

### 5.2 动态再平衡策略

**动态再平衡策略**：定期重新优化投资组合。

```sql
-- 动态再平衡策略（带错误处理和性能测试）
DO $$
DECLARE
    rebalance_frequency INTEGER := 30;  -- 每30天再平衡一次
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'asset_returns') THEN
            RAISE WARNING '表 asset_returns 不存在，无法执行动态再平衡';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行动态再平衡，再平衡频率: % 天', rebalance_frequency;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '动态再平衡准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 动态再平衡：计算再平衡日期和权重
WITH rebalance_dates AS (
    SELECT DISTINCT
        DATE_TRUNC('month', date) + (rebalance_frequency - 1) * INTERVAL '1 day' AS rebalance_date
    FROM asset_returns
    WHERE date >= CURRENT_DATE - INTERVAL '1 year'
),
recent_returns AS (
    SELECT
        date,
        asset,
        return_rate
    FROM asset_returns
    WHERE date >= CURRENT_DATE - INTERVAL '90 days'
),
rebalance_weights AS (
    SELECT
        rd.rebalance_date,
        ar.asset,
        STDDEV(ar.return_rate) AS volatility,
        1.0 / NULLIF(STDDEV(ar.return_rate), 0) AS inv_vol
    FROM rebalance_dates rd
    CROSS JOIN (SELECT DISTINCT asset FROM asset_returns) ar
    LEFT JOIN recent_returns rr ON ar.asset = rr.asset
    GROUP BY rd.rebalance_date, ar.asset
)
SELECT
    rebalance_date,
    asset,
    ROUND((inv_vol / SUM(inv_vol) OVER (PARTITION BY rebalance_date))::numeric, 4) AS rebalance_weight
FROM rebalance_weights
WHERE inv_vol IS NOT NULL
ORDER BY rebalance_date, asset;
```

### 5.3 因子投资组合优化

**因子投资组合优化**：基于因子模型的组合优化。

```sql
-- 因子投资组合优化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'factor_loadings') THEN
            RAISE WARNING '表 factor_loadings 不存在，创建示例表';

            CREATE TABLE factor_loadings (
                asset VARCHAR(10) NOT NULL,
                factor VARCHAR(20) NOT NULL,
                loading NUMERIC(10, 6) NOT NULL,
                PRIMARY KEY (asset, factor)
            );

            INSERT INTO factor_loadings (asset, factor, loading) VALUES
                ('A', 'Market', 1.2),
                ('A', 'Size', 0.8),
                ('B', 'Market', 0.9),
                ('B', 'Size', 1.1);

            RAISE NOTICE '表 factor_loadings 创建成功';
        END IF;

        RAISE NOTICE '开始执行因子投资组合优化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '因子投资组合优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 因子投资组合优化：基于因子暴露优化权重
WITH factor_exposures AS (
    SELECT
        asset,
        SUM(loading) AS total_factor_exposure
    FROM factor_loadings
    GROUP BY asset
),
optimized_weights AS (
    SELECT
        asset,
        total_factor_exposure,
        total_factor_exposure / SUM(total_factor_exposure) OVER () AS factor_weight
    FROM factor_exposures
)
SELECT
    asset,
    ROUND(total_factor_exposure::numeric, 6) AS factor_exposure,
    ROUND(factor_weight::numeric, 4) AS optimal_weight
FROM optimized_weights
ORDER BY factor_weight DESC;
```

### 5.4 风险预算组合优化

**风险预算组合优化**：基于风险预算的组合优化。

```sql
-- 风险预算组合优化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'risk_budgets') THEN
            RAISE WARNING '表 risk_budgets 不存在，创建示例表';

            CREATE TABLE risk_budgets (
                asset VARCHAR(10) PRIMARY KEY,
                risk_budget NUMERIC(5, 4) NOT NULL CHECK (risk_budget >= 0 AND risk_budget <= 1)
            );

            INSERT INTO risk_budgets (asset, risk_budget) VALUES
                ('A', 0.3),
                ('B', 0.4),
                ('C', 0.3);

            RAISE NOTICE '表 risk_budgets 创建成功';
        END IF;

        RAISE NOTICE '开始执行风险预算组合优化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '风险预算组合优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 风险预算组合优化：根据风险预算分配权重
WITH asset_volatility AS (
    SELECT
        asset,
        STDDEV(return_rate) AS volatility
    FROM asset_returns
    GROUP BY asset
),
risk_budget_weights AS (
    SELECT
        av.asset,
        av.volatility,
        rb.risk_budget,
        rb.risk_budget / NULLIF(av.volatility, 0) AS weight_factor
    FROM asset_volatility av
    JOIN risk_budgets rb ON av.asset = rb.asset
)
SELECT
    asset,
    ROUND(volatility::numeric, 6) AS volatility,
    ROUND(risk_budget::numeric, 4) AS risk_budget,
    ROUND((weight_factor / SUM(weight_factor) OVER ())::numeric, 4) AS optimal_weight
FROM risk_budget_weights
ORDER BY asset;
```

---

## 6. 算法性能对比与优化

### 6.1 优化方法对比

| 方法 | 数学定义 | 时间复杂度 | 空间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|-----------|-----------|---------|------|------|
| **均值-方差** | $\max \frac{\mathbf{w}^T \boldsymbol{\mu} - R_f}{\sqrt{\mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}}}$ | $O(n^3)$ | $O(n^2)$ | 标准优化 | 理论完善 | 需要估计参数 |
| **风险平价** | $\min \sum_{i,j} (RC_i - RC_j)^2$ | $O(n^2)$ | $O(n^2)$ | 多资产组合 | 稳健 | 可能忽略收益 |
| **最小方差** | $\min \mathbf{w}^T \boldsymbol{\Sigma} \mathbf{w}$ | $O(n^3)$ | $O(n^2)$ | 风险最小化 | 简单 | 可能收益较低 |

### 6.2 性能优化建议

1. **矩阵运算优化**：
   - 使用数组类型优化矩阵计算
   - 缓存协方差矩阵

2. **并行处理**：
   - 利用PostgreSQL并行查询
   - 批量计算多个组合

3. **算法优化**：
   - 使用简化方法（如波动率倒数）
   - 迭代优化算法

### 6.3 常见问题与解决方案

**问题1**：协方差矩阵估计不准确

- **解决方案**：使用更长的历史数据、使用因子模型、正则化

**问题2**：优化结果不稳定

- **解决方案**：添加约束条件、使用稳健估计、多次优化

**问题3**：计算性能慢

- **解决方案**：使用物化视图、并行查询、简化算法

**问题4**：权重极端

- **解决方案**：添加权重约束、使用正则化、风险平价

---

## 7. 最佳实践

### 7.1 优化方法选择

1. **标准优化**：使用均值-方差优化
2. **多资产组合**：使用风险平价
3. **风险最小化**：使用最小方差组合

### 7.2 约束条件设置

1. **权重约束**：设置最小和最大权重
2. **行业约束**：限制行业集中度
3. **流动性约束**：考虑资产流动性

### 7.3 参数调优

1. **时间窗口**：选择合适的估计窗口
2. **风险厌恶系数**：根据风险偏好调整
3. **再平衡频率**：平衡成本和收益

### 7.4 SQL实现注意事项

1. **矩阵运算**：使用数组类型或表结构
2. **迭代算法**：使用递归CTE或外部工具
3. **性能优化**：使用物化视图和索引
4. **数值稳定性**：注意数值精度和稳定性

---

## 📚 参考资源

### 学术文献

- 《投资组合理论与资本市场》（Portfolio Theory and Capital Markets）- Markowitz理论
- 《风险平价投资组合》（Risk Parity Portfolios）- 风险平价方法

### PostgreSQL官方文档

- [数组操作](https://www.postgresql.org/docs/current/arrays.html)
- [窗口函数](https://www.postgresql.org/docs/current/tutorial-window.html)
- [递归查询](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE)

### 在线资源

- PostgreSQL投资组合优化指南
- Markowitz模型详解
- 投资组合优化最佳实践

### 相关算法

- [收益率计算](./收益率计算.md) - 收益率计算
- [风险评估算法](./风险评估算法.md) - 风险评估
- [金融时间序列分析](./金融时间序列分析.md) - 时间序列分析

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
