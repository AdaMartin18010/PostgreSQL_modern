# PostgreSQL å…³è”è§„åˆ™è¯„ä¼°ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ•°æ®æŒ–æ˜ | å…³è”è§„åˆ™ | è§„åˆ™è¯„ä¼°
> **éš¾åº¦çº§åˆ«**: â­â­â­â­ (é«˜çº§)
> **å‚è€ƒæ ‡å‡†**: Association Rule Evaluation, Rule Quality Metrics, Data Mining

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL å…³è”è§„åˆ™è¯„ä¼°ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-å…³è”è§„åˆ™è¯„ä¼°ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [å…³è”è§„åˆ™è¯„ä¼°æ¦‚è¿°](#å…³è”è§„åˆ™è¯„ä¼°æ¦‚è¿°)
    - [è¯„ä¼°æŒ‡æ ‡](#è¯„ä¼°æŒ‡æ ‡)
  - [1. æå‡åº¦åˆ†æ](#1-æå‡åº¦åˆ†æ)
    - [1.1 æå‡åº¦è®¡ç®—](#11-æå‡åº¦è®¡ç®—)
  - [2. å¡æ–¹æ£€éªŒ](#2-å¡æ–¹æ£€éªŒ)
    - [2.1 å¡æ–¹æ£€éªŒåŸç†](#21-å¡æ–¹æ£€éªŒåŸç†)
    - [2.2 å¡æ–¹æ£€éªŒå®ç°](#22-å¡æ–¹æ£€éªŒå®ç°)
  - [3. è§„åˆ™å‰ªæ](#3-è§„åˆ™å‰ªæ)
    - [3.1 åŸºäºæå‡åº¦çš„å‰ªæ](#31-åŸºäºæå‡åº¦çš„å‰ªæ)
    - [3.2 åŸºäºç½®ä¿¡åº¦çš„å‰ªæ](#32-åŸºäºç½®ä¿¡åº¦çš„å‰ªæ)
  - [4. ç»¼åˆè¯„ä¼°æŒ‡æ ‡](#4-ç»¼åˆè¯„ä¼°æŒ‡æ ‡)
    - [4.1 è§„åˆ™è¯„åˆ†](#41-è§„åˆ™è¯„åˆ†)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## å…³è”è§„åˆ™è¯„ä¼°æ¦‚è¿°

**å…³è”è§„åˆ™è¯„ä¼°**ä½¿ç”¨å¤šç§æŒ‡æ ‡è¯„ä¼°è§„åˆ™çš„è´¨é‡å’Œæ„ä¹‰ï¼Œç­›é€‰æœ‰ä»·å€¼çš„å…³è”è§„åˆ™ã€‚

### è¯„ä¼°æŒ‡æ ‡

| æŒ‡æ ‡ | å…¬å¼ | å«ä¹‰ |
|------|------|------|
| **æ”¯æŒåº¦** | $P(A \cup B)$ | è§„åˆ™å‡ºç°çš„é¢‘ç‡ |
| **ç½®ä¿¡åº¦** | $P(B\|A)$ | è§„åˆ™çš„å¯ä¿¡åº¦ |
| **æå‡åº¦** | $\frac{P(B\|A)}{P(B)}$ | è§„åˆ™çš„æœ‰æ•ˆæ€§ |
| **å¡æ–¹å€¼** | $\chi^2$ | ç»Ÿè®¡æ˜¾è‘—æ€§ |

---

## 1. æå‡åº¦åˆ†æ

### 1.1 æå‡åº¦è®¡ç®—

**æå‡åº¦ï¼ˆLiftï¼‰**è¡¡é‡è§„åˆ™çš„æœ‰æ•ˆæ€§ã€‚

$$Lift(A \rightarrow B) = \frac{P(B|A)}{P(B)} = \frac{Confidence(A \rightarrow B)}{Support(B)}$$

**è§£é‡Š**ï¼š

- $Lift > 1$ï¼šæ­£ç›¸å…³ï¼Œè§„åˆ™æœ‰æ•ˆ
- $Lift = 1$ï¼šç‹¬ç«‹ï¼Œè§„åˆ™æ— æ•ˆ
- $Lift < 1$ï¼šè´Ÿç›¸å…³ï¼Œè§„åˆ™æœ‰å®³

```sql
-- å…³è”è§„åˆ™æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'transaction_data') THEN
            DROP TABLE transaction_data, association_rules CASCADE;
        END IF;

        CREATE TABLE transaction_data (
            transaction_id INTEGER NOT NULL,
            item_id VARCHAR(20) NOT NULL,
            PRIMARY KEY (transaction_id, item_id)
        );

        -- æ’å…¥ç¤ºä¾‹äº¤æ˜“æ•°æ®
        INSERT INTO transaction_data (transaction_id, item_id) VALUES
            (1, 'A'), (1, 'B'), (1, 'C'),
            (2, 'A'), (2, 'B'),
            (3, 'B'), (3, 'C'),
            (4, 'A'), (4, 'C'),
            (5, 'A'), (5, 'B'), (5, 'C');

        CREATE TABLE association_rules (
            rule_id SERIAL PRIMARY KEY,
            antecedent TEXT NOT NULL,  -- å‰ä»¶
            consequent TEXT NOT NULL,  -- åä»¶
            support NUMERIC NOT NULL,
            confidence NUMERIC NOT NULL
        );

        -- æ’å…¥ç¤ºä¾‹è§„åˆ™
        INSERT INTO association_rules (antecedent, consequent, support, confidence) VALUES
            ('A', 'B', 0.6, 0.75),
            ('B', 'C', 0.6, 0.75),
            ('A', 'C', 0.4, 0.5);

        RAISE NOTICE 'å…³è”è§„åˆ™æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- æå‡åº¦è®¡ç®—
WITH item_support AS (
    SELECT
        item_id,
        COUNT(DISTINCT transaction_id)::NUMERIC /
        (SELECT COUNT(DISTINCT transaction_id) FROM transaction_data) AS support
    FROM transaction_data
    GROUP BY item_id
),
rule_lift AS (
    SELECT
        ar.rule_id,
        ar.antecedent,
        ar.consequent,
        ar.support AS rule_support,
        ar.confidence,
        is_cons.support AS consequent_support,
        ar.confidence / NULLIF(is_cons.support, 0) AS lift
    FROM association_rules ar
    JOIN item_support is_cons ON ar.consequent = is_cons.item_id
)
SELECT
    rule_id,
    antecedent || ' â†’ ' || consequent AS rule,
    ROUND(rule_support::numeric, 4) AS support,
    ROUND(confidence::numeric, 4) AS confidence,
    ROUND(lift::numeric, 4) AS lift,
    CASE
        WHEN lift > 1.0 THEN 'Positive association âœ“'
        WHEN lift = 1.0 THEN 'Independent'
        ELSE 'Negative association âœ—'
    END AS lift_interpretation
FROM rule_lift
ORDER BY lift DESC;
```

---

## 2. å¡æ–¹æ£€éªŒ

### 2.1 å¡æ–¹æ£€éªŒåŸç†

**å¡æ–¹æ£€éªŒ**è¯„ä¼°è§„åˆ™çš„ç»Ÿè®¡æ˜¾è‘—æ€§ã€‚

**å¡æ–¹ç»Ÿè®¡é‡**ï¼š
$$\chi^2 = \sum_{i,j} \frac{(O_{ij} - E_{ij})^2}{E_{ij}}$$

å…¶ä¸­ $O_{ij}$ æ˜¯è§‚å¯Ÿé¢‘æ•°ï¼Œ$E_{ij}$ æ˜¯æœŸæœ›é¢‘æ•°ã€‚

### 2.2 å¡æ–¹æ£€éªŒå®ç°

```sql
-- å¡æ–¹æ£€éªŒï¼šè¯„ä¼°è§„åˆ™ A â†’ B çš„ç»Ÿè®¡æ˜¾è‘—æ€§
WITH rule_ab AS (
    SELECT 'A' AS antecedent, 'B' AS consequent
),
contingency_table AS (
    SELECT
        COUNT(DISTINCT t1.transaction_id) FILTER (
            WHERE EXISTS (SELECT 1 FROM transaction_data t2
                          WHERE t2.transaction_id = t1.transaction_id
                          AND t2.item_id = 'A')
            AND EXISTS (SELECT 1 FROM transaction_data t2
                       WHERE t2.transaction_id = t1.transaction_id
                       AND t2.item_id = 'B')
        ) AS n11,  -- Aå’ŒBéƒ½å‡ºç°
        COUNT(DISTINCT t1.transaction_id) FILTER (
            WHERE EXISTS (SELECT 1 FROM transaction_data t2
                          WHERE t2.transaction_id = t1.transaction_id
                          AND t2.item_id = 'A')
            AND NOT EXISTS (SELECT 1 FROM transaction_data t2
                           WHERE t2.transaction_id = t1.transaction_id
                           AND t2.item_id = 'B')
        ) AS n10,  -- åªæœ‰A
        COUNT(DISTINCT t1.transaction_id) FILTER (
            WHERE NOT EXISTS (SELECT 1 FROM transaction_data t2
                             WHERE t2.transaction_id = t1.transaction_id
                             AND t2.item_id = 'A')
            AND EXISTS (SELECT 1 FROM transaction_data t2
                       WHERE t2.transaction_id = t1.transaction_id
                       AND t2.item_id = 'B')
        ) AS n01,  -- åªæœ‰B
        COUNT(DISTINCT t1.transaction_id) FILTER (
            WHERE NOT EXISTS (SELECT 1 FROM transaction_data t2
                             WHERE t2.transaction_id = t1.transaction_id
                             AND t2.item_id = 'A')
            AND NOT EXISTS (SELECT 1 FROM transaction_data t2
                           WHERE t2.transaction_id = t1.transaction_id
                           AND t2.item_id = 'B')
        ) AS n00,  -- éƒ½ä¸å‡ºç°
        COUNT(DISTINCT transaction_id) AS total
    FROM transaction_data t1
),
expected_frequencies AS (
    SELECT
        n11, n10, n01, n00, total,
        (n11 + n10)::NUMERIC * (n11 + n01) / NULLIF(total, 0) AS e11,
        (n11 + n10)::NUMERIC * (n10 + n00) / NULLIF(total, 0) AS e10,
        (n01 + n00)::NUMERIC * (n11 + n01) / NULLIF(total, 0) AS e01,
        (n01 + n00)::NUMERIC * (n10 + n00) / NULLIF(total, 0) AS e00
    FROM contingency_table
),
chi_square AS (
    SELECT
        POWER(n11 - e11, 2) / NULLIF(e11, 0) +
        POWER(n10 - e10, 2) / NULLIF(e10, 0) +
        POWER(n01 - e01, 2) / NULLIF(e01, 0) +
        POWER(n00 - e00, 2) / NULLIF(e00, 0) AS chi_square_stat,
        -- è‡ªç”±åº¦ = (è¡Œæ•°-1) * (åˆ—æ•°-1) = 1
        1 AS degrees_of_freedom
    FROM expected_frequencies
)
SELECT
    ROUND(chi_square_stat::numeric, 4) AS chi_square_value,
    degrees_of_freedom,
    CASE
        WHEN chi_square_stat > 3.841 THEN 'Significant association (p < 0.05) âœ“'
        WHEN chi_square_stat > 2.706 THEN 'Marginally significant (p < 0.10)'
        ELSE 'No significant association (p â‰¥ 0.10) âœ—'
    END AS association_test_result
FROM chi_square;
```

---

## 3. è§„åˆ™å‰ªæ

### 3.1 åŸºäºæå‡åº¦çš„å‰ªæ

**å‰ªæç­–ç•¥**ï¼šç§»é™¤æå‡åº¦â‰¤1çš„è§„åˆ™ã€‚

```sql
-- è§„åˆ™å‰ªæï¼šç§»é™¤æ— æ•ˆè§„åˆ™
WITH rule_metrics AS (
    SELECT
        ar.rule_id,
        ar.antecedent,
        ar.consequent,
        ar.support,
        ar.confidence,
        is_cons.support AS consequent_support,
        ar.confidence / NULLIF(is_cons.support, 0) AS lift
    FROM association_rules ar
    JOIN (
        SELECT
            item_id,
            COUNT(DISTINCT transaction_id)::NUMERIC /
            (SELECT COUNT(DISTINCT transaction_id) FROM transaction_data) AS support
        FROM transaction_data
        GROUP BY item_id
    ) is_cons ON ar.consequent = is_cons.item_id
),
pruned_rules AS (
    SELECT
        rule_id,
        antecedent || ' â†’ ' || consequent AS rule,
        ROUND(support::numeric, 4) AS support,
        ROUND(confidence::numeric, 4) AS confidence,
        ROUND(lift::numeric, 4) AS lift
    FROM rule_metrics
    WHERE lift > 1.0  -- åªä¿ç•™æå‡åº¦>1çš„è§„åˆ™
      AND support >= 0.3  -- æœ€å°æ”¯æŒåº¦
      AND confidence >= 0.5  -- æœ€å°ç½®ä¿¡åº¦
)
SELECT
    rule_id,
    rule,
    support,
    confidence,
    lift,
    'Kept' AS pruning_status
FROM pruned_rules
ORDER BY lift DESC;
```

### 3.2 åŸºäºç½®ä¿¡åº¦çš„å‰ªæ

```sql
-- ç½®ä¿¡åº¦å‰ªæï¼šç§»é™¤ä½ç½®ä¿¡åº¦è§„åˆ™
WITH confidence_pruning AS (
    SELECT
        rule_id,
        antecedent || ' â†’ ' || consequent AS rule,
        support,
        confidence,
        CASE
            WHEN confidence >= 0.8 THEN 'High confidence'
            WHEN confidence >= 0.6 THEN 'Medium confidence'
            WHEN confidence >= 0.5 THEN 'Low confidence'
            ELSE 'Very low confidence - Prune'
        END AS confidence_level
    FROM association_rules
)
SELECT
    rule_id,
    rule,
    ROUND(support::numeric, 4) AS support,
    ROUND(confidence::numeric, 4) AS confidence,
    confidence_level
FROM confidence_pruning
WHERE confidence >= 0.5  -- ä¿ç•™ç½®ä¿¡åº¦â‰¥0.5çš„è§„åˆ™
ORDER BY confidence DESC;
```

---

## 4. PostgreSQL 18 å¹¶è¡Œå…³è”è§„åˆ™è¯„ä¼°å¢å¼º

**PostgreSQL 18** æ˜¾è‘—å¢å¼ºäº†å¹¶è¡Œå…³è”è§„åˆ™è¯„ä¼°è®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œæå‡åº¦åˆ†æã€å¡æ–¹æ£€éªŒå’Œè§„åˆ™å‰ªæï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡å…³è”è§„åˆ™è¯„ä¼°çš„æ€§èƒ½ã€‚

### 4.1 å¹¶è¡Œå…³è”è§„åˆ™è¯„ä¼°åŸç†

PostgreSQL 18 çš„å¹¶è¡Œå…³è”è§„åˆ™è¯„ä¼°é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«æè§„åˆ™æ•°æ®
2. **å¹¶è¡ŒæŒ‡æ ‡è®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—è¯„ä¼°æŒ‡æ ‡
3. **å¹¶è¡Œè§„åˆ™ç­›é€‰**ï¼šå¹¶è¡Œæ‰§è¡Œè§„åˆ™å‰ªæå’Œæ’åº
4. **ç»“æœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è¯„ä¼°ç»“æœ

### 4.2 å¹¶è¡Œæå‡åº¦åˆ†æ

```sql
-- PostgreSQL 18 å¹¶è¡Œæå‡åº¦åˆ†æï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'association_rules') THEN
            RAISE WARNING 'è¡¨ association_rules ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œæå‡åº¦åˆ†æ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œæå‡åº¦åˆ†æ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæå‡åº¦åˆ†æå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œæå‡åº¦è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH rule_metrics AS (
    SELECT
        ar.rule_id,
        ar.antecedent,
        ar.consequent,
        ar.support,
        ar.confidence,
        is_cons.support AS consequent_support,
        ar.confidence / NULLIF(is_cons.support, 0) AS lift_value
    FROM association_rules ar
    JOIN (
        SELECT consequent, support FROM association_rules
    ) is_cons ON ar.consequent = is_cons.consequent
)
SELECT
    rule_id,
    antecedent || ' => ' || consequent AS rule,
    ROUND(confidence::numeric, 4) AS confidence,
    ROUND(lift_value::numeric, 4) AS lift,
    CASE
        WHEN lift_value > 1 THEN 'Positive association âœ“'
        WHEN lift_value = 1 THEN 'Independent'
        ELSE 'Negative association'
    END AS association_type
FROM rule_metrics
ORDER BY lift DESC;
```

### 4.3 å¹¶è¡Œå¡æ–¹æ£€éªŒ

```sql
-- PostgreSQL 18 å¹¶è¡Œå¡æ–¹æ£€éªŒï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'transaction_data') THEN
            RAISE WARNING 'è¡¨ transaction_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå¡æ–¹æ£€éªŒ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå¡æ–¹æ£€éªŒ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå¡æ–¹æ£€éªŒå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå¡æ–¹ç»Ÿè®¡é‡è®¡ç®—
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH contingency_table AS (
    SELECT
        COUNT(*) FILTER (WHERE item1 = 'A' AND item2 = 'B') AS n11,
        COUNT(*) FILTER (WHERE item1 = 'A' AND item2 != 'B') AS n10,
        COUNT(*) FILTER (WHERE item1 != 'A' AND item2 = 'B') AS n01,
        COUNT(*) FILTER (WHERE item1 != 'A' AND item2 != 'B') AS n00,
        COUNT(*) AS total
    FROM (
        SELECT
            transaction_id,
            MAX(CASE WHEN item_id = 'A' THEN 1 ELSE 0 END) AS item1,
            MAX(CASE WHEN item_id = 'B' THEN 1 ELSE 0 END) AS item2
        FROM transaction_data
        GROUP BY transaction_id
    ) AS transaction_items
),
chi_square_calc AS (
    SELECT
        n11, n10, n01, n00, total,
        (n11 + n10)::NUMERIC * (n11 + n01) / NULLIF(total, 0) AS e11,
        (n11 + n10)::NUMERIC * (n10 + n00) / NULLIF(total, 0) AS e10,
        (n01 + n00)::NUMERIC * (n11 + n01) / NULLIF(total, 0) AS e01,
        (n01 + n00)::NUMERIC * (n10 + n00) / NULLIF(total, 0) AS e00
    FROM contingency_table
)
SELECT
    ROUND((POWER(n11 - e11, 2) / NULLIF(e11, 0) +
           POWER(n10 - e10, 2) / NULLIF(e10, 0) +
           POWER(n01 - e01, 2) / NULLIF(e01, 0) +
           POWER(n00 - e00, 2) / NULLIF(e00, 0))::numeric, 4) AS chi_square_stat,
    CASE
        WHEN (POWER(n11 - e11, 2) / NULLIF(e11, 0) +
              POWER(n10 - e10, 2) / NULLIF(e10, 0) +
              POWER(n01 - e01, 2) / NULLIF(e01, 0) +
              POWER(n00 - e00, 2) / NULLIF(e00, 0)) > 3.841 THEN 'Significant association âœ“'
        ELSE 'No significant association'
    END AS test_result
FROM chi_square_calc;
```

---

## 5. ç»¼åˆè¯„ä¼°æŒ‡æ ‡

### 4.1 è§„åˆ™è¯„åˆ†

**ç»¼åˆè¯„åˆ†**ç»“åˆå¤šä¸ªæŒ‡æ ‡ã€‚

```sql
-- ç»¼åˆè§„åˆ™è¯„åˆ†
WITH rule_scoring AS (
    SELECT
        ar.rule_id,
        ar.antecedent || ' â†’ ' || ar.consequent AS rule,
        ar.support,
        ar.confidence,
        is_cons.support AS consequent_support,
        ar.confidence / NULLIF(is_cons.support, 0) AS lift,
        -- ç»¼åˆè¯„åˆ†ï¼šåŠ æƒå¹³å‡
        (ar.support * 0.3 + ar.confidence * 0.4 +
         (ar.confidence / NULLIF(is_cons.support, 0)) * 0.3) AS composite_score
    FROM association_rules ar
    JOIN (
        SELECT
            item_id,
            COUNT(DISTINCT transaction_id)::NUMERIC /
            (SELECT COUNT(DISTINCT transaction_id) FROM transaction_data) AS support
        FROM transaction_data
        GROUP BY item_id
    ) is_cons ON ar.consequent = is_cons.item_id
)
SELECT
    rule_id,
    rule,
    ROUND(support::numeric, 4) AS support,
    ROUND(confidence::numeric, 4) AS confidence,
    ROUND(lift::numeric, 4) AS lift,
    ROUND(composite_score::numeric, 4) AS composite_score,
    ROW_NUMBER() OVER (ORDER BY composite_score DESC) AS rank
FROM rule_scoring
ORDER BY composite_score DESC;
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Agrawal, R., et al. (1993)**: "Mining Association Rules between Sets of Items in Large Databases"
2. **Brin, S., et al. (1997)**: "Beyond Market Baskets: Generalizing Association Rules to Correlations"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**ï¼šåœ¨transaction_idå’Œitem_idä¸Šåˆ›å»ºç´¢å¼•
2. **æ‰¹é‡è®¡ç®—**ï¼šæ‰¹é‡è®¡ç®—å¤šä¸ªè§„åˆ™çš„æŒ‡æ ‡
3. **ç¼“å­˜ç»“æœ**ï¼šç¼“å­˜é¢‘ç¹è®¿é—®çš„è§„åˆ™è¯„ä¼°ç»“æœ

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **å¤šæŒ‡æ ‡è¯„ä¼°**ï¼šç»“åˆæ”¯æŒåº¦ã€ç½®ä¿¡åº¦ã€æå‡åº¦ç­‰å¤šä¸ªæŒ‡æ ‡
2. **ç»Ÿè®¡æ˜¾è‘—æ€§**ï¼šä½¿ç”¨å¡æ–¹æ£€éªŒéªŒè¯è§„åˆ™æ˜¾è‘—æ€§
3. **ä¸šåŠ¡éªŒè¯**ï¼šç»“åˆä¸šåŠ¡çŸ¥è¯†éªŒè¯è§„åˆ™åˆç†æ€§
4. **è§„åˆ™å‰ªæ**ï¼šç§»é™¤æ— æ•ˆå’Œå†—ä½™è§„åˆ™

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
