# PostgreSQL 序列模式挖掘算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数据挖掘 | 序列模式 | GSP算法
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Sequence Pattern Mining, GSP Algorithm, PrefixSpan

---

## 📋 目录

- [PostgreSQL 序列模式挖掘算法完整指南](#postgresql-序列模式挖掘算法完整指南)
  - [📋 目录](#-目录)
  - [序列模式挖掘概述](#序列模式挖掘概述)
    - [核心概念](#核心概念)
  - [1. GSP算法](#1-gsp算法)
    - [1.1 GSP算法原理](#11-gsp算法原理)
    - [1.2 GSP算法实现](#12-gsp算法实现)
    - [1.3 序列模式匹配](#13-序列模式匹配)
  - [2. PrefixSpan算法](#2-prefixspan算法)
    - [2.1 PrefixSpan原理](#21-prefixspan原理)
    - [2.2 PrefixSpan实现](#22-prefixspan实现)
  - [3. 复杂度分析](#3-复杂度分析)
    - [3.1 时间复杂度](#31-时间复杂度)
    - [3.2 空间复杂度](#32-空间复杂度)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 用户行为序列分析](#41-用户行为序列分析)
  - [📚 参考资源](#-参考资源)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 序列模式挖掘概述

**序列模式挖掘**发现序列数据中的频繁模式，用于分析时间序列、用户行为序列等。

### 核心概念

| 概念 | 定义 | 示例 |
|------|------|------|
| **序列** | 有序的事件列表 | <A, B, C> |
| **子序列** | 序列的一部分 | <A, C> 是 <A, B, C> 的子序列 |
| **支持度** | 包含模式的序列比例 | 2/3 = 66.7% |
| **频繁序列** | 支持度≥最小支持度的序列 | min_sup = 50% |

---

## 1. GSP算法

### 1.1 GSP算法原理

**GSP（Generalized Sequential Pattern）**是Apriori的序列版本，使用候选生成和剪枝策略。

**算法流程**：

1. 找出所有1-序列频繁项集
2. 使用频繁k-序列生成候选(k+1)-序列
3. 扫描数据库计算候选序列支持度
4. 重复步骤2-3直到没有新的频繁序列

### 1.2 GSP算法实现

```sql
-- 序列数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sequence_data') THEN
            DROP TABLE sequence_data CASCADE;
        END IF;

        CREATE TABLE sequence_data (
            sequence_id INTEGER NOT NULL,
            event_order INTEGER NOT NULL,
            event_type VARCHAR(20) NOT NULL,
            PRIMARY KEY (sequence_id, event_order)
        );

        -- 插入示例序列数据
        INSERT INTO sequence_data (sequence_id, event_order, event_type) VALUES
            (1, 1, 'A'), (1, 2, 'B'), (1, 3, 'C'),
            (2, 1, 'A'), (2, 2, 'B'),
            (3, 1, 'B'), (3, 2, 'C'),
            (4, 1, 'A'), (4, 2, 'C'),
            (5, 1, 'B'), (5, 2, 'C');

        CREATE INDEX idx_sequence_id ON sequence_data(sequence_id);
        CREATE INDEX idx_event_type ON sequence_data(event_type);

        RAISE NOTICE '序列数据表创建成功，共 % 条记录', (SELECT COUNT(*) FROM sequence_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- GSP算法：1-序列频繁项集
WITH single_item_patterns AS (
    SELECT
        event_type AS pattern,
        COUNT(DISTINCT sequence_id) AS support_count,
        COUNT(DISTINCT sequence_id)::NUMERIC /
        (SELECT COUNT(DISTINCT sequence_id) FROM sequence_data) AS support_ratio
    FROM sequence_data
    GROUP BY event_type
),
frequent_1_sequences AS (
    SELECT
        pattern,
        support_count,
        ROUND(support_ratio::numeric, 4) AS support_ratio
    FROM single_item_patterns
    WHERE support_ratio >= 0.5  -- 最小支持度50%
)
SELECT
    pattern AS frequent_1_sequence,
    support_count,
    ROUND(support_ratio::numeric, 2) AS support_percentage
FROM frequent_1_sequences
ORDER BY support_count DESC;

-- GSP算法：2-序列候选生成和验证
WITH frequent_1_items AS (
    SELECT DISTINCT event_type
    FROM sequence_data
    GROUP BY event_type
    HAVING COUNT(DISTINCT sequence_id)::NUMERIC /
           (SELECT COUNT(DISTINCT sequence_id) FROM sequence_data) >= 0.5
),
candidate_2_sequences AS (
    SELECT
        f1.event_type || ',' || f2.event_type AS pattern,
        ARRAY[f1.event_type, f2.event_type] AS pattern_array
    FROM frequent_1_items f1
    CROSS JOIN frequent_1_items f2
    WHERE f1.event_type != f2.event_type
),
pattern_support AS (
    SELECT
        c.pattern,
        COUNT(DISTINCT s1.sequence_id) AS support_count
    FROM candidate_2_sequences c
    JOIN sequence_data s1 ON s1.event_type = c.pattern_array[1]
    JOIN sequence_data s2 ON s2.sequence_id = s1.sequence_id
        AND s2.event_type = c.pattern_array[2]
        AND s2.event_order > s1.event_order
    GROUP BY c.pattern
)
SELECT
    pattern AS frequent_2_sequence,
    support_count,
    ROUND((support_count::NUMERIC / (SELECT COUNT(DISTINCT sequence_id) FROM sequence_data) * 100)::numeric, 2) AS support_percentage
FROM pattern_support
WHERE support_count::NUMERIC / (SELECT COUNT(DISTINCT sequence_id) FROM sequence_data) >= 0.5
ORDER BY support_count DESC;
```

### 1.3 序列模式匹配

```sql
-- 序列模式匹配：检查序列是否包含模式
CREATE OR REPLACE FUNCTION sequence_contains_pattern(
    p_sequence_id INTEGER,
    p_pattern TEXT[]
)
RETURNS BOOLEAN AS $$
DECLARE
    pattern_length INTEGER;
    match_count INTEGER;
BEGIN
    pattern_length := array_length(p_pattern, 1);

    -- 检查序列中是否存在模式的所有元素（按顺序）
    SELECT COUNT(*) INTO match_count
    FROM (
        SELECT
            event_type,
            event_order,
            ROW_NUMBER() OVER (ORDER BY event_order) AS rn
        FROM sequence_data
        WHERE sequence_id = p_sequence_id
        ORDER BY event_order
    ) seq
    WHERE EXISTS (
        SELECT 1
        FROM unnest(p_pattern) WITH ORDINALITY AS pattern(event_type, pos)
        WHERE seq.event_type = pattern.event_type
          AND seq.rn = (
              SELECT COALESCE(MAX(rn), 0) + 1
              FROM sequence_data s2
              WHERE s2.sequence_id = p_sequence_id
                AND s2.event_order < seq.event_order
                AND s2.event_type = p_pattern[GREATEST(1, pattern.pos - 1)]
          )
    );

    RETURN match_count >= pattern_length;
END;
$$ LANGUAGE plpgsql;

-- 使用模式匹配函数
SELECT
    sequence_id,
    sequence_contains_pattern(sequence_id, ARRAY['A', 'B']) AS contains_ab,
    sequence_contains_pattern(sequence_id, ARRAY['B', 'C']) AS contains_bc
FROM (SELECT DISTINCT sequence_id FROM sequence_data) seqs;
```

---

## 2. PrefixSpan算法

### 2.1 PrefixSpan原理

**PrefixSpan（Prefix-projected Sequential Pattern mining）**使用投影数据库避免候选生成。

**算法优势**：

- 不需要候选生成
- 投影数据库更小
- 效率更高

### 2.2 PrefixSpan实现

```sql
-- PrefixSpan：前缀投影
WITH prefix_projection AS (
    SELECT
        sequence_id,
        event_order,
        event_type,
        -- 找到前缀'A'后的投影
        CASE
            WHEN event_type = 'A' THEN
                ROW_NUMBER() OVER (PARTITION BY sequence_id ORDER BY event_order)
            ELSE NULL
        END AS prefix_position
    FROM sequence_data
),
projected_sequences AS (
    SELECT
        sequence_id,
        event_order,
        event_type
    FROM prefix_projection
    WHERE sequence_id IN (
        SELECT DISTINCT sequence_id
        FROM prefix_projection
        WHERE prefix_position = 1
    )
    AND event_order > (
        SELECT MIN(event_order)
        FROM prefix_projection p2
        WHERE p2.sequence_id = prefix_projection.sequence_id
          AND p2.prefix_position = 1
    )
)
SELECT
    event_type,
    COUNT(DISTINCT sequence_id) AS support_count
FROM projected_sequences
GROUP BY event_type
ORDER BY support_count DESC;
```

---

## 3. 复杂度分析

### 3.1 时间复杂度

| 算法 | 时间复杂度 | 说明 |
|------|-----------|------|
| **GSP** | $O(n \cdot m^k)$ | n=序列数，m=事件类型数，k=模式长度 |
| **PrefixSpan** | $O(n \cdot m)$ | 投影数据库更小 |

### 3.2 空间复杂度

| 算法 | 空间复杂度 | 说明 |
|------|-----------|------|
| **GSP** | $O(m^k)$ | 存储候选序列 |
| **PrefixSpan** | $O(n)$ | 投影数据库 |

---

## 4. 实际应用案例

### 4.1 用户行为序列分析

```sql
-- 用户行为序列：分析用户购买路径
WITH user_behavior_sequences AS (
    SELECT
        user_id AS sequence_id,
        purchase_order AS event_order,
        product_category AS event_type
    FROM user_purchases
    ORDER BY user_id, purchase_order
),
frequent_paths AS (
    SELECT
        ARRAY_AGG(event_type ORDER BY event_order) AS path_pattern,
        COUNT(DISTINCT sequence_id) AS user_count
    FROM user_behavior_sequences
    GROUP BY sequence_id
)
SELECT
    path_pattern,
    user_count,
    ROUND((user_count::NUMERIC / (SELECT COUNT(DISTINCT sequence_id) FROM user_behavior_sequences) * 100)::numeric, 2) AS path_frequency
FROM frequent_paths
WHERE user_count >= 10  -- 至少10个用户
ORDER BY user_count DESC
LIMIT 20;
```

---

## 📚 参考资源

1. **Srikant, R., Agrawal, R. (1996)**: "Mining Sequential Patterns: Generalizations and Performance Improvements"
2. **Pei, J., et al. (2004)**: "Mining Sequential Patterns by Pattern-Growth: The PrefixSpan Approach"

---

## 📊 性能优化建议

1. **索引优化**：在sequence_id和event_order上创建索引
2. **剪枝策略**：使用Apriori性质剪枝候选序列
3. **并行计算**：并行处理不同长度的序列模式
4. **增量更新**：增量更新频繁序列

---

## 🎯 最佳实践

1. **支持度选择**：根据数据规模选择合适的最小支持度
2. **模式长度**：限制最大模式长度避免组合爆炸
3. **时间约束**：添加时间窗口约束
4. **结果验证**：验证发现的模式是否有业务意义

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
