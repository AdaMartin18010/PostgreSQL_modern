# PostgreSQL 时间序列可视化数据生成完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数据可视化 | 时间序列 | 趋势分析
> **难度级别**: ⭐⭐⭐ (中级)
> **参考标准**: Time Series Visualization, Data Visualization Best Practices

---

## 📋 目录

- [PostgreSQL 时间序列可视化数据生成完整指南](#postgresql-时间序列可视化数据生成完整指南)
  - [📋 目录](#-目录)
  - [时间序列可视化概述](#时间序列可视化概述)
  - [理论基础](#理论基础)
    - [时间序列可视化问题定义](#时间序列可视化问题定义)
    - [核心概念](#核心概念)
    - [可视化类型](#可视化类型)
    - [技术栈](#技术栈)
  - [1. 数据准备](#1-数据准备)
  - [2. 趋势图数据](#2-趋势图数据)
    - [2.1 基础趋势图](#21-基础趋势图)
    - [2.2 多系列对比趋势图](#22-多系列对比趋势图)
  - [3. 季节性分解](#3-季节性分解)
    - [3.1 基础季节性分解](#31-基础季节性分解)
    - [3.2 季节性模式可视化](#32-季节性模式可视化)
  - [4. 面积图数据](#4-面积图数据)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 销售趋势分析](#51-销售趋势分析)
    - [5.2 异常检测可视化](#52-异常检测可视化)
  - [📊 性能优化建议](#-性能优化建议)
    - [索引优化](#索引优化)
    - [物化视图](#物化视图)
  - [🎯 最佳实践](#-最佳实践)
    - [数据准备](#数据准备)
    - [可视化设计](#可视化设计)
    - [SQL实现注意事项](#sql实现注意事项)
  - [📈 可视化方法对比](#-可视化方法对比)
  - [🔍 常见问题与解决方案](#-常见问题与解决方案)
    - [问题1：数据点过多，图表难以阅读](#问题1数据点过多图表难以阅读)
    - [问题2：季节性不明显](#问题2季节性不明显)
    - [问题3：趋势计算慢](#问题3趋势计算慢)
  - [📚 参考资源](#-参考资源)

---

## 时间序列可视化概述

时间序列可视化帮助理解数据的趋势、季节性和异常。

## 理论基础

### 时间序列可视化问题定义

时间序列可视化是将时间序列数据转换为图表和图形，以直观展示数据的趋势、周期性、异常和模式的过程。

### 核心概念

1. **趋势分析**：
   - 长期趋势：数据的整体方向
   - 短期波动：数据的局部变化
   - 移动平均：平滑数据，突出趋势

2. **季节性分析**：
   - 季节性模式：周期性重复的模式
   - 季节性分解：将数据分解为趋势、季节性和残差

3. **异常检测**：
   - 异常值识别：识别偏离正常模式的数据点
   - 异常模式：识别异常的时间段

### 可视化类型

| 图表类型 | 适用场景 | 数据维度 |
|---------|---------|---------|
| **折线图** | 趋势展示、时间序列 | 时间 + 数值 |
| **面积图** | 累积趋势、堆叠数据 | 时间 + 数值 |
| **柱状图** | 离散时间点对比 | 时间 + 数值 |
| **热力图** | 时间模式、周期性 | 时间 + 分类 |

### 技术栈

- **窗口函数**：AVG、SUM、LAG、LEAD、ROW_NUMBER
- **时间函数**：DATE_TRUNC、EXTRACT、INTERVAL
- **聚合函数**：SUM、AVG、COUNT、PERCENTILE_CONT
- **CTE**：递归CTE、多级CTE

---

## 1. 数据准备

```sql
-- 时间序列数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            DROP TABLE time_series_data CASCADE;
        END IF;

        CREATE TABLE time_series_data (
            date DATE NOT NULL,
            value NUMERIC NOT NULL,
            category VARCHAR(50),
            PRIMARY KEY (date, category)
        );

        -- 插入示例时间序列数据（带趋势和季节性）
        INSERT INTO time_series_data (date, value, category)
        SELECT
            '2024-01-01'::DATE + (i * INTERVAL '1 day'),
            100 + i * 0.1 + 10 * SIN(i * 2 * PI() / 30) + (RANDOM() - 0.5) * 2 AS value,
            'Series A' AS category
        FROM generate_series(0, 365) i;

        INSERT INTO time_series_data (date, value, category)
        SELECT
            '2024-01-01'::DATE + (i * INTERVAL '1 day'),
            80 + i * 0.08 + 8 * SIN(i * 2 * PI() / 30) + (RANDOM() - 0.5) * 2 AS value,
            'Series B' AS category
        FROM generate_series(0, 365) i;

        CREATE INDEX idx_time_series_date ON time_series_data(date);
        CREATE INDEX idx_time_series_category ON time_series_data(category);

        RAISE NOTICE '时间序列数据表创建成功，共 % 条记录', (SELECT COUNT(*) FROM time_series_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;
```

---

## 2. 趋势图数据

### 2.1 基础趋势图

```sql
-- 时间序列趋势图数据生成（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING '表 time_series_data 不存在，无法生成趋势图数据';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成趋势图数据';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '趋势图数据生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 基础趋势图：原始数据 + 移动平均
WITH time_series AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS moving_avg_7,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS moving_avg_30
    FROM time_series_data
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS original_value,
    ROUND(moving_avg_7::numeric, 2) AS trend_7day,
    ROUND(moving_avg_30::numeric, 2) AS trend_30day
FROM time_series
ORDER BY category, date;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg_7
FROM time_series_data
WHERE category = 'Series A'
ORDER BY date;
```

### 2.2 多系列对比趋势图

```sql
-- 多系列对比趋势图数据
WITH series_comparison AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS trend_line,
        LAG(value) OVER (
            PARTITION BY category
            ORDER BY date
        ) AS prev_value,
        CASE
            WHEN LAG(value) OVER (PARTITION BY category ORDER BY date) IS NOT NULL THEN
                ((value - LAG(value) OVER (PARTITION BY category ORDER BY date)) /
                 NULLIF(LAG(value) OVER (PARTITION BY category ORDER BY date), 0) * 100)
            ELSE NULL
        END AS day_over_day_change
    FROM time_series_data
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS value,
    ROUND(trend_line::numeric, 2) AS trend_line,
    ROUND(day_over_day_change::numeric, 2) AS day_over_day_change_pct
FROM series_comparison
ORDER BY category, date;
```

---

## 3. 季节性分解

### 3.1 基础季节性分解

```sql
-- 季节性分解数据（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING '表 time_series_data 不存在，无法进行季节性分解';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行季节性分解';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '季节性分解准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 季节性分解：趋势 + 季节性 + 残差
WITH trend_component AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 14 PRECEDING AND 14 FOLLOWING
        ) AS trend
    FROM time_series_data
),
seasonal_component AS (
    SELECT
        date,
        category,
        value,
        trend,
        EXTRACT(MONTH FROM date) AS month,
        EXTRACT(DAY FROM date) AS day_of_month,
        AVG(value - trend) OVER (
            PARTITION BY category, EXTRACT(MONTH FROM date)
        ) AS seasonal_monthly,
        AVG(value - trend) OVER (
            PARTITION BY category, EXTRACT(DAY FROM date)
        ) AS seasonal_daily
    FROM trend_component
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS original_value,
    ROUND(trend::numeric, 2) AS trend_component,
    ROUND(seasonal_monthly::numeric, 2) AS seasonal_monthly,
    ROUND(seasonal_daily::numeric, 2) AS seasonal_daily,
    ROUND((value - trend - seasonal_monthly)::numeric, 2) AS residual
FROM seasonal_component
ORDER BY category, date;
```

### 3.2 季节性模式可视化

```sql
-- 季节性模式可视化：按月份/星期汇总
WITH monthly_pattern AS (
    SELECT
        category,
        EXTRACT(MONTH FROM date) AS month,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        STDDEV(value) AS stddev_value
    FROM time_series_data
    GROUP BY category, EXTRACT(MONTH FROM date)
),
weekly_pattern AS (
    SELECT
        category,
        EXTRACT(DOW FROM date) AS day_of_week,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value
    FROM time_series_data
    GROUP BY category, EXTRACT(DOW FROM date)
)
SELECT
    'Monthly Pattern' AS pattern_type,
    category,
    month::INTEGER AS period,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(min_value::numeric, 2) AS min_value,
    ROUND(max_value::numeric, 2) AS max_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM monthly_pattern
UNION ALL
SELECT
    'Weekly Pattern',
    category,
    day_of_week::INTEGER,
    ROUND(avg_value::numeric, 2),
    ROUND(min_value::numeric, 2),
    ROUND(max_value::numeric, 2),
    NULL
FROM weekly_pattern
ORDER BY pattern_type, category, period;
```

---

## 4. 面积图数据

```sql
-- 面积图数据生成（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING '表 time_series_data 不存在，无法生成面积图数据';
            RETURN;
        END IF;
        RAISE NOTICE '开始生成面积图数据';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '面积图数据生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 堆叠面积图数据
WITH cumulative_values AS (
    SELECT
        date,
        category,
        value,
        SUM(value) OVER (
            PARTITION BY date
            ORDER BY category
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS cumulative_value,
        SUM(value) OVER (PARTITION BY date) AS total_value
    FROM time_series_data
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS value,
    ROUND(cumulative_value::numeric, 2) AS cumulative_value,
    ROUND(total_value::numeric, 2) AS total_value,
    ROUND((value / NULLIF(total_value, 0) * 100)::numeric, 2) AS percentage
FROM cumulative_values
ORDER BY date, category;
```

---

## 5. PostgreSQL 18 并行时间序列可视化增强

**PostgreSQL 18** 显著增强了并行时间序列可视化数据生成计算能力，支持并行执行趋势图、季节性分解和面积图数据生成，大幅提升大规模时间序列可视化数据准备的性能。

### 5.1 并行时间序列可视化原理

PostgreSQL 18 的并行时间序列可视化通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描时间序列数据
2. **并行趋势计算**：每个工作进程独立计算趋势成分
3. **并行季节性提取**：并行执行季节性成分提取
4. **结果合并**：主进程合并所有工作进程的计算结果

### 5.2 并行趋势图数据生成

```sql
-- PostgreSQL 18 并行趋势图数据生成（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING '表 time_series_data 不存在，无法执行并行趋势图数据生成';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行趋势图数据生成';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行趋势图数据生成准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行移动平均趋势
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS moving_avg_30
FROM time_series_data
WHERE date >= CURRENT_DATE - INTERVAL '1 year'
ORDER BY date;
```

### 5.3 并行季节性分解可视化

```sql
-- PostgreSQL 18 并行季节性分解可视化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING '表 time_series_data 不存在，无法执行并行季节性分解可视化';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行季节性分解可视化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行季节性分解可视化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行季节性模式提取
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH trend_component AS (
    SELECT
        date,
        value,
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ) AS trend
    FROM time_series_data
)
SELECT
    date,
    value,
    ROUND(trend::numeric, 4) AS trend_component,
    ROUND((value - trend)::numeric, 4) AS detrended,
    AVG(value - trend) OVER (
        PARTITION BY EXTRACT(MONTH FROM date)
    ) AS seasonal_component
FROM trend_component
ORDER BY date;
```

---

## 6. 实际应用案例

### 5.1 销售趋势分析

```sql
-- 销售趋势分析应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        -- 创建销售数据表
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_data') THEN
            DROP TABLE sales_data CASCADE;
        END IF;

        CREATE TABLE sales_data (
            sale_date DATE NOT NULL,
            product_category VARCHAR(50) NOT NULL,
            sales_amount NUMERIC NOT NULL,
            PRIMARY KEY (sale_date, product_category)
        );

        -- 插入示例销售数据
        INSERT INTO sales_data (sale_date, product_category, sales_amount)
        SELECT
            '2024-01-01'::DATE + (i * INTERVAL '1 day'),
            CASE (i % 3)
                WHEN 0 THEN 'Electronics'
                WHEN 1 THEN 'Clothing'
                ELSE 'Food'
            END AS product_category,
            1000 + i * 2 + 100 * SIN(i * 2 * PI() / 30) + (RANDOM() - 0.5) * 100 AS sales_amount
        FROM generate_series(0, 180) i;

        CREATE INDEX idx_sales_date ON sales_data(sale_date);
        CREATE INDEX idx_sales_category ON sales_data(product_category);

        RAISE NOTICE '销售数据表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '销售趋势分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 销售趋势分析：按类别和总体
WITH sales_trends AS (
    SELECT
        sale_date,
        product_category,
        sales_amount,
        SUM(sales_amount) OVER (
            PARTITION BY product_category
            ORDER BY sale_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS weekly_sales,
        AVG(sales_amount) OVER (
            PARTITION BY product_category
            ORDER BY sale_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS weekly_avg,
        SUM(sales_amount) OVER (PARTITION BY sale_date) AS daily_total
    FROM sales_data
)
SELECT
    sale_date,
    product_category,
    ROUND(sales_amount::numeric, 2) AS daily_sales,
    ROUND(weekly_sales::numeric, 2) AS weekly_sales,
    ROUND(weekly_avg::numeric, 2) AS weekly_avg,
    ROUND(daily_total::numeric, 2) AS daily_total,
    ROUND((sales_amount / NULLIF(daily_total, 0) * 100)::numeric, 2) AS category_percentage
FROM sales_trends
ORDER BY sale_date, product_category;
```

### 5.2 异常检测可视化

```sql
-- 异常检测可视化应用（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING '表 time_series_data 不存在，无法进行异常检测可视化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行异常检测可视化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '异常检测可视化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 异常检测：使用Z-score方法
WITH time_series_stats AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS rolling_mean,
        STDDEV(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS rolling_stddev
    FROM time_series_data
),
anomaly_detection AS (
    SELECT
        date,
        category,
        value,
        rolling_mean,
        rolling_stddev,
        CASE
            WHEN rolling_stddev > 0 THEN (value - rolling_mean) / rolling_stddev
            ELSE 0
        END AS z_score,
        CASE
            WHEN ABS((value - rolling_mean) / NULLIF(rolling_stddev, 0)) > 2 THEN 'Anomaly'
            ELSE 'Normal'
        END AS anomaly_status
    FROM time_series_stats
    WHERE rolling_mean IS NOT NULL AND rolling_stddev IS NOT NULL
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS value,
    ROUND(rolling_mean::numeric, 2) AS expected_value,
    ROUND(z_score::numeric, 2) AS z_score,
    anomaly_status,
    ROUND((value - rolling_mean)::numeric, 2) AS deviation
FROM anomaly_detection
ORDER BY category, date;
```

---

## 📊 性能优化建议

### 索引优化

```sql
-- 创建关键索引
CREATE INDEX IF NOT EXISTS idx_time_series_date ON time_series_data(date);
CREATE INDEX IF NOT EXISTS idx_time_series_category ON time_series_data(category);
CREATE INDEX IF NOT EXISTS idx_time_series_date_category ON time_series_data(date, category);
```

### 物化视图

```sql
-- 创建常用可视化数据的物化视图
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_time_series_trends AS
SELECT
    date,
    category,
    value,
    AVG(value) OVER (
        PARTITION BY category
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7
FROM time_series_data;

CREATE UNIQUE INDEX ON mv_time_series_trends(date, category);

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_time_series_trends;
```

---

## 🎯 最佳实践

### 数据准备

1. **时间粒度**：根据分析需求选择合适的时间粒度
2. **数据完整性**：确保时间序列数据完整无缺失
3. **数据质量**：清洗异常值和缺失值

### 可视化设计

1. **趋势线**：使用移动平均平滑数据，突出趋势
2. **季节性**：使用季节性分解展示周期性模式
3. **异常标记**：使用不同颜色或标记突出异常值

### SQL实现注意事项

1. **错误处理**：使用DO块进行错误处理
2. **NULL值处理**：使用COALESCE和NULLIF处理NULL值
3. **性能优化**：使用索引和物化视图优化性能
4. **数据类型转换**：注意数据类型转换和精度

---

## 📈 可视化方法对比

| 方法 | 适用场景 | 优势 | 局限性 |
|------|---------|------|--------|
| 折线图 | 趋势展示、连续数据 | 直观、易于理解 | 数据点过多时难以阅读 |
| 面积图 | 累积趋势、堆叠数据 | 展示总量和组成 | 可能掩盖细节 |
| 柱状图 | 离散时间点对比 | 清晰对比 | 不适合连续数据 |
| 热力图 | 时间模式、周期性 | 展示模式 | 需要足够数据 |

---

## 🔍 常见问题与解决方案

### 问题1：数据点过多，图表难以阅读

**原因**：

- 时间粒度太细
- 数据量过大

**解决方案**：

- 使用时间聚合（按天/周/月）
- 使用移动平均平滑
- 使用采样减少数据点

### 问题2：季节性不明显

**原因**：

- 数据周期不足
- 季节性分解方法不当

**解决方案**：

- 收集足够长的数据
- 使用合适的季节性分解方法
- 使用频域分析检测周期

### 问题3：趋势计算慢

**原因**：

- 窗口函数计算复杂
- 未使用索引

**解决方案**：

- 使用物化视图缓存结果
- 创建合适的索引
- 优化窗口函数参数

---

## 📚 参考资源

1. **Tufte, E.R. (2001)**: "The Visual Display of Quantitative Information"
2. **Few, S. (2009)**: "Now You See It: Simple Visualization Techniques for Quantitative Analysis"
3. **Heer, J., Bostock, M., Ogievetsky, V. (2010)**: "A Tour Through the Visualization Zoo"

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
