# PostgreSQL æ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®ç”Ÿæˆå®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ•°æ®å¯è§†åŒ– | æ—¶é—´åºåˆ— | è¶‹åŠ¿åˆ†æž
> **éš¾åº¦çº§åˆ«**: â­â­â­ (ä¸­çº§)
> **å‚è€ƒæ ‡å‡†**: Time Series Visualization, Data Visualization Best Practices

---

## ðŸ“‹ ç›®å½•

- [PostgreSQL æ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®ç”Ÿæˆå®Œæ•´æŒ‡å—](#postgresql-æ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®ç”Ÿæˆå®Œæ•´æŒ‡å—)
  - [ðŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ—¶é—´åºåˆ—å¯è§†åŒ–æ¦‚è¿°](#æ—¶é—´åºåˆ—å¯è§†åŒ–æ¦‚è¿°)
  - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
    - [æ—¶é—´åºåˆ—å¯è§†åŒ–é—®é¢˜å®šä¹‰](#æ—¶é—´åºåˆ—å¯è§†åŒ–é—®é¢˜å®šä¹‰)
    - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [å¯è§†åŒ–ç±»åž‹](#å¯è§†åŒ–ç±»åž‹)
    - [æŠ€æœ¯æ ˆ](#æŠ€æœ¯æ ˆ)
  - [1. æ•°æ®å‡†å¤‡](#1-æ•°æ®å‡†å¤‡)
  - [2. è¶‹åŠ¿å›¾æ•°æ®](#2-è¶‹åŠ¿å›¾æ•°æ®)
    - [2.1 åŸºç¡€è¶‹åŠ¿å›¾](#21-åŸºç¡€è¶‹åŠ¿å›¾)
    - [2.2 å¤šç³»åˆ—å¯¹æ¯”è¶‹åŠ¿å›¾](#22-å¤šç³»åˆ—å¯¹æ¯”è¶‹åŠ¿å›¾)
  - [3. å­£èŠ‚æ€§åˆ†è§£](#3-å­£èŠ‚æ€§åˆ†è§£)
    - [3.1 åŸºç¡€å­£èŠ‚æ€§åˆ†è§£](#31-åŸºç¡€å­£èŠ‚æ€§åˆ†è§£)
    - [3.2 å­£èŠ‚æ€§æ¨¡å¼å¯è§†åŒ–](#32-å­£èŠ‚æ€§æ¨¡å¼å¯è§†åŒ–)
  - [4. é¢ç§¯å›¾æ•°æ®](#4-é¢ç§¯å›¾æ•°æ®)
  - [5. PostgreSQL 18 å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–å¢žå¼º](#5-postgresql-18-å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–å¢žå¼º)
    - [5.1 å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–åŽŸç†](#51-å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–åŽŸç†)
    - [5.2 å¹¶è¡Œè¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆ](#52-å¹¶è¡Œè¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆ)
    - [5.3 å¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£å¯è§†åŒ–](#53-å¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£å¯è§†åŒ–)
  - [6. å®žé™…åº”ç”¨æ¡ˆä¾‹](#6-å®žé™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 é”€å”®è¶‹åŠ¿åˆ†æž](#51-é”€å”®è¶‹åŠ¿åˆ†æž)
    - [5.2 å¼‚å¸¸æ£€æµ‹å¯è§†åŒ–](#52-å¼‚å¸¸æ£€æµ‹å¯è§†åŒ–)
  - [ðŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [ç´¢å¼•ä¼˜åŒ–](#ç´¢å¼•ä¼˜åŒ–)
    - [ç‰©åŒ–è§†å›¾](#ç‰©åŒ–è§†å›¾)
  - [ðŸŽ¯ æœ€ä½³å®žè·µ](#-æœ€ä½³å®žè·µ)
    - [æ•°æ®å‡†å¤‡](#æ•°æ®å‡†å¤‡)
    - [å¯è§†åŒ–è®¾è®¡](#å¯è§†åŒ–è®¾è®¡)
    - [SQLå®žçŽ°æ³¨æ„äº‹é¡¹](#sqlå®žçŽ°æ³¨æ„äº‹é¡¹)
  - [ðŸ“ˆ å¯è§†åŒ–æ–¹æ³•å¯¹æ¯”](#-å¯è§†åŒ–æ–¹æ³•å¯¹æ¯”)
  - [ðŸ” å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ](#-å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ)
    - [é—®é¢˜1ï¼šæ•°æ®ç‚¹è¿‡å¤šï¼Œå›¾è¡¨éš¾ä»¥é˜…è¯»](#é—®é¢˜1æ•°æ®ç‚¹è¿‡å¤šå›¾è¡¨éš¾ä»¥é˜…è¯»)
    - [é—®é¢˜2ï¼šå­£èŠ‚æ€§ä¸æ˜Žæ˜¾](#é—®é¢˜2å­£èŠ‚æ€§ä¸æ˜Žæ˜¾)
    - [é—®é¢˜3ï¼šè¶‹åŠ¿è®¡ç®—æ…¢](#é—®é¢˜3è¶‹åŠ¿è®¡ç®—æ…¢)
  - [ðŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [SQLå®žçŽ°æ³¨æ„äº‹é¡¹](#sqlå®žçŽ°æ³¨æ„äº‹é¡¹-1)
    - [PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢žå¼ºï¼‰](#postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢žå¼º)
    - [é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢žå¼ºï¼‰](#é«˜çº§ä¼˜åŒ–æŠ€å·§å¢žå¼º)

---

## æ—¶é—´åºåˆ—å¯è§†åŒ–æ¦‚è¿°

æ—¶é—´åºåˆ—å¯è§†åŒ–å¸®åŠ©ç†è§£æ•°æ®çš„è¶‹åŠ¿ã€å­£èŠ‚æ€§å’Œå¼‚å¸¸ã€‚

## ç†è®ºåŸºç¡€

### æ—¶é—´åºåˆ—å¯è§†åŒ–é—®é¢˜å®šä¹‰

æ—¶é—´åºåˆ—å¯è§†åŒ–æ˜¯å°†æ—¶é—´åºåˆ—æ•°æ®è½¬æ¢ä¸ºå›¾è¡¨å’Œå›¾å½¢ï¼Œä»¥ç›´è§‚å±•ç¤ºæ•°æ®çš„è¶‹åŠ¿ã€å‘¨æœŸæ€§ã€å¼‚å¸¸å’Œæ¨¡å¼çš„è¿‡ç¨‹ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

1. **è¶‹åŠ¿åˆ†æž**ï¼š
   - é•¿æœŸè¶‹åŠ¿ï¼šæ•°æ®çš„æ•´ä½“æ–¹å‘
   - çŸ­æœŸæ³¢åŠ¨ï¼šæ•°æ®çš„å±€éƒ¨å˜åŒ–
   - ç§»åŠ¨å¹³å‡ï¼šå¹³æ»‘æ•°æ®ï¼Œçªå‡ºè¶‹åŠ¿

2. **å­£èŠ‚æ€§åˆ†æž**ï¼š
   - å­£èŠ‚æ€§æ¨¡å¼ï¼šå‘¨æœŸæ€§é‡å¤çš„æ¨¡å¼
   - å­£èŠ‚æ€§åˆ†è§£ï¼šå°†æ•°æ®åˆ†è§£ä¸ºè¶‹åŠ¿ã€å­£èŠ‚æ€§å’Œæ®‹å·®

3. **å¼‚å¸¸æ£€æµ‹**ï¼š
   - å¼‚å¸¸å€¼è¯†åˆ«ï¼šè¯†åˆ«åç¦»æ­£å¸¸æ¨¡å¼çš„æ•°æ®ç‚¹
   - å¼‚å¸¸æ¨¡å¼ï¼šè¯†åˆ«å¼‚å¸¸çš„æ—¶é—´æ®µ

### å¯è§†åŒ–ç±»åž‹

| å›¾è¡¨ç±»åž‹ | é€‚ç”¨åœºæ™¯ | æ•°æ®ç»´åº¦ |
|---------|---------|---------|
| **æŠ˜çº¿å›¾** | è¶‹åŠ¿å±•ç¤ºã€æ—¶é—´åºåˆ— | æ—¶é—´ + æ•°å€¼ |
| **é¢ç§¯å›¾** | ç´¯ç§¯è¶‹åŠ¿ã€å †å æ•°æ® | æ—¶é—´ + æ•°å€¼ |
| **æŸ±çŠ¶å›¾** | ç¦»æ•£æ—¶é—´ç‚¹å¯¹æ¯” | æ—¶é—´ + æ•°å€¼ |
| **çƒ­åŠ›å›¾** | æ—¶é—´æ¨¡å¼ã€å‘¨æœŸæ€§ | æ—¶é—´ + åˆ†ç±» |

### æŠ€æœ¯æ ˆ

- **çª—å£å‡½æ•°**ï¼šAVGã€SUMã€LAGã€LEADã€ROW_NUMBER
- **æ—¶é—´å‡½æ•°**ï¼šDATE_TRUNCã€EXTRACTã€INTERVAL
- **èšåˆå‡½æ•°**ï¼šSUMã€AVGã€COUNTã€PERCENTILE_CONT
- **CTE**ï¼šé€’å½’CTEã€å¤šçº§CTE

---

## 1. æ•°æ®å‡†å¤‡

```sql
-- æ—¶é—´åºåˆ—æ•°æ®å‡†å¤‡ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            DROP TABLE time_series_data CASCADE;
        END IF;

        CREATE TABLE time_series_data (
            date DATE NOT NULL,
            value NUMERIC NOT NULL,
            category VARCHAR(50),
            PRIMARY KEY (date, category)
        );

        -- æ’å…¥ç¤ºä¾‹æ—¶é—´åºåˆ—æ•°æ®ï¼ˆå¸¦è¶‹åŠ¿å’Œå­£èŠ‚æ€§ï¼‰
        INSERT INTO time_series_data (date, value, category)
        SELECT
            '2024-01-01'::DATE + (i * INTERVAL '1 day'),
            100 + i * 0.1 + 10 * SIN(i * 2 * PI() / 30) + (RANDOM() - 0.5) * 2 AS value,
            'Series A' AS category
        FROM generate_series(0, 365) i;

        INSERT INTO time_series_data (date, value, category)
        SELECT
            '2024-01-01'::DATE + (i * INTERVAL '1 day'),
            80 + i * 0.08 + 8 * SIN(i * 2 * PI() / 30) + (RANDOM() - 0.5) * 2 AS value,
            'Series B' AS category
        FROM generate_series(0, 365) i;

        CREATE INDEX idx_time_series_date ON time_series_data(date);
        CREATE INDEX idx_time_series_category ON time_series_data(category);

        RAISE NOTICE 'æ—¶é—´åºåˆ—æ•°æ®è¡¨åˆ›å»ºæˆåŠŸï¼Œå…± % æ¡è®°å½•', (SELECT COUNT(*) FROM time_series_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;
```

---

## 2. è¶‹åŠ¿å›¾æ•°æ®

### 2.1 åŸºç¡€è¶‹åŠ¿å›¾

```sql
-- æ—¶é—´åºåˆ—è¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING 'è¡¨ time_series_data ä¸å­˜åœ¨ï¼Œæ— æ³•ç”Ÿæˆè¶‹åŠ¿å›¾æ•°æ®';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹ç”Ÿæˆè¶‹åŠ¿å›¾æ•°æ®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'è¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- åŸºç¡€è¶‹åŠ¿å›¾ï¼šåŽŸå§‹æ•°æ® + ç§»åŠ¨å¹³å‡
WITH time_series AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS moving_avg_7,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS moving_avg_30
    FROM time_series_data
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS original_value,
    ROUND(moving_avg_7::numeric, 2) AS trend_7day,
    ROUND(moving_avg_30::numeric, 2) AS trend_30day
FROM time_series
ORDER BY category, date;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg_7
FROM time_series_data
WHERE category = 'Series A'
ORDER BY date;
```

### 2.2 å¤šç³»åˆ—å¯¹æ¯”è¶‹åŠ¿å›¾

```sql
-- å¤šç³»åˆ—å¯¹æ¯”è¶‹åŠ¿å›¾æ•°æ®
WITH series_comparison AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS trend_line,
        LAG(value) OVER (
            PARTITION BY category
            ORDER BY date
        ) AS prev_value,
        CASE
            WHEN LAG(value) OVER (PARTITION BY category ORDER BY date) IS NOT NULL THEN
                ((value - LAG(value) OVER (PARTITION BY category ORDER BY date)) /
                 NULLIF(LAG(value) OVER (PARTITION BY category ORDER BY date), 0) * 100)
            ELSE NULL
        END AS day_over_day_change
    FROM time_series_data
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS value,
    ROUND(trend_line::numeric, 2) AS trend_line,
    ROUND(day_over_day_change::numeric, 2) AS day_over_day_change_pct
FROM series_comparison
ORDER BY category, date;
```

---

## 3. å­£èŠ‚æ€§åˆ†è§£

### 3.1 åŸºç¡€å­£èŠ‚æ€§åˆ†è§£

```sql
-- å­£èŠ‚æ€§åˆ†è§£æ•°æ®ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING 'è¡¨ time_series_data ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå­£èŠ‚æ€§åˆ†è§£';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå­£èŠ‚æ€§åˆ†è§£';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å­£èŠ‚æ€§åˆ†è§£å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å­£èŠ‚æ€§åˆ†è§£ï¼šè¶‹åŠ¿ + å­£èŠ‚æ€§ + æ®‹å·®
WITH trend_component AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 14 PRECEDING AND 14 FOLLOWING
        ) AS trend
    FROM time_series_data
),
seasonal_component AS (
    SELECT
        date,
        category,
        value,
        trend,
        EXTRACT(MONTH FROM date) AS month,
        EXTRACT(DAY FROM date) AS day_of_month,
        AVG(value - trend) OVER (
            PARTITION BY category, EXTRACT(MONTH FROM date)
        ) AS seasonal_monthly,
        AVG(value - trend) OVER (
            PARTITION BY category, EXTRACT(DAY FROM date)
        ) AS seasonal_daily
    FROM trend_component
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS original_value,
    ROUND(trend::numeric, 2) AS trend_component,
    ROUND(seasonal_monthly::numeric, 2) AS seasonal_monthly,
    ROUND(seasonal_daily::numeric, 2) AS seasonal_daily,
    ROUND((value - trend - seasonal_monthly)::numeric, 2) AS residual
FROM seasonal_component
ORDER BY category, date;
```

### 3.2 å­£èŠ‚æ€§æ¨¡å¼å¯è§†åŒ–

```sql
-- å­£èŠ‚æ€§æ¨¡å¼å¯è§†åŒ–ï¼šæŒ‰æœˆä»½/æ˜ŸæœŸæ±‡æ€»
WITH monthly_pattern AS (
    SELECT
        category,
        EXTRACT(MONTH FROM date) AS month,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        STDDEV(value) AS stddev_value
    FROM time_series_data
    GROUP BY category, EXTRACT(MONTH FROM date)
),
weekly_pattern AS (
    SELECT
        category,
        EXTRACT(DOW FROM date) AS day_of_week,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value
    FROM time_series_data
    GROUP BY category, EXTRACT(DOW FROM date)
)
SELECT
    'Monthly Pattern' AS pattern_type,
    category,
    month::INTEGER AS period,
    ROUND(avg_value::numeric, 2) AS avg_value,
    ROUND(min_value::numeric, 2) AS min_value,
    ROUND(max_value::numeric, 2) AS max_value,
    ROUND(stddev_value::numeric, 2) AS stddev_value
FROM monthly_pattern
UNION ALL
SELECT
    'Weekly Pattern',
    category,
    day_of_week::INTEGER,
    ROUND(avg_value::numeric, 2),
    ROUND(min_value::numeric, 2),
    ROUND(max_value::numeric, 2),
    NULL
FROM weekly_pattern
ORDER BY pattern_type, category, period;
```

---

## 4. é¢ç§¯å›¾æ•°æ®

```sql
-- é¢ç§¯å›¾æ•°æ®ç”Ÿæˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING 'è¡¨ time_series_data ä¸å­˜åœ¨ï¼Œæ— æ³•ç”Ÿæˆé¢ç§¯å›¾æ•°æ®';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹ç”Ÿæˆé¢ç§¯å›¾æ•°æ®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é¢ç§¯å›¾æ•°æ®ç”Ÿæˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å †å é¢ç§¯å›¾æ•°æ®
WITH cumulative_values AS (
    SELECT
        date,
        category,
        value,
        SUM(value) OVER (
            PARTITION BY date
            ORDER BY category
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS cumulative_value,
        SUM(value) OVER (PARTITION BY date) AS total_value
    FROM time_series_data
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS value,
    ROUND(cumulative_value::numeric, 2) AS cumulative_value,
    ROUND(total_value::numeric, 2) AS total_value,
    ROUND((value / NULLIF(total_value, 0) * 100)::numeric, 2) AS percentage
FROM cumulative_values
ORDER BY date, category;
```

---

## 5. PostgreSQL 18 å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–å¢žå¼º

**PostgreSQL 18** æ˜¾è‘—å¢žå¼ºäº†å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®ç”Ÿæˆè®¡ç®—èƒ½åŠ›ï¼Œæ”¯æŒå¹¶è¡Œæ‰§è¡Œè¶‹åŠ¿å›¾ã€å­£èŠ‚æ€§åˆ†è§£å’Œé¢ç§¯å›¾æ•°æ®ç”Ÿæˆï¼Œå¤§å¹…æå‡å¤§è§„æ¨¡æ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®å‡†å¤‡çš„æ€§èƒ½ã€‚

### 5.1 å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–åŽŸç†

PostgreSQL 18 çš„å¹¶è¡Œæ—¶é—´åºåˆ—å¯è§†åŒ–é€šè¿‡ä»¥ä¸‹æ–¹å¼å®žçŽ°ï¼š

1. **å¹¶è¡Œæ‰«æ**ï¼šå¤šä¸ªå·¥ä½œè¿›ç¨‹å¹¶è¡Œæ‰«ææ—¶é—´åºåˆ—æ•°æ®
2. **å¹¶è¡Œè¶‹åŠ¿è®¡ç®—**ï¼šæ¯ä¸ªå·¥ä½œè¿›ç¨‹ç‹¬ç«‹è®¡ç®—è¶‹åŠ¿æˆåˆ†
3. **å¹¶è¡Œå­£èŠ‚æ€§æå–**ï¼šå¹¶è¡Œæ‰§è¡Œå­£èŠ‚æ€§æˆåˆ†æå–
4. **ç»“æžœåˆå¹¶**ï¼šä¸»è¿›ç¨‹åˆå¹¶æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è®¡ç®—ç»“æžœ

### 5.2 å¹¶è¡Œè¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆ

```sql
-- PostgreSQL 18 å¹¶è¡Œè¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING 'è¡¨ time_series_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œè¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆ';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œè¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œè¶‹åŠ¿å›¾æ•°æ®ç”Ÿæˆå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œç§»åŠ¨å¹³å‡è¶‹åŠ¿
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    date,
    value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS moving_avg_30
FROM time_series_data
WHERE date >= CURRENT_DATE - INTERVAL '1 year'
ORDER BY date;
```

### 5.3 å¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£å¯è§†åŒ–

```sql
-- PostgreSQL 18 å¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£å¯è§†åŒ–ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING 'è¡¨ time_series_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œå¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£å¯è§†åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ‰§è¡ŒPostgreSQL 18å¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£å¯è§†åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£å¯è§†åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- å¹¶è¡Œå­£èŠ‚æ€§æ¨¡å¼æå–
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
WITH trend_component AS (
    SELECT
        date,
        value,
        AVG(value) OVER (
            ORDER BY date
            ROWS BETWEEN 5 PRECEDING AND 6 FOLLOWING
        ) AS trend
    FROM time_series_data
)
SELECT
    date,
    value,
    ROUND(trend::numeric, 4) AS trend_component,
    ROUND((value - trend)::numeric, 4) AS detrended,
    AVG(value - trend) OVER (
        PARTITION BY EXTRACT(MONTH FROM date)
    ) AS seasonal_component
FROM trend_component
ORDER BY date;
```

---

## 6. å®žé™…åº”ç”¨æ¡ˆä¾‹

### 5.1 é”€å”®è¶‹åŠ¿åˆ†æž

```sql
-- é”€å”®è¶‹åŠ¿åˆ†æžåº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        -- åˆ›å»ºé”€å”®æ•°æ®è¡¨
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'sales_data') THEN
            DROP TABLE sales_data CASCADE;
        END IF;

        CREATE TABLE sales_data (
            sale_date DATE NOT NULL,
            product_category VARCHAR(50) NOT NULL,
            sales_amount NUMERIC NOT NULL,
            PRIMARY KEY (sale_date, product_category)
        );

        -- æ’å…¥ç¤ºä¾‹é”€å”®æ•°æ®
        INSERT INTO sales_data (sale_date, product_category, sales_amount)
        SELECT
            '2024-01-01'::DATE + (i * INTERVAL '1 day'),
            CASE (i % 3)
                WHEN 0 THEN 'Electronics'
                WHEN 1 THEN 'Clothing'
                ELSE 'Food'
            END AS product_category,
            1000 + i * 2 + 100 * SIN(i * 2 * PI() / 30) + (RANDOM() - 0.5) * 100 AS sales_amount
        FROM generate_series(0, 180) i;

        CREATE INDEX idx_sales_date ON sales_data(sale_date);
        CREATE INDEX idx_sales_category ON sales_data(product_category);

        RAISE NOTICE 'é”€å”®æ•°æ®è¡¨åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é”€å”®è¶‹åŠ¿åˆ†æžå‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- é”€å”®è¶‹åŠ¿åˆ†æžï¼šæŒ‰ç±»åˆ«å’Œæ€»ä½“
WITH sales_trends AS (
    SELECT
        sale_date,
        product_category,
        sales_amount,
        SUM(sales_amount) OVER (
            PARTITION BY product_category
            ORDER BY sale_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS weekly_sales,
        AVG(sales_amount) OVER (
            PARTITION BY product_category
            ORDER BY sale_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS weekly_avg,
        SUM(sales_amount) OVER (PARTITION BY sale_date) AS daily_total
    FROM sales_data
)
SELECT
    sale_date,
    product_category,
    ROUND(sales_amount::numeric, 2) AS daily_sales,
    ROUND(weekly_sales::numeric, 2) AS weekly_sales,
    ROUND(weekly_avg::numeric, 2) AS weekly_avg,
    ROUND(daily_total::numeric, 2) AS daily_total,
    ROUND((sales_amount / NULLIF(daily_total, 0) * 100)::numeric, 2) AS category_percentage
FROM sales_trends
ORDER BY sale_date, product_category;
```

### 5.2 å¼‚å¸¸æ£€æµ‹å¯è§†åŒ–

```sql
-- å¼‚å¸¸æ£€æµ‹å¯è§†åŒ–åº”ç”¨ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING 'è¡¨ time_series_data ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œå¼‚å¸¸æ£€æµ‹å¯è§†åŒ–';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œå¼‚å¸¸æ£€æµ‹å¯è§†åŒ–';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¼‚å¸¸æ£€æµ‹å¯è§†åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¼‚å¸¸æ£€æµ‹ï¼šä½¿ç”¨Z-scoreæ–¹æ³•
WITH time_series_stats AS (
    SELECT
        date,
        category,
        value,
        AVG(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS rolling_mean,
        STDDEV(value) OVER (
            PARTITION BY category
            ORDER BY date
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS rolling_stddev
    FROM time_series_data
),
anomaly_detection AS (
    SELECT
        date,
        category,
        value,
        rolling_mean,
        rolling_stddev,
        CASE
            WHEN rolling_stddev > 0 THEN (value - rolling_mean) / rolling_stddev
            ELSE 0
        END AS z_score,
        CASE
            WHEN ABS((value - rolling_mean) / NULLIF(rolling_stddev, 0)) > 2 THEN 'Anomaly'
            ELSE 'Normal'
        END AS anomaly_status
    FROM time_series_stats
    WHERE rolling_mean IS NOT NULL AND rolling_stddev IS NOT NULL
)
SELECT
    date,
    category,
    ROUND(value::numeric, 2) AS value,
    ROUND(rolling_mean::numeric, 2) AS expected_value,
    ROUND(z_score::numeric, 2) AS z_score,
    anomaly_status,
    ROUND((value - rolling_mean)::numeric, 2) AS deviation
FROM anomaly_detection
ORDER BY category, date;
```

---

## ðŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå…³é”®ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_time_series_date ON time_series_data(date);
CREATE INDEX IF NOT EXISTS idx_time_series_category ON time_series_data(category);
CREATE INDEX IF NOT EXISTS idx_time_series_date_category ON time_series_data(date, category);
```

### ç‰©åŒ–è§†å›¾

```sql
-- åˆ›å»ºå¸¸ç”¨å¯è§†åŒ–æ•°æ®çš„ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_time_series_trends AS
SELECT
    date,
    category,
    value,
    AVG(value) OVER (
        PARTITION BY category
        ORDER BY date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7
FROM time_series_data;

CREATE UNIQUE INDEX ON mv_time_series_trends(date, category);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_time_series_trends;
```

---

## ðŸŽ¯ æœ€ä½³å®žè·µ

### æ•°æ®å‡†å¤‡

1. **æ—¶é—´ç²’åº¦**ï¼šæ ¹æ®åˆ†æžéœ€æ±‚é€‰æ‹©åˆé€‚çš„æ—¶é—´ç²’åº¦
2. **æ•°æ®å®Œæ•´æ€§**ï¼šç¡®ä¿æ—¶é—´åºåˆ—æ•°æ®å®Œæ•´æ— ç¼ºå¤±
3. **æ•°æ®è´¨é‡**ï¼šæ¸…æ´—å¼‚å¸¸å€¼å’Œç¼ºå¤±å€¼

### å¯è§†åŒ–è®¾è®¡

1. **è¶‹åŠ¿çº¿**ï¼šä½¿ç”¨ç§»åŠ¨å¹³å‡å¹³æ»‘æ•°æ®ï¼Œçªå‡ºè¶‹åŠ¿
2. **å­£èŠ‚æ€§**ï¼šä½¿ç”¨å­£èŠ‚æ€§åˆ†è§£å±•ç¤ºå‘¨æœŸæ€§æ¨¡å¼
3. **å¼‚å¸¸æ ‡è®°**ï¼šä½¿ç”¨ä¸åŒé¢œè‰²æˆ–æ ‡è®°çªå‡ºå¼‚å¸¸å€¼

### SQLå®žçŽ°æ³¨æ„äº‹é¡¹

1. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨DOå—è¿›è¡Œé”™è¯¯å¤„ç†
2. **NULLå€¼å¤„ç†**ï¼šä½¿ç”¨COALESCEå’ŒNULLIFå¤„ç†NULLå€¼
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨ç´¢å¼•å’Œç‰©åŒ–è§†å›¾ä¼˜åŒ–æ€§èƒ½
4. **æ•°æ®ç±»åž‹è½¬æ¢**ï¼šæ³¨æ„æ•°æ®ç±»åž‹è½¬æ¢å’Œç²¾åº¦

---

## ðŸ“ˆ å¯è§†åŒ–æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | é€‚ç”¨åœºæ™¯ | ä¼˜åŠ¿ | å±€é™æ€§ |
|------|---------|------|--------|
| æŠ˜çº¿å›¾ | è¶‹åŠ¿å±•ç¤ºã€è¿žç»­æ•°æ® | ç›´è§‚ã€æ˜“äºŽç†è§£ | æ•°æ®ç‚¹è¿‡å¤šæ—¶éš¾ä»¥é˜…è¯» |
| é¢ç§¯å›¾ | ç´¯ç§¯è¶‹åŠ¿ã€å †å æ•°æ® | å±•ç¤ºæ€»é‡å’Œç»„æˆ | å¯èƒ½æŽ©ç›–ç»†èŠ‚ |
| æŸ±çŠ¶å›¾ | ç¦»æ•£æ—¶é—´ç‚¹å¯¹æ¯” | æ¸…æ™°å¯¹æ¯” | ä¸é€‚åˆè¿žç»­æ•°æ® |
| çƒ­åŠ›å›¾ | æ—¶é—´æ¨¡å¼ã€å‘¨æœŸæ€§ | å±•ç¤ºæ¨¡å¼ | éœ€è¦è¶³å¤Ÿæ•°æ® |

---

## ðŸ” å¸¸è§é—®é¢˜ä¸Žè§£å†³æ–¹æ¡ˆ

### é—®é¢˜1ï¼šæ•°æ®ç‚¹è¿‡å¤šï¼Œå›¾è¡¨éš¾ä»¥é˜…è¯»

**åŽŸå› **ï¼š

- æ—¶é—´ç²’åº¦å¤ªç»†
- æ•°æ®é‡è¿‡å¤§

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨æ—¶é—´èšåˆï¼ˆæŒ‰å¤©/å‘¨/æœˆï¼‰
- ä½¿ç”¨ç§»åŠ¨å¹³å‡å¹³æ»‘
- ä½¿ç”¨é‡‡æ ·å‡å°‘æ•°æ®ç‚¹

### é—®é¢˜2ï¼šå­£èŠ‚æ€§ä¸æ˜Žæ˜¾

**åŽŸå› **ï¼š

- æ•°æ®å‘¨æœŸä¸è¶³
- å­£èŠ‚æ€§åˆ†è§£æ–¹æ³•ä¸å½“

**è§£å†³æ–¹æ¡ˆ**ï¼š

- æ”¶é›†è¶³å¤Ÿé•¿çš„æ•°æ®
- ä½¿ç”¨åˆé€‚çš„å­£èŠ‚æ€§åˆ†è§£æ–¹æ³•
- ä½¿ç”¨é¢‘åŸŸåˆ†æžæ£€æµ‹å‘¨æœŸ

### é—®é¢˜3ï¼šè¶‹åŠ¿è®¡ç®—æ…¢

**åŽŸå› **ï¼š

- çª—å£å‡½æ•°è®¡ç®—å¤æ‚
- æœªä½¿ç”¨ç´¢å¼•

**è§£å†³æ–¹æ¡ˆ**ï¼š

- ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ç»“æžœ
- åˆ›å»ºåˆé€‚çš„ç´¢å¼•
- ä¼˜åŒ–çª—å£å‡½æ•°å‚æ•°

---

## ðŸ“š å‚è€ƒèµ„æº

1. **Tufte, E.R. (2001)**: "The Visual Display of Quantitative Information"
2. **Few, S. (2009)**: "Now You See It: Simple Visualization Techniques for Quantitative Analysis"
3. **Heer, J., Bostock, M., Ogievetsky, V. (2010)**: "A Tour Through the Visualization Zoo"

---

### SQLå®žçŽ°æ³¨æ„äº‹é¡¹

1. **æ—¶é—´èšåˆ**: æ ¹æ®æ•°æ®é‡é€‰æ‹©åˆé€‚çš„æ—¶é—´ç²’åº¦ï¼ˆå°æ—¶/å¤©/å‘¨/æœˆï¼‰
2. **çª—å£å‡½æ•°**: ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ç§»åŠ¨å¹³å‡å’Œè¶‹åŠ¿
3. **é‡‡æ ·ç­–ç•¥**: å¯¹äºŽå¤§æ•°æ®é‡ï¼Œä½¿ç”¨é‡‡æ ·å‡å°‘å¯è§†åŒ–æ•°æ®ç‚¹
4. **æ€§èƒ½ä¼˜åŒ–**: ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å¯è§†åŒ–æ•°æ®

### PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢žå¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢žå¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡æ—¶é—´åºåˆ—å¯è§†åŒ–çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºŽåŒ…å«æ—¶é—´æˆ³çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºŽTop-Næ—¶é—´ç‚¹æŸ¥è¯¢å’Œæ—¶é—´èŒƒå›´å¯¹æ¯”æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢žå¼º**ï¼š
   - å¯¹äºŽå¤§è§„æ¨¡æ—¶é—´åºåˆ—å¯è§†åŒ–ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºŽæ‰¹é‡è¶‹åŠ¿è®¡ç®—å’Œå¹¶è¡Œå­£èŠ‚æ€§åˆ†è§£

3. **å¹¶è¡ŒæŸ¥è¯¢å¢žå¼º**ï¼š
   - æ—¶é—´åºåˆ—å¯è§†åŒ–æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨5èŠ‚è¯¦ç»†è¯´æ˜Žï¼‰
   - é€‚ç”¨äºŽå¤§è§„æ¨¡æ—¶é—´åºåˆ—åˆ†æžå’Œå¹¶è¡Œå›¾è¡¨æ•°æ®ç”Ÿæˆ

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–æ—¶é—´åºåˆ—å¯è§†åŒ–æŸ¥è¯¢**

```sql
-- ä¸ºæ—¶é—´åºåˆ—å¯è§†åŒ–åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_timeseries_viz_skip_scan
ON time_series_data(timestamp DESC, value DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ¯ä¸ªæ—¶é—´ç‚¹çš„æœ€å¤§å€¼
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (DATE_TRUNC('hour', timestamp))
    timestamp,
    series_name,
    value
FROM time_series_data
ORDER BY DATE_TRUNC('hour', timestamp), value DESC
LIMIT 50;
```

### é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢žå¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜æ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®**

å¯¹äºŽé¢‘ç¹ä½¿ç”¨çš„æ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®ï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜æ—¶é—´åºåˆ—å¯è§†åŒ–æ•°æ®
CREATE MATERIALIZED VIEW IF NOT EXISTS timeseries_visualization_cache AS
WITH trend_calculation AS (
    SELECT
        DATE_TRUNC('day', timestamp) AS date_day,
        series_name,
        AVG(value) AS daily_avg,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—ç§»åŠ¨å¹³å‡ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        AVG(value) OVER (
            PARTITION BY series_name
            ORDER BY DATE_TRUNC('day', timestamp)
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) AS moving_avg_7d,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—è¶‹åŠ¿æ–¹å‘
        CASE
            WHEN AVG(value) OVER (
                PARTITION BY series_name
                ORDER BY DATE_TRUNC('day', timestamp)
                ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
            ) > AVG(value) OVER (
                PARTITION BY series_name
                ORDER BY DATE_TRUNC('day', timestamp)
                ROWS BETWEEN 13 PRECEDING AND 7 PRECEDING
            ) THEN 'Upward Trend'
            WHEN AVG(value) OVER (
                PARTITION BY series_name
                ORDER BY DATE_TRUNC('day', timestamp)
                ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
            ) < AVG(value) OVER (
                PARTITION BY series_name
                ORDER BY DATE_TRUNC('day', timestamp)
                ROWS BETWEEN 13 PRECEDING AND 7 PRECEDING
            ) THEN 'Downward Trend'
            ELSE 'Stable Trend'
        END AS trend_direction
    FROM time_series_data
    GROUP BY DATE_TRUNC('day', timestamp), series_name
)
SELECT
    date_day,
    series_name,
    ROUND(daily_avg::numeric, 4) AS daily_avg,
    ROUND(moving_avg_7d::numeric, 4) AS moving_avg_7d,
    trend_direction
FROM trend_calculation
ORDER BY date_day DESC, series_name;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_timeseries_viz_cache_date_series ON timeseries_visualization_cache(date_day DESC, series_name);
CREATE INDEX idx_timeseries_viz_cache_trend ON timeseries_visualization_cache(trend_direction, daily_avg DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY timeseries_visualization_cache;
```

**2. å®žæ—¶æ—¶é—´åºåˆ—å¯è§†åŒ–ï¼šå¢žé‡è¶‹åŠ¿æ›´æ–°**

**å®žæ—¶æ—¶é—´åºåˆ—å¯è§†åŒ–**ï¼šå¯¹äºŽå®žæ—¶æ•°æ®ï¼Œä½¿ç”¨å¢žé‡æ–¹æ³•æ›´æ–°å¯è§†åŒ–æ•°æ®ã€‚

```sql
-- å®žæ—¶æ—¶é—´åºåˆ—å¯è§†åŒ–ï¼šå¢žé‡è¶‹åŠ¿æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'timeseries_visualization_state') THEN
            CREATE TABLE timeseries_visualization_state (
                series_name VARCHAR(100) NOT NULL,
                time_granularity VARCHAR(20) NOT NULL,  -- 'hour', 'day', 'week', 'month'
                time_bucket TIMESTAMPTZ NOT NULL,
                sum_values NUMERIC DEFAULT 0,
                count_values BIGINT DEFAULT 0,
                avg_value NUMERIC,
                trend_value NUMERIC,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (series_name, time_granularity, time_bucket)
            );

            CREATE INDEX idx_timeseries_viz_state_series ON timeseries_visualization_state(series_name, time_bucket DESC);
            CREATE INDEX idx_timeseries_viz_state_updated ON timeseries_visualization_state(last_updated DESC);

            RAISE NOTICE 'æ—¶é—´åºåˆ—å¯è§†åŒ–çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢žé‡æ—¶é—´åºåˆ—å¯è§†åŒ–æ›´æ–°';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢žé‡æ—¶é—´åºåˆ—å¯è§†åŒ–æ›´æ–°å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**3. æ™ºèƒ½æ—¶é—´åºåˆ—å¯è§†åŒ–ï¼šè‡ªé€‚åº”èšåˆç­–ç•¥é€‰æ‹©**

**æ™ºèƒ½æ—¶é—´åºåˆ—å¯è§†åŒ–**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜èšåˆç­–ç•¥ã€‚

```sql
-- æ™ºèƒ½æ—¶é—´åºåˆ—å¯è§†åŒ–ï¼šè‡ªé€‚åº”èšåˆç­–ç•¥é€‰æ‹©ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    data_points_count BIGINT;
    time_span_days INTEGER;
    recommended_granularity VARCHAR(20);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'time_series_data') THEN
            RAISE WARNING 'è¡¨ time_series_data ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½æ—¶é—´åºåˆ—å¯è§†åŒ–ä¼˜åŒ–';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®ç‰¹å¾
        SELECT
            COUNT(*),
            EXTRACT(DAY FROM MAX(timestamp) - MIN(timestamp))
        INTO data_points_count, time_span_days
        FROM time_series_data;

        -- æ ¹æ®æ•°æ®ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©æ—¶é—´ç²’åº¦
        IF time_span_days < 7 THEN
            recommended_granularity := 'hour';  -- çŸ­æœŸæ•°æ®ï¼šå°æ—¶çº§
        ELSIF time_span_days < 90 THEN
            recommended_granularity := 'day';  -- ä¸­æœŸæ•°æ®ï¼šå¤©çº§
        ELSIF time_span_days < 365 THEN
            recommended_granularity := 'week';  -- é•¿æœŸæ•°æ®ï¼šå‘¨çº§
        ELSE
            recommended_granularity := 'month';  -- è¶…é•¿æœŸæ•°æ®ï¼šæœˆçº§
        END IF;

        RAISE NOTICE 'æ•°æ®ç‚¹æ•°: %, æ—¶é—´è·¨åº¦: % å¤©, æŽ¨èç²’åº¦: %',
            data_points_count, time_span_days, recommended_granularity;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½æ—¶é—´åºåˆ—å¯è§†åŒ–ä¼˜åŒ–å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

**æœ€åŽæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç†è®ºæŽ¨å¯¼ã€å®žçŽ°å’ŒPostgreSQL 18æ–°ç‰¹æ€§æ”¯æŒï¼‰
