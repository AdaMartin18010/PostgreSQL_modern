# PostgreSQL äº¤äº’å¼å¯è§†åŒ–æ•°æ®ç”Ÿæˆå®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ•°æ®å¯è§†åŒ– | äº¤äº’å¼ | åŠ¨æ€æŸ¥è¯¢
> **éš¾åº¦çº§åˆ«**: â­â­â­ (ä¸­çº§)
> **å‚è€ƒæ ‡å‡†**: Interactive Visualization, Dynamic Queries

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL äº¤äº’å¼å¯è§†åŒ–æ•°æ®ç”Ÿæˆå®Œæ•´æŒ‡å—](#postgresql-äº¤äº’å¼å¯è§†åŒ–æ•°æ®ç”Ÿæˆå®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [äº¤äº’å¼å¯è§†åŒ–æ¦‚è¿°](#äº¤äº’å¼å¯è§†åŒ–æ¦‚è¿°)
    - [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
  - [1. åŠ¨æ€æŸ¥è¯¢](#1-åŠ¨æ€æŸ¥è¯¢)
    - [1.1 å‚æ•°åŒ–æŸ¥è¯¢](#11-å‚æ•°åŒ–æŸ¥è¯¢)
    - [1.2 åŠ¨æ€èšåˆ](#12-åŠ¨æ€èšåˆ)
  - [2. å®æ—¶æ›´æ–°](#2-å®æ—¶æ›´æ–°)
    - [2.1 ç‰©åŒ–è§†å›¾è‡ªåŠ¨åˆ·æ–°](#21-ç‰©åŒ–è§†å›¾è‡ªåŠ¨åˆ·æ–°)
    - [2.2 å¢é‡æ›´æ–°ç­–ç•¥](#22-å¢é‡æ›´æ–°ç­–ç•¥)
  - [3. äº¤äº’å¼é’»å–](#3-äº¤äº’å¼é’»å–)
    - [3.1 å±‚æ¬¡é’»å–](#31-å±‚æ¬¡é’»å–)
  - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 æŸ¥è¯¢æ€§èƒ½æµ‹è¯•](#41-æŸ¥è¯¢æ€§èƒ½æµ‹è¯•)
    - [4.2 ç´¢å¼•ä¼˜åŒ–](#42-ç´¢å¼•ä¼˜åŒ–)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
  - [ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®](#-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
  - [ğŸ¯ æœ€ä½³å®è·µ](#-æœ€ä½³å®è·µ)

---

## äº¤äº’å¼å¯è§†åŒ–æ¦‚è¿°

**äº¤äº’å¼å¯è§†åŒ–**å…è®¸ç”¨æˆ·é€šè¿‡äº¤äº’æ“ä½œæ¢ç´¢æ•°æ®ï¼Œå®ç°åŠ¨æ€æŸ¥è¯¢ã€å®æ—¶æ›´æ–°å’Œäº¤äº’å¼åˆ†æã€‚

### æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§ | æè¿° | å®ç°æ–¹å¼ |
|------|------|---------|
| **åŠ¨æ€æŸ¥è¯¢** | æ ¹æ®ç”¨æˆ·è¾“å…¥åŠ¨æ€ç”ŸæˆæŸ¥è¯¢ | å‚æ•°åŒ–æŸ¥è¯¢ã€CTE |
| **å®æ—¶æ›´æ–°** | æ•°æ®å˜åŒ–æ—¶è‡ªåŠ¨æ›´æ–°å¯è§†åŒ– | ç‰©åŒ–è§†å›¾ã€è§¦å‘å™¨ |
| **äº¤äº’å¼è¿‡æ»¤** | ç”¨æˆ·ç‚¹å‡»ç­›é€‰æ•°æ® | åŠ¨æ€WHEREæ¡ä»¶ |
| **é’»å–åˆ†æ** | ä»æ±‡æ€»åˆ°æ˜ç»†çš„æ·±å…¥åˆ†æ | å±‚æ¬¡æŸ¥è¯¢ |

---

## 1. åŠ¨æ€æŸ¥è¯¢

### 1.1 å‚æ•°åŒ–æŸ¥è¯¢

**å‚æ•°åŒ–æŸ¥è¯¢**ä½¿ç”¨å ä½ç¬¦å®ç°åŠ¨æ€æŸ¥è¯¢ã€‚

```sql
-- åˆ›å»ºäº¤äº’å¼æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'interactive_data') THEN
            DROP TABLE interactive_data CASCADE;
        END IF;

        CREATE TABLE interactive_data (
            id SERIAL PRIMARY KEY,
            date DATE NOT NULL,
            category VARCHAR(50) NOT NULL,
            region VARCHAR(50) NOT NULL,
            value NUMERIC NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        -- æ’å…¥ç¤ºä¾‹æ•°æ®
        INSERT INTO interactive_data (date, category, region, value) VALUES
            ('2024-01-01', 'Electronics', 'North', 1000),
            ('2024-01-02', 'Electronics', 'South', 1200),
            ('2024-01-03', 'Clothing', 'North', 800),
            ('2024-01-04', 'Clothing', 'South', 900),
            ('2024-01-05', 'Electronics', 'East', 1100);

        CREATE INDEX idx_interactive_date ON interactive_data(date);
        CREATE INDEX idx_interactive_category ON interactive_data(category);
        CREATE INDEX idx_interactive_region ON interactive_data(region);

        RAISE NOTICE 'äº¤äº’å¼æ•°æ®è¡¨åˆ›å»ºæˆåŠŸï¼Œå…± % æ¡è®°å½•', (SELECT COUNT(*) FROM interactive_data);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- åŠ¨æ€æŸ¥è¯¢ï¼šå¤šç»´åº¦è¿‡æ»¤
CREATE OR REPLACE FUNCTION interactive_query(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_category VARCHAR DEFAULT NULL,
    p_region VARCHAR DEFAULT NULL,
    p_limit INTEGER DEFAULT 1000
)
RETURNS TABLE (
    date DATE,
    category VARCHAR,
    region VARCHAR,
    value NUMERIC,
    total_value NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH filtered_data AS (
        SELECT
            id.date,
            id.category,
            id.region,
            id.value
        FROM interactive_data id
        WHERE (p_start_date IS NULL OR id.date >= p_start_date)
          AND (p_end_date IS NULL OR id.date <= p_end_date)
          AND (p_category IS NULL OR id.category = p_category)
          AND (p_region IS NULL OR id.region = p_region)
    ),
    aggregated AS (
        SELECT
            date,
            category,
            region,
            SUM(value) AS value,
            SUM(SUM(value)) OVER () AS total_value
        FROM filtered_data
        GROUP BY date, category, region
    )
    SELECT
        a.date,
        a.category,
        a.region,
        a.value,
        a.total_value
    FROM aggregated a
    ORDER BY a.date DESC, a.value DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨åŠ¨æ€æŸ¥è¯¢å‡½æ•°
SELECT * FROM interactive_query(
    p_start_date := '2024-01-01',
    p_end_date := '2024-01-05',
    p_category := 'Electronics',
    p_limit := 100
);
```

### 1.2 åŠ¨æ€èšåˆ

**åŠ¨æ€èšåˆ**æ ¹æ®ç”¨æˆ·é€‰æ‹©åŠ¨æ€è®¡ç®—èšåˆæŒ‡æ ‡ã€‚

```sql
-- åŠ¨æ€èšåˆå‡½æ•°
CREATE OR REPLACE FUNCTION dynamic_aggregate(
    p_metric VARCHAR,  -- 'sum', 'avg', 'count', 'max', 'min'
    p_group_by VARCHAR[] DEFAULT ARRAY['date']::VARCHAR[]
)
RETURNS TABLE (
    group_key TEXT,
    metric_value NUMERIC
) AS $$
DECLARE
    sql_query TEXT;
    group_clause TEXT;
BEGIN
    -- æ„å»ºGROUP BYå­å¥
    group_clause := array_to_string(p_group_by, ', ');

    -- æ„å»ºSQLæŸ¥è¯¢
    sql_query := format('
        SELECT
            CONCAT(%s) AS group_key,
            %s(value) AS metric_value
        FROM interactive_data
        GROUP BY %s
        ORDER BY metric_value DESC
    ', group_clause, p_metric, group_clause);

    RETURN QUERY EXECUTE sql_query;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨åŠ¨æ€èšåˆ
SELECT * FROM dynamic_aggregate('sum', ARRAY['category', 'region']);
```

---

## 2. å®æ—¶æ›´æ–°

### 2.1 ç‰©åŒ–è§†å›¾è‡ªåŠ¨åˆ·æ–°

**ç‰©åŒ–è§†å›¾**ç¼“å­˜æŸ¥è¯¢ç»“æœï¼Œæ”¯æŒå¢é‡æ›´æ–°ã€‚

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'interactive_summary') THEN
            DROP MATERIALIZED VIEW interactive_summary CASCADE;
        END IF;

        CREATE MATERIALIZED VIEW interactive_summary AS
        SELECT
            date,
            category,
            region,
            COUNT(*) AS record_count,
            SUM(value) AS total_value,
            AVG(value) AS avg_value,
            MIN(value) AS min_value,
            MAX(value) AS max_value,
            STDDEV(value) AS stddev_value
        FROM interactive_data
        GROUP BY date, category, region;

        CREATE UNIQUE INDEX idx_interactive_summary ON interactive_summary(date, category, region);

        RAISE NOTICE 'ç‰©åŒ–è§†å›¾åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºç‰©åŒ–è§†å›¾å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- è‡ªåŠ¨åˆ·æ–°è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION refresh_interactive_summary()
RETURNS TRIGGER AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY interactive_summary;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨ï¼ˆå¯é€‰ï¼šåœ¨æ•°æ®æ›´æ–°æ—¶è‡ªåŠ¨åˆ·æ–°ï¼‰
-- CREATE TRIGGER trg_refresh_summary
-- AFTER INSERT OR UPDATE OR DELETE ON interactive_data
-- FOR EACH STATEMENT
-- EXECUTE FUNCTION refresh_interactive_summary();

-- æ‰‹åŠ¨åˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY interactive_summary;
```

### 2.2 å¢é‡æ›´æ–°ç­–ç•¥

**å¢é‡æ›´æ–°**åªæ›´æ–°å˜åŒ–çš„æ•°æ®ï¼Œæé«˜æ€§èƒ½ã€‚

```sql
-- å¢é‡æ›´æ–°ç‰©åŒ–è§†å›¾
CREATE OR REPLACE FUNCTION incremental_refresh_summary(p_last_update TIMESTAMP)
RETURNS VOID AS $$
BEGIN
    -- åˆ é™¤è¿‡æœŸçš„æ±‡æ€»æ•°æ®
    DELETE FROM interactive_summary
    WHERE date IN (
        SELECT DISTINCT date
        FROM interactive_data
        WHERE created_at > p_last_update
    );

    -- æ’å…¥æ–°çš„æ±‡æ€»æ•°æ®
    INSERT INTO interactive_summary
    SELECT
        date,
        category,
        region,
        COUNT(*) AS record_count,
        SUM(value) AS total_value,
        AVG(value) AS avg_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        STDDEV(value) AS stddev_value
    FROM interactive_data
    WHERE created_at > p_last_update
    GROUP BY date, category, region
    ON CONFLICT (date, category, region) DO UPDATE SET
        record_count = EXCLUDED.record_count,
        total_value = EXCLUDED.total_value,
        avg_value = EXCLUDED.avg_value,
        min_value = EXCLUDED.min_value,
        max_value = EXCLUDED.max_value,
        stddev_value = EXCLUDED.stddev_value;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. äº¤äº’å¼é’»å–

### 3.1 å±‚æ¬¡é’»å–

**å±‚æ¬¡é’»å–**ä»æ±‡æ€»åˆ°æ˜ç»†çš„æ·±å…¥åˆ†æã€‚

```sql
-- å±‚æ¬¡é’»å–ï¼šä»å¹´åº¦åˆ°æœˆåº¦åˆ°æ—¥åº¦
WITH hierarchy_levels AS (
    SELECT
        'year' AS level,
        DATE_TRUNC('year', date) AS time_period,
        category,
        SUM(value) AS total_value
    FROM interactive_data
    GROUP BY DATE_TRUNC('year', date), category

    UNION ALL

    SELECT
        'month' AS level,
        DATE_TRUNC('month', date) AS time_period,
        category,
        SUM(value) AS total_value
    FROM interactive_data
    GROUP BY DATE_TRUNC('month', date), category

    UNION ALL

    SELECT
        'day' AS level,
        date AS time_period,
        category,
        SUM(value) AS total_value
    FROM interactive_data
    GROUP BY date, category
)
SELECT
    level,
    time_period,
    category,
    ROUND(total_value::numeric, 2) AS total_value,
    ROUND(100.0 * total_value / SUM(total_value) OVER (PARTITION BY level), 2) AS percentage
FROM hierarchy_levels
ORDER BY level, time_period, category;
```

---

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 æŸ¥è¯¢æ€§èƒ½æµ‹è¯•

```sql
-- æ€§èƒ½æµ‹è¯•ï¼šåŠ¨æ€æŸ¥è¯¢
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM interactive_query(
    p_start_date := '2024-01-01',
    p_end_date := '2024-01-05',
    p_category := 'Electronics'
);
```

### 4.2 ç´¢å¼•ä¼˜åŒ–

```sql
-- åˆ›å»ºå¤åˆç´¢å¼•ä¼˜åŒ–å¤šç»´åº¦æŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_interactive_composite
ON interactive_data(date, category, region)
INCLUDE (value);

-- åˆ†æç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'interactive_data';
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Heer, J., Bostock, M. (2010)**: "Crowdsourcing Graphical Perception: Using Mechanical Turk to Assess Visualization Design"
2. **Shneiderman, B. (1996)**: "The Eyes Have It: A Task by Data Type Taxonomy for Information Visualizations"

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ä½¿ç”¨ç‰©åŒ–è§†å›¾**ï¼šç¼“å­˜å¸¸ç”¨æŸ¥è¯¢ç»“æœ
2. **åˆ›å»ºåˆé€‚ç´¢å¼•**ï¼šä¼˜åŒ–å¤šç»´åº¦æŸ¥è¯¢
3. **å‚æ•°åŒ–æŸ¥è¯¢**ï¼šé¿å…SQLæ³¨å…¥ï¼Œæé«˜ç¼“å­˜æ•ˆç‡
4. **å¢é‡æ›´æ–°**ï¼šåªæ›´æ–°å˜åŒ–çš„æ•°æ®

---

## ğŸ¯ æœ€ä½³å®è·µ

1. **æŸ¥è¯¢ä¼˜åŒ–**ï¼šä½¿ç”¨EXPLAIN ANALYZEåˆ†ææŸ¥è¯¢æ€§èƒ½
2. **ç¼“å­˜ç­–ç•¥**ï¼šåˆç†ä½¿ç”¨ç‰©åŒ–è§†å›¾å’Œç¼“å­˜
3. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›å¿«é€Ÿå“åº”å’Œå®æ—¶åé¦ˆ
4. **å®‰å…¨æ€§**ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢SQLæ³¨å…¥

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
