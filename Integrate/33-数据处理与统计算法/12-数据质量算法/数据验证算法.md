# PostgreSQL 数据验证算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数据验证 | 约束检查
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 数据验证算法完整指南](#postgresql-数据验证算法完整指南)
  - [📋 目录](#-目录)
  - [数据验证概述](#数据验证概述)
    - [理论基础](#理论基础)
      - [数据验证原理](#数据验证原理)
      - [验证规则类型](#验证规则类型)
      - [验证策略](#验证策略)
    - [核心算法](#核心算法)
  - [1. 格式验证](#1-格式验证)
    - [1.1 格式验证原理](#11-格式验证原理)
      - [正则表达式基础](#正则表达式基础)
      - [PostgreSQL正则表达式函数](#postgresql正则表达式函数)
    - [1.2 邮箱格式验证实现](#12-邮箱格式验证实现)
    - [1.3 电话号码验证实现](#13-电话号码验证实现)
    - [1.4 URL格式验证](#14-url格式验证)
    - [1.5 身份证号验证](#15-身份证号验证)
  - [2. 范围验证](#2-范围验证)
    - [2.1 范围验证原理](#21-范围验证原理)
      - [数值范围验证](#数值范围验证)
      - [日期范围验证](#日期范围验证)
      - [字符串长度验证](#字符串长度验证)
    - [2.2 数值范围验证实现](#22-数值范围验证实现)
    - [2.3 日期范围验证](#23-日期范围验证)
    - [2.4 字符串长度验证](#24-字符串长度验证)
  - [3. 业务规则验证](#3-业务规则验证)
    - [3.1 业务规则验证原理](#31-业务规则验证原理)
      - [跨字段验证](#跨字段验证)
      - [条件验证](#条件验证)
      - [聚合验证](#聚合验证)
    - [3.2 自定义规则验证实现](#32-自定义规则验证实现)
    - [3.3 引用完整性验证](#33-引用完整性验证)
    - [3.4 唯一性验证](#34-唯一性验证)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 综合数据验证](#41-综合数据验证)
    - [4.2 用户注册数据验证](#42-用户注册数据验证)
    - [4.3 订单数据验证](#43-订单数据验证)
    - [4.4 数据质量监控](#44-数据质量监控)
    - [4.5 实时数据验证](#45-实时数据验证)
  - [5. 算法性能对比与优化](#5-算法性能对比与优化)
    - [5.1 验证方法对比](#51-验证方法对比)
    - [5.2 性能优化建议](#52-性能优化建议)
    - [5.3 常见问题与解决方案](#53-常见问题与解决方案)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 验证策略](#61-验证策略)
    - [6.2 验证规则设计](#62-验证规则设计)
    - [6.3 错误处理](#63-错误处理)
    - [6.4 SQL实现注意事项](#64-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 数据验证概述

**数据验证（Data Validation）**是确保数据质量的关键环节，通过检查数据是否符合预定义的规则、约束和业务逻辑，识别和标记无效、不一致或不符合要求的数据。

### 理论基础

#### 数据验证原理

**数据验证**是在数据进入系统或处理之前，对数据进行检查以确保其正确性、完整性和一致性的过程。

**验证目标**：

1. **正确性**：数据值是否正确
2. **完整性**：必需字段是否存在
3. **一致性**：数据是否符合业务规则
4. **格式性**：数据格式是否符合规范
5. **有效性**：数据是否在有效范围内

#### 验证规则类型

1. **格式验证（Format Validation）**：
   - 检查数据格式是否符合规范
   - 使用正则表达式、模式匹配
   - 示例：邮箱格式、电话号码格式、日期格式

2. **范围验证（Range Validation）**：
   - 检查数据值是否在有效范围内
   - 数值范围、日期范围、字符串长度
   - 示例：年龄在0-150之间、分数在0-100之间

3. **业务规则验证（Business Rule Validation）**：
   - 检查数据是否符合业务逻辑
   - 跨字段验证、条件验证
   - 示例：订单金额必须大于0、结束日期必须晚于开始日期

4. **引用完整性验证（Referential Integrity Validation）**：
   - 检查外键引用是否有效
   - 确保关联数据存在
   - 示例：订单必须关联有效的客户

5. **唯一性验证（Uniqueness Validation）**：
   - 检查数据是否唯一
   - 主键、唯一约束
   - 示例：邮箱地址必须唯一

#### 验证策略

1. **实时验证（Real-time Validation）**：
   - 在数据输入时立即验证
   - 提供即时反馈
   - 适合用户输入场景

2. **批量验证（Batch Validation）**：
   - 对大量数据进行批量验证
   - 生成验证报告
   - 适合数据导入、ETL场景

3. **延迟验证（Deferred Validation）**：
   - 在事务提交时验证
   - 提高性能
   - 适合数据库约束

### 核心算法

| 验证类型 | 验证方法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|---------|-----------|-----------|---------|
| **格式验证** | 正则表达式、模式匹配 | $O(n)$ | $O(1)$ | 邮箱、电话、URL |
| **范围验证** | 数值比较、区间检查 | $O(n)$ | $O(1)$ | 年龄、分数、日期 |
| **规则验证** | 条件判断、逻辑运算 | $O(n)$ | $O(1)$ | 业务规则、跨字段验证 |
| **完整性验证** | 外键检查、关联查询 | $O(n \log n)$ | $O(n)$ | 引用完整性 |
| **唯一性验证** | 哈希表、索引查找 | $O(n)$ | $O(n)$ | 唯一约束 |

---

## 1. 格式验证

### 1.1 格式验证原理

**格式验证**检查数据是否符合预定义的格式规范，通常使用正则表达式（Regular Expression）进行模式匹配。

#### 正则表达式基础

**正则表达式**是一种描述字符串模式的语法，用于匹配、查找和替换文本。

**常用元字符**：

- `.`：匹配任意字符
- `*`：匹配前一个字符0次或多次
- `+`：匹配前一个字符1次或多次
- `?`：匹配前一个字符0次或1次
- `^`：匹配字符串开始
- `$`：匹配字符串结束
- `[]`：字符类，匹配括号内的任意字符
- `()`：分组
- `|`：或运算符

#### PostgreSQL正则表达式函数

1. **~**：匹配正则表达式（区分大小写）
2. **~***：匹配正则表达式（不区分大小写）
3. **!~**：不匹配正则表达式（区分大小写）
4. **!~***：不匹配正则表达式（不区分大小写）
5. **regexp_match()**：返回匹配的子串
6. **regexp_replace()**：替换匹配的子串

### 1.2 邮箱格式验证实现

```sql
-- 创建测试数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'validation_test') THEN
            RAISE WARNING '表 validation_test 已存在，先删除';
            DROP TABLE validation_test CASCADE;
        END IF;

        CREATE TABLE validation_test (
            id SERIAL PRIMARY KEY,
            email VARCHAR(100),
            phone VARCHAR(20),
            age INTEGER,
            score NUMERIC(5, 2)
        );

        INSERT INTO validation_test (email, phone, age, score) VALUES
            ('valid@example.com', '13800138000', 25, 85.5),
            ('invalid-email', '12345', 15, 120.0),
            ('test@domain', '13800138001', 30, 95.0),
            ('user@test.com', 'invalid-phone', 25, 75.5);

        RAISE NOTICE '表 validation_test 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 validation_test 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 邮箱格式验证（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'validation_test') THEN
            RAISE WARNING '表 validation_test 不存在，无法验证邮箱格式';
            RETURN;
        END IF;
        RAISE NOTICE '开始验证邮箱格式';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '邮箱格式验证准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 验证邮箱格式
SELECT
    id,
    email,
    CASE
        WHEN email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN 'Valid'
        ELSE 'Invalid'
    END AS email_validation_status,
    CASE
        WHEN email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN NULL
        ELSE 'Email format is invalid'
    END AS validation_error
FROM validation_test
WHERE email IS NOT NULL
ORDER BY id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    email
FROM validation_test
WHERE email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
```

### 1.3 电话号码验证实现

**电话号码验证**验证电话号码格式，支持多种格式（固定电话、手机、国际号码等）。

```sql
-- 电话号码验证（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'validation_test') THEN
            RAISE WARNING '表 validation_test 不存在，无法验证电话号码';
            RETURN;
        END IF;
        RAISE NOTICE '开始验证电话号码格式';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '电话号码验证准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 验证中国手机号格式（11位数字，以1开头）
SELECT
    id,
    phone,
    CASE
        WHEN phone ~ '^1[3-9]\d{9}$' THEN 'Valid'
        ELSE 'Invalid'
    END AS phone_validation_status,
    CASE
        WHEN phone ~ '^1[3-9]\d{9}$' THEN NULL
        ELSE 'Phone number format is invalid (should be 11 digits starting with 1)'
    END AS validation_error
FROM validation_test
WHERE phone IS NOT NULL
ORDER BY id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    phone
FROM validation_test
WHERE phone ~ '^1[3-9]\d{9}$';
```

---

### 1.4 URL格式验证

**URL格式验证**验证URL地址格式。

```sql
-- URL格式验证
SELECT
    id,
    url,
    CASE
        WHEN url ~* '^https?://([\da-z\.-]+)\.([a-z\.]{2,6})([/\w \.-]*)*/?$' THEN 'Valid'
        ELSE 'Invalid'
    END AS url_validation_status
FROM url_test
WHERE url IS NOT NULL;
```

### 1.5 身份证号验证

**身份证号验证**验证中国身份证号码格式和校验位。

```sql
-- 身份证号验证（18位，包含校验位）
CREATE OR REPLACE FUNCTION validate_id_card(id_card TEXT) RETURNS BOOLEAN AS $$
DECLARE
    weights INTEGER[] := ARRAY[7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2];
    check_codes CHAR[] := ARRAY['1','0','X','9','8','7','6','5','4','3','2'];
    sum_val INTEGER := 0;
    i INTEGER;
BEGIN
    -- 检查长度
    IF LENGTH(id_card) != 18 THEN
        RETURN FALSE;
    END IF;

    -- 检查前17位是否为数字
    IF id_card ~ '^\d{17}' THEN
        -- 计算校验位
        FOR i IN 1..17 LOOP
            sum_val := sum_val + (SUBSTRING(id_card, i, 1)::INTEGER * weights[i]);
        END LOOP;

        -- 验证校验位
        RETURN SUBSTRING(id_card, 18, 1) = check_codes[(sum_val % 11) + 1];
    END IF;

    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

-- 使用函数验证身份证号
SELECT
    id,
    id_card,
    validate_id_card(id_card) AS is_valid
FROM id_card_test;
```

## 2. 范围验证

### 2.1 范围验证原理

**范围验证**检查数据值是否在预定义的有效范围内，包括数值范围、日期范围、字符串长度等。

#### 数值范围验证

**数值范围验证**检查数值是否在最小值和最大值之间：
$$min\_value \leq value \leq max\_value$$

#### 日期范围验证

**日期范围验证**检查日期是否在有效的时间范围内：
$$start\_date \leq date \leq end\_date$$

#### 字符串长度验证

**字符串长度验证**检查字符串长度是否在有效范围内：
$$min\_length \leq LENGTH(string) \leq max\_length$$

### 2.2 数值范围验证实现

```sql
-- 数值范围验证（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'validation_test') THEN
            RAISE WARNING '表 validation_test 不存在，无法验证数值范围';
            RETURN;
        END IF;
        RAISE NOTICE '开始验证数值范围';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '数值范围验证准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 验证年龄范围（18-100）
SELECT
    id,
    age,
    CASE
        WHEN age >= 18 AND age <= 100 THEN 'Valid'
        WHEN age < 18 THEN 'Invalid - Too young'
        WHEN age > 100 THEN 'Invalid - Too old'
        ELSE 'Invalid - NULL or out of range'
    END AS age_validation_status
FROM validation_test
ORDER BY id;

-- 验证分数范围（0-100）
SELECT
    id,
    score,
    CASE
        WHEN score >= 0 AND score <= 100 THEN 'Valid'
        WHEN score < 0 THEN 'Invalid - Negative score'
        WHEN score > 100 THEN 'Invalid - Score exceeds maximum'
        ELSE 'Invalid - NULL'
    END AS score_validation_status
FROM validation_test
ORDER BY id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    age
FROM validation_test
WHERE age >= 18 AND age <= 100;
```

---

### 2.3 日期范围验证

**日期范围验证**检查日期是否在有效范围内。

```sql
-- 日期范围验证
SELECT
    id,
    start_date,
    end_date,
    CASE
        WHEN start_date <= end_date THEN 'Valid'
        ELSE 'Invalid - Start date must be before end date'
    END AS date_range_status,
    CASE
        WHEN start_date > CURRENT_DATE THEN 'Future start date'
        WHEN end_date < CURRENT_DATE THEN 'Past end date'
        ELSE 'Current date range'
    END AS date_status
FROM date_test
WHERE start_date IS NOT NULL AND end_date IS NOT NULL;
```

### 2.4 字符串长度验证

**字符串长度验证**检查字符串长度是否在有效范围内。

```sql
-- 字符串长度验证
SELECT
    id,
    name,
    LENGTH(name) AS name_length,
    CASE
        WHEN LENGTH(name) >= 2 AND LENGTH(name) <= 50 THEN 'Valid'
        WHEN LENGTH(name) < 2 THEN 'Invalid - Too short (minimum 2 characters)'
        WHEN LENGTH(name) > 50 THEN 'Invalid - Too long (maximum 50 characters)'
        ELSE 'Invalid - NULL'
    END AS length_validation_status
FROM name_test
WHERE name IS NOT NULL;
```

## 3. 业务规则验证

### 3.1 业务规则验证原理

**业务规则验证**检查数据是否符合特定的业务逻辑和约束条件，通常涉及多个字段之间的关系。

#### 跨字段验证

**跨字段验证**检查多个字段之间的关系：

- 订单金额必须大于0
- 结束日期必须晚于开始日期
- 折扣金额不能超过原价

#### 条件验证

**条件验证**根据某个条件检查其他字段：

- 如果订单类型是"退货"，则必须填写退货原因
- 如果用户是VIP，则折扣率可以更高

#### 聚合验证

**聚合验证**检查聚合结果是否符合规则：

- 订单总金额必须等于各商品金额之和
- 库存数量不能为负数

### 3.2 自定义规则验证实现

```sql
-- 自定义规则验证（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'validation_test') THEN
            RAISE WARNING '表 validation_test 不存在，无法进行自定义规则验证';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行自定义规则验证';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '自定义规则验证准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 综合验证：所有字段必须通过验证
WITH validation_results AS (
    SELECT
        id,
        email,
        phone,
        age,
        score,
        CASE
            WHEN email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN TRUE
            ELSE FALSE
        END AS email_valid,
        CASE
            WHEN phone ~ '^1[3-9]\d{9}$' THEN TRUE
            ELSE FALSE
        END AS phone_valid,
        CASE
            WHEN age >= 18 AND age <= 100 THEN TRUE
            ELSE FALSE
        END AS age_valid,
        CASE
            WHEN score >= 0 AND score <= 100 THEN TRUE
            ELSE FALSE
        END AS score_valid
    FROM validation_test
)
SELECT
    id,
    email,
    phone,
    age,
    score,
    email_valid,
    phone_valid,
    age_valid,
    score_valid,
    CASE
        WHEN email_valid AND phone_valid AND age_valid AND score_valid THEN 'All Valid'
        ELSE 'Has Invalid Fields'
    END AS overall_status,
    ARRAY_REMOVE(ARRAY[
        CASE WHEN NOT email_valid THEN 'email' END,
        CASE WHEN NOT phone_valid THEN 'phone' END,
        CASE WHEN NOT age_valid THEN 'age' END,
        CASE WHEN NOT score_valid THEN 'score' END
    ], NULL) AS invalid_fields
FROM validation_results
ORDER BY id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) FILTER (WHERE email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') AS valid_emails
FROM validation_test;
```

---

### 3.3 引用完整性验证

**引用完整性验证**检查外键引用是否有效。

```sql
-- 引用完整性验证：检查订单是否关联有效的客户
SELECT
    o.order_id,
    o.customer_id,
    CASE
        WHEN c.customer_id IS NOT NULL THEN 'Valid'
        ELSE 'Invalid - Customer does not exist'
    END AS referential_integrity_status
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE o.customer_id IS NOT NULL;
```

### 3.4 唯一性验证

**唯一性验证**检查数据是否唯一。

```sql
-- 唯一性验证：检查邮箱是否重复
WITH email_counts AS (
    SELECT
        email,
        COUNT(*) AS email_count
    FROM users
    WHERE email IS NOT NULL
    GROUP BY email
)
SELECT
    u.user_id,
    u.email,
    CASE
        WHEN ec.email_count = 1 THEN 'Unique'
        ELSE 'Duplicate'
    END AS uniqueness_status
FROM users u
LEFT JOIN email_counts ec ON u.email = ec.email
WHERE u.email IS NOT NULL;
```

## 4. 实际应用案例

### 4.1 综合数据验证

**综合数据验证**整合多种验证方法，生成完整的验证报告。

```sql
-- 综合数据验证示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'validation_test') THEN
            RAISE WARNING '表 validation_test 不存在，无法进行综合数据验证';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行综合数据验证';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '综合数据验证准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 生成数据验证报告
WITH validation_summary AS (
    SELECT
        COUNT(*) AS total_records,
        COUNT(*) FILTER (WHERE email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') AS valid_emails,
        COUNT(*) FILTER (WHERE phone ~ '^1[3-9]\d{9}$') AS valid_phones,
        COUNT(*) FILTER (WHERE age >= 18 AND age <= 100) AS valid_ages,
        COUNT(*) FILTER (WHERE score >= 0 AND score <= 100) AS valid_scores,
        COUNT(*) FILTER (WHERE
            email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
            AND phone ~ '^1[3-9]\d{9}$'
            AND age >= 18 AND age <= 100
            AND score >= 0 AND score <= 100
        ) AS fully_valid_records
    FROM validation_test
)
SELECT
    total_records,
    valid_emails,
    ROUND((valid_emails::numeric / total_records * 100)::numeric, 2) AS email_validity_pct,
    valid_phones,
    ROUND((valid_phones::numeric / total_records * 100)::numeric, 2) AS phone_validity_pct,
    valid_ages,
    ROUND((valid_ages::numeric / total_records * 100)::numeric, 2) AS age_validity_pct,
    valid_scores,
    ROUND((valid_scores::numeric / total_records * 100)::numeric, 2) AS score_validity_pct,
    fully_valid_records,
    ROUND((fully_valid_records::numeric / total_records * 100)::numeric, 2) AS overall_validity_pct,
    CASE
        WHEN fully_valid_records::numeric / total_records >= 0.95 THEN 'Excellent'
        WHEN fully_valid_records::numeric / total_records >= 0.80 THEN 'Good'
        WHEN fully_valid_records::numeric / total_records >= 0.60 THEN 'Fair'
        ELSE 'Poor'
    END AS data_quality_rating
FROM validation_summary;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) FILTER (WHERE email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') AS valid_count
FROM validation_test;
```

---

### 4.2 用户注册数据验证

**场景**：验证用户注册时的数据质量。

```sql
-- 用户注册数据验证：综合验证所有字段
WITH user_validation AS (
    SELECT
        user_id,
        username,
        email,
        phone,
        birth_date,
        -- 格式验证
        CASE WHEN username ~ '^[a-zA-Z0-9_]{3,20}$' THEN TRUE ELSE FALSE END AS username_valid,
        CASE WHEN email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN TRUE ELSE FALSE END AS email_valid,
        CASE WHEN phone ~ '^1[3-9]\d{9}$' THEN TRUE ELSE FALSE END AS phone_valid,
        -- 范围验证
        CASE WHEN birth_date >= '1900-01-01' AND birth_date <= CURRENT_DATE THEN TRUE ELSE FALSE END AS birth_date_valid,
        -- 业务规则验证
        CASE WHEN LENGTH(username) >= 3 AND LENGTH(username) <= 20 THEN TRUE ELSE FALSE END AS username_length_valid
    FROM user_registration
)
SELECT
    user_id,
    username,
    email,
    phone,
    birth_date,
    username_valid,
    email_valid,
    phone_valid,
    birth_date_valid,
    username_length_valid,
    CASE
        WHEN username_valid AND email_valid AND phone_valid AND birth_date_valid AND username_length_valid THEN 'All Valid'
        ELSE 'Has Invalid Fields'
    END AS overall_status,
    ARRAY_REMOVE(ARRAY[
        CASE WHEN NOT username_valid THEN 'username' END,
        CASE WHEN NOT email_valid THEN 'email' END,
        CASE WHEN NOT phone_valid THEN 'phone' END,
        CASE WHEN NOT birth_date_valid THEN 'birth_date' END,
        CASE WHEN NOT username_length_valid THEN 'username_length' END
    ], NULL) AS invalid_fields
FROM user_validation
ORDER BY user_id;
```

### 4.3 订单数据验证

**场景**：验证订单数据的完整性和正确性。

```sql
-- 订单数据验证：验证订单业务规则
WITH order_validation AS (
    SELECT
        o.order_id,
        o.customer_id,
        o.order_date,
        o.total_amount,
        o.discount_amount,
        oi.item_count,
        oi.items_total,
        -- 业务规则验证
        CASE WHEN o.total_amount > 0 THEN TRUE ELSE FALSE END AS amount_valid,
        CASE WHEN o.discount_amount <= o.total_amount THEN TRUE ELSE FALSE END AS discount_valid,
        CASE WHEN o.total_amount = oi.items_total THEN TRUE ELSE FALSE END AS amount_match_valid,
        CASE WHEN c.customer_id IS NOT NULL THEN TRUE ELSE FALSE END AS customer_valid,
        CASE WHEN o.order_date <= CURRENT_DATE THEN TRUE ELSE FALSE END AS date_valid
    FROM orders o
    LEFT JOIN customers c ON o.customer_id = c.customer_id
    LEFT JOIN (
        SELECT
            order_id,
            COUNT(*) AS item_count,
            SUM(quantity * price) AS items_total
        FROM order_items
        GROUP BY order_id
    ) oi ON o.order_id = oi.order_id
)
SELECT
    order_id,
    customer_id,
    order_date,
    total_amount,
    discount_amount,
    amount_valid,
    discount_valid,
    amount_match_valid,
    customer_valid,
    date_valid,
    CASE
        WHEN amount_valid AND discount_valid AND amount_match_valid AND customer_valid AND date_valid THEN 'Valid'
        ELSE 'Invalid'
    END AS validation_status
FROM order_validation
ORDER BY order_id;
```

### 4.4 数据质量监控

**场景**：持续监控数据质量，生成质量报告。

```sql
-- 数据质量监控：生成质量报告
WITH quality_metrics AS (
    SELECT
        'users' AS table_name,
        COUNT(*) AS total_records,
        COUNT(*) FILTER (WHERE email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') AS valid_emails,
        COUNT(*) FILTER (WHERE phone ~ '^1[3-9]\d{9}$') AS valid_phones,
        COUNT(*) FILTER (WHERE created_at <= CURRENT_DATE) AS valid_dates,
        COUNT(DISTINCT email) AS unique_emails
    FROM users
    UNION ALL
    SELECT
        'orders' AS table_name,
        COUNT(*) AS total_records,
        COUNT(*) FILTER (WHERE total_amount > 0) AS valid_amounts,
        COUNT(*) FILTER (WHERE order_date <= CURRENT_DATE) AS valid_dates,
        COUNT(*) FILTER (WHERE customer_id IS NOT NULL) AS valid_customers,
        NULL::BIGINT AS unique_emails
    FROM orders
)
SELECT
    table_name,
    total_records,
    valid_emails,
    ROUND((valid_emails::numeric / NULLIF(total_records, 0) * 100)::numeric, 2) AS email_quality_pct,
    valid_phones,
    ROUND((valid_phones::numeric / NULLIF(total_records, 0) * 100)::numeric, 2) AS phone_quality_pct,
    valid_dates,
    ROUND((valid_dates::numeric / NULLIF(total_records, 0) * 100)::numeric, 2) AS date_quality_pct,
    CASE
        WHEN (valid_emails::numeric / NULLIF(total_records, 0) >= 0.95
              AND valid_phones::numeric / NULLIF(total_records, 0) >= 0.95) THEN 'Excellent'
        WHEN (valid_emails::numeric / NULLIF(total_records, 0) >= 0.80
              AND valid_phones::numeric / NULLIF(total_records, 0) >= 0.80) THEN 'Good'
        ELSE 'Needs Improvement'
    END AS quality_rating
FROM quality_metrics;
```

### 4.5 实时数据验证

**场景**：在数据插入时进行实时验证。

```sql
-- 实时数据验证：使用触发器进行验证
CREATE OR REPLACE FUNCTION validate_user_data() RETURNS TRIGGER AS $$
BEGIN
    -- 验证邮箱格式
    IF NEW.email IS NOT NULL AND
       NEW.email !~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION 'Invalid email format: %', NEW.email;
    END IF;

    -- 验证电话号码格式
    IF NEW.phone IS NOT NULL AND
       NEW.phone !~ '^1[3-9]\d{9}$' THEN
        RAISE EXCEPTION 'Invalid phone format: %', NEW.phone;
    END IF;

    -- 验证用户名长度
    IF LENGTH(NEW.username) < 3 OR LENGTH(NEW.username) > 20 THEN
        RAISE EXCEPTION 'Username length must be between 3 and 20 characters';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER user_validation_trigger
BEFORE INSERT OR UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION validate_user_data();
```

---

## 5. 算法性能对比与优化

### 5.1 验证方法对比

| 验证方法 | 性能 | 准确性 | 适用场景 | 实现复杂度 |
|---------|------|--------|---------|-----------|
| **正则表达式** | 中 | 高 | 格式验证 | 中 |
| **数值比较** | 快 | 高 | 范围验证 | 低 |
| **外键检查** | 慢 | 高 | 引用完整性 | 中 |
| **唯一性检查** | 中 | 高 | 唯一性验证 | 中 |
| **触发器验证** | 中 | 高 | 实时验证 | 高 |

### 5.2 性能优化建议

1. **索引优化**：
   - 在验证字段上创建索引
   - 使用覆盖索引减少回表
   - 为外键创建索引

2. **约束使用**：
   - 使用CHECK约束进行简单验证
   - 使用UNIQUE约束确保唯一性
   - 使用FOREIGN KEY确保引用完整性

3. **函数优化**：
   - 创建验证函数提高复用性
   - 使用IMMUTABLE函数优化性能
   - 避免在函数中进行复杂计算

4. **批量验证**：
   - 使用批量验证减少数据库访问
   - 使用物化视图缓存验证结果
   - 并行处理大量数据

### 5.3 常见问题与解决方案

**问题1**：正则表达式性能慢

- **解决方案**：优化正则表达式、使用索引、考虑使用CHECK约束

**问题2**：验证规则复杂

- **解决方案**：创建验证函数、使用触发器、模块化设计

**问题3**：实时验证影响性能

- **解决方案**：异步验证、批量验证、使用物化视图

**问题4**：验证错误信息不清晰

- **解决方案**：提供详细的错误信息、使用错误码、记录验证日志

---

## 6. 最佳实践

### 6.1 验证策略

1. **多层验证**：
   - 前端验证：用户输入时验证
   - 应用层验证：业务逻辑验证
   - 数据库层验证：约束和触发器验证

2. **验证时机**：
   - 实时验证：数据输入时
   - 批量验证：数据导入时
   - 定期验证：数据维护时

3. **验证粒度**：
   - 字段级验证：单个字段
   - 记录级验证：整条记录
   - 表级验证：整个表

### 6.2 验证规则设计

1. **规则明确**：
   - 定义清晰的验证规则
   - 文档化所有规则
   - 提供示例和反例

2. **规则可维护**：
   - 集中管理验证规则
   - 使用配置表存储规则
   - 支持规则动态更新

3. **规则可扩展**：
   - 支持自定义规则
   - 支持规则组合
   - 支持规则优先级

### 6.3 错误处理

1. **错误信息**：
   - 提供清晰的错误信息
   - 指出具体的验证失败原因
   - 提供修复建议

2. **错误记录**：
   - 记录所有验证错误
   - 生成验证报告
   - 跟踪错误趋势

3. **错误恢复**：
   - 支持数据修复
   - 提供修复工具
   - 验证修复结果

### 6.4 SQL实现注意事项

1. **性能考虑**：
   - 优化正则表达式
   - 使用索引加速验证
   - 避免全表扫描

2. **可维护性**：
   - 使用函数封装验证逻辑
   - 清晰的代码注释
   - 模块化设计

3. **错误处理**：
   - 使用异常处理
   - 提供详细错误信息
   - 记录验证日志

---

## 📚 参考资源

### 学术文献

1. **《数据质量：概念、技术与实践》**（Batini et al., 2009）- 数据验证和质量保证

2. **《数据库系统概念》**（Silberschatz et al., 2019）- 第6章 完整性约束

3. **PostgreSQL官方文档** - 约束、触发器、函数

### PostgreSQL官方文档

- **约束**: <https://www.postgresql.org/docs/current/ddl-constraints.html>
- **触发器**: <https://www.postgresql.org/docs/current/triggers.html>
- **正则表达式**: <https://www.postgresql.org/docs/current/functions-matching.html>
- **CHECK约束**: <https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS>

### 在线资源

- **数据验证**: <https://en.wikipedia.org/wiki/Data_validation>
- **正则表达式**: <https://www.regular-expressions.info/>
- **数据质量**: <https://www.postgresql.org/docs/current/performance-tips.html>

### 相关算法

- **数据清洗算法**：数据验证的前置步骤
- **数据完整性检查**：完整性验证
- **数据标准化算法**：格式标准化
- **数据质量算法**：质量保证

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
