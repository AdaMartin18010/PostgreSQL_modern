# PostgreSQL 数据完整性检查完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数据完整性 | 约束检查
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 数据完整性检查完整指南](#postgresql-数据完整性检查完整指南)
  - [📋 目录](#-目录)
  - [数据完整性概述](#数据完整性概述)
    - [理论基础](#理论基础)
      - [数据完整性类型](#数据完整性类型)
      - [完整性约束](#完整性约束)
      - [完整性检查方法](#完整性检查方法)
    - [核心检查项](#核心检查项)
  - [1. 外键完整性](#1-外键完整性)
    - [1.1 外键完整性原理](#11-外键完整性原理)
      - [外键约束](#外键约束)
      - [外键完整性检查](#外键完整性检查)
    - [1.2 外键约束检查实现](#12-外键约束检查实现)
  - [2. 引用完整性](#2-引用完整性)
    - [2.1 引用完整性原理](#21-引用完整性原理)
      - [孤立记录](#孤立记录)
      - [循环引用](#循环引用)
    - [2.2 孤立记录检测实现](#22-孤立记录检测实现)
  - [3. 数据一致性](#3-数据一致性)
    - [3.1 数据一致性原理](#31-数据一致性原理)
      - [一致性类型](#一致性类型)
    - [3.2 数据一致性检查实现](#32-数据一致性检查实现)
  - [4. 实体完整性检查](#4-实体完整性检查)
    - [4.1 实体完整性原理](#41-实体完整性原理)
      - [主键完整性](#主键完整性)
      - [唯一性检查](#唯一性检查)
    - [4.2 主键完整性检查实现](#42-主键完整性检查实现)
    - [4.3 唯一约束检查实现](#43-唯一约束检查实现)
  - [6. 实际应用案例](#6-实际应用案例)
    - [5.1 综合完整性检查](#51-综合完整性检查)
    - [5.2 多表完整性检查](#52-多表完整性检查)
    - [5.3 完整性修复建议](#53-完整性修复建议)
    - [5.4 完整性监控自动化](#54-完整性监控自动化)
    - [5.5 完整性约束管理](#55-完整性约束管理)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [6.1 完整性检查方法对比](#61-完整性检查方法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [7.1 约束设计](#71-约束设计)
    - [7.2 完整性检查](#72-完整性检查)
    - [7.3 问题修复](#73-问题修复)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 数据完整性概述

**数据完整性（Data Integrity）**是数据库系统的重要特性，确保数据的准确性、一致性和可靠性。数据完整性包括实体完整性、参照完整性、域完整性和用户定义的完整性。

### 理论基础

#### 数据完整性类型

1. **实体完整性（Entity Integrity）**：
   - 主键约束：确保每行都有唯一标识
   - 非空约束：确保必需字段不为空
   - 唯一约束：确保字段值唯一

2. **参照完整性（Referential Integrity）**：
   - 外键约束：确保外键值引用有效的主键
   - 防止孤立记录：子表中的记录必须有对应的父表记录
   - 级联操作：DELETE/UPDATE的级联行为

3. **域完整性（Domain Integrity）**：
   - CHECK约束：确保字段值在有效范围内
   - 数据类型：确保数据类型正确
   - 默认值：提供合理的默认值

4. **用户定义的完整性（User-defined Integrity）**：
   - 业务规则：自定义的业务逻辑约束
   - 触发器：复杂的数据完整性规则
   - 存储过程：数据完整性验证逻辑

#### 完整性约束

**约束类型**：

- **PRIMARY KEY**：主键约束
- **FOREIGN KEY**：外键约束
- **UNIQUE**：唯一约束
- **NOT NULL**：非空约束
- **CHECK**：检查约束
- **DEFAULT**：默认值约束

#### 完整性检查方法

1. **约束检查**：使用数据库约束自动检查
2. **查询检查**：使用SQL查询手动检查
3. **触发器检查**：使用触发器实时检查
4. **存储过程检查**：使用存储过程批量检查

### 核心检查项

| 检查项 | 用途 | 时间复杂度 | 空间复杂度 | 检查方法 |
|--------|------|-----------|-----------|---------|
| **外键完整性** | 检查外键约束 | $O(n)$ | $O(1)$ | 外键约束、JOIN查询 |
| **引用完整性** | 检查孤立记录 | $O(n \log n)$ | $O(n)$ | LEFT JOIN、NOT EXISTS |
| **数据一致性** | 检查数据一致性 | $O(n)$ | $O(1)$ | 聚合函数、比较查询 |
| **实体完整性** | 检查主键唯一性 | $O(n \log n)$ | $O(n)$ | 唯一约束、GROUP BY |
| **域完整性** | 检查值域约束 | $O(n)$ | $O(1)$ | CHECK约束、WHERE条件 |

---

## 1. 外键完整性

### 1.1 外键完整性原理

**外键完整性（Foreign Key Integrity）**确保子表中的外键值必须引用父表中存在的主键值，维护表之间的引用关系。

#### 外键约束

**外键约束**定义：

```sql
FOREIGN KEY (child_column) REFERENCES parent_table(parent_column)
[ON DELETE action] [ON UPDATE action]
```

**级联操作**：

- **CASCADE**：级联删除/更新
- **SET NULL**：设置为NULL
- **SET DEFAULT**：设置为默认值
- **RESTRICT**：禁止删除/更新（默认）
- **NO ACTION**：不执行任何操作

#### 外键完整性检查

**检查方法**：

1. **约束检查**：数据库自动检查（推荐）
2. **查询检查**：手动查询验证
3. **触发器检查**：实时检查

### 1.2 外键约束检查实现

```sql
-- 创建测试表结构（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 已存在，先删除';
            DROP TABLE orders CASCADE;
        END IF;

        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'customers') THEN
            RAISE WARNING '表 customers 已存在，先删除';
            DROP TABLE customers CASCADE;
        END IF;

        CREATE TABLE customers (
            customer_id SERIAL PRIMARY KEY,
            customer_name VARCHAR(100) NOT NULL,
            email VARCHAR(100) UNIQUE
        );

        CREATE TABLE orders (
            order_id SERIAL PRIMARY KEY,
            customer_id INTEGER NOT NULL,
            order_date DATE NOT NULL,
            total_amount NUMERIC(10, 2),
            FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        );

        INSERT INTO customers (customer_name, email) VALUES
            ('John Doe', 'john@example.com'),
            ('Jane Smith', 'jane@example.com'),
            ('Bob Wilson', 'bob@example.com');

        INSERT INTO orders (customer_id, order_date, total_amount) VALUES
            (1, '2024-01-01', 100.50),
            (1, '2024-01-02', 200.75),
            (2, '2024-01-03', 150.00),
            (3, '2024-01-04', 300.25);

        RAISE NOTICE '表 customers 和 orders 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 检查外键完整性（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法检查外键完整性';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查外键完整性';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '外键完整性检查准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 检查外键约束
SELECT
    tc.constraint_name,
    tc.table_name,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
    AND ccu.table_schema = tc.table_schema
WHERE tc.constraint_type = 'FOREIGN KEY'
    AND tc.table_name = 'orders'
ORDER BY tc.constraint_name;

-- 检查违反外键约束的记录（如果有的话，先插入一条无效记录测试）
DO $$
BEGIN
    BEGIN
        -- 临时禁用外键约束检查（仅用于演示）
        INSERT INTO orders (customer_id, order_date, total_amount) VALUES
            (999, '2024-01-05', 500.00);
    EXCEPTION
        WHEN foreign_key_violation THEN
            RAISE NOTICE '外键约束正常工作：无法插入无效的customer_id';
        WHEN OTHERS THEN
            RAISE WARNING '插入测试记录失败: %', SQLERRM;
    END;
END $$;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    o.order_id,
    o.customer_id,
    c.customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id;
```

---

## 2. 引用完整性

### 2.1 引用完整性原理

**引用完整性（Referential Integrity）**确保数据库中的引用关系是有效的，防止出现孤立记录（Orphan Records）和循环引用。

#### 孤立记录

**孤立记录**是指子表中存在外键值，但父表中没有对应主键值的记录。

**产生原因**：

- 父记录被删除，但子记录未删除
- 数据导入时未检查引用关系
- 约束被临时禁用

#### 循环引用

**循环引用**是指表之间存在循环的引用关系，可能导致数据不一致。

**检测方法**：

- 使用递归查询检测循环
- 使用图算法检测环

### 2.2 孤立记录检测实现

```sql
-- 孤立记录检测（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法检测孤立记录';
            RETURN;
        END IF;
        RAISE NOTICE '开始检测孤立记录';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '孤立记录检测准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 检测orders表中的孤立记录（没有对应customer的记录）
SELECT
    o.order_id,
    o.customer_id,
    o.order_date,
    o.total_amount,
    'Orphaned record: customer_id does not exist in customers table' AS issue_description
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id IS NULL;

-- 统计孤立记录数量
SELECT
    COUNT(*) AS orphaned_records_count,
    'orders' AS table_name,
    'customer_id' AS foreign_key_column
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id IS NULL;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    o.order_id,
    o.customer_id
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id IS NULL;
```

---

## 3. 数据一致性

### 3.1 数据一致性原理

**数据一致性（Data Consistency）**确保数据库中的数据在逻辑上是一致的，包括跨表一致性、聚合一致性和业务规则一致性。

#### 一致性类型

1. **跨表一致性**：
   - 订单总金额 = 订单项金额之和
   - 账户余额 = 交易金额之和

2. **聚合一致性**：
   - 汇总数据 = 明细数据之和
   - 统计结果 = 实际数据

3. **业务规则一致性**：
   - 订单状态转换符合业务规则
   - 数据值符合业务逻辑

### 3.2 数据一致性检查实现

```sql
-- 创建订单明细表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING '表 order_items 已存在，先删除';
            DROP TABLE order_items CASCADE;
        END IF;

        CREATE TABLE order_items (
            item_id SERIAL PRIMARY KEY,
            order_id INTEGER NOT NULL,
            product_name VARCHAR(100) NOT NULL,
            quantity INTEGER NOT NULL,
            unit_price NUMERIC(10, 2) NOT NULL,
            FOREIGN KEY (order_id) REFERENCES orders(order_id)
        );

        INSERT INTO order_items (order_id, product_name, quantity, unit_price) VALUES
            (1, 'Product A', 2, 50.25),
            (1, 'Product B', 1, 100.00),
            (2, 'Product C', 3, 66.92),
            (3, 'Product A', 1, 50.25),
            (3, 'Product D', 2, 75.00);

        RAISE NOTICE '表 order_items 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 order_items 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 数据一致性检查：订单总额与明细总额是否一致（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'order_items') THEN
            RAISE WARNING '表 order_items 不存在，无法进行数据一致性检查';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行数据一致性检查';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '数据一致性检查准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 检查订单总额与明细总额的一致性
WITH order_totals AS (
    SELECT
        o.order_id,
        o.total_amount AS order_total,
        COALESCE(SUM(oi.quantity * oi.unit_price), 0) AS calculated_total
    FROM orders o
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY o.order_id, o.total_amount
)
SELECT
    order_id,
    ROUND(order_total::numeric, 2) AS order_total,
    ROUND(calculated_total::numeric, 2) AS calculated_total,
    ROUND(ABS(order_total - calculated_total)::numeric, 2) AS difference,
    CASE
        WHEN ABS(order_total - calculated_total) < 0.01 THEN 'Consistent'
        ELSE 'Inconsistent'
    END AS consistency_status
FROM order_totals
ORDER BY ABS(order_total - calculated_total) DESC;

-- 检查订单是否有明细项
SELECT
    o.order_id,
    o.order_date,
    o.total_amount,
    COUNT(oi.item_id) AS item_count,
    CASE
        WHEN COUNT(oi.item_id) = 0 THEN 'No items - Data inconsistency'
        ELSE 'Has items'
    END AS consistency_status
FROM orders o
LEFT JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id, o.order_date, o.total_amount
ORDER BY item_count, o.order_id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    o.order_id,
    SUM(oi.quantity * oi.unit_price) AS calculated_total
FROM orders o
LEFT JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id;
```

---

## 4. 实体完整性检查

### 4.1 实体完整性原理

**实体完整性（Entity Integrity）**确保每个实体（表）都有唯一标识，主要通过主键约束实现。

#### 主键完整性

**主键约束**：

- 唯一性：主键值必须唯一
- 非空性：主键值不能为NULL
- 不可变性：主键值不应更改

#### 唯一性检查

**唯一性检查**验证字段值是否唯一，包括主键和唯一约束。

### 4.2 主键完整性检查实现

```sql
-- 主键完整性检查：检测重复主键
WITH duplicate_keys AS (
    SELECT
        customer_id,
        COUNT(*) AS duplicate_count
    FROM customers
    GROUP BY customer_id
    HAVING COUNT(*) > 1
)
SELECT
    customer_id,
    duplicate_count,
    'Duplicate primary key' AS issue_type
FROM duplicate_keys;

-- 检查NULL主键
SELECT
    COUNT(*) AS null_key_count,
    'NULL primary key' AS issue_type
FROM customers
WHERE customer_id IS NULL;
```

### 4.3 唯一约束检查实现

```sql
-- 唯一约束检查：检测重复邮箱
WITH duplicate_emails AS (
    SELECT
        email,
        COUNT(*) AS duplicate_count,
        ARRAY_AGG(customer_id) AS customer_ids
    FROM customers
    WHERE email IS NOT NULL
    GROUP BY email
    HAVING COUNT(*) > 1
)
SELECT
    email,
    duplicate_count,
    customer_ids,
    'Duplicate email' AS issue_type
FROM duplicate_emails;
```

## 6. 实际应用案例

### 5.1 综合完整性检查

**综合完整性检查**整合多种完整性检查方法，生成完整的完整性报告。

```sql
-- 综合完整性检查示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'orders') THEN
            RAISE WARNING '表 orders 不存在，无法进行综合完整性检查';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行综合完整性检查';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '综合完整性检查准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 生成完整性检查报告
WITH integrity_checks AS (
    SELECT
        'Foreign Key Integrity' AS check_type,
        COUNT(*) AS issue_count,
        'Orders with invalid customer_id' AS description
    FROM orders o
    LEFT JOIN customers c ON o.customer_id = c.customer_id
    WHERE c.customer_id IS NULL

    UNION ALL

    SELECT
        'Data Consistency' AS check_type,
        COUNT(*) AS issue_count,
        'Orders with total_amount mismatch' AS description
    FROM (
        SELECT o.order_id
        FROM orders o
        LEFT JOIN (
            SELECT order_id, SUM(quantity * unit_price) AS calculated_total
            FROM order_items
            GROUP BY order_id
        ) oi ON o.order_id = oi.order_id
        WHERE ABS(o.total_amount - COALESCE(oi.calculated_total, 0)) > 0.01
    ) inconsistent_orders

    UNION ALL

    SELECT
        'Referential Integrity' AS check_type,
        COUNT(*) AS issue_count,
        'Orders without items' AS description
    FROM orders o
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    WHERE oi.item_id IS NULL
)
SELECT
    check_type,
    issue_count,
    description,
    CASE
        WHEN issue_count = 0 THEN 'Pass'
        ELSE 'Fail'
    END AS check_status
FROM integrity_checks
ORDER BY issue_count DESC, check_type;

-- 详细完整性报告
WITH detailed_report AS (
    SELECT
        o.order_id,
        o.customer_id,
        o.order_date,
        o.total_amount,
        CASE WHEN c.customer_id IS NULL THEN 'Missing customer' ELSE 'OK' END AS customer_status,
        COUNT(oi.item_id) AS item_count,
        COALESCE(SUM(oi.quantity * oi.unit_price), 0) AS calculated_total,
        CASE
            WHEN COUNT(oi.item_id) = 0 THEN 'No items'
            WHEN ABS(o.total_amount - COALESCE(SUM(oi.quantity * oi.unit_price), 0)) > 0.01 THEN 'Amount mismatch'
            ELSE 'OK'
        END AS consistency_status
    FROM orders o
    LEFT JOIN customers c ON o.customer_id = c.customer_id
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY o.order_id, o.customer_id, o.order_date, o.total_amount, c.customer_id
)
SELECT
    order_id,
    customer_id,
    order_date,
    ROUND(total_amount::numeric, 2) AS total_amount,
    item_count,
    ROUND(calculated_total::numeric, 2) AS calculated_total,
    customer_status,
    consistency_status,
    CASE
        WHEN customer_status = 'OK' AND consistency_status = 'OK' THEN 'All checks passed'
        ELSE 'Issues found'
    END AS overall_status
FROM detailed_report
ORDER BY overall_status, order_id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    o.order_id,
    c.customer_id IS NOT NULL AS has_customer,
    COUNT(oi.item_id) AS item_count
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id, c.customer_id;
```

### 5.2 多表完整性检查

**场景**：检查多个相关表的完整性。

```sql
-- 多表完整性检查：检查整个数据库的完整性
WITH integrity_report AS (
    -- 外键完整性
    SELECT
        'Foreign Key Integrity' AS check_category,
        'orders.customer_id' AS check_item,
        COUNT(*) AS issue_count,
        'Orphaned orders' AS description
    FROM orders o
    LEFT JOIN customers c ON o.customer_id = c.customer_id
    WHERE c.customer_id IS NULL

    UNION ALL

    SELECT
        'Foreign Key Integrity',
        'order_items.order_id',
        COUNT(*),
        'Orphaned order items'
    FROM order_items oi
    LEFT JOIN orders o ON oi.order_id = o.order_id
    WHERE o.order_id IS NULL

    UNION ALL

    -- 数据一致性
    SELECT
        'Data Consistency',
        'orders.total_amount',
        COUNT(*),
        'Amount mismatch'
    FROM orders o
    LEFT JOIN (
        SELECT order_id, SUM(quantity * unit_price) AS calculated_total
        FROM order_items
        GROUP BY order_id
    ) oi ON o.order_id = oi.order_id
    WHERE ABS(o.total_amount - COALESCE(oi.calculated_total, 0)) > 0.01

    UNION ALL

    -- 实体完整性
    SELECT
        'Entity Integrity',
        'customers.email',
        COUNT(*),
        'Duplicate emails'
    FROM (
        SELECT email
        FROM customers
        WHERE email IS NOT NULL
        GROUP BY email
        HAVING COUNT(*) > 1
    ) duplicates
)
SELECT
    check_category,
    check_item,
    issue_count,
    description,
    CASE
        WHEN issue_count = 0 THEN 'Pass'
        WHEN issue_count < 10 THEN 'Warning'
        ELSE 'Fail'
    END AS severity
FROM integrity_report
ORDER BY issue_count DESC, check_category;
```

### 5.3 完整性修复建议

**场景**：生成完整性问题的修复建议。

```sql
-- 完整性修复建议：生成修复SQL语句
WITH orphaned_orders AS (
    SELECT
        o.order_id,
        o.customer_id,
        'DELETE FROM orders WHERE order_id = ' || o.order_id || ';' AS delete_sql,
        'UPDATE orders SET customer_id = NULL WHERE order_id = ' || o.order_id || ';' AS nullify_sql,
        'Orphaned order' AS issue_type
    FROM orders o
    LEFT JOIN customers c ON o.customer_id = c.customer_id
    WHERE c.customer_id IS NULL
    LIMIT 10
)
SELECT
    order_id,
    customer_id,
    issue_type,
    delete_sql AS recommended_action,
    'Delete orphaned record' AS action_description
FROM orphaned_orders
ORDER BY order_id;
```

### 5.4 完整性监控自动化

**场景**：自动化完整性监控和报告。

```sql
-- 完整性监控自动化：创建监控表
CREATE TABLE IF NOT EXISTS integrity_monitoring (
    check_id SERIAL PRIMARY KEY,
    check_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    check_type VARCHAR(50) NOT NULL,
    table_name VARCHAR(100) NOT NULL,
    issue_count INTEGER NOT NULL,
    check_status VARCHAR(20) NOT NULL,
    details JSONB
);

-- 插入监控结果
INSERT INTO integrity_monitoring (check_type, table_name, issue_count, check_status, details)
SELECT
    'Foreign Key Integrity' AS check_type,
    'orders' AS table_name,
    COUNT(*) AS issue_count,
    CASE WHEN COUNT(*) = 0 THEN 'Pass' ELSE 'Fail' END AS check_status,
    jsonb_build_object(
        'orphaned_records', COUNT(*),
        'sample_ids', ARRAY_AGG(o.order_id) FILTER (WHERE o.order_id IS NOT NULL)
    ) AS details
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id IS NULL;

-- 查询最近的监控结果
SELECT
    check_date,
    check_type,
    table_name,
    issue_count,
    check_status,
    details
FROM integrity_monitoring
ORDER BY check_date DESC
LIMIT 20;
```

### 5.5 完整性约束管理

**场景**：管理和检查数据库中的完整性约束。

```sql
-- 完整性约束管理：列出所有约束
SELECT
    tc.table_schema,
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    kcu.column_name,
    ccu.table_name AS referenced_table,
    ccu.column_name AS referenced_column,
    rc.update_rule,
    rc.delete_rule
FROM information_schema.table_constraints tc
LEFT JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
LEFT JOIN information_schema.constraint_column_usage ccu
    ON tc.constraint_name = ccu.constraint_name
    AND tc.table_schema = ccu.table_schema
LEFT JOIN information_schema.referential_constraints rc
    ON tc.constraint_name = rc.constraint_name
    AND tc.table_schema = rc.constraint_schema
WHERE tc.table_schema = 'public'
    AND tc.constraint_type IN ('PRIMARY KEY', 'FOREIGN KEY', 'UNIQUE', 'CHECK')
ORDER BY tc.table_name, tc.constraint_type;
```

---

## 7. 算法性能对比与优化

### 6.1 完整性检查方法对比

| 检查方法 | 性能 | 准确性 | 实时性 | 适用场景 |
|---------|------|--------|--------|---------|
| **约束检查** | 快 | 高 | 实时 | 数据插入/更新时 |
| **查询检查** | 中 | 高 | 批量 | 定期检查 |
| **触发器检查** | 中 | 高 | 实时 | 复杂业务规则 |
| **存储过程检查** | 慢 | 高 | 批量 | 综合检查 |

### 6.2 性能优化建议

1. **索引优化**：
   - 在外键列上创建索引
   - 在主键列上创建索引
   - 使用覆盖索引

2. **约束使用**：
   - 使用数据库约束自动检查
   - 避免应用层重复检查
   - 合理使用级联操作

3. **批量检查**：
   - 使用批量查询减少数据库访问
   - 使用物化视图缓存结果
   - 并行处理大量数据

4. **检查策略**：
   - 实时检查：使用约束和触发器
   - 定期检查：使用定时任务
   - 按需检查：使用存储过程

### 6.3 常见问题与解决方案

**问题1**：外键约束影响性能

- **解决方案**：创建索引、优化查询、考虑延迟约束检查

**问题2**：孤立记录难以修复

- **解决方案**：使用级联删除、数据迁移、手动修复

**问题3**：完整性检查耗时过长

- **解决方案**：分批检查、使用索引、优化查询

**问题4**：循环引用难以检测

- **解决方案**：使用递归查询、图算法、限制引用深度

---

## 8. 最佳实践

### 7.1 约束设计

1. **主键设计**：
   - 选择稳定的主键
   - 避免使用业务字段作为主键
   - 使用SERIAL或UUID

2. **外键设计**：
   - 为所有外键创建索引
   - 选择合适的级联操作
   - 避免循环引用

3. **唯一约束**：
   - 在业务唯一字段上创建唯一约束
   - 考虑部分唯一约束
   - 使用唯一索引

### 7.2 完整性检查

1. **检查频率**：
   - 实时检查：关键业务数据
   - 定期检查：一般数据
   - 按需检查：历史数据

2. **检查范围**：
   - 全量检查：重要数据
   - 抽样检查：大量数据
   - 增量检查：变化数据

3. **检查报告**：
   - 生成详细报告
   - 记录检查历史
   - 跟踪问题修复

### 7.3 问题修复

1. **修复策略**：
   - 优先修复关键问题
   - 批量修复相似问题
   - 验证修复结果

2. **修复方法**：
   - 删除无效记录
   - 更新引用关系
   - 数据迁移

3. **修复验证**：
   - 重新运行完整性检查
   - 验证业务逻辑
   - 监控数据质量

### 7.4 SQL实现注意事项

1. **性能考虑**：
   - 使用索引加速检查
   - 避免全表扫描
   - 优化JOIN操作

2. **准确性**：
   - 使用精确的比较
   - 处理NULL值
   - 考虑精度问题

3. **可维护性**：
   - 使用函数封装检查逻辑
   - 清晰的代码注释
   - 模块化设计

---

## 📚 参考资源

### 学术文献

1. **《数据库系统概念》**（Silberschatz et al., 2019）- 第6章 完整性约束

2. **《数据库设计》**（Teorey et al., 2010）- 数据完整性设计

3. **PostgreSQL官方文档** - 约束、外键、触发器

### PostgreSQL官方文档

- **约束**: <https://www.postgresql.org/docs/current/ddl-constraints.html>
- **外键**: <https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK>
- **触发器**: <https://www.postgresql.org/docs/current/triggers.html>
- **信息模式**: <https://www.postgresql.org/docs/current/information-schema.html>

### 在线资源

- **数据完整性**: <https://en.wikipedia.org/wiki/Data_integrity>
- **引用完整性**: <https://en.wikipedia.org/wiki/Referential_integrity>
- **数据库约束**: <https://www.postgresql.org/docs/current/ddl-constraints.html>

### 相关算法

- **数据验证算法**：数据完整性验证
- **数据清洗算法**：数据完整性修复
- **数据标准化算法**：数据格式标准化
- **查询优化算法**：完整性检查优化

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
