# PostgreSQL 数据标准化算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数据标准化 | 数据规范化
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 数据标准化算法完整指南](#postgresql-数据标准化算法完整指南)
  - [📋 目录](#-目录)
  - [数据标准化概述](#数据标准化概述)
    - [理论基础](#理论基础)
      - [数据标准化目的](#数据标准化目的)
      - [标准化方法分类](#标准化方法分类)
      - [标准化 vs 归一化](#标准化-vs-归一化)
    - [核心算法](#核心算法)
  - [1. 文本标准化](#1-文本标准化)
    - [1.1 文本标准化原理](#11-文本标准化原理)
      - [大小写转换](#大小写转换)
      - [空格处理](#空格处理)
      - [特殊字符处理](#特殊字符处理)
    - [1.2 大小写标准化实现](#12-大小写标准化实现)
    - [1.3 去除空格实现](#13-去除空格实现)
    - [1.4 文本规范化综合处理](#14-文本规范化综合处理)
  - [2. 数值标准化](#2-数值标准化)
    - [2.1 数值标准化原理](#21-数值标准化原理)
      - [Z-score标准化](#z-score标准化)
      - [Min-Max标准化](#min-max标准化)
      - [Robust标准化](#robust标准化)
    - [2.2 Z-score标准化实现](#22-z-score标准化实现)
    - [2.3 Min-Max标准化实现](#23-min-max标准化实现)
    - [2.4 Robust标准化实现](#24-robust标准化实现)
    - [2.5 Decimal Scaling标准化实现](#25-decimal-scaling标准化实现)
  - [3. 日期时间标准化](#3-日期时间标准化)
    - [3.1 日期时间标准化原理](#31-日期时间标准化原理)
      - [日期格式标准化](#日期格式标准化)
      - [时区标准化](#时区标准化)
    - [3.2 日期格式标准化实现](#32-日期格式标准化实现)
    - [3.3 时区标准化实现](#33-时区标准化实现)
  - [4. 分类数据标准化](#4-分类数据标准化)
    - [4.1 分类数据标准化原理](#41-分类数据标准化原理)
      - [编码统一](#编码统一)
      - [类别映射](#类别映射)
    - [4.2 分类数据标准化实现](#42-分类数据标准化实现)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 综合数据标准化](#51-综合数据标准化)
    - [5.2 客户数据标准化](#52-客户数据标准化)
    - [5.3 产品数据标准化](#53-产品数据标准化)
    - [5.4 时间序列数据标准化](#54-时间序列数据标准化)
    - [5.5 批量数据标准化](#55-批量数据标准化)
  - [6. 算法性能对比与优化](#6-算法性能对比与优化)
    - [6.1 标准化方法对比](#61-标准化方法对比)
    - [6.2 性能优化建议](#62-性能优化建议)
    - [6.3 常见问题与解决方案](#63-常见问题与解决方案)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 标准化策略](#71-标准化策略)
    - [7.2 标准化实施](#72-标准化实施)
    - [7.3 标准化验证](#73-标准化验证)
    - [7.4 SQL实现注意事项](#74-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 数据标准化概述

**数据标准化（Data Standardization）**是将数据转换为统一的格式、范围和表示方法的过程，确保数据的一致性、可比性和可分析性。数据标准化是数据预处理的重要环节，为后续的数据分析和机器学习提供高质量的数据基础。

### 理论基础

#### 数据标准化目的

1. **格式统一**：统一数据的表示格式
2. **范围统一**：统一数据的数值范围
3. **消除量纲**：消除不同量纲的影响
4. **提高可比性**：使不同来源的数据可以比较
5. **改善分析效果**：提高数据分析和机器学习的效果

#### 标准化方法分类

1. **文本标准化**：
   - 大小写转换
   - 空格处理
   - 特殊字符处理
   - 编码统一

2. **数值标准化**：
   - **Z-score标准化**：标准化到均值0、标准差1
   - **Min-Max标准化**：标准化到[0,1]范围
   - **Robust标准化**：使用中位数和四分位距
   - **Decimal Scaling**：小数点缩放

3. **日期时间标准化**：
   - 日期格式统一
   - 时区标准化
   - 时间戳标准化

4. **分类数据标准化**：
   - 编码统一
   - 类别映射
   - 独热编码

#### 标准化 vs 归一化

**标准化（Standardization）**：

- 改变数据分布
- 均值0、标准差1
- 适合正态分布数据

**归一化（Normalization）**：

- 改变数据范围
- [0,1]范围
- 适合有界数据

### 核心算法

| 算法 | 公式 | 用途 | 时间复杂度 | 适用场景 |
|------|------|------|-----------|---------|
| **Z-score** | $z = \frac{x - \mu}{\sigma}$ | 标准化到均值0方差1 | $O(n)$ | 正态分布数据 |
| **Min-Max** | $x' = \frac{x - min}{max - min}$ | 标准化到0-1范围 | $O(n)$ | 有界数据 |
| **Robust** | $x' = \frac{x - median}{IQR}$ | 标准化到中位数0 | $O(n \log n)$ | 有异常值数据 |
| **Decimal Scaling** | $x' = \frac{x}{10^j}$ | 小数点缩放 | $O(n)$ | 大数值数据 |

---

## 1. 文本标准化

### 1.1 文本标准化原理

**文本标准化**统一文本的格式，包括大小写、空格、特殊字符等，确保文本数据的一致性。

#### 大小写转换

**转换方法**：

- **LOWER()**：转换为小写
- **UPPER()**：转换为大写
- **INITCAP()**：首字母大写

#### 空格处理

**处理方法**：

- **TRIM()**：去除首尾空格
- **LTRIM()**：去除左侧空格
- **RTRIM()**：去除右侧空格
- **REGEXP_REPLACE()**：替换多个空格为单个空格

#### 特殊字符处理

**处理方法**：

- 去除控制字符
- 统一标点符号
- 处理Unicode字符

### 1.2 大小写标准化实现

```sql
-- 创建测试数据表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 已存在，先删除';
            DROP TABLE standardization_test CASCADE;
        END IF;

        CREATE TABLE standardization_test (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100),
            description TEXT,
            value NUMERIC(10, 2),
            created_date VARCHAR(50)
        );

        INSERT INTO standardization_test (name, description, value, created_date) VALUES
            ('John DOE', '  Some Description  ', 100.5, '2024-01-01'),
            ('jane smith', 'Another Description', 200.3, '01/15/2024'),
            ('BOB WILSON', '  Yet Another  ', 150.7, '2024-1-5');

        RAISE NOTICE '表 standardization_test 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 standardization_test 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;

-- 大小写标准化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 不存在，无法进行大小写标准化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行大小写标准化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '大小写标准化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 转换为小写
SELECT
    id,
    name,
    LOWER(name) AS name_lowercase,
    INITCAP(name) AS name_title_case,
    UPPER(name) AS name_uppercase
FROM standardization_test
ORDER BY id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    LOWER(name) AS name_lowercase
FROM standardization_test;
```

### 1.3 去除空格实现

**去除空格**清理文本中的多余空格，统一文本格式。

```sql
-- 去除空格（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 不存在，无法去除空格';
            RETURN;
        END IF;
        RAISE NOTICE '开始去除空格';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '去除空格准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 去除首尾空格和多余空格
SELECT
    id,
    description,
    TRIM(description) AS trimmed_description,
    REGEXP_REPLACE(TRIM(description), '\s+', ' ', 'g') AS normalized_description
FROM standardization_test
ORDER BY id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    TRIM(description) AS trimmed
FROM standardization_test;
```

---

### 1.4 文本规范化综合处理

**文本规范化**综合处理文本的多个方面。

```sql
-- 文本规范化综合处理
CREATE OR REPLACE FUNCTION normalize_text(input_text TEXT) RETURNS TEXT AS $$
BEGIN
    -- 去除首尾空格
    input_text := TRIM(input_text);
    -- 统一多个空格为单个空格
    input_text := REGEXP_REPLACE(input_text, '\s+', ' ', 'g');
    -- 转换为小写
    input_text := LOWER(input_text);
    -- 去除特殊字符（保留字母、数字、空格、连字符）
    input_text := REGEXP_REPLACE(input_text, '[^a-z0-9\s-]', '', 'g');
    RETURN input_text;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 使用规范化函数
SELECT
    id,
    name,
    normalize_text(name) AS normalized_name,
    description,
    normalize_text(description) AS normalized_description
FROM standardization_test;
```

## 2. 数值标准化

### 2.1 数值标准化原理

**数值标准化**将数值数据转换为统一的数值范围或分布，消除量纲影响，提高数据的可比性。

#### Z-score标准化

**Z-score标准化**（标准化）将数据转换为标准正态分布：
$$z = \frac{x - \mu}{\sigma}$$

其中：

- $\mu$：均值
- $\sigma$：标准差

**特点**：

- 均值变为0
- 标准差变为1
- 保持原始分布形状

#### Min-Max标准化

**Min-Max标准化**（归一化）将数据缩放到[0,1]范围：
$$x' = \frac{x - x_{min}}{x_{max} - x_{min}}$$

**特点**：

- 范围变为[0,1]
- 保持原始分布形状
- 对异常值敏感

#### Robust标准化

**Robust标准化**使用中位数和四分位距，对异常值不敏感：
$$x' = \frac{x - median}{IQR}$$

其中$IQR = Q_3 - Q_1$（四分位距）。

**特点**：

- 对异常值鲁棒
- 适合有异常值的数据
- 中位数变为0

### 2.2 Z-score标准化实现

```sql
-- Z-score标准化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 不存在，无法进行Z-score标准化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行Z-score标准化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Z-score标准化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Z-score标准化
WITH value_stats AS (
    SELECT
        AVG(value) AS mean_value,
        STDDEV(value) AS stddev_value
    FROM standardization_test
    WHERE value IS NOT NULL
)
SELECT
    st.id,
    st.value AS original_value,
    ROUND((st.value - vs.mean_value) / NULLIF(vs.stddev_value, 0)::numeric, 4) AS z_score
FROM standardization_test st
CROSS JOIN value_stats vs
WHERE st.value IS NOT NULL
ORDER BY st.id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    AVG(value) AS mean_value,
    STDDEV(value) AS stddev_value
FROM standardization_test
WHERE value IS NOT NULL;
```

### 2.3 Min-Max标准化实现

**Min-Max标准化**将数据标准化到0-1范围，适合有界数据。

```sql
-- Min-Max标准化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 不存在，无法进行Min-Max标准化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行Min-Max标准化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Min-Max标准化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Min-Max标准化到0-1范围
WITH value_stats AS (
    SELECT
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        MAX(value) - MIN(value) AS value_range
    FROM standardization_test
    WHERE value IS NOT NULL
)
SELECT
    st.id,
    st.value AS original_value,
    ROUND(((st.value - vs.min_value) / NULLIF(vs.value_range, 0))::numeric, 4) AS min_max_normalized
FROM standardization_test st
CROSS JOIN value_stats vs
WHERE st.value IS NOT NULL
ORDER BY st.id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    MIN(value) AS min_value,
    MAX(value) AS max_value
FROM standardization_test
WHERE value IS NOT NULL;
```

---

### 2.4 Robust标准化实现

**Robust标准化**使用中位数和四分位距，对异常值不敏感。

```sql
-- Robust标准化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 不存在，无法进行Robust标准化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行Robust标准化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'Robust标准化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- Robust标准化
WITH value_stats AS (
    SELECT
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) AS median_value,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY value) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY value) AS iqr_value
    FROM standardization_test
    WHERE value IS NOT NULL
)
SELECT
    st.id,
    st.value AS original_value,
    ROUND((st.value - vs.median_value) / NULLIF(vs.iqr_value, 0)::numeric, 4) AS robust_normalized
FROM standardization_test st
CROSS JOIN value_stats vs
WHERE st.value IS NOT NULL
ORDER BY st.id;
```

### 2.5 Decimal Scaling标准化实现

**Decimal Scaling标准化**通过移动小数点进行标准化。

```sql
-- Decimal Scaling标准化
WITH value_stats AS (
    SELECT
        MAX(ABS(value)) AS max_abs_value,
        CEILING(LOG(10, MAX(ABS(value)))) AS scaling_factor
    FROM standardization_test
    WHERE value IS NOT NULL
)
SELECT
    st.id,
    st.value AS original_value,
    ROUND((st.value / POWER(10, vs.scaling_factor))::numeric, 4) AS decimal_scaled
FROM standardization_test st
CROSS JOIN value_stats vs
WHERE st.value IS NOT NULL
ORDER BY st.id;
```

## 3. 日期时间标准化

### 3.1 日期时间标准化原理

**日期时间标准化**统一日期时间的格式、时区和表示方法，确保时间数据的一致性。

#### 日期格式标准化

**常见日期格式**：

- ISO 8601：`YYYY-MM-DD`
- 美国格式：`MM/DD/YYYY`
- 欧洲格式：`DD/MM/YYYY`
- 时间戳：Unix timestamp

#### 时区标准化

**时区处理**：

- 统一时区（如UTC）
- 时区转换
- 夏令时处理

### 3.2 日期格式标准化实现

```sql
-- 日期格式标准化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 不存在，无法进行日期格式标准化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行日期格式标准化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '日期格式标准化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 标准化日期格式为YYYY-MM-DD
SELECT
    id,
    created_date AS original_date,
    CASE
        WHEN created_date ~ '^\d{4}-\d{2}-\d{2}$' THEN created_date::DATE
        WHEN created_date ~ '^\d{2}/\d{2}/\d{4}$' THEN TO_DATE(created_date, 'MM/DD/YYYY')
        WHEN created_date ~ '^\d{4}-\d{1,2}-\d{1,2}$' THEN created_date::DATE
        ELSE NULL
    END AS standardized_date,
    TO_CHAR(
        CASE
            WHEN created_date ~ '^\d{4}-\d{2}-\d{2}$' THEN created_date::DATE
            WHEN created_date ~ '^\d{2}/\d{2}/\d{4}$' THEN TO_DATE(created_date, 'MM/DD/YYYY')
            WHEN created_date ~ '^\d{4}-\d{1,2}-\d{1,2}$' THEN created_date::DATE
            ELSE NULL
        END,
        'YYYY-MM-DD'
    ) AS formatted_date
FROM standardization_test
ORDER BY id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    created_date::DATE AS standardized_date
FROM standardization_test
WHERE created_date ~ '^\d{4}-\d{2}-\d{2}$';
```

---

### 3.3 时区标准化实现

**时区标准化**统一时区表示。

```sql
-- 时区标准化：统一转换为UTC
SELECT
    id,
    created_timestamp,
    created_timestamp AT TIME ZONE 'UTC' AS utc_timestamp,
    EXTRACT(TIMEZONE FROM created_timestamp) AS timezone_offset
FROM timestamp_test;
```

## 4. 分类数据标准化

### 4.1 分类数据标准化原理

**分类数据标准化**统一分类数据的编码和表示方法。

#### 编码统一

**编码方法**：

- 统一编码格式
- 映射到标准编码
- 处理编码不一致

#### 类别映射

**映射方法**：

- 同义词合并
- 类别标准化
- 层次结构统一

### 4.2 分类数据标准化实现

```sql
-- 分类数据标准化：统一类别编码
WITH category_mapping AS (
    SELECT 'Electronics' AS original_category, 'ELECTRONICS' AS standardized_category
    UNION ALL SELECT 'electronics', 'ELECTRONICS'
    UNION ALL SELECT 'ELECTRONICS', 'ELECTRONICS'
    UNION ALL SELECT 'Clothing', 'CLOTHING'
    UNION ALL SELECT 'clothing', 'CLOTHING'
    UNION ALL SELECT 'CLOTHING', 'CLOTHING'
)
SELECT
    p.product_id,
    p.category AS original_category,
    COALESCE(cm.standardized_category, UPPER(TRIM(p.category))) AS standardized_category
FROM products p
LEFT JOIN category_mapping cm ON LOWER(TRIM(p.category)) = LOWER(TRIM(cm.original_category));
```

## 5. 实际应用案例

### 5.1 综合数据标准化

**综合数据标准化**整合多种标准化方法，处理完整的数据集。

```sql
-- 综合数据标准化示例（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'standardization_test') THEN
            RAISE WARNING '表 standardization_test 不存在，无法进行综合数据标准化';
            RETURN;
        END IF;
        RAISE NOTICE '开始进行综合数据标准化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '综合数据标准化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 综合标准化处理
WITH value_stats AS (
    SELECT
        AVG(value) AS mean_value,
        STDDEV(value) AS stddev_value,
        MIN(value) AS min_value,
        MAX(value) AS max_value,
        MAX(value) - MIN(value) AS value_range
    FROM standardization_test
    WHERE value IS NOT NULL
)
SELECT
    st.id,
    INITCAP(TRIM(st.name)) AS standardized_name,
    REGEXP_REPLACE(TRIM(st.description), '\s+', ' ', 'g') AS standardized_description,
    st.value AS original_value,
    ROUND((st.value - vs.mean_value) / NULLIF(vs.stddev_value, 0)::numeric, 4) AS z_score,
    ROUND(((st.value - vs.min_value) / NULLIF(vs.value_range, 0))::numeric, 4) AS min_max_normalized,
    TO_CHAR(
        CASE
            WHEN st.created_date ~ '^\d{4}-\d{2}-\d{2}$' THEN st.created_date::DATE
            WHEN st.created_date ~ '^\d{2}/\d{2}/\d{4}$' THEN TO_DATE(st.created_date, 'MM/DD/YYYY')
            WHEN st.created_date ~ '^\d{4}-\d{1,2}-\d{1,2}$' THEN st.created_date::DATE
            ELSE NULL
        END,
        'YYYY-MM-DD'
    ) AS standardized_date
FROM standardization_test st
CROSS JOIN value_stats vs
ORDER BY st.id;

-- 性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    INITCAP(TRIM(name)) AS standardized_name,
    AVG(value) AS mean_value
FROM standardization_test
GROUP BY name;
```

### 5.2 客户数据标准化

**场景**：标准化客户数据，统一格式和表示。

```sql
-- 客户数据标准化：综合处理客户信息
WITH customer_standardization AS (
    SELECT
        customer_id,
        -- 姓名标准化
        INITCAP(TRIM(name)) AS standardized_name,
        -- 邮箱标准化
        LOWER(TRIM(email)) AS standardized_email,
        -- 电话标准化（去除空格和特殊字符）
        REGEXP_REPLACE(REGEXP_REPLACE(phone, '[^\d]', '', 'g'), '^(\d{3})(\d{4})(\d{4})$', '\1-\2-\3') AS standardized_phone,
        -- 地址标准化
        UPPER(TRIM(address)) AS standardized_address,
        -- 创建日期标准化
        TO_CHAR(created_date, 'YYYY-MM-DD') AS standardized_date
    FROM customers
)
SELECT
    customer_id,
    standardized_name,
    standardized_email,
    standardized_phone,
    standardized_address,
    standardized_date
FROM customer_standardization
ORDER BY customer_id;
```

### 5.3 产品数据标准化

**场景**：标准化产品数据，统一分类和属性。

```sql
-- 产品数据标准化：标准化产品分类和价格
WITH product_stats AS (
    SELECT
        category,
        AVG(price) AS avg_price,
        STDDEV(price) AS stddev_price,
        MIN(price) AS min_price,
        MAX(price) AS max_price
    FROM products
    WHERE price IS NOT NULL AND price > 0
    GROUP BY category
),
product_standardization AS (
    SELECT
        p.product_id,
        p.product_name,
        -- 产品名称标准化
        INITCAP(TRIM(p.product_name)) AS standardized_name,
        -- 分类标准化
        UPPER(TRIM(p.category)) AS standardized_category,
        -- 价格Z-score标准化（按分类）
        ROUND((p.price - ps.avg_price) / NULLIF(ps.stddev_price, 0)::numeric, 4) AS price_z_score,
        -- 价格Min-Max标准化（按分类）
        ROUND(((p.price - ps.min_price) / NULLIF(ps.max_price - ps.min_price, 0))::numeric, 4) AS price_min_max
    FROM products p
    LEFT JOIN product_stats ps ON UPPER(TRIM(p.category)) = UPPER(TRIM(ps.category))
    WHERE p.price IS NOT NULL AND p.price > 0
)
SELECT
    product_id,
    standardized_name,
    standardized_category,
    price_z_score,
    price_min_max
FROM product_standardization
ORDER BY standardized_category, price_z_score DESC;
```

### 5.4 时间序列数据标准化

**场景**：标准化时间序列数据，统一时间格式和数值范围。

```sql
-- 时间序列数据标准化：标准化销售数据
WITH sales_stats AS (
    SELECT
        AVG(amount) AS mean_amount,
        STDDEV(amount) AS stddev_amount,
        MIN(amount) AS min_amount,
        MAX(amount) AS max_amount,
        MAX(amount) - MIN(amount) AS amount_range
    FROM sales
    WHERE amount IS NOT NULL
),
sales_standardization AS (
    SELECT
        s.sale_id,
        -- 日期标准化
        TO_CHAR(s.sale_date, 'YYYY-MM-DD') AS standardized_date,
        -- 时间标准化（统一为24小时制）
        TO_CHAR(s.sale_time, 'HH24:MI:SS') AS standardized_time,
        -- 金额Z-score标准化
        ROUND((s.amount - ss.mean_amount) / NULLIF(ss.stddev_amount, 0)::numeric, 4) AS amount_z_score,
        -- 金额Min-Max标准化
        ROUND(((s.amount - ss.min_amount) / NULLIF(ss.amount_range, 0))::numeric, 4) AS amount_min_max,
        -- 原始金额
        s.amount AS original_amount
    FROM sales s
    CROSS JOIN sales_stats ss
    WHERE s.amount IS NOT NULL
)
SELECT
    sale_id,
    standardized_date,
    standardized_time,
    original_amount,
    amount_z_score,
    amount_min_max
FROM sales_standardization
ORDER BY standardized_date, standardized_time;
```

### 5.5 批量数据标准化

**场景**：批量标准化大量数据，提高处理效率。

```sql
-- 批量数据标准化：使用UPDATE批量更新标准化后的数据
-- 创建标准化后的表
CREATE TABLE IF NOT EXISTS customers_standardized AS
SELECT
    customer_id,
    INITCAP(TRIM(name)) AS standardized_name,
    LOWER(TRIM(email)) AS standardized_email,
    REGEXP_REPLACE(REGEXP_REPLACE(phone, '[^\d]', '', 'g'), '^(\d{3})(\d{4})(\d{4})$', '\1-\2-\3') AS standardized_phone,
    UPPER(TRIM(address)) AS standardized_address,
    TO_CHAR(created_date, 'YYYY-MM-DD') AS standardized_date
FROM customers;

-- 创建索引加速查询
CREATE INDEX IF NOT EXISTS idx_customers_std_email ON customers_standardized(standardized_email);
CREATE INDEX IF NOT EXISTS idx_customers_std_name ON customers_standardized(standardized_name);

-- 验证标准化结果
SELECT
    COUNT(*) AS total_records,
    COUNT(DISTINCT standardized_email) AS unique_emails,
    COUNT(*) FILTER (WHERE standardized_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') AS valid_emails
FROM customers_standardized;
```

---

## 6. 算法性能对比与优化

### 6.1 标准化方法对比

| 标准化方法 | 公式 | 优点 | 缺点 | 适用场景 |
|-----------|------|------|------|---------|
| **Z-score** | $z = \frac{x - \mu}{\sigma}$ | 保持分布形状、适合正态分布 | 对异常值敏感 | 正态分布数据 |
| **Min-Max** | $x' = \frac{x - min}{max - min}$ | 范围固定[0,1]、简单直观 | 对异常值敏感 | 有界数据 |
| **Robust** | $x' = \frac{x - median}{IQR}$ | 对异常值鲁棒 | 计算复杂度高 | 有异常值数据 |
| **Decimal Scaling** | $x' = \frac{x}{10^j}$ | 简单快速 | 范围不固定 | 大数值数据 |

### 6.2 性能优化建议

1. **批量处理**：
   - 使用批量UPDATE/INSERT
   - 使用CTE减少重复计算
   - 使用物化视图缓存结果

2. **函数优化**：
   - 创建IMMUTABLE函数
   - 使用函数索引
   - 避免重复计算统计值

3. **索引优化**：
   - 在标准化后的字段上创建索引
   - 使用表达式索引
   - 考虑覆盖索引

4. **并行处理**：
   - 使用并行查询
   - 分批处理大数据集
   - 使用分区表

### 6.3 常见问题与解决方案

**问题1**：标准化后数据范围不符合预期

- **解决方案**：检查统计值计算、处理NULL值、验证公式

**问题2**：标准化性能慢

- **解决方案**：批量处理、使用物化视图、优化统计值计算

**问题3**：异常值影响标准化

- **解决方案**：使用Robust标准化、先处理异常值、使用截断方法

**问题4**：文本标准化不彻底

- **解决方案**：使用正则表达式、处理Unicode字符、统一编码

---

## 7. 最佳实践

### 7.1 标准化策略

1. **数据探索**：
   - 先分析数据分布
   - 识别异常值
   - 确定标准化方法

2. **方法选择**：
   - 正态分布：Z-score
   - 有界数据：Min-Max
   - 有异常值：Robust
   - 大数值：Decimal Scaling

3. **参数保存**：
   - 保存统计值（均值、标准差等）
   - 用于新数据标准化
   - 保持一致性

### 7.2 标准化实施

1. **预处理**：
   - 先清洗数据
   - 处理缺失值
   - 处理异常值

2. **标准化**：
   - 按列标准化
   - 保存标准化参数
   - 验证标准化结果

3. **后处理**：
   - 验证标准化效果
   - 检查数据分布
   - 记录标准化日志

### 7.3 标准化验证

1. **统计验证**：
   - 检查均值是否为0（Z-score）
   - 检查范围是否为[0,1]（Min-Max）
   - 检查标准差是否为1（Z-score）

2. **分布验证**：
   - 可视化数据分布
   - 比较标准化前后分布
   - 检查是否保持分布形状

3. **业务验证**：
   - 验证业务逻辑
   - 检查数据含义
   - 确认标准化合理

### 7.4 SQL实现注意事项

1. **性能考虑**：
   - 批量处理数据
   - 使用物化视图
   - 优化统计值计算

2. **准确性**：
   - 处理NULL值
   - 处理除零错误
   - 数值精度控制

3. **可维护性**：
   - 使用函数封装逻辑
   - 清晰的代码注释
   - 模块化设计

---

## 📚 参考资源

### 学术文献

1. **《数据挖掘：概念与技术》**（Han et al., 2011）- 第3章 数据预处理

2. **《机器学习》**（周志华, 2016）- 第11章 特征选择与稀疏学习

3. **《统计学习方法》**（李航, 2012）- 数据预处理

### PostgreSQL官方文档

- **字符串函数**: <https://www.postgresql.org/docs/current/functions-string.html>
- **数学函数**: <https://www.postgresql.org/docs/current/functions-math.html>
- **日期时间函数**: <https://www.postgresql.org/docs/current/functions-datetime.html>
- **正则表达式**: <https://www.postgresql.org/docs/current/functions-matching.html>

### 在线资源

- **数据标准化**: <https://en.wikipedia.org/wiki/Feature_scaling>
- **Z-score**: <https://en.wikipedia.org/wiki/Standard_score>
- **数据预处理**: <https://scikit-learn.org/stable/modules/preprocessing.html>

### 相关算法

- **数据清洗算法**：数据标准化的前置步骤
- **数据验证算法**：数据标准化的验证
- **数据完整性检查**：数据标准化的完整性保证
- **描述性统计**：标准化统计值计算

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档状态**: ✅ 已完成

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
