# PostgreSQL æ•°æ®æ¸…æ´—ç®—æ³•å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æŠ€æœ¯æ ˆ**: PostgreSQL 17+/18+ | æ•°æ®æ¸…æ´— | æ•°æ®è´¨é‡
> **éš¾åº¦çº§åˆ«**: â­â­â­ (ä¸­çº§)

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL æ•°æ®æ¸…æ´—ç®—æ³•å®Œæ•´æŒ‡å—](#postgresql-æ•°æ®æ¸…æ´—ç®—æ³•å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ•°æ®æ¸…æ´—æ¦‚è¿°](#æ•°æ®æ¸…æ´—æ¦‚è¿°)
    - [ç†è®ºåŸºç¡€](#ç†è®ºåŸºç¡€)
      - [æ•°æ®è´¨é‡ç»´åº¦](#æ•°æ®è´¨é‡ç»´åº¦)
      - [ç¼ºå¤±å€¼æœºåˆ¶](#ç¼ºå¤±å€¼æœºåˆ¶)
      - [å¼‚å¸¸å€¼ç†è®º](#å¼‚å¸¸å€¼ç†è®º)
    - [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [1. ç¼ºå¤±å€¼å¤„ç†](#1-ç¼ºå¤±å€¼å¤„ç†)
    - [1.1 ç¼ºå¤±å€¼æ£€æµ‹åŸç†](#11-ç¼ºå¤±å€¼æ£€æµ‹åŸç†)
      - [ç¼ºå¤±å€¼è¡¨ç¤º](#ç¼ºå¤±å€¼è¡¨ç¤º)
      - [ç¼ºå¤±æ¨¡å¼åˆ†æ](#ç¼ºå¤±æ¨¡å¼åˆ†æ)
    - [1.2 ç¼ºå¤±å€¼æ£€æµ‹å®ç°](#12-ç¼ºå¤±å€¼æ£€æµ‹å®ç°)
    - [1.3 ç¼ºå¤±å€¼å¡«å……æ–¹æ³•](#13-ç¼ºå¤±å€¼å¡«å……æ–¹æ³•)
      - [å¡«å……æ–¹æ³•åˆ†ç±»](#å¡«å……æ–¹æ³•åˆ†ç±»)
      - [å¡«å……æ–¹æ³•é€‰æ‹©](#å¡«å……æ–¹æ³•é€‰æ‹©)
    - [1.4 ç¼ºå¤±å€¼å¡«å……å®ç°](#14-ç¼ºå¤±å€¼å¡«å……å®ç°)
  - [2. å¼‚å¸¸å€¼å¤„ç†](#2-å¼‚å¸¸å€¼å¤„ç†)
    - [2.1 å¼‚å¸¸å€¼æ£€æµ‹åŸç†](#21-å¼‚å¸¸å€¼æ£€æµ‹åŸç†)
      - [å¼‚å¸¸å€¼æ£€æµ‹æ–¹æ³•](#å¼‚å¸¸å€¼æ£€æµ‹æ–¹æ³•)
      - [IQRæ–¹æ³•è¯¦è§£](#iqræ–¹æ³•è¯¦è§£)
      - [Z-scoreæ–¹æ³•è¯¦è§£](#z-scoreæ–¹æ³•è¯¦è§£)
    - [2.2 å¼‚å¸¸å€¼æ£€æµ‹å®ç°](#22-å¼‚å¸¸å€¼æ£€æµ‹å®ç°)
  - [3. é‡å¤æ•°æ®å¤„ç†](#3-é‡å¤æ•°æ®å¤„ç†)
    - [3.1 é‡å¤æ•°æ®æ£€æµ‹åŸç†](#31-é‡å¤æ•°æ®æ£€æµ‹åŸç†)
      - [é‡å¤ç±»å‹](#é‡å¤ç±»å‹)
      - [æ£€æµ‹æ–¹æ³•](#æ£€æµ‹æ–¹æ³•)
      - [ç¼–è¾‘è·ç¦»](#ç¼–è¾‘è·ç¦»)
    - [3.2 é‡å¤æ•°æ®æ£€æµ‹å®ç°](#32-é‡å¤æ•°æ®æ£€æµ‹å®ç°)
  - [4. æ•°æ®æ ¼å¼æ ‡å‡†åŒ–](#4-æ•°æ®æ ¼å¼æ ‡å‡†åŒ–)
    - [4.1 æ ¼å¼ç»Ÿä¸€](#41-æ ¼å¼ç»Ÿä¸€)
    - [4.2 æ•°æ®ç±»å‹è½¬æ¢](#42-æ•°æ®ç±»å‹è½¬æ¢)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 ç»¼åˆæ•°æ®æ¸…æ´—](#51-ç»¼åˆæ•°æ®æ¸…æ´—)
    - [5.2 å®¢æˆ·æ•°æ®æ¸…æ´—](#52-å®¢æˆ·æ•°æ®æ¸…æ´—)
    - [5.3 é”€å”®æ•°æ®æ¸…æ´—](#53-é”€å”®æ•°æ®æ¸…æ´—)
    - [5.4 æ–‡æœ¬æ•°æ®æ¸…æ´—](#54-æ–‡æœ¬æ•°æ®æ¸…æ´—)
    - [5.5 æ•°æ®è´¨é‡ç›‘æ§](#55-æ•°æ®è´¨é‡ç›‘æ§)
  - [6. PostgreSQL 18å¹¶è¡Œæ•°æ®æ¸…æ´—](#6-postgresql-18å¹¶è¡Œæ•°æ®æ¸…æ´—)
    - [6.1 å¹¶è¡Œæ•°æ®æ¸…æ´—æ¦‚è¿°](#61-å¹¶è¡Œæ•°æ®æ¸…æ´—æ¦‚è¿°)
      - [å¹¶è¡Œæ•°æ®æ¸…æ´—é…ç½®](#å¹¶è¡Œæ•°æ®æ¸…æ´—é…ç½®)
      - [å¹¶è¡Œæ•°æ®æ¸…æ´—å®ç°](#å¹¶è¡Œæ•°æ®æ¸…æ´—å®ç°)
  - [7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–](#7-ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–)
    - [7.1 æ¸…æ´—æ–¹æ³•å¯¹æ¯”](#71-æ¸…æ´—æ–¹æ³•å¯¹æ¯”)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ](#73-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 æ•°æ®æ¸…æ´—æµç¨‹](#81-æ•°æ®æ¸…æ´—æµç¨‹)
    - [8.2 ç¼ºå¤±å€¼å¤„ç†ç­–ç•¥](#82-ç¼ºå¤±å€¼å¤„ç†ç­–ç•¥)
    - [8.3 å¼‚å¸¸å€¼å¤„ç†ç­–ç•¥](#83-å¼‚å¸¸å€¼å¤„ç†ç­–ç•¥)
    - [8.4 é‡å¤æ•°æ®å¤„ç†ç­–ç•¥](#84-é‡å¤æ•°æ®å¤„ç†ç­–ç•¥)
    - [8.5 SQLå®ç°æ³¨æ„äº‹é¡¹](#85-sqlå®ç°æ³¨æ„äº‹é¡¹)
    - [8.6 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰](#86-postgresql-18-æ–°ç‰¹æ€§åº”ç”¨å¢å¼º)
    - [8.7 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰](#87-é«˜çº§ä¼˜åŒ–æŠ€å·§å¢å¼º)
  - [ğŸ“š å‚è€ƒèµ„æº](#-å‚è€ƒèµ„æº)
    - [å­¦æœ¯æ–‡çŒ®](#å­¦æœ¯æ–‡çŒ®)
    - [åœ¨çº¿èµ„æº](#åœ¨çº¿èµ„æº)
    - [ç›¸å…³ç®—æ³•](#ç›¸å…³ç®—æ³•)

---

## æ•°æ®æ¸…æ´—æ¦‚è¿°

**æ•°æ®æ¸…æ´—ï¼ˆData Cleaningï¼‰**æ˜¯æ•°æ®é¢„å¤„ç†çš„æ ¸å¿ƒç¯èŠ‚ï¼Œç”¨äºè¯†åˆ«å’Œä¿®å¤æ•°æ®è´¨é‡é—®é¢˜ï¼Œæé«˜æ•°æ®å¯é æ€§å’Œå¯ç”¨æ€§ã€‚æ•°æ®æ¸…æ´—æ˜¯æ•°æ®ç§‘å­¦å’Œæ•°æ®åˆ†æçš„åŸºç¡€ï¼Œç›´æ¥å½±å“åç»­åˆ†æå’Œå»ºæ¨¡çš„è´¨é‡ã€‚

### ç†è®ºåŸºç¡€

#### æ•°æ®è´¨é‡ç»´åº¦

æ•°æ®è´¨é‡å¯ä»¥ä»ä»¥ä¸‹ç»´åº¦è¯„ä¼°ï¼š

1. **å®Œæ•´æ€§ï¼ˆCompletenessï¼‰**ï¼šæ•°æ®æ˜¯å¦å®Œæ•´ï¼Œç¼ºå¤±å€¼æ¯”ä¾‹
2. **å‡†ç¡®æ€§ï¼ˆAccuracyï¼‰**ï¼šæ•°æ®æ˜¯å¦æ­£ç¡®ï¼Œæ˜¯å¦ç¬¦åˆä¸šåŠ¡è§„åˆ™
3. **ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰**ï¼šæ•°æ®åœ¨ä¸åŒæ¥æºæ˜¯å¦ä¸€è‡´
4. **æ—¶æ•ˆæ€§ï¼ˆTimelinessï¼‰**ï¼šæ•°æ®æ˜¯å¦åŠæ—¶æ›´æ–°
5. **æœ‰æ•ˆæ€§ï¼ˆValidityï¼‰**ï¼šæ•°æ®æ˜¯å¦ç¬¦åˆé¢„å®šä¹‰çš„æ ¼å¼å’ŒèŒƒå›´
6. **å”¯ä¸€æ€§ï¼ˆUniquenessï¼‰**ï¼šæ˜¯å¦å­˜åœ¨é‡å¤è®°å½•

#### ç¼ºå¤±å€¼æœºåˆ¶

**ç¼ºå¤±å€¼ç±»å‹**ï¼ˆLittle & Rubinåˆ†ç±»ï¼‰ï¼š

1. **å®Œå…¨éšæœºç¼ºå¤±ï¼ˆMCAR, Missing Completely At Randomï¼‰**ï¼š
   - ç¼ºå¤±ä¸è§‚æµ‹å€¼å’Œæœªè§‚æµ‹å€¼éƒ½æ— å…³
   - åˆ é™¤ç¼ºå¤±å€¼ä¸ä¼šå¼•å…¥åå·®

2. **éšæœºç¼ºå¤±ï¼ˆMAR, Missing At Randomï¼‰**ï¼š
   - ç¼ºå¤±ä¸è§‚æµ‹å€¼ç›¸å…³ï¼Œä½†ä¸æœªè§‚æµ‹å€¼æ— å…³
   - å¯ä»¥ä½¿ç”¨è§‚æµ‹å€¼é¢„æµ‹ç¼ºå¤±å€¼

3. **ééšæœºç¼ºå¤±ï¼ˆMNAR, Missing Not At Randomï¼‰**ï¼š
   - ç¼ºå¤±ä¸æœªè§‚æµ‹å€¼ç›¸å…³
   - æœ€éš¾å¤„ç†ï¼Œå¯èƒ½å¼•å…¥åå·®

#### å¼‚å¸¸å€¼ç†è®º

**å¼‚å¸¸å€¼ï¼ˆOutlierï¼‰å®šä¹‰**ï¼šä¸æ•°æ®é›†ä¸­å…¶ä»–è§‚æµ‹å€¼æ˜¾è‘—ä¸åŒçš„å€¼ã€‚

**å¼‚å¸¸å€¼ç±»å‹**ï¼š

- **ç‚¹å¼‚å¸¸**ï¼šå•ä¸ªæ•°æ®ç‚¹å¼‚å¸¸
- **ä¸Šä¸‹æ–‡å¼‚å¸¸**ï¼šåœ¨ç‰¹å®šä¸Šä¸‹æ–‡ä¸­å¼‚å¸¸
- **é›†ä½“å¼‚å¸¸**ï¼šä¸€ç»„æ•°æ®ç‚¹é›†ä½“å¼‚å¸¸

### æ ¸å¿ƒç®—æ³•

| ç®—æ³• | ç”¨é€” | å¤æ‚åº¦ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|--------|------|------|
| **ç¼ºå¤±å€¼æ£€æµ‹** | è¯†åˆ«ç©ºå€¼ | $O(n)$ | ç®€å•å¿«é€Ÿ | åªèƒ½æ£€æµ‹æ˜¾å¼NULL |
| **IQRå¼‚å¸¸æ£€æµ‹** | è¯†åˆ«ç¦»ç¾¤å€¼ | $O(n \log n)$ | ç¨³å¥ã€ä¸å‡è®¾åˆ†å¸ƒ | åªé€‚ç”¨äºå•å˜é‡ |
| **Z-scoreå¼‚å¸¸æ£€æµ‹** | è¯†åˆ«ç¦»ç¾¤å€¼ | $O(n)$ | å¿«é€Ÿã€æ ‡å‡†åŒ– | å‡è®¾æ­£æ€åˆ†å¸ƒ |
| **é‡å¤æ£€æµ‹ï¼ˆå“ˆå¸Œï¼‰** | è¯†åˆ«é‡å¤è®°å½• | $O(n)$ | å¿«é€Ÿ | å¯èƒ½å“ˆå¸Œå†²çª |
| **é‡å¤æ£€æµ‹ï¼ˆæ’åºï¼‰** | è¯†åˆ«é‡å¤è®°å½• | $O(n \log n)$ | å‡†ç¡® | éœ€è¦æ’åº |
| **ç¼–è¾‘è·ç¦»** | æ¨¡ç³Šé‡å¤æ£€æµ‹ | $O(n^2)$ | å¤„ç†æ‹¼å†™é”™è¯¯ | è®¡ç®—å¤æ‚åº¦é«˜ |

---

## 1. ç¼ºå¤±å€¼å¤„ç†

### 1.1 ç¼ºå¤±å€¼æ£€æµ‹åŸç†

**ç¼ºå¤±å€¼æ£€æµ‹**æ˜¯æ•°æ®æ¸…æ´—çš„ç¬¬ä¸€æ­¥ï¼Œéœ€è¦å‡†ç¡®è¯†åˆ«æ•°æ®ä¸­çš„ç¼ºå¤±å€¼ã€‚

#### ç¼ºå¤±å€¼è¡¨ç¤º

åœ¨PostgreSQLä¸­ï¼Œç¼ºå¤±å€¼é€šå¸¸è¡¨ç¤ºä¸ºï¼š

- **NULL**ï¼šæ˜¾å¼ç¼ºå¤±å€¼
- **ç©ºå­—ç¬¦ä¸²**ï¼šå¯èƒ½è¡¨ç¤ºç¼ºå¤±ï¼ˆéœ€è¦ä¸šåŠ¡åˆ¤æ–­ï¼‰
- **ç‰¹æ®Šå€¼**ï¼šå¦‚-1ã€999ç­‰ï¼ˆéœ€è¦ä¸šåŠ¡è§„åˆ™åˆ¤æ–­ï¼‰

#### ç¼ºå¤±æ¨¡å¼åˆ†æ

**ç¼ºå¤±æ¨¡å¼ï¼ˆMissing Patternï¼‰**ï¼š

- **å•è°ƒç¼ºå¤±**ï¼šå¦‚æœå˜é‡$X_j$ç¼ºå¤±ï¼Œåˆ™$X_{j+1}, ..., X_p$ä¹Ÿç¼ºå¤±
- **ä»»æ„ç¼ºå¤±**ï¼šç¼ºå¤±å€¼éšæœºåˆ†å¸ƒ
- **å—ç¼ºå¤±**ï¼šæŸäº›å˜é‡ç»„åˆç»å¸¸ä¸€èµ·ç¼ºå¤±

### 1.2 ç¼ºå¤±å€¼æ£€æµ‹å®ç°

```sql
-- åˆ›å»ºæµ‹è¯•æ•°æ®è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_quality_test') THEN
            RAISE WARNING 'è¡¨ data_quality_test å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤';
            DROP TABLE data_quality_test CASCADE;
        END IF;

        CREATE TABLE data_quality_test (
            id SERIAL PRIMARY KEY,
            name VARCHAR(100),
            email VARCHAR(100),
            age INTEGER,
            salary NUMERIC(10, 2),
            created_at TIMESTAMP
        );

        INSERT INTO data_quality_test (name, email, age, salary, created_at) VALUES
            ('John Doe', 'john@example.com', 30, 50000.00, '2024-01-01'),
            ('Jane Smith', NULL, 25, 45000.00, '2024-01-02'),
            (NULL, 'bob@example.com', NULL, 60000.00, '2024-01-03'),
            ('Alice Brown', 'alice@example.com', 35, NULL, '2024-01-04'),
            ('Charlie Wilson', 'charlie@example.com', 28, 55000.00, NULL);

        RAISE NOTICE 'è¡¨ data_quality_test åˆ›å»ºæˆåŠŸ';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING 'è¡¨ data_quality_test å·²å­˜åœ¨';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'åˆ›å»ºè¡¨å¤±è´¥: %', SQLERRM;
    END;
END $$;

-- ç¼ºå¤±å€¼æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_quality_test') THEN
            RAISE WARNING 'è¡¨ data_quality_test ä¸å­˜åœ¨ï¼Œæ— æ³•æ£€æµ‹ç¼ºå¤±å€¼';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ£€æµ‹ç¼ºå¤±å€¼';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç¼ºå¤±å€¼æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç»Ÿè®¡å„å­—æ®µçš„ç¼ºå¤±å€¼
SELECT
    'name' AS column_name,
    COUNT(*) AS total_rows,
    COUNT(name) AS non_null_count,
    COUNT(*) - COUNT(name) AS null_count,
    ROUND(((COUNT(*) - COUNT(name))::numeric / COUNT(*) * 100)::numeric, 2) AS null_percentage
FROM data_quality_test
UNION ALL
SELECT
    'email' AS column_name,
    COUNT(*) AS total_rows,
    COUNT(email) AS non_null_count,
    COUNT(*) - COUNT(email) AS null_count,
    ROUND(((COUNT(*) - COUNT(email))::numeric / COUNT(*) * 100)::numeric, 2) AS null_percentage
FROM data_quality_test
UNION ALL
SELECT
    'age' AS column_name,
    COUNT(*) AS total_rows,
    COUNT(age) AS non_null_count,
    COUNT(*) - COUNT(age) AS null_count,
    ROUND(((COUNT(*) - COUNT(age))::numeric / COUNT(*) * 100)::numeric, 2) AS null_percentage
FROM data_quality_test
UNION ALL
SELECT
    'salary' AS column_name,
    COUNT(*) AS total_rows,
    COUNT(salary) AS non_null_count,
    COUNT(*) - COUNT(salary) AS null_count,
    ROUND(((COUNT(*) - COUNT(salary))::numeric / COUNT(*) * 100)::numeric, 2) AS null_percentage
FROM data_quality_test
ORDER BY null_percentage DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) - COUNT(name) AS null_count
FROM data_quality_test;
```

### 1.3 ç¼ºå¤±å€¼å¡«å……æ–¹æ³•

**ç¼ºå¤±å€¼å¡«å……ï¼ˆImputationï¼‰**ä½¿ç”¨åˆç†å€¼å¡«å……ç¼ºå¤±æ•°æ®ï¼Œæœ‰å¤šç§æ–¹æ³•ã€‚

#### å¡«å……æ–¹æ³•åˆ†ç±»

1. **åˆ é™¤æ³•**ï¼š
   - **åˆ—è¡¨åˆ é™¤**ï¼šåˆ é™¤åŒ…å«ç¼ºå¤±å€¼çš„æ•´è¡Œ
   - **æˆå¯¹åˆ é™¤**ï¼šåªåˆ é™¤åˆ†æä¸­æ¶‰åŠçš„ç¼ºå¤±å€¼
   - **ä¼˜ç‚¹**ï¼šç®€å•ã€æ— åå·®ï¼ˆMCARæ—¶ï¼‰
   - **ç¼ºç‚¹**ï¼šä¸¢å¤±ä¿¡æ¯ã€æ ·æœ¬é‡å‡å°‘

2. **å•å€¼å¡«å……**ï¼š
   - **å‡å€¼/ä¸­ä½æ•°/ä¼—æ•°å¡«å……**ï¼šä½¿ç”¨ç»Ÿè®¡é‡å¡«å……
   - **å‰å‘å¡«å……/åå‘å¡«å……**ï¼šä½¿ç”¨å‰ä¸€ä¸ª/åä¸€ä¸ªå€¼å¡«å……
   - **å¸¸æ•°å¡«å……**ï¼šä½¿ç”¨å›ºå®šå€¼å¡«å……
   - **ä¼˜ç‚¹**ï¼šç®€å•ã€å¿«é€Ÿ
   - **ç¼ºç‚¹**ï¼šå¯èƒ½å¼•å…¥åå·®ã€ä½ä¼°æ–¹å·®

3. **æ’å€¼æ³•**ï¼š
   - **çº¿æ€§æ’å€¼**ï¼šä½¿ç”¨çº¿æ€§å‡½æ•°æ’å€¼
   - **æ ·æ¡æ’å€¼**ï¼šä½¿ç”¨æ ·æ¡å‡½æ•°æ’å€¼
   - **ä¼˜ç‚¹**ï¼šä¿æŒæ•°æ®è¶‹åŠ¿
   - **ç¼ºç‚¹**ï¼šå‡è®¾æ•°æ®è¿ç»­

4. **æ¨¡å‹å¡«å……**ï¼š
   - **å›å½’å¡«å……**ï¼šä½¿ç”¨å›å½’æ¨¡å‹é¢„æµ‹
   - **KNNå¡«å……**ï¼šä½¿ç”¨Kè¿‘é‚»å¡«å……
   - **ä¼˜ç‚¹**ï¼šè€ƒè™‘å˜é‡å…³ç³»
   - **ç¼ºç‚¹**ï¼šè®¡ç®—å¤æ‚ã€å¯èƒ½è¿‡æ‹Ÿåˆ

#### å¡«å……æ–¹æ³•é€‰æ‹©

| æ•°æ®ç±»å‹ | æ¨èæ–¹æ³• | åŸå›  |
|---------|---------|------|
| **è¿ç»­æ•°å€¼** | å‡å€¼/ä¸­ä½æ•° | ä¿æŒä¸­å¿ƒè¶‹åŠ¿ |
| **åˆ†ç±»æ•°æ®** | ä¼—æ•° | æœ€å¸¸è§å€¼ |
| **æ—¶é—´åºåˆ—** | å‰å‘/åå‘å¡«å…… | ä¿æŒæ—¶é—´è¿ç»­æ€§ |
| **æœ‰åºæ•°æ®** | ä¸­ä½æ•° | ç¨³å¥æ€§ |
| **æœ‰ç›¸å…³æ€§** | å›å½’/KNN | åˆ©ç”¨å˜é‡å…³ç³» |

### 1.4 ç¼ºå¤±å€¼å¡«å……å®ç°

```sql
-- ç¼ºå¤±å€¼å¡«å……ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_quality_test') THEN
            RAISE WARNING 'è¡¨ data_quality_test ä¸å­˜åœ¨ï¼Œæ— æ³•å¡«å……ç¼ºå¤±å€¼';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹å¡«å……ç¼ºå¤±å€¼';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç¼ºå¤±å€¼å¡«å……å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨å‡å€¼å¡«å……æ•°å€¼å­—æ®µ
WITH filled_data AS (
    SELECT
        id,
        COALESCE(name, 'Unknown') AS name,
        COALESCE(email, 'noemail@example.com') AS email,
        COALESCE(age, (SELECT ROUND(AVG(age)) FROM data_quality_test WHERE age IS NOT NULL)) AS age,
        COALESCE(salary, (SELECT AVG(salary) FROM data_quality_test WHERE salary IS NOT NULL)) AS salary,
        COALESCE(created_at, NOW()) AS created_at
    FROM data_quality_test
)
SELECT
    id,
    name,
    email,
    age,
    ROUND(salary::numeric, 2) AS salary,
    created_at
FROM filled_data
ORDER BY id;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COALESCE(age, (SELECT AVG(age) FROM data_quality_test WHERE age IS NOT NULL)) AS age
FROM data_quality_test;
```

---

## 2. å¼‚å¸¸å€¼å¤„ç†

### 2.1 å¼‚å¸¸å€¼æ£€æµ‹åŸç†

**å¼‚å¸¸å€¼æ£€æµ‹ï¼ˆOutlier Detectionï¼‰**ä½¿ç”¨ç»Ÿè®¡æ–¹æ³•è¯†åˆ«ä¸æ•°æ®é›†ä¸­å…¶ä»–è§‚æµ‹å€¼æ˜¾è‘—ä¸åŒçš„å€¼ã€‚

#### å¼‚å¸¸å€¼æ£€æµ‹æ–¹æ³•

1. **åŸºäºç»Ÿè®¡çš„æ–¹æ³•**ï¼š
   - **Z-scoreæ–¹æ³•**ï¼š$z = \frac{x - \mu}{\sigma}$ï¼Œé€šå¸¸$|z| > 3$ä¸ºå¼‚å¸¸
   - **IQRæ–¹æ³•**ï¼šä½¿ç”¨å››åˆ†ä½è·ï¼Œ$x < Q_1 - 1.5 \times IQR$ æˆ– $x > Q_3 + 1.5 \times IQR$
   - **Grubbsæ£€éªŒ**ï¼šå‡è®¾æ£€éªŒæ–¹æ³•

2. **åŸºäºè·ç¦»çš„æ–¹æ³•**ï¼š
   - **KNNè·ç¦»**ï¼šè®¡ç®—åˆ°Kè¿‘é‚»çš„è·ç¦»
   - **å±€éƒ¨å¼‚å¸¸å› å­ï¼ˆLOFï¼‰**ï¼šç›¸å¯¹å¯†åº¦æ–¹æ³•

3. **åŸºäºå¯†åº¦çš„æ–¹æ³•**ï¼š
   - **DBSCAN**ï¼šåŸºäºå¯†åº¦çš„èšç±»
   - **Isolation Forest**ï¼šéš”ç¦»æ£®æ—

#### IQRæ–¹æ³•è¯¦è§£

**å››åˆ†ä½è·ï¼ˆIQRï¼‰**ï¼š
$$IQR = Q_3 - Q_1$$

**å¼‚å¸¸å€¼è¾¹ç•Œ**ï¼š

- **ä¸‹ç•Œ**ï¼š$Q_1 - 1.5 \times IQR$
- **ä¸Šç•Œ**ï¼š$Q_3 + 1.5 \times IQR$

**æç«¯å¼‚å¸¸å€¼è¾¹ç•Œ**ï¼ˆå¯é€‰ï¼‰ï¼š

- **ä¸‹ç•Œ**ï¼š$Q_1 - 3 \times IQR$
- **ä¸Šç•Œ**ï¼š$Q_3 + 3 \times IQR$

#### Z-scoreæ–¹æ³•è¯¦è§£

**Z-scoreæ ‡å‡†åŒ–**ï¼š
$$z = \frac{x - \mu}{\sigma}$$

**å¼‚å¸¸å€¼åˆ¤æ–­**ï¼š

- **æ¸©å’Œå¼‚å¸¸å€¼**ï¼š$|z| > 2$
- **æç«¯å¼‚å¸¸å€¼**ï¼š$|z| > 3$

**æ³¨æ„**ï¼šZ-scoreæ–¹æ³•å‡è®¾æ•°æ®è¿‘ä¼¼æ­£æ€åˆ†å¸ƒã€‚

### 2.2 å¼‚å¸¸å€¼æ£€æµ‹å®ç°

```sql
-- å¼‚å¸¸å€¼æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_quality_test') THEN
            RAISE WARNING 'è¡¨ data_quality_test ä¸å­˜åœ¨ï¼Œæ— æ³•æ£€æµ‹å¼‚å¸¸å€¼';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ£€æµ‹å¼‚å¸¸å€¼';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¼‚å¸¸å€¼æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ä½¿ç”¨IQRæ–¹æ³•æ£€æµ‹å¼‚å¸¸å€¼
WITH salary_stats AS (
    SELECT
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) AS q3,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS median,
        AVG(salary) AS mean,
        STDDEV(salary) AS stddev
    FROM data_quality_test
    WHERE salary IS NOT NULL
),
outlier_detection AS (
    SELECT
        dqt.id,
        dqt.salary,
        ss.mean,
        ss.median,
        ss.q1,
        ss.q3,
        ss.q3 - ss.q1 AS iqr,
        ss.q1 - 1.5 * (ss.q3 - ss.q1) AS lower_bound,
        ss.q3 + 1.5 * (ss.q3 - ss.q1) AS upper_bound,
        CASE
            WHEN dqt.salary < ss.q1 - 1.5 * (ss.q3 - ss.q1) THEN 'Lower Outlier'
            WHEN dqt.salary > ss.q3 + 1.5 * (ss.q3 - ss.q1) THEN 'Upper Outlier'
            ELSE 'Normal'
        END AS outlier_status
    FROM data_quality_test dqt
    CROSS JOIN salary_stats ss
    WHERE dqt.salary IS NOT NULL
)
SELECT
    id,
    ROUND(salary::numeric, 2) AS salary,
    ROUND(mean::numeric, 2) AS mean,
    ROUND(median::numeric, 2) AS median,
    ROUND(lower_bound::numeric, 2) AS lower_bound,
    ROUND(upper_bound::numeric, 2) AS upper_bound,
    outlier_status
FROM outlier_detection
ORDER BY salary DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) AS q3
FROM data_quality_test
WHERE salary IS NOT NULL;
```

---

## 3. é‡å¤æ•°æ®å¤„ç†

### 3.1 é‡å¤æ•°æ®æ£€æµ‹åŸç†

**é‡å¤æ•°æ®æ£€æµ‹ï¼ˆDuplicate Detectionï¼‰**è¯†åˆ«æ•°æ®é›†ä¸­é‡å¤æˆ–è¿‘ä¼¼é‡å¤çš„è®°å½•ã€‚

#### é‡å¤ç±»å‹

1. **å®Œå…¨é‡å¤**ï¼šæ‰€æœ‰å­—æ®µå®Œå…¨ç›¸åŒ
2. **éƒ¨åˆ†é‡å¤**ï¼šå…³é”®å­—æ®µç›¸åŒï¼ˆå¦‚emailã€èº«ä»½è¯å·ï¼‰
3. **è¿‘ä¼¼é‡å¤**ï¼šç”±äºæ‹¼å†™é”™è¯¯ã€æ ¼å¼å·®å¼‚å¯¼è‡´çš„é‡å¤

#### æ£€æµ‹æ–¹æ³•

1. **ç²¾ç¡®åŒ¹é…**ï¼š
   - **å“ˆå¸Œæ–¹æ³•**ï¼šè®¡ç®—è®°å½•å“ˆå¸Œå€¼
   - **æ’åºæ–¹æ³•**ï¼šæ’åºåæ¯”è¾ƒç›¸é‚»è®°å½•
   - **å¤æ‚åº¦**ï¼š$O(n)$ï¼ˆå“ˆå¸Œï¼‰æˆ– $O(n \log n)$ï¼ˆæ’åºï¼‰

2. **æ¨¡ç³ŠåŒ¹é…**ï¼š
   - **ç¼–è¾‘è·ç¦»ï¼ˆLevenshteinï¼‰**ï¼šè®¡ç®—å­—ç¬¦ä¸²ç›¸ä¼¼åº¦
   - **Jaccardç›¸ä¼¼åº¦**ï¼šé›†åˆç›¸ä¼¼åº¦
   - **ä½™å¼¦ç›¸ä¼¼åº¦**ï¼šå‘é‡ç›¸ä¼¼åº¦
   - **å¤æ‚åº¦**ï¼š$O(n^2)$ æˆ–æ›´é«˜

#### ç¼–è¾‘è·ç¦»

**Levenshteinè·ç¦»**ï¼šå°†ä¸€ä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸ºå¦ä¸€ä¸ªå­—ç¬¦ä¸²æ‰€éœ€çš„æœ€å°‘å•å­—ç¬¦ç¼–è¾‘æ“ä½œæ•°ã€‚

**æ“ä½œ**ï¼š

- **æ’å…¥**ï¼šæ’å…¥ä¸€ä¸ªå­—ç¬¦
- **åˆ é™¤**ï¼šåˆ é™¤ä¸€ä¸ªå­—ç¬¦
- **æ›¿æ¢**ï¼šæ›¿æ¢ä¸€ä¸ªå­—ç¬¦

**åŠ¨æ€è§„åˆ’ç®—æ³•**ï¼š

$$
d[i][j] = \begin{cases}
\max(i, j) & \text{if } \min(i, j) = 0 \\
\min\begin{cases}
d[i-1][j] + 1 \\
d[i][j-1] + 1 \\
d[i-1][j-1] + (s1[i] \neq s2[j])
\end{cases} & \text{otherwise}
\end{cases}
$$

### 3.2 é‡å¤æ•°æ®æ£€æµ‹å®ç°

```sql
-- é‡å¤æ•°æ®æ£€æµ‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_quality_test') THEN
            RAISE WARNING 'è¡¨ data_quality_test ä¸å­˜åœ¨ï¼Œæ— æ³•æ£€æµ‹é‡å¤æ•°æ®';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹æ£€æµ‹é‡å¤æ•°æ®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'é‡å¤æ•°æ®æ£€æµ‹å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ£€æµ‹åŸºäºemailçš„é‡å¤è®°å½•
WITH duplicate_emails AS (
    SELECT
        email,
        COUNT(*) AS duplicate_count,
        ARRAY_AGG(id ORDER BY id) AS duplicate_ids
    FROM data_quality_test
    WHERE email IS NOT NULL
    GROUP BY email
    HAVING COUNT(*) > 1
)
SELECT
    email,
    duplicate_count,
    duplicate_ids,
    'Duplicate email addresses found' AS issue_description
FROM duplicate_emails
ORDER BY duplicate_count DESC;

-- æ£€æµ‹å®Œå…¨é‡å¤çš„è®°å½•
WITH row_hashes AS (
    SELECT
        id,
        MD5(COALESCE(name, '') || COALESCE(email, '') || COALESCE(age::text, '') || COALESCE(salary::text, '')) AS row_hash
    FROM data_quality_test
),
duplicate_rows AS (
    SELECT
        row_hash,
        COUNT(*) AS duplicate_count,
        ARRAY_AGG(id ORDER BY id) AS duplicate_ids
    FROM row_hashes
    GROUP BY row_hash
    HAVING COUNT(*) > 1
)
SELECT
    row_hash,
    duplicate_count,
    duplicate_ids,
    'Duplicate rows found' AS issue_description
FROM duplicate_rows
ORDER BY duplicate_count DESC;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    email,
    COUNT(*) AS duplicate_count
FROM data_quality_test
WHERE email IS NOT NULL
GROUP BY email
HAVING COUNT(*) > 1;
```

---

## 4. æ•°æ®æ ¼å¼æ ‡å‡†åŒ–

### 4.1 æ ¼å¼ç»Ÿä¸€

**æ•°æ®æ ¼å¼æ ‡å‡†åŒ–**ç»Ÿä¸€æ•°æ®æ ¼å¼ï¼Œæé«˜æ•°æ®ä¸€è‡´æ€§ã€‚

```sql
-- æ•°æ®æ ¼å¼æ ‡å‡†åŒ–ï¼šç»Ÿä¸€ç”µè¯å·ç ã€é‚®ç®±ã€æ—¥æœŸæ ¼å¼
WITH raw_data AS (
    SELECT
        id,
        phone,
        email,
        date_string
    FROM customer_data
),
formatted_data AS (
    SELECT
        id,
        -- ç”µè¯å·ç æ ‡å‡†åŒ–ï¼šç§»é™¤ç©ºæ ¼ã€æ‹¬å·ã€è¿å­—ç¬¦
        REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(phone, '[-\s()]', '', 'g'), '^\+', ''), '^0', '') AS standardized_phone,
        -- é‚®ç®±æ ‡å‡†åŒ–ï¼šè½¬å°å†™ã€å»é™¤ç©ºæ ¼
        LOWER(TRIM(email)) AS standardized_email,
        -- æ—¥æœŸæ ¼å¼æ ‡å‡†åŒ–
        CASE
            WHEN date_string ~ '^\d{4}-\d{2}-\d{2}$' THEN date_string::DATE
            WHEN date_string ~ '^\d{2}/\d{2}/\d{4}$' THEN TO_DATE(date_string, 'MM/DD/YYYY')
            WHEN date_string ~ '^\d{2}-\d{2}-\d{4}$' THEN TO_DATE(date_string, 'DD-MM-YYYY')
            ELSE NULL
        END AS standardized_date
    FROM raw_data
)
SELECT
    id,
    standardized_phone,
    standardized_email,
    standardized_date
FROM formatted_data;
```

### 4.2 æ•°æ®ç±»å‹è½¬æ¢

**æ•°æ®ç±»å‹è½¬æ¢**ç¡®ä¿æ•°æ®ç±»å‹æ­£ç¡®ï¼Œä¾¿äºåç»­å¤„ç†ã€‚

```sql
-- æ•°æ®ç±»å‹è½¬æ¢å’ŒéªŒè¯
WITH type_conversion AS (
    SELECT
        id,
        -- å­—ç¬¦ä¸²è½¬æ•°å€¼ï¼ˆå¤„ç†éæ•°å­—å­—ç¬¦ï¼‰
        CASE
            WHEN value_string ~ '^-?\d+\.?\d*$' THEN value_string::NUMERIC
            ELSE NULL
        END AS numeric_value,
        -- å­—ç¬¦ä¸²è½¬æ—¥æœŸ
        CASE
            WHEN date_string ~ '^\d{4}-\d{2}-\d{2}$' THEN date_string::DATE
            ELSE NULL
        END AS date_value,
        -- å¸ƒå°”å€¼æ ‡å‡†åŒ–
        CASE
            WHEN UPPER(bool_string) IN ('TRUE', '1', 'YES', 'Y') THEN TRUE
            WHEN UPPER(bool_string) IN ('FALSE', '0', 'NO', 'N') THEN FALSE
            ELSE NULL
        END AS bool_value
    FROM raw_data
)
SELECT * FROM type_conversion;
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 ç»¼åˆæ•°æ®æ¸…æ´—

**ç»¼åˆæ•°æ®æ¸…æ´—**æ•´åˆå¤šç§æ¸…æ´—æ–¹æ³•ï¼Œå…¨é¢æå‡æ•°æ®è´¨é‡ã€‚

```sql
-- ç»¼åˆæ•°æ®æ¸…æ´—ç¤ºä¾‹ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_quality_test') THEN
            RAISE WARNING 'è¡¨ data_quality_test ä¸å­˜åœ¨ï¼Œæ— æ³•è¿›è¡Œç»¼åˆæ•°æ®æ¸…æ´—';
            RETURN;
        END IF;
        RAISE NOTICE 'å¼€å§‹è¿›è¡Œç»¼åˆæ•°æ®æ¸…æ´—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'ç»¼åˆæ•°æ®æ¸…æ´—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- ç»¼åˆæ•°æ®è´¨é‡æŠ¥å‘Š
WITH quality_metrics AS (
    SELECT
        COUNT(*) AS total_rows,
        COUNT(name) AS name_filled,
        COUNT(email) AS email_filled,
        COUNT(age) AS age_filled,
        COUNT(salary) AS salary_filled,
        COUNT(DISTINCT email) FILTER (WHERE email IS NOT NULL) AS unique_emails,
        COUNT(*) FILTER (WHERE email IS NOT NULL) AS total_emails
    FROM data_quality_test
),
salary_stats AS (
    SELECT
        AVG(salary) AS avg_salary,
        STDDEV(salary) AS stddev_salary,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) AS q3
    FROM data_quality_test
    WHERE salary IS NOT NULL
),
outlier_count AS (
    SELECT
        COUNT(*) AS outlier_rows
    FROM data_quality_test dqt
    CROSS JOIN salary_stats ss
    WHERE dqt.salary IS NOT NULL
        AND (dqt.salary < ss.q1 - 1.5 * (ss.q3 - ss.q1) OR dqt.salary > ss.q3 + 1.5 * (ss.q3 - ss.q1))
)
SELECT
    qm.total_rows,
    ROUND((qm.name_filled::numeric / qm.total_rows * 100)::numeric, 2) AS name_completeness_pct,
    ROUND((qm.email_filled::numeric / qm.total_rows * 100)::numeric, 2) AS email_completeness_pct,
    ROUND((qm.age_filled::numeric / qm.total_rows * 100)::numeric, 2) AS age_completeness_pct,
    ROUND((qm.salary_filled::numeric / qm.total_rows * 100)::numeric, 2) AS salary_completeness_pct,
    qm.total_emails - qm.unique_emails AS duplicate_emails,
    oc.outlier_rows,
    CASE
        WHEN (qm.name_filled::numeric / qm.total_rows) < 0.9 THEN 'Low'
        WHEN (qm.email_filled::numeric / qm.total_rows) < 0.9 THEN 'Low'
        WHEN oc.outlier_rows > qm.total_rows * 0.1 THEN 'Low'
        ELSE 'High'
    END AS overall_quality
FROM quality_metrics qm
CROSS JOIN outlier_count oc;

-- æ€§èƒ½æµ‹è¯•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    COUNT(*) AS total_rows,
    COUNT(name) AS name_filled
FROM data_quality_test;
```

### 5.2 å®¢æˆ·æ•°æ®æ¸…æ´—

**åœºæ™¯**ï¼šæ¸…æ´—å®¢æˆ·æ•°æ®ï¼Œç»Ÿä¸€æ ¼å¼ï¼Œå»é™¤é‡å¤ï¼Œå¡«å……ç¼ºå¤±å€¼ã€‚

```sql
-- å®¢æˆ·æ•°æ®æ¸…æ´—ï¼šç»¼åˆå¤„ç†
WITH customer_raw AS (
    SELECT
        customer_id,
        name,
        email,
        phone,
        address,
        registration_date,
        last_purchase_date
    FROM raw_customer_data
),
-- æ­¥éª¤1ï¼šæ ¼å¼æ ‡å‡†åŒ–
formatted_customers AS (
    SELECT
        customer_id,
        -- å§“åæ ‡å‡†åŒ–ï¼šå»é™¤å¤šä½™ç©ºæ ¼ã€é¦–å­—æ¯å¤§å†™
        INITCAP(REGEXP_REPLACE(TRIM(name), '\s+', ' ', 'g')) AS standardized_name,
        -- é‚®ç®±æ ‡å‡†åŒ–ï¼šè½¬å°å†™ã€å»é™¤ç©ºæ ¼
        LOWER(TRIM(email)) AS standardized_email,
        -- ç”µè¯æ ‡å‡†åŒ–ï¼šç»Ÿä¸€æ ¼å¼
        REGEXP_REPLACE(REGEXP_REPLACE(phone, '[-\s()]', '', 'g'), '^\+', '') AS standardized_phone,
        -- åœ°å€æ ‡å‡†åŒ–ï¼šå»é™¤å¤šä½™ç©ºæ ¼
        REGEXP_REPLACE(TRIM(address), '\s+', ' ', 'g') AS standardized_address,
        registration_date,
        last_purchase_date
    FROM customer_raw
),
-- æ­¥éª¤2ï¼šç¼ºå¤±å€¼å¡«å……
filled_customers AS (
    SELECT
        customer_id,
        COALESCE(standardized_name, 'Unknown') AS name,
        COALESCE(standardized_email, 'noemail@unknown.com') AS email,
        COALESCE(standardized_phone, '0000000000') AS phone,
        COALESCE(standardized_address, 'Unknown Address') AS address,
        COALESCE(registration_date, CURRENT_DATE) AS registration_date,
        last_purchase_date
    FROM formatted_customers
),
-- æ­¥éª¤3ï¼šé‡å¤æ£€æµ‹
duplicate_analysis AS (
    SELECT
        email,
        COUNT(*) AS duplicate_count,
        ARRAY_AGG(customer_id ORDER BY registration_date) AS customer_ids,
        MIN(registration_date) AS earliest_registration
    FROM filled_customers
    WHERE email != 'noemail@unknown.com'
    GROUP BY email
    HAVING COUNT(*) > 1
),
-- æ­¥éª¤4ï¼šå¼‚å¸¸å€¼æ£€æµ‹ï¼ˆæ³¨å†Œæ—¥æœŸå¼‚å¸¸ï¼‰
outlier_dates AS (
    SELECT
        customer_id,
        registration_date,
        CASE
            WHEN registration_date > CURRENT_DATE THEN 'Future date'
            WHEN registration_date < '1900-01-01' THEN 'Too old'
            WHEN registration_date > last_purchase_date THEN 'Registration after purchase'
            ELSE 'Normal'
        END AS date_anomaly
    FROM filled_customers
    WHERE registration_date IS NOT NULL
),
-- æ­¥éª¤5ï¼šæ¸…æ´—åçš„æ•°æ®
cleaned_customers AS (
    SELECT
        fc.customer_id,
        fc.name,
        fc.email,
        fc.phone,
        fc.address,
        fc.registration_date,
        fc.last_purchase_date,
        CASE
            WHEN da.email IN (SELECT email FROM duplicate_analysis) THEN 'Duplicate'
            WHEN od.date_anomaly != 'Normal' THEN 'Date anomaly'
            ELSE 'Clean'
        END AS data_quality_status
    FROM filled_customers fc
    LEFT JOIN duplicate_analysis da ON fc.email = da.email
    LEFT JOIN outlier_dates od ON fc.customer_id = od.customer_id
)
SELECT
    customer_id,
    name,
    email,
    phone,
    registration_date,
    data_quality_status
FROM cleaned_customers
ORDER BY customer_id;
```

### 5.3 é”€å”®æ•°æ®æ¸…æ´—

**åœºæ™¯**ï¼šæ¸…æ´—é”€å”®æ•°æ®ï¼Œæ£€æµ‹å¼‚å¸¸è®¢å•ï¼Œç»Ÿä¸€é‡‘é¢æ ¼å¼ã€‚

```sql
-- é”€å”®æ•°æ®æ¸…æ´—ï¼šæ£€æµ‹å¼‚å¸¸è®¢å•å’Œæ ¼å¼é—®é¢˜
WITH sales_raw AS (
    SELECT
        order_id,
        customer_id,
        order_date,
        order_amount,
        product_count,
        discount_rate,
        payment_method
    FROM raw_sales_data
    WHERE order_date >= CURRENT_DATE - INTERVAL '90 days'
),
-- é‡‘é¢å¼‚å¸¸æ£€æµ‹
amount_outliers AS (
    SELECT
        order_id,
        order_amount,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY order_amount) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY order_amount) AS q3,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY order_amount) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY order_amount) AS iqr
    FROM sales_raw
    GROUP BY order_id, order_amount
),
-- æ•°æ®è´¨é‡æ£€æŸ¥
quality_checks AS (
    SELECT
        sr.order_id,
        sr.customer_id,
        sr.order_date,
        sr.order_amount,
        sr.product_count,
        sr.discount_rate,
        sr.payment_method,
        -- é‡‘é¢å¼‚å¸¸
        CASE
            WHEN sr.order_amount < ao.q1 - 1.5 * ao.iqr OR
                 sr.order_amount > ao.q3 + 1.5 * ao.iqr THEN 'Amount outlier'
            WHEN sr.order_amount <= 0 THEN 'Invalid amount'
            WHEN sr.order_amount > 1000000 THEN 'Suspiciously large'
            ELSE 'Normal'
        END AS amount_status,
        -- äº§å“æ•°é‡å¼‚å¸¸
        CASE
            WHEN sr.product_count <= 0 THEN 'Invalid count'
            WHEN sr.product_count > 1000 THEN 'Suspiciously large'
            ELSE 'Normal'
        END AS count_status,
        -- æŠ˜æ‰£ç‡å¼‚å¸¸
        CASE
            WHEN sr.discount_rate < 0 OR sr.discount_rate > 1 THEN 'Invalid discount'
            WHEN sr.discount_rate > 0.9 THEN 'Suspicious discount'
            ELSE 'Normal'
        END AS discount_status,
        -- æ—¥æœŸå¼‚å¸¸
        CASE
            WHEN sr.order_date > CURRENT_DATE THEN 'Future date'
            WHEN sr.order_date < CURRENT_DATE - INTERVAL '10 years' THEN 'Too old'
            ELSE 'Normal'
        END AS date_status
    FROM sales_raw sr
    LEFT JOIN amount_outliers ao ON sr.order_id = ao.order_id
),
-- ç»¼åˆè´¨é‡è¯„ä¼°
quality_summary AS (
    SELECT
        order_id,
        customer_id,
        order_date,
        order_amount,
        product_count,
        amount_status,
        count_status,
        discount_status,
        date_status,
        CASE
            WHEN amount_status != 'Normal' OR count_status != 'Normal' OR
                 discount_status != 'Normal' OR date_status != 'Normal' THEN 'Needs review'
            ELSE 'Clean'
        END AS overall_status
    FROM quality_checks
)
SELECT
    order_id,
    customer_id,
    order_date,
    ROUND(order_amount::numeric, 2) AS order_amount,
    product_count,
    overall_status,
    ARRAY_REMOVE(ARRAY[
        CASE WHEN amount_status != 'Normal' THEN amount_status END,
        CASE WHEN count_status != 'Normal' THEN count_status END,
        CASE WHEN discount_status != 'Normal' THEN discount_status END,
        CASE WHEN date_status != 'Normal' THEN date_status END
    ], NULL) AS issues
FROM quality_summary
WHERE overall_status = 'Needs review'
ORDER BY order_date DESC;
```

### 5.4 æ–‡æœ¬æ•°æ®æ¸…æ´—

**åœºæ™¯**ï¼šæ¸…æ´—æ–‡æœ¬æ•°æ®ï¼Œå»é™¤å™ªå£°ï¼Œæ ‡å‡†åŒ–æ ¼å¼ã€‚

```sql
-- æ–‡æœ¬æ•°æ®æ¸…æ´—ï¼šå»é™¤å™ªå£°ã€æ ‡å‡†åŒ–æ ¼å¼
WITH text_data AS (
    SELECT
        id,
        raw_text,
        description
    FROM product_descriptions
),
cleaned_text AS (
    SELECT
        id,
        raw_text,
        -- å»é™¤å¤šä½™ç©ºæ ¼
        REGEXP_REPLACE(raw_text, '\s+', ' ', 'g') AS cleaned_spaces,
        -- å»é™¤ç‰¹æ®Šå­—ç¬¦ï¼ˆä¿ç•™å­—æ¯ã€æ•°å­—ã€åŸºæœ¬æ ‡ç‚¹ï¼‰
        REGEXP_REPLACE(raw_text, '[^\w\s.,!?-]', '', 'g') AS cleaned_special,
        -- å»é™¤HTMLæ ‡ç­¾
        REGEXP_REPLACE(raw_text, '<[^>]+>', '', 'g') AS cleaned_html,
        -- å»é™¤URL
        REGEXP_REPLACE(raw_text, 'https?://\S+', '', 'g') AS cleaned_urls,
        -- å»é™¤é‚®ç®±åœ°å€
        REGEXP_REPLACE(raw_text, '\S+@\S+', '', 'g') AS cleaned_emails,
        -- æ ‡å‡†åŒ–å¤§å°å†™ï¼ˆé¦–å­—æ¯å¤§å†™ï¼‰
        INITCAP(raw_text) AS capitalized_text,
        -- å»é™¤å‰åç©ºæ ¼
        TRIM(raw_text) AS trimmed_text
    FROM text_data
),
-- ç»¼åˆæ¸…æ´—
fully_cleaned AS (
    SELECT
        id,
        raw_text AS original_text,
        TRIM(REGEXP_REPLACE(
            REGEXP_REPLACE(
                REGEXP_REPLACE(
                    REGEXP_REPLACE(raw_text, '<[^>]+>', '', 'g'),
                    'https?://\S+', '', 'g'
                ),
                '\S+@\S+', '', 'g'
            ),
            '\s+', ' ', 'g'
        )) AS cleaned_text,
        LENGTH(raw_text) AS original_length,
        LENGTH(TRIM(REGEXP_REPLACE(
            REGEXP_REPLACE(
                REGEXP_REPLACE(
                    REGEXP_REPLACE(raw_text, '<[^>]+>', '', 'g'),
                    'https?://\S+', '', 'g'
                ),
                '\S+@\S+', '', 'g'
            ),
            '\s+', ' ', 'g'
        ))) AS cleaned_length
    FROM text_data
)
SELECT
    id,
    LEFT(original_text, 50) AS original_preview,
    LEFT(cleaned_text, 50) AS cleaned_preview,
    original_length,
    cleaned_length,
    original_length - cleaned_length AS removed_chars
FROM fully_cleaned
WHERE original_length != cleaned_length
ORDER BY removed_chars DESC;
```

### 5.5 æ•°æ®è´¨é‡ç›‘æ§

**åœºæ™¯**ï¼šå»ºç«‹æ•°æ®è´¨é‡ç›‘æ§ç³»ç»Ÿï¼ŒæŒç»­è·Ÿè¸ªæ•°æ®è´¨é‡æŒ‡æ ‡ã€‚

```sql
-- æ•°æ®è´¨é‡ç›‘æ§ï¼šæŒç»­è·Ÿè¸ªè´¨é‡æŒ‡æ ‡
WITH quality_metrics AS (
    SELECT
        DATE_TRUNC('day', created_at) AS check_date,
        -- å®Œæ•´æ€§æŒ‡æ ‡
        COUNT(*) AS total_records,
        COUNT(name) AS name_filled,
        COUNT(email) AS email_filled,
        COUNT(phone) AS phone_filled,
        -- å‡†ç¡®æ€§æŒ‡æ ‡ï¼ˆç¤ºä¾‹ï¼šé‚®ç®±æ ¼å¼éªŒè¯ï¼‰
        COUNT(*) FILTER (WHERE email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$') AS valid_emails,
        -- å”¯ä¸€æ€§æŒ‡æ ‡
        COUNT(DISTINCT email) FILTER (WHERE email IS NOT NULL) AS unique_emails,
        COUNT(*) FILTER (WHERE email IS NOT NULL) AS total_emails,
        -- æ—¶æ•ˆæ€§æŒ‡æ ‡ï¼ˆæœ€è¿‘7å¤©æ›´æ–°çš„è®°å½•ï¼‰
        COUNT(*) FILTER (WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days') AS recent_updates
    FROM customer_data
    WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY DATE_TRUNC('day', created_at)
),
quality_scores AS (
    SELECT
        check_date,
        total_records,
        -- å®Œæ•´æ€§å¾—åˆ†
        ROUND((name_filled + email_filled + phone_filled)::numeric / (total_records * 3) * 100, 2) AS completeness_score,
        -- å‡†ç¡®æ€§å¾—åˆ†
        ROUND(valid_emails::numeric / NULLIF(total_emails, 0) * 100, 2) AS accuracy_score,
        -- å”¯ä¸€æ€§å¾—åˆ†
        ROUND(unique_emails::numeric / NULLIF(total_emails, 0) * 100, 2) AS uniqueness_score,
        -- æ—¶æ•ˆæ€§å¾—åˆ†
        ROUND(recent_updates::numeric / NULLIF(total_records, 0) * 100, 2) AS timeliness_score,
        -- ç»¼åˆå¾—åˆ†
        ROUND((
            (name_filled + email_filled + phone_filled)::numeric / (total_records * 3) * 0.3 +
            valid_emails::numeric / NULLIF(total_emails, 0) * 0.3 +
            unique_emails::numeric / NULLIF(total_emails, 0) * 0.2 +
            recent_updates::numeric / NULLIF(total_records, 0) * 0.2
        ) * 100, 2) AS overall_quality_score
    FROM quality_metrics
)
SELECT
    check_date,
    total_records,
    ROUND(completeness_score::numeric, 2) AS completeness_pct,
    ROUND(accuracy_score::numeric, 2) AS accuracy_pct,
    ROUND(uniqueness_score::numeric, 2) AS uniqueness_pct,
    ROUND(timeliness_score::numeric, 2) AS timeliness_pct,
    ROUND(overall_quality_score::numeric, 2) AS overall_score,
    CASE
        WHEN overall_quality_score >= 90 THEN 'Excellent'
        WHEN overall_quality_score >= 80 THEN 'Good'
        WHEN overall_quality_score >= 70 THEN 'Fair'
        ELSE 'Poor'
    END AS quality_grade
FROM quality_scores
ORDER BY check_date DESC;
```

---

## 6. PostgreSQL 18å¹¶è¡Œæ•°æ®æ¸…æ´—

### 6.1 å¹¶è¡Œæ•°æ®æ¸…æ´—æ¦‚è¿°

**PostgreSQL 18å¹¶è¡Œæ•°æ®æ¸…æ´—**ï¼šåˆ©ç”¨PostgreSQL 18çš„å¹¶è¡ŒæŸ¥è¯¢èƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¤§è§„æ¨¡æ•°æ®æ¸…æ´—çš„æ€§èƒ½ã€‚

#### å¹¶è¡Œæ•°æ®æ¸…æ´—é…ç½®

```sql
-- é…ç½®å¹¶è¡Œæ•°æ®æ¸…æ´—å‚æ•°ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- è®¾ç½®å¹¶è¡Œå·¥ä½œè¿›ç¨‹æ•°
        SET max_parallel_workers_per_gather = 4;

        -- è®¾ç½®å¹¶è¡Œè¡¨æ‰«æé˜ˆå€¼
        SET min_parallel_table_scan_size = '8MB';

        -- è®¾ç½®å¹¶è¡Œèšåˆæˆæœ¬é˜ˆå€¼
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¹¶è¡Œæ•°æ®æ¸…æ´—å‚æ•°å·²é…ç½®';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ•°æ®æ¸…æ´—é…ç½®å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;
```

#### å¹¶è¡Œæ•°æ®æ¸…æ´—å®ç°

```sql
-- å¹¶è¡Œæ•°æ®æ¸…æ´—ï¼šå¤§è§„æ¨¡æ•°æ®å¼‚å¸¸å€¼æ£€æµ‹å’Œæ¸…æ´—ï¼ˆPostgreSQL 18+ï¼‰
DO $$
BEGIN
    BEGIN
        -- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
        SET max_parallel_workers_per_gather = 4;
        SET parallel_setup_cost = 0;
        SET parallel_tuple_cost = 0.0001;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¹¶è¡Œæ•°æ®æ¸…æ´—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¹¶è¡Œæ•°æ®æ¸…æ´—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¹¶è¡Œå¼‚å¸¸å€¼æ£€æµ‹å’Œæ¸…æ´—
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH parallel_stats AS (
    SELECT
        column_name,
        AVG(column_value) AS mean_value,
        STDDEV(column_value) AS stddev_value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY column_value) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY column_value) AS q3
    FROM data_table
    GROUP BY column_name
),
parallel_cleaned AS (
    SELECT
        dt.id,
        dt.column_name,
        dt.column_value,
        ps.mean_value,
        ps.stddev_value,
        ps.q1,
        ps.q3,
        (ps.q3 - ps.q1) AS iqr,
        CASE
            WHEN dt.column_value < ps.q1 - 1.5 * (ps.q3 - ps.q1) OR
                 dt.column_value > ps.q3 + 1.5 * (ps.q3 - ps.q1) THEN TRUE
            ELSE FALSE
        END AS is_outlier
    FROM data_table dt
    JOIN parallel_stats ps ON dt.column_name = ps.column_name
)
SELECT
    column_name,
    COUNT(*) AS total_records,
    COUNT(*) FILTER (WHERE is_outlier) AS outlier_count,
    ROUND((COUNT(*) FILTER (WHERE is_outlier)::numeric / COUNT(*) * 100)::numeric, 2) AS outlier_percentage
FROM parallel_cleaned
GROUP BY column_name
ORDER BY outlier_percentage DESC;
```

---

## 7. ç®—æ³•æ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–

### 7.1 æ¸…æ´—æ–¹æ³•å¯¹æ¯”

| æ–¹æ³• | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ | å¤æ‚åº¦ |
|------|---------|------|------|--------|
| **åˆ é™¤ç¼ºå¤±å€¼** | MCARç¼ºå¤± | ç®€å•ã€æ— åå·® | ä¸¢å¤±ä¿¡æ¯ | $O(n)$ |
| **å‡å€¼å¡«å……** | è¿ç»­æ•°å€¼ | å¿«é€Ÿã€ç®€å• | ä½ä¼°æ–¹å·® | $O(n)$ |
| **å›å½’å¡«å……** | æœ‰ç›¸å…³æ€§ | åˆ©ç”¨å…³ç³» | å¯èƒ½è¿‡æ‹Ÿåˆ | $O(n \cdot p)$ |
| **IQRå¼‚å¸¸æ£€æµ‹** | å•å˜é‡ | ç¨³å¥ã€æ— åˆ†å¸ƒå‡è®¾ | åªé€‚ç”¨å•å˜é‡ | $O(n \log n)$ |
| **Z-scoreæ£€æµ‹** | æ­£æ€åˆ†å¸ƒ | å¿«é€Ÿã€æ ‡å‡†åŒ– | å‡è®¾åˆ†å¸ƒ | $O(n)$ |
| **å“ˆå¸Œé‡å¤æ£€æµ‹** | å®Œå…¨é‡å¤ | å¿«é€Ÿ | å¯èƒ½å†²çª | $O(n)$ |
| **ç¼–è¾‘è·ç¦»** | è¿‘ä¼¼é‡å¤ | å¤„ç†æ‹¼å†™é”™è¯¯ | è®¡ç®—æ…¢ | $O(n^2)$ |

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**ï¼šåœ¨å…³é”®å­—æ®µä¸Šåˆ›å»ºç´¢å¼•åŠ é€Ÿé‡å¤æ£€æµ‹
2. **æ‰¹é‡å¤„ç†**ï¼šæ‰¹é‡å¤„ç†å¤§é‡æ•°æ®ï¼Œå‡å°‘I/O
3. **å¹¶è¡Œå¤„ç†**ï¼šåˆ©ç”¨PostgreSQLå¹¶è¡ŒæŸ¥è¯¢åŠ é€Ÿå¤„ç†
4. **ç‰©åŒ–è§†å›¾**ï¼šç¼“å­˜æ¸…æ´—ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—
5. **å¢é‡å¤„ç†**ï¼šåªå¤„ç†æ–°å¢æˆ–å˜æ›´çš„æ•°æ®

### 7.3 å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**é—®é¢˜1**ï¼šç¼ºå¤±å€¼å¡«å……åæ¨¡å‹æ€§èƒ½ä¸‹é™

- **è§£å†³æ–¹æ¡ˆ**ï¼šæ£€æŸ¥ç¼ºå¤±æœºåˆ¶ã€å°è¯•ä¸åŒå¡«å……æ–¹æ³•ã€ä½¿ç”¨ç¼ºå¤±å€¼æŒ‡ç¤ºå˜é‡

**é—®é¢˜2**ï¼šå¼‚å¸¸å€¼æ£€æµ‹è¯¯åˆ æ­£å¸¸æ•°æ®

- **è§£å†³æ–¹æ¡ˆ**ï¼šè°ƒæ•´é˜ˆå€¼ã€ä½¿ç”¨å¤šç§æ–¹æ³•äº¤å‰éªŒè¯ã€ç»“åˆä¸šåŠ¡çŸ¥è¯†

**é—®é¢˜3**ï¼šé‡å¤æ£€æµ‹è®¡ç®—æ—¶é—´è¿‡é•¿

- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å“ˆå¸Œæ–¹æ³•ã€é‡‡æ ·æ£€æµ‹ã€å¹¶è¡Œå¤„ç†

**é—®é¢˜4**ï¼šæ¸…æ´—åæ•°æ®é‡å¤§å¹…å‡å°‘

- **è§£å†³æ–¹æ¡ˆ**ï¼šæ£€æŸ¥æ¸…æ´—è§„åˆ™æ˜¯å¦è¿‡ä¸¥ã€è€ƒè™‘ä¿ç•™éƒ¨åˆ†å¼‚å¸¸å€¼ã€ä½¿ç”¨è½¯åˆ é™¤

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ•°æ®æ¸…æ´—æµç¨‹

1. **æ•°æ®æ¢ç´¢**ï¼š
   - äº†è§£æ•°æ®ç»“æ„å’Œåˆ†å¸ƒ
   - è¯†åˆ«æ•°æ®è´¨é‡é—®é¢˜
   - ç¡®å®šæ¸…æ´—ä¼˜å…ˆçº§

2. **æ¸…æ´—ç­–ç•¥**ï¼š
   - æ ¹æ®ä¸šåŠ¡éœ€æ±‚åˆ¶å®šè§„åˆ™
   - å¹³è¡¡æ•°æ®è´¨é‡å’Œæ•°æ®é‡
   - è®°å½•æ¸…æ´—å†³ç­–

3. **æ¸…æ´—æ‰§è¡Œ**ï¼š
   - åˆ†æ­¥éª¤æ‰§è¡Œæ¸…æ´—
   - ä¿ç•™åŸå§‹æ•°æ®å¤‡ä»½
   - è®°å½•æ¸…æ´—æ—¥å¿—

4. **è´¨é‡éªŒè¯**ï¼š
   - éªŒè¯æ¸…æ´—æ•ˆæœ
   - æ£€æŸ¥æ¸…æ´—åæ•°æ®åˆ†å¸ƒ
   - è¯„ä¼°å¯¹åç»­åˆ†æçš„å½±å“

### 8.2 ç¼ºå¤±å€¼å¤„ç†ç­–ç•¥

1. **åˆ†æç¼ºå¤±æ¨¡å¼**ï¼š
   - è®¡ç®—ç¼ºå¤±æ¯”ä¾‹
   - åˆ†æç¼ºå¤±ç›¸å…³æ€§
   - åˆ¤æ–­ç¼ºå¤±æœºåˆ¶

2. **é€‰æ‹©å¡«å……æ–¹æ³•**ï¼š
   - MCARï¼šå¯ä»¥ä½¿ç”¨åˆ é™¤æˆ–ç®€å•å¡«å……
   - MARï¼šä½¿ç”¨æ¨¡å‹å¡«å……
   - MNARï¼šéœ€è¦é¢†åŸŸçŸ¥è¯†

3. **éªŒè¯å¡«å……æ•ˆæœ**ï¼š
   - æ¯”è¾ƒå¡«å……å‰ååˆ†å¸ƒ
   - è¯„ä¼°å¯¹æ¨¡å‹çš„å½±å“
   - ä½¿ç”¨äº¤å‰éªŒè¯

### 8.3 å¼‚å¸¸å€¼å¤„ç†ç­–ç•¥

1. **å¼‚å¸¸å€¼è¯†åˆ«**ï¼š
   - ä½¿ç”¨å¤šç§æ–¹æ³•æ£€æµ‹
   - ç»“åˆä¸šåŠ¡çŸ¥è¯†åˆ¤æ–­
   - åŒºåˆ†é”™è¯¯å’ŒçœŸå®å¼‚å¸¸

2. **å¼‚å¸¸å€¼å¤„ç†**ï¼š
   - **åˆ é™¤**ï¼šç¡®è®¤æ˜¯é”™è¯¯æ•°æ®
   - **ä¿®æ­£**ï¼šå¯ä»¥ä¿®æ­£çš„é”™è¯¯
   - **ä¿ç•™**ï¼šçœŸå®çš„å¼‚å¸¸å€¼ï¼ˆå¯èƒ½åŒ…å«é‡è¦ä¿¡æ¯ï¼‰
   - **è½¬æ¢**ï¼šä½¿ç”¨å¯¹æ•°å˜æ¢ç­‰

3. **å¼‚å¸¸å€¼åˆ†æ**ï¼š
   - åˆ†æå¼‚å¸¸å€¼äº§ç”ŸåŸå› 
   - æ”¹è¿›æ•°æ®æ”¶é›†è¿‡ç¨‹
   - å»ºç«‹å¼‚å¸¸å€¼ç›‘æ§

### 8.4 é‡å¤æ•°æ®å¤„ç†ç­–ç•¥

1. **é‡å¤æ£€æµ‹**ï¼š
   - ç¡®å®šå…³é”®å­—æ®µ
   - é€‰æ‹©æ£€æµ‹æ–¹æ³•
   - è®¾ç½®ç›¸ä¼¼åº¦é˜ˆå€¼

2. **é‡å¤å¤„ç†**ï¼š
   - **åˆ é™¤**ï¼šå®Œå…¨é‡å¤çš„è®°å½•
   - **åˆå¹¶**ï¼šéƒ¨åˆ†é‡å¤çš„è®°å½•
   - **æ ‡è®°**ï¼šä¿ç•™ä½†æ ‡è®°ä¸ºé‡å¤

3. **é¢„é˜²æªæ–½**ï¼š
   - æ•°æ®å…¥åº“å‰éªŒè¯
   - ä½¿ç”¨å”¯ä¸€çº¦æŸ
   - å»ºç«‹æ•°æ®æ ‡å‡†

### 8.5 SQLå®ç°æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½è€ƒè™‘**ï¼š
   - åˆ›å»ºå¿…è¦çš„ç´¢å¼•
   - ä½¿ç”¨æ‰¹é‡æ“ä½œ
   - é¿å…å…¨è¡¨æ‰«æ

2. **æ•°æ®å®‰å…¨**ï¼š
   - ä¿ç•™åŸå§‹æ•°æ®å¤‡ä»½
   - ä½¿ç”¨äº‹åŠ¡ç¡®ä¿ä¸€è‡´æ€§
   - è®°å½•æ¸…æ´—æ“ä½œæ—¥å¿—

3. **å¯è¿½æº¯æ€§**ï¼š
   - è®°å½•æ¸…æ´—è§„åˆ™
   - ä¿å­˜æ¸…æ´—å†å²
   - å»ºç«‹å®¡è®¡è·Ÿè¸ª

### 8.6 PostgreSQL 18 æ–°ç‰¹æ€§åº”ç”¨ï¼ˆå¢å¼ºï¼‰

**PostgreSQL 18**å¼•å…¥äº†å¤šé¡¹å¢å¼ºåŠŸèƒ½ï¼Œå¯ä»¥æ˜¾è‘—æå‡æ•°æ®æ¸…æ´—ç®—æ³•çš„æ€§èƒ½ï¼š

1. **Skip Scanä¼˜åŒ–**ï¼š
   - å¯¹äºåŒ…å«æ¸…æ´—é”®çš„ç´¢å¼•ï¼ŒSkip Scanå¯ä»¥è·³è¿‡ä¸å¿…è¦çš„ç´¢å¼•æ‰«æ
   - ç‰¹åˆ«é€‚ç”¨äºTop-Nå¼‚å¸¸å€¼æŸ¥è¯¢å’Œé‡å¤æ•°æ®æ£€æµ‹æŸ¥è¯¢

2. **å¼‚æ­¥I/Oå¢å¼º**ï¼š
   - å¯¹äºå¤§è§„æ¨¡æ•°æ®æ¸…æ´—è®¡ç®—ï¼Œå¼‚æ­¥I/Oå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½
   - é€‚ç”¨äºæ‰¹é‡ç¼ºå¤±å€¼å¡«å……å’Œå¼‚å¸¸å€¼æ£€æµ‹

3. **å¹¶è¡ŒæŸ¥è¯¢å¢å¼º**ï¼š
   - æ•°æ®æ¸…æ´—æ”¯æŒæ›´å¥½çš„å¹¶è¡Œæ‰§è¡Œï¼ˆå·²åœ¨6èŠ‚è¯¦ç»†è¯´æ˜ï¼‰
   - é€‚ç”¨äºå¤§è§„æ¨¡æ•°æ®æ¸…æ´—å’Œå¤šæ­¥éª¤æ¸…æ´—æµç¨‹

**ç¤ºä¾‹ï¼šä½¿ç”¨Skip Scanä¼˜åŒ–æ•°æ®æ¸…æ´—æŸ¥è¯¢**

```sql
-- ä¸ºæ•°æ®æ¸…æ´—åˆ›å»ºSkip Scanä¼˜åŒ–ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_data_cleaning_skip_scan
ON data_quality_test(name, created_at DESC);

-- Skip Scanä¼˜åŒ–æŸ¥è¯¢ï¼šæŸ¥æ‰¾æœ€æ–°åˆ›å»ºçš„å‰10æ¡æœ‰é—®é¢˜çš„è®°å½•
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT DISTINCT ON (name)
    id,
    name,
    email,
    age,
    salary,
    created_at
FROM data_quality_test
WHERE name IS NULL OR email IS NULL OR age IS NULL OR salary IS NULL
ORDER BY name, created_at DESC
LIMIT 50;
```

### 8.7 é«˜çº§ä¼˜åŒ–æŠ€å·§ï¼ˆå¢å¼ºï¼‰

**1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜æ•°æ®æ¸…æ´—ç»“æœ**

å¯¹äºé¢‘ç¹ä½¿ç”¨çš„æ•°æ®æ¸…æ´—ç»“æœï¼Œä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜ï¼š

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç¼“å­˜æ•°æ®æ¸…æ´—ç»“æœ
CREATE MATERIALIZED VIEW IF NOT EXISTS data_cleaning_cache AS
WITH data_quality_summary AS (
    SELECT
        table_name,
        column_name,
        COUNT(*) AS total_rows,
        COUNT(*) FILTER (WHERE value IS NULL) AS missing_count,
        COUNT(*) FILTER (WHERE value IS NOT NULL) AS valid_count,
        ROUND((COUNT(*) FILTER (WHERE value IS NULL)::numeric / COUNT(*) * 100)::numeric, 2) AS missing_pct,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å¼‚å¸¸å€¼ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        COUNT(*) FILTER (WHERE
            value IS NOT NULL AND (
                ABS((value - AVG(value) OVER (PARTITION BY table_name, column_name)) /
                    NULLIF(STDDEV(value) OVER (PARTITION BY table_name, column_name), 0)) > 3
            )
        ) AS outlier_count,
        COUNT(*) FILTER (WHERE
            value IS NOT NULL AND (
                value < PERCENTILE_CONT(0.25) OVER (PARTITION BY table_name, column_name) -
                1.5 * (PERCENTILE_CONT(0.75) OVER (PARTITION BY table_name, column_name) -
                       PERCENTILE_CONT(0.25) OVER (PARTITION BY table_name, column_name)) OR
                value > PERCENTILE_CONT(0.75) OVER (PARTITION BY table_name, column_name) +
                1.5 * (PERCENTILE_CONT(0.75) OVER (PARTITION BY table_name, column_name) -
                       PERCENTILE_CONT(0.25) OVER (PARTITION BY table_name, column_name))
            )
        ) AS iqr_outlier_count
    FROM data_quality_test
    GROUP BY table_name, column_name, value
)
SELECT DISTINCT ON (table_name, column_name)
    table_name,
    column_name,
    total_rows,
    missing_count,
    valid_count,
    ROUND(missing_pct::numeric, 2) AS missing_pct,
    outlier_count,
    iqr_outlier_count,
    CASE
        WHEN missing_pct > 50 THEN 'Poor Quality'
        WHEN missing_pct > 20 THEN 'Moderate Quality'
        WHEN outlier_count + iqr_outlier_count > total_rows * 0.1 THEN 'High Anomaly Rate'
        ELSE 'Good Quality'
    END AS quality_status
FROM data_quality_summary
ORDER BY table_name, column_name, total_rows DESC;

-- åˆ›å»ºç´¢å¼•åŠ é€Ÿç‰©åŒ–è§†å›¾æŸ¥è¯¢
CREATE INDEX idx_data_cleaning_cache_table_column ON data_cleaning_cache(table_name, column_name);
CREATE INDEX idx_data_cleaning_cache_quality ON data_cleaning_cache(quality_status, missing_pct DESC);

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY data_cleaning_cache;
```

**2. å®æ—¶æ•°æ®æ¸…æ´—ï¼šå¢é‡æ¸…æ´—æ›´æ–°**

**å®æ—¶æ•°æ®æ¸…æ´—**ï¼šå¯¹äºæµå¼æ•°æ®ï¼Œä½¿ç”¨å¢é‡æ–¹æ³•è¿›è¡Œæ•°æ®æ¸…æ´—ã€‚

```sql
-- å®æ—¶æ•°æ®æ¸…æ´—ï¼šå¢é‡æ¸…æ´—æ›´æ–°ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_cleaning_state') THEN
            CREATE TABLE data_cleaning_state (
                table_name VARCHAR(100) NOT NULL,
                column_name VARCHAR(100) NOT NULL,
                quality_metric VARCHAR(50) NOT NULL,  -- 'missing', 'outlier', 'duplicate'
                issue_count BIGINT DEFAULT 0,
                cleaned_count BIGINT DEFAULT 0,
                last_cleaned_at TIMESTAMPTZ,
                last_updated TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (table_name, column_name, quality_metric)
            );

            CREATE INDEX idx_data_cleaning_state_table_column ON data_cleaning_state(table_name, column_name);
            CREATE INDEX idx_data_cleaning_state_updated ON data_cleaning_state(last_updated DESC);

            RAISE NOTICE 'æ•°æ®æ¸…æ´—çŠ¶æ€è¡¨åˆ›å»ºæˆåŠŸ';
        END IF;

        RAISE NOTICE 'å¼€å§‹æ‰§è¡Œå¢é‡æ•°æ®æ¸…æ´—';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'å¢é‡æ•°æ®æ¸…æ´—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- å¢é‡æ›´æ–°æ•°æ®æ¸…æ´—ç»Ÿè®¡ï¼šå®æ—¶æ•°æ®æ¸…æ´—
WITH new_data_quality_issues AS (
    SELECT
        'data_quality_test' AS table_name,
        column_name,
        'missing' AS quality_metric,
        COUNT(*) AS new_issue_count
    FROM (
        SELECT 'name' AS column_name, name AS value FROM data_quality_test WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM data_cleaning_state)
        UNION ALL
        SELECT 'email' AS column_name, email AS value FROM data_quality_test WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM data_cleaning_state)
        UNION ALL
        SELECT 'age' AS column_name, age::text AS value FROM data_quality_test WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM data_cleaning_state)
        UNION ALL
        SELECT 'salary' AS column_name, salary::text AS value FROM data_quality_test WHERE created_at > (SELECT COALESCE(MAX(last_updated), '1970-01-01') FROM data_cleaning_state)
    ) AS column_values
    WHERE value IS NULL
    GROUP BY column_name
),
updated_cleaning_state AS (
    SELECT
        COALESCE(dcs.table_name, ndqi.table_name) AS table_name,
        COALESCE(dcs.column_name, ndqi.column_name) AS column_name,
        COALESCE(dcs.quality_metric, ndqi.quality_metric) AS quality_metric,
        COALESCE(dcs.issue_count, 0) + COALESCE(ndqi.new_issue_count, 0) AS new_issue_count,
        COALESCE(dcs.cleaned_count, 0) AS new_cleaned_count
    FROM data_cleaning_state dcs
    FULL OUTER JOIN new_data_quality_issues ndqi ON dcs.table_name = ndqi.table_name
                                                    AND dcs.column_name = ndqi.column_name
                                                    AND dcs.quality_metric = ndqi.quality_metric
)
-- æ›´æ–°æˆ–æ’å…¥æ•°æ®æ¸…æ´—çŠ¶æ€
INSERT INTO data_cleaning_state (
    table_name,
    column_name,
    quality_metric,
    issue_count,
    cleaned_count,
    last_cleaned_at,
    last_updated
)
SELECT
    table_name,
    column_name,
    quality_metric,
    new_issue_count,
    new_cleaned_count,
    CASE WHEN new_issue_count > 0 THEN NOW() ELSE NULL END AS last_cleaned_at,
    NOW()
FROM updated_cleaning_state
ON CONFLICT (table_name, column_name, quality_metric)
DO UPDATE SET
    issue_count = EXCLUDED.issue_count,
    cleaned_count = EXCLUDED.cleaned_count,
    last_cleaned_at = EXCLUDED.last_cleaned_at,
    last_updated = NOW();
```

**3. æ™ºèƒ½æ•°æ®æ¸…æ´—ï¼šè‡ªé€‚åº”æ¸…æ´—ç­–ç•¥**

**æ™ºèƒ½æ•°æ®æ¸…æ´—**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜æ¸…æ´—ç­–ç•¥ã€‚

```sql
-- æ™ºèƒ½æ•°æ®æ¸…æ´—ï¼šè‡ªé€‚åº”æ¸…æ´—ç­–ç•¥ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œæ€§èƒ½æµ‹è¯•ï¼‰
DO $$
DECLARE
    missing_pct NUMERIC;
    outlier_pct NUMERIC;
    cleaning_strategy VARCHAR(50);
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'data_quality_test') THEN
            RAISE WARNING 'è¡¨ data_quality_test ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œæ™ºèƒ½æ•°æ®æ¸…æ´—';
            RETURN;
        END IF;

        -- è®¡ç®—æ•°æ®è´¨é‡ç‰¹å¾
        SELECT
            (COUNT(*) FILTER (WHERE name IS NULL OR email IS NULL OR age IS NULL OR salary IS NULL)::numeric / COUNT(*) * 100),
            (COUNT(*) FILTER (WHERE
                ABS((COALESCE(age, 0) - AVG(COALESCE(age, 0)) OVER ()) /
                     NULLIF(STDDEV(COALESCE(age, 0)) OVER (), 0)) > 3
            )::numeric / COUNT(*) * 100)
        INTO missing_pct, outlier_pct
        FROM data_quality_test;

        -- æ ¹æ®æ•°æ®è´¨é‡ç‰¹å¾è‡ªé€‚åº”é€‰æ‹©æ¸…æ´—ç­–ç•¥
        IF missing_pct > 30 OR outlier_pct > 20 THEN
            cleaning_strategy := 'AGGRESSIVE_CLEANING';  -- æ¿€è¿›æ¸…æ´—ï¼šå¤§é‡é—®é¢˜æ•°æ®
        ELSIF missing_pct > 10 OR outlier_pct > 5 THEN
            cleaning_strategy := 'MODERATE_CLEANING';  -- ä¸­ç­‰æ¸…æ´—ï¼šä¸­ç­‰é—®é¢˜æ•°æ®
        ELSE
            cleaning_strategy := 'CONSERVATIVE_CLEANING';  -- ä¿å®ˆæ¸…æ´—ï¼šå°‘é‡é—®é¢˜æ•°æ®
        END IF;

        RAISE NOTICE 'ç¼ºå¤±å€¼æ¯”ä¾‹: %%%, å¼‚å¸¸å€¼æ¯”ä¾‹: %%%, é€‰æ‹©ç­–ç•¥: %',
            missing_pct, outlier_pct, cleaning_strategy;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'æ™ºèƒ½æ•°æ®æ¸…æ´—å‡†å¤‡å¤±è´¥: %', SQLERRM;
            RAISE;
    END;
END $$;

-- æ™ºèƒ½æ•°æ®æ¸…æ´—ï¼šæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸åŒçš„æ¸…æ´—æ–¹å¼
WITH data_quality_assessment AS (
    SELECT
        id,
        name,
        email,
        age,
        salary,
        created_at,
        -- è¯„ä¼°æ•°æ®è´¨é‡
        CASE
            WHEN name IS NULL THEN 1 ELSE 0 END +
        CASE WHEN email IS NULL THEN 1 ELSE 0 END +
        CASE WHEN age IS NULL THEN 1 ELSE 0 END +
        CASE WHEN salary IS NULL THEN 1 ELSE 0 END AS missing_count,
        -- ä½¿ç”¨çª—å£å‡½æ•°è®¡ç®—å¼‚å¸¸å€¼å¾—åˆ†ï¼ˆé¿å…é‡å¤è®¡ç®—ï¼‰
        CASE
            WHEN age IS NOT NULL THEN
                ABS((age - AVG(age) OVER ()) / NULLIF(STDDEV(age) OVER (), 0))
            ELSE NULL
        END AS age_z_score,
        CASE
            WHEN salary IS NOT NULL THEN
                ABS((salary - AVG(salary) OVER ()) / NULLIF(STDDEV(salary) OVER (), 0))
            ELSE NULL
        END AS salary_z_score
    FROM data_quality_test
),
cleaning_recommendations AS (
    SELECT
        id,
        name,
        email,
        age,
        salary,
        created_at,
        missing_count,
        age_z_score,
        salary_z_score,
        CASE
            WHEN missing_count >= 3 OR COALESCE(age_z_score, 0) > 3 OR COALESCE(salary_z_score, 0) > 3 THEN 'DELETE'
            WHEN missing_count >= 2 OR COALESCE(age_z_score, 0) > 2 OR COALESCE(salary_z_score, 0) > 2 THEN 'FILL_OR_CORRECT'
            WHEN missing_count = 1 OR COALESCE(age_z_score, 0) > 1 OR COALESCE(salary_z_score, 0) > 1 THEN 'REVIEW'
            ELSE 'KEEP'
        END AS cleaning_action,
        CASE
            WHEN missing_count >= 3 THEN 'Multiple missing values'
            WHEN COALESCE(age_z_score, 0) > 3 THEN 'Extreme age outlier'
            WHEN COALESCE(salary_z_score, 0) > 3 THEN 'Extreme salary outlier'
            WHEN missing_count >= 2 THEN 'Several missing values'
            ELSE 'Minor quality issues'
        END AS cleaning_reason
    FROM data_quality_assessment
)
SELECT
    id,
    name,
    email,
    age,
    salary,
    created_at,
    missing_count,
    ROUND(COALESCE(age_z_score::numeric, 0), 4) AS age_z_score,
    ROUND(COALESCE(salary_z_score::numeric, 0), 4) AS salary_z_score,
    cleaning_action,
    cleaning_reason
FROM cleaning_recommendations
WHERE cleaning_action != 'KEEP'
ORDER BY
    CASE cleaning_action
        WHEN 'DELETE' THEN 1
        WHEN 'FILL_OR_CORRECT' THEN 2
        WHEN 'REVIEW' THEN 3
        ELSE 4
    END,
    missing_count DESC,
    GREATEST(COALESCE(age_z_score, 0), COALESCE(salary_z_score, 0)) DESC
LIMIT 50;
```

---

## ğŸ“š å‚è€ƒèµ„æº

### å­¦æœ¯æ–‡çŒ®

1. **Little, R.J.A., Rubin, D.B. (2019)**: "Statistical Analysis with Missing Data", 3rd Edition, Wiley.

2. **Hawkins, D.M. (1980)**: "Identification of Outliers", Chapman and Hall.

3. **Elmagarmid, A.K., Ipeirotis, P.G., Verykios, V.S. (2007)**: "Duplicate Record Detection: A Survey", *IEEE Transactions on Knowledge and Data Engineering*.

4. **ã€Šæ•°æ®æŒ–æ˜ï¼šæ¦‚å¿µä¸æŠ€æœ¯ã€‹**ï¼ˆHan, Kamber, Pei, 2012ï¼‰- Chapter 3: Data Preprocessing

5. **ã€Šæ•°æ®ç§‘å­¦æ‰‹å†Œã€‹**ï¼ˆJake VanderPlas, 2016ï¼‰- Chapter 3: Data Manipulation with Pandas

### åœ¨çº¿èµ„æº

- **PostgreSQLå­—ç¬¦ä¸²å‡½æ•°**: <https://www.postgresql.org/docs/current/functions-string.html>
- **PostgreSQLæ­£åˆ™è¡¨è¾¾å¼**: <https://www.postgresql.org/docs/current/functions-matching.html>
- **æ•°æ®æ¸…æ´—æœ€ä½³å®è·µ**: <https://towardsdatascience.com/data-cleaning-in-python-the-ultimate-guide-2020-c63b88bf0a0>

### ç›¸å…³ç®—æ³•

- **æ•°æ®éªŒè¯ç®—æ³•**ï¼šæ•°æ®æ ¼å¼å’Œè§„åˆ™éªŒè¯
- **æ•°æ®æ ‡å‡†åŒ–ç®—æ³•**ï¼šæ•°æ®æ ¼å¼ç»Ÿä¸€
- **æ•°æ®å®Œæ•´æ€§æ£€æŸ¥**ï¼šçº¦æŸå’Œè§„åˆ™æ£€æŸ¥
- **å¼‚å¸¸æ£€æµ‹ç®—æ³•**ï¼šé«˜çº§å¼‚å¸¸æ£€æµ‹æ–¹æ³•

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
