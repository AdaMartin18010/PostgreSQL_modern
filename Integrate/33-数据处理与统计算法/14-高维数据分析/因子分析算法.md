# PostgreSQL 因子分析算法完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 因子分析 | 降维 | 潜在变量
> **难度级别**: ⭐⭐⭐⭐⭐ (专家级)
> **参考标准**: Factor Analysis (Harman), Multivariate Analysis, Psychometrics

---

## 📋 目录

- [PostgreSQL 因子分析算法完整指南](#postgresql-因子分析算法完整指南)
  - [📋 目录](#-目录)
  - [因子分析概述](#因子分析概述)
    - [理论基础](#理论基础)
    - [数学模型](#数学模型)
    - [应用场景](#应用场景)
  - [1. 探索性因子分析](#1-探索性因子分析)
    - [1.1 因子模型](#11-因子模型)
    - [1.2 因子载荷](#12-因子载荷)
    - [1.3 因子提取](#13-因子提取)
  - [2. 验证性因子分析](#2-验证性因子分析)
    - [2.1 模型设定](#21-模型设定)
    - [2.2 参数估计](#22-参数估计)
    - [2.3 模型拟合](#23-模型拟合)
  - [3. 因子旋转](#3-因子旋转)
    - [3.1 正交旋转](#31-正交旋转)
    - [3.2 斜交旋转](#32-斜交旋转)
  - [4. 因子得分](#4-因子得分)
    - [4.1 因子得分计算](#41-因子得分计算)
  - [5. 复杂度分析](#5-复杂度分析)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 心理测量](#61-心理测量)
    - [6.2 市场研究](#62-市场研究)
  - [📚 参考资源](#-参考资源)
  - [📊 性能优化建议](#-性能优化建议)
  - [🎯 最佳实践](#-最佳实践)

---

## 因子分析概述

**因子分析（Factor Analysis）**是一种多元统计方法，用于识别观测变量背后的潜在因子结构。

### 理论基础

因子分析假设观测变量是潜在因子的线性组合，通过分析变量间的相关性来揭示潜在结构。

### 数学模型

**因子模型**:
$$X = \Lambda F + \epsilon$$

其中：

- $X \in \mathbb{R}^{p \times 1}$ 是观测变量向量
- $\Lambda \in \mathbb{R}^{p \times m}$ 是因子载荷矩阵
- $F \in \mathbb{R}^{m \times 1}$ 是因子向量
- $\epsilon \in \mathbb{R}^{p \times 1}$ 是误差项

**协方差结构**:
$$\Sigma = \Lambda \Phi \Lambda^T + \Psi$$

其中：

- $\Phi$ 是因子协方差矩阵
- $\Psi$ 是误差协方差矩阵（通常是对角矩阵）

### 应用场景

| 应用领域 | 具体应用 |
|---------|---------|
| **心理学** | 智力测试、人格测量 |
| **市场研究** | 消费者行为分析、品牌形象 |
| **社会科学** | 社会调查、态度测量 |
| **金融** | 风险因子分析、资产定价 |

---

## 1. 探索性因子分析

### 1.1 因子模型

**探索性因子分析（EFA）**用于探索数据的因子结构，无需先验假设。

```sql
-- 因子分析数据准备（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'factor_analysis_data') THEN
            RAISE WARNING '表 factor_analysis_data 已存在，先删除';
            DROP TABLE factor_analysis_data CASCADE;
        END IF;

        CREATE TABLE factor_analysis_data (
            id SERIAL PRIMARY KEY,
            var1 NUMERIC NOT NULL,
            var2 NUMERIC NOT NULL,
            var3 NUMERIC NOT NULL,
            var4 NUMERIC NOT NULL,
            var5 NUMERIC NOT NULL
        );

        -- 插入示例数据
        INSERT INTO factor_analysis_data (var1, var2, var3, var4, var5) VALUES
            (3.5, 4.0, 3.8, 2.5, 2.8),
            (4.2, 4.5, 4.1, 3.0, 3.2),
            (3.8, 4.2, 4.0, 2.8, 3.0),
            (4.0, 4.3, 4.2, 2.9, 3.1);

        RAISE NOTICE '表 factor_analysis_data 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE WARNING '表 factor_analysis_data 已存在';
        WHEN OTHERS THEN
            RAISE EXCEPTION '创建表失败: %', SQLERRM;
    END;
END $$;
```

### 1.2 因子载荷

**因子载荷** $\lambda_{ij}$ 表示变量 $i$ 与因子 $j$ 的相关性。

```sql
-- 相关矩阵计算（用于因子分析）
WITH standardized_data AS (
    SELECT
        id,
        (var1 - AVG(var1) OVER ()) / NULLIF(STDDEV(var1) OVER (), 0) AS z_var1,
        (var2 - AVG(var2) OVER ()) / NULLIF(STDDEV(var2) OVER (), 0) AS z_var2,
        (var3 - AVG(var3) OVER ()) / NULLIF(STDDEV(var3) OVER (), 0) AS z_var3,
        (var4 - AVG(var4) OVER ()) / NULLIF(STDDEV(var4) OVER (), 0) AS z_var4,
        (var5 - AVG(var5) OVER ()) / NULLIF(STDDEV(var5) OVER (), 0) AS z_var5
    FROM factor_analysis_data
),
correlation_matrix AS (
    SELECT
        'var1' AS var_i,
        'var1' AS var_j,
        AVG(z_var1 * z_var1) AS correlation
    FROM standardized_data
    UNION ALL
    SELECT 'var1', 'var2', AVG(z_var1 * z_var2) FROM standardized_data
    UNION ALL
    SELECT 'var1', 'var3', AVG(z_var1 * z_var3) FROM standardized_data
    -- ... 更多相关对
)
SELECT
    var_i,
    var_j,
    ROUND(correlation::numeric, 4) AS correlation_coefficient
FROM correlation_matrix
ORDER BY var_i, var_j;
```

### 1.3 因子提取

**因子提取方法**:

1. **主成分法**: 使用PCA提取因子
2. **最大似然法**: 最大化似然函数
3. **主轴因子法**: 迭代估计因子载荷

```sql
-- 因子提取（使用主成分法，简化版）
WITH correlation_matrix AS (
    SELECT * FROM computed_correlation_matrix
),
eigenvalue_decomposition AS (
    SELECT
        eigenvalue,
        eigenvector,
        ROW_NUMBER() OVER (ORDER BY eigenvalue DESC) AS factor_rank
    FROM compute_eigenvalues(correlation_matrix)
),
factor_loadings AS (
    SELECT
        factor_rank,
        eigenvalue,
        eigenvector,
        SQRT(eigenvalue) * eigenvector AS factor_loading
    FROM eigenvalue_decomposition
    WHERE eigenvalue > 1.0  -- Kaiser准则：保留特征值>1的因子
)
SELECT
    factor_rank,
    ROUND(eigenvalue::numeric, 4) AS eigenvalue,
    ROUND((eigenvalue / SUM(eigenvalue) OVER () * 100)::numeric, 2) AS variance_explained_pct
FROM factor_loadings
ORDER BY factor_rank;
```

---

## 2. 验证性因子分析

### 2.1 模型设定

**验证性因子分析（CFA）**用于验证先验的因子结构假设。

**模型设定**包括：

- 因子数量
- 变量与因子的关系
- 因子间的相关关系

### 2.2 参数估计

**参数估计**使用最大似然估计：

$$\hat{\Lambda}, \hat{\Phi}, \hat{\Psi} = \arg\max_{\Lambda, \Phi, \Psi} \log L(\Lambda, \Phi, \Psi | X)$$

```sql
-- CFA参数估计（简化版：展示概念）
WITH model_parameters AS (
    SELECT
        variable_id,
        factor_id,
        loading_estimate,
        standard_error,
        loading_estimate / NULLIF(standard_error, 0) AS t_statistic
    FROM cfa_estimates
)
SELECT
    variable_id,
    factor_id,
    ROUND(loading_estimate::numeric, 4) AS factor_loading,
    ROUND(t_statistic::numeric, 4) AS t_value,
    CASE
        WHEN ABS(t_statistic) > 1.96 THEN 'Significant'
        ELSE 'Not significant'
    END AS significance
FROM model_parameters
ORDER BY variable_id, factor_id;
```

### 2.3 模型拟合

**拟合指数**:

- **卡方统计量**: $\chi^2 = (n-1)F_{ML}$
- **CFI**: 比较拟合指数
- **RMSEA**: 近似误差均方根
- **SRMR**: 标准化残差均方根

```sql
-- 模型拟合评估
WITH fit_indices AS (
    SELECT
        chi_square,
        degrees_of_freedom,
        chi_square / NULLIF(degrees_of_freedom, 0) AS chi_square_df_ratio,
        cfi,
        rmsea,
        srmr
    FROM cfa_fit_statistics
)
SELECT
    ROUND(chi_square::numeric, 4) AS chi_square,
    degrees_of_freedom,
    ROUND(chi_square_df_ratio::numeric, 4) AS chi_sq_df_ratio,
    ROUND(cfi::numeric, 4) AS cfi,
    ROUND(rmsea::numeric, 4) AS rmsea,
    ROUND(srmr::numeric, 4) AS srmr,
    CASE
        WHEN cfi > 0.95 AND rmsea < 0.06 AND srmr < 0.08 THEN 'Good fit'
        WHEN cfi > 0.90 AND rmsea < 0.08 THEN 'Acceptable fit'
        ELSE 'Poor fit'
    END AS fit_quality
FROM fit_indices;
```

---

## 3. 因子旋转

### 3.1 正交旋转

**Varimax旋转**是最常用的正交旋转方法，最大化因子载荷的方差。

**目标函数**:
$$\max \sum_{j=1}^{m} \left[\sum_{i=1}^{p} \lambda_{ij}^4 - \frac{1}{p}\left(\sum_{i=1}^{p} \lambda_{ij}^2\right)^2\right]$$

```sql
-- Varimax旋转（简化版：展示概念）
WITH factor_loadings AS (
    SELECT
        variable_id,
        factor_id,
        loading_value
    FROM extracted_factors
),
rotated_loadings AS (
    SELECT
        variable_id,
        factor_id,
        -- Varimax旋转后的载荷（简化计算）
        loading_value * rotation_matrix_value AS rotated_loading
    FROM factor_loadings
    CROSS JOIN rotation_matrix
)
SELECT
    variable_id,
    factor_id,
    ROUND(rotated_loading::numeric, 4) AS rotated_loading
FROM rotated_loadings
ORDER BY variable_id, factor_id;
```

### 3.2 斜交旋转

**Oblimin旋转**允许因子间相关，更符合实际。

---

## 4. 因子得分

### 4.1 因子得分计算

**因子得分**表示每个样本在因子上的得分。

**回归法**:
$$F = (X - \mu)^T \Lambda (\Lambda^T \Lambda)^{-1}$$

```sql
-- 因子得分计算
WITH standardized_scores AS (
    SELECT
        id,
        (var1 - AVG(var1) OVER ()) / NULLIF(STDDEV(var1) OVER (), 0) AS z_var1,
        (var2 - AVG(var2) OVER ()) / NULLIF(STDDEV(var2) OVER (), 0) AS z_var2
        -- ... 更多变量
    FROM factor_analysis_data
),
factor_scores AS (
    SELECT
        id,
        z_var1 * loading_var1_factor1 + z_var2 * loading_var2_factor1 AS factor1_score,
        z_var1 * loading_var1_factor2 + z_var2 * loading_var2_factor2 AS factor2_score
    FROM standardized_scores
    CROSS JOIN factor_loadings
)
SELECT
    id,
    ROUND(factor1_score::numeric, 4) AS factor1_score,
    ROUND(factor2_score::numeric, 4) AS factor2_score
FROM factor_scores
ORDER BY id;
```

---

## 5. 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| **相关矩阵** | $O(np^2)$ | $O(p^2)$ |
| **特征值分解** | $O(p^3)$ | $O(p^2)$ |
| **因子提取** | $O(p^3)$ | $O(p^2)$ |
| **因子旋转** | $O(p^2m \times iterations)$ | $O(pm)$ |

其中 $n$ 是样本数，$p$ 是变量数，$m$ 是因子数。

---

## 6. 实际应用案例

### 6.1 心理测量

```sql
-- 心理测量因子分析应用
WITH psychological_scores AS (
    SELECT
        participant_id,
        anxiety_score,
        depression_score,
        stress_score,
        sleep_quality_score
    FROM psychological_assessment
),
factor_analysis AS (
    SELECT
        participant_id,
        -- 提取心理压力因子
        factor_score AS psychological_stress_factor
    FROM compute_factor_scores(psychological_scores)
)
SELECT
    participant_id,
    ROUND(psychological_stress_factor::numeric, 4) AS stress_factor_score
FROM factor_analysis;
```

### 6.2 市场研究

```sql
-- 市场研究因子分析应用
WITH consumer_ratings AS (
    SELECT
        consumer_id,
        price_rating,
        quality_rating,
        brand_rating,
        design_rating
    FROM consumer_survey
),
brand_factors AS (
    SELECT
        consumer_id,
        -- 提取品牌形象因子
        factor_score AS brand_image_factor
    FROM compute_factor_scores(consumer_ratings)
)
SELECT
    consumer_id,
    ROUND(brand_image_factor::numeric, 4) AS brand_image_score
FROM brand_factors;
```

---

## 📚 参考资源

1. **Harman, H.H. (1976)**: "Modern Factor Analysis"
2. **Fabrigar, L.R., Wegener, D.T. (2012)**: "Exploratory Factor Analysis"
3. **Brown, T.A. (2015)**: "Confirmatory Factor Analysis for Applied Research"

## 📊 性能优化建议

1. **样本量**: 确保足够的样本量（通常n>5p）
2. **因子数量**: 使用Kaiser准则或碎石图确定因子数
3. **旋转方法**: 根据因子相关性选择旋转方法

## 🎯 最佳实践

1. **数据质量**: 检查数据的相关性和正态性
2. **因子数量**: 使用多种方法确定因子数
3. **解释性**: 确保因子有实际意义
4. **验证**: 使用CFA验证EFA的结果

---

**最后更新**: 2025年1月
**文档状态**: ✅ 已完成
