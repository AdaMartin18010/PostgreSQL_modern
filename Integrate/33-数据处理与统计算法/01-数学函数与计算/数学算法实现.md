# PostgreSQL 数学算法实现完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数学算法 | 递归算法
> **难度级别**: ⭐⭐⭐⭐ (高级)

---

## 📋 目录

- [PostgreSQL 数学算法实现完整指南](#postgresql-数学算法实现完整指南)
  - [📋 目录](#-目录)
  - [数学算法实现概述](#数学算法实现概述)
    - [核心算法列表](#核心算法列表)
  - [1. 斐波那契数列](#1-斐波那契数列)
    - [1.1 递归CTE实现](#11-递归cte实现)
  - [2. 阶乘计算](#2-阶乘计算)
    - [2.1 递归函数实现](#21-递归函数实现)
  - [3. 质数判断](#3-质数判断)
    - [3.1 质数判断函数](#31-质数判断函数)
  - [4. 最大公约数](#4-最大公约数)
    - [4.1 欧几里得算法](#41-欧几里得算法)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 组合数学：排列组合](#51-组合数学排列组合)

---

## 数学算法实现概述

**数学算法实现**使用PostgreSQL的递归CTE和函数实现经典数学算法。

### 核心算法列表

| 算法名称 | 实现方式 | 复杂度 | 应用场景 |
|---------|---------|--------|---------|
| **斐波那契** | 递归CTE | O(n) | 序列生成 |
| **阶乘** | 递归函数 | O(n) | 组合数学 |
| **质数判断** | 循环判断 | O(√n) | 密码学 |
| **最大公约数** | 欧几里得算法 | O(log n) | 分数化简 |

---

## 1. 斐波那契数列

### 1.1 递归CTE实现

```sql
-- 斐波那契数列（带错误处理）
DO $$
DECLARE
    n INTEGER := 10;
    fib_result INTEGER;
BEGIN
    BEGIN
        IF n < 0 THEN
            RAISE WARNING 'n必须大于等于0';
            RETURN;
        END IF;

        IF n > 1000 THEN
            RAISE WARNING 'n过大，可能导致性能问题';
        END IF;

        RAISE NOTICE '开始计算斐波那契数列前%项', n;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '斐波那契计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 使用递归CTE生成斐波那契数列
WITH RECURSIVE fibonacci AS (
    SELECT
        0 AS n,
        0 AS fib_n,
        1 AS fib_next
    UNION ALL
    SELECT
        n + 1,
        fib_next,
        fib_n + fib_next
    FROM fibonacci
    WHERE n < 10
)
SELECT n, fib_n AS fibonacci_number
FROM fibonacci
ORDER BY n;
```

---

## 2. 阶乘计算

### 2.1 递归函数实现

```sql
-- 阶乘计算函数（带错误处理）
CREATE OR REPLACE FUNCTION factorial(n INTEGER)
RETURNS BIGINT
LANGUAGE plpgsql
AS $$
DECLARE
    result BIGINT := 1;
    i INTEGER;
BEGIN
    BEGIN
        IF n < 0 THEN
            RAISE EXCEPTION '阶乘的n必须大于等于0';
        END IF;

        IF n > 20 THEN
            RAISE EXCEPTION 'n过大，结果会溢出BIGINT范围';
        END IF;

        IF n = 0 OR n = 1 THEN
            RETURN 1;
        END IF;

        FOR i IN 2..n LOOP
            result := result * i;
        END LOOP;

        RETURN result;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '阶乘计算失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 测试阶乘函数
SELECT factorial(5) AS factorial_5;  -- 120
```

---

## 3. 质数判断

### 3.1 质数判断函数

```sql
-- 质数判断函数（带错误处理）
CREATE OR REPLACE FUNCTION is_prime(n INTEGER)
RETURNS BOOLEAN
LANGUAGE plpgsql
AS $$
DECLARE
    i INTEGER;
BEGIN
    BEGIN
        IF n < 2 THEN
            RETURN FALSE;
        END IF;

        IF n = 2 THEN
            RETURN TRUE;
        END IF;

        IF n % 2 = 0 THEN
            RETURN FALSE;
        END IF;

        -- 检查从3到sqrt(n)的奇数
        FOR i IN 3..FLOOR(SQRT(n))::INTEGER BY 2 LOOP
            IF n % i = 0 THEN
                RETURN FALSE;
            END IF;
        END LOOP;

        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '质数判断失败: %', SQLERRM;
            RETURN NULL;
    END;
END $$;

-- 测试质数判断
SELECT n, is_prime(n) AS is_prime
FROM generate_series(1, 20) AS n;
```

---

## 4. 最大公约数

### 4.1 欧几里得算法

```sql
-- 最大公约数函数（欧几里得算法，带错误处理）
CREATE OR REPLACE FUNCTION gcd(a INTEGER, b INTEGER)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
    temp INTEGER;
    x INTEGER := ABS(a);
    y INTEGER := ABS(b);
BEGIN
    BEGIN
        IF x = 0 AND y = 0 THEN
            RAISE EXCEPTION '两个数不能同时为0';
        END IF;

        -- 欧几里得算法
        WHILE y != 0 LOOP
            temp := y;
            y := x % y;
            x := temp;
        END LOOP;

        RETURN x;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '最大公约数计算失败: %', SQLERRM;
            RETURN NULL;
    END;
END $$;

-- 测试最大公约数
SELECT gcd(48, 18) AS gcd_result;  -- 6
```

---

## 5. 实际应用案例

### 5.1 组合数学：排列组合

```sql
-- 组合数计算 C(n, k) = n! / (k! * (n-k)!)
CREATE OR REPLACE FUNCTION combination(n INTEGER, k INTEGER)
RETURNS BIGINT
LANGUAGE plpgsql
AS $$
DECLARE
    result BIGINT;
BEGIN
    BEGIN
        IF n < 0 OR k < 0 OR k > n THEN
            RAISE EXCEPTION '参数无效: n=%%, k=%%', n, k;
        END IF;

        IF k = 0 OR k = n THEN
            RETURN 1;
        END IF;

        -- 优化：使用较小的k值
        IF k > n - k THEN
            k := n - k;
        END IF;

        result := 1;
        FOR i IN 0..k-1 LOOP
            result := result * (n - i) / (i + 1);
        END LOOP;

        RETURN result;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '组合数计算失败: %', SQLERRM;
            RETURN NULL;
    END;
END $$;

-- 测试组合数
SELECT combination(5, 2) AS combination_5_2;  -- 10
```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
