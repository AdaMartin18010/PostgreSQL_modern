# PostgreSQL 数值精度处理完整指南

> **创建日期**: 2025年1月
> **技术栈**: PostgreSQL 17+/18+ | 数值精度 | 金融计算
> **难度级别**: ⭐⭐⭐ (中级)

---

## 📋 目录

- [PostgreSQL 数值精度处理完整指南](#postgresql-数值精度处理完整指南)
  - [📋 目录](#-目录)
  - [数值精度处理概述](#数值精度处理概述)
    - [理论基础](#理论基础)
      - [精度问题定义](#精度问题定义)
      - [精度处理方法](#精度处理方法)
      - [数据类型精度](#数据类型精度)
    - [核心函数列表](#核心函数列表)
  - [1. 四舍五入](#1-四舍五入)
    - [1.1 四舍五入原理](#11-四舍五入原理)
      - [四舍五入规则](#四舍五入规则)
    - [1.2 基本四舍五入实现](#12-基本四舍五入实现)
    - [1.3 银行家舍入](#13-银行家舍入)
  - [2. 截断](#2-截断)
    - [2.1 截断原理](#21-截断原理)
      - [截断规则](#截断规则)
    - [2.2 基本截断实现](#22-基本截断实现)
  - [3. 取整函数](#3-取整函数)
    - [3.1 CEIL和FLOOR原理](#31-ceil和floor原理)
    - [3.2 CEIL和FLOOR实现](#32-ceil和floor实现)
  - [4. 精度控制](#4-精度控制)
    - [4.1 数据类型精度原理](#41-数据类型精度原理)
      - [NUMERIC精度](#numeric精度)
      - [浮点数精度](#浮点数精度)
    - [4.2 数据类型精度实现](#42-数据类型精度实现)
    - [4.3 精度转换](#43-精度转换)
  - [5. 精度优化策略](#5-精度优化策略)
    - [5.1 精度选择优化](#51-精度选择优化)
    - [5.2 计算精度优化](#52-计算精度优化)
    - [5.3 显示精度优化](#53-显示精度优化)
  - [6. 实际应用案例](#6-实际应用案例)
    - [6.1 金融计算：金额格式化](#61-金融计算金额格式化)
    - [6.2 统计分析：精度控制](#62-统计分析精度控制)
    - [6.3 科学计算：精度管理](#63-科学计算精度管理)
    - [6.4 数据展示：格式化输出](#64-数据展示格式化输出)
  - [7. 算法性能对比与优化](#7-算法性能对比与优化)
    - [7.1 精度处理方法对比](#71-精度处理方法对比)
    - [7.2 性能优化建议](#72-性能优化建议)
    - [7.3 常见问题与解决方案](#73-常见问题与解决方案)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 数据类型选择](#81-数据类型选择)
    - [8.2 精度设置](#82-精度设置)
    - [8.3 舍入策略](#83-舍入策略)
    - [8.4 SQL实现注意事项](#84-sql实现注意事项)
  - [📚 参考资源](#-参考资源)
    - [学术文献](#学术文献)
    - [PostgreSQL官方文档](#postgresql官方文档)
    - [在线资源](#在线资源)
    - [相关算法](#相关算法)

---

## 数值精度处理概述

**数值精度处理（Numeric Precision Handling）**用于控制数值的显示精度和计算精度，在金融计算、科学计算等领域尤为重要。PostgreSQL提供了多种精度处理函数和数据类型。

### 理论基础

#### 精度问题定义

**精度问题**：数值在计算机中的表示和计算存在精度限制：

1. **浮点数精度**：IEEE 754标准定义的浮点数表示
2. **舍入误差**：计算过程中的累积误差
3. **显示精度**：数值的显示格式

#### 精度处理方法

1. **四舍五入（Rounding）**：按规则舍入到指定精度
2. **截断（Truncation）**：直接截断到指定精度
3. **向上取整（Ceiling）**：向上舍入到整数
4. **向下取整（Flooring）**：向下舍入到整数

#### 数据类型精度

PostgreSQL数值类型精度：

- **NUMERIC(precision, scale)**：精确数值，precision总位数，scale小数位数
- **REAL**：单精度浮点数（约6位有效数字）
- **DOUBLE PRECISION**：双精度浮点数（约15位有效数字）

### 核心函数列表

| 函数名称 | 数学定义 | 用途 | 时间复杂度 | 适用场景 |
|---------|---------|------|-----------|---------|
| **ROUND()** | $\text{round}(x, n)$ | 四舍五入 | $O(1)$ | 通用舍入 |
| **TRUNC()** | $\text{trunc}(x, n)$ | 截断 | $O(1)$ | 精确截断 |
| **CEIL()** | $\lceil x \rceil$ | 向上取整 | $O(1)$ | 向上舍入 |
| **FLOOR()** | $\lfloor x \rfloor$ | 向下取整 | $O(1)$ | 向下舍入 |

---

## 1. 四舍五入

### 1.1 四舍五入原理

**四舍五入（Rounding）**是将数值按规则舍入到指定精度的操作。

#### 四舍五入规则

**标准四舍五入规则**：

- 如果小数部分 $\geq 0.5$，向上舍入
- 如果小数部分 $< 0.5$，向下舍入

**数学定义**：$\text{round}(x, n) = \lfloor x \times 10^n + 0.5 \rfloor / 10^n$

### 1.2 基本四舍五入实现

**基本四舍五入**的实现和使用。

```sql
-- 四舍五入（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始执行四舍五入测试';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '四舍五入准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 四舍五入到不同精度
SELECT
    value,
    ROUND(value, 2) AS rounded_2,
    ROUND(value, 0) AS rounded_0,
    ROUND(value, -2) AS rounded_neg2
FROM (VALUES
    (123.456789),
    (123.454789),
    (123.455789)
) AS t(value);

-- 性能测试：批量四舍五入
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    value,
    ROUND(value, 2) AS rounded_value
FROM (
    SELECT generate_series(1, 100000) AS id, random() * 1000 AS value
) AS test_data;
```

### 1.3 银行家舍入

**银行家舍入（Banker's Rounding）**：当小数部分恰好为0.5时，舍入到最近的偶数。

```sql
-- 银行家舍入（PostgreSQL默认使用标准四舍五入）
-- 注意：PostgreSQL的ROUND函数使用标准四舍五入，不是银行家舍入
SELECT
    value,
    ROUND(value, 0) AS standard_rounding,
    -- 银行家舍入实现（简化版）
    CASE
        WHEN value - FLOOR(value) = 0.5 THEN
            CASE WHEN FLOOR(value) % 2 = 0 THEN FLOOR(value) ELSE CEIL(value) END
        ELSE ROUND(value, 0)
    END AS bankers_rounding
FROM (VALUES
    (2.5),
    (3.5),
    (4.5),
    (5.5)
) AS t(value);
```

---

## 2. 截断

### 2.1 截断原理

**截断（Truncation）**是将数值直接截断到指定精度，不进行舍入。

#### 截断规则

**截断规则**：直接丢弃超出精度的部分，不进行任何舍入。

**数学定义**：$\text{trunc}(x, n) = \lfloor x \times 10^n \rfloor / 10^n$

### 2.2 基本截断实现

**基本截断**的实现和使用。

```sql
-- 截断（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始执行截断测试';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '截断准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 截断到不同精度
SELECT
    value,
    TRUNC(value, 2) AS truncated_2,
    TRUNC(value, 0) AS truncated_0,
    TRUNC(value, -2) AS truncated_neg2
FROM (VALUES
    (123.456789),
    (123.454789),
    (123.455789)
) AS t(value);

-- 性能测试：批量截断
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    value,
    TRUNC(value, 2) AS truncated_value
FROM (
    SELECT generate_series(1, 100000) AS id, random() * 1000 AS value
) AS test_data;
```

---

## 3. 取整函数

### 3.1 CEIL和FLOOR原理

**取整函数**用于将数值舍入到整数：

- **CEIL（向上取整）**：$\lceil x \rceil = \min\{n \in \mathbb{Z} \mid n \geq x\}$
- **FLOOR（向下取整）**：$\lfloor x \rfloor = \max\{n \in \mathbb{Z} \mid n \leq x\}$

### 3.2 CEIL和FLOOR实现

**CEIL和FLOOR**的实现和使用。

```sql
-- CEIL和FLOOR（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始执行取整函数测试';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '取整函数准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- CEIL和FLOOR对比
SELECT
    value,
    CEIL(value) AS ceil_value,
    FLOOR(value) AS floor_value,
    ROUND(value) AS round_value
FROM (VALUES
    (123.1),
    (123.5),
    (123.9),
    (-123.1),
    (-123.5),
    (-123.9)
) AS t(value);

-- 性能测试：批量取整
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    value,
    CEIL(value) AS ceil_value,
    FLOOR(value) AS floor_value
FROM (
    SELECT generate_series(1, 100000) AS id, random() * 1000 AS value
) AS test_data;
```

---

## 4. 精度控制

### 4.1 数据类型精度原理

**数据类型精度**控制数值的存储和计算精度。

#### NUMERIC精度

**NUMERIC(precision, scale)**：

- **precision**：总位数（1-1000）
- **scale**：小数位数（0-precision）
- **示例**：NUMERIC(10, 2)可以存储最多10位数字，其中2位是小数

#### 浮点数精度

**REAL和DOUBLE PRECISION**：

- **REAL**：单精度，约6位有效数字
- **DOUBLE PRECISION**：双精度，约15位有效数字
- **注意**：浮点数存在精度误差

### 4.2 数据类型精度实现

**数据类型精度**的实现和使用。

```sql
-- 精度控制（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始执行精度控制测试';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '精度控制准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 不同精度类型对比
SELECT
    value,
    value::NUMERIC(10, 2) AS numeric_10_2,
    value::NUMERIC(10, 4) AS numeric_10_4,
    value::REAL AS real_value,
    value::DOUBLE PRECISION AS double_value
FROM (VALUES
    (123.4567890123456789),
    (123.45),
    (123.4567)
) AS t(value);
```

### 4.3 精度转换

**精度转换**：在不同精度类型之间转换。

```sql
-- 精度转换（带错误处理）
DO $$
DECLARE
    numeric_value NUMERIC(10, 2) := 123.45;
    real_value REAL;
    double_value DOUBLE PRECISION;
BEGIN
    BEGIN
        -- NUMERIC转REAL
        real_value := numeric_value::REAL;
        RAISE NOTICE 'NUMERIC转REAL: % -> %', numeric_value, real_value;

        -- NUMERIC转DOUBLE PRECISION
        double_value := numeric_value::DOUBLE PRECISION;
        RAISE NOTICE 'NUMERIC转DOUBLE: % -> %', numeric_value, double_value;

        -- 注意精度损失
        RAISE NOTICE '精度损失警告：REAL和DOUBLE PRECISION可能存在精度误差';
    EXCEPTION
        WHEN numeric_value_out_of_range THEN
            RAISE WARNING '数值超出精度范围';
        WHEN OTHERS THEN
            RAISE WARNING '精度转换失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

---

## 5. 精度优化策略

### 5.1 精度选择优化

**精度选择优化**：根据应用场景选择合适的精度。

```sql
-- 精度选择优化（带错误处理）
DO $$
BEGIN
    BEGIN
        -- 金融数据：使用NUMERIC(15, 2)
        CREATE TABLE IF NOT EXISTS financial_data (
            id SERIAL PRIMARY KEY,
            amount NUMERIC(15, 2) NOT NULL,  -- 高精度，2位小数
            rate NUMERIC(10, 6) NOT NULL      -- 利率，6位小数
        );

        -- 科学数据：使用DOUBLE PRECISION
        CREATE TABLE IF NOT EXISTS scientific_data (
            id SERIAL PRIMARY KEY,
            value DOUBLE PRECISION NOT NULL   -- 高精度浮点
        );

        RAISE NOTICE '精度选择优化表创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '精度选择优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.2 计算精度优化

**计算精度优化**：在计算过程中保持精度。

```sql
-- 计算精度优化（带错误处理）
DO $$
DECLARE
    value1 NUMERIC(10, 2) := 100.50;
    value2 NUMERIC(10, 2) := 50.25;
    result NUMERIC(10, 2);
BEGIN
    BEGIN
        -- 保持精度：使用NUMERIC类型进行计算
        result := value1 + value2;
        RAISE NOTICE '计算结果: % + % = %', value1, value2, result;

        -- 精度控制：使用ROUND控制结果精度
        result := ROUND(value1 * value2, 2);
        RAISE NOTICE '乘法结果（保留2位小数）: % * % = %', value1, value2, result;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '计算精度优化失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 5.3 显示精度优化

**显示精度优化**：优化数值的显示格式。

```sql
-- 显示精度优化（带错误处理）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始执行显示精度优化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '显示精度优化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 不同格式的数值显示
SELECT
    amount,
    TO_CHAR(amount, 'FM$999,999,999.00') AS currency_format,
    TO_CHAR(amount, '999,999,999.00') AS number_format,
    TO_CHAR(amount, 'FM999,999,999.00') AS compact_format,
    ROUND(amount, 2) AS rounded_amount
FROM (VALUES
    (1234567.89),
    (123.45),
    (0.99)
) AS t(amount);
```

---

## 6. PostgreSQL 18 并行精度处理增强

**PostgreSQL 18** 显著增强了并行精度处理能力，支持并行执行四舍五入、截断、取整和精度控制操作，大幅提升大规模精度处理的性能。

### 6.1 并行精度处理原理

PostgreSQL 18 的并行精度处理通过以下方式实现：

1. **并行扫描**：多个工作进程并行扫描数据
2. **并行精度计算**：每个工作进程独立执行精度处理
3. **并行格式化**：并行执行数值格式化
4. **结果合并**：主进程合并所有工作进程的处理结果

### 6.2 并行四舍五入和截断

```sql
-- PostgreSQL 18 并行四舍五入和截断（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'numeric_data') THEN
            RAISE WARNING '表 numeric_data 不存在，无法执行并行四舍五入和截断';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行四舍五入和截断';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行四舍五入和截断准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行四舍五入和截断
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    value,
    ROUND(value, 2) AS rounded_2,
    ROUND(value, 4) AS rounded_4,
    TRUNC(value, 2) AS truncated_2,
    TRUNC(value, 4) AS truncated_4,
    CEIL(value) AS ceiling_value,
    FLOOR(value) AS floor_value
FROM numeric_data
WHERE value IS NOT NULL;
```

### 6.3 并行精度控制

```sql
-- PostgreSQL 18 并行精度控制（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'financial_data') THEN
            RAISE WARNING '表 financial_data 不存在，无法执行并行精度控制';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行PostgreSQL 18并行精度控制';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '并行精度控制准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;

-- 并行精度控制：金融数据格式化
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    amount,
    ROUND(amount::NUMERIC, 2) AS amount_2_decimal,
    ROUND(amount::NUMERIC, 4) AS amount_4_decimal,
    TO_CHAR(amount, 'FM999,999,999.00') AS formatted_amount
FROM financial_data
WHERE amount IS NOT NULL;
```

---

## 7. 实际应用案例

### 6.1 金融计算：金额格式化

**金额格式化**：将数值格式化为货币格式。

```sql
-- 金额格式化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'transactions') THEN
            RAISE WARNING '表 transactions 不存在，无法执行金额格式化';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行金额格式化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '金额格式化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 金额格式化查询
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    transaction_id,
    amount,
    ROUND(amount, 2) AS rounded_amount,
    TO_CHAR(ROUND(amount, 2), 'FM$999,999,999.00') AS formatted_amount,
    TRUNC(amount, 2) AS truncated_amount
FROM transactions
ORDER BY amount DESC;
```

### 6.2 统计分析：精度控制

**统计分析精度控制**：在统计分析中控制精度。

```sql
-- 统计分析精度控制（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'statistical_data') THEN
            RAISE WARNING '表 statistical_data 不存在，无法执行统计分析';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行统计分析精度控制';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '统计分析准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 统计分析：控制统计量的精度
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    category,
    COUNT(*) AS count,
    ROUND(AVG(value), 2) AS avg_value,
    ROUND(STDDEV(value), 2) AS stddev_value,
    ROUND(MIN(value), 2) AS min_value,
    ROUND(MAX(value), 2) AS max_value
FROM statistical_data
GROUP BY category
ORDER BY avg_value DESC;
```

### 6.3 科学计算：精度管理

**科学计算精度管理**：在科学计算中管理精度。

```sql
-- 科学计算精度管理（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'scientific_measurements') THEN
            RAISE WARNING '表 scientific_measurements 不存在，无法执行科学计算';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行科学计算精度管理';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '科学计算准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 科学计算：使用DOUBLE PRECISION保持高精度
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    measurement_id,
    value::DOUBLE PRECISION AS high_precision_value,
    ROUND(value::DOUBLE PRECISION, 6) AS rounded_6_decimal,
    LOG(10, value::DOUBLE PRECISION) AS log_value
FROM scientific_measurements
WHERE value > 0
ORDER BY value;
```

### 6.4 数据展示：格式化输出

**数据展示格式化**：优化数据的显示格式。

```sql
-- 数据展示格式化（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'report_data') THEN
            RAISE WARNING '表 report_data 不存在，无法执行数据展示格式化';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行数据展示格式化';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '数据展示格式化准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 数据展示：多种格式化选项
EXPLAIN (ANALYZE, BUFFERS, TIMING, VERBOSE)
SELECT
    id,
    value,
    ROUND(value, 2) AS rounded_2,
    TRUNC(value, 2) AS truncated_2,
    TO_CHAR(value, 'FM999,999,999.00') AS formatted_value,
    CASE
        WHEN value >= 1000 THEN TO_CHAR(value / 1000, 'FM999.99') || 'K'
        ELSE TO_CHAR(value, 'FM999.99')
    END AS compact_format
FROM report_data
ORDER BY value DESC;
```

---

## 8. 算法性能对比与优化

### 7.1 精度处理方法对比

| 方法 | 数学定义 | 用途 | 时间复杂度 | 适用场景 | 优点 | 缺点 |
|------|---------|------|-----------|---------|------|------|
| **ROUND** | $\lfloor x \times 10^n + 0.5 \rfloor / 10^n$ | 四舍五入 | $O(1)$ | 通用舍入 | 标准方法 | 可能偏差 |
| **TRUNC** | $\lfloor x \times 10^n \rfloor / 10^n$ | 截断 | $O(1)$ | 精确截断 | 无偏差 | 可能损失精度 |
| **CEIL** | $\lceil x \rceil$ | 向上取整 | $O(1)$ | 向上舍入 | 保证上界 | 可能高估 |
| **FLOOR** | $\lfloor x \rfloor$ | 向下取整 | $O(1)$ | 向下舍入 | 保证下界 | 可能低估 |

### 7.2 性能优化建议

1. **数据类型选择**：
   - 金融计算使用NUMERIC类型
   - 科学计算使用DOUBLE PRECISION类型

2. **精度设置**：
   - 根据实际需求设置精度
   - 避免过度精度导致性能下降

3. **批量处理**：
   - 使用批量操作提高性能
   - 避免逐行精度处理

4. **函数优化**：
   - 使用IMMUTABLE函数创建函数索引
   - 缓存精度转换结果

### 7.3 常见问题与解决方案

**问题1**：精度丢失

- **解决方案**：使用NUMERIC类型，避免REAL/DOUBLE PRECISION

**问题2**：舍入误差累积

- **解决方案**：在最终结果时进行舍入，避免中间结果舍入

**问题3**：显示格式不符合预期

- **解决方案**：使用TO_CHAR函数格式化输出

**问题4**：精度设置不合理

- **解决方案**：根据业务需求设置合适的精度

---

## 9. 最佳实践

### 8.1 数据类型选择

1. **金融计算**：使用NUMERIC(precision, scale)
2. **科学计算**：使用DOUBLE PRECISION
3. **整数计算**：使用INTEGER/BIGINT

### 8.2 精度设置

1. **金额**：NUMERIC(15, 2)（2位小数）
2. **利率**：NUMERIC(10, 6)（6位小数）
3. **百分比**：NUMERIC(5, 2)（2位小数）

### 8.3 舍入策略

1. **金融计算**：使用ROUND四舍五入
2. **统计分析**：根据需求选择ROUND或TRUNC
3. **科学计算**：保持高精度，最后显示时舍入

### 8.4 SQL实现注意事项

1. **精度一致性**：确保计算过程中的精度一致
2. **舍入时机**：在最终结果时进行舍入
3. **格式显示**：使用TO_CHAR函数格式化输出
4. **性能考虑**：避免过度精度导致性能下降

---

## 📚 参考资源

### 学术文献

- 《数值分析》（Numerical Analysis）- 数值精度理论
- 《金融数学》（Financial Mathematics）- 金融计算精度

### PostgreSQL官方文档

- [数值类型](https://www.postgresql.org/docs/current/datatype-numeric.html)
- [数学函数](https://www.postgresql.org/docs/current/functions-math.html)
- [格式化函数](https://www.postgresql.org/docs/current/functions-formatting.html)

### 在线资源

- PostgreSQL数值精度指南
- 金融计算最佳实践
- 科学计算精度管理

### 相关算法

- [基础数学函数](./基础数学函数.md) - 基础数学运算
- [高级数学计算](./高级数学计算.md) - 高级计算
- [数学算法实现](./数学算法实现.md) - 算法实现

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
