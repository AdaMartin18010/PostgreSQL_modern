# PostgreSQL向量数据库建模完整指南

> **创建日期**: 2025年1月
> **来源**: pgvector官方文档 + PostgreSQL 18新特性 + 实践总结
> **状态**: PostgreSQL 18+新特性
> **文档编号**: 08-07

---

## 📑 目录

- [PostgreSQL向量数据库建模完整指南](#postgresql向量数据库建模完整指南)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 什么是向量数据库](#11-什么是向量数据库)
    - [1.2 pgvector简介](#12-pgvector简介)
    - [1.3 应用场景](#13-应用场景)
  - [1.4 理论基础](#14-理论基础)
    - [1.4.1 向量相似度理论](#141-向量相似度理论)
    - [1.4.2 HNSW索引理论](#142-hnsw索引理论)
    - [1.4.3 IVFFlat索引理论](#143-ivfflat索引理论)
    - [1.4.4 向量维度理论](#144-向量维度理论)
    - [1.4.5 复杂度分析](#145-复杂度分析)
  - [2. 数据类型选择](#2-数据类型选择)
    - [2.1 vector类型](#21-vector类型)
    - [2.2 维度选择](#22-维度选择)
    - [2.3 精度选择](#23-精度选择)
  - [3. 索引策略](#3-索引策略)
    - [3.1 HNSW索引](#31-hnsw索引)
    - [3.2 IVFFlat索引](#32-ivfflat索引)
    - [3.3 索引选择指南](#33-索引选择指南)
  - [4. 查询模式](#4-查询模式)
    - [4.1 向量相似度查询](#41-向量相似度查询)
    - [4.2 KNN查询](#42-knn查询)
    - [4.3 范围查询](#43-范围查询)
  - [5. 混合搜索建模](#5-混合搜索建模)
    - [5.1 向量+全文搜索](#51-向量全文搜索)
    - [5.2 向量+关系查询](#52-向量关系查询)
    - [5.3 多模态查询优化](#53-多模态查询优化)
  - [6. RAG应用建模](#6-rag应用建模)
    - [6.1 文档向量化](#61-文档向量化)
    - [6.2 检索策略](#62-检索策略)
    - [6.3 上下文管理](#63-上下文管理)
  - [7. 分区策略](#7-分区策略)
    - [7.1 向量数据分区](#71-向量数据分区)
    - [7.2 性能优化](#72-性能优化)
  - [8. PostgreSQL 18优化](#8-postgresql-18优化)
    - [8.1 异步I/O优化](#81-异步io优化)
    - [8.2 GIN并行构建优化](#82-gin并行构建优化)
  - [9. 性能优化建议](#9-性能优化建议)
    - [9.1 索引参数调优](#91-索引参数调优)
    - [9.2 查询优化策略](#92-查询优化策略)
    - [9.3 批量操作优化](#93-批量操作优化)
    - [9.4 分区优化策略](#94-分区优化策略)
    - [9.5 PostgreSQL 18异步I/O优化](#95-postgresql-18异步io优化)
  - [10. 最佳实践](#10-最佳实践)
    - [10.1 设计原则](#101-设计原则)
    - [10.2 性能优化](#102-性能优化)
    - [10.3 监控和维护](#103-监控和维护)
    - [10.4 SQL实现注意事项](#104-sql实现注意事项)
  - [11. 常见问题与解决方案](#11-常见问题与解决方案)
    - [问题1: 索引创建失败](#问题1-索引创建失败)
    - [问题2: 查询性能慢](#问题2-查询性能慢)
    - [问题3: 索引占用空间过大](#问题3-索引占用空间过大)
    - [问题4: 向量相似度计算不准确](#问题4-向量相似度计算不准确)
  - [12. 相关资源](#12-相关资源)
    - [12.1 核心相关文档](#121-核心相关文档)
    - [12.2 官方资源](#122-官方资源)
    - [12.3 应用案例](#123-应用案例)

---

## 1. 概述

### 1.1 什么是向量数据库

向量数据库专门用于存储和查询高维向量数据，支持相似度搜索和最近邻查询。

**核心特性**:

- 高维向量存储（通常128-1536维）
- 相似度搜索（余弦相似度、欧氏距离等）
- 最近邻查询（KNN）
- 大规模向量检索

### 1.2 pgvector简介

pgvector是PostgreSQL的向量数据库扩展，提供：

- `vector`数据类型
- HNSW和IVFFlat索引
- 向量相似度操作符
- 与PostgreSQL原生集成

**版本要求**:

- PostgreSQL 11+
- pgvector 0.5.0+（推荐0.7.0+）
- PostgreSQL 18+（推荐，支持异步I/O和GIN并行构建）⭐

### 1.3 应用场景

**AI/ML应用**:

- 语义搜索
- 推荐系统
- 图像检索
- 语音识别

**RAG应用**:

- 文档检索
- 知识库问答
- 代码搜索

**推荐系统**:

- 商品推荐
- 内容推荐
- 用户相似度匹配

---

## 1.4 理论基础

### 1.4.1 向量相似度理论

**向量相似度**是衡量两个向量相似程度的指标：

**余弦相似度（Cosine Similarity）**:

$$\text{cos}(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{||\mathbf{A}|| \times ||\mathbf{B}||} = \frac{\sum_{i=1}^{n} A_i B_i}{\sqrt{\sum_{i=1}^{n} A_i^2} \times \sqrt{\sum_{i=1}^{n} B_i^2}}$$

- 取值范围: $[-1, 1]$
- 值越大，相似度越高
- 不受向量长度影响

**欧氏距离（Euclidean Distance）**:

$$d(\mathbf{A}, \mathbf{B}) = ||\mathbf{A} - \mathbf{B}||_2 = \sqrt{\sum_{i=1}^{n} (A_i - B_i)^2}$$

- 取值范围: $[0, +\infty)$
- 值越小，相似度越高
- 受向量长度影响

**点积（Dot Product）**:

$$\mathbf{A} \cdot \mathbf{B} = \sum_{i=1}^{n} A_i B_i$$

- 取值范围: $(-\infty, +\infty)$
- 值越大，相似度越高（假设向量已归一化）

### 1.4.2 HNSW索引理论

**HNSW（Hierarchical Navigable Small World）**是一种近似最近邻搜索算法：

**算法原理**:

1. **分层结构**: 构建多层图结构
2. **上层稀疏**: 上层节点少，连接稀疏
3. **下层密集**: 下层节点多，连接密集
4. **贪心搜索**: 从上层开始，逐层向下搜索

**复杂度分析**:

- **构建复杂度**: $O(N \log N)$
- **搜索复杂度**: $O(\log N)$ (近似)
- **空间复杂度**: $O(N)$

**参数说明**:

- **m**: 每个节点的最大连接数（通常16-32）
- **ef_construction**: 构建时的搜索范围（通常64-200）
- **ef_search**: 查询时的搜索范围（通常40-200）

### 1.4.3 IVFFlat索引理论

**IVFFlat（Inverted File with Flat Compression）**是一种基于聚类的索引：

**算法原理**:

1. **聚类**: 将向量聚类成多个中心
2. **倒排索引**: 为每个中心建立倒排列表
3. **搜索**: 在最近的几个中心中搜索

**复杂度分析**:

- **构建复杂度**: $O(N \log N)$
- **搜索复杂度**: $O(\sqrt{N})$ (近似)
- **空间复杂度**: $O(N)$

**参数说明**:

- **lists**: 聚类中心数量（通常$\sqrt{N}$）

### 1.4.4 向量维度理论

**维度选择原则**:

- **低维（<128）**: 计算快，但表达能力弱
- **中维（128-512）**: 平衡性能和表达能力
- **高维（>512）**: 表达能力强，但计算慢

**维度诅咒（Curse of Dimensionality）**:

- 高维空间中，所有点都变得相似
- 需要更多数据才能有效学习
- 计算复杂度随维度指数增长

### 1.4.5 复杂度分析

**存储复杂度**:

- **向量存储**: $O(N \times D)$ where N is number of vectors, D is dimension
- **HNSW索引**: $O(N \times m)$ where m is connection count
- **IVFFlat索引**: $O(N)$

**查询复杂度**:

- **线性搜索**: $O(N \times D)$
- **HNSW搜索**: $O(\log N \times D)$ (近似)
- **IVFFlat搜索**: $O(\sqrt{N} \times D)$ (近似)

---

## 2. 数据类型选择

### 2.1 vector类型

**语法**:

```sql
-- 创建vector类型列（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS documents (
        id SERIAL PRIMARY KEY,
        content TEXT NOT NULL,
        embedding vector(1536)  -- 1536维向量（OpenAI text-embedding-3-large）
    );
    RAISE NOTICE '表 documents 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 documents 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 documents 失败: %', SQLERRM;
END $$;
```

**维度选择**:

| 模型 | 维度 | 推荐用途 |
|------|------|---------|
| **OpenAI text-embedding-ada-002** | 1536 | 通用文本嵌入 |
| **OpenAI text-embedding-3-small** | 1536 | 通用文本嵌入 |
| **OpenAI text-embedding-3-large** | 3072 | 高质量文本嵌入 |
| **sentence-transformers/all-MiniLM-L6-v2** | 384 | 轻量级文本嵌入 |
| **sentence-transformers/all-mpnet-base-v2** | 768 | 高质量文本嵌入 |

### 2.2 维度选择

**选择原则**:

1. **模型输出维度**: 使用嵌入模型的输出维度
2. **性能平衡**: 维度越高，精度越高，但查询越慢
3. **存储成本**: 维度越高，存储空间越大

**推荐配置**:

```sql
-- 通用场景：1536维（OpenAI标准，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS documents (
        id SERIAL PRIMARY KEY,
        content TEXT NOT NULL,
        embedding vector(1536)
    );
    RAISE NOTICE '表 documents 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 documents 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 documents 失败: %', SQLERRM;
END $$;

-- 高性能场景：384维（轻量级模型，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS documents_fast (
        id SERIAL PRIMARY KEY,
        content TEXT NOT NULL,
        embedding vector(384)
    );
    RAISE NOTICE '表 documents_fast 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 documents_fast 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 documents_fast 失败: %', SQLERRM;
END $$;

-- 高质量场景：3072维（高质量模型，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS documents_quality (
        id SERIAL PRIMARY KEY,
        content TEXT NOT NULL,
        embedding vector(3072)
    );
    RAISE NOTICE '表 documents_quality 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 documents_quality 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 documents_quality 失败: %', SQLERRM;
END $$;
```

### 2.3 精度选择

**vector类型精度**:

- PostgreSQL默认使用`real`（32位浮点数）
- 精度足够，性能更好
- 如需更高精度，可使用`double precision`（需要自定义类型）

---

## 3. 索引策略

### 3.1 HNSW索引

**定义**: Hierarchical Navigable Small World，分层导航小世界索引，适用于大规模向量检索。

**特点**:

- 查询速度快（O(log n)）
- 索引构建慢
- 索引占用空间大
- 支持精确和近似搜索

**PostgreSQL实现**:

```sql
-- 创建HNSW索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_documents_embedding_hnsw
    ON documents USING hnsw (embedding vector_cosine_ops);
    RAISE NOTICE 'HNSW索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建HNSW索引失败: %', SQLERRM;
END $$;

-- HNSW索引参数（带错误处理）
DO $$
BEGIN
    DROP INDEX IF EXISTS idx_documents_embedding_hnsw;
    CREATE INDEX idx_documents_embedding_hnsw
    ON documents USING hnsw (embedding vector_cosine_ops)
    WITH (
        m = 16,        -- 每个节点的连接数（默认16，范围4-64）
        ef_construction = 64  -- 构建时的搜索范围（默认64，范围4-1000）
    );
    RAISE NOTICE 'HNSW索引（带参数）创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建HNSW索引失败: %', SQLERRM;
END $$;
```

**参数调优**:

| 参数 | 默认值 | 推荐值 | 说明 |
|------|--------|--------|------|
| **m** | 16 | 16-32 | 越大，查询越快，但索引越大 |
| **ef_construction** | 64 | 64-200 | 越大，索引质量越高，但构建越慢 |

**适用场景**:

- 大规模向量检索（百万级以上）
- 高精度要求
- 查询性能优先

### 3.2 IVFFlat索引

**定义**: Inverted File with Flat Compression，倒排文件索引，适用于中等规模向量检索。

**特点**:

- 索引构建快
- 索引占用空间小
- 查询速度中等
- 需要预训练（聚类）

**PostgreSQL实现**:

```sql
-- 创建IVFFlat索引（需要先有数据，带错误处理）
-- 1. 插入足够的数据（至少lists数量×1000）
-- INSERT INTO documents (content, embedding) VALUES ...;

-- 2. 创建IVFFlat索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_documents_embedding_ivfflat
    ON documents USING ivfflat (embedding vector_cosine_ops)
    WITH (
        lists = 100  -- 聚类数量（默认100，推荐：sqrt(行数)）
    );
    RAISE NOTICE 'IVFFlat索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建IVFFlat索引失败: %', SQLERRM;
END $$;
```

**参数调优**:

| 参数 | 默认值 | 推荐值 | 说明 |
|------|--------|--------|------|
| **lists** | 100 | sqrt(行数) | 聚类数量，影响查询精度 |

**适用场景**:

- 中等规模向量检索（10万-100万）
- 索引构建速度优先
- 存储空间受限

### 3.3 索引选择指南

**决策树**:

```
数据规模？
├─ < 10万行 → 无需索引（全表扫描）
├─ 10万-100万行 → IVFFlat索引
└─ > 100万行 → HNSW索引 ⭐
```

**对比矩阵**:

| 索引类型 | 构建速度 | 查询速度 | 索引大小 | 精度 | 适用规模 |
|---------|---------|---------|---------|------|---------|
| **无索引** | - | 慢 | 0 | 100% | < 10万 |
| **IVFFlat** | 快 | 中等 | 小 | 90-95% | 10万-100万 |
| **HNSW** | 慢 | **快** | **大** | **95-99%** | **> 100万** ⭐ |

---

## 4. 查询模式

### 4.1 向量相似度查询

**余弦相似度**（最常用）:

```sql
-- 余弦相似度查询（1 - 距离，值越大越相似，带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行余弦相似度查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, content, 1 - (embedding <=> $1::vector) AS similarity
FROM documents
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 使用索引加速（带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行索引加速查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, content
FROM documents
ORDER BY embedding <=> $1::vector
LIMIT 10;
-- Index Scan using idx_documents_embedding_hnsw
```

**欧氏距离**:

```sql
-- 欧氏距离查询（距离越小越相似，带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行欧氏距离查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, content, embedding <-> $1::vector AS distance
FROM documents
ORDER BY embedding <-> $1::vector
LIMIT 10;
```

**内积**:

```sql
-- 内积查询（值越大越相似，带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行内积查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, content, embedding <#> $1::vector AS inner_product
FROM documents
ORDER BY embedding <#> $1::vector DESC
LIMIT 10;
```

### 4.2 KNN查询

**K最近邻查询**:

```sql
-- KNN查询（K=10，带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行KNN查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, content, embedding <=> $1::vector AS distance
FROM documents
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 带阈值过滤的KNN查询（带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行带阈值过滤的KNN查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, content, embedding <=> $1::vector AS distance
FROM documents
WHERE embedding <=> $1::vector < 0.3  -- 相似度阈值
ORDER BY embedding <=> $1::vector
LIMIT 10;
```

### 4.3 范围查询

**范围查询**:

```sql
-- 范围查询（距离小于阈值，带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行范围查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, content, embedding <=> $1::vector AS distance
FROM documents
WHERE embedding <=> $1::vector < 0.5  -- 距离阈值
ORDER BY embedding <=> $1::vector;
```

---

## 5. 混合搜索建模

### 5.1 向量+全文搜索

**场景**: 结合语义搜索和关键词搜索，提供更准确的检索结果。

**数据模型**:

```sql
-- Documents表创建（混合搜索，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'documents') THEN
        CREATE TABLE documents (
            id SERIAL PRIMARY KEY,
            title TEXT NOT NULL,
            content TEXT NOT NULL,
            embedding vector(1536),  -- 向量嵌入
            search_vector tsvector,  -- 全文搜索向量
            metadata JSONB DEFAULT '{}'
        );
        RAISE NOTICE '表 documents 创建成功';
    ELSE
        RAISE NOTICE '表 documents 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 documents 失败: %', SQLERRM;
END $$;

-- 创建向量索引（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'documents') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_documents_embedding_hnsw') THEN
            CREATE INDEX idx_documents_embedding_hnsw
            ON documents USING hnsw (embedding vector_cosine_ops);
            RAISE NOTICE '向量HNSW索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_documents_embedding_hnsw 已存在，跳过创建';
        END IF;
    ELSE
        RAISE NOTICE '表 documents 不存在，跳过索引创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建向量HNSW索引失败: %', SQLERRM;
END $$;

-- 创建全文搜索索引（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'documents') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_documents_search_vector_gin') THEN
            CREATE INDEX idx_documents_search_vector_gin
            ON documents USING GIN (search_vector);
            RAISE NOTICE '全文搜索GIN索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_documents_search_vector_gin 已存在，跳过创建';
        END IF;
    ELSE
        RAISE NOTICE '表 documents 不存在，跳过索引创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建全文搜索GIN索引失败: %', SQLERRM;
END $$;

-- 自动更新全文搜索向量（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'documents') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_search_vector') THEN
            CREATE TRIGGER update_search_vector
            BEFORE INSERT OR UPDATE ON documents
            FOR EACH ROW
            EXECUTE FUNCTION tsvector_update_trigger(
                search_vector, 'pg_catalog.english', title, content
            );
            RAISE NOTICE '全文搜索向量更新触发器创建成功';
        ELSE
            RAISE NOTICE '触发器 update_search_vector 已存在，跳过创建';
        END IF;
    ELSE
        RAISE NOTICE '表 documents 不存在，跳过触发器创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建全文搜索向量更新触发器失败: %', SQLERRM;
END $$;
```

**混合查询**:

```sql
-- 混合搜索查询（向量相似度 + 全文搜索，带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行混合搜索查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH vector_results AS (
    SELECT id, title, content, embedding <=> $1::vector AS vector_distance
    FROM documents
    ORDER BY embedding <=> $1::vector
    LIMIT 50
),
text_results AS (
    SELECT id, title, content, ts_rank(search_vector, $2::tsquery) AS text_rank
    FROM documents
    WHERE search_vector @@ $2::tsquery
    ORDER BY text_rank DESC
    LIMIT 50
)
SELECT
    COALESCE(v.id, t.id) AS id,
    COALESCE(v.title, t.title) AS title,
    COALESCE(v.content, t.content) AS content,
    COALESCE(1 - v.vector_distance, 0) * 0.6 + COALESCE(t.text_rank, 0) * 0.4 AS combined_score
FROM vector_results v
FULL OUTER JOIN text_results t ON v.id = t.id
ORDER BY combined_score DESC
LIMIT 10;
```

**性能优化**:

- PostgreSQL 18异步I/O提升向量检索性能
- GIN并行构建提升全文搜索索引构建速度

### 5.2 向量+关系查询

**场景**: 结合向量相似度和业务关系查询。

**数据模型**:

```sql
-- Products表创建（向量+关系查询，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'products') THEN
        CREATE TABLE products (
            id SERIAL PRIMARY KEY,
            name TEXT NOT NULL,
            description TEXT,
            category_id INTEGER NOT NULL,
            price NUMERIC(10,2),
            embedding vector(1536),
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
        RAISE NOTICE '表 products 创建成功';
    ELSE
        RAISE NOTICE '表 products 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 products 失败: %', SQLERRM;
END $$;

-- 创建向量索引（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'products') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_embedding_hnsw') THEN
            CREATE INDEX idx_products_embedding_hnsw
            ON products USING hnsw (embedding vector_cosine_ops);
            RAISE NOTICE '向量HNSW索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_products_embedding_hnsw 已存在，跳过创建';
        END IF;
    ELSE
        RAISE NOTICE '表 products 不存在，跳过索引创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建向量HNSW索引失败: %', SQLERRM;
END $$;

-- 创建业务索引（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'products') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_category') THEN
            CREATE INDEX idx_products_category ON products(category_id);
            RAISE NOTICE '分类索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_products_category 已存在，跳过创建';
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_products_price') THEN
            CREATE INDEX idx_products_price ON products(price);
            RAISE NOTICE '价格索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_products_price 已存在，跳过创建';
        END IF;
    ELSE
        RAISE NOTICE '表 products 不存在，跳过索引创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建业务索引失败: %', SQLERRM;
END $$;
```

**混合查询**:

```sql
-- 向量相似度 + 业务过滤（带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'products') THEN
            RAISE WARNING '表 products 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行向量相似度+业务过滤查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT id, name, description, price,
       embedding <=> $1::vector AS distance
FROM products
WHERE category_id = $2  -- 业务过滤
  AND price BETWEEN $3 AND $4  -- 价格范围
ORDER BY embedding <=> $1::vector
LIMIT 20;
```

### 5.3 多模态查询优化

**场景**: 同时查询文本、图像、音频等多种模态的数据。

**数据模型**:

```sql
-- Multimedia content表创建（多模态，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'multimedia_content') THEN
        CREATE TABLE multimedia_content (
            id SERIAL PRIMARY KEY,
            content_type TEXT NOT NULL CHECK (content_type IN ('text', 'image', 'audio')),
            text_content TEXT,
            image_path TEXT,
            audio_path TEXT,
            text_embedding vector(1536),  -- 文本向量
            image_embedding vector(512),  -- 图像向量
            audio_embedding vector(128),  -- 音频向量
            metadata JSONB DEFAULT '{}'
        );
        RAISE NOTICE '表 multimedia_content 创建成功';
    ELSE
        RAISE NOTICE '表 multimedia_content 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 multimedia_content 失败: %', SQLERRM;
END $$;

-- 创建多模态向量索引（带错误处理）
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'multimedia_content') THEN
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_multimedia_text_embedding_hnsw') THEN
            CREATE INDEX idx_multimedia_text_embedding_hnsw
            ON multimedia_content USING hnsw (text_embedding vector_cosine_ops);
            RAISE NOTICE '文本向量HNSW索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_multimedia_text_embedding_hnsw 已存在，跳过创建';
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_multimedia_image_embedding_hnsw') THEN
            CREATE INDEX idx_multimedia_image_embedding_hnsw
            ON multimedia_content USING hnsw (image_embedding vector_cosine_ops);
            RAISE NOTICE '图像向量HNSW索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_multimedia_image_embedding_hnsw 已存在，跳过创建';
        END IF;
        
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_multimedia_audio_embedding_hnsw') THEN
            CREATE INDEX idx_multimedia_audio_embedding_hnsw
            ON multimedia_content USING hnsw (audio_embedding vector_cosine_ops);
            RAISE NOTICE '音频向量HNSW索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_multimedia_audio_embedding_hnsw 已存在，跳过创建';
        END IF;
    ELSE
        RAISE NOTICE '表 multimedia_content 不存在，跳过索引创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建多模态向量索引失败: %', SQLERRM;
END $$;
```

**多模态查询**:

```sql
-- 多模态相似度查询（带性能测试和错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'multimedia_content') THEN
            RAISE WARNING '表 multimedia_content 不存在，无法执行查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行多模态相似度查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH text_results AS (
    SELECT id, content_type, text_embedding <=> $1::vector AS distance
    FROM multimedia_content
    WHERE content_type = 'text'
    ORDER BY text_embedding <=> $1::vector
    LIMIT 10
),
image_results AS (
    SELECT id, content_type, image_embedding <=> $2::vector AS distance
    FROM multimedia_content
    WHERE content_type = 'image'
    ORDER BY image_embedding <=> $2::vector
    LIMIT 10
)
SELECT * FROM text_results
UNION ALL
SELECT * FROM image_results
ORDER BY distance;
```

---

## 6. RAG应用建模

### 6.1 文档向量化

**文档分块策略**:

```sql
-- 创建文档分块表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_chunks') THEN
            CREATE TABLE document_chunks (
                id SERIAL PRIMARY KEY,
                document_id INTEGER NOT NULL,
                chunk_index INTEGER NOT NULL,
                chunk_text TEXT NOT NULL,
                embedding vector(1536) NOT NULL,
                metadata JSONB DEFAULT '{}',
                created_at TIMESTAMPTZ DEFAULT NOW(),
                UNIQUE(document_id, chunk_index)
            );
            RAISE NOTICE '表 document_chunks 创建成功';
        ELSE
            RAISE NOTICE '表 document_chunks 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 document_chunks 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表 document_chunks 失败: %', SQLERRM;
    END;
END $$;

-- 创建向量索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_chunks') THEN
            RAISE WARNING '表 document_chunks 不存在，无法创建索引';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_document_chunks_embedding_hnsw') THEN
            CREATE INDEX idx_document_chunks_embedding_hnsw
            ON document_chunks USING hnsw (embedding vector_cosine_ops);
            RAISE NOTICE '向量HNSW索引 idx_document_chunks_embedding_hnsw 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_document_chunks_embedding_hnsw 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 document_chunks 不存在';
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建向量HNSW索引失败: %', SQLERRM;
    END;
END $$;

-- 创建文档索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_chunks') THEN
            RAISE WARNING '表 document_chunks 不存在，无法创建索引';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_document_chunks_document_id') THEN
            CREATE INDEX idx_document_chunks_document_id
            ON document_chunks(document_id);
            RAISE NOTICE '索引 idx_document_chunks_document_id 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_document_chunks_document_id 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 document_chunks 不存在';
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
    END;
END $$;
```

**分块策略**:

1. **固定大小分块**: 每块500-1000字符
2. **重叠分块**: 相邻块重叠50-100字符
3. **语义分块**: 按段落或句子分块

### 6.2 检索策略

**检索流程**:

```sql
-- RAG检索函数
CREATE OR REPLACE FUNCTION rag_retrieve(
    query_embedding vector(1536),
    top_k INTEGER DEFAULT 10,
    similarity_threshold FLOAT DEFAULT 0.7
)
RETURNS TABLE (
    chunk_id INTEGER,
    document_id INTEGER,
    chunk_text TEXT,
    similarity FLOAT
) AS $$
BEGIN
    BEGIN
        -- 参数验证
        IF query_embedding IS NULL THEN
            RAISE EXCEPTION 'query_embedding不能为NULL';
        END IF;

        IF top_k IS NULL OR top_k <= 0 THEN
            RAISE EXCEPTION 'top_k必须大于0';
        END IF;

        IF similarity_threshold IS NULL OR similarity_threshold < 0 OR similarity_threshold > 1 THEN
            RAISE EXCEPTION 'similarity_threshold必须在0-1之间';
        END IF;

        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'document_chunks') THEN
            RAISE EXCEPTION '表 document_chunks 不存在';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '参数验证失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        RETURN QUERY
        SELECT
            dc.id,
            dc.document_id,
            dc.chunk_text,
            1 - (dc.embedding <=> query_embedding) AS similarity
        FROM document_chunks dc
        WHERE 1 - (dc.embedding <=> query_embedding) >= similarity_threshold
        ORDER BY dc.embedding <=> query_embedding
        LIMIT top_k;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'RAG检索失败: %', SQLERRM;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql;
```

**重排序策略**:

```sql
-- 带重排序的RAG检索
WITH initial_results AS (
    SELECT id, chunk_text, embedding <=> $1::vector AS distance
    FROM document_chunks
    ORDER BY embedding <=> $1::vector
    LIMIT 50
),
reranked_results AS (
    SELECT
        id,
        chunk_text,
        1 - distance AS similarity,
        -- 重排序：结合相似度和业务权重
        (1 - distance) * 0.7 +
        COALESCE((metadata->>'relevance_score')::FLOAT, 0) * 0.3 AS final_score
    FROM initial_results
    JOIN document_chunks USING (id)
)
SELECT id, chunk_text, similarity, final_score
FROM reranked_results
ORDER BY final_score DESC
LIMIT 10;
```

### 6.3 上下文管理

**上下文窗口管理**:

```sql
-- 创建RAG会话表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'rag_conversations') THEN
            CREATE TABLE rag_conversations (
                id SERIAL PRIMARY KEY,
                session_id TEXT NOT NULL,
                query_text TEXT NOT NULL,
                query_embedding vector(1536),
                retrieved_chunks INTEGER[],
                response_text TEXT,
                created_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 rag_conversations 创建成功';
        ELSE
            RAISE NOTICE '表 rag_conversations 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 rag_conversations 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表 rag_conversations 失败: %', SQLERRM;
    END;
END $$;

-- 创建会话索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'rag_conversations') THEN
            RAISE WARNING '表 rag_conversations 不存在，无法创建索引';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_rag_conversations_session_id') THEN
            CREATE INDEX idx_rag_conversations_session_id
            ON rag_conversations(session_id, created_at DESC);
            RAISE NOTICE '索引 idx_rag_conversations_session_id 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_rag_conversations_session_id 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '表 rag_conversations 不存在';
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建索引失败: %', SQLERRM;
    END;
END $$;

-- 获取会话上下文
CREATE OR REPLACE FUNCTION get_conversation_context(
    p_session_id TEXT,
    p_limit INTEGER DEFAULT 5
)
RETURNS TABLE (
    query_text TEXT,
    response_text TEXT,
    retrieved_chunks INTEGER[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT rc.query_text, rc.response_text, rc.retrieved_chunks
    FROM rag_conversations rc
    WHERE rc.session_id = p_session_id
    ORDER BY rc.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. 分区策略

### 7.1 向量数据分区

**按时间分区**:

```sql
-- 向量数据按时间分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data') THEN
            CREATE TABLE vector_data (
                id SERIAL,
                time TIMESTAMPTZ NOT NULL,
                data TEXT,
                embedding vector(1536),
                PRIMARY KEY (id, time)
            ) PARTITION BY RANGE (time);
            RAISE NOTICE '分区表 vector_data 创建成功（按时间分区）';
        ELSE
            RAISE NOTICE '表 vector_data 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 vector_data 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表 vector_data 失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建月度分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data') THEN
            RAISE WARNING '分区表 vector_data 不存在，无法创建分区';
            RETURN;
        END IF;
        CREATE TABLE IF NOT EXISTS vector_data_2024_01 PARTITION OF vector_data
        FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
        RAISE NOTICE '分区 vector_data_2024_01 创建成功';
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区 vector_data_2024_01 已存在，跳过创建';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区 vector_data_2024_01 失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 在每个分区上创建向量索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data_2024_01') THEN
            RAISE WARNING '分区 vector_data_2024_01 不存在，无法创建索引';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_vector_data_2024_01_embedding_hnsw') THEN
            CREATE INDEX idx_vector_data_2024_01_embedding_hnsw
            ON vector_data_2024_01 USING hnsw (embedding vector_cosine_ops);
            RAISE NOTICE '向量HNSW索引 idx_vector_data_2024_01_embedding_hnsw 创建成功';
        ELSE
            RAISE NOTICE '索引 idx_vector_data_2024_01_embedding_hnsw 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN undefined_table THEN
            RAISE WARNING '分区 vector_data_2024_01 不存在';
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建向量HNSW索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

**按类别分区**:

```sql
-- 向量数据按类别分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data') THEN
            CREATE TABLE vector_data (
                id SERIAL,
                category TEXT NOT NULL,
                data TEXT,
                embedding vector(1536),
                PRIMARY KEY (id, category)
            ) PARTITION BY LIST (category);
            RAISE NOTICE '分区表 vector_data 创建成功（按类别分区）';
        ELSE
            RAISE NOTICE '表 vector_data 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 vector_data 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表 vector_data 失败: %', SQLERRM;
    END;
END $$;

-- 创建类别分区（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data') THEN
            RAISE WARNING '分区表 vector_data 不存在，无法创建分区';
            RETURN;
        END IF;
        CREATE TABLE IF NOT EXISTS vector_data_text PARTITION OF vector_data
        FOR VALUES IN ('text');
        CREATE TABLE IF NOT EXISTS vector_data_image PARTITION OF vector_data
        FOR VALUES IN ('image');
```

### 7.2 性能优化

**分区剪枝**:

```sql
-- PostgreSQL 18自动分区剪枝（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'vector_data') THEN
            RAISE WARNING '表 vector_data 不存在，无法执行分区剪枝查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行分区剪枝查询（只扫描相关分区）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM vector_data
WHERE time >= '2024-01-01'
  AND time < '2024-02-01'
  AND embedding <=> $1::vector < 0.5;
-- 只扫描vector_data_2024_01分区
```

---

## 8. PostgreSQL 18优化

### 8.1 异步I/O优化

**配置**:

```sql
-- PostgreSQL 18：异步I/O配置（向量数据库优化）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET io_direct = 'data';
    ALTER SYSTEM SET io_combine_limit = '256kB';
    PERFORM pg_reload_conf();
    RAISE NOTICE '异步I/O配置已更新（向量检索性能提升40%+）';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '配置异步I/O失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;
```

**性能提升**:

- 向量索引构建速度提升40%+
- 大规模向量检索I/O性能提升2-3倍
- 批量向量插入性能提升50-60%

### 8.2 GIN并行构建优化

**配置**:

```sql
-- PostgreSQL 18：GIN并行构建配置（全文搜索索引）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET max_parallel_maintenance_workers = 8;
    PERFORM pg_reload_conf();
    RAISE NOTICE 'GIN并行构建已配置（全文搜索索引构建速度提升3-4倍）';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '配置GIN并行构建失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;

-- 创建全文搜索索引（自动使用并行构建）
CREATE INDEX CONCURRENTLY idx_documents_search_vector_gin
ON documents USING GIN (search_vector);
```

**性能提升**:

- 全文搜索索引构建速度提升3-4倍
- 混合搜索（向量+全文）索引构建速度提升

---

## 9. 性能优化建议

### 9.1 索引参数调优

**HNSW参数调优**:

```sql
-- 高性能场景（查询优先）
CREATE INDEX idx_documents_embedding_hnsw_fast
ON documents USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 32,              -- 增加连接数
    ef_construction = 200  -- 增加构建精度
);

-- 平衡场景（默认）
CREATE INDEX idx_documents_embedding_hnsw_balanced
ON documents USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 16,
    ef_construction = 64
);

-- 存储优化场景（索引大小优先）
CREATE INDEX idx_documents_embedding_hnsw_small
ON documents USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 8,               -- 减少连接数
    ef_construction = 32  -- 减少构建精度
);
```

### 9.2 查询优化策略

**查询参数调优**:

```sql
-- 设置HNSW查询参数（PostgreSQL 18+）
SET hnsw.ef_search = 100;  -- 搜索范围（默认40，越大越精确但越慢）

-- 高性能查询（快速但精度略低）
SET hnsw.ef_search = 40;
SELECT * FROM documents
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 高精度查询（慢但精度高）
SET hnsw.ef_search = 200;
SELECT * FROM documents
ORDER BY embedding <=> $1::vector
LIMIT 10;
```

**混合查询优化**:

```sql
-- 优化混合查询（向量+全文搜索）
WITH vector_results AS (
    SELECT id, content, embedding <=> $1::vector AS distance
    FROM documents
    ORDER BY embedding <=> $1::vector
    LIMIT 50
),
text_results AS (
    SELECT id, content, ts_rank(search_vector, $2::tsquery) AS text_rank
    FROM documents
    WHERE search_vector @@ $2::tsquery
    ORDER BY text_rank DESC
    LIMIT 50
)
SELECT
    COALESCE(v.id, t.id) AS id,
    COALESCE(v.content, t.content) AS content,
    COALESCE(1 - v.distance, 0) * 0.6 + COALESCE(t.text_rank, 0) * 0.4 AS combined_score
FROM vector_results v
FULL OUTER JOIN text_results t ON v.id = t.id
ORDER BY combined_score DESC
LIMIT 10;
```

### 9.3 批量操作优化

**批量插入优化**:

```sql
-- 批量插入向量数据（PostgreSQL 18异步I/O优化）
BEGIN;
COPY documents (content, embedding) FROM STDIN WITH (FORMAT binary);
-- 批量插入数据
COMMIT;

-- 或使用批量INSERT（PostgreSQL 18优化，带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行批量插入';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行批量INSERT（PostgreSQL 18优化）';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '批量插入准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
INSERT INTO documents (content, embedding)
SELECT content, embedding
FROM unnest($1::TEXT[], $2::vector[])
AS t(content, embedding);
```

### 9.4 分区优化策略

**向量数据分区优化**:

```sql
-- 按时间分区优化查询（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            CREATE TABLE documents (
                id SERIAL,
                content TEXT,
                embedding vector(1536),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                PRIMARY KEY (id, created_at)
            ) PARTITION BY RANGE (created_at);
            RAISE NOTICE '分区表 documents 创建成功';
        ELSE
            RAISE NOTICE '表 documents 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 documents 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区表 documents 失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 创建分区并创建索引（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法创建分区';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents_2025_01') THEN
            CREATE TABLE documents_2025_01 PARTITION OF documents
            FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
            RAISE NOTICE '分区 documents_2025_01 创建成功';
        ELSE
            RAISE NOTICE '分区 documents_2025_01 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '分区 documents_2025_01 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建分区 documents_2025_01 失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents_2025_01') THEN
            RAISE WARNING '分区 documents_2025_01 不存在，无法创建索引';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_documents_2025_01_embedding_hnsw') THEN
            CREATE INDEX idx_documents_2025_01_embedding_hnsw
            ON documents_2025_01 USING hnsw (embedding vector_cosine_ops);
            RAISE NOTICE 'HNSW索引创建成功';
        ELSE
            RAISE NOTICE '索引 idx_documents_2025_01_embedding_hnsw 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '索引已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建HNSW索引失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 9.5 PostgreSQL 18异步I/O优化

**异步I/O配置**:

```sql
-- PostgreSQL 18：启用异步I/O优化向量操作
ALTER SYSTEM SET io_direct = 'data';
ALTER SYSTEM SET io_combine_limit = '256kB';
SELECT pg_reload_conf();
```

---

## 10. 最佳实践

### 10.1 设计原则

1. **维度选择**: 根据嵌入模型选择维度
2. **索引选择**: 大规模使用HNSW，中等规模使用IVFFlat
3. **分区策略**: 按时间或类别分区
4. **混合搜索**: 结合向量和全文搜索
5. **向量归一化**: 对向量进行归一化处理

### 10.2 性能优化

1. **PostgreSQL 18优化**: 启用异步I/O和GIN并行构建
2. **索引参数**: 根据场景调整HNSW参数
3. **查询优化**: 使用合适的ef_search值
4. **批量操作**: 使用COPY或批量INSERT
5. **分区优化**: 使用分区提升查询性能

### 10.3 监控和维护

1. **索引监控**: 定期检查索引大小和使用情况
2. **性能监控**: 监控查询响应时间
3. **数据质量**: 确保向量数据质量
4. **定期优化**: 定期重建索引优化性能

### 10.4 SQL实现注意事项

1. **错误处理**: 使用DO块处理向量操作错误
2. **性能监控**: 使用EXPLAIN (ANALYZE, BUFFERS, TIMING)分析查询性能
3. **并发控制**: 处理并发查询的竞争条件
4. **资源管理**: 限制查询的内存和CPU使用

---

## 11. 常见问题与解决方案

### 问题1: 索引创建失败

**原因**:

- IVFFlat索引需要足够的数据量
- 内存不足
- 参数设置不合理

**解决方案**:

- 使用HNSW索引（不需要预训练）
- 增加可用内存
- 调整索引参数

**示例**:

```sql
-- 诊断：检查数据量（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法检查数据量';
            RETURN;
        END IF;
        RAISE NOTICE '开始检查数据量';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT COUNT(*) FROM documents;
-- IVFFlat索引需要至少lists×1000行数据

-- 解决：使用HNSW索引（不需要预训练，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法创建索引';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector') THEN
            RAISE WARNING 'pgvector扩展未安装，无法创建HNSW索引';
            RETURN;
        END IF;
        IF EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_documents_embedding_hnsw') THEN
            RAISE NOTICE '索引 idx_documents_embedding_hnsw 已存在';
            RETURN;
        END IF;
        CREATE INDEX idx_documents_embedding_hnsw
        ON documents USING hnsw (embedding vector_cosine_ops);
        RAISE NOTICE 'HNSW索引创建成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '创建HNSW索引失败: %', SQLERRM;
    END;
END $$;
```

### 问题2: 查询性能慢

**原因**:

- 索引未使用
- ef_search参数过小
- 向量维度过高

**解决方案**:

- 检查索引使用情况
- 调整ef_search参数
- 降低向量维度（使用PCA等）

**示例**:

```sql
-- 诊断：检查索引使用情况
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM documents
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 解决：调整ef_search参数
SET hnsw.ef_search = 100;
```

### 问题3: 索引占用空间过大

**原因**:

- HNSW参数m值过大
- 向量维度过高
- 数据量过大

**解决方案**:

- 调整HNSW参数（减少m值）
- 降低向量维度
- 使用分区减少索引大小

**示例**:

```sql
-- 诊断：检查索引大小（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        RAISE NOTICE '开始检查索引大小';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE indexname LIKE '%hnsw%'
ORDER BY pg_relation_size(indexrelid) DESC;

-- 解决：调整HNSW参数（减少m值，带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法调整索引';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'idx_documents_embedding_hnsw') THEN
            RAISE WARNING '索引 idx_documents_embedding_hnsw 不存在，无法调整';
            RETURN;
        END IF;
        DROP INDEX idx_documents_embedding_hnsw;
        CREATE INDEX idx_documents_embedding_hnsw
        ON documents USING hnsw (embedding vector_cosine_ops)
        WITH (m = 8);  -- 减少连接数
        RAISE NOTICE 'HNSW索引参数调整成功';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '调整索引参数失败: %', SQLERRM;
    END;
END $$;
```

### 问题4: 向量相似度计算不准确

**原因**:

- 向量未归一化
- 相似度度量选择不当
- 向量质量差

**解决方案**:

- 对向量进行归一化
- 选择合适的相似度度量
- 使用更好的向量模型

**示例**:

```sql
-- 向量归一化函数
CREATE OR REPLACE FUNCTION normalize_vector(v vector)
RETURNS vector AS $$
DECLARE
    v_norm FLOAT;
    v_dim INT;
BEGIN
    BEGIN
        -- 参数验证
        IF v IS NULL THEN
            RAISE EXCEPTION '向量不能为NULL';
        END IF;

        v_dim := array_length(v, 1);
        IF v_dim IS NULL OR v_dim <= 0 THEN
            RAISE EXCEPTION '向量维度无效';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '参数验证失败: %', SQLERRM;
            RAISE;
    END;

    BEGIN
        -- 计算向量范数
        SELECT sqrt(sum(pow(unnest(v), 2))) INTO v_norm;

        IF v_norm IS NULL OR v_norm = 0 THEN
            RAISE EXCEPTION '向量范数为0，无法归一化';
        END IF;

        -- 归一化
        RETURN (SELECT array_agg(unnest(v) / v_norm)::vector FROM generate_series(1, v_dim));
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '向量归一化失败: %', SQLERRM;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 使用归一化向量（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'documents') THEN
            RAISE WARNING '表 documents 不存在，无法执行UPDATE';
            RETURN;
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'normalize_vector') THEN
            RAISE WARNING '函数 normalize_vector 不存在，无法执行UPDATE';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行向量归一化UPDATE';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING 'UPDATE准备失败: %', SQLERRM;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
UPDATE documents
SET embedding = normalize_vector(embedding);
```

---

## 12. 相关资源

### 12.1 核心相关文档

- [PostgreSQL18新特性](./PostgreSQL18新特性.md) - PostgreSQL 18新特性指南
- [索引策略](./索引策略.md) - 索引策略指南
- [性能优化](./性能优化.md) - 性能优化指南
- [数据类型选择](./数据类型选择.md) - 数据类型选择指南

### 12.2 官方资源

- [pgvector GitHub](https://github.com/pgvector/pgvector) - pgvector官方仓库
- [pgvector文档](https://github.com/pgvector/pgvector#readme) - pgvector官方文档
- [PostgreSQL 18文档](https://www.postgresql.org/docs/18/) - PostgreSQL 18官方文档

### 12.3 应用案例

- [推荐系统数据模型案例](../10-综合应用案例/推荐系统数据模型案例.md) - 推荐系统建模案例
- [RAG应用数据模型案例](../10-综合应用案例/RAG应用数据模型案例.md) - RAG应用建模案例

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**状态**: ✅ 已完成
