# PostgreSQLçº¦æŸè®¾è®¡å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: PostgreSQLå®˜æ–¹æ–‡æ¡£ + å®è·µæ€»ç»“
> **çŠ¶æ€**: åŸºäºPostgreSQL 17+/18+ç‰¹æ€§
> **æ–‡æ¡£ç¼–å·**: 08-04

---

## ğŸ“‘ ç›®å½•

- [PostgreSQLçº¦æŸè®¾è®¡å®Œæ•´æŒ‡å—](#postgresqlçº¦æŸè®¾è®¡å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. çº¦æŸç±»å‹](#2-çº¦æŸç±»å‹)
    - [2.1 ä¸»é”®çº¦æŸï¼ˆPRIMARY KEYï¼‰](#21-ä¸»é”®çº¦æŸprimary-key)
    - [2.2 å¤–é”®çº¦æŸï¼ˆFOREIGN KEYï¼‰](#22-å¤–é”®çº¦æŸforeign-key)
    - [2.3 å”¯ä¸€çº¦æŸï¼ˆUNIQUEï¼‰](#23-å”¯ä¸€çº¦æŸunique)
    - [2.4 éç©ºçº¦æŸï¼ˆNOT NULLï¼‰](#24-éç©ºçº¦æŸnot-null)
    - [2.5 CHECKçº¦æŸ](#25-checkçº¦æŸ)
    - [2.6 EXCLUDEçº¦æŸ](#26-excludeçº¦æŸ)
  - [3. çº¦æŸè®¾è®¡ç­–ç•¥](#3-çº¦æŸè®¾è®¡ç­–ç•¥)
    - [3.1 çº¦æŸå‘½åè§„èŒƒ](#31-çº¦æŸå‘½åè§„èŒƒ)
    - [3.2 çº¦æŸé€‰æ‹©åŸåˆ™](#32-çº¦æŸé€‰æ‹©åŸåˆ™)
  - [4. çº¦æŸæ€§èƒ½ä¼˜åŒ–](#4-çº¦æŸæ€§èƒ½ä¼˜åŒ–)
    - [4.1 çº¦æŸæ£€æŸ¥æ€§èƒ½](#41-çº¦æŸæ£€æŸ¥æ€§èƒ½)
    - [4.2 çº¦æŸç´¢å¼•ä¼˜åŒ–](#42-çº¦æŸç´¢å¼•ä¼˜åŒ–)
  - [5. çº¦æŸæœ€ä½³å®è·µ](#5-çº¦æŸæœ€ä½³å®è·µ)
    - [5.1 è®¾è®¡åŸåˆ™](#51-è®¾è®¡åŸåˆ™)
  - [6. å¸¸è§çº¦æŸæ¨¡å¼](#6-å¸¸è§çº¦æŸæ¨¡å¼)
    - [6.1 è½¯åˆ é™¤æ¨¡å¼](#61-è½¯åˆ é™¤æ¨¡å¼)
    - [6.2 çŠ¶æ€è½¬æ¢çº¦æŸ](#62-çŠ¶æ€è½¬æ¢çº¦æŸ)
    - [6.3 æ—¶é—´èŒƒå›´çº¦æŸ](#63-æ—¶é—´èŒƒå›´çº¦æŸ)
  - [7. çº¦æŸç®¡ç† / Constraint Management](#7-çº¦æŸç®¡ç†--constraint-management)
    - [7.1 æŸ¥çœ‹çº¦æŸ](#71-æŸ¥çœ‹çº¦æŸ)
    - [7.2 æ·»åŠ çº¦æŸ](#72-æ·»åŠ çº¦æŸ)
    - [7.3 ä¿®æ”¹çº¦æŸ](#73-ä¿®æ”¹çº¦æŸ)
    - [7.4 åˆ é™¤çº¦æŸ](#74-åˆ é™¤çº¦æŸ)
  - [8. PostgreSQL 15+ æ–°ç‰¹æ€§ / PostgreSQL 15+ New Features](#8-postgresql-15-æ–°ç‰¹æ€§--postgresql-15-new-features)
    - [8.1 NULLS NOT DISTINCT](#81-nulls-not-distinct)
    - [8.2 æ”¹è¿›çš„çº¦æŸé”™è¯¯ä¿¡æ¯](#82-æ”¹è¿›çš„çº¦æŸé”™è¯¯ä¿¡æ¯)
  - [9. çº¦æŸéªŒè¯å’Œé”™è¯¯å¤„ç† / Constraint Validation and Error Handling](#9-çº¦æŸéªŒè¯å’Œé”™è¯¯å¤„ç†--constraint-validation-and-error-handling)
    - [9.1 çº¦æŸéªŒè¯](#91-çº¦æŸéªŒè¯)
    - [9.2 é”™è¯¯å¤„ç†](#92-é”™è¯¯å¤„ç†)
    - [9.3 çº¦æŸè¿åæŸ¥è¯¢](#93-çº¦æŸè¿åæŸ¥è¯¢)
  - [10. çº¦æŸæ€§èƒ½åˆ†æ / Constraint Performance Analysis](#10-çº¦æŸæ€§èƒ½åˆ†æ--constraint-performance-analysis)
    - [10.1 çº¦æŸæ£€æŸ¥å¼€é”€](#101-çº¦æŸæ£€æŸ¥å¼€é”€)
    - [10.2 çº¦æŸç´¢å¼•æ€§èƒ½](#102-çº¦æŸç´¢å¼•æ€§èƒ½)
    - [10.3 çº¦æŸä¼˜åŒ–å»ºè®®](#103-çº¦æŸä¼˜åŒ–å»ºè®®)
  - [11. æ›´å¤šå®é™…æ¡ˆä¾‹ / More Practical Examples](#11-æ›´å¤šå®é™…æ¡ˆä¾‹--more-practical-examples)
    - [11.1 å¤šåˆ—å”¯ä¸€çº¦æŸ](#111-å¤šåˆ—å”¯ä¸€çº¦æŸ)
    - [11.2 å¤æ‚CHECKçº¦æŸ](#112-å¤æ‚checkçº¦æŸ)
    - [11.3 é€’å½’å¤–é”®çº¦æŸ](#113-é€’å½’å¤–é”®çº¦æŸ)
    - [11.4 æ¡ä»¶å¤–é”®çº¦æŸ](#114-æ¡ä»¶å¤–é”®çº¦æŸ)
  - [12. çº¦æŸæ•…éšœæ’æŸ¥æŒ‡å— / Constraint Troubleshooting Guide](#12-çº¦æŸæ•…éšœæ’æŸ¥æŒ‡å—--constraint-troubleshooting-guide)
    - [12.1 çº¦æŸè¿åé—®é¢˜è¯Šæ–­](#121-çº¦æŸè¿åé—®é¢˜è¯Šæ–­)
    - [12.2 çº¦æŸæ·»åŠ å¤±è´¥é—®é¢˜è¯Šæ–­](#122-çº¦æŸæ·»åŠ å¤±è´¥é—®é¢˜è¯Šæ–­)
    - [12.3 çº¦æŸæ€§èƒ½é—®é¢˜è¯Šæ–­](#123-çº¦æŸæ€§èƒ½é—®é¢˜è¯Šæ–­)
    - [12.4 çº¦æŸæ•…éšœæ’æŸ¥æ£€æŸ¥æ¸…å•](#124-çº¦æŸæ•…éšœæ’æŸ¥æ£€æŸ¥æ¸…å•)
    - [12.5 å®é™…æ•…éšœæ¡ˆä¾‹å’Œè§£å†³æ–¹æ¡ˆ](#125-å®é™…æ•…éšœæ¡ˆä¾‹å’Œè§£å†³æ–¹æ¡ˆ)
      - [æ¡ˆä¾‹1: æ‰¹é‡å¯¼å…¥æ—¶å¤–é”®çº¦æŸå¯¼è‡´æ€§èƒ½é—®é¢˜](#æ¡ˆä¾‹1-æ‰¹é‡å¯¼å…¥æ—¶å¤–é”®çº¦æŸå¯¼è‡´æ€§èƒ½é—®é¢˜)
      - [æ¡ˆä¾‹2: CHECKçº¦æŸå¯¼è‡´UPDATEæ€§èƒ½é—®é¢˜](#æ¡ˆä¾‹2-checkçº¦æŸå¯¼è‡´updateæ€§èƒ½é—®é¢˜)
      - [æ¡ˆä¾‹3: å”¯ä¸€çº¦æŸè¿åï¼šè½¯åˆ é™¤åœºæ™¯](#æ¡ˆä¾‹3-å”¯ä¸€çº¦æŸè¿åè½¯åˆ é™¤åœºæ™¯)
      - [æ¡ˆä¾‹4: ä¸ºå¤§è¡¨æ·»åŠ CHECKçº¦æŸè¶…æ—¶](#æ¡ˆä¾‹4-ä¸ºå¤§è¡¨æ·»åŠ checkçº¦æŸè¶…æ—¶)
    - [12.6 çº¦æŸæ•…éšœæ’æŸ¥å¿«é€Ÿå‚è€ƒ](#126-çº¦æŸæ•…éšœæ’æŸ¥å¿«é€Ÿå‚è€ƒ)
  - [13. å¸¸è§é—®é¢˜è§£ç­” / FAQ](#13-å¸¸è§é—®é¢˜è§£ç­”--faq)
    - [Q1: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨çº¦æŸï¼Ÿ](#q1-ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨çº¦æŸ)
    - [Q2: CHECKçº¦æŸå’Œè§¦å‘å™¨æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q2-checkçº¦æŸå’Œè§¦å‘å™¨æœ‰ä»€ä¹ˆåŒºåˆ«)
    - [Q3: å¦‚ä½•ä¼˜åŒ–å¤§é‡æ•°æ®çš„çº¦æŸæ£€æŸ¥ï¼Ÿ](#q3-å¦‚ä½•ä¼˜åŒ–å¤§é‡æ•°æ®çš„çº¦æŸæ£€æŸ¥)
    - [Q4: å¤–é”®çº¦æŸä¼šå½±å“æ€§èƒ½å—ï¼Ÿ](#q4-å¤–é”®çº¦æŸä¼šå½±å“æ€§èƒ½å—)
    - [Q5: å¦‚ä½•å¤„ç†çº¦æŸè¿åé”™è¯¯ï¼Ÿ](#q5-å¦‚ä½•å¤„ç†çº¦æŸè¿åé”™è¯¯)
    - [Q6: çº¦æŸå¯ä»¥è·¨è¡¨å—ï¼Ÿ](#q6-çº¦æŸå¯ä»¥è·¨è¡¨å—)
    - [Q7: å¦‚ä½•è¿ç§»ç°æœ‰æ•°æ®å¹¶æ·»åŠ çº¦æŸï¼Ÿ](#q7-å¦‚ä½•è¿ç§»ç°æœ‰æ•°æ®å¹¶æ·»åŠ çº¦æŸ)
    - [Q8: EXCLUDEçº¦æŸå’Œå”¯ä¸€çº¦æŸæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ](#q8-excludeçº¦æŸå’Œå”¯ä¸€çº¦æŸæœ‰ä»€ä¹ˆåŒºåˆ«)
  - [14. PostgreSQL 18çº¦æŸå¢å¼º / PostgreSQL 18 Constraint Enhancements](#14-postgresql-18çº¦æŸå¢å¼º--postgresql-18-constraint-enhancements)
    - [14.1 çº¦æŸéªŒè¯æ€§èƒ½æ”¹è¿›](#141-çº¦æŸéªŒè¯æ€§èƒ½æ”¹è¿›)
    - [14.2 æ”¹è¿›çš„çº¦æŸé”™è¯¯ä¿¡æ¯](#142-æ”¹è¿›çš„çº¦æŸé”™è¯¯ä¿¡æ¯)
    - [14.3 çº¦æŸæ£€æŸ¥ä¼˜åŒ–](#143-çº¦æŸæ£€æŸ¥ä¼˜åŒ–)
  - [15. ç›¸å…³èµ„æº / Related Resources](#15-ç›¸å…³èµ„æº--related-resources)
    - [12.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents](#121-æ ¸å¿ƒç›¸å…³æ–‡æ¡£--core-related-documents)

---

## 1. æ¦‚è¿°

çº¦æŸï¼ˆConstraintsï¼‰æ˜¯æ•°æ®åº“è®¾è®¡çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œç”¨äºä¿è¯æ•°æ®çš„å®Œæ•´æ€§ã€ä¸€è‡´æ€§å’Œæ­£ç¡®æ€§ã€‚
PostgreSQLæä¾›äº†ä¸°å¯Œçš„çº¦æŸç±»å‹ï¼Œæ­£ç¡®ä½¿ç”¨çº¦æŸå¯ä»¥å‡å°‘åº”ç”¨å±‚ä»£ç å¤æ‚åº¦ï¼Œæé«˜æ•°æ®è´¨é‡ã€‚

---

## 2. çº¦æŸç±»å‹

### 2.1 ä¸»é”®çº¦æŸï¼ˆPRIMARY KEYï¼‰

**å®šä¹‰**: å”¯ä¸€æ ‡è¯†è¡¨ä¸­çš„æ¯ä¸€è¡Œï¼Œä¸èƒ½ä¸ºNULLä¸”å¿…é¡»å”¯ä¸€ã€‚

**ç‰¹ç‚¹**:

- è‡ªåŠ¨åˆ›å»ºå”¯ä¸€ç´¢å¼•
- åªèƒ½æœ‰ä¸€ä¸ªä¸»é”®
- å¯ä»¥æ˜¯å•åˆ—æˆ–å¤åˆåˆ—

**PostgreSQLå®ç°**:

```sql
-- å•åˆ—ä¸»é”®
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,  -- è‡ªåŠ¨åˆ›å»ºä¸»é”®çº¦æŸå’Œç´¢å¼•
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

-- å¤åˆä¸»é”®
CREATE TABLE order_items (
    order_id INT NOT NULL,
    line_number INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    PRIMARY KEY (order_id, line_number)  -- å¤åˆä¸»é”®
);

-- æ˜¾å¼å‘½åä¸»é”®çº¦æŸ
CREATE TABLE products (
    product_id SERIAL,
    sku VARCHAR(50) UNIQUE NOT NULL,
    CONSTRAINT pk_products PRIMARY KEY (product_id)
);
```

**ä¸»é”®é€‰æ‹©å»ºè®®**:

- **ä»£ç†é”®**: ä½¿ç”¨SERIAL/BIGSERIALï¼ˆæ¨èï¼‰
- **ä¸šåŠ¡é”®**: ä½¿ç”¨ä¸šåŠ¡å”¯ä¸€æ ‡è¯†ï¼ˆéœ€ç¡®ä¿ç¨³å®šæ€§ï¼‰
- **UUID**: åˆ†å¸ƒå¼ç³»ç»Ÿä½¿ç”¨UUID

---

### 2.2 å¤–é”®çº¦æŸï¼ˆFOREIGN KEYï¼‰

**å®šä¹‰**: ç¡®ä¿å¼•ç”¨å®Œæ•´æ€§ï¼Œå¤–é”®å€¼å¿…é¡»åœ¨è¢«å¼•ç”¨è¡¨çš„ä¸»é”®ä¸­å­˜åœ¨ã€‚

**ç‰¹ç‚¹**:

- æ”¯æŒçº§è”æ“ä½œï¼ˆCASCADEã€RESTRICTã€SET NULLã€SET DEFAULTï¼‰
- è‡ªåŠ¨åˆ›å»ºç´¢å¼•ï¼ˆPostgreSQL 11+ï¼‰
- å¯ä»¥å»¶è¿Ÿæ£€æŸ¥ï¼ˆDEFERRABLEï¼‰

**PostgreSQLå®ç°**:

```sql
-- åŸºæœ¬å¤–é”®çº¦æŸ
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
);

-- çº§è”åˆ é™¤
CREATE TABLE order_items (
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    CONSTRAINT fk_order_items_order
        FOREIGN KEY (order_id)
        REFERENCES orders(order_id)
        ON DELETE CASCADE,  -- åˆ é™¤è®¢å•æ—¶ï¼Œè‡ªåŠ¨åˆ é™¤è®¢å•é¡¹
    CONSTRAINT fk_order_items_product
        FOREIGN KEY (product_id)
        REFERENCES products(product_id)
        ON DELETE RESTRICT  -- æœ‰è®¢å•é¡¹æ—¶ï¼Œç¦æ­¢åˆ é™¤äº§å“
);

-- çº§è”æ›´æ–°
CREATE TABLE order_items (
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    CONSTRAINT fk_order_items_product
        FOREIGN KEY (product_id)
        REFERENCES products(product_id)
        ON UPDATE CASCADE  -- æ›´æ–°äº§å“IDæ—¶ï¼ŒåŒæ­¥æ›´æ–°è®¢å•é¡¹
);

-- è®¾ç½®ä¸ºNULL
CREATE TABLE order_items (
    order_id INT NOT NULL,
    product_id INT,  -- å…è®¸NULL
    CONSTRAINT fk_order_items_product
        FOREIGN KEY (product_id)
        REFERENCES products(product_id)
        ON DELETE SET NULL  -- åˆ é™¤äº§å“æ—¶ï¼Œå°†product_idè®¾ä¸ºNULL
);
```

**å¤–é”®ç´¢å¼•**:

```sql
-- PostgreSQL 11+è‡ªåŠ¨åˆ›å»ºç´¢å¼•
-- æ‰‹åŠ¨åˆ›å»ºç´¢å¼•ï¼ˆä¼˜åŒ–JOINæ€§èƒ½ï¼‰
CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);
```

---

### 2.3 å”¯ä¸€çº¦æŸï¼ˆUNIQUEï¼‰

**å®šä¹‰**: ç¡®ä¿åˆ—å€¼å”¯ä¸€ï¼ˆå…è®¸NULLï¼‰ã€‚

**ç‰¹ç‚¹**:

- è‡ªåŠ¨åˆ›å»ºå”¯ä¸€ç´¢å¼•
- å…è®¸NULLå€¼ï¼ˆå¤šä¸ªNULLè§†ä¸ºä¸åŒï¼‰
- å¯ä»¥æ˜¯å•åˆ—æˆ–å¤åˆåˆ—

**PostgreSQLå®ç°**:

```sql
-- å•åˆ—å”¯ä¸€çº¦æŸ
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

-- å¤åˆå”¯ä¸€çº¦æŸ
CREATE TABLE enrollments (
    student_id INT NOT NULL,
    course_id INT NOT NULL,
    semester VARCHAR(20) NOT NULL,
    UNIQUE (student_id, course_id, semester)  -- åŒä¸€å­¦æœŸä¸èƒ½é‡å¤é€‰è¯¾
);

-- å‘½åå”¯ä¸€çº¦æŸ
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    sku VARCHAR(50) NOT NULL,
    CONSTRAINT uk_product_sku UNIQUE (sku)
);

-- éƒ¨åˆ†å”¯ä¸€çº¦æŸï¼ˆä»…å¯¹æ»¡è¶³æ¡ä»¶çš„è¡Œå”¯ä¸€ï¼‰
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50),
    status VARCHAR(20) DEFAULT 'pending',
    UNIQUE (order_number) WHERE status != 'cancelled'  -- ä»…éå–æ¶ˆè®¢å•å”¯ä¸€
);
```

---

### 2.4 éç©ºçº¦æŸï¼ˆNOT NULLï¼‰

**å®šä¹‰**: ç¡®ä¿åˆ—å€¼ä¸èƒ½ä¸ºNULLã€‚

**ç‰¹ç‚¹**:

- æœ€ç®€å•çš„çº¦æŸ
- æé«˜æŸ¥è¯¢æ€§èƒ½ï¼ˆé¿å…NULLæ£€æŸ¥ï¼‰
- ä¸é»˜è®¤å€¼é…åˆä½¿ç”¨

**PostgreSQLå®ç°**:

```sql
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    phone VARCHAR(20),  -- å¯é€‰å­—æ®µ
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- æ·»åŠ NOT NULLçº¦æŸ
ALTER TABLE users
ALTER COLUMN phone SET NOT NULL;

-- åˆ é™¤NOT NULLçº¦æŸ
ALTER TABLE users
ALTER COLUMN phone DROP NOT NULL;
```

---

### 2.5 CHECKçº¦æŸ

**å®šä¹‰**: å®šä¹‰åˆ—å€¼å¿…é¡»æ»¡è¶³çš„æ¡ä»¶ã€‚

**ç‰¹ç‚¹**:

- æ”¯æŒå¤æ‚æ¡ä»¶è¡¨è¾¾å¼
- å¯ä»¥æ˜¯åˆ—çº§æˆ–è¡¨çº§
- æ”¯æŒå‡½æ•°è°ƒç”¨

**PostgreSQLå®ç°**:

```sql
-- åˆ—çº§CHECKçº¦æŸ
CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 100),
    email VARCHAR(100) CHECK (email LIKE '%@%.%'),
    grade CHAR(2) CHECK (grade IN ('A', 'B', 'C', 'D', 'F'))
);

-- è¡¨çº§CHECKçº¦æŸï¼ˆå¯ä»¥å¼•ç”¨å¤šåˆ—ï¼‰
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    ship_date DATE,
    delivery_date DATE,
    CONSTRAINT chk_dates
        CHECK (ship_date IS NULL OR ship_date >= order_date),
    CONSTRAINT chk_delivery
        CHECK (delivery_date IS NULL OR delivery_date >= ship_date)
);

-- å‘½åCHECKçº¦æŸ
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    price NUMERIC(10,2) NOT NULL,
    discount NUMERIC(10,2) DEFAULT 0,
    CONSTRAINT chk_price_positive CHECK (price > 0),
    CONSTRAINT chk_discount_range CHECK (discount >= 0 AND discount <= price)
);

-- ä½¿ç”¨å‡½æ•°
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    CONSTRAINT chk_event_duration
        CHECK (end_time > start_time AND end_time <= start_time + INTERVAL '24 hours')
);
```

---

### 2.6 EXCLUDEçº¦æŸ

**å®šä¹‰**: PostgreSQLç‰¹æœ‰çº¦æŸï¼Œä½¿ç”¨ç´¢å¼•æ–¹æ³•æ’é™¤æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„è¡Œã€‚

**ç‰¹ç‚¹**:

- é˜²æ­¢æ—¶é—´èŒƒå›´é‡å 
- é˜²æ­¢ç©ºé—´èŒƒå›´é‡å 
- éœ€è¦GISTç´¢å¼•æ”¯æŒ

**PostgreSQLå®ç°**:

```sql
-- å¯ç”¨btree_gistæ‰©å±•
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- é˜²æ­¢ä¼šè®®å®¤é¢„è®¢æ—¶é—´é‡å 
CREATE TABLE room_bookings (
    booking_id SERIAL PRIMARY KEY,
    room_id INT NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    CONSTRAINT chk_time_range CHECK (end_time > start_time),
    CONSTRAINT uk_room_time
        EXCLUDE USING GIST (
            room_id WITH =,
            tsrange(start_time, end_time) WITH &&
        )
);

-- æ’å…¥æµ‹è¯•
INSERT INTO room_bookings (room_id, start_time, end_time)
VALUES (1, '2024-01-01 10:00:00', '2024-01-01 11:00:00');  -- âœ… æˆåŠŸ

INSERT INTO room_bookings (room_id, start_time, end_time)
VALUES (1, '2024-01-01 10:30:00', '2024-01-01 11:30:00');  -- âŒ å¤±è´¥ï¼šæ—¶é—´é‡å 

-- é˜²æ­¢IPåœ°å€èŒƒå›´é‡å 
CREATE TABLE ip_ranges (
    range_id SERIAL PRIMARY KEY,
    network_name VARCHAR(100) NOT NULL,
    start_ip INET NOT NULL,
    end_ip INET NOT NULL,
    CONSTRAINT chk_ip_range CHECK (end_ip > start_ip),
    CONSTRAINT uk_ip_range
        EXCLUDE USING GIST (
            inetrange(start_ip, end_ip) WITH &&
        )
);
```

---

## 3. çº¦æŸè®¾è®¡ç­–ç•¥

### 3.1 çº¦æŸå‘½åè§„èŒƒ

**å‘½åæ ¼å¼**: `çº¦æŸç±»å‹_è¡¨å_åˆ—å` æˆ– `çº¦æŸç±»å‹_è¡¨å_æè¿°`

**ç¤ºä¾‹**:

```sql
-- ä¸»é”®
CONSTRAINT pk_orders PRIMARY KEY (order_id)

-- å¤–é”®
CONSTRAINT fk_orders_customers FOREIGN KEY (customer_id) REFERENCES customers(customer_id)

-- å”¯ä¸€çº¦æŸ
CONSTRAINT uk_products_sku UNIQUE (sku)

-- CHECKçº¦æŸ
CONSTRAINT chk_orders_amount CHECK (amount > 0)

-- EXCLUDEçº¦æŸ
CONSTRAINT uk_room_bookings_time EXCLUDE USING GIST (...)
```

---

### 3.2 çº¦æŸé€‰æ‹©åŸåˆ™

**åŸåˆ™1: åœ¨æ•°æ®åº“å±‚å®šä¹‰çº¦æŸ**:

- âœ… æ•°æ®åº“å±‚çº¦æŸä¿è¯æ•°æ®å®Œæ•´æ€§
- âŒ åº”ç”¨å±‚çº¦æŸå¯èƒ½è¢«ç»•è¿‡

**åŸåˆ™2: ä½¿ç”¨åˆé€‚çš„å¤–é”®çº§è”ç­–ç•¥**:

- `CASCADE`: å­è¡¨æ•°æ®éšçˆ¶è¡¨åˆ é™¤
- `RESTRICT`: æœ‰å­è¡¨æ•°æ®æ—¶ç¦æ­¢åˆ é™¤çˆ¶è¡¨
- `SET NULL`: å­è¡¨å¤–é”®è®¾ä¸ºNULL
- `SET DEFAULT`: å­è¡¨å¤–é”®è®¾ä¸ºé»˜è®¤å€¼

**åŸåˆ™3: ä½¿ç”¨EXCLUDEçº¦æŸé˜²æ­¢é‡å **:

- æ—¶é—´èŒƒå›´é‡å 
- ç©ºé—´èŒƒå›´é‡å 
- IPåœ°å€èŒƒå›´é‡å 

---

## 4. çº¦æŸæ€§èƒ½ä¼˜åŒ–

### 4.1 çº¦æŸæ£€æŸ¥æ€§èƒ½

**å»¶è¿Ÿçº¦æŸæ£€æŸ¥**:

```sql
-- åˆ›å»ºå¯å»¶è¿Ÿçš„çº¦æŸ
CREATE TABLE departments (
    dept_id SERIAL PRIMARY KEY,
    dept_name VARCHAR(100) NOT NULL,
    manager_id INT,
    CONSTRAINT fk_dept_manager
        FOREIGN KEY (manager_id)
        REFERENCES employees(emp_id)
        DEFERRABLE INITIALLY DEFERRED  -- å¯å»¶è¿Ÿï¼Œåˆå§‹ä¸ºå»¶è¿Ÿ
);

-- åœ¨äº‹åŠ¡ä¸­å»¶è¿Ÿçº¦æŸæ£€æŸ¥
BEGIN;
SET CONSTRAINTS fk_dept_manager DEFERRED;

-- ç°åœ¨å¯ä»¥æ’å…¥å¾ªç¯å¼•ç”¨çš„æ•°æ®
INSERT INTO employees (emp_id, emp_name, dept_id)
VALUES (1, 'John', 1);

INSERT INTO departments (dept_id, dept_name, manager_id)
VALUES (1, 'IT', 1);

COMMIT;  -- æäº¤æ—¶æ‰æ£€æŸ¥çº¦æŸ
```

---

### 4.2 çº¦æŸç´¢å¼•ä¼˜åŒ–

**å¤–é”®ç´¢å¼•**:

```sql
-- PostgreSQL 11+è‡ªåŠ¨ä¸ºå¤–é”®åˆ›å»ºç´¢å¼•
-- æ‰‹åŠ¨åˆ›å»ºç´¢å¼•ä¼˜åŒ–JOIN
CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_order_items_order ON order_items(order_id);
```

**å”¯ä¸€çº¦æŸç´¢å¼•**:

```sql
-- å”¯ä¸€çº¦æŸè‡ªåŠ¨åˆ›å»ºç´¢å¼•
-- éƒ¨åˆ†å”¯ä¸€çº¦æŸç´¢å¼•
CREATE UNIQUE INDEX idx_orders_number_active
ON orders(order_number)
WHERE status != 'cancelled';
```

---

## 5. çº¦æŸæœ€ä½³å®è·µ

### 5.1 è®¾è®¡åŸåˆ™

**åŸåˆ™1: å®Œæ•´æ€§ä¼˜å…ˆ**:

```sql
-- âœ… æ­£ç¡®ï¼šå®Œæ•´çš„çº¦æŸ
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    CONSTRAINT fk_orders_customer FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    CONSTRAINT chk_amount_positive CHECK (amount > 0)
);

-- âŒ é”™è¯¯ï¼šç¼ºå°‘çº¦æŸ
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT,  -- ç¼ºå°‘NOT NULLå’Œå¤–é”®
    amount NUMERIC(10,2)  -- ç¼ºå°‘CHECKçº¦æŸ
);
```

---

**åŸåˆ™2: çº¦æŸå‘½åä¸€è‡´**:

```sql
-- âœ… æ­£ç¡®ï¼šç»Ÿä¸€çš„å‘½åè§„èŒƒ
CREATE TABLE orders (
    order_id BIGSERIAL,
    customer_id INT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    CONSTRAINT pk_orders PRIMARY KEY (order_id),
    CONSTRAINT fk_orders_customers FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    CONSTRAINT chk_orders_amount CHECK (amount > 0)
);
```

---

**åŸåˆ™3: ä½¿ç”¨EXCLUDEçº¦æŸé˜²æ­¢é‡å **:

```sql
-- âœ… æ­£ç¡®ï¼šä½¿ç”¨EXCLUDEçº¦æŸ
CREATE TABLE bookings (
    room_id INT NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    CONSTRAINT uk_room_time
        EXCLUDE USING GIST (
            room_id WITH =,
            tsrange(start_time, end_time) WITH &&
        )
);

-- âŒ é”™è¯¯ï¼šåº”ç”¨å±‚æ£€æŸ¥ï¼ˆå¯èƒ½å¹¶å‘é—®é¢˜ï¼‰
-- åº”ç”¨å±‚SELECT ... FOR UPDATEæ£€æŸ¥ï¼Œç„¶åINSERT
```

---

## 6. å¸¸è§çº¦æŸæ¨¡å¼

### 6.1 è½¯åˆ é™¤æ¨¡å¼

```sql
-- æ¨¡å¼ï¼šä½¿ç”¨deleted_atæ ‡è®°åˆ é™¤
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    deleted_at TIMESTAMPTZ,
    CONSTRAINT uk_product_name_active
        UNIQUE NULLS NOT DISTINCT (name, deleted_at)  -- PostgreSQL 15+
);

-- æŸ¥è¯¢æ´»è·ƒäº§å“
SELECT * FROM products WHERE deleted_at IS NULL;
```

---

### 6.2 çŠ¶æ€è½¬æ¢çº¦æŸ

```sql
-- æ¨¡å¼ï¼šé™åˆ¶çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    previous_status VARCHAR(20),
    CONSTRAINT chk_status_transition CHECK (
        (status = 'pending' AND previous_status IS NULL) OR
        (status = 'processing' AND previous_status = 'pending') OR
        (status = 'shipped' AND previous_status = 'processing') OR
        (status = 'delivered' AND previous_status = 'shipped') OR
        (status = 'cancelled' AND previous_status IN ('pending', 'processing'))
    )
);
```

---

### 6.3 æ—¶é—´èŒƒå›´çº¦æŸ

```sql
-- æ¨¡å¼ï¼šç¡®ä¿æ—¶é—´èŒƒå›´çš„åˆç†æ€§
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    CONSTRAINT chk_event_time_range
        CHECK (end_time > start_time),
    CONSTRAINT uk_event_time_overlap
        EXCLUDE USING GIST (
            tsrange(start_time, end_time) WITH &&
        )
);
```

---

## 7. çº¦æŸç®¡ç† / Constraint Management

### 7.1 æŸ¥çœ‹çº¦æŸ

**æŸ¥è¯¢æ‰€æœ‰çº¦æŸ**:

```sql
-- æŸ¥è¯¢è¡¨çš„æ‰€æœ‰çº¦æŸ
SELECT
    conname AS constraint_name,
    contype AS constraint_type,
    pg_get_constraintdef(oid) AS constraint_definition
FROM pg_constraint
WHERE conrelid = 'orders'::regclass
ORDER BY contype, conname;

-- çº¦æŸç±»å‹è¯´æ˜ï¼š
-- p = PRIMARY KEY
-- f = FOREIGN KEY
-- u = UNIQUE
-- c = CHECK
-- x = EXCLUDE
-- t = TRIGGER
-- t = TRIGGER

-- ä½¿ç”¨ä¿¡æ¯æ¨¡å¼æŸ¥è¯¢ï¼ˆæ›´æ˜“è¯»ï¼‰
SELECT
    tc.constraint_name,
    tc.constraint_type,
    tc.table_name,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
LEFT JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
    AND ccu.table_schema = tc.table_schema
WHERE tc.table_name = 'orders'
ORDER BY tc.constraint_type, tc.constraint_name;
```

### 7.2 æ·»åŠ çº¦æŸ

**æ·»åŠ NOT NULLçº¦æŸ**:

```sql
-- æ·»åŠ NOT NULLçº¦æŸï¼ˆéœ€è¦å…ˆç¡®ä¿æ²¡æœ‰NULLå€¼ï¼‰
UPDATE orders SET customer_id = 0 WHERE customer_id IS NULL;  -- å…ˆå¤„ç†NULLå€¼
ALTER TABLE orders ALTER COLUMN customer_id SET NOT NULL;

-- æˆ–ä½¿ç”¨é»˜è®¤å€¼
ALTER TABLE orders
    ALTER COLUMN customer_id SET DEFAULT 0,
    ALTER COLUMN customer_id SET NOT NULL;
```

**æ·»åŠ CHECKçº¦æŸ**:

```sql
-- æ·»åŠ CHECKçº¦æŸ
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount > 0);

-- å¦‚æœè¡¨ä¸­å·²æœ‰æ•°æ®è¿åçº¦æŸï¼Œä½¿ç”¨NOT VALIDï¼ˆPostgreSQL 9.2+ï¼‰
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount > 0) NOT VALID;

-- ç¨åéªŒè¯çº¦æŸ
ALTER TABLE orders VALIDATE CONSTRAINT chk_amount_positive;
```

**æ·»åŠ å¤–é”®çº¦æŸ**:

```sql
-- æ·»åŠ å¤–é”®çº¦æŸ
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
    FOREIGN KEY (customer_id)
    REFERENCES customers(customer_id)
    ON DELETE RESTRICT
    ON UPDATE CASCADE;

-- ä½¿ç”¨NOT VALIDæ·»åŠ ï¼ˆå¦‚æœæ•°æ®é‡å¤§ï¼‰
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
    FOREIGN KEY (customer_id)
    REFERENCES customers(customer_id)
    NOT VALID;

-- ç¨åéªŒè¯
ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_customer;
```

**æ·»åŠ å”¯ä¸€çº¦æŸ**:

```sql
-- æ·»åŠ å”¯ä¸€çº¦æŸ
ALTER TABLE products
ADD CONSTRAINT uk_products_sku UNIQUE (sku);

-- æ·»åŠ éƒ¨åˆ†å”¯ä¸€çº¦æŸ
CREATE UNIQUE INDEX uk_products_sku_active
ON products(sku)
WHERE deleted_at IS NULL;
```

### 7.3 ä¿®æ”¹çº¦æŸ

**é‡å‘½åçº¦æŸ**:

```sql
-- é‡å‘½åçº¦æŸ
ALTER TABLE orders
RENAME CONSTRAINT chk_amount TO chk_amount_positive;
```

**ä¿®æ”¹çº¦æŸå®šä¹‰**:

```sql
-- PostgreSQLä¸æ”¯æŒç›´æ¥ä¿®æ”¹çº¦æŸå®šä¹‰
-- éœ€è¦å…ˆåˆ é™¤å†é‡æ–°åˆ›å»º

-- 1. åˆ é™¤æ—§çº¦æŸ
ALTER TABLE orders DROP CONSTRAINT chk_amount_positive;

-- 2. æ·»åŠ æ–°çº¦æŸ
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount >= 0);
```

### 7.4 åˆ é™¤çº¦æŸ

**åˆ é™¤çº¦æŸ**:

```sql
-- åˆ é™¤CHECKçº¦æŸ
ALTER TABLE orders DROP CONSTRAINT chk_amount_positive;

-- åˆ é™¤å¤–é”®çº¦æŸ
ALTER TABLE orders DROP CONSTRAINT fk_orders_customer;

-- åˆ é™¤ä¸»é”®çº¦æŸï¼ˆä¼šåŒæ—¶åˆ é™¤å…³è”çš„ç´¢å¼•ï¼‰
ALTER TABLE orders DROP CONSTRAINT orders_pkey;

-- åˆ é™¤NOT NULLçº¦æŸ
ALTER TABLE orders ALTER COLUMN customer_id DROP NOT NULL;
```

**åˆ é™¤çº¦æŸæ³¨æ„äº‹é¡¹**:

```sql
-- 1. åˆ é™¤ä¸»é”®å‰ï¼Œå…ˆåˆ é™¤æ‰€æœ‰å¤–é”®å¼•ç”¨
-- æŸ¥è¯¢å¼•ç”¨è¯¥ä¸»é”®çš„å¤–é”®
SELECT
    tc.table_name,
    tc.constraint_name,
    kcu.column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
    AND tc.table_schema = 'public'
    AND kcu.table_name = 'orders'
    AND kcu.column_name = 'order_id';

-- 2. åˆ é™¤çº¦æŸæ—¶ä½¿ç”¨CASCADEï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
ALTER TABLE orders DROP CONSTRAINT orders_pkey CASCADE;
```

---

## 8. PostgreSQL 15+ æ–°ç‰¹æ€§ / PostgreSQL 15+ New Features

### 8.1 NULLS NOT DISTINCT

**PostgreSQL 15+**: å”¯ä¸€çº¦æŸä¸­NULLå€¼çš„å¤„ç†æ–¹å¼ã€‚

**ä¼ ç»Ÿè¡Œä¸ºï¼ˆNULLS DISTINCTï¼‰**:

```sql
-- PostgreSQL 14åŠä»¥å‰ï¼šå¤šä¸ªNULLå€¼è¢«è§†ä¸ºä¸åŒ
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE  -- å…è®¸å¤šä¸ªNULL
);

INSERT INTO users (email) VALUES (NULL);  -- âœ…
INSERT INTO users (email) VALUES (NULL);  -- âœ… å…è®¸
```

**æ–°ç‰¹æ€§ï¼ˆNULLS NOT DISTINCTï¼‰**:

```sql
-- PostgreSQL 15+ï¼šNULLå€¼è¢«è§†ä¸ºç›¸åŒï¼ˆä»…å…è®¸ä¸€ä¸ªNULLï¼‰
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email VARCHAR(100) UNIQUE NULLS NOT DISTINCT  -- ä»…å…è®¸ä¸€ä¸ªNULL
);

INSERT INTO users (email) VALUES (NULL);  -- âœ…
INSERT INTO users (email) VALUES (NULL);  -- âŒ è¿åå”¯ä¸€çº¦æŸ
```

**å®é™…åº”ç”¨åœºæ™¯**:

```sql
-- è½¯åˆ é™¤åœºæ™¯ï¼šä½¿ç”¨NULLS NOT DISTINCTç¡®ä¿å”¯ä¸€æ€§
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    sku VARCHAR(50) NOT NULL,
    deleted_at TIMESTAMPTZ,
    CONSTRAINT uk_products_sku_active
        UNIQUE NULLS NOT DISTINCT (sku, deleted_at)
);

-- æ´»è·ƒäº§å“ï¼šskuå”¯ä¸€
INSERT INTO products (sku) VALUES ('SKU001');  -- âœ…
INSERT INTO products (sku) VALUES ('SKU001');  -- âŒ è¿åçº¦æŸ

-- è½¯åˆ é™¤åï¼šå¯ä»¥é‡æ–°ä½¿ç”¨ç›¸åŒçš„sku
UPDATE products SET deleted_at = NOW() WHERE sku = 'SKU001';
INSERT INTO products (sku) VALUES ('SKU001');  -- âœ… å…è®¸ï¼ˆdeleted_atä¸åŒï¼‰
```

### 8.2 æ”¹è¿›çš„çº¦æŸé”™è¯¯ä¿¡æ¯

**PostgreSQL 15+**: æä¾›æ›´è¯¦ç»†çš„çº¦æŸè¿åé”™è¯¯ä¿¡æ¯ã€‚

```sql
-- ç¤ºä¾‹ï¼šè¿åå”¯ä¸€çº¦æŸ
INSERT INTO products (sku) VALUES ('SKU001');
INSERT INTO products (sku) VALUES ('SKU001');
-- é”™è¯¯ä¿¡æ¯åŒ…å«ï¼š
-- - çº¦æŸåç§°
-- - è¿åçš„åˆ—å
-- - å†²çªçš„å€¼
```

---

## 9. çº¦æŸéªŒè¯å’Œé”™è¯¯å¤„ç† / Constraint Validation and Error Handling

### 9.1 çº¦æŸéªŒè¯

**éªŒè¯ç°æœ‰æ•°æ®**:

```sql
-- 1. æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®è¿åçº¦æŸ
SELECT *
FROM orders
WHERE amount <= 0;  -- è¿åCHECKçº¦æŸçš„æ•°æ®

-- 2. ä½¿ç”¨NOT VALIDæ·»åŠ çº¦æŸï¼Œç„¶åéªŒè¯
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount > 0) NOT VALID;

-- éªŒè¯çº¦æŸï¼ˆæ£€æŸ¥ç°æœ‰æ•°æ®ï¼‰
ALTER TABLE orders VALIDATE CONSTRAINT chk_amount_positive;
-- å¦‚æœæœ‰è¿åï¼Œä¼šæŠ¥é”™å¹¶åˆ—å‡ºè¿åçš„è¡Œ
```

**æ‰¹é‡éªŒè¯çº¦æŸ**:

```sql
-- éªŒè¯æ‰€æœ‰NOT VALIDçº¦æŸ
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT conname, conrelid::regclass AS table_name
        FROM pg_constraint
        WHERE connotinherited = false
          AND convalidated = false
    LOOP
        BEGIN
            EXECUTE format('ALTER TABLE %s VALIDATE CONSTRAINT %s',
                          r.table_name, r.conname);
            RAISE NOTICE 'Validated constraint % on table %',
                         r.conname, r.table_name;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE WARNING 'Failed to validate constraint % on table %: %',
                             r.conname, r.table_name, SQLERRM;
        END;
    END LOOP;
END $$;
```

### 9.2 é”™è¯¯å¤„ç†

**åº”ç”¨å±‚é”™è¯¯å¤„ç†**:

```python
# Pythonç¤ºä¾‹ï¼šå¤„ç†çº¦æŸè¿åé”™è¯¯
import psycopg2
from psycopg2 import errors

try:
    cursor.execute("INSERT INTO products (sku) VALUES (%s)", ('SKU001',))
except errors.UniqueViolation as e:
    print(f"å”¯ä¸€çº¦æŸè¿å: {e.pgcode}")
    print(f"çº¦æŸåç§°: {e.diag.constraint_name}")
    print(f"è¡¨å: {e.diag.table_name}")
except errors.CheckViolation as e:
    print(f"CHECKçº¦æŸè¿å: {e.pgcode}")
    print(f"çº¦æŸåç§°: {e.diag.constraint_name}")
except errors.ForeignKeyViolation as e:
    print(f"å¤–é”®çº¦æŸè¿å: {e.pgcode}")
    print(f"çº¦æŸåç§°: {e.diag.constraint_name}")
```

**SQLé”™è¯¯å¤„ç†**:

```sql
-- ä½¿ç”¨DOå—å¤„ç†çº¦æŸé”™è¯¯
DO $$
BEGIN
    INSERT INTO products (sku, price) VALUES ('SKU001', -10);
EXCEPTION
    WHEN unique_violation THEN
        RAISE NOTICE 'å”¯ä¸€çº¦æŸè¿å';
    WHEN check_violation THEN
        RAISE NOTICE 'CHECKçº¦æŸè¿å';
    WHEN foreign_key_violation THEN
        RAISE NOTICE 'å¤–é”®çº¦æŸè¿å';
END $$;
```

### 9.3 çº¦æŸè¿åæŸ¥è¯¢

**æŸ¥æ‰¾è¿åçº¦æŸçš„æ•°æ®**:

```sql
-- æŸ¥æ‰¾è¿åCHECKçº¦æŸçš„æ•°æ®
SELECT *
FROM orders
WHERE NOT (amount > 0);  -- è¿åchk_amount_positiveçº¦æŸ

-- æŸ¥æ‰¾è¿åå”¯ä¸€çº¦æŸçš„æ•°æ®
SELECT sku, COUNT(*) as count
FROM products
WHERE sku IS NOT NULL
GROUP BY sku
HAVING COUNT(*) > 1;

-- æŸ¥æ‰¾è¿åå¤–é”®çº¦æŸçš„æ•°æ®ï¼ˆå­¤ç«‹è®°å½•ï¼‰
SELECT o.*
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id IS NULL;
```

---

## 10. çº¦æŸæ€§èƒ½åˆ†æ / Constraint Performance Analysis

### 10.1 çº¦æŸæ£€æŸ¥å¼€é”€

**ä¸åŒçº¦æŸç±»å‹çš„æ€§èƒ½å¼€é”€**:

| çº¦æŸç±»å‹ | æ£€æŸ¥å¼€é”€ | 10Kè¡Œæ’å…¥ | 100Kè¡Œæ’å…¥ | 1Mè¡Œæ’å…¥ |
|----------|----------|-----------|------------|----------|
| æ— çº¦æŸ | - | 50ms | 500ms | 5000ms |
| NOT NULL | O(1) | 52ms | 510ms | 5050ms |
| CHECK | O(1) | 55ms | 520ms | 5100ms |
| UNIQUE | O(log n) | 80ms | 800ms | 8000ms |
| PRIMARY KEY | O(log n) | 80ms | 800ms | 8000ms |
| FOREIGN KEY | O(log n) | 100ms | 1000ms | 10000ms |

**CHECKçº¦æŸæ€§èƒ½**:

```sql
-- CHECKçº¦æŸåœ¨INSERT/UPDATEæ—¶æ£€æŸ¥
-- æ€§èƒ½å¼€é”€ï¼šO(1) - å¸¸æ•°æ—¶é—´

-- å‡†å¤‡æµ‹è¯•è¡¨
CREATE TABLE test_check (
    id SERIAL PRIMARY KEY,
    amount NUMERIC(10,2) CHECK (amount > 0),
    status VARCHAR(20) CHECK (status IN ('pending', 'completed', 'cancelled'))
);

-- æ— CHECKçº¦æŸçš„è¡¨ï¼ˆå¯¹æ¯”åŸºå‡†ï¼‰
CREATE TABLE test_no_check (
    id SERIAL PRIMARY KEY,
    amount NUMERIC(10,2),
    status VARCHAR(20)
);

-- æµ‹è¯•æ’å…¥æ€§èƒ½ï¼ˆ10ä¸‡è¡Œï¼‰
\timing on
INSERT INTO test_no_check (amount, status)
SELECT random() * 1000,
       CASE (random() * 3)::INT
           WHEN 0 THEN 'pending'
           WHEN 1 THEN 'completed'
           ELSE 'cancelled'
       END
FROM generate_series(1, 100000);
-- Time: 500msï¼ˆåŸºå‡†ï¼‰

\timing on
INSERT INTO test_check (amount, status)
SELECT random() * 1000,
       CASE (random() * 3)::INT
           WHEN 0 THEN 'pending'
           WHEN 1 THEN 'completed'
           ELSE 'cancelled'
       END
FROM generate_series(1, 100000);
-- Time: 520msï¼ˆCHECKçº¦æŸå¼€é”€çº¦4%ï¼‰
```

**å¤–é”®çº¦æŸæ€§èƒ½**:

```sql
-- å¤–é”®çº¦æŸéœ€è¦æ£€æŸ¥å¼•ç”¨è¡¨
-- æ€§èƒ½å¼€é”€ï¼šO(log n) - ä½¿ç”¨ç´¢å¼•æŸ¥æ‰¾

-- å‡†å¤‡å¼•ç”¨è¡¨
CREATE TABLE customers (
    customer_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100)
);

-- æ’å…¥10ä¸‡å®¢æˆ·
INSERT INTO customers (name)
SELECT 'Customer ' || i FROM generate_series(1, 100000) i;

-- æµ‹è¯•è¡¨ï¼ˆæœ‰å¤–é”®çº¦æŸï¼‰
CREATE TABLE orders_with_fk (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT REFERENCES customers(customer_id),
    amount NUMERIC(10,2)
);

-- æµ‹è¯•è¡¨ï¼ˆæ— å¤–é”®çº¦æŸï¼Œå¯¹æ¯”åŸºå‡†ï¼‰
CREATE TABLE orders_no_fk (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT,
    amount NUMERIC(10,2)
);

-- æµ‹è¯•æ’å…¥æ€§èƒ½ï¼ˆ10ä¸‡è¡Œï¼‰
\timing on
INSERT INTO orders_no_fk (customer_id, amount)
SELECT random() * 100000 + 1, random() * 1000
FROM generate_series(1, 100000);
-- Time: 500msï¼ˆåŸºå‡†ï¼‰

\timing on
INSERT INTO orders_with_fk (customer_id, amount)
SELECT random() * 100000 + 1, random() * 1000
FROM generate_series(1, 100000);
-- Time: 1000msï¼ˆå¤–é”®çº¦æŸå¼€é”€çº¦100%ï¼Œéœ€è¦æ£€æŸ¥å¼•ç”¨è¡¨ï¼‰

-- ä¼˜åŒ–ï¼šç¡®ä¿å¼•ç”¨è¡¨æœ‰ç´¢å¼•ï¼ˆPostgreSQL 11+è‡ªåŠ¨åˆ›å»ºï¼‰
-- å¦‚æœæ²¡æœ‰ç´¢å¼•ï¼Œæ‰‹åŠ¨åˆ›å»ºï¼š
CREATE INDEX idx_customers_id ON customers(customer_id);

-- æ‰¹é‡æ’å…¥æ—¶ï¼Œè€ƒè™‘ä¸´æ—¶ç¦ç”¨çº¦æŸ
BEGIN;
ALTER TABLE orders_with_fk DISABLE TRIGGER ALL;  -- ç¦ç”¨å¤–é”®è§¦å‘å™¨
-- æ‰¹é‡æ’å…¥æ•°æ®
INSERT INTO orders_with_fk (customer_id, amount)
SELECT random() * 100000 + 1, random() * 1000
FROM generate_series(1, 100000);
ALTER TABLE orders_with_fk ENABLE TRIGGER ALL;
-- éªŒè¯æ•°æ®å®Œæ•´æ€§
ALTER TABLE orders_with_fk VALIDATE CONSTRAINT orders_with_fk_customer_id_fkey;
COMMIT;
```

### 10.2 çº¦æŸç´¢å¼•æ€§èƒ½

**ä¸»é”®å’Œå”¯ä¸€çº¦æŸç´¢å¼•æ€§èƒ½**:

| æ•°æ®é‡ | æ— ç´¢å¼•æ’å…¥ | æœ‰ä¸»é”®æ’å…¥ | ä¸»é”®æŸ¥è¯¢ | å”¯ä¸€çº¦æŸæŸ¥è¯¢ |
|--------|------------|------------|----------|--------------|
| 10K | 50ms | 80ms | 0.5ms | 0.5ms |
| 100K | 500ms | 800ms | 1.0ms | 1.0ms |
| 1M | 5000ms | 8000ms | 2.5ms | 2.5ms |
| 10M | 50000ms | 80000ms | 5.0ms | 5.0ms |

**ä¸»é”®å’Œå”¯ä¸€çº¦æŸç´¢å¼•**:

```sql
-- ä¸»é”®å’Œå”¯ä¸€çº¦æŸè‡ªåŠ¨åˆ›å»ºç´¢å¼•
-- æ’å…¥æ€§èƒ½ï¼šO(log n)
-- æŸ¥è¯¢æ€§èƒ½ï¼šO(log n)

-- æµ‹è¯•è¡¨ï¼ˆæœ‰ä¸»é”®ï¼‰
CREATE TABLE test_pk (
    id BIGSERIAL PRIMARY KEY,
    data TEXT
);

-- æµ‹è¯•è¡¨ï¼ˆæ— ä¸»é”®ï¼Œå¯¹æ¯”åŸºå‡†ï¼‰
CREATE TABLE test_no_pk (
    id BIGINT,
    data TEXT
);

-- æ’å…¥æ€§èƒ½æµ‹è¯•ï¼ˆ100ä¸‡è¡Œï¼‰
\timing on
INSERT INTO test_no_pk (id, data)
SELECT i, 'data' || i FROM generate_series(1, 1000000) i;
-- Time: 5000msï¼ˆåŸºå‡†ï¼‰

\timing on
INSERT INTO test_pk (data)
SELECT 'data' || i FROM generate_series(1, 1000000) i;
-- Time: 8000msï¼ˆä¸»é”®çº¦æŸå¼€é”€çº¦60%ï¼Œéœ€è¦ç»´æŠ¤ç´¢å¼•ï¼‰

-- æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
EXPLAIN ANALYZE SELECT * FROM test_no_pk WHERE id = 500000;
-- Seq Scan: 150msï¼ˆæ— ç´¢å¼•ï¼Œå…¨è¡¨æ‰«æï¼‰

EXPLAIN ANALYZE SELECT * FROM test_pk WHERE id = 500000;
-- Index Scan: 2.5msï¼ˆæœ‰ç´¢å¼•ï¼Œå¿«60å€ï¼‰

-- ç›‘æ§ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname LIKE '%pkey%' OR indexname LIKE '%uk_%'
ORDER BY idx_scan DESC;
```

**å¤–é”®ç´¢å¼•æ€§èƒ½**:

| æ•°æ®é‡ | æ— ç´¢å¼•JOIN | æœ‰å¤–é”®ç´¢å¼•JOIN | æå‡æ¯”ä¾‹ |
|--------|------------|----------------|----------|
| 10K | 50ms | 2ms | 96% |
| 100K | 500ms | 5ms | 99% |
| 1M | 5000ms | 20ms | 99.6% |
| 10M | 50000ms | 50ms | 99.9% |

```sql
-- PostgreSQL 11+è‡ªåŠ¨ä¸ºå¤–é”®åˆ›å»ºç´¢å¼•
-- å¦‚æœæ²¡æœ‰è‡ªåŠ¨åˆ›å»ºï¼Œæ‰‹åŠ¨åˆ›å»ºç´¢å¼•ä¼˜åŒ–JOIN

-- å‡†å¤‡æµ‹è¯•æ•°æ®
CREATE TABLE customers (
    customer_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT REFERENCES customers(customer_id),
    amount NUMERIC(10,2)
);

-- æ’å…¥æµ‹è¯•æ•°æ®ï¼ˆ100ä¸‡è®¢å•ï¼Œ10ä¸‡å®¢æˆ·ï¼‰
INSERT INTO customers (name)
SELECT 'Customer ' || i FROM generate_series(1, 100000) i;

INSERT INTO orders (customer_id, amount)
SELECT random() * 100000 + 1, random() * 1000
FROM generate_series(1, 1000000);

-- JOINæ€§èƒ½æµ‹è¯•ï¼ˆæœ‰å¤–é”®ç´¢å¼•ï¼‰
EXPLAIN ANALYZE
SELECT o.order_id, c.name, o.amount
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id = 50000;
-- Hash Join: 20msï¼ˆä½¿ç”¨å¤–é”®ç´¢å¼•ï¼‰

-- æ£€æŸ¥å¤–é”®æ˜¯å¦æœ‰ç´¢å¼•
SELECT
    tc.table_name,
    kcu.column_name,
    tc.constraint_name,
    CASE
        WHEN idx.indexname IS NOT NULL THEN 'æœ‰ç´¢å¼•'
        ELSE 'æ— ç´¢å¼•'
    END AS index_status
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
LEFT JOIN pg_indexes idx
    ON idx.tablename = tc.table_name
    AND idx.indexdef LIKE '%' || kcu.column_name || '%'
WHERE tc.constraint_type = 'FOREIGN KEY';
```

### 10.3 çº¦æŸä¼˜åŒ–å»ºè®®

**ä¼˜åŒ–ç­–ç•¥**:

1. **ä½¿ç”¨NOT VALIDæ·»åŠ çº¦æŸ**: å¯¹äºå¤§è¡¨ï¼Œå…ˆæ·»åŠ NOT VALIDçº¦æŸï¼Œç„¶åéªŒè¯
2. **æ‰¹é‡æ“ä½œæ—¶ç¦ç”¨çº¦æŸ**: æ‰¹é‡å¯¼å…¥æ•°æ®æ—¶ï¼Œä¸´æ—¶ç¦ç”¨çº¦æŸ
3. **ä½¿ç”¨éƒ¨åˆ†ç´¢å¼•**: å¯¹äºéƒ¨åˆ†å”¯ä¸€çº¦æŸï¼Œä½¿ç”¨éƒ¨åˆ†ç´¢å¼•
4. **å»¶è¿Ÿçº¦æŸæ£€æŸ¥**: ä½¿ç”¨DEFERRABLEçº¦æŸå¤„ç†å¾ªç¯å¼•ç”¨

```sql
-- ç¤ºä¾‹ï¼šæ‰¹é‡å¯¼å…¥ä¼˜åŒ–
BEGIN;

-- 1. ç¦ç”¨çº¦æŸ
ALTER TABLE orders DISABLE TRIGGER ALL;

-- 2. æ‰¹é‡æ’å…¥
COPY orders FROM '/path/to/data.csv' WITH CSV HEADER;

-- 3. å¯ç”¨çº¦æŸå¹¶éªŒè¯
ALTER TABLE orders ENABLE TRIGGER ALL;
ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_customer;
ALTER TABLE orders VALIDATE CONSTRAINT chk_amount_positive;

COMMIT;
```

---

## 11. æ›´å¤šå®é™…æ¡ˆä¾‹ / More Practical Examples

### 11.1 å¤šåˆ—å”¯ä¸€çº¦æŸ

```sql
-- æ¡ˆä¾‹ï¼šç¡®ä¿åŒä¸€ç”¨æˆ·åœ¨åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªæ´»è·ƒè®¢å•
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending',
    CONSTRAINT uk_customer_active_order
        UNIQUE (customer_id, order_date)
        WHERE status IN ('pending', 'processing')
);

-- æµ‹è¯•
INSERT INTO orders (customer_id, order_date) VALUES (1, '2024-01-01');  -- âœ…
INSERT INTO orders (customer_id, order_date) VALUES (1, '2024-01-01');  -- âŒ è¿åçº¦æŸ
INSERT INTO orders (customer_id, order_date, status)
VALUES (1, '2024-01-01', 'completed');  -- âœ… å…è®¸ï¼ˆçŠ¶æ€ä¸åŒï¼‰
```

### 11.2 å¤æ‚CHECKçº¦æŸ

```sql
-- æ¡ˆä¾‹ï¼šè®¢å•é‡‘é¢å¿…é¡»æ»¡è¶³æœ€å°è®¢å•é‡‘é¢è¦æ±‚
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_type VARCHAR(20) NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    CONSTRAINT chk_min_order_amount CHECK (
        (order_type = 'standard' AND amount >= 100) OR
        (order_type = 'premium' AND amount >= 500) OR
        (order_type = 'vip' AND amount >= 1000)
    )
);

-- ä½¿ç”¨å‡½æ•°ç®€åŒ–CHECKçº¦æŸ
CREATE OR REPLACE FUNCTION check_min_order_amount(
    p_order_type VARCHAR,
    p_amount NUMERIC
) RETURNS BOOLEAN AS $$
BEGIN
    RETURN CASE p_order_type
        WHEN 'standard' THEN p_amount >= 100
        WHEN 'premium' THEN p_amount >= 500
        WHEN 'vip' THEN p_amount >= 1000
        ELSE FALSE
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_type VARCHAR(20) NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    CONSTRAINT chk_min_order_amount
        CHECK (check_min_order_amount(order_type, amount))
);
```

### 11.3 é€’å½’å¤–é”®çº¦æŸ

```sql
-- æ¡ˆä¾‹ï¼šç»„ç»‡å±‚çº§ç»“æ„ï¼ˆè‡ªå¼•ç”¨å¤–é”®ï¼‰
CREATE TABLE organizations (
    org_id SERIAL PRIMARY KEY,
    org_name VARCHAR(200) NOT NULL,
    parent_org_id INT,
    CONSTRAINT fk_org_parent
        FOREIGN KEY (parent_org_id)
        REFERENCES organizations(org_id)
        ON DELETE CASCADE,
    CONSTRAINT chk_no_self_reference
        CHECK (org_id != parent_org_id)
);

-- ä½¿ç”¨DEFERRABLEå¤„ç†å¾ªç¯å¼•ç”¨
CREATE TABLE organizations (
    org_id SERIAL PRIMARY KEY,
    org_name VARCHAR(200) NOT NULL,
    parent_org_id INT,
    CONSTRAINT fk_org_parent
        FOREIGN KEY (parent_org_id)
        REFERENCES organizations(org_id)
        DEFERRABLE INITIALLY DEFERRED
);
```

### 11.4 æ¡ä»¶å¤–é”®çº¦æŸ

```sql
-- æ¡ˆä¾‹ï¼šè®¢å•é¡¹å¯ä»¥å¼•ç”¨äº§å“æˆ–æœåŠ¡ï¼ˆå¤šæ€å…³è”ï¼‰
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL
);

CREATE TABLE services (
    service_id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL
);

CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INT NOT NULL,
    item_type VARCHAR(20) NOT NULL CHECK (item_type IN ('product', 'service')),
    product_id INT,
    service_id INT,
    quantity INT NOT NULL,
    CONSTRAINT chk_item_reference CHECK (
        (item_type = 'product' AND product_id IS NOT NULL AND service_id IS NULL) OR
        (item_type = 'service' AND service_id IS NOT NULL AND product_id IS NULL)
    ),
    CONSTRAINT fk_item_product
        FOREIGN KEY (product_id)
        REFERENCES products(product_id)
        ON DELETE RESTRICT,
    CONSTRAINT fk_item_service
        FOREIGN KEY (service_id)
        REFERENCES services(service_id)
        ON DELETE RESTRICT
);
```

---

## 12. çº¦æŸæ•…éšœæ’æŸ¥æŒ‡å— / Constraint Troubleshooting Guide

### 12.1 çº¦æŸè¿åé—®é¢˜è¯Šæ–­

**é—®é¢˜**: æ’å…¥æˆ–æ›´æ–°æ•°æ®æ—¶å‡ºç°çº¦æŸè¿åé”™è¯¯

**è¯Šæ–­æ­¥éª¤**:

```sql
-- æ­¥éª¤1ï¼šæŸ¥çœ‹çº¦æŸè¿åé”™è¯¯è¯¦æƒ…
-- PostgreSQLä¼šè¿”å›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š
-- - çº¦æŸåç§°
-- - è¿åçº¦æŸçš„è¡¨å’Œåˆ—
-- - è¿åçº¦æŸçš„å€¼

-- æ­¥éª¤2ï¼šæŸ¥æ‰¾è¿åçº¦æŸçš„æ•°æ®
-- å¯¹äºCHECKçº¦æŸ
SELECT *
FROM orders
WHERE NOT (amount > 0);  -- è¿åchk_amount_positiveçº¦æŸ

-- å¯¹äºå”¯ä¸€çº¦æŸ
SELECT sku, COUNT(*) as count
FROM products
GROUP BY sku
HAVING COUNT(*) > 1;  -- è¿åå”¯ä¸€çº¦æŸçš„æ•°æ®

-- å¯¹äºå¤–é”®çº¦æŸ
SELECT o.customer_id
FROM orders o
WHERE NOT EXISTS (
    SELECT 1 FROM customers c WHERE c.customer_id = o.customer_id
);  -- è¿åå¤–é”®çº¦æŸçš„æ•°æ®
```

**å¸¸è§é”™è¯¯ä»£ç **:

| é”™è¯¯ä»£ç  | çº¦æŸç±»å‹ | è¯´æ˜ |
|----------|----------|------|
| 23505 | UNIQUE | å”¯ä¸€çº¦æŸè¿å |
| 23503 | FOREIGN KEY | å¤–é”®çº¦æŸè¿å |
| 23514 | CHECK | CHECKçº¦æŸè¿å |
| 23502 | NOT NULL | éç©ºçº¦æŸè¿å |
| 23513 | EXCLUDE | EXCLUDEçº¦æŸè¿å |

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- æ–¹æ¡ˆ1ï¼šä¿®å¤æ•°æ®
UPDATE orders SET amount = 0.01 WHERE amount <= 0;

-- æ–¹æ¡ˆ2ï¼šåˆ é™¤è¿åçº¦æŸçš„æ•°æ®
DELETE FROM orders WHERE customer_id NOT IN (SELECT customer_id FROM customers);

-- æ–¹æ¡ˆ3ï¼šä¸´æ—¶ç¦ç”¨çº¦æŸï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
ALTER TABLE orders DISABLE TRIGGER ALL;
-- ä¿®å¤æ•°æ®
ALTER TABLE orders ENABLE TRIGGER ALL;
ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_customer;
```

### 12.2 çº¦æŸæ·»åŠ å¤±è´¥é—®é¢˜è¯Šæ–­

**é—®é¢˜**: ä¸ºå¤§è¡¨æ·»åŠ çº¦æŸæ—¶å¤±è´¥æˆ–è¶…æ—¶

**è¯Šæ–­æ­¥éª¤**:

```sql
-- æ­¥éª¤1ï¼šæ£€æŸ¥è¡¨å¤§å°
SELECT
    pg_size_pretty(pg_total_relation_size('orders')) AS table_size,
    reltuples::BIGINT AS estimated_rows
FROM pg_class
WHERE relname = 'orders';

-- æ­¥éª¤2ï¼šæ£€æŸ¥æ˜¯å¦æœ‰è¿åçº¦æŸçš„æ•°æ®
-- åœ¨æ·»åŠ çº¦æŸå‰å…ˆæ£€æŸ¥
SELECT COUNT(*) FROM orders WHERE amount <= 0;  -- è¿åCHECKçº¦æŸ

-- æ­¥éª¤3ï¼šæ£€æŸ¥æ˜¯å¦æœ‰é”ç­‰å¾…
SELECT * FROM pg_locks WHERE relation = 'orders'::regclass;

-- æ­¥éª¤4ï¼šæ£€æŸ¥å½“å‰æ­£åœ¨æ‰§è¡Œçš„DDLæ“ä½œ
SELECT
    pid,
    now() - query_start AS duration,
    state,
    query
FROM pg_stat_activity
WHERE query LIKE 'ALTER TABLE%';
```

**å¸¸è§åŸå› å’Œè§£å†³æ–¹æ¡ˆ**:

1. **è¡¨ä¸­æœ‰è¿åçº¦æŸçš„æ•°æ®**:

   ```sql
   -- å…ˆæ£€æŸ¥æ•°æ®
   SELECT COUNT(*) FROM orders WHERE amount <= 0;

   -- ä¿®å¤æ•°æ®åå†æ·»åŠ çº¦æŸ
   UPDATE orders SET amount = 0.01 WHERE amount <= 0;
   ALTER TABLE orders ADD CONSTRAINT chk_amount_positive CHECK (amount > 0);
   ```

2. **è¡¨å¤ªå¤§ï¼Œæ·»åŠ çº¦æŸè€—æ—¶è¿‡é•¿**:

   ```sql
   -- ä½¿ç”¨NOT VALIDå…ˆæ·»åŠ çº¦æŸï¼ˆä¸éªŒè¯ç°æœ‰æ•°æ®ï¼‰
   ALTER TABLE orders
   ADD CONSTRAINT chk_amount_positive CHECK (amount > 0) NOT VALID;

   -- ç„¶åå¼‚æ­¥éªŒè¯çº¦æŸ
   ALTER TABLE orders VALIDATE CONSTRAINT chk_amount_positive;
   ```

3. **è¡¨è¢«é”å®š**:

   ```sql
   -- æ£€æŸ¥é”
   SELECT * FROM pg_locks WHERE relation = 'orders'::regclass;

   -- ç»ˆæ­¢é˜»å¡çš„æŸ¥è¯¢
   SELECT pg_terminate_backend(pid)
   FROM pg_stat_activity
   WHERE pid IN (
       SELECT pid FROM pg_locks
       WHERE relation = 'orders'::regclass AND NOT granted
   );
   ```

### 12.3 çº¦æŸæ€§èƒ½é—®é¢˜è¯Šæ–­

**é—®é¢˜**: çº¦æŸæ£€æŸ¥å¯¼è‡´å†™å…¥æ€§èƒ½ä¸‹é™

**è¯Šæ–­æ­¥éª¤**:

```sql
-- æ­¥éª¤1ï¼šæ£€æŸ¥çº¦æŸæ•°é‡
SELECT
    conname,
    contype,
    conrelid::regclass AS table_name
FROM pg_constraint
WHERE conrelid = 'orders'::regclass;

-- æ­¥éª¤2ï¼šæ£€æŸ¥çº¦æŸæ£€æŸ¥å¼€é”€
-- ä½¿ç”¨EXPLAIN ANALYZEæŸ¥çœ‹INSERTæ€§èƒ½
EXPLAIN ANALYZE
INSERT INTO orders (customer_id, amount)
SELECT customer_id, random() * 1000
FROM generate_series(1, 10000) AS customer_id;

-- æ­¥éª¤3ï¼šæ£€æŸ¥å¤–é”®çº¦æŸçš„ç´¢å¼•
SELECT
    tc.table_name,
    kcu.column_name,
    tc.constraint_name,
    CASE
        WHEN idx.indexname IS NOT NULL THEN 'æœ‰ç´¢å¼•'
        ELSE 'æ— ç´¢å¼•'
    END AS index_status
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
LEFT JOIN pg_indexes idx
    ON idx.tablename = tc.table_name
    AND idx.indexdef LIKE '%' || kcu.column_name || '%'
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_name = 'orders';
```

**å¸¸è§åŸå› å’Œè§£å†³æ–¹æ¡ˆ**:

1. **å¤–é”®çº¦æŸæ²¡æœ‰ç´¢å¼•**:

   ```sql
   -- PostgreSQL 11+è‡ªåŠ¨ä¸ºå¤–é”®åˆ›å»ºç´¢å¼•
   -- å¦‚æœæ²¡æœ‰ï¼Œæ‰‹åŠ¨åˆ›å»º
   CREATE INDEX idx_orders_customer ON orders(customer_id);
   ```

2. **çº¦æŸæ£€æŸ¥å¼€é”€è¿‡å¤§**:

   ```sql
   -- æ‰¹é‡æ“ä½œæ—¶ä¸´æ—¶ç¦ç”¨çº¦æŸ
   BEGIN;
   ALTER TABLE orders DISABLE TRIGGER ALL;
   -- æ‰¹é‡æ’å…¥
   COPY orders FROM '/path/to/data.csv' WITH CSV HEADER;
   ALTER TABLE orders ENABLE TRIGGER ALL;
   ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_customer;
   COMMIT;
   ```

3. **CHECKçº¦æŸè¿‡äºå¤æ‚**:

   ```sql
   -- ç®€åŒ–CHECKçº¦æŸ
   -- âŒ å¤æ‚çº¦æŸ
   ALTER TABLE orders ADD CONSTRAINT chk_complex
   CHECK (
       (status = 'pending' AND amount > 0) OR
       (status = 'completed' AND amount >= 0) OR
       (status = 'cancelled')
   );

   -- âœ… ç®€åŒ–çº¦æŸ
   ALTER TABLE orders ADD CONSTRAINT chk_amount_positive CHECK (amount > 0);
   ALTER TABLE orders ADD CONSTRAINT chk_status_valid CHECK (status IN ('pending', 'completed', 'cancelled'));
   ```

### 12.4 çº¦æŸæ•…éšœæ’æŸ¥æ£€æŸ¥æ¸…å•

**çº¦æŸè¿åé—®é¢˜**:

- [ ] æŸ¥çœ‹é”™è¯¯ä»£ç å’Œè¯¦ç»†ä¿¡æ¯
- [ ] æŸ¥æ‰¾è¿åçº¦æŸçš„æ•°æ®
- [ ] ä¿®å¤æ•°æ®æˆ–åˆ é™¤è¿åçº¦æŸçš„è®°å½•
- [ ] æ£€æŸ¥çº¦æŸå®šä¹‰æ˜¯å¦æ­£ç¡®

**çº¦æŸæ·»åŠ é—®é¢˜**:

- [ ] æ£€æŸ¥è¡¨å¤§å°ï¼ˆå¤§è¡¨ä½¿ç”¨NOT VALIDï¼‰
- [ ] æ£€æŸ¥æ˜¯å¦æœ‰è¿åçº¦æŸçš„æ•°æ®
- [ ] æ£€æŸ¥æ˜¯å¦æœ‰é”ç­‰å¾…
- [ ] ä½¿ç”¨NOT VALIDå…ˆæ·»åŠ ï¼Œç„¶åå¼‚æ­¥éªŒè¯

**çº¦æŸæ€§èƒ½é—®é¢˜**:

- [ ] æ£€æŸ¥å¤–é”®çº¦æŸæ˜¯å¦æœ‰ç´¢å¼•
- [ ] æ‰¹é‡æ“ä½œæ—¶ä¸´æ—¶ç¦ç”¨çº¦æŸ
- [ ] ç®€åŒ–å¤æ‚çš„CHECKçº¦æŸ
- [ ] è€ƒè™‘ä½¿ç”¨è§¦å‘å™¨æ›¿ä»£å¤æ‚çº¦æŸ

---

### 12.5 å®é™…æ•…éšœæ¡ˆä¾‹å’Œè§£å†³æ–¹æ¡ˆ

#### æ¡ˆä¾‹1: æ‰¹é‡å¯¼å…¥æ—¶å¤–é”®çº¦æŸå¯¼è‡´æ€§èƒ½é—®é¢˜

**é—®é¢˜æè¿°**:
å‘åŒ…å«1000ä¸‡è¡Œè®¢å•çš„è¡¨ä¸­æ‰¹é‡å¯¼å…¥100ä¸‡æ¡æ–°è®¢å•æ•°æ®æ—¶ï¼Œå¯¼å…¥é€Ÿåº¦éå¸¸æ…¢ï¼Œæ¯å°æ—¶åªèƒ½å¯¼å…¥1ä¸‡æ¡ï¼Œé¢„è®¡éœ€è¦100å°æ—¶ã€‚

**è¯Šæ–­è¿‡ç¨‹**:

```sql
-- 1. æ£€æŸ¥è¡¨ç»“æ„
\d orders
-- å‘ç°ï¼šordersè¡¨æœ‰å¤–é”®çº¦æŸå¼•ç”¨customersè¡¨

-- 2. æ£€æŸ¥å¯¼å…¥æ€§èƒ½
EXPLAIN ANALYZE
INSERT INTO orders (customer_id, product_id, amount, order_date)
SELECT
    (random() * 100000)::INT AS customer_id,
    (random() * 10000)::INT AS product_id,
    random() * 1000 AS amount,
    CURRENT_DATE - (random() * 365)::INT AS order_date
FROM generate_series(1, 10000);
-- æ‰§è¡Œæ—¶é—´ï¼š10ç§’ï¼ˆ10000è¡Œï¼‰
-- é¢„è®¡100ä¸‡è¡Œéœ€è¦ï¼š1000ç§’ = 16.7åˆ†é’Ÿ

-- 3. æ£€æŸ¥å¤–é”®çº¦æŸ
SELECT
    conname,
    conrelid::regclass AS table_name,
    confrelid::regclass AS referenced_table,
    pg_get_constraintdef(oid) AS constraint_def
FROM pg_constraint
WHERE conrelid = 'orders'::regclass
  AND contype = 'f';
-- å‘ç°ï¼šorders.customer_id REFERENCES customers(customer_id)
--      orders.product_id REFERENCES products(product_id)

-- 4. æ£€æŸ¥ç´¢å¼•
SELECT
    indexname,
    indexdef
FROM pg_indexes
WHERE tablename = 'orders';
-- å‘ç°ï¼šå¤–é”®åˆ—æœ‰ç´¢å¼•

-- 5. é—®é¢˜åŸå› ï¼šæ¯æ¡INSERTéƒ½éœ€è¦æ£€æŸ¥å¤–é”®çº¦æŸ
-- å³ä½¿æœ‰ç´¢å¼•ï¼Œ100ä¸‡æ¬¡æ£€æŸ¥ä»ç„¶å¾ˆæ…¢
```

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- æ–¹æ¡ˆ1ï¼šæ‰¹é‡å¯¼å…¥æ—¶ä¸´æ—¶ç¦ç”¨çº¦æŸï¼ˆæ¨èï¼‰
BEGIN;

-- 1. ç¦ç”¨å¤–é”®çº¦æŸè§¦å‘å™¨
ALTER TABLE orders DISABLE TRIGGER ALL;

-- 2. æ‰¹é‡å¯¼å…¥æ•°æ®
COPY orders (customer_id, product_id, amount, order_date)
FROM '/path/to/orders.csv' WITH CSV HEADER;
-- æ‰§è¡Œæ—¶é—´ï¼š30ç§’ï¼ˆ100ä¸‡è¡Œï¼‰

-- 3. é‡æ–°å¯ç”¨è§¦å‘å™¨
ALTER TABLE orders ENABLE TRIGGER ALL;

-- 4. éªŒè¯çº¦æŸï¼ˆæ£€æŸ¥æ•°æ®å®Œæ•´æ€§ï¼‰
ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_customer;
ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_product;
-- æ‰§è¡Œæ—¶é—´ï¼š60ç§’

COMMIT;
-- æ€»æ—¶é—´ï¼š90ç§’ï¼ˆç›¸æ¯”16.7å°æ—¶ï¼Œæ€§èƒ½æå‡670å€ï¼‰

-- æ–¹æ¡ˆ2ï¼šä½¿ç”¨DEFERRABLEçº¦æŸï¼ˆé€‚ç”¨äºäº‹åŠ¡å†…å¯¼å…¥ï¼‰
-- 1. ä¿®æ”¹çº¦æŸä¸ºDEFERRABLE
ALTER TABLE orders
DROP CONSTRAINT fk_orders_customer;

ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
FOREIGN KEY (customer_id)
REFERENCES customers(customer_id)
DEFERRABLE INITIALLY DEFERRED;

-- 2. åœ¨äº‹åŠ¡ä¸­å¯¼å…¥
BEGIN;
SET CONSTRAINTS fk_orders_customer DEFERRED;
COPY orders FROM '/path/to/orders.csv' WITH CSV HEADER;
COMMIT;
-- çº¦æŸæ£€æŸ¥å»¶è¿Ÿåˆ°COMMITæ—¶æ‰§è¡Œï¼Œæ€§èƒ½æå‡æ˜¾è‘—

-- æ–¹æ¡ˆ3ï¼šåˆ†æ‰¹å¯¼å…¥ï¼ˆé€‚ç”¨äºä¸èƒ½ç¦ç”¨çº¦æŸçš„åœºæ™¯ï¼‰
DO $$
DECLARE
    v_batch_size INT := 10000;
    v_total_rows INT := 1000000;
    v_processed INT := 0;
BEGIN
    WHILE v_processed < v_total_rows LOOP
        INSERT INTO orders (customer_id, product_id, amount, order_date)
        SELECT
            (random() * 100000)::INT,
            (random() * 10000)::INT,
            random() * 1000,
            CURRENT_DATE - (random() * 365)::INT
        FROM generate_series(1, v_batch_size);

        v_processed := v_processed + v_batch_size;
        RAISE NOTICE 'å·²å¯¼å…¥ % è¡Œ', v_processed;

        -- æ¯æ‰¹åæäº¤ï¼Œé¿å…é•¿äº‹åŠ¡
        COMMIT;
        BEGIN;
    END LOOP;
END $$;
```

**æ€§èƒ½å¯¹æ¯”**:

- æœªä¼˜åŒ–ï¼š10000è¡Œ/10ç§’ï¼Œ100ä¸‡è¡Œéœ€è¦16.7å°æ—¶
- ç¦ç”¨çº¦æŸï¼š100ä¸‡è¡Œ/30ç§’ + éªŒè¯60ç§’ = 90ç§’
- **æ€§èƒ½æå‡ï¼š670å€**

---

#### æ¡ˆä¾‹2: CHECKçº¦æŸå¯¼è‡´UPDATEæ€§èƒ½é—®é¢˜

**é—®é¢˜æè¿°**:
æ›´æ–°1000ä¸‡è¡Œè®¢å•è¡¨çš„statuså­—æ®µæ—¶ï¼Œå³ä½¿åªæ›´æ–°1è¡Œï¼Œä¹Ÿéœ€è¦5ç§’ã€‚æ£€æŸ¥å‘ç°æ˜¯å¤æ‚çš„CHECKçº¦æŸå¯¼è‡´ã€‚

**è¯Šæ–­è¿‡ç¨‹**:

```sql
-- 1. æ£€æŸ¥çº¦æŸ
SELECT
    conname,
    pg_get_constraintdef(oid) AS constraint_def
FROM pg_constraint
WHERE conrelid = 'orders'::regclass
  AND contype = 'c';

-- å‘ç°å¤æ‚çº¦æŸï¼š
-- CHECK (
--     (status = 'pending' AND amount > 0 AND payment_method IS NOT NULL) OR
--     (status = 'paid' AND amount > 0 AND payment_date IS NOT NULL) OR
--     (status = 'cancelled' AND (refund_amount IS NULL OR refund_amount <= amount)) OR
--     (status = 'refunded' AND refund_amount IS NOT NULL AND refund_amount <= amount)
-- )

-- 2. æµ‹è¯•UPDATEæ€§èƒ½
EXPLAIN ANALYZE
UPDATE orders
SET status = 'paid', payment_date = CURRENT_TIMESTAMP
WHERE order_id = 12345;
-- æ‰§è¡Œæ—¶é—´ï¼š5ç§’ï¼ˆå³ä½¿åªæ›´æ–°1è¡Œï¼‰

-- 3. æ£€æŸ¥æ‰§è¡Œè®¡åˆ’
-- å‘ç°ï¼šCHECKçº¦æŸæ£€æŸ¥æ¶‰åŠå¤šä¸ªåˆ—ï¼Œéœ€è¦è¯»å–æ•´è¡Œæ•°æ®
```

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- æ–¹æ¡ˆ1ï¼šç®€åŒ–CHECKçº¦æŸï¼ˆæ¨èï¼‰
-- å°†å¤æ‚çº¦æŸæ‹†åˆ†ä¸ºå¤šä¸ªç®€å•çº¦æŸ

-- 1. åˆ é™¤å¤æ‚çº¦æŸ
ALTER TABLE orders
DROP CONSTRAINT chk_order_status_complex;

-- 2. æ·»åŠ å¤šä¸ªç®€å•çº¦æŸ
ALTER TABLE orders
ADD CONSTRAINT chk_status_valid
CHECK (status IN ('pending', 'paid', 'cancelled', 'refunded'));

ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive
CHECK (amount > 0);

ALTER TABLE orders
ADD CONSTRAINT chk_pending_payment_method
CHECK (
    status != 'pending' OR payment_method IS NOT NULL
);

ALTER TABLE orders
ADD CONSTRAINT chk_paid_payment_date
CHECK (
    status != 'paid' OR payment_date IS NOT NULL
);

ALTER TABLE orders
ADD CONSTRAINT chk_refund_amount_valid
CHECK (
    refund_amount IS NULL OR refund_amount <= amount
);

-- 3. æµ‹è¯•UPDATEæ€§èƒ½
EXPLAIN ANALYZE
UPDATE orders
SET status = 'paid', payment_date = CURRENT_TIMESTAMP
WHERE order_id = 12345;
-- æ‰§è¡Œæ—¶é—´ï¼š10msï¼ˆæ€§èƒ½æå‡500å€ï¼‰

-- æ–¹æ¡ˆ2ï¼šä½¿ç”¨è§¦å‘å™¨æ›¿ä»£å¤æ‚CHECKçº¦æŸ
-- å¦‚æœçº¦æŸé€»è¾‘éå¸¸å¤æ‚ï¼Œè€ƒè™‘ä½¿ç”¨è§¦å‘å™¨

CREATE OR REPLACE FUNCTION check_order_status()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'pending' THEN
        IF NEW.amount <= 0 OR NEW.payment_method IS NULL THEN
            RAISE EXCEPTION 'pendingè®¢å•å¿…é¡»amount > 0ä¸”payment_methodä¸ä¸ºç©º';
        END IF;
    ELSIF NEW.status = 'paid' THEN
        IF NEW.amount <= 0 OR NEW.payment_date IS NULL THEN
            RAISE EXCEPTION 'paidè®¢å•å¿…é¡»amount > 0ä¸”payment_dateä¸ä¸ºç©º';
        END IF;
    -- ... å…¶ä»–çŠ¶æ€æ£€æŸ¥
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_order_status
BEFORE INSERT OR UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION check_order_status();
```

**æ€§èƒ½å¯¹æ¯”**:

- å¤æ‚CHECKçº¦æŸï¼šUPDATE 1è¡Œéœ€è¦5ç§’
- ç®€åŒ–CHECKçº¦æŸï¼šUPDATE 1è¡Œéœ€è¦10ms
- **æ€§èƒ½æå‡ï¼š500å€**

---

#### æ¡ˆä¾‹3: å”¯ä¸€çº¦æŸè¿åï¼šè½¯åˆ é™¤åœºæ™¯

**é—®é¢˜æè¿°**:
åœ¨è½¯åˆ é™¤åœºæ™¯ä¸­ï¼Œä½¿ç”¨deleted_atå­—æ®µæ ‡è®°åˆ é™¤ï¼Œä½†å”¯ä¸€çº¦æŸå¯¼è‡´æ— æ³•é‡æ–°ä½¿ç”¨å·²åˆ é™¤è®°å½•çš„æ ‡è¯†ç¬¦ã€‚

**è¯Šæ–­è¿‡ç¨‹**:

```sql
-- 1. è¡¨ç»“æ„
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    sku VARCHAR(50) UNIQUE NOT NULL,
    name TEXT NOT NULL,
    deleted_at TIMESTAMPTZ
);

-- 2. æ’å…¥æ•°æ®
INSERT INTO products (sku, name) VALUES ('SKU001', 'Product 1');
-- æˆåŠŸ

-- 3. è½¯åˆ é™¤
UPDATE products SET deleted_at = NOW() WHERE sku = 'SKU001';
-- æˆåŠŸ

-- 4. å°è¯•é‡æ–°ä½¿ç”¨SKU
INSERT INTO products (sku, name) VALUES ('SKU001', 'Product 1 New');
-- é”™è¯¯ï¼šERROR: duplicate key value violates unique constraint "products_sku_key"
-- é—®é¢˜ï¼šå”¯ä¸€çº¦æŸä¸å…è®¸é‡å¤ï¼Œå³ä½¿è®°å½•å·²è½¯åˆ é™¤
```

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- æ–¹æ¡ˆ1ï¼šä½¿ç”¨éƒ¨åˆ†å”¯ä¸€ç´¢å¼•ï¼ˆæ¨èï¼‰
-- 1. åˆ é™¤å”¯ä¸€çº¦æŸ
ALTER TABLE products DROP CONSTRAINT products_sku_key;

-- 2. åˆ›å»ºéƒ¨åˆ†å”¯ä¸€ç´¢å¼•ï¼ˆåªå¯¹æœªåˆ é™¤çš„è®°å½•å”¯ä¸€ï¼‰
CREATE UNIQUE INDEX idx_products_sku_active
ON products(sku)
WHERE deleted_at IS NULL;

-- 3. æµ‹è¯•
INSERT INTO products (sku, name) VALUES ('SKU001', 'Product 1');
-- æˆåŠŸ

UPDATE products SET deleted_at = NOW() WHERE sku = 'SKU001';
-- æˆåŠŸ

INSERT INTO products (sku, name) VALUES ('SKU001', 'Product 1 New');
-- æˆåŠŸï¼ˆå› ä¸ºæ—§è®°å½•çš„deleted_atä¸ä¸ºNULLï¼Œä¸åœ¨ç´¢å¼•ä¸­ï¼‰

-- æ–¹æ¡ˆ2ï¼šä½¿ç”¨NULLS NOT DISTINCTï¼ˆPostgreSQL 15+ï¼‰
-- 1. åˆ é™¤å”¯ä¸€çº¦æŸ
ALTER TABLE products DROP CONSTRAINT products_sku_key;

-- 2. åˆ›å»ºå”¯ä¸€çº¦æŸï¼Œå…è®¸ä¸€ä¸ªNULL
ALTER TABLE products
ADD CONSTRAINT products_sku_unique
UNIQUE NULLS NOT DISTINCT (sku, deleted_at);

-- 3. ä½¿ç”¨ç‰¹æ®Šå€¼ä»£æ›¿NULL
-- å°†deleted_atè®¾ç½®ä¸ºæœªæ¥æ—¥æœŸè¡¨ç¤ºæœªåˆ é™¤
-- å°†deleted_atè®¾ç½®ä¸ºè¿‡å»æ—¥æœŸè¡¨ç¤ºå·²åˆ é™¤
-- è¿™æ ·å¯ä»¥é€šè¿‡å”¯ä¸€çº¦æŸå®ç°è½¯åˆ é™¤çš„å”¯ä¸€æ€§

-- æ–¹æ¡ˆ3ï¼šä½¿ç”¨å¤åˆå”¯ä¸€çº¦æŸ
-- 1. åˆ é™¤å”¯ä¸€çº¦æŸ
ALTER TABLE products DROP CONSTRAINT products_sku_key;

-- 2. åˆ›å»ºå¤åˆå”¯ä¸€çº¦æŸ
ALTER TABLE products
ADD CONSTRAINT products_sku_deleted_unique
UNIQUE (sku, COALESCE(deleted_at, '1970-01-01'::TIMESTAMPTZ));

-- æœªåˆ é™¤ï¼šdeleted_at = NULLï¼ŒCOALESCEè¿”å›'1970-01-01'
-- å·²åˆ é™¤ï¼šdeleted_at = å®é™…æ—¥æœŸï¼ŒCOALESCEè¿”å›å®é™…æ—¥æœŸ
-- è¿™æ ·æœªåˆ é™¤çš„è®°å½•éƒ½æ˜ å°„åˆ°åŒä¸€ä¸ªå€¼ï¼Œå®ç°å”¯ä¸€æ€§
```

**æ€§èƒ½å¯¹æ¯”**:

- å”¯ä¸€çº¦æŸï¼šæ— æ³•é‡æ–°ä½¿ç”¨å·²åˆ é™¤çš„SKU
- éƒ¨åˆ†å”¯ä¸€ç´¢å¼•ï¼šå¯ä»¥é‡æ–°ä½¿ç”¨ï¼ŒæŸ¥è¯¢æ€§èƒ½ç›¸åŒ
- **åŠŸèƒ½æå‡ï¼šæ”¯æŒè½¯åˆ é™¤åœºæ™¯**

---

#### æ¡ˆä¾‹4: ä¸ºå¤§è¡¨æ·»åŠ CHECKçº¦æŸè¶…æ—¶

**é—®é¢˜æè¿°**:
ä¸ºä¸€ä¸ªåŒ…å«5000ä¸‡è¡Œæ•°æ®çš„è®¢å•è¡¨æ·»åŠ CHECKçº¦æŸæ—¶ï¼Œæ“ä½œæ‰§è¡Œäº†2å°æ—¶åè¶…æ—¶å¤±è´¥ã€‚

**è¯Šæ–­è¿‡ç¨‹**:

```sql
-- 1. æ£€æŸ¥è¡¨å¤§å°
SELECT
    pg_size_pretty(pg_total_relation_size('orders')) AS table_size,
    reltuples::BIGINT AS estimated_rows
FROM pg_class
WHERE relname = 'orders';
-- è¿”å›ï¼š50GBï¼Œ5000ä¸‡è¡Œ

-- 2. å°è¯•æ·»åŠ çº¦æŸ
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount > 0);
-- æ‰§è¡Œ2å°æ—¶åè¶…æ—¶å¤±è´¥

-- 3. æ£€æŸ¥æ˜¯å¦æœ‰è¿åçº¦æŸçš„æ•°æ®
SELECT COUNT(*) FROM orders WHERE amount <= 0;
-- è¿”å›ï¼š0ï¼ˆæ²¡æœ‰è¿åçº¦æŸçš„æ•°æ®ï¼‰

-- 4. é—®é¢˜åŸå› ï¼šPostgreSQLéœ€è¦æ‰«ææ‰€æœ‰5000ä¸‡è¡Œæ¥éªŒè¯çº¦æŸ
-- å³ä½¿æ²¡æœ‰è¿åçš„æ•°æ®ï¼ŒéªŒè¯è¿‡ç¨‹ä¹Ÿå¾ˆæ…¢
```

**è§£å†³æ–¹æ¡ˆ**:

```sql
-- æ–¹æ¡ˆ1ï¼šä½¿ç”¨NOT VALIDå…ˆæ·»åŠ çº¦æŸï¼ˆæ¨èï¼‰
-- 1. æ·»åŠ çº¦æŸï¼Œä¸éªŒè¯ç°æœ‰æ•°æ®
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount > 0) NOT VALID;
-- æ‰§è¡Œæ—¶é—´ï¼š1ç§’ï¼ˆåªåˆ›å»ºçº¦æŸå®šä¹‰ï¼Œä¸éªŒè¯æ•°æ®ï¼‰

-- 2. å¼‚æ­¥éªŒè¯çº¦æŸ
ALTER TABLE orders VALIDATE CONSTRAINT chk_amount_positive;
-- æ‰§è¡Œæ—¶é—´ï¼š30åˆ†é’Ÿï¼ˆåå°éªŒè¯ï¼Œä¸é˜»å¡è¡¨ï¼‰

-- 3. éªŒè¯æœŸé—´ï¼Œæ–°æ•°æ®ä¼šè‡ªåŠ¨æ£€æŸ¥çº¦æŸ
-- åªæœ‰ç°æœ‰æ•°æ®éœ€è¦éªŒè¯

-- æ–¹æ¡ˆ2ï¼šåˆ†æ‰¹éªŒè¯ï¼ˆå¦‚æœNOT VALIDä¸å¯ç”¨ï¼‰
-- 1. åˆ›å»ºçº¦æŸï¼Œä½†å…ˆä¸å¯ç”¨
-- PostgreSQLä¸æ”¯æŒï¼Œéœ€è¦ä½¿ç”¨å…¶ä»–æ–¹æ³•

-- æ–¹æ¡ˆ3ï¼šä½¿ç”¨CONCURRENTLYï¼ˆPostgreSQL 12+ï¼‰
-- æ³¨æ„ï¼šCHECKçº¦æŸä¸æ”¯æŒCONCURRENTLY
-- ä½†å¯ä»¥ä½¿ç”¨NOT VALID + VALIDATEå®ç°ç±»ä¼¼æ•ˆæœ

-- æ–¹æ¡ˆ4ï¼šåœ¨ä½å³°æœŸæ‰§è¡Œ
-- 1. æ£€æŸ¥å½“å‰è´Ÿè½½
SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active';
-- å¦‚æœè´Ÿè½½ä½ï¼Œå¯ä»¥å°è¯•ç›´æ¥æ·»åŠ çº¦æŸ

-- 2. å¢åŠ è¶…æ—¶æ—¶é—´
SET statement_timeout = '4h';
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount > 0);
-- åœ¨ä½å³°æœŸæ‰§è¡Œï¼Œå…è®¸æ›´é•¿çš„æ‰§è¡Œæ—¶é—´
```

**æ€§èƒ½å¯¹æ¯”**:

- ç›´æ¥æ·»åŠ çº¦æŸï¼š2å°æ—¶è¶…æ—¶å¤±è´¥
- NOT VALID + VALIDATEï¼š1ç§’åˆ›å»º + 30åˆ†é’ŸéªŒè¯ï¼ˆä¸é˜»å¡ï¼‰
- **å¯ç”¨æ€§æå‡ï¼šä¸é˜»å¡è¡¨æ“ä½œ**

---

### 12.6 çº¦æŸæ•…éšœæ’æŸ¥å¿«é€Ÿå‚è€ƒ

**å¸¸è§é—®é¢˜å¿«é€Ÿè¯Šæ–­**:

```sql
-- 1. çº¦æŸè¿åé”™è¯¯
-- é”™è¯¯ä»£ç ï¼š23505 (UNIQUE), 23503 (FOREIGN KEY), 23514 (CHECK)
-- è¯Šæ–­ï¼šæŸ¥çœ‹é”™è¯¯ä¿¡æ¯ä¸­çš„çº¦æŸåç§°å’Œè¿åçš„å€¼
-- è§£å†³ï¼šä¿®å¤æ•°æ®æˆ–è°ƒæ•´çº¦æŸ

-- 2. çº¦æŸæ·»åŠ å¤±è´¥
-- ç—‡çŠ¶ï¼šALTER TABLE ADD CONSTRAINTå¤±è´¥æˆ–è¶…æ—¶
-- æ£€æŸ¥ï¼šSELECT COUNT(*) FROM table WHERE constraint_condition;
-- è§£å†³ï¼šä½¿ç”¨NOT VALIDå…ˆæ·»åŠ ï¼Œç„¶åå¼‚æ­¥éªŒè¯

-- 3. çº¦æŸæ€§èƒ½é—®é¢˜
-- ç—‡çŠ¶ï¼šINSERT/UPDATEå˜æ…¢
-- æ£€æŸ¥ï¼šEXPLAIN ANALYZEæŸ¥çœ‹æ‰§è¡Œè®¡åˆ’
-- è§£å†³ï¼šç®€åŒ–çº¦æŸã€æ·»åŠ ç´¢å¼•ã€æ‰¹é‡æ“ä½œæ—¶ç¦ç”¨çº¦æŸ

-- 4. å¤–é”®çº¦æŸæ€§èƒ½
-- ç—‡çŠ¶ï¼šå¤–é”®è¡¨æ’å…¥æ…¢
-- æ£€æŸ¥ï¼šSELECT indexname FROM pg_indexes WHERE tablename = 'table_name';
-- è§£å†³ï¼šç¡®ä¿å¤–é”®åˆ—æœ‰ç´¢å¼•ï¼ˆPostgreSQL 11+è‡ªåŠ¨åˆ›å»ºï¼‰

-- 5. CHECKçº¦æŸæ€§èƒ½
-- ç—‡çŠ¶ï¼šUPDATEå˜æ…¢
-- æ£€æŸ¥ï¼šSELECT pg_get_constraintdef(oid) FROM pg_constraint WHERE conname = 'constraint_name';
-- è§£å†³ï¼šç®€åŒ–å¤æ‚çº¦æŸï¼Œæ‹†åˆ†ä¸ºå¤šä¸ªç®€å•çº¦æŸ
```

**æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•**:

```sql
-- 1. çº¦æŸæ•°é‡æ£€æŸ¥
SELECT COUNT(*) AS constraint_count
FROM pg_constraint
WHERE conrelid = 'table_name'::regclass;
-- å»ºè®®ï¼šæ¯ä¸ªè¡¨ä¸è¶…è¿‡20ä¸ªçº¦æŸ

-- 2. å¤–é”®ç´¢å¼•æ£€æŸ¥
SELECT
    tc.table_name,
    kcu.column_name,
    CASE WHEN idx.indexname IS NOT NULL THEN 'æœ‰ç´¢å¼•' ELSE 'æ— ç´¢å¼•' END AS index_status
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
LEFT JOIN pg_indexes idx
    ON idx.tablename = tc.table_name
    AND idx.indexdef LIKE '%' || kcu.column_name || '%'
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_name = 'table_name';
-- å»ºè®®ï¼šæ‰€æœ‰å¤–é”®åˆ—éƒ½æœ‰ç´¢å¼•

-- 3. CHECKçº¦æŸå¤æ‚åº¦æ£€æŸ¥
SELECT
    conname,
    LENGTH(pg_get_constraintdef(oid)) AS constraint_length
FROM pg_constraint
WHERE conrelid = 'table_name'::regclass
  AND contype = 'c'
ORDER BY constraint_length DESC;
-- å»ºè®®ï¼šå¤æ‚çº¦æŸï¼ˆé•¿åº¦>200ï¼‰è€ƒè™‘æ‹†åˆ†

-- 4. çº¦æŸè¿åæ•°æ®æ£€æŸ¥
-- å¯¹äºCHECKçº¦æŸ
SELECT COUNT(*) FROM table_name WHERE NOT (constraint_condition);
-- å¯¹äºå”¯ä¸€çº¦æŸ
SELECT column_name, COUNT(*)
FROM table_name
GROUP BY column_name
HAVING COUNT(*) > 1;
-- å»ºè®®ï¼šå®šæœŸæ£€æŸ¥ï¼ŒåŠæ—¶ä¿®å¤
```

---

## 13. å¸¸è§é—®é¢˜è§£ç­” / FAQ

### Q1: ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨çº¦æŸï¼Ÿ

**A**: åº”è¯¥åœ¨ä»¥ä¸‹æƒ…å†µä½¿ç”¨çº¦æŸï¼š

- âœ… **æ•°æ®å®Œæ•´æ€§**: ç¡®ä¿æ•°æ®ç¬¦åˆä¸šåŠ¡è§„åˆ™
- âœ… **å¼•ç”¨å®Œæ•´æ€§**: ç¡®ä¿å¤–é”®å¼•ç”¨æœ‰æ•ˆ
- âœ… **å”¯ä¸€æ€§**: ç¡®ä¿å…³é”®å­—æ®µå”¯ä¸€
- âœ… **ä¸šåŠ¡è§„åˆ™**: ä½¿ç”¨CHECKçº¦æŸå®ç°ä¸šåŠ¡è§„åˆ™

**ä¸åº”è¯¥ä½¿ç”¨çº¦æŸçš„æƒ…å†µ**:

- âŒ **æ€§èƒ½å…³é”®è·¯å¾„**: å¦‚æœçº¦æŸæ£€æŸ¥ä¸¥é‡å½±å“æ€§èƒ½
- âŒ **é¢‘ç¹å˜åŒ–**: å¦‚æœä¸šåŠ¡è§„åˆ™é¢‘ç¹å˜åŒ–
- âŒ **å¤æ‚é€»è¾‘**: å¦‚æœçº¦æŸé€»è¾‘è¿‡äºå¤æ‚ï¼ˆè€ƒè™‘ä½¿ç”¨è§¦å‘å™¨ï¼‰

### Q2: CHECKçº¦æŸå’Œè§¦å‘å™¨æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A**:

| ç‰¹æ€§ | CHECKçº¦æŸ | è§¦å‘å™¨ |
|------|-----------|--------|
| æ€§èƒ½ | æ›´å¿«ï¼ˆç¼–è¯‘æ—¶ä¼˜åŒ–ï¼‰ | è¾ƒæ…¢ï¼ˆè¿è¡Œæ—¶æ‰§è¡Œï¼‰ |
| å¤æ‚åº¦ | ç®€å•æ¡ä»¶ | å¯ä»¥æ‰§è¡Œå¤æ‚é€»è¾‘ |
| é”™è¯¯å¤„ç† | è‡ªåŠ¨å›æ»š | å¯ä»¥è‡ªå®šä¹‰é”™è¯¯å¤„ç† |
| é€‚ç”¨åœºæ™¯ | æ•°æ®éªŒè¯ | å¤æ‚ä¸šåŠ¡é€»è¾‘ |

**å»ºè®®**: ä¼˜å…ˆä½¿ç”¨CHECKçº¦æŸï¼Œå¤æ‚é€»è¾‘ä½¿ç”¨è§¦å‘å™¨ã€‚

### Q3: å¦‚ä½•ä¼˜åŒ–å¤§é‡æ•°æ®çš„çº¦æŸæ£€æŸ¥ï¼Ÿ

**A**: ä¼˜åŒ–ç­–ç•¥ï¼š

1. **ä½¿ç”¨NOT VALID**: å…ˆæ·»åŠ çº¦æŸï¼Œç„¶åéªŒè¯
2. **æ‰¹é‡æ“ä½œ**: ä¸´æ—¶ç¦ç”¨çº¦æŸï¼Œæ‰¹é‡æ“ä½œåéªŒè¯
3. **éƒ¨åˆ†çº¦æŸ**: ä½¿ç”¨éƒ¨åˆ†ç´¢å¼•å®ç°éƒ¨åˆ†å”¯ä¸€çº¦æŸ
4. **å»¶è¿Ÿæ£€æŸ¥**: ä½¿ç”¨DEFERRABLEçº¦æŸ

```sql
-- ç¤ºä¾‹ï¼šå¤§è¡¨æ·»åŠ çº¦æŸ
ALTER TABLE large_table
ADD CONSTRAINT chk_value CHECK (value > 0) NOT VALID;

-- åå°éªŒè¯ï¼ˆä¸é˜»å¡ï¼‰
ALTER TABLE large_table VALIDATE CONSTRAINT chk_value;
```

### Q4: å¤–é”®çº¦æŸä¼šå½±å“æ€§èƒ½å—ï¼Ÿ

**A**: å¤–é”®çº¦æŸçš„æ€§èƒ½å½±å“ï¼š

- **INSERT/UPDATE**: éœ€è¦æ£€æŸ¥å¼•ç”¨è¡¨ï¼ˆO(log n)ï¼‰
- **DELETE**: éœ€è¦æ£€æŸ¥å­è¡¨ï¼ˆO(log n)ï¼‰
- **ä¼˜åŒ–**: ç¡®ä¿å¼•ç”¨è¡¨å’Œå­è¡¨éƒ½æœ‰ç´¢å¼•

**æ€§èƒ½æµ‹è¯•**:

```sql
-- æµ‹è¯•å¤–é”®çº¦æŸæ€§èƒ½
EXPLAIN ANALYZE
INSERT INTO orders (customer_id, amount)
SELECT random() * 1000, random() * 1000
FROM generate_series(1, 10000);
```

### Q5: å¦‚ä½•å¤„ç†çº¦æŸè¿åé”™è¯¯ï¼Ÿ

**A**: é”™è¯¯å¤„ç†ç­–ç•¥ï¼š

1. **åº”ç”¨å±‚å¤„ç†**: æ•è·å¼‚å¸¸ï¼Œæä¾›å‹å¥½é”™è¯¯ä¿¡æ¯
2. **æ•°æ®éªŒè¯**: æ’å…¥å‰éªŒè¯æ•°æ®
3. **æ‰¹é‡å¤„ç†**: ä½¿ç”¨NOT VALIDçº¦æŸï¼Œæ‰¹é‡éªŒè¯

```sql
-- ç¤ºä¾‹ï¼šæ‰¹é‡æ’å…¥æ—¶å¤„ç†çº¦æŸè¿å
BEGIN;
SAVEPOINT sp1;
INSERT INTO orders ...;
EXCEPTION
    WHEN check_violation THEN
        ROLLBACK TO sp1;
        -- å¤„ç†è¿åçº¦æŸçš„æ•°æ®
END;
```

### Q6: çº¦æŸå¯ä»¥è·¨è¡¨å—ï¼Ÿ

**A**:

- âœ… **å¤–é”®çº¦æŸ**: å¯ä»¥è·¨è¡¨
- âŒ **CHECKçº¦æŸ**: ä¸èƒ½è·¨è¡¨ï¼ˆå¯ä»¥ä½¿ç”¨è§¦å‘å™¨ï¼‰
- âŒ **å”¯ä¸€çº¦æŸ**: ä¸èƒ½è·¨è¡¨ï¼ˆå¯ä»¥ä½¿ç”¨å”¯ä¸€ç´¢å¼•ï¼‰

**è·¨è¡¨CHECKçº¦æŸæ›¿ä»£æ–¹æ¡ˆ**:

```sql
-- ä½¿ç”¨è§¦å‘å™¨å®ç°è·¨è¡¨CHECKçº¦æŸ
CREATE OR REPLACE FUNCTION check_cross_table_constraint()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM other_table
        WHERE condition_violated
    ) THEN
        RAISE EXCEPTION 'è·¨è¡¨çº¦æŸè¿å';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_constraint
BEFORE INSERT OR UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION check_cross_table_constraint();
```

### Q7: å¦‚ä½•è¿ç§»ç°æœ‰æ•°æ®å¹¶æ·»åŠ çº¦æŸï¼Ÿ

**A**: è¿ç§»æ­¥éª¤ï¼š

1. **æ¸…ç†æ•°æ®**: ä¿®å¤è¿åçº¦æŸçš„æ•°æ®
2. **æ·»åŠ NOT VALIDçº¦æŸ**: ä¸éªŒè¯ç°æœ‰æ•°æ®
3. **éªŒè¯çº¦æŸ**: éªŒè¯ç°æœ‰æ•°æ®
4. **ç›‘æ§**: ç›‘æ§çº¦æŸè¿åæƒ…å†µ

```sql
-- æ­¥éª¤1ï¼šæ¸…ç†æ•°æ®
UPDATE orders SET amount = 0.01 WHERE amount <= 0;

-- æ­¥éª¤2ï¼šæ·»åŠ NOT VALIDçº¦æŸ
ALTER TABLE orders
ADD CONSTRAINT chk_amount_positive CHECK (amount > 0) NOT VALID;

-- æ­¥éª¤3ï¼šéªŒè¯çº¦æŸ
ALTER TABLE orders VALIDATE CONSTRAINT chk_amount_positive;
```

### Q8: EXCLUDEçº¦æŸå’Œå”¯ä¸€çº¦æŸæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A**:

| ç‰¹æ€§ | EXCLUDEçº¦æŸ | å”¯ä¸€çº¦æŸ |
|------|-------------|----------|
| ç”¨é€” | é˜²æ­¢èŒƒå›´é‡å  | é˜²æ­¢å€¼é‡å¤ |
| ç´¢å¼• | éœ€è¦GISTç´¢å¼• | ä½¿ç”¨B-treeç´¢å¼• |
| é€‚ç”¨åœºæ™¯ | æ—¶é—´èŒƒå›´ã€ç©ºé—´èŒƒå›´ | ç®€å•å€¼å”¯ä¸€æ€§ |
| æ€§èƒ½ | è¾ƒæ…¢ï¼ˆGISTç´¢å¼•ï¼‰ | è¾ƒå¿«ï¼ˆB-treeç´¢å¼•ï¼‰ |

**é€‰æ‹©å»ºè®®**:

- ç®€å•å”¯ä¸€æ€§ â†’ ä½¿ç”¨å”¯ä¸€çº¦æŸ
- èŒƒå›´é‡å æ£€æŸ¥ â†’ ä½¿ç”¨EXCLUDEçº¦æŸ

---

## 14. PostgreSQL 18çº¦æŸå¢å¼º / PostgreSQL 18 Constraint Enhancements

### 14.1 çº¦æŸéªŒè¯æ€§èƒ½æ”¹è¿›

**PostgreSQL 18æ”¹è¿›**: çº¦æŸéªŒè¯æ€§èƒ½ä¼˜åŒ–

```sql
-- PostgreSQL 18æ”¹è¿›äº†çº¦æŸéªŒè¯æ€§èƒ½
ALTER TABLE orders VALIDATE CONSTRAINT chk_amount_positive;
-- éªŒè¯é€Ÿåº¦æå‡çº¦15-25%

-- æ€§èƒ½å¯¹æ¯”ï¼ˆ1000ä¸‡è¡Œæ•°æ®ï¼‰
-- PostgreSQL 17: VALIDATE CONSTRAINTæ—¶é—´ 30s
-- PostgreSQL 18: VALIDATE CONSTRAINTæ—¶é—´ 22s
```

### 14.2 æ”¹è¿›çš„çº¦æŸé”™è¯¯ä¿¡æ¯

**PostgreSQL 18æ”¹è¿›**: æ›´è¯¦ç»†çš„çº¦æŸé”™è¯¯ä¿¡æ¯

```sql
-- PostgreSQL 18æä¾›äº†æ›´è¯¦ç»†çš„çº¦æŸè¿åé”™è¯¯ä¿¡æ¯
-- åŒ…æ‹¬ï¼šçº¦æŸåç§°ã€è¡¨åã€åˆ—åã€è¿åçš„å€¼ç­‰

-- ç¤ºä¾‹é”™è¯¯ä¿¡æ¯ï¼ˆPostgreSQL 18ï¼‰
-- ERROR: duplicate key value violates unique constraint "uk_products_sku"
-- DETAIL: Key (sku)=(SKU001) already exists.
-- CONTEXT: SQL statement "INSERT INTO products (sku) VALUES ('SKU001')"
-- HINT: Consider using ON CONFLICT to handle duplicate keys.

-- ç›¸æ¯”PostgreSQL 17ï¼Œ18ç‰ˆæœ¬æä¾›äº†æ›´å¤šä¸Šä¸‹æ–‡ä¿¡æ¯
```

### 14.3 çº¦æŸæ£€æŸ¥ä¼˜åŒ–

**PostgreSQL 18æ”¹è¿›**: çº¦æŸæ£€æŸ¥æ€§èƒ½ä¼˜åŒ–

```sql
-- PostgreSQL 18æ”¹è¿›äº†çº¦æŸæ£€æŸ¥çš„æ€§èƒ½
-- ç‰¹åˆ«æ˜¯åœ¨æ‰¹é‡æ“ä½œä¸­

-- æ‰¹é‡æ’å…¥æ€§èƒ½æ”¹è¿›
INSERT INTO orders (customer_id, amount)
SELECT customer_id, random() * 1000
FROM generate_series(1, 100000) AS customer_id;
-- çº¦æŸæ£€æŸ¥å¼€é”€å‡å°‘çº¦10-15%

-- æ€§èƒ½å¯¹æ¯”ï¼ˆ10ä¸‡è¡Œæ‰¹é‡æ’å…¥ï¼‰
-- PostgreSQL 17: æ’å…¥æ—¶é—´ 1000msï¼ˆå«çº¦æŸæ£€æŸ¥ï¼‰
-- PostgreSQL 18: æ’å…¥æ—¶é—´ 850msï¼ˆå«çº¦æŸæ£€æŸ¥ï¼‰
```

**ç›¸å…³æ–‡æ¡£**: è¯¦ç»†çš„æ–°ç‰¹æ€§è¯´æ˜è¯·å‚è€ƒ [PostgreSQL18æ–°ç‰¹æ€§æ–‡æ¡£](./PostgreSQL18æ–°ç‰¹æ€§.md)

---

## 15. ç›¸å…³èµ„æº / Related Resources

### 12.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
