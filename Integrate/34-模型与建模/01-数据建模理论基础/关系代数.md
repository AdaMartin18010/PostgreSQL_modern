# 关系代数完整指南

> **创建日期**: 2025年1月
> **来源**: 数据库系统理论基础
> **状态**: 基于现有内容深化扩展

---

## 📚 概述

关系代数是关系数据库的理论基础，由E.F. Codd在1970年提出。关系代数提供了一组操作符，用于操作关系（表），是SQL语言的数学基础。

---

## 🎯 核心概念

### 关系（Relation）

**定义**: 关系是元组的集合，可以理解为一张表。

**数学表示**: R(A₁, A₂, ..., Aₙ)，其中Aᵢ是属性

**示例**:

```
学生关系 R(学号, 姓名, 年龄)
```

---

### 元组（Tuple）

**定义**: 关系中的一行数据。

**示例**:

```
(2024001, '张三', 20)
```

---

### 属性（Attribute）

**定义**: 关系的列，表示数据的特征。

**示例**:

```
学号、姓名、年龄
```

---

## 🔧 基本操作符

### 1. 选择（Selection）- σ

**定义**: 从关系中选择满足条件的元组。

**符号**: σ<sub>条件</sub>(R)

**SQL等价**: `SELECT * FROM R WHERE 条件`

**示例**:

```sql
-- 关系代数: σ<sub>年龄>18</sub>(学生)
-- SQL:
SELECT * FROM students WHERE age > 18;
```

**PostgreSQL示例**:

```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    dept_id INT
);

-- 选择年龄大于18的学生
SELECT * FROM students WHERE age > 18;
```

---

### 2. 投影（Projection）- π

**定义**: 从关系中选择指定的属性列。

**符号**: π<sub>属性列表</sub>(R)

**SQL等价**: `SELECT 属性列表 FROM R`

**示例**:

```sql
-- 关系代数: π<sub>姓名,年龄</sub>(学生)
-- SQL:
SELECT name, age FROM students;
```

**PostgreSQL示例**:

```sql
-- 投影：只选择姓名和年龄
SELECT name, age FROM students;

-- 投影：选择不重复的部门ID
SELECT DISTINCT dept_id FROM students;
```

---

### 3. 并（Union）- ∪

**定义**: 合并两个关系的所有元组，去除重复。

**符号**: R₁ ∪ R₂

**要求**: 两个关系必须有相同的属性集合（并兼容）。

**SQL等价**: `SELECT * FROM R1 UNION SELECT * FROM R2`

**示例**:

```sql
-- 关系代数: 学生₁ ∪ 学生₂
-- SQL:
SELECT * FROM students_2023
UNION
SELECT * FROM students_2024;
```

**PostgreSQL示例**:

```sql
-- 合并两个学期的学生
CREATE TABLE students_2023 (
    student_id INT,
    name VARCHAR(100),
    age INT
);

CREATE TABLE students_2024 (
    student_id INT,
    name VARCHAR(100),
    age INT
);

-- 并操作
SELECT * FROM students_2023
UNION
SELECT * FROM students_2024;
```

---

### 4. 差（Difference）- −

**定义**: 从第一个关系中去除在第二个关系中存在的元组。

**符号**: R₁ − R₂

**SQL等价**: `SELECT * FROM R1 EXCEPT SELECT * FROM R2`

**示例**:

```sql
-- 关系代数: 学生₁ − 学生₂
-- SQL:
SELECT * FROM students_2023
EXCEPT
SELECT * FROM students_2024;
```

**PostgreSQL示例**:

```sql
-- 找出2023年有但2024年没有的学生
SELECT * FROM students_2023
EXCEPT
SELECT * FROM students_2024;
```

---

### 5. 交（Intersection）- ∩

**定义**: 找出两个关系中共有的元组。

**符号**: R₁ ∩ R₂

**SQL等价**: `SELECT * FROM R1 INTERSECT SELECT * FROM R2`

**示例**:

```sql
-- 关系代数: 学生₁ ∩ 学生₂
-- SQL:
SELECT * FROM students_2023
INTERSECT
SELECT * FROM students_2024;
```

**PostgreSQL示例**:

```sql
-- 找出两个学期都有的学生
SELECT * FROM students_2023
INTERSECT
SELECT * FROM students_2024;
```

---

### 6. 笛卡尔积（Cartesian Product）- ×

**定义**: 两个关系的所有可能组合。

**符号**: R₁ × R₂

**结果**: 如果R₁有m个元组，R₂有n个元组，则结果有m×n个元组。

**SQL等价**: `SELECT * FROM R1 CROSS JOIN R2`

**示例**:

```sql
-- 关系代数: 学生 × 课程
-- SQL:
SELECT * FROM students CROSS JOIN courses;
```

**PostgreSQL示例**:

```sql
CREATE TABLE students (
    student_id INT,
    name VARCHAR(100)
);

CREATE TABLE courses (
    course_id INT,
    course_name VARCHAR(100)
);

-- 笛卡尔积：所有学生和所有课程的组合
SELECT * FROM students CROSS JOIN courses;
```

---

### 7. 重命名（Rename）- ρ

**定义**: 重命名关系或属性。

**符号**: ρ<sub>新名称</sub>(R) 或 ρ<sub>新名称(属性列表)</sub>(R)

**SQL等价**: `SELECT 属性 AS 新名称 FROM R` 或使用表别名

**示例**:

```sql
-- 关系代数: ρ<sub>S(学号,姓名)</sub>(学生)
-- SQL:
SELECT student_id AS 学号, name AS 姓名 FROM students AS S;
```

**PostgreSQL示例**:

```sql
-- 重命名关系
SELECT s.student_id, s.name
FROM students AS s;

-- 重命名属性
SELECT student_id AS 学号, name AS 姓名
FROM students;
```

---

## 🔗 连接操作

### 1. 自然连接（Natural Join）- ⋈

**定义**: 基于相同属性名的等值连接，自动去除重复属性。

**符号**: R₁ ⋈ R₂

**SQL等价**: `SELECT * FROM R1 NATURAL JOIN R2`

**示例**:

```sql
-- 关系代数: 学生 ⋈ 选课
-- SQL:
SELECT * FROM students NATURAL JOIN enrollments;
```

**PostgreSQL示例**:

```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE enrollments (
    student_id INT REFERENCES students(student_id),
    course_id INT,
    grade CHAR(2)
);

-- 自然连接（基于student_id）
SELECT * FROM students NATURAL JOIN enrollments;
```

---

### 2. θ连接（Theta Join）- ⋈<sub>θ</sub>

**定义**: 基于任意条件θ的连接。

**符号**: R₁ ⋈<sub>θ</sub> R₂

**SQL等价**: `SELECT * FROM R1 JOIN R2 ON 条件`

**示例**:

```sql
-- 关系代数: 学生 ⋈<sub>学生.年龄>教师.年龄</sub> 教师
-- SQL:
SELECT * FROM students s
JOIN teachers t ON s.age > t.age;
```

**PostgreSQL示例**:

```sql
-- θ连接：找出年龄大于教师年龄的学生
SELECT s.name AS student_name, t.name AS teacher_name
FROM students s
JOIN teachers t ON s.age > t.age;
```

---

### 3. 等值连接（Equijoin）

**定义**: θ连接的特殊情况，条件为等值比较。

**符号**: R₁ ⋈<sub>R₁.A=R₂.B</sub> R₂

**SQL等价**: `SELECT * FROM R1 JOIN R2 ON R1.A = R2.B`

**示例**:

```sql
-- 关系代数: 学生 ⋈<sub>学生.学号=选课.学号</sub> 选课
-- SQL:
SELECT * FROM students s
JOIN enrollments e ON s.student_id = e.student_id;
```

---

### 4. 外连接（Outer Join）

**左外连接（Left Outer Join）- ⟕**:

- 保留左关系的所有元组
- SQL: `LEFT JOIN` 或 `LEFT OUTER JOIN`

**右外连接（Right Outer Join）- ⟖**:

- 保留右关系的所有元组
- SQL: `RIGHT JOIN` 或 `RIGHT OUTER JOIN`

**全外连接（Full Outer Join）- ⟗**:

- 保留两个关系的所有元组
- SQL: `FULL JOIN` 或 `FULL OUTER JOIN`

**PostgreSQL示例**:

```sql
-- 左外连接：所有学生及其选课（包括未选课的学生）
SELECT s.student_id, s.name, e.course_id, e.grade
FROM students s
LEFT JOIN enrollments e ON s.student_id = e.student_id;

-- 右外连接：所有课程及其选课学生（包括未被选的课程）
SELECT s.student_id, s.name, c.course_id, c.course_name
FROM students s
RIGHT JOIN enrollments e ON s.student_id = e.student_id
RIGHT JOIN courses c ON e.course_id = c.course_id;

-- 全外连接：所有学生和所有课程
SELECT s.student_id, s.name, c.course_id, c.course_name
FROM students s
FULL OUTER JOIN enrollments e ON s.student_id = e.student_id
FULL OUTER JOIN courses c ON e.course_id = c.course_id;
```

---

## 📊 扩展操作符

### 1. 除（Division）- ÷

**定义**: 找出满足特定条件的所有元组。

**符号**: R₁ ÷ R₂

**含义**: 找出R₁中与R₂的所有元组都有关系的元组。

**示例**:

```sql
-- 找出选了所有课程的学生
-- 关系代数: 选课 ÷ 课程
-- SQL实现:
SELECT student_id
FROM enrollments e1
WHERE NOT EXISTS (
    SELECT course_id
    FROM courses c
    WHERE NOT EXISTS (
        SELECT *
        FROM enrollments e2
        WHERE e2.student_id = e1.student_id
          AND e2.course_id = c.course_id
    )
);
```

**PostgreSQL示例**:

```sql
-- 使用EXCEPT实现除法
SELECT DISTINCT student_id
FROM enrollments
WHERE NOT EXISTS (
    SELECT course_id FROM courses
    EXCEPT
    SELECT course_id
    FROM enrollments e2
    WHERE e2.student_id = enrollments.student_id
);
```

---

### 2. 赋值（Assignment）- ←

**定义**: 将关系代数表达式的结果赋值给新关系。

**符号**: 新关系 ← 表达式

**SQL等价**: `CREATE TABLE 新关系 AS SELECT ...`

**PostgreSQL示例**:

```sql
-- 关系代数: 成年学生 ← σ<sub>年龄≥18</sub>(学生)
-- SQL:
CREATE TABLE adult_students AS
SELECT * FROM students WHERE age >= 18;
```

---

## 🔄 关系代数表达式示例

### 示例1: 复杂查询

**需求**: 找出选了"数据库"课程且成绩大于80的学生姓名。

**关系代数**:

```
π<sub>姓名</sub>(σ<sub>课程名='数据库' AND 成绩>80</sub>(学生 ⋈ 选课 ⋈ 课程))
```

**SQL**:

```sql
SELECT DISTINCT s.name
FROM students s
JOIN enrollments e ON s.student_id = e.student_id
JOIN courses c ON e.course_id = c.course_id
WHERE c.course_name = '数据库'
  AND e.grade::INT > 80;
```

---

### 示例2: 聚合查询

**需求**: 统计每个学生的选课数量。

**关系代数**（需要扩展操作符）:

```
学生 ⋈<sub>COUNT</sub>(选课)
```

**SQL**:

```sql
SELECT s.student_id, s.name, COUNT(e.course_id) AS course_count
FROM students s
LEFT JOIN enrollments e ON s.student_id = e.student_id
GROUP BY s.student_id, s.name;
```

---

## 📐 关系代数的性质

### 1. 交换律

- **并**: R₁ ∪ R₂ = R₂ ∪ R₁
- **交**: R₁ ∩ R₂ = R₂ ∩ R₁
- **笛卡尔积**: R₁ × R₂ ≠ R₂ × R₁（不满足）

---

### 2. 结合律

- **并**: (R₁ ∪ R₂) ∪ R₃ = R₁ ∪ (R₂ ∪ R₃)
- **交**: (R₁ ∩ R₂) ∩ R₃ = R₁ ∩ (R₂ ∩ R₃)
- **连接**: (R₁ ⋈ R₂) ⋈ R₃ = R₁ ⋈ (R₂ ⋈ R₃)

---

### 3. 分配律

- **选择对并**: σ<sub>θ</sub>(R₁ ∪ R₂) = σ<sub>θ</sub>(R₁) ∪ σ<sub>θ</sub>(R₂)
- **选择对交**: σ<sub>θ</sub>(R₁ ∩ R₂) = σ<sub>θ</sub>(R₁) ∩ σ<sub>θ</sub>(R₂)
- **投影对并**: π<sub>A</sub>(R₁ ∪ R₂) = π<sub>A</sub>(R₁) ∪ π<sub>A</sub>(R₂)

---

## 🎯 关系代数与SQL的对应关系

| 关系代数操作 | SQL操作 |
|------------|---------|
| σ<sub>条件</sub>(R) | SELECT * FROM R WHERE 条件 |
| π<sub>A₁,A₂</sub>(R) | SELECT A₁, A₂ FROM R |
| R₁ ∪ R₂ | SELECT *FROM R1 UNION SELECT* FROM R2 |
| R₁ − R₂ | SELECT *FROM R1 EXCEPT SELECT* FROM R2 |
| R₁ ∩ R₂ | SELECT *FROM R1 INTERSECT SELECT* FROM R2 |
| R₁ × R₂ | SELECT * FROM R1 CROSS JOIN R2 |
| R₁ ⋈ R₂ | SELECT * FROM R1 NATURAL JOIN R2 |
| R₁ ⋈<sub>θ</sub> R₂ | SELECT * FROM R1 JOIN R2 ON 条件 |

---

## 📚 相关资源

- [范式理论](./范式理论.md) - 数据库规范化理论
- [ER模型](./ER模型.md) - 实体-关系模型
- [约束理论](./约束理论.md) - 数据完整性约束

---

## 🔗 参考文档

- 《数据库系统概念》- Abraham Silberschatz et al.
- 《An Introduction to Database Systems》- C.J. Date
- PostgreSQL官方文档: [Queries](https://www.postgresql.org/docs/current/queries.html)

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
