# 范式理论完整指南

> **创建日期**: 2025年1月  
> **来源**: 数据库系统理论基础  
> **状态**: 基于现有内容深化扩展  
> **文档编号**: 01-01

---

## 📑 目录

- [1. 概述](#1-概述)
- [2. 范式等级](#2-范式等级)
  - [2.1 第一范式（1NF）](#21-第一范式1nf)
  - [2.2 第二范式（2NF）](#22-第二范式2nf)
  - [2.3 第三范式（3NF）](#23-第三范式3nf)
  - [2.4 BCNF（Boyce-Codd范式）](#24-bcnfboyce-codd范式)
  - [2.5 第四范式（4NF）](#25-第四范式4nf)
  - [2.6 第五范式（5NF）](#26-第五范式5nf)
- [3. 范式选择指南](#3-范式选择指南)
  - [3.1 何时使用哪个范式？](#31-何时使用哪个范式)
  - [3.2 实践建议](#32-实践建议)
- [4. PostgreSQL特定实现](#4-postgresql特定实现)
  - [4.1 使用约束保证范式](#41-使用约束保证范式)
  - [4.2 反规范化策略](#42-反规范化策略)
- [5. 范式检查清单](#5-范式检查清单)
  - [5.1 1NF检查](#51-1nf检查)
  - [5.2 2NF检查](#52-2nf检查)
  - [5.3 3NF检查](#53-3nf检查)
  - [5.4 BCNF检查](#54-bcnf检查)
- [6. 相关资源](#6-相关资源)
- [7. 参考书目](#7-参考书目)

---

## 1. 概述

范式理论（Normalization Theory）是关系数据库设计的理论基础，通过消除数据冗余和保证数据一致性来优化数据库结构。范式从第一范式（1NF）到第五范式（5NF），以及BCNF（Boyce-Codd范式）。

---

## 2. 范式等级

### 2.1 第一范式（1NF）

**定义**: 每个属性都是原子值，不可再分。

**要求**:

- 每个列都是不可分割的基本数据项
- 同一列中不能有多个值
- 不能有重复的行

**违反1NF的示例**:

```sql
-- ❌ 错误：电话号码包含多个值
CREATE TABLE customer (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    phone_numbers VARCHAR(200)  -- 存储 "13800138000,13900139000"
);

-- ✅ 正确：拆分到单独的表
CREATE TABLE customer (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE customer_phone (
    phone_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customer(customer_id),
    phone_number VARCHAR(20) NOT NULL
);
```

**PostgreSQL实现**:

```sql
-- 使用数组类型（PostgreSQL特有，但仍需谨慎）
CREATE TABLE customer (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    phone_numbers TEXT[]  -- 数组类型，但查询复杂
);

-- 推荐：使用规范化设计
CREATE TABLE customer (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE customer_phone (
    phone_id SERIAL PRIMARY KEY,
    customer_id INT NOT NULL REFERENCES customer(customer_id),
    phone_number VARCHAR(20) NOT NULL,
    phone_type VARCHAR(20) DEFAULT 'MOBILE',
    is_primary BOOLEAN DEFAULT FALSE
);
```

---

### 2.2 第二范式（2NF）

**定义**: 在1NF基础上，非主属性完全依赖于主键（消除部分函数依赖）。

**要求**:

- 满足1NF
- 所有非主属性完全依赖于主键
- 不存在部分函数依赖

**违反2NF的示例**:

```sql
-- ❌ 错误：订单行表中，产品名称部分依赖于产品ID，而不是订单行主键
CREATE TABLE order_line (
    order_id INT,
    line_number INT,
    product_id INT,
    product_name VARCHAR(100),  -- 部分依赖：依赖于product_id
    quantity INT,
    unit_price NUMERIC(10,2),
    PRIMARY KEY (order_id, line_number)
);

-- ✅ 正确：产品信息独立成表
CREATE TABLE product (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    category VARCHAR(50)
);

CREATE TABLE order_line (
    order_id INT,
    line_number INT,
    product_id INT REFERENCES product(product_id),
    quantity INT NOT NULL CHECK (quantity > 0),
    unit_price NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
    PRIMARY KEY (order_id, line_number)
);
```

---

### 2.3 第三范式（3NF）

**定义**: 在2NF基础上，非主属性不依赖于其他非主属性（消除传递依赖）。

**要求**:

- 满足2NF
- 所有非主属性直接依赖于主键
- 不存在传递函数依赖

**违反3NF的示例**:

```sql
-- ❌ 错误：城市依赖于邮政编码，邮政编码依赖于客户ID（传递依赖）
CREATE TABLE customer (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    zip_code VARCHAR(10),
    city VARCHAR(50),      -- 传递依赖：依赖于zip_code
    state VARCHAR(50)      -- 传递依赖：依赖于zip_code
);

-- ✅ 正确：地址信息独立成表
CREATE TABLE zip_code (
    zip_code VARCHAR(10) PRIMARY KEY,
    city VARCHAR(50) NOT NULL,
    state VARCHAR(50) NOT NULL
);

CREATE TABLE customer (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    zip_code VARCHAR(10) REFERENCES zip_code(zip_code)
);
```

**PostgreSQL实现**:

```sql
-- 使用CHECK约束确保数据一致性
CREATE TABLE zip_code (
    zip_code VARCHAR(10) PRIMARY KEY,
    city VARCHAR(50) NOT NULL,
    state VARCHAR(50) NOT NULL,
    CHECK (LENGTH(zip_code) >= 5)
);

CREATE TABLE customer (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    zip_code VARCHAR(10) REFERENCES zip_code(zip_code),
    address_line1 VARCHAR(200),
    address_line2 VARCHAR(200)
);

-- 创建索引优化查询
CREATE INDEX idx_customer_zip ON customer(zip_code);
```

---

### 2.4 BCNF（Boyce-Codd范式）

**定义**: 在3NF基础上，每个决定因素都是候选键。

**要求**:

- 满足3NF
- 所有函数依赖的左边都是候选键

**BCNF示例**:

```sql
-- 场景：课程-教师-教室关系
-- 假设：每个教师在一个时间只能教一门课，每门课在一个时间只能在一个教室

-- ❌ 可能违反BCNF的设计
CREATE TABLE teaching (
    course_id INT,
    teacher_id INT,
    classroom_id INT,
    time_slot VARCHAR(20),
    PRIMARY KEY (course_id, teacher_id, time_slot)
    -- 如果存在依赖：teacher_id, time_slot -> classroom_id
    -- 且teacher_id, time_slot不是候选键，则违反BCNF
);

-- ✅ BCNF设计
CREATE TABLE course_teacher (
    course_id INT,
    teacher_id INT,
    time_slot VARCHAR(20),
    PRIMARY KEY (course_id, teacher_id, time_slot)
);

CREATE TABLE teacher_classroom (
    teacher_id INT,
    time_slot VARCHAR(20),
    classroom_id INT,
    PRIMARY KEY (teacher_id, time_slot)
);
```

---

### 2.5 第四范式（4NF）

**定义**: 在BCNF基础上，消除多值依赖。

**要求**:

- 满足BCNF
- 不存在非平凡的多值依赖

**4NF示例**:

```sql
-- 场景：员工-技能-语言关系
-- 假设：技能和语言是独立的，一个员工可以有多个技能和多种语言

-- ❌ 违反4NF：存在多值依赖
CREATE TABLE employee_skills_languages (
    employee_id INT,
    skill VARCHAR(50),
    language VARCHAR(50),
    PRIMARY KEY (employee_id, skill, language)
    -- 存在多值依赖：employee_id ->-> skill, employee_id ->-> language
);

-- ✅ 4NF设计：拆分多值依赖
CREATE TABLE employee_skill (
    employee_id INT,
    skill VARCHAR(50),
    PRIMARY KEY (employee_id, skill)
);

CREATE TABLE employee_language (
    employee_id INT,
    language VARCHAR(50),
    PRIMARY KEY (employee_id, language)
);
```

---

### 2.6 第五范式（5NF）

**定义**: 在4NF基础上，消除连接依赖。

**要求**:

- 满足4NF
- 不存在非平凡的连接依赖

**5NF示例**:

```sql
-- 场景：供应商-零件-项目关系
-- 假设：只有当供应商提供零件、零件用于项目、供应商参与项目时，三者才有关联

-- ❌ 可能存在连接依赖
CREATE TABLE supplier_part_project (
    supplier_id INT,
    part_id INT,
    project_id INT,
    PRIMARY KEY (supplier_id, part_id, project_id)
);

-- ✅ 5NF设计：分解连接依赖
CREATE TABLE supplier_part (
    supplier_id INT,
    part_id INT,
    PRIMARY KEY (supplier_id, part_id)
);

CREATE TABLE part_project (
    part_id INT,
    project_id INT,
    PRIMARY KEY (part_id, project_id)
);

CREATE TABLE supplier_project (
    supplier_id INT,
    project_id INT,
    PRIMARY KEY (supplier_id, project_id)
);
```

---

## 3. 范式选择指南

### 3.1 何时使用哪个范式？

| 范式 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| **1NF** | 所有场景（基础要求） | 数据原子性 | 可能存在冗余 |
| **2NF** | 复合主键场景 | 消除部分依赖 | 需要更多表 |
| **3NF** | **OLTP系统推荐** | 消除传递依赖，平衡性能和一致性 | 查询可能需要JOIN |
| **BCNF** | 复杂业务规则 | 更强的规范化 | 可能过度设计 |
| **4NF/5NF** | 理论研究 | 理论完美 | 实际应用少，性能差 |

### 实践建议

1. **OLTP系统**: 通常达到**3NF**即可
   - 平衡数据一致性和查询性能
   - 避免过度规范化导致的性能问题

2. **OLAP系统**: 可以使用**2NF或更低**
   - 优先考虑查询性能
   - 允许适度冗余（星型模式、雪花模式）

3. **特殊场景**: 根据业务需求灵活选择
   - 时间序列数据：可能不需要严格规范化
   - 文档数据：使用JSONB等半结构化类型

---

## 4. PostgreSQL特定实现

### 4.1 使用约束保证范式

```sql
-- 1NF：使用CHECK约束确保原子性
CREATE TABLE customer (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

-- 2NF/3NF：使用外键保证引用完整性
CREATE TABLE order_line (
    order_id INT REFERENCES orders(order_id),
    product_id INT REFERENCES products(product_id),
    quantity INT NOT NULL CHECK (quantity > 0),
    PRIMARY KEY (order_id, product_id)
);

-- 使用唯一约束保证候选键
CREATE TABLE customer_email (
    customer_id INT PRIMARY KEY REFERENCES customer(customer_id),
    email VARCHAR(255) NOT NULL UNIQUE
);
```

### 反规范化策略

在某些场景下，PostgreSQL允许适度反规范化：

```sql
-- 场景：频繁查询订单总金额，避免每次计算
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customer(customer_id),
    order_date TIMESTAMPTZ DEFAULT NOW(),
    total_amount NUMERIC(10,2),  -- 反规范化：冗余存储
    -- 使用触发器或生成列保持一致性
    CHECK (total_amount >= 0)
);

-- 使用生成列（PostgreSQL 12+）
CREATE TABLE order_line (
    line_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    quantity INT NOT NULL,
    unit_price NUMERIC(10,2) NOT NULL,
    line_amount NUMERIC(10,2) GENERATED ALWAYS AS (quantity * unit_price) STORED
);
```

---

## 5. 范式检查清单

### 5.1 1NF检查

- [ ] 每个属性都是原子值
- [ ] 没有多值属性
- [ ] 没有重复行

### 2NF检查

- [ ] 满足1NF
- [ ] 所有非主属性完全依赖于主键
- [ ] 没有部分函数依赖

### 3NF检查

- [ ] 满足2NF
- [ ] 所有非主属性直接依赖于主键
- [ ] 没有传递函数依赖

### BCNF检查

- [ ] 满足3NF
- [ ] 所有函数依赖的左边都是候选键

---

## 6. 相关资源

- [ER模型设计](../01-数据建模理论基础/ER模型.md)
- [约束理论](../01-数据建模理论基础/约束理论.md)
- [OLTP建模实践](../04-OLTP建模/范式化设计.md)
- [PostgreSQL实现](../04-OLTP建模/PostgreSQL实现.md)

---

## 7. 参考书目

1. Silberschatz, A., Korth, H. F., & Sudarshan, S. *Database System Concepts*. 7th Edition. McGraw-Hill, 2019.
2. Date, C. J. *An Introduction to Database Systems*. 8th Edition. Addison-Wesley, 2003.

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
