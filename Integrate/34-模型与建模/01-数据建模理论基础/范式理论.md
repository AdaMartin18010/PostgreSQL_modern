# 范式理论完整指南

> **创建日期**: 2025年1月
> **来源**: 数据库系统理论基础
> **状态**: 基于现有内容深化扩展
> **文档编号**: 01-01

---

## 📑 目录

- [范式理论完整指南](#范式理论完整指南)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 范式理论基本概念](#111-范式理论基本概念)
    - [1.1.2 函数依赖理论](#112-函数依赖理论)
    - [1.1.3 第一范式（1NF）理论](#113-第一范式1nf理论)
    - [1.1.4 第二范式（2NF）理论](#114-第二范式2nf理论)
    - [1.1.5 第三范式（3NF）理论](#115-第三范式3nf理论)
    - [1.1.6 BCNF理论](#116-bcnf理论)
    - [1.1.7 范式权衡理论](#117-范式权衡理论)
    - [1.1.8 复杂度分析](#118-复杂度分析)
  - [2. 范式等级](#2-范式等级)
    - [2.1 第一范式（1NF）](#21-第一范式1nf)
    - [2.2 第二范式（2NF）](#22-第二范式2nf)
    - [2.3 第三范式（3NF）](#23-第三范式3nf)
    - [2.4 BCNF（Boyce-Codd范式）](#24-bcnfboyce-codd范式)
    - [2.5 第四范式（4NF）](#25-第四范式4nf)
    - [2.6 第五范式（5NF）](#26-第五范式5nf)
  - [3. 范式选择指南](#3-范式选择指南)
    - [3.1 何时使用哪个范式？](#31-何时使用哪个范式)
    - [实践建议](#实践建议)
  - [4. PostgreSQL特定实现](#4-postgresql特定实现)
    - [4.1 使用约束保证范式](#41-使用约束保证范式)
    - [反规范化策略](#反规范化策略)
  - [5. 范式检查清单](#5-范式检查清单)
    - [5.1 1NF检查](#51-1nf检查)
    - [2NF检查](#2nf检查)
    - [3NF检查](#3nf检查)
    - [BCNF检查](#bcnf检查)
  - [6. 相关资源](#6-相关资源)
  - [7. 参考书目](#7-参考书目)

---

## 1. 概述

范式理论（Normalization Theory）是关系数据库设计的理论基础，通过消除数据冗余和保证数据一致性来优化数据库结构。
范式从第一范式（1NF）到第五范式（5NF），以及BCNF（Boyce-Codd范式）。

---

## 1.1 理论基础

### 1.1.1 范式理论基本概念

**范式（Normal Form）**:

- **定义**: 关系数据库设计的规范级别
- **目的**: 消除数据冗余，保证数据一致性
- **方法**: 通过分解表来消除冗余

**范式等级**:

- **1NF**: 第一范式
- **2NF**: 第二范式
- **3NF**: 第三范式
- **BCNF**: Boyce-Codd范式
- **4NF**: 第四范式
- **5NF**: 第五范式

### 1.1.2 函数依赖理论

**函数依赖（Functional Dependency）**:

- **定义**: $X \rightarrow Y$ 表示X决定Y
- **完全依赖**: $X \rightarrow Y$ 且X的任何真子集都不能决定Y
- **部分依赖**: $X \rightarrow Y$ 但X的某个真子集也能决定Y
- **传递依赖**: $X \rightarrow Y \rightarrow Z$ 且Y不决定X

**Armstrong公理**:

- **自反律**: $Y \subseteq X \Rightarrow X \rightarrow Y$
- **增广律**: $X \rightarrow Y \Rightarrow XZ \rightarrow YZ$
- **传递律**: $X \rightarrow Y, Y \rightarrow Z \Rightarrow X \rightarrow Z$

### 1.1.3 第一范式（1NF）理论

**1NF定义**:

- **要求**: 每个属性都是原子值，不可再分
- **数学表示**: $\forall A \in R, A$ is atomic
- **违反**: 属性包含多个值或复合值

**1NF分解**:

- **多值属性**: 分解为单独的表
- **复合属性**: 分解为多个简单属性

### 1.1.4 第二范式（2NF）理论

**2NF定义**:

- **要求**: 满足1NF，且消除部分依赖
- **数学表示**: $\forall X \rightarrow Y, X$ is not a proper subset of key
- **违反**: 非主属性部分依赖于主键

**2NF分解**:

- **识别部分依赖**: 识别非主属性对主键的部分依赖
- **分解表**: 将部分依赖的属性分离到新表

### 1.1.5 第三范式（3NF）理论

**3NF定义**:

- **要求**: 满足2NF，且消除传递依赖
- **数学表示**: $\forall X \rightarrow Y, X$ is a superkey or Y is prime
- **违反**: 非主属性传递依赖于主键

**3NF分解**:

- **识别传递依赖**: 识别非主属性的传递依赖
- **分解表**: 将传递依赖的属性分离到新表

### 1.1.6 BCNF理论

**BCNF定义**:

- **要求**: 满足3NF，且消除主属性对非主属性的部分依赖
- **数学表示**: $\forall X \rightarrow Y, X$ is a superkey
- **违反**: 主属性部分依赖于非主属性

**BCNF分解**:

- **识别违反**: 识别违反BCNF的函数依赖
- **分解表**: 分解表消除违反

### 1.1.7 范式权衡理论

**范式化优势**:

- **数据一致性**: 消除冗余，保证一致性
- **存储效率**: 减少存储空间
- **更新效率**: 更新操作更简单

**范式化劣势**:

- **查询复杂度**: 需要更多JOIN操作
- **查询性能**: 可能影响查询性能
- **设计复杂度**: 表结构更复杂

**权衡原则**:

- **OLTP系统**: 优先范式化（3NF/BCNF）
- **OLAP系统**: 允许反范式化
- **混合系统**: 根据场景选择

### 1.1.8 复杂度分析

**存储复杂度**:

- **范式化前**: $O(N \times M)$ where N is rows, M is redundant columns
- **范式化后**: $O(N + R)$ where R is reference rows

**查询复杂度**:

- **范式化前**: $O(1)$ (single table query)
- **范式化后**: $O(J)$ where J is number of JOINs

---

## 2. 范式等级

### 2.1 第一范式（1NF）

**定义**: 每个属性都是原子值，不可再分。

**要求**:

- 每个列都是不可分割的基本数据项
- 同一列中不能有多个值
- 不能有重复的行

**违反1NF的示例**:

```sql
-- ❌ 错误：电话号码包含多个值（带错误处理，反模式示例）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_multivalue') THEN
        CREATE TABLE customer_multivalue (
            customer_id INT PRIMARY KEY,
            name VARCHAR(100),
            phone_numbers VARCHAR(200)  -- 存储 "13800138000,13900139000"
        );
        RAISE NOTICE '表 customer_multivalue 创建成功（反模式示例）';
    ELSE
        RAISE NOTICE '表 customer_multivalue 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建示例表失败: %', SQLERRM;
END $$;

-- ✅ 正确：拆分到单独的表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_1nf_example') THEN
        CREATE TABLE customer_1nf_example (
            customer_id INT PRIMARY KEY,
            name VARCHAR(100)
        );
        RAISE NOTICE '表 customer_1nf_example 创建成功';
    ELSE
        RAISE NOTICE '表 customer_1nf_example 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_1nf_example 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_phone_1nf') THEN
        CREATE TABLE customer_phone_1nf (
            phone_id SERIAL PRIMARY KEY,
            customer_id INT REFERENCES customer_1nf_example(customer_id),
            phone_number VARCHAR(20) NOT NULL
        );
        RAISE NOTICE '表 customer_phone_1nf 创建成功';
    ELSE
        RAISE NOTICE '表 customer_phone_1nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '请先创建 customer_1nf_example 表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_phone_1nf 失败: %', SQLERRM;
END $$;
```

**PostgreSQL实现**:

```sql
-- 使用数组类型（PostgreSQL特有，但仍需谨慎，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_array') THEN
        CREATE TABLE customer_array (
            customer_id INT PRIMARY KEY,
            name VARCHAR(100),
            phone_numbers TEXT[]  -- 数组类型，但查询复杂
        );
        RAISE NOTICE '表 customer_array 创建成功（示例表）';
    ELSE
        RAISE NOTICE '表 customer_array 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建示例表失败: %', SQLERRM;
END $$;

-- 推荐：使用规范化设计（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer') THEN
        CREATE TABLE customer (
            customer_id INT PRIMARY KEY,
            name VARCHAR(100)
        );
        RAISE NOTICE '表 customer 创建成功';
    ELSE
        RAISE NOTICE '表 customer 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_phone') THEN
        CREATE TABLE customer_phone (
            phone_id SERIAL PRIMARY KEY,
            customer_id INT NOT NULL REFERENCES customer(customer_id),
            phone_number VARCHAR(20) NOT NULL,
            phone_type VARCHAR(20) DEFAULT 'MOBILE',
            is_primary BOOLEAN DEFAULT FALSE
        );
        RAISE NOTICE '表 customer_phone 创建成功';
    ELSE
        RAISE NOTICE '表 customer_phone 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_phone 失败: %', SQLERRM;
END $$;

---

### 2.2 第二范式（2NF）

**定义**: 在1NF基础上，非主属性完全依赖于主键（消除部分函数依赖）。

**要求**:

- 满足1NF
- 所有非主属性完全依赖于主键
- 不存在部分函数依赖

**违反2NF的示例**:

```sql
-- ❌ 错误：订单行表中，产品名称部分依赖于产品ID（反模式示例，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'order_line_bad') THEN
        CREATE TABLE order_line_bad (
            order_id INT,
            line_number INT,
            product_id INT,
            product_name VARCHAR(100),  -- 部分依赖：依赖于product_id
            quantity INT,
            unit_price NUMERIC(10,2),
            PRIMARY KEY (order_id, line_number)
        );
        RAISE NOTICE '表 order_line_bad 创建成功（反模式示例）';
    ELSE
        RAISE NOTICE '表 order_line_bad 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建示例表失败: %', SQLERRM;
END $$;

-- ✅ 正确：产品信息独立成表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'product') THEN
        CREATE TABLE product (
            product_id INT PRIMARY KEY,
            product_name VARCHAR(100) NOT NULL,
            category VARCHAR(50)
        );
        RAISE NOTICE '表 product 创建成功';
    ELSE
        RAISE NOTICE '表 product 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 product 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'order_line') THEN
        CREATE TABLE order_line (
            order_id INT,
            line_number INT,
            product_id INT REFERENCES product(product_id),
            quantity INT NOT NULL CHECK (quantity > 0),
            unit_price NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
            PRIMARY KEY (order_id, line_number)
        );
        RAISE NOTICE '表 order_line 创建成功';
    ELSE
        RAISE NOTICE '表 order_line 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 order_line 失败: %', SQLERRM;
END $$;

---

### 2.3 第三范式（3NF）

**定义**: 在2NF基础上，非主属性不依赖于其他非主属性（消除传递依赖）。

**要求**:

- 满足2NF
- 所有非主属性直接依赖于主键
- 不存在传递函数依赖

**违反3NF的示例**:

```sql
-- ❌ 错误：城市依赖于邮政编码，邮政编码依赖于客户ID（传递依赖，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_transitive_dep') THEN
        CREATE TABLE customer_transitive_dep (
            customer_id INT PRIMARY KEY,
            name VARCHAR(100),
            zip_code VARCHAR(10),
            city VARCHAR(50),      -- 传递依赖：依赖于zip_code
            state VARCHAR(50)      -- 传递依赖：依赖于zip_code
        );
        RAISE NOTICE '表 customer_transitive_dep 创建成功（反模式示例）';
    ELSE
        RAISE NOTICE '表 customer_transitive_dep 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建示例表失败: %', SQLERRM;
END $$;

-- ✅ 正确：地址信息独立成表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'zip_code_3nf') THEN
        CREATE TABLE zip_code_3nf (
            zip_code VARCHAR(10) PRIMARY KEY,
            city VARCHAR(50) NOT NULL,
            state VARCHAR(50) NOT NULL
        );
        RAISE NOTICE '表 zip_code_3nf 创建成功';
    ELSE
        RAISE NOTICE '表 zip_code_3nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 zip_code_3nf 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_3nf') THEN
        CREATE TABLE customer_3nf (
            customer_id INT PRIMARY KEY,
            name VARCHAR(100),
            zip_code VARCHAR(10) REFERENCES zip_code_3nf(zip_code)
        );
        RAISE NOTICE '表 customer_3nf 创建成功';
    ELSE
        RAISE NOTICE '表 customer_3nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '请先创建 zip_code_3nf 表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_3nf 失败: %', SQLERRM;
END $$;
```

**PostgreSQL实现**:

```sql
-- 使用CHECK约束确保数据一致性（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'zip_code_with_check') THEN
        CREATE TABLE zip_code_with_check (
            zip_code VARCHAR(10) PRIMARY KEY,
            city VARCHAR(50) NOT NULL,
            state VARCHAR(50) NOT NULL,
            CHECK (LENGTH(zip_code) >= 5)
        );
        RAISE NOTICE '表 zip_code_with_check 创建成功';
    ELSE
        RAISE NOTICE '表 zip_code_with_check 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 zip_code_with_check 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_with_check') THEN
        CREATE TABLE customer_with_check (
            customer_id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            zip_code VARCHAR(10) REFERENCES zip_code_with_check(zip_code),
            address_line1 VARCHAR(200),
            address_line2 VARCHAR(200)
        );
        RAISE NOTICE '表 customer_with_check 创建成功';
    ELSE
        RAISE NOTICE '表 customer_with_check 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '请先创建 zip_code_with_check 表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_with_check 失败: %', SQLERRM;
END $$;

-- 创建索引优化查询
CREATE INDEX idx_customer_zip ON customer(zip_code);
```

---

### 2.4 BCNF（Boyce-Codd范式）

**定义**: 在3NF基础上，每个决定因素都是候选键。

**要求**:

- 满足3NF
- 所有函数依赖的左边都是候选键

**BCNF示例**:

```sql
-- 场景：课程-教师-教室关系
-- 假设：每个教师在一个时间只能教一门课，每门课在一个时间只能在一个教室

-- ❌ 可能违反BCNF的设计
-- 违反BCNF示例（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'teaching_violates_bcnf') THEN
        CREATE TABLE teaching_violates_bcnf (
            course_id INT,
            teacher_id INT,
            classroom_id INT,
            time_slot VARCHAR(20),
            PRIMARY KEY (course_id, teacher_id, time_slot)
            -- 如果存在依赖：teacher_id, time_slot -> classroom_id
            -- 且teacher_id, time_slot不是候选键，则违反BCNF
        );
        RAISE NOTICE '表 teaching_violates_bcnf 创建成功（反模式示例）';
    ELSE
        RAISE NOTICE '表 teaching_violates_bcnf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建示例表失败: %', SQLERRM;
END $$;

-- ✅ BCNF设计（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'course_teacher_bcnf') THEN
        CREATE TABLE course_teacher_bcnf (
            course_id INT,
            teacher_id INT,
            time_slot VARCHAR(20),
            PRIMARY KEY (course_id, teacher_id, time_slot)
        );
        RAISE NOTICE '表 course_teacher_bcnf 创建成功';
    ELSE
        RAISE NOTICE '表 course_teacher_bcnf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 course_teacher_bcnf 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'teacher_classroom_bcnf') THEN
        CREATE TABLE teacher_classroom_bcnf (
            teacher_id INT,
            time_slot VARCHAR(20),
            classroom_id INT,
            PRIMARY KEY (teacher_id, time_slot)
        );
        RAISE NOTICE '表 teacher_classroom_bcnf 创建成功';
    ELSE
        RAISE NOTICE '表 teacher_classroom_bcnf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 teacher_classroom_bcnf 失败: %', SQLERRM;
END $$;
```

---

### 2.5 第四范式（4NF）

**定义**: 在BCNF基础上，消除多值依赖。

**要求**:

- 满足BCNF
- 不存在非平凡的多值依赖

**4NF示例**:

```sql
-- 场景：员工-技能-语言关系
-- 假设：技能和语言是独立的，一个员工可以有多个技能和多种语言

-- ❌ 违反4NF：存在多值依赖（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'employee_skills_languages_4nf') THEN
        CREATE TABLE employee_skills_languages_4nf (
            employee_id INT,
            skill VARCHAR(50),
            language VARCHAR(50),
            PRIMARY KEY (employee_id, skill, language)
            -- 存在多值依赖：employee_id ->-> skill, employee_id ->-> language
        );
        RAISE NOTICE '表 employee_skills_languages_4nf 创建成功（反模式示例）';
    ELSE
        RAISE NOTICE '表 employee_skills_languages_4nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建示例表失败: %', SQLERRM;
END $$;

-- ✅ 4NF设计：拆分多值依赖（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'employee_skill_4nf') THEN
        CREATE TABLE employee_skill_4nf (
            employee_id INT,
            skill VARCHAR(50),
            PRIMARY KEY (employee_id, skill)
        );
        RAISE NOTICE '表 employee_skill_4nf 创建成功';
    ELSE
        RAISE NOTICE '表 employee_skill_4nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 employee_skill_4nf 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'employee_language_4nf') THEN
        CREATE TABLE employee_language_4nf (
            employee_id INT,
            language VARCHAR(50),
            PRIMARY KEY (employee_id, language)
        );
        RAISE NOTICE '表 employee_language_4nf 创建成功';
    ELSE
        RAISE NOTICE '表 employee_language_4nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 employee_language_4nf 失败: %', SQLERRM;
END $$;
```

---

### 2.6 第五范式（5NF）

**定义**: 在4NF基础上，消除连接依赖。

**要求**:

- 满足4NF
- 不存在非平凡的连接依赖

**5NF示例**:

```sql
-- 场景：供应商-零件-项目关系
-- 假设：只有当供应商提供零件、零件用于项目、供应商参与项目时，三者才有关联

-- ❌ 可能存在连接依赖（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'supplier_part_project_5nf') THEN
        CREATE TABLE supplier_part_project_5nf (
            supplier_id INT,
            part_id INT,
            project_id INT,
            PRIMARY KEY (supplier_id, part_id, project_id)
        );
        RAISE NOTICE '表 supplier_part_project_5nf 创建成功（反模式示例）';
    ELSE
        RAISE NOTICE '表 supplier_part_project_5nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建示例表失败: %', SQLERRM;
END $$;

-- ✅ 5NF设计：分解连接依赖（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'supplier_part_5nf') THEN
        CREATE TABLE supplier_part_5nf (
            supplier_id INT,
            part_id INT,
            PRIMARY KEY (supplier_id, part_id)
        );
        RAISE NOTICE '表 supplier_part_5nf 创建成功';
    ELSE
        RAISE NOTICE '表 supplier_part_5nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 supplier_part_5nf 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'part_project_5nf') THEN
        CREATE TABLE part_project_5nf (
            part_id INT,
            project_id INT,
            PRIMARY KEY (part_id, project_id)
        );
        RAISE NOTICE '表 part_project_5nf 创建成功';
    ELSE
        RAISE NOTICE '表 part_project_5nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 part_project_5nf 失败: %', SQLERRM;
END $$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'supplier_project_5nf') THEN
        CREATE TABLE supplier_project_5nf (
            supplier_id INT,
            project_id INT,
            PRIMARY KEY (supplier_id, project_id)
        );
        RAISE NOTICE '表 supplier_project_5nf 创建成功';
    ELSE
        RAISE NOTICE '表 supplier_project_5nf 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 supplier_project_5nf 失败: %', SQLERRM;
END $$;
```

---

## 3. 范式选择指南

### 3.1 何时使用哪个范式？

| 范式 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| **1NF** | 所有场景（基础要求） | 数据原子性 | 可能存在冗余 |
| **2NF** | 复合主键场景 | 消除部分依赖 | 需要更多表 |
| **3NF** | **OLTP系统推荐** | 消除传递依赖，平衡性能和一致性 | 查询可能需要JOIN |
| **BCNF** | 复杂业务规则 | 更强的规范化 | 可能过度设计 |
| **4NF/5NF** | 理论研究 | 理论完美 | 实际应用少，性能差 |

### 实践建议

1. **OLTP系统**: 通常达到**3NF**即可
   - 平衡数据一致性和查询性能
   - 避免过度规范化导致的性能问题

2. **OLAP系统**: 可以使用**2NF或更低**
   - 优先考虑查询性能
   - 允许适度冗余（星型模式、雪花模式）

3. **特殊场景**: 根据业务需求灵活选择
   - 时间序列数据：可能不需要严格规范化
   - 文档数据：使用JSONB等半结构化类型

---

## 4. PostgreSQL特定实现

### 4.1 使用约束保证范式

```sql
-- 1NF：使用CHECK约束确保原子性（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_constraint') THEN
        CREATE TABLE customer_constraint (
            customer_id SERIAL PRIMARY KEY,
            name VARCHAR(100) NOT NULL,
            email VARCHAR(255) NOT NULL,
            CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
        );
        RAISE NOTICE '表 customer_constraint 创建成功';
    ELSE
        RAISE NOTICE '表 customer_constraint 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_constraint 失败: %', SQLERRM;
END $$;

-- 2NF/3NF：使用外键保证引用完整性（带错误处理，需要先创建orders和products表）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'order_line_normalized') THEN
        CREATE TABLE order_line_normalized (
            order_id INT REFERENCES orders(order_id),
            product_id INT REFERENCES products(product_id),
            quantity INT NOT NULL CHECK (quantity > 0),
            PRIMARY KEY (order_id, product_id)
        );
        RAISE NOTICE '表 order_line_normalized 创建成功';
    ELSE
        RAISE NOTICE '表 order_line_normalized 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '请先创建 orders 和 products 表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 order_line_normalized 失败: %', SQLERRM;
END $$;

-- 使用唯一约束保证候选键（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'customer_email_constraint') THEN
        CREATE TABLE customer_email_constraint (
            customer_id INT PRIMARY KEY REFERENCES customer_constraint(customer_id),
            email VARCHAR(255) NOT NULL UNIQUE
        );
        RAISE NOTICE '表 customer_email_constraint 创建成功';
    ELSE
        RAISE NOTICE '表 customer_email_constraint 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '请先创建 customer_constraint 表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_email_constraint 失败: %', SQLERRM;
END $$;
```

### 反规范化策略

在某些场景下，PostgreSQL允许适度反规范化：

```sql
-- 场景：频繁查询订单总金额，避免每次计算
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customer(customer_id),
    order_date TIMESTAMPTZ DEFAULT NOW(),
    total_amount NUMERIC(10,2),  -- 反规范化：冗余存储
    -- 使用触发器或生成列保持一致性
    CHECK (total_amount >= 0)
);

-- 使用生成列（PostgreSQL 12+）
CREATE TABLE order_line (
    line_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id),
    quantity INT NOT NULL,
    unit_price NUMERIC(10,2) NOT NULL,
    line_amount NUMERIC(10,2) GENERATED ALWAYS AS (quantity * unit_price) STORED
);
```

---

## 5. 范式检查清单

### 5.1 1NF检查

- [ ] 每个属性都是原子值
- [ ] 没有多值属性
- [ ] 没有重复行

### 2NF检查

- [ ] 满足1NF
- [ ] 所有非主属性完全依赖于主键
- [ ] 没有部分函数依赖

### 3NF检查

- [ ] 满足2NF
- [ ] 所有非主属性直接依赖于主键
- [ ] 没有传递函数依赖

### BCNF检查

- [ ] 满足3NF
- [ ] 所有函数依赖的左边都是候选键

---

## 6. 相关资源

- [ER模型设计](../01-数据建模理论基础/ER模型.md)
- [约束理论](../01-数据建模理论基础/约束理论.md)
- [OLTP建模实践](../04-OLTP建模/范式化设计.md)
- [PostgreSQL实现](../04-OLTP建模/PostgreSQL实现.md)

---

## 7. 参考书目

1. Silberschatz, A., Korth, H. F., & Sudarshan, S. *Database System Concepts*. 7th Edition. McGraw-Hill, 2019.
2. Date, C. J. *An Introduction to Database Systems*. 8th Edition. Addison-Wesley, 2003.

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
