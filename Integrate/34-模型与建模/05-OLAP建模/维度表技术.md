# OLAPç»´åº¦è¡¨æŠ€æœ¯å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: Kimballã€Šæ•°æ®ä»“åº“å·¥å…·ç®±ã€‹+ æƒå¨èµ„æºå¯¹é½
> **çŠ¶æ€**: åŸºäºæƒå¨èµ„æºæ·±åŒ–æ‰©å±•
> **æ–‡æ¡£ç¼–å·**: 05-03

---

## ğŸ“‘ ç›®å½•

- [OLAPç»´åº¦è¡¨æŠ€æœ¯å®Œæ•´æŒ‡å—](#olapç»´åº¦è¡¨æŠ€æœ¯å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [1.1 ç†è®ºåŸºç¡€](#11-ç†è®ºåŸºç¡€)
    - [1.1.1 ç»´åº¦è¡¨åŸºæœ¬æ¦‚å¿µ](#111-ç»´åº¦è¡¨åŸºæœ¬æ¦‚å¿µ)
    - [1.1.2 ç¼“æ…¢å˜åŒ–ç»´ç†è®º](#112-ç¼“æ…¢å˜åŒ–ç»´ç†è®º)
    - [1.1.3 SCD Type 2ç†è®º](#113-scd-type-2ç†è®º)
    - [1.1.4 è§’è‰²æ‰®æ¼”ç»´åº¦ç†è®º](#114-è§’è‰²æ‰®æ¼”ç»´åº¦ç†è®º)
    - [1.1.5 æ‚é¡¹ç»´åº¦ç†è®º](#115-æ‚é¡¹ç»´åº¦ç†è®º)
    - [1.1.6 ä¸€è‡´æ€§ç»´åº¦ç†è®º](#116-ä¸€è‡´æ€§ç»´åº¦ç†è®º)
    - [1.1.7 å¤æ‚åº¦åˆ†æ](#117-å¤æ‚åº¦åˆ†æ)
  - [2. ç¼“æ…¢å˜åŒ–ç»´åº¦ï¼ˆSCDï¼‰](#2-ç¼“æ…¢å˜åŒ–ç»´åº¦scd)
    - [2.1 SCD Type 1: è¦†ç›–å†å²å€¼](#21-scd-type-1-è¦†ç›–å†å²å€¼)
    - [2.2 SCD Type 2: ä¿ç•™å®Œæ•´å†å²](#22-scd-type-2-ä¿ç•™å®Œæ•´å†å²)
    - [2.3 SCD Type 3: ä¿ç•™æœ‰é™å†å²](#23-scd-type-3-ä¿ç•™æœ‰é™å†å²)
    - [2.4 SCD Type 4: å¿«ç…§è¡¨](#24-scd-type-4-å¿«ç…§è¡¨)
    - [2.5 SCD Type 6: æ··åˆæ–¹æ³•](#25-scd-type-6-æ··åˆæ–¹æ³•)
  - [3. è§’è‰²æ‰®æ¼”ç»´åº¦](#3-è§’è‰²æ‰®æ¼”ç»´åº¦)
  - [4. æ‚é¡¹ç»´åº¦](#4-æ‚é¡¹ç»´åº¦)
  - [5. é€€åŒ–ç»´åº¦](#5-é€€åŒ–ç»´åº¦)
  - [6. ä¸€è‡´æ€§ç»´åº¦](#6-ä¸€è‡´æ€§ç»´åº¦)
  - [7. PostgreSQLå®ç°](#7-postgresqlå®ç°)
    - [7.1 SCD Type 2è‡ªåŠ¨å¤„ç†](#71-scd-type-2è‡ªåŠ¨å¤„ç†)
    - [7.2 ç»´åº¦è¡¨ç´¢å¼•ç­–ç•¥](#72-ç»´åº¦è¡¨ç´¢å¼•ç­–ç•¥)
  - [8. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Examples](#8-å®é™…åº”ç”¨æ¡ˆä¾‹--practical-application-examples)
    - [8.1 æ¡ˆä¾‹1: SCD Type 2äº§å“ç»´åº¦](#81-æ¡ˆä¾‹1-scd-type-2äº§å“ç»´åº¦)
    - [8.2 æ¡ˆä¾‹2: è§’è‰²æ‰®æ¼”ç»´åº¦åº”ç”¨](#82-æ¡ˆä¾‹2-è§’è‰²æ‰®æ¼”ç»´åº¦åº”ç”¨)
    - [8.3 æ¡ˆä¾‹3: æ‚é¡¹ç»´åº¦åº”ç”¨](#83-æ¡ˆä¾‹3-æ‚é¡¹ç»´åº¦åº”ç”¨)
  - [9. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§ / Performance Optimization and Monitoring](#9-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§--performance-optimization-and-monitoring)
    - [9.1 ç»´åº¦è¡¨æ€§èƒ½ä¼˜åŒ–](#91-ç»´åº¦è¡¨æ€§èƒ½ä¼˜åŒ–)
    - [9.2 SCDæ€§èƒ½ç›‘æ§](#92-scdæ€§èƒ½ç›‘æ§)
  - [10. å¸¸è§é—®é¢˜è§£ç­” / FAQ](#10-å¸¸è§é—®é¢˜è§£ç­”--faq)
    - [Q1: SCD Type 1ã€2ã€3å¦‚ä½•é€‰æ‹©ï¼Ÿ](#q1-scd-type-123å¦‚ä½•é€‰æ‹©)
    - [Q2: SCD Type 2ä¼šå¯¼è‡´ç»´åº¦è¡¨å¾ˆå¤§å—ï¼Ÿ](#q2-scd-type-2ä¼šå¯¼è‡´ç»´åº¦è¡¨å¾ˆå¤§å—)
    - [Q3: è§’è‰²æ‰®æ¼”ç»´åº¦å¦‚ä½•ä¼˜åŒ–ï¼Ÿ](#q3-è§’è‰²æ‰®æ¼”ç»´åº¦å¦‚ä½•ä¼˜åŒ–)
    - [Q4: æ‚é¡¹ç»´åº¦ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ï¼Ÿ](#q4-æ‚é¡¹ç»´åº¦ä»€ä¹ˆæ—¶å€™ä½¿ç”¨)
    - [Q5: å¦‚ä½•ä¼˜åŒ–ç»´åº¦è¡¨æŸ¥è¯¢æ€§èƒ½ï¼Ÿ](#q5-å¦‚ä½•ä¼˜åŒ–ç»´åº¦è¡¨æŸ¥è¯¢æ€§èƒ½)
  - [11. ç›¸å…³èµ„æº / Related Resources](#11-ç›¸å…³èµ„æº--related-resources)
    - [11.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents](#111-æ ¸å¿ƒç›¸å…³æ–‡æ¡£--core-related-documents)
    - [11.2 ç†è®ºåŸºç¡€ / Theoretical Foundation](#112-ç†è®ºåŸºç¡€--theoretical-foundation)
    - [11.3 å®è·µæŒ‡å— / Practical Guides](#113-å®è·µæŒ‡å—--practical-guides)
    - [11.4 åº”ç”¨æ¡ˆä¾‹ / Application Cases](#114-åº”ç”¨æ¡ˆä¾‹--application-cases)
    - [11.5 å‚è€ƒèµ„æº / Reference Resources](#115-å‚è€ƒèµ„æº--reference-resources)

---

## 1. æ¦‚è¿°

ç»´åº¦è¡¨æ˜¯ç»´åº¦å»ºæ¨¡çš„æ ¸å¿ƒç»„ä»¶ï¼Œæè¿°ä¸šåŠ¡è¿‡ç¨‹çš„ä¸Šä¸‹æ–‡ã€‚
Kimballå®šä¹‰äº†å¤šç§ç»´åº¦è¡¨æŠ€æœ¯ï¼ŒåŒ…æ‹¬ç¼“æ…¢å˜åŒ–ç»´åº¦ï¼ˆSCDï¼‰ã€è§’è‰²æ‰®æ¼”ç»´åº¦ã€æ‚é¡¹ç»´åº¦ç­‰ã€‚
æ­£ç¡®ä½¿ç”¨è¿™äº›æŠ€æœ¯å¯¹æ•°æ®ä»“åº“è®¾è®¡è‡³å…³é‡è¦ã€‚

---

## 1.1 ç†è®ºåŸºç¡€

### 1.1.1 ç»´åº¦è¡¨åŸºæœ¬æ¦‚å¿µ

**ç»´åº¦è¡¨ï¼ˆDimension Tableï¼‰**æè¿°ä¸šåŠ¡è¿‡ç¨‹çš„ä¸Šä¸‹æ–‡ï¼š

- **ç»´åº¦å±æ€§**: æä¾›æŸ¥è¯¢å’Œè¿‡æ»¤æ¡ä»¶
- **ç»´åº¦é”®**: ä¸»é”®ï¼Œè¢«äº‹å®è¡¨å¼•ç”¨
- **ä¸šåŠ¡é”®**: ä¸šåŠ¡ç³»ç»Ÿä¸­çš„å”¯ä¸€æ ‡è¯†

**ç»´åº¦è¡¨ç‰¹å¾**:

- **è¡Œæ•°å°‘**: é€šå¸¸æ•°åƒåˆ°æ•°ç™¾ä¸‡è¡Œ
- **åˆ—æ•°å¤š**: é€šå¸¸20-100åˆ—
- **å¯æ›´æ–°**: ç»´åº¦å±æ€§å¯ä»¥æ›´æ–°

### 1.1.2 ç¼“æ…¢å˜åŒ–ç»´ç†è®º

**ç¼“æ…¢å˜åŒ–ç»´ï¼ˆSlowly Changing Dimension, SCDï¼‰**:

- **é—®é¢˜**: ç»´åº¦å±æ€§ä¼šç¼“æ…¢å˜åŒ–
- **æŒ‘æˆ˜**: å¦‚ä½•ä¿ç•™å†å²å€¼
- **è§£å†³æ–¹æ¡ˆ**: SCD Type 1/2/3/4/6

**SCDç±»å‹å¯¹æ¯”**:

| ç±»å‹ | å†å²ä¿ç•™ | å­˜å‚¨æˆæœ¬ | æŸ¥è¯¢å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|---------|---------|-----------|---------|
| **Type 1** | ä¸ä¿ç•™ | ä½ | ä½ | é”™è¯¯æ›´æ­£ |
| **Type 2** | å®Œæ•´ä¿ç•™ | é«˜ | ä¸­ | å†å²åˆ†æ |
| **Type 3** | éƒ¨åˆ†ä¿ç•™ | ä¸­ | ä¸­ | æœ‰é™å†å² |
| **Type 4** | å¿«ç…§ä¿ç•™ | é«˜ | é«˜ | å®Œæ•´å†å² |
| **Type 6** | æ··åˆä¿ç•™ | é«˜ | é«˜ | å¤æ‚åœºæ™¯ |

### 1.1.3 SCD Type 2ç†è®º

**SCD Type 2**ä¿ç•™å®Œæ•´å†å²ï¼š

- **æ–¹æ³•**: æ·»åŠ æ–°è¡Œä¿ç•™å†å²å€¼
- **æ ‡è¯†**: ä½¿ç”¨ä»£ç†é”®ï¼ˆSurrogate Keyï¼‰
- **æ—¶é—´æˆ³**: ä½¿ç”¨æœ‰æ•ˆæ—¥æœŸæ ‡è¯†ç‰ˆæœ¬

**æ•°å­¦è¡¨ç¤º**:

- **ç»´åº¦ç‰ˆæœ¬**: $D_v = \{d_1, d_2, ..., d_n\}$
- **æœ‰æ•ˆæ—¶é—´**: $T_{valid} = [T_{from}, T_{to})$
- **å½“å‰ç‰ˆæœ¬**: $D_{current} = \{d | T_{to} = NULL\}$

### 1.1.4 è§’è‰²æ‰®æ¼”ç»´åº¦ç†è®º

**è§’è‰²æ‰®æ¼”ç»´åº¦ï¼ˆRole-Playing Dimensionï¼‰**:

- **å®šä¹‰**: åŒä¸€ç»´åº¦è¡¨åœ¨äº‹å®è¡¨ä¸­æ‰®æ¼”å¤šä¸ªè§’è‰²
- **ç¤ºä¾‹**: æ—¥æœŸç»´åº¦å¯ä»¥æ‰®æ¼”è®¢å•æ—¥æœŸã€å‘è´§æ—¥æœŸã€äº¤ä»˜æ—¥æœŸ
- **å®ç°**: åœ¨äº‹å®è¡¨ä¸­ä½¿ç”¨å¤šä¸ªå¤–é”®å¼•ç”¨åŒä¸€ç»´åº¦è¡¨

**è§’è‰²æ‰®æ¼”ç»´åº¦ä¼˜åŒ–**:

- **è§†å›¾**: ä¸ºæ¯ä¸ªè§’è‰²åˆ›å»ºè§†å›¾
- **åˆ«å**: ä½¿ç”¨è¡¨åˆ«ååŒºåˆ†è§’è‰²
- **æ€§èƒ½**: ä¸å½±å“æŸ¥è¯¢æ€§èƒ½

### 1.1.5 æ‚é¡¹ç»´åº¦ç†è®º

**æ‚é¡¹ç»´åº¦ï¼ˆJunk Dimensionï¼‰**:

- **å®šä¹‰**: å°†å¤šä¸ªä½åŸºæ•°çš„æ ‡å¿—ä½ç»„åˆæˆä¸€ä¸ªç»´åº¦
- **ç›®çš„**: å‡å°‘äº‹å®è¡¨çš„åˆ—æ•°
- **ç¤ºä¾‹**: å°†å¤šä¸ªå¸ƒå°”æ ‡å¿—ç»„åˆæˆä¸€ä¸ªç»´åº¦

**æ‚é¡¹ç»´åº¦è®¾è®¡**:

- **ç»„åˆ**: $D_{junk} = \{f_1, f_2, ..., f_n\}$ where $f_i$ is flag
- **åŸºæ•°**: $|D_{junk}| = \prod_{i=1}^{n} |f_i|$
- **ä¼˜åŒ–**: åªåŒ…å«å®é™…å­˜åœ¨çš„ç»„åˆ

### 1.1.6 ä¸€è‡´æ€§ç»´åº¦ç†è®º

**ä¸€è‡´æ€§ç»´åº¦ï¼ˆConformed Dimensionï¼‰**:

- **å®šä¹‰**: åœ¨å¤šä¸ªæ•°æ®ä»“åº“ä¸­å…±äº«çš„ç»´åº¦
- **ç›®çš„**: æ”¯æŒè·¨æ•°æ®ä»“åº“åˆ†æ
- **è¦æ±‚**: ç»´åº¦å®šä¹‰å’Œå±æ€§ä¸€è‡´

**ä¸€è‡´æ€§ç»´åº¦åŸåˆ™**:

- **å®šä¹‰ä¸€è‡´**: ç»´åº¦å®šä¹‰å¿…é¡»ä¸€è‡´
- **å±æ€§ä¸€è‡´**: ç»´åº¦å±æ€§å¿…é¡»ä¸€è‡´
- **é”®ä¸€è‡´**: ç»´åº¦é”®å¿…é¡»ä¸€è‡´

### 1.1.7 å¤æ‚åº¦åˆ†æ

**å­˜å‚¨å¤æ‚åº¦**:

- **ç»´åº¦è¡¨**: $O(D)$ where D is number of dimension rows
- **SCD Type 2**: $O(D \times V)$ where V is average versions per dimension
- **æ‚é¡¹ç»´åº¦**: $O(C)$ where C is number of combinations

**æŸ¥è¯¢å¤æ‚åº¦**:

- **ç»´åº¦æŸ¥è¯¢**: $O(\log D)$ with index
- **SCD Type 2æŸ¥è¯¢**: $O(\log D \times V)$ with index
- **è§’è‰²æ‰®æ¼”æŸ¥è¯¢**: $O(\log D)$ with index

---

## 2. ç¼“æ…¢å˜åŒ–ç»´åº¦ï¼ˆSCDï¼‰

### 2.1 SCD Type 1: è¦†ç›–å†å²å€¼

**å®šä¹‰**: ç›´æ¥æ›´æ–°ç»´åº¦è®°å½•ï¼Œä¸ä¿ç•™å†å²å€¼ã€‚

**ç‰¹ç‚¹**:

- ç®€å•ç›´æ¥
- ä¸ä¿ç•™å†å²
- é€‚åˆä¸é‡è¦çš„å±æ€§å˜æ›´

**é€‚ç”¨åœºæ™¯**:

- å®¢æˆ·åœ°å€æ›´æ­£
- äº§å“æè¿°æ›´æ–°
- ä¸é‡è¦çš„å±æ€§å˜æ›´

**PostgreSQLå®ç°**:

```sql
-- SCD Type 1ï¼šå®¢æˆ·ç»´åº¦è¡¨
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    customer_id INT NOT NULL UNIQUE,  -- ä¸šåŠ¡é”®
    customer_name VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    phone VARCHAR(20),
    city VARCHAR(50),
    state VARCHAR(50),
    country VARCHAR(50) DEFAULT 'China',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ›´æ–°å®¢æˆ·ä¿¡æ¯ï¼ˆç›´æ¥è¦†ç›–ï¼‰
UPDATE dim_customer
SET
    email = 'newemail@example.com',
    phone = '13800138000',
    updated_at = NOW()
WHERE customer_id = 123;
```

---

### 2.2 SCD Type 2: ä¿ç•™å®Œæ•´å†å²

**å®šä¹‰**: ä¸ºæ¯ä¸ªå˜åŒ–åˆ›å»ºæ–°è®°å½•ï¼Œä¿ç•™å®Œæ•´å†å²ã€‚

**ç‰¹ç‚¹**:

- ä¿ç•™å®Œæ•´å†å²
- æ”¯æŒå†å²åˆ†æ
- éœ€è¦æœ‰æ•ˆæ—¥æœŸå­—æ®µ

**é€‚ç”¨åœºæ™¯**:

- å®¢æˆ·åœ°å€å˜æ›´
- äº§å“åˆ†ç±»å˜æ›´
- å‘˜å·¥éƒ¨é—¨å˜æ›´

**PostgreSQLå®ç°**:

```sql
-- SCD Type 2ï¼šå®¢æˆ·ç»´åº¦è¡¨ï¼ˆä¿ç•™å†å²ï¼‰
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,  -- ä¸šåŠ¡é”®ï¼ˆä¸å”¯ä¸€ï¼‰
    customer_name VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    phone VARCHAR(20),
    city VARCHAR(50),
    state VARCHAR(50),
    -- SCD Type 2å­—æ®µ
    valid_from DATE NOT NULL,
    valid_to DATE,
    is_current BOOLEAN DEFAULT TRUE,
    version_number INT DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (valid_to IS NULL OR valid_to >= valid_from)
);

-- åˆ›å»ºå”¯ä¸€ç´¢å¼•ï¼ˆä¸šåŠ¡é”® + æœ‰æ•ˆæ—¥æœŸï¼‰
CREATE UNIQUE INDEX idx_dim_customer_business_key
ON dim_customer(customer_id, valid_from);

-- æ’å…¥æ–°å®¢æˆ·
INSERT INTO dim_customer (customer_id, customer_name, email, city, valid_from)
VALUES (123, 'å¼ ä¸‰', 'zhangsan@example.com', 'åŒ—äº¬', '2024-01-01');

-- å®¢æˆ·åœ°å€å˜æ›´ï¼ˆåˆ›å»ºæ–°è®°å½•ï¼‰
INSERT INTO dim_customer (customer_id, customer_name, email, city, valid_from, version_number)
VALUES (123, 'å¼ ä¸‰', 'zhangsan@example.com', 'ä¸Šæµ·', '2024-06-01', 2);

-- æ›´æ–°æ—§è®°å½•çš„valid_toå’Œis_current
UPDATE dim_customer
SET
    valid_to = '2024-05-31',
    is_current = FALSE
WHERE customer_id = 123
  AND is_current = TRUE
  AND version_number = 1;

-- æŸ¥è¯¢å½“å‰æœ‰æ•ˆè®°å½•
SELECT * FROM dim_customer
WHERE customer_id = 123
  AND is_current = TRUE;

-- æŸ¥è¯¢å†å²è®°å½•
SELECT * FROM dim_customer
WHERE customer_id = 123
ORDER BY valid_from DESC;
```

**è‡ªåŠ¨å¤„ç†SCD Type 2çš„å‡½æ•°**:

```sql
-- SCD Type 2æ›´æ–°å‡½æ•°
CREATE OR REPLACE FUNCTION update_dim_customer_scd2(
    p_customer_id INT,
    p_customer_name VARCHAR(100),
    p_email VARCHAR(100),
    p_city VARCHAR(50),
    p_change_date DATE DEFAULT CURRENT_DATE
)
RETURNS INT AS $$
DECLARE
    v_new_key INT;
    v_new_version INT;
BEGIN
    -- è·å–å½“å‰ç‰ˆæœ¬å·
    SELECT COALESCE(MAX(version_number), 0) + 1
    INTO v_new_version
    FROM dim_customer
    WHERE customer_id = p_customer_id;

    -- å…³é—­æ—§è®°å½•
    UPDATE dim_customer
    SET
        valid_to = p_change_date - INTERVAL '1 day',
        is_current = FALSE,
        updated_at = NOW()
    WHERE customer_id = p_customer_id
      AND is_current = TRUE;

    -- æ’å…¥æ–°è®°å½•
    INSERT INTO dim_customer (
        customer_id, customer_name, email, city,
        valid_from, version_number, is_current
    )
    VALUES (
        p_customer_id, p_customer_name, p_email, p_city,
        p_change_date, v_new_version, TRUE
    )
    RETURNING customer_key INTO v_new_key;

    RETURN v_new_key;
END;
$$ LANGUAGE plpgsql;
```

---

### 2.3 SCD Type 3: ä¿ç•™æœ‰é™å†å²

**å®šä¹‰**: åœ¨ç»´åº¦è¡¨ä¸­æ·»åŠ "æ—§å€¼"åˆ—ï¼Œä»…ä¿ç•™ä¸Šä¸€æ¬¡çš„å€¼ã€‚

**ç‰¹ç‚¹**:

- ä¿ç•™æœ‰é™å†å²ï¼ˆä»…ä¸Šä¸€æ¬¡ï¼‰
- è¡¨ç»“æ„ç®€å•
- é€‚åˆå¶å°”å˜åŒ–çš„å±æ€§

**é€‚ç”¨åœºæ™¯**:

- äº§å“å½“å‰åˆ†ç±»å’Œä¸Šä¸€åˆ†ç±»
- å®¢æˆ·å½“å‰åœ°åŒºå’Œä¸Šä¸€åœ°åŒº

**PostgreSQLå®ç°**:

```sql
-- SCD Type 3ï¼šäº§å“ç»´åº¦è¡¨ï¼ˆä¿ç•™ä¸Šä¸€å€¼ï¼‰
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL UNIQUE,
    product_name VARCHAR(200) NOT NULL,
    -- å½“å‰å€¼
    current_category VARCHAR(100),
    current_brand VARCHAR(100),
    -- ä¸Šä¸€å€¼ï¼ˆSCD Type 3ï¼‰
    previous_category VARCHAR(100),
    previous_brand VARCHAR(100),
    -- å˜æ›´æ—¥æœŸ
    category_changed_date DATE,
    brand_changed_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ›´æ–°äº§å“åˆ†ç±»ï¼ˆä¿ç•™ä¸Šä¸€å€¼ï¼‰
CREATE OR REPLACE FUNCTION update_product_category_scd3(
    p_product_id INT,
    p_new_category VARCHAR(100)
)
RETURNS VOID AS $$
BEGIN
    UPDATE dim_product
    SET
        previous_category = current_category,
        current_category = p_new_category,
        category_changed_date = CURRENT_DATE,
        updated_at = NOW()
    WHERE product_id = p_product_id;
END;
$$ LANGUAGE plpgsql;
```

---

### 2.4 SCD Type 4: å¿«ç…§è¡¨

**å®šä¹‰**: ä½¿ç”¨å•ç‹¬çš„è¿·ä½ ç»´åº¦è¡¨å­˜å‚¨é¢‘ç¹å˜åŒ–çš„å±æ€§ã€‚

**ç‰¹ç‚¹**:

- ä¸»ç»´åº¦è¡¨ç¨³å®š
- è¿·ä½ ç»´åº¦è¡¨å­˜å‚¨å˜åŒ–
- é€‚åˆé¢‘ç¹å˜åŒ–çš„å±æ€§

**é€‚ç”¨åœºæ™¯**:

- äº§å“ä»·æ ¼å†å²
- å®¢æˆ·ä¿¡ç”¨ç­‰çº§å†å²
- åº“å­˜æ°´å¹³å†å²

**PostgreSQLå®ç°**:

```sql
-- ä¸»ç»´åº¦è¡¨ï¼ˆç¨³å®šå±æ€§ï¼‰
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL UNIQUE,
    product_name VARCHAR(200) NOT NULL,
    category VARCHAR(100),
    brand VARCHAR(100)
);

-- è¿·ä½ ç»´åº¦è¡¨ï¼ˆä»·æ ¼å†å²ï¼‰
CREATE TABLE dim_product_price (
    price_key SERIAL PRIMARY KEY,
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    price NUMERIC(10,2) NOT NULL,
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_current BOOLEAN DEFAULT TRUE,
    UNIQUE(product_key, effective_date)
);

-- æŸ¥è¯¢äº§å“å½“å‰ä»·æ ¼
SELECT
    p.product_name,
    pp.price AS current_price,
    pp.effective_date
FROM dim_product p
JOIN dim_product_price pp ON p.product_key = pp.product_key
WHERE pp.is_current = TRUE;
```

---

### 2.5 SCD Type 6: æ··åˆæ–¹æ³•

**å®šä¹‰**: ç»“åˆSCD Type 1ã€Type 2ã€Type 3çš„æ··åˆæ–¹æ³•ã€‚

**ç‰¹ç‚¹**:

- çµæ´»å¤„ç†ä¸åŒå±æ€§
- éƒ¨åˆ†å±æ€§ä¿ç•™å†å²ï¼Œéƒ¨åˆ†ç›´æ¥æ›´æ–°
- é€‚åˆå¤æ‚ä¸šåŠ¡åœºæ™¯

**PostgreSQLå®ç°**:

```sql
-- SCD Type 6ï¼šæ··åˆæ–¹æ³•
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    customer_name VARCHAR(100) NOT NULL,
    -- Type 1ï¼šç›´æ¥æ›´æ–°ï¼ˆä¸ä¿ç•™å†å²ï¼‰
    email VARCHAR(100),
    phone VARCHAR(20),
    -- Type 2ï¼šä¿ç•™å®Œæ•´å†å²
    city VARCHAR(50),
    state VARCHAR(50),
    valid_from DATE NOT NULL,
    valid_to DATE,
    is_current BOOLEAN DEFAULT TRUE,
    -- Type 3ï¼šä¿ç•™ä¸Šä¸€å€¼
    previous_city VARCHAR(50),
    city_changed_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 3. è§’è‰²æ‰®æ¼”ç»´åº¦

**å®šä¹‰**: åŒä¸€ä¸ªç»´åº¦è¡¨åœ¨äº‹å®è¡¨ä¸­å¤šæ¬¡ä½¿ç”¨ï¼Œæ‰®æ¼”ä¸åŒè§’è‰²ã€‚

**ç‰¹ç‚¹**:

- é¿å…é‡å¤ç»´åº¦è¡¨
- ä½¿ç”¨è§†å›¾æˆ–åˆ«å
- å¸¸è§äºæ—¶é—´ç»´åº¦

**PostgreSQLå®ç°**:

```sql
-- è®¢å•äº‹å®è¡¨ï¼ˆå¤šä¸ªæ—¥æœŸç»´åº¦ï¼‰
CREATE TABLE fact_orders (
    order_key BIGSERIAL PRIMARY KEY,
    order_date_key INT NOT NULL REFERENCES dim_date(date_key),
    ship_date_key INT REFERENCES dim_date(date_key),
    delivery_date_key INT REFERENCES dim_date(date_key),
    cancel_date_key INT REFERENCES dim_date(date_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    order_amount NUMERIC(10,2) NOT NULL
);

-- åˆ›å»ºè§’è‰²æ‰®æ¼”è§†å›¾
CREATE VIEW dim_order_date AS SELECT * FROM dim_date;
CREATE VIEW dim_ship_date AS SELECT * FROM dim_date;
CREATE VIEW dim_delivery_date AS SELECT * FROM dim_date;

-- æŸ¥è¯¢ï¼ˆä½¿ç”¨è§†å›¾ï¼‰
SELECT
    od.year_number AS order_year,
    sd.month_name AS ship_month,
    dd.day_name AS delivery_day,
    SUM(f.order_amount) AS total_amount
FROM fact_orders f
JOIN dim_order_date od ON f.order_date_key = od.date_key
JOIN dim_ship_date sd ON f.ship_date_key = sd.date_key
JOIN dim_delivery_date dd ON f.delivery_date_key = dd.date_key
GROUP BY od.year_number, sd.month_name, dd.day_name;
```

---

## 4. æ‚é¡¹ç»´åº¦

**å®šä¹‰**: å°†å¤šä¸ªä½åŸºæ•°çš„æ ‡å¿—å’ŒæŒ‡æ ‡ç»„åˆæˆä¸€ä¸ªç»´åº¦è¡¨ã€‚

**ç‰¹ç‚¹**:

- å‡å°‘äº‹å®è¡¨åˆ—æ•°
- æé«˜æŸ¥è¯¢æ€§èƒ½
- é€‚åˆå¤šä¸ªå¸ƒå°”æ ‡å¿—

**PostgreSQLå®ç°**:

```sql
-- æ‚é¡¹ç»´åº¦è¡¨
CREATE TABLE dim_order_junk (
    junk_key SERIAL PRIMARY KEY,
    -- ç»„åˆå¤šä¸ªæ ‡å¿—
    is_online_order BOOLEAN NOT NULL,
    is_express_delivery BOOLEAN NOT NULL,
    is_gift_wrapped BOOLEAN NOT NULL,
    payment_method VARCHAR(20) NOT NULL,
    delivery_method VARCHAR(20) NOT NULL,
    -- å”¯ä¸€çº¦æŸ
    UNIQUE(is_online_order, is_express_delivery, is_gift_wrapped, payment_method, delivery_method)
);

-- è®¢å•äº‹å®è¡¨ï¼ˆä½¿ç”¨æ‚é¡¹ç»´åº¦ï¼‰
CREATE TABLE fact_orders (
    order_key BIGSERIAL PRIMARY KEY,
    order_date_key INT NOT NULL REFERENCES dim_date(date_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    junk_key INT NOT NULL REFERENCES dim_order_junk(junk_key),  -- æ‚é¡¹ç»´åº¦
    order_amount NUMERIC(10,2) NOT NULL
);

-- æŸ¥è¯¢ï¼ˆä½¿ç”¨æ‚é¡¹ç»´åº¦ï¼‰
SELECT
    d.year_number,
    j.is_online_order,
    j.payment_method,
    SUM(f.order_amount) AS total_amount
FROM fact_orders f
JOIN dim_date d ON f.order_date_key = d.date_key
JOIN dim_order_junk j ON f.junk_key = j.junk_key
WHERE j.is_express_delivery = TRUE
GROUP BY d.year_number, j.is_online_order, j.payment_method;
```

---

## 5. é€€åŒ–ç»´åº¦

**å®šä¹‰**: ç»´åº¦å±æ€§ç›´æ¥å­˜å‚¨åœ¨äº‹å®è¡¨ä¸­ï¼Œä¸å•ç‹¬åˆ›å»ºç»´åº¦è¡¨ã€‚

**é€‚ç”¨åœºæ™¯**:

- äº¤æ˜“ç¼–å·
- è®¢å•ç¼–å·
- å‘ç¥¨ç¼–å·

**PostgreSQLå®ç°**:

```sql
-- äº‹å®è¡¨ï¼ˆåŒ…å«é€€åŒ–ç»´åº¦ï¼‰
CREATE TABLE fact_sales (
    sale_id BIGSERIAL PRIMARY KEY,
    date_key INT NOT NULL REFERENCES dim_date(date_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    -- é€€åŒ–ç»´åº¦ï¼ˆç›´æ¥å­˜å‚¨åœ¨äº‹å®è¡¨ä¸­ï¼‰
    transaction_number VARCHAR(50),  -- äº¤æ˜“ç¼–å·
    receipt_number VARCHAR(50),      -- æ”¶æ®ç¼–å·
    -- åº¦é‡å€¼
    sales_amount NUMERIC(10,2) NOT NULL
);

-- ä¸ºé€€åŒ–ç»´åº¦åˆ›å»ºç´¢å¼•
CREATE INDEX idx_fact_sales_transaction_num ON fact_sales(transaction_number);
CREATE INDEX idx_fact_sales_receipt_num ON fact_sales(receipt_number);
```

---

## 6. ä¸€è‡´æ€§ç»´åº¦

**å®šä¹‰**: åœ¨ä¸åŒäº‹å®è¡¨ä¸­ä½¿ç”¨ç›¸åŒçš„ç»´åº¦è¡¨ï¼Œç¡®ä¿ä¸€è‡´æ€§ã€‚

**ç‰¹ç‚¹**:

- ç»´åº¦é”®å€¼ä¸€è‡´
- å±æ€§å®šä¹‰ä¸€è‡´
- æ”¯æŒè·¨äº‹å®è¡¨åˆ†æ

**PostgreSQLå®ç°**:

```sql
-- ä¸€è‡´æ€§ç»´åº¦ï¼šæ—¶é—´ç»´åº¦
CREATE TABLE dim_date (
    date_key INT PRIMARY KEY,
    date_actual DATE NOT NULL UNIQUE,
    day_name VARCHAR(10),
    month_name VARCHAR(10),
    quarter_number INT,
    year_number INT
);

-- å¤šä¸ªäº‹å®è¡¨ä½¿ç”¨ç›¸åŒçš„æ—¶é—´ç»´åº¦
CREATE TABLE fact_sales (
    sale_id BIGSERIAL PRIMARY KEY,
    date_key INT NOT NULL REFERENCES dim_date(date_key),  -- ä¸€è‡´æ€§ç»´åº¦
    ...
);

CREATE TABLE fact_orders (
    order_id BIGSERIAL PRIMARY KEY,
    date_key INT NOT NULL REFERENCES dim_date(date_key),  -- ä¸€è‡´æ€§ç»´åº¦
    ...
);

-- è·¨äº‹å®è¡¨åˆ†æ
SELECT
    d.year_number,
    SUM(s.sales_amount) AS total_sales,
    SUM(o.order_amount) AS total_orders
FROM dim_date d
LEFT JOIN fact_sales s ON d.date_key = s.date_key
LEFT JOIN fact_orders o ON d.date_key = o.date_key
WHERE d.year_number = 2024
GROUP BY d.year_number;
```

---

## 7. PostgreSQLå®ç°

### 7.1 SCD Type 2è‡ªåŠ¨å¤„ç†

```sql
-- åˆ›å»ºSCD Type 2å¤„ç†å‡½æ•°
CREATE OR REPLACE FUNCTION process_scd_type2(
    p_table_name TEXT,
    p_business_key_col TEXT,
    p_business_key_val INT,
    p_change_date DATE DEFAULT CURRENT_DATE
)
RETURNS INT AS $$
DECLARE
    v_sql TEXT;
    v_new_key INT;
BEGIN
    -- å…³é—­æ—§è®°å½•
    v_sql := format('
        UPDATE %I
        SET valid_to = $1 - INTERVAL ''1 day'',
            is_current = FALSE,
            updated_at = NOW()
        WHERE %I = $2
          AND is_current = TRUE',
        p_table_name, p_business_key_col);

    EXECUTE v_sql USING p_change_date, p_business_key_val;

    -- è¿”å›æ–°é”®ï¼ˆéœ€è¦æ ¹æ®å®é™…æƒ…å†µå®ç°ï¼‰
    RETURN v_new_key;
END;
$$ LANGUAGE plpgsql;
```

---

### 7.2 ç»´åº¦è¡¨ç´¢å¼•ç­–ç•¥

```sql
-- SCD Type 2ç»´åº¦è¡¨ç´¢å¼•
CREATE INDEX idx_dim_customer_business_key ON dim_customer(customer_id, valid_from);
CREATE INDEX idx_dim_customer_current ON dim_customer(customer_id) WHERE is_current = TRUE;
CREATE INDEX idx_dim_customer_valid_date ON dim_customer(valid_from, valid_to);

-- ç»´åº¦è¡¨æŸ¥è¯¢ä¼˜åŒ–
-- æŸ¥è¯¢å½“å‰æœ‰æ•ˆè®°å½•ï¼ˆä½¿ç”¨éƒ¨åˆ†ç´¢å¼•ï¼‰
SELECT * FROM dim_customer
WHERE customer_id = 123
  AND is_current = TRUE;

-- æŸ¥è¯¢å†å²è®°å½•ï¼ˆä½¿ç”¨æ—¥æœŸç´¢å¼•ï¼‰
SELECT * FROM dim_customer
WHERE customer_id = 123
  AND valid_from <= '2024-06-01'
  AND (valid_to IS NULL OR valid_to >= '2024-06-01');
```

---

## 8. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Examples

### 8.1 æ¡ˆä¾‹1: SCD Type 2äº§å“ç»´åº¦

**å®Œæ•´SCD Type 2å®ç°**:

```sql
-- SCD Type 2äº§å“ç»´åº¦è¡¨
CREATE TABLE dim_product_scd2 (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_code VARCHAR(50) NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_name VARCHAR(100),
    brand_name VARCHAR(100),
    unit_price NUMERIC(10,2),
    valid_from DATE NOT NULL,
    valid_to DATE,
    is_current BOOLEAN DEFAULT TRUE,
    UNIQUE(product_id, valid_from)
);

-- SCD Type 2æ›´æ–°å‡½æ•°
CREATE OR REPLACE FUNCTION update_product_scd2(
    p_product_id INT,
    p_new_data JSONB
)
RETURNS VOID AS $$
DECLARE
    v_current_key INT;
BEGIN
    -- å…³é—­å½“å‰ç‰ˆæœ¬
    UPDATE dim_product_scd2
    SET valid_to = CURRENT_DATE - INTERVAL '1 day',
        is_current = FALSE
    WHERE product_id = p_product_id
      AND is_current = TRUE;

    -- åˆ›å»ºæ–°ç‰ˆæœ¬
    INSERT INTO dim_product_scd2 (
        product_id, product_code, product_name,
        category_name, brand_name, unit_price,
        valid_from, is_current
    )
    VALUES (
        p_product_id,
        p_new_data->>'product_code',
        p_new_data->>'product_name',
        p_new_data->>'category_name',
        p_new_data->>'brand_name',
        (p_new_data->>'unit_price')::NUMERIC,
        CURRENT_DATE,
        TRUE
    );
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢å†å²ç‰ˆæœ¬
SELECT * FROM dim_product_scd2
WHERE product_id = 123
  AND valid_from <= '2024-06-01'
  AND (valid_to IS NULL OR valid_to >= '2024-06-01');
```

### 8.2 æ¡ˆä¾‹2: è§’è‰²æ‰®æ¼”ç»´åº¦åº”ç”¨

**æ—¥æœŸè§’è‰²æ‰®æ¼”ç»´åº¦**:

```sql
-- äº‹å®è¡¨ï¼šè®¢å•äº‹å®ï¼ˆå¤šä¸ªæ—¥æœŸè§’è‰²ï¼‰
CREATE TABLE fact_orders (
    order_id BIGSERIAL,
    order_date_key INT NOT NULL REFERENCES dim_date(date_key),
    ship_date_key INT REFERENCES dim_date(date_key),
    delivery_date_key INT REFERENCES dim_date(date_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    order_amount NUMERIC(10,2) NOT NULL
);

-- æŸ¥è¯¢ï¼šä½¿ç”¨è§’è‰²æ‰®æ¼”ç»´åº¦
-- æŒ‰è®¢å•æ—¥æœŸåˆ†æ
SELECT
    d1.year_number,
    d1.month_number,
    SUM(f.order_amount) AS total_orders
FROM fact_orders f
JOIN dim_date d1 ON f.order_date_key = d1.date_key
GROUP BY d1.year_number, d1.month_number;

-- æŒ‰å‘è´§æ—¥æœŸåˆ†æ
SELECT
    d2.year_number,
    d2.month_number,
    SUM(f.order_amount) AS total_shipped
FROM fact_orders f
JOIN dim_date d2 ON f.ship_date_key = d2.date_key
GROUP BY d2.year_number, d2.month_number;
```

### 8.3 æ¡ˆä¾‹3: æ‚é¡¹ç»´åº¦åº”ç”¨

**è®¢å•æ‚é¡¹ç»´åº¦**:

```sql
-- æ‚é¡¹ç»´åº¦ï¼šè®¢å•å±æ€§ç»„åˆ
CREATE TABLE dim_order_junk (
    junk_key SERIAL PRIMARY KEY,
    payment_method VARCHAR(50),
    shipping_method VARCHAR(50),
    order_source VARCHAR(50),
    promotion_type VARCHAR(50),
    is_gift BOOLEAN,
    is_express BOOLEAN,
    UNIQUE(payment_method, shipping_method, order_source, promotion_type, is_gift, is_express)
);

-- äº‹å®è¡¨å¼•ç”¨æ‚é¡¹ç»´åº¦
CREATE TABLE fact_order_detail (
    order_id BIGSERIAL,
    date_key INT NOT NULL REFERENCES dim_date(date_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    junk_key INT REFERENCES dim_order_junk(junk_key),
    order_amount NUMERIC(10,2) NOT NULL
);

-- æŸ¥è¯¢ï¼šä½¿ç”¨æ‚é¡¹ç»´åº¦
SELECT
    oj.payment_method,
    oj.shipping_method,
    SUM(f.order_amount) AS total_amount,
    COUNT(*) AS order_count
FROM fact_order_detail f
JOIN dim_order_junk oj ON f.junk_key = oj.junk_key
GROUP BY oj.payment_method, oj.shipping_method;
```

---

## 9. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§ / Performance Optimization and Monitoring

### 9.1 ç»´åº¦è¡¨æ€§èƒ½ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**:

```sql
-- SCD Type 2ç»´åº¦è¡¨ç´¢å¼•
CREATE INDEX idx_dim_product_id_current ON dim_product_scd2(product_id) WHERE is_current = TRUE;
CREATE INDEX idx_dim_product_valid_range ON dim_product_scd2(product_id, valid_from, valid_to);

-- æ‚é¡¹ç»´åº¦ç´¢å¼•
CREATE INDEX idx_dim_junk_lookup ON dim_order_junk(payment_method, shipping_method, order_source);
```

**æŸ¥è¯¢ä¼˜åŒ–**:

```sql
-- âœ… ä¼˜åŒ–ï¼šä½¿ç”¨å½“å‰ç‰ˆæœ¬ç´¢å¼•
SELECT * FROM dim_product_scd2
WHERE product_id = 123 AND is_current = TRUE;  -- ä½¿ç”¨éƒ¨åˆ†ç´¢å¼•

-- âœ… ä¼˜åŒ–ï¼šå†å²ç‰ˆæœ¬æŸ¥è¯¢
SELECT * FROM dim_product_scd2
WHERE product_id = 123
  AND valid_from <= '2024-06-01'
  AND (valid_to IS NULL OR valid_to >= '2024-06-01');  -- ä½¿ç”¨èŒƒå›´ç´¢å¼•
```

### 9.2 SCDæ€§èƒ½ç›‘æ§

**ç›‘æ§SCDè¡¨å¤§å°**:

```sql
-- ç›‘æ§ç»´åº¦è¡¨å¤§å°å’Œç‰ˆæœ¬æ•°
SELECT
    'dim_product_scd2' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE is_current = TRUE) AS current_rows,
    COUNT(*) FILTER (WHERE is_current = FALSE) AS historical_rows,
    COUNT(DISTINCT product_id) AS unique_products,
    AVG(COUNT(*) OVER (PARTITION BY product_id)) AS avg_versions_per_product
FROM dim_product_scd2;

-- ç›‘æ§SCDæ›´æ–°é¢‘ç‡
SELECT
    DATE_TRUNC('month', valid_from) AS month,
    COUNT(*) AS new_versions,
    COUNT(DISTINCT product_id) AS products_updated
FROM dim_product_scd2
WHERE valid_from >= CURRENT_DATE - INTERVAL '12 months'
GROUP BY month
ORDER BY month DESC;
```

---

## 10. å¸¸è§é—®é¢˜è§£ç­” / FAQ

### Q1: SCD Type 1ã€2ã€3å¦‚ä½•é€‰æ‹©ï¼Ÿ

**A**: é€‰æ‹©åŸåˆ™ï¼š

| SCDç±»å‹ | é€‚ç”¨åœºæ™¯ | ç‰¹ç‚¹ |
|---------|---------|------|
| Type 1 | é”™è¯¯ä¿®æ­£ã€ä¸é‡è¦å±æ€§ | è¦†ç›–å†å²ï¼Œä¸ä¿ç•™å†å² |
| Type 2 | é‡è¦å±æ€§å˜æ›´ | ä¿ç•™å®Œæ•´å†å² |
| Type 3 | æœ‰é™å†å²éœ€æ±‚ | ä¿ç•™æœ‰é™å†å²åˆ— |

**é€‰æ‹©å†³ç­–**:

- éœ€è¦å®Œæ•´å†å² â†’ SCD Type 2
- åªéœ€è¦å½“å‰å€¼ â†’ SCD Type 1
- éœ€è¦æœ‰é™å†å² â†’ SCD Type 3

### Q2: SCD Type 2ä¼šå¯¼è‡´ç»´åº¦è¡¨å¾ˆå¤§å—ï¼Ÿ

**A**: å¤§å°æ§åˆ¶ç­–ç•¥ï¼š

```sql
-- ç›‘æ§ç»´åº¦è¡¨å¤§å°
SELECT
    product_id,
    COUNT(*) AS version_count,
    MAX(valid_from) AS latest_version
FROM dim_product_scd2
GROUP BY product_id
HAVING COUNT(*) > 10  -- ç‰ˆæœ¬è¿‡å¤šçš„äº§å“
ORDER BY version_count DESC;

-- ä¼˜åŒ–ï¼šå½’æ¡£æ—§ç‰ˆæœ¬
CREATE TABLE dim_product_scd2_archive (LIKE dim_product_scd2 INCLUDING ALL);
INSERT INTO dim_product_scd2_archive
SELECT * FROM dim_product_scd2
WHERE valid_to < CURRENT_DATE - INTERVAL '5 years';
DELETE FROM dim_product_scd2
WHERE valid_to < CURRENT_DATE - INTERVAL '5 years';
```

### Q3: è§’è‰²æ‰®æ¼”ç»´åº¦å¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**A**: ä¼˜åŒ–ç­–ç•¥ï¼š

1. **è§†å›¾åˆ«å**: ä½¿ç”¨è§†å›¾åˆ›å»ºåˆ«å
2. **ç´¢å¼•ä¼˜åŒ–**: ä¸ºæ¯ä¸ªè§’è‰²åˆ›å»ºç´¢å¼•
3. **æŸ¥è¯¢ä¼˜åŒ–**: é¿å…å¤šæ¬¡JOINåŒä¸€ç»´åº¦è¡¨

```sql
-- åˆ›å»ºè§†å›¾åˆ«å
CREATE VIEW dim_order_date AS SELECT * FROM dim_date;
CREATE VIEW dim_ship_date AS SELECT * FROM dim_date;
CREATE VIEW dim_delivery_date AS SELECT * FROM dim_date;

-- æŸ¥è¯¢æ—¶ä½¿ç”¨è§†å›¾
SELECT * FROM fact_orders f
JOIN dim_order_date d1 ON f.order_date_key = d1.date_key
JOIN dim_ship_date d2 ON f.ship_date_key = d2.date_key;
```

### Q4: æ‚é¡¹ç»´åº¦ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ï¼Ÿ

**A**: æ‚é¡¹ç»´åº¦é€‚ç”¨åœºæ™¯ï¼š

- âœ… **ä½åŸºæ•°å±æ€§**: å±æ€§å€¼æ•°é‡æœ‰é™
- âœ… **å±æ€§ç»„åˆ**: å¤šä¸ªä½åŸºæ•°å±æ€§ç»„åˆ
- âœ… **å‡å°‘äº‹å®è¡¨åˆ—**: å‡å°‘äº‹å®è¡¨åˆ—æ•°

**ä¸é€‚ç”¨åœºæ™¯**:

- âŒ **é«˜åŸºæ•°å±æ€§**: å±æ€§å€¼å¾ˆå¤š
- âŒ **ç‹¬ç«‹å±æ€§**: å±æ€§ç‹¬ç«‹ä½¿ç”¨ï¼Œä¸éœ€è¦ç»„åˆ

### Q5: å¦‚ä½•ä¼˜åŒ–ç»´åº¦è¡¨æŸ¥è¯¢æ€§èƒ½ï¼Ÿ

**A**: æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥ï¼š

1. **å½“å‰ç‰ˆæœ¬ç´¢å¼•**: ä¸ºis_currentåˆ›å»ºéƒ¨åˆ†ç´¢å¼•
2. **å†å²ç‰ˆæœ¬ç´¢å¼•**: ä¸ºvalid_from/valid_toåˆ›å»ºèŒƒå›´ç´¢å¼•
3. **ç‰©åŒ–è§†å›¾**: ç¼“å­˜å¸¸ç”¨ç»´åº¦æŸ¥è¯¢ç»“æœ

```sql
-- å½“å‰ç‰ˆæœ¬ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW mv_dim_product_current AS
SELECT * FROM dim_product_scd2 WHERE is_current = TRUE;

CREATE UNIQUE INDEX ON mv_dim_product_current(product_id);

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_dim_product_current;
```

---

## 11. ç›¸å…³èµ„æº / Related Resources

### 11.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents

- [ç»´åº¦å»ºæ¨¡åŸºç¡€](./ç»´åº¦å»ºæ¨¡åŸºç¡€.md) - ç»´åº¦å»ºæ¨¡åŸºç¡€ç†è®º
- [äº‹å®è¡¨æŠ€æœ¯](./äº‹å®è¡¨æŠ€æœ¯.md) - äº‹å®è¡¨è®¾è®¡æŠ€æœ¯
- [PostgreSQLåˆ—å­˜å®ç°](./PostgreSQLåˆ—å­˜å®ç°.md) - åˆ—å­˜è¡¨å®ç°
- [ç´¢å¼•ç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/ç´¢å¼•ç­–ç•¥.md) - ç»´åº¦è¡¨ç´¢å¼•è®¾è®¡
- [æ€§èƒ½ä¼˜åŒ–](../08-PostgreSQLå»ºæ¨¡å®è·µ/æ€§èƒ½ä¼˜åŒ–.md) - ç»´åº¦è¡¨æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–
- [çº¦æŸè®¾è®¡](../08-PostgreSQLå»ºæ¨¡å®è·µ/çº¦æŸè®¾è®¡.md) - ç»´åº¦è¡¨çº¦æŸè®¾è®¡

### 11.2 ç†è®ºåŸºç¡€ / Theoretical Foundation

- [Kimballç»´åº¦å»ºæ¨¡](../02-æƒå¨èµ„æºä¸æ ‡å‡†/Kimballç»´åº¦å»ºæ¨¡.md) - Kimballç»´åº¦è¡¨è®¾è®¡ç†è®º
- [èŒƒå¼ç†è®º](../01-æ•°æ®å»ºæ¨¡ç†è®ºåŸºç¡€/èŒƒå¼ç†è®º.md) - æ•°æ®åº“èŒƒå¼ç†è®ºï¼ˆSCDè®¾è®¡ï¼‰

### 11.3 å®è·µæŒ‡å— / Practical Guides

- [æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§](#9-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§--performance-optimization-and-monitoring) - æœ¬æ–‡æ¡£çš„æ€§èƒ½ç›‘æ§ç« èŠ‚
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#8-å®é™…åº”ç”¨æ¡ˆä¾‹--practical-application-examples) - æœ¬æ–‡æ¡£çš„åº”ç”¨æ¡ˆä¾‹ç« èŠ‚
- [ç¼“æ…¢å˜åŒ–ç»´åº¦ï¼ˆSCDï¼‰](#2-ç¼“æ…¢å˜åŒ–ç»´åº¦scd) - æœ¬æ–‡æ¡£çš„SCDç« èŠ‚

### 11.4 åº”ç”¨æ¡ˆä¾‹ / Application Cases

- [ç”µå•†æ•°æ®æ¨¡å‹æ¡ˆä¾‹](../10-ç»¼åˆåº”ç”¨æ¡ˆä¾‹/ç”µå•†æ•°æ®æ¨¡å‹æ¡ˆä¾‹.md) - ç”µå•†ç»´åº¦è¡¨è®¾è®¡æ¡ˆä¾‹
- [é‡‘èæ•°æ®æ¨¡å‹æ¡ˆä¾‹](../10-ç»¼åˆåº”ç”¨æ¡ˆä¾‹/é‡‘èæ•°æ®æ¨¡å‹æ¡ˆä¾‹.md) - é‡‘èç»´åº¦è¡¨è®¾è®¡æ¡ˆä¾‹

### 11.5 å‚è€ƒèµ„æº / Reference Resources

- [æƒå¨èµ„æºç´¢å¼•](../00-å¯¼èˆªä¸ç´¢å¼•/æƒå¨èµ„æºç´¢å¼•.md) - æƒå¨èµ„æºåˆ—è¡¨
- [æœ¯è¯­å¯¹ç…§è¡¨](../00-å¯¼èˆªä¸ç´¢å¼•/æœ¯è¯­å¯¹ç…§è¡¨.md) - æœ¯è¯­å¯¹ç…§
- [å¿«é€ŸæŸ¥æ‰¾æŒ‡å—](../00-å¯¼èˆªä¸ç´¢å¼•/å¿«é€ŸæŸ¥æ‰¾æŒ‡å—.md) - å¿«é€ŸæŸ¥æ‰¾å·¥å…·
- PostgreSQLå®˜æ–¹æ–‡æ¡£: [Table Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)

- [Kimballç»´åº¦å»ºæ¨¡](../02-æƒå¨èµ„æºä¸æ ‡å‡†/Kimballç»´åº¦å»ºæ¨¡.md) - ç»´åº¦è¡¨æŠ€æœ¯æ¥æº
- [ç»´åº¦å»ºæ¨¡åŸºç¡€](./ç»´åº¦å»ºæ¨¡åŸºç¡€.md) - ç»´åº¦å»ºæ¨¡åŸºç¡€
- [äº‹å®è¡¨æŠ€æœ¯](./äº‹å®è¡¨æŠ€æœ¯.md) - äº‹å®è¡¨è®¾è®¡æŠ€æœ¯
- [ç´¢å¼•ç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/ç´¢å¼•ç­–ç•¥.md) - ç»´åº¦è¡¨ç´¢å¼•ç­–ç•¥
- [çº¦æŸè®¾è®¡](../08-PostgreSQLå»ºæ¨¡å®è·µ/çº¦æŸè®¾è®¡.md) - ç»´åº¦è¡¨çº¦æŸè®¾è®¡

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
