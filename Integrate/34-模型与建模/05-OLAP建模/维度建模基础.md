# OLAP维度建模基础完整指南

> **创建日期**: 2025年1月
> **来源**: Kimball《数据仓库工具箱》+ 实践总结
> **状态**: 基于权威资源深化扩展
> **文档编号**: 05-01

---

## 📑 目录

- [OLAP维度建模基础完整指南](#olap维度建模基础完整指南)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 维度建模基本概念](#111-维度建模基本概念)
    - [1.1.2 事实表理论](#112-事实表理论)
    - [1.1.3 维度表理论](#113-维度表理论)
    - [1.1.4 星型模式理论](#114-星型模式理论)
    - [1.1.5 雪花模式理论](#115-雪花模式理论)
    - [1.1.6 维度建模设计步骤](#116-维度建模设计步骤)
    - [1.1.7 复杂度分析](#117-复杂度分析)
  - [2. 维度建模核心概念](#2-维度建模核心概念)
    - [2.1 事实表（Fact Table）](#21-事实表fact-table)
    - [2.2 维度表（Dimension Table）](#22-维度表dimension-table)
  - [3. 星型模式（Star Schema）](#3-星型模式star-schema)
  - [4. 雪花模式（Snowflake Schema）](#4-雪花模式snowflake-schema)
  - [5. 星型模式 vs 雪花模式](#5-星型模式-vs-雪花模式)
    - [5.1 对比矩阵](#51-对比矩阵)
    - [5.2 选择建议](#52-选择建议)
  - [6. 维度建模设计步骤](#6-维度建模设计步骤)
    - [6.1 Kimball的四个关键决策](#61-kimball的四个关键决策)
    - [6.2 设计步骤](#62-设计步骤)
  - [7. PostgreSQL实现](#7-postgresql实现)
    - [7.1 事实表设计](#71-事实表设计)
    - [7.2 维度表设计](#72-维度表设计)
    - [7.3 物化视图优化](#73-物化视图优化)
  - [8. 实际应用案例 / Practical Application Examples](#8-实际应用案例--practical-application-examples)
    - [8.1 案例1: 销售分析星型模式](#81-案例1-销售分析星型模式)
    - [8.2 案例2: 库存分析星型模式](#82-案例2-库存分析星型模式)
    - [8.3 案例3: 客户分析星型模式](#83-案例3-客户分析星型模式)
  - [9. 性能优化与监控 / Performance Optimization and Monitoring](#9-性能优化与监控--performance-optimization-and-monitoring)
    - [9.1 星型模式性能优化](#91-星型模式性能优化)
    - [9.2 查询性能监控](#92-查询性能监控)
  - [10. 常见问题解答 / FAQ](#10-常见问题解答--faq)
    - [Q1: 星型模式和雪花模式如何选择？](#q1-星型模式和雪花模式如何选择)
    - [Q2: 如何确定事实表的粒度？](#q2-如何确定事实表的粒度)
    - [Q3: 维度表应该包含多少属性？](#q3-维度表应该包含多少属性)
    - [Q4: 如何优化星型模式查询性能？](#q4-如何优化星型模式查询性能)
    - [Q5: 如何处理维度表的缓慢变化？](#q5-如何处理维度表的缓慢变化)
  - [11. 相关资源 / Related Resources](#11-相关资源--related-resources)
    - [11.1 核心相关文档 / Core Related Documents](#111-核心相关文档--core-related-documents)
    - [11.2 理论基础 / Theoretical Foundation](#112-理论基础--theoretical-foundation)
    - [11.3 实践指南 / Practical Guides](#113-实践指南--practical-guides)
    - [11.4 应用案例 / Application Cases](#114-应用案例--application-cases)
    - [11.5 参考资源 / Reference Resources](#115-参考资源--reference-resources)

---

## 1. 概述

维度建模（Dimensional Modeling）是数据仓库设计的核心方法，由Ralph Kimball提出。维度建模以业务需求为驱动，采用星型模式设计，强调易用性和查询性能，是OLAP系统的主流建模方法。

---

## 1.1 理论基础

### 1.1.1 维度建模基本概念

**维度建模（Dimensional Modeling）**是数据仓库设计的核心方法：

- **目标**: 提高查询性能，简化查询逻辑
- **方法**: 星型模式（Star Schema）或雪花模式（Snowflake Schema）
- **原则**: 以业务需求为驱动，强调易用性

**维度建模 vs 范式化建模**:

- **维度建模**: 去范式化，允许冗余，优化查询性能
- **范式化建模**: 消除冗余，优化存储和更新性能

### 1.1.2 事实表理论

**事实表（Fact Table）**存储业务过程的度量值：

- **度量值类型**:
  - **可加度量值**: $M_{additive} = \sum_{i=1}^{n} m_i$
  - **半可加度量值**: $M_{semi-additive} = \sum_{i \in D} m_i$ (only for dimension D)
  - **不可加度量值**: $M_{non-additive} = f(m_1, m_2, ..., m_n)$ (function)

**事实表粒度**:

- **事务粒度**: 每个事务一行
- **快照粒度**: 每个时间点一行
- **累积快照粒度**: 每个业务过程一行

### 1.1.3 维度表理论

**维度表（Dimension Table）**描述业务过程的上下文：

- **维度属性**: 提供查询和过滤条件
- **缓慢变化**: 维度属性会缓慢变化
- **层次结构**: 维度可以有层次结构（如年-月-日）

**缓慢变化维（SCD）**:

- **SCD Type 1**: 覆盖历史值
- **SCD Type 2**: 保留历史值（添加新行）
- **SCD Type 3**: 保留部分历史值（添加历史列）

### 1.1.4 星型模式理论

**星型模式（Star Schema）**:

- **中心**: 事实表（Fact Table）
- **周围**: 维度表（Dimension Table）
- **关系**: 事实表通过外键连接维度表

**星型模式优势**:

- **查询简单**: 减少JOIN操作
- **性能优化**: 优化查询性能
- **易于理解**: 业务用户易于理解

### 1.1.5 雪花模式理论

**雪花模式（Snowflake Schema）**:

- **规范化**: 维度表规范化
- **层次结构**: 维度层次结构分解为多个表
- **关系**: 维度表之间也有关系

**雪花模式优势**:

- **存储优化**: 减少存储空间
- **更新优化**: 更新操作更简单
- **查询复杂**: 需要更多JOIN操作

### 1.1.6 维度建模设计步骤

**Kimball的四个关键决策**:

1. **业务过程**: 选择要建模的业务过程
2. **粒度**: 确定事实表的粒度
3. **维度**: 确定维度表
4. **度量值**: 确定度量值

**设计步骤**:

1. 选择业务过程
2. 声明粒度
3. 识别维度
4. 识别度量值

### 1.1.7 复杂度分析

**存储复杂度**:

- **事实表**: $O(F)$ where F is number of facts
- **维度表**: $O(D)$ where D is number of dimensions
- **总存储**: $O(F + D)$

**查询复杂度**:

- **星型模式**: $O(\log F + \log D)$ with indexes
- **雪花模式**: $O(\log F + \sum_{i=1}^{n} \log D_i)$ with indexes

---

## 2. 维度建模核心概念

### 2.1 事实表（Fact Table）

**定义**: 存储业务过程的度量值（Measure），是星型模式的中心。

**特点**:

- 包含度量值（可加、半可加、不可加）
- 包含外键指向维度表
- 行数通常很大（百万到数十亿行）
- 列数相对较少（10-20列）

**度量值类型**:

- **可加度量值**: 可以跨所有维度相加（如销售额、数量）
- **半可加度量值**: 只能跨部分维度相加（如账户余额、库存）
- **不可加度量值**: 不能相加（如比率、百分比）

**示例**:

```sql
-- 销售事实表
CREATE TABLE fact_sales (
    sale_id BIGSERIAL PRIMARY KEY,
    -- 外键（维度键）
    date_key INT NOT NULL REFERENCES dim_date(date_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    store_key INT NOT NULL REFERENCES dim_store(store_key),
    -- 度量值
    sales_amount NUMERIC(10,2) NOT NULL,  -- 可加
    sales_quantity INT NOT NULL,          -- 可加
    discount_amount NUMERIC(10,2),        -- 可加
    profit_margin NUMERIC(5,2)            -- 不可加（比率）
);
```

---

### 2.2 维度表（Dimension Table）

**定义**: 描述业务过程的上下文，提供查询和过滤条件。

**特点**:

- 包含描述性属性
- 行数相对较少（数千到数百万行）
- 列数较多（10-100列）
- 通常去范式化（Denormalized）

**维度类型**:

- **时间维度**: 日期、时间层次结构
- **产品维度**: 产品属性、分类
- **客户维度**: 客户属性、地理信息
- **商店维度**: 商店属性、位置信息

**示例**:

```sql
-- 产品维度表
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,  -- 业务键
    product_name VARCHAR(200) NOT NULL,
    category_name VARCHAR(100),  -- 去范式化
    brand_name VARCHAR(100),     -- 去范式化
    unit_price NUMERIC(10,2),
    is_active BOOLEAN DEFAULT TRUE,
    valid_from DATE NOT NULL,
    valid_to DATE,
    -- SCD Type 2字段
    is_current BOOLEAN DEFAULT TRUE,
    version_number INT DEFAULT 1
);

-- 时间维度表
CREATE TABLE dim_date (
    date_key INT PRIMARY KEY,  -- YYYYMMDD格式
    date_actual DATE NOT NULL UNIQUE,
    day_name VARCHAR(10),
    day_of_week INT,
    day_of_month INT,
    day_of_year INT,
    week_of_year INT,
    month_name VARCHAR(10),
    month_number INT,
    quarter_number INT,
    year_number INT,
    is_weekend BOOLEAN,
    is_holiday BOOLEAN,
    holiday_name VARCHAR(50)
);
```

---

## 3. 星型模式（Star Schema）

**定义**: 一个事实表被多个维度表围绕，形似星型。

**特点**:

- 维度表去范式化
- 查询性能好（JOIN少）
- 易于理解和使用
- 适合OLAP查询

**示例**:

```sql
-- 星型模式示例（带错误处理）
-- 事实表：销售事实
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'fact_sales') THEN
        CREATE TABLE fact_sales (
            sale_id BIGSERIAL PRIMARY KEY,
            date_key INT NOT NULL REFERENCES dim_date(date_key),
            product_key INT NOT NULL REFERENCES dim_product(product_key),
            customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
            store_key INT NOT NULL REFERENCES dim_store(store_key),
            sales_amount NUMERIC(10,2) NOT NULL,
            sales_quantity INT NOT NULL
        );
        RAISE NOTICE '表 fact_sales 创建成功';
    ELSE
        RAISE NOTICE '表 fact_sales 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 fact_sales 失败: %', SQLERRM;
END $$;

-- 维度表：日期维度（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'dim_date') THEN
        CREATE TABLE dim_date (
            date_key INT PRIMARY KEY,
            date_actual DATE NOT NULL,
            day_name VARCHAR(10),
            month_name VARCHAR(10),
            quarter_number INT,
            year_number INT
        );
        RAISE NOTICE '表 dim_date 创建成功';
    ELSE
        RAISE NOTICE '表 dim_date 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 dim_date 失败: %', SQLERRM;
END $$;

-- 维度表：产品维度（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'dim_product') THEN
        CREATE TABLE dim_product (
            product_key SERIAL PRIMARY KEY,
            product_id INT NOT NULL,
            product_name VARCHAR(200),
            category_name VARCHAR(100),  -- 去范式化
            brand_name VARCHAR(100)     -- 去范式化
        );
        RAISE NOTICE '表 dim_product 创建成功';
    ELSE
        RAISE NOTICE '表 dim_product 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 dim_product 失败: %', SQLERRM;
END $$;

-- 维度表：客户维度（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'dim_customer') THEN
        CREATE TABLE dim_customer (
            customer_key SERIAL PRIMARY KEY,
            customer_id INT NOT NULL,
            customer_name VARCHAR(100),
            city_name VARCHAR(50),      -- 去范式化
            state_name VARCHAR(50),     -- 去范式化
            country_name VARCHAR(50)    -- 去范式化
        );
        RAISE NOTICE '表 dim_customer 创建成功';
    ELSE
        RAISE NOTICE '表 dim_customer 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 dim_customer 失败: %', SQLERRM;
END $$;

-- 维度表：商店维度（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'dim_store') THEN
        CREATE TABLE dim_store (
            store_key SERIAL PRIMARY KEY,
            store_id INT NOT NULL,
            store_name VARCHAR(100),
            city_name VARCHAR(50),      -- 去范式化
            region_name VARCHAR(50)     -- 去范式化
        );
        RAISE NOTICE '表 dim_store 创建成功';
    ELSE
        RAISE NOTICE '表 dim_store 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 dim_store 失败: %', SQLERRM;
END $$;
```

**查询示例**:

```sql
-- 星型模式查询（简单JOIN）
SELECT
    d.year_number,
    d.month_name,
    p.category_name,
    SUM(f.sales_amount) AS total_sales,
    SUM(f.sales_quantity) AS total_quantity
FROM fact_sales f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_product p ON f.product_key = p.product_key
WHERE d.year_number = 2024
GROUP BY d.year_number, d.month_name, p.category_name
ORDER BY d.year_number, d.month_name, p.category_name;
```

---

## 4. 雪花模式（Snowflake Schema）

**定义**: 维度表进一步规范化，形成层次结构，形似雪花。

**特点**:

- 维度表规范化
- 减少数据冗余
- JOIN数量增加
- 查询性能略差

**示例**:

```sql
-- 雪花模式示例
-- 产品维度表（规范化）
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_name VARCHAR(200),
    category_key INT NOT NULL REFERENCES dim_category(category_key),
    brand_key INT NOT NULL REFERENCES dim_brand(brand_key)
);

-- 产品分类维度表
CREATE TABLE dim_category (
    category_key SERIAL PRIMARY KEY,
    category_id INT NOT NULL,
    category_name VARCHAR(100),
    department_key INT NOT NULL REFERENCES dim_department(department_key)
);

-- 部门维度表
CREATE TABLE dim_department (
    department_key SERIAL PRIMARY KEY,
    department_id INT NOT NULL,
    department_name VARCHAR(100)
);

-- 品牌维度表
CREATE TABLE dim_brand (
    brand_key SERIAL PRIMARY KEY,
    brand_id INT NOT NULL,
    brand_name VARCHAR(100),
    manufacturer_key INT NOT NULL REFERENCES dim_manufacturer(manufacturer_key)
);

-- 制造商维度表
CREATE TABLE dim_manufacturer (
    manufacturer_key SERIAL PRIMARY KEY,
    manufacturer_id INT NOT NULL,
    manufacturer_name VARCHAR(100)
);
```

**查询示例**:

```sql
-- 雪花模式查询（多级JOIN）
SELECT
    d.year_number,
    dept.department_name,
    cat.category_name,
    SUM(f.sales_amount) AS total_sales
FROM fact_sales f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_product p ON f.product_key = p.product_key
JOIN dim_category cat ON p.category_key = cat.category_key
JOIN dim_department dept ON cat.department_key = dept.department_key
WHERE d.year_number = 2024
GROUP BY d.year_number, dept.department_name, cat.category_name;
```

---

## 5. 星型模式 vs 雪花模式

### 5.1 对比矩阵

| 维度 | 星型模式 | 雪花模式 |
|------|---------|---------|
| **数据冗余** | 高（去范式化） | 低（规范化） |
| **JOIN数量** | 少（1级JOIN） | 多（多级JOIN） |
| **查询性能** | 快 | 较慢 |
| **存储空间** | 大 | 小 |
| **维护复杂度** | 低 | 高 |
| **易用性** | 高 | 低 |
| **适用场景** | OLAP查询 | 数据规范化要求高 |

---

### 5.2 选择建议

**使用星型模式**:

- ✅ OLAP查询为主
- ✅ 查询性能优先
- ✅ 维度表变化不频繁
- ✅ 存储成本可接受

**使用雪花模式**:

- ✅ 数据规范化要求高
- ✅ 维度表层次结构复杂
- ✅ 存储空间有限
- ✅ 维度表更新频繁

---

## 6. 维度建模设计步骤

### 6.1 Kimball的四个关键决策

**1. 业务过程（Business Process）**:

- 识别核心业务活动
- 如：销售、订单、支付、发货

**2. 粒度（Grain）**:

- 定义事实表的详细程度
- 如：每个订单行、每个交易、每天汇总

**3. 维度（Dimensions）**:

- 描述业务过程的上下文
- 如：时间、产品、客户、商店

**4. 事实（Facts）**:

- 业务过程的度量值
- 如：销售额、数量、成本

---

### 6.2 设计步骤

**步骤1: 选择业务过程**:

```sql
-- 业务过程：销售交易
-- 粒度：每个销售交易行
```

**步骤2: 声明粒度**:

```sql
-- 粒度声明：每个订单行的每个产品
-- 意味着：一个订单可以有多个事实行
```

**步骤3: 识别维度**:

```sql
-- 维度：
-- - 日期（订单日期）
-- - 产品（产品ID）
-- - 客户（客户ID）
-- - 商店（商店ID）
-- - 促销（促销ID，可选）
```

**步骤4: 识别事实**:

```sql
-- 事实（度量值）：
-- - 销售金额（可加）
-- - 销售数量（可加）
-- - 折扣金额（可加）
-- - 利润率（不可加）
```

---

## 7. PostgreSQL实现

### 7.1 事实表设计

```sql
-- 销售事实表
CREATE TABLE fact_sales (
    sale_id BIGSERIAL PRIMARY KEY,
    -- 维度键
    date_key INT NOT NULL REFERENCES dim_date(date_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    store_key INT NOT NULL REFERENCES dim_store(store_key),
    promotion_key INT REFERENCES dim_promotion(promotion_key),
    -- 度量值
    sales_amount NUMERIC(10,2) NOT NULL,
    sales_quantity INT NOT NULL,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    cost_amount NUMERIC(10,2),
    profit_amount NUMERIC(10,2) GENERATED ALWAYS AS (sales_amount - cost_amount) STORED,
    -- 元数据
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_fact_sales_date ON fact_sales(date_key);
CREATE INDEX idx_fact_sales_product ON fact_sales(product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);
CREATE INDEX idx_fact_sales_store ON fact_sales(store_key);

-- 复合索引（常用查询组合）
CREATE INDEX idx_fact_sales_date_product ON fact_sales(date_key, product_key);
```

---

### 7.2 维度表设计

```sql
-- 时间维度表（预填充）
CREATE TABLE dim_date (
    date_key INT PRIMARY KEY,  -- YYYYMMDD
    date_actual DATE NOT NULL UNIQUE,
    day_name VARCHAR(10),
    day_of_week INT,
    day_of_month INT,
    day_of_year INT,
    week_of_year INT,
    month_name VARCHAR(10),
    month_number INT,
    quarter_number INT,
    year_number INT,
    is_weekend BOOLEAN,
    is_holiday BOOLEAN,
    holiday_name VARCHAR(50)
);

-- 填充时间维度（2020-2030）
CREATE OR REPLACE FUNCTION populate_date_dimension()
RETURNS VOID AS $$
DECLARE
    current_date DATE := '2020-01-01';
    end_date DATE := '2030-12-31';
BEGIN
    WHILE current_date <= end_date LOOP
        INSERT INTO dim_date (
            date_key, date_actual, day_name, day_of_week,
            day_of_month, day_of_year, week_of_year,
            month_name, month_number, quarter_number, year_number,
            is_weekend, is_holiday
        ) VALUES (
            TO_CHAR(current_date, 'YYYYMMDD')::INT,
            current_date,
            TO_CHAR(current_date, 'Day'),
            EXTRACT(DOW FROM current_date),
            EXTRACT(DAY FROM current_date),
            EXTRACT(DOY FROM current_date),
            EXTRACT(WEEK FROM current_date),
            TO_CHAR(current_date, 'Month'),
            EXTRACT(MONTH FROM current_date),
            EXTRACT(QUARTER FROM current_date),
            EXTRACT(YEAR FROM current_date),
            EXTRACT(DOW FROM current_date) IN (0, 6),
            FALSE
        )
        ON CONFLICT (date_key) DO NOTHING;

        current_date := current_date + INTERVAL '1 day';
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT populate_date_dimension();
```

---

### 7.3 物化视图优化

```sql
-- 创建物化视图（预聚合）
CREATE MATERIALIZED VIEW mv_sales_monthly AS
SELECT
    d.year_number,
    d.month_number,
    p.category_name,
    SUM(f.sales_amount) AS total_sales,
    SUM(f.sales_quantity) AS total_quantity,
    COUNT(*) AS transaction_count
FROM fact_sales f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_product p ON f.product_key = p.product_key
GROUP BY d.year_number, d.month_number, p.category_name;

-- 创建索引
CREATE INDEX idx_mv_sales_monthly_date ON mv_sales_monthly(year_number, month_number);
CREATE INDEX idx_mv_sales_monthly_category ON mv_sales_monthly(category_name);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_monthly;
```

---

## 8. 实际应用案例 / Practical Application Examples

### 8.1 案例1: 销售分析星型模式

**完整销售分析星型模式**:

```sql
-- 维度表：日期维度
CREATE TABLE dim_date (
    date_key SERIAL PRIMARY KEY,
    date_value DATE NOT NULL UNIQUE,
    year_number INT NOT NULL,
    quarter_number INT NOT NULL,
    month_number INT NOT NULL,
    week_number INT NOT NULL,
    day_of_week INT NOT NULL,
    is_weekend BOOLEAN NOT NULL,
    is_holiday BOOLEAN DEFAULT FALSE
);

-- 维度表：产品维度
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_code VARCHAR(50) UNIQUE NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_name VARCHAR(100),
    brand_name VARCHAR(100),
    unit_price NUMERIC(10,2),
    is_current BOOLEAN DEFAULT TRUE,
    valid_from DATE NOT NULL,
    valid_to DATE
);

-- 维度表：客户维度
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    customer_name VARCHAR(200),
    customer_type VARCHAR(50),
    region VARCHAR(100),
    city VARCHAR(100),
    is_current BOOLEAN DEFAULT TRUE
);

-- 事实表：销售事实
CREATE TABLE fact_sales (
    sale_id BIGSERIAL,
    date_key INT NOT NULL REFERENCES dim_date(date_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    sales_amount NUMERIC(10,2) NOT NULL,
    sales_quantity INT NOT NULL,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    cost_amount NUMERIC(10,2),
    profit_amount NUMERIC(10,2),
    sale_timestamp TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (sale_id, date_key)
) PARTITION BY RANGE (date_key);

-- 查询：销售分析
SELECT
    d.year_number,
    d.month_number,
    p.category_name,
    c.region,
    SUM(f.sales_amount) AS total_sales,
    SUM(f.sales_quantity) AS total_quantity,
    COUNT(*) AS transaction_count,
    AVG(f.sales_amount) AS avg_sale_amount
FROM fact_sales f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_product p ON f.product_key = p.product_key
JOIN dim_customer c ON f.customer_key = c.customer_key
WHERE d.year_number = 2024
GROUP BY d.year_number, d.month_number, p.category_name, c.region
ORDER BY total_sales DESC;
```

### 8.2 案例2: 库存分析星型模式

**库存分析星型模式**:

```sql
-- 维度表：时间维度
CREATE TABLE dim_time (
    time_key SERIAL PRIMARY KEY,
    time_value TIMESTAMPTZ NOT NULL UNIQUE,
    hour_number INT NOT NULL,
    day_of_month INT NOT NULL,
    month_number INT NOT NULL,
    year_number INT NOT NULL
);

-- 维度表：仓库维度
CREATE TABLE dim_warehouse (
    warehouse_key SERIAL PRIMARY KEY,
    warehouse_id INT NOT NULL UNIQUE,
    warehouse_name VARCHAR(200) NOT NULL,
    location VARCHAR(200),
    warehouse_type VARCHAR(50)
);

-- 事实表：库存快照事实
CREATE TABLE fact_inventory_snapshot (
    snapshot_id BIGSERIAL,
    time_key INT NOT NULL REFERENCES dim_time(time_key),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    warehouse_key INT NOT NULL REFERENCES dim_warehouse(warehouse_key),
    quantity_on_hand INT NOT NULL,
    quantity_available INT NOT NULL,
    quantity_reserved INT DEFAULT 0,
    cost_value NUMERIC(10,2),
    snapshot_date DATE NOT NULL,
    PRIMARY KEY (snapshot_id, snapshot_date)
) PARTITION BY RANGE (snapshot_date);

-- 查询：库存分析
SELECT
    t.year_number,
    t.month_number,
    p.category_name,
    w.warehouse_name,
    AVG(f.quantity_on_hand) AS avg_inventory,
    SUM(f.cost_value) AS total_inventory_value
FROM fact_inventory_snapshot f
JOIN dim_time t ON f.time_key = t.time_key
JOIN dim_product p ON f.product_key = p.product_key
JOIN dim_warehouse w ON f.warehouse_key = w.warehouse_key
WHERE t.year_number = 2024
GROUP BY t.year_number, t.month_number, p.category_name, w.warehouse_name;
```

### 8.3 案例3: 客户分析星型模式

**客户分析星型模式**:

```sql
-- 维度表：客户细分维度
CREATE TABLE dim_customer_segment (
    segment_key SERIAL PRIMARY KEY,
    segment_name VARCHAR(100) NOT NULL UNIQUE,
    segment_description TEXT,
    priority_level INT
);

-- 事实表：客户行为事实
CREATE TABLE fact_customer_behavior (
    behavior_id BIGSERIAL,
    date_key INT NOT NULL REFERENCES dim_date(date_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    segment_key INT REFERENCES dim_customer_segment(segment_key),
    page_views INT DEFAULT 0,
    sessions INT DEFAULT 0,
    orders_count INT DEFAULT 0,
    total_spent NUMERIC(10,2) DEFAULT 0,
    avg_order_value NUMERIC(10,2),
    behavior_date DATE NOT NULL,
    PRIMARY KEY (behavior_id, behavior_date)
) PARTITION BY RANGE (behavior_date);

-- 查询：客户分析
SELECT
    d.year_number,
    cs.segment_name,
    COUNT(DISTINCT f.customer_key) AS customer_count,
    SUM(f.page_views) AS total_page_views,
    SUM(f.orders_count) AS total_orders,
    SUM(f.total_spent) AS total_revenue,
    AVG(f.avg_order_value) AS avg_order_value
FROM fact_customer_behavior f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_customer_segment cs ON f.segment_key = cs.segment_key
WHERE d.year_number = 2024
GROUP BY d.year_number, cs.segment_name
ORDER BY total_revenue DESC;
```

---

## 9. 性能优化与监控 / Performance Optimization and Monitoring

### 9.1 星型模式性能优化

**索引优化**:

```sql
-- 事实表索引
CREATE INDEX idx_fact_sales_date_product ON fact_sales(date_key, product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);
CREATE INDEX idx_fact_sales_date ON fact_sales(date_key);

-- 维度表索引
CREATE INDEX idx_dim_product_category ON dim_product(category_name) WHERE is_current = TRUE;
CREATE INDEX idx_dim_customer_region ON dim_customer(region);
CREATE INDEX idx_dim_date_year_month ON dim_date(year_number, month_number);
```

**物化视图优化**:

```sql
-- 创建预聚合视图
CREATE MATERIALIZED VIEW mv_sales_monthly_summary AS
SELECT
    d.year_number,
    d.month_number,
    p.category_name,
    SUM(f.sales_amount) AS total_sales,
    SUM(f.sales_quantity) AS total_quantity,
    COUNT(*) AS transaction_count
FROM fact_sales f
JOIN dim_date d ON f.date_key = d.date_key
JOIN dim_product p ON f.product_key = p.product_key
GROUP BY d.year_number, d.month_number, p.category_name;

CREATE UNIQUE INDEX ON mv_sales_monthly_summary(year_number, month_number, category_name);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_monthly_summary;
```

### 9.2 查询性能监控

**监控查询性能**:

```sql
-- 使用pg_stat_statements监控
SELECT
    LEFT(query, 100) AS query_preview,
    calls,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%fact_sales%'
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 监控物化视图使用情况
SELECT
    schemaname,
    matviewname,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||matviewname)) AS size,
    last_refresh_time
FROM pg_matviews
WHERE schemaname = 'public';
```

---

## 10. 常见问题解答 / FAQ

### Q1: 星型模式和雪花模式如何选择？

**A**: 选择原则：

| 特性 | 星型模式 | 雪花模式 |
|------|---------|---------|
| 查询性能 | ✅ 更快 | ⚠️ 较慢 |
| 存储空间 | ⚠️ 较大 | ✅ 较小 |
| 维护复杂度 | ✅ 简单 | ⚠️ 复杂 |
| 规范化程度 | ❌ 低 | ✅ 高 |

**建议**:

- 优先使用星型模式（查询性能更好）
- 仅在维度表很大且需要规范化时使用雪花模式

### Q2: 如何确定事实表的粒度？

**A**: 粒度确定原则：

1. **最细粒度**: 选择业务过程的最细粒度
2. **业务需求**: 满足所有业务查询需求
3. **性能考虑**: 粒度越细，事实表越大

**示例**:

- 订单系统 → 订单行级别（每个订单项一行）
- 库存系统 → 仓库×产品×时间点级别

### Q3: 维度表应该包含多少属性？

**A**: 属性数量原则：

- **推荐**: 20-50个属性
- **最多**: 不超过100个属性
- **原则**: 包含所有业务查询需要的属性

**优化策略**:

- 常用属性放在维度表
- 不常用属性使用杂项维度或Junk维度

### Q4: 如何优化星型模式查询性能？

**A**: 优化策略：

1. **物化视图**: 预计算常用聚合
2. **索引优化**: 为JOIN列和WHERE条件创建索引
3. **分区优化**: 按时间分区事实表
4. **列存表**: 使用列存表存储事实表

```sql
-- 优化：使用物化视图
CREATE MATERIALIZED VIEW mv_sales_daily AS
SELECT date_key, product_key, SUM(sales_amount) AS daily_sales
FROM fact_sales
GROUP BY date_key, product_key;

-- 查询时使用物化视图
SELECT * FROM mv_sales_daily WHERE date_key = 12345;
```

### Q5: 如何处理维度表的缓慢变化？

**A**: SCD处理策略：

```sql
-- SCD Type 2：保留历史版本
CREATE TABLE dim_product_scd2 (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_name VARCHAR(100),
    valid_from DATE NOT NULL,
    valid_to DATE,
    is_current BOOLEAN DEFAULT TRUE
);

-- 查询当前版本
SELECT * FROM dim_product_scd2 WHERE is_current = TRUE;

-- 查询历史版本
SELECT * FROM dim_product_scd2
WHERE product_id = 123
  AND valid_from <= '2024-06-01'
  AND (valid_to IS NULL OR valid_to >= '2024-06-01');
```

---

## 11. 相关资源 / Related Resources

### 11.1 核心相关文档 / Core Related Documents

- [事实表技术](./事实表技术.md) - 事实表设计技术详解
- [维度表技术](./维度表技术.md) - 维度表设计技术详解
- [PostgreSQL列存实现](./PostgreSQL列存实现.md) - 列存表实现OLAP
- [分区策略](../08-PostgreSQL建模实践/分区策略.md) - 事实表分区策略
- [索引策略](../08-PostgreSQL建模实践/索引策略.md) - 星型模式索引设计
- [性能优化](../08-PostgreSQL建模实践/性能优化.md) - OLAP查询性能优化

### 11.2 理论基础 / Theoretical Foundation

- [Kimball维度建模](../02-权威资源与标准/Kimball维度建模.md) - Kimball维度建模理论
- [范式理论](../01-数据建模理论基础/范式理论.md) - 数据库范式理论（OLAP反范式化）

### 11.3 实践指南 / Practical Guides

- [性能优化与监控](#9-性能优化与监控--performance-optimization-and-monitoring) - 本文档的性能监控章节
- [实际应用案例](#8-实际应用案例--practical-application-examples) - 本文档的应用案例章节

### 11.4 应用案例 / Application Cases

- [电商数据模型案例](../10-综合应用案例/电商数据模型案例.md) - 电商OLAP分析案例
- [金融数据模型案例](../10-综合应用案例/金融数据模型案例.md) - 金融OLAP分析案例

### 11.5 参考资源 / Reference Resources

- [权威资源索引](../00-导航与索引/权威资源索引.md) - 权威资源列表
- [术语对照表](../00-导航与索引/术语对照表.md) - 术语对照
- [快速查找指南](../00-导航与索引/快速查找指南.md) - 快速查找工具
- PostgreSQL官方文档: [Materialized Views](https://www.postgresql.org/docs/current/sql-creatematerializedview.html)

- [Kimball维度建模](../02-权威资源与标准/Kimball维度建模.md) - 维度建模权威指南
- [事实表技术](./事实表技术.md) - 事实表设计技术
- [维度表技术](./维度表技术.md) - 维度表设计技术
- [索引策略](../08-PostgreSQL建模实践/索引策略.md) - 维度表索引策略
- [分区策略](../08-PostgreSQL建模实践/分区策略.md) - 事实表分区策略

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
