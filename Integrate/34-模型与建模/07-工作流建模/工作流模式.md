# å·¥ä½œæµæ¨¡å¼

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: å·¥ä½œæµæ¨¡å¼ç ”ç©¶
> **çŠ¶æ€**: å¾…å®Œå–„
> **æ–‡æ¡£ç¼–å·**: 07-04

---

## ğŸ“‘ ç›®å½•

- [å·¥ä½œæµæ¨¡å¼](#å·¥ä½œæµæ¨¡å¼)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. é¡ºåºæ¨¡å¼](#2-é¡ºåºæ¨¡å¼)
    - [2.1 é¡ºåºæ¨¡å¼å®šä¹‰](#21-é¡ºåºæ¨¡å¼å®šä¹‰)
    - [2.2 PostgreSQLå®ç°](#22-postgresqlå®ç°)
    - [2.3 é¡ºåºæ‰§è¡Œå‡½æ•°](#23-é¡ºåºæ‰§è¡Œå‡½æ•°)
  - [3. å¹¶è¡Œæ¨¡å¼](#3-å¹¶è¡Œæ¨¡å¼)
    - [3.1 å¹¶è¡Œæ¨¡å¼å®šä¹‰](#31-å¹¶è¡Œæ¨¡å¼å®šä¹‰)
    - [3.2 PostgreSQLå®ç°](#32-postgresqlå®ç°)
  - [4. é€‰æ‹©æ¨¡å¼](#4-é€‰æ‹©æ¨¡å¼)
    - [4.1 é€‰æ‹©æ¨¡å¼å®šä¹‰](#41-é€‰æ‹©æ¨¡å¼å®šä¹‰)
    - [4.2 PostgreSQLå®ç°](#42-postgresqlå®ç°)
  - [5. å¾ªç¯æ¨¡å¼](#5-å¾ªç¯æ¨¡å¼)
    - [5.1 å¾ªç¯æ¨¡å¼å®šä¹‰](#51-å¾ªç¯æ¨¡å¼å®šä¹‰)
    - [5.2 PostgreSQLå®ç°](#52-postgresqlå®ç°)
  - [6. PostgreSQLå®ç°](#6-postgresqlå®ç°)
    - [6.1 ç»¼åˆå·¥ä½œæµå¼•æ“](#61-ç»¼åˆå·¥ä½œæµå¼•æ“)
  - [7. ç›¸å…³èµ„æº](#7-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

å·¥ä½œæµæ¨¡å¼å®šä¹‰äº†å¸¸è§çš„å·¥ä½œæµæ§åˆ¶ç»“æ„ï¼Œæ˜¯æ„å»ºå¤æ‚ä¸šåŠ¡æµç¨‹çš„åŸºç¡€ã€‚
è¿™äº›æ¨¡å¼æ˜¯ç»è¿‡éªŒè¯çš„ã€å¯é‡ç”¨çš„å·¥ä½œæµè®¾è®¡è§£å†³æ–¹æ¡ˆã€‚

**æ ¸å¿ƒä»·å€¼**:

- **æ ‡å‡†åŒ–**ï¼šæä¾›æ ‡å‡†çš„å·¥ä½œæµæ§åˆ¶ç»“æ„
- **å¯é‡ç”¨**ï¼šæ¨¡å¼å¯ä»¥åœ¨ä¸åŒåœºæ™¯ä¸­é‡ç”¨
- **å¯ç»„åˆ**ï¼šå¤šä¸ªæ¨¡å¼å¯ä»¥ç»„åˆæˆå¤æ‚æµç¨‹
- **å¯ç»´æŠ¤**ï¼šæ ‡å‡†æ¨¡å¼æ˜“äºç†è§£å’Œç»´æŠ¤

---

## 2. é¡ºåºæ¨¡å¼

### 2.1 é¡ºåºæ¨¡å¼å®šä¹‰

**é¡ºåºæ¨¡å¼ï¼ˆSequence Patternï¼‰**ï¼šä»»åŠ¡æŒ‰å›ºå®šé¡ºåºä¾æ¬¡æ‰§è¡Œï¼Œå‰ä¸€ä¸ªä»»åŠ¡å®Œæˆåæ‰èƒ½æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚

**ç‰¹ç‚¹**:

- ä¸¥æ ¼çš„æ‰§è¡Œé¡ºåº
- å‰é©±ä»»åŠ¡å®Œæˆåæ‰èƒ½å¼€å§‹åç»­ä»»åŠ¡
- é€‚ç”¨äºæœ‰ä¾èµ–å…³ç³»çš„ä»»åŠ¡é“¾

### 2.2 PostgreSQLå®ç°

**é¡ºåºå·¥ä½œæµè¡¨è®¾è®¡**:

```sql
-- å·¥ä½œæµå®šä¹‰è¡¨
CREATE TABLE workflow_definition (
    workflow_id SERIAL PRIMARY KEY,
    workflow_name VARCHAR(200) NOT NULL,
    workflow_type VARCHAR(50) NOT NULL, -- 'sequence', 'parallel', 'choice', 'loop'
    definition JSONB NOT NULL,
    version INT DEFAULT 1,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å·¥ä½œæµå®ä¾‹è¡¨
CREATE TABLE workflow_instance (
    instance_id BIGSERIAL PRIMARY KEY,
    workflow_id INT NOT NULL REFERENCES workflow_definition(workflow_id),
    current_step INT DEFAULT 1,
    status VARCHAR(50) DEFAULT 'running', -- 'running', 'completed', 'failed', 'cancelled'
    context JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ
);

-- å·¥ä½œæµæ­¥éª¤è¡¨
CREATE TABLE workflow_step (
    step_id SERIAL PRIMARY KEY,
    workflow_id INT NOT NULL REFERENCES workflow_definition(workflow_id),
    step_order INT NOT NULL,
    step_name VARCHAR(200) NOT NULL,
    step_type VARCHAR(50), -- 'task', 'sub_workflow'
    handler_function VARCHAR(200),
    is_required BOOLEAN DEFAULT TRUE,
    UNIQUE(workflow_id, step_order)
);

-- å·¥ä½œæµæ‰§è¡Œå†å²è¡¨
CREATE TABLE workflow_execution_history (
    history_id BIGSERIAL PRIMARY KEY,
    instance_id BIGINT NOT NULL REFERENCES workflow_instance(instance_id),
    step_id INT NOT NULL REFERENCES workflow_step(step_id),
    status VARCHAR(50) NOT NULL, -- 'started', 'completed', 'failed'
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    result JSONB,
    error_message TEXT
);

-- é¡ºåºå·¥ä½œæµå®šä¹‰ç¤ºä¾‹
INSERT INTO workflow_definition (workflow_name, workflow_type, definition) VALUES (
    'è®¢å•å¤„ç†æµç¨‹',
    'sequence',
    '{
        "steps": [
            {"order": 1, "name": "éªŒè¯è®¢å•", "handler": "validate_order"},
            {"order": 2, "name": "å¤„ç†æ”¯ä»˜", "handler": "process_payment"},
            {"order": 3, "name": "å‡†å¤‡å‘è´§", "handler": "prepare_shipment"},
            {"order": 4, "name": "å‘é€é€šçŸ¥", "handler": "send_notification"}
        ]
    }'::JSONB
);
```

### 2.3 é¡ºåºæ‰§è¡Œå‡½æ•°

**é¡ºåºæ‰§è¡Œé€»è¾‘**:

```sql
-- æ‰§è¡Œä¸‹ä¸€æ­¥
CREATE OR REPLACE FUNCTION execute_next_step(
    p_instance_id BIGINT
)
RETURNS BOOLEAN AS $$
DECLARE
    v_workflow_id INT;
    v_current_step INT;
    v_next_step RECORD;
    v_step_handler VARCHAR;
BEGIN
    -- è·å–å½“å‰å·¥ä½œæµä¿¡æ¯
    SELECT workflow_id, current_step INTO v_workflow_id, v_current_step
    FROM workflow_instance
    WHERE instance_id = p_instance_id
      AND status = 'running';

    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    -- è·å–ä¸‹ä¸€æ­¥
    SELECT * INTO v_next_step
    FROM workflow_step
    WHERE workflow_id = v_workflow_id
      AND step_order = v_current_step;

    IF NOT FOUND THEN
        -- å·¥ä½œæµå®Œæˆ
        UPDATE workflow_instance
        SET status = 'completed',
            completed_at = NOW()
        WHERE instance_id = p_instance_id;
        RETURN FALSE;
    END IF;

    -- è®°å½•æ­¥éª¤å¼€å§‹
    INSERT INTO workflow_execution_history (
        instance_id, step_id, status, start_time
    ) VALUES (
        p_instance_id, v_next_step.step_id, 'started', NOW()
    );

    -- æ‰§è¡Œæ­¥éª¤ï¼ˆè¿™é‡Œè°ƒç”¨handlerå‡½æ•°ï¼‰
    -- å®é™…å®ç°ä¸­ï¼Œhandler_functionä¼šæ‰§è¡Œå…·ä½“çš„ä¸šåŠ¡é€»è¾‘
    -- ç¤ºä¾‹ï¼šEXECUTE format('SELECT %s($1)', v_next_step.handler_function) USING p_instance_id;

    -- æ›´æ–°å½“å‰æ­¥éª¤
    UPDATE workflow_instance
    SET current_step = current_step + 1,
        updated_at = NOW()
    WHERE instance_id = p_instance_id;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. å¹¶è¡Œæ¨¡å¼

### 3.1 å¹¶è¡Œæ¨¡å¼å®šä¹‰

**å¹¶è¡Œæ¨¡å¼ï¼ˆParallel Patternï¼‰**ï¼šå¤šä¸ªä»»åŠ¡åŒæ—¶æ‰§è¡Œï¼Œæ‰€æœ‰ä»»åŠ¡å®Œæˆåæ‰èƒ½ç»§ç»­åç»­æµç¨‹ã€‚

**ç‰¹ç‚¹**:

- ä»»åŠ¡å¹¶è¡Œæ‰§è¡Œ
- éœ€è¦ç­‰å¾…æ‰€æœ‰å¹¶è¡Œä»»åŠ¡å®Œæˆ
- é€‚ç”¨äºç‹¬ç«‹çš„ä»»åŠ¡é›†åˆ

### 3.2 PostgreSQLå®ç°

**å¹¶è¡Œå·¥ä½œæµå®šä¹‰**:

```sql
-- å¹¶è¡Œå·¥ä½œæµå®šä¹‰ç¤ºä¾‹
INSERT INTO workflow_definition (workflow_name, workflow_type, definition) VALUES (
    'è®¢å•æ”¯ä»˜åå¤„ç†',
    'parallel',
    '{
        "steps": [
            {"order": 1, "name": "å‘é€é‚®ä»¶é€šçŸ¥", "handler": "send_email", "parallel_group": 1},
            {"order": 1, "name": "å‘é€çŸ­ä¿¡é€šçŸ¥", "handler": "send_sms", "parallel_group": 1},
            {"order": 1, "name": "æ›´æ–°åº“å­˜", "handler": "update_inventory", "parallel_group": 1},
            {"order": 2, "name": "åç»­å¤„ç†", "handler": "post_process"}
        ],
        "parallel_groups": [1]
    }'::JSONB
);

-- å¹¶è¡Œæ­¥éª¤æ‰§è¡ŒçŠ¶æ€è¡¨
CREATE TABLE parallel_step_status (
    status_id BIGSERIAL PRIMARY KEY,
    instance_id BIGINT NOT NULL REFERENCES workflow_instance(instance_id),
    parallel_group INT NOT NULL,
    step_id INT NOT NULL REFERENCES workflow_step(step_id),
    status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'running', 'completed', 'failed'
    start_time TIMESTAMPTZ,
    end_time TIMESTAMPTZ,
    result JSONB
);

-- æ£€æŸ¥å¹¶è¡Œç»„æ˜¯å¦å®Œæˆ
CREATE OR REPLACE FUNCTION check_parallel_group_completed(
    p_instance_id BIGINT,
    p_parallel_group INT
)
RETURNS BOOLEAN AS $$
DECLARE
    v_total_count INT;
    v_completed_count INT;
BEGIN
    -- ç»Ÿè®¡å¹¶è¡Œç»„ä¸­çš„æ­¥éª¤æ€»æ•°
    SELECT COUNT(*) INTO v_total_count
    FROM workflow_step ws
    JOIN workflow_instance wi ON ws.workflow_id = wi.workflow_id
    WHERE wi.instance_id = p_instance_id
      AND (ws.definition->>'parallel_group')::INT = p_parallel_group;

    -- ç»Ÿè®¡å·²å®Œæˆæ­¥éª¤æ•°
    SELECT COUNT(*) INTO v_completed_count
    FROM parallel_step_status
    WHERE instance_id = p_instance_id
      AND parallel_group = p_parallel_group
      AND status = 'completed';

    RETURN v_completed_count = v_total_count;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. é€‰æ‹©æ¨¡å¼

### 4.1 é€‰æ‹©æ¨¡å¼å®šä¹‰

**é€‰æ‹©æ¨¡å¼ï¼ˆChoice Patternï¼‰**ï¼šæ ¹æ®æ¡ä»¶é€‰æ‹©æ‰§è¡Œä¸åŒçš„åˆ†æ”¯ï¼Œåªæœ‰ä¸€ä¸ªåˆ†æ”¯ä¼šè¢«æ‰§è¡Œã€‚

**ç‰¹ç‚¹**:

- åŸºäºæ¡ä»¶çš„åˆ†æ”¯é€‰æ‹©
- äº’æ–¥æ‰§è¡Œ
- é€‚ç”¨äºæ¡ä»¶åˆ¤æ–­åœºæ™¯

### 4.2 PostgreSQLå®ç°

**é€‰æ‹©å·¥ä½œæµå®šä¹‰**:

```sql
-- é€‰æ‹©å·¥ä½œæµå®šä¹‰ç¤ºä¾‹
INSERT INTO workflow_definition (workflow_name, workflow_type, definition) VALUES (
    'è®¢å•å¤„ç†åˆ†æ”¯',
    'choice',
    '{
        "condition": "order_amount > 1000",
        "branches": [
            {
                "condition": "order_amount > 1000",
                "steps": [
                    {"order": 1, "name": "VIPå¤„ç†", "handler": "vip_process"}
                ]
            },
            {
                "condition": "order_amount <= 1000",
                "steps": [
                    {"order": 1, "name": "æ™®é€šå¤„ç†", "handler": "normal_process"}
                ]
            }
        ]
    }'::JSONB
);

-- é€‰æ‹©åˆ†æ”¯æ‰§è¡Œå‡½æ•°
CREATE OR REPLACE FUNCTION execute_choice_branch(
    p_instance_id BIGINT,
    p_condition JSONB
)
RETURNS INT AS $$
DECLARE
    v_workflow_id INT;
    v_context JSONB;
    v_branch RECORD;
    v_matched_branch INT;
BEGIN
    -- è·å–å·¥ä½œæµå’Œä¸Šä¸‹æ–‡
    SELECT wi.workflow_id, wi.context INTO v_workflow_id, v_context
    FROM workflow_instance wi
    WHERE wi.instance_id = p_instance_id;

    -- æŸ¥æ‰¾åŒ¹é…çš„åˆ†æ”¯
    SELECT branch_id INTO v_matched_branch
    FROM jsonb_array_elements(
        (SELECT definition->'branches' FROM workflow_definition WHERE workflow_id = v_workflow_id)
    ) WITH ORDINALITY AS branches(branch, branch_id)
    WHERE evaluate_condition(branch->>'condition', v_context);

    IF v_matched_branch IS NULL THEN
        RAISE EXCEPTION 'No matching branch found';
    END IF;

    RETURN v_matched_branch;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. å¾ªç¯æ¨¡å¼

### 5.1 å¾ªç¯æ¨¡å¼å®šä¹‰

**å¾ªç¯æ¨¡å¼ï¼ˆLoop Patternï¼‰**ï¼šé‡å¤æ‰§è¡ŒæŸäº›ä»»åŠ¡ï¼Œç›´åˆ°æ»¡è¶³é€€å‡ºæ¡ä»¶ã€‚

**ç‰¹ç‚¹**:

- é‡å¤æ‰§è¡Œ
- æœ‰é€€å‡ºæ¡ä»¶
- é€‚ç”¨äºéœ€è¦é‡è¯•æˆ–è¿­ä»£çš„åœºæ™¯

### 5.2 PostgreSQLå®ç°

**å¾ªç¯å·¥ä½œæµå®šä¹‰**:

```sql
-- å¾ªç¯å·¥ä½œæµå®šä¹‰ç¤ºä¾‹
INSERT INTO workflow_definition (workflow_name, workflow_type, definition) VALUES (
    'é‡è¯•æ”¯ä»˜æµç¨‹',
    'loop',
    '{
        "max_iterations": 3,
        "exit_condition": "payment_status = ''success''",
        "steps": [
            {"order": 1, "name": "å°è¯•æ”¯ä»˜", "handler": "attempt_payment"},
            {"order": 2, "name": "æ£€æŸ¥ç»“æœ", "handler": "check_result"}
        ]
    }'::JSONB
);

-- å¾ªç¯æ‰§è¡Œå‡½æ•°
CREATE OR REPLACE FUNCTION execute_loop_workflow(
    p_instance_id BIGINT
)
RETURNS VOID AS $$
DECLARE
    v_workflow_def JSONB;
    v_max_iterations INT;
    v_current_iteration INT := 0;
    v_exit_condition TEXT;
    v_context JSONB;
    v_should_exit BOOLEAN := FALSE;
BEGIN
    -- è·å–å·¥ä½œæµå®šä¹‰
    SELECT wd.definition, wi.context INTO v_workflow_def, v_context
    FROM workflow_instance wi
    JOIN workflow_definition wd ON wi.workflow_id = wd.workflow_id
    WHERE wi.instance_id = p_instance_id;

    v_max_iterations := (v_workflow_def->>'max_iterations')::INT;
    v_exit_condition := v_workflow_def->>'exit_condition';

    -- å¾ªç¯æ‰§è¡Œ
    WHILE v_current_iteration < v_max_iterations AND NOT v_should_exit LOOP
        v_current_iteration := v_current_iteration + 1;

        -- æ‰§è¡Œå¾ªç¯ä½“å†…çš„æ­¥éª¤
        PERFORM execute_workflow_steps(p_instance_id, v_workflow_def->'steps');

        -- æ£€æŸ¥é€€å‡ºæ¡ä»¶
        SELECT evaluate_condition(v_exit_condition, v_context) INTO v_should_exit;

        -- æ›´æ–°ä¸Šä¸‹æ–‡
        UPDATE workflow_instance
        SET context = context || jsonb_build_object('iteration', v_current_iteration),
            updated_at = NOW()
        WHERE instance_id = p_instance_id;
    END LOOP;

    -- å¦‚æœè¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•°ä»æœªé€€å‡ºï¼Œæ ‡è®°ä¸ºå¤±è´¥
    IF NOT v_should_exit THEN
        UPDATE workflow_instance
        SET status = 'failed',
            context = context || jsonb_build_object('error', 'Max iterations reached')
        WHERE instance_id = p_instance_id;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. PostgreSQLå®ç°

### 6.1 ç»¼åˆå·¥ä½œæµå¼•æ“

**å®Œæ•´å·¥ä½œæµç³»ç»Ÿ**:

```sql
-- å·¥ä½œæµæ‰§è¡Œå¼•æ“ä¸»å‡½æ•°
CREATE OR REPLACE FUNCTION execute_workflow(
    p_instance_id BIGINT
)
RETURNS VOID AS $$
DECLARE
    v_workflow_type VARCHAR;
    v_workflow_def JSONB;
BEGIN
    -- è·å–å·¥ä½œæµç±»å‹å’Œå®šä¹‰
    SELECT wd.workflow_type, wd.definition INTO v_workflow_type, v_workflow_def
    FROM workflow_instance wi
    JOIN workflow_definition wd ON wi.workflow_id = wd.workflow_id
    WHERE wi.instance_id = p_instance_id
      AND wi.status = 'running';

    -- æ ¹æ®ç±»å‹æ‰§è¡Œä¸åŒçš„æ¨¡å¼
    CASE v_workflow_type
        WHEN 'sequence' THEN
            PERFORM execute_sequence_workflow(p_instance_id);
        WHEN 'parallel' THEN
            PERFORM execute_parallel_workflow(p_instance_id);
        WHEN 'choice' THEN
            PERFORM execute_choice_workflow(p_instance_id);
        WHEN 'loop' THEN
            PERFORM execute_loop_workflow(p_instance_id);
        ELSE
            RAISE EXCEPTION 'Unknown workflow type: %', v_workflow_type;
    END CASE;
END;
$$ LANGUAGE plpgsql;

-- å·¥ä½œæµçŠ¶æ€æŸ¥è¯¢è§†å›¾
CREATE VIEW workflow_status_view AS
SELECT
    wi.instance_id,
    wd.workflow_name,
    wi.status,
    wi.current_step,
    wi.created_at,
    wi.updated_at,
    wi.completed_at,
    -- æ‰§è¡Œè¿›åº¦
    (
        SELECT COUNT(*)
        FROM workflow_execution_history weh
        WHERE weh.instance_id = wi.instance_id
          AND weh.status = 'completed'
    ) AS completed_steps,
    (
        SELECT COUNT(*)
        FROM workflow_step ws
        WHERE ws.workflow_id = wi.workflow_id
    ) AS total_steps
FROM workflow_instance wi
JOIN workflow_definition wd ON wi.workflow_id = wd.workflow_id;
```

---

## 7. ç›¸å…³èµ„æº

- [çŠ¶æ€æœºå»ºæ¨¡](./çŠ¶æ€æœºå»ºæ¨¡.md) - çŠ¶æ€æœºå»ºæ¨¡åŸºç¡€
- [JSONBçŠ¶æ€æœºå®ç°](./JSONBçŠ¶æ€æœºå®ç°.md) - JSONBå®ç°çŠ¶æ€æœº
- [BPMNå»ºæ¨¡](./BPMNå»ºæ¨¡.md) - BPMNæ ‡å‡†å»ºæ¨¡
- [å·¥ä½œæµæ¨¡å¼ç ”ç©¶](https://www.workflowpatterns.com/) - å·¥ä½œæµæ¨¡å¼æƒå¨èµ„æº

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
