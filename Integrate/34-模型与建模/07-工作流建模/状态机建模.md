# çŠ¶æ€æœºå»ºæ¨¡

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: çŠ¶æ€æœºç†è®º
> **çŠ¶æ€**: å¾…å®Œå–„
> **æ–‡æ¡£ç¼–å·**: 07-02

---

## ğŸ“‘ ç›®å½•

- [çŠ¶æ€æœºå»ºæ¨¡](#çŠ¶æ€æœºå»ºæ¨¡)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. çŠ¶æ€æœºåŸºç¡€](#2-çŠ¶æ€æœºåŸºç¡€)
    - [2.1 çŠ¶æ€æœºè¦ç´ ](#21-çŠ¶æ€æœºè¦ç´ )
    - [2.2 çŠ¶æ€æœºç±»å‹](#22-çŠ¶æ€æœºç±»å‹)
    - [2.3 çŠ¶æ€æœºè¡¨ç¤º](#23-çŠ¶æ€æœºè¡¨ç¤º)
  - [3. çŠ¶æ€è½¬æ¢è®¾è®¡](#3-çŠ¶æ€è½¬æ¢è®¾è®¡)
    - [3.1 çŠ¶æ€å®šä¹‰](#31-çŠ¶æ€å®šä¹‰)
    - [3.2 è½¬æ¢è§„åˆ™å®šä¹‰](#32-è½¬æ¢è§„åˆ™å®šä¹‰)
    - [3.3 çŠ¶æ€è½¬æ¢å†å²](#33-çŠ¶æ€è½¬æ¢å†å²)
  - [4. çŠ¶æ€éªŒè¯](#4-çŠ¶æ€éªŒè¯)
    - [4.1 çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°](#41-çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°)
    - [4.2 çŠ¶æ€è½¬æ¢æ‰§è¡Œå‡½æ•°](#42-çŠ¶æ€è½¬æ¢æ‰§è¡Œå‡½æ•°)
  - [5. PostgreSQLå®ç°](#5-postgresqlå®ç°)
    - [5.1 å®Œæ•´çŠ¶æ€æœºç³»ç»Ÿ](#51-å®Œæ•´çŠ¶æ€æœºç³»ç»Ÿ)
    - [5.2 çŠ¶æ€æœºè§¦å‘å™¨](#52-çŠ¶æ€æœºè§¦å‘å™¨)
    - [5.3 çŠ¶æ€æŸ¥è¯¢è§†å›¾](#53-çŠ¶æ€æŸ¥è¯¢è§†å›¾)
  - [6. ç›¸å…³èµ„æº](#6-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

çŠ¶æ€æœºå»ºæ¨¡ç”¨äºæè¿°ç³»ç»Ÿæˆ–å¯¹è±¡çš„çŠ¶æ€å˜åŒ–è¿‡ç¨‹ï¼Œæ˜¯å·¥ä½œæµå»ºæ¨¡çš„åŸºç¡€ã€‚
æœ‰é™çŠ¶æ€æœºï¼ˆFinite State Machine, FSMï¼‰æ˜¯ä¸€ç§è®¡ç®—æ¨¡å‹ï¼Œé€šè¿‡çŠ¶æ€ã€äº‹ä»¶å’Œè½¬æ¢æ¥æè¿°ç³»ç»Ÿè¡Œä¸ºã€‚

**æ ¸å¿ƒä»·å€¼**:

- **è¡Œä¸ºå»ºæ¨¡**ï¼šæ¸…æ™°æè¿°ç³»ç»ŸçŠ¶æ€å˜åŒ–
- **è§„åˆ™éªŒè¯**ï¼šç¡®ä¿çŠ¶æ€è½¬æ¢ç¬¦åˆä¸šåŠ¡è§„åˆ™
- **æµç¨‹æ§åˆ¶**ï¼šå®ç°å¤æ‚ä¸šåŠ¡æµç¨‹çš„çŠ¶æ€ç®¡ç†
- **é”™è¯¯å¤„ç†**ï¼šå®šä¹‰å¼‚å¸¸çŠ¶æ€å’Œæ¢å¤æœºåˆ¶

---

## 2. çŠ¶æ€æœºåŸºç¡€

### 2.1 çŠ¶æ€æœºè¦ç´ 

**çŠ¶æ€æœºä¸‰è¦ç´ **:

| è¦ç´  | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| çŠ¶æ€ï¼ˆStateï¼‰ | ç³»ç»Ÿåœ¨æŸä¸€æ—¶åˆ»çš„æ¡ä»¶ | å¾…å¤„ç†ã€å¤„ç†ä¸­ã€å·²å®Œæˆ |
| äº‹ä»¶ï¼ˆEventï¼‰ | å¼•èµ·çŠ¶æ€è½¬æ¢çš„è§¦å‘å™¨ | å¼€å§‹å¤„ç†ã€å®Œæˆå¤„ç†ã€å–æ¶ˆ |
| è½¬æ¢ï¼ˆTransitionï¼‰ | çŠ¶æ€ä¹‹é—´çš„å˜åŒ–è·¯å¾„ | å¾…å¤„ç† â†’ å¤„ç†ä¸­ |

### 2.2 çŠ¶æ€æœºç±»å‹

**çŠ¶æ€æœºåˆ†ç±»**:

- **æœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰**ï¼šçŠ¶æ€æ•°é‡æœ‰é™
- **å±‚æ¬¡çŠ¶æ€æœºï¼ˆHSMï¼‰**ï¼šæ”¯æŒçŠ¶æ€çš„å±‚æ¬¡ç»“æ„
- **å¹¶å‘çŠ¶æ€æœº**ï¼šå¤šä¸ªçŠ¶æ€æœºå¹¶è¡Œè¿è¡Œ
- **çŠ¶æ€å›¾ï¼ˆStatechartï¼‰**ï¼šæ‰©å±•çš„çŠ¶æ€æœºï¼Œæ”¯æŒå¤åˆçŠ¶æ€

### 2.3 çŠ¶æ€æœºè¡¨ç¤º

**çŠ¶æ€è½¬æ¢å›¾ç¤ºä¾‹**:

```text
         [åˆ›å»ºè®¢å•]
             |
             v
        [å¾…å¤„ç†] --[å¼€å§‹å¤„ç†]--> [å¤„ç†ä¸­]
             |                      |
             |                      v
             |                  [å·²å®Œæˆ]
             |
             v
        [å·²å–æ¶ˆ]
```

---

## 3. çŠ¶æ€è½¬æ¢è®¾è®¡

### 3.1 çŠ¶æ€å®šä¹‰

**çŠ¶æ€è¡¨è®¾è®¡**:

```sql
-- çŠ¶æ€å®šä¹‰è¡¨
CREATE TABLE state_definition (
    state_id SERIAL PRIMARY KEY,
    state_machine_name VARCHAR(100) NOT NULL,
    state_name VARCHAR(100) NOT NULL,
    state_type VARCHAR(50), -- 'initial', 'normal', 'final', 'error'
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    UNIQUE(state_machine_name, state_name)
);

-- ç¤ºä¾‹ï¼šè®¢å•çŠ¶æ€æœº
INSERT INTO state_definition (state_machine_name, state_name, state_type, description) VALUES
    ('order', 'pending', 'initial', 'è®¢å•å¾…å¤„ç†'),
    ('order', 'processing', 'normal', 'è®¢å•å¤„ç†ä¸­'),
    ('order', 'completed', 'final', 'è®¢å•å·²å®Œæˆ'),
    ('order', 'cancelled', 'final', 'è®¢å•å·²å–æ¶ˆ'),
    ('order', 'error', 'error', 'è®¢å•å¤„ç†é”™è¯¯');
```

### 3.2 è½¬æ¢è§„åˆ™å®šä¹‰

**çŠ¶æ€è½¬æ¢è§„åˆ™è¡¨**:

```sql
-- çŠ¶æ€è½¬æ¢è§„åˆ™è¡¨
CREATE TABLE state_transition_rule (
    rule_id SERIAL PRIMARY KEY,
    state_machine_name VARCHAR(100) NOT NULL,
    from_state VARCHAR(100) NOT NULL,
    to_state VARCHAR(100) NOT NULL,
    event_name VARCHAR(100) NOT NULL,
    -- è½¬æ¢æ¡ä»¶ï¼ˆJSONBå­˜å‚¨å¤æ‚æ¡ä»¶ï¼‰
    condition JSONB,
    -- è½¬æ¢åŠ¨ä½œ
    action TEXT,
    -- æƒé™æ£€æŸ¥
    required_role VARCHAR(100),
    is_enabled BOOLEAN DEFAULT TRUE,
    UNIQUE(state_machine_name, from_state, event_name)
);

-- ç¤ºä¾‹ï¼šè®¢å•çŠ¶æ€è½¬æ¢è§„åˆ™
INSERT INTO state_transition_rule (
    state_machine_name, from_state, to_state, event_name, condition, required_role
) VALUES
    ('order', 'pending', 'processing', 'start_processing', NULL, 'operator'),
    ('order', 'processing', 'completed', 'complete', '{"all_items_shipped": true}', 'operator'),
    ('order', 'pending', 'cancelled', 'cancel', NULL, 'customer'),
    ('order', 'processing', 'cancelled', 'cancel', '{"allow_cancel": true}', 'customer'),
    ('order', 'processing', 'error', 'error_occurred', NULL, 'system');
```

### 3.3 çŠ¶æ€è½¬æ¢å†å²

**çŠ¶æ€è½¬æ¢å†å²è¡¨**:

```sql
-- çŠ¶æ€è½¬æ¢å†å²è¡¨
CREATE TABLE state_transition_history (
    history_id BIGSERIAL PRIMARY KEY,
    entity_type VARCHAR(100) NOT NULL, -- 'order', 'task', etc.
    entity_id BIGINT NOT NULL,
    from_state VARCHAR(100),
    to_state VARCHAR(100) NOT NULL,
    event_name VARCHAR(100) NOT NULL,
    -- è½¬æ¢ä¸Šä¸‹æ–‡
    context JSONB,
    -- æ“ä½œä¿¡æ¯
    operator_id VARCHAR(100),
    operator_name VARCHAR(200),
    -- æ—¶é—´æˆ³
    transition_time TIMESTAMPTZ DEFAULT NOW(),
    -- å¤‡æ³¨
    notes TEXT
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_transition_history_entity ON state_transition_history(entity_type, entity_id, transition_time DESC);
CREATE INDEX idx_transition_history_state ON state_transition_history(to_state, transition_time DESC);
```

---

## 4. çŠ¶æ€éªŒè¯

### 4.1 çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°

**éªŒè¯å‡½æ•°**:

```sql
-- éªŒè¯çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
CREATE OR REPLACE FUNCTION validate_state_transition(
    p_state_machine_name VARCHAR,
    p_from_state VARCHAR,
    p_to_state VARCHAR,
    p_event_name VARCHAR,
    p_context JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
DECLARE
    v_rule_exists BOOLEAN;
    v_condition_met BOOLEAN := TRUE;
BEGIN
    -- æ£€æŸ¥è½¬æ¢è§„åˆ™æ˜¯å¦å­˜åœ¨
    SELECT EXISTS(
        SELECT 1 FROM state_transition_rule
        WHERE state_machine_name = p_state_machine_name
          AND from_state = p_from_state
          AND to_state = p_to_state
          AND event_name = p_event_name
          AND is_enabled = TRUE
    ) INTO v_rule_exists;

    IF NOT v_rule_exists THEN
        RETURN FALSE;
    END IF;

    -- æ£€æŸ¥è½¬æ¢æ¡ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
    IF p_context IS NOT NULL THEN
        SELECT EXISTS(
            SELECT 1 FROM state_transition_rule
            WHERE state_machine_name = p_state_machine_name
              AND from_state = p_from_state
              AND to_state = p_to_state
              AND event_name = p_event_name
              AND (condition IS NULL OR condition <@ p_context)
        ) INTO v_condition_met;
    END IF;

    RETURN v_rule_exists AND v_condition_met;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 çŠ¶æ€è½¬æ¢æ‰§è¡Œå‡½æ•°

**æ‰§è¡ŒçŠ¶æ€è½¬æ¢**:

```sql
-- æ‰§è¡ŒçŠ¶æ€è½¬æ¢
CREATE OR REPLACE FUNCTION execute_state_transition(
    p_entity_type VARCHAR,
    p_entity_id BIGINT,
    p_state_machine_name VARCHAR,
    p_event_name VARCHAR,
    p_context JSONB DEFAULT NULL,
    p_operator_id VARCHAR DEFAULT NULL,
    p_operator_name VARCHAR DEFAULT NULL,
    p_notes TEXT DEFAULT NULL
)
RETURNS VARCHAR AS $$
DECLARE
    v_current_state VARCHAR;
    v_new_state VARCHAR;
    v_transition_valid BOOLEAN;
BEGIN
    -- è·å–å½“å‰çŠ¶æ€ï¼ˆéœ€è¦æ ¹æ®å®ä½“ç±»å‹æŸ¥è¯¢å¯¹åº”çš„çŠ¶æ€è¡¨ï¼‰
    -- è¿™é‡Œå‡è®¾æœ‰ä¸€ä¸ªé€šç”¨çš„çŠ¶æ€è¡¨
    SELECT current_state INTO v_current_state
    FROM entity_state
    WHERE entity_type = p_entity_type
      AND entity_id = p_entity_id;

    IF v_current_state IS NULL THEN
        RAISE EXCEPTION 'Entity %:% not found', p_entity_type, p_entity_id;
    END IF;

    -- æŸ¥æ‰¾ç›®æ ‡çŠ¶æ€
    SELECT to_state INTO v_new_state
    FROM state_transition_rule
    WHERE state_machine_name = p_state_machine_name
      AND from_state = v_current_state
      AND event_name = p_event_name
      AND is_enabled = TRUE
    LIMIT 1;

    IF v_new_state IS NULL THEN
        RAISE EXCEPTION 'Invalid transition from % with event %', v_current_state, p_event_name;
    END IF;

    -- éªŒè¯è½¬æ¢
    SELECT validate_state_transition(
        p_state_machine_name,
        v_current_state,
        v_new_state,
        p_event_name,
        p_context
    ) INTO v_transition_valid;

    IF NOT v_transition_valid THEN
        RAISE EXCEPTION 'State transition validation failed';
    END IF;

    -- æ›´æ–°çŠ¶æ€
    UPDATE entity_state
    SET current_state = v_new_state,
        updated_at = NOW()
    WHERE entity_type = p_entity_type
      AND entity_id = p_entity_id;

    -- è®°å½•è½¬æ¢å†å²
    INSERT INTO state_transition_history (
        entity_type, entity_id, from_state, to_state,
        event_name, context, operator_id, operator_name, notes
    ) VALUES (
        p_entity_type, p_entity_id, v_current_state, v_new_state,
        p_event_name, p_context, p_operator_id, p_operator_name, p_notes
    );

    RETURN v_new_state;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. PostgreSQLå®ç°

### 5.1 å®Œæ•´çŠ¶æ€æœºç³»ç»Ÿ

**å®ä½“çŠ¶æ€è¡¨**:

```sql
-- é€šç”¨å®ä½“çŠ¶æ€è¡¨
CREATE TABLE entity_state (
    entity_type VARCHAR(100) NOT NULL,
    entity_id BIGINT NOT NULL,
    state_machine_name VARCHAR(100) NOT NULL,
    current_state VARCHAR(100) NOT NULL,
    -- çŠ¶æ€æ•°æ®ï¼ˆJSONBå­˜å‚¨çŠ¶æ€ç›¸å…³çš„é¢å¤–æ•°æ®ï¼‰
    state_data JSONB DEFAULT '{}',
    -- æ—¶é—´æˆ³
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (entity_type, entity_id)
);

-- è®¢å•çŠ¶æ€è¡¨ï¼ˆå…·ä½“å®ç°ï¼‰
CREATE TABLE order_state (
    order_id BIGINT PRIMARY KEY,
    current_state VARCHAR(100) NOT NULL,
    state_data JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- è®¢å•è¡¨
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    order_amount NUMERIC(10,2) NOT NULL,
    order_date TIMESTAMPTZ DEFAULT NOW(),
    -- çŠ¶æ€é€šè¿‡order_stateè¡¨ç®¡ç†
    FOREIGN KEY (order_id) REFERENCES order_state(order_id)
);
```

### 5.2 çŠ¶æ€æœºè§¦å‘å™¨

**è‡ªåŠ¨çŠ¶æ€ç®¡ç†è§¦å‘å™¨**:

```sql
-- åˆ›å»ºè®¢å•æ—¶åˆå§‹åŒ–çŠ¶æ€
CREATE OR REPLACE FUNCTION init_order_state()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO order_state (order_id, current_state)
    VALUES (NEW.order_id, 'pending');

    INSERT INTO entity_state (entity_type, entity_id, state_machine_name, current_state)
    VALUES ('order', NEW.order_id, 'order', 'pending');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_init_order_state
    AFTER INSERT ON orders
    FOR EACH ROW
    EXECUTE FUNCTION init_order_state();

-- çŠ¶æ€æ›´æ–°è§¦å‘å™¨
CREATE OR REPLACE FUNCTION sync_order_state()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE entity_state
    SET current_state = NEW.current_state,
        updated_at = NOW()
    WHERE entity_type = 'order'
      AND entity_id = NEW.order_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sync_order_state
    AFTER UPDATE ON order_state
    FOR EACH ROW
    WHEN (OLD.current_state IS DISTINCT FROM NEW.current_state)
    EXECUTE FUNCTION sync_order_state();
```

### 5.3 çŠ¶æ€æŸ¥è¯¢è§†å›¾

**çŠ¶æ€æŸ¥è¯¢è§†å›¾**:

```sql
-- è®¢å•çŠ¶æ€æŸ¥è¯¢è§†å›¾
CREATE VIEW order_status_view AS
SELECT
    o.order_id,
    o.customer_id,
    o.order_amount,
    o.order_date,
    os.current_state,
    os.state_data,
    os.updated_at AS last_state_change,
    -- çŠ¶æ€æŒç»­æ—¶é—´
    NOW() - os.updated_at AS state_duration,
    -- è½¬æ¢å†å²ç»Ÿè®¡
    (
        SELECT COUNT(*)
        FROM state_transition_history
        WHERE entity_type = 'order'
          AND entity_id = o.order_id
    ) AS transition_count
FROM orders o
JOIN order_state os ON o.order_id = os.order_id;
```

---

## 6. ç›¸å…³èµ„æº

- [JSONBçŠ¶æ€æœºå®ç°](./JSONBçŠ¶æ€æœºå®ç°.md) - JSONBå®ç°çŠ¶æ€æœº
- [å·¥ä½œæµæ¨¡å¼](./å·¥ä½œæµæ¨¡å¼.md) - å·¥ä½œæµæ¨¡å¼æŒ‡å—
- [BPMNå»ºæ¨¡](./BPMNå»ºæ¨¡.md) - BPMNæ ‡å‡†å»ºæ¨¡
- [UMLçŠ¶æ€å›¾](https://www.uml-diagrams.org/state-machine-diagrams.html) - UMLçŠ¶æ€å›¾è§„èŒƒ

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
