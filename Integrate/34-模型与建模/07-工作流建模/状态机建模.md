# çŠ¶æ€æœºå»ºæ¨¡

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: çŠ¶æ€æœºç†è®º
> **çŠ¶æ€**: âœ… å·²å®Œæˆ
> **æ–‡æ¡£ç¼–å·**: 07-02

---

## ğŸ“‘ ç›®å½•

- [çŠ¶æ€æœºå»ºæ¨¡](#çŠ¶æ€æœºå»ºæ¨¡)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [1.1 ç†è®ºåŸºç¡€](#11-ç†è®ºåŸºç¡€)
    - [1.1.1 æœ‰é™çŠ¶æ€æœºç†è®º](#111-æœ‰é™çŠ¶æ€æœºç†è®º)
    - [1.1.2 çŠ¶æ€è½¬æ¢ç†è®º](#112-çŠ¶æ€è½¬æ¢ç†è®º)
    - [1.1.3 çŠ¶æ€æœºç±»å‹ç†è®º](#113-çŠ¶æ€æœºç±»å‹ç†è®º)
    - [1.1.4 çŠ¶æ€éªŒè¯ç†è®º](#114-çŠ¶æ€éªŒè¯ç†è®º)
    - [1.1.5 çŠ¶æ€å†å²ç†è®º](#115-çŠ¶æ€å†å²ç†è®º)
    - [1.1.6 å¤æ‚åº¦åˆ†æ](#116-å¤æ‚åº¦åˆ†æ)
  - [2. çŠ¶æ€æœºåŸºç¡€](#2-çŠ¶æ€æœºåŸºç¡€)
    - [2.1 çŠ¶æ€æœºè¦ç´ ](#21-çŠ¶æ€æœºè¦ç´ )
    - [2.2 çŠ¶æ€æœºç±»å‹](#22-çŠ¶æ€æœºç±»å‹)
    - [2.3 çŠ¶æ€æœºè¡¨ç¤º](#23-çŠ¶æ€æœºè¡¨ç¤º)
  - [3. çŠ¶æ€è½¬æ¢è®¾è®¡](#3-çŠ¶æ€è½¬æ¢è®¾è®¡)
    - [3.1 çŠ¶æ€å®šä¹‰](#31-çŠ¶æ€å®šä¹‰)
    - [3.2 è½¬æ¢è§„åˆ™å®šä¹‰](#32-è½¬æ¢è§„åˆ™å®šä¹‰)
    - [3.3 çŠ¶æ€è½¬æ¢å†å²](#33-çŠ¶æ€è½¬æ¢å†å²)
  - [4. çŠ¶æ€éªŒè¯](#4-çŠ¶æ€éªŒè¯)
    - [4.1 çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°](#41-çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°)
    - [4.2 çŠ¶æ€è½¬æ¢æ‰§è¡Œå‡½æ•°](#42-çŠ¶æ€è½¬æ¢æ‰§è¡Œå‡½æ•°)
  - [5. PostgreSQLå®ç°](#5-postgresqlå®ç°)
    - [5.1 å®Œæ•´çŠ¶æ€æœºç³»ç»Ÿ](#51-å®Œæ•´çŠ¶æ€æœºç³»ç»Ÿ)
    - [5.2 çŠ¶æ€æœºè§¦å‘å™¨](#52-çŠ¶æ€æœºè§¦å‘å™¨)
    - [5.3 çŠ¶æ€æŸ¥è¯¢è§†å›¾](#53-çŠ¶æ€æŸ¥è¯¢è§†å›¾)
  - [6. æ›´å¤šå®é™…æ¡ˆä¾‹ / More Practical Examples](#6-æ›´å¤šå®é™…æ¡ˆä¾‹--more-practical-examples)
    - [6.1 æ¡ˆä¾‹1: è®¢å•çŠ¶æ€æœº](#61-æ¡ˆä¾‹1-è®¢å•çŠ¶æ€æœº)
    - [6.2 æ¡ˆä¾‹2: å®¡æ‰¹æµç¨‹çŠ¶æ€æœº](#62-æ¡ˆä¾‹2-å®¡æ‰¹æµç¨‹çŠ¶æ€æœº)
    - [6.3 æ¡ˆä¾‹3: æ”¯ä»˜çŠ¶æ€æœº](#63-æ¡ˆä¾‹3-æ”¯ä»˜çŠ¶æ€æœº)
  - [7. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§ / Performance Optimization and Monitoring](#7-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§--performance-optimization-and-monitoring)
    - [7.1 çŠ¶æ€æœºæ€§èƒ½ä¼˜åŒ–](#71-çŠ¶æ€æœºæ€§èƒ½ä¼˜åŒ–)
    - [7.2 çŠ¶æ€æœºç›‘æ§](#72-çŠ¶æ€æœºç›‘æ§)
  - [8. å¸¸è§é—®é¢˜è§£ç­” / FAQ](#8-å¸¸è§é—®é¢˜è§£ç­”--faq)
    - [Q1: çŠ¶æ€æœºåº”è¯¥æœ‰å¤šå°‘ä¸ªçŠ¶æ€ï¼Ÿ](#q1-çŠ¶æ€æœºåº”è¯¥æœ‰å¤šå°‘ä¸ªçŠ¶æ€)
    - [Q2: å¦‚ä½•å¤„ç†å¹¶å‘çŠ¶æ€è½¬æ¢ï¼Ÿ](#q2-å¦‚ä½•å¤„ç†å¹¶å‘çŠ¶æ€è½¬æ¢)
    - [Q3: çŠ¶æ€è½¬æ¢å†å²è¡¨ä¼šå¾ˆå¤§ï¼Œå¦‚ä½•ä¼˜åŒ–ï¼Ÿ](#q3-çŠ¶æ€è½¬æ¢å†å²è¡¨ä¼šå¾ˆå¤§å¦‚ä½•ä¼˜åŒ–)
    - [Q4: å¦‚ä½•å®ç°çŠ¶æ€æœºçš„å›æ»šï¼Ÿ](#q4-å¦‚ä½•å®ç°çŠ¶æ€æœºçš„å›æ»š)
    - [Q5: çŠ¶æ€æœºæ€§èƒ½å¦‚ä½•ä¼˜åŒ–ï¼Ÿ](#q5-çŠ¶æ€æœºæ€§èƒ½å¦‚ä½•ä¼˜åŒ–)
  - [8. ç›¸å…³èµ„æº / Related Resources](#8-ç›¸å…³èµ„æº--related-resources)
    - [8.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents](#81-æ ¸å¿ƒç›¸å…³æ–‡æ¡£--core-related-documents)
    - [8.2 ç†è®ºåŸºç¡€ / Theoretical Foundation](#82-ç†è®ºåŸºç¡€--theoretical-foundation)
    - [8.3 å®è·µæŒ‡å— / Practical Guides](#83-å®è·µæŒ‡å—--practical-guides)
    - [8.4 åº”ç”¨æ¡ˆä¾‹ / Application Cases](#84-åº”ç”¨æ¡ˆä¾‹--application-cases)
    - [8.5 å‚è€ƒèµ„æº / Reference Resources](#85-å‚è€ƒèµ„æº--reference-resources)

---

## 1. æ¦‚è¿°

çŠ¶æ€æœºå»ºæ¨¡ç”¨äºæè¿°ç³»ç»Ÿæˆ–å¯¹è±¡çš„çŠ¶æ€å˜åŒ–è¿‡ç¨‹ï¼Œæ˜¯å·¥ä½œæµå»ºæ¨¡çš„åŸºç¡€ã€‚
æœ‰é™çŠ¶æ€æœºï¼ˆFinite State Machine, FSMï¼‰æ˜¯ä¸€ç§è®¡ç®—æ¨¡å‹ï¼Œé€šè¿‡çŠ¶æ€ã€äº‹ä»¶å’Œè½¬æ¢æ¥æè¿°ç³»ç»Ÿè¡Œä¸ºã€‚

**æ ¸å¿ƒä»·å€¼**:

- **è¡Œä¸ºå»ºæ¨¡**ï¼šæ¸…æ™°æè¿°ç³»ç»ŸçŠ¶æ€å˜åŒ–
- **è§„åˆ™éªŒè¯**ï¼šç¡®ä¿çŠ¶æ€è½¬æ¢ç¬¦åˆä¸šåŠ¡è§„åˆ™
- **æµç¨‹æ§åˆ¶**ï¼šå®ç°å¤æ‚ä¸šåŠ¡æµç¨‹çš„çŠ¶æ€ç®¡ç†
- **é”™è¯¯å¤„ç†**ï¼šå®šä¹‰å¼‚å¸¸çŠ¶æ€å’Œæ¢å¤æœºåˆ¶

---

## 1.1 ç†è®ºåŸºç¡€

### 1.1.1 æœ‰é™çŠ¶æ€æœºç†è®º

**æœ‰é™çŠ¶æ€æœºï¼ˆFinite State Machine, FSMï¼‰**:

- **å®šä¹‰**: $M = (Q, \Sigma, \delta, q_0, F)$
  - $Q$: çŠ¶æ€é›†åˆ
  - $\Sigma$: è¾“å…¥å­—æ¯è¡¨ï¼ˆäº‹ä»¶é›†åˆï¼‰
  - $\delta$: è½¬æ¢å‡½æ•° $Q \times \Sigma \rightarrow Q$
  - $q_0$: åˆå§‹çŠ¶æ€
  - $F$: ç»ˆæ­¢çŠ¶æ€é›†åˆ

**çŠ¶æ€æœºè¦ç´ **:

- **çŠ¶æ€ï¼ˆStateï¼‰**: ç³»ç»Ÿåœ¨æŸä¸€æ—¶åˆ»çš„æ¡ä»¶
- **äº‹ä»¶ï¼ˆEventï¼‰**: å¼•èµ·çŠ¶æ€è½¬æ¢çš„è§¦å‘å™¨
- **è½¬æ¢ï¼ˆTransitionï¼‰**: çŠ¶æ€ä¹‹é—´çš„å˜åŒ–è·¯å¾„

### 1.1.2 çŠ¶æ€è½¬æ¢ç†è®º

**çŠ¶æ€è½¬æ¢**:

- **è½¬æ¢å‡½æ•°**: $\delta(q, e) = q'$ where $q, q' \in Q, e \in \Sigma$
- **è½¬æ¢æ¡ä»¶**: è½¬æ¢å¯ä»¥é™„åŠ æ¡ä»¶
- **è½¬æ¢åŠ¨ä½œ**: è½¬æ¢æ—¶å¯ä»¥æ‰§è¡ŒåŠ¨ä½œ

**çŠ¶æ€è½¬æ¢å›¾**:

- **æœ‰å‘å›¾**: $G = (V, E)$ where V is states, E is transitions
- **è·¯å¾„**: çŠ¶æ€åºåˆ— $q_0 \rightarrow q_1 \rightarrow ... \rightarrow q_n$
- **å¯è¾¾æ€§**: çŠ¶æ€$q_j$ä»çŠ¶æ€$q_i$å¯è¾¾

### 1.1.3 çŠ¶æ€æœºç±»å‹ç†è®º

**çŠ¶æ€æœºåˆ†ç±»**:

- **æœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰**: çŠ¶æ€æ•°é‡æœ‰é™
- **å±‚æ¬¡çŠ¶æ€æœºï¼ˆHSMï¼‰**: æ”¯æŒçŠ¶æ€çš„å±‚æ¬¡ç»“æ„
- **å¹¶å‘çŠ¶æ€æœº**: å¤šä¸ªçŠ¶æ€æœºå¹¶è¡Œè¿è¡Œ
- **çŠ¶æ€å›¾ï¼ˆStatechartï¼‰**: æ‰©å±•çš„çŠ¶æ€æœºï¼Œæ”¯æŒå¤åˆçŠ¶æ€

**å±‚æ¬¡çŠ¶æ€æœº**:

- **çˆ¶çŠ¶æ€**: åŒ…å«å­çŠ¶æ€çš„å¤åˆçŠ¶æ€
- **å­çŠ¶æ€**: çˆ¶çŠ¶æ€å†…çš„çŠ¶æ€
- **ç»§æ‰¿**: å­çŠ¶æ€ç»§æ‰¿çˆ¶çŠ¶æ€çš„è¡Œä¸º

### 1.1.4 çŠ¶æ€éªŒè¯ç†è®º

**çŠ¶æ€è½¬æ¢éªŒè¯**:

- **å‰ç½®æ¡ä»¶**: è½¬æ¢å‰å¿…é¡»æ»¡è¶³çš„æ¡ä»¶
- **åç½®æ¡ä»¶**: è½¬æ¢åå¿…é¡»æ»¡è¶³çš„æ¡ä»¶
- **ä¸å˜å¼**: çŠ¶æ€è½¬æ¢è¿‡ç¨‹ä¸­ä¿æŒä¸å˜çš„æ¡ä»¶

**éªŒè¯è§„åˆ™**:

- **åˆæ³•æ€§æ£€æŸ¥**: æ£€æŸ¥è½¬æ¢æ˜¯å¦åˆæ³•
- **ä¸€è‡´æ€§æ£€æŸ¥**: æ£€æŸ¥çŠ¶æ€æ˜¯å¦ä¸€è‡´
- **å®Œæ•´æ€§æ£€æŸ¥**: æ£€æŸ¥çŠ¶æ€æ˜¯å¦å®Œæ•´

### 1.1.5 çŠ¶æ€å†å²ç†è®º

**çŠ¶æ€å†å²è¿½è¸ª**:

- **å†å²è®°å½•**: è®°å½•æ‰€æœ‰çŠ¶æ€è½¬æ¢
- **æ—¶é—´æˆ³**: è®°å½•çŠ¶æ€è½¬æ¢çš„æ—¶é—´
- **äº‹ä»¶è®°å½•**: è®°å½•è§¦å‘è½¬æ¢çš„äº‹ä»¶

**å†å²æŸ¥è¯¢**:

- **æ—¶é—´ç‚¹æŸ¥è¯¢**: æŸ¥è¯¢ç‰¹å®šæ—¶é—´ç‚¹çš„çŠ¶æ€
- **å˜æ›´å†å²**: æŸ¥è¯¢çŠ¶æ€å˜æ›´å†å²
- **å®¡è®¡è¿½è¸ª**: è®°å½•æ“ä½œå®¡è®¡ä¿¡æ¯

### 1.1.6 å¤æ‚åº¦åˆ†æ

**å­˜å‚¨å¤æ‚åº¦**:

- **çŠ¶æ€è¡¨**: $O(S)$ where S is number of states
- **è½¬æ¢è¡¨**: $O(S \times E)$ where E is number of events
- **å†å²è¡¨**: $O(N \times H)$ where N is entities, H is average history per entity

**æ‰§è¡Œå¤æ‚åº¦**:

- **çŠ¶æ€è½¬æ¢**: $O(1)$ (constant time)
- **çŠ¶æ€éªŒè¯**: $O(V)$ where V is number of validation rules
- **å†å²æŸ¥è¯¢**: $O(\log H)$ with index

---

## 2. çŠ¶æ€æœºåŸºç¡€

### 2.1 çŠ¶æ€æœºè¦ç´ 

**çŠ¶æ€æœºä¸‰è¦ç´ **:

| è¦ç´  | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| çŠ¶æ€ï¼ˆStateï¼‰ | ç³»ç»Ÿåœ¨æŸä¸€æ—¶åˆ»çš„æ¡ä»¶ | å¾…å¤„ç†ã€å¤„ç†ä¸­ã€å·²å®Œæˆ |
| äº‹ä»¶ï¼ˆEventï¼‰ | å¼•èµ·çŠ¶æ€è½¬æ¢çš„è§¦å‘å™¨ | å¼€å§‹å¤„ç†ã€å®Œæˆå¤„ç†ã€å–æ¶ˆ |
| è½¬æ¢ï¼ˆTransitionï¼‰ | çŠ¶æ€ä¹‹é—´çš„å˜åŒ–è·¯å¾„ | å¾…å¤„ç† â†’ å¤„ç†ä¸­ |

### 2.2 çŠ¶æ€æœºç±»å‹

**çŠ¶æ€æœºåˆ†ç±»**:

- **æœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰**ï¼šçŠ¶æ€æ•°é‡æœ‰é™
- **å±‚æ¬¡çŠ¶æ€æœºï¼ˆHSMï¼‰**ï¼šæ”¯æŒçŠ¶æ€çš„å±‚æ¬¡ç»“æ„
- **å¹¶å‘çŠ¶æ€æœº**ï¼šå¤šä¸ªçŠ¶æ€æœºå¹¶è¡Œè¿è¡Œ
- **çŠ¶æ€å›¾ï¼ˆStatechartï¼‰**ï¼šæ‰©å±•çš„çŠ¶æ€æœºï¼Œæ”¯æŒå¤åˆçŠ¶æ€

### 2.3 çŠ¶æ€æœºè¡¨ç¤º

**çŠ¶æ€è½¬æ¢å›¾ç¤ºä¾‹**:

```text
         [åˆ›å»ºè®¢å•]
             |
             v
        [å¾…å¤„ç†] --[å¼€å§‹å¤„ç†]--> [å¤„ç†ä¸­]
             |                      |
             |                      v
             |                  [å·²å®Œæˆ]
             |
             v
        [å·²å–æ¶ˆ]
```

---

## 3. çŠ¶æ€è½¬æ¢è®¾è®¡

### 3.1 çŠ¶æ€å®šä¹‰

**çŠ¶æ€è¡¨è®¾è®¡**:

```sql
-- çŠ¶æ€å®šä¹‰è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS state_definition (
        state_id SERIAL PRIMARY KEY,
        state_machine_name VARCHAR(100) NOT NULL,
        state_name VARCHAR(100) NOT NULL,
        state_type VARCHAR(50), -- 'initial', 'normal', 'final', 'error'
        description TEXT,
        is_active BOOLEAN DEFAULT TRUE,
        UNIQUE(state_machine_name, state_name)
    );
    RAISE NOTICE 'è¡¨ state_definition åˆ›å»ºæˆåŠŸ';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE 'è¡¨ state_definition å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ›å»ºè¡¨ state_definition å¤±è´¥: %', SQLERRM;
END $$;

-- ç¤ºä¾‹ï¼šè®¢å•çŠ¶æ€æœºï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    INSERT INTO state_definition (state_machine_name, state_name, state_type, description) VALUES
        ('order', 'pending', 'initial', 'è®¢å•å¾…å¤„ç†'),
        ('order', 'processing', 'normal', 'è®¢å•å¤„ç†ä¸­'),
        ('order', 'completed', 'final', 'è®¢å•å·²å®Œæˆ'),
        ('order', 'cancelled', 'final', 'è®¢å•å·²å–æ¶ˆ'),
        ('order', 'error', 'error', 'è®¢å•å¤„ç†é”™è¯¯')
    ON CONFLICT DO NOTHING;
    RAISE NOTICE 'çŠ¶æ€å®šä¹‰æ•°æ®æ’å…¥æˆåŠŸ';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'æ’å…¥çŠ¶æ€å®šä¹‰æ•°æ®å¤±è´¥: %', SQLERRM;
END $$;
```

### 3.2 è½¬æ¢è§„åˆ™å®šä¹‰

**çŠ¶æ€è½¬æ¢è§„åˆ™è¡¨**:

```sql
-- çŠ¶æ€è½¬æ¢è§„åˆ™è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS state_transition_rule (
        rule_id SERIAL PRIMARY KEY,
        state_machine_name VARCHAR(100) NOT NULL,
        from_state VARCHAR(100) NOT NULL,
        to_state VARCHAR(100) NOT NULL,
        event_name VARCHAR(100) NOT NULL,
        -- è½¬æ¢æ¡ä»¶ï¼ˆJSONBå­˜å‚¨å¤æ‚æ¡ä»¶ï¼‰
        condition JSONB,
        -- è½¬æ¢åŠ¨ä½œ
        action TEXT,
        -- æƒé™æ£€æŸ¥
        required_role VARCHAR(100),
        is_enabled BOOLEAN DEFAULT TRUE,
        UNIQUE(state_machine_name, from_state, event_name)
    );
    RAISE NOTICE 'è¡¨ state_transition_rule åˆ›å»ºæˆåŠŸ';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE 'è¡¨ state_transition_rule å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ›å»ºè¡¨ state_transition_rule å¤±è´¥: %', SQLERRM;
END $$;

-- ç¤ºä¾‹ï¼šè®¢å•çŠ¶æ€è½¬æ¢è§„åˆ™ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    INSERT INTO state_transition_rule (
        state_machine_name, from_state, to_state, event_name, condition, required_role
    ) VALUES
        ('order', 'pending', 'processing', 'start_processing', NULL, 'operator'),
        ('order', 'processing', 'completed', 'complete', '{"all_items_shipped": true}'::jsonb, 'operator'),
        ('order', 'pending', 'cancelled', 'cancel', NULL, 'customer'),
        ('order', 'processing', 'cancelled', 'cancel', '{"allow_cancel": true}'::jsonb, 'customer'),
        ('order', 'processing', 'error', 'error_occurred', NULL, 'system')
    ON CONFLICT DO NOTHING;
    RAISE NOTICE 'çŠ¶æ€è½¬æ¢è§„åˆ™æ•°æ®æ’å…¥æˆåŠŸ';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'æ’å…¥çŠ¶æ€è½¬æ¢è§„åˆ™æ•°æ®å¤±è´¥: %', SQLERRM;
END $$;
```

### 3.3 çŠ¶æ€è½¬æ¢å†å²

**çŠ¶æ€è½¬æ¢å†å²è¡¨**:

```sql
-- çŠ¶æ€è½¬æ¢å†å²è¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS state_transition_history (
        history_id BIGSERIAL PRIMARY KEY,
        entity_type VARCHAR(100) NOT NULL, -- 'order', 'task', etc.
        entity_id BIGINT NOT NULL,
        from_state VARCHAR(100),
        to_state VARCHAR(100) NOT NULL,
        event_name VARCHAR(100) NOT NULL,
        -- è½¬æ¢ä¸Šä¸‹æ–‡
        context JSONB,
        -- æ“ä½œä¿¡æ¯
        operator_id VARCHAR(100),
        operator_name VARCHAR(200),
        -- æ—¶é—´æˆ³
        transition_time TIMESTAMPTZ DEFAULT NOW(),
        -- å¤‡æ³¨
        notes TEXT
    );
    RAISE NOTICE 'è¡¨ state_transition_history åˆ›å»ºæˆåŠŸ';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE 'è¡¨ state_transition_history å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ›å»ºè¡¨ state_transition_history å¤±è´¥: %', SQLERRM;
END $$;

-- åˆ›å»ºç´¢å¼•ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_transition_history_entity ON state_transition_history(entity_type, entity_id, transition_time DESC);
    CREATE INDEX IF NOT EXISTS idx_transition_history_state ON state_transition_history(to_state, transition_time DESC);
    RAISE NOTICE 'ç´¢å¼•åˆ›å»ºæˆåŠŸ';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
END $$;
```

---

## 4. çŠ¶æ€éªŒè¯

### 4.1 çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°

**éªŒè¯å‡½æ•°**:

```sql
-- éªŒè¯çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
CREATE OR REPLACE FUNCTION validate_state_transition(
    p_state_machine_name VARCHAR,
    p_from_state VARCHAR,
    p_to_state VARCHAR,
    p_event_name VARCHAR,
    p_context JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
DECLARE
    v_rule_exists BOOLEAN;
    v_condition_met BOOLEAN := TRUE;
BEGIN
    -- æ£€æŸ¥è½¬æ¢è§„åˆ™æ˜¯å¦å­˜åœ¨
    SELECT EXISTS(
        SELECT 1 FROM state_transition_rule
        WHERE state_machine_name = p_state_machine_name
          AND from_state = p_from_state
          AND to_state = p_to_state
          AND event_name = p_event_name
          AND is_enabled = TRUE
    ) INTO v_rule_exists;

    IF NOT v_rule_exists THEN
        RETURN FALSE;
    END IF;

    -- æ£€æŸ¥è½¬æ¢æ¡ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
    IF p_context IS NOT NULL THEN
        SELECT EXISTS(
            SELECT 1 FROM state_transition_rule
            WHERE state_machine_name = p_state_machine_name
              AND from_state = p_from_state
              AND to_state = p_to_state
              AND event_name = p_event_name
              AND (condition IS NULL OR condition <@ p_context)
        ) INTO v_condition_met;
    END IF;

    RETURN v_rule_exists AND v_condition_met;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 çŠ¶æ€è½¬æ¢æ‰§è¡Œå‡½æ•°

**æ‰§è¡ŒçŠ¶æ€è½¬æ¢**:

```sql
-- æ‰§è¡ŒçŠ¶æ€è½¬æ¢
CREATE OR REPLACE FUNCTION execute_state_transition(
    p_entity_type VARCHAR,
    p_entity_id BIGINT,
    p_state_machine_name VARCHAR,
    p_event_name VARCHAR,
    p_context JSONB DEFAULT NULL,
    p_operator_id VARCHAR DEFAULT NULL,
    p_operator_name VARCHAR DEFAULT NULL,
    p_notes TEXT DEFAULT NULL
)
RETURNS VARCHAR AS $$
DECLARE
    v_current_state VARCHAR;
    v_new_state VARCHAR;
    v_transition_valid BOOLEAN;
BEGIN
    -- è·å–å½“å‰çŠ¶æ€ï¼ˆéœ€è¦æ ¹æ®å®ä½“ç±»å‹æŸ¥è¯¢å¯¹åº”çš„çŠ¶æ€è¡¨ï¼‰
    -- è¿™é‡Œå‡è®¾æœ‰ä¸€ä¸ªé€šç”¨çš„çŠ¶æ€è¡¨
    SELECT current_state INTO v_current_state
    FROM entity_state
    WHERE entity_type = p_entity_type
      AND entity_id = p_entity_id;

    IF v_current_state IS NULL THEN
        RAISE EXCEPTION 'Entity %:% not found', p_entity_type, p_entity_id;
    END IF;

    -- æŸ¥æ‰¾ç›®æ ‡çŠ¶æ€
    SELECT to_state INTO v_new_state
    FROM state_transition_rule
    WHERE state_machine_name = p_state_machine_name
      AND from_state = v_current_state
      AND event_name = p_event_name
      AND is_enabled = TRUE
    LIMIT 1;

    IF v_new_state IS NULL THEN
        RAISE EXCEPTION 'Invalid transition from % with event %', v_current_state, p_event_name;
    END IF;

    -- éªŒè¯è½¬æ¢
    SELECT validate_state_transition(
        p_state_machine_name,
        v_current_state,
        v_new_state,
        p_event_name,
        p_context
    ) INTO v_transition_valid;

    IF NOT v_transition_valid THEN
        RAISE EXCEPTION 'State transition validation failed';
    END IF;

    -- æ›´æ–°çŠ¶æ€
    UPDATE entity_state
    SET current_state = v_new_state,
        updated_at = NOW()
    WHERE entity_type = p_entity_type
      AND entity_id = p_entity_id;

    -- è®°å½•è½¬æ¢å†å²
    INSERT INTO state_transition_history (
        entity_type, entity_id, from_state, to_state,
        event_name, context, operator_id, operator_name, notes
    ) VALUES (
        p_entity_type, p_entity_id, v_current_state, v_new_state,
        p_event_name, p_context, p_operator_id, p_operator_name, p_notes
    );

    RETURN v_new_state;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. PostgreSQLå®ç°

### 5.1 å®Œæ•´çŠ¶æ€æœºç³»ç»Ÿ

**å®ä½“çŠ¶æ€è¡¨**:

```sql
-- é€šç”¨å®ä½“çŠ¶æ€è¡¨
CREATE TABLE entity_state (
    entity_type VARCHAR(100) NOT NULL,
    entity_id BIGINT NOT NULL,
    state_machine_name VARCHAR(100) NOT NULL,
    current_state VARCHAR(100) NOT NULL,
    -- çŠ¶æ€æ•°æ®ï¼ˆJSONBå­˜å‚¨çŠ¶æ€ç›¸å…³çš„é¢å¤–æ•°æ®ï¼‰
    state_data JSONB DEFAULT '{}',
    -- æ—¶é—´æˆ³
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (entity_type, entity_id)
);

-- è®¢å•çŠ¶æ€è¡¨ï¼ˆå…·ä½“å®ç°ï¼‰
CREATE TABLE order_state (
    order_id BIGINT PRIMARY KEY,
    current_state VARCHAR(100) NOT NULL,
    state_data JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- è®¢å•è¡¨
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    order_amount NUMERIC(10,2) NOT NULL,
    order_date TIMESTAMPTZ DEFAULT NOW(),
    -- çŠ¶æ€é€šè¿‡order_stateè¡¨ç®¡ç†
    FOREIGN KEY (order_id) REFERENCES order_state(order_id)
);
```

### 5.2 çŠ¶æ€æœºè§¦å‘å™¨

**è‡ªåŠ¨çŠ¶æ€ç®¡ç†è§¦å‘å™¨**:

```sql
-- åˆ›å»ºè®¢å•æ—¶åˆå§‹åŒ–çŠ¶æ€
CREATE OR REPLACE FUNCTION init_order_state()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO order_state (order_id, current_state)
    VALUES (NEW.order_id, 'pending');

    INSERT INTO entity_state (entity_type, entity_id, state_machine_name, current_state)
    VALUES ('order', NEW.order_id, 'order', 'pending');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_init_order_state
    AFTER INSERT ON orders
    FOR EACH ROW
    EXECUTE FUNCTION init_order_state();

-- çŠ¶æ€æ›´æ–°è§¦å‘å™¨
CREATE OR REPLACE FUNCTION sync_order_state()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE entity_state
    SET current_state = NEW.current_state,
        updated_at = NOW()
    WHERE entity_type = 'order'
      AND entity_id = NEW.order_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sync_order_state
    AFTER UPDATE ON order_state
    FOR EACH ROW
    WHEN (OLD.current_state IS DISTINCT FROM NEW.current_state)
    EXECUTE FUNCTION sync_order_state();
```

### 5.3 çŠ¶æ€æŸ¥è¯¢è§†å›¾

**çŠ¶æ€æŸ¥è¯¢è§†å›¾**:

```sql
-- è®¢å•çŠ¶æ€æŸ¥è¯¢è§†å›¾
CREATE VIEW order_status_view AS
SELECT
    o.order_id,
    o.customer_id,
    o.order_amount,
    o.order_date,
    os.current_state,
    os.state_data,
    os.updated_at AS last_state_change,
    -- çŠ¶æ€æŒç»­æ—¶é—´
    NOW() - os.updated_at AS state_duration,
    -- è½¬æ¢å†å²ç»Ÿè®¡
    (
        SELECT COUNT(*)
        FROM state_transition_history
        WHERE entity_type = 'order'
          AND entity_id = o.order_id
    ) AS transition_count
FROM orders o
JOIN order_state os ON o.order_id = os.order_id;
```

---

## 6. æ›´å¤šå®é™…æ¡ˆä¾‹ / More Practical Examples

### 6.1 æ¡ˆä¾‹1: è®¢å•çŠ¶æ€æœº

**å®Œæ•´è®¢å•çŠ¶æ€æœºå®ç°**:

```sql
-- è®¢å•çŠ¶æ€æœºå®šä¹‰
INSERT INTO state_definition (state_machine_name, state_name, state_type, description) VALUES
    ('order', 'created', 'initial', 'è®¢å•å·²åˆ›å»º'),
    ('order', 'paid', 'normal', 'è®¢å•å·²æ”¯ä»˜'),
    ('order', 'shipped', 'normal', 'è®¢å•å·²å‘è´§'),
    ('order', 'delivered', 'final', 'è®¢å•å·²é€è¾¾'),
    ('order', 'cancelled', 'final', 'è®¢å•å·²å–æ¶ˆ'),
    ('order', 'refunded', 'final', 'è®¢å•å·²é€€æ¬¾');

-- è®¢å•çŠ¶æ€è½¬æ¢è§„åˆ™
INSERT INTO state_transition_rule (
    state_machine_name, from_state, to_state, event_name, condition, required_role
) VALUES
    ('order', 'created', 'paid', 'pay', NULL, 'customer'),
    ('order', 'paid', 'shipped', 'ship', '{"all_items_ready": true}', 'operator'),
    ('order', 'shipped', 'delivered', 'deliver', NULL, 'system'),
    ('order', 'created', 'cancelled', 'cancel', '{"allow_cancel": true}', 'customer'),
    ('order', 'paid', 'cancelled', 'cancel', '{"allow_cancel": true, "not_shipped": true}', 'customer'),
    ('order', 'paid', 'refunded', 'refund', '{"refund_reason": "valid"}', 'operator'),
    ('order', 'shipped', 'refunded', 'refund', '{"return_received": true}', 'operator');

-- è®¢å•è¡¨
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    total_amount NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è®¢å•çŠ¶æ€è¡¨
CREATE TABLE order_state (
    order_id BIGINT PRIMARY KEY REFERENCES orders(order_id),
    current_state VARCHAR(100) NOT NULL DEFAULT 'created',
    state_data JSONB DEFAULT '{}',
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- è®¢å•çŠ¶æ€è½¬æ¢å‡½æ•°
CREATE OR REPLACE FUNCTION change_order_state(
    p_order_id BIGINT,
    p_event_name VARCHAR,
    p_context JSONB DEFAULT NULL,
    p_operator_id VARCHAR DEFAULT NULL
)
RETURNS VARCHAR AS $$
DECLARE
    v_current_state VARCHAR;
    v_new_state VARCHAR;
BEGIN
    -- è·å–å½“å‰çŠ¶æ€
    SELECT current_state INTO v_current_state
    FROM order_state
    WHERE order_id = p_order_id;

    IF v_current_state IS NULL THEN
        RAISE EXCEPTION 'Order % not found', p_order_id;
    END IF;

    -- æŸ¥æ‰¾ç›®æ ‡çŠ¶æ€
    SELECT to_state INTO v_new_state
    FROM state_transition_rule
    WHERE state_machine_name = 'order'
      AND from_state = v_current_state
      AND event_name = p_event_name
      AND is_enabled = TRUE
      AND (condition IS NULL OR condition <@ COALESCE(p_context, '{}'::jsonb))
    LIMIT 1;

    IF v_new_state IS NULL THEN
        RAISE EXCEPTION 'Invalid transition from % with event %', v_current_state, p_event_name;
    END IF;

    -- æ›´æ–°çŠ¶æ€
    UPDATE order_state
    SET current_state = v_new_state,
        state_data = COALESCE(p_context, '{}'::jsonb),
        updated_at = NOW()
    WHERE order_id = p_order_id;

    -- è®°å½•å†å²
    INSERT INTO state_transition_history (
        entity_type, entity_id, from_state, to_state,
        event_name, context, operator_id
    ) VALUES (
        'order', p_order_id, v_current_state, v_new_state,
        p_event_name, p_context, p_operator_id
    );

    RETURN v_new_state;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT change_order_state(1, 'pay', '{"payment_method": "credit_card"}'::jsonb, 'customer_123');
SELECT change_order_state(1, 'ship', '{"tracking_number": "TR123456"}'::jsonb, 'operator_456');
```

### 6.2 æ¡ˆä¾‹2: å®¡æ‰¹æµç¨‹çŠ¶æ€æœº

**å¤šçº§å®¡æ‰¹çŠ¶æ€æœº**:

```sql
-- å®¡æ‰¹çŠ¶æ€æœºå®šä¹‰
INSERT INTO state_definition (state_machine_name, state_name, state_type, description) VALUES
    ('approval', 'draft', 'initial', 'è‰ç¨¿'),
    ('approval', 'submitted', 'normal', 'å·²æäº¤'),
    ('approval', 'level1_approving', 'normal', 'ä¸€çº§å®¡æ‰¹ä¸­'),
    ('approval', 'level2_approving', 'normal', 'äºŒçº§å®¡æ‰¹ä¸­'),
    ('approval', 'approved', 'final', 'å·²æ‰¹å‡†'),
    ('approval', 'rejected', 'final', 'å·²æ‹’ç»'),
    ('approval', 'withdrawn', 'final', 'å·²æ’¤å›');

-- å®¡æ‰¹è½¬æ¢è§„åˆ™
INSERT INTO state_transition_rule (
    state_machine_name, from_state, to_state, event_name, condition, required_role
) VALUES
    ('approval', 'draft', 'submitted', 'submit', NULL, 'applicant'),
    ('approval', 'submitted', 'level1_approving', 'assign_level1', NULL, 'admin'),
    ('approval', 'level1_approving', 'level2_approving', 'approve_level1', '{"amount": {"$gt": 10000}}', 'level1_approver'),
    ('approval', 'level1_approving', 'approved', 'approve_level1', '{"amount": {"$lte": 10000}}', 'level1_approver'),
    ('approval', 'level2_approving', 'approved', 'approve_level2', NULL, 'level2_approver'),
    ('approval', 'level1_approving', 'rejected', 'reject', NULL, 'level1_approver'),
    ('approval', 'level2_approving', 'rejected', 'reject', NULL, 'level2_approver'),
    ('approval', 'submitted', 'withdrawn', 'withdraw', NULL, 'applicant'),
    ('approval', 'level1_approving', 'withdrawn', 'withdraw', NULL, 'applicant');

-- å®¡æ‰¹ç”³è¯·è¡¨
CREATE TABLE approval_request (
    request_id BIGSERIAL PRIMARY KEY,
    applicant_id BIGINT NOT NULL,
    request_type VARCHAR(50) NOT NULL,
    amount NUMERIC(10,2),
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å®¡æ‰¹çŠ¶æ€è¡¨
CREATE TABLE approval_state (
    request_id BIGINT PRIMARY KEY REFERENCES approval_request(request_id),
    current_state VARCHAR(100) NOT NULL DEFAULT 'draft',
    current_approver_id BIGINT,
    state_data JSONB DEFAULT '{}',
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- å®¡æ‰¹å†å²è¡¨
CREATE TABLE approval_history (
    history_id BIGSERIAL PRIMARY KEY,
    request_id BIGINT NOT NULL REFERENCES approval_request(request_id),
    from_state VARCHAR(100),
    to_state VARCHAR(100) NOT NULL,
    approver_id BIGINT,
    approver_name VARCHAR(200),
    comments TEXT,
    transition_time TIMESTAMPTZ DEFAULT NOW()
);
```

### 6.3 æ¡ˆä¾‹3: æ”¯ä»˜çŠ¶æ€æœº

**æ”¯ä»˜æµç¨‹çŠ¶æ€æœº**:

```sql
-- æ”¯ä»˜çŠ¶æ€æœºå®šä¹‰
INSERT INTO state_definition (state_machine_name, state_name, state_type, description) VALUES
    ('payment', 'pending', 'initial', 'å¾…æ”¯ä»˜'),
    ('payment', 'processing', 'normal', 'å¤„ç†ä¸­'),
    ('payment', 'succeeded', 'final', 'æ”¯ä»˜æˆåŠŸ'),
    ('payment', 'failed', 'final', 'æ”¯ä»˜å¤±è´¥'),
    ('payment', 'refunding', 'normal', 'é€€æ¬¾ä¸­'),
    ('payment', 'refunded', 'final', 'å·²é€€æ¬¾'),
    ('payment', 'cancelled', 'final', 'å·²å–æ¶ˆ');

-- æ”¯ä»˜è½¬æ¢è§„åˆ™
INSERT INTO state_transition_rule (
    state_machine_name, from_state, to_state, event_name, condition, required_role
) VALUES
    ('payment', 'pending', 'processing', 'process', NULL, 'system'),
    ('payment', 'processing', 'succeeded', 'success', NULL, 'payment_gateway'),
    ('payment', 'processing', 'failed', 'fail', NULL, 'payment_gateway'),
    ('payment', 'pending', 'cancelled', 'cancel', NULL, 'customer'),
    ('payment', 'succeeded', 'refunding', 'refund', NULL, 'operator'),
    ('payment', 'refunding', 'refunded', 'refund_success', NULL, 'payment_gateway'),
    ('payment', 'refunding', 'failed', 'refund_fail', NULL, 'payment_gateway');

-- æ”¯ä»˜è¡¨
CREATE TABLE payments (
    payment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ”¯ä»˜çŠ¶æ€è¡¨
CREATE TABLE payment_state (
    payment_id BIGINT PRIMARY KEY REFERENCES payments(payment_id),
    current_state VARCHAR(100) NOT NULL DEFAULT 'pending',
    gateway_transaction_id VARCHAR(200),
    state_data JSONB DEFAULT '{}',
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 7. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§ / Performance Optimization and Monitoring

### 7.1 çŠ¶æ€æœºæ€§èƒ½ä¼˜åŒ–

**ç´¢å¼•ä¼˜åŒ–**:

```sql
-- çŠ¶æ€è½¬æ¢å†å²è¡¨ç´¢å¼•
CREATE INDEX idx_transition_history_entity_time
ON state_transition_history(entity_type, entity_id, transition_time DESC);

CREATE INDEX idx_transition_history_state_time
ON state_transition_history(to_state, transition_time DESC);

-- çŠ¶æ€è½¬æ¢è§„åˆ™è¡¨ç´¢å¼•
CREATE INDEX idx_transition_rule_lookup
ON state_transition_rule(state_machine_name, from_state, event_name, is_enabled);

-- å®ä½“çŠ¶æ€è¡¨ç´¢å¼•
CREATE INDEX idx_entity_state_lookup
ON entity_state(entity_type, entity_id);

CREATE INDEX idx_entity_state_current
ON entity_state(state_machine_name, current_state);
```

**æŸ¥è¯¢ä¼˜åŒ–**:

```sql
-- ä¼˜åŒ–ï¼šä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜çŠ¶æ€ç»Ÿè®¡
CREATE MATERIALIZED VIEW state_statistics AS
SELECT
    entity_type,
    state_machine_name,
    current_state,
    COUNT(*) AS entity_count,
    MAX(updated_at) AS last_update
FROM entity_state
GROUP BY entity_type, state_machine_name, current_state;

CREATE INDEX ON state_statistics(entity_type, state_machine_name, current_state);

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY state_statistics;
```

### 7.2 çŠ¶æ€æœºç›‘æ§

**çŠ¶æ€æœºç›‘æ§æŸ¥è¯¢**:

```sql
-- ç›‘æ§ï¼šå„çŠ¶æ€çš„å®ä½“æ•°é‡
SELECT
    entity_type,
    state_machine_name,
    current_state,
    COUNT(*) AS count,
    MIN(updated_at) AS oldest_entity,
    MAX(updated_at) AS newest_entity
FROM entity_state
GROUP BY entity_type, state_machine_name, current_state
ORDER BY count DESC;

-- ç›‘æ§ï¼šçŠ¶æ€è½¬æ¢é¢‘ç‡
SELECT
    entity_type,
    from_state,
    to_state,
    event_name,
    COUNT(*) AS transition_count,
    AVG(EXTRACT(EPOCH FROM (transition_time - LAG(transition_time) OVER (PARTITION BY entity_type, entity_id ORDER BY transition_time)))) AS avg_duration_seconds
FROM state_transition_history
WHERE transition_time >= NOW() - INTERVAL '24 hours'
GROUP BY entity_type, from_state, to_state, event_name
ORDER BY transition_count DESC;

-- ç›‘æ§ï¼šé•¿æ—¶é—´åœç•™åœ¨æŸä¸ªçŠ¶æ€çš„å®ä½“
SELECT
    es.entity_type,
    es.entity_id,
    es.current_state,
    es.updated_at,
    NOW() - es.updated_at AS duration_in_state
FROM entity_state es
WHERE es.updated_at < NOW() - INTERVAL '7 days'
  AND es.current_state NOT IN ('completed', 'cancelled', 'closed')
ORDER BY duration_in_state DESC;
```

---

## 8. å¸¸è§é—®é¢˜è§£ç­” / FAQ

### Q1: çŠ¶æ€æœºåº”è¯¥æœ‰å¤šå°‘ä¸ªçŠ¶æ€ï¼Ÿ

**A**: çŠ¶æ€æ•°é‡å»ºè®®ï¼š

- **æœ€å°‘**: 3ä¸ªçŠ¶æ€ï¼ˆåˆå§‹ã€è¿›è¡Œä¸­ã€ç»ˆæ€ï¼‰
- **æ¨è**: 5-10ä¸ªçŠ¶æ€
- **æœ€å¤š**: ä¸è¶…è¿‡20ä¸ªçŠ¶æ€

**åŸåˆ™**: éµå¾ªç±³å‹’å®šå¾‹ï¼ˆ7Â±2ï¼‰ï¼Œä¿æŒçŠ¶æ€æœºç®€å•æ˜“æ‡‚ã€‚

### Q2: å¦‚ä½•å¤„ç†å¹¶å‘çŠ¶æ€è½¬æ¢ï¼Ÿ

**A**: å¹¶å‘æ§åˆ¶ç­–ç•¥ï¼š

```sql
-- ä½¿ç”¨SELECT FOR UPDATEé”å®šå®ä½“
BEGIN;
SELECT current_state FROM order_state
WHERE order_id = 123 FOR UPDATE;

-- æ‰§è¡ŒçŠ¶æ€è½¬æ¢
SELECT change_order_state(123, 'ship', ...);
COMMIT;

-- æˆ–ä½¿ç”¨ä¹è§‚é”ï¼ˆç‰ˆæœ¬å·ï¼‰
CREATE TABLE order_state (
    order_id BIGINT PRIMARY KEY,
    current_state VARCHAR(100),
    version INT DEFAULT 1,
    ...
);

UPDATE order_state
SET current_state = 'shipped',
    version = version + 1
WHERE order_id = 123 AND version = 1;  -- ç‰ˆæœ¬æ£€æŸ¥
```

### Q3: çŠ¶æ€è½¬æ¢å†å²è¡¨ä¼šå¾ˆå¤§ï¼Œå¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**A**: ä¼˜åŒ–ç­–ç•¥ï¼š

1. **åˆ†åŒº**: æŒ‰æ—¶é—´åˆ†åŒºå†å²è¡¨
2. **å½’æ¡£**: å®šæœŸå½’æ¡£æ—§å†å²æ•°æ®
3. **å‹ç¼©**: ä½¿ç”¨JSONBå‹ç¼©å­˜å‚¨ä¸Šä¸‹æ–‡æ•°æ®
4. **ç´¢å¼•**: åˆ›å»ºåˆé€‚çš„ç´¢å¼•

```sql
-- åˆ†åŒºå†å²è¡¨
CREATE TABLE state_transition_history (
    ...
) PARTITION BY RANGE (transition_time);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE state_transition_history_2024_01
PARTITION OF state_transition_history
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

### Q4: å¦‚ä½•å®ç°çŠ¶æ€æœºçš„å›æ»šï¼Ÿ

**A**: å›æ»šå®ç°ï¼š

```sql
-- æ·»åŠ å›æ»šæ ‡å¿—åˆ°è½¬æ¢è§„åˆ™
ALTER TABLE state_transition_rule
ADD COLUMN is_reversible BOOLEAN DEFAULT FALSE;

-- å›æ»šå‡½æ•°
CREATE OR REPLACE FUNCTION rollback_state_transition(
    p_entity_type VARCHAR,
    p_entity_id BIGINT,
    p_steps INT DEFAULT 1
)
RETURNS VARCHAR AS $$
DECLARE
    v_target_history RECORD;
BEGIN
    -- æŸ¥æ‰¾è¦å›æ»šåˆ°çš„å†å²è®°å½•
    SELECT * INTO v_target_history
    FROM state_transition_history
    WHERE entity_type = p_entity_type
      AND entity_id = p_entity_id
    ORDER BY transition_time DESC
    OFFSET p_steps
    LIMIT 1;

    IF v_target_history IS NULL THEN
        RAISE EXCEPTION 'Cannot rollback % steps', p_steps;
    END IF;

    -- æ¢å¤åˆ°ç›®æ ‡çŠ¶æ€
    UPDATE entity_state
    SET current_state = v_target_history.to_state,
        updated_at = NOW()
    WHERE entity_type = p_entity_type
      AND entity_id = p_entity_id;

    -- è®°å½•å›æ»šå†å²
    INSERT INTO state_transition_history (
        entity_type, entity_id, from_state, to_state,
        event_name, context
    ) VALUES (
        p_entity_type, p_entity_id,
        (SELECT current_state FROM entity_state
         WHERE entity_type = p_entity_type AND entity_id = p_entity_id),
        v_target_history.to_state,
        'rollback',
        jsonb_build_object('rollback_to', v_target_history.history_id)
    );

    RETURN v_target_history.to_state;
END;
$$ LANGUAGE plpgsql;
```

### Q5: çŠ¶æ€æœºæ€§èƒ½å¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**A**: æ€§èƒ½ä¼˜åŒ–å»ºè®®ï¼š

1. **ç´¢å¼•**: ä¸ºé¢‘ç¹æŸ¥è¯¢çš„åˆ—åˆ›å»ºç´¢å¼•
2. **ç‰©åŒ–è§†å›¾**: ç¼“å­˜çŠ¶æ€ç»Ÿè®¡ä¿¡æ¯
3. **æ‰¹é‡æ“ä½œ**: æ‰¹é‡æ›´æ–°çŠ¶æ€
4. **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥å¤„ç†çŠ¶æ€è½¬æ¢

```sql
-- æ‰¹é‡çŠ¶æ€æ›´æ–°
CREATE OR REPLACE FUNCTION batch_update_states(
    p_updates JSONB
)
RETURNS TABLE(entity_id BIGINT, new_state VARCHAR) AS $$
DECLARE
    v_update JSONB;
BEGIN
    FOR v_update IN SELECT * FROM jsonb_array_elements(p_updates)
    LOOP
        UPDATE entity_state
        SET current_state = v_update->>'new_state',
            updated_at = NOW()
        WHERE entity_type = v_update->>'entity_type'
          AND entity_id = (v_update->>'entity_id')::BIGINT;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## 8. ç›¸å…³èµ„æº / Related Resources

### 8.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents

- [JSONBçŠ¶æ€æœºå®ç°](./JSONBçŠ¶æ€æœºå®ç°.md) - JSONBå®ç°çŠ¶æ€æœº
- [å·¥ä½œæµæ¨¡å¼](./å·¥ä½œæµæ¨¡å¼.md) - å·¥ä½œæµæ¨¡å¼æŒ‡å—
- [BPMNå»ºæ¨¡](./BPMNå»ºæ¨¡.md) - BPMNæ ‡å‡†å»ºæ¨¡
- [è®¢å•ç®¡ç†æ¨¡å‹](../04-OLTPå»ºæ¨¡/è®¢å•ç®¡ç†æ¨¡å‹.md) - è®¢å•çŠ¶æ€æœºåº”ç”¨æ¡ˆä¾‹

### 8.2 ç†è®ºåŸºç¡€ / Theoretical Foundation

- [çº¦æŸç†è®º](../01-æ•°æ®å»ºæ¨¡ç†è®ºåŸºç¡€/çº¦æŸç†è®º.md) - çŠ¶æ€è½¬æ¢çº¦æŸç†è®º

### 8.3 å®è·µæŒ‡å— / Practical Guides

- [æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§](#7-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§--performance-optimization-and-monitoring) - æœ¬æ–‡æ¡£çš„æ€§èƒ½ç›‘æ§ç« èŠ‚
- [æ›´å¤šå®é™…æ¡ˆä¾‹](#6-æ›´å¤šå®é™…æ¡ˆä¾‹--more-practical-examples) - æœ¬æ–‡æ¡£çš„åº”ç”¨æ¡ˆä¾‹ç« èŠ‚
- [ç´¢å¼•ç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/ç´¢å¼•ç­–ç•¥.md) - çŠ¶æ€æœºç´¢å¼•è®¾è®¡

### 8.4 åº”ç”¨æ¡ˆä¾‹ / Application Cases

- [ç”µå•†æ•°æ®æ¨¡å‹æ¡ˆä¾‹](../10-ç»¼åˆåº”ç”¨æ¡ˆä¾‹/ç”µå•†æ•°æ®æ¨¡å‹æ¡ˆä¾‹.md) - ç”µå•†è®¢å•çŠ¶æ€æœºæ¡ˆä¾‹

### 8.5 å‚è€ƒèµ„æº / Reference Resources

- [æƒå¨èµ„æºç´¢å¼•](../00-å¯¼èˆªä¸ç´¢å¼•/æƒå¨èµ„æºç´¢å¼•.md) - æƒå¨èµ„æºåˆ—è¡¨
- [æœ¯è¯­å¯¹ç…§è¡¨](../00-å¯¼èˆªä¸ç´¢å¼•/æœ¯è¯­å¯¹ç…§è¡¨.md) - æœ¯è¯­å¯¹ç…§
- [å¿«é€ŸæŸ¥æ‰¾æŒ‡å—](../00-å¯¼èˆªä¸ç´¢å¼•/å¿«é€ŸæŸ¥æ‰¾æŒ‡å—.md) - å¿«é€ŸæŸ¥æ‰¾å·¥å…·
- UMLçŠ¶æ€å›¾: [UML State Machine Diagrams](https://www.uml-diagrams.org/state-machine-diagrams.html)

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
