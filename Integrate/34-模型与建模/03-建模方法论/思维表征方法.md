# 思维表征方法

> **创建日期**: 2025年1月
> **来源**: 数据建模方法论
> **状态**: ✅ 已完成
> **文档编号**: 03-01

---

## 📑 目录

- [思维表征方法](#思维表征方法)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 思维表征理论](#111-思维表征理论)
    - [1.1.2 思维导图理论](#112-思维导图理论)
    - [1.1.3 决策树理论](#113-决策树理论)
    - [1.1.4 多维矩阵理论](#114-多维矩阵理论)
    - [1.1.5 复杂度分析](#115-复杂度分析)
  - [2. 思维导图法](#2-思维导图法)
    - [2.1 概念](#21-概念)
    - [2.2 在数据建模中的应用](#22-在数据建模中的应用)
    - [2.3 PostgreSQL实现](#23-postgresql实现)
  - [3. 多维矩阵法](#3-多维矩阵法)
    - [3.1 概念](#31-概念)
    - [3.2 在数据建模中的应用](#32-在数据建模中的应用)
    - [3.3 PostgreSQL实现](#33-postgresql实现)
  - [4. 决策树法](#4-决策树法)
    - [4.1 概念](#41-概念)
    - [4.2 在数据建模中的应用](#42-在数据建模中的应用)
    - [4.3 PostgreSQL实现](#43-postgresql实现)
  - [5. 证明网络法](#5-证明网络法)
    - [5.1 概念](#51-概念)
    - [5.2 在数据建模中的应用](#52-在数据建模中的应用)
    - [5.3 PostgreSQL实现](#53-postgresql实现)
  - [6. PostgreSQL实现](#6-postgresql实现)
    - [6.1 综合应用示例](#61-综合应用示例)
  - [7. 实际应用案例 / Practical Application Examples](#7-实际应用案例--practical-application-examples)
    - [7.1 案例1: 使用思维导图分析电商业务](#71-案例1-使用思维导图分析电商业务)
    - [7.2 案例2: 使用决策树选择数据模型](#72-案例2-使用决策树选择数据模型)
    - [7.3 案例3: 使用多维矩阵对比建模方案](#73-案例3-使用多维矩阵对比建模方案)
  - [8. 常见问题解答 / FAQ](#8-常见问题解答--faq)
    - [Q1: 什么时候使用思维导图？](#q1-什么时候使用思维导图)
    - [Q2: 决策树和多维矩阵有什么区别？](#q2-决策树和多维矩阵有什么区别)
    - [Q3: 如何将思维表征方法应用到实际建模？](#q3-如何将思维表征方法应用到实际建模)
    - [Q4: 思维表征方法如何存储和管理？](#q4-思维表征方法如何存储和管理)
    - [Q5: 如何评估思维表征方法的效果？](#q5-如何评估思维表征方法的效果)
  - [7. 相关资源](#7-相关资源)

---

## 1. 概述

思维表征方法是数据建模过程中用于组织、分析和表达复杂业务逻辑的工具和技术。
这些方法帮助建模师从不同角度理解业务需求，识别实体关系，并做出合理的设计决策。

**核心价值**:

- 结构化思维：将复杂问题分解为可管理的部分
- 可视化表达：通过图形化方式展示业务逻辑
- 决策支持：为建模决策提供系统化方法
- 知识传递：便于团队沟通和知识共享

---

## 1.1 理论基础

### 1.1.1 思维表征理论

**思维表征（Mental Representation）**:

- **定义**: 在思维中表示和组织信息的方式
- **目的**: 帮助理解和分析复杂问题
- **方法**: 思维导图、决策树、多维矩阵等

**表征方法**:

- **思维导图**: 放射状的可视化思维工具
- **决策树**: 树状结构的决策工具
- **多维矩阵**: 多维度的对比工具

### 1.1.2 思维导图理论

**思维导图（Mind Map）**:

- **定义**: 以中心主题为核心，向外延伸分支的可视化工具
- **结构**: $Map = \{Root, \{Branch_1, Branch_2, ..., Branch_n\}\}$
- **优势**: 直观、易理解、易扩展

**思维导图特点**:

- **中心主题**: 核心概念
- **分支结构**: 概念之间的关系
- **层次结构**: 概念的层次关系

### 1.1.3 决策树理论

**决策树（Decision Tree）**:

- **定义**: 树状结构的决策工具
- **结构**: $Tree = \{Root, \{Node_1, Node_2, ..., Node_n\}\}$
- **优势**: 清晰的决策路径、易于理解

**决策树特点**:

- **根节点**: 决策起点
- **内部节点**: 决策条件
- **叶节点**: 决策结果

### 1.1.4 多维矩阵理论

**多维矩阵（Multi-Dimensional Matrix）**:

- **定义**: 多维度的对比工具
- **结构**: $Matrix = \{Dim_1, Dim_2, ..., Dim_n\}$
- **优势**: 多维度对比、全面分析

**多维矩阵特点**:

- **多维度**: 多个对比维度
- **交叉分析**: 维度间的交叉分析
- **全面性**: 全面的对比分析

### 1.1.5 复杂度分析

**表征复杂度**:

- **思维导图**: $O(N)$ where N is number of nodes
- **决策树**: $O(H)$ where H is tree height
- **多维矩阵**: $O(D_1 \times D_2 \times ... \times D_n)$ where D_i is dimension size

---

## 2. 思维导图法

### 2.1 概念

思维导图（Mind Map）是一种放射状的可视化思维工具，以中心主题为核心，向外延伸分支，展示概念之间的关联关系。

### 2.2 在数据建模中的应用

**用途**:

- 业务领域分析：识别核心业务实体和关系
- 需求梳理：组织用户需求和非功能性需求
- 概念模型设计：初步设计实体和属性
- 团队讨论：可视化业务逻辑讨论

**示例：电商业务思维导图**:

```text
                    电商系统
                    /   |   \
                   /    |    \
              用户   商品   订单
              /|\    /|\    /|\
             / | \  / | \  / | \
          注册 登录 浏览 分类 下单 支付
```

### 2.3 PostgreSQL实现

使用JSONB存储思维导图结构：

```sql
-- 思维导图存储表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'mind_map') THEN
        CREATE TABLE mind_map (
            map_id SERIAL PRIMARY KEY,
            map_name VARCHAR(200) NOT NULL,
            root_node JSONB NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
        RAISE NOTICE '表 mind_map 创建成功';
    ELSE
        RAISE NOTICE '表 mind_map 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 mind_map 失败: %', SQLERRM;
END $$;

-- 示例：电商业务思维导图
INSERT INTO mind_map (map_name, root_node) VALUES (
    '电商业务领域',
    '{
        "id": "ecommerce",
        "label": "电商系统",
        "children": [
            {
                "id": "user",
                "label": "用户",
                "children": [
                    {"id": "register", "label": "注册"},
                    {"id": "login", "label": "登录"},
                    {"id": "profile", "label": "个人资料"}
                ]
            },
            {
                "id": "product",
                "label": "商品",
                "children": [
                    {"id": "catalog", "label": "商品目录"},
                    {"id": "category", "label": "分类"},
                    {"id": "inventory", "label": "库存"}
                ]
            },
            {
                "id": "order",
                "label": "订单",
                "children": [
                    {"id": "create", "label": "下单"},
                    {"id": "payment", "label": "支付"},
                    {"id": "shipment", "label": "配送"}
                ]
            }
        ]
    }'::JSONB
);

-- 查询思维导图节点
SELECT
    map_name,
    jsonb_path_query(root_node, '$.children[*].label') AS main_nodes
FROM mind_map
WHERE map_id = 1;
```

---

## 3. 多维矩阵法

### 3.1 概念

多维矩阵法通过构建N维矩阵，从多个维度分析业务实体之间的关系，特别适用于复杂业务场景的分析。

### 3.2 在数据建模中的应用

**用途**:

- 实体关系分析：分析实体之间的多对多关系
- 权限矩阵：设计角色权限模型
- 业务规则矩阵：梳理复杂的业务规则
- 数据质量矩阵：评估数据质量维度

**示例：用户-角色-权限三维矩阵**:

| 用户类型 | 角色 | 权限 | 值 |
|---------|------|------|-----|
| 管理员 | Admin | 用户管理 | 1 |
| 管理员 | Admin | 订单管理 | 1 |
| 普通用户 | User | 查看订单 | 1 |
| 普通用户 | User | 创建订单 | 1 |
| 普通用户 | User | 用户管理 | 0 |

### 3.3 PostgreSQL实现

```sql
-- 多维矩阵存储表（用户-角色-权限，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'permission_matrix') THEN
        CREATE TABLE permission_matrix (
            matrix_id SERIAL PRIMARY KEY,
            user_type VARCHAR(50) NOT NULL,
            role_name VARCHAR(50) NOT NULL,
            permission_name VARCHAR(100) NOT NULL,
            has_permission BOOLEAN DEFAULT FALSE,
            UNIQUE(user_type, role_name, permission_name)
        );
        RAISE NOTICE '表 permission_matrix 创建成功';
    ELSE
        RAISE NOTICE '表 permission_matrix 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 permission_matrix 失败: %', SQLERRM;
END $$;

-- 插入权限矩阵数据
INSERT INTO permission_matrix (user_type, role_name, permission_name, has_permission) VALUES
    ('管理员', 'Admin', '用户管理', TRUE),
    ('管理员', 'Admin', '订单管理', TRUE),
    ('普通用户', 'User', '查看订单', TRUE),
    ('普通用户', 'User', '创建订单', TRUE),
    ('普通用户', 'User', '用户管理', FALSE);

-- 查询权限矩阵
SELECT
    user_type,
    role_name,
    permission_name,
    CASE WHEN has_permission THEN '✓' ELSE '✗' END AS permission
FROM permission_matrix
ORDER BY user_type, role_name, permission_name;

-- 使用CUBE进行多维分析
SELECT
    user_type,
    role_name,
    permission_name,
    COUNT(*) FILTER (WHERE has_permission) AS granted_count,
    COUNT(*) AS total_count
FROM permission_matrix
GROUP BY CUBE(user_type, role_name, permission_name)
ORDER BY user_type, role_name, permission_name;
```

---

## 4. 决策树法

### 4.1 概念

决策树是一种树形结构，通过一系列条件判断，逐步缩小问题范围，最终得出决策结果。

### 4.2 在数据建模中的应用

**用途**:

- 数据类型选择：根据数据特征选择合适的数据类型
- 索引策略选择：根据查询模式选择索引类型
- 分区策略选择：根据数据分布选择分区方式
- 架构模式选择：根据业务需求选择OLTP/OLAP

**示例：数据类型选择决策树**:

```text
                    数据类型选择
                    /           \
              数值类型？        非数值类型？
              /      \          /          \
          整数？    小数？    文本？      其他？
          /   \     /   \     /   \      /    \
        SMALLINT  BIGINT  NUMERIC TEXT  DATE  JSONB
        范围小    范围大   精确度   长度  时间  结构化
```

### 4.3 PostgreSQL实现

```sql
-- 决策树规则表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'decision_tree') THEN
        CREATE TABLE decision_tree (
            node_id SERIAL PRIMARY KEY,
            parent_id INT REFERENCES decision_tree(node_id),
            condition_text TEXT NOT NULL,
            decision_result TEXT,
            is_leaf BOOLEAN DEFAULT FALSE
        );
        RAISE NOTICE '表 decision_tree 创建成功';
    ELSE
        RAISE NOTICE '表 decision_tree 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 decision_tree 失败: %', SQLERRM;
END $$;

-- 数据类型选择决策树
INSERT INTO decision_tree (parent_id, condition_text, decision_result, is_leaf) VALUES
    (NULL, '数据类型选择', NULL, FALSE),
    (1, '是数值类型？', NULL, FALSE),
    (1, '非数值类型？', NULL, FALSE),
    (2, '是整数？', NULL, FALSE),
    (2, '是小数？', NULL, FALSE),
    (3, '是文本？', NULL, FALSE),
    (3, '是时间？', NULL, FALSE),
    (4, '范围 < 32767', 'SMALLINT', TRUE),
    (4, '范围 < 2147483647', 'INTEGER', TRUE),
    (4, '范围更大', 'BIGINT', TRUE),
    (5, '需要精确计算', 'NUMERIC', TRUE),
    (5, '近似值即可', 'DOUBLE PRECISION', TRUE),
    (6, '长度 < 255', 'VARCHAR(n)', TRUE),
    (6, '长度不定', 'TEXT', TRUE),
    (7, '仅日期', 'DATE', TRUE),
    (7, '日期+时间', 'TIMESTAMP', TRUE),
    (7, '带时区', 'TIMESTAMPTZ', TRUE);

-- 递归查询决策树路径
WITH RECURSIVE tree_path AS (
    SELECT
        node_id,
        parent_id,
        condition_text,
        decision_result,
        ARRAY[node_id] AS path,
        1 AS level
    FROM decision_tree
    WHERE parent_id IS NULL

    UNION ALL

    SELECT
        dt.node_id,
        dt.parent_id,
        dt.condition_text,
        dt.decision_result,
        tp.path || dt.node_id,
        tp.level + 1
    FROM decision_tree dt
    JOIN tree_path tp ON dt.parent_id = tp.node_id
)
SELECT
    level,
    condition_text,
    decision_result,
    path
FROM tree_path
WHERE is_leaf = TRUE
ORDER BY path;
```

---

## 5. 证明网络法

### 5.1 概念

证明网络（Proof Network）是一种有向无环图（DAG），展示从前提条件到结论的推理路径，适用于复杂业务规则的建模。

### 5.2 在数据建模中的应用

**用途**:

- 业务规则建模：展示复杂业务规则的推理过程
- 数据验证规则：设计数据完整性验证逻辑
- 工作流设计：设计状态转换规则
- 权限推导：设计权限继承和推导规则

**示例：订单状态转换证明网络**:

```text
    订单创建
       |
       v
    待支付 --[支付成功]--> 已支付
       |                      |
       |                      v
       |                   待发货
       |                      |
       |                      v
       |                   已发货
       |                      |
       |                      v
       |                   已完成
       |
       v
    已取消
```

### 5.3 PostgreSQL实现

```sql
-- 证明网络节点表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'proof_network_node') THEN
        CREATE TABLE proof_network_node (
            node_id SERIAL PRIMARY KEY,
            node_name VARCHAR(100) NOT NULL,
            node_type VARCHAR(50) NOT NULL, -- 'premise', 'conclusion', 'intermediate'
            description TEXT
        );
        RAISE NOTICE '表 proof_network_node 创建成功';
    ELSE
        RAISE NOTICE '表 proof_network_node 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 proof_network_node 失败: %', SQLERRM;
END $$;

-- 证明网络边表（推理关系，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'proof_network_edge') THEN
        CREATE TABLE proof_network_edge (
            edge_id SERIAL PRIMARY KEY,
            from_node_id INT NOT NULL REFERENCES proof_network_node(node_id),
            to_node_id INT NOT NULL REFERENCES proof_network_node(node_id),
            rule_name VARCHAR(100) NOT NULL,
            rule_condition TEXT,
            UNIQUE(from_node_id, to_node_id)
        );
        RAISE NOTICE '表 proof_network_edge 创建成功';
    ELSE
        RAISE NOTICE '表 proof_network_edge 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN undefined_table THEN
        RAISE EXCEPTION '请先创建 proof_network_node 表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 proof_network_edge 失败: %', SQLERRM;
END $$;

-- 订单状态转换网络
INSERT INTO proof_network_node (node_name, node_type, description) VALUES
    ('订单创建', 'premise', '订单初始状态'),
    ('待支付', 'intermediate', '等待支付'),
    ('已支付', 'intermediate', '支付完成'),
    ('待发货', 'intermediate', '等待发货'),
    ('已发货', 'intermediate', '已发货'),
    ('已完成', 'conclusion', '订单完成'),
    ('已取消', 'conclusion', '订单取消');

INSERT INTO proof_network_edge (from_node_id, to_node_id, rule_name, rule_condition) VALUES
    (1, 2, '创建订单', 'order.created = TRUE'),
    (2, 3, '支付成功', 'payment.status = "SUCCESS"'),
    (2, 7, '取消订单', 'order.cancelled = TRUE'),
    (3, 4, '支付完成', 'payment.status = "SUCCESS"'),
    (4, 5, '发货', 'shipment.shipped = TRUE'),
    (5, 6, '确认收货', 'order.confirmed = TRUE');

-- 查询从起点到终点的所有路径
WITH RECURSIVE path_search AS (
    SELECT
        from_node_id,
        to_node_id,
        rule_name,
        ARRAY[from_node_id, to_node_id] AS path,
        1 AS depth
    FROM proof_network_edge
    WHERE from_node_id = 1  -- 从"订单创建"开始

    UNION ALL

    SELECT
        pn.from_node_id,
        pn.to_node_id,
        pn.rule_name,
        ps.path || pn.to_node_id,
        ps.depth + 1
    FROM proof_network_edge pn
    JOIN path_search ps ON pn.from_node_id = ps.to_node_id
    WHERE pn.to_node_id != ALL(ps.path)  -- 避免循环
      AND ps.depth < 10  -- 限制深度
)
SELECT
    path,
    array_agg(rule_name ORDER BY depth) AS rules
FROM path_search
WHERE to_node_id IN (6, 7)  -- 终点：已完成或已取消
GROUP BY path
ORDER BY array_length(path, 1);
```

---

## 6. PostgreSQL实现

### 6.1 综合应用示例

将多种思维表征方法结合使用：

```sql
-- 业务建模工作空间表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'modeling_workspace') THEN
        CREATE TABLE modeling_workspace (
            workspace_id SERIAL PRIMARY KEY,
            project_name VARCHAR(200) NOT NULL,
            -- 思维导图
            mind_map JSONB,
            -- 多维矩阵
            matrices JSONB,
            -- 决策树
            decision_trees JSONB,
            -- 证明网络
            proof_networks JSONB,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW()
        );
        RAISE NOTICE '表 modeling_workspace 创建成功';
    ELSE
        RAISE NOTICE '表 modeling_workspace 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 modeling_workspace 失败: %', SQLERRM;
END $$;

-- 创建综合建模工作空间
INSERT INTO modeling_workspace (project_name, mind_map, matrices, decision_trees, proof_networks) VALUES (
    '电商系统建模',
    '{"root": "电商系统", "children": [...]}'::JSONB,
    '{"permissions": [...], "business_rules": [...]}'::JSONB,
    '{"data_type_selection": [...], "index_strategy": [...]}'::JSONB,
    '{"order_state_machine": [...], "permission_inheritance": [...]}'::JSONB
);
```

---

## 7. 实际应用案例 / Practical Application Examples

### 7.1 案例1: 使用思维导图分析电商业务

**业务分析思维导图存储**:

```sql
-- 思维导图节点表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'mind_map_nodes') THEN
        CREATE TABLE mind_map_nodes (
            node_id BIGSERIAL PRIMARY KEY,
            map_name VARCHAR(100) NOT NULL,
            node_text TEXT NOT NULL,
            node_type VARCHAR(50), -- 'root', 'branch', 'leaf'
            parent_node_id BIGINT REFERENCES mind_map_nodes(node_id),
            node_order INT,
            metadata JSONB,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
        RAISE NOTICE '表 mind_map_nodes 创建成功';
    ELSE
        RAISE NOTICE '表 mind_map_nodes 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 mind_map_nodes 失败: %', SQLERRM;
END $$;

-- 电商业务思维导图
INSERT INTO mind_map_nodes (map_name, node_text, node_type, parent_node_id, node_order) VALUES
    ('ecommerce_business', '电商业务', 'root', NULL, 1),
    ('ecommerce_business', '用户管理', 'branch', 1, 1),
    ('ecommerce_business', '商品管理', 'branch', 1, 2),
    ('ecommerce_business', '订单管理', 'branch', 1, 3),
    ('ecommerce_business', '用户注册', 'leaf', 2, 1),
    ('ecommerce_business', '用户登录', 'leaf', 2, 2),
    ('ecommerce_business', '商品发布', 'leaf', 3, 1),
    ('ecommerce_business', '订单创建', 'leaf', 4, 1);

-- 查询思维导图结构
WITH RECURSIVE mind_map_tree AS (
    SELECT node_id, node_text, node_type, parent_node_id, 0 AS level
    FROM mind_map_nodes
    WHERE map_name = 'ecommerce_business' AND parent_node_id IS NULL
    UNION ALL
    SELECT n.node_id, n.node_text, n.node_type, n.parent_node_id, m.level + 1
    FROM mind_map_nodes n
    JOIN mind_map_tree m ON n.parent_node_id = m.node_id
)
SELECT REPEAT('  ', level) || node_text AS tree_view
FROM mind_map_tree
ORDER BY level, node_order;
```

### 7.2 案例2: 使用决策树选择数据模型

**数据模型选择决策树**:

```sql
-- 决策树节点表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'decision_tree_nodes') THEN
        CREATE TABLE decision_tree_nodes (
            node_id SERIAL PRIMARY KEY,
            tree_name VARCHAR(100) NOT NULL,
            node_text TEXT NOT NULL,
            node_type VARCHAR(50), -- 'question', 'decision', 'leaf'
            parent_node_id INT REFERENCES decision_tree_nodes(node_id),
            condition_expression TEXT,
            result_value TEXT
        );
        RAISE NOTICE '表 decision_tree_nodes 创建成功';
    ELSE
        RAISE NOTICE '表 decision_tree_nodes 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 decision_tree_nodes 失败: %', SQLERRM;
END $$;

-- 数据模型选择决策树
INSERT INTO decision_tree_nodes (tree_name, node_text, node_type, parent_node_id, condition_expression, result_value) VALUES
    ('data_model_selection', '查询类型？', 'question', NULL, NULL, NULL),
    ('data_model_selection', 'OLTP', 'decision', 1, 'query_type = "OLTP"', NULL),
    ('data_model_selection', 'OLAP', 'decision', 1, 'query_type = "OLAP"', NULL),
    ('data_model_selection', '实体类型？', 'question', 2, NULL, NULL),
    ('data_model_selection', '人员和组织', 'leaf', 4, NULL, 'Party模式'),
    ('data_model_selection', '订单和交易', 'leaf', 4, NULL, 'Order模式'),
    ('data_model_selection', '账户和余额', 'leaf', 4, NULL, 'Account模式'),
    ('data_model_selection', '维度建模', 'leaf', 3, NULL, '星型模式');

-- 决策树查询函数
CREATE OR REPLACE FUNCTION evaluate_decision_tree(
    p_tree_name VARCHAR,
    p_context JSONB
)
RETURNS TEXT AS $$
DECLARE
    v_current_node RECORD;
    v_result TEXT;
BEGIN
    -- 从根节点开始
    SELECT * INTO v_current_node
    FROM decision_tree_nodes
    WHERE tree_name = p_tree_name AND parent_node_id IS NULL;

    -- 遍历决策树
    WHILE v_current_node.node_type != 'leaf' LOOP
        -- 根据条件选择子节点
        SELECT * INTO v_current_node
        FROM decision_tree_nodes
        WHERE parent_node_id = v_current_node.node_id
          AND (condition_expression IS NULL OR
               evaluate_condition(condition_expression, p_context))
        LIMIT 1;

        IF v_current_node IS NULL THEN
            RETURN 'No decision found';
        END IF;
    END LOOP;

    RETURN v_current_node.result_value;
END;
$$ LANGUAGE plpgsql;
```

### 7.3 案例3: 使用多维矩阵对比建模方案

**建模方案对比矩阵**:

```sql
-- 多维矩阵表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'comparison_matrix') THEN
        CREATE TABLE comparison_matrix (
            matrix_id SERIAL PRIMARY KEY,
            matrix_name VARCHAR(100) NOT NULL,
            dimension1 VARCHAR(100),
            dimension2 VARCHAR(100),
            dimension3 VARCHAR(100),
            cell_value JSONB,
            created_at TIMESTAMPTZ DEFAULT NOW()
        );
        RAISE NOTICE '表 comparison_matrix 创建成功';
    ELSE
        RAISE NOTICE '表 comparison_matrix 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 comparison_matrix 失败: %', SQLERRM;
END $$;

-- 建模方案对比矩阵（性能 vs 成本 vs 复杂度）
INSERT INTO comparison_matrix (matrix_name, dimension1, dimension2, dimension3, cell_value) VALUES
    ('modeling_options', 'Party模式', '性能', '成本', '{"score": 8, "cost": 100}'::jsonb),
    ('modeling_options', 'Party模式', '性能', '复杂度', '{"score": 7, "complexity": "medium"}'::jsonb),
    ('modeling_options', 'Order模式', '性能', '成本', '{"score": 9, "cost": 120}'::jsonb),
    ('modeling_options', 'Order模式', '性能', '复杂度', '{"score": 8, "complexity": "medium"}'::jsonb),
    ('modeling_options', 'Account模式', '性能', '成本', '{"score": 7, "cost": 150}'::jsonb),
    ('modeling_options', 'Account模式', '性能', '复杂度', '{"score": 6, "complexity": "high"}'::jsonb);

-- 查询对比矩阵
SELECT
    dimension1 AS option_name,
    dimension2 AS metric_type,
    dimension3 AS comparison_dimension,
    cell_value->>'score' AS score,
    cell_value->>'cost' AS cost,
    cell_value->>'complexity' AS complexity
FROM comparison_matrix
WHERE matrix_name = 'modeling_options'
ORDER BY dimension1, dimension2, dimension3;
```

---

## 8. 常见问题解答 / FAQ

### Q1: 什么时候使用思维导图？

**A**: 思维导图适用场景：

- ✅ **需求分析**: 梳理复杂业务需求
- ✅ **概念梳理**: 整理业务概念和关系
- ✅ **知识整理**: 组织建模知识体系
- ✅ **团队沟通**: 可视化表达业务逻辑

**不适用场景**:

- ❌ **技术决策**: 技术选型更适合用决策树
- ❌ **方案对比**: 方案对比更适合用多维矩阵

### Q2: 决策树和多维矩阵有什么区别？

**A**: 区别对比：

| 特性 | 决策树 | 多维矩阵 |
|------|--------|----------|
| 用途 | 单一决策路径 | 多维度对比 |
| 结构 | 树形结构 | 矩阵结构 |
| 适用场景 | 选择决策 | 方案对比 |
| 复杂度 | 中等 | 较高 |

**选择原则**:

- 需要选择方案 → 使用决策树
- 需要对比方案 → 使用多维矩阵

### Q3: 如何将思维表征方法应用到实际建模？

**A**: 应用流程：

1. **需求分析阶段**: 使用思维导图梳理业务需求
2. **方案设计阶段**: 使用决策树选择数据模型
3. **方案对比阶段**: 使用多维矩阵对比不同方案
4. **实施验证阶段**: 使用证明网络验证设计

```sql
-- 综合应用示例
-- 步骤1：创建思维导图
INSERT INTO mind_map_nodes (...) VALUES (...);

-- 步骤2：使用决策树选择方案
SELECT evaluate_decision_tree('data_model_selection', '{"query_type": "OLTP"}'::jsonb);

-- 步骤3：使用多维矩阵对比方案
SELECT * FROM comparison_matrix WHERE matrix_name = 'modeling_options';
```

### Q4: 思维表征方法如何存储和管理？

**A**: 存储管理策略：

```sql
-- 版本管理（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'mind_map_versions') THEN
        CREATE TABLE mind_map_versions (
            version_id BIGSERIAL PRIMARY KEY,
            map_name VARCHAR(100) NOT NULL,
            version_number INT NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            created_by VARCHAR(100),
            notes TEXT
        );
        RAISE NOTICE '表 mind_map_versions 创建成功';
    ELSE
        RAISE NOTICE '表 mind_map_versions 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 mind_map_versions 失败: %', SQLERRM;
END $$;

-- 版本对比
CREATE OR REPLACE FUNCTION compare_mind_map_versions(
    p_map_name VARCHAR,
    p_version1 INT,
    p_version2 INT
)
RETURNS TABLE(
    node_id BIGINT,
    change_type VARCHAR,
    old_value TEXT,
    new_value TEXT
) AS $$
BEGIN
    -- 对比两个版本的差异
    RETURN QUERY
    SELECT ...;
END;
$$ LANGUAGE plpgsql;
```

### Q5: 如何评估思维表征方法的效果？

**A**: 效果评估：

```sql
-- 使用情况统计
SELECT
    map_name,
    COUNT(*) AS node_count,
    COUNT(*) FILTER (WHERE node_type = 'leaf') AS leaf_count,
    MAX(created_at) AS last_updated
FROM mind_map_nodes
GROUP BY map_name
ORDER BY last_updated DESC;

-- 决策树使用效果
SELECT
    tree_name,
    COUNT(*) AS decision_count,
    COUNT(DISTINCT result_value) AS unique_decisions
FROM decision_tree_nodes
WHERE node_type = 'leaf'
GROUP BY tree_name;
```

---

## 7. 相关资源

- [建模决策框架](./建模决策框架.md) - 决策框架方法
- [ER模型](../01-数据建模理论基础/ER模型.md) - 实体关系建模
- [文档格式规范](../00-导航与索引/文档格式规范.md) - 文档规范
- [成本效益分析](./成本效益分析.md) - 成本效益评估

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
