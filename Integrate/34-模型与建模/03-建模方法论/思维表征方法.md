# 思维表征方法

> **创建日期**: 2025年1月
> **来源**: 数据建模方法论
> **状态**: 待完善
> **文档编号**: 03-01

---

## 📑 目录

- [思维表征方法](#思维表征方法)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 思维导图法](#2-思维导图法)
    - [2.1 概念](#21-概念)
    - [2.2 在数据建模中的应用](#22-在数据建模中的应用)
    - [2.3 PostgreSQL实现](#23-postgresql实现)
  - [3. 多维矩阵法](#3-多维矩阵法)
    - [3.1 概念](#31-概念)
    - [3.2 在数据建模中的应用](#32-在数据建模中的应用)
    - [3.3 PostgreSQL实现](#33-postgresql实现)
  - [4. 决策树法](#4-决策树法)
    - [4.1 概念](#41-概念)
    - [4.2 在数据建模中的应用](#42-在数据建模中的应用)
    - [4.3 PostgreSQL实现](#43-postgresql实现)
  - [5. 证明网络法](#5-证明网络法)
    - [5.1 概念](#51-概念)
    - [5.2 在数据建模中的应用](#52-在数据建模中的应用)
    - [5.3 PostgreSQL实现](#53-postgresql实现)
  - [6. PostgreSQL实现](#6-postgresql实现)
    - [6.1 综合应用示例](#61-综合应用示例)
  - [7. 相关资源](#7-相关资源)

---

## 1. 概述

思维表征方法是数据建模过程中用于组织、分析和表达复杂业务逻辑的工具和技术。
这些方法帮助建模师从不同角度理解业务需求，识别实体关系，并做出合理的设计决策。

**核心价值**:

- 结构化思维：将复杂问题分解为可管理的部分
- 可视化表达：通过图形化方式展示业务逻辑
- 决策支持：为建模决策提供系统化方法
- 知识传递：便于团队沟通和知识共享

---

## 2. 思维导图法

### 2.1 概念

思维导图（Mind Map）是一种放射状的可视化思维工具，以中心主题为核心，向外延伸分支，展示概念之间的关联关系。

### 2.2 在数据建模中的应用

**用途**:

- 业务领域分析：识别核心业务实体和关系
- 需求梳理：组织用户需求和非功能性需求
- 概念模型设计：初步设计实体和属性
- 团队讨论：可视化业务逻辑讨论

**示例：电商业务思维导图**:

```text
                    电商系统
                    /   |   \
                   /    |    \
              用户   商品   订单
              /|\    /|\    /|\
             / | \  / | \  / | \
          注册 登录 浏览 分类 下单 支付
```

### 2.3 PostgreSQL实现

使用JSONB存储思维导图结构：

```sql
-- 思维导图存储表
CREATE TABLE mind_map (
    map_id SERIAL PRIMARY KEY,
    map_name VARCHAR(200) NOT NULL,
    root_node JSONB NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 示例：电商业务思维导图
INSERT INTO mind_map (map_name, root_node) VALUES (
    '电商业务领域',
    '{
        "id": "ecommerce",
        "label": "电商系统",
        "children": [
            {
                "id": "user",
                "label": "用户",
                "children": [
                    {"id": "register", "label": "注册"},
                    {"id": "login", "label": "登录"},
                    {"id": "profile", "label": "个人资料"}
                ]
            },
            {
                "id": "product",
                "label": "商品",
                "children": [
                    {"id": "catalog", "label": "商品目录"},
                    {"id": "category", "label": "分类"},
                    {"id": "inventory", "label": "库存"}
                ]
            },
            {
                "id": "order",
                "label": "订单",
                "children": [
                    {"id": "create", "label": "下单"},
                    {"id": "payment", "label": "支付"},
                    {"id": "shipment", "label": "配送"}
                ]
            }
        ]
    }'::JSONB
);

-- 查询思维导图节点
SELECT
    map_name,
    jsonb_path_query(root_node, '$.children[*].label') AS main_nodes
FROM mind_map
WHERE map_id = 1;
```

---

## 3. 多维矩阵法

### 3.1 概念

多维矩阵法通过构建N维矩阵，从多个维度分析业务实体之间的关系，特别适用于复杂业务场景的分析。

### 3.2 在数据建模中的应用

**用途**:

- 实体关系分析：分析实体之间的多对多关系
- 权限矩阵：设计角色权限模型
- 业务规则矩阵：梳理复杂的业务规则
- 数据质量矩阵：评估数据质量维度

**示例：用户-角色-权限三维矩阵**:

| 用户类型 | 角色 | 权限 | 值 |
|---------|------|------|-----|
| 管理员 | Admin | 用户管理 | 1 |
| 管理员 | Admin | 订单管理 | 1 |
| 普通用户 | User | 查看订单 | 1 |
| 普通用户 | User | 创建订单 | 1 |
| 普通用户 | User | 用户管理 | 0 |

### 3.3 PostgreSQL实现

```sql
-- 多维矩阵存储表（用户-角色-权限）
CREATE TABLE permission_matrix (
    matrix_id SERIAL PRIMARY KEY,
    user_type VARCHAR(50) NOT NULL,
    role_name VARCHAR(50) NOT NULL,
    permission_name VARCHAR(100) NOT NULL,
    has_permission BOOLEAN DEFAULT FALSE,
    UNIQUE(user_type, role_name, permission_name)
);

-- 插入权限矩阵数据
INSERT INTO permission_matrix (user_type, role_name, permission_name, has_permission) VALUES
    ('管理员', 'Admin', '用户管理', TRUE),
    ('管理员', 'Admin', '订单管理', TRUE),
    ('普通用户', 'User', '查看订单', TRUE),
    ('普通用户', 'User', '创建订单', TRUE),
    ('普通用户', 'User', '用户管理', FALSE);

-- 查询权限矩阵
SELECT
    user_type,
    role_name,
    permission_name,
    CASE WHEN has_permission THEN '✓' ELSE '✗' END AS permission
FROM permission_matrix
ORDER BY user_type, role_name, permission_name;

-- 使用CUBE进行多维分析
SELECT
    user_type,
    role_name,
    permission_name,
    COUNT(*) FILTER (WHERE has_permission) AS granted_count,
    COUNT(*) AS total_count
FROM permission_matrix
GROUP BY CUBE(user_type, role_name, permission_name)
ORDER BY user_type, role_name, permission_name;
```

---

## 4. 决策树法

### 4.1 概念

决策树是一种树形结构，通过一系列条件判断，逐步缩小问题范围，最终得出决策结果。

### 4.2 在数据建模中的应用

**用途**:

- 数据类型选择：根据数据特征选择合适的数据类型
- 索引策略选择：根据查询模式选择索引类型
- 分区策略选择：根据数据分布选择分区方式
- 架构模式选择：根据业务需求选择OLTP/OLAP

**示例：数据类型选择决策树**:

```text
                    数据类型选择
                    /           \
              数值类型？        非数值类型？
              /      \          /          \
          整数？    小数？    文本？      其他？
          /   \     /   \     /   \      /    \
        SMALLINT  BIGINT  NUMERIC TEXT  DATE  JSONB
        范围小    范围大   精确度   长度  时间  结构化
```

### 4.3 PostgreSQL实现

```sql
-- 决策树规则表
CREATE TABLE decision_tree (
    node_id SERIAL PRIMARY KEY,
    parent_id INT REFERENCES decision_tree(node_id),
    condition_text TEXT NOT NULL,
    decision_result TEXT,
    is_leaf BOOLEAN DEFAULT FALSE
);

-- 数据类型选择决策树
INSERT INTO decision_tree (parent_id, condition_text, decision_result, is_leaf) VALUES
    (NULL, '数据类型选择', NULL, FALSE),
    (1, '是数值类型？', NULL, FALSE),
    (1, '非数值类型？', NULL, FALSE),
    (2, '是整数？', NULL, FALSE),
    (2, '是小数？', NULL, FALSE),
    (3, '是文本？', NULL, FALSE),
    (3, '是时间？', NULL, FALSE),
    (4, '范围 < 32767', 'SMALLINT', TRUE),
    (4, '范围 < 2147483647', 'INTEGER', TRUE),
    (4, '范围更大', 'BIGINT', TRUE),
    (5, '需要精确计算', 'NUMERIC', TRUE),
    (5, '近似值即可', 'DOUBLE PRECISION', TRUE),
    (6, '长度 < 255', 'VARCHAR(n)', TRUE),
    (6, '长度不定', 'TEXT', TRUE),
    (7, '仅日期', 'DATE', TRUE),
    (7, '日期+时间', 'TIMESTAMP', TRUE),
    (7, '带时区', 'TIMESTAMPTZ', TRUE);

-- 递归查询决策树路径
WITH RECURSIVE tree_path AS (
    SELECT
        node_id,
        parent_id,
        condition_text,
        decision_result,
        ARRAY[node_id] AS path,
        1 AS level
    FROM decision_tree
    WHERE parent_id IS NULL

    UNION ALL

    SELECT
        dt.node_id,
        dt.parent_id,
        dt.condition_text,
        dt.decision_result,
        tp.path || dt.node_id,
        tp.level + 1
    FROM decision_tree dt
    JOIN tree_path tp ON dt.parent_id = tp.node_id
)
SELECT
    level,
    condition_text,
    decision_result,
    path
FROM tree_path
WHERE is_leaf = TRUE
ORDER BY path;
```

---

## 5. 证明网络法

### 5.1 概念

证明网络（Proof Network）是一种有向无环图（DAG），展示从前提条件到结论的推理路径，适用于复杂业务规则的建模。

### 5.2 在数据建模中的应用

**用途**:

- 业务规则建模：展示复杂业务规则的推理过程
- 数据验证规则：设计数据完整性验证逻辑
- 工作流设计：设计状态转换规则
- 权限推导：设计权限继承和推导规则

**示例：订单状态转换证明网络**:

```text
    订单创建
       |
       v
    待支付 --[支付成功]--> 已支付
       |                      |
       |                      v
       |                   待发货
       |                      |
       |                      v
       |                   已发货
       |                      |
       |                      v
       |                   已完成
       |
       v
    已取消
```

### 5.3 PostgreSQL实现

```sql
-- 证明网络节点表
CREATE TABLE proof_network_node (
    node_id SERIAL PRIMARY KEY,
    node_name VARCHAR(100) NOT NULL,
    node_type VARCHAR(50) NOT NULL, -- 'premise', 'conclusion', 'intermediate'
    description TEXT
);

-- 证明网络边表（推理关系）
CREATE TABLE proof_network_edge (
    edge_id SERIAL PRIMARY KEY,
    from_node_id INT NOT NULL REFERENCES proof_network_node(node_id),
    to_node_id INT NOT NULL REFERENCES proof_network_node(node_id),
    rule_name VARCHAR(100) NOT NULL,
    rule_condition TEXT,
    UNIQUE(from_node_id, to_node_id)
);

-- 订单状态转换网络
INSERT INTO proof_network_node (node_name, node_type, description) VALUES
    ('订单创建', 'premise', '订单初始状态'),
    ('待支付', 'intermediate', '等待支付'),
    ('已支付', 'intermediate', '支付完成'),
    ('待发货', 'intermediate', '等待发货'),
    ('已发货', 'intermediate', '已发货'),
    ('已完成', 'conclusion', '订单完成'),
    ('已取消', 'conclusion', '订单取消');

INSERT INTO proof_network_edge (from_node_id, to_node_id, rule_name, rule_condition) VALUES
    (1, 2, '创建订单', 'order.created = TRUE'),
    (2, 3, '支付成功', 'payment.status = "SUCCESS"'),
    (2, 7, '取消订单', 'order.cancelled = TRUE'),
    (3, 4, '支付完成', 'payment.status = "SUCCESS"'),
    (4, 5, '发货', 'shipment.shipped = TRUE'),
    (5, 6, '确认收货', 'order.confirmed = TRUE');

-- 查询从起点到终点的所有路径
WITH RECURSIVE path_search AS (
    SELECT
        from_node_id,
        to_node_id,
        rule_name,
        ARRAY[from_node_id, to_node_id] AS path,
        1 AS depth
    FROM proof_network_edge
    WHERE from_node_id = 1  -- 从"订单创建"开始

    UNION ALL

    SELECT
        pn.from_node_id,
        pn.to_node_id,
        pn.rule_name,
        ps.path || pn.to_node_id,
        ps.depth + 1
    FROM proof_network_edge pn
    JOIN path_search ps ON pn.from_node_id = ps.to_node_id
    WHERE pn.to_node_id != ALL(ps.path)  -- 避免循环
      AND ps.depth < 10  -- 限制深度
)
SELECT
    path,
    array_agg(rule_name ORDER BY depth) AS rules
FROM path_search
WHERE to_node_id IN (6, 7)  -- 终点：已完成或已取消
GROUP BY path
ORDER BY array_length(path, 1);
```

---

## 6. PostgreSQL实现

### 6.1 综合应用示例

将多种思维表征方法结合使用：

```sql
-- 业务建模工作空间表
CREATE TABLE modeling_workspace (
    workspace_id SERIAL PRIMARY KEY,
    project_name VARCHAR(200) NOT NULL,
    -- 思维导图
    mind_map JSONB,
    -- 多维矩阵
    matrices JSONB,
    -- 决策树
    decision_trees JSONB,
    -- 证明网络
    proof_networks JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建综合建模工作空间
INSERT INTO modeling_workspace (project_name, mind_map, matrices, decision_trees, proof_networks) VALUES (
    '电商系统建模',
    '{"root": "电商系统", "children": [...]}'::JSONB,
    '{"permissions": [...], "business_rules": [...]}'::JSONB,
    '{"data_type_selection": [...], "index_strategy": [...]}'::JSONB,
    '{"order_state_machine": [...], "permission_inheritance": [...]}'::JSONB
);
```

---

## 7. 相关资源

- [建模决策框架](./建模决策框架.md) - 决策框架方法
- [ER模型](../01-数据建模理论基础/ER模型.md) - 实体关系建模
- [文档格式规范](../00-导航与索引/文档格式规范.md) - 文档规范

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
