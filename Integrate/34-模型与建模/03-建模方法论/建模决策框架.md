# å»ºæ¨¡å†³ç­–æ¡†æ¶

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: æ•°æ®å»ºæ¨¡æœ€ä½³å®è·µ
> **çŠ¶æ€**: å¾…å®Œå–„
> **æ–‡æ¡£ç¼–å·**: 03-02

---

## ğŸ“‘ ç›®å½•

- [å»ºæ¨¡å†³ç­–æ¡†æ¶](#å»ºæ¨¡å†³ç­–æ¡†æ¶)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2. éœ€æ±‚åˆ†ææ¡†æ¶](#2-éœ€æ±‚åˆ†ææ¡†æ¶)
    - [2.1 ä¸šåŠ¡éœ€æ±‚åˆ†æ](#21-ä¸šåŠ¡éœ€æ±‚åˆ†æ)
    - [2.2 åŠŸèƒ½éœ€æ±‚åˆ†æ](#22-åŠŸèƒ½éœ€æ±‚åˆ†æ)
    - [2.3 æ•°æ®éœ€æ±‚åˆ†æ](#23-æ•°æ®éœ€æ±‚åˆ†æ)
  - [3. æ¶æ„é€‰æ‹©æ¡†æ¶](#3-æ¶æ„é€‰æ‹©æ¡†æ¶)
    - [3.1 OLTP vs OLAPå†³ç­–](#31-oltp-vs-olapå†³ç­–)
    - [3.2 æ•°æ®æ¨¡å‹é€‰æ‹©](#32-æ•°æ®æ¨¡å‹é€‰æ‹©)
  - [4. æŠ€æœ¯é€‰å‹æ¡†æ¶](#4-æŠ€æœ¯é€‰å‹æ¡†æ¶)
    - [4.1 æ•°æ®ç±»å‹é€‰æ‹©å†³ç­–](#41-æ•°æ®ç±»å‹é€‰æ‹©å†³ç­–)
    - [4.2 ç´¢å¼•ç­–ç•¥é€‰æ‹©å†³ç­–](#42-ç´¢å¼•ç­–ç•¥é€‰æ‹©å†³ç­–)
    - [4.3 åˆ†åŒºç­–ç•¥é€‰æ‹©å†³ç­–](#43-åˆ†åŒºç­–ç•¥é€‰æ‹©å†³ç­–)
  - [5. å®æ–½å†³ç­–æ¡†æ¶](#5-å®æ–½å†³ç­–æ¡†æ¶)
    - [5.1 å®æ–½ä¼˜å…ˆçº§å†³ç­–](#51-å®æ–½ä¼˜å…ˆçº§å†³ç­–)
    - [5.2 è¿ç§»ç­–ç•¥å†³ç­–](#52-è¿ç§»ç­–ç•¥å†³ç­–)
  - [6. PostgreSQLå®ç°](#6-postgresqlå®ç°)
    - [6.1 ç»¼åˆå†³ç­–æ”¯æŒç³»ç»Ÿ](#61-ç»¼åˆå†³ç­–æ”¯æŒç³»ç»Ÿ)
  - [7. ç›¸å…³èµ„æº](#7-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

å»ºæ¨¡å†³ç­–æ¡†æ¶æä¾›ç³»ç»ŸåŒ–çš„æ–¹æ³•ï¼Œå¸®åŠ©æ•°æ®å»ºæ¨¡å¸ˆåœ¨å¤æ‚åœºæ™¯ä¸‹åšå‡ºæ­£ç¡®çš„è®¾è®¡å†³ç­–ã€‚
è¯¥æ¡†æ¶æ¶µç›–ä»éœ€æ±‚åˆ†æåˆ°æŠ€æœ¯å®æ–½çš„å®Œæ•´å†³ç­–æµç¨‹ã€‚

**æ ¸å¿ƒåŸåˆ™**:

- **éœ€æ±‚é©±åŠ¨**ï¼šä»¥ä¸šåŠ¡éœ€æ±‚ä¸ºæ ¸å¿ƒ
- **æ•°æ®é©±åŠ¨**ï¼šåŸºäºæ•°æ®ç‰¹å¾åšå†³ç­–
- **æˆæœ¬æ•ˆç›Š**ï¼šå¹³è¡¡æ€§èƒ½ã€æˆæœ¬å’Œå¤æ‚åº¦
- **å¯æ‰©å±•æ€§**ï¼šè€ƒè™‘æœªæ¥å˜åŒ–å’Œæ‰©å±•

---

## 2. éœ€æ±‚åˆ†ææ¡†æ¶

### 2.1 ä¸šåŠ¡éœ€æ±‚åˆ†æ

**å…³é”®é—®é¢˜**:

1. ä¸šåŠ¡ç›®æ ‡æ˜¯ä»€ä¹ˆï¼Ÿ
2. æ ¸å¿ƒä¸šåŠ¡æµç¨‹æ˜¯ä»€ä¹ˆï¼Ÿ
3. æ•°æ®ä½¿ç”¨åœºæ™¯æœ‰å“ªäº›ï¼Ÿ
4. æ€§èƒ½è¦æ±‚æ˜¯ä»€ä¹ˆï¼Ÿ
5. æ•°æ®é‡çº§æ˜¯å¤šå°‘ï¼Ÿ

**åˆ†æç»´åº¦**:

| ç»´åº¦ | é—®é¢˜ | å½±å“ |
|------|------|------|
| ä¸šåŠ¡ç›®æ ‡ | ç³»ç»Ÿè¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ | ç¡®å®šå»ºæ¨¡é‡ç‚¹ |
| ç”¨æˆ·è§’è‰² | è°ä½¿ç”¨æ•°æ®ï¼Ÿ | å½±å“æŸ¥è¯¢æ¨¡å¼ |
| æ•°æ®æ¥æº | æ•°æ®ä»å“ªé‡Œæ¥ï¼Ÿ | å½±å“ETLè®¾è®¡ |
| ä½¿ç”¨é¢‘ç‡ | æ•°æ®è®¿é—®é¢‘ç‡ï¼Ÿ | å½±å“ç´¢å¼•ç­–ç•¥ |
| æ•°æ®é‡ | æ•°æ®è§„æ¨¡å¤šå¤§ï¼Ÿ | å½±å“åˆ†åŒºç­–ç•¥ |

### 2.2 åŠŸèƒ½éœ€æ±‚åˆ†æ

```sql
-- éœ€æ±‚åˆ†æè®°å½•è¡¨
CREATE TABLE requirement_analysis (
    req_id SERIAL PRIMARY KEY,
    project_name VARCHAR(200) NOT NULL,
    requirement_type VARCHAR(50) NOT NULL, -- 'functional', 'non-functional'
    requirement_text TEXT NOT NULL,
    priority INT DEFAULT 5, -- 1-10
    impact_on_modeling TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç¤ºä¾‹ï¼šç”µå•†ç³»ç»Ÿéœ€æ±‚åˆ†æ
INSERT INTO requirement_analysis (project_name, requirement_type, requirement_text, priority, impact_on_modeling) VALUES
    ('ç”µå•†ç³»ç»Ÿ', 'functional', 'æ”¯æŒç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€ä¸ªäººä¿¡æ¯ç®¡ç†', 9, 'éœ€è¦ç”¨æˆ·è¡¨ã€è®¤è¯è¡¨'),
    ('ç”µå•†ç³»ç»Ÿ', 'functional', 'æ”¯æŒå•†å“æµè§ˆã€æœç´¢ã€åˆ†ç±»', 10, 'éœ€è¦å•†å“è¡¨ã€åˆ†ç±»è¡¨ã€æœç´¢ç´¢å¼•'),
    ('ç”µå•†ç³»ç»Ÿ', 'functional', 'æ”¯æŒè®¢å•åˆ›å»ºã€æ”¯ä»˜ã€é…é€', 10, 'éœ€è¦è®¢å•è¡¨ã€æ”¯ä»˜è¡¨ã€é…é€è¡¨'),
    ('ç”µå•†ç³»ç»Ÿ', 'non-functional', 'æ”¯æŒ1000å¹¶å‘ç”¨æˆ·', 8, 'éœ€è¦è¿æ¥æ± ã€æŸ¥è¯¢ä¼˜åŒ–'),
    ('ç”µå•†ç³»ç»Ÿ', 'non-functional', 'æ•°æ®ä¿ç•™5å¹´', 7, 'éœ€è¦åˆ†åŒºç­–ç•¥ã€å½’æ¡£æ–¹æ¡ˆ');
```

### 2.3 æ•°æ®éœ€æ±‚åˆ†æ

**æ•°æ®ç‰¹å¾åˆ†æ**:

```sql
-- æ•°æ®ç‰¹å¾åˆ†æè¡¨
CREATE TABLE data_characteristics (
    char_id SERIAL PRIMARY KEY,
    entity_name VARCHAR(100) NOT NULL,
    -- æ•°æ®é‡ç‰¹å¾
    estimated_rows BIGINT,
    growth_rate NUMERIC(5,2), -- å¹´å¢é•¿ç‡%
    -- è®¿é—®ç‰¹å¾
    read_frequency VARCHAR(50), -- 'high', 'medium', 'low'
    write_frequency VARCHAR(50),
    -- æŸ¥è¯¢ç‰¹å¾
    typical_query_pattern TEXT,
    -- æ•°æ®ç‰¹å¾
    data_volatility VARCHAR(50), -- 'static', 'slow', 'fast'
    data_retention_years INT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç¤ºä¾‹ï¼šè®¢å•æ•°æ®ç‰¹å¾
INSERT INTO data_characteristics (
    entity_name, estimated_rows, growth_rate,
    read_frequency, write_frequency, data_volatility, data_retention_years
) VALUES (
    'è®¢å•è¡¨', 10000000, 50.0,
    'high', 'high', 'fast', 5
);
```

---

## 3. æ¶æ„é€‰æ‹©æ¡†æ¶

### 3.1 OLTP vs OLAPå†³ç­–

**å†³ç­–çŸ©é˜µ**:

| ç‰¹å¾ | OLTP | OLAP |
|------|------|------|
| ä¸»è¦ç”¨é€” | äº‹åŠ¡å¤„ç† | æ•°æ®åˆ†æ |
| æ•°æ®æ¨¡å‹ | è§„èŒƒåŒ–ï¼ˆ3NFï¼‰ | ç»´åº¦å»ºæ¨¡ |
| æŸ¥è¯¢ç±»å‹ | ç®€å•æŸ¥è¯¢ï¼Œå°‘é‡æ•°æ® | å¤æ‚æŸ¥è¯¢ï¼Œå¤§é‡æ•°æ® |
| å†™å…¥æ¨¡å¼ | é¢‘ç¹å†™å…¥ | æ‰¹é‡åŠ è½½ |
| ä¸€è‡´æ€§è¦æ±‚ | å¼ºä¸€è‡´æ€§ | æœ€ç»ˆä¸€è‡´æ€§ |
| å“åº”æ—¶é—´ | æ¯«ç§’çº§ | ç§’åˆ°åˆ†é’Ÿçº§ |

**å†³ç­–æµç¨‹**:

```sql
-- æ¶æ„é€‰æ‹©å†³ç­–è¡¨
CREATE TABLE architecture_decision (
    decision_id SERIAL PRIMARY KEY,
    scenario_description TEXT NOT NULL,
    -- è¯„ä¼°ç»´åº¦
    transaction_volume INT, -- äº‹åŠ¡é‡/ç§’
    query_complexity VARCHAR(50), -- 'simple', 'complex'
    data_volume BIGINT,
    consistency_requirement VARCHAR(50), -- 'strong', 'eventual'
    -- å†³ç­–ç»“æœ
    recommended_architecture VARCHAR(50), -- 'OLTP', 'OLAP', 'HTAP'
    reasoning TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å†³ç­–å‡½æ•°
CREATE OR REPLACE FUNCTION recommend_architecture(
    p_transaction_volume INT,
    p_query_complexity VARCHAR,
    p_data_volume BIGINT,
    p_consistency_requirement VARCHAR
)
RETURNS VARCHAR AS $$
BEGIN
    -- OLTPåœºæ™¯ï¼šé«˜äº‹åŠ¡é‡ã€ç®€å•æŸ¥è¯¢ã€å¼ºä¸€è‡´æ€§
    IF p_transaction_volume > 1000
       AND p_query_complexity = 'simple'
       AND p_consistency_requirement = 'strong' THEN
        RETURN 'OLTP';
    END IF;

    -- OLAPåœºæ™¯ï¼šä½äº‹åŠ¡é‡ã€å¤æ‚æŸ¥è¯¢ã€å¤§æ•°æ®é‡
    IF p_transaction_volume < 100
       AND p_query_complexity = 'complex'
       AND p_data_volume > 1000000000 THEN
        RETURN 'OLAP';
    END IF;

    -- HTAPåœºæ™¯ï¼šæ··åˆéœ€æ±‚
    RETURN 'HTAP';
END;
$$ LANGUAGE plpgsql;
```

### 3.2 æ•°æ®æ¨¡å‹é€‰æ‹©

**è§„èŒƒåŒ– vs ç»´åº¦å»ºæ¨¡**:

```sql
-- æ•°æ®æ¨¡å‹é€‰æ‹©å†³ç­–è¡¨
CREATE TABLE model_decision (
    decision_id SERIAL PRIMARY KEY,
    use_case VARCHAR(200) NOT NULL,
    -- è¯„ä¼°å› ç´ 
    is_transactional BOOLEAN,
    requires_history BOOLEAN,
    query_pattern VARCHAR(50), -- 'point_lookup', 'aggregation', 'scan'
    -- å†³ç­–ç»“æœ
    recommended_model VARCHAR(50), -- 'normalized', 'dimensional', 'hybrid'
    normalization_level INT, -- 1NF-5NF
    reasoning TEXT
);
```

---

## 4. æŠ€æœ¯é€‰å‹æ¡†æ¶

### 4.1 æ•°æ®ç±»å‹é€‰æ‹©å†³ç­–

**å†³ç­–æ ‘**:

```sql
-- æ•°æ®ç±»å‹é€‰æ‹©å†³ç­–å‡½æ•°
CREATE OR REPLACE FUNCTION select_data_type(
    p_data_kind VARCHAR, -- 'number', 'text', 'date', 'boolean', 'structured'
    p_range_min BIGINT DEFAULT NULL,
    p_range_max BIGINT DEFAULT NULL,
    p_precision INT DEFAULT NULL,
    p_scale INT DEFAULT NULL,
    p_max_length INT DEFAULT NULL,
    p_need_timezone BOOLEAN DEFAULT FALSE
)
RETURNS VARCHAR AS $$
BEGIN
    -- æ•°å€¼ç±»å‹
    IF p_data_kind = 'number' THEN
        IF p_precision IS NOT NULL THEN
            RETURN format('NUMERIC(%s, %s)', p_precision, COALESCE(p_scale, 0));
        ELSIF p_range_max <= 32767 THEN
            RETURN 'SMALLINT';
        ELSIF p_range_max <= 2147483647 THEN
            RETURN 'INTEGER';
        ELSE
            RETURN 'BIGINT';
        END IF;
    END IF;

    -- æ–‡æœ¬ç±»å‹
    IF p_data_kind = 'text' THEN
        IF p_max_length IS NOT NULL AND p_max_length <= 255 THEN
            RETURN format('VARCHAR(%s)', p_max_length);
        ELSE
            RETURN 'TEXT';
        END IF;
    END IF;

    -- æ—¥æœŸæ—¶é—´ç±»å‹
    IF p_data_kind = 'date' THEN
        IF p_need_timezone THEN
            RETURN 'TIMESTAMPTZ';
        ELSE
            RETURN 'TIMESTAMP';
        END IF;
    END IF;

    -- å¸ƒå°”ç±»å‹
    IF p_data_kind = 'boolean' THEN
        RETURN 'BOOLEAN';
    END IF;

    -- ç»“æ„åŒ–æ•°æ®
    IF p_data_kind = 'structured' THEN
        RETURN 'JSONB';
    END IF;

    RETURN 'TEXT'; -- é»˜è®¤
END;
$$ LANGUAGE plpgsql;
```

### 4.2 ç´¢å¼•ç­–ç•¥é€‰æ‹©å†³ç­–

```sql
-- ç´¢å¼•ç­–ç•¥é€‰æ‹©å‡½æ•°
CREATE OR REPLACE FUNCTION select_index_strategy(
    p_query_pattern VARCHAR, -- 'equality', 'range', 'prefix', 'full_text', 'spatial'
    p_data_type VARCHAR,
    p_cardinality BIGINT,
    p_update_frequency VARCHAR -- 'low', 'medium', 'high'
)
RETURNS VARCHAR AS $$
BEGIN
    -- ç­‰å€¼æŸ¥è¯¢ï¼šB-Treeæˆ–Hash
    IF p_query_pattern = 'equality' THEN
        IF p_update_frequency = 'low' THEN
            RETURN 'HASH';
        ELSE
            RETURN 'BTREE';
        END IF;
    END IF;

    -- èŒƒå›´æŸ¥è¯¢ï¼šB-Treeæˆ–BRIN
    IF p_query_pattern = 'range' THEN
        IF p_cardinality > 1000000 AND p_update_frequency = 'low' THEN
            RETURN 'BRIN';
        ELSE
            RETURN 'BTREE';
        END IF;
    END IF;

    -- å…¨æ–‡æœç´¢ï¼šGIN
    IF p_query_pattern = 'full_text' THEN
        RETURN 'GIN';
    END IF;

    -- ç©ºé—´æŸ¥è¯¢ï¼šGIST
    IF p_query_pattern = 'spatial' THEN
        RETURN 'GIST';
    END IF;

    RETURN 'BTREE'; -- é»˜è®¤
END;
$$ LANGUAGE plpgsql;
```

### 4.3 åˆ†åŒºç­–ç•¥é€‰æ‹©å†³ç­–

```sql
-- åˆ†åŒºç­–ç•¥é€‰æ‹©å‡½æ•°
CREATE OR REPLACE FUNCTION select_partition_strategy(
    p_table_size BIGINT,
    p_partition_key_type VARCHAR, -- 'date', 'id', 'region'
    p_query_pattern VARCHAR, -- 'time_range', 'id_range', 'list'
    p_data_distribution VARCHAR -- 'uniform', 'skewed'
)
RETURNS VARCHAR AS $$
BEGIN
    -- å¤§è¡¨æ‰éœ€è¦åˆ†åŒº
    IF p_table_size < 10000000 THEN
        RETURN 'NO_PARTITION';
    END IF;

    -- æ—¶é—´åˆ†åŒºï¼šRANGE
    IF p_partition_key_type = 'date' AND p_query_pattern = 'time_range' THEN
        RETURN 'RANGE';
    END IF;

    -- IDèŒƒå›´åˆ†åŒºï¼šRANGEæˆ–HASH
    IF p_partition_key_type = 'id' THEN
        IF p_data_distribution = 'uniform' THEN
            RETURN 'HASH';
        ELSE
            RETURN 'RANGE';
        END IF;
    END IF;

    -- åˆ—è¡¨åˆ†åŒºï¼šLIST
    IF p_query_pattern = 'list' THEN
        RETURN 'LIST';
    END IF;

    RETURN 'RANGE'; -- é»˜è®¤
END;
$$ LANGUAGE plpgsql;
```

---

## 5. å®æ–½å†³ç­–æ¡†æ¶

### 5.1 å®æ–½ä¼˜å…ˆçº§å†³ç­–

**ä¼˜å…ˆçº§è¯„ä¼°çŸ©é˜µ**:

```sql
-- å®æ–½ä¼˜å…ˆçº§è¯„ä¼°è¡¨
CREATE TABLE implementation_priority (
    task_id SERIAL PRIMARY KEY,
    task_name VARCHAR(200) NOT NULL,
    -- è¯„ä¼°ç»´åº¦ï¼ˆ1-10åˆ†ï¼‰
    business_value INT CHECK (business_value BETWEEN 1 AND 10),
    technical_complexity INT CHECK (technical_complexity BETWEEN 1 AND 10),
    risk_level INT CHECK (risk_level BETWEEN 1 AND 10),
    dependencies TEXT,
    -- è®¡ç®—ä¼˜å…ˆçº§
    priority_score NUMERIC GENERATED ALWAYS AS (
        business_value * 0.4 - technical_complexity * 0.3 - risk_level * 0.3
    ) STORED,
    recommended_order INT
);

-- ç¤ºä¾‹ï¼šç”µå•†ç³»ç»Ÿå®æ–½ä¼˜å…ˆçº§
INSERT INTO implementation_priority (task_name, business_value, technical_complexity, risk_level) VALUES
    ('ç”¨æˆ·è®¤è¯ç³»ç»Ÿ', 9, 3, 2),
    ('å•†å“ç›®å½•ç³»ç»Ÿ', 10, 5, 3),
    ('è®¢å•ç®¡ç†ç³»ç»Ÿ', 10, 7, 4),
    ('æ”¯ä»˜é›†æˆ', 9, 8, 6),
    ('æ•°æ®åˆ†ææŠ¥è¡¨', 7, 6, 3);

-- æŒ‰ä¼˜å…ˆçº§æ’åº
SELECT
    task_name,
    business_value,
    technical_complexity,
    risk_level,
    priority_score,
    ROW_NUMBER() OVER (ORDER BY priority_score DESC) AS recommended_order
FROM implementation_priority
ORDER BY priority_score DESC;
```

### 5.2 è¿ç§»ç­–ç•¥å†³ç­–

**è¿ç§»ç­–ç•¥é€‰æ‹©**:

```sql
-- è¿ç§»ç­–ç•¥å†³ç­–è¡¨
CREATE TABLE migration_strategy (
    strategy_id SERIAL PRIMARY KEY,
    scenario VARCHAR(200) NOT NULL,
    -- è¯„ä¼°å› ç´ 
    downtime_tolerance VARCHAR(50), -- 'zero', 'low', 'high'
    data_volume BIGINT,
    complexity_level VARCHAR(50), -- 'low', 'medium', 'high'
    -- æ¨èç­–ç•¥
    recommended_strategy VARCHAR(100), -- 'big_bang', 'parallel', 'gradual', 'blue_green'
    reasoning TEXT
);

-- è¿ç§»ç­–ç•¥å†³ç­–å‡½æ•°
CREATE OR REPLACE FUNCTION select_migration_strategy(
    p_downtime_tolerance VARCHAR,
    p_data_volume BIGINT,
    p_complexity_level VARCHAR
)
RETURNS VARCHAR AS $$
BEGIN
    -- é›¶åœæœºï¼šè“ç»¿éƒ¨ç½²
    IF p_downtime_tolerance = 'zero' THEN
        RETURN 'blue_green';
    END IF;

    -- å¤§æ•°æ®é‡+ä½å¤æ‚åº¦ï¼šå¹¶è¡Œè¿è¡Œ
    IF p_data_volume > 1000000000 AND p_complexity_level = 'low' THEN
        RETURN 'parallel';
    END IF;

    -- ä½å¤æ‚åº¦ï¼šå¤§çˆ†ç‚¸å¼
    IF p_complexity_level = 'low' THEN
        RETURN 'big_bang';
    END IF;

    -- é»˜è®¤ï¼šæ¸è¿›å¼
    RETURN 'gradual';
END;
$$ LANGUAGE plpgsql;
```

---

## 6. PostgreSQLå®ç°

### 6.1 ç»¼åˆå†³ç­–æ”¯æŒç³»ç»Ÿ

```sql
-- å†³ç­–è®°å½•è¡¨
CREATE TABLE modeling_decisions (
    decision_id SERIAL PRIMARY KEY,
    project_name VARCHAR(200) NOT NULL,
    decision_type VARCHAR(50) NOT NULL, -- 'architecture', 'data_type', 'index', 'partition'
    decision_context JSONB NOT NULL,
    decision_result VARCHAR(200) NOT NULL,
    reasoning TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by VARCHAR(100)
);

-- å†³ç­–æŸ¥è¯¢è§†å›¾
CREATE VIEW decision_summary AS
SELECT
    project_name,
    decision_type,
    COUNT(*) AS decision_count,
    jsonb_object_agg(decision_result, COUNT(*)) AS decisions
FROM modeling_decisions
GROUP BY project_name, decision_type;
```

---

## 7. ç›¸å…³èµ„æº

- [æ€ç»´è¡¨å¾æ–¹æ³•](./æ€ç»´è¡¨å¾æ–¹æ³•.md) - æ€ç»´å·¥å…·å’Œæ–¹æ³•
- [æˆæœ¬æ•ˆç›Šåˆ†æ](./æˆæœ¬æ•ˆç›Šåˆ†æ.md) - æˆæœ¬æ•ˆç›Šè¯„ä¼°
- [æ•°æ®ç±»å‹é€‰æ‹©](../08-PostgreSQLå»ºæ¨¡å®è·µ/æ•°æ®ç±»å‹é€‰æ‹©.md) - æ•°æ®ç±»å‹é€‰æ‹©æŒ‡å—
- [ç´¢å¼•ç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/ç´¢å¼•ç­–ç•¥.md) - ç´¢å¼•ç­–ç•¥æŒ‡å—
- [åˆ†åŒºç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/åˆ†åŒºç­–ç•¥.md) - åˆ†åŒºç­–ç•¥æŒ‡å—

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
