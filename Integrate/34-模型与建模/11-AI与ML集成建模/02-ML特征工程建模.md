# ML特征工程建模指南

> **创建日期**: 2025年1月
> **来源**: PostgreSQL 18+ + 实践总结
> **状态**: PostgreSQL 18+新特性
> **文档编号**: 11-02

---

## 📑 目录

- [ML特征工程建模指南](#ml特征工程建模指南)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 特征工程概念](#111-特征工程概念)
    - [1.1.2 特征类型理论](#112-特征类型理论)
    - [1.1.3 特征版本管理理论](#113-特征版本管理理论)
    - [1.1.4 特征服务理论](#114-特征服务理论)
    - [1.1.5 复杂度分析](#115-复杂度分析)
  - [2. 特征存储建模](#2-特征存储建模)
    - [2.1 特征定义表](#21-特征定义表)
    - [2.2 特征值表](#22-特征值表)
    - [2.3 向量特征表](#23-向量特征表)
  - [3. 特征版本管理](#3-特征版本管理)
    - [3.1 特征版本表](#31-特征版本表)
    - [3.2 特征血缘关系](#32-特征血缘关系)
  - [4. 特征计算管道](#4-特征计算管道)
    - [4.1 特征计算任务表](#41-特征计算任务表)
    - [4.2 特征计算日志](#42-特征计算日志)
  - [5. 特征服务建模](#5-特征服务建模)
    - [5.1 特征服务表](#51-特征服务表)
    - [5.2 特征请求日志](#52-特征请求日志)
  - [6. PostgreSQL 18优化](#6-postgresql-18优化)
    - [6.1 虚拟生成列优化](#61-虚拟生成列优化)
    - [6.2 异步I/O优化](#62-异步io优化)
    - [6.3 向量索引优化](#63-向量索引优化)
  - [7. 性能优化建议](#7-性能优化建议)
    - [7.1 索引优化策略](#71-索引优化策略)
    - [7.2 分区策略优化](#72-分区策略优化)
    - [7.3 物化视图缓存](#73-物化视图缓存)
    - [7.4 批量操作优化](#74-批量操作优化)
    - [7.5 PostgreSQL 18异步I/O优化](#75-postgresql-18异步io优化)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 特征存储](#81-特征存储)
    - [8.2 特征版本管理](#82-特征版本管理)
    - [8.3 特征服务](#83-特征服务)
    - [8.4 SQL实现注意事项](#84-sql实现注意事项)
  - [9. 常见问题与解决方案](#9-常见问题与解决方案)
    - [问题1: 特征查询性能慢](#问题1-特征查询性能慢)
    - [问题2: 向量特征相似度查询慢](#问题2-向量特征相似度查询慢)
    - [问题3: 特征值表数据量过大](#问题3-特征值表数据量过大)
    - [问题4: 特征版本管理复杂](#问题4-特征版本管理复杂)
  - [10. 相关资源](#10-相关资源)
    - [10.1 核心相关文档](#101-核心相关文档)
    - [10.2 官方资源](#102-官方资源)

---

## 1. 概述

特征工程是机器学习的关键环节，涉及特征的提取、转换、存储和服务。

**核心需求**:

- 特征存储和管理
- 特征版本控制
- 特征计算管道
- 特征服务（在线/离线）

---

## 1.1 理论基础

### 1.1.1 特征工程概念

**特征工程**是将原始数据转换为机器学习模型可用的特征的过程，包括：

1. **特征提取**: 从原始数据中提取有用信息
2. **特征转换**: 对特征进行标准化、归一化等转换
3. **特征选择**: 选择对模型最有用的特征
4. **特征存储**: 存储特征值供模型使用

### 1.1.2 特征类型理论

**数值特征（Numeric Features）**:

- **连续特征**: 可以取任意实数值（如年龄、收入）
- **离散特征**: 只能取特定值（如计数、排名）

**分类特征（Categorical Features）**:

- **有序分类**: 有顺序关系（如评级：低、中、高）
- **无序分类**: 无顺序关系（如颜色：红、绿、蓝）

**文本特征（Text Features）**:

- **词袋模型（Bag of Words）**: 将文本表示为词频向量
- **TF-IDF**: 词频-逆文档频率
- **词嵌入（Word Embeddings）**: 将词映射到向量空间

**向量特征（Vector Features）**:

- **密集向量**: 所有维度都有值
- **稀疏向量**: 大部分维度为0

### 1.1.3 特征版本管理理论

**特征版本控制原则**:

1. **不可变性**: 已发布的特征版本不可修改
2. **可追溯性**: 记录特征的来源和转换过程
3. **可重现性**: 能够重现特征的计算过程
4. **血缘关系**: 记录特征之间的依赖关系

**特征血缘图（Feature Lineage）**:

特征血缘图是一个有向无环图（DAG），表示特征之间的依赖关系：

$$G = (V, E)$$

其中：

- $V$: 特征节点集合
- $E$: 特征依赖边集合

### 1.1.4 特征服务理论

**在线特征服务（Online Feature Serving）**:

- **低延迟**: 毫秒级响应时间
- **高可用**: 99.9%+可用性
- **实时计算**: 支持实时特征计算

**离线特征服务（Offline Feature Serving）**:

- **批量计算**: 批量生成特征
- **高吞吐**: 支持大规模数据处理
- **预计算**: 预先计算特征值

### 1.1.5 复杂度分析

**存储复杂度**:

- **特征定义**: $O(F)$ where F is number of features
- **特征值**: $O(F \times E)$ where E is number of entities
- **特征版本**: $O(F \times V)$ where V is number of versions

**查询复杂度**:

- **单特征查询**: $O(\log E)$ with index
- **批量特征查询**: $O(F \times \log E)$
- **特征血缘查询**: $O(V + E)$ graph traversal

---

## 2. 特征存储建模

### 2.1 特征定义表

```sql
-- 特征定义表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_definitions (
        id SERIAL PRIMARY KEY,
        feature_name VARCHAR(255) NOT NULL,
        feature_type VARCHAR(50) NOT NULL,  -- 'numeric', 'categorical', 'text', 'vector', etc.
        description TEXT,
        data_type VARCHAR(50),  -- 'int', 'float', 'string', 'jsonb', 'vector'
        dimension INTEGER,  -- 向量维度（如果是vector类型）
        default_value TEXT,
        validation_rules JSONB DEFAULT '{}',  -- 验证规则
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(feature_name)
    );
    RAISE NOTICE '表 feature_definitions 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 feature_definitions 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 feature_definitions 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_feature_definitions_type ON feature_definitions(feature_type);
    CREATE INDEX IF NOT EXISTS idx_feature_definitions_created_at ON feature_definitions(created_at DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 2.2 特征值表

```sql
-- 通用特征值表（适用于所有特征类型，带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'feature_values') THEN
        CREATE TABLE feature_values (
            id BIGSERIAL,
            feature_name VARCHAR(255) NOT NULL REFERENCES feature_definitions(feature_name),
            entity_id VARCHAR(255) NOT NULL,  -- 实体ID（用户ID、商品ID等）
            entity_type VARCHAR(50) NOT NULL,  -- 实体类型（'user', 'product', 'order', etc.）
            feature_value JSONB NOT NULL,  -- 特征值（支持各种类型）
            timestamp TIMESTAMPTZ DEFAULT NOW(),
            version VARCHAR(50),  -- 特征版本
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ DEFAULT NOW(),
            PRIMARY KEY (id, timestamp),
            UNIQUE(feature_name, entity_id, entity_type, timestamp)
        ) PARTITION BY RANGE (timestamp);  -- 按时间分区
        RAISE NOTICE '分区表 feature_values 创建成功';
    ELSE
        RAISE NOTICE '表 feature_values 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表 feature_values 失败: %', SQLERRM;
END $$;

-- 创建月度分区（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_values_2024_01 PARTITION OF feature_values
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
    RAISE NOTICE '分区创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '分区已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE WARNING '创建分区失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_feature_values_feature_entity ON feature_values(feature_name, entity_id, entity_type, timestamp DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

CREATE INDEX idx_feature_values_entity ON feature_values(entity_id, entity_type, timestamp DESC);

```

### 2.3 向量特征表

```sql
-- 向量特征专用表（pgvector优化，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS vector_features (
        id BIGSERIAL PRIMARY KEY,
        feature_name VARCHAR(255) NOT NULL REFERENCES feature_definitions(feature_name),
        entity_id VARCHAR(255) NOT NULL,
        entity_type VARCHAR(50) NOT NULL,
        feature_vector vector(1536) NOT NULL,  -- 向量特征
        timestamp TIMESTAMPTZ DEFAULT NOW(),
        version VARCHAR(50),
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(feature_name, entity_id, entity_type, timestamp)
    );
    RAISE NOTICE '表 vector_features 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 vector_features 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 vector_features 失败: %', SQLERRM;
END $$;

-- 创建向量索引（HNSW，带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_vector_features_hnsw
    ON vector_features USING hnsw (feature_vector vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);
    RAISE NOTICE '向量索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建向量索引失败: %', SQLERRM;
END $$;

-- 创建实体索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_vector_features_entity ON vector_features(feature_name, entity_id, entity_type);
    RAISE NOTICE '实体索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建实体索引失败: %', SQLERRM;
END $$;

CREATE INDEX idx_vector_features_entity ON vector_features(entity_id, entity_type, timestamp DESC);

```

---

## 3. 特征版本管理

### 3.1 特征版本表

```sql
-- 特征版本表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_versions (
        id SERIAL PRIMARY KEY,
        feature_name VARCHAR(255) NOT NULL REFERENCES feature_definitions(feature_name),
        version VARCHAR(50) NOT NULL,
        version_type VARCHAR(20) NOT NULL CHECK (version_type IN ('major', 'minor', 'patch')),
        transformation_code TEXT,  -- 特征转换代码
        transformation_config JSONB DEFAULT '{}',  -- 转换配置
        is_active BOOLEAN DEFAULT FALSE,
        is_production BOOLEAN DEFAULT FALSE,
        performance_metrics JSONB DEFAULT '{}',  -- 性能指标
        created_at TIMESTAMPTZ DEFAULT NOW(),
        created_by VARCHAR(255),
        notes TEXT,
        UNIQUE(feature_name, version)
    );
    RAISE NOTICE '表 feature_versions 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 feature_versions 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 feature_versions 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_feature_versions_feature ON feature_versions(feature_name);
    CREATE INDEX IF NOT EXISTS idx_feature_versions_active ON feature_versions(feature_name, is_active) WHERE is_active = TRUE;
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 3.2 特征血缘关系

```sql
-- 特征血缘关系表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_lineage (
        id SERIAL PRIMARY KEY,
        feature_name VARCHAR(255) NOT NULL REFERENCES feature_definitions(feature_name),
        source_feature_name VARCHAR(255) REFERENCES feature_definitions(feature_name),
        transformation_type VARCHAR(50),  -- 'aggregation', 'transformation', 'join', etc.
        transformation_details JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 feature_lineage 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 feature_lineage 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 feature_lineage 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_feature_lineage_feature ON feature_lineage(feature_name);
    CREATE INDEX IF NOT EXISTS idx_feature_lineage_source ON feature_lineage(source_feature_name);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

---

## 4. 特征计算管道

### 4.1 特征计算任务表

```sql
-- 特征计算任务表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_computation_tasks (
        id SERIAL PRIMARY KEY,
        task_name VARCHAR(255) NOT NULL,
        feature_name VARCHAR(255) NOT NULL REFERENCES feature_definitions(feature_name),
        computation_type VARCHAR(50) NOT NULL,  -- 'batch', 'streaming', 'on-demand'
        status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'running', 'completed', 'failed')),
        schedule_config JSONB DEFAULT '{}',  -- 调度配置
        computation_config JSONB DEFAULT '{}',  -- 计算配置
        started_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        duration INTERVAL GENERATED ALWAYS AS (completed_at - started_at) VIRTUAL,  -- PostgreSQL 18虚拟生成列
        records_processed BIGINT,
        error_message TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 feature_computation_tasks 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 feature_computation_tasks 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 feature_computation_tasks 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_feature_computation_tasks_feature ON feature_computation_tasks(feature_name);
    CREATE INDEX IF NOT EXISTS idx_feature_computation_tasks_status ON feature_computation_tasks(status);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

CREATE INDEX idx_feature_computation_tasks_started_at ON feature_computation_tasks(started_at DESC);

```

### 4.2 特征计算日志

```sql
-- 特征计算日志表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'feature_computation_logs') THEN
        CREATE TABLE feature_computation_logs (
            id BIGSERIAL,
            task_id INTEGER NOT NULL REFERENCES feature_computation_tasks(id),
            log_level VARCHAR(20) NOT NULL CHECK (log_level IN ('info', 'warning', 'error')),
            log_message TEXT NOT NULL,
            log_data JSONB DEFAULT '{}',
            created_at TIMESTAMPTZ DEFAULT NOW(),
            PRIMARY KEY (id, created_at)
        ) PARTITION BY RANGE (created_at);
        RAISE NOTICE '分区表 feature_computation_logs 创建成功';
    ELSE
        RAISE NOTICE '表 feature_computation_logs 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表 feature_computation_logs 失败: %', SQLERRM;
END $$;

-- 创建月度分区（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_computation_logs_2024_01 PARTITION OF feature_computation_logs
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
    RAISE NOTICE '分区创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '分区已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE WARNING '创建分区失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_feature_computation_logs_task ON feature_computation_logs(task_id, created_at DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

---

## 5. 特征服务建模

### 5.1 特征服务表

```sql
-- 特征服务表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_services (
        id SERIAL PRIMARY KEY,
        service_name VARCHAR(255) NOT NULL,
        service_type VARCHAR(50) NOT NULL CHECK (service_type IN ('online', 'offline', 'hybrid')),
        endpoint_url TEXT,
        api_key VARCHAR(255),
        supported_features TEXT[],  -- 支持的特征列表
        config JSONB DEFAULT '{}',
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(service_name)
    );
    RAISE NOTICE '表 feature_services 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 feature_services 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 feature_services 失败: %', SQLERRM;
END $$;
```

### 5.2 特征请求日志

```sql
-- 特征请求表（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'feature_requests') THEN
        CREATE TABLE feature_requests (
            id BIGSERIAL,
            service_id INTEGER NOT NULL REFERENCES feature_services(id),
            request_id VARCHAR(255) UNIQUE,
            entity_id VARCHAR(255) NOT NULL,
            entity_type VARCHAR(50) NOT NULL,
            requested_features TEXT[],  -- 请求的特征列表
            response_data JSONB,
            processing_time_ms INTEGER,
            status VARCHAR(20) NOT NULL CHECK (status IN ('success', 'error', 'timeout')),
            error_message TEXT,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            PRIMARY KEY (id, created_at)
        ) PARTITION BY RANGE (created_at);
        RAISE NOTICE '分区表 feature_requests 创建成功';
    ELSE
        RAISE NOTICE '表 feature_requests 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表 feature_requests 失败: %', SQLERRM;
END $$;

-- 创建月度分区（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS feature_requests_2024_01 PARTITION OF feature_requests
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
    RAISE NOTICE '分区创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '分区已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE WARNING '创建分区失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_feature_requests_service ON feature_requests(service_id, created_at DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

CREATE INDEX idx_feature_requests_entity ON feature_requests(entity_id, entity_type, created_at DESC);
CREATE INDEX idx_feature_requests_status ON feature_requests(status, created_at DESC);

```

---

## 6. PostgreSQL 18优化

### 6.1 虚拟生成列优化

```sql
-- PostgreSQL 18：使用虚拟生成列优化计算字段
ALTER TABLE feature_computation_tasks
ADD COLUMN duration INTERVAL GENERATED ALWAYS AS (
    completed_at - started_at
) VIRTUAL;

-- 在虚拟生成列上创建索引（PostgreSQL 18支持）
CREATE INDEX idx_feature_computation_tasks_duration ON feature_computation_tasks (duration)
WHERE completed_at IS NOT NULL;
```

### 6.2 异步I/O优化

```sql
-- PostgreSQL 18：异步I/O优化（批量特征值写入）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET io_direct = 'data';
    ALTER SYSTEM SET io_combine_limit = '256kB';
    PERFORM pg_reload_conf();
    RAISE NOTICE '异步I/O配置已更新（特征值批量写入性能提升50-60%）';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '配置异步I/O失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;
```

### 6.3 向量索引优化

```sql
-- PostgreSQL 18：GIN并行构建优化（向量特征索引）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET max_parallel_maintenance_workers = 8;
    PERFORM pg_reload_conf();
    RAISE NOTICE 'GIN并行构建已配置（向量特征索引构建速度提升3-4倍）';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '配置GIN并行构建失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;
```

---

## 7. 性能优化建议

### 7.1 索引优化策略

**特征值查询优化**:

```sql
-- 为常用查询创建复合索引
CREATE INDEX idx_feature_values_entity ON feature_values(entity_type, entity_id, timestamp DESC);
CREATE INDEX idx_feature_values_feature_entity ON feature_values(feature_name, entity_id, timestamp DESC);

-- 为JSONB字段创建GIN索引（PostgreSQL 18优化）
CREATE INDEX idx_feature_values_value ON feature_values USING gin(feature_value);
```

**向量特征索引优化**:

```sql
-- 使用pgvector的HNSW索引优化向量相似度查询
CREATE INDEX idx_vector_features_vector ON vector_features
USING hnsw (feature_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

### 7.2 分区策略优化

**时间分区优化**:

```sql
-- 按时间分区存储特征值（PostgreSQL 18声明式分区）
CREATE TABLE feature_values (
    id BIGSERIAL,
    feature_name VARCHAR(255) NOT NULL,
    entity_id VARCHAR(255) NOT NULL,
    feature_value JSONB NOT NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (id, timestamp)
) PARTITION BY RANGE (timestamp);

-- 创建月度分区
CREATE TABLE feature_values_2025_01 PARTITION OF feature_values
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### 7.3 物化视图缓存

**缓存热点特征**:

```sql
-- 创建物化视图缓存常用特征
CREATE MATERIALIZED VIEW mv_feature_cache AS
SELECT
    feature_name,
    entity_id,
    entity_type,
    feature_value,
    timestamp
FROM feature_values
WHERE feature_name IN ('user_age', 'user_income', 'product_category')
  AND timestamp >= NOW() - INTERVAL '7 days';

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_feature_cache;
```

### 7.4 批量操作优化

**批量特征写入**:

```sql
-- 使用COPY命令批量插入（性能提升10-100倍）
COPY feature_values (feature_name, entity_id, entity_type, feature_value, timestamp)
FROM STDIN WITH (FORMAT csv);
```

### 7.5 PostgreSQL 18异步I/O优化

**异步I/O配置**:

```sql
-- PostgreSQL 18：启用异步I/O优化特征写入
ALTER SYSTEM SET io_direct = 'data';
ALTER SYSTEM SET io_combine_limit = '256kB';
SELECT pg_reload_conf();
```

---

## 8. 最佳实践

### 8.1 特征存储

1. **分区策略**: 按时间分区，便于数据管理和清理
2. **索引优化**: 为常用查询模式创建索引
3. **向量优化**: 向量特征使用专用表和HNSW索引
4. **数据压缩**: 使用PostgreSQL的压缩功能减少存储空间

### 8.2 特征版本管理

1. **语义化版本**: 使用语义化版本号
2. **版本激活**: 同时只激活一个版本
3. **血缘追踪**: 记录特征之间的依赖关系
4. **版本回滚**: 保留历史版本，支持快速回滚

### 8.3 特征服务

1. **缓存策略**: 对热点特征进行缓存
2. **批量查询**: 支持批量特征查询
3. **监控告警**: 监控特征服务的性能和可用性
4. **降级策略**: 实现特征服务的降级策略

### 8.4 SQL实现注意事项

1. **错误处理**: 使用DO块处理特征操作错误
2. **事务管理**: 特征更新应在事务中执行
3. **性能监控**: 使用EXPLAIN (ANALYZE, BUFFERS, TIMING)分析查询性能
4. **数据一致性**: 确保特征值和特征定义的一致性

---

## 9. 常见问题与解决方案

### 问题1: 特征查询性能慢

**原因**:

- 缺少索引
- 全表扫描
- JSONB字段查询未使用索引

**解决方案**:

- 为常用查询字段创建索引
- 为JSONB字段创建GIN索引
- 使用物化视图缓存热点特征

**示例**:

```sql
-- 优化前：全表扫描
SELECT feature_value
FROM feature_values
WHERE entity_id = 'user_1' AND feature_name = 'user_age';

-- 优化后：使用索引
CREATE INDEX idx_feature_values_entity_feature
ON feature_values(entity_id, feature_name, timestamp DESC);

SELECT feature_value
FROM feature_values
WHERE entity_id = 'user_1' AND feature_name = 'user_age'
ORDER BY timestamp DESC
LIMIT 1;
```

### 问题2: 向量特征相似度查询慢

**原因**:

- 缺少向量索引
- 使用线性扫描
- 向量维度过高

**解决方案**:

- 使用pgvector的HNSW索引
- 降低向量维度（使用PCA等降维技术）
- 使用近似最近邻搜索

**示例**:

```sql
-- 优化后：使用HNSW索引
CREATE INDEX idx_vector_features_vector ON vector_features
USING hnsw (feature_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

SELECT entity_id, feature_vector <-> $query_vector AS distance
FROM vector_features
ORDER BY feature_vector <-> $query_vector
LIMIT 10;
```

### 问题3: 特征值表数据量过大

**原因**:

- 特征值未分区
- 历史数据未归档
- 缺少数据保留策略

**解决方案**:

- 使用时间分区表
- 定期归档历史数据
- 实施数据保留策略

### 问题4: 特征版本管理复杂

**原因**:

- 版本信息分散
- 缺少版本比较工具
- 版本回滚困难

**解决方案**:

- 集中管理版本信息
- 创建版本比较视图
- 实现版本回滚机制

---

## 10. 相关资源

### 10.1 核心相关文档

- [向量数据库建模](../08-PostgreSQL建模实践/向量数据库建模.md) - pgvector建模指南
- [PostgreSQL18新特性](../08-PostgreSQL建模实践/PostgreSQL18新特性.md) - PostgreSQL 18新特性指南
- [性能优化](../08-PostgreSQL建模实践/性能优化.md) - 性能优化指南

### 10.2 官方资源

- [pgvector GitHub](https://github.com/pgvector/pgvector) - pgvector官方仓库
- [PostgreSQL 18文档](https://www.postgresql.org/docs/18/) - PostgreSQL 18官方文档

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**状态**: ✅ 已完成
