# AI模型数据建模指南

> **创建日期**: 2025年1月
> **来源**: PostgreSQL 18+ + pgvector + 实践总结
> **状态**: PostgreSQL 18+新特性
> **文档编号**: 11-01

---

## 📑 目录

- [AI模型数据建模指南](#ai模型数据建模指南)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 AI模型生命周期管理](#111-ai模型生命周期管理)
    - [1.1.2 模型版本管理理论](#112-模型版本管理理论)
    - [1.1.3 模型评估指标理论](#113-模型评估指标理论)
    - [1.1.4 数据建模复杂度分析](#114-数据建模复杂度分析)
  - [2. 模型元数据建模](#2-模型元数据建模)
    - [2.1 模型表设计](#21-模型表设计)
    - [2.2 模型参数表](#22-模型参数表)
  - [3. 模型版本管理](#3-模型版本管理)
    - [3.1 模型版本表](#31-模型版本表)
    - [3.2 版本比较和回滚](#32-版本比较和回滚)
  - [4. 模型训练数据建模](#4-模型训练数据建模)
    - [4.1 训练数据集表](#41-训练数据集表)
    - [4.2 训练记录表](#42-训练记录表)
  - [5. 模型评估数据建模](#5-模型评估数据建模)
    - [5.1 评估指标表](#51-评估指标表)
    - [5.2 评估结果汇总](#52-评估结果汇总)
  - [6. 模型部署数据建模](#6-模型部署数据建模)
    - [6.1 部署环境表](#61-部署环境表)
    - [6.2 模型部署表](#62-模型部署表)
    - [6.3 推理请求日志](#63-推理请求日志)
  - [7. PostgreSQL 18优化](#7-postgresql-18优化)
    - [7.1 虚拟生成列优化](#71-虚拟生成列优化)
    - [7.2 异步I/O优化](#72-异步io优化)
  - [8. 性能优化建议](#8-性能优化建议)
    - [8.1 索引优化策略](#81-索引优化策略)
    - [8.2 分区策略](#82-分区策略)
    - [8.3 物化视图缓存](#83-物化视图缓存)
    - [8.4 批量操作优化](#84-批量操作优化)
    - [8.5 PostgreSQL 18异步I/O优化](#85-postgresql-18异步io优化)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 模型版本管理](#91-模型版本管理)
    - [9.2 训练数据管理](#92-训练数据管理)
    - [9.3 评估和监控](#93-评估和监控)
    - [9.4 SQL实现注意事项](#94-sql实现注意事项)
  - [10. 常见问题与解决方案](#10-常见问题与解决方案)
    - [问题1: 模型版本查询性能慢](#问题1-模型版本查询性能慢)
    - [问题2: 训练记录表数据量过大](#问题2-训练记录表数据量过大)
    - [问题3: 模型性能指标查询复杂](#问题3-模型性能指标查询复杂)
    - [问题4: 模型文件存储路径管理](#问题4-模型文件存储路径管理)
  - [11. 相关资源](#11-相关资源)
    - [11.1 核心相关文档](#111-核心相关文档)
    - [11.2 官方资源](#112-官方资源)

---

## 1. 概述

AI模型数据建模涉及模型元数据、版本管理、训练数据、评估数据、部署数据等的存储和管理。

**核心需求**:

- 模型元数据管理
- 模型版本控制
- 训练数据管理
- 评估指标存储
- 模型部署跟踪

---

## 1.1 理论基础

### 1.1.1 AI模型生命周期管理

**AI模型生命周期**包括以下阶段：

1. **模型开发**: 模型设计、参数配置、超参数调优
2. **模型训练**: 使用训练数据集训练模型
3. **模型评估**: 使用验证/测试集评估模型性能
4. **模型部署**: 将模型部署到生产环境
5. **模型监控**: 监控模型在生产环境的性能
6. **模型迭代**: 基于监控结果优化和重新训练模型

### 1.1.2 模型版本管理理论

**语义化版本控制（Semantic Versioning）**:

版本号格式：`MAJOR.MINOR.PATCH`

- **MAJOR**: 不兼容的API变更
- **MINOR**: 向后兼容的功能新增
- **PATCH**: 向后兼容的问题修复

**模型版本管理原则**:

1. **不可变性**: 已发布的模型版本不可修改
2. **可追溯性**: 每个版本应记录完整的元数据
3. **可回滚性**: 支持快速回滚到历史版本
4. **可比较性**: 版本间性能指标可比较

### 1.1.3 模型评估指标理论

**分类模型指标**:

- **准确率（Accuracy）**: $Accuracy = \frac{TP + TN}{TP + TN + FP + FN}$
- **精确率（Precision）**: $Precision = \frac{TP}{TP + FP}$
- **召回率（Recall）**: $Recall = \frac{TP}{TP + FN}$
- **F1分数**: $F1 = 2 \times \frac{Precision \times Recall}{Precision + Recall}$

**回归模型指标**:

- **均方误差（MSE）**: $MSE = \frac{1}{n}\sum_{i=1}^{n}(y_i - \hat{y}_i)^2$
- **均方根误差（RMSE）**: $RMSE = \sqrt{MSE}$
- **平均绝对误差（MAE）**: $MAE = \frac{1}{n}\sum_{i=1}^{n}|y_i - \hat{y}_i|$
- **R²分数**: $R^2 = 1 - \frac{SS_{res}}{SS_{tot}}$

### 1.1.4 数据建模复杂度分析

**存储复杂度**:

- **模型元数据**: $O(1)$ per model
- **模型版本**: $O(V)$ where V is number of versions
- **训练数据**: $O(D)$ where D is dataset size
- **评估指标**: $O(M \times V)$ where M is number of metrics

**查询复杂度**:

- **模型查找**: $O(\log N)$ with index (N is number of models)
- **版本比较**: $O(V)$ linear scan
- **性能查询**: $O(\log M)$ with index (M is number of metrics)

---

## 2. 模型元数据建模

### 2.1 模型表设计

```sql
-- 创建模型表（带错误处理）
DO $$
BEGIN
    CREATE TABLE ai_models (
        id SERIAL PRIMARY KEY,
        model_name VARCHAR(255) NOT NULL,
        model_type VARCHAR(50) NOT NULL,  -- 'embedding', 'classification', 'regression', etc.
        model_framework VARCHAR(50),  -- 'pytorch', 'tensorflow', 'huggingface', etc.
        description TEXT,
        input_dimension INTEGER,  -- 输入维度
        output_dimension INTEGER,  -- 输出维度
        model_path TEXT,  -- 模型文件路径
        config JSONB DEFAULT '{}',  -- 模型配置
        metadata JSONB DEFAULT '{}',  -- 额外元数据
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(model_name)
    );
    RAISE NOTICE '表 ai_models 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 ai_models 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 ai_models 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_ai_models_type ON ai_models(model_type);
    CREATE INDEX IF NOT EXISTS idx_ai_models_framework ON ai_models(model_framework);
    CREATE INDEX IF NOT EXISTS idx_ai_models_created_at ON ai_models(created_at DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 2.2 模型参数表

```sql
-- 创建模型参数表（带错误处理）
DO $$
BEGIN
    CREATE TABLE model_parameters (
        id SERIAL PRIMARY KEY,
        model_id INTEGER NOT NULL REFERENCES ai_models(id) ON DELETE CASCADE,
        parameter_name VARCHAR(255) NOT NULL,
        parameter_value TEXT NOT NULL,
        parameter_type VARCHAR(50),  -- 'int', 'float', 'string', 'json'
        description TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(model_id, parameter_name)
    );
    RAISE NOTICE '表 model_parameters 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 model_parameters 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 model_parameters 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_model_parameters_model_id ON model_parameters(model_id);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

---

## 3. 模型版本管理

### 3.1 模型版本表

```sql
-- 创建模型版本表（带错误处理）
DO $$
BEGIN
    CREATE TABLE model_versions (
        id SERIAL PRIMARY KEY,
        model_id INTEGER NOT NULL REFERENCES ai_models(id) ON DELETE CASCADE,
        version VARCHAR(50) NOT NULL,  -- '1.0.0', 'v2.1', etc.
        version_type VARCHAR(20) NOT NULL CHECK (version_type IN ('major', 'minor', 'patch', 'experimental')),
        model_file_path TEXT NOT NULL,
        checksum VARCHAR(64),  -- 模型文件校验和
        training_config JSONB DEFAULT '{}',  -- 训练配置
        performance_metrics JSONB DEFAULT '{}',  -- 性能指标
        is_active BOOLEAN DEFAULT FALSE,  -- 是否激活
        is_production BOOLEAN DEFAULT FALSE,  -- 是否生产环境
        created_at TIMESTAMPTZ DEFAULT NOW(),
        created_by VARCHAR(255),
        notes TEXT,
        UNIQUE(model_id, version)
    );
    RAISE NOTICE '表 model_versions 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 model_versions 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 model_versions 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_model_versions_model_id ON model_versions(model_id);
    CREATE INDEX IF NOT EXISTS idx_model_versions_active ON model_versions(model_id, is_active) WHERE is_active = TRUE;
    CREATE INDEX IF NOT EXISTS idx_model_versions_production ON model_versions(model_id, is_production) WHERE is_production = TRUE;
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 3.2 版本比较和回滚

```sql
-- 获取模型的所有版本（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    mv.version,
    mv.version_type,
    mv.performance_metrics,
    mv.is_active,
    mv.is_production,
    mv.created_at
FROM model_versions mv
WHERE mv.model_id = 1
ORDER BY mv.created_at DESC;

-- 激活特定版本（带错误处理）
DO $$
DECLARE
    v_model_id INTEGER := 1;
    v_version VARCHAR(50) := '1.0.0';
BEGIN
    -- 先取消所有版本的激活状态
    UPDATE model_versions
    SET is_active = FALSE
    WHERE model_id = v_model_id;

    -- 激活指定版本
    UPDATE model_versions
    SET is_active = TRUE
    WHERE model_id = v_model_id AND version = v_version;

    IF NOT FOUND THEN
        RAISE EXCEPTION '版本 % 不存在', v_version;
    END IF;

    RAISE NOTICE '版本 % 已激活', v_version;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '激活版本失败: %', SQLERRM;
END $$;

-- 回滚到上一个版本（带错误处理）
DO $$
DECLARE
    v_model_id INTEGER := 1;
    v_prev_version VARCHAR(50);
BEGIN
    WITH current_version AS (
        SELECT version, created_at
        FROM model_versions
        WHERE model_id = v_model_id AND is_active = TRUE
    )
    SELECT version INTO v_prev_version
    FROM model_versions
    WHERE model_id = v_model_id
      AND created_at < (SELECT created_at FROM current_version)
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_prev_version IS NULL THEN
        RAISE EXCEPTION '没有可回滚的版本';
    END IF;

    -- 取消当前版本
    UPDATE model_versions
    SET is_active = FALSE
    WHERE model_id = v_model_id AND is_active = TRUE;

    -- 激活上一个版本
    UPDATE model_versions
    SET is_active = TRUE
    WHERE model_id = v_model_id AND version = v_prev_version;

    RAISE NOTICE '已回滚到版本 %', v_prev_version;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '回滚失败: %', SQLERRM;
END $$;
```

---

## 4. 模型训练数据建模

### 4.1 训练数据集表

```sql
-- 创建训练数据集表（带错误处理）
DO $$
BEGIN
    CREATE TABLE training_datasets (
        id SERIAL PRIMARY KEY,
        dataset_name VARCHAR(255) NOT NULL,
        dataset_type VARCHAR(50) NOT NULL,  -- 'text', 'image', 'tabular', etc.
        description TEXT,
        data_path TEXT,  -- 数据集路径
        total_samples INTEGER,
        train_samples INTEGER,
        validation_samples INTEGER,
        test_samples INTEGER,
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(dataset_name)
    );
    RAISE NOTICE '表 training_datasets 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 training_datasets 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 training_datasets 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_training_datasets_type ON training_datasets(dataset_type);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 4.2 训练记录表

```sql
-- 创建训练记录表（带错误处理）
DO $$
BEGIN
    CREATE TABLE training_runs (
        id SERIAL PRIMARY KEY,
        model_version_id INTEGER NOT NULL REFERENCES model_versions(id) ON DELETE CASCADE,
        dataset_id INTEGER NOT NULL REFERENCES training_datasets(id),
        run_name VARCHAR(255),
        status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'running', 'completed', 'failed', 'cancelled')),
        started_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        duration INTERVAL GENERATED ALWAYS AS (completed_at - started_at) VIRTUAL,  -- PostgreSQL 18虚拟生成列
        training_config JSONB DEFAULT '{}',
        hyperparameters JSONB DEFAULT '{}',
        training_loss JSONB DEFAULT '[]',  -- 训练损失历史
        validation_loss JSONB DEFAULT '[]',  -- 验证损失历史
        metrics JSONB DEFAULT '{}',  -- 训练指标
        error_message TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        created_by VARCHAR(255)
    );
    RAISE NOTICE '表 training_runs 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 training_runs 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 training_runs 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_training_runs_model_version ON training_runs(model_version_id);
    CREATE INDEX IF NOT EXISTS idx_training_runs_status ON training_runs(status);
    CREATE INDEX IF NOT EXISTS idx_training_runs_started_at ON training_runs(started_at DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

---

## 5. 模型评估数据建模

### 5.1 评估指标表

```sql
-- 创建评估指标表（带错误处理）
DO $$
BEGIN
    CREATE TABLE model_evaluations (
        id SERIAL PRIMARY KEY,
        model_version_id INTEGER NOT NULL REFERENCES model_versions(id) ON DELETE CASCADE,
        evaluation_dataset_id INTEGER REFERENCES training_datasets(id),
        evaluation_type VARCHAR(50) NOT NULL,  -- 'accuracy', 'f1', 'precision', 'recall', 'mse', etc.
        metric_name VARCHAR(100) NOT NULL,
        metric_value NUMERIC(10,6) NOT NULL,
        evaluation_config JSONB DEFAULT '{}',
        evaluated_at TIMESTAMPTZ DEFAULT NOW(),
        notes TEXT
    );
    RAISE NOTICE '表 model_evaluations 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 model_evaluations 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 model_evaluations 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_model_evaluations_model_version ON model_evaluations(model_version_id);
    CREATE INDEX IF NOT EXISTS idx_model_evaluations_type ON model_evaluations(evaluation_type);
    CREATE INDEX IF NOT EXISTS idx_model_evaluations_evaluated_at ON model_evaluations(evaluated_at DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 5.2 评估结果汇总

```sql
-- 获取模型版本的所有评估指标（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    mv.version,
    me.metric_name,
    me.metric_value,
    me.evaluated_at
FROM model_versions mv
JOIN model_evaluations me ON mv.id = me.model_version_id
WHERE mv.model_id = 1
ORDER BY me.evaluated_at DESC;

-- 比较不同版本的性能（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH version_metrics AS (
    SELECT
        mv.version,
        me.metric_name,
        AVG(me.metric_value) AS avg_metric_value
    FROM model_versions mv
    JOIN model_evaluations me ON mv.id = me.model_version_id
    WHERE mv.model_id = 1
    GROUP BY mv.version, me.metric_name
)
SELECT
    metric_name,
    jsonb_object_agg(version, avg_metric_value) AS version_comparison
FROM version_metrics
GROUP BY metric_name;
```

---

## 6. 模型部署数据建模

### 6.1 部署环境表

```sql
-- 创建部署环境表（带错误处理）
DO $$
BEGIN
    CREATE TABLE deployment_environments (
        id SERIAL PRIMARY KEY,
        environment_name VARCHAR(100) NOT NULL,
        environment_type VARCHAR(50) NOT NULL CHECK (environment_type IN ('development', 'staging', 'production')),
        endpoint_url TEXT,
        api_key VARCHAR(255),
        config JSONB DEFAULT '{}',
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW(),
        UNIQUE(environment_name)
    );
    RAISE NOTICE '表 deployment_environments 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 deployment_environments 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 deployment_environments 失败: %', SQLERRM;
END $$;
```

### 6.2 模型部署表

```sql
-- 创建模型部署表（带错误处理）
DO $$
BEGIN
    CREATE TABLE model_deployments (
        id SERIAL PRIMARY KEY,
        model_version_id INTEGER NOT NULL REFERENCES model_versions(id) ON DELETE CASCADE,
        environment_id INTEGER NOT NULL REFERENCES deployment_environments(id),
        deployment_status VARCHAR(20) NOT NULL CHECK (deployment_status IN ('pending', 'deploying', 'active', 'inactive', 'failed')),
        deployed_at TIMESTAMPTZ,
        undeployed_at TIMESTAMPTZ,
        deployment_config JSONB DEFAULT '{}',
        health_check_url TEXT,
        last_health_check TIMESTAMPTZ,
        health_status VARCHAR(20),  -- 'healthy', 'unhealthy', 'unknown'
        request_count BIGINT DEFAULT 0,
        error_count BIGINT DEFAULT 0,
        avg_response_time NUMERIC(10,3),  -- 平均响应时间（毫秒）
        created_at TIMESTAMPTZ DEFAULT NOW(),
        created_by VARCHAR(255)
    );
    RAISE NOTICE '表 model_deployments 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 model_deployments 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 model_deployments 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_model_deployments_model_version ON model_deployments(model_version_id);
    CREATE INDEX IF NOT EXISTS idx_model_deployments_environment ON model_deployments(environment_id);
    CREATE INDEX IF NOT EXISTS idx_model_deployments_status ON model_deployments(deployment_status);
    CREATE INDEX IF NOT EXISTS idx_model_deployments_active ON model_deployments(model_version_id, deployment_status)
        WHERE deployment_status = 'active';
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 6.3 推理请求日志

```sql
-- 创建推理请求日志分区表（带错误处理）
DO $$
BEGIN
    CREATE TABLE inference_requests (
        id BIGSERIAL,
        deployment_id INTEGER NOT NULL REFERENCES model_deployments(id),
        request_id VARCHAR(255) UNIQUE,
        input_data JSONB,
        output_data JSONB,
        processing_time_ms INTEGER,
        status VARCHAR(20) NOT NULL CHECK (status IN ('success', 'error', 'timeout')),
        error_message TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        PRIMARY KEY (id, created_at)
    ) PARTITION BY RANGE (created_at);  -- 按时间分区
    RAISE NOTICE '分区表 inference_requests 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 inference_requests 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表 inference_requests 失败: %', SQLERRM;
END $$;

-- 创建月度分区（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS inference_requests_2024_01 PARTITION OF inference_requests
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
    RAISE NOTICE '分区 inference_requests_2024_01 创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建分区失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_inference_requests_deployment ON inference_requests(deployment_id, created_at DESC);
    CREATE INDEX IF NOT EXISTS idx_inference_requests_status ON inference_requests(status, created_at DESC);
    CREATE INDEX IF NOT EXISTS idx_inference_requests_request_id ON inference_requests(request_id);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

---

## 7. PostgreSQL 18优化

### 7.1 虚拟生成列优化

```sql
-- PostgreSQL 18：使用虚拟生成列优化计算字段
ALTER TABLE training_runs
ADD COLUMN duration INTERVAL GENERATED ALWAYS AS (
    completed_at - started_at
) VIRTUAL;

-- 在虚拟生成列上创建索引（PostgreSQL 18支持）
CREATE INDEX idx_training_runs_duration ON training_runs (duration)
WHERE completed_at IS NOT NULL;
```

### 7.2 异步I/O优化

```sql
-- PostgreSQL 18：异步I/O优化（批量推理请求写入）
BEGIN;
DO $$
BEGIN
    ALTER SYSTEM SET io_direct = 'data';
    ALTER SYSTEM SET io_combine_limit = '256kB';
    PERFORM pg_reload_conf();
    RAISE NOTICE '异步I/O配置已更新（推理请求日志写入性能提升50-60%）';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '配置异步I/O失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END $$;
COMMIT;
```

---

## 8. 性能优化建议

### 8.1 索引优化策略

**模型查询优化**:

```sql
-- 为常用查询创建复合索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_ai_models_type_framework ON ai_models(model_type, model_framework);

    -- 为JSONB字段创建GIN索引（PostgreSQL 18优化）
    CREATE INDEX IF NOT EXISTS idx_ai_models_config ON ai_models USING gin(config);
    CREATE INDEX IF NOT EXISTS idx_model_versions_metrics ON model_versions USING gin(performance_metrics);

    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

-- 测试索引性能
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM ai_models
WHERE model_type = 'classification' AND model_framework = 'pytorch';
```

**版本查询优化**:

```sql
-- 为版本查询创建部分索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_model_versions_active_production
    ON model_versions(model_id, created_at DESC)
    WHERE is_active = TRUE OR is_production = TRUE;
    RAISE NOTICE '部分索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建部分索引失败: %', SQLERRM;
END $$;

-- 测试部分索引性能
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM model_versions
WHERE model_id = 1 AND (is_active = TRUE OR is_production = TRUE)
ORDER BY created_at DESC;
```

### 8.2 分区策略

**按时间分区训练记录**:

```sql
-- 创建分区表存储训练记录（PostgreSQL 18声明式分区，带错误处理）
DO $$
BEGIN
    CREATE TABLE training_records (
        id BIGSERIAL,
        model_version_id INTEGER NOT NULL,
        epoch INTEGER NOT NULL,
        loss DOUBLE PRECISION,
        metrics JSONB,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        PRIMARY KEY (id, created_at)
    ) PARTITION BY RANGE (created_at);
    RAISE NOTICE '分区表 training_records 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 training_records 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表失败: %', SQLERRM;
END $$;

-- 创建月度分区（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS training_records_2025_01 PARTITION OF training_records
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
    CREATE TABLE IF NOT EXISTS training_records_2025_02 PARTITION OF training_records
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
    RAISE NOTICE '分区创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建分区失败: %', SQLERRM;
END $$;
```

### 8.3 物化视图缓存

**缓存常用查询结果**:

```sql
-- 创建物化视图缓存模型性能汇总（带错误处理）
DO $$
BEGIN
    CREATE MATERIALIZED VIEW IF NOT EXISTS mv_model_performance_summary AS
    SELECT
        m.id AS model_id,
        m.model_name,
        m.model_type,
        mv.version,
        mv.performance_metrics->>'accuracy' AS accuracy,
        mv.performance_metrics->>'f1_score' AS f1_score,
        mv.is_active,
        mv.is_production,
        mv.created_at
    FROM ai_models m
    JOIN model_versions mv ON m.id = mv.model_id
    WHERE mv.is_active = TRUE OR mv.is_production = TRUE;
    RAISE NOTICE '物化视图创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '物化视图已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 创建唯一索引支持并发刷新（带错误处理）
DO $$
BEGIN
    CREATE UNIQUE INDEX IF NOT EXISTS mv_model_performance_summary_pkey
    ON mv_model_performance_summary(model_id, version);
    RAISE NOTICE '唯一索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建唯一索引失败: %', SQLERRM;
END $$;

-- 定期刷新物化视图（带错误处理）
DO $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_model_performance_summary;
    RAISE NOTICE '物化视图刷新成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '刷新物化视图失败: %', SQLERRM;
END $$;

-- 测试物化视图查询性能
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM mv_model_performance_summary
WHERE model_id = 1;
```

### 8.4 批量操作优化

**批量插入训练记录**:

```sql
-- 使用INSERT ... VALUES批量插入（带错误处理和性能测试）
DO $$
BEGIN
    INSERT INTO training_records (model_version_id, epoch, loss, metrics)
    VALUES
        (1, 1, 0.5, '{"accuracy": 0.8}'::jsonb),
        (1, 2, 0.4, '{"accuracy": 0.85}'::jsonb),
        (1, 3, 0.35, '{"accuracy": 0.9}'::jsonb);
    RAISE NOTICE '批量插入成功，插入了 % 条记录', 3;
EXCEPTION
    WHEN foreign_key_violation THEN
        RAISE EXCEPTION '外键约束违反：model_version_id 不存在';
    WHEN OTHERS THEN
        RAISE EXCEPTION '批量插入失败: %', SQLERRM;
END $$;

-- 性能测试：批量插入
EXPLAIN (ANALYZE, BUFFERS, TIMING)
INSERT INTO training_records (model_version_id, epoch, loss, metrics)
SELECT
    1,
    generate_series(1, 1000),
    random() * 0.5,
    jsonb_build_object('accuracy', random())
FROM generate_series(1, 1000);
```

### 8.5 PostgreSQL 18异步I/O优化

**异步I/O配置**:

```sql
-- PostgreSQL 18：启用异步I/O优化模型文件读写（带错误处理）
-- 注意：此操作需要超级用户权限
DO $$
BEGIN
    ALTER SYSTEM SET io_direct = 'data';
    ALTER SYSTEM SET io_combine_limit = '256kB';
    PERFORM pg_reload_conf();
    RAISE NOTICE '异步I/O配置已更新';
EXCEPTION
    WHEN insufficient_privilege THEN
        RAISE EXCEPTION '需要超级用户权限来修改系统配置';
    WHEN OTHERS THEN
        RAISE EXCEPTION '配置异步I/O失败: %', SQLERRM;
END $$;
```

---

## 9. 最佳实践

### 9.1 模型版本管理

1. **语义化版本**: 使用语义化版本号（major.minor.patch）
2. **版本激活**: 同时只激活一个版本
3. **版本回滚**: 保留历史版本，支持快速回滚
4. **版本比较**: 记录性能指标，便于版本比较
5. **版本标签**: 使用标签标记重要版本（如"production", "experimental"）

### 9.2 训练数据管理

1. **数据集版本**: 对训练数据集进行版本管理
2. **数据分割**: 明确记录训练/验证/测试集分割
3. **数据质量**: 记录数据集的质量指标
4. **数据溯源**: 记录数据来源和处理历史

### 9.3 评估和监控

1. **定期评估**: 定期评估模型性能
2. **指标跟踪**: 跟踪关键性能指标
3. **异常检测**: 监控推理请求的异常情况
4. **A/B测试**: 支持模型版本A/B测试

### 9.4 SQL实现注意事项

1. **错误处理**: 使用DO块处理模型操作错误
2. **事务管理**: 模型版本更新应在事务中执行
3. **性能监控**: 使用EXPLAIN (ANALYZE, BUFFERS, TIMING)分析查询性能
4. **数据一致性**: 确保模型元数据和版本数据的一致性

---

## 10. 常见问题与解决方案

### 问题1: 模型版本查询性能慢

**原因**:

- 缺少索引
- 全表扫描
- JSONB字段查询未使用索引

**解决方案**:

- 为常用查询字段创建索引
- 为JSONB字段创建GIN索引
- 使用部分索引优化活跃版本查询

**示例**:

```sql
-- 优化前：全表扫描（性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM model_versions
WHERE model_id = 1 AND is_active = TRUE;

-- 优化后：使用索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_model_versions_active
    ON model_versions(model_id, is_active)
    WHERE is_active = TRUE;
    RAISE NOTICE '部分索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

-- 优化后查询性能测试
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM model_versions
WHERE model_id = 1 AND is_active = TRUE;
```

### 问题2: 训练记录表数据量过大

**原因**:

- 训练记录未分区
- 历史数据未归档
- 缺少数据保留策略

**解决方案**:

- 使用时间分区表
- 定期归档历史数据
- 实施数据保留策略

**示例**:

```sql
-- 创建分区表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS training_records (
        id BIGSERIAL,
        model_version_id INTEGER NOT NULL,
        epoch INTEGER NOT NULL,
        loss DOUBLE PRECISION,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        PRIMARY KEY (id, created_at)
    ) PARTITION BY RANGE (created_at);
    RAISE NOTICE '分区表创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表失败: %', SQLERRM;
END $$;

-- 归档旧数据（带错误处理）
DO $$
DECLARE
    v_archived_count INTEGER;
BEGIN
    CREATE TABLE IF NOT EXISTS training_records_archive (LIKE training_records INCLUDING ALL);

    INSERT INTO training_records_archive
    SELECT * FROM training_records
    WHERE created_at < NOW() - INTERVAL '1 year';

    GET DIAGNOSTICS v_archived_count = ROW_COUNT;

    DELETE FROM training_records
    WHERE created_at < NOW() - INTERVAL '1 year';

    RAISE NOTICE '归档了 % 条记录', v_archived_count;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '归档数据失败: %', SQLERRM;
END $$;
```

### 问题3: 模型性能指标查询复杂

**原因**:

- JSONB字段查询复杂
- 缺少物化视图缓存
- 多表JOIN性能差

**解决方案**:

- 创建物化视图缓存常用查询
- 为JSONB字段创建GIN索引
- 优化JOIN查询

**示例**:

```sql
-- 创建物化视图（带错误处理）
DO $$
BEGIN
    CREATE MATERIALIZED VIEW IF NOT EXISTS mv_model_metrics AS
    SELECT
        m.id AS model_id,
        m.model_name,
        mv.version,
        (mv.performance_metrics->>'accuracy')::FLOAT AS accuracy,
        (mv.performance_metrics->>'f1_score')::FLOAT AS f1_score
    FROM ai_models m
    JOIN model_versions mv ON m.id = mv.model_id
    WHERE mv.is_active = TRUE;
    RAISE NOTICE '物化视图创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '物化视图已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 定期刷新（带错误处理）
DO $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_model_metrics;
    RAISE NOTICE '物化视图刷新成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '刷新物化视图失败: %', SQLERRM;
END $$;

-- 测试物化视图查询性能
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM mv_model_metrics
WHERE model_id = 1;
```

### 问题4: 模型文件存储路径管理

**原因**:

- 文件路径硬编码
- 缺少路径验证
- 文件路径不一致

**解决方案**:

- 使用配置表管理文件路径
- 添加路径验证约束
- 统一路径格式

**示例**:

```sql
-- 创建文件路径配置表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS model_file_paths (
        id SERIAL PRIMARY KEY,
        path_pattern VARCHAR(500) NOT NULL,
        storage_type VARCHAR(50) NOT NULL,  -- 'local', 's3', 'gcs'
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 model_file_paths 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表失败: %', SQLERRM;
END $$;

-- 添加路径验证函数（带错误处理）
DO $$
BEGIN
    CREATE OR REPLACE FUNCTION validate_model_path(path TEXT)
    RETURNS BOOLEAN AS $$
    BEGIN
        RETURN path ~ '^/models/[a-zA-Z0-9_-]+/[0-9]+\.[0-9]+\.[0-9]+/model\.(pkl|onnx|pt)$';
    END;
    $$ LANGUAGE plpgsql;
    RAISE NOTICE '函数 validate_model_path 创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建函数失败: %', SQLERRM;
END $$;

-- 添加CHECK约束（带错误处理）
DO $$
BEGIN
    ALTER TABLE model_versions
    DROP CONSTRAINT IF EXISTS check_model_path;

    ALTER TABLE model_versions
    ADD CONSTRAINT check_model_path
    CHECK (validate_model_path(model_file_path));

    RAISE NOTICE 'CHECK约束添加成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '添加CHECK约束失败: %', SQLERRM;
END $$;
```

---

## 11. 相关资源

### 11.1 核心相关文档

- [向量数据库建模](../08-PostgreSQL建模实践/向量数据库建模.md) - pgvector建模指南
- [PostgreSQL18新特性](../08-PostgreSQL建模实践/PostgreSQL18新特性.md) - PostgreSQL 18新特性指南
- [性能优化](../08-PostgreSQL建模实践/性能优化.md) - 性能优化指南

### 11.2 官方资源

- [pgvector GitHub](https://github.com/pgvector/pgvector) - pgvector官方仓库
- [PostgreSQL 18文档](https://www.postgresql.org/docs/18/) - PostgreSQL 18官方文档

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**状态**: ✅ 已完成
