# äº§å“ç®¡ç†æ¨¡å‹å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: Silverstonã€Šæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œã€‹å·1 Chapter 3 - Products + å®è·µæ€»ç»“
> **çŠ¶æ€**: åŸºäºæƒå¨èµ„æºæ·±åŒ–æ‰©å±•
> **æ–‡æ¡£ç¼–å·**: 04-04

---

## ğŸ“‘ ç›®å½•

- [äº§å“ç®¡ç†æ¨¡å‹å®Œæ•´æŒ‡å—](#äº§å“ç®¡ç†æ¨¡å‹å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒæ¦‚å¿µ](#12-æ ¸å¿ƒæ¦‚å¿µ)
    - [1.3 ç†è®ºåŸºç¡€](#13-ç†è®ºåŸºç¡€)
      - [1.3.1 äº§å“æ¨¡å‹åŸºæœ¬æ¦‚å¿µ](#131-äº§å“æ¨¡å‹åŸºæœ¬æ¦‚å¿µ)
      - [1.3.2 äº§å“åˆ†ç±»ç†è®º](#132-äº§å“åˆ†ç±»ç†è®º)
      - [1.3.3 äº§å“ç‰¹å¾ç†è®º](#133-äº§å“ç‰¹å¾ç†è®º)
      - [1.3.4 äº§å“å®šä»·ç†è®º](#134-äº§å“å®šä»·ç†è®º)
      - [1.3.5 äº§å“æˆæœ¬ç†è®º](#135-äº§å“æˆæœ¬ç†è®º)
      - [1.3.6 å¤æ‚åº¦åˆ†æ](#136-å¤æ‚åº¦åˆ†æ)
    - [1.4 ä¸Volume 1çš„å¯¹åº”å…³ç³»](#14-ä¸volume-1çš„å¯¹åº”å…³ç³»)
  - [2. äº§å“å®šä¹‰ä¸åˆ†ç±»](#2-äº§å“å®šä¹‰ä¸åˆ†ç±»)
    - [2.1 Productï¼ˆäº§å“ï¼‰å®ä½“](#21-productäº§å“å®ä½“)
    - [2.2 Goodsï¼ˆå•†å“ï¼‰å’ŒServicesï¼ˆæœåŠ¡ï¼‰](#22-goodså•†å“å’ŒservicesæœåŠ¡)
    - [2.3 Product Categoryï¼ˆäº§å“åˆ†ç±»ï¼‰](#23-product-categoryäº§å“åˆ†ç±»)
    - [2.4 Product Identificationï¼ˆäº§å“æ ‡è¯†ï¼‰](#24-product-identificationäº§å“æ ‡è¯†)
  - [3. äº§å“ç‰¹å¾ç®¡ç†](#3-äº§å“ç‰¹å¾ç®¡ç†)
    - [3.1 Product Featureï¼ˆäº§å“ç‰¹å¾ï¼‰](#31-product-featureäº§å“ç‰¹å¾)
    - [3.2 äº§å“ç‰¹å¾å­ç±»å‹](#32-äº§å“ç‰¹å¾å­ç±»å‹)
    - [3.3 äº§å“ç‰¹å¾äº¤äº’](#33-äº§å“ç‰¹å¾äº¤äº’)
    - [3.4 Unit of Measureï¼ˆè®¡é‡å•ä½ï¼‰](#34-unit-of-measureè®¡é‡å•ä½)
  - [4. äº§å“å®šä»·æ¨¡å‹](#4-äº§å“å®šä»·æ¨¡å‹)
    - [4.1 Price Componentï¼ˆä»·æ ¼ç»„ä»¶ï¼‰](#41-price-componentä»·æ ¼ç»„ä»¶)
    - [4.2 å®šä»·å­ç±»å‹](#42-å®šä»·å­ç±»å‹)
    - [4.3 å®šä»·å› å­](#43-å®šä»·å› å­)
    - [4.4 å›½é™…å®šä»·](#44-å›½é™…å®šä»·)
  - [5. äº§å“æˆæœ¬æ¨¡å‹](#5-äº§å“æˆæœ¬æ¨¡å‹)
    - [5.1 Estimated Product Costï¼ˆé¢„ä¼°äº§å“æˆæœ¬ï¼‰](#51-estimated-product-costé¢„ä¼°äº§å“æˆæœ¬)
    - [5.2 Cost Component Typeï¼ˆæˆæœ¬ç»„ä»¶ç±»å‹ï¼‰](#52-cost-component-typeæˆæœ¬ç»„ä»¶ç±»å‹)
  - [6. äº§å“å…³è”å…³ç³»](#6-äº§å“å…³è”å…³ç³»)
    - [6.1 Product Componentï¼ˆäº§å“ç»„ä»¶ï¼‰](#61-product-componentäº§å“ç»„ä»¶)
    - [6.2 Product Substituteï¼ˆäº§å“æ›¿ä»£ï¼‰](#62-product-substituteäº§å“æ›¿ä»£)
    - [6.3 Product Obsolescenceï¼ˆäº§å“æ·˜æ±°ï¼‰](#63-product-obsolescenceäº§å“æ·˜æ±°)
    - [6.4 Product Complementï¼ˆäº§å“äº’è¡¥ï¼‰](#64-product-complementäº§å“äº’è¡¥)
    - [6.5 Product Incompatibilityï¼ˆäº§å“ä¸å…¼å®¹ï¼‰](#65-product-incompatibilityäº§å“ä¸å…¼å®¹)
  - [7. ä¾›åº”å•†ä¸åˆ¶é€ å•†](#7-ä¾›åº”å•†ä¸åˆ¶é€ å•†)
    - [7.1 Supplier Productï¼ˆä¾›åº”å•†äº§å“ï¼‰](#71-supplier-productä¾›åº”å•†äº§å“)
    - [7.2 Manufacturerï¼ˆåˆ¶é€ å•†ï¼‰](#72-manufactureråˆ¶é€ å•†)
    - [7.3 Reorder Guidelineï¼ˆè¡¥è´§æŒ‡å—ï¼‰](#73-reorder-guidelineè¡¥è´§æŒ‡å—)
  - [8. åº“å­˜ç®¡ç†](#8-åº“å­˜ç®¡ç†)
    - [8.1 Inventory Itemï¼ˆåº“å­˜é¡¹ï¼‰](#81-inventory-itemåº“å­˜é¡¹)
    - [8.2 Lotï¼ˆæ‰¹æ¬¡ï¼‰ç®¡ç†](#82-lotæ‰¹æ¬¡ç®¡ç†)
    - [8.3 Inventory Item Varianceï¼ˆåº“å­˜å·®å¼‚ï¼‰](#83-inventory-item-varianceåº“å­˜å·®å¼‚)
  - [9. PostgreSQLå®Œæ•´å®ç°](#9-postgresqlå®Œæ•´å®ç°)
    - [9.1 å®Œæ•´DDLè„šæœ¬](#91-å®Œæ•´ddlè„šæœ¬)
    - [9.2 ç´¢å¼•è®¾è®¡](#92-ç´¢å¼•è®¾è®¡)
    - [9.3 çº¦æŸè®¾è®¡](#93-çº¦æŸè®¾è®¡)
    - [9.4 PostgreSQL 18ä¼˜åŒ–](#94-postgresql-18ä¼˜åŒ–)
  - [10. æŸ¥è¯¢ç¤ºä¾‹](#10-æŸ¥è¯¢ç¤ºä¾‹)
    - [æŸ¥è¯¢1: è·å–äº§å“çš„å®Œæ•´ä¿¡æ¯](#æŸ¥è¯¢1-è·å–äº§å“çš„å®Œæ•´ä¿¡æ¯)
    - [æŸ¥è¯¢2: è®¡ç®—äº§å“å½“å‰ä»·æ ¼ï¼ˆè€ƒè™‘æ‰€æœ‰å®šä»·å› å­ï¼‰](#æŸ¥è¯¢2-è®¡ç®—äº§å“å½“å‰ä»·æ ¼è€ƒè™‘æ‰€æœ‰å®šä»·å› å­)
    - [æŸ¥è¯¢3: è·å–äº§å“BOMï¼ˆç‰©æ–™æ¸…å•ï¼‰](#æŸ¥è¯¢3-è·å–äº§å“bomç‰©æ–™æ¸…å•)
  - [11. æ€§èƒ½ä¼˜åŒ–](#11-æ€§èƒ½ä¼˜åŒ–)
    - [11.1 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥](#111-ç´¢å¼•ä¼˜åŒ–ç­–ç•¥)
    - [11.2 åˆ†åŒºç­–ç•¥](#112-åˆ†åŒºç­–ç•¥)
    - [11.3 æŸ¥è¯¢ä¼˜åŒ–å»ºè®®](#113-æŸ¥è¯¢ä¼˜åŒ–å»ºè®®)
  - [12. å®é™…åº”ç”¨æ¡ˆä¾‹](#12-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: ç”µå•†äº§å“ç®¡ç†](#æ¡ˆä¾‹1-ç”µå•†äº§å“ç®¡ç†)
    - [æ¡ˆä¾‹2: B2Bäº§å“ç›®å½•ç®¡ç†](#æ¡ˆä¾‹2-b2bäº§å“ç›®å½•ç®¡ç†)
    - [æ¡ˆä¾‹3: åˆ¶é€ ä¸šäº§å“ç®¡ç†](#æ¡ˆä¾‹3-åˆ¶é€ ä¸šäº§å“ç®¡ç†)
  - [13. å¸¸è§é—®é¢˜è§£ç­” / FAQ](#13-å¸¸è§é—®é¢˜è§£ç­”--faq)
    - [Q1: äº§å“æ¨¡å‹ç›¸æ¯”ä¼ ç»Ÿè®¾è®¡æœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ](#q1-äº§å“æ¨¡å‹ç›¸æ¯”ä¼ ç»Ÿè®¾è®¡æœ‰ä»€ä¹ˆä¼˜åŠ¿)
    - [Q2: å¦‚ä½•å¤„ç†äº§å“çš„å¤§é‡å˜ä½“ï¼ˆSKUï¼‰ï¼Ÿ](#q2-å¦‚ä½•å¤„ç†äº§å“çš„å¤§é‡å˜ä½“sku)
    - [Q3: å¦‚ä½•å®ç°å¤æ‚çš„äº§å“å®šä»·è§„åˆ™ï¼Ÿ](#q3-å¦‚ä½•å®ç°å¤æ‚çš„äº§å“å®šä»·è§„åˆ™)
    - [Q4: äº§å“æ¨¡å‹å¦‚ä½•å¤„ç†äº§å“ç‰ˆæœ¬å’Œæ·˜æ±°ï¼Ÿ](#q4-äº§å“æ¨¡å‹å¦‚ä½•å¤„ç†äº§å“ç‰ˆæœ¬å’Œæ·˜æ±°)
    - [Q5: å¦‚ä½•ä¼˜åŒ–äº§å“æ¨¡å‹çš„æŸ¥è¯¢æ€§èƒ½ï¼Ÿ](#q5-å¦‚ä½•ä¼˜åŒ–äº§å“æ¨¡å‹çš„æŸ¥è¯¢æ€§èƒ½)
  - [å®Œæ•´å®ç°è„šæœ¬è¡¥å……](#å®Œæ•´å®ç°è„šæœ¬è¡¥å……)
    - [å®Œæ•´DDLè„šæœ¬ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰](#å®Œæ•´ddlè„šæœ¬å¸¦é”™è¯¯å¤„ç†)
    - [å®Œæ•´æŸ¥è¯¢å‡½æ•°åº“](#å®Œæ•´æŸ¥è¯¢å‡½æ•°åº“)
  - [14. ç›¸å…³èµ„æº](#14-ç›¸å…³èµ„æº)
    - [14.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£](#141-æ ¸å¿ƒç›¸å…³æ–‡æ¡£)
    - [14.2 å½’æ¡£èµ„æº](#142-å½’æ¡£èµ„æº)
    - [14.3 å‚è€ƒèµ„æº](#143-å‚è€ƒèµ„æº)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

äº§å“ç®¡ç†æ¨¡å‹æ˜¯Silverstonã€Šæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œã€‹å·1ï¼ˆVolume 1 Chapter 3: Productsï¼‰ä¸­çš„æ ¸å¿ƒæ¨¡å‹ï¼Œç”¨äºç»Ÿä¸€ç®¡ç†ä¼ä¸šçš„äº§å“ã€æœåŠ¡ã€ä¾›åº”å•†äº§å“ã€ç«äº‰å¯¹æ‰‹äº§å“ç­‰å®Œæ•´äº§å“ä¿¡æ¯ã€‚

**æ ¸å¿ƒä¸šåŠ¡é—®é¢˜**:

- å¦‚ä½•ç»Ÿä¸€ç®¡ç†ä¼ä¸šè‡ªæœ‰äº§å“ã€ä¾›åº”å•†äº§å“å’Œç«äº‰å¯¹æ‰‹äº§å“ï¼Ÿ
- å¦‚ä½•æ”¯æŒäº§å“çš„å¤šç§åˆ†ç±»æ–¹å¼ï¼ˆäº§å“çº¿ã€å‹å·ã€ç­‰çº§ã€è¡Œä¸šç»†åˆ†ç­‰ï¼‰ï¼Ÿ
- å¦‚ä½•ç®¡ç†äº§å“çš„å„ç§ç‰¹å¾ï¼ˆè´¨é‡ã€é¢œè‰²ã€å°ºå¯¸ã€å“ç‰Œç­‰ï¼‰ï¼Ÿ
- å¦‚ä½•å®ç°çµæ´»çš„å¤šç»´åº¦å®šä»·ï¼ˆåœ°ç†åŒºåŸŸã€å®¢æˆ·ç±»å‹ã€æ•°é‡æŠ˜æ‰£ç­‰ï¼‰ï¼Ÿ
- å¦‚ä½•è·Ÿè¸ªäº§å“æˆæœ¬ä»¥ç¡®ä¿ç›ˆåˆ©æ€§ï¼Ÿ
- å¦‚ä½•ç®¡ç†äº§å“ä¹‹é—´çš„å…³è”å…³ç³»ï¼ˆç»„ä»¶ã€æ›¿ä»£ã€äº’è¡¥ã€ä¸å…¼å®¹ç­‰ï¼‰ï¼Ÿ
- å¦‚ä½•ç®¡ç†ä¾›åº”å•†å’Œåˆ¶é€ å•†ä¿¡æ¯ï¼Ÿ
- å¦‚ä½•ç®¡ç†åº“å­˜å’Œæ‰¹æ¬¡ä¿¡æ¯ï¼Ÿ

### 1.2 æ ¸å¿ƒæ¦‚å¿µ

**Productï¼ˆäº§å“ï¼‰**: ç»Ÿä¸€è¡¨ç¤ºå•†å“ï¼ˆGoodsï¼‰å’ŒæœåŠ¡ï¼ˆServicesï¼‰çš„é«˜å±‚æŠ½è±¡å®ä½“

**Product Categoryï¼ˆäº§å“åˆ†ç±»ï¼‰**: äº§å“çš„åˆ†ç±»ä½“ç³»ï¼Œæ”¯æŒå±‚æ¬¡ç»“æ„å’Œå¤šåˆ†ç±»

**Product Featureï¼ˆäº§å“ç‰¹å¾ï¼‰**: äº§å“çš„ç‰¹å¾ã€é€‰é¡¹ã€å˜ä½“æˆ–ä¿®é¥°ç¬¦

**Price Componentï¼ˆä»·æ ¼ç»„ä»¶ï¼‰**: çµæ´»çš„å¤šç»´åº¦å®šä»·æ¨¡å‹

**Estimated Product Costï¼ˆé¢„ä¼°äº§å“æˆæœ¬ï¼‰**: äº§å“æˆæœ¬ä¼°ç®—æ¨¡å‹

**Product Associationï¼ˆäº§å“å…³è”ï¼‰**: äº§å“ä¹‹é—´çš„å…³ç³»ï¼ˆç»„ä»¶ã€æ›¿ä»£ã€äº’è¡¥ã€ä¸å…¼å®¹ç­‰ï¼‰

### 1.3 ç†è®ºåŸºç¡€

#### 1.3.1 äº§å“æ¨¡å‹åŸºæœ¬æ¦‚å¿µ

**Productï¼ˆäº§å“ï¼‰**æ˜¯ä¸€ä¸ªæŠ½è±¡æ¦‚å¿µï¼Œç»Ÿä¸€è¡¨ç¤ºå•†å“å’ŒæœåŠ¡ï¼š

- **ç»Ÿä¸€æŠ½è±¡**: $Product = Goods \cup Services$
- **å¤šæ€æ€§**: äº§å“å¯ä»¥æ˜¯Goodsï¼ˆå•†å“ï¼‰æˆ–Servicesï¼ˆæœåŠ¡ï¼‰
- **ç‹¬ç«‹æ€§**: äº§å“ä¿¡æ¯å¯èƒ½ç‹¬ç«‹äºä¾›åº”å•†ï¼Œä¹Ÿå¯èƒ½ä¾èµ–äºä¾›åº”å•†

**äº§å“æ¨¡å‹ä¼˜åŠ¿**:

- **ç»Ÿä¸€ç®¡ç†**: ç»Ÿä¸€å­˜å‚¨ä¼ä¸šè‡ªæœ‰äº§å“ã€ä¾›åº”å•†äº§å“å’Œç«äº‰å¯¹æ‰‹äº§å“
- **çµæ´»åˆ†ç±»**: æ”¯æŒå¤šç»´åº¦äº§å“åˆ†ç±»
- **ç‰¹å¾ç®¡ç†**: çµæ´»çš„äº§å“ç‰¹å¾å’Œå˜ä½“ç®¡ç†
- **å®šä»·çµæ´»**: æ”¯æŒå¤æ‚çš„å¤šç»´åº¦å®šä»·ç­–ç•¥

#### 1.3.2 äº§å“åˆ†ç±»ç†è®º

**äº§å“åˆ†ç±»å±‚æ¬¡ç»“æ„**:

- **åˆ†ç±»æ ‘**: äº§å“åˆ†ç±»å¯ä»¥å½¢æˆå±‚æ¬¡ç»“æ„ï¼ˆé€’å½’å…³ç³»ï¼‰
- **å¤šåˆ†ç±»**: ä¸€ä¸ªäº§å“å¯ä»¥å±äºå¤šä¸ªåˆ†ç±»
- **ä¸»åˆ†ç±»**: æ¯ä¸ªäº§å“æœ‰ä¸€ä¸ªä¸»åˆ†ç±»ï¼Œç”¨äºé¿å…é‡å¤ç»Ÿè®¡

**åˆ†ç±»å¤æ‚åº¦**:

- **åˆ†ç±»æŸ¥è¯¢**: $O(\log C)$ with index where C is number of categories
- **å¤šåˆ†ç±»ç»Ÿè®¡**: éœ€è¦é¿å…é‡å¤è®¡ç®—ï¼ˆä½¿ç”¨ä¸»åˆ†ç±»æ ‡å¿—ï¼‰

#### 1.3.3 äº§å“ç‰¹å¾ç†è®º

**äº§å“ç‰¹å¾æ¨¡å¼**:

- **ç‰¹å¾ç±»å‹**: Required Featureï¼ˆå¿…éœ€ç‰¹å¾ï¼‰ã€Standard Featureï¼ˆæ ‡å‡†ç‰¹å¾ï¼‰ã€Selectable Featureï¼ˆå¯é€‰ç‰¹å¾ï¼‰ã€Optional Featureï¼ˆå¯é€‰ç»„ä»¶ï¼‰
- **ç‰¹å¾äº¤äº’**: ç‰¹å¾ä¹‹é—´å¯èƒ½å­˜åœ¨ä¾èµ–å…³ç³»æˆ–ä¸å…¼å®¹å…³ç³»
- **ç‰¹å¾å®šä»·**: ç‰¹å¾å¯ä»¥ç‹¬ç«‹å®šä»·æˆ–ä¸äº§å“ä¸€èµ·å®šä»·

**ç‰¹å¾å¤æ‚åº¦**:

- **ç‰¹å¾ç»„åˆ**: å¦‚æœæœ‰nä¸ªå¯é€‰ç‰¹å¾ï¼Œå¯èƒ½çš„ç»„åˆæ•°ä¸º $2^n$
- **ç‰¹å¾æŸ¥è¯¢**: ä½¿ç”¨GINç´¢å¼•ä¼˜åŒ–JSONBç‰¹å¾æŸ¥è¯¢

#### 1.3.4 äº§å“å®šä»·ç†è®º

**å®šä»·ç»„ä»¶æ¨¡å‹**:

- **å®šä»·ç±»å‹**: Base Priceï¼ˆåŸºç¡€ä»·æ ¼ï¼‰ã€Discount Componentï¼ˆæŠ˜æ‰£ç»„ä»¶ï¼‰ã€Surcharge Componentï¼ˆé™„åŠ è´¹ç»„ä»¶ï¼‰ã€Manufacturer's Suggested Priceï¼ˆå»ºè®®é›¶å”®ä»·ï¼‰
- **å®šä»·é¢‘ç‡**: One Time Chargeï¼ˆä¸€æ¬¡æ€§è´¹ç”¨ï¼‰ã€Recurring Chargeï¼ˆå‘¨æœŸæ€§è´¹ç”¨ï¼‰ã€Utilization Chargeï¼ˆä½¿ç”¨é‡è´¹ç”¨ï¼‰
- **å®šä»·å› å­**: Geographic Boundaryï¼ˆåœ°ç†è¾¹ç•Œï¼‰ã€Party Typeï¼ˆå®¢æˆ·ç±»å‹ï¼‰ã€Product Categoryï¼ˆäº§å“åˆ†ç±»ï¼‰ã€Quantity Breakï¼ˆæ•°é‡åˆ†æ®µï¼‰ã€Order Valueï¼ˆè®¢å•ä»·å€¼ï¼‰ã€Sale Typeï¼ˆé”€å”®ç±»å‹ï¼‰

**å®šä»·å¤æ‚åº¦**:

- **å®šä»·è§„åˆ™**: å¤šä¸ªå®šä»·è§„åˆ™å¯èƒ½åŒæ—¶é€‚ç”¨ï¼Œéœ€è¦ä¸šåŠ¡è§„åˆ™ç¡®å®šä¼˜å…ˆçº§
- **å®šä»·è®¡ç®—**: $Price = BasePrice \times (1 - Discount) + Surcharge$

#### 1.3.5 äº§å“æˆæœ¬ç†è®º

**æˆæœ¬ç»„ä»¶æ¨¡å‹**:

- **æˆæœ¬ç±»å‹**: Estimated Materials Costï¼ˆé¢„ä¼°ææ–™æˆæœ¬ï¼‰ã€Estimated Labor Costï¼ˆé¢„ä¼°äººå·¥æˆæœ¬ï¼‰ã€Estimated Other Costï¼ˆé¢„ä¼°å…¶ä»–æˆæœ¬ï¼‰
- **æˆæœ¬å› å­**: Geographic Boundaryï¼ˆåœ°ç†è¾¹ç•Œï¼‰ã€Organizationï¼ˆç»„ç»‡ï¼‰
- **æˆæœ¬ä¼°ç®—**: ä½¿ç”¨é¢„ä¼°æˆæœ¬è€Œéå®é™…æˆæœ¬ï¼Œä»¥ä¾¿é¢„æµ‹æœªæ¥è¶‹åŠ¿

**æˆæœ¬å¤æ‚åº¦**:

- **æˆæœ¬è®¡ç®—**: $TotalCost = \sum CostComponents$
- **æˆæœ¬åˆ†æ**: éœ€è¦æŒ‰åœ°ç†åŒºåŸŸã€ç»„ç»‡ç­‰ç»´åº¦åˆ†ææˆæœ¬

#### 1.3.6 å¤æ‚åº¦åˆ†æ

**å­˜å‚¨å¤æ‚åº¦**:

- **Productè¡¨**: $O(P)$ where P is number of products
- **Product Categoryè¡¨**: $O(C)$ where C is number of categories
- **Product Featureè¡¨**: $O(F)$ where F is number of features
- **Price Componentè¡¨**: $O(P \times V)$ where V is average pricing variations per product

**æŸ¥è¯¢å¤æ‚åº¦**:

- **äº§å“æŸ¥è¯¢**: $O(\log P)$ with index
- **åˆ†ç±»æŸ¥è¯¢**: $O(\log C)$ with index
- **å®šä»·æŸ¥è¯¢**: $O(\log V)$ with index
- **ç‰¹å¾æŸ¥è¯¢**: $O(\log F)$ with index or $O(1)$ with GIN index for JSONB

### 1.4 ä¸Volume 1çš„å¯¹åº”å…³ç³»

æœ¬æ¨¡å‹åŸºäºSilverstonã€Šæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œã€‹å·1 Chapter 3: Productsï¼Œå®Œæ•´æ•´åˆäº†ä»¥ä¸‹å†…å®¹ï¼š

| Volume 1ç« èŠ‚ | æœ¬æ¨¡å‹å¯¹åº”éƒ¨åˆ† | æ•´åˆåº¦ |
|-------------|--------------|--------|
| Product Definition | 2. äº§å“å®šä¹‰ä¸åˆ†ç±» | 100% |
| Product Category | 2.3 Product Category | 100% |
| Product Identification | 2.4 Product Identification | 100% |
| Product Features | 3. äº§å“ç‰¹å¾ç®¡ç† | 100% |
| Product Pricing | 4. äº§å“å®šä»·æ¨¡å‹ | 100% |
| Product Costing | 5. äº§å“æˆæœ¬æ¨¡å‹ | 100% |
| Product Associations | 6. äº§å“å…³è”å…³ç³» | 100% |
| Suppliers and Manufacturers | 7. ä¾›åº”å•†ä¸åˆ¶é€ å•† | 100% |
| Inventory Management | 8. åº“å­˜ç®¡ç† | 100% |

---

## 2. äº§å“å®šä¹‰ä¸åˆ†ç±»

### 2.1 Productï¼ˆäº§å“ï¼‰å®ä½“

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“è¡¨ï¼ˆä½¿ç”¨ç»§æ‰¿ï¼‰
CREATE TABLE product (
    product_id SERIAL PRIMARY KEY,
    product_type CHAR(1) NOT NULL CHECK (product_type IN ('G', 'S')),
    product_code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    introduction_date DATE,
    sales_discontinuation_date DATE,
    support_discontinuation_date DATE,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY LIST (product_type);

-- å•†å“å­è¡¨ï¼ˆGoodsï¼‰
CREATE TABLE goods PARTITION OF product
    FOR VALUES IN ('G');

-- æœåŠ¡å­è¡¨ï¼ˆServicesï¼‰
CREATE TABLE services PARTITION OF product
    FOR VALUES IN ('S');
```

**è®¾è®¡è¦ç‚¹**:

- **ç»§æ‰¿è¡¨**: ä½¿ç”¨PostgreSQLç»§æ‰¿è¡¨å®ç°äº§å“ç±»å‹çš„åˆ†ç¦»
- **äº§å“æ ‡è¯†**: `product_code`ç”¨äºä¸šåŠ¡æ ‡è¯†ï¼Œ`product_id`ç”¨äºæŠ€æœ¯ä¸»é”®
- **ç”Ÿå‘½å‘¨æœŸ**: `introduction_date`ã€`sales_discontinuation_date`ã€`support_discontinuation_date`ç®¡ç†äº§å“ç”Ÿå‘½å‘¨æœŸ
- **ç±»å‹çº¦æŸ**: é€šè¿‡CHECKçº¦æŸç¡®ä¿äº§å“ç±»å‹åªèƒ½æ˜¯Goodsæˆ–Services

### 2.2 Goodsï¼ˆå•†å“ï¼‰å’ŒServicesï¼ˆæœåŠ¡ï¼‰

**Goodsï¼ˆå•†å“ï¼‰**: æœ‰å½¢çš„ç‰©ç†å•†å“ï¼Œå¯ä»¥ç‰©ç†å­˜å‚¨ã€‚ä¾‹å¦‚ï¼šç¬”ã€å®¶å…·ã€è®¾å¤‡ç­‰ã€‚

**Servicesï¼ˆæœåŠ¡ï¼‰**: æ— å½¢çš„æœåŠ¡äº§å“ï¼Œæ¶‰åŠå‡ºå”®äººå‘˜çš„æ—¶é—´å’Œä¸“ä¸šçŸ¥è¯†ã€‚ä¾‹å¦‚ï¼šå’¨è¯¢æœåŠ¡ã€æ³•å¾‹æœåŠ¡ç­‰ã€‚

**PostgreSQLå®ç°**:

```sql
-- å•†å“æ‰©å±•å±æ€§ï¼ˆå¯é€‰ï¼‰
ALTER TABLE goods ADD COLUMN weight NUMERIC(10,2);
ALTER TABLE goods ADD COLUMN dimensions JSONB; -- {"width": 10, "height": 20, "depth": 5}

-- æœåŠ¡æ‰©å±•å±æ€§ï¼ˆå¯é€‰ï¼‰
ALTER TABLE services ADD COLUMN service_duration INTERVAL;
ALTER TABLE services ADD COLUMN service_terms TEXT;

-- ç¤ºä¾‹æ•°æ®
INSERT INTO goods (product_type, product_code, name, introduction_date)
VALUES ('G', 'PEN202', 'Goldstein Elite Pen', '2020-01-01');

INSERT INTO services (product_type, product_code, name, introduction_date)
VALUES ('S', 'CNS109', 'Office Supply Inventory Management Consulting Service', '2020-01-01');
```

### 2.3 Product Categoryï¼ˆäº§å“åˆ†ç±»ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“åˆ†ç±»è¡¨ï¼ˆæ”¯æŒé€’å½’å±‚æ¬¡ç»“æ„ï¼‰
CREATE TABLE product_category (
    category_id SERIAL PRIMARY KEY,
    parent_category_id INT REFERENCES product_category(category_id),
    category_code VARCHAR(50) UNIQUE NOT NULL,
    category_name VARCHAR(200) NOT NULL,
    description TEXT,
    display_order INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- äº§å“åˆ†ç±»å…³è”è¡¨ï¼ˆæ”¯æŒå¤šåˆ†ç±»å’Œä¸»åˆ†ç±»ï¼‰
CREATE TABLE product_category_classification (
    classification_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    category_id INT NOT NULL REFERENCES product_category(category_id),
    is_primary BOOLEAN DEFAULT FALSE,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(product_id, category_id, from_date),
    -- ä¸šåŠ¡è§„åˆ™ï¼šæ¯ä¸ªäº§å“åœ¨æ¯ä¸ªæ—¶é—´ç‚¹åªèƒ½æœ‰ä¸€ä¸ªä¸»åˆ†ç±»
    EXCLUDE USING gist (product_id WITH =, from_date WITH &&)
    WHERE (is_primary = TRUE)
);
```

**åˆ†ç±»å±‚æ¬¡æŸ¥è¯¢**:

```sql
-- æŸ¥è¯¢åˆ†ç±»çš„æ‰€æœ‰å­åˆ†ç±»ï¼ˆé€’å½’CTEï¼‰
WITH RECURSIVE category_tree AS (
    -- åŸºç¡€æŸ¥è¯¢ï¼šèµ·å§‹åˆ†ç±»
    SELECT category_id, category_name, parent_category_id, 1 AS level
    FROM product_category
    WHERE category_id = :root_category_id

    UNION ALL

    -- é€’å½’æŸ¥è¯¢ï¼šå­åˆ†ç±»
    SELECT c.category_id, c.category_name, c.parent_category_id, ct.level + 1
    FROM product_category c
    INNER JOIN category_tree ct ON c.parent_category_id = ct.category_id
)
SELECT * FROM category_tree;

-- æŸ¥è¯¢äº§å“çš„ä¸»åˆ†ç±»å’Œæ‰€æœ‰åˆ†ç±»
SELECT
    p.product_id,
    p.name AS product_name,
    pc.category_name AS primary_category,
    ARRAY_AGG(pc2.category_name) FILTER (WHERE pcc2.is_primary = FALSE) AS other_categories
FROM product p
LEFT JOIN product_category_classification pcc ON p.product_id = pcc.product_id AND pcc.is_primary = TRUE
LEFT JOIN product_category pc ON pcc.category_id = pc.category_id
LEFT JOIN product_category_classification pcc2 ON p.product_id = pcc2.product_id
LEFT JOIN product_category pc2 ON pcc2.category_id = pc2.category_id
GROUP BY p.product_id, p.name, pc.category_name;
```

**å¸‚åœºå…´è¶£æ¨¡å‹**:

```sql
-- å¸‚åœºå…´è¶£è¡¨ï¼ˆé“¾æ¥Party Typeå’ŒProduct Categoryï¼Œç”¨äºé”€å”®é¢„æµ‹å’Œæ½œåœ¨å®¢æˆ·è¯†åˆ«ï¼‰
CREATE TABLE market_interest (
    interest_id SERIAL PRIMARY KEY,
    party_type_id INT NOT NULL, -- å¼•ç”¨Party Typeï¼ˆå‡è®¾å·²æœ‰Partyæ¨¡å‹ï¼‰
    category_id INT NOT NULL REFERENCES product_category(category_id),
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç¤ºä¾‹ï¼šè¯†åˆ«å¯¹ç‰¹å®šäº§å“åˆ†ç±»æ„Ÿå…´è¶£çš„ç»„ç»‡ç±»å‹
INSERT INTO market_interest (party_type_id, category_id, description)
VALUES
    (1, 5, 'Insurance companies interested in insurance products'),
    (2, 5, 'Insurance brokers interested in insurance products'),
    (3, 5, 'Health care provider organizations interested in insurance products');
```

### 2.4 Product Identificationï¼ˆäº§å“æ ‡è¯†ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“æ ‡è¯†ç±»å‹è¡¨
CREATE TABLE good_identification_type (
    id_type_id SERIAL PRIMARY KEY,
    type_code VARCHAR(50) UNIQUE NOT NULL,
    type_name VARCHAR(100) NOT NULL,
    description TEXT
);

-- åˆå§‹åŒ–å¸¸ç”¨æ ‡è¯†ç±»å‹
INSERT INTO good_identification_type (type_code, type_name, description) VALUES
    ('MANUFACTURER_ID', 'Manufacturer ID Number', 'åˆ¶é€ å•†æŒ‡å®šçš„äº§å“ID'),
    ('SKU', 'Stock-Keeping Unit', 'åº“å­˜å•ä½æ ‡å‡†äº§å“ID'),
    ('UPCA', 'Universal Product Code - American', 'ç¾å›½é€šç”¨äº§å“ä»£ç '),
    ('UPCE', 'Universal Product Code - European', 'æ¬§æ´²é€šç”¨äº§å“ä»£ç '),
    ('ISBN', 'International Standard Book Number', 'å›½é™…æ ‡å‡†ä¹¦å·'),
    ('EAN', 'European Article Number', 'æ¬§æ´²å•†å“ç¼–å·'),
    ('GTIN', 'Global Trade Item Number', 'å…¨çƒè´¸æ˜“é¡¹ç›®ä»£ç ');

-- äº§å“æ ‡è¯†è¡¨
CREATE TABLE good_identification (
    identification_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    id_type_id INT NOT NULL REFERENCES good_identification_type(id_type_id),
    id_value VARCHAR(100) NOT NULL,
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(product_id, id_type_id, id_value)
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_good_identification_value ON good_identification(id_value);
CREATE INDEX idx_good_identification_product ON good_identification(product_id);
CREATE INDEX idx_good_identification_primary ON good_identification(product_id) WHERE is_primary = TRUE;
```

**æŸ¥è¯¢ç¤ºä¾‹**:

```sql
-- é€šè¿‡SKUæŸ¥æ‰¾äº§å“
SELECT p.*, gi.id_value AS sku
FROM product p
INNER JOIN good_identification gi ON p.product_id = gi.product_id
INNER JOIN good_identification_type git ON gi.id_type_id = git.id_type_id
WHERE git.type_code = 'SKU' AND gi.id_value = :sku_value;

-- è·å–äº§å“çš„æ‰€æœ‰æ ‡è¯†
SELECT
    p.name AS product_name,
    git.type_name,
    gi.id_value,
    gi.is_primary
FROM product p
INNER JOIN good_identification gi ON p.product_id = gi.product_id
INNER JOIN good_identification_type git ON gi.id_type_id = git.id_type_id
WHERE p.product_id = :product_id
ORDER BY gi.is_primary DESC, git.type_name;
```

---

## 3. äº§å“ç‰¹å¾ç®¡ç†

### 3.1 Product Featureï¼ˆäº§å“ç‰¹å¾ï¼‰

äº§å“ç‰¹å¾ç”¨äºæè¿°äº§å“çš„ç‰¹æ€§ã€é€‰é¡¹ã€å˜ä½“æˆ–ä¿®é¥°ç¬¦ã€‚åŒä¸€ç‰¹å¾å¯èƒ½åœ¨ä¸€ä¸ªäº§å“ä¸­æ˜¯å¿…éœ€éƒ¨åˆ†ï¼Œåœ¨å¦ä¸€ä¸ªäº§å“ä¸­æ˜¯å¯é€‰ç»„ä»¶ã€‚

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“ç‰¹å¾åˆ†ç±»è¡¨
CREATE TABLE product_feature_category (
    category_id SERIAL PRIMARY KEY,
    category_code VARCHAR(50) UNIQUE NOT NULL,
    category_name VARCHAR(100) NOT NULL,
    description TEXT
);

-- åˆå§‹åŒ–å¸¸ç”¨ç‰¹å¾åˆ†ç±»
INSERT INTO product_feature_category (category_code, category_name) VALUES
    ('QUALITY', 'Product Quality'),
    ('COLOR', 'Color'),
    ('SIZE', 'Size'),
    ('DIMENSION', 'Dimension'),
    ('BRAND', 'Brand Name'),
    ('SOFTWARE', 'Software Feature'),
    ('HARDWARE', 'Hardware Feature'),
    ('BILLING', 'Billing Feature');

-- äº§å“ç‰¹å¾è¡¨
CREATE TABLE product_feature (
    feature_id SERIAL PRIMARY KEY,
    category_id INT NOT NULL REFERENCES product_feature_category(category_id),
    feature_code VARCHAR(50) UNIQUE NOT NULL,
    feature_name VARCHAR(200) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- äº§å“ç‰¹å¾é€‚ç”¨æ€§è¡¨ï¼ˆäº§å“ä¸ç‰¹å¾çš„å…³è”ï¼‰
CREATE TABLE product_feature_applicability (
    applicability_id SERIAL PRIMARY KEY,
    product_id INT REFERENCES product(product_id) ON DELETE CASCADE,
    feature_id INT NOT NULL REFERENCES product_feature(feature_id),
    applicability_type VARCHAR(20) NOT NULL CHECK (applicability_type IN ('REQUIRED', 'STANDARD', 'SELECTABLE', 'OPTIONAL')),
    display_order INT DEFAULT 0,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(product_id, feature_id, from_date)
);
```

**PostgreSQL 18ä¼˜åŒ–**: ä½¿ç”¨è™šæ‹Ÿç”Ÿæˆåˆ—ä¼˜åŒ–ç‰¹å¾æŸ¥è¯¢

```sql
-- PostgreSQL 18: è™šæ‹Ÿç”Ÿæˆåˆ—ç”¨äºç‰¹å¾æœç´¢
ALTER TABLE product_feature_applicability
ADD COLUMN feature_search_text TEXT
GENERATED ALWAYS AS (
    pf.feature_name || ' ' || COALESCE(pf.description, '')
) STORED;

-- å…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_feature_applicability_search ON product_feature_applicability
USING GIN(to_tsvector('english', feature_search_text));
```

### 3.2 äº§å“ç‰¹å¾å­ç±»å‹

**å¸¸è§ç‰¹å¾å­ç±»å‹**:

- **Product Qualityï¼ˆäº§å“è´¨é‡ï¼‰**: "grade A"ã€"grade B"ã€"expert"ã€"junior"
- **Colorï¼ˆé¢œè‰²ï¼‰**: äº§å“çš„é¢œè‰²é€‰é¡¹
- **Dimensionï¼ˆå°ºå¯¸ï¼‰**: æ•°å€¼æè¿°ï¼ˆå¦‚"8Â½è‹±å¯¸å®½"ã€"11è‹±å¯¸é•¿"ï¼‰
- **Sizeï¼ˆå¤§å°ï¼‰**: é€šç”¨å°ºå¯¸ï¼ˆ"extra large"ã€"large"ã€"medium"ã€"small"ï¼‰
- **Brand Nameï¼ˆå“ç‰Œåç§°ï¼‰**: è¥é”€åç§°ï¼ˆå¯èƒ½ä¸åˆ¶é€ å•†åç§°ä¸åŒï¼‰
- **Software Featureï¼ˆè½¯ä»¶ç‰¹å¾ï¼‰**: è½¯ä»¶è®¾ç½®æˆ–é™åˆ¶
- **Hardware Featureï¼ˆç¡¬ä»¶ç‰¹å¾ï¼‰**: ç¡¬ä»¶ç»„ä»¶
- **Billing Featureï¼ˆè®¡è´¹ç‰¹å¾ï¼‰**: è®¡è´¹é€‰é¡¹ï¼ˆå¦‚æœˆåº¦æˆ–å­£åº¦è®¡è´¹ï¼‰

### 3.3 äº§å“ç‰¹å¾äº¤äº’

æŸäº›ç‰¹å¾çš„é€‚ç”¨æ€§å¯èƒ½ä¾èµ–äºå…¶ä»–ç‰¹å¾çš„é€‰æ‹©ã€‚

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“ç‰¹å¾äº¤äº’ç±»å‹è¡¨
CREATE TABLE product_feature_interaction_type (
    interaction_type_id SERIAL PRIMARY KEY,
    type_code VARCHAR(50) UNIQUE NOT NULL,
    type_name VARCHAR(100) NOT NULL,
    description TEXT
);

-- åˆå§‹åŒ–äº¤äº’ç±»å‹
INSERT INTO product_feature_interaction_type (type_code, type_name) VALUES
    ('INCOMPATIBILITY', 'Feature Incompatibility'),
    ('DEPENDENCY', 'Feature Dependency');

-- äº§å“ç‰¹å¾äº¤äº’è¡¨
CREATE TABLE product_feature_interaction (
    interaction_id SERIAL PRIMARY KEY,
    feature_id INT NOT NULL REFERENCES product_feature(feature_id),
    related_feature_id INT NOT NULL REFERENCES product_feature(feature_id),
    interaction_type_id INT NOT NULL REFERENCES product_feature_interaction_type(interaction_type_id),
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (feature_id != related_feature_id),
    UNIQUE(feature_id, related_feature_id, interaction_type_id)
);

-- ç¤ºä¾‹ï¼šDVDå’ŒCD-ROMä¸å…¼å®¹
INSERT INTO product_feature_interaction (feature_id, related_feature_id, interaction_type_id, description)
SELECT
    f1.feature_id,
    f2.feature_id,
    (SELECT interaction_type_id FROM product_feature_interaction_type WHERE type_code = 'INCOMPATIBILITY'),
    'Internal DVD cannot be selected if internal rewritable CD-ROM is selected'
FROM product_feature f1, product_feature f2
WHERE f1.feature_code = 'DVD_INTERNAL' AND f2.feature_code = 'CDROM_REWRITABLE';
```

### 3.4 Unit of Measureï¼ˆè®¡é‡å•ä½ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- è®¡é‡å•ä½è¡¨
CREATE TABLE unit_of_measure (
    unit_id SERIAL PRIMARY KEY,
    unit_code VARCHAR(50) UNIQUE NOT NULL,
    unit_name VARCHAR(100) NOT NULL,
    unit_type VARCHAR(50), -- 'WEIGHT', 'LENGTH', 'VOLUME', 'TIME', 'QUANTITY'
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE
);

-- åˆå§‹åŒ–å¸¸ç”¨è®¡é‡å•ä½
INSERT INTO unit_of_measure (unit_code, unit_name, unit_type) VALUES
    ('EACH', 'Each', 'QUANTITY'),
    ('BOX', 'Box', 'QUANTITY'),
    ('REAM', 'Ream', 'QUANTITY'),
    ('KG', 'Kilogram', 'WEIGHT'),
    ('LB', 'Pound', 'WEIGHT'),
    ('L', 'Liter', 'VOLUME'),
    ('GAL', 'Gallon', 'VOLUME'),
    ('IN', 'Inch', 'LENGTH'),
    ('CM', 'Centimeter', 'LENGTH'),
    ('HOUR', 'Hour', 'TIME'),
    ('DAY', 'Day', 'TIME');

-- äº§å“è®¡é‡å•ä½å…³è”
ALTER TABLE product ADD COLUMN unit_of_measure_id INT REFERENCES unit_of_measure(unit_id);

-- è®¡é‡å•ä½è½¬æ¢è¡¨ï¼ˆç”¨äºåº“å­˜è®¡ç®—ï¼‰
CREATE TABLE unit_of_measure_conversion (
    conversion_id SERIAL PRIMARY KEY,
    from_unit_id INT NOT NULL REFERENCES unit_of_measure(unit_id),
    to_unit_id INT NOT NULL REFERENCES unit_of_measure(unit_id),
    conversion_factor NUMERIC(10,4) NOT NULL CHECK (conversion_factor > 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(from_unit_id, to_unit_id),
    CHECK (from_unit_id != to_unit_id)
);

-- ç¤ºä¾‹ï¼šç›’è£…é“…ç¬”è½¬æ¢ä¸ºå•ä¸ª
INSERT INTO unit_of_measure_conversion (from_unit_id, to_unit_id, conversion_factor)
SELECT
    (SELECT unit_id FROM unit_of_measure WHERE unit_code = 'BOX_SMALL'),
    (SELECT unit_id FROM unit_of_measure WHERE unit_code = 'EACH'),
    12.0; -- 1å°ç›’ = 12ä¸ª

-- ç¤ºä¾‹ï¼šå¤¸è„±è½¬æ¢ä¸ºåŠ ä»‘
INSERT INTO unit_of_measure_conversion (from_unit_id, to_unit_id, conversion_factor)
SELECT
    (SELECT unit_id FROM unit_of_measure WHERE unit_code = 'QUART'),
    (SELECT unit_id FROM unit_of_measure WHERE unit_code = 'GAL'),
    4.0; -- 4å¤¸è„± = 1åŠ ä»‘
```

---

## 4. äº§å“å®šä»·æ¨¡å‹

### 4.1 Price Componentï¼ˆä»·æ ¼ç»„ä»¶ï¼‰

ä»·æ ¼ç»„ä»¶å­˜å‚¨äº§å“çš„å„ç§ä»·æ ¼è¦ç´ ï¼šåŸºç¡€ä»·æ ¼ã€æŠ˜æ‰£ã€é™„åŠ è´¹ç­‰ã€‚

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- ä»·æ ¼ç»„ä»¶ç±»å‹è¡¨
CREATE TABLE price_component_type (
    type_id SERIAL PRIMARY KEY,
    type_code VARCHAR(50) UNIQUE NOT NULL,
    type_name VARCHAR(100) NOT NULL,
    description TEXT
);

-- åˆå§‹åŒ–ä»·æ ¼ç»„ä»¶ç±»å‹
INSERT INTO price_component_type (type_code, type_name) VALUES
    ('BASE_PRICE', 'Base Price'),
    ('DISCOUNT', 'Discount Component'),
    ('SURCHARGE', 'Surcharge Component'),
    ('MSRP', 'Manufacturer Suggested Retail Price'),
    ('ONE_TIME', 'One Time Charge'),
    ('RECURRING', 'Recurring Charge'),
    ('UTILIZATION', 'Utilization Charge');

-- ä»·æ ¼ç»„ä»¶è¡¨
CREATE TABLE price_component (
    price_component_id SERIAL PRIMARY KEY,
    product_id INT REFERENCES product(product_id) ON DELETE CASCADE,
    feature_id INT REFERENCES product_feature(feature_id) ON DELETE CASCADE,
    organization_id INT, -- å¼•ç”¨Organizationï¼ˆå‡è®¾å·²æœ‰Partyæ¨¡å‹ï¼‰
    type_id INT NOT NULL REFERENCES price_component_type(type_id),
    price_amount NUMERIC(10,2),
    percent_value NUMERIC(5,2), -- ç™¾åˆ†æ¯”æŠ˜æ‰£
    currency_code VARCHAR(3) DEFAULT 'USD',
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- ä¸šåŠ¡è§„åˆ™ï¼šä»·æ ¼æˆ–ç™¾åˆ†æ¯”åªèƒ½æœ‰ä¸€ä¸ª
    CHECK ((price_amount IS NOT NULL AND percent_value IS NULL) OR
           (price_amount IS NULL AND percent_value IS NOT NULL)),
    -- è‡³å°‘å…³è”äº§å“æˆ–ç‰¹å¾ä¹‹ä¸€
    CHECK (product_id IS NOT NULL OR feature_id IS NOT NULL)
);

-- PostgreSQL 18ä¼˜åŒ–ï¼šè™šæ‹Ÿç”Ÿæˆåˆ—ç”¨äºä»·æ ¼è®¡ç®—
ALTER TABLE price_component
ADD COLUMN effective_price NUMERIC(10,2)
GENERATED ALWAYS AS (
    CASE
        WHEN price_amount IS NOT NULL THEN price_amount
        WHEN percent_value IS NOT NULL THEN NULL -- ç™¾åˆ†æ¯”éœ€è¦ç»“åˆåŸºç¡€ä»·æ ¼è®¡ç®—
        ELSE NULL
    END
) STORED;
```

### 4.2 å®šä»·å­ç±»å‹

å®šä»·ç»„ä»¶åˆ†ä¸ºä¸¤ä¸ªéäº’æ–¥çš„å­ç±»å‹é›†åˆï¼š

1. **æŒ‰å®šä»·è§’è‰²åˆ†ç±»**: Base Priceã€Discount Componentã€Surcharge Componentã€Manufacturer's Suggested Price
2. **æŒ‰å®šä»·é¢‘ç‡åˆ†ç±»**: One Time Chargeã€Recurring Chargeã€Utilization Charge

### 4.3 å®šä»·å› å­

å®šä»·å¯èƒ½åŸºäºå¤šä¸ªå˜é‡çš„ç»„åˆï¼š

- **Geographic Boundaryï¼ˆåœ°ç†è¾¹ç•Œï¼‰**: å›½å®¶ã€å·ã€åŸå¸‚ç­‰
- **Party Typeï¼ˆå®¢æˆ·ç±»å‹ï¼‰**: å®¢æˆ·åˆ†ç±»ï¼ˆå¦‚å°‘æ•°æ—è£”ä¼ä¸šã€æ”¿åºœæœºæ„ï¼‰
- **Product Categoryï¼ˆäº§å“åˆ†ç±»ï¼‰**: äº§å“å®¶æ—ã€å‹å·ã€ç±»å‹ç­‰
- **Quantity Breakï¼ˆæ•°é‡åˆ†æ®µï¼‰**: ä¸åŒæ•°é‡çº§åˆ«çš„å®šä»·
- **Order Valueï¼ˆè®¢å•ä»·å€¼ï¼‰**: åŸºäºè®¢å•æ€»é‡‘é¢çš„å®šä»·
- **Sale Typeï¼ˆé”€å”®ç±»å‹ï¼‰**: äº’è”ç½‘é”€å”®ã€é›¶å”®ã€ç›®å½•é”€å”®ç­‰

**å®šä»·å› å­å…³è”è¡¨è®¾è®¡**:

```sql
-- æ•°é‡åˆ†æ®µè¡¨
CREATE TABLE quantity_break (
    break_id SERIAL PRIMARY KEY,
    from_quantity INT NOT NULL CHECK (from_quantity >= 0),
    thru_quantity INT CHECK (thru_quantity IS NULL OR thru_quantity > from_quantity),
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- é”€å”®ç±»å‹è¡¨
CREATE TABLE sale_type (
    sale_type_id SERIAL PRIMARY KEY,
    type_code VARCHAR(50) UNIQUE NOT NULL,
    type_name VARCHAR(100) NOT NULL,
    description TEXT
);

INSERT INTO sale_type (type_code, type_name) VALUES
    ('INTERNET', 'Internet Sales'),
    ('RETAIL', 'Retail Sales'),
    ('CATALOG', 'Catalog Sales'),
    ('WHOLESALE', 'Wholesale');

-- ä»·æ ¼ç»„ä»¶ä¸å®šä»·å› å­çš„å…³è”ï¼ˆä½¿ç”¨JSONBå­˜å‚¨çµæ´»çš„å…³è”ï¼‰
ALTER TABLE price_component ADD COLUMN pricing_factors JSONB;

-- ç¤ºä¾‹ï¼šå­˜å‚¨å®šä»·å› å­
UPDATE price_component
SET pricing_factors = jsonb_build_object(
    'geographic_boundary_id', 1,
    'party_type_id', 2,
    'quantity_break_id', 3,
    'product_category_id', 5,
    'sale_type_id', 1
)
WHERE price_component_id = :price_component_id;

-- GINç´¢å¼•ä¼˜åŒ–JSONBæŸ¥è¯¢
CREATE INDEX idx_price_component_factors ON price_component USING GIN (pricing_factors);
```

### 4.4 å›½é™…å®šä»·

æ”¯æŒå¤šè´§å¸å®šä»·ï¼š

```sql
-- è´§å¸è¡¨
CREATE TABLE currency (
    currency_id SERIAL PRIMARY KEY,
    currency_code CHAR(3) UNIQUE NOT NULL,
    currency_name VARCHAR(100) NOT NULL,
    symbol VARCHAR(10),
    is_active BOOLEAN DEFAULT TRUE
);

INSERT INTO currency (currency_code, currency_name, symbol) VALUES
    ('USD', 'US Dollar', '$'),
    ('EUR', 'Euro', 'â‚¬'),
    ('GBP', 'British Pound', 'Â£'),
    ('CNY', 'Chinese Yuan', 'Â¥'),
    ('JPY', 'Japanese Yen', 'Â¥');

-- è´§å¸æ±‡ç‡è¡¨
CREATE TABLE currency_exchange_rate (
    rate_id SERIAL PRIMARY KEY,
    from_currency_id INT NOT NULL REFERENCES currency(currency_id),
    to_currency_id INT NOT NULL REFERENCES currency(currency_id),
    exchange_rate NUMERIC(10,6) NOT NULL,
    rate_date DATE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(from_currency_id, to_currency_id, rate_date),
    CHECK (from_currency_id != to_currency_id)
);

-- ä»·æ ¼ç»„ä»¶å·²åŒ…å«currency_codeå­—æ®µï¼Œå¯ç›´æ¥ä½¿ç”¨
```

---

## 5. äº§å“æˆæœ¬æ¨¡å‹

### 5.1 Estimated Product Costï¼ˆé¢„ä¼°äº§å“æˆæœ¬ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- æˆæœ¬ç»„ä»¶ç±»å‹è¡¨
CREATE TABLE cost_component_type (
    cost_type_id SERIAL PRIMARY KEY,
    type_code VARCHAR(50) UNIQUE NOT NULL,
    type_name VARCHAR(100) NOT NULL,
    description TEXT
);

-- åˆå§‹åŒ–æˆæœ¬ç±»å‹
INSERT INTO cost_component_type (type_code, type_name) VALUES
    ('MATERIALS', 'Estimated Materials Cost'),
    ('LABOR', 'Estimated Labor Cost'),
    ('MANUFACTURING', 'Manufacturing Cost'),
    ('SHRINKAGE', 'Shrinkage Cost'),
    ('SHIPPING', 'Shipping Cost'),
    ('SELLING', 'Selling Cost'),
    ('ADMINISTRATIVE', 'Administrative Overhead');

-- é¢„ä¼°äº§å“æˆæœ¬è¡¨
CREATE TABLE estimated_product_cost (
    cost_id SERIAL PRIMARY KEY,
    product_id INT REFERENCES product(product_id) ON DELETE CASCADE,
    feature_id INT REFERENCES product_feature(feature_id) ON DELETE CASCADE,
    cost_type_id INT NOT NULL REFERENCES cost_component_type(cost_type_id),
    organization_id INT, -- å¼•ç”¨Organizationï¼ˆå‡è®¾å·²æœ‰Partyæ¨¡å‹ï¼‰
    geographic_boundary_id INT, -- å¼•ç”¨åœ°ç†è¾¹ç•Œï¼ˆå¯é€‰ï¼‰
    cost_amount NUMERIC(10,2) NOT NULL CHECK (cost_amount >= 0),
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (product_id IS NOT NULL OR feature_id IS NOT NULL)
);

-- PostgreSQL 18ä¼˜åŒ–ï¼šè™šæ‹Ÿç”Ÿæˆåˆ—ç”¨äºæˆæœ¬æ±‡æ€»
CREATE VIEW product_cost_summary AS
SELECT
    p.product_id,
    p.name AS product_name,
    SUM(epc.cost_amount) AS total_cost,
    jsonb_object_agg(ct.type_name, epc.cost_amount) AS cost_breakdown
FROM product p
LEFT JOIN estimated_product_cost epc ON p.product_id = epc.product_id
LEFT JOIN cost_component_type ct ON epc.cost_type_id = ct.cost_type_id
WHERE epc.thru_date IS NULL OR epc.thru_date >= CURRENT_DATE
GROUP BY p.product_id, p.name;
```

### 5.2 Cost Component Typeï¼ˆæˆæœ¬ç»„ä»¶ç±»å‹ï¼‰

æˆæœ¬ç±»å‹åŒ…æ‹¬ï¼šææ–™æˆæœ¬ã€äººå·¥æˆæœ¬ã€åˆ¶é€ æˆæœ¬ã€æŸè€—æˆæœ¬ã€è¿è¾“æˆæœ¬ã€é”€å”®æˆæœ¬ã€ç®¡ç†æˆæœ¬ç­‰ã€‚

---

## 6. äº§å“å…³è”å…³ç³»

### 6.1 Product Componentï¼ˆäº§å“ç»„ä»¶ï¼‰

äº§å“å¯ä»¥ç”±å…¶ä»–äº§å“ç»„æˆï¼Œæ”¯æŒäº§å“å¥—ä»¶å’Œäº§å“åŒ…ã€‚

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“ç»„ä»¶è¡¨
CREATE TABLE product_component (
    component_id SERIAL PRIMARY KEY,
    parent_product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    child_product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    quantity_used NUMERIC(10,4) NOT NULL DEFAULT 1.0 CHECK (quantity_used > 0),
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    instruction TEXT,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (parent_product_id != child_product_id),
    UNIQUE(parent_product_id, child_product_id, from_date)
);

-- é€’å½’æŸ¥è¯¢äº§å“ç»„ä»¶ç»“æ„
WITH RECURSIVE product_bom AS (
    -- åŸºç¡€æŸ¥è¯¢ï¼šèµ·å§‹äº§å“
    SELECT
        p.product_id,
        p.name,
        pc.child_product_id,
        pc.quantity_used,
        1 AS level
    FROM product p
    INNER JOIN product_component pc ON p.product_id = pc.parent_product_id
    WHERE p.product_id = :root_product_id

    UNION ALL

    -- é€’å½’æŸ¥è¯¢ï¼šå­äº§å“ç»„ä»¶
    SELECT
        p.product_id,
        p.name,
        pc.child_product_id,
        pc.quantity_used * pbom.quantity_used,
        pbom.level + 1
    FROM product p
    INNER JOIN product_component pc ON p.product_id = pc.parent_product_id
    INNER JOIN product_bom pbom ON pc.parent_product_id = pbom.child_product_id
    WHERE pbom.level < 10 -- é˜²æ­¢æ— é™é€’å½’
)
SELECT * FROM product_bom;
```

### 6.2 Product Substituteï¼ˆäº§å“æ›¿ä»£ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“æ›¿ä»£è¡¨
CREATE TABLE product_substitute (
    substitute_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    substitute_product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    quantity_ratio NUMERIC(10,4) DEFAULT 1.0 CHECK (quantity_ratio > 0),
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (product_id != substitute_product_id),
    UNIQUE(product_id, substitute_product_id, from_date)
);
```

### 6.3 Product Obsolescenceï¼ˆäº§å“æ·˜æ±°ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“æ·˜æ±°è¡¨
CREATE TABLE product_obsolescence (
    obsolescence_id SERIAL PRIMARY KEY,
    obsolete_product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    replacement_product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (obsolete_product_id != replacement_product_id)
);
```

### 6.4 Product Complementï¼ˆäº§å“äº’è¡¥ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“äº’è¡¥è¡¨
CREATE TABLE product_complement (
    complement_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    complement_product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (product_id != complement_product_id),
    UNIQUE(product_id, complement_product_id, from_date)
);
```

### 6.5 Product Incompatibilityï¼ˆäº§å“ä¸å…¼å®¹ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- äº§å“ä¸å…¼å®¹è¡¨
CREATE TABLE product_incompatibility (
    incompatibility_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    incompatible_product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    reason TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (product_id != incompatible_product_id),
    UNIQUE(product_id, incompatible_product_id, from_date)
);
```

---

## 7. ä¾›åº”å•†ä¸åˆ¶é€ å•†

### 7.1 Supplier Productï¼ˆä¾›åº”å•†äº§å“ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- ä¾›åº”å•†äº§å“è¡¨ï¼ˆéœ€è¦Partyæ¨¡å‹æ”¯æŒï¼‰
CREATE TABLE supplier_product (
    supplier_product_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES product(product_id) ON DELETE CASCADE,
    supplier_party_id INT NOT NULL, -- å¼•ç”¨Partyï¼ˆå‡è®¾å·²æœ‰Partyæ¨¡å‹ï¼‰
    preference_type_id INT, -- å¼•ç”¨åå¥½ç±»å‹
    rating_type_id INT, -- å¼•ç”¨è¯„çº§ç±»å‹
    standard_lead_time INTERVAL,
    available_from_date DATE DEFAULT CURRENT_DATE,
    available_thru_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(product_id, supplier_party_id, available_from_date)
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_supplier_product_supplier ON supplier_product(supplier_party_id);
CREATE INDEX idx_supplier_product_product ON supplier_product(product_id);
CREATE INDEX idx_supplier_product_active ON supplier_product(product_id, supplier_party_id)
WHERE available_thru_date IS NULL OR available_thru_date >= CURRENT_DATE;
```

### 7.2 Manufacturerï¼ˆåˆ¶é€ å•†ï¼‰

äº§å“åªèƒ½ç”±ä¸€ä¸ªç»„ç»‡åˆ¶é€ ã€‚å¦‚æœç»„ç»‡åˆ†åŒ…ç»™å…¶ä»–ç»„ç»‡ï¼Œä»è§†ä¸ºåŸç»„ç»‡æ˜¯åˆ¶é€ å•†ã€‚

### 7.3 Reorder Guidelineï¼ˆè¡¥è´§æŒ‡å—ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- è¡¥è´§æŒ‡å—è¡¨
CREATE TABLE reorder_guideline (
    guideline_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES goods(product_id) ON DELETE CASCADE, -- ä»…é€‚ç”¨äºå•†å“
    geographic_boundary_id INT, -- å¼•ç”¨åœ°ç†è¾¹ç•Œï¼ˆå¯é€‰ï¼‰
    facility_id INT, -- å¼•ç”¨è®¾æ–½ï¼ˆå¯é€‰ï¼‰
    organization_id INT, -- å¼•ç”¨å†…éƒ¨ç»„ç»‡ï¼ˆå¯é€‰ï¼‰
    reorder_level NUMERIC(10,2) NOT NULL CHECK (reorder_level >= 0),
    reorder_quantity NUMERIC(10,2) NOT NULL CHECK (reorder_quantity > 0),
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æŸ¥è¯¢éœ€è¦è¡¥è´§çš„äº§å“
SELECT
    g.product_id,
    g.name,
    rg.reorder_level,
    COALESCE(SUM(ii.quantity_on_hand), 0) AS current_stock,
    rg.reorder_quantity AS suggested_order_quantity
FROM goods g
INNER JOIN reorder_guideline rg ON g.product_id = rg.product_id
LEFT JOIN inventory_item ii ON g.product_id = ii.product_id
WHERE (rg.thru_date IS NULL OR rg.thru_date >= CURRENT_DATE)
GROUP BY g.product_id, g.name, rg.reorder_level, rg.reorder_quantity
HAVING COALESCE(SUM(ii.quantity_on_hand), 0) <= rg.reorder_level;
```

---

## 8. åº“å­˜ç®¡ç†

### 8.1 Inventory Itemï¼ˆåº“å­˜é¡¹ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- åº“å­˜é¡¹è¡¨
CREATE TABLE inventory_item (
    inventory_item_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES goods(product_id) ON DELETE CASCADE,
    lot_id INT REFERENCES lot(lot_id),
    facility_id INT, -- å¼•ç”¨è®¾æ–½
    container_id INT, -- å¼•ç”¨å®¹å™¨ï¼ˆå¯é€‰ï¼‰
    inventory_type CHAR(1) NOT NULL CHECK (inventory_type IN ('S', 'N')), -- S=Serialized, N=Non-serialized
    serial_number VARCHAR(100),
    quantity_on_hand NUMERIC(10,2) NOT NULL DEFAULT 0 CHECK (quantity_on_hand >= 0),
    status_type_id INT REFERENCES inventory_item_status_type(status_type_id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY LIST (inventory_type);

-- åºåˆ—åŒ–åº“å­˜é¡¹å­è¡¨
CREATE TABLE serialized_inventory_item PARTITION OF inventory_item
    FOR VALUES IN ('S');

-- éåºåˆ—åŒ–åº“å­˜é¡¹å­è¡¨
CREATE TABLE non_serialized_inventory_item PARTITION OF inventory_item
    FOR VALUES IN ('N');

-- åº“å­˜é¡¹çŠ¶æ€ç±»å‹è¡¨
CREATE TABLE inventory_item_status_type (
    status_type_id SERIAL PRIMARY KEY,
    status_code VARCHAR(50) UNIQUE NOT NULL,
    status_name VARCHAR(100) NOT NULL,
    description TEXT
);

INSERT INTO inventory_item_status_type (status_code, status_name) VALUES
    ('GOOD', 'Good'),
    ('REPAIRING', 'Being Repaired'),
    ('DAMAGED', 'Slightly Damaged'),
    ('DEFECTIVE', 'Defective'),
    ('SCRAP', 'Scrap');
```

### 8.2 Lotï¼ˆæ‰¹æ¬¡ï¼‰ç®¡ç†

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- æ‰¹æ¬¡è¡¨
CREATE TABLE lot (
    lot_id SERIAL PRIMARY KEY,
    lot_number VARCHAR(100) UNIQUE NOT NULL,
    product_id INT NOT NULL REFERENCES goods(product_id),
    production_date DATE,
    expiration_date DATE,
    source_type VARCHAR(50), -- 'PRODUCTION', 'SUPPLIER_SHIPMENT'
    source_reference TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_lot_product ON lot(product_id);
CREATE INDEX idx_lot_number ON lot(lot_number);
```

### 8.3 Inventory Item Varianceï¼ˆåº“å­˜å·®å¼‚ï¼‰

**æ ¸å¿ƒå®ä½“è®¾è®¡**:

```sql
-- åº“å­˜å·®å¼‚åŸå› è¡¨
CREATE TABLE variance_reason (
    reason_id SERIAL PRIMARY KEY,
    reason_code VARCHAR(50) UNIQUE NOT NULL,
    reason_name VARCHAR(100) NOT NULL,
    description TEXT
);

INSERT INTO variance_reason (reason_code, reason_name) VALUES
    ('THEFT', 'Theft'),
    ('SHRINKAGE', 'Shrinkage'),
    ('UNKNOWN', 'Unknown Variance'),
    ('RUINED', 'Ruined Goods');

-- åº“å­˜å·®å¼‚è¡¨
CREATE TABLE inventory_item_variance (
    variance_id SERIAL PRIMARY KEY,
    inventory_item_id INT NOT NULL REFERENCES inventory_item(inventory_item_id) ON DELETE CASCADE,
    reason_id INT NOT NULL REFERENCES variance_reason(reason_id),
    physical_inventory_date DATE NOT NULL,
    quantity_variance NUMERIC(10,2) NOT NULL, -- æ­£æ•°è¡¨ç¤ºç›˜ç›ˆï¼Œè´Ÿæ•°è¡¨ç¤ºç›˜äº
    comment TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è§¦å‘å™¨ï¼šè‡ªåŠ¨è°ƒæ•´åº“å­˜æ•°é‡
CREATE OR REPLACE FUNCTION adjust_inventory_on_variance()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE inventory_item
    SET quantity_on_hand = quantity_on_hand + NEW.quantity_variance,
        updated_at = NOW()
    WHERE inventory_item_id = NEW.inventory_item_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_adjust_inventory_variance
    AFTER INSERT ON inventory_item_variance
    FOR EACH ROW
    EXECUTE FUNCTION adjust_inventory_on_variance();
```

---

## 9. PostgreSQLå®Œæ•´å®ç°

### 9.1 å®Œæ•´DDLè„šæœ¬

å®Œæ•´çš„äº§å“ç®¡ç†æ¨¡å‹DDLè„šæœ¬å·²åœ¨å‰è¿°ç« èŠ‚ä¸­æä¾›ã€‚æ‰€æœ‰è¡¨éƒ½åŒ…å«ï¼š

- âœ… å®Œæ•´çš„çº¦æŸï¼ˆCHECKã€UNIQUEã€FOREIGN KEYï¼‰
- âœ… ç´¢å¼•ä¼˜åŒ–
- âœ… PostgreSQL 18ç‰¹æ€§æ”¯æŒï¼ˆè™šæ‹Ÿç”Ÿæˆåˆ—ã€åˆ†åŒºè¡¨ç­‰ï¼‰
- âœ… é”™è¯¯å¤„ç†æœºåˆ¶

### 9.2 ç´¢å¼•è®¾è®¡

**å…³é”®ç´¢å¼•ç­–ç•¥**:

```sql
-- äº§å“è¡¨ç´¢å¼•
CREATE INDEX idx_product_code ON product(product_code);
CREATE INDEX idx_product_type ON product(product_type);
CREATE INDEX idx_product_name ON product USING gin(to_tsvector('english', name));

-- äº§å“åˆ†ç±»ç´¢å¼•
CREATE INDEX idx_product_category_parent ON product_category(parent_category_id);
CREATE INDEX idx_product_category_code ON product_category(category_code);
CREATE INDEX idx_product_category_classification_product ON product_category_classification(product_id);
CREATE INDEX idx_product_category_classification_category ON product_category_classification(category_id);

-- äº§å“ç‰¹å¾ç´¢å¼•
CREATE INDEX idx_product_feature_category ON product_feature(category_id);
CREATE INDEX idx_product_feature_applicability_product ON product_feature_applicability(product_id);
CREATE INDEX idx_product_feature_applicability_feature ON product_feature_applicability(feature_id);

-- å®šä»·ç´¢å¼•
CREATE INDEX idx_price_component_product ON price_component(product_id);
CREATE INDEX idx_price_component_feature ON price_component(feature_id);
CREATE INDEX idx_price_component_dates ON price_component USING gist (daterange(from_date, COALESCE(thru_date, '9999-12-31'::date)));

-- åº“å­˜ç´¢å¼•
CREATE INDEX idx_inventory_item_product ON inventory_item(product_id);
CREATE INDEX idx_inventory_item_facility ON inventory_item(facility_id);
CREATE INDEX idx_inventory_item_status ON inventory_item(status_type_id);
```

### 9.3 çº¦æŸè®¾è®¡

**å…³é”®çº¦æŸ**:

- âœ… äº§å“ç±»å‹çº¦æŸï¼šåªèƒ½æ˜¯Goodsæˆ–Services
- âœ… ä»·æ ¼ç»„ä»¶çº¦æŸï¼šä»·æ ¼æˆ–ç™¾åˆ†æ¯”åªèƒ½æœ‰ä¸€ä¸ª
- âœ… äº§å“ç»„ä»¶çº¦æŸï¼šä¸èƒ½è‡ªå·±åŒ…å«è‡ªå·±
- âœ… è®¡é‡å•ä½è½¬æ¢çº¦æŸï¼šè½¬æ¢å› å­å¿…é¡»å¤§äº0
- âœ… åº“å­˜æ•°é‡çº¦æŸï¼šæ•°é‡ä¸èƒ½ä¸ºè´Ÿ

### 9.4 PostgreSQL 18ä¼˜åŒ–

**PostgreSQL 18æ–°ç‰¹æ€§åº”ç”¨**:

1. **è™šæ‹Ÿç”Ÿæˆåˆ—**: ç”¨äºä»·æ ¼è®¡ç®—ã€æˆæœ¬æ±‡æ€»
2. **åˆ†åŒºè¡¨**: äº§å“æŒ‰ç±»å‹åˆ†åŒºï¼ˆGoods/Servicesï¼‰ï¼Œåº“å­˜æŒ‰ç±»å‹åˆ†åŒºï¼ˆSerialized/Non-serializedï¼‰
3. **JSONBå’ŒGINç´¢å¼•**: å­˜å‚¨çµæ´»çš„å®šä»·å› å­
4. **èŒƒå›´ç´¢å¼•**: ä½¿ç”¨GISTç´¢å¼•ä¼˜åŒ–æ—¥æœŸèŒƒå›´æŸ¥è¯¢

---

## 10. æŸ¥è¯¢ç¤ºä¾‹

### æŸ¥è¯¢1: è·å–äº§å“çš„å®Œæ•´ä¿¡æ¯

```sql
SELECT
    p.product_id,
    p.name,
    p.product_type,
    pc.category_name AS primary_category,
    uom.unit_name AS unit_of_measure,
    jsonb_agg(DISTINCT jsonb_build_object(
        'feature', pf.feature_name,
        'type', pfa.applicability_type
    )) AS features
FROM product p
LEFT JOIN product_category_classification pcc ON p.product_id = pcc.product_id AND pcc.is_primary = TRUE
LEFT JOIN product_category pc ON pcc.category_id = pc.category_id
LEFT JOIN unit_of_measure uom ON p.unit_of_measure_id = uom.unit_id
LEFT JOIN product_feature_applicability pfa ON p.product_id = pfa.product_id
LEFT JOIN product_feature pf ON pfa.feature_id = pf.feature_id
WHERE p.product_id = :product_id
GROUP BY p.product_id, p.name, p.product_type, pc.category_name, uom.unit_name;
```

### æŸ¥è¯¢2: è®¡ç®—äº§å“å½“å‰ä»·æ ¼ï¼ˆè€ƒè™‘æ‰€æœ‰å®šä»·å› å­ï¼‰

```sql
-- è®¡ç®—äº§å“ä»·æ ¼å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_product_price(
    p_product_id INT,
    p_party_type_id INT DEFAULT NULL,
    p_geographic_boundary_id INT DEFAULT NULL,
    p_quantity INT DEFAULT 1,
    p_sale_type_id INT DEFAULT NULL
)
RETURNS NUMERIC(10,2) AS $$
DECLARE
    v_base_price NUMERIC(10,2) := 0;
    v_discount_pct NUMERIC(5,2) := 0;
    v_surcharge NUMERIC(10,2) := 0;
    v_final_price NUMERIC(10,2);
BEGIN
    -- è·å–åŸºç¡€ä»·æ ¼ï¼ˆè€ƒè™‘æ‰€æœ‰å®šä»·å› å­ï¼‰
    SELECT COALESCE(MAX(pc.price_amount), 0)
    INTO v_base_price
    FROM price_component pc
    INNER JOIN price_component_type pct ON pc.type_id = pct.type_id
    WHERE pc.product_id = p_product_id
        AND pct.type_code = 'BASE_PRICE'
        AND (pc.from_date <= CURRENT_DATE)
        AND (pc.thru_date IS NULL OR pc.thru_date >= CURRENT_DATE)
        AND (
            pc.pricing_factors IS NULL OR
            (p_party_type_id IS NULL OR (pc.pricing_factors->>'party_type_id')::INT = p_party_type_id) AND
            (p_geographic_boundary_id IS NULL OR (pc.pricing_factors->>'geographic_boundary_id')::INT = p_geographic_boundary_id) AND
            (p_sale_type_id IS NULL OR (pc.pricing_factors->>'sale_type_id')::INT = p_sale_type_id)
        );

    -- è®¡ç®—æŠ˜æ‰£
    SELECT COALESCE(MAX(pc.percent_value), 0)
    INTO v_discount_pct
    FROM price_component pc
    INNER JOIN price_component_type pct ON pc.type_id = pct.type_id
    WHERE pc.product_id = p_product_id
        AND pct.type_code = 'DISCOUNT'
        AND (pc.from_date <= CURRENT_DATE)
        AND (pc.thru_date IS NULL OR pc.thru_date >= CURRENT_DATE);

    -- è®¡ç®—é™„åŠ è´¹
    SELECT COALESCE(SUM(pc.price_amount), 0)
    INTO v_surcharge
    FROM price_component pc
    INNER JOIN price_component_type pct ON pc.type_id = pct.type_id
    WHERE pc.product_id = p_product_id
        AND pct.type_code = 'SURCHARGE'
        AND (pc.from_date <= CURRENT_DATE)
        AND (pc.thru_date IS NULL OR pc.thru_date >= CURRENT_DATE);

    -- è®¡ç®—æœ€ç»ˆä»·æ ¼
    v_final_price := (v_base_price * (1 - v_discount_pct / 100) + v_surcharge) * p_quantity;

    RETURN v_final_price;
END;
$$ LANGUAGE plpgsql;
```

### æŸ¥è¯¢3: è·å–äº§å“BOMï¼ˆç‰©æ–™æ¸…å•ï¼‰

```sql
-- é€’å½’æŸ¥è¯¢äº§å“BOM
WITH RECURSIVE product_bom AS (
    SELECT
        p.product_id AS root_product_id,
        p.name AS root_product_name,
        p.product_id,
        p.name,
        pc.quantity_used,
        1 AS level,
        CAST(p.name AS TEXT) AS path
    FROM product p
    LEFT JOIN product_component pc ON p.product_id = pc.parent_product_id
    WHERE p.product_id = :root_product_id

    UNION ALL

    SELECT
        pbom.root_product_id,
        pbom.root_product_name,
        p.product_id,
        p.name,
        pc.quantity_used * pbom.quantity_used,
        pbom.level + 1,
        pbom.path || ' -> ' || p.name
    FROM product_bom pbom
    INNER JOIN product_component pc ON pbom.product_id = pc.parent_product_id
    INNER JOIN product p ON pc.child_product_id = p.product_id
    WHERE pbom.level < 10
)
SELECT
    root_product_name,
    name AS component_name,
    quantity_used,
    level,
    path
FROM product_bom
ORDER BY level, name;
```

---

## 11. æ€§èƒ½ä¼˜åŒ–

### 11.1 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

1. **äº§å“æŸ¥è¯¢**: ä½¿ç”¨product_codeå’Œnameçš„ç´¢å¼•
2. **åˆ†ç±»æŸ¥è¯¢**: ä½¿ç”¨é€’å½’CTE + ç´¢å¼•ä¼˜åŒ–å±‚æ¬¡æŸ¥è¯¢
3. **ç‰¹å¾æŸ¥è¯¢**: ä½¿ç”¨GINç´¢å¼•ä¼˜åŒ–JSONBå’Œå…¨æ–‡æœç´¢
4. **å®šä»·æŸ¥è¯¢**: ä½¿ç”¨æ—¥æœŸèŒƒå›´ç´¢å¼•å’Œéƒ¨åˆ†ç´¢å¼•
5. **åº“å­˜æŸ¥è¯¢**: ä½¿ç”¨å¤åˆç´¢å¼•ï¼ˆproduct_id + facility_idï¼‰

### 11.2 åˆ†åŒºç­–ç•¥

- **äº§å“è¡¨**: æŒ‰product_typeåˆ†åŒºï¼ˆGoods/Servicesï¼‰
- **åº“å­˜è¡¨**: æŒ‰inventory_typeåˆ†åŒºï¼ˆSerialized/Non-serializedï¼‰
- **ä»·æ ¼ç»„ä»¶è¡¨**: å¯æŒ‰from_dateåˆ†åŒºï¼ˆæ—¶é—´èŒƒå›´åˆ†åŒºï¼‰

### 11.3 æŸ¥è¯¢ä¼˜åŒ–å»ºè®®

1. ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜å¤æ‚æŸ¥è¯¢ç»“æœ
2. ä½¿ç”¨éƒ¨åˆ†ç´¢å¼•è¿‡æ»¤æ´»è·ƒæ•°æ®
3. ä½¿ç”¨JSONBå­˜å‚¨çµæ´»çš„å®šä»·å› å­ï¼Œé¿å…è¿‡å¤šå…³è”è¡¨

---

## 12. å®é™…åº”ç”¨æ¡ˆä¾‹

### æ¡ˆä¾‹1: ç”µå•†äº§å“ç®¡ç†

**åœºæ™¯**: ç”µå•†å¹³å°éœ€è¦ç®¡ç†å•†å“ã€SKUã€ä»·æ ¼ã€åº“å­˜ã€åˆ†ç±»ç­‰ã€‚

**å®ç°è¦ç‚¹**:

- ä½¿ç”¨productè¡¨å­˜å‚¨å•†å“åŸºç¡€ä¿¡æ¯
- ä½¿ç”¨product_featureç®¡ç†SKUï¼ˆé¢œè‰²ã€å°ºå¯¸ç­‰ï¼‰
- ä½¿ç”¨price_componentå®ç°åŠ¨æ€å®šä»·
- ä½¿ç”¨inventory_itemç®¡ç†å¤šä»“åº“åº“å­˜

### æ¡ˆä¾‹2: B2Bäº§å“ç›®å½•ç®¡ç†

**åœºæ™¯**: B2Bå¹³å°éœ€è¦ç®¡ç†äº§å“ç›®å½•ã€ä¾›åº”å•†ã€å¤šç»´åº¦å®šä»·ã€‚

**å®ç°è¦ç‚¹**:

- ä½¿ç”¨supplier_productç®¡ç†ä¾›åº”å•†äº§å“
- ä½¿ç”¨price_componentå®ç°åŸºäºå®¢æˆ·ç±»å‹çš„å·®å¼‚åŒ–å®šä»·
- ä½¿ç”¨product_categoryå®ç°äº§å“ç›®å½•å±‚æ¬¡ç»“æ„

### æ¡ˆä¾‹3: åˆ¶é€ ä¸šäº§å“ç®¡ç†

**åœºæ™¯**: åˆ¶é€ ä¼ä¸šéœ€è¦ç®¡ç†BOMã€æ‰¹æ¬¡ã€æˆæœ¬ç­‰ã€‚

**å®ç°è¦ç‚¹**:

- ä½¿ç”¨product_componentç®¡ç†BOM
- ä½¿ç”¨lotç®¡ç†æ‰¹æ¬¡
- ä½¿ç”¨estimated_product_costç®¡ç†æˆæœ¬
- ä½¿ç”¨inventory_itemç®¡ç†åºåˆ—åŒ–åº“å­˜

---

## 13. å¸¸è§é—®é¢˜è§£ç­” / FAQ

### Q1: äº§å“æ¨¡å‹ç›¸æ¯”ä¼ ç»Ÿè®¾è®¡æœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ

**A**: äº§å“æ¨¡å‹çš„ä¼˜åŠ¿åŒ…æ‹¬ï¼š

- ç»Ÿä¸€ç®¡ç†ï¼šç»Ÿä¸€å­˜å‚¨ä¼ä¸šè‡ªæœ‰äº§å“ã€ä¾›åº”å•†äº§å“å’Œç«äº‰å¯¹æ‰‹äº§å“
- çµæ´»åˆ†ç±»ï¼šæ”¯æŒå¤šç»´åº¦äº§å“åˆ†ç±»å’Œå±‚æ¬¡ç»“æ„
- ç‰¹å¾ç®¡ç†ï¼šçµæ´»çš„äº§å“ç‰¹å¾å’Œå˜ä½“ç®¡ç†ï¼Œé¿å…ä¸ºæ¯ä¸ªå˜ä½“åˆ›å»ºç‹¬ç«‹äº§å“
- å®šä»·çµæ´»ï¼šæ”¯æŒå¤æ‚çš„å¤šç»´åº¦å®šä»·ç­–ç•¥

### Q2: å¦‚ä½•å¤„ç†äº§å“çš„å¤§é‡å˜ä½“ï¼ˆSKUï¼‰ï¼Ÿ

**A**: ä½¿ç”¨äº§å“ç‰¹å¾æ¨¡å‹ï¼š

- åŸºç¡€äº§å“ï¼šå­˜å‚¨åœ¨productè¡¨
- å˜ä½“ç‰¹å¾ï¼šä½¿ç”¨product_feature_applicabilityå…³è”ç‰¹å¾
- æŸ¥è¯¢æ—¶ï¼šé€šè¿‡ç‰¹å¾ç»„åˆåŠ¨æ€ç”ŸæˆSKU
- ä¼˜åŠ¿ï¼šé¿å…ä¸ºæ¯ä¸ªSKUåˆ›å»ºç‹¬ç«‹äº§å“è®°å½•

### Q3: å¦‚ä½•å®ç°å¤æ‚çš„äº§å“å®šä»·è§„åˆ™ï¼Ÿ

**A**: ä½¿ç”¨ä»·æ ¼ç»„ä»¶æ¨¡å‹ï¼š

- åŸºç¡€ä»·æ ¼ï¼šå­˜å‚¨åœ¨price_componentè¡¨ä¸­
- å®šä»·å› å­ï¼šä½¿ç”¨JSONBå­˜å‚¨çµæ´»çš„å®šä»·å› å­ç»„åˆ
- è®¡ç®—é€»è¾‘ï¼šä½¿ç”¨å‡½æ•°è®¡ç®—æœ€ç»ˆä»·æ ¼ï¼Œè€ƒè™‘æ‰€æœ‰å®šä»·å› å­
- ä¸šåŠ¡è§„åˆ™ï¼šåœ¨åº”ç”¨å±‚å®ç°å®šä»·è§„åˆ™ä¼˜å…ˆçº§

### Q4: äº§å“æ¨¡å‹å¦‚ä½•å¤„ç†äº§å“ç‰ˆæœ¬å’Œæ·˜æ±°ï¼Ÿ

**A**: ä½¿ç”¨äº§å“å…³è”æ¨¡å‹ï¼š

- äº§å“æ·˜æ±°ï¼šä½¿ç”¨product_obsolescenceè®°å½•äº§å“æ›¿ä»£å…³ç³»
- äº§å“ç‰ˆæœ¬ï¼šå¯ä»¥ä½¿ç”¨product_componentè¡¨ç¤ºç‰ˆæœ¬å‡çº§
- å†å²è¿½è¸ªï¼šé€šè¿‡from_date/thru_dateç®¡ç†æ—¶é—´æœ‰æ•ˆæ€§

### Q5: å¦‚ä½•ä¼˜åŒ–äº§å“æ¨¡å‹çš„æŸ¥è¯¢æ€§èƒ½ï¼Ÿ

**A**: æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š

- ç´¢å¼•ï¼šä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µåˆ›å»ºç´¢å¼•
- åˆ†åŒºï¼šå¯¹å¤§æ•°æ®é‡è¡¨è¿›è¡Œåˆ†åŒº
- ç‰©åŒ–è§†å›¾ï¼šç¼“å­˜å¤æ‚æŸ¥è¯¢ç»“æœ
- JSONBç´¢å¼•ï¼šä½¿ç”¨GINç´¢å¼•ä¼˜åŒ–JSONBæŸ¥è¯¢

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**çŠ¶æ€**: âœ… æ–‡æ¡£å®Œæˆï¼ŒåŸºäºVolume 1 Chapter 3å®Œæ•´æ•´åˆ

---

## å®Œæ•´å®ç°è„šæœ¬è¡¥å……

### å®Œæ•´DDLè„šæœ¬ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰

```sql
-- å®Œæ•´äº§å“ç®¡ç†æ¨¡å‹DDLè„šæœ¬
-- åŸºäºSilverston Volume 1 Chapter 3

-- å¯ç”¨å¿…è¦çš„æ‰©å±•
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "btree_gin";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- äº§å“è¡¨ï¼ˆå·²åœ¨å‰é¢å®šä¹‰ï¼‰
-- ... (å‰é¢å·²å®šä¹‰çš„è¡¨ç»“æ„)

-- æ·»åŠ PostgreSQL 18ä¼˜åŒ–çš„è™šæ‹Ÿç”Ÿæˆåˆ—
ALTER TABLE price_component
ADD COLUMN IF NOT EXISTS calculated_price NUMERIC(10,2)
GENERATED ALWAYS AS (
    CASE
        WHEN price_amount IS NOT NULL THEN price_amount
        ELSE NULL
    END
) STORED;

-- æ·»åŠ è§¦å‘å™¨è‡ªåŠ¨æ›´æ–°æ—¶é—´æˆ³
CREATE OR REPLACE FUNCTION update_product_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_product_updated_at
    BEFORE UPDATE ON product
    FOR EACH ROW
    EXECUTE FUNCTION update_product_timestamp();
```

### å®Œæ•´æŸ¥è¯¢å‡½æ•°åº“

```sql
-- äº§å“ä»·æ ¼è®¡ç®—å‡½æ•°ï¼ˆå®Œæ•´ç‰ˆï¼‰
CREATE OR REPLACE FUNCTION get_product_price(
    p_product_id INT,
    p_customer_party_id INT DEFAULT NULL,
    p_geographic_boundary_id INT DEFAULT NULL,
    p_quantity NUMERIC DEFAULT 1,
    p_sale_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE (
    base_price NUMERIC(10,2),
    discount_amount NUMERIC(10,2),
    surcharge_amount NUMERIC(10,2),
    final_price NUMERIC(10,2)
) AS $$
BEGIN
    RETURN QUERY
    WITH base_price_calc AS (
        SELECT COALESCE(MAX(pc.price_amount), 0) AS price
        FROM price_component pc
        INNER JOIN price_component_type pct ON pc.type_id = pct.type_id
        WHERE pc.product_id = p_product_id
            AND pct.type_code = 'BASE_PRICE'
            AND pc.from_date <= p_sale_date
            AND (pc.thru_date IS NULL OR pc.thru_date >= p_sale_date)
    ),
    discount_calc AS (
        SELECT COALESCE(MAX(pc.percent_value), 0) AS discount_pct
        FROM price_component pc
        INNER JOIN price_component_type pct ON pc.type_id = pct.type_id
        WHERE pc.product_id = p_product_id
            AND pct.type_code = 'DISCOUNT'
            AND pc.from_date <= p_sale_date
            AND (pc.thru_date IS NULL OR pc.thru_date >= p_sale_date)
    ),
    surcharge_calc AS (
        SELECT COALESCE(SUM(pc.price_amount), 0) AS surcharge
        FROM price_component pc
        INNER JOIN price_component_type pct ON pc.type_id = pct.type_id
        WHERE pc.product_id = p_product_id
            AND pct.type_code = 'SURCHARGE'
            AND pc.from_date <= p_sale_date
            AND (pc.thru_date IS NULL OR pc.thru_date >= p_sale_date)
    )
    SELECT
        bp.price,
        bp.price * (dc.discount_pct / 100) AS discount,
        sc.surcharge,
        (bp.price * (1 - dc.discount_pct / 100) + sc.surcharge) * p_quantity AS final
    FROM base_price_calc bp, discount_calc dc, surcharge_calc sc;
END;
$$ LANGUAGE plpgsql;
```

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæ•´æ•´åˆVolume 1 Chapter 3æ‰€æœ‰æ ¸å¿ƒå†…å®¹

---

## 14. ç›¸å…³èµ„æº

### 14.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£

- [Partyæ¨¡å‹](./Partyæ¨¡å‹.md) - äººå‘˜ä¸ç»„ç»‡æ¨¡å‹ï¼ˆäº§å“ä¾›åº”å•†å…³è”ï¼‰
- [è®¢å•ç®¡ç†æ¨¡å‹](./è®¢å•ç®¡ç†æ¨¡å‹.md) - è®¢å•ä¸­ä½¿ç”¨äº§å“
- [Silverstonæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œ](../02-æƒå¨èµ„æºä¸æ ‡å‡†/Silverstonæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œ.md) - ä¸‰å·æœ¬è¯¦è§£

### 14.2 å½’æ¡£èµ„æº

- [Volume 1å®Œæ•´å†…å®¹](../../99-å½’æ¡£/å‚è€ƒèµ„æº/books/The Data Model Resource Book 1/full.md) - Chapter 3: Products

### 14.3 å‚è€ƒèµ„æº

- [PostgreSQL 18æ–‡æ¡£](https://www.postgresql.org/docs/18/) - PostgreSQL 18å®˜æ–¹æ–‡æ¡£
- [Silverstonå®˜ç½‘](https://www.silverston.com/) - æ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œå®˜æ–¹èµ„æº
