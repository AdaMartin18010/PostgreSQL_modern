# è®¢å•ç®¡ç†æ¨¡å‹å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: Silverstonã€Šæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œã€‹å·1 + å®è·µæ€»ç»“
> **çŠ¶æ€**: åŸºäºæƒå¨èµ„æºæ·±åŒ–æ‰©å±•
> **æ–‡æ¡£ç¼–å·**: 04-03

---

## ğŸ“‘ ç›®å½•

- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
- [2. æ ¸å¿ƒå®ä½“è®¾è®¡](#2-æ ¸å¿ƒå®ä½“è®¾è®¡)
  - [2.1 è®¢å•å¤´ï¼ˆOrder Headerï¼‰](#21-è®¢å•å¤´order-header)
  - [2.2 è®¢å•è¡Œï¼ˆOrder Lineï¼‰](#22-è®¢å•è¡Œorder-line)
  - [2.3 è®¢å•çŠ¶æ€ï¼ˆOrder Statusï¼‰](#23-è®¢å•çŠ¶æ€order-status)
- [3. æ”¯ä»˜ç®¡ç†](#3-æ”¯ä»˜ç®¡ç†)
- [4. å‘è´§ç®¡ç†](#4-å‘è´§ç®¡ç†)
- [5. è®¢å•å†å²è¿½è¸ª](#5-è®¢å•å†å²è¿½è¸ª)
- [6. PostgreSQLå®ç°](#6-postgresqlå®ç°)
- [7. æ€§èƒ½ä¼˜åŒ–](#7-æ€§èƒ½ä¼˜åŒ–)
- [8. ç›¸å…³èµ„æº](#8-ç›¸å…³èµ„æº)

---

## 1. æ¦‚è¿°

è®¢å•ç®¡ç†æ¨¡å‹æ˜¯ç”µå•†ã€ERPç­‰ä¸šåŠ¡ç³»ç»Ÿçš„æ ¸å¿ƒæ¨¡å‹ï¼Œæ¶‰åŠè®¢å•åˆ›å»ºã€æ”¯ä»˜ã€å‘è´§ã€é€€è´§ç­‰å®Œæ•´ä¸šåŠ¡æµç¨‹ã€‚
è‰¯å¥½çš„è®¢å•æ¨¡å‹è®¾è®¡éœ€è¦æ”¯æŒå¤æ‚ä¸šåŠ¡åœºæ™¯ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§å’ŒæŸ¥è¯¢æ€§èƒ½ã€‚

---

## 2. æ ¸å¿ƒå®ä½“è®¾è®¡

### 2.1 è®¢å•å¤´ï¼ˆOrder Headerï¼‰

**å®šä¹‰**: è®¢å•çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬å®¢æˆ·ã€è®¢å•æ—¥æœŸã€æ€»é‡‘é¢ç­‰ã€‚

**æ ¸å¿ƒå­—æ®µ**:

- è®¢å•IDï¼ˆä¸»é”®ï¼‰
- è®¢å•ç¼–å·ï¼ˆä¸šåŠ¡å”¯ä¸€æ ‡è¯†ï¼‰
- å®¢æˆ·IDï¼ˆå¤–é”®ï¼‰
- è®¢å•æ—¥æœŸ
- è®¢å•çŠ¶æ€
- æ€»é‡‘é¢
- å¸ç§

**PostgreSQLå®ç°**:

```sql
-- è®¢å•å¤´è¡¨
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id INT NOT NULL REFERENCES party(party_id),
    order_date TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' NOT NULL,
    total_amount NUMERIC(10,2) NOT NULL DEFAULT 0,
    currency_code CHAR(3) DEFAULT 'CNY' NOT NULL,
    shipping_address_id INT REFERENCES addresses(address_id),
    billing_address_id INT REFERENCES addresses(address_id),
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (total_amount >= 0),
    CHECK (status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded'))
);

-- è®¢å•ç¼–å·ç”Ÿæˆå‡½æ•°
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TEXT AS $$
DECLARE
    prefix TEXT := 'ORD';
    date_part TEXT := TO_CHAR(NOW(), 'YYYYMMDD');
    seq_part TEXT;
BEGIN
    SELECT LPAD(COALESCE(MAX(SUBSTRING(order_number FROM '[0-9]+$'))::INT + 1, 1)::TEXT, 6, '0')
    INTO seq_part
    FROM orders
    WHERE order_number LIKE prefix || date_part || '%';

    RETURN prefix || date_part || seq_part;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨è§¦å‘å™¨è‡ªåŠ¨ç”Ÿæˆè®¢å•ç¼–å·
CREATE OR REPLACE FUNCTION set_order_number()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.order_number IS NULL THEN
        NEW.order_number := generate_order_number();
    END IF;
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_order_number
BEFORE INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION set_order_number();
```

---

### 2.2 è®¢å•è¡Œï¼ˆOrder Lineï¼‰

**å®šä¹‰**: è®¢å•çš„æ˜ç»†é¡¹ï¼ŒåŒ…æ‹¬å•†å“ã€æ•°é‡ã€å•ä»·ç­‰ã€‚

**æ ¸å¿ƒå­—æ®µ**:

- è®¢å•è¡ŒIDï¼ˆä¸»é”®ï¼‰
- è®¢å•IDï¼ˆå¤–é”®ï¼‰
- å•†å“IDï¼ˆå¤–é”®ï¼‰
- æ•°é‡
- å•ä»·
- è¡Œé‡‘é¢ï¼ˆè®¡ç®—å­—æ®µï¼‰
- æŠ˜æ‰£é‡‘é¢

**PostgreSQLå®ç°**:

```sql
-- è®¢å•è¡Œè¡¨
CREATE TABLE order_items (
    line_id SERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    line_number INT NOT NULL,
    product_id INT NOT NULL REFERENCES products(product_id),
    product_name VARCHAR(200) NOT NULL,  -- å†—ä½™ï¼Œé¿å…å•†å“ä¿¡æ¯å˜æ›´å½±å“å†å²è®¢å•
    product_sku VARCHAR(50),  -- å†—ä½™
    quantity INT NOT NULL CHECK (quantity > 0),
    unit_price NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
    discount_amount NUMERIC(10,2) DEFAULT 0 CHECK (discount_amount >= 0),
    line_amount NUMERIC(10,2) GENERATED ALWAYS AS
        ((quantity * unit_price) - discount_amount) STORED,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(order_id, line_number),
    CHECK (discount_amount <= quantity * unit_price)
);

-- åˆ›å»ºç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- è®¢å•æ€»é‡‘é¢è®¡ç®—è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(line_amount), 0)
        FROM order_items
        WHERE order_id = COALESCE(NEW.order_id, OLD.order_id)
    ),
    updated_at = NOW()
    WHERE order_id = COALESCE(NEW.order_id, OLD.order_id);

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_total
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_total();
```

---

### 2.3 è®¢å•çŠ¶æ€ï¼ˆOrder Statusï¼‰

**å®šä¹‰**: è®¢å•çŠ¶æ€æµè½¬ï¼Œæ”¯æŒçŠ¶æ€å†å²è¿½è¸ªã€‚

**çŠ¶æ€æµè½¬**:

```text
pending â†’ confirmed â†’ processing â†’ shipped â†’ delivered
                â†“
            cancelled
                â†“
            refunded
```

**PostgreSQLå®ç°**:

```sql
-- è®¢å•çŠ¶æ€å†å²è¡¨
CREATE TABLE order_status_history (
    history_id SERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    status VARCHAR(20) NOT NULL,
    previous_status VARCHAR(20),
    changed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    changed_by INT REFERENCES party(party_id),
    notes TEXT,
    CHECK (status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded'))
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_order_status_history_order ON order_status_history(order_id);
CREATE INDEX idx_order_status_history_status ON order_status_history(status, changed_at);

-- çŠ¶æ€å˜æ›´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION log_order_status_change()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO order_status_history (order_id, status, previous_status, changed_by)
        VALUES (NEW.order_id, NEW.status, OLD.status, current_setting('app.user_id', TRUE)::INT);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_log_order_status_change
AFTER UPDATE OF status ON orders
FOR EACH ROW
EXECUTE FUNCTION log_order_status_change();
```

---

## 3. æ”¯ä»˜ç®¡ç†

### 3.1 æ”¯ä»˜è¡¨è®¾è®¡

**å®šä¹‰**: è®¢å•æ”¯ä»˜ä¿¡æ¯ï¼Œæ”¯æŒå¤šæ”¯ä»˜æ–¹å¼ã€åˆ†æœŸä»˜æ¬¾ã€‚

**PostgreSQLå®ç°**:

```sql
-- æ”¯ä»˜è¡¨
CREATE TABLE payments (
    payment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    payment_number VARCHAR(50) UNIQUE NOT NULL,
    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('CASH', 'CARD', 'ALIPAY', 'WECHAT', 'BANK_TRANSFER')),
    payment_amount NUMERIC(10,2) NOT NULL CHECK (payment_amount > 0),
    payment_status VARCHAR(20) DEFAULT 'pending' NOT NULL CHECK (payment_status IN ('pending', 'processing', 'completed', 'failed', 'refunded')),
    payment_date TIMESTAMPTZ,
    transaction_id VARCHAR(100),  -- ç¬¬ä¸‰æ–¹äº¤æ˜“ID
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_payments_order ON payments(order_id);
CREATE INDEX idx_payments_status ON payments(payment_status);
CREATE INDEX idx_payments_transaction ON payments(transaction_id);

-- æ”¯ä»˜çŠ¶æ€å˜æ›´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_order_payment_status()
RETURNS TRIGGER AS $$
DECLARE
    total_paid NUMERIC(10,2);
    order_total NUMERIC(10,2);
BEGIN
    -- è®¡ç®—è®¢å•å·²æ”¯ä»˜æ€»é¢
    SELECT COALESCE(SUM(payment_amount), 0)
    INTO total_paid
    FROM payments
    WHERE order_id = NEW.order_id
      AND payment_status = 'completed';

    -- è·å–è®¢å•æ€»é¢
    SELECT total_amount INTO order_total FROM orders WHERE order_id = NEW.order_id;

    -- æ›´æ–°è®¢å•çŠ¶æ€
    IF total_paid >= order_total THEN
        UPDATE orders
        SET status = CASE
            WHEN status = 'pending' THEN 'confirmed'
            ELSE status
        END
        WHERE order_id = NEW.order_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_payment_status
AFTER INSERT OR UPDATE OF payment_status ON payments
FOR EACH ROW
WHEN (NEW.payment_status = 'completed')
EXECUTE FUNCTION update_order_payment_status();
```

---

### 3.2 é€€æ¬¾ç®¡ç†

**PostgreSQLå®ç°**:

```sql
-- é€€æ¬¾è¡¨
CREATE TABLE refunds (
    refund_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    payment_id BIGINT REFERENCES payments(payment_id),
    refund_number VARCHAR(50) UNIQUE NOT NULL,
    refund_amount NUMERIC(10,2) NOT NULL CHECK (refund_amount > 0),
    refund_reason TEXT,
    refund_status VARCHAR(20) DEFAULT 'pending' NOT NULL CHECK (refund_status IN ('pending', 'processing', 'completed', 'rejected')),
    refund_date TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- é€€æ¬¾å®Œæˆè§¦å‘å™¨
CREATE OR REPLACE FUNCTION process_refund()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.refund_status = 'completed' AND OLD.refund_status != 'completed' THEN
        -- æ›´æ–°è®¢å•çŠ¶æ€
        UPDATE orders
        SET status = 'refunded',
            updated_at = NOW()
        WHERE order_id = NEW.order_id;

        -- æ›´æ–°æ”¯ä»˜çŠ¶æ€
        UPDATE payments
        SET payment_status = 'refunded',
            updated_at = NOW()
        WHERE payment_id = NEW.payment_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_process_refund
AFTER UPDATE OF refund_status ON refunds
FOR EACH ROW
EXECUTE FUNCTION process_refund();
```

---

## 4. å‘è´§ç®¡ç†

### 4.1 å‘è´§è¡¨è®¾è®¡

**PostgreSQLå®ç°**:

```sql
-- å‘è´§è¡¨
CREATE TABLE shipments (
    shipment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    shipment_number VARCHAR(50) UNIQUE NOT NULL,
    carrier_id INT REFERENCES carriers(carrier_id),
    carrier_name VARCHAR(100),  -- å†—ä½™
    tracking_number VARCHAR(100),
    shipment_status VARCHAR(20) DEFAULT 'pending' NOT NULL CHECK (shipment_status IN ('pending', 'picked', 'in_transit', 'delivered', 'returned')),
    shipped_date TIMESTAMPTZ,
    delivered_date TIMESTAMPTZ,
    shipping_address_id INT REFERENCES addresses(address_id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ‰¿è¿å•†è¡¨
CREATE TABLE carriers (
    carrier_id SERIAL PRIMARY KEY,
    carrier_name VARCHAR(100) NOT NULL UNIQUE,
    contact_phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE
);

-- å‘è´§æ˜ç»†è¡¨ï¼ˆæ”¯æŒéƒ¨åˆ†å‘è´§ï¼‰
CREATE TABLE shipment_items (
    shipment_item_id SERIAL PRIMARY KEY,
    shipment_id BIGINT NOT NULL REFERENCES shipments(shipment_id) ON DELETE CASCADE,
    order_item_id INT NOT NULL REFERENCES order_items(line_id),
    quantity_shipped INT NOT NULL CHECK (quantity_shipped > 0),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å‘è´§çŠ¶æ€å˜æ›´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_order_shipment_status()
RETURNS TRIGGER AS $$
DECLARE
    all_shipped BOOLEAN;
    all_delivered BOOLEAN;
BEGIN
    -- æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è®¢å•è¡Œéƒ½å·²å‘è´§
    SELECT COUNT(*) = 0
    INTO all_shipped
    FROM order_items oi
    WHERE oi.order_id = NEW.order_id
      AND NOT EXISTS (
          SELECT 1 FROM shipment_items si
          JOIN shipments s ON si.shipment_id = s.shipment_id
          WHERE si.order_item_id = oi.line_id
            AND s.shipment_status IN ('picked', 'in_transit', 'delivered')
      );

    -- æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å‘è´§éƒ½å·²é€è¾¾
    SELECT COUNT(*) = 0
    INTO all_delivered
    FROM shipments s
    WHERE s.order_id = NEW.order_id
      AND s.shipment_status != 'delivered';

    -- æ›´æ–°è®¢å•çŠ¶æ€
    IF NEW.shipment_status = 'picked' AND all_shipped THEN
        UPDATE orders
        SET status = 'shipped',
            updated_at = NOW()
        WHERE order_id = NEW.order_id;
    ELSIF NEW.shipment_status = 'delivered' AND all_delivered THEN
        UPDATE orders
        SET status = 'delivered',
            updated_at = NOW()
        WHERE order_id = NEW.order_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_shipment_status
AFTER UPDATE OF shipment_status ON shipments
FOR EACH ROW
EXECUTE FUNCTION update_order_shipment_status();
```

---

## 5. è®¢å•å†å²è¿½è¸ª

### 5.1 è®¢å•å¿«ç…§è¡¨

**å®šä¹‰**: å®šæœŸä¿å­˜è®¢å•å¿«ç…§ï¼Œç”¨äºå†å²æŸ¥è¯¢å’Œå®¡è®¡ã€‚

**PostgreSQLå®ç°**:

```sql
-- è®¢å•å¿«ç…§è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE order_snapshots (
    snapshot_id BIGSERIAL,
    order_id BIGINT NOT NULL,
    snapshot_date DATE NOT NULL,
    order_data JSONB NOT NULL,  -- è®¢å•å®Œæ•´æ•°æ®å¿«ç…§
    PRIMARY KEY (snapshot_id, snapshot_date)
) PARTITION BY RANGE (snapshot_date);

-- åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE order_snapshots_2024_01 PARTITION OF order_snapshots
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- è®¢å•å¿«ç…§ç”Ÿæˆå‡½æ•°
CREATE OR REPLACE FUNCTION create_order_snapshot()
RETURNS VOID AS $$
DECLARE
    order_rec RECORD;
BEGIN
    FOR order_rec IN
        SELECT
            o.*,
            jsonb_agg(
                jsonb_build_object(
                    'line_id', oi.line_id,
                    'product_id', oi.product_id,
                    'product_name', oi.product_name,
                    'quantity', oi.quantity,
                    'unit_price', oi.unit_price,
                    'line_amount', oi.line_amount
                )
            ) AS items
        FROM orders o
        LEFT JOIN order_items oi ON o.order_id = oi.order_id
        WHERE o.order_date >= CURRENT_DATE - INTERVAL '1 month'
        GROUP BY o.order_id
    LOOP
        INSERT INTO order_snapshots (order_id, snapshot_date, order_data)
        VALUES (
            order_rec.order_id,
            CURRENT_DATE,
            to_jsonb(order_rec)
        )
        ON CONFLICT DO NOTHING;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- å®šæœŸæ‰§è¡Œï¼ˆä½¿ç”¨pg_cronæ‰©å±•ï¼‰
-- SELECT cron.schedule('create-order-snapshot', '0 0 1 * *', 'SELECT create_order_snapshot()');
```

---

## 6. PostgreSQLå®ç°

### 6.1 å®Œæ•´è®¢å•åˆ›å»ºæµç¨‹

```sql
-- 1. åˆ›å»ºè®¢å•
INSERT INTO orders (customer_id, total_amount)
VALUES (1, 0)
RETURNING order_id, order_number;

-- 2. æ·»åŠ è®¢å•è¡Œ
INSERT INTO order_items (order_id, line_number, product_id, product_name, quantity, unit_price)
VALUES
    (1, 1, 101, 'å•†å“A', 2, 100.00),
    (1, 2, 102, 'å•†å“B', 1, 200.00);

-- 3. è®¢å•æ€»é‡‘é¢è‡ªåŠ¨æ›´æ–°ï¼ˆé€šè¿‡è§¦å‘å™¨ï¼‰

-- 4. åˆ›å»ºæ”¯ä»˜
INSERT INTO payments (order_id, payment_method, payment_amount, payment_status)
VALUES (1, 'ALIPAY', 400.00, 'completed');

-- 5. è®¢å•çŠ¶æ€è‡ªåŠ¨æ›´æ–°ä¸ºconfirmedï¼ˆé€šè¿‡è§¦å‘å™¨ï¼‰

-- 6. åˆ›å»ºå‘è´§
INSERT INTO shipments (order_id, carrier_id, tracking_number, shipment_status)
VALUES (1, 1, 'SF1234567890', 'picked');

-- 7. æ·»åŠ å‘è´§æ˜ç»†
INSERT INTO shipment_items (shipment_id, order_item_id, quantity_shipped)
VALUES (1, 1, 2), (1, 2, 1);
```

---

### 6.2 è®¢å•æŸ¥è¯¢ä¼˜åŒ–

```sql
-- æŸ¥è¯¢è®¢å•è¯¦æƒ…ï¼ˆä½¿ç”¨CTEä¼˜åŒ–ï¼‰
WITH order_summary AS (
    SELECT
        o.*,
        COUNT(oi.line_id) AS item_count,
        SUM(oi.line_amount) AS calculated_total
    FROM orders o
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.order_id = 1
    GROUP BY o.order_id
)
SELECT
    os.*,
    jsonb_agg(
        jsonb_build_object(
            'product_name', oi.product_name,
            'quantity', oi.quantity,
            'unit_price', oi.unit_price,
            'line_amount', oi.line_amount
        )
    ) AS items,
    jsonb_agg(
        jsonb_build_object(
            'payment_method', p.payment_method,
            'payment_amount', p.payment_amount,
            'payment_status', p.payment_status
        )
    ) FILTER (WHERE p.payment_id IS NOT NULL) AS payments
FROM order_summary os
LEFT JOIN order_items oi ON os.order_id = oi.order_id
LEFT JOIN payments p ON os.order_id = p.order_id
GROUP BY os.order_id, os.order_number, os.customer_id, os.order_date,
         os.status, os.total_amount, os.item_count, os.calculated_total;
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 ç´¢å¼•ç­–ç•¥

```sql
-- è®¢å•è¡¨ç´¢å¼•
CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_orders_date ON orders(order_date);
CREATE INDEX idx_orders_status ON orders(status) WHERE status IN ('pending', 'processing');
CREATE INDEX idx_orders_number ON orders(order_number);

-- è®¢å•è¡Œè¡¨ç´¢å¼•
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- æ”¯ä»˜è¡¨ç´¢å¼•
CREATE INDEX idx_payments_order ON payments(order_id);
CREATE INDEX idx_payments_status ON payments(payment_status);
CREATE INDEX idx_payments_transaction ON payments(transaction_id);

-- å‘è´§è¡¨ç´¢å¼•
CREATE INDEX idx_shipments_order ON shipments(order_id);
CREATE INDEX idx_shipments_tracking ON shipments(tracking_number);
```

---

### 7.2 åˆ†åŒºç­–ç•¥

```sql
-- è®¢å•è¡¨æŒ‰æœˆåˆ†åŒºï¼ˆå¤§è¡¨åœºæ™¯ï¼‰
ALTER TABLE orders PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024_01 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- è®¢å•å†å²è¡¨æŒ‰å¹´åˆ†åŒº
CREATE TABLE order_status_history (
    history_id SERIAL,
    order_id BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL,
    changed_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (history_id, changed_at)
) PARTITION BY RANGE (changed_at);

CREATE TABLE order_status_history_2024 PARTITION OF order_status_history
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

---

## 8. ç›¸å…³èµ„æº

- [Partyæ¨¡å‹](./Partyæ¨¡å‹.md) - å®¢æˆ·æ¨¡å‹
- [èŒƒå¼åŒ–è®¾è®¡](./èŒƒå¼åŒ–è®¾è®¡.md) - OLTPè®¾è®¡åŸåˆ™
- [çº¦æŸè®¾è®¡](../08-PostgreSQLå»ºæ¨¡å®è·µ/çº¦æŸè®¾è®¡.md) - çº¦æŸè®¾è®¡å®è·µ
- [ç´¢å¼•ç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/ç´¢å¼•ç­–ç•¥.md) - ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
- [Silverstonæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œ](../02-æƒå¨èµ„æºä¸æ ‡å‡†/Silverstonæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œ.md) - è®¢å•æ¨¡å‹æ¥æº

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
