# è®¢å•ç®¡ç†æ¨¡å‹å®Œæ•´æŒ‡å—

> **åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ
> **æ¥æº**: Silverstonã€Šæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œã€‹å·1 + å®è·µæ€»ç»“
> **çŠ¶æ€**: åŸºäºæƒå¨èµ„æºæ·±åŒ–æ‰©å±•
> **æ–‡æ¡£ç¼–å·**: 04-03

---

## ğŸ“‘ ç›®å½•

- [è®¢å•ç®¡ç†æ¨¡å‹å®Œæ•´æŒ‡å—](#è®¢å•ç®¡ç†æ¨¡å‹å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
  - [1.1 ç†è®ºåŸºç¡€](#11-ç†è®ºåŸºç¡€)
    - [1.1.1 è®¢å•æ¨¡å‹åŸºæœ¬æ¦‚å¿µ](#111-è®¢å•æ¨¡å‹åŸºæœ¬æ¦‚å¿µ)
    - [1.1.2 è®¢å•è®¾è®¡æ¨¡å¼](#112-è®¢å•è®¾è®¡æ¨¡å¼)
    - [1.1.3 æ”¯ä»˜ç®¡ç†ç†è®º](#113-æ”¯ä»˜ç®¡ç†ç†è®º)
    - [1.1.4 å‘è´§ç®¡ç†ç†è®º](#114-å‘è´§ç®¡ç†ç†è®º)
    - [1.1.5 è®¢å•å†å²è¿½è¸ªç†è®º](#115-è®¢å•å†å²è¿½è¸ªç†è®º)
    - [1.1.6 å¤æ‚åº¦åˆ†æ](#116-å¤æ‚åº¦åˆ†æ)
  - [2. æ ¸å¿ƒå®ä½“è®¾è®¡](#2-æ ¸å¿ƒå®ä½“è®¾è®¡)
    - [2.1 è®¢å•å¤´ï¼ˆOrder Headerï¼‰](#21-è®¢å•å¤´order-header)
    - [2.2 è®¢å•è¡Œï¼ˆOrder Lineï¼‰](#22-è®¢å•è¡Œorder-line)
    - [2.3 è®¢å•çŠ¶æ€ï¼ˆOrder Statusï¼‰](#23-è®¢å•çŠ¶æ€order-status)
  - [3. æ”¯ä»˜ç®¡ç†](#3-æ”¯ä»˜ç®¡ç†)
    - [3.1 æ”¯ä»˜è¡¨è®¾è®¡](#31-æ”¯ä»˜è¡¨è®¾è®¡)
    - [3.2 é€€æ¬¾ç®¡ç†](#32-é€€æ¬¾ç®¡ç†)
  - [4. å‘è´§ç®¡ç†](#4-å‘è´§ç®¡ç†)
    - [4.1 å‘è´§è¡¨è®¾è®¡](#41-å‘è´§è¡¨è®¾è®¡)
  - [5. è®¢å•å†å²è¿½è¸ª](#5-è®¢å•å†å²è¿½è¸ª)
    - [5.1 è®¢å•å¿«ç…§è¡¨](#51-è®¢å•å¿«ç…§è¡¨)
  - [6. PostgreSQLå®ç°](#6-postgresqlå®ç°)
    - [6.1 å®Œæ•´è®¢å•åˆ›å»ºæµç¨‹](#61-å®Œæ•´è®¢å•åˆ›å»ºæµç¨‹)
    - [6.2 è®¢å•æŸ¥è¯¢ä¼˜åŒ–](#62-è®¢å•æŸ¥è¯¢ä¼˜åŒ–)
  - [7. æ€§èƒ½ä¼˜åŒ–](#7-æ€§èƒ½ä¼˜åŒ–)
    - [7.1 ç´¢å¼•ç­–ç•¥](#71-ç´¢å¼•ç­–ç•¥)
    - [7.2 åˆ†åŒºç­–ç•¥](#72-åˆ†åŒºç­–ç•¥)
  - [8. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Examples](#8-å®é™…åº”ç”¨æ¡ˆä¾‹--practical-application-examples)
    - [8.1 æ¡ˆä¾‹1: ç”µå•†è®¢å•ç³»ç»Ÿ](#81-æ¡ˆä¾‹1-ç”µå•†è®¢å•ç³»ç»Ÿ)
    - [8.2 æ¡ˆä¾‹2: B2Bè®¢å•ç³»ç»Ÿ](#82-æ¡ˆä¾‹2-b2bè®¢å•ç³»ç»Ÿ)
    - [8.3 æ¡ˆä¾‹3: è®¢é˜…è®¢å•ç³»ç»Ÿ](#83-æ¡ˆä¾‹3-è®¢é˜…è®¢å•ç³»ç»Ÿ)
  - [9. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§ / Performance Optimization and Monitoring](#9-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§--performance-optimization-and-monitoring)
    - [9.1 è®¢å•æŸ¥è¯¢ä¼˜åŒ–](#91-è®¢å•æŸ¥è¯¢ä¼˜åŒ–)
    - [9.2 è®¢å•å¤„ç†ç›‘æ§](#92-è®¢å•å¤„ç†ç›‘æ§)
  - [10. å¸¸è§é—®é¢˜è§£ç­” / FAQ](#10-å¸¸è§é—®é¢˜è§£ç­”--faq)
    - [Q1: è®¢å•è¡¨åº”è¯¥å¦‚ä½•è®¾è®¡æ‰èƒ½æ”¯æŒå¤æ‚ä¸šåŠ¡ï¼Ÿ](#q1-è®¢å•è¡¨åº”è¯¥å¦‚ä½•è®¾è®¡æ‰èƒ½æ”¯æŒå¤æ‚ä¸šåŠ¡)
    - [Q2: å¦‚ä½•å¤„ç†è®¢å•çš„å¹¶å‘ä¿®æ”¹ï¼Ÿ](#q2-å¦‚ä½•å¤„ç†è®¢å•çš„å¹¶å‘ä¿®æ”¹)
    - [Q3: è®¢å•å†å²æ•°æ®å¦‚ä½•ç®¡ç†ï¼Ÿ](#q3-è®¢å•å†å²æ•°æ®å¦‚ä½•ç®¡ç†)
    - [Q4: å¦‚ä½•ä¼˜åŒ–è®¢å•æŸ¥è¯¢æ€§èƒ½ï¼Ÿ](#q4-å¦‚ä½•ä¼˜åŒ–è®¢å•æŸ¥è¯¢æ€§èƒ½)
    - [Q5: è®¢å•é€€æ¬¾å¦‚ä½•å¤„ç†ï¼Ÿ](#q5-è®¢å•é€€æ¬¾å¦‚ä½•å¤„ç†)
  - [11. ç›¸å…³èµ„æº / Related Resources](#11-ç›¸å…³èµ„æº--related-resources)
    - [11.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents](#111-æ ¸å¿ƒç›¸å…³æ–‡æ¡£--core-related-documents)
    - [11.2 ç†è®ºåŸºç¡€ / Theoretical Foundation](#112-ç†è®ºåŸºç¡€--theoretical-foundation)
    - [11.3 å®è·µæŒ‡å— / Practical Guides](#113-å®è·µæŒ‡å—--practical-guides)
    - [11.4 åº”ç”¨æ¡ˆä¾‹ / Application Cases](#114-åº”ç”¨æ¡ˆä¾‹--application-cases)
    - [11.5 å‚è€ƒèµ„æº / Reference Resources](#115-å‚è€ƒèµ„æº--reference-resources)

---

## 1. æ¦‚è¿°

è®¢å•ç®¡ç†æ¨¡å‹æ˜¯ç”µå•†ã€ERPç­‰ä¸šåŠ¡ç³»ç»Ÿçš„æ ¸å¿ƒæ¨¡å‹ï¼Œæ¶‰åŠè®¢å•åˆ›å»ºã€æ”¯ä»˜ã€å‘è´§ã€é€€è´§ç­‰å®Œæ•´ä¸šåŠ¡æµç¨‹ã€‚
è‰¯å¥½çš„è®¢å•æ¨¡å‹è®¾è®¡éœ€è¦æ”¯æŒå¤æ‚ä¸šåŠ¡åœºæ™¯ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§å’ŒæŸ¥è¯¢æ€§èƒ½ã€‚

---

## 1.1 ç†è®ºåŸºç¡€

### 1.1.1 è®¢å•æ¨¡å‹åŸºæœ¬æ¦‚å¿µ

**è®¢å•ï¼ˆOrderï¼‰**æ˜¯ä¸šåŠ¡äº¤æ˜“çš„æ ¸å¿ƒå®ä½“ï¼š

- **è®¢å•å¤´ï¼ˆOrder Headerï¼‰**: è®¢å•çš„åŸºæœ¬ä¿¡æ¯
- **è®¢å•è¡Œï¼ˆOrder Lineï¼‰**: è®¢å•çš„æ˜ç»†ä¿¡æ¯
- **è®¢å•çŠ¶æ€ï¼ˆOrder Statusï¼‰**: è®¢å•çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€

**è®¢å•ç”Ÿå‘½å‘¨æœŸ**:

- **çŠ¶æ€è½¬æ¢**: $S_1 \rightarrow S_2 \rightarrow ... \rightarrow S_n$
- **çŠ¶æ€æœº**: å®šä¹‰å…è®¸çš„çŠ¶æ€è½¬æ¢
- **çŠ¶æ€å†å²**: è®°å½•çŠ¶æ€è½¬æ¢å†å²

### 1.1.2 è®¢å•è®¾è®¡æ¨¡å¼

**è®¢å•å¤´-è®¢å•è¡Œæ¨¡å¼**:

- **ä¸€å¯¹å¤šå…³ç³»**: ä¸€ä¸ªè®¢å•å¤´å¯¹åº”å¤šä¸ªè®¢å•è¡Œ
- **èšåˆæ ¹**: è®¢å•å¤´æ˜¯èšåˆæ ¹
- **äº‹åŠ¡è¾¹ç•Œ**: è®¢å•å¤´+è®¢å•è¡Œåœ¨åŒä¸€äº‹åŠ¡ä¸­

**è®¢å•è®¾è®¡åŸåˆ™**:

- **ä¸å¯å˜æ€§**: å·²ç¡®è®¤è®¢å•ä¸å¯ä¿®æ”¹
- **å¯è¿½æº¯æ€§**: è®°å½•è®¢å•å˜æ›´å†å²
- **ä¸€è‡´æ€§**: è®¢å•å¤´æ€»é‡‘é¢ = è®¢å•è¡Œé‡‘é¢ä¹‹å’Œ

### 1.1.3 æ”¯ä»˜ç®¡ç†ç†è®º

**æ”¯ä»˜æµç¨‹**:

- **æ”¯ä»˜åˆ›å»º**: åˆ›å»ºæ”¯ä»˜è®°å½•
- **æ”¯ä»˜å¤„ç†**: å¤„ç†æ”¯ä»˜è¯·æ±‚
- **æ”¯ä»˜ç¡®è®¤**: ç¡®è®¤æ”¯ä»˜ç»“æœ

**æ”¯ä»˜çŠ¶æ€æœº**:

- **çŠ¶æ€**: pending â†’ processing â†’ completed/failed
- **å¹‚ç­‰æ€§**: æ”¯ä»˜æ“ä½œéœ€è¦ä¿è¯å¹‚ç­‰æ€§
- **å¯¹è´¦**: å®šæœŸå¯¹è´¦ç¡®ä¿æ•°æ®ä¸€è‡´æ€§

### 1.1.4 å‘è´§ç®¡ç†ç†è®º

**å‘è´§æµç¨‹**:

- **å‘è´§åˆ›å»º**: åˆ›å»ºå‘è´§è®°å½•
- **å‘è´§å¤„ç†**: å¤„ç†å‘è´§è¯·æ±‚
- **å‘è´§ç¡®è®¤**: ç¡®è®¤å‘è´§ç»“æœ

**å‘è´§çŠ¶æ€**:

- **çŠ¶æ€**: pending â†’ shipped â†’ delivered â†’ returned
- **ç‰©æµè·Ÿè¸ª**: è®°å½•ç‰©æµä¿¡æ¯
- **å¼‚å¸¸å¤„ç†**: å¤„ç†å‘è´§å¼‚å¸¸

### 1.1.5 è®¢å•å†å²è¿½è¸ªç†è®º

**å†å²è¿½è¸ªæ¨¡å¼**:

- **å¿«ç…§æ¨¡å¼**: ä¿å­˜è®¢å•å¿«ç…§
- **äº‹ä»¶æº¯æº**: è®°å½•è®¢å•äº‹ä»¶
- **ç‰ˆæœ¬æ§åˆ¶**: è®°å½•è®¢å•ç‰ˆæœ¬

**å†å²æŸ¥è¯¢**:

- **æ—¶é—´ç‚¹æŸ¥è¯¢**: æŸ¥è¯¢ç‰¹å®šæ—¶é—´ç‚¹çš„è®¢å•çŠ¶æ€
- **å˜æ›´å†å²**: æŸ¥è¯¢è®¢å•å˜æ›´å†å²
- **å®¡è®¡è¿½è¸ª**: è®°å½•æ“ä½œå®¡è®¡ä¿¡æ¯

### 1.1.6 å¤æ‚åº¦åˆ†æ

**å­˜å‚¨å¤æ‚åº¦**:

- **è®¢å•å¤´**: $O(O)$ where O is number of orders
- **è®¢å•è¡Œ**: $O(O \times L)$ where L is average lines per order
- **è®¢å•å†å²**: $O(O \times H)$ where H is average history records per order

**æŸ¥è¯¢å¤æ‚åº¦**:

- **è®¢å•æŸ¥è¯¢**: $O(\log O)$ with index
- **è®¢å•è¡ŒæŸ¥è¯¢**: $O(\log L)$ with index
- **å†å²æŸ¥è¯¢**: $O(\log H)$ with index

---

## 2. æ ¸å¿ƒå®ä½“è®¾è®¡

### 2.1 è®¢å•å¤´ï¼ˆOrder Headerï¼‰

**å®šä¹‰**: è®¢å•çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬å®¢æˆ·ã€è®¢å•æ—¥æœŸã€æ€»é‡‘é¢ç­‰ã€‚

**æ ¸å¿ƒå­—æ®µ**:

- è®¢å•IDï¼ˆä¸»é”®ï¼‰
- è®¢å•ç¼–å·ï¼ˆä¸šåŠ¡å”¯ä¸€æ ‡è¯†ï¼‰
- å®¢æˆ·IDï¼ˆå¤–é”®ï¼‰
- è®¢å•æ—¥æœŸ
- è®¢å•çŠ¶æ€
- æ€»é‡‘é¢
- å¸ç§

**PostgreSQLå®ç°**:

```sql
-- è®¢å•å¤´è¡¨
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id INT NOT NULL REFERENCES party(party_id),
    order_date TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' NOT NULL,
    total_amount NUMERIC(10,2) NOT NULL DEFAULT 0,
    currency_code CHAR(3) DEFAULT 'CNY' NOT NULL,
    shipping_address_id INT REFERENCES addresses(address_id),
    billing_address_id INT REFERENCES addresses(address_id),
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CHECK (total_amount >= 0),
    CHECK (status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded'))
);

-- è®¢å•ç¼–å·ç”Ÿæˆå‡½æ•°
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TEXT AS $$
DECLARE
    prefix TEXT := 'ORD';
    date_part TEXT := TO_CHAR(NOW(), 'YYYYMMDD');
    seq_part TEXT;
BEGIN
    SELECT LPAD(COALESCE(MAX(SUBSTRING(order_number FROM '[0-9]+$'))::INT + 1, 1)::TEXT, 6, '0')
    INTO seq_part
    FROM orders
    WHERE order_number LIKE prefix || date_part || '%';

    RETURN prefix || date_part || seq_part;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨è§¦å‘å™¨è‡ªåŠ¨ç”Ÿæˆè®¢å•ç¼–å·
CREATE OR REPLACE FUNCTION set_order_number()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.order_number IS NULL THEN
        NEW.order_number := generate_order_number();
    END IF;
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_set_order_number
BEFORE INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION set_order_number();
```

---

### 2.2 è®¢å•è¡Œï¼ˆOrder Lineï¼‰

**å®šä¹‰**: è®¢å•çš„æ˜ç»†é¡¹ï¼ŒåŒ…æ‹¬å•†å“ã€æ•°é‡ã€å•ä»·ç­‰ã€‚

**æ ¸å¿ƒå­—æ®µ**:

- è®¢å•è¡ŒIDï¼ˆä¸»é”®ï¼‰
- è®¢å•IDï¼ˆå¤–é”®ï¼‰
- å•†å“IDï¼ˆå¤–é”®ï¼‰
- æ•°é‡
- å•ä»·
- è¡Œé‡‘é¢ï¼ˆè®¡ç®—å­—æ®µï¼‰
- æŠ˜æ‰£é‡‘é¢

**PostgreSQLå®ç°**:

```sql
-- è®¢å•è¡Œè¡¨ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'order_items') THEN
        CREATE TABLE order_items (
            line_id SERIAL PRIMARY KEY,
            order_id BIGINT NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
            line_number INT NOT NULL,
            product_id INT NOT NULL REFERENCES products(product_id),
            product_name VARCHAR(200) NOT NULL,  -- å†—ä½™ï¼Œé¿å…å•†å“ä¿¡æ¯å˜æ›´å½±å“å†å²è®¢å•
            product_sku VARCHAR(50),  -- å†—ä½™
            quantity INT NOT NULL CHECK (quantity > 0),
            unit_price NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
            discount_amount NUMERIC(10,2) DEFAULT 0 CHECK (discount_amount >= 0),
            line_amount NUMERIC(10,2) GENERATED ALWAYS AS
                ((quantity * unit_price) - discount_amount) STORED,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            UNIQUE(order_id, line_number),
            CHECK (discount_amount <= quantity * unit_price)
        );
        RAISE NOTICE 'è¡¨ order_items åˆ›å»ºæˆåŠŸ';
    ELSE
        RAISE NOTICE 'è¡¨ order_items å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'åˆ›å»ºè¡¨ order_items å¤±è´¥: %', SQLERRM;
END $$;

-- åˆ›å»ºç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢ï¼ˆå¸¦é”™è¯¯å¤„ç†ï¼‰
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_order_items_order ON order_items(order_id);
    CREATE INDEX IF NOT EXISTS idx_order_items_product ON order_items(product_id);
    RAISE NOTICE 'ç´¢å¼•åˆ›å»ºæˆåŠŸ';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'åˆ›å»ºç´¢å¼•å¤±è´¥: %', SQLERRM;
END $$;

-- è®¢å•æ€»é‡‘é¢è®¡ç®—è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(line_amount), 0)
        FROM order_items
        WHERE order_id = COALESCE(NEW.order_id, OLD.order_id)
    ),
    updated_at = NOW()
    WHERE order_id = COALESCE(NEW.order_id, OLD.order_id);

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_total
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_total();
```

---

### 2.3 è®¢å•çŠ¶æ€ï¼ˆOrder Statusï¼‰

**å®šä¹‰**: è®¢å•çŠ¶æ€æµè½¬ï¼Œæ”¯æŒçŠ¶æ€å†å²è¿½è¸ªã€‚

**çŠ¶æ€æµè½¬**:

```text
pending â†’ confirmed â†’ processing â†’ shipped â†’ delivered
                â†“
            cancelled
                â†“
            refunded
```

**PostgreSQLå®ç°**:

```sql
-- è®¢å•çŠ¶æ€å†å²è¡¨
CREATE TABLE order_status_history (
    history_id SERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
    status VARCHAR(20) NOT NULL,
    previous_status VARCHAR(20),
    changed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    changed_by INT REFERENCES party(party_id),
    notes TEXT,
    CHECK (status IN ('pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded'))
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_order_status_history_order ON order_status_history(order_id);
CREATE INDEX idx_order_status_history_status ON order_status_history(status, changed_at);

-- çŠ¶æ€å˜æ›´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION log_order_status_change()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO order_status_history (order_id, status, previous_status, changed_by)
        VALUES (NEW.order_id, NEW.status, OLD.status, current_setting('app.user_id', TRUE)::INT);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_log_order_status_change
AFTER UPDATE OF status ON orders
FOR EACH ROW
EXECUTE FUNCTION log_order_status_change();
```

---

## 3. æ”¯ä»˜ç®¡ç†

### 3.1 æ”¯ä»˜è¡¨è®¾è®¡

**å®šä¹‰**: è®¢å•æ”¯ä»˜ä¿¡æ¯ï¼Œæ”¯æŒå¤šæ”¯ä»˜æ–¹å¼ã€åˆ†æœŸä»˜æ¬¾ã€‚

**PostgreSQLå®ç°**:

```sql
-- æ”¯ä»˜è¡¨
CREATE TABLE payments (
    payment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    payment_number VARCHAR(50) UNIQUE NOT NULL,
    payment_method VARCHAR(20) NOT NULL CHECK (payment_method IN ('CASH', 'CARD', 'ALIPAY', 'WECHAT', 'BANK_TRANSFER')),
    payment_amount NUMERIC(10,2) NOT NULL CHECK (payment_amount > 0),
    payment_status VARCHAR(20) DEFAULT 'pending' NOT NULL CHECK (payment_status IN ('pending', 'processing', 'completed', 'failed', 'refunded')),
    payment_date TIMESTAMPTZ,
    transaction_id VARCHAR(100),  -- ç¬¬ä¸‰æ–¹äº¤æ˜“ID
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_payments_order ON payments(order_id);
CREATE INDEX idx_payments_status ON payments(payment_status);
CREATE INDEX idx_payments_transaction ON payments(transaction_id);

-- æ”¯ä»˜çŠ¶æ€å˜æ›´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_order_payment_status()
RETURNS TRIGGER AS $$
DECLARE
    total_paid NUMERIC(10,2);
    order_total NUMERIC(10,2);
BEGIN
    -- è®¡ç®—è®¢å•å·²æ”¯ä»˜æ€»é¢
    SELECT COALESCE(SUM(payment_amount), 0)
    INTO total_paid
    FROM payments
    WHERE order_id = NEW.order_id
      AND payment_status = 'completed';

    -- è·å–è®¢å•æ€»é¢
    SELECT total_amount INTO order_total FROM orders WHERE order_id = NEW.order_id;

    -- æ›´æ–°è®¢å•çŠ¶æ€
    IF total_paid >= order_total THEN
        UPDATE orders
        SET status = CASE
            WHEN status = 'pending' THEN 'confirmed'
            ELSE status
        END
        WHERE order_id = NEW.order_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_payment_status
AFTER INSERT OR UPDATE OF payment_status ON payments
FOR EACH ROW
WHEN (NEW.payment_status = 'completed')
EXECUTE FUNCTION update_order_payment_status();
```

---

### 3.2 é€€æ¬¾ç®¡ç†

**PostgreSQLå®ç°**:

```sql
-- é€€æ¬¾è¡¨
CREATE TABLE refunds (
    refund_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    payment_id BIGINT REFERENCES payments(payment_id),
    refund_number VARCHAR(50) UNIQUE NOT NULL,
    refund_amount NUMERIC(10,2) NOT NULL CHECK (refund_amount > 0),
    refund_reason TEXT,
    refund_status VARCHAR(20) DEFAULT 'pending' NOT NULL CHECK (refund_status IN ('pending', 'processing', 'completed', 'rejected')),
    refund_date TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- é€€æ¬¾å®Œæˆè§¦å‘å™¨
CREATE OR REPLACE FUNCTION process_refund()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.refund_status = 'completed' AND OLD.refund_status != 'completed' THEN
        -- æ›´æ–°è®¢å•çŠ¶æ€
        UPDATE orders
        SET status = 'refunded',
            updated_at = NOW()
        WHERE order_id = NEW.order_id;

        -- æ›´æ–°æ”¯ä»˜çŠ¶æ€
        UPDATE payments
        SET payment_status = 'refunded',
            updated_at = NOW()
        WHERE payment_id = NEW.payment_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_process_refund
AFTER UPDATE OF refund_status ON refunds
FOR EACH ROW
EXECUTE FUNCTION process_refund();
```

---

## 4. å‘è´§ç®¡ç†

### 4.1 å‘è´§è¡¨è®¾è®¡

**PostgreSQLå®ç°**:

```sql
-- å‘è´§è¡¨
CREATE TABLE shipments (
    shipment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    shipment_number VARCHAR(50) UNIQUE NOT NULL,
    carrier_id INT REFERENCES carriers(carrier_id),
    carrier_name VARCHAR(100),  -- å†—ä½™
    tracking_number VARCHAR(100),
    shipment_status VARCHAR(20) DEFAULT 'pending' NOT NULL CHECK (shipment_status IN ('pending', 'picked', 'in_transit', 'delivered', 'returned')),
    shipped_date TIMESTAMPTZ,
    delivered_date TIMESTAMPTZ,
    shipping_address_id INT REFERENCES addresses(address_id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ‰¿è¿å•†è¡¨
CREATE TABLE carriers (
    carrier_id SERIAL PRIMARY KEY,
    carrier_name VARCHAR(100) NOT NULL UNIQUE,
    contact_phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE
);

-- å‘è´§æ˜ç»†è¡¨ï¼ˆæ”¯æŒéƒ¨åˆ†å‘è´§ï¼‰
CREATE TABLE shipment_items (
    shipment_item_id SERIAL PRIMARY KEY,
    shipment_id BIGINT NOT NULL REFERENCES shipments(shipment_id) ON DELETE CASCADE,
    order_item_id INT NOT NULL REFERENCES order_items(line_id),
    quantity_shipped INT NOT NULL CHECK (quantity_shipped > 0),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å‘è´§çŠ¶æ€å˜æ›´è§¦å‘å™¨
CREATE OR REPLACE FUNCTION update_order_shipment_status()
RETURNS TRIGGER AS $$
DECLARE
    all_shipped BOOLEAN;
    all_delivered BOOLEAN;
BEGIN
    -- æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è®¢å•è¡Œéƒ½å·²å‘è´§
    SELECT COUNT(*) = 0
    INTO all_shipped
    FROM order_items oi
    WHERE oi.order_id = NEW.order_id
      AND NOT EXISTS (
          SELECT 1 FROM shipment_items si
          JOIN shipments s ON si.shipment_id = s.shipment_id
          WHERE si.order_item_id = oi.line_id
            AND s.shipment_status IN ('picked', 'in_transit', 'delivered')
      );

    -- æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å‘è´§éƒ½å·²é€è¾¾
    SELECT COUNT(*) = 0
    INTO all_delivered
    FROM shipments s
    WHERE s.order_id = NEW.order_id
      AND s.shipment_status != 'delivered';

    -- æ›´æ–°è®¢å•çŠ¶æ€
    IF NEW.shipment_status = 'picked' AND all_shipped THEN
        UPDATE orders
        SET status = 'shipped',
            updated_at = NOW()
        WHERE order_id = NEW.order_id;
    ELSIF NEW.shipment_status = 'delivered' AND all_delivered THEN
        UPDATE orders
        SET status = 'delivered',
            updated_at = NOW()
        WHERE order_id = NEW.order_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_shipment_status
AFTER UPDATE OF shipment_status ON shipments
FOR EACH ROW
EXECUTE FUNCTION update_order_shipment_status();
```

---

## 5. è®¢å•å†å²è¿½è¸ª

### 5.1 è®¢å•å¿«ç…§è¡¨

**å®šä¹‰**: å®šæœŸä¿å­˜è®¢å•å¿«ç…§ï¼Œç”¨äºå†å²æŸ¥è¯¢å’Œå®¡è®¡ã€‚

**PostgreSQLå®ç°**:

```sql
-- è®¢å•å¿«ç…§è¡¨ï¼ˆæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE order_snapshots (
    snapshot_id BIGSERIAL,
    order_id BIGINT NOT NULL,
    snapshot_date DATE NOT NULL,
    order_data JSONB NOT NULL,  -- è®¢å•å®Œæ•´æ•°æ®å¿«ç…§
    PRIMARY KEY (snapshot_id, snapshot_date)
) PARTITION BY RANGE (snapshot_date);

-- åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE order_snapshots_2024_01 PARTITION OF order_snapshots
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- è®¢å•å¿«ç…§ç”Ÿæˆå‡½æ•°
CREATE OR REPLACE FUNCTION create_order_snapshot()
RETURNS VOID AS $$
DECLARE
    order_rec RECORD;
BEGIN
    FOR order_rec IN
        SELECT
            o.*,
            jsonb_agg(
                jsonb_build_object(
                    'line_id', oi.line_id,
                    'product_id', oi.product_id,
                    'product_name', oi.product_name,
                    'quantity', oi.quantity,
                    'unit_price', oi.unit_price,
                    'line_amount', oi.line_amount
                )
            ) AS items
        FROM orders o
        LEFT JOIN order_items oi ON o.order_id = oi.order_id
        WHERE o.order_date >= CURRENT_DATE - INTERVAL '1 month'
        GROUP BY o.order_id
    LOOP
        INSERT INTO order_snapshots (order_id, snapshot_date, order_data)
        VALUES (
            order_rec.order_id,
            CURRENT_DATE,
            to_jsonb(order_rec)
        )
        ON CONFLICT DO NOTHING;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- å®šæœŸæ‰§è¡Œï¼ˆä½¿ç”¨pg_cronæ‰©å±•ï¼‰
-- SELECT cron.schedule('create-order-snapshot', '0 0 1 * *', 'SELECT create_order_snapshot()');
```

---

## 6. PostgreSQLå®ç°

### 6.1 å®Œæ•´è®¢å•åˆ›å»ºæµç¨‹

```sql
-- 1. åˆ›å»ºè®¢å•
INSERT INTO orders (customer_id, total_amount)
VALUES (1, 0)
RETURNING order_id, order_number;

-- 2. æ·»åŠ è®¢å•è¡Œ
INSERT INTO order_items (order_id, line_number, product_id, product_name, quantity, unit_price)
VALUES
    (1, 1, 101, 'å•†å“A', 2, 100.00),
    (1, 2, 102, 'å•†å“B', 1, 200.00);

-- 3. è®¢å•æ€»é‡‘é¢è‡ªåŠ¨æ›´æ–°ï¼ˆé€šè¿‡è§¦å‘å™¨ï¼‰

-- 4. åˆ›å»ºæ”¯ä»˜
INSERT INTO payments (order_id, payment_method, payment_amount, payment_status)
VALUES (1, 'ALIPAY', 400.00, 'completed');

-- 5. è®¢å•çŠ¶æ€è‡ªåŠ¨æ›´æ–°ä¸ºconfirmedï¼ˆé€šè¿‡è§¦å‘å™¨ï¼‰

-- 6. åˆ›å»ºå‘è´§
INSERT INTO shipments (order_id, carrier_id, tracking_number, shipment_status)
VALUES (1, 1, 'SF1234567890', 'picked');

-- 7. æ·»åŠ å‘è´§æ˜ç»†
INSERT INTO shipment_items (shipment_id, order_item_id, quantity_shipped)
VALUES (1, 1, 2), (1, 2, 1);
```

---

### 6.2 è®¢å•æŸ¥è¯¢ä¼˜åŒ–

```sql
-- æŸ¥è¯¢è®¢å•è¯¦æƒ…ï¼ˆä½¿ç”¨CTEä¼˜åŒ–ï¼‰
WITH order_summary AS (
    SELECT
        o.*,
        COUNT(oi.line_id) AS item_count,
        SUM(oi.line_amount) AS calculated_total
    FROM orders o
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.order_id = 1
    GROUP BY o.order_id
)
SELECT
    os.*,
    jsonb_agg(
        jsonb_build_object(
            'product_name', oi.product_name,
            'quantity', oi.quantity,
            'unit_price', oi.unit_price,
            'line_amount', oi.line_amount
        )
    ) AS items,
    jsonb_agg(
        jsonb_build_object(
            'payment_method', p.payment_method,
            'payment_amount', p.payment_amount,
            'payment_status', p.payment_status
        )
    ) FILTER (WHERE p.payment_id IS NOT NULL) AS payments
FROM order_summary os
LEFT JOIN order_items oi ON os.order_id = oi.order_id
LEFT JOIN payments p ON os.order_id = p.order_id
GROUP BY os.order_id, os.order_number, os.customer_id, os.order_date,
         os.status, os.total_amount, os.item_count, os.calculated_total;
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 ç´¢å¼•ç­–ç•¥

```sql
-- è®¢å•è¡¨ç´¢å¼•
CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_orders_date ON orders(order_date);
CREATE INDEX idx_orders_status ON orders(status) WHERE status IN ('pending', 'processing');
CREATE INDEX idx_orders_number ON orders(order_number);

-- è®¢å•è¡Œè¡¨ç´¢å¼•
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- æ”¯ä»˜è¡¨ç´¢å¼•
CREATE INDEX idx_payments_order ON payments(order_id);
CREATE INDEX idx_payments_status ON payments(payment_status);
CREATE INDEX idx_payments_transaction ON payments(transaction_id);

-- å‘è´§è¡¨ç´¢å¼•
CREATE INDEX idx_shipments_order ON shipments(order_id);
CREATE INDEX idx_shipments_tracking ON shipments(tracking_number);
```

---

### 7.2 åˆ†åŒºç­–ç•¥

```sql
-- è®¢å•è¡¨æŒ‰æœˆåˆ†åŒºï¼ˆå¤§è¡¨åœºæ™¯ï¼‰
ALTER TABLE orders PARTITION BY RANGE (order_date);

CREATE TABLE orders_2024_01 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- è®¢å•å†å²è¡¨æŒ‰å¹´åˆ†åŒº
CREATE TABLE order_status_history (
    history_id SERIAL,
    order_id BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL,
    changed_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (history_id, changed_at)
) PARTITION BY RANGE (changed_at);

CREATE TABLE order_status_history_2024 PARTITION OF order_status_history
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

---

## 8. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Examples

### 8.1 æ¡ˆä¾‹1: ç”µå•†è®¢å•ç³»ç»Ÿ

**ç”µå•†è®¢å•å®Œæ•´å®ç°**:

```sql
-- ç”µå•†è®¢å•ç³»ç»Ÿï¼šæ”¯æŒå¤šå•†å“ã€å¤šæ”¯ä»˜æ–¹å¼ã€å¤šå‘è´§åœ°å€
CREATE TABLE ecommerce_orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id BIGINT NOT NULL,
    order_date TIMESTAMPTZ DEFAULT NOW(),
    total_amount NUMERIC(10,2) NOT NULL,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    shipping_fee NUMERIC(10,2) DEFAULT 0,
    final_amount NUMERIC(10,2) NOT NULL,
    order_status VARCHAR(20) DEFAULT 'pending',
    payment_status VARCHAR(20) DEFAULT 'unpaid',
    shipping_status VARCHAR(20) DEFAULT 'unshipped',
    shipping_address JSONB NOT NULL,
    billing_address JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE ecommerce_order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES ecommerce_orders(order_id),
    product_id BIGINT NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    product_sku VARCHAR(100),
    quantity INT NOT NULL CHECK (quantity > 0),
    unit_price NUMERIC(10,2) NOT NULL,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    line_total NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è®¢å•åˆ›å»ºå‡½æ•°
CREATE OR REPLACE FUNCTION create_ecommerce_order(
    p_customer_id BIGINT,
    p_items JSONB,
    p_shipping_address JSONB
)
RETURNS BIGINT AS $$
DECLARE
    v_order_id BIGINT;
    v_total_amount NUMERIC(10,2) := 0;
    v_item JSONB;
BEGIN
    -- è®¡ç®—æ€»é‡‘é¢
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
        v_total_amount := v_total_amount +
            ((v_item->>'quantity')::INT * (v_item->>'unit_price')::NUMERIC);
    END LOOP;

    -- åˆ›å»ºè®¢å•
    INSERT INTO ecommerce_orders (
        order_number, customer_id, total_amount, final_amount, shipping_address
    )
    VALUES (
        'ORD' || TO_CHAR(NOW(), 'YYYYMMDD') || LPAD(nextval('order_number_seq')::TEXT, 6, '0'),
        p_customer_id,
        v_total_amount,
        v_total_amount,
        p_shipping_address
    )
    RETURNING order_id INTO v_order_id;

    -- åˆ›å»ºè®¢å•é¡¹
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
        INSERT INTO ecommerce_order_items (
            order_id, product_id, product_name, product_sku,
            quantity, unit_price, line_total
        )
        VALUES (
            v_order_id,
            (v_item->>'product_id')::BIGINT,
            v_item->>'product_name',
            v_item->>'product_sku',
            (v_item->>'quantity')::INT,
            (v_item->>'unit_price')::NUMERIC,
            (v_item->>'quantity')::INT * (v_item->>'unit_price')::NUMERIC
        );
    END LOOP;

    RETURN v_order_id;
END;
$$ LANGUAGE plpgsql;
```

### 8.2 æ¡ˆä¾‹2: B2Bè®¢å•ç³»ç»Ÿ

**B2Bè®¢å•ç³»ç»Ÿå®ç°**:

```sql
-- B2Bè®¢å•ç³»ç»Ÿï¼šæ”¯æŒåˆåŒã€å‘ç¥¨ã€åˆ†æœŸä»˜æ¬¾
CREATE TABLE b2b_orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    customer_company_id BIGINT NOT NULL,
    sales_rep_id BIGINT,
    contract_id BIGINT,
    order_date DATE NOT NULL,
    required_delivery_date DATE,
    total_amount NUMERIC(15,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'CNY',
    payment_terms VARCHAR(50), -- 'NET30', 'NET60', etc.
    order_status VARCHAR(20) DEFAULT 'draft',
    approval_status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE b2b_order_installments (
    installment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES b2b_orders(order_id),
    installment_number INT NOT NULL,
    due_date DATE NOT NULL,
    amount NUMERIC(15,2) NOT NULL,
    paid_amount NUMERIC(15,2) DEFAULT 0,
    payment_status VARCHAR(20) DEFAULT 'unpaid',
    paid_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºåˆ†æœŸä»˜æ¬¾è®¡åˆ’
CREATE OR REPLACE FUNCTION create_payment_plan(
    p_order_id BIGINT,
    p_total_amount NUMERIC,
    p_installment_count INT,
    p_payment_terms VARCHAR
)
RETURNS VOID AS $$
DECLARE
    v_installment_amount NUMERIC(15,2);
    v_due_date DATE;
    i INT;
BEGIN
    v_installment_amount := p_total_amount / p_installment_count;
    v_due_date := CURRENT_DATE;

    -- æ ¹æ®ä»˜æ¬¾æ¡ä»¶è®¡ç®—åˆ°æœŸæ—¥
    IF p_payment_terms = 'NET30' THEN
        v_due_date := CURRENT_DATE + INTERVAL '30 days';
    ELSIF p_payment_terms = 'NET60' THEN
        v_due_date := CURRENT_DATE + INTERVAL '60 days';
    END IF;

    FOR i IN 1..p_installment_count
    LOOP
        INSERT INTO b2b_order_installments (
            order_id, installment_number, due_date, amount
        )
        VALUES (
            p_order_id,
            i,
            v_due_date + (i - 1 || ' months')::INTERVAL,
            v_installment_amount
        );
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 8.3 æ¡ˆä¾‹3: è®¢é˜…è®¢å•ç³»ç»Ÿ

**è®¢é˜…è®¢å•ç³»ç»Ÿå®ç°**:

```sql
-- è®¢é˜…è®¢å•ç³»ç»Ÿï¼šæ”¯æŒå‘¨æœŸæ€§è®¢å•ã€è‡ªåŠ¨ç»­è®¢
CREATE TABLE subscription_orders (
    subscription_id BIGSERIAL PRIMARY KEY,
    subscription_number VARCHAR(50) UNIQUE NOT NULL,
    customer_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    subscription_type VARCHAR(50) NOT NULL, -- 'monthly', 'quarterly', 'yearly'
    start_date DATE NOT NULL,
    end_date DATE,
    next_billing_date DATE NOT NULL,
    billing_cycle INT NOT NULL, -- å¤©æ•°
    amount_per_cycle NUMERIC(10,2) NOT NULL,
    auto_renew BOOLEAN DEFAULT TRUE,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE subscription_billing_history (
    billing_id BIGSERIAL PRIMARY KEY,
    subscription_id BIGINT NOT NULL REFERENCES subscription_orders(subscription_id),
    billing_date DATE NOT NULL,
    billing_period_start DATE NOT NULL,
    billing_period_end DATE NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    payment_status VARCHAR(20) DEFAULT 'pending',
    paid_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è‡ªåŠ¨ç”Ÿæˆè´¦å•
CREATE OR REPLACE FUNCTION generate_subscription_billings()
RETURNS INT AS $$
DECLARE
    v_subscription RECORD;
    v_count INT := 0;
BEGIN
    FOR v_subscription IN
        SELECT * FROM subscription_orders
        WHERE status = 'active'
          AND next_billing_date <= CURRENT_DATE
    LOOP
        -- åˆ›å»ºè´¦å•
        INSERT INTO subscription_billing_history (
            subscription_id, billing_date,
            billing_period_start, billing_period_end,
            amount
        )
        VALUES (
            v_subscription.subscription_id,
            CURRENT_DATE,
            v_subscription.next_billing_date - (v_subscription.billing_cycle || ' days')::INTERVAL,
            v_subscription.next_billing_date,
            v_subscription.amount_per_cycle
        );

        -- æ›´æ–°ä¸‹æ¬¡è´¦å•æ—¥æœŸ
        UPDATE subscription_orders
        SET next_billing_date = next_billing_date + (billing_cycle || ' days')::INTERVAL
        WHERE subscription_id = v_subscription.subscription_id;

        v_count := v_count + 1;
    END LOOP;

    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

---

## 9. æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§ / Performance Optimization and Monitoring

### 9.1 è®¢å•æŸ¥è¯¢ä¼˜åŒ–

**æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥**:

```sql
-- è®¢å•åˆ—è¡¨æŸ¥è¯¢ä¼˜åŒ–ï¼ˆè¦†ç›–ç´¢å¼•ï¼‰
CREATE INDEX idx_orders_customer_status_date ON orders(customer_id, order_status, order_date DESC)
INCLUDE (order_id, total_amount);

-- æŸ¥è¯¢ä»…éœ€æ‰«æç´¢å¼•
SELECT order_id, total_amount, order_date
FROM orders
WHERE customer_id = 123 AND order_status = 'completed'
ORDER BY order_date DESC
LIMIT 20;

-- è®¢å•è¯¦æƒ…æŸ¥è¯¢ä¼˜åŒ–ï¼ˆç‰©åŒ–è§†å›¾ï¼‰
CREATE MATERIALIZED VIEW mv_order_summary AS
SELECT
    o.order_id,
    o.order_number,
    o.customer_id,
    o.total_amount,
    o.order_status,
    COUNT(oi.item_id) AS item_count,
    SUM(oi.quantity) AS total_quantity
FROM orders o
LEFT JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id, o.order_number, o.customer_id, o.total_amount, o.order_status;

CREATE UNIQUE INDEX ON mv_order_summary(order_id);
```

### 9.2 è®¢å•å¤„ç†ç›‘æ§

**ç›‘æ§æŸ¥è¯¢**:

```sql
-- ç›‘æ§ï¼šè®¢å•å¤„ç†æ€§èƒ½
SELECT
    order_status,
    COUNT(*) AS order_count,
    AVG(EXTRACT(EPOCH FROM (updated_at - created_at))) AS avg_processing_seconds,
    MAX(EXTRACT(EPOCH FROM (updated_at - created_at))) AS max_processing_seconds
FROM orders
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY order_status
ORDER BY order_count DESC;

-- ç›‘æ§ï¼šè®¢å•é‡‘é¢åˆ†å¸ƒ
SELECT
    CASE
        WHEN total_amount < 100 THEN '0-100'
        WHEN total_amount < 500 THEN '100-500'
        WHEN total_amount < 1000 THEN '500-1000'
        ELSE '1000+'
    END AS amount_range,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_revenue
FROM orders
WHERE order_date >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY amount_range
ORDER BY amount_range;

-- ç›‘æ§ï¼šè®¢å•é¡¹ç»Ÿè®¡
SELECT
    product_id,
    COUNT(*) AS order_count,
    SUM(quantity) AS total_quantity,
    SUM(line_total) AS total_revenue
FROM order_items
WHERE created_at >= NOW() - INTERVAL '7 days'
GROUP BY product_id
ORDER BY total_revenue DESC
LIMIT 10;
```

---

## 10. å¸¸è§é—®é¢˜è§£ç­” / FAQ

### Q1: è®¢å•è¡¨åº”è¯¥å¦‚ä½•è®¾è®¡æ‰èƒ½æ”¯æŒå¤æ‚ä¸šåŠ¡ï¼Ÿ

**A**: è®¾è®¡åŸåˆ™ï¼š

1. **è®¢å•å¤´è¡¨**: å­˜å‚¨è®¢å•åŸºæœ¬ä¿¡æ¯
2. **è®¢å•é¡¹è¡¨**: å­˜å‚¨è®¢å•å•†å“æ˜ç»†
3. **è®¢å•çŠ¶æ€è¡¨**: å­˜å‚¨è®¢å•çŠ¶æ€å†å²
4. **æ‰©å±•è¡¨**: ä½¿ç”¨JSONBå­˜å‚¨çµæ´»å­—æ®µ

```sql
-- æ ¸å¿ƒè¡¨ï¼šè®¢å•å¤´
CREATE TABLE orders (...);

-- æ˜ç»†è¡¨ï¼šè®¢å•é¡¹
CREATE TABLE order_items (...);

-- å†å²è¡¨ï¼šçŠ¶æ€å˜æ›´
CREATE TABLE order_status_history (...);

-- æ‰©å±•è¡¨ï¼šçµæ´»å­—æ®µ
CREATE TABLE order_extensions (
    order_id BIGINT PRIMARY KEY REFERENCES orders(order_id),
    custom_fields JSONB
);
```

### Q2: å¦‚ä½•å¤„ç†è®¢å•çš„å¹¶å‘ä¿®æ”¹ï¼Ÿ

**A**: å¹¶å‘æ§åˆ¶ç­–ç•¥ï¼š

```sql
-- ä½¿ç”¨ä¹è§‚é”ï¼ˆç‰ˆæœ¬å·ï¼‰
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    version INT DEFAULT 1,
    ...
);

-- æ›´æ–°æ—¶æ£€æŸ¥ç‰ˆæœ¬
UPDATE orders
SET order_status = 'shipped',
    version = version + 1
WHERE order_id = 123 AND version = 1;  -- ç‰ˆæœ¬æ£€æŸ¥

-- ä½¿ç”¨è¡Œçº§é”
BEGIN;
SELECT * FROM orders WHERE order_id = 123 FOR UPDATE;
-- æ‰§è¡Œæ›´æ–°
UPDATE orders SET order_status = 'shipped' WHERE order_id = 123;
COMMIT;
```

### Q3: è®¢å•å†å²æ•°æ®å¦‚ä½•ç®¡ç†ï¼Ÿ

**A**: å†å²æ•°æ®ç®¡ç†ï¼š

```sql
-- æ–¹æ¡ˆ1ï¼šå†å²è¡¨å½’æ¡£
CREATE TABLE orders_archive (LIKE orders INCLUDING ALL);
INSERT INTO orders_archive
SELECT * FROM orders WHERE order_date < CURRENT_DATE - INTERVAL '2 years';
DELETE FROM orders WHERE order_date < CURRENT_DATE - INTERVAL '2 years';

-- æ–¹æ¡ˆ2ï¼šåˆ†åŒºè¡¨
CREATE TABLE orders (
    ...
) PARTITION BY RANGE (order_date);

-- å®šæœŸå½’æ¡£æ—§åˆ†åŒº
ALTER TABLE orders DETACH PARTITION orders_2022_01;
ALTER TABLE orders_2022_01 RENAME TO orders_2022_01_archive;
```

### Q4: å¦‚ä½•ä¼˜åŒ–è®¢å•æŸ¥è¯¢æ€§èƒ½ï¼Ÿ

**A**: æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥ï¼š

1. **ç´¢å¼•ä¼˜åŒ–**: ä¸ºå¸¸ç”¨æŸ¥è¯¢åˆ›å»ºç´¢å¼•
2. **ç‰©åŒ–è§†å›¾**: é¢„è®¡ç®—è®¢å•ç»Ÿè®¡
3. **åˆ†åŒºä¼˜åŒ–**: æŒ‰æ—¶é—´åˆ†åŒºè®¢å•è¡¨
4. **æŸ¥è¯¢ä¼˜åŒ–**: é¿å…SELECT *ï¼ŒåªæŸ¥è¯¢éœ€è¦çš„åˆ—

```sql
-- åˆ›å»ºè®¢å•ç»Ÿè®¡ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW mv_order_statistics AS
SELECT
    DATE_TRUNC('day', order_date) AS order_day,
    order_status,
    COUNT(*) AS order_count,
    SUM(total_amount) AS total_revenue
FROM orders
GROUP BY order_day, order_status;

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_order_statistics;
```

### Q5: è®¢å•é€€æ¬¾å¦‚ä½•å¤„ç†ï¼Ÿ

**A**: é€€æ¬¾å¤„ç†ï¼š

```sql
-- é€€æ¬¾è¡¨
CREATE TABLE order_refunds (
    refund_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    refund_amount NUMERIC(10,2) NOT NULL,
    refund_reason TEXT,
    refund_type VARCHAR(50), -- 'full', 'partial'
    refund_status VARCHAR(20) DEFAULT 'pending',
    refunded_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- é€€æ¬¾å¤„ç†å‡½æ•°
CREATE OR REPLACE FUNCTION process_refund(
    p_order_id BIGINT,
    p_refund_amount NUMERIC,
    p_refund_reason TEXT
)
RETURNS BIGINT AS $$
DECLARE
    v_refund_id BIGINT;
    v_order_amount NUMERIC;
BEGIN
    -- æ£€æŸ¥è®¢å•é‡‘é¢
    SELECT total_amount INTO v_order_amount FROM orders WHERE order_id = p_order_id;

    IF p_refund_amount > v_order_amount THEN
        RAISE EXCEPTION 'Refund amount exceeds order amount';
    END IF;

    -- åˆ›å»ºé€€æ¬¾è®°å½•
    INSERT INTO order_refunds (
        order_id, refund_amount, refund_reason, refund_type
    )
    VALUES (
        p_order_id,
        p_refund_amount,
        p_refund_reason,
        CASE WHEN p_refund_amount = v_order_amount THEN 'full' ELSE 'partial' END
    )
    RETURNING refund_id INTO v_refund_id;

    -- æ›´æ–°è®¢å•çŠ¶æ€
    UPDATE orders
    SET order_status = 'refunded',
        updated_at = NOW()
    WHERE order_id = p_order_id;

    RETURN v_refund_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 11. ç›¸å…³èµ„æº / Related Resources

### 11.1 æ ¸å¿ƒç›¸å…³æ–‡æ¡£ / Core Related Documents

- [Partyæ¨¡å‹](./Partyæ¨¡å‹.md) - è®¢å•æ¨¡å‹ä¸­çš„å®¢æˆ·/ä¾›åº”å•†Party
- [èŒƒå¼åŒ–è®¾è®¡](./èŒƒå¼åŒ–è®¾è®¡.md) - OLTPè®¾è®¡åŸåˆ™å’ŒèŒƒå¼åŒ–ç­–ç•¥
- [çº¦æŸè®¾è®¡](../08-PostgreSQLå»ºæ¨¡å®è·µ/çº¦æŸè®¾è®¡.md) - è®¢å•æ¨¡å‹çº¦æŸè®¾è®¡å®è·µ
- [ç´¢å¼•ç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/ç´¢å¼•ç­–ç•¥.md) - è®¢å•æ¨¡å‹ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
- [åˆ†åŒºç­–ç•¥](../08-PostgreSQLå»ºæ¨¡å®è·µ/åˆ†åŒºç­–ç•¥.md) - è®¢å•è¡¨åˆ†åŒºç­–ç•¥
- [æ€§èƒ½ä¼˜åŒ–](../08-PostgreSQLå»ºæ¨¡å®è·µ/æ€§èƒ½ä¼˜åŒ–.md) - è®¢å•æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

### 11.2 ç†è®ºåŸºç¡€ / Theoretical Foundation

- [èŒƒå¼ç†è®º](../01-æ•°æ®å»ºæ¨¡ç†è®ºåŸºç¡€/èŒƒå¼ç†è®º.md) - æ•°æ®åº“èŒƒå¼ç†è®º
- [çº¦æŸç†è®º](../01-æ•°æ®å»ºæ¨¡ç†è®ºåŸºç¡€/çº¦æŸç†è®º.md) - å®Œæ•´æ€§çº¦æŸç†è®º
- [Silverstonæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œ](../02-æƒå¨èµ„æºä¸æ ‡å‡†/Silverstonæ•°æ®æ¨¡å‹èµ„æºæ‰‹å†Œ.md) - è®¢å•æ¨¡å‹æ¥æºï¼ˆVolume 1ï¼‰

### 11.3 å®è·µæŒ‡å— / Practical Guides

- [æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§](#9-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§--performance-optimization-and-monitoring) - æœ¬æ–‡æ¡£çš„æ€§èƒ½ç›‘æ§ç« èŠ‚
- [å®é™…åº”ç”¨æ¡ˆä¾‹](#8-å®é™…åº”ç”¨æ¡ˆä¾‹--practical-application-examples) - æœ¬æ–‡æ¡£çš„åº”ç”¨æ¡ˆä¾‹ç« èŠ‚

### 11.4 åº”ç”¨æ¡ˆä¾‹ / Application Cases

- [ç”µå•†æ•°æ®æ¨¡å‹æ¡ˆä¾‹](../10-ç»¼åˆåº”ç”¨æ¡ˆä¾‹/ç”µå•†æ•°æ®æ¨¡å‹æ¡ˆä¾‹.md) - ç”µå•†è®¢å•ç³»ç»Ÿå®Œæ•´æ¡ˆä¾‹
- [é‡‘èæ•°æ®æ¨¡å‹æ¡ˆä¾‹](../10-ç»¼åˆåº”ç”¨æ¡ˆä¾‹/é‡‘èæ•°æ®æ¨¡å‹æ¡ˆä¾‹.md) - é‡‘èäº¤æ˜“è®¢å•æ¡ˆä¾‹

### 11.5 å‚è€ƒèµ„æº / Reference Resources

- [æƒå¨èµ„æºç´¢å¼•](../00-å¯¼èˆªä¸ç´¢å¼•/æƒå¨èµ„æºç´¢å¼•.md) - æƒå¨èµ„æºåˆ—è¡¨
- [æœ¯è¯­å¯¹ç…§è¡¨](../00-å¯¼èˆªä¸ç´¢å¼•/æœ¯è¯­å¯¹ç…§è¡¨.md) - Volume 1/2æœ¯è¯­å¯¹ç…§
- [å¿«é€ŸæŸ¥æ‰¾æŒ‡å—](../00-å¯¼èˆªä¸ç´¢å¼•/å¿«é€ŸæŸ¥æ‰¾æŒ‡å—.md) - å¿«é€ŸæŸ¥æ‰¾å·¥å…·
- PostgreSQLå®˜æ–¹æ–‡æ¡£: [Table Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
