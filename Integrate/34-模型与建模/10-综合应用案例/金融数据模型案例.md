# 金融数据模型案例

> **创建日期**: 2025年1月
> **来源**: 综合应用案例
> **状态**: ✅ 已完成
> **文档编号**: 10-02

---

## 📑 目录

- [金融数据模型案例](#金融数据模型案例)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 金融数据模型设计理论](#111-金融数据模型设计理论)
    - [1.1.2 Account模式理论](#112-account模式理论)
    - [1.1.3 交易处理理论](#113-交易处理理论)
    - [1.1.4 风险控制理论](#114-风险控制理论)
    - [1.1.5 审计追踪理论](#115-审计追踪理论)
    - [1.1.6 并发控制理论](#116-并发控制理论)
    - [1.1.7 复杂度分析](#117-复杂度分析)
  - [2. 业务需求](#2-业务需求)
    - [2.1 核心业务功能](#21-核心业务功能)
    - [2.2 性能要求](#22-性能要求)
  - [3. 账户模型设计](#3-账户模型设计)
    - [3.1 客户模型](#31-客户模型)
    - [3.2 账户模型（Account模式）](#32-账户模型account模式)
  - [4. 交易模型设计](#4-交易模型设计)
    - [4.1 交易表设计](#41-交易表设计)
    - [4.2 交易处理函数](#42-交易处理函数)
  - [5. 风控模型设计](#5-风控模型设计)
    - [5.1 风险规则表](#51-风险规则表)
    - [5.2 风险检测函数](#52-风险检测函数)
  - [6. PostgreSQL实现](#6-postgresql实现)
    - [6.1 完整系统实现](#61-完整系统实现)
    - [6.2 查询示例](#62-查询示例)
  - [7. 性能优化与监控 / Performance Optimization and Monitoring](#7-性能优化与监控--performance-optimization-and-monitoring)
    - [7.1 交易性能优化](#71-交易性能优化)
    - [7.2 账户查询优化](#72-账户查询优化)
    - [7.3 风控性能优化](#73-风控性能优化)
    - [7.4 监控与审计](#74-监控与审计)
  - [8. 常见问题解答 / FAQ](#8-常见问题解答--faq)
    - [Q1: 如何保证金融交易的ACID特性？](#q1-如何保证金融交易的acid特性)
    - [Q2: 如何处理并发交易？](#q2-如何处理并发交易)
    - [Q3: 如何实现交易回滚？](#q3-如何实现交易回滚)
    - [Q4: 如何优化风控检测性能？](#q4-如何优化风控检测性能)
    - [Q5: 如何实现完整的审计追踪？](#q5-如何实现完整的审计追踪)
    - [Q6: 如何保证数据一致性？](#q6-如何保证数据一致性)
  - [8. 相关资源 / Related Resources](#8-相关资源--related-resources)
    - [8.1 核心相关文档 / Core Related Documents](#81-核心相关文档--core-related-documents)
    - [8.2 理论基础 / Theoretical Foundation](#82-理论基础--theoretical-foundation)
    - [8.3 实践指南 / Practical Guides](#83-实践指南--practical-guides)
    - [8.4 应用案例 / Application Cases](#84-应用案例--application-cases)
    - [8.5 参考资源 / Reference Resources](#85-参考资源--reference-resources)

---

## 1. 概述

金融数据模型案例展示金融行业的数据建模实践。
本案例涵盖银行核心业务的数据模型设计，包括账户管理、交易处理、风险控制等。

**案例特点**:

- **高一致性要求**：金融数据必须保证强一致性
- **审计追踪**：完整的操作历史记录
- **风险控制**：实时风险监控和预警
- **合规要求**：符合金融监管要求

---

## 1.1 理论基础

### 1.1.1 金融数据模型设计理论

**金融数据模型**:

- **ACID特性**: 保证事务的原子性、一致性、隔离性、持久性
- **强一致性**: 金融数据必须保证强一致性
- **审计追踪**: 完整的操作历史记录
- **合规要求**: 符合金融监管要求

**模型设计原则**:

- **数据完整性**: 使用约束保证数据完整性
- **事务管理**: 使用事务保证数据一致性
- **审计追踪**: 记录所有操作历史
- **性能优化**: 优化高频交易性能

### 1.1.2 Account模式理论

**Account模式应用**:

- **账户模型**: 账户余额和交易历史
- **账户类型**: 储蓄、信用卡、贷款等账户类型
- **余额管理**: 账户余额的实时更新

**Account模式特点**:

- **余额一致性**: 保证账户余额一致性
- **交易历史**: 记录所有交易历史
- **账户关系**: 支持账户间关系

### 1.1.3 交易处理理论

**交易处理**:

- **交易类型**: 存款、取款、转账等交易类型
- **交易状态**: 交易状态机管理交易生命周期
- **交易对账**: 交易对账保证数据一致性

**交易处理原则**:

- **原子性**: 交易要么全部成功，要么全部失败
- **一致性**: 交易前后数据一致性
- **隔离性**: 并发交易互不干扰
- **持久性**: 交易结果持久化

### 1.1.4 风险控制理论

**风险控制**:

- **风险规则**: 风险规则定义和评估
- **实时监控**: 实时风险监控和预警
- **异常检测**: 异常交易检测和处理

**风险控制方法**:

- **规则引擎**: 基于规则的风险评估
- **机器学习**: 基于机器学习的异常检测
- **实时监控**: 实时风险监控和预警

### 1.1.5 审计追踪理论

**审计追踪**:

- **操作记录**: 记录所有数据操作
- **变更历史**: 记录数据变更历史
- **审计查询**: 支持审计查询和分析

**审计追踪要求**:

- **完整性**: 记录所有操作
- **不可篡改**: 审计记录不可篡改
- **可追溯**: 支持操作追溯

### 1.1.6 并发控制理论

**并发控制**:

- **锁机制**: 使用锁保证并发安全
- **事务隔离**: 使用事务隔离级别控制并发
- **乐观锁**: 使用乐观锁提高并发性能

**并发控制策略**:

- **悲观锁**: 使用悲观锁保证数据一致性
- **乐观锁**: 使用乐观锁提高并发性能
- **死锁处理**: 死锁检测和处理

### 1.1.7 复杂度分析

**存储复杂度**:

- **账户存储**: $O(A)$ where A is number of accounts
- **交易存储**: $O(T)$ where T is number of transactions
- **审计存储**: $O(A \times H)$ where H is average history per account

**查询复杂度**:

- **账户查询**: $O(\log A)$ with index
- **交易查询**: $O(\log T)$ with index
- **风险检测**: $O(R)$ where R is number of rules

---

## 2. 业务需求

### 2.1 核心业务功能

**业务需求清单**:

1. **客户管理**
   - 客户信息管理（KYC）
   - 客户账户管理
   - 客户关系管理

2. **账户管理**
   - 账户开户、销户
   - 账户余额管理
   - 账户类型管理（储蓄、信用卡、贷款等）

3. **交易处理**
   - 存款、取款、转账
   - 交易记录和查询
   - 交易对账

4. **贷款管理**
   - 贷款申请、审批
   - 贷款发放、还款
   - 利息计算

5. **风险控制**
   - 实时风险监控
   - 异常交易检测
   - 信用评估

### 2.2 性能要求

- **高并发**：支持10000+ TPS
- **低延迟**：交易响应时间<50ms
- **高可用**：99.99%可用性
- **数据安全**：加密存储，审计日志

---

## 3. 账户模型设计

### 3.1 客户模型

**客户表设计**:

```sql
-- 客户表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS customers (
        customer_id SERIAL PRIMARY KEY,
        customer_number VARCHAR(50) UNIQUE NOT NULL,
        -- 基本信息
        first_name VARCHAR(100) NOT NULL,
        last_name VARCHAR(100) NOT NULL,
        id_type VARCHAR(50) NOT NULL, -- 'id_card', 'passport', etc.
        id_number VARCHAR(50) NOT NULL,
        -- 联系信息
        email VARCHAR(200),
        phone VARCHAR(50),
        address TEXT,
        -- KYC信息
        kyc_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'verified', 'rejected'
        kyc_verified_at TIMESTAMPTZ,
        -- 状态
        status VARCHAR(50) DEFAULT 'active', -- 'active', 'inactive', 'closed'
        -- 时间戳
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 customers 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 customers 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customers 失败: %', SQLERRM;
END $$;

-- 客户关系表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS customer_relationships (
        relationship_id SERIAL PRIMARY KEY,
        customer_id INT NOT NULL REFERENCES customers(customer_id),
        related_customer_id INT NOT NULL REFERENCES customers(customer_id),
        relationship_type VARCHAR(50) NOT NULL, -- 'spouse', 'parent', 'guardian'
        valid_from DATE,
        valid_to DATE,
        CHECK (customer_id != related_customer_id)
    );
    RAISE NOTICE '表 customer_relationships 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 customer_relationships 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 customer_relationships 失败: %', SQLERRM;
END $$;
```

### 3.2 账户模型（Account模式）

**账户表设计**:

```sql
-- 账户类型表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS account_types (
        type_id SERIAL PRIMARY KEY,
        type_code VARCHAR(50) UNIQUE NOT NULL,
        type_name VARCHAR(200) NOT NULL,
        -- 账户特性
        allows_negative_balance BOOLEAN DEFAULT FALSE,
        interest_rate NUMERIC(5,4) DEFAULT 0,
        min_balance NUMERIC(15,2) DEFAULT 0,
        max_balance NUMERIC(15,2),
        -- 费用
        monthly_fee NUMERIC(10,2) DEFAULT 0,
        transaction_fee NUMERIC(10,2) DEFAULT 0
    );
    RAISE NOTICE '表 account_types 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 account_types 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 account_types 失败: %', SQLERRM;
END $$;

-- 账户表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS accounts (
        account_id BIGSERIAL PRIMARY KEY,
        account_number VARCHAR(50) UNIQUE NOT NULL,
        customer_id INT NOT NULL REFERENCES customers(customer_id),
        account_type_id INT NOT NULL REFERENCES account_types(type_id),
        -- 账户信息
        account_name VARCHAR(200),
        currency_code CHAR(3) DEFAULT 'CNY',
        -- 余额（冗余字段，实际余额从交易计算）
        current_balance NUMERIC(15,2) NOT NULL DEFAULT 0,
        available_balance NUMERIC(15,2) NOT NULL DEFAULT 0,
        -- 状态
        status VARCHAR(50) DEFAULT 'active', -- 'active', 'frozen', 'closed'
        -- 时间戳
        opened_date DATE DEFAULT CURRENT_DATE,
        closed_date DATE,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 accounts 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 accounts 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 accounts 失败: %', SQLERRM;
END $$;

-- 账户余额快照表（每日快照，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS account_balance_snapshot (
        snapshot_id BIGSERIAL PRIMARY KEY,
        account_id BIGINT NOT NULL REFERENCES accounts(account_id),
        snapshot_date DATE NOT NULL,
        -- 余额信息
        opening_balance NUMERIC(15,2) NOT NULL,
        closing_balance NUMERIC(15,2) NOT NULL,
        -- 交易统计
        debit_count INT DEFAULT 0,
        credit_count INT DEFAULT 0,
        total_debits NUMERIC(15,2) DEFAULT 0,
        total_credits NUMERIC(15,2) DEFAULT 0,
        UNIQUE(account_id, snapshot_date)
    );
    RAISE NOTICE '表 account_balance_snapshot 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 account_balance_snapshot 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 account_balance_snapshot 失败: %', SQLERRM;
END $$;
```

---

## 4. 交易模型设计

### 4.1 交易表设计

**交易表**:

```sql
-- 交易类型表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS transaction_types (
        type_id SERIAL PRIMARY KEY,
        type_code VARCHAR(50) UNIQUE NOT NULL,
        type_name VARCHAR(200) NOT NULL,
        direction CHAR(1) NOT NULL CHECK (direction IN ('D', 'C')), -- 'D'=Debit, 'C'=Credit
        description TEXT
    );
    RAISE NOTICE '表 transaction_types 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 transaction_types 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 transaction_types 失败: %', SQLERRM;
END $$;

-- 交易表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS transactions (
        transaction_id BIGSERIAL PRIMARY KEY,
        transaction_number VARCHAR(50) UNIQUE NOT NULL,
        -- 账户关联
        account_id BIGINT NOT NULL REFERENCES accounts(account_id),
        -- 交易信息
        transaction_type_id INT NOT NULL REFERENCES transaction_types(type_id),
        transaction_date TIMESTAMPTZ DEFAULT NOW(),
        value_date DATE NOT NULL,
        -- 金额
        amount NUMERIC(15,2) NOT NULL CHECK (amount > 0),
        currency_code CHAR(3) DEFAULT 'CNY',
        -- 余额（交易后余额）
        balance_after NUMERIC(15,2),
        -- 关联交易（如转账）
        related_transaction_id BIGINT REFERENCES transactions(transaction_id),
        related_account_id BIGINT REFERENCES accounts(account_id),
        -- 描述
        description TEXT,
        reference_number VARCHAR(100),
        -- 状态
        status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'posted', 'cancelled', 'reversed'
        posted_at TIMESTAMPTZ,
        -- 审计信息
        created_by VARCHAR(100),
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 transactions 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 transactions 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 transactions 失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_transactions_account_date ON transactions(account_id, transaction_date DESC);
    CREATE INDEX IF NOT EXISTS idx_transactions_type ON transactions(transaction_type_id, transaction_date DESC);
    CREATE INDEX IF NOT EXISTS idx_transactions_status ON transactions(status, transaction_date DESC);
    CREATE INDEX IF NOT EXISTS idx_transactions_number ON transactions(transaction_number);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

### 4.2 交易处理函数

**交易处理**:

```sql
-- 执行交易
CREATE OR REPLACE FUNCTION execute_transaction(
    p_account_id BIGINT,
    p_transaction_type_id INT,
    p_amount NUMERIC,
    p_description TEXT DEFAULT NULL,
    p_reference_number VARCHAR DEFAULT NULL,
    p_created_by VARCHAR DEFAULT NULL
)
RETURNS BIGINT AS $$
DECLARE
    v_transaction_id BIGINT;
    v_account_balance NUMERIC(15,2);
    v_direction CHAR(1);
    v_new_balance NUMERIC(15,2);
BEGIN
    -- 获取账户余额
    SELECT current_balance INTO v_account_balance
    FROM accounts
    WHERE account_id = p_account_id
      AND status = 'active';

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Account % not found or not active', p_account_id;
    END IF;

    -- 获取交易方向
    SELECT direction INTO v_direction
    FROM transaction_types
    WHERE type_id = p_transaction_type_id;

    -- 计算新余额
    IF v_direction = 'D' THEN
        v_new_balance := v_account_balance - p_amount;
    ELSE
        v_new_balance := v_account_balance + p_amount;
    END IF;

    -- 检查余额（根据账户类型）
    -- 这里简化处理，实际应该检查账户类型配置

    -- 创建交易记录
    INSERT INTO transactions (
        transaction_number, account_id, transaction_type_id,
        amount, balance_after, description, reference_number,
        status, posted_at, created_by
    ) VALUES (
        'TXN' || TO_CHAR(NOW(), 'YYYYMMDD') || LPAD(NEXTVAL('transaction_seq')::TEXT, 10, '0'),
        p_account_id, p_transaction_type_id,
        p_amount, v_new_balance, p_description, p_reference_number,
        'posted', NOW(), p_created_by
    ) RETURNING transaction_id INTO v_transaction_id;

    -- 更新账户余额
    UPDATE accounts
    SET current_balance = v_new_balance,
        available_balance = v_new_balance,
        updated_at = NOW()
    WHERE account_id = p_account_id;

    RETURN v_transaction_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. 风控模型设计

### 5.1 风险规则表

**风险规则**:

```sql
-- 风险规则表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS risk_rules (
        rule_id SERIAL PRIMARY KEY,
        rule_name VARCHAR(200) NOT NULL,
        rule_type VARCHAR(50) NOT NULL, -- 'amount_limit', 'frequency_limit', 'pattern_detection'
        -- 规则配置
        rule_config JSONB NOT NULL,
        -- 风险等级
        risk_level VARCHAR(50), -- 'low', 'medium', 'high', 'critical'
        -- 状态
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 risk_rules 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 risk_rules 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 risk_rules 失败: %', SQLERRM;
END $$;

-- 风险事件表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS risk_events (
        event_id BIGSERIAL PRIMARY KEY,
        transaction_id BIGINT REFERENCES transactions(transaction_id),
        account_id BIGINT REFERENCES accounts(account_id),
        -- 风险信息
        rule_id INT REFERENCES risk_rules(rule_id),
        risk_level VARCHAR(50) NOT NULL,
        risk_score INT CHECK (risk_score BETWEEN 0 AND 100),
        -- 事件详情
        event_description TEXT,
        event_data JSONB,
        -- 处理状态
        status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'reviewed', 'approved', 'rejected'
        reviewed_by VARCHAR(100),
        reviewed_at TIMESTAMPTZ,
        -- 时间戳
        detected_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 risk_events 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 risk_events 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 risk_events 失败: %', SQLERRM;
END $$;

-- 风险规则示例（带错误处理）
DO $$
BEGIN
    INSERT INTO risk_rules (rule_name, rule_type, rule_config, risk_level) VALUES
        ('大额交易监控', 'amount_limit', '{"max_amount": 100000, "time_window": "1 day"}'::jsonb, 'high'),
        ('频繁交易监控', 'frequency_limit', '{"max_count": 10, "time_window": "1 hour"}'::jsonb, 'medium'),
        ('异常时间交易', 'pattern_detection', '{"suspicious_hours": [0, 1, 2, 3, 4, 5]}'::jsonb, 'low')
    ON CONFLICT DO NOTHING;
    RAISE NOTICE '风险规则插入成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '插入风险规则失败: %', SQLERRM;
END $$;
```

### 5.2 风险检测函数

**风险检测**:

```sql
-- 交易风险检测
CREATE OR REPLACE FUNCTION detect_transaction_risk(
    p_transaction_id BIGINT
)
RETURNS TABLE (
    rule_id INT,
    risk_level VARCHAR,
    risk_score INT,
    description TEXT
) AS $$
DECLARE
    v_transaction RECORD;
    v_account_id BIGINT;
    v_amount NUMERIC(15,2);
    v_transaction_date TIMESTAMPTZ;
BEGIN
    -- 获取交易信息
    SELECT account_id, amount, transaction_date
    INTO v_account_id, v_amount, v_transaction_date
    FROM transactions
    WHERE transaction_id = p_transaction_id;

    -- 检测大额交易
    FOR v_rule IN
        SELECT rule_id, rule_config, risk_level
        FROM risk_rules
        WHERE rule_type = 'amount_limit' AND is_active = TRUE
    LOOP
        IF v_amount > (v_rule.rule_config->>'max_amount')::NUMERIC THEN
            RETURN QUERY SELECT
                v_rule.rule_id,
                v_rule.risk_level,
                80,
                format('交易金额 %s 超过限额 %s', v_amount, v_rule.rule_config->>'max_amount');
        END IF;
    END LOOP;

    -- 检测频繁交易
    FOR v_rule IN
        SELECT rule_id, rule_config, risk_level
        FROM risk_rules
        WHERE rule_type = 'frequency_limit' AND is_active = TRUE
    LOOP
        IF (
            SELECT COUNT(*)
            FROM transactions
            WHERE account_id = v_account_id
              AND transaction_date > NOW() - (v_rule.rule_config->>'time_window')::INTERVAL
        ) > (v_rule.rule_config->>'max_count')::INT THEN
            RETURN QUERY SELECT
                v_rule.rule_id,
                v_rule.risk_level,
                60,
                '交易频率异常';
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. PostgreSQL实现

### 6.1 完整系统实现

**表创建顺序**:

```sql
-- 1. 基础表
-- customers
-- account_types
-- transaction_types
-- risk_rules

-- 2. 业务表
-- accounts
-- transactions
-- account_balance_snapshot

-- 3. 风控表
-- risk_events

-- 4. 创建触发器
-- 交易后自动风险检测
CREATE OR REPLACE FUNCTION trigger_risk_detection()
RETURNS TRIGGER AS $$
DECLARE
    v_risk RECORD;
BEGIN
    IF NEW.status = 'posted' THEN
        FOR v_risk IN SELECT * FROM detect_transaction_risk(NEW.transaction_id)
        LOOP
            INSERT INTO risk_events (
                transaction_id, account_id, rule_id,
                risk_level, risk_score, event_description
            ) VALUES (
                NEW.transaction_id, NEW.account_id, v_risk.rule_id,
                v_risk.risk_level, v_risk.risk_score, v_risk.description
            );
        END LOOP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器（带错误处理）
DO $$
BEGIN
    DROP TRIGGER IF EXISTS trigger_transaction_risk_detection ON transactions;
    CREATE TRIGGER trigger_transaction_risk_detection
        AFTER INSERT OR UPDATE ON transactions
        FOR EACH ROW
        WHEN (NEW.status = 'posted')
        EXECUTE FUNCTION trigger_risk_detection();
    RAISE NOTICE '触发器创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建触发器失败: %', SQLERRM;
END $$;
```

### 6.2 查询示例

**账户查询**:

```sql
-- 查询账户交易历史（带性能测试）
EXPLAIN ANALYZE
SELECT
    t.transaction_number,
    t.transaction_date,
    tt.type_name,
    CASE tt.direction
        WHEN 'D' THEN -t.amount
        ELSE t.amount
    END AS amount,
    t.balance_after,
    t.description
FROM transactions t
JOIN transaction_types tt ON t.transaction_type_id = tt.type_id
WHERE t.account_id = 1
ORDER BY t.transaction_date DESC
LIMIT 100;

-- 风险事件查询（带性能测试）
EXPLAIN ANALYZE
SELECT
    re.event_id,
    re.detected_at,
    rr.rule_name,
    re.risk_level,
    re.risk_score,
    re.event_description,
    t.transaction_number,
    t.amount
FROM risk_events re
JOIN risk_rules rr ON re.rule_id = rr.rule_id
LEFT JOIN transactions t ON re.transaction_id = t.transaction_id
WHERE re.status = 'pending'
ORDER BY re.detected_at DESC;
```

---

## 7. 性能优化与监控 / Performance Optimization and Monitoring

### 7.1 交易性能优化

**索引优化**:

```sql
-- 交易表索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_transactions_account_date ON transactions(account_id, transaction_date DESC);
    CREATE INDEX IF NOT EXISTS idx_transactions_type_date ON transactions(transaction_type_id, transaction_date DESC);
    CREATE INDEX IF NOT EXISTS idx_transactions_status ON transactions(status) WHERE status = 'pending';
    CREATE INDEX IF NOT EXISTS idx_transactions_number ON transactions(transaction_number);

    -- 账户余额索引（快速查询余额）
    CREATE INDEX IF NOT EXISTS idx_accounts_customer ON accounts(customer_id, account_type_id);
    CREATE INDEX IF NOT EXISTS idx_accounts_status ON accounts(status) WHERE status = 'active';

    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

**批量处理优化**:

```sql
-- 批量交易处理函数
CREATE OR REPLACE FUNCTION batch_process_transactions(
    p_transactions JSONB
)
RETURNS TABLE(transaction_id BIGINT, status VARCHAR, error_message TEXT) AS $$
DECLARE
    v_tx JSONB;
    v_result RECORD;
BEGIN
    FOR v_tx IN SELECT * FROM jsonb_array_elements(p_transactions)
    LOOP
        BEGIN
            SELECT * INTO v_result FROM process_transaction(
                (v_tx->>'account_id')::BIGINT,
                (v_tx->>'transaction_type')::VARCHAR,
                (v_tx->>'amount')::NUMERIC,
                v_tx->>'description'
            );
            RETURN QUERY SELECT v_result.transaction_id, 'success', NULL::TEXT;
        EXCEPTION WHEN OTHERS THEN
            RETURN QUERY SELECT NULL::BIGINT, 'failed', SQLERRM;
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 账户查询优化

**物化视图优化**:

```sql
-- 账户余额汇总视图（带错误处理）
DO $$
BEGIN
    CREATE MATERIALIZED VIEW IF NOT EXISTS mv_account_balance_summary AS
    SELECT
        customer_id,
        account_type_id,
        COUNT(*) AS account_count,
        SUM(current_balance) AS total_balance,
        AVG(current_balance) AS avg_balance,
        MAX(updated_at) AS last_transaction_date
    FROM accounts
    WHERE status = 'active'
    GROUP BY customer_id, account_type_id;
    RAISE NOTICE '物化视图创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '物化视图已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 创建唯一索引（带错误处理）
DO $$
BEGIN
    CREATE UNIQUE INDEX IF NOT EXISTS mv_account_balance_summary_pkey
    ON mv_account_balance_summary(customer_id, account_type_id);
    RAISE NOTICE '唯一索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建唯一索引失败: %', SQLERRM;
END $$;

-- 定期刷新（带错误处理）
DO $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_account_balance_summary;
    RAISE NOTICE '物化视图刷新成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '刷新物化视图失败: %', SQLERRM;
END $$;

-- 测试物化视图查询性能
EXPLAIN ANALYZE
SELECT * FROM mv_account_balance_summary
WHERE customer_id = 1;
```

### 7.3 风控性能优化

**风控规则缓存**:

```sql
-- 活跃风控规则缓存（带错误处理）
DO $$
BEGIN
    CREATE MATERIALIZED VIEW IF NOT EXISTS mv_active_risk_rules AS
    SELECT
        rule_id,
        rule_name,
        rule_type,
        rule_config,
        risk_level,
        is_active
    FROM risk_rules
    WHERE is_active = TRUE;
    RAISE NOTICE '物化视图创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '物化视图已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 创建索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS mv_active_risk_rules_idx
    ON mv_active_risk_rules(rule_type, risk_level);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

-- 风控检测函数优化（使用缓存）
CREATE OR REPLACE FUNCTION check_risk_optimized(
    p_transaction_id BIGINT
)
RETURNS TABLE(rule_id INT, risk_level VARCHAR, risk_score NUMERIC) AS $$
DECLARE
    v_tx RECORD;
    v_rule RECORD;
BEGIN
    -- 获取交易信息
    SELECT * INTO v_tx FROM transactions WHERE transaction_id = p_transaction_id;

    -- 使用缓存的规则
    FOR v_rule IN SELECT * FROM mv_active_risk_rules WHERE rule_type = 'transaction'
    LOOP
        -- 执行规则检查（简化示例）
        IF evaluate_risk_condition(v_rule.rule_condition, v_tx) THEN
            RETURN QUERY SELECT v_rule.rule_id, v_rule.risk_level, 100.0::NUMERIC;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 7.4 监控与审计

**交易监控**:

```sql
-- 监控：交易处理性能（带性能测试）
EXPLAIN ANALYZE
SELECT
    tt.type_name AS transaction_type,
    t.status,
    COUNT(*) AS transaction_count,
    AVG(EXTRACT(EPOCH FROM (t.posted_at - t.created_at))) AS avg_processing_seconds,
    SUM(t.amount) AS total_amount
FROM transactions t
JOIN transaction_types tt ON t.transaction_type_id = tt.type_id
WHERE t.created_at >= NOW() - INTERVAL '1 hour'
GROUP BY tt.type_name, t.status
ORDER BY transaction_count DESC;

-- 监控：账户余额异常（带性能测试）
EXPLAIN ANALYZE
SELECT
    account_id,
    customer_id,
    account_type_id,
    current_balance,
    updated_at AS last_transaction_date,
    CASE
        WHEN current_balance < 0 THEN 'negative_balance'
        WHEN current_balance > 1000000 THEN 'high_balance'
        WHEN updated_at < NOW() - INTERVAL '1 year' THEN 'inactive'
        ELSE 'normal'
    END AS alert_type
FROM accounts
WHERE status = 'active'
  AND (
    current_balance < 0 OR
    current_balance > 1000000 OR
    updated_at < NOW() - INTERVAL '1 year'
  );

-- 审计：交易完整性检查（带性能测试）
EXPLAIN ANALYZE
SELECT
    t.transaction_id,
    t.account_id,
    t.amount,
    a.current_balance,
    (
        SELECT SUM(
            CASE tt.direction
                WHEN 'D' THEN -t2.amount
                ELSE t2.amount
            END
        ) FROM transactions t2
        JOIN transaction_types tt ON t2.transaction_type_id = tt.type_id
        WHERE t2.account_id = t.account_id
          AND t2.transaction_date <= t.transaction_date
          AND t2.status = 'posted'
    ) AS calculated_balance
FROM transactions t
JOIN accounts a ON t.account_id = a.account_id
WHERE ABS(a.balance - (
    SELECT SUM(amount) FROM transactions
    WHERE account_id = t.account_id
)) > 0.01;
```

---

## 8. 常见问题解答 / FAQ

### Q1: 如何保证金融交易的ACID特性？

**A**: ACID保证策略：

```sql
-- 使用事务保证原子性
BEGIN;
    -- 扣款
    UPDATE accounts SET balance = balance - 1000 WHERE account_id = 1;
    -- 记录交易
    INSERT INTO transactions (...) VALUES (...);
    -- 检查余额
    IF (SELECT balance FROM accounts WHERE account_id = 1) < 0 THEN
        RAISE EXCEPTION 'Insufficient balance';
    END IF;
COMMIT;

-- 使用锁保证一致性
SELECT * FROM accounts WHERE account_id = 1 FOR UPDATE;
```

### Q2: 如何处理并发交易？

**A**: 并发控制策略：

```sql
-- 使用行级锁
BEGIN;
SELECT * FROM accounts WHERE account_id = 1 FOR UPDATE;
-- 执行交易
UPDATE accounts SET balance = balance - 1000 WHERE account_id = 1;
COMMIT;

-- 使用乐观锁（版本号）
CREATE TABLE accounts (
    account_id BIGSERIAL PRIMARY KEY,
    balance NUMERIC(15,2) NOT NULL,
    version INT DEFAULT 1,
    ...
);

UPDATE accounts
SET balance = balance - 1000,
    version = version + 1
WHERE account_id = 1 AND version = 1;  -- 版本检查
```

### Q3: 如何实现交易回滚？

**A**: 回滚实现：

```sql
-- 交易回滚函数
CREATE OR REPLACE FUNCTION rollback_transaction(
    p_transaction_id BIGINT
)
RETURNS VOID AS $$
DECLARE
    v_tx RECORD;
BEGIN
    -- 获取交易信息
    SELECT * INTO v_tx FROM transactions WHERE transaction_id = p_transaction_id;

    IF v_tx.status != 'completed' THEN
        RAISE EXCEPTION 'Transaction is not completed';
    END IF;

    BEGIN
        -- 回滚账户余额
        IF v_tx.transaction_type = 'debit' THEN
            UPDATE accounts SET balance = balance + v_tx.amount WHERE account_id = v_tx.account_id;
        ELSIF v_tx.transaction_type = 'credit' THEN
            UPDATE accounts SET balance = balance - v_tx.amount WHERE account_id = v_tx.account_id;
        END IF;

        -- 更新交易状态
        UPDATE transactions
        SET status = 'rolled_back',
            rolled_back_at = NOW()
        WHERE transaction_id = p_transaction_id;

        -- 记录回滚历史
        INSERT INTO transaction_history (
            transaction_id, action, action_time, action_by
        ) VALUES (
            p_transaction_id, 'rollback', NOW(), current_user
        );
    EXCEPTION WHEN OTHERS THEN
        RAISE EXCEPTION 'Rollback failed: %', SQLERRM;
    END;
END;
$$ LANGUAGE plpgsql;
```

### Q4: 如何优化风控检测性能？

**A**: 风控优化策略：

1. **规则缓存**: 使用物化视图缓存活跃规则
2. **异步检测**: 非关键规则异步检测
3. **规则优先级**: 先检测高风险规则
4. **批量检测**: 批量处理多个交易

```sql
-- 异步风控检测
CREATE TABLE risk_check_queue (
    queue_id BIGSERIAL PRIMARY KEY,
    transaction_id BIGINT NOT NULL,
    priority INT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_risk_queue_priority ON risk_check_queue(priority DESC, created_at);
```

### Q5: 如何实现完整的审计追踪？

**A**: 审计追踪实现：

```sql
-- 审计日志表
CREATE TABLE audit_log (
    log_id BIGSERIAL PRIMARY KEY,
    table_name VARCHAR(100) NOT NULL,
    record_id BIGINT NOT NULL,
    action VARCHAR(20) NOT NULL, -- INSERT, UPDATE, DELETE
    old_data JSONB,
    new_data JSONB,
    changed_by VARCHAR(100),
    changed_at TIMESTAMPTZ DEFAULT NOW()
);

-- 通用审计触发器
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, record_id, action, new_data, changed_by)
        VALUES (TG_TABLE_NAME, NEW.account_id, 'INSERT', row_to_json(NEW)::jsonb, current_user);
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, record_id, action, old_data, new_data, changed_by)
        VALUES (TG_TABLE_NAME, NEW.account_id, 'UPDATE', row_to_json(OLD)::jsonb, row_to_json(NEW)::jsonb, current_user);
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, record_id, action, old_data, changed_by)
        VALUES (TG_TABLE_NAME, OLD.account_id, 'DELETE', row_to_json(OLD)::jsonb, current_user);
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_audit_accounts
AFTER INSERT OR UPDATE OR DELETE ON accounts
FOR EACH ROW EXECUTE FUNCTION audit_trigger();
```

### Q6: 如何保证数据一致性？

**A**: 一致性保证：

```sql
-- 使用CHECK约束
ALTER TABLE accounts
ADD CONSTRAINT chk_balance_non_negative
CHECK (balance >= 0);

-- 使用触发器验证
CREATE OR REPLACE FUNCTION validate_account_balance()
RETURNS TRIGGER AS $$
BEGIN
    -- 验证余额一致性
    IF ABS(NEW.balance - (
        SELECT COALESCE(SUM(amount), 0)
        FROM transactions
        WHERE account_id = NEW.account_id
          AND status = 'completed'
    )) > 0.01 THEN
        RAISE EXCEPTION 'Account balance inconsistency';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validate_balance
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE FUNCTION validate_account_balance();
```

---

## 8. 相关资源 / Related Resources

### 8.1 核心相关文档 / Core Related Documents

- [常见建模模式](../09-建模模式与反模式/常见建模模式.md#5-account模式) - Account模式应用
- [Party模型](../04-OLTP建模/Party模型.md) - 金融Party模型应用
- [约束设计](../08-PostgreSQL建模实践/约束设计.md) - 数据完整性约束
- [性能优化](../08-PostgreSQL建模实践/性能优化.md) - 性能优化指南
- [并发控制和锁优化](../08-PostgreSQL建模实践/性能优化.md#10-并发控制和锁优化) - 并发控制

### 8.2 理论基础 / Theoretical Foundation

- [Silverston数据模型资源手册](../02-权威资源与标准/Silverston数据模型资源手册.md) - 金融模型来源
- [约束理论](../01-数据建模理论基础/约束理论.md) - 金融约束理论

### 8.3 实践指南 / Practical Guides

- [性能优化与监控](#7-性能优化与监控--performance-optimization-and-monitoring) - 本文档的性能监控章节
- [索引策略](../08-PostgreSQL建模实践/索引策略.md) - 金融模型索引设计
- [分区策略](../08-PostgreSQL建模实践/分区策略.md) - 金融模型分区策略

### 8.4 应用案例 / Application Cases

- [电商数据模型案例](./电商数据模型案例.md) - 电商系统建模案例
- [IoT监控系统案例](./IoT监控系统案例.md) - IoT系统建模案例

### 8.5 参考资源 / Reference Resources

- [权威资源索引](../00-导航与索引/权威资源索引.md) - 权威资源列表
- [术语对照表](../00-导航与索引/术语对照表.md) - 术语对照
- [快速查找指南](../00-导航与索引/快速查找指南.md) - 快速查找工具

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
