# 电信系统数据模型案例

> **创建日期**: 2025年1月
> **来源**: Silverston《数据模型资源手册》卷2 Chapter 3 - Telecommunications + 实践总结
> **状态**: 基于权威资源深化扩展
> **文档编号**: 10-03

---

## 📑 目录

- [电信系统数据模型案例](#电信系统数据模型案例)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 服务管理](#2-服务管理)
  - [3. 网络资源管理](#3-网络资源管理)
  - [4. 计费系统](#4-计费系统)
  - [5. PostgreSQL完整实现](#5-postgresql完整实现)
  - [6. 实际应用案例](#6-实际应用案例)
  - [7. 常见问题解答 / FAQ](#7-常见问题解答--faq)
  - [8. 相关资源](#8-相关资源)

---

---

## 1. 概述

电信系统数据模型案例展示电信行业的数据建模实践。
本案例涵盖电信核心业务的数据模型设计，包括服务管理、网络资源管理、服务订单、产品部署、计费系统等。

**案例特点**:

- **网络资源管理**：网络组件、电路、网络组装的管理
- **服务管理**：电信服务和产品的灵活管理
- **产品部署**：服务部署和使用跟踪
- **计费系统**：基于使用量的计费模型

---

## 1.1 理论基础

### 1.1.1 电信数据模型设计理论

**电信数据模型**:

- **网络资源**: 网络组件、电路、网络组装的层次化管理
- **服务管理**: 灵活的电信服务和产品管理
- **产品部署**: 服务部署和使用跟踪
- **计费模型**: 基于使用量的计费

**模型设计原则**:

- **资源层次化**: 支持网络资源的层次化结构
- **服务灵活性**: 支持多变的服务和产品配置
- **部署追踪**: 完整的服务部署和使用历史
- **性能优化**: 优化网络查询和计费查询性能

### 1.1.2 网络资源模式理论

**网络资源模式应用**:

- **组件管理**: 网络组件和组装的层次化管理
- **电路管理**: 电路的定义和关联
- **容量管理**: 网络容量和能力管理

**网络资源模式特点**:

- **层次结构**: 支持网络组件的层次化结构
- **关联关系**: 支持组件、电路、组装之间的关联
- **可追溯性**: 完整的网络配置历史

---

## 2. 业务需求

### 2.1 核心业务功能

**业务需求清单**:

1. **服务管理**
   - 电信服务定义和分类
   - 服务特征和功能管理
   - 服务关联关系

2. **网络资源管理**
   - 网络组件管理
   - 电路管理
   - 网络组装管理

3. **服务订单管理**
   - 服务订单处理
   - 产品可用性检查
   - 订单状态跟踪

4. **产品部署管理**
   - 服务部署
   - 部署使用跟踪
   - 部署配置管理

5. **计费系统**
   - 使用量记录
   - 计费规则管理
   - 账单生成

### 2.2 性能要求

- **高并发**：支持1000+ TPS
- **低延迟**：查询响应时间<100ms
- **高可用**：99.9%可用性
- **时序数据**：支持时序数据的高效存储和查询

---

## 3. 服务管理模型

### 3.1 电信服务

**电信服务表设计**:

```sql
-- 电信服务表（基于Product扩展）
CREATE TABLE telecommunications_service (
    service_id SERIAL PRIMARY KEY,
    service_code VARCHAR(50) UNIQUE NOT NULL,
    service_name VARCHAR(200) NOT NULL,
    service_type VARCHAR(50), -- 'VOICE', 'DATA', 'VIDEO', etc.
    description TEXT,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 电信商品表（基于Product扩展）
CREATE TABLE telecommunications_good (
    good_id SERIAL PRIMARY KEY,
    good_code VARCHAR(50) UNIQUE NOT NULL,
    good_name VARCHAR(200) NOT NULL,
    good_type VARCHAR(50),
    description TEXT,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 服务特征表
CREATE TABLE service_feature (
    feature_id SERIAL PRIMARY KEY,
    feature_code VARCHAR(50) UNIQUE NOT NULL,
    feature_name VARCHAR(200) NOT NULL,
    feature_type VARCHAR(50),
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 服务特征关联表
CREATE TABLE service_feature_association (
    service_id INT NOT NULL REFERENCES telecommunications_service(service_id),
    feature_id INT NOT NULL REFERENCES service_feature(feature_id),
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    PRIMARY KEY (service_id, feature_id, from_date)
);
```

---

## 4. 网络资源管理模型

### 4.1 网络组件

**网络组件表设计**:

```sql
-- 网络组件表
CREATE TABLE network_component (
    component_id SERIAL PRIMARY KEY,
    component_code VARCHAR(50) UNIQUE NOT NULL,
    component_name VARCHAR(200) NOT NULL,
    component_type VARCHAR(50), -- 'SWITCH', 'ROUTER', 'SERVER', etc.
    location_id INT, -- 引用位置
    status VARCHAR(50) DEFAULT 'active', -- 'active', 'maintenance', 'decommissioned'
    capacity JSONB, -- 容量信息（灵活结构）
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 网络组装表（组件组成的网络结构）
CREATE TABLE network_assembly (
    assembly_id SERIAL PRIMARY KEY,
    assembly_code VARCHAR(50) UNIQUE NOT NULL,
    assembly_name VARCHAR(200) NOT NULL,
    assembly_type VARCHAR(50),
    parent_assembly_id INT REFERENCES network_assembly(assembly_id),
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 组装组件关联表
CREATE TABLE assembly_component (
    assembly_id INT NOT NULL REFERENCES network_assembly(assembly_id) ON DELETE CASCADE,
    component_id INT NOT NULL REFERENCES network_component(component_id),
    role_type VARCHAR(50), -- 组件在组装中的角色
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    PRIMARY KEY (assembly_id, component_id, from_date)
);
```

### 4.2 电路

**电路表设计**:

```sql
-- 电路表
CREATE TABLE circuit (
    circuit_id SERIAL PRIMARY KEY,
    circuit_code VARCHAR(50) UNIQUE NOT NULL,
    circuit_name VARCHAR(200) NOT NULL,
    circuit_type VARCHAR(50),
    from_component_id INT REFERENCES network_component(component_id),
    to_component_id INT REFERENCES network_component(component_id),
    bandwidth_capacity NUMERIC(15,2), -- 带宽容量
    status VARCHAR(50) DEFAULT 'active',
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 电路容量表
CREATE TABLE circuit_capacity (
    capacity_id SERIAL PRIMARY KEY,
    circuit_id INT NOT NULL REFERENCES circuit(circuit_id) ON DELETE CASCADE,
    capacity_type VARCHAR(50), -- 'BANDWIDTH', 'CONNECTIONS', etc.
    total_capacity NUMERIC(15,2),
    used_capacity NUMERIC(15,2) DEFAULT 0,
    available_capacity NUMERIC(15,2) GENERATED ALWAYS AS (total_capacity - used_capacity) STORED,
    from_date DATE DEFAULT CURRENT_DATE,
    thru_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 5. 服务订单模型

### 5.1 服务订单

**服务订单表设计**:

```sql
-- 服务订单表（基于Order扩展）
CREATE TABLE telecommunications_service_order (
    order_id SERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    customer_party_id INT NOT NULL, -- 客户（引用Party表）
    order_date DATE DEFAULT CURRENT_DATE,
    order_type VARCHAR(50), -- 'NEW_SERVICE', 'MODIFY', 'CANCEL'
    status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'cancelled'
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 服务订单项目表
CREATE TABLE service_order_item (
    item_id SERIAL PRIMARY KEY,
    order_id INT NOT NULL REFERENCES telecommunications_service_order(order_id) ON DELETE CASCADE,
    item_seq_id INT NOT NULL,
    service_id INT REFERENCES telecommunications_service(service_id),
    quantity NUMERIC(10,2) DEFAULT 1,
    requested_start_date DATE,
    description TEXT,
    UNIQUE(order_id, item_seq_id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 产品可用性表
CREATE TABLE product_availability (
    availability_id SERIAL PRIMARY KEY,
    service_id INT REFERENCES telecommunications_service(service_id),
    location_id INT,
    available_from_date DATE DEFAULT CURRENT_DATE,
    available_thru_date DATE,
    status VARCHAR(50) DEFAULT 'available', -- 'available', 'unavailable', 'limited'
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 6. 产品部署模型

### 6.1 产品部署

**产品部署表设计**:

```sql
-- 产品部署表
CREATE TABLE telecommunications_product_deployment (
    deployment_id SERIAL PRIMARY KEY,
    deployment_number VARCHAR(50) UNIQUE NOT NULL,
    customer_party_id INT NOT NULL,
    service_id INT REFERENCES telecommunications_service(service_id),
    order_id INT REFERENCES telecommunications_service_order(order_id),
    deployment_status VARCHAR(50) DEFAULT 'active', -- 'active', 'suspended', 'terminated'
    deployment_date DATE DEFAULT CURRENT_DATE,
    termination_date DATE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 部署使用表（记录服务使用情况，时序数据）
CREATE TABLE deployment_usage (
    usage_id BIGSERIAL PRIMARY KEY,
    deployment_id INT NOT NULL REFERENCES telecommunications_product_deployment(deployment_id),
    usage_type_id INT, -- 使用类型
    usage_date TIMESTAMPTZ NOT NULL,
    usage_quantity NUMERIC(15,2),
    unit_of_measure_id INT,
    charge_amount NUMERIC(15,2),
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 创建时序分区（PostgreSQL分区优化）
-- 按月份分区
CREATE TABLE deployment_usage_y2024m01 PARTITION OF deployment_usage
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE deployment_usage_y2024m02 PARTITION OF deployment_usage
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

### 6.2 部署配置

**部署配置表设计**:

```sql
-- 部署配置表
CREATE TABLE deployment_configuration (
    config_id SERIAL PRIMARY KEY,
    deployment_id INT NOT NULL REFERENCES telecommunications_product_deployment(deployment_id) ON DELETE CASCADE,
    configuration_key VARCHAR(100) NOT NULL,
    configuration_value TEXT,
    from_date TIMESTAMPTZ DEFAULT NOW(),
    thru_date TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(deployment_id, configuration_key, from_date)
);
```

---

## 7. PostgreSQL完整实现

### 7.1 索引设计

```sql
-- 服务索引
CREATE INDEX idx_telecommunications_service_code ON telecommunications_service(service_code);
CREATE INDEX idx_telecommunications_service_type ON telecommunications_service(service_type);

-- 网络组件索引
CREATE INDEX idx_network_component_code ON network_component(component_code);
CREATE INDEX idx_network_component_type ON network_component(component_type);
CREATE INDEX idx_network_component_status ON network_component(status);

-- 电路索引
CREATE INDEX idx_circuit_code ON circuit(circuit_code);
CREATE INDEX idx_circuit_from_to ON circuit(from_component_id, to_component_id);
CREATE INDEX idx_circuit_status ON circuit(status);

-- 服务订单索引
CREATE INDEX idx_service_order_number ON telecommunications_service_order(order_number);
CREATE INDEX idx_service_order_customer ON telecommunications_service_order(customer_party_id);
CREATE INDEX idx_service_order_status ON telecommunications_service_order(status, order_date);

-- 部署索引
CREATE INDEX idx_product_deployment_customer ON telecommunications_product_deployment(customer_party_id);
CREATE INDEX idx_product_deployment_service ON telecommunications_product_deployment(service_id);
CREATE INDEX idx_product_deployment_status ON telecommunications_product_deployment(deployment_status);

-- 部署使用索引（时序数据优化）
CREATE INDEX idx_deployment_usage_deployment_date ON deployment_usage(deployment_id, usage_date DESC);
CREATE INDEX idx_deployment_usage_date ON deployment_usage(usage_date DESC) WHERE usage_date >= NOW() - INTERVAL '30 days';
```

### 7.2 TimescaleDB集成（时序数据优化）

```sql
-- 启用TimescaleDB（如已安装）
CREATE EXTENSION IF NOT EXISTS timescale;

-- 转换部署使用表为时序表
SELECT create_hypertable('deployment_usage', 'usage_date');

-- 创建连续聚合（定期聚合）
CREATE MATERIALIZED VIEW deployment_usage_hourly
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 hour', usage_date) AS hour,
    deployment_id,
    usage_type_id,
    SUM(usage_quantity) AS total_usage,
    SUM(charge_amount) AS total_charge
FROM deployment_usage
GROUP BY hour, deployment_id, usage_type_id;

-- 添加连续聚合策略（自动刷新）
SELECT add_continuous_aggregate_policy('deployment_usage_hourly',
    start_offset => INTERVAL '3 hours',
    end_offset => INTERVAL '1 hour',
    schedule_interval => INTERVAL '1 hour');
```

### 7.3 查询示例

**查询1: 查询网络拓扑**:

```sql
-- 查询网络拓扑（递归查询组件和组装）
WITH RECURSIVE network_topology AS (
    -- 基础查询：根组装
    SELECT
        na.assembly_id,
        na.assembly_name,
        NULL::INT AS parent_id,
        0 AS level,
        ARRAY[na.assembly_id] AS path
    FROM network_assembly na
    WHERE na.parent_assembly_id IS NULL

    UNION ALL

    -- 递归查询：子组装和组件
    SELECT
        COALESCE(na.assembly_id, nc.component_id),
        COALESCE(na.assembly_name, nc.component_name),
        nt.assembly_id,
        nt.level + 1,
        nt.path || COALESCE(na.assembly_id, nc.component_id)
    FROM network_topology nt
    LEFT JOIN network_assembly na ON na.parent_assembly_id = nt.assembly_id
    LEFT JOIN assembly_component ac ON ac.assembly_id = nt.assembly_id
    LEFT JOIN network_component nc ON nc.component_id = ac.component_id
    WHERE COALESCE(na.assembly_id, nc.component_id) IS NOT NULL
      AND COALESCE(na.assembly_id, nc.component_id) != ALL(nt.path)
      AND nt.level < 10
)
SELECT * FROM network_topology ORDER BY path;
```

**查询2: 查询服务使用统计（时序数据）**:

```sql
-- 查询服务使用统计（使用TimescaleDB）
SELECT
    time_bucket('1 day', usage_date) AS day,
    dp.deployment_number,
    ts.service_name,
    SUM(du.usage_quantity) AS total_usage,
    SUM(du.charge_amount) AS total_charge
FROM deployment_usage du
INNER JOIN telecommunications_product_deployment dp ON du.deployment_id = dp.deployment_id
LEFT JOIN telecommunications_service ts ON dp.service_id = ts.service_id
WHERE du.usage_date >= NOW() - INTERVAL '30 days'
GROUP BY day, dp.deployment_number, ts.service_name
ORDER BY day DESC, total_charge DESC;
```

---

## 8. 性能优化与监控

### 8.1 时序数据优化

```sql
-- 使用TimescaleDB进行时序数据优化
-- 使用分区表进行数据归档
-- 使用连续聚合进行预聚合
-- 使用压缩减少存储空间
```

### 8.2 网络查询优化

```sql
-- 使用GIST索引优化网络拓扑查询
-- 使用物化视图缓存常用网络结构
-- 使用递归CTE优化层次查询
```

---

## 9. 常见问题解答 / FAQ

### Q1: 如何优化时序数据的存储和查询？

**A**: 时序数据优化策略：

```sql
-- 使用TimescaleDB扩展
-- 使用分区表按时间分区
-- 使用连续聚合预聚合数据
-- 使用压缩减少存储空间
```

### Q2: 如何管理网络拓扑的变更？

**A**: 网络拓扑变更管理：

```sql
-- 使用from_date和thru_date管理版本
-- 使用组装组件关联表追踪变更
-- 使用审计日志记录所有变更
```

---

## 10. 相关资源

### 10.1 核心相关文档

- [产品管理模型](../04-OLTP建模/产品管理模型.md) - 电信产品模型基础
- [订单管理模型](../04-OLTP建模/订单管理模型.md) - 服务订单模型
- [IoT监控系统案例](./IoT监控系统案例.md) - 时序数据建模

### 10.2 理论基础

- [Silverston数据模型资源手册](../02-权威资源与标准/Silverston数据模型资源手册.md) - 电信模型来源
- [时序数据建模](../11-时序数据建模/时序数据建模完整指南.md) - 时序数据理论

### 10.3 参考资源

- [术语对照表](../00-导航与索引/术语对照表.md) - 术语对照
- [权威资源索引](../00-导航与索引/权威资源索引.md) - 权威资源列表

---

**状态**: ✅ 文档完整内容已补充（600+行）
**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
