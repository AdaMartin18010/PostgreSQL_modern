# 电商数据模型案例

> **创建日期**: 2025年1月
> **来源**: 综合应用案例
> **状态**: ✅ 已完成
> **文档编号**: 10-01

---

## 📑 目录

- [电商数据模型案例](#电商数据模型案例)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 业务需求](#2-业务需求)
    - [2.1 核心业务功能](#21-核心业务功能)
    - [2.2 性能要求](#22-性能要求)
  - [3. OLTP模型设计](#3-oltp模型设计)
    - [3.1 用户模型（Party模式）](#31-用户模型party模式)
    - [3.2 商品模型（Product模式）](#32-商品模型product模式)
    - [3.3 订单模型（Order模式）](#33-订单模型order模式)
    - [3.4 支付模型](#34-支付模型)
  - [4. OLAP模型设计](#4-olap模型设计)
    - [4.1 维度表设计](#41-维度表设计)
    - [4.2 事实表设计](#42-事实表设计)
  - [5. 实施步骤](#5-实施步骤)
    - [5.1 阶段一：OLTP系统建设](#51-阶段一oltp系统建设)
    - [5.2 阶段二：OLAP系统建设](#52-阶段二olap系统建设)
    - [5.3 阶段三：数据同步](#53-阶段三数据同步)
  - [6. PostgreSQL实现](#6-postgresql实现)
    - [6.1 完整表结构](#61-完整表结构)
    - [6.2 查询示例](#62-查询示例)
  - [7. 性能优化与监控 / Performance Optimization and Monitoring](#7-性能优化与监控--performance-optimization-and-monitoring)
    - [7.1 OLTP性能优化](#71-oltp性能优化)
    - [7.2 OLAP性能优化](#72-olap性能优化)
    - [7.3 数据同步优化](#73-数据同步优化)
    - [7.4 监控与诊断](#74-监控与诊断)
  - [8. 常见问题解答 / FAQ](#8-常见问题解答--faq)
    - [Q1: OLTP和OLAP数据如何同步？](#q1-oltp和olap数据如何同步)
    - [Q2: 如何处理历史数据变更（SCD）？](#q2-如何处理历史数据变更scd)
    - [Q3: 如何优化大促期间的性能？](#q3-如何优化大促期间的性能)
    - [Q4: 如何优化OLAP查询性能？](#q4-如何优化olap查询性能)
    - [Q5: 如何处理数据一致性问题？](#q5-如何处理数据一致性问题)
    - [Q6: 如何监控数据质量？](#q6-如何监控数据质量)
  - [8. 相关资源 / Related Resources](#8-相关资源--related-resources)
    - [8.1 核心相关文档 / Core Related Documents](#81-核心相关文档--core-related-documents)
    - [8.2 理论基础 / Theoretical Foundation](#82-理论基础--theoretical-foundation)
    - [8.3 实践指南 / Practical Guides](#83-实践指南--practical-guides)
    - [8.4 应用案例 / Application Cases](#84-应用案例--application-cases)
    - [8.5 参考资源 / Reference Resources](#85-参考资源--reference-resources)

---

## 1. 概述

电商数据模型案例展示如何将数据建模理论应用于实际业务场景。
本案例涵盖从OLTP事务处理到OLAP数据分析的完整数据模型设计。

**案例特点**:

- **完整业务场景**：涵盖用户、商品、订单、支付等核心业务
- **双模型设计**：OLTP和OLAP模型并存
- **实际应用**：基于真实电商业务需求
- **PostgreSQL实现**：完整的SQL实现

---

## 2. 业务需求

### 2.1 核心业务功能

**业务需求清单**:

1. **用户管理**
   - 用户注册、登录、个人信息管理
   - 用户地址管理
   - 用户等级和积分管理

2. **商品管理**
   - 商品信息管理
   - 商品分类和属性
   - 库存管理
   - 价格管理

3. **订单管理**
   - 订单创建、支付、发货、完成
   - 订单状态跟踪
   - 退换货处理

4. **支付管理**
   - 多种支付方式支持
   - 支付记录和退款

5. **数据分析**
   - 销售统计分析
   - 用户行为分析
   - 商品销售排行
   - 库存分析

### 2.2 性能要求

- **OLTP**：支持1000+并发用户，响应时间<100ms
- **OLAP**：支持复杂分析查询，数据量10亿+
- **数据保留**：订单数据保留5年

---

## 3. OLTP模型设计

### 3.1 用户模型（Party模式）

**用户表设计**:

```sql
-- 用户表（Person）
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(200) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(50),
    -- 用户等级
    user_level VARCHAR(50) DEFAULT 'regular', -- 'regular', 'vip', 'premium'
    points INT DEFAULT 0,
    -- 状态
    status VARCHAR(50) DEFAULT 'active', -- 'active', 'inactive', 'banned'
    -- 时间戳
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);

-- 用户地址表
CREATE TABLE user_addresses (
    address_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES users(user_id),
    address_type VARCHAR(50), -- 'home', 'work', 'billing', 'shipping'
    recipient_name VARCHAR(100),
    phone VARCHAR(50),
    province VARCHAR(50),
    city VARCHAR(50),
    district VARCHAR(50),
    street VARCHAR(200),
    postal_code VARCHAR(20),
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 3.2 商品模型（Product模式）

**商品表设计**:

```sql
-- 商品分类表
CREATE TABLE product_categories (
    category_id SERIAL PRIMARY KEY,
    parent_category_id INT REFERENCES product_categories(category_id),
    category_code VARCHAR(50) UNIQUE NOT NULL,
    category_name VARCHAR(200) NOT NULL,
    display_order INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE
);

-- 商品表
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_code VARCHAR(50) UNIQUE NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_id INT REFERENCES product_categories(category_id),
    -- 商品信息
    description TEXT,
    brand VARCHAR(100),
    -- 价格
    list_price NUMERIC(10,2) NOT NULL,
    sale_price NUMERIC(10,2),
    -- 库存
    stock_quantity INT DEFAULT 0,
    -- 状态
    status VARCHAR(50) DEFAULT 'active', -- 'active', 'inactive', 'out_of_stock'
    -- 时间戳
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 商品属性表
CREATE TABLE product_attributes (
    attribute_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES products(product_id),
    attribute_name VARCHAR(100) NOT NULL,
    attribute_value TEXT NOT NULL,
    UNIQUE(product_id, attribute_name)
);
```

### 3.3 订单模型（Order模式）

**订单表设计**:

```sql
-- 订单表
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    user_id INT NOT NULL REFERENCES users(user_id),
    -- 订单信息
    order_date TIMESTAMPTZ DEFAULT NOW(),
    -- 地址信息
    shipping_address_id INT REFERENCES user_addresses(address_id),
    billing_address_id INT REFERENCES user_addresses(address_id),
    -- 金额信息
    subtotal NUMERIC(10,2) NOT NULL DEFAULT 0,
    shipping_fee NUMERIC(10,2) DEFAULT 0,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    tax_amount NUMERIC(10,2) DEFAULT 0,
    total_amount NUMERIC(10,2) GENERATED ALWAYS AS (
        subtotal + shipping_fee - discount_amount + tax_amount
    ) STORED,
    -- 订单状态
    order_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'paid', 'shipped', 'completed', 'cancelled'
    -- 时间戳
    paid_at TIMESTAMPTZ,
    shipped_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 订单明细表
CREATE TABLE order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    product_id INT NOT NULL REFERENCES products(product_id),
    -- 订单行信息
    quantity INT NOT NULL CHECK (quantity > 0),
    unit_price NUMERIC(10,2) NOT NULL,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    line_total NUMERIC(10,2) GENERATED ALWAYS AS (
        quantity * unit_price - discount_amount
    ) STORED,
    -- 状态
    item_status VARCHAR(50) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 订单状态历史表
CREATE TABLE order_status_history (
    history_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    from_status VARCHAR(50),
    to_status VARCHAR(50) NOT NULL,
    changed_at TIMESTAMPTZ DEFAULT NOW(),
    changed_by VARCHAR(100),
    notes TEXT
);
```

### 3.4 支付模型

**支付表设计**:

```sql
-- 支付表
CREATE TABLE payments (
    payment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    payment_number VARCHAR(50) UNIQUE NOT NULL,
    -- 支付信息
    payment_method VARCHAR(50) NOT NULL, -- 'credit_card', 'debit_card', 'alipay', 'wechat'
    payment_amount NUMERIC(10,2) NOT NULL,
    -- 支付状态
    payment_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed', 'refunded'
    -- 交易信息
    transaction_id VARCHAR(100),
    payment_date TIMESTAMPTZ,
    -- 支付详情
    payment_details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 4. OLAP模型设计

### 4.1 维度表设计

**维度表**:

```sql
-- 日期维度表
CREATE TABLE dim_date (
    date_id INT PRIMARY KEY,
    date_value DATE NOT NULL UNIQUE,
    year INT NOT NULL,
    quarter INT NOT NULL,
    month INT NOT NULL,
    week INT NOT NULL,
    day_of_month INT NOT NULL,
    day_of_week INT NOT NULL,
    is_weekend BOOLEAN,
    is_holiday BOOLEAN,
    holiday_name VARCHAR(100)
);

-- 商品维度表（SCD Type 2）
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_code VARCHAR(50) NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_id INT,
    category_name VARCHAR(200),
    brand VARCHAR(100),
    -- SCD字段
    valid_from TIMESTAMPTZ NOT NULL,
    valid_to TIMESTAMPTZ,
    is_current BOOLEAN DEFAULT TRUE
);

-- 用户维度表（SCD Type 1）
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    user_id INT NOT NULL UNIQUE,
    username VARCHAR(50),
    email VARCHAR(200),
    user_level VARCHAR(50),
    registration_date DATE
);
```

### 4.2 事实表设计

**销售事实表**:

```sql
-- 销售事实表（事务事实表）
CREATE TABLE fact_sales (
    sale_id BIGSERIAL PRIMARY KEY,
    -- 维度键
    date_id INT NOT NULL REFERENCES dim_date(date_id),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    -- 退化维度
    order_id BIGINT NOT NULL,
    order_number VARCHAR(50),
    -- 度量值
    quantity INT NOT NULL,
    unit_price NUMERIC(10,2) NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2),
    profit NUMERIC(10,2) GENERATED ALWAYS AS (amount - COALESCE(cost, 0)) STORED,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    shipping_fee NUMERIC(10,2) DEFAULT 0,
    -- 时间戳
    sale_timestamp TIMESTAMPTZ NOT NULL
);

-- 创建索引
CREATE INDEX idx_fact_sales_date ON fact_sales(date_id);
CREATE INDEX idx_fact_sales_product ON fact_sales(product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);
CREATE INDEX idx_fact_sales_timestamp ON fact_sales(sale_timestamp DESC);
```

---

## 5. 实施步骤

### 5.1 阶段一：OLTP系统建设

1. **创建基础表结构**
   - 用户表、商品表、订单表
   - 建立外键关系
   - 创建必要索引

2. **实现业务逻辑**
   - 订单创建流程
   - 支付处理流程
   - 库存管理

3. **性能优化**
   - 索引优化
   - 查询优化
   - 连接池配置

### 5.2 阶段二：OLAP系统建设

1. **维度表构建**
   - 日期维度表（一次性生成）
   - 商品维度表（SCD Type 2）
   - 用户维度表（SCD Type 1）

2. **ETL流程设计**
   - 数据抽取（从OLTP）
   - 数据转换（维度键关联）
   - 数据加载（到事实表）

3. **数据仓库优化**
   - 分区策略
   - 索引策略
   - 物化视图

### 5.3 阶段三：数据同步

**ETL流程实现**:

```sql
-- ETL函数：同步订单数据到事实表
CREATE OR REPLACE FUNCTION etl_sync_sales()
RETURNS INT AS $$
DECLARE
    v_count INT := 0;
BEGIN
    INSERT INTO fact_sales (
        date_id, product_key, customer_key,
        order_id, order_number,
        quantity, unit_price, amount, discount_amount, shipping_fee,
        sale_timestamp
    )
    SELECT
        dd.date_id,
        dp.product_key,
        dc.customer_key,
        o.order_id,
        o.order_number,
        oi.quantity,
        oi.unit_price,
        oi.line_total,
        oi.discount_amount,
        o.shipping_fee,
        o.order_date
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN dim_date dd ON DATE(o.order_date) = dd.date_value
    JOIN dim_product dp ON oi.product_id = dp.product_id AND dp.is_current = TRUE
    JOIN dim_customer dc ON o.user_id = dc.user_id
    WHERE o.order_status = 'completed'
      AND o.order_date > (
          SELECT MAX(sale_timestamp) FROM fact_sales
      )
    ON CONFLICT DO NOTHING;

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. PostgreSQL实现

### 6.1 完整表结构

**创建所有表**:

```sql
-- 执行顺序：先创建基础表，再创建外键
-- 1. 用户表
-- 2. 商品表
-- 3. 订单表
-- 4. 支付表
-- 5. 维度表
-- 6. 事实表

-- 创建分区（订单表按月分区）
ALTER TABLE orders PARTITION BY RANGE (order_date);

CREATE TABLE orders_2025_01 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- 事实表按月分区
ALTER TABLE fact_sales PARTITION BY RANGE (sale_timestamp);

CREATE TABLE fact_sales_2025_01 PARTITION OF fact_sales
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### 6.2 查询示例

**OLTP查询**:

```sql
-- 查询用户订单
SELECT
    o.order_number,
    o.order_date,
    o.total_amount,
    o.order_status,
    COUNT(oi.item_id) AS item_count
FROM orders o
LEFT JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.user_id = 1
GROUP BY o.order_id, o.order_number, o.order_date, o.total_amount, o.order_status
ORDER BY o.order_date DESC;
```

**OLAP查询**:

```sql
-- 销售分析查询
SELECT
    dd.year,
    dd.month,
    dp.category_name,
    SUM(fs.quantity) AS total_quantity,
    SUM(fs.amount) AS total_amount,
    SUM(fs.profit) AS total_profit,
    COUNT(DISTINCT fs.order_id) AS order_count
FROM fact_sales fs
JOIN dim_date dd ON fs.date_id = dd.date_id
JOIN dim_product dp ON fs.product_key = dp.product_key
WHERE dd.year = 2025
GROUP BY dd.year, dd.month, dp.category_name
ORDER BY dd.year, dd.month, total_amount DESC;
```

---

## 7. 性能优化与监控 / Performance Optimization and Monitoring

### 7.1 OLTP性能优化

**索引优化**:

```sql
-- 订单表索引
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date DESC);
CREATE INDEX idx_orders_status_date ON orders(order_status, order_date DESC);
CREATE INDEX idx_orders_number ON orders(order_number);

-- 订单项索引
CREATE INDEX idx_order_items_order ON order_items(order_id);
CREATE INDEX idx_order_items_product ON order_items(product_id);

-- 商品索引
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_status ON products(status) WHERE status = 'active';
CREATE INDEX idx_products_name ON products USING GIN(to_tsvector('english', product_name));

-- 用户索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_phone ON users(phone);
```

**查询优化**:

```sql
-- ✅ 优化：使用覆盖索引
CREATE INDEX idx_orders_covering ON orders(order_id, user_id, order_status, order_date, total_amount);

-- 查询仅需扫描索引
SELECT order_id, order_status, total_amount
FROM orders
WHERE user_id = 123 AND order_date >= '2025-01-01';
```

### 7.2 OLAP性能优化

**物化视图优化**:

```sql
-- 创建预聚合物化视图
CREATE MATERIALIZED VIEW mv_sales_summary_monthly AS
SELECT
    dd.year,
    dd.month,
    dp.category_name,
    COUNT(*) AS order_count,
    SUM(fs.quantity) AS total_quantity,
    SUM(fs.amount) AS total_amount,
    AVG(fs.amount) AS avg_amount
FROM fact_sales fs
JOIN dim_date dd ON fs.date_id = dd.date_id
JOIN dim_product dp ON fs.product_key = dp.product_key
GROUP BY dd.year, dd.month, dp.category_name;

CREATE UNIQUE INDEX ON mv_sales_summary_monthly(year, month, category_name);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary_monthly;
```

**分区优化**:

```sql
-- 事实表按时间分区
CREATE TABLE fact_sales (
    ...
) PARTITION BY RANGE (sale_timestamp);

-- 按月分区
CREATE TABLE fact_sales_2025_01 PARTITION OF fact_sales
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
CREATE TABLE fact_sales_2025_02 PARTITION OF fact_sales
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

### 7.3 数据同步优化

**增量同步优化**:

```sql
-- 优化：使用CDC（Change Data Capture）
CREATE TABLE cdc_orders_log (
    log_id BIGSERIAL PRIMARY KEY,
    table_name VARCHAR(100) NOT NULL,
    operation CHAR(1) NOT NULL, -- 'I', 'U', 'D'
    order_id BIGINT NOT NULL,
    change_data JSONB NOT NULL,
    change_time TIMESTAMPTZ DEFAULT NOW()
);

-- 创建触发器记录变更
CREATE OR REPLACE FUNCTION log_order_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO cdc_orders_log (table_name, operation, order_id, change_data)
        VALUES ('orders', 'I', NEW.order_id, row_to_json(NEW)::jsonb);
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO cdc_orders_log (table_name, operation, order_id, change_data)
        VALUES ('orders', 'U', NEW.order_id, row_to_json(NEW)::jsonb);
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO cdc_orders_log (table_name, operation, order_id, change_data)
        VALUES ('orders', 'D', OLD.order_id, row_to_json(OLD)::jsonb);
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_log_order_changes
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION log_order_changes();
```

### 7.4 监控与诊断

**性能监控查询**:

```sql
-- 监控：订单处理性能
SELECT
    order_status,
    COUNT(*) AS order_count,
    AVG(EXTRACT(EPOCH FROM (updated_at - created_at))) AS avg_processing_seconds,
    MAX(EXTRACT(EPOCH FROM (updated_at - created_at))) AS max_processing_seconds
FROM orders
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY order_status;

-- 监控：OLAP查询性能
SELECT
    LEFT(query, 100) AS query_preview,
    calls,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%fact_sales%'
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 监控：数据同步延迟
SELECT
    'fact_sales' AS table_name,
    MAX(sale_timestamp) AS latest_data_time,
    NOW() - MAX(sale_timestamp) AS sync_delay
FROM fact_sales;
```

---

## 8. 常见问题解答 / FAQ

### Q1: OLTP和OLAP数据如何同步？

**A**: 同步策略：

1. **实时同步**: 使用触发器或CDC（适合小数据量）
2. **批量同步**: 定时ETL任务（适合大数据量）
3. **流式同步**: 使用Kafka + Debezium（适合实时性要求高）

**推荐方案**:

```sql
-- 方案1：定时批量同步（推荐）
SELECT sync_orders_to_fact_sales();  -- 每小时执行

-- 方案2：实时同步（小数据量）
-- 使用触发器在订单完成时立即同步
```

### Q2: 如何处理历史数据变更（SCD）？

**A**: SCD处理策略：

```sql
-- SCD Type 2：保留历史版本
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_name VARCHAR(100),
    price NUMERIC(10,2),
    valid_from TIMESTAMPTZ NOT NULL,
    valid_to TIMESTAMPTZ,
    is_current BOOLEAN DEFAULT TRUE
);

-- 更新商品信息时创建新版本
CREATE OR REPLACE FUNCTION update_product_scd2(
    p_product_id INT,
    p_new_data JSONB
)
RETURNS VOID AS $$
BEGIN
    -- 关闭旧版本
    UPDATE dim_product
    SET valid_to = NOW(),
        is_current = FALSE
    WHERE product_id = p_product_id AND is_current = TRUE;

    -- 创建新版本
    INSERT INTO dim_product (product_id, product_name, category_name, price, valid_from)
    VALUES (
        p_product_id,
        p_new_data->>'product_name',
        p_new_data->>'category_name',
        (p_new_data->>'price')::NUMERIC,
        NOW()
    );
END;
$$ LANGUAGE plpgsql;
```

### Q3: 如何优化大促期间的性能？

**A**: 大促优化策略：

1. **读写分离**: 使用主从复制分离读写
2. **缓存**: 使用Redis缓存热点数据
3. **限流**: 限制并发请求数
4. **预热**: 提前预热数据库连接和缓存

```sql
-- 预热：提前加载热点数据到缓存
SELECT * FROM products WHERE status = 'active' AND is_hot = TRUE;

-- 限流：使用连接池限制并发
-- max_connections = 200
-- 使用pgBouncer连接池
```

### Q4: 如何优化OLAP查询性能？

**A**: OLAP优化策略：

1. **物化视图**: 预计算聚合结果
2. **分区**: 按时间分区事实表
3. **索引**: 为维度键创建索引
4. **列存**: 使用列存表存储事实表

```sql
-- 使用列存表（Citus）
CREATE TABLE fact_sales_columnar (
    LIKE fact_sales INCLUDING ALL
) USING columnar;

-- 迁移数据到列存表
INSERT INTO fact_sales_columnar SELECT * FROM fact_sales;
```

### Q5: 如何处理数据一致性问题？

**A**: 一致性保证：

```sql
-- 使用事务保证一致性
BEGIN;
    INSERT INTO orders (...) VALUES (...);
    INSERT INTO order_items (...) VALUES (...);
    UPDATE products SET stock = stock - 1 WHERE product_id = ...;
COMMIT;

-- 使用分布式事务（Citus）
BEGIN;
    INSERT INTO orders (...) VALUES (...);
    INSERT INTO order_items (...) VALUES (...);
COMMIT;  -- Citus自动处理分布式事务
```

### Q6: 如何监控数据质量？

**A**: 数据质量监控：

```sql
-- 数据完整性检查
SELECT
    'orders' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE order_status IS NULL) AS null_status_count,
    COUNT(*) FILTER (WHERE total_amount < 0) AS invalid_amount_count
FROM orders;

-- 数据一致性检查
SELECT
    o.order_id,
    o.total_amount AS order_amount,
    SUM(oi.line_total) AS calculated_amount,
    o.total_amount - SUM(oi.line_total) AS difference
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id, o.total_amount
HAVING ABS(o.total_amount - SUM(oi.line_total)) > 0.01;
```

---

## 8. 相关资源 / Related Resources

### 8.1 核心相关文档 / Core Related Documents

- [Party模型](../04-OLTP建模/Party模型.md) - Party模式应用
- [订单管理模型](../04-OLTP建模/订单管理模型.md) - 订单模型设计
- [范式化设计](../04-OLTP建模/范式化设计.md) - OLTP范式化设计
- [维度建模基础](../05-OLAP建模/维度建模基础.md) - 维度建模理论
- [事实表技术](../05-OLAP建模/事实表技术.md) - 事实表设计
- [性能优化](../08-PostgreSQL建模实践/性能优化.md) - 性能优化指南

### 8.2 理论基础 / Theoretical Foundation

- [Silverston数据模型资源手册](../02-权威资源与标准/Silverston数据模型资源手册.md) - Party和订单模型来源
- [Kimball维度建模](../02-权威资源与标准/Kimball维度建模.md) - 维度建模理论来源

### 8.3 实践指南 / Practical Guides

- [性能优化与监控](#7-性能优化与监控--performance-optimization-and-monitoring) - 本文档的性能监控章节
- [索引策略](../08-PostgreSQL建模实践/索引策略.md) - 电商模型索引设计
- [分区策略](../08-PostgreSQL建模实践/分区策略.md) - 电商模型分区策略

### 8.4 应用案例 / Application Cases

- [金融数据模型案例](./金融数据模型案例.md) - 金融系统建模案例
- [IoT监控系统案例](./IoT监控系统案例.md) - IoT系统建模案例

### 8.5 参考资源 / Reference Resources

- [权威资源索引](../00-导航与索引/权威资源索引.md) - 权威资源列表
- [术语对照表](../00-导航与索引/术语对照表.md) - 术语对照
- [快速查找指南](../00-导航与索引/快速查找指南.md) - 快速查找工具

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
