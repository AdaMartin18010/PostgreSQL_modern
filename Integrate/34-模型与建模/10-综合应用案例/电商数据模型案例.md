# 电商数据模型案例

> **创建日期**: 2025年1月
> **来源**: 综合应用案例
> **状态**: ✅ 已完成
> **文档编号**: 10-01

---

## 📑 目录

- [电商数据模型案例](#电商数据模型案例)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 电商数据模型设计理论](#111-电商数据模型设计理论)
    - [1.1.2 Party模式理论](#112-party模式理论)
    - [1.1.3 Order模式理论](#113-order模式理论)
    - [1.1.4 Product模式理论](#114-product模式理论)
    - [1.1.5 维度建模理论](#115-维度建模理论)
    - [1.1.6 数据同步理论](#116-数据同步理论)
    - [1.1.7 复杂度分析](#117-复杂度分析)
  - [2. 业务需求](#2-业务需求)
    - [2.1 核心业务功能](#21-核心业务功能)
    - [2.2 性能要求](#22-性能要求)
  - [3. OLTP模型设计](#3-oltp模型设计)
    - [3.1 用户模型（Party模式）](#31-用户模型party模式)
    - [3.2 商品模型（Product模式）](#32-商品模型product模式)
    - [3.3 订单模型（Order模式）](#33-订单模型order模式)
    - [3.4 支付模型](#34-支付模型)
  - [4. OLAP模型设计](#4-olap模型设计)
    - [4.1 维度表设计](#41-维度表设计)
    - [4.2 事实表设计](#42-事实表设计)
  - [5. 实施步骤](#5-实施步骤)
    - [5.1 阶段一：OLTP系统建设](#51-阶段一oltp系统建设)
    - [5.2 阶段二：OLAP系统建设](#52-阶段二olap系统建设)
    - [5.3 阶段三：数据同步](#53-阶段三数据同步)
  - [6. PostgreSQL实现](#6-postgresql实现)
    - [6.1 完整表结构](#61-完整表结构)
    - [6.2 查询示例](#62-查询示例)
  - [7. 性能优化与监控 / Performance Optimization and Monitoring](#7-性能优化与监控--performance-optimization-and-monitoring)
    - [7.1 OLTP性能优化](#71-oltp性能优化)
    - [7.2 OLAP性能优化](#72-olap性能优化)
    - [7.3 数据同步优化](#73-数据同步优化)
    - [7.4 监控与诊断](#74-监控与诊断)
  - [8. 常见问题解答 / FAQ](#8-常见问题解答--faq)
    - [Q1: OLTP和OLAP数据如何同步？](#q1-oltp和olap数据如何同步)
    - [Q2: 如何处理历史数据变更（SCD）？](#q2-如何处理历史数据变更scd)
    - [Q3: 如何优化大促期间的性能？](#q3-如何优化大促期间的性能)
    - [Q4: 如何优化OLAP查询性能？](#q4-如何优化olap查询性能)
    - [Q5: 如何处理数据一致性问题？](#q5-如何处理数据一致性问题)
    - [Q6: 如何监控数据质量？](#q6-如何监控数据质量)
  - [8. 相关资源 / Related Resources](#8-相关资源--related-resources)
    - [8.1 核心相关文档 / Core Related Documents](#81-核心相关文档--core-related-documents)
    - [8.2 理论基础 / Theoretical Foundation](#82-理论基础--theoretical-foundation)
    - [8.3 实践指南 / Practical Guides](#83-实践指南--practical-guides)
    - [8.4 应用案例 / Application Cases](#84-应用案例--application-cases)
    - [8.5 参考资源 / Reference Resources](#85-参考资源--reference-resources)

---

## 1. 概述

电商数据模型案例展示如何将数据建模理论应用于实际业务场景。
本案例涵盖从OLTP事务处理到OLAP数据分析的完整数据模型设计。

**案例特点**:

- **完整业务场景**：涵盖用户、商品、订单、支付等核心业务
- **双模型设计**：OLTP和OLAP模型并存
- **实际应用**：基于真实电商业务需求
- **PostgreSQL实现**：完整的SQL实现

---

## 1.1 理论基础

### 1.1.1 电商数据模型设计理论

**电商数据模型**:

- **OLTP模型**: 支持事务处理，保证数据一致性
- **OLAP模型**: 支持数据分析，优化查询性能
- **双模型架构**: OLTP和OLAP分离，通过ETL同步

**模型选择原则**:

- **OLTP**: 范式化设计（3NF/BCNF），保证数据一致性
- **OLAP**: 维度建模（星型模式），优化查询性能
- **数据同步**: ETL/ELT管道，保证数据一致性

### 1.1.2 Party模式理论

**Party模式应用**:

- **用户模型**: 使用Party模式统一管理人员和组织
- **角色管理**: 通过Party Role管理用户角色（买家、卖家、管理员）
- **关系管理**: 通过Party Relationship管理用户关系

**Party模式优势**:

- **统一管理**: 统一管理用户信息
- **角色灵活**: 支持多角色和角色变更
- **关系管理**: 支持复杂的用户关系

### 1.1.3 Order模式理论

**Order模式应用**:

- **订单头-订单行**: 订单头+订单行的聚合模式
- **订单状态**: 订单状态机管理订单生命周期
- **订单历史**: 订单历史追踪保证可追溯性

**Order模式特点**:

- **事务边界**: 订单头+订单行在同一事务中
- **状态管理**: 订单状态机保证状态转换正确性
- **历史追踪**: 订单历史记录保证可追溯性

### 1.1.4 Product模式理论

**Product模式应用**:

- **商品分类**: 商品分类层次结构
- **商品属性**: 灵活的商品属性管理
- **价格管理**: 商品价格和促销管理

**Product模式特点**:

- **分类层次**: 支持多级分类
- **属性灵活**: 支持动态商品属性
- **版本管理**: 支持商品版本管理

### 1.1.5 维度建模理论

**OLAP维度建模**:

- **星型模式**: 事实表+维度表的星型模式
- **维度表**: 时间、商品、用户、订单等维度
- **事实表**: 销售事实表，记录销售交易

**维度建模优势**:

- **查询性能**: 星型模式优化查询性能
- **易用性**: 业务用户易于理解
- **扩展性**: 易于添加新的维度

### 1.1.6 数据同步理论

**ETL/ELT管道**:

- **抽取（Extract）**: 从OLTP系统抽取数据
- **转换（Transform）**: 数据清洗和转换
- **加载（Load）**: 加载到OLAP系统

**数据同步策略**:

- **增量同步**: 只同步变更数据
- **全量同步**: 定期全量同步
- **实时同步**: 实时数据同步（CDC）

### 1.1.7 复杂度分析

**存储复杂度**:

- **OLTP存储**: $O(U + P + O)$ where U is users, P is products, O is orders
- **OLAP存储**: $O(F)$ where F is number of facts
- **同步存储**: $O(S)$ where S is sync overhead

**查询复杂度**:

- **OLTP查询**: $O(\log N)$ with index
- **OLAP查询**: $O(\log F)$ with index and aggregation
- **同步查询**: $O(\log S)$ with index

---

## 2. 业务需求

### 2.1 核心业务功能

**业务需求清单**:

1. **用户管理**
   - 用户注册、登录、个人信息管理
   - 用户地址管理
   - 用户等级和积分管理

2. **商品管理**
   - 商品信息管理
   - 商品分类和属性
   - 库存管理
   - 价格管理

3. **订单管理**
   - 订单创建、支付、发货、完成
   - 订单状态跟踪
   - 退换货处理

4. **支付管理**
   - 多种支付方式支持
   - 支付记录和退款

5. **数据分析**
   - 销售统计分析
   - 用户行为分析
   - 商品销售排行
   - 库存分析

### 2.2 性能要求

- **OLTP**：支持1000+并发用户，响应时间<100ms
- **OLAP**：支持复杂分析查询，数据量10亿+
- **数据保留**：订单数据保留5年

---

## 3. OLTP模型设计

### 3.1 用户模型（Party模式）

**用户表设计**:

```sql
-- 用户表（Person）- 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS users (
        user_id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(200) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        first_name VARCHAR(100),
        last_name VARCHAR(100),
        phone VARCHAR(50),
        -- 用户等级
        user_level VARCHAR(50) DEFAULT 'regular', -- 'regular', 'vip', 'premium'
        points INT DEFAULT 0,
        -- 状态
        status VARCHAR(50) DEFAULT 'active', -- 'active', 'inactive', 'banned'
        -- 时间戳
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW(),
        last_login_at TIMESTAMPTZ
    );
    RAISE NOTICE '表 users 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 users 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 users 失败: %', SQLERRM;
END $$;

-- 用户地址表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS user_addresses (
        address_id SERIAL PRIMARY KEY,
        user_id INT NOT NULL REFERENCES users(user_id),
        address_type VARCHAR(50), -- 'home', 'work', 'billing', 'shipping'
        recipient_name VARCHAR(100),
        phone VARCHAR(50),
        province VARCHAR(50),
        city VARCHAR(50),
        district VARCHAR(50),
        street VARCHAR(200),
        postal_code VARCHAR(20),
        is_default BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 user_addresses 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 user_addresses 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 user_addresses 失败: %', SQLERRM;
END $$;
```

### 3.2 商品模型（Product模式）

**商品表设计**:

```sql
-- 商品分类表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS product_categories (
        category_id SERIAL PRIMARY KEY,
        parent_category_id INT REFERENCES product_categories(category_id),
        category_code VARCHAR(50) UNIQUE NOT NULL,
        category_name VARCHAR(200) NOT NULL,
        display_order INT DEFAULT 0,
        is_active BOOLEAN DEFAULT TRUE
    );
    RAISE NOTICE '表 product_categories 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 product_categories 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 product_categories 失败: %', SQLERRM;
END $$;

-- 商品表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS products (
        product_id SERIAL PRIMARY KEY,
        product_code VARCHAR(50) UNIQUE NOT NULL,
        product_name VARCHAR(200) NOT NULL,
        category_id INT REFERENCES product_categories(category_id),
        -- 商品信息
        description TEXT,
        brand VARCHAR(100),
        -- 价格
        list_price NUMERIC(10,2) NOT NULL,
        sale_price NUMERIC(10,2),
        -- 库存
        stock_quantity INT DEFAULT 0,
        -- 状态
        status VARCHAR(50) DEFAULT 'active', -- 'active', 'inactive', 'out_of_stock'
        -- 时间戳
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 products 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 products 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 products 失败: %', SQLERRM;
END $$;

-- 商品属性表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS product_attributes (
        attribute_id SERIAL PRIMARY KEY,
        product_id INT NOT NULL REFERENCES products(product_id),
        attribute_name VARCHAR(100) NOT NULL,
        attribute_value TEXT NOT NULL,
        UNIQUE(product_id, attribute_name)
    );
    RAISE NOTICE '表 product_attributes 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 product_attributes 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 product_attributes 失败: %', SQLERRM;
END $$;
```

### 3.3 订单模型（Order模式）

**订单表设计**:

```sql
-- 订单表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS orders (
        order_id BIGSERIAL PRIMARY KEY,
        order_number VARCHAR(50) UNIQUE NOT NULL,
        user_id INT NOT NULL REFERENCES users(user_id),
        -- 订单信息
        order_date TIMESTAMPTZ DEFAULT NOW(),
        -- 地址信息
        shipping_address_id INT REFERENCES user_addresses(address_id),
        billing_address_id INT REFERENCES user_addresses(address_id),
        -- 金额信息
        subtotal NUMERIC(10,2) NOT NULL DEFAULT 0,
        shipping_fee NUMERIC(10,2) DEFAULT 0,
        discount_amount NUMERIC(10,2) DEFAULT 0,
        tax_amount NUMERIC(10,2) DEFAULT 0,
        total_amount NUMERIC(10,2) GENERATED ALWAYS AS (
            subtotal + shipping_fee - discount_amount + tax_amount
        ) STORED,
        -- 订单状态
        order_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'paid', 'shipped', 'completed', 'cancelled'
        -- 时间戳
        paid_at TIMESTAMPTZ,
        shipped_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        cancelled_at TIMESTAMPTZ,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 orders 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 orders 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 orders 失败: %', SQLERRM;
END $$;

-- 订单明细表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS order_items (
        item_id BIGSERIAL PRIMARY KEY,
        order_id BIGINT NOT NULL REFERENCES orders(order_id),
        product_id INT NOT NULL REFERENCES products(product_id),
        -- 订单行信息
        quantity INT NOT NULL CHECK (quantity > 0),
        unit_price NUMERIC(10,2) NOT NULL,
        discount_amount NUMERIC(10,2) DEFAULT 0,
        line_total NUMERIC(10,2) GENERATED ALWAYS AS (
            quantity * unit_price - discount_amount
        ) STORED,
        -- 状态
        item_status VARCHAR(50) DEFAULT 'pending',
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 order_items 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 order_items 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 order_items 失败: %', SQLERRM;
END $$;

-- 订单状态历史表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS order_status_history (
        history_id BIGSERIAL PRIMARY KEY,
        order_id BIGINT NOT NULL REFERENCES orders(order_id),
        from_status VARCHAR(50),
        to_status VARCHAR(50) NOT NULL,
        changed_at TIMESTAMPTZ DEFAULT NOW(),
        changed_by VARCHAR(100),
        notes TEXT
    );
    RAISE NOTICE '表 order_status_history 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 order_status_history 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 order_status_history 失败: %', SQLERRM;
END $$;
```

### 3.4 支付模型

**支付表设计**:

```sql
-- 支付表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS payments (
        payment_id BIGSERIAL PRIMARY KEY,
        order_id BIGINT NOT NULL REFERENCES orders(order_id),
        payment_number VARCHAR(50) UNIQUE NOT NULL,
        -- 支付信息
        payment_method VARCHAR(50) NOT NULL, -- 'credit_card', 'debit_card', 'alipay', 'wechat'
        payment_amount NUMERIC(10,2) NOT NULL,
        -- 支付状态
        payment_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed', 'refunded'
        -- 交易信息
        transaction_id VARCHAR(100),
        payment_date TIMESTAMPTZ,
        -- 支付详情
        payment_details JSONB,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 payments 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 payments 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 payments 失败: %', SQLERRM;
END $$;
```

---

## 4. OLAP模型设计

### 4.1 维度表设计

**维度表**:

```sql
-- 日期维度表 - 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS dim_date (
        date_id INT PRIMARY KEY,
        date_value DATE NOT NULL UNIQUE,
        year INT NOT NULL,
        quarter INT NOT NULL,
        month INT NOT NULL,
        week INT NOT NULL,
        day_of_month INT NOT NULL,
        day_of_week INT NOT NULL,
        is_weekend BOOLEAN,
        is_holiday BOOLEAN,
        holiday_name VARCHAR(100)
    );
    RAISE NOTICE '表 dim_date 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 dim_date 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 dim_date 失败: %', SQLERRM;
END $$;

-- 商品维度表（SCD Type 2）- 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS dim_product (
        product_key SERIAL PRIMARY KEY,
        product_id INT NOT NULL,
        product_code VARCHAR(50) NOT NULL,
        product_name VARCHAR(200) NOT NULL,
        category_id INT,
        category_name VARCHAR(200),
        brand VARCHAR(100),
        -- SCD字段
        valid_from TIMESTAMPTZ NOT NULL,
        valid_to TIMESTAMPTZ,
        is_current BOOLEAN DEFAULT TRUE
    );
    RAISE NOTICE '表 dim_product 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 dim_product 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 dim_product 失败: %', SQLERRM;
END $$;

-- 用户维度表（SCD Type 1）- 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS dim_customer (
        customer_key SERIAL PRIMARY KEY,
        user_id INT NOT NULL UNIQUE,
        username VARCHAR(50),
        email VARCHAR(200),
        user_level VARCHAR(50),
        registration_date DATE
    );
    RAISE NOTICE '表 dim_customer 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 dim_customer 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 dim_customer 失败: %', SQLERRM;
END $$;
```

### 4.2 事实表设计

**销售事实表**:

```sql
-- 销售事实表（事务事实表）- 带错误处理
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS fact_sales (
        sale_id BIGSERIAL PRIMARY KEY,
        -- 维度键
        date_id INT NOT NULL REFERENCES dim_date(date_id),
        product_key INT NOT NULL REFERENCES dim_product(product_key),
        customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
        -- 退化维度
        order_id BIGINT NOT NULL,
        order_number VARCHAR(50),
        -- 度量值
        quantity INT NOT NULL,
        unit_price NUMERIC(10,2) NOT NULL,
        amount NUMERIC(10,2) NOT NULL,
        cost NUMERIC(10,2),
        profit NUMERIC(10,2) GENERATED ALWAYS AS (amount - COALESCE(cost, 0)) STORED,
        discount_amount NUMERIC(10,2) DEFAULT 0,
        shipping_fee NUMERIC(10,2) DEFAULT 0,
        -- 时间戳
        sale_timestamp TIMESTAMPTZ NOT NULL
    );
    RAISE NOTICE '表 fact_sales 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 fact_sales 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 fact_sales 失败: %', SQLERRM;
END $$;

-- 创建索引 - 带错误处理
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_fact_sales_date ON fact_sales(date_id);
    CREATE INDEX IF NOT EXISTS idx_fact_sales_product ON fact_sales(product_key);
    CREATE INDEX IF NOT EXISTS idx_fact_sales_customer ON fact_sales(customer_key);
    CREATE INDEX IF NOT EXISTS idx_fact_sales_timestamp ON fact_sales(sale_timestamp DESC);
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

---

## 5. 实施步骤

### 5.1 阶段一：OLTP系统建设

1. **创建基础表结构**
   - 用户表、商品表、订单表
   - 建立外键关系
   - 创建必要索引

2. **实现业务逻辑**
   - 订单创建流程
   - 支付处理流程
   - 库存管理

3. **性能优化**
   - 索引优化
   - 查询优化
   - 连接池配置

### 5.2 阶段二：OLAP系统建设

1. **维度表构建**
   - 日期维度表（一次性生成）
   - 商品维度表（SCD Type 2）
   - 用户维度表（SCD Type 1）

2. **ETL流程设计**
   - 数据抽取（从OLTP）
   - 数据转换（维度键关联）
   - 数据加载（到事实表）

3. **数据仓库优化**
   - 分区策略
   - 索引策略
   - 物化视图

### 5.3 阶段三：数据同步

**ETL流程实现**:

```sql
-- ETL函数：同步订单数据到事实表（带错误处理）
CREATE OR REPLACE FUNCTION etl_sync_sales()
RETURNS INT AS $$
DECLARE
    v_count INT := 0;
    v_max_timestamp TIMESTAMPTZ;
BEGIN
    -- 获取最大时间戳（带错误处理）
    BEGIN
        SELECT MAX(sale_timestamp) INTO v_max_timestamp FROM fact_sales;
        IF v_max_timestamp IS NULL THEN
            v_max_timestamp := '1970-01-01'::TIMESTAMPTZ;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '获取最大时间戳失败: %', SQLERRM;
            v_max_timestamp := '1970-01-01'::TIMESTAMPTZ;
    END;

    -- 插入数据（带错误处理）
    BEGIN
        INSERT INTO fact_sales (
            date_id, product_key, customer_key,
            order_id, order_number,
            quantity, unit_price, amount, discount_amount, shipping_fee,
            sale_timestamp
        )
        SELECT
            dd.date_id,
            dp.product_key,
            dc.customer_key,
            o.order_id,
            o.order_number,
            oi.quantity,
            oi.unit_price,
            oi.line_total,
            oi.discount_amount,
            o.shipping_fee,
            o.order_date
        FROM orders o
        JOIN order_items oi ON o.order_id = oi.order_id
        JOIN dim_date dd ON DATE(o.order_date) = dd.date_value
        JOIN dim_product dp ON oi.product_id = dp.product_id AND dp.is_current = TRUE
        JOIN dim_customer dc ON o.user_id = dc.user_id
        WHERE o.order_status = 'completed'
          AND o.order_date > v_max_timestamp
        ON CONFLICT DO NOTHING;

        GET DIAGNOSTICS v_count = ROW_COUNT;
        RAISE NOTICE '同步了 % 条记录', v_count;
    EXCEPTION
        WHEN foreign_key_violation THEN
            RAISE EXCEPTION '外键约束违反，请检查维度表数据';
        WHEN OTHERS THEN
            RAISE EXCEPTION 'ETL同步失败: %', SQLERRM;
    END;

    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- 性能测试：ETL查询性能
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    dd.date_id,
    dp.product_key,
    dc.customer_key,
    o.order_id,
    o.order_number,
    oi.quantity,
    oi.unit_price,
    oi.line_total
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN dim_date dd ON DATE(o.order_date) = dd.date_value
JOIN dim_product dp ON oi.product_id = dp.product_id AND dp.is_current = TRUE
JOIN dim_customer dc ON o.user_id = dc.user_id
WHERE o.order_status = 'completed'
LIMIT 100;
```

---

## 6. PostgreSQL实现

### 6.1 完整表结构

**创建所有表**:

```sql
-- 执行顺序：先创建基础表，再创建外键
-- 1. 用户表
-- 2. 商品表
-- 3. 订单表
-- 4. 支付表
-- 5. 维度表
-- 6. 事实表

-- 创建分区（订单表按月分区）
ALTER TABLE orders PARTITION BY RANGE (order_date);

CREATE TABLE orders_2025_01 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- 事实表按月分区
ALTER TABLE fact_sales PARTITION BY RANGE (sale_timestamp);

CREATE TABLE fact_sales_2025_01 PARTITION OF fact_sales
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### 6.2 查询示例

**OLTP查询**:

```sql
-- 查询用户订单（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    o.order_number,
    o.order_date,
    o.total_amount,
    o.order_status,
    COUNT(oi.item_id) AS item_count
FROM orders o
LEFT JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.user_id = 1
GROUP BY o.order_id, o.order_number, o.order_date, o.total_amount, o.order_status
ORDER BY o.order_date DESC;
```

**OLAP查询**:

```sql
-- 销售分析查询（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    dd.year,
    dd.month,
    dp.category_name,
    SUM(fs.quantity) AS total_quantity,
    SUM(fs.amount) AS total_amount,
    SUM(fs.profit) AS total_profit,
    COUNT(DISTINCT fs.order_id) AS order_count
FROM fact_sales fs
JOIN dim_date dd ON fs.date_id = dd.date_id
JOIN dim_product dp ON fs.product_key = dp.product_key
WHERE dd.year = 2025
GROUP BY dd.year, dd.month, dp.category_name
ORDER BY dd.year, dd.month, total_amount DESC;
```

---

## 7. 性能优化与监控 / Performance Optimization and Monitoring

### 7.1 OLTP性能优化

**索引优化**:

```sql
-- 订单表索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_orders_user_date ON orders(user_id, order_date DESC);
    CREATE INDEX IF NOT EXISTS idx_orders_status_date ON orders(order_status, order_date DESC);
    CREATE INDEX IF NOT EXISTS idx_orders_number ON orders(order_number);

    -- 订单项索引
    CREATE INDEX IF NOT EXISTS idx_order_items_order ON order_items(order_id);
    CREATE INDEX IF NOT EXISTS idx_order_items_product ON order_items(product_id);

    -- 商品索引
    CREATE INDEX IF NOT EXISTS idx_products_category ON products(category_id);
    CREATE INDEX IF NOT EXISTS idx_products_status ON products(status) WHERE status = 'active';
    CREATE INDEX IF NOT EXISTS idx_products_name ON products USING GIN(to_tsvector('english', product_name));

    -- 用户索引
    CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    CREATE INDEX IF NOT EXISTS idx_users_phone ON users(phone);

    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;

**查询优化**:

```sql
-- ✅ 优化：使用覆盖索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_orders_covering ON orders(order_id, user_id, order_status, order_date, total_amount);
    RAISE NOTICE '覆盖索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建覆盖索引失败: %', SQLERRM;
END $$;

-- 查询仅需扫描索引（带性能测试）
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT order_id, order_status, total_amount
FROM orders
WHERE user_id = 123 AND order_date >= '2025-01-01';
```

### 7.2 OLAP性能优化

**物化视图优化**:

```sql
-- 创建预聚合物化视图（带错误处理）
DO $$
BEGIN
    CREATE MATERIALIZED VIEW IF NOT EXISTS mv_sales_summary_monthly AS
    SELECT
        dd.year,
        dd.month,
        dp.category_name,
        COUNT(*) AS order_count,
        SUM(fs.quantity) AS total_quantity,
        SUM(fs.amount) AS total_amount,
        AVG(fs.amount) AS avg_amount
    FROM fact_sales fs
    JOIN dim_date dd ON fs.date_id = dd.date_id
    JOIN dim_product dp ON fs.product_key = dp.product_key
    GROUP BY dd.year, dd.month, dp.category_name;
    RAISE NOTICE '物化视图创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '物化视图已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建物化视图失败: %', SQLERRM;
END $$;

-- 创建唯一索引（带错误处理）
DO $$
BEGIN
    CREATE UNIQUE INDEX IF NOT EXISTS mv_sales_summary_monthly_pkey
    ON mv_sales_summary_monthly(year, month, category_name);
    RAISE NOTICE '唯一索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建唯一索引失败: %', SQLERRM;
END $$;

-- 定期刷新（带错误处理）
DO $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_sales_summary_monthly;
    RAISE NOTICE '物化视图刷新成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '刷新物化视图失败: %', SQLERRM;
END $$;

-- 测试物化视图查询性能
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM mv_sales_summary_monthly
WHERE year = 2025
ORDER BY total_amount DESC;
```

**分区优化**:

```sql
-- 事实表按时间分区（带错误处理）
-- 注意：如果表已存在，需要先删除后重建或使用ALTER TABLE
DO $$
BEGIN
    -- 如果表不存在，创建分区表
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'fact_sales') THEN
        CREATE TABLE fact_sales (
            sale_id BIGSERIAL,
            date_id INT NOT NULL,
            product_key INT NOT NULL,
            customer_key INT NOT NULL,
            order_id BIGINT NOT NULL,
            order_number VARCHAR(50),
            quantity INT NOT NULL,
            unit_price NUMERIC(10,2) NOT NULL,
            amount NUMERIC(10,2) NOT NULL,
            cost NUMERIC(10,2),
            profit NUMERIC(10,2),
            discount_amount NUMERIC(10,2) DEFAULT 0,
            shipping_fee NUMERIC(10,2) DEFAULT 0,
            sale_timestamp TIMESTAMPTZ NOT NULL,
            PRIMARY KEY (sale_id, sale_timestamp)
        ) PARTITION BY RANGE (sale_timestamp);
        RAISE NOTICE '分区表 fact_sales 创建成功';
    ELSE
        RAISE NOTICE '表 fact_sales 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建分区表失败: %', SQLERRM;
END $$;

-- 按月分区（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS fact_sales_2025_01 PARTITION OF fact_sales
        FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
    CREATE TABLE IF NOT EXISTS fact_sales_2025_02 PARTITION OF fact_sales
        FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
    RAISE NOTICE '分区创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建分区失败: %', SQLERRM;
END $$;
```

### 7.3 数据同步优化

**增量同步优化**:

```sql
-- 优化：使用CDC（Change Data Capture）
CREATE TABLE cdc_orders_log (
    log_id BIGSERIAL PRIMARY KEY,
    table_name VARCHAR(100) NOT NULL,
    operation CHAR(1) NOT NULL, -- 'I', 'U', 'D'
    order_id BIGINT NOT NULL,
    change_data JSONB NOT NULL,
    change_time TIMESTAMPTZ DEFAULT NOW()
);

-- 创建触发器记录变更
CREATE OR REPLACE FUNCTION log_order_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO cdc_orders_log (table_name, operation, order_id, change_data)
        VALUES ('orders', 'I', NEW.order_id, row_to_json(NEW)::jsonb);
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO cdc_orders_log (table_name, operation, order_id, change_data)
        VALUES ('orders', 'U', NEW.order_id, row_to_json(NEW)::jsonb);
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO cdc_orders_log (table_name, operation, order_id, change_data)
        VALUES ('orders', 'D', OLD.order_id, row_to_json(OLD)::jsonb);
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_log_order_changes
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION log_order_changes();
```

### 7.4 监控与诊断

**性能监控查询**:

```sql
-- 监控：订单处理性能
SELECT
    order_status,
    COUNT(*) AS order_count,
    AVG(EXTRACT(EPOCH FROM (updated_at - created_at))) AS avg_processing_seconds,
    MAX(EXTRACT(EPOCH FROM (updated_at - created_at))) AS max_processing_seconds
FROM orders
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY order_status;

-- 监控：OLAP查询性能
SELECT
    LEFT(query, 100) AS query_preview,
    calls,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%fact_sales%'
ORDER BY mean_exec_time DESC
LIMIT 10;

-- 监控：数据同步延迟
SELECT
    'fact_sales' AS table_name,
    MAX(sale_timestamp) AS latest_data_time,
    NOW() - MAX(sale_timestamp) AS sync_delay
FROM fact_sales;
```

---

## 8. 常见问题解答 / FAQ

### Q1: OLTP和OLAP数据如何同步？

**A**: 同步策略：

1. **实时同步**: 使用触发器或CDC（适合小数据量）
2. **批量同步**: 定时ETL任务（适合大数据量）
3. **流式同步**: 使用Kafka + Debezium（适合实时性要求高）

**推荐方案**:

```sql
-- 方案1：定时批量同步（推荐）
SELECT sync_orders_to_fact_sales();  -- 每小时执行

-- 方案2：实时同步（小数据量）
-- 使用触发器在订单完成时立即同步
```

### Q2: 如何处理历史数据变更（SCD）？

**A**: SCD处理策略：

```sql
-- SCD Type 2：保留历史版本
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_name VARCHAR(100),
    price NUMERIC(10,2),
    valid_from TIMESTAMPTZ NOT NULL,
    valid_to TIMESTAMPTZ,
    is_current BOOLEAN DEFAULT TRUE
);

-- 更新商品信息时创建新版本
CREATE OR REPLACE FUNCTION update_product_scd2(
    p_product_id INT,
    p_new_data JSONB
)
RETURNS VOID AS $$
BEGIN
    -- 关闭旧版本
    UPDATE dim_product
    SET valid_to = NOW(),
        is_current = FALSE
    WHERE product_id = p_product_id AND is_current = TRUE;

    -- 创建新版本
    INSERT INTO dim_product (product_id, product_name, category_name, price, valid_from)
    VALUES (
        p_product_id,
        p_new_data->>'product_name',
        p_new_data->>'category_name',
        (p_new_data->>'price')::NUMERIC,
        NOW()
    );
END;
$$ LANGUAGE plpgsql;
```

### Q3: 如何优化大促期间的性能？

**A**: 大促优化策略：

1. **读写分离**: 使用主从复制分离读写
2. **缓存**: 使用Redis缓存热点数据
3. **限流**: 限制并发请求数
4. **预热**: 提前预热数据库连接和缓存

```sql
-- 预热：提前加载热点数据到缓存
SELECT * FROM products WHERE status = 'active' AND is_hot = TRUE;

-- 限流：使用连接池限制并发
-- max_connections = 200
-- 使用pgBouncer连接池
```

### Q4: 如何优化OLAP查询性能？

**A**: OLAP优化策略：

1. **物化视图**: 预计算聚合结果
2. **分区**: 按时间分区事实表
3. **索引**: 为维度键创建索引
4. **列存**: 使用列存表存储事实表

```sql
-- 使用列存表（Citus）
CREATE TABLE fact_sales_columnar (
    LIKE fact_sales INCLUDING ALL
) USING columnar;

-- 迁移数据到列存表
INSERT INTO fact_sales_columnar SELECT * FROM fact_sales;
```

### Q5: 如何处理数据一致性问题？

**A**: 一致性保证：

```sql
-- 使用事务保证一致性
BEGIN;
    INSERT INTO orders (...) VALUES (...);
    INSERT INTO order_items (...) VALUES (...);
    UPDATE products SET stock = stock - 1 WHERE product_id = ...;
COMMIT;

-- 使用分布式事务（Citus）
BEGIN;
    INSERT INTO orders (...) VALUES (...);
    INSERT INTO order_items (...) VALUES (...);
COMMIT;  -- Citus自动处理分布式事务
```

### Q6: 如何监控数据质量？

**A**: 数据质量监控：

```sql
-- 数据完整性检查
SELECT
    'orders' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE order_status IS NULL) AS null_status_count,
    COUNT(*) FILTER (WHERE total_amount < 0) AS invalid_amount_count
FROM orders;

-- 数据一致性检查
SELECT
    o.order_id,
    o.total_amount AS order_amount,
    SUM(oi.line_total) AS calculated_amount,
    o.total_amount - SUM(oi.line_total) AS difference
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY o.order_id, o.total_amount
HAVING ABS(o.total_amount - SUM(oi.line_total)) > 0.01;
```

---

## 8. 相关资源 / Related Resources

### 8.1 核心相关文档 / Core Related Documents

- [Party模型](../04-OLTP建模/Party模型.md) - Party模式应用
- [订单管理模型](../04-OLTP建模/订单管理模型.md) - 订单模型设计
- [范式化设计](../04-OLTP建模/范式化设计.md) - OLTP范式化设计
- [维度建模基础](../05-OLAP建模/维度建模基础.md) - 维度建模理论
- [事实表技术](../05-OLAP建模/事实表技术.md) - 事实表设计
- [性能优化](../08-PostgreSQL建模实践/性能优化.md) - 性能优化指南

### 8.2 理论基础 / Theoretical Foundation

- [Silverston数据模型资源手册](../02-权威资源与标准/Silverston数据模型资源手册.md) - Party和订单模型来源
- [Kimball维度建模](../02-权威资源与标准/Kimball维度建模.md) - 维度建模理论来源

### 8.3 实践指南 / Practical Guides

- [性能优化与监控](#7-性能优化与监控--performance-optimization-and-monitoring) - 本文档的性能监控章节
- [索引策略](../08-PostgreSQL建模实践/索引策略.md) - 电商模型索引设计
- [分区策略](../08-PostgreSQL建模实践/分区策略.md) - 电商模型分区策略

### 8.4 应用案例 / Application Cases

- [金融数据模型案例](./金融数据模型案例.md) - 金融系统建模案例
- [IoT监控系统案例](./IoT监控系统案例.md) - IoT系统建模案例

### 8.5 参考资源 / Reference Resources

- [权威资源索引](../00-导航与索引/权威资源索引.md) - 权威资源列表
- [术语对照表](../00-导航与索引/术语对照表.md) - 术语对照
- [快速查找指南](../00-导航与索引/快速查找指南.md) - 快速查找工具

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
