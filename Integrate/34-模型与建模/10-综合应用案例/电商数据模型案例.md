# 电商数据模型案例

> **创建日期**: 2025年1月
> **来源**: 综合应用案例
> **状态**: 待完善
> **文档编号**: 10-01

---

## 📑 目录

- [电商数据模型案例](#电商数据模型案例)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 业务需求](#2-业务需求)
    - [2.1 核心业务功能](#21-核心业务功能)
    - [2.2 性能要求](#22-性能要求)
  - [3. OLTP模型设计](#3-oltp模型设计)
    - [3.1 用户模型（Party模式）](#31-用户模型party模式)
    - [3.2 商品模型（Product模式）](#32-商品模型product模式)
    - [3.3 订单模型（Order模式）](#33-订单模型order模式)
    - [3.4 支付模型](#34-支付模型)
  - [4. OLAP模型设计](#4-olap模型设计)
    - [4.1 维度表设计](#41-维度表设计)
    - [4.2 事实表设计](#42-事实表设计)
  - [5. 实施步骤](#5-实施步骤)
    - [5.1 阶段一：OLTP系统建设](#51-阶段一oltp系统建设)
    - [5.2 阶段二：OLAP系统建设](#52-阶段二olap系统建设)
    - [5.3 阶段三：数据同步](#53-阶段三数据同步)
  - [6. PostgreSQL实现](#6-postgresql实现)
    - [6.1 完整表结构](#61-完整表结构)
    - [6.2 查询示例](#62-查询示例)
  - [7. 相关资源](#7-相关资源)

---

## 1. 概述

电商数据模型案例展示如何将数据建模理论应用于实际业务场景。
本案例涵盖从OLTP事务处理到OLAP数据分析的完整数据模型设计。

**案例特点**:

- **完整业务场景**：涵盖用户、商品、订单、支付等核心业务
- **双模型设计**：OLTP和OLAP模型并存
- **实际应用**：基于真实电商业务需求
- **PostgreSQL实现**：完整的SQL实现

---

## 2. 业务需求

### 2.1 核心业务功能

**业务需求清单**:

1. **用户管理**
   - 用户注册、登录、个人信息管理
   - 用户地址管理
   - 用户等级和积分管理

2. **商品管理**
   - 商品信息管理
   - 商品分类和属性
   - 库存管理
   - 价格管理

3. **订单管理**
   - 订单创建、支付、发货、完成
   - 订单状态跟踪
   - 退换货处理

4. **支付管理**
   - 多种支付方式支持
   - 支付记录和退款

5. **数据分析**
   - 销售统计分析
   - 用户行为分析
   - 商品销售排行
   - 库存分析

### 2.2 性能要求

- **OLTP**：支持1000+并发用户，响应时间<100ms
- **OLAP**：支持复杂分析查询，数据量10亿+
- **数据保留**：订单数据保留5年

---

## 3. OLTP模型设计

### 3.1 用户模型（Party模式）

**用户表设计**:

```sql
-- 用户表（Person）
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(200) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(50),
    -- 用户等级
    user_level VARCHAR(50) DEFAULT 'regular', -- 'regular', 'vip', 'premium'
    points INT DEFAULT 0,
    -- 状态
    status VARCHAR(50) DEFAULT 'active', -- 'active', 'inactive', 'banned'
    -- 时间戳
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);

-- 用户地址表
CREATE TABLE user_addresses (
    address_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES users(user_id),
    address_type VARCHAR(50), -- 'home', 'work', 'billing', 'shipping'
    recipient_name VARCHAR(100),
    phone VARCHAR(50),
    province VARCHAR(50),
    city VARCHAR(50),
    district VARCHAR(50),
    street VARCHAR(200),
    postal_code VARCHAR(20),
    is_default BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 3.2 商品模型（Product模式）

**商品表设计**:

```sql
-- 商品分类表
CREATE TABLE product_categories (
    category_id SERIAL PRIMARY KEY,
    parent_category_id INT REFERENCES product_categories(category_id),
    category_code VARCHAR(50) UNIQUE NOT NULL,
    category_name VARCHAR(200) NOT NULL,
    display_order INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE
);

-- 商品表
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_code VARCHAR(50) UNIQUE NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_id INT REFERENCES product_categories(category_id),
    -- 商品信息
    description TEXT,
    brand VARCHAR(100),
    -- 价格
    list_price NUMERIC(10,2) NOT NULL,
    sale_price NUMERIC(10,2),
    -- 库存
    stock_quantity INT DEFAULT 0,
    -- 状态
    status VARCHAR(50) DEFAULT 'active', -- 'active', 'inactive', 'out_of_stock'
    -- 时间戳
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 商品属性表
CREATE TABLE product_attributes (
    attribute_id SERIAL PRIMARY KEY,
    product_id INT NOT NULL REFERENCES products(product_id),
    attribute_name VARCHAR(100) NOT NULL,
    attribute_value TEXT NOT NULL,
    UNIQUE(product_id, attribute_name)
);
```

### 3.3 订单模型（Order模式）

**订单表设计**:

```sql
-- 订单表
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    order_number VARCHAR(50) UNIQUE NOT NULL,
    user_id INT NOT NULL REFERENCES users(user_id),
    -- 订单信息
    order_date TIMESTAMPTZ DEFAULT NOW(),
    -- 地址信息
    shipping_address_id INT REFERENCES user_addresses(address_id),
    billing_address_id INT REFERENCES user_addresses(address_id),
    -- 金额信息
    subtotal NUMERIC(10,2) NOT NULL DEFAULT 0,
    shipping_fee NUMERIC(10,2) DEFAULT 0,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    tax_amount NUMERIC(10,2) DEFAULT 0,
    total_amount NUMERIC(10,2) GENERATED ALWAYS AS (
        subtotal + shipping_fee - discount_amount + tax_amount
    ) STORED,
    -- 订单状态
    order_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'paid', 'shipped', 'completed', 'cancelled'
    -- 时间戳
    paid_at TIMESTAMPTZ,
    shipped_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    cancelled_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 订单明细表
CREATE TABLE order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    product_id INT NOT NULL REFERENCES products(product_id),
    -- 订单行信息
    quantity INT NOT NULL CHECK (quantity > 0),
    unit_price NUMERIC(10,2) NOT NULL,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    line_total NUMERIC(10,2) GENERATED ALWAYS AS (
        quantity * unit_price - discount_amount
    ) STORED,
    -- 状态
    item_status VARCHAR(50) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 订单状态历史表
CREATE TABLE order_status_history (
    history_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    from_status VARCHAR(50),
    to_status VARCHAR(50) NOT NULL,
    changed_at TIMESTAMPTZ DEFAULT NOW(),
    changed_by VARCHAR(100),
    notes TEXT
);
```

### 3.4 支付模型

**支付表设计**:

```sql
-- 支付表
CREATE TABLE payments (
    payment_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id),
    payment_number VARCHAR(50) UNIQUE NOT NULL,
    -- 支付信息
    payment_method VARCHAR(50) NOT NULL, -- 'credit_card', 'debit_card', 'alipay', 'wechat'
    payment_amount NUMERIC(10,2) NOT NULL,
    -- 支付状态
    payment_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed', 'refunded'
    -- 交易信息
    transaction_id VARCHAR(100),
    payment_date TIMESTAMPTZ,
    -- 支付详情
    payment_details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 4. OLAP模型设计

### 4.1 维度表设计

**维度表**:

```sql
-- 日期维度表
CREATE TABLE dim_date (
    date_id INT PRIMARY KEY,
    date_value DATE NOT NULL UNIQUE,
    year INT NOT NULL,
    quarter INT NOT NULL,
    month INT NOT NULL,
    week INT NOT NULL,
    day_of_month INT NOT NULL,
    day_of_week INT NOT NULL,
    is_weekend BOOLEAN,
    is_holiday BOOLEAN,
    holiday_name VARCHAR(100)
);

-- 商品维度表（SCD Type 2）
CREATE TABLE dim_product (
    product_key SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    product_code VARCHAR(50) NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    category_id INT,
    category_name VARCHAR(200),
    brand VARCHAR(100),
    -- SCD字段
    valid_from TIMESTAMPTZ NOT NULL,
    valid_to TIMESTAMPTZ,
    is_current BOOLEAN DEFAULT TRUE
);

-- 用户维度表（SCD Type 1）
CREATE TABLE dim_customer (
    customer_key SERIAL PRIMARY KEY,
    user_id INT NOT NULL UNIQUE,
    username VARCHAR(50),
    email VARCHAR(200),
    user_level VARCHAR(50),
    registration_date DATE
);
```

### 4.2 事实表设计

**销售事实表**:

```sql
-- 销售事实表（事务事实表）
CREATE TABLE fact_sales (
    sale_id BIGSERIAL PRIMARY KEY,
    -- 维度键
    date_id INT NOT NULL REFERENCES dim_date(date_id),
    product_key INT NOT NULL REFERENCES dim_product(product_key),
    customer_key INT NOT NULL REFERENCES dim_customer(customer_key),
    -- 退化维度
    order_id BIGINT NOT NULL,
    order_number VARCHAR(50),
    -- 度量值
    quantity INT NOT NULL,
    unit_price NUMERIC(10,2) NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    cost NUMERIC(10,2),
    profit NUMERIC(10,2) GENERATED ALWAYS AS (amount - COALESCE(cost, 0)) STORED,
    discount_amount NUMERIC(10,2) DEFAULT 0,
    shipping_fee NUMERIC(10,2) DEFAULT 0,
    -- 时间戳
    sale_timestamp TIMESTAMPTZ NOT NULL
);

-- 创建索引
CREATE INDEX idx_fact_sales_date ON fact_sales(date_id);
CREATE INDEX idx_fact_sales_product ON fact_sales(product_key);
CREATE INDEX idx_fact_sales_customer ON fact_sales(customer_key);
CREATE INDEX idx_fact_sales_timestamp ON fact_sales(sale_timestamp DESC);
```

---

## 5. 实施步骤

### 5.1 阶段一：OLTP系统建设

1. **创建基础表结构**
   - 用户表、商品表、订单表
   - 建立外键关系
   - 创建必要索引

2. **实现业务逻辑**
   - 订单创建流程
   - 支付处理流程
   - 库存管理

3. **性能优化**
   - 索引优化
   - 查询优化
   - 连接池配置

### 5.2 阶段二：OLAP系统建设

1. **维度表构建**
   - 日期维度表（一次性生成）
   - 商品维度表（SCD Type 2）
   - 用户维度表（SCD Type 1）

2. **ETL流程设计**
   - 数据抽取（从OLTP）
   - 数据转换（维度键关联）
   - 数据加载（到事实表）

3. **数据仓库优化**
   - 分区策略
   - 索引策略
   - 物化视图

### 5.3 阶段三：数据同步

**ETL流程实现**:

```sql
-- ETL函数：同步订单数据到事实表
CREATE OR REPLACE FUNCTION etl_sync_sales()
RETURNS INT AS $$
DECLARE
    v_count INT := 0;
BEGIN
    INSERT INTO fact_sales (
        date_id, product_key, customer_key,
        order_id, order_number,
        quantity, unit_price, amount, discount_amount, shipping_fee,
        sale_timestamp
    )
    SELECT
        dd.date_id,
        dp.product_key,
        dc.customer_key,
        o.order_id,
        o.order_number,
        oi.quantity,
        oi.unit_price,
        oi.line_total,
        oi.discount_amount,
        o.shipping_fee,
        o.order_date
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN dim_date dd ON DATE(o.order_date) = dd.date_value
    JOIN dim_product dp ON oi.product_id = dp.product_id AND dp.is_current = TRUE
    JOIN dim_customer dc ON o.user_id = dc.user_id
    WHERE o.order_status = 'completed'
      AND o.order_date > (
          SELECT MAX(sale_timestamp) FROM fact_sales
      )
    ON CONFLICT DO NOTHING;

    GET DIAGNOSTICS v_count = ROW_COUNT;
    RETURN v_count;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. PostgreSQL实现

### 6.1 完整表结构

**创建所有表**:

```sql
-- 执行顺序：先创建基础表，再创建外键
-- 1. 用户表
-- 2. 商品表
-- 3. 订单表
-- 4. 支付表
-- 5. 维度表
-- 6. 事实表

-- 创建分区（订单表按月分区）
ALTER TABLE orders PARTITION BY RANGE (order_date);

CREATE TABLE orders_2025_01 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- 事实表按月分区
ALTER TABLE fact_sales PARTITION BY RANGE (sale_timestamp);

CREATE TABLE fact_sales_2025_01 PARTITION OF fact_sales
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### 6.2 查询示例

**OLTP查询**:

```sql
-- 查询用户订单
SELECT
    o.order_number,
    o.order_date,
    o.total_amount,
    o.order_status,
    COUNT(oi.item_id) AS item_count
FROM orders o
LEFT JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.user_id = 1
GROUP BY o.order_id, o.order_number, o.order_date, o.total_amount, o.order_status
ORDER BY o.order_date DESC;
```

**OLAP查询**:

```sql
-- 销售分析查询
SELECT
    dd.year,
    dd.month,
    dp.category_name,
    SUM(fs.quantity) AS total_quantity,
    SUM(fs.amount) AS total_amount,
    SUM(fs.profit) AS total_profit,
    COUNT(DISTINCT fs.order_id) AS order_count
FROM fact_sales fs
JOIN dim_date dd ON fs.date_id = dd.date_id
JOIN dim_product dp ON fs.product_key = dp.product_key
WHERE dd.year = 2025
GROUP BY dd.year, dd.month, dp.category_name
ORDER BY dd.year, dd.month, total_amount DESC;
```

---

## 7. 相关资源

- [Party模型](../04-OLTP建模/Party模型.md) - Party模式应用
- [订单管理模型](../04-OLTP建模/订单管理模型.md) - 订单模型设计
- [维度建模基础](../05-OLAP建模/维度建模基础.md) - 维度建模理论
- [事实表技术](../05-OLAP建模/事实表技术.md) - 事实表设计

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
