# 医疗系统数据模型案例

> **创建日期**: 2025年1月
> **来源**: Silverston《数据模型资源手册》卷2 Chapter 4 - Health Care + 实践总结
> **状态**: 基于权威资源深化扩展
> **文档编号**: 10-04

---

## 📑 目录

- [医疗系统数据模型案例](#医疗系统数据模型案例)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 医疗数据模型设计理论](#111-医疗数据模型设计理论)
    - [1.1.2 Party模式在医疗中的应用](#112-party模式在医疗中的应用)
  - [2. 业务需求](#2-业务需求)
    - [2.1 核心业务功能](#21-核心业务功能)
    - [2.2 性能要求](#22-性能要求)
  - [3. 患者管理](#3-患者管理)
    - [3.1 患者模型（基于Party）](#31-患者模型基于party)
    - [3.2 患者关系](#32-患者关系)
  - [4. 医疗设施与从业者](#4-医疗设施与从业者)
    - [4.1 医疗设施](#41-医疗设施)
    - [4.2 从业者](#42-从业者)
  - [5. 诊疗记录](#5-诊疗记录)
    - [5.1 诊疗期（Episode）](#51-诊疗期episode)
    - [5.2 就诊（Visit）](#52-就诊visit)
    - [5.3 医疗交付（Delivery）](#53-医疗交付delivery)
  - [6. 医疗理赔](#6-医疗理赔)
    - [6.1 理赔申请](#61-理赔申请)
    - [6.2 理赔结算](#62-理赔结算)
  - [7. PostgreSQL完整实现](#7-postgresql完整实现)
    - [7.1 索引设计](#71-索引设计)
    - [7.2 查询示例](#72-查询示例)
  - [8. 合规性设计](#8-合规性设计)
    - [8.1 行级安全（RLS）](#81-行级安全rls)
    - [8.2 审计日志](#82-审计日志)
  - [9. 常见问题解答 / FAQ](#9-常见问题解答--faq)
    - [Q1: 如何保护患者隐私？](#q1-如何保护患者隐私)
    - [Q2: 如何管理诊疗期的连续性？](#q2-如何管理诊疗期的连续性)
  - [10. 相关资源](#10-相关资源)
    - [10.1 核心相关文档](#101-核心相关文档)
    - [10.2 理论基础](#102-理论基础)
    - [10.3 参考资源](#103-参考资源)

---

---

## 1. 概述

医疗系统数据模型案例展示医疗行业的数据建模实践。
本案例涵盖医疗核心业务的数据模型设计，包括患者管理、医疗设施、从业者、诊疗记录、医疗理赔等。

**案例特点**:

- **患者隐私保护**：严格的数据安全和隐私保护
- **合规要求**：符合医疗监管要求（HIPAA、HL7等）
- **诊疗记录管理**：完整的诊疗期和就诊记录
- **理赔处理**：高效的医疗理赔处理流程

---

## 1.1 理论基础

### 1.1.1 医疗数据模型设计理论

**医疗数据模型**:

- **患者隐私**: 严格的患者隐私保护
- **合规追踪**: 符合HIPAA等医疗监管要求
- **诊疗记录**: 完整的诊疗期和就诊记录管理
- **理赔处理**: 高效的医疗理赔处理

**模型设计原则**:

- **数据安全**: 使用加密和访问控制保护患者数据
- **合规追踪**: 记录所有关键操作历史
- **诊疗连续性**: 支持诊疗期和就诊的连续性记录
- **性能优化**: 优化高频查询性能

### 1.1.2 Party模式在医疗中的应用

**Party模式应用**:

- **患者角色**: 患者作为Party的一种角色
- **从业者角色**: 医生、护士等作为Party的角色
- **提供者角色**: 医疗机构作为Party的角色

**Party模式特点**:

- **角色灵活性**: 一个人可以扮演多个角色
- **关系管理**: 支持复杂的医患关系管理
- **可追溯性**: 完整的角色和关系历史

---

## 2. 业务需求

### 2.1 核心业务功能

**业务需求清单**:

1. **患者管理**
   - 患者信息管理
   - 患者角色和关系管理
   - 患者隐私保护

2. **医疗设施管理**
   - 医疗机构信息管理
   - 科室和设施管理
   - 设施联系方式管理

3. **从业者管理**
   - 医生、护士等从业者信息
   - 从业者资质和证书管理
   - 从业者与设施的关系

4. **诊疗记录管理**
   - 诊疗期（Episode）管理
   - 就诊（Visit）记录
   - 医疗交付（Delivery）记录

5. **医疗理赔管理**
   - 理赔申请处理
   - 理赔审核和结算
   - 理赔历史追踪

### 2.2 性能要求

- **高并发**：支持500+ TPS
- **低延迟**：查询响应时间<200ms
- **高可用**：99.9%可用性
- **数据安全**：加密存储，访问控制，审计日志

---

## 3. 患者管理

### 3.1 患者模型（基于Party）

**患者角色设计**:

```sql
-- 患者角色表（基于Party Role扩展，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS patient_role (
        role_id SERIAL PRIMARY KEY,
        party_id INT NOT NULL, -- 引用Party表
        patient_number VARCHAR(50) UNIQUE NOT NULL,
        from_date DATE DEFAULT CURRENT_DATE,
        thru_date DATE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 patient_role 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 patient_role 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 patient_role 失败: %', SQLERRM;
END $$;

-- 患者信息表（扩展信息，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS patient_information (
        patient_info_id SERIAL PRIMARY KEY,
        party_id INT NOT NULL, -- 引用Party表
        date_of_birth DATE,
        gender VARCHAR(10),
        blood_type VARCHAR(10),
        emergency_contact_party_id INT, -- 紧急联系人
        primary_language VARCHAR(50),
        medical_record_number VARCHAR(50),
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 patient_information 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 patient_information 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 patient_information 失败: %', SQLERRM;
END $$;
```

### 3.2 患者关系

**患者关系表设计**:

```sql
-- 患者关系表（基于Party Relationship扩展，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS patient_relationship (
        relationship_id SERIAL PRIMARY KEY,
        patient_party_id INT NOT NULL, -- 患者Party
        related_party_id INT NOT NULL, -- 相关Party（家属、监护人等）
        relationship_type VARCHAR(50) NOT NULL, -- 'parent', 'guardian', 'spouse', etc.
        from_date DATE DEFAULT CURRENT_DATE,
        thru_date DATE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 patient_relationship 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 patient_relationship 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 patient_relationship 失败: %', SQLERRM;
END $$;
```

---

## 4. 医疗设施与从业者

### 4.1 医疗设施

**医疗设施表设计**:

```sql
-- 医疗设施表（基于Facility扩展，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_facility (
        facility_id SERIAL PRIMARY KEY,
        facility_code VARCHAR(50) UNIQUE NOT NULL,
        facility_name VARCHAR(200) NOT NULL,
        facility_type VARCHAR(50), -- 'HOSPITAL', 'CLINIC', 'LAB', etc.
        address TEXT,
        phone VARCHAR(50),
        email VARCHAR(200),
        license_number VARCHAR(100),
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_facility 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_facility 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_facility 失败: %', SQLERRM;
END $$;

-- 科室表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS facility_department (
        department_id SERIAL PRIMARY KEY,
        facility_id INT NOT NULL REFERENCES health_care_facility(facility_id),
        department_code VARCHAR(50) NOT NULL,
        department_name VARCHAR(200) NOT NULL,
        parent_department_id INT REFERENCES facility_department(department_id),
        description TEXT,
        UNIQUE(facility_id, department_code),
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 facility_department 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 facility_department 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_facility表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 facility_department 失败: %', SQLERRM;
END $$;
```

### 4.2 从业者

**从业者角色设计**:

```sql
-- 从业者角色表（基于Party Role扩展，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS practitioner_role (
        role_id SERIAL PRIMARY KEY,
        party_id INT NOT NULL, -- 引用Party表
        practitioner_number VARCHAR(50) UNIQUE NOT NULL,
        practitioner_type VARCHAR(50), -- 'PHYSICIAN', 'NURSE', 'TECHNICIAN', etc.
        license_number VARCHAR(100),
        specialty VARCHAR(200),
        from_date DATE DEFAULT CURRENT_DATE,
        thru_date DATE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 practitioner_role 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 practitioner_role 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 practitioner_role 失败: %', SQLERRM;
END $$;

-- 从业者与设施关联表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS practitioner_facility (
        practitioner_facility_id SERIAL PRIMARY KEY,
        practitioner_party_id INT NOT NULL,
        facility_id INT NOT NULL REFERENCES health_care_facility(facility_id),
        department_id INT REFERENCES facility_department(department_id),
        from_date DATE DEFAULT CURRENT_DATE,
        thru_date DATE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 practitioner_facility 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 practitioner_facility 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_facility和facility_department表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 practitioner_facility 失败: %', SQLERRM;
END $$;

-- 提供者角色表（医疗机构作为提供者，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS provider_role (
        role_id SERIAL PRIMARY KEY,
        party_id INT NOT NULL, -- 引用Party表（机构）
        facility_id INT REFERENCES health_care_facility(facility_id),
        provider_number VARCHAR(50) UNIQUE NOT NULL,
        provider_type VARCHAR(50),
        from_date DATE DEFAULT CURRENT_DATE,
        thru_date DATE,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 provider_role 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 provider_role 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_facility表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 provider_role 失败: %', SQLERRM;
END $$;
```

---

## 5. 诊疗记录

### 5.1 诊疗期（Episode）

**诊疗期表设计**:

```sql
-- 诊疗期表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_episode (
        episode_id SERIAL PRIMARY KEY,
        episode_number VARCHAR(50) UNIQUE NOT NULL,
        patient_party_id INT NOT NULL, -- 患者
        episode_type VARCHAR(50), -- 诊疗期类型
        episode_description TEXT,
        episode_start_date DATE NOT NULL,
        episode_end_date DATE,
        episode_outcome TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_episode 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_episode 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_episode 失败: %', SQLERRM;
END $$;
```

### 5.2 就诊（Visit）

**就诊表设计**:

```sql
-- 就诊表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_visit (
        visit_id SERIAL PRIMARY KEY,
        visit_number VARCHAR(50) UNIQUE NOT NULL,
        episode_id INT REFERENCES health_care_episode(episode_id),
        patient_party_id INT NOT NULL,
        facility_id INT REFERENCES health_care_facility(facility_id),
        department_id INT REFERENCES facility_department(department_id),
        visit_date DATE NOT NULL,
        visit_type VARCHAR(50), -- 'INPATIENT', 'OUTPATIENT', 'EMERGENCY'
        description TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_visit 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_visit 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建主表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_visit 失败: %', SQLERRM;
END $$;
```

### 5.3 医疗交付（Delivery）

**医疗交付表设计**:

```sql
-- 医疗交付表（医疗服务或物品的提供，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_delivery (
        delivery_id SERIAL PRIMARY KEY,
        delivery_number VARCHAR(50) UNIQUE NOT NULL,
        visit_id INT REFERENCES health_care_visit(visit_id),
        delivery_type VARCHAR(50), -- 'PROCEDURE', 'DIAGNOSIS', 'MEDICATION', 'TEST'
        delivery_code VARCHAR(100), -- 医疗编码（如CPT、ICD等）
        delivery_description TEXT,
        delivery_date TIMESTAMPTZ DEFAULT NOW(),
        quantity NUMERIC(10,2),
        unit_of_measure_id INT,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_delivery 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_delivery 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_visit表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_delivery 失败: %', SQLERRM;
END $$;

-- 交付从业者角色表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS delivery_practitioner_role (
        delivery_role_id SERIAL PRIMARY KEY,
        delivery_id INT NOT NULL REFERENCES health_care_delivery(delivery_id) ON DELETE CASCADE,
        practitioner_party_id INT NOT NULL,
        role_type VARCHAR(50) NOT NULL, -- 'PRIMARY', 'ASSISTANT', 'TECHNICIAN', etc.
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 delivery_practitioner_role 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 delivery_practitioner_role 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_delivery表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 delivery_practitioner_role 失败: %', SQLERRM;
END $$;

-- 交付结果表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS delivery_outcome (
        outcome_id SERIAL PRIMARY KEY,
        delivery_id INT NOT NULL REFERENCES health_care_delivery(delivery_id) ON DELETE CASCADE,
        outcome_type VARCHAR(50),
        outcome_description TEXT,
        outcome_date TIMESTAMPTZ DEFAULT NOW(),
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 delivery_outcome 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 delivery_outcome 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_delivery表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 delivery_outcome 失败: %', SQLERRM;
END $$;
```

---

## 6. 医疗理赔

### 6.1 理赔申请

**医疗理赔表设计**:

```sql
-- 医疗理赔表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_claim (
        claim_id SERIAL PRIMARY KEY,
        claim_number VARCHAR(50) UNIQUE NOT NULL,
        patient_party_id INT NOT NULL,
        insurance_policy_id INT, -- 引用保险单
        claim_date DATE DEFAULT CURRENT_DATE,
        total_claim_amount NUMERIC(15,2),
        status VARCHAR(50) DEFAULT 'submitted', -- 'submitted', 'adjusting', 'settled', 'rejected'
        created_at TIMESTAMPTZ DEFAULT NOW(),
        updated_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_claim 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_claim 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_claim 失败: %', SQLERRM;
END $$;
```

-- 理赔项目表（关联到医疗交付）
-- 医疗理赔项目表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'health_care_claim_item') THEN
            CREATE TABLE health_care_claim_item (
                claim_item_id SERIAL PRIMARY KEY,
                claim_id INT NOT NULL REFERENCES health_care_claim(claim_id) ON DELETE CASCADE,
                item_seq_id INT NOT NULL,
                delivery_id INT REFERENCES health_care_delivery(delivery_id),
                claim_amount NUMERIC(15,2),
                quantity NUMERIC(10,2),
                unit_of_measure_id INT,
                diagnosis_code VARCHAR(100), -- 诊断编码
                service_code VARCHAR(100), -- 服务编码
                description TEXT,
                UNIQUE(claim_id, item_seq_id)
            );
            RAISE NOTICE '表 health_care_claim_item 创建成功';
        ELSE
            RAISE NOTICE '表 health_care_claim_item 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 health_care_claim_item 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表 health_care_claim_item 失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 理赔代码表（带错误处理）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'claim_code') THEN
            CREATE TABLE claim_code (
                code_id SERIAL PRIMARY KEY,
                claim_item_id INT NOT NULL REFERENCES health_care_claim_item(claim_item_id) ON DELETE CASCADE,
                code_type VARCHAR(50) NOT NULL, -- 'DIAGNOSIS', 'PROCEDURE', 'MODIFIER'
                code_value VARCHAR(100) NOT NULL,
                code_description TEXT,
                created_at TIMESTAMPTZ DEFAULT NOW()
            );
            RAISE NOTICE '表 claim_code 创建成功';
        ELSE
            RAISE NOTICE '表 claim_code 已存在，跳过创建';
        END IF;
    EXCEPTION
        WHEN duplicate_table THEN
            RAISE NOTICE '表 claim_code 已存在';
        WHEN OTHERS THEN
            RAISE WARNING '创建表 claim_code 失败: %', SQLERRM;
            RAISE;
    END;
END $$;
```

### 6.2 理赔结算

**理赔结算表设计**:

```sql
-- 理赔结算表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_claim_settlement (
        settlement_id SERIAL PRIMARY KEY,
        claim_item_id INT NOT NULL REFERENCES health_care_claim_item(claim_item_id),
        settlement_date DATE DEFAULT CURRENT_DATE,
        settlement_amount NUMERIC(15,2) NOT NULL,
        deductible_amount NUMERIC(15,2) DEFAULT 0,
        copay_amount NUMERIC(15,2) DEFAULT 0,
        coinsurance_amount NUMERIC(15,2) DEFAULT 0,
        disallowed_amount NUMERIC(15,2) DEFAULT 0,
        payment_amount NUMERIC(15,2) NOT NULL,
        explanation_of_benefit TEXT,
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_claim_settlement 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_claim_settlement 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_claim_item表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_claim_settlement 失败: %', SQLERRM;
END $$;

-- 理赔支付表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_claim_payment (
        payment_id SERIAL PRIMARY KEY,
        settlement_id INT NOT NULL REFERENCES health_care_claim_settlement(settlement_id),
        payment_type VARCHAR(50),
        payment_method VARCHAR(50),
        payment_amount NUMERIC(15,2) NOT NULL,
        payment_date DATE DEFAULT CURRENT_DATE,
        payee_party_id INT NOT NULL, -- 收款方（患者或提供者）
        status VARCHAR(50) DEFAULT 'pending',
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_claim_payment 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_claim_payment 已存在，跳过创建';
    WHEN foreign_key_violation THEN
        RAISE WARNING '外键约束违反，请先创建health_care_claim_settlement表';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_claim_payment 失败: %', SQLERRM;
END $$;
```

---

## 7. PostgreSQL完整实现

### 7.1 索引设计

```sql
-- 患者索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_patient_role_party ON patient_role(party_id);
    CREATE INDEX IF NOT EXISTS idx_patient_role_number ON patient_role(patient_number);
    CREATE INDEX IF NOT EXISTS idx_patient_information_party ON patient_information(party_id);
    RAISE NOTICE '患者索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建患者索引失败: %', SQLERRM;
END $$;

-- 设施索引
CREATE INDEX idx_health_care_facility_code ON health_care_facility(facility_code);
CREATE INDEX idx_facility_department_facility ON facility_department(facility_id);

-- 从业者索引
CREATE INDEX idx_practitioner_role_party ON practitioner_role(party_id);
CREATE INDEX idx_practitioner_role_number ON practitioner_role(practitioner_number);
CREATE INDEX idx_practitioner_facility_practitioner ON practitioner_facility(practitioner_party_id);
CREATE INDEX idx_practitioner_facility_facility ON practitioner_facility(facility_id);

-- 诊疗期索引
CREATE INDEX idx_health_care_episode_patient ON health_care_episode(patient_party_id);
CREATE INDEX idx_health_care_episode_dates ON health_care_episode(episode_start_date, episode_end_date);

-- 就诊索引
CREATE INDEX idx_health_care_visit_patient ON health_care_visit(patient_party_id);
CREATE INDEX idx_health_care_visit_episode ON health_care_visit(episode_id);
CREATE INDEX idx_health_care_visit_facility ON health_care_visit(facility_id);
CREATE INDEX idx_health_care_visit_date ON health_care_visit(visit_date DESC);

-- 医疗交付索引
CREATE INDEX idx_health_care_delivery_visit ON health_care_delivery(visit_id);
CREATE INDEX idx_health_care_delivery_code ON health_care_delivery(delivery_code);
CREATE INDEX idx_health_care_delivery_date ON health_care_delivery(delivery_date DESC);

-- 理赔索引
CREATE INDEX idx_health_care_claim_patient ON health_care_claim(patient_party_id);
CREATE INDEX idx_health_care_claim_policy ON health_care_claim(insurance_policy_id);
CREATE INDEX idx_health_care_claim_status ON health_care_claim(status, claim_date);
CREATE INDEX idx_health_care_claim_date ON health_care_claim(claim_date DESC);
```

### 7.2 查询示例

**查询1: 查询患者完整诊疗历史**:

```sql
-- 查询患者完整诊疗历史（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'health_care_episode') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'health_care_visit') OR
           NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'health_care_delivery') THEN
            RAISE WARNING '必需的表不存在，无法执行患者诊疗历史查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行患者完整诊疗历史查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    he.episode_number,
    he.episode_description,
    he.episode_start_date,
    he.episode_end_date,
    hv.visit_date,
    hv.visit_type,
    hcd.delivery_type,
    hcd.delivery_description,
    hcd.delivery_date
FROM health_care_episode he
LEFT JOIN health_care_visit hv ON he.episode_id = hv.episode_id
LEFT JOIN health_care_delivery hcd ON hv.visit_id = hcd.visit_id
WHERE he.patient_party_id = :patient_party_id
ORDER BY he.episode_start_date DESC, hv.visit_date DESC, hcd.delivery_date DESC;

**查询2: 查询理赔统计**:

```sql
-- 查询理赔统计（带错误处理和性能测试）
DO $$
BEGIN
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'health_care_claim') THEN
            RAISE WARNING '表 health_care_claim 不存在，无法执行理赔统计查询';
            RETURN;
        END IF;
        RAISE NOTICE '开始执行理赔统计查询';
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '查询准备失败: %', SQLERRM;
            RAISE;
    END;
END $$;

EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    DATE_TRUNC('month', hcc.claim_date) AS claim_month,
    COUNT(*) AS claim_count,
    SUM(hcc.total_claim_amount) AS total_claim_amount,
    AVG(hcc.total_claim_amount) AS avg_claim_amount,
    SUM(hccs.settlement_amount) AS total_settlement_amount,
    SUM(hccs.payment_amount) AS total_payment_amount
FROM health_care_claim hcc
LEFT JOIN health_care_claim_item hcci ON hcc.claim_id = hcci.claim_id
LEFT JOIN health_care_claim_settlement hccs ON hcci.claim_item_id = hccs.claim_item_id
WHERE hcc.claim_date >= :start_date
  AND hcc.claim_date <= :end_date
GROUP BY DATE_TRUNC('month', hcc.claim_date)
ORDER BY claim_month DESC;
```

---

## 8. 合规性设计

### 8.1 行级安全（RLS）

```sql
-- 启用RLS（带错误处理）
DO $$
BEGIN
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'patient_information') THEN
            ALTER TABLE patient_information ENABLE ROW LEVEL SECURITY;
            RAISE NOTICE 'patient_information表RLS已启用';
        END IF;
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'health_care_delivery') THEN
            ALTER TABLE health_care_delivery ENABLE ROW LEVEL SECURITY;
            RAISE NOTICE 'health_care_delivery表RLS已启用';
        END IF;
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'health_care_claim') THEN
            ALTER TABLE health_care_claim ENABLE ROW LEVEL SECURITY;
            RAISE NOTICE 'health_care_claim表RLS已启用';
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE WARNING '启用RLS失败: %', SQLERRM;
            RAISE;
    END;
END $$;

-- 患者信息访问策略（仅患者本人和授权医生可访问）
CREATE POLICY patient_info_access ON patient_information
    FOR ALL
    USING (
        -- 患者本人
        party_id = current_setting('app.current_party_id')::INT
        OR
        -- 授权医生（带性能测试说明）
        -- 注意：EXISTS子查询的性能测试通常在RLS策略测试时进行
        -- EXPLAIN (ANALYZE, BUFFERS, TIMING)
        -- SELECT 1 FROM practitioner_role pr
        -- WHERE pr.party_id = current_setting('app.current_party_id')::INT
        --   AND pr.from_date <= CURRENT_DATE
        --   AND (pr.thru_date IS NULL OR pr.thru_date >= CURRENT_DATE);
        EXISTS (
            SELECT 1 FROM practitioner_role pr
            WHERE pr.party_id = current_setting('app.current_party_id')::INT
              AND pr.from_date <= CURRENT_DATE
              AND (pr.thru_date IS NULL OR pr.thru_date >= CURRENT_DATE)
        )
    );
```

### 8.2 审计日志

```sql
-- 医疗数据审计日志表（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS health_care_audit_log (
        log_id BIGSERIAL PRIMARY KEY,
        table_name VARCHAR(100) NOT NULL,
        record_id BIGINT NOT NULL,
        action VARCHAR(20) NOT NULL,
        patient_party_id INT,
        old_data JSONB,
        new_data JSONB,
        changed_by VARCHAR(100),
        changed_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 health_care_audit_log 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 health_care_audit_log 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 health_care_audit_log 失败: %', SQLERRM;
END $$;
```

-- 审计触发器
CREATE OR REPLACE FUNCTION health_care_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO health_care_audit_log (
        table_name, record_id, action, patient_party_id,
        old_data, new_data, changed_by
    ) VALUES (
        TG_TABLE_NAME,
        COALESCE(NEW.patient_party_id, OLD.patient_party_id, NEW.episode_id, OLD.episode_id),
        TG_OP,
        COALESCE(NEW.patient_party_id, OLD.patient_party_id),
        CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD)::jsonb ELSE NULL END,
        CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN row_to_json(NEW)::jsonb ELSE NULL END,
        current_user
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit_patient_info
    AFTER INSERT OR UPDATE OR DELETE ON patient_information
    FOR EACH ROW
    EXECUTE FUNCTION health_care_audit_trigger();
```

---

## 9. 常见问题解答 / FAQ

### Q1: 如何保护患者隐私？

**A**: 患者隐私保护策略：

```sql
-- 使用RLS限制访问
-- 使用加密存储敏感信息
-- 使用审计日志记录所有访问
-- 定期审查访问权限
```

### Q2: 如何管理诊疗期的连续性？

**A**: 诊疗期连续性管理：

```sql
-- 使用诊疗期表记录完整诊疗过程
-- 使用就诊表记录每次就诊
-- 使用医疗交付表记录具体医疗服务
-- 支持诊疗期的关联和追溯
```

---

## 10. 相关资源

### 10.1 核心相关文档

- [Party模型](../04-OLTP建模/Party模型.md) - 患者、从业者、提供者模型基础
- [保险系统数据模型案例](./保险系统数据模型案例.md) - 医疗理赔模型
- [产品管理模型](../04-OLTP建模/产品管理模型.md) - 医疗产品模型

### 10.2 理论基础

- [Silverston数据模型资源手册](../02-权威资源与标准/Silverston数据模型资源手册.md) - 医疗模型来源
- [行业标准与规范](../02-权威资源与标准/行业标准与规范.md) - HL7 FHIR标准

### 10.3 参考资源

- [术语对照表](../00-导航与索引/术语对照表.md) - 术语对照
- [权威资源索引](../00-导航与索引/权威资源索引.md) - 权威资源列表

---

**状态**: ✅ 文档完整内容已补充（700+行）
**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
