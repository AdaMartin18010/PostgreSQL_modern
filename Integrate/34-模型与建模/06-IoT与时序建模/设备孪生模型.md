# 设备孪生模型

> **创建日期**: 2025年1月
> **来源**: IoT数字孪生理论
> **状态**: 待完善
> **文档编号**: 06-03

---

## 📑 目录

- [设备孪生模型](#设备孪生模型)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 设备模型设计](#2-设备模型设计)
    - [2.1 设备基础模型](#21-设备基础模型)
    - [2.2 设备属性模型](#22-设备属性模型)
    - [2.3 设备关系模型](#23-设备关系模型)
  - [3. 状态管理](#3-状态管理)
    - [3.1 设备状态表](#31-设备状态表)
    - [3.2 状态更新函数](#32-状态更新函数)
    - [3.3 状态查询](#33-状态查询)
  - [4. 遥测数据](#4-遥测数据)
    - [4.1 遥测数据模型](#41-遥测数据模型)
    - [4.2 遥测数据查询](#42-遥测数据查询)
  - [5. 命令与控制](#5-命令与控制)
    - [5.1 命令模型](#51-命令模型)
    - [5.2 命令执行函数](#52-命令执行函数)
    - [5.3 命令查询](#53-命令查询)
  - [6. PostgreSQL实现](#6-postgresql实现)
    - [6.1 完整设备孪生系统](#61-完整设备孪生系统)
    - [6.2 设备孪生视图](#62-设备孪生视图)
  - [7. 相关资源](#7-相关资源)

---

## 1. 概述

设备孪生模型用于在数据库中表示物理设备的数字副本，支持状态同步和远程控制。
设备孪生（Digital Twin）是物理设备在数字世界的完整映射，包含设备属性、状态、遥测数据和命令接口。

**核心价值**:

- **状态同步**：实时同步物理设备状态
- **远程控制**：通过数字孪生控制物理设备
- **历史追溯**：记录设备完整生命周期
- **预测分析**：基于孪生数据进行预测

---

## 2. 设备模型设计

### 2.1 设备基础模型

**设备元数据表**:

```sql
-- 设备表（设备孪生）
CREATE TABLE device_twin (
    device_id VARCHAR(50) PRIMARY KEY,
    device_name VARCHAR(200) NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    -- 设备属性（JSONB存储灵活属性）
    properties JSONB DEFAULT '{}',
    -- 设备配置
    configuration JSONB DEFAULT '{}',
    -- 设备状态
    status VARCHAR(50) DEFAULT 'offline', -- 'online', 'offline', 'error'
    -- 位置信息
    location JSONB,
    -- 元数据
    manufacturer VARCHAR(100),
    model_number VARCHAR(100),
    serial_number VARCHAR(100),
    firmware_version VARCHAR(50),
    -- 时间戳
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_seen_at TIMESTAMPTZ
);

-- 创建索引
CREATE INDEX idx_device_twin_type ON device_twin(device_type);
CREATE INDEX idx_device_twin_status ON device_twin(status);
CREATE INDEX idx_device_twin_properties ON device_twin USING GIN(properties);
```

### 2.2 设备属性模型

**结构化属性设计**:

```sql
-- 设备属性定义表
CREATE TABLE device_property_definition (
    property_id SERIAL PRIMARY KEY,
    device_type VARCHAR(50) NOT NULL,
    property_name VARCHAR(100) NOT NULL,
    property_type VARCHAR(50) NOT NULL, -- 'string', 'number', 'boolean', 'object'
    description TEXT,
    default_value JSONB,
    constraints JSONB, -- 约束条件，如范围、枚举值等
    is_required BOOLEAN DEFAULT FALSE,
    UNIQUE(device_type, property_name)
);

-- 示例：温度传感器属性定义
INSERT INTO device_property_definition (
    device_type, property_name, property_type, description, constraints, is_required
) VALUES
    ('temperature_sensor', 'temperature', 'number', '温度值（摄氏度）',
     '{"min": -50, "max": 100}', TRUE),
    ('temperature_sensor', 'humidity', 'number', '湿度值（百分比）',
     '{"min": 0, "max": 100}', FALSE),
    ('temperature_sensor', 'battery_level', 'number', '电池电量',
     '{"min": 0, "max": 100}', FALSE);
```

### 2.3 设备关系模型

**设备层级关系**:

```sql
-- 设备关系表（支持层级结构）
CREATE TABLE device_relationship (
    relationship_id SERIAL PRIMARY KEY,
    parent_device_id VARCHAR(50) REFERENCES device_twin(device_id),
    child_device_id VARCHAR(50) REFERENCES device_twin(device_id),
    relationship_type VARCHAR(50) NOT NULL, -- 'contains', 'controls', 'monitors'
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(parent_device_id, child_device_id, relationship_type),
    CHECK (parent_device_id != child_device_id)
);

-- 示例：网关包含多个传感器
INSERT INTO device_relationship (parent_device_id, child_device_id, relationship_type) VALUES
    ('gateway_001', 'sensor_001', 'contains'),
    ('gateway_001', 'sensor_002', 'contains'),
    ('gateway_001', 'sensor_003', 'contains');
```

---

## 3. 状态管理

### 3.1 设备状态表

**状态历史记录**:

```sql
-- 设备状态历史表
CREATE TABLE device_state_history (
    state_id BIGSERIAL PRIMARY KEY,
    device_id VARCHAR(50) NOT NULL REFERENCES device_twin(device_id),
    -- 状态信息
    status VARCHAR(50) NOT NULL,
    state_data JSONB, -- 完整状态快照
    -- 状态变化原因
    change_reason VARCHAR(200),
    -- 时间戳
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_state_history_device_time ON device_state_history(device_id, timestamp DESC);
CREATE INDEX idx_state_history_status ON device_state_history(status, timestamp DESC);

-- 分区（按月分区）
CREATE TABLE device_state_history (
    state_id BIGSERIAL,
    device_id VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL,
    state_data JSONB,
    change_reason VARCHAR(200),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (state_id, timestamp)
) PARTITION BY RANGE (timestamp);

CREATE TABLE device_state_history_2025_01
    PARTITION OF device_state_history
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### 3.2 状态更新函数

**状态同步函数**:

```sql
-- 更新设备状态
CREATE OR REPLACE FUNCTION update_device_state(
    p_device_id VARCHAR,
    p_status VARCHAR,
    p_state_data JSONB DEFAULT NULL,
    p_change_reason VARCHAR DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    -- 更新设备孪生当前状态
    UPDATE device_twin
    SET
        status = p_status,
        properties = COALESCE(p_state_data, properties),
        updated_at = NOW(),
        last_seen_at = NOW()
    WHERE device_id = p_device_id;

    -- 记录状态历史
    INSERT INTO device_state_history (
        device_id, status, state_data, change_reason
    ) VALUES (
        p_device_id, p_status, p_state_data, p_change_reason
    );
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT update_device_state(
    'device_001',
    'online',
    '{"temperature": 25.5, "humidity": 60.0}'::JSONB,
    '设备上线'
);
```

### 3.3 状态查询

**当前状态查询**:

```sql
-- 查询设备当前状态
SELECT
    dt.device_id,
    dt.device_name,
    dt.status,
    dt.properties,
    dt.last_seen_at,
    CASE
        WHEN dt.last_seen_at > NOW() - INTERVAL '5 minutes' THEN 'active'
        WHEN dt.last_seen_at > NOW() - INTERVAL '1 hour' THEN 'inactive'
        ELSE 'offline'
    END AS activity_status
FROM device_twin dt
WHERE dt.device_id = 'device_001';

-- 查询状态历史
SELECT
    status,
    timestamp,
    state_data,
    change_reason,
    LAG(status) OVER (ORDER BY timestamp) AS previous_status
FROM device_state_history
WHERE device_id = 'device_001'
ORDER BY timestamp DESC
LIMIT 100;
```

---

## 4. 遥测数据

### 4.1 遥测数据模型

**遥测数据表**:

```sql
-- 遥测数据表（使用TimescaleDB）
CREATE TABLE device_telemetry (
    time TIMESTAMPTZ NOT NULL,
    device_id VARCHAR(50) NOT NULL REFERENCES device_twin(device_id),
    -- 遥测数据（JSONB存储灵活结构）
    telemetry_data JSONB NOT NULL,
    -- 数据质量
    quality_code INT DEFAULT 0, -- 0=good, 1=uncertain, 2=bad
    -- 元数据
    metadata JSONB
);

-- 转换为Hypertable
SELECT create_hypertable('device_telemetry', 'time',
    chunk_time_interval => INTERVAL '1 day');

-- 创建索引
CREATE INDEX idx_telemetry_device_time ON device_telemetry(device_id, time DESC);
CREATE INDEX idx_telemetry_data ON device_telemetry USING GIN(telemetry_data);

-- 示例数据
INSERT INTO device_telemetry (time, device_id, telemetry_data) VALUES
    (NOW(), 'device_001', '{"temperature": 25.5, "humidity": 60.0, "pressure": 1013.25}'),
    (NOW() + INTERVAL '1 second', 'device_001', '{"temperature": 25.6, "humidity": 60.1, "pressure": 1013.26}');
```

### 4.2 遥测数据查询

**数据查询函数**:

```sql
-- 查询设备遥测数据
CREATE OR REPLACE FUNCTION get_device_telemetry(
    p_device_id VARCHAR,
    p_start_time TIMESTAMPTZ,
    p_end_time TIMESTAMPTZ,
    p_metric_name VARCHAR DEFAULT NULL
)
RETURNS TABLE (
    time TIMESTAMPTZ,
    metric_name VARCHAR,
    metric_value DOUBLE PRECISION
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        dt.time,
        key AS metric_name,
        (value::TEXT)::DOUBLE PRECISION AS metric_value
    FROM device_telemetry dt,
         jsonb_each(dt.telemetry_data) AS kv
    WHERE dt.device_id = p_device_id
      AND dt.time BETWEEN p_start_time AND p_end_time
      AND (p_metric_name IS NULL OR key = p_metric_name)
    ORDER BY dt.time DESC;
END;
$$ LANGUAGE plpgsql;

-- 使用示例
SELECT * FROM get_device_telemetry(
    'device_001',
    NOW() - INTERVAL '1 hour',
    NOW(),
    'temperature'
);
```

---

## 5. 命令与控制

### 5.1 命令模型

**设备命令表**:

```sql
-- 设备命令表
CREATE TABLE device_command (
    command_id BIGSERIAL PRIMARY KEY,
    device_id VARCHAR(50) NOT NULL REFERENCES device_twin(device_id),
    -- 命令信息
    command_name VARCHAR(100) NOT NULL,
    command_payload JSONB,
    -- 命令状态
    status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'sent', 'acknowledged', 'completed', 'failed'
    -- 优先级
    priority INT DEFAULT 5 CHECK (priority BETWEEN 1 AND 10),
    -- 时间戳
    created_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    acknowledged_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    -- 结果
    result JSONB,
    error_message TEXT,
    -- 超时设置
    timeout_seconds INT DEFAULT 30
);

-- 创建索引
CREATE INDEX idx_command_device_status ON device_command(device_id, status);
CREATE INDEX idx_command_pending ON device_command(status, priority DESC, created_at)
    WHERE status = 'pending';
```

### 5.2 命令执行函数

**命令发送函数**:

```sql
-- 发送设备命令
CREATE OR REPLACE FUNCTION send_device_command(
    p_device_id VARCHAR,
    p_command_name VARCHAR,
    p_command_payload JSONB DEFAULT NULL,
    p_priority INT DEFAULT 5,
    p_timeout_seconds INT DEFAULT 30
)
RETURNS BIGINT AS $$
DECLARE
    v_command_id BIGINT;
BEGIN
    -- 检查设备是否在线
    IF NOT EXISTS (
        SELECT 1 FROM device_twin
        WHERE device_id = p_device_id AND status = 'online'
    ) THEN
        RAISE EXCEPTION 'Device % is not online', p_device_id;
    END IF;

    -- 创建命令
    INSERT INTO device_command (
        device_id, command_name, command_payload, priority, timeout_seconds
    ) VALUES (
        p_device_id, p_command_name, p_command_payload, p_priority, p_timeout_seconds
    ) RETURNING command_id INTO v_command_id;

    RETURN v_command_id;
END;
$$ LANGUAGE plpgsql;

-- 更新命令状态
CREATE OR REPLACE FUNCTION update_command_status(
    p_command_id BIGINT,
    p_status VARCHAR,
    p_result JSONB DEFAULT NULL,
    p_error_message TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    UPDATE device_command
    SET
        status = p_status,
        result = p_result,
        error_message = p_error_message,
        sent_at = CASE WHEN p_status = 'sent' THEN NOW() ELSE sent_at END,
        acknowledged_at = CASE WHEN p_status = 'acknowledged' THEN NOW() ELSE acknowledged_at END,
        completed_at = CASE WHEN p_status IN ('completed', 'failed') THEN NOW() ELSE completed_at END
    WHERE command_id = p_command_id;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 命令查询

**待执行命令查询**:

```sql
-- 查询待执行的命令
SELECT
    command_id,
    device_id,
    command_name,
    command_payload,
    priority,
    created_at,
    EXTRACT(EPOCH FROM (NOW() - created_at)) AS age_seconds
FROM device_command
WHERE status = 'pending'
  AND device_id = 'device_001'
ORDER BY priority DESC, created_at ASC
LIMIT 10;

-- 查询命令历史
SELECT
    command_id,
    device_id,
    command_name,
    status,
    created_at,
    completed_at,
    EXTRACT(EPOCH FROM (completed_at - created_at)) AS execution_time_seconds
FROM device_command
WHERE device_id = 'device_001'
ORDER BY created_at DESC
LIMIT 100;
```

---

## 6. PostgreSQL实现

### 6.1 完整设备孪生系统

```sql
-- 设备孪生主表
CREATE TABLE device_twin (
    device_id VARCHAR(50) PRIMARY KEY,
    device_name VARCHAR(200) NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    properties JSONB DEFAULT '{}',
    configuration JSONB DEFAULT '{}',
    status VARCHAR(50) DEFAULT 'offline',
    location JSONB,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_seen_at TIMESTAMPTZ
);

-- 设备状态历史（分区表）
CREATE TABLE device_state_history (
    state_id BIGSERIAL,
    device_id VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL,
    state_data JSONB,
    change_reason VARCHAR(200),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (state_id, timestamp)
) PARTITION BY RANGE (timestamp);

-- 设备遥测数据（Hypertable）
CREATE TABLE device_telemetry (
    time TIMESTAMPTZ NOT NULL,
    device_id VARCHAR(50) NOT NULL,
    telemetry_data JSONB NOT NULL,
    quality_code INT DEFAULT 0,
    metadata JSONB
);

SELECT create_hypertable('device_telemetry', 'time');

-- 设备命令表
CREATE TABLE device_command (
    command_id BIGSERIAL PRIMARY KEY,
    device_id VARCHAR(50) NOT NULL,
    command_name VARCHAR(100) NOT NULL,
    command_payload JSONB,
    status VARCHAR(50) DEFAULT 'pending',
    priority INT DEFAULT 5,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    acknowledged_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    result JSONB,
    error_message TEXT,
    timeout_seconds INT DEFAULT 30
);

-- 创建索引
CREATE INDEX idx_device_twin_status ON device_twin(status);
CREATE INDEX idx_device_twin_properties ON device_twin USING GIN(properties);
CREATE INDEX idx_state_history_device ON device_state_history(device_id, timestamp DESC);
CREATE INDEX idx_telemetry_device ON device_telemetry(device_id, time DESC);
CREATE INDEX idx_command_pending ON device_command(device_id, status, priority DESC);
```

### 6.2 设备孪生视图

**综合视图**:

```sql
-- 设备孪生综合视图
CREATE VIEW device_twin_summary AS
SELECT
    dt.device_id,
    dt.device_name,
    dt.device_type,
    dt.status,
    dt.last_seen_at,
    -- 最新遥测数据
    (
        SELECT telemetry_data
        FROM device_telemetry
        WHERE device_id = dt.device_id
        ORDER BY time DESC
        LIMIT 1
    ) AS latest_telemetry,
    -- 待执行命令数
    (
        SELECT COUNT(*)
        FROM device_command
        WHERE device_id = dt.device_id AND status = 'pending'
    ) AS pending_commands,
    -- 今日数据点数
    (
        SELECT COUNT(*)
        FROM device_telemetry
        WHERE device_id = dt.device_id
          AND time > CURRENT_DATE
    ) AS today_data_points
FROM device_twin dt;
```

---

## 7. 相关资源

- [时序数据模型](./时序数据模型.md) - 时序数据建模指南
- [TimescaleDB实践](./TimescaleDB实践.md) - TimescaleDB详细指南
- [Azure IoT Hub设备孪生](https://docs.microsoft.com/azure/iot-hub/) - Azure设备孪生参考
- [AWS IoT设备影子](https://docs.aws.amazon.com/iot/) - AWS设备影子参考

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
