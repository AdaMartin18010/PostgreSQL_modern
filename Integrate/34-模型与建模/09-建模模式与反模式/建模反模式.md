# 建模反模式

> **创建日期**: 2025年1月
> **来源**: 数据建模反模式研究
> **状态**: ✅ 已完成
> **文档编号**: 09-02

---

## 📑 目录

- [建模反模式](#建模反模式)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [1.1 理论基础](#11-理论基础)
    - [1.1.1 反模式基本概念](#111-反模式基本概念)
    - [1.1.2 过度使用JSONB反模式理论](#112-过度使用jsonb反模式理论)
    - [1.1.3 无控制分区反模式理论](#113-无控制分区反模式理论)
    - [1.1.4 缺失约束反模式理论](#114-缺失约束反模式理论)
    - [1.1.5 过度规范化反模式理论](#115-过度规范化反模式理论)
    - [1.1.6 反模式识别理论](#116-反模式识别理论)
    - [1.1.7 反模式重构理论](#117-反模式重构理论)
    - [1.1.8 复杂度分析](#118-复杂度分析)
  - [2. 过度使用JSONB](#2-过度使用jsonb)
    - [2.1 反模式描述](#21-反模式描述)
    - [2.2 问题分析](#22-问题分析)
    - [2.3 解决方案](#23-解决方案)
  - [3. 无控制的分区](#3-无控制的分区)
    - [3.1 反模式描述](#31-反模式描述)
    - [3.2 问题分析](#32-问题分析)
    - [3.3 解决方案](#33-解决方案)
  - [4. 缺失约束](#4-缺失约束)
    - [4.1 反模式描述](#41-反模式描述)
    - [4.2 问题分析](#42-问题分析)
    - [4.3 解决方案](#43-解决方案)
  - [5. 过度规范化](#5-过度规范化)
    - [5.1 反模式描述](#51-反模式描述)
    - [5.2 问题分析](#52-问题分析)
    - [5.3 解决方案](#53-解决方案)
  - [6. 重构策略](#6-重构策略)
    - [6.1 识别反模式](#61-识别反模式)
    - [6.2 重构步骤](#62-重构步骤)
    - [6.3 重构示例](#63-重构示例)
    - [6.4 重构最佳实践](#64-重构最佳实践)
  - [7. 更多反模式案例 / More Anti-Pattern Examples](#7-更多反模式案例--more-anti-pattern-examples)
    - [7.1 案例1: 过度使用触发器](#71-案例1-过度使用触发器)
    - [7.2 案例2: 缺少索引设计](#72-案例2-缺少索引设计)
    - [7.3 案例3: 数据类型选择错误](#73-案例3-数据类型选择错误)
  - [8. 常见问题解答 / FAQ](#8-常见问题解答--faq)
    - [Q1: 如何识别反模式？](#q1-如何识别反模式)
    - [Q2: 反模式重构的优先级如何确定？](#q2-反模式重构的优先级如何确定)
    - [Q3: 如何安全地重构反模式？](#q3-如何安全地重构反模式)
    - [Q4: 如何避免引入新的反模式？](#q4-如何避免引入新的反模式)
    - [Q5: 反模式重构后如何验证？](#q5-反模式重构后如何验证)
  - [8. 相关资源 / Related Resources](#8-相关资源--related-resources)
    - [8.1 核心相关文档 / Core Related Documents](#81-核心相关文档--core-related-documents)
    - [8.2 理论基础 / Theoretical Foundation](#82-理论基础--theoretical-foundation)
    - [8.3 实践指南 / Practical Guides](#83-实践指南--practical-guides)
    - [8.4 应用案例 / Application Cases](#84-应用案例--application-cases)
    - [8.5 参考资源 / Reference Resources](#85-参考资源--reference-resources)

---

## 1. 概述

建模反模式是常见但错误的数据建模实践，识别和避免这些反模式对系统质量至关重要。
反模式虽然看似解决了问题，但会带来长期的技术债务和维护成本。

**核心危害**:

- **性能问题**：导致查询性能下降
- **数据质量**：数据完整性无法保证
- **维护困难**：增加系统复杂度
- **扩展性差**：难以适应业务变化

---

## 1.1 理论基础

### 1.1.1 反模式基本概念

**反模式（Anti-Pattern）**:

- **定义**: 常见但错误的设计模式
- **特征**: 看似解决问题，但带来长期问题
- **危害**: 技术债务、维护成本、性能问题

**反模式分类**:

- **设计反模式**: 设计层面的反模式
- **实现反模式**: 实现层面的反模式
- **性能反模式**: 性能相关的反模式

### 1.1.2 过度使用JSONB反模式理论

**过度使用JSONB**:

- **问题**: 将所有数据存储在JSONB中
- **危害**: 查询性能差、数据完整性无法保证、类型安全缺失
- **原因**: 追求灵活性，忽视结构化优势

**JSONB使用原则**:

- **适用场景**: 半结构化数据、动态属性
- **不适用场景**: 结构化数据、需要约束的数据
- **权衡**: 灵活性与性能的权衡

### 1.1.3 无控制分区反模式理论

**无控制分区**:

- **问题**: 分区数量过多或过少
- **危害**: 查询性能差、管理困难
- **原因**: 缺乏分区策略

**分区设计原则**:

- **分区数量**: 建议100-1000个分区
- **分区大小**: 建议100MB-1GB per partition
- **分区键**: 选择合适的分区键

### 1.1.4 缺失约束反模式理论

**缺失约束**:

- **问题**: 缺少必要的约束
- **危害**: 数据完整性无法保证、数据质量差
- **原因**: 追求灵活性，忽视数据完整性

**约束设计原则**:

- **完整性约束**: 主键、外键、唯一约束
- **业务约束**: CHECK约束、NOT NULL约束
- **约束权衡**: 完整性与性能的权衡

### 1.1.5 过度规范化反模式理论

**过度规范化**:

- **问题**: 过度范式化导致查询复杂
- **危害**: 查询性能差、JOIN操作多
- **原因**: 追求范式化，忽视查询性能

**规范化权衡**:

- **OLTP系统**: 优先范式化（3NF/BCNF）
- **OLAP系统**: 允许反范式化
- **混合系统**: 根据场景选择

### 1.1.6 反模式识别理论

**反模式识别**:

- **性能指标**: 查询性能下降
- **数据质量**: 数据完整性问题
- **维护成本**: 维护困难

**识别方法**:

- **性能分析**: 分析查询性能
- **代码审查**: 审查数据模型设计
- **监控指标**: 监控系统指标

### 1.1.7 反模式重构理论

**重构策略**:

- **识别反模式**: 识别系统中的反模式
- **评估影响**: 评估反模式的影响
- **制定计划**: 制定重构计划
- **执行重构**: 执行重构

**重构原则**:

- **渐进式重构**: 逐步重构，避免大改动
- **测试验证**: 重构后测试验证
- **文档更新**: 更新相关文档

### 1.1.8 复杂度分析

**反模式影响**:

- **性能影响**: $O(N)$ to $O(N^2)$ (worst case)
- **维护成本**: $O(M)$ where M is complexity
- **技术债务**: $O(D)$ where D is debt

**重构复杂度**:

- **识别复杂度**: $O(C)$ where C is code size
- **重构复杂度**: $O(R)$ where R is refactoring scope
- **验证复杂度**: $O(T)$ where T is test cases

---

## 2. 过度使用JSONB

### 2.1 反模式描述

**问题**：将所有数据都存储在JSONB字段中，放弃关系型数据库的结构化优势。

**典型表现**:

```sql
-- 反模式示例：过度使用JSONB（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS users (
        user_id SERIAL PRIMARY KEY,
        data JSONB  -- 所有用户数据都在JSONB中
    );
    RAISE NOTICE '表 users 创建成功（反模式示例）';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 users 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 users 失败: %', SQLERRM;
END $$;

-- 所有查询都需要JSONB操作（带性能测试）
EXPLAIN ANALYZE
SELECT * FROM users WHERE data->>'email' = 'user@example.com';
```

### 2.2 问题分析

**主要问题**:

1. **查询性能差**：JSONB字段上的查询无法有效使用索引
2. **数据完整性无法保证**：无法使用CHECK约束、外键等
3. **类型安全缺失**：数据类型无法验证
4. **维护困难**：结构不清晰，难以理解

### 2.3 解决方案

**正确做法**:

```sql
-- 正确做法：结构化表设计（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS users (
        user_id SERIAL PRIMARY KEY,
        email VARCHAR(200) UNIQUE NOT NULL,
        first_name VARCHAR(100),
        last_name VARCHAR(100),
        created_at TIMESTAMPTZ DEFAULT NOW()
    );
    RAISE NOTICE '表 users 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 users 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 users 失败: %', SQLERRM;
END $$;

-- 只在需要灵活扩展时使用JSONB（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS user_preferences (
        user_id INT PRIMARY KEY REFERENCES users(user_id),
        preferences JSONB DEFAULT '{}'  -- 用户偏好设置，结构可能变化
    );
    RAISE NOTICE '表 user_preferences 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 user_preferences 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 user_preferences 失败: %', SQLERRM;
END $$;
```

---

## 3. 无控制的分区

### 3.1 反模式描述

**问题**：盲目创建大量分区，没有考虑查询模式和分区策略。

**典型表现**:

```sql
-- 反模式示例：过度分区（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'orders') THEN
        CREATE TABLE orders (
            order_id BIGSERIAL,
            order_date TIMESTAMPTZ,
            -- ... 其他字段
            PRIMARY KEY (order_id, order_date)
        ) PARTITION BY RANGE (order_date);
        RAISE NOTICE '表 orders 创建成功（反模式示例）';
    ELSE
        RAISE NOTICE '表 orders 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 orders 失败: %', SQLERRM;
END $$;

-- 创建每天一个分区（过度分区）
-- 导致分区数量过多，管理困难
```

### 3.2 问题分析

**主要问题**:

1. **分区数量过多**：导致元数据膨胀
2. **查询性能下降**：分区裁剪效率低
3. **维护成本高**：需要频繁创建/删除分区
4. **资源浪费**：小分区占用过多元数据空间

### 3.3 解决方案

**正确做法**:

```sql
-- 正确做法：合理分区策略（带错误处理）
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE tablename = 'orders') THEN
        CREATE TABLE orders (
            order_id BIGSERIAL,
            order_date TIMESTAMPTZ,
            -- ... 其他字段
            PRIMARY KEY (order_id, order_date)
        ) PARTITION BY RANGE (order_date);
        RAISE NOTICE '表 orders 创建成功';
    ELSE
        RAISE NOTICE '表 orders 已存在，跳过创建';
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 orders 失败: %', SQLERRM;
END $$;

-- 按月分区（根据数据量调整，带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS orders_2025_01 PARTITION OF orders
        FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
    CREATE TABLE IF NOT EXISTS orders_2025_02 PARTITION OF orders
        FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
    RAISE NOTICE '分区创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '分区已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE WARNING '创建分区失败: %', SQLERRM;
END $$;

-- 使用分区管理函数自动创建
CREATE OR REPLACE FUNCTION create_monthly_partition(
    p_table_name TEXT,
    p_start_date DATE
)
RETURNS VOID AS $$
DECLARE
    v_partition_name TEXT;
    v_end_date DATE;
BEGIN
    v_end_date := p_start_date + INTERVAL '1 month';
    v_partition_name := format('%s_%s', p_table_name, to_char(p_start_date, 'YYYY_MM'));

    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
        v_partition_name, p_table_name, p_start_date, v_end_date
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 4. 缺失约束

### 4.1 反模式描述

**问题**：表设计时缺少必要的约束，依赖应用层保证数据完整性。

**典型表现**:

```sql
-- 反模式示例：缺少约束（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS orders (
        order_id INT,
        customer_id INT,
        order_date TIMESTAMPTZ,
        amount NUMERIC(10,2),
        status VARCHAR(50)
        -- 缺少PRIMARY KEY、FOREIGN KEY、CHECK约束
    );
    RAISE NOTICE '表 orders 创建成功（反模式示例）';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 orders 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 orders 失败: %', SQLERRM;
END $$;
```

### 4.2 问题分析

**主要问题**:

1. **数据完整性无法保证**：可能出现重复、无效数据
2. **查询性能差**：缺少索引（PRIMARY KEY自动创建索引）
3. **数据质量低**：无法防止错误数据插入
4. **维护困难**：需要应用层处理所有验证逻辑

### 4.3 解决方案

**正确做法**:

```sql
-- 正确做法：完整的约束设计（带错误处理）
DO $$
BEGIN
    CREATE TABLE IF NOT EXISTS orders (
        order_id BIGSERIAL PRIMARY KEY,
        customer_id INT NOT NULL REFERENCES customers(customer_id),
        order_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        amount NUMERIC(10,2) NOT NULL CHECK (amount > 0),
        status VARCHAR(50) NOT NULL CHECK (status IN ('pending', 'processing', 'completed', 'cancelled')),
        -- 唯一约束
        order_number VARCHAR(50) UNIQUE NOT NULL,
        -- 排除约束（防止重叠）
        CONSTRAINT orders_date_range EXCLUDE USING GIST (
            customer_id WITH =,
            tsrange(order_date, order_date + INTERVAL '1 day') WITH &&
        )
    );
    RAISE NOTICE '表 orders 创建成功';
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表 orders 已存在，跳过创建';
    WHEN OTHERS THEN
        RAISE EXCEPTION '创建表 orders 失败: %', SQLERRM;
END $$;

-- 添加索引（带错误处理）
DO $$
BEGIN
    CREATE INDEX IF NOT EXISTS idx_orders_customer_date ON orders(customer_id, order_date DESC);
    CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status) WHERE status = 'pending';
    RAISE NOTICE '索引创建成功';
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '创建索引失败: %', SQLERRM;
END $$;
```

---

## 5. 过度规范化

### 5.1 反模式描述

**问题**：过度追求规范化，将表拆分得过细，导致查询需要大量JOIN。

**典型表现**:

```sql
-- 反模式示例：过度规范化
CREATE TABLE user_first_name (user_id INT PRIMARY KEY, first_name VARCHAR(100));
CREATE TABLE user_last_name (user_id INT PRIMARY KEY, last_name VARCHAR(100));
CREATE TABLE user_email (user_id INT PRIMARY KEY, email VARCHAR(200));
-- ... 每个属性一个表

-- 查询需要大量JOIN
SELECT u1.first_name, u2.last_name, u3.email
FROM user_first_name u1
JOIN user_last_name u2 ON u1.user_id = u2.user_id
JOIN user_email u3 ON u1.user_id = u3.user_id;
```

### 5.2 问题分析

**主要问题**:

1. **查询性能差**：需要大量JOIN操作
2. **复杂度高**：表结构难以理解
3. **维护困难**：修改需要涉及多个表
4. **资源浪费**：元数据开销大

### 5.3 解决方案

**正确做法**:

```sql
-- 正确做法：适度规范化
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    email VARCHAR(200) UNIQUE NOT NULL,
    phone VARCHAR(50),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 只在必要时拆分（如一对多关系）
CREATE TABLE user_addresses (
    address_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES users(user_id),
    address_type VARCHAR(50), -- 'home', 'work', 'billing'
    street VARCHAR(200),
    city VARCHAR(100),
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE
);
```

---

## 6. 重构策略

### 6.1 识别反模式

**识别方法**:

```sql
-- 检查缺少约束的表
SELECT
    schemaname,
    tablename,
    CASE WHEN pk.constraint_name IS NULL THEN 'Missing PK' END AS missing_pk,
    CASE WHEN fk.constraint_name IS NULL THEN 'Missing FK' END AS missing_fk
FROM pg_tables t
LEFT JOIN (
    SELECT conrelid::regclass::text AS table_name, conname AS constraint_name
    FROM pg_constraint
    WHERE contype = 'p'
) pk ON t.tablename = pk.table_name
WHERE schemaname = 'public';

-- 检查过度使用JSONB的表
SELECT
    tablename,
    attname,
    typname
FROM pg_attribute a
JOIN pg_class c ON a.attrelid = c.oid
JOIN pg_type t ON a.atttypid = t.oid
WHERE typname = 'jsonb'
  AND attnum > 0
  AND NOT attisdropped;

-- 检查分区数量
SELECT
    schemaname,
    tablename,
    COUNT(*) AS partition_count
FROM pg_inherits
JOIN pg_class ON inhparent = pg_class.oid
GROUP BY schemaname, tablename
HAVING COUNT(*) > 100;  -- 分区过多
```

### 6.2 重构步骤

**重构流程**:

1. **评估影响**：分析反模式的影响范围
2. **制定计划**：设计重构方案
3. **数据迁移**：安全迁移数据
4. **验证测试**：确保数据完整性
5. **性能测试**：验证性能提升

### 6.3 重构示例

**添加约束重构**:

```sql
-- 步骤1：检查数据质量
SELECT COUNT(*) FROM orders WHERE order_id IS NULL;
SELECT COUNT(*) FROM orders WHERE customer_id NOT IN (SELECT customer_id FROM customers);

-- 步骤2：清理数据
DELETE FROM orders WHERE order_id IS NULL;
DELETE FROM orders WHERE customer_id NOT IN (SELECT customer_id FROM customers);

-- 步骤3：添加约束
ALTER TABLE orders
    ADD CONSTRAINT orders_pk PRIMARY KEY (order_id),
    ADD CONSTRAINT orders_customer_fk FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    ADD CONSTRAINT orders_amount_check CHECK (amount > 0);

-- 步骤4：添加索引
CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_orders_date ON orders(order_date DESC);
```

### 6.4 重构最佳实践

**重构原则**:

1. **渐进式重构**：分阶段进行，避免大爆炸式变更
2. **数据备份**：重构前完整备份数据
3. **测试验证**：充分测试重构后的功能
4. **文档更新**：更新相关文档
5. **性能监控**：监控重构后的性能指标

---

## 7. 更多反模式案例 / More Anti-Pattern Examples

### 7.1 案例1: 过度使用触发器

**反模式描述**:

```sql
-- ❌ 反模式：为每个操作创建触发器
CREATE TRIGGER trigger_update_timestamp AFTER UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_timestamp();
CREATE TRIGGER trigger_update_timestamp AFTER UPDATE ON orders FOR EACH ROW EXECUTE FUNCTION update_timestamp();
CREATE TRIGGER trigger_update_timestamp AFTER UPDATE ON products FOR EACH ROW EXECUTE FUNCTION update_timestamp();
-- ... 为每个表都创建触发器

-- ❌ 反模式：触发器嵌套调用
CREATE TRIGGER trigger_after_order AFTER INSERT ON orders
FOR EACH ROW EXECUTE FUNCTION process_order();  -- 这个函数又触发其他触发器

-- ❌ 反模式：触发器执行复杂业务逻辑
CREATE TRIGGER trigger_complex_logic AFTER INSERT ON orders
FOR EACH ROW EXECUTE FUNCTION complex_business_logic();  -- 函数包含大量业务逻辑
```

**问题分析**:

- **性能问题**: 触发器会增加每次DML操作的开销
- **调试困难**: 触发器逻辑难以追踪和调试
- **维护复杂**: 触发器之间的依赖关系复杂
- **测试困难**: 触发器逻辑难以单独测试

**解决方案**:

```sql
-- ✅ 正确：使用DEFAULT值
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50),
    updated_at TIMESTAMPTZ DEFAULT NOW()  -- 使用DEFAULT
);

-- ✅ 正确：使用应用层逻辑处理复杂业务
-- 在应用代码中处理业务逻辑，而不是在触发器中

-- ✅ 正确：仅在必要时使用触发器（如审计日志）
CREATE TRIGGER trigger_audit_log AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION log_audit();  -- 仅用于审计
```

### 7.2 案例2: 缺少索引设计

**反模式描述**:

```sql
-- ❌ 反模式：没有为外键创建索引
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL REFERENCES customers(customer_id),  -- 没有索引
    order_date DATE NOT NULL  -- 没有索引
);

-- ❌ 反模式：没有为WHERE条件创建索引
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    category_id INT NOT NULL,  -- WHERE category_id = ? 但没有索引
    status VARCHAR(20),  -- WHERE status = 'active' 但没有索引
    price NUMERIC(10,2)
);

-- ❌ 反模式：创建过多索引
CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);
CREATE INDEX idx_orders_date_customer ON orders(order_date, customer_id);  -- 重复索引
CREATE INDEX idx_orders_customer_status ON orders(customer_id, status);
CREATE INDEX idx_orders_status ON orders(status);
-- 索引过多，写入性能下降
```

**问题分析**:

- **查询性能差**: 缺少索引导致全表扫描
- **写入性能差**: 索引过多导致写入变慢
- **存储浪费**: 不必要的索引占用存储空间

**解决方案**:

```sql
-- ✅ 正确：为外键创建索引
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL REFERENCES customers(customer_id)
);
CREATE INDEX idx_orders_customer ON orders(customer_id);  -- 外键索引

-- ✅ 正确：为常用查询创建索引
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_status ON products(status) WHERE status = 'active';  -- 部分索引

-- ✅ 正确：删除未使用的索引
SELECT indexname FROM pg_stat_user_indexes WHERE idx_scan = 0;
DROP INDEX idx_unused_index;
```

### 7.3 案例3: 数据类型选择错误

**反模式描述**:

```sql
-- ❌ 反模式：金融金额使用浮点类型
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    amount DOUBLE PRECISION  -- 精度损失
);

-- ❌ 反模式：时间戳不使用时区
CREATE TABLE events (
    event_id BIGSERIAL PRIMARY KEY,
    created_at TIMESTAMP  -- 时区问题
);

-- ❌ 反模式：文本字段使用VARCHAR限制过小
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    description VARCHAR(100)  -- 可能截断
);

-- ❌ 反模式：使用TEXT存储结构化数据
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    profile TEXT  -- 应该使用JSONB
);
```

**问题分析**:

- **数据精度**: 浮点类型导致精度损失
- **时区问题**: 无时区时间戳导致时区混乱
- **数据截断**: VARCHAR限制过小导致数据丢失
- **查询困难**: TEXT存储结构化数据难以查询

**解决方案**:

```sql
-- ✅ 正确：金融金额使用NUMERIC
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    amount NUMERIC(10,2)  -- 精确计算
);

-- ✅ 正确：时间戳使用时区
CREATE TABLE events (
    event_id BIGSERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ  -- 自动处理时区
);

-- ✅ 正确：文本字段使用TEXT
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    description TEXT  -- 无限制
);

-- ✅ 正确：结构化数据使用JSONB
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    profile JSONB  -- 支持查询和索引
);
CREATE INDEX idx_users_profile ON users USING GIN (profile);
```

---

## 8. 常见问题解答 / FAQ

### Q1: 如何识别反模式？

**A**: 识别方法：

1. **性能问题**: 查询慢、写入慢
2. **数据质量问题**: 数据不一致、精度丢失
3. **维护困难**: 代码复杂、难以理解
4. **扩展性差**: 难以适应业务变化

**识别工具**:

```sql
-- 检查未使用的索引
SELECT indexname FROM pg_stat_user_indexes WHERE idx_scan = 0;

-- 检查慢查询
SELECT * FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 10;

-- 检查缺少约束的表
SELECT tablename FROM pg_tables
WHERE schemaname = 'public'
  AND tablename NOT IN (
    SELECT DISTINCT tablename FROM pg_constraints WHERE contype = 'p'
  );
```

### Q2: 反模式重构的优先级如何确定？

**A**: 优先级原则：

1. **P0 - 数据完整性**: 缺失约束、数据类型错误
2. **P1 - 性能问题**: 缺少索引、过度分区
3. **P2 - 代码质量**: 过度使用触发器、复杂视图
4. **P3 - 可维护性**: 命名不规范、缺少文档

**评估矩阵**:

| 反模式 | 影响范围 | 修复难度 | 优先级 |
|--------|---------|---------|--------|
| 缺失约束 | 高 | 中 | P0 |
| 缺少索引 | 高 | 低 | P1 |
| 过度使用触发器 | 中 | 高 | P2 |
| 命名不规范 | 低 | 低 | P3 |

### Q3: 如何安全地重构反模式？

**A**: 安全重构步骤：

1. **备份数据**: 完整备份数据库
2. **创建测试环境**: 在测试环境验证重构
3. **分阶段重构**: 逐步重构，不要一次性改动太多
4. **监控性能**: 重构后监控性能变化
5. **回滚计划**: 准备回滚方案

```sql
-- 重构示例：添加缺失的索引
-- 步骤1：在测试环境测试
CREATE INDEX CONCURRENTLY idx_test_orders_customer ON orders(customer_id);

-- 步骤2：验证查询性能
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;

-- 步骤3：在生产环境执行
CREATE INDEX CONCURRENTLY idx_orders_customer ON orders(customer_id);
```

### Q4: 如何避免引入新的反模式？

**A**: 预防策略：

1. **代码审查**: 定期审查数据库设计
2. **设计规范**: 遵循数据库设计规范
3. **性能测试**: 定期进行性能测试
4. **监控告警**: 设置性能监控告警

**检查清单**:

- [ ] 所有外键都有索引
- [ ] WHERE条件中的列都有索引
- [ ] 金融金额使用NUMERIC类型
- [ ] 时间戳使用TIMESTAMPTZ
- [ ] 文本字段使用TEXT（除非需要长度限制）
- [ ] 避免过度使用触发器
- [ ] 避免过度分区
- [ ] 避免过度使用JSONB

### Q5: 反模式重构后如何验证？

**A**: 验证方法：

```sql
-- 验证1：查询性能对比
-- 重构前
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;
-- Seq Scan: 1000ms

-- 重构后（添加索引）
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;
-- Index Scan: 5ms

-- 验证2：数据完整性检查
SELECT COUNT(*) FROM orders WHERE amount < 0;  -- 应该为0（添加CHECK约束后）

-- 验证3：索引使用情况
SELECT indexname, idx_scan FROM pg_stat_user_indexes
WHERE tablename = 'orders';
```

---

## 8. 相关资源 / Related Resources

### 8.1 核心相关文档 / Core Related Documents

- [常见建模模式](./常见建模模式.md) - 正确的建模模式
- [约束设计](../08-PostgreSQL建模实践/约束设计.md) - 约束设计指南
- [分区策略](../08-PostgreSQL建模实践/分区策略.md) - 分区策略指南
- [数据类型选择](../08-PostgreSQL建模实践/数据类型选择.md) - 数据类型选择指南
- [索引策略](../08-PostgreSQL建模实践/索引策略.md) - 索引设计指南
- [性能优化](../08-PostgreSQL建模实践/性能优化.md) - 性能优化指南

### 8.2 理论基础 / Theoretical Foundation

- [范式理论](../01-数据建模理论基础/范式理论.md) - 数据库范式理论
- [约束理论](../01-数据建模理论基础/约束理论.md) - 完整性约束理论

### 8.3 实践指南 / Practical Guides

- [更多反模式案例](#7-更多反模式案例--more-anti-pattern-examples) - 本文档的反模式案例章节
- [常见问题解答](#8-常见问题解答--faq) - 本文档的FAQ章节

### 8.4 应用案例 / Application Cases

- [电商数据模型案例](../10-综合应用案例/电商数据模型案例.md) - 电商反模式案例
- [金融数据模型案例](../10-综合应用案例/金融数据模型案例.md) - 金融反模式案例

### 8.5 参考资源 / Reference Resources

- [权威资源索引](../00-导航与索引/权威资源索引.md) - 权威资源列表
- [术语对照表](../00-导航与索引/术语对照表.md) - 术语对照
- [快速查找指南](../00-导航与索引/快速查找指南.md) - 快速查找工具

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
