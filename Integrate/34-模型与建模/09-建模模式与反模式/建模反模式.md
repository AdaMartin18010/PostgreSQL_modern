# 建模反模式

> **创建日期**: 2025年1月
> **来源**: 数据建模反模式研究
> **状态**: 待完善
> **文档编号**: 09-02

---

## 📑 目录

- [建模反模式](#建模反模式)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 过度使用JSONB](#2-过度使用jsonb)
    - [2.1 反模式描述](#21-反模式描述)
    - [2.2 问题分析](#22-问题分析)
    - [2.3 解决方案](#23-解决方案)
  - [3. 无控制的分区](#3-无控制的分区)
    - [3.1 反模式描述](#31-反模式描述)
    - [3.2 问题分析](#32-问题分析)
    - [3.3 解决方案](#33-解决方案)
  - [4. 缺失约束](#4-缺失约束)
    - [4.1 反模式描述](#41-反模式描述)
    - [4.2 问题分析](#42-问题分析)
    - [4.3 解决方案](#43-解决方案)
  - [5. 过度规范化](#5-过度规范化)
    - [5.1 反模式描述](#51-反模式描述)
    - [5.2 问题分析](#52-问题分析)
    - [5.3 解决方案](#53-解决方案)
  - [6. 重构策略](#6-重构策略)
    - [6.1 识别反模式](#61-识别反模式)
    - [6.2 重构步骤](#62-重构步骤)
    - [6.3 重构示例](#63-重构示例)
    - [6.4 重构最佳实践](#64-重构最佳实践)
  - [7. 相关资源](#7-相关资源)

---

## 1. 概述

建模反模式是常见但错误的数据建模实践，识别和避免这些反模式对系统质量至关重要。
反模式虽然看似解决了问题，但会带来长期的技术债务和维护成本。

**核心危害**:

- **性能问题**：导致查询性能下降
- **数据质量**：数据完整性无法保证
- **维护困难**：增加系统复杂度
- **扩展性差**：难以适应业务变化

---

## 2. 过度使用JSONB

### 2.1 反模式描述

**问题**：将所有数据都存储在JSONB字段中，放弃关系型数据库的结构化优势。

**典型表现**:

```sql
-- 反模式示例：过度使用JSONB
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    data JSONB  -- 所有用户数据都在JSONB中
);

-- 所有查询都需要JSONB操作
SELECT * FROM users WHERE data->>'email' = 'user@example.com';
```

### 2.2 问题分析

**主要问题**:

1. **查询性能差**：JSONB字段上的查询无法有效使用索引
2. **数据完整性无法保证**：无法使用CHECK约束、外键等
3. **类型安全缺失**：数据类型无法验证
4. **维护困难**：结构不清晰，难以理解

### 2.3 解决方案

**正确做法**:

```sql
-- 正确做法：结构化表设计
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email VARCHAR(200) UNIQUE NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 只在需要灵活扩展时使用JSONB
CREATE TABLE user_preferences (
    user_id INT PRIMARY KEY REFERENCES users(user_id),
    preferences JSONB DEFAULT '{}'  -- 用户偏好设置，结构可能变化
);
```

---

## 3. 无控制的分区

### 3.1 反模式描述

**问题**：盲目创建大量分区，没有考虑查询模式和分区策略。

**典型表现**:

```sql
-- 反模式示例：过度分区
CREATE TABLE orders (
    order_id BIGSERIAL,
    order_date TIMESTAMPTZ,
    -- ... 其他字段
) PARTITION BY RANGE (order_date);

-- 创建每天一个分区（过度分区）
-- 导致分区数量过多，管理困难
```

### 3.2 问题分析

**主要问题**:

1. **分区数量过多**：导致元数据膨胀
2. **查询性能下降**：分区裁剪效率低
3. **维护成本高**：需要频繁创建/删除分区
4. **资源浪费**：小分区占用过多元数据空间

### 3.3 解决方案

**正确做法**:

```sql
-- 正确做法：合理分区策略
CREATE TABLE orders (
    order_id BIGSERIAL,
    order_date TIMESTAMPTZ,
    -- ... 其他字段
) PARTITION BY RANGE (order_date);

-- 按月分区（根据数据量调整）
CREATE TABLE orders_2025_01 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE orders_2025_02 PARTITION OF orders
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- 使用分区管理函数自动创建
CREATE OR REPLACE FUNCTION create_monthly_partition(
    p_table_name TEXT,
    p_start_date DATE
)
RETURNS VOID AS $$
DECLARE
    v_partition_name TEXT;
    v_end_date DATE;
BEGIN
    v_end_date := p_start_date + INTERVAL '1 month';
    v_partition_name := format('%s_%s', p_table_name, to_char(p_start_date, 'YYYY_MM'));

    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
        v_partition_name, p_table_name, p_start_date, v_end_date
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 4. 缺失约束

### 4.1 反模式描述

**问题**：表设计时缺少必要的约束，依赖应用层保证数据完整性。

**典型表现**:

```sql
-- 反模式示例：缺少约束
CREATE TABLE orders (
    order_id INT,
    customer_id INT,
    order_date TIMESTAMPTZ,
    amount NUMERIC(10,2),
    status VARCHAR(50)
    -- 缺少PRIMARY KEY、FOREIGN KEY、CHECK约束
);
```

### 4.2 问题分析

**主要问题**:

1. **数据完整性无法保证**：可能出现重复、无效数据
2. **查询性能差**：缺少索引（PRIMARY KEY自动创建索引）
3. **数据质量低**：无法防止错误数据插入
4. **维护困难**：需要应用层处理所有验证逻辑

### 4.3 解决方案

**正确做法**:

```sql
-- 正确做法：完整的约束设计
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id INT NOT NULL REFERENCES customers(customer_id),
    order_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    amount NUMERIC(10,2) NOT NULL CHECK (amount > 0),
    status VARCHAR(50) NOT NULL CHECK (status IN ('pending', 'processing', 'completed', 'cancelled')),
    -- 唯一约束
    order_number VARCHAR(50) UNIQUE NOT NULL,
    -- 排除约束（防止重叠）
    CONSTRAINT orders_date_range EXCLUDE USING GIST (
        customer_id WITH =,
        tsrange(order_date, order_date + INTERVAL '1 day') WITH &&
    )
);

-- 添加索引
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date DESC);
CREATE INDEX idx_orders_status ON orders(status) WHERE status = 'pending';
```

---

## 5. 过度规范化

### 5.1 反模式描述

**问题**：过度追求规范化，将表拆分得过细，导致查询需要大量JOIN。

**典型表现**:

```sql
-- 反模式示例：过度规范化
CREATE TABLE user_first_name (user_id INT PRIMARY KEY, first_name VARCHAR(100));
CREATE TABLE user_last_name (user_id INT PRIMARY KEY, last_name VARCHAR(100));
CREATE TABLE user_email (user_id INT PRIMARY KEY, email VARCHAR(200));
-- ... 每个属性一个表

-- 查询需要大量JOIN
SELECT u1.first_name, u2.last_name, u3.email
FROM user_first_name u1
JOIN user_last_name u2 ON u1.user_id = u2.user_id
JOIN user_email u3 ON u1.user_id = u3.user_id;
```

### 5.2 问题分析

**主要问题**:

1. **查询性能差**：需要大量JOIN操作
2. **复杂度高**：表结构难以理解
3. **维护困难**：修改需要涉及多个表
4. **资源浪费**：元数据开销大

### 5.3 解决方案

**正确做法**:

```sql
-- 正确做法：适度规范化
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    email VARCHAR(200) UNIQUE NOT NULL,
    phone VARCHAR(50),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 只在必要时拆分（如一对多关系）
CREATE TABLE user_addresses (
    address_id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES users(user_id),
    address_type VARCHAR(50), -- 'home', 'work', 'billing'
    street VARCHAR(200),
    city VARCHAR(100),
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE
);
```

---

## 6. 重构策略

### 6.1 识别反模式

**识别方法**:

```sql
-- 检查缺少约束的表
SELECT
    schemaname,
    tablename,
    CASE WHEN pk.constraint_name IS NULL THEN 'Missing PK' END AS missing_pk,
    CASE WHEN fk.constraint_name IS NULL THEN 'Missing FK' END AS missing_fk
FROM pg_tables t
LEFT JOIN (
    SELECT conrelid::regclass::text AS table_name, conname AS constraint_name
    FROM pg_constraint
    WHERE contype = 'p'
) pk ON t.tablename = pk.table_name
WHERE schemaname = 'public';

-- 检查过度使用JSONB的表
SELECT
    tablename,
    attname,
    typname
FROM pg_attribute a
JOIN pg_class c ON a.attrelid = c.oid
JOIN pg_type t ON a.atttypid = t.oid
WHERE typname = 'jsonb'
  AND attnum > 0
  AND NOT attisdropped;

-- 检查分区数量
SELECT
    schemaname,
    tablename,
    COUNT(*) AS partition_count
FROM pg_inherits
JOIN pg_class ON inhparent = pg_class.oid
GROUP BY schemaname, tablename
HAVING COUNT(*) > 100;  -- 分区过多
```

### 6.2 重构步骤

**重构流程**:

1. **评估影响**：分析反模式的影响范围
2. **制定计划**：设计重构方案
3. **数据迁移**：安全迁移数据
4. **验证测试**：确保数据完整性
5. **性能测试**：验证性能提升

### 6.3 重构示例

**添加约束重构**:

```sql
-- 步骤1：检查数据质量
SELECT COUNT(*) FROM orders WHERE order_id IS NULL;
SELECT COUNT(*) FROM orders WHERE customer_id NOT IN (SELECT customer_id FROM customers);

-- 步骤2：清理数据
DELETE FROM orders WHERE order_id IS NULL;
DELETE FROM orders WHERE customer_id NOT IN (SELECT customer_id FROM customers);

-- 步骤3：添加约束
ALTER TABLE orders
    ADD CONSTRAINT orders_pk PRIMARY KEY (order_id),
    ADD CONSTRAINT orders_customer_fk FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    ADD CONSTRAINT orders_amount_check CHECK (amount > 0);

-- 步骤4：添加索引
CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_orders_date ON orders(order_date DESC);
```

### 6.4 重构最佳实践

**重构原则**:

1. **渐进式重构**：分阶段进行，避免大爆炸式变更
2. **数据备份**：重构前完整备份数据
3. **测试验证**：充分测试重构后的功能
4. **文档更新**：更新相关文档
5. **性能监控**：监控重构后的性能指标

---

## 7. 相关资源

- [常见建模模式](./常见建模模式.md) - 正确的建模模式
- [约束设计](../08-PostgreSQL建模实践/约束设计.md) - 约束设计指南
- [分区策略](../08-PostgreSQL建模实践/分区策略.md) - 分区策略指南
- [数据类型选择](../08-PostgreSQL建模实践/数据类型选择.md) - 数据类型选择指南

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
