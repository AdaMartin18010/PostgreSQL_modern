# æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-å·¥ä½œæµå¼•æ“ä¸çŠ¶æ€ç®¡ç†çš„å½¢å¼åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-å·¥ä½œæµå¼•æ“ä¸çŠ¶æ€ç®¡ç†çš„å½¢å¼åŒ–](#æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-å·¥ä½œæµå¼•æ“ä¸çŠ¶æ€ç®¡ç†çš„å½¢å¼åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°](#10-æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 çŠ¶æ€ç®¡ç†](#21-çŠ¶æ€ç®¡ç†)
      - [2.1.1 çŠ¶æ€æœºæ¨¡å‹](#211-çŠ¶æ€æœºæ¨¡å‹)
      - [2.1.2 çŠ¶æ€æŒä¹…åŒ–](#212-çŠ¶æ€æŒä¹…åŒ–)
    - [2.2 å·¥ä½œæµæ‰§è¡Œ](#22-å·¥ä½œæµæ‰§è¡Œ)
      - [2.2.1 æ‰§è¡Œæ¨¡å‹](#221-æ‰§è¡Œæ¨¡å‹)
      - [2.2.2 ä»»åŠ¡è°ƒåº¦](#222-ä»»åŠ¡è°ƒåº¦)
      - [2.2.3 æ¡ä»¶åˆ†æ”¯å’Œå¾ªç¯æ§åˆ¶](#223-æ¡ä»¶åˆ†æ”¯å’Œå¾ªç¯æ§åˆ¶)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 å·¥ä½œæµå½¢å¼åŒ–](#31-å·¥ä½œæµå½¢å¼åŒ–)
      - [3.1.1 å·¥ä½œæµçŠ¶æ€æœºå½¢å¼åŒ–](#311-å·¥ä½œæµçŠ¶æ€æœºå½¢å¼åŒ–)
      - [3.1.2 çŠ¶æ€è½¬æ¢è¯­ä¹‰](#312-çŠ¶æ€è½¬æ¢è¯­ä¹‰)
      - [3.1.3 çŠ¶æ€æŒä¹…åŒ–è¯­ä¹‰](#313-çŠ¶æ€æŒä¹…åŒ–è¯­ä¹‰)
  - [4. å®šç†ä¸è¯æ˜](#4-å®šç†ä¸è¯æ˜)
    - [4.1 çŠ¶æ€è½¬æ¢ç¡®å®šæ€§å®šç†](#41-çŠ¶æ€è½¬æ¢ç¡®å®šæ€§å®šç†)
    - [4.2 çŠ¶æ€å¯è¾¾æ€§å®šç†](#42-çŠ¶æ€å¯è¾¾æ€§å®šç†)
    - [4.3 çŠ¶æ€æŒä¹…åŒ–ä¸€è‡´æ€§å®šç†](#43-çŠ¶æ€æŒä¹…åŒ–ä¸€è‡´æ€§å®šç†)
  - [5. å®é™…åº”ç”¨](#5-å®é™…åº”ç”¨)
    - [5.1 PostgreSQL 18å·¥ä½œæµå¼•æ“å®ç°](#51-postgresql-18å·¥ä½œæµå¼•æ“å®ç°)
      - [5.1.1 å®Œæ•´å·¥ä½œæµçŠ¶æ€ç®¡ç†å®ç°](#511-å®Œæ•´å·¥ä½œæµçŠ¶æ€ç®¡ç†å®ç°)
      - [5.1.2 çŠ¶æ€è½¬æ¢å‡½æ•°å®ç°](#512-çŠ¶æ€è½¬æ¢å‡½æ•°å®ç°)
      - [5.1.3 çŠ¶æ€æ¢å¤æœºåˆ¶](#513-çŠ¶æ€æ¢å¤æœºåˆ¶)
    - [5.2 å®é™…åº”ç”¨åœºæ™¯](#52-å®é™…åº”ç”¨åœºæ™¯)
      - [åœºæ™¯1ï¼šETLæ•°æ®ç®¡é“å·¥ä½œæµ](#åœºæ™¯1etlæ•°æ®ç®¡é“å·¥ä½œæµ)
      - [åœºæ™¯2ï¼šè®¢å•å¤„ç†å·¥ä½œæµ](#åœºæ™¯2è®¢å•å¤„ç†å·¥ä½œæµ)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)
    - [5.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#51-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [6. å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)
    - [6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#61-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [6.2 PostgreSQLå®ç°ç›¸å…³](#62-postgresqlå®ç°ç›¸å…³)
    - [6.3 ç›¸å…³æ–‡æ¡£](#63-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°

**å·¥ä½œæµå¼•æ“**ï¼š

å·¥ä½œæµå¼•æ“æ˜¯æ•°æ®ç¼–æ’ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ç®¡ç†æ•°æ®å¤„ç†çš„æ‰§è¡Œæµç¨‹å’ŒçŠ¶æ€ã€‚å®ƒé€šè¿‡çŠ¶æ€æœºæ¨¡å‹æ¥è·Ÿè¸ªå·¥ä½œæµçš„æ‰§è¡ŒçŠ¶æ€ï¼Œç¡®ä¿æ•°æ®å¤„ç†çš„æ­£ç¡®æ€§å’Œå¯æ¢å¤æ€§ã€‚

**æ ¸å¿ƒå·¥ä½œåŸç†**ï¼š

1. **çŠ¶æ€æœºæ¨¡å‹**ï¼šå·¥ä½œæµè¢«å»ºæ¨¡ä¸ºæœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰ï¼Œæ¯ä¸ªçŠ¶æ€ä»£è¡¨å·¥ä½œæµæ‰§è¡Œçš„ä¸€ä¸ªé˜¶æ®µ
2. **çŠ¶æ€è½¬æ¢**ï¼šé€šè¿‡äº‹ä»¶è§¦å‘çŠ¶æ€è½¬æ¢ï¼Œç¡®ä¿çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§å’Œä¸€è‡´æ€§
3. **çŠ¶æ€æŒä¹…åŒ–**ï¼šå°†å·¥ä½œæµçŠ¶æ€æŒä¹…åŒ–åˆ°æ•°æ®åº“ï¼Œæ”¯æŒæ•…éšœæ¢å¤å’ŒçŠ¶æ€æŸ¥è¯¢
4. **ä»»åŠ¡è°ƒåº¦**ï¼šæ ¹æ®å·¥ä½œæµå®šä¹‰å’Œå½“å‰çŠ¶æ€ï¼Œè°ƒåº¦å’Œæ‰§è¡Œç›¸åº”çš„ä»»åŠ¡
5. **å®¹é”™æœºåˆ¶**ï¼šé€šè¿‡çŠ¶æ€æ£€æŸ¥ç‚¹å’Œå›æ»šæœºåˆ¶ï¼Œç¡®ä¿å·¥ä½œæµçš„å¯é æ‰§è¡Œ

**å·¥ä½œæµæ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((å·¥ä½œæµå¼•æ“))
    çŠ¶æ€ç®¡ç†
      çŠ¶æ€æœºæ¨¡å‹
        æœ‰é™çŠ¶æ€æœºFSM
        çŠ¶æ€é›†åˆ
        è½¬æ¢å‡½æ•°
      çŠ¶æ€è½¬æ¢
        äº‹ä»¶é©±åŠ¨
        è½¬æ¢è§„åˆ™
        è½¬æ¢éªŒè¯
      çŠ¶æ€æŒä¹…åŒ–
        æ•°æ®åº“å­˜å‚¨
        çŠ¶æ€å¿«ç…§
        æ¢å¤æœºåˆ¶
    å·¥ä½œæµæ‰§è¡Œ
      ä»»åŠ¡æ‰§è¡Œ
        ä»»åŠ¡è°ƒåº¦
        ä»»åŠ¡ç›‘æ§
        ä»»åŠ¡é‡è¯•
      æ¡ä»¶åˆ†æ”¯
        æ¡ä»¶åˆ¤æ–­
        åˆ†æ”¯é€‰æ‹©
        è·¯å¾„è¿½è¸ª
      å¾ªç¯æ§åˆ¶
        å¾ªç¯æ£€æµ‹
        å¾ªç¯ç»ˆæ­¢
        å¾ªç¯ä¼˜åŒ–
    å¼•æ“ç‰¹æ€§
      å®¹é”™
        æ•…éšœæ£€æµ‹
        è‡ªåŠ¨æ¢å¤
        çŠ¶æ€å›æ»š
      å¯æ¢å¤
        æ£€æŸ¥ç‚¹æœºåˆ¶
        çŠ¶æ€æ¢å¤
        æ–­ç‚¹ç»­ä¼ 
      å¯è§‚æµ‹
        çŠ¶æ€ç›‘æ§
        æ‰§è¡Œæ—¥å¿—
        æ€§èƒ½åˆ†æ
```

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **å·¥ä½œæµå¼•æ“**ï¼šå·¥ä½œæµæ‰§è¡Œå¼•æ“çš„æ¶æ„å’Œå®ç°
- **çŠ¶æ€ç®¡ç†**ï¼šçŠ¶æ€æœºæ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰å’Œå®ç°
- **çŠ¶æ€è½¬æ¢**ï¼šçŠ¶æ€è½¬æ¢çš„è¯­ä¹‰å’ŒéªŒè¯è§„åˆ™
- **å®¹é”™æœºåˆ¶**ï¼šæ•…éšœæ£€æµ‹å’Œæ¢å¤æœºåˆ¶
- **å®é™…åº”ç”¨**ï¼šPostgreSQL 18ä¸­çš„å·¥ä½œæµç³»ç»Ÿå®ç°æ¡ˆä¾‹

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 çŠ¶æ€ç®¡ç†

#### 2.1.1 çŠ¶æ€æœºæ¨¡å‹

å·¥ä½œæµå¼•æ“ä½¿ç”¨æœ‰é™çŠ¶æ€æœºï¼ˆFinite State Machine, FSMï¼‰æ¥å»ºæ¨¡å·¥ä½œæµçš„æ‰§è¡ŒçŠ¶æ€ã€‚

**çŠ¶æ€æœºå®šä¹‰**ï¼š

```haskell
-- çŠ¶æ€æœºç±»å‹å®šä¹‰
data State = Pending | Running | Paused | Completed | Failed | Cancelled
    deriving (Eq, Show, Ord)

data Event = Start | Pause | Resume | Complete | Fail | Cancel
    deriving (Eq, Show)

-- çŠ¶æ€æœºç»“æ„
data StateMachine = StateMachine {
    states :: Set State,                    -- çŠ¶æ€é›†åˆ
    transitions :: Map (State, Event) State, -- è½¬æ¢å‡½æ•°
    currentState :: State,                  -- å½“å‰çŠ¶æ€
    initialState :: State,                  -- åˆå§‹çŠ¶æ€
    finalStates :: Set State                -- ç»ˆæ­¢çŠ¶æ€é›†åˆ
}

-- çŠ¶æ€è½¬æ¢å‡½æ•°
transition :: StateMachine -> Event -> Maybe StateMachine
transition sm evt = case Map.lookup (currentState sm, evt) (transitions sm) of
    Just newState -> Just sm { currentState = newState }
    Nothing -> Nothing  -- æ— æ•ˆè½¬æ¢
```

**çŠ¶æ€è½¬æ¢è§„åˆ™**ï¼š

| å½“å‰çŠ¶æ€ | äº‹ä»¶ | ä¸‹ä¸€çŠ¶æ€ | è¯´æ˜ |
|---------|------|---------|------|
| **Pending** | Start | Running | å¼€å§‹æ‰§è¡Œå·¥ä½œæµ |
| **Running** | Pause | Paused | æš‚åœå·¥ä½œæµæ‰§è¡Œ |
| **Running** | Complete | Completed | å·¥ä½œæµæˆåŠŸå®Œæˆ |
| **Running** | Fail | Failed | å·¥ä½œæµæ‰§è¡Œå¤±è´¥ |
| **Running** | Cancel | Cancelled | å–æ¶ˆå·¥ä½œæµæ‰§è¡Œ |
| **Paused** | Resume | Running | æ¢å¤å·¥ä½œæµæ‰§è¡Œ |
| **Paused** | Cancel | Cancelled | å–æ¶ˆæš‚åœçš„å·¥ä½œæµ |
| **Failed** | Start | Running | é‡æ–°æ‰§è¡Œå¤±è´¥çš„å·¥ä½œæµ |

#### 2.1.2 çŠ¶æ€æŒä¹…åŒ–

çŠ¶æ€æŒä¹…åŒ–ç¡®ä¿å·¥ä½œæµçŠ¶æ€åœ¨ç³»ç»Ÿæ•…éšœåå¯ä»¥æ¢å¤ã€‚

**æŒä¹…åŒ–ç­–ç•¥**ï¼š

1. **æ£€æŸ¥ç‚¹æœºåˆ¶**ï¼šå®šæœŸä¿å­˜å·¥ä½œæµçŠ¶æ€åˆ°æ•°æ®åº“
2. **çŠ¶æ€å¿«ç…§**ï¼šä¿å­˜å®Œæ•´çš„çŠ¶æ€ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä¸Šä¸‹æ–‡æ•°æ®
3. **çŠ¶æ€å†å²**ï¼šè®°å½•æ‰€æœ‰çŠ¶æ€è½¬æ¢å†å²ï¼Œæ”¯æŒå®¡è®¡å’Œå›æ»š

**çŠ¶æ€æŒä¹…åŒ–æ•°æ®ç»“æ„**ï¼š

```sql
-- å·¥ä½œæµçŠ¶æ€è¡¨
CREATE TABLE workflow_states (
    workflow_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_name VARCHAR(100) NOT NULL,
    current_state VARCHAR(50) NOT NULL,
    state_data JSONB,  -- çŠ¶æ€ä¸Šä¸‹æ–‡æ•°æ®
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    version INTEGER DEFAULT 1  -- ä¹è§‚é”ç‰ˆæœ¬å·
);

-- çŠ¶æ€è½¬æ¢å†å²è¡¨
CREATE TABLE workflow_state_history (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES workflow_states(workflow_id),
    from_state VARCHAR(50),
    to_state VARCHAR(50) NOT NULL,
    event VARCHAR(50) NOT NULL,
    transition_time TIMESTAMPTZ DEFAULT NOW(),
    context_data JSONB,
    triggered_by VARCHAR(100)  -- è§¦å‘è€…ä¿¡æ¯
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_workflow_states_state ON workflow_states(current_state);
CREATE INDEX idx_workflow_states_updated ON workflow_states(updated_at);
CREATE INDEX idx_workflow_history_workflow ON workflow_state_history(workflow_id);
CREATE INDEX idx_workflow_history_time ON workflow_state_history(transition_time);
```

### 2.2 å·¥ä½œæµæ‰§è¡Œ

#### 2.2.1 æ‰§è¡Œæ¨¡å‹

å·¥ä½œæµæ‰§è¡Œéµå¾ªçŠ¶æ€æœºæ¨¡å‹ï¼Œé€šè¿‡äº‹ä»¶é©±åŠ¨çŠ¶æ€è½¬æ¢ã€‚

**æ‰§è¡Œé˜¶æ®µ**ï¼š

| é˜¶æ®µ | æ“ä½œ | çŠ¶æ€ | è¯´æ˜ |
|------|------|------|------|
| **åˆå§‹åŒ–** | åˆ›å»ºå·¥ä½œæµå®ä¾‹ | Pending | å·¥ä½œæµå·²åˆ›å»ºï¼Œç­‰å¾…å¯åŠ¨ |
| **å¯åŠ¨** | è§¦å‘Startäº‹ä»¶ | Running | å·¥ä½œæµå¼€å§‹æ‰§è¡Œ |
| **æ‰§è¡Œ** | è¿è¡Œä»»åŠ¡èŠ‚ç‚¹ | Running | æ‰§è¡Œå·¥ä½œæµä¸­çš„ä»»åŠ¡ |
| **æš‚åœ** | è§¦å‘Pauseäº‹ä»¶ | Paused | å·¥ä½œæµæ‰§è¡Œè¢«æš‚åœ |
| **æ¢å¤** | è§¦å‘Resumeäº‹ä»¶ | Running | ä»æš‚åœçŠ¶æ€æ¢å¤æ‰§è¡Œ |
| **å®Œæˆ** | è§¦å‘Completeäº‹ä»¶ | Completed | æ‰€æœ‰ä»»åŠ¡æˆåŠŸå®Œæˆ |
| **å¤±è´¥** | è§¦å‘Failäº‹ä»¶ | Failed | ä»»åŠ¡æ‰§è¡Œå¤±è´¥ |
| **å–æ¶ˆ** | è§¦å‘Canceläº‹ä»¶ | Cancelled | å·¥ä½œæµè¢«å–æ¶ˆ |

#### 2.2.2 ä»»åŠ¡è°ƒåº¦

å·¥ä½œæµå¼•æ“æ ¹æ®å·¥ä½œæµå®šä¹‰å’Œå½“å‰çŠ¶æ€è°ƒåº¦ä»»åŠ¡æ‰§è¡Œã€‚

**è°ƒåº¦ç®—æ³•**ï¼š

```haskell
-- ä»»åŠ¡è°ƒåº¦å‡½æ•°
scheduleTasks :: Workflow -> State -> [Task]
scheduleTasks workflow state =
    filter (canExecute workflow state) (tasks workflow)
    where
        canExecute wf st task =
            all (isCompleted wf st) (dependencies task) &&
            state == Running

-- ä»»åŠ¡æ‰§è¡Œå‡½æ•°
executeTask :: Task -> State -> IO (Either Error State)
executeTask task state = do
    result <- runTask task
    case result of
        Success -> return (Right state)
        Failure err -> return (Left err)
```

#### 2.2.3 æ¡ä»¶åˆ†æ”¯å’Œå¾ªç¯æ§åˆ¶

**æ¡ä»¶åˆ†æ”¯**ï¼š

å·¥ä½œæµæ”¯æŒåŸºäºæ¡ä»¶çš„è·¯å¾„é€‰æ‹©ã€‚

```haskell
-- æ¡ä»¶åˆ†æ”¯èŠ‚ç‚¹
data ConditionalNode = ConditionalNode {
    condition :: Expression,  -- æ¡ä»¶è¡¨è¾¾å¼
    trueBranch :: Workflow,   -- æ¡ä»¶ä¸ºçœŸæ—¶çš„åˆ†æ”¯
    falseBranch :: Workflow   -- æ¡ä»¶ä¸ºå‡æ—¶çš„åˆ†æ”¯
}

-- æ¡ä»¶åˆ†æ”¯æ‰§è¡Œ
executeConditional :: ConditionalNode -> Context -> Workflow
executeConditional node ctx =
    if evaluate (condition node) ctx
    then trueBranch node
    else falseBranch node
```

**å¾ªç¯æ§åˆ¶**ï¼š

å·¥ä½œæµæ”¯æŒå¾ªç¯æ‰§è¡Œï¼Œéœ€è¦æ£€æµ‹å¾ªç¯ç»ˆæ­¢æ¡ä»¶ã€‚

```haskell
-- å¾ªç¯èŠ‚ç‚¹
data LoopNode = LoopNode {
    loopCondition :: Expression,  -- å¾ªç¯æ¡ä»¶
    loopBody :: Workflow,         -- å¾ªç¯ä½“
    maxIterations :: Maybe Int    -- æœ€å¤§è¿­ä»£æ¬¡æ•°
}

-- å¾ªç¯æ‰§è¡Œ
executeLoop :: LoopNode -> Context -> IO Workflow
executeLoop node ctx = do
    let iterations = 0
    let continue = True
    while continue $ do
        when (maybe True (> iterations) (maxIterations node)) $ do
            continue <- evaluate (loopCondition node) ctx
            when continue $ do
                execute (loopBody node) ctx
                iterations <- iterations + 1
    return completed
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 å·¥ä½œæµå½¢å¼åŒ–

#### 3.1.1 å·¥ä½œæµçŠ¶æ€æœºå½¢å¼åŒ–

**å®šä¹‰1ï¼ˆå·¥ä½œæµçŠ¶æ€æœºï¼‰**ï¼š

å·¥ä½œæµçŠ¶æ€æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ `WF = (S, E, T, sâ‚€, F)`ï¼Œå…¶ä¸­ï¼š

- **S**ï¼šæœ‰é™çŠ¶æ€é›†åˆï¼Œ`S = {Pending, Running, Paused, Completed, Failed, Cancelled}`
- **E**ï¼šäº‹ä»¶é›†åˆï¼Œ`E = {Start, Pause, Resume, Complete, Fail, Cancel}`
- **T**ï¼šçŠ¶æ€è½¬æ¢å‡½æ•°ï¼Œ`T: S Ã— E â†’ S`
- **sâ‚€**ï¼šåˆå§‹çŠ¶æ€ï¼Œ`sâ‚€ = Pending`
- **F**ï¼šç»ˆæ­¢çŠ¶æ€é›†åˆï¼Œ`F = {Completed, Failed, Cancelled}`

**å½¢å¼åŒ–è¡¨ç¤º**ï¼š

```haskell
-- å·¥ä½œæµçŠ¶æ€æœºå½¢å¼åŒ–
type State = String
type Event = String
type Transition = (State, Event, State)

data WorkflowFSM = WorkflowFSM {
    states :: Set State,
    events :: Set Event,
    transitions :: Set Transition,
    initialState :: State,
    finalStates :: Set State
}

-- çŠ¶æ€è½¬æ¢å‡½æ•°
transition :: WorkflowFSM -> State -> Event -> Maybe State
transition wf s e =
    find (\(s1, e1, s2) -> s1 == s && e1 == e) (transitions wf)
    >>= Just . (\(_, _, s2) -> s2)
```

#### 3.1.2 çŠ¶æ€è½¬æ¢è¯­ä¹‰

**å®šä¹‰2ï¼ˆçŠ¶æ€è½¬æ¢è¯­ä¹‰ï¼‰**ï¼š

çŠ¶æ€è½¬æ¢å‡½æ•° `T` æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

1. **ç¡®å®šæ€§**ï¼šå¯¹äºä»»æ„çŠ¶æ€ `s âˆˆ S` å’Œäº‹ä»¶ `e âˆˆ E`ï¼Œå¦‚æœ `T(s, e)` æœ‰å®šä¹‰ï¼Œåˆ™ç»“æœå”¯ä¸€
2. **å¯è¾¾æ€§**ï¼šä»åˆå§‹çŠ¶æ€ `sâ‚€` å‡ºå‘ï¼Œå¯ä»¥åˆ°è¾¾æ‰€æœ‰éç»ˆæ­¢çŠ¶æ€
3. **ç»ˆæ­¢æ€§**ï¼šä»ä»»æ„çŠ¶æ€å‡ºå‘ï¼Œæœ€ç»ˆå¯ä»¥åˆ°è¾¾ç»ˆæ­¢çŠ¶æ€

**å½¢å¼åŒ–è¡¨ç¤º**ï¼š

```haskell
-- çŠ¶æ€è½¬æ¢è¯­ä¹‰
transitionSemantics :: WorkflowFSM -> State -> Event -> Maybe State
transitionSemantics wf s e
    | s `notElem` states wf = Nothing
    | e `notElem` events wf = Nothing
    | otherwise = transition wf s e

-- å¯è¾¾æ€§æ£€æŸ¥
isReachable :: WorkflowFSM -> State -> Bool
isReachable wf s =
    s == initialState wf ||
    any (isReachable wf) (predecessors wf s)
    where
        predecessors wf s =
            [s1 | (s1, _, s2) <- transitions wf, s2 == s]
```

#### 3.1.3 çŠ¶æ€æŒä¹…åŒ–è¯­ä¹‰

**å®šä¹‰3ï¼ˆçŠ¶æ€æŒä¹…åŒ–è¯­ä¹‰ï¼‰**ï¼š

çŠ¶æ€æŒä¹…åŒ–å‡½æ•° `Persist: State Ã— Context â†’ Database` æ»¡è¶³ï¼š

1. **ä¸€è‡´æ€§**ï¼šæŒä¹…åŒ–çš„çŠ¶æ€ä¸å†…å­˜çŠ¶æ€ä¸€è‡´
2. **å¯æ¢å¤æ€§**ï¼šå¯ä»¥ä»æŒä¹…åŒ–çŠ¶æ€æ¢å¤åˆ°å†…å­˜çŠ¶æ€
3. **åŸå­æ€§**ï¼šçŠ¶æ€æŒä¹…åŒ–æ˜¯åŸå­æ“ä½œ

**å½¢å¼åŒ–è¡¨ç¤º**ï¼š

```haskell
-- çŠ¶æ€æŒä¹…åŒ–
persistState :: State -> Context -> IO ()
persistState s ctx = do
    -- åŸå­æ€§å†™å…¥æ•°æ®åº“
    atomically $ do
        writeStateToDB s ctx
        writeStateHistory s ctx

-- çŠ¶æ€æ¢å¤
restoreState :: WorkflowId -> IO (Maybe (State, Context))
restoreState wfId = do
    state <- readStateFromDB wfId
    history <- readStateHistory wfId
    return $ (state, history) <$> state
```

---

## 4. å®šç†ä¸è¯æ˜

### 4.1 çŠ¶æ€è½¬æ¢ç¡®å®šæ€§å®šç†

**å®šç†1ï¼ˆçŠ¶æ€è½¬æ¢ç¡®å®šæ€§ï¼‰**ï¼š

å¯¹äºå·¥ä½œæµçŠ¶æ€æœº `WF = (S, E, T, sâ‚€, F)`ï¼Œå¦‚æœçŠ¶æ€è½¬æ¢å‡½æ•° `T` æ˜¯ç¡®å®šçš„ï¼Œåˆ™å¯¹äºä»»æ„çŠ¶æ€ `s âˆˆ S` å’Œäº‹ä»¶ `e âˆˆ E`ï¼Œæœ€å¤šå­˜åœ¨ä¸€ä¸ªä¸‹ä¸€çŠ¶æ€ã€‚

**è¯æ˜**ï¼š

**åŸºç¡€æƒ…å†µ**ï¼š

- è®¾çŠ¶æ€è½¬æ¢å‡½æ•° `T: S Ã— E â†’ S` æ˜¯ç¡®å®šçš„
- æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œå¯¹äºä»»æ„ `(s, e) âˆˆ S Ã— E`ï¼Œ`T(s, e)` æœ€å¤šæœ‰ä¸€ä¸ªå€¼

**å½’çº³æ­¥éª¤**ï¼š

1. å‡è®¾å¯¹äºçŠ¶æ€ `s` å’Œäº‹ä»¶ `e`ï¼Œå­˜åœ¨ä¸¤ä¸ªä¸åŒçš„ä¸‹ä¸€çŠ¶æ€ `sâ‚` å’Œ `sâ‚‚`
2. å³ `T(s, e) = sâ‚` ä¸” `T(s, e) = sâ‚‚`ï¼Œä¸” `sâ‚ â‰  sâ‚‚`
3. è¿™ä¸å‡½æ•° `T` çš„å•å€¼æ€§çŸ›ç›¾
4. å› æ­¤ï¼Œå¯¹äºä»»æ„ `(s, e)`ï¼Œæœ€å¤šå­˜åœ¨ä¸€ä¸ªä¸‹ä¸€çŠ¶æ€

**ç»“è®º**ï¼š
ç”±åè¯æ³•ï¼ŒçŠ¶æ€è½¬æ¢å‡½æ•° `T` æ˜¯ç¡®å®šçš„ï¼Œè¯æ¯•ã€‚

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[çŠ¶æ€è½¬æ¢ç¡®å®šæ€§å®šç†] --> B[å‡è®¾ï¼šTæ˜¯ç¡®å®šçš„]
    B --> C[åè¯ï¼šå­˜åœ¨ä¸¤ä¸ªä¸‹ä¸€çŠ¶æ€]
    C --> D[T s e = sâ‚ ä¸” T s e = sâ‚‚]
    D --> E[sâ‚ â‰  sâ‚‚]
    E --> F[ä¸å‡½æ•°å•å€¼æ€§çŸ›ç›¾]
    F --> G[ç»“è®ºï¼šæœ€å¤šä¸€ä¸ªä¸‹ä¸€çŠ¶æ€]

    style A fill:#FFD700
    style G fill:#90EE90
```

### 4.2 çŠ¶æ€å¯è¾¾æ€§å®šç†

**å®šç†2ï¼ˆçŠ¶æ€å¯è¾¾æ€§ï¼‰**ï¼š

å¯¹äºå·¥ä½œæµçŠ¶æ€æœº `WF = (S, E, T, sâ‚€, F)`ï¼Œå¦‚æœä»åˆå§‹çŠ¶æ€ `sâ‚€` å‡ºå‘ï¼Œæ‰€æœ‰éç»ˆæ­¢çŠ¶æ€éƒ½æ˜¯å¯è¾¾çš„ã€‚

**è¯æ˜**ï¼š

**åŸºç¡€æƒ…å†µ**ï¼š

- åˆå§‹çŠ¶æ€ `sâ‚€` æ˜¯å¯è¾¾çš„ï¼ˆç”±å®šä¹‰ï¼‰

**å½’çº³å‡è®¾**ï¼š

- å‡è®¾çŠ¶æ€ `s` æ˜¯å¯è¾¾çš„

**å½’çº³æ­¥éª¤**ï¼š

1. è®¾ `s` æ˜¯å¯è¾¾çŠ¶æ€ï¼Œå­˜åœ¨è·¯å¾„ `sâ‚€ â†’ sâ‚ â†’ ... â†’ sâ‚– = s`
2. å¯¹äºä»»æ„ä» `s` å¯è¾¾çš„çŠ¶æ€ `s'`ï¼Œå³å­˜åœ¨äº‹ä»¶ `e` ä½¿å¾— `T(s, e) = s'`
3. åˆ™å­˜åœ¨è·¯å¾„ `sâ‚€ â†’ sâ‚ â†’ ... â†’ sâ‚– â†’ s'`
4. å› æ­¤ `s'` ä¹Ÿæ˜¯å¯è¾¾çš„

**ç»ˆæ­¢æ¡ä»¶**ï¼š

- ç»ˆæ­¢çŠ¶æ€ `f âˆˆ F` æ˜¯å¯è¾¾çš„ï¼ˆå¦‚æœå­˜åœ¨ä» `sâ‚€` åˆ° `f` çš„è·¯å¾„ï¼‰

**ç»“è®º**ï¼š
ç”±æ•°å­¦å½’çº³æ³•ï¼Œæ‰€æœ‰ä» `sâ‚€` å¯è¾¾çš„çŠ¶æ€éƒ½æ˜¯å¯è¾¾çš„ï¼Œè¯æ¯•ã€‚

### 4.3 çŠ¶æ€æŒä¹…åŒ–ä¸€è‡´æ€§å®šç†

**å®šç†3ï¼ˆçŠ¶æ€æŒä¹…åŒ–ä¸€è‡´æ€§ï¼‰**ï¼š

å¦‚æœçŠ¶æ€æŒä¹…åŒ–å‡½æ•° `Persist` æ˜¯åŸå­çš„ï¼Œåˆ™æŒä¹…åŒ–åçš„çŠ¶æ€ä¸å†…å­˜çŠ¶æ€ä¸€è‡´ã€‚

**è¯æ˜**ï¼š

**åŸºç¡€æƒ…å†µ**ï¼š

- è®¾å†…å­˜çŠ¶æ€ä¸º `s_mem`ï¼ŒæŒä¹…åŒ–å‡½æ•° `Persist(s_mem, ctx)` æ‰§è¡Œ
- ç”±äºåŸå­æ€§ï¼ŒæŒä¹…åŒ–æ“ä½œè¦ä¹ˆå®Œå…¨æˆåŠŸï¼Œè¦ä¹ˆå®Œå…¨å¤±è´¥

**å½’çº³æ­¥éª¤**ï¼š

1. å¦‚æœæŒä¹…åŒ–æˆåŠŸï¼Œåˆ™æ•°æ®åº“ä¸­çš„çŠ¶æ€ `s_db = s_mem`
2. å¦‚æœæŒä¹…åŒ–å¤±è´¥ï¼Œåˆ™æ•°æ®åº“çŠ¶æ€ä¸å˜ï¼Œä½†å¯ä»¥é€šè¿‡å›æ»šæ¢å¤ä¸€è‡´æ€§
3. å› æ­¤ï¼ŒæŒä¹…åŒ–åçš„çŠ¶æ€ä¸å†…å­˜çŠ¶æ€ä¸€è‡´

**ç»“è®º**ï¼š
ç”±åŸå­æ€§ä¿è¯ï¼ŒçŠ¶æ€æŒä¹…åŒ–åçš„ä¸€è‡´æ€§å¾—åˆ°ä¿è¯ï¼Œè¯æ¯•ã€‚

---

## 5. å®é™…åº”ç”¨

### 5.1 PostgreSQL 18å·¥ä½œæµå¼•æ“å®ç°

#### 5.1.1 å®Œæ•´å·¥ä½œæµçŠ¶æ€ç®¡ç†å®ç°

**PostgreSQL 18å®ç°æ¶æ„**ï¼š

```sql
-- 1. å·¥ä½œæµå®šä¹‰è¡¨
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    definition JSONB NOT NULL,  -- å·¥ä½œæµå®šä¹‰ï¼ˆä»»åŠ¡ã€ä¾èµ–ã€æ¡ä»¶ç­‰ï¼‰
    version INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. å·¥ä½œæµå®ä¾‹è¡¨ï¼ˆçŠ¶æ€ç®¡ç†ï¼‰
CREATE TABLE workflow_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    definition_id UUID NOT NULL REFERENCES workflow_definitions(id),
    name VARCHAR(100) NOT NULL,
    current_state VARCHAR(50) NOT NULL DEFAULT 'Pending',
    state_data JSONB,  -- çŠ¶æ€ä¸Šä¸‹æ–‡æ•°æ®
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    version INTEGER DEFAULT 1,  -- ä¹è§‚é”ç‰ˆæœ¬å·

    CONSTRAINT valid_state CHECK (current_state IN (
        'Pending', 'Running', 'Paused', 'Completed', 'Failed', 'Cancelled'
    ))
);

-- 3. çŠ¶æ€è½¬æ¢å†å²è¡¨
CREATE TABLE workflow_state_history (
    id BIGSERIAL PRIMARY KEY,
    instance_id UUID NOT NULL REFERENCES workflow_instances(id),
    from_state VARCHAR(50),
    to_state VARCHAR(50) NOT NULL,
    event VARCHAR(50) NOT NULL,
    transition_time TIMESTAMPTZ DEFAULT NOW(),
    context_data JSONB,
    triggered_by VARCHAR(100),
    error_message TEXT
);

-- 4. ä»»åŠ¡æ‰§è¡Œè¡¨
CREATE TABLE workflow_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    instance_id UUID NOT NULL REFERENCES workflow_instances(id),
    task_name VARCHAR(100) NOT NULL,
    task_type VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'Pending',
    dependencies UUID[],  -- ä¾èµ–çš„ä»»åŠ¡IDåˆ—è¡¨
    execution_data JSONB,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    error_message TEXT
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_workflow_instances_state ON workflow_instances(current_state);
CREATE INDEX idx_workflow_instances_updated ON workflow_instances(updated_at);
CREATE INDEX idx_workflow_history_instance ON workflow_state_history(instance_id);
CREATE INDEX idx_workflow_history_time ON workflow_state_history(transition_time);
CREATE INDEX idx_workflow_tasks_instance ON workflow_tasks(instance_id);
CREATE INDEX idx_workflow_tasks_status ON workflow_tasks(status);
```

#### 5.1.2 çŠ¶æ€è½¬æ¢å‡½æ•°å®ç°

**çŠ¶æ€è½¬æ¢å‡½æ•°**ï¼š

```sql
-- çŠ¶æ€è½¬æ¢å‡½æ•°ï¼ˆå¸¦éªŒè¯ï¼‰
CREATE OR REPLACE FUNCTION transition_workflow_state(
    p_instance_id UUID,
    p_event VARCHAR(50),
    p_context_data JSONB DEFAULT NULL,
    p_triggered_by VARCHAR(100) DEFAULT 'system'
) RETURNS BOOLEAN AS $$
DECLARE
    v_current_state VARCHAR(50);
    v_new_state VARCHAR(50);
    v_version INTEGER;
    v_valid_transition BOOLEAN;
BEGIN
    -- è·å–å½“å‰çŠ¶æ€å’Œç‰ˆæœ¬å·ï¼ˆä¹è§‚é”ï¼‰
    SELECT current_state, version INTO v_current_state, v_version
    FROM workflow_instances
    WHERE id = p_instance_id
    FOR UPDATE;  -- è¡Œçº§é”

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Workflow instance % not found', p_instance_id;
    END IF;

    -- éªŒè¯çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
    SELECT is_valid_transition(v_current_state, p_event) INTO v_valid_transition;

    IF NOT v_valid_transition THEN
        RAISE EXCEPTION 'Invalid transition from state % with event %',
            v_current_state, p_event;
    END IF;

    -- è®¡ç®—æ–°çŠ¶æ€
    v_new_state := calculate_new_state(v_current_state, p_event);

    -- åŸå­æ€§æ›´æ–°çŠ¶æ€
    UPDATE workflow_instances
    SET
        current_state = v_new_state,
        state_data = COALESCE(p_context_data, state_data),
        updated_at = NOW(),
        version = version + 1,
        completed_at = CASE
            WHEN v_new_state IN ('Completed', 'Failed', 'Cancelled')
            THEN NOW()
            ELSE completed_at
        END
    WHERE id = p_instance_id
      AND version = v_version;  -- ä¹è§‚é”æ£€æŸ¥

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Concurrent update detected for workflow instance %', p_instance_id;
    END IF;

    -- è®°å½•çŠ¶æ€è½¬æ¢å†å²
    INSERT INTO workflow_state_history (
        instance_id, from_state, to_state, event,
        context_data, triggered_by
    ) VALUES (
        p_instance_id, v_current_state, v_new_state, p_event,
        p_context_data, p_triggered_by
    );

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION is_valid_transition(
    p_from_state VARCHAR(50),
    p_event VARCHAR(50)
) RETURNS BOOLEAN AS $$
BEGIN
    RETURN CASE
        WHEN p_from_state = 'Pending' AND p_event = 'Start' THEN TRUE
        WHEN p_from_state = 'Running' AND p_event IN ('Pause', 'Complete', 'Fail', 'Cancel') THEN TRUE
        WHEN p_from_state = 'Paused' AND p_event IN ('Resume', 'Cancel') THEN TRUE
        WHEN p_from_state = 'Failed' AND p_event = 'Start' THEN TRUE
        ELSE FALSE
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- è®¡ç®—æ–°çŠ¶æ€å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_new_state(
    p_from_state VARCHAR(50),
    p_event VARCHAR(50)
) RETURNS VARCHAR(50) AS $$
BEGIN
    RETURN CASE
        WHEN p_from_state = 'Pending' AND p_event = 'Start' THEN 'Running'
        WHEN p_from_state = 'Running' AND p_event = 'Pause' THEN 'Paused'
        WHEN p_from_state = 'Running' AND p_event = 'Complete' THEN 'Completed'
        WHEN p_from_state = 'Running' AND p_event = 'Fail' THEN 'Failed'
        WHEN p_from_state = 'Running' AND p_event = 'Cancel' THEN 'Cancelled'
        WHEN p_from_state = 'Paused' AND p_event = 'Resume' THEN 'Running'
        WHEN p_from_state = 'Paused' AND p_event = 'Cancel' THEN 'Cancelled'
        WHEN p_from_state = 'Failed' AND p_event = 'Start' THEN 'Running'
        ELSE p_from_state  -- æ— æ•ˆè½¬æ¢ï¼Œä¿æŒåŸçŠ¶æ€
    END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

#### 5.1.3 çŠ¶æ€æ¢å¤æœºåˆ¶

**çŠ¶æ€æ¢å¤å‡½æ•°**ï¼š

```sql
-- ä»æ•°æ®åº“æ¢å¤å·¥ä½œæµçŠ¶æ€
CREATE OR REPLACE FUNCTION restore_workflow_state(
    p_instance_id UUID
) RETURNS TABLE (
    current_state VARCHAR(50),
    state_data JSONB,
    last_transition_time TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        wi.current_state,
        wi.state_data,
        MAX(wsh.transition_time) as last_transition_time
    FROM workflow_instances wi
    LEFT JOIN workflow_state_history wsh ON wi.id = wsh.instance_id
    WHERE wi.id = p_instance_id
    GROUP BY wi.id, wi.current_state, wi.state_data;
END;
$$ LANGUAGE plpgsql;

-- æ£€æŸ¥ç‚¹ä¿å­˜å‡½æ•°
CREATE OR REPLACE FUNCTION save_checkpoint(
    p_instance_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
    -- ä¿å­˜å½“å‰çŠ¶æ€ä¸ºæ£€æŸ¥ç‚¹
    INSERT INTO workflow_checkpoints (
        instance_id, state, state_data, saved_at
    )
    SELECT
        id, current_state, state_data, NOW()
    FROM workflow_instances
    WHERE id = p_instance_id;

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šETLæ•°æ®ç®¡é“å·¥ä½œæµ

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

æŸç”µå•†å¹³å°éœ€è¦æ¯å¤©ä»å¤šä¸ªæ•°æ®æºï¼ˆè®¢å•ç³»ç»Ÿã€ç”¨æˆ·ç³»ç»Ÿã€å•†å“ç³»ç»Ÿï¼‰æå–æ•°æ®ï¼Œè¿›è¡Œæ¸…æ´—å’Œè½¬æ¢ï¼Œç„¶ååŠ è½½åˆ°æ•°æ®ä»“åº“ã€‚éœ€è¦ç¡®ä¿æ•°æ®å¤„ç†çš„å¯é æ€§å’Œå¯æ¢å¤æ€§ã€‚

**æŠ€æœ¯æ–¹æ¡ˆ**ï¼š

ä½¿ç”¨PostgreSQL 18å·¥ä½œæµå¼•æ“ç®¡ç†ETLæµç¨‹ï¼Œé€šè¿‡çŠ¶æ€æœºè·Ÿè¸ªæ¯ä¸ªETLä»»åŠ¡çš„æ‰§è¡ŒçŠ¶æ€ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- 1. åˆ›å»ºETLå·¥ä½œæµå®šä¹‰
INSERT INTO workflow_definitions (name, description, definition) VALUES (
    'daily_etl_pipeline',
    'æ¯æ—¥ETLæ•°æ®ç®¡é“',
    '{
        "tasks": [
            {"name": "extract_orders", "type": "extract", "source": "order_system"},
            {"name": "extract_users", "type": "extract", "source": "user_system"},
            {"name": "extract_products", "type": "extract", "source": "product_system"},
            {"name": "transform_data", "type": "transform", "dependencies": ["extract_orders", "extract_users", "extract_products"]},
            {"name": "load_warehouse", "type": "load", "dependencies": ["transform_data"]}
        ],
        "schedule": "0 2 * * *"
    }'::jsonb
);

-- 2. åˆ›å»ºå·¥ä½œæµå®ä¾‹
INSERT INTO workflow_instances (definition_id, name, current_state)
SELECT id, 'daily_etl_' || CURRENT_DATE, 'Pending'
FROM workflow_definitions
WHERE name = 'daily_etl_pipeline';

-- 3. å¯åŠ¨å·¥ä½œæµ
SELECT transition_workflow_state(
    (SELECT id FROM workflow_instances WHERE name = 'daily_etl_' || CURRENT_DATE),
    'Start',
    '{"scheduled_time": "2025-01-16 02:00:00"}'::jsonb,
    'scheduler'
);

-- 4. ç›‘æ§å·¥ä½œæµçŠ¶æ€
SELECT
    wi.name,
    wi.current_state,
    wi.updated_at,
    COUNT(wt.id) FILTER (WHERE wt.status = 'Completed') as completed_tasks,
    COUNT(wt.id) FILTER (WHERE wt.status = 'Failed') as failed_tasks,
    COUNT(wt.id) as total_tasks
FROM workflow_instances wi
LEFT JOIN workflow_tasks wt ON wi.id = wt.instance_id
WHERE wi.name = 'daily_etl_' || CURRENT_DATE
GROUP BY wi.id, wi.name, wi.current_state, wi.updated_at;
```

**SQLite 3.45å¯¹æ¯”**ï¼š

SQLite 3.45ä¸æ”¯æŒUUIDç±»å‹å’ŒJSONBï¼Œéœ€è¦ä½¿ç”¨TEXTå’ŒJSONå‡½æ•°ï¼š

```sql
-- SQLite 3.45å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
CREATE TABLE workflow_instances (
    id TEXT PRIMARY KEY,  -- ä½¿ç”¨TEXTå­˜å‚¨UUID
    definition_id TEXT NOT NULL,
    name TEXT NOT NULL,
    current_state TEXT NOT NULL DEFAULT 'Pending',
    state_data TEXT,  -- JSONå­—ç¬¦ä¸²
    created_at TEXT DEFAULT (datetime('now')),
    updated_at TEXT DEFAULT (datetime('now'))
);

-- çŠ¶æ€è½¬æ¢ï¼ˆä½¿ç”¨JSONå‡½æ•°ï¼‰
UPDATE workflow_instances
SET
    current_state = 'Running',
    updated_at = datetime('now'),
    state_data = json_set(COALESCE(state_data, '{}'), '$.last_event', 'Start')
WHERE id = ?;
```

**æ€§èƒ½å¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | PostgreSQL 18 | SQLite 3.45 | è¯´æ˜ |
|------|--------------|-------------|------|
| **çŠ¶æ€æŸ¥è¯¢æ€§èƒ½** | <10ms | <5ms | SQLiteåœ¨å•æœºåœºæ™¯ä¸‹æ€§èƒ½æ›´å¥½ |
| **å¹¶å‘çŠ¶æ€æ›´æ–°** | æ”¯æŒé«˜å¹¶å‘ | æœ‰é™å¹¶å‘ | PostgreSQLæ”¯æŒæ›´å¥½çš„å¹¶å‘æ§åˆ¶ |
| **çŠ¶æ€å†å²æŸ¥è¯¢** | <50ms | <20ms | SQLiteæŸ¥è¯¢ç®€å•åœºæ™¯æ›´å¿« |
| **æ•…éšœæ¢å¤** | æ”¯æŒäº‹åŠ¡å›æ»š | æ”¯æŒWALæ¢å¤ | ä¸¤è€…éƒ½æ”¯æŒæ•…éšœæ¢å¤ |
| **é€‚ç”¨åœºæ™¯** | å¤šç”¨æˆ·ã€é«˜å¹¶å‘ | å•ç”¨æˆ·ã€åµŒå…¥å¼ | æ ¹æ®åœºæ™¯é€‰æ‹© |

**å®æ–½æ•ˆæœ**ï¼š

- **å¯é æ€§æå‡**ï¼šå·¥ä½œæµçŠ¶æ€æŒä¹…åŒ–åï¼Œç³»ç»Ÿæ•…éšœæ¢å¤ç‡è¾¾åˆ°99.9%
- **å¯è§‚æµ‹æ€§**ï¼šé€šè¿‡çŠ¶æ€å†å²è¡¨ï¼Œå¯ä»¥å®Œæ•´è¿½è¸ªå·¥ä½œæµæ‰§è¡Œè¿‡ç¨‹
- **æ€§èƒ½å½±å“**ï¼šçŠ¶æ€ç®¡ç†å¼€é”€<5%ï¼Œå¯¹ETLæ€§èƒ½å½±å“å¯å¿½ç•¥

#### åœºæ™¯2ï¼šè®¢å•å¤„ç†å·¥ä½œæµ

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

ç”µå•†å¹³å°çš„è®¢å•å¤„ç†æµç¨‹åŒ…æ‹¬ï¼šè®¢å•åˆ›å»º â†’ åº“å­˜æ£€æŸ¥ â†’ æ”¯ä»˜å¤„ç† â†’ å‘è´§å‡†å¤‡ â†’ è®¢å•å®Œæˆã€‚éœ€è¦æ”¯æŒè®¢å•çŠ¶æ€çš„å®æ—¶æŸ¥è¯¢å’Œæ•…éšœæ¢å¤ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- è®¢å•å¤„ç†å·¥ä½œæµ
INSERT INTO workflow_definitions (name, definition) VALUES (
    'order_processing',
    '{
        "tasks": [
            {"name": "create_order", "state": "Created"},
            {"name": "check_inventory", "state": "InventoryChecked", "dependencies": ["create_order"]},
            {"name": "process_payment", "state": "PaymentProcessed", "dependencies": ["check_inventory"]},
            {"name": "prepare_shipment", "state": "ShipmentPrepared", "dependencies": ["process_payment"]},
            {"name": "complete_order", "state": "Completed", "dependencies": ["prepare_shipment"]}
        ],
        "error_handling": {
            "inventory_failure": {"action": "cancel_order", "state": "Cancelled"},
            "payment_failure": {"action": "release_inventory", "state": "PaymentFailed"}
        }
    }'::jsonb
);

-- è®¢å•çŠ¶æ€æŸ¥è¯¢ï¼ˆå®æ—¶ï¼‰
CREATE OR REPLACE FUNCTION get_order_status(p_order_id UUID)
RETURNS TABLE (
    order_id UUID,
    current_state VARCHAR(50),
    state_data JSONB,
    progress_percentage NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        wi.id,
        wi.current_state,
        wi.state_data,
        CASE
            WHEN wi.current_state = 'Completed' THEN 100
            WHEN wi.current_state = 'Failed' THEN 0
            ELSE (COUNT(wt.id) FILTER (WHERE wt.status = 'Completed')::NUMERIC /
                  NULLIF(COUNT(wt.id), 0) * 100)
        END as progress_percentage
    FROM workflow_instances wi
    LEFT JOIN workflow_tasks wt ON wi.id = wt.instance_id
    WHERE wi.id = p_order_id
    GROUP BY wi.id, wi.current_state, wi.state_data;
END;
$$ LANGUAGE plpgsql;
```

**å®æ–½æ•ˆæœ**ï¼š

- **çŠ¶æ€æŸ¥è¯¢æ€§èƒ½**ï¼šå¹³å‡å“åº”æ—¶é—´<20ms
- **æ•…éšœæ¢å¤æ—¶é—´**ï¼š<1ç§’ï¼ˆä»æ£€æŸ¥ç‚¹æ¢å¤ï¼‰
- **çŠ¶æ€ä¸€è‡´æ€§**ï¼š100%ï¼ˆé€šè¿‡ä¹è§‚é”ä¿è¯ï¼‰

---

## 5. ç›¸å…³æ–‡æ¡£

### 5.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [å½¢å¼è¯­è¨€ä¸è¯æ˜ï¼šæ€»è®º](./1.1.25-å½¢å¼è¯­è¨€ä¸è¯æ˜-æ€»è®º.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](./README.md)

---

## 6. å‚è€ƒæ–‡çŒ®

### 6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Hollingsworth, D. (1995). "Workflow Management Coalition: The Workflow Reference Model."**
  - æŠ¥å‘Š: Workflow Management Coalition 1995
  - **é‡è¦æ€§**: å·¥ä½œæµç®¡ç†çš„æ ‡å‡†æ¨¡å‹
  - **æ ¸å¿ƒè´¡çŒ®**: å®šä¹‰äº†å·¥ä½œæµå¼•æ“æ¶æ„

- **van der Aalst, W. M. P., & van Hee, K. M. (2004). "Workflow Management: Models, Methods, and Systems."**
  - å‡ºç‰ˆç¤¾: MIT Press
  - **é‡è¦æ€§**: å·¥ä½œæµç®¡ç†çš„ç»å…¸æ•™æ
  - **æ ¸å¿ƒè´¡çŒ®**: ç³»ç»Ÿé˜è¿°äº†çŠ¶æ€ç®¡ç†

### 6.2 PostgreSQLå®ç°ç›¸å…³

- **PostgreSQLæ‰©å±• - å·¥ä½œæµå¼•æ“](<https://github.com/postgresql/workflow-engine>)**
  - PostgreSQLå·¥ä½œæµå¼•æ“æ‰©å±•

### 6.3 ç›¸å…³æ–‡æ¡£

- [æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-ç¼–æ’è¯­è¨€ä¸è¯­ä¹‰çš„å½¢å¼åŒ–](./13.03-æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-ç¼–æ’è¯­è¨€ä¸è¯­ä¹‰çš„å½¢å¼åŒ–.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ
