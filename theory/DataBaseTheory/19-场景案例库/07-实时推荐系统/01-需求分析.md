# 实时推荐系统 - 需求分析

## 元数据
- **案例类型**: 图数据库 + 协同过滤
- **难度等级**: ⭐⭐⭐⭐⭐
- **数据规模**: 千万用户、亿级交互
- **技术栈**: Apache AGE + pgvector + Redis
- **创建日期**: 2025-12-04

---

## 1. 业务背景

### 1.1 场景描述

某电商平台需要构建**实时推荐系统**，为用户推荐可能感兴趣的商品。

**核心需求**:
- 千万级用户，亿级商品
- 实时推荐（延迟<100ms）
- 个性化推荐（准确率>35%）
- 多策略融合（协同过滤、内容推荐、图推荐）

### 1.2 业务指标

| 指标 | 目标 | 说明 |
|------|------|------|
| **用户规模** | 1000万活跃用户 | DAU |
| **商品规模** | 500万SKU | 在售商品 |
| **交互数据** | 10亿条 | 浏览、收藏、购买 |
| **推荐延迟** | <100ms | P95 |
| **点击率CTR** | >3% | 推荐效果 |
| **转化率CVR** | >0.8% | 购买转化 |
| **推荐准确率** | >35% | Hit Rate |
| **系统可用性** | 99.95% | SLA |

---

## 2. 技术挑战

### 2.1 核心挑战

#### 挑战1: 冷启动问题

```
新用户问题:
├─ 无历史行为数据
├─ 无法使用协同过滤
└─ 需要基于内容推荐

解决方案:
├─ 用户画像填充
├─ 热门商品推荐
└─ 基于类目的内容推荐
```

#### 挑战2: 实时性要求

```
延迟要求: P95 < 100ms

挑战:
├─ 图遍历计算耗时
├─ 向量相似度计算
└─ 多策略融合排序

优化方案:
├─ 预计算 + 缓存
├─ 索引优化（HNSW、GIN）
└─ 异步更新
```

#### 挑战3: 数据稀疏性

```
问题:
├─ 长尾商品交互少
├─ 协同过滤效果差
└─ 推荐多样性不足

解决:
├─ 混合推荐策略
├─ 图推荐补充
└─ 内容特征增强
```

### 2.2 性能要求

```
QPS要求:
├─ 推荐查询: 10,000 QPS
├─ 行为记录: 5,000 TPS
└─ 模型更新: 实时增量

数据规模:
├─ 用户: 1000万
├─ 商品: 500万
├─ 交互: 10亿条
└─ 图节点: 1500万
```

---

## 3. 推荐策略

### 3.1 多策略推荐

#### 策略1: 协同过滤（User-Based CF）

```sql
-- 基于用户的协同过滤
-- 找到相似用户喜欢的商品

思路:
1. 找到与目标用户相似的K个用户
2. 统计这些用户喜欢的商品
3. 过滤目标用户已交互的商品
4. 按相似度加权排序

优势: 发现新颖商品
劣势: 冷启动、计算复杂
权重: 40%
```

#### 策略2: 图推荐（Graph-Based）

```cypher
-- 使用Apache AGE图遍历

MATCH (u:User {id: $user_id})-[:PURCHASED]->(p1:Product)
MATCH (p1)<-[:PURCHASED]-(other:User)-[:PURCHASED]->(p2:Product)
WHERE NOT (u)-[:PURCHASED]->(p2)
RETURN p2, COUNT(other) AS共同购买用户数
ORDER BY 共同购买用户数 DESC
LIMIT 20

优势: 发现关联商品、可解释
劣势: 图遍历耗时
权重: 30%
```

#### 策略3: 内容推荐（Content-Based）

```sql
-- 基于商品特征向量相似度

SELECT
    p.product_id,
    p.title,
    1 - (p.embedding <=> $user_preference_vector) AS similarity
FROM products p
WHERE p.category_id IN (SELECT category_id FROM user_interests WHERE user_id = $user_id)
ORDER BY p.embedding <=> $user_preference_vector
LIMIT 20;

优势: 解决冷启动、可控
劣势: 缺乏惊喜、多样性不足
权重: 20%
```

#### 策略4: 热门推荐（Popularity）

```sql
-- 热门商品推荐（兜底策略）

SELECT
    product_id,
    title,
    hot_score
FROM product_hot_ranking
WHERE category_id = $category_id
  AND create_time > NOW() - INTERVAL '30 days'
ORDER BY hot_score DESC
LIMIT 20;

优势: 简单高效、转化率高
劣势: 无个性化、马太效应
权重: 10%
```

### 3.2 策略融合

```python
# 融合算法
def fuse_recommendations(user_id):
    """多策略融合推荐"""

    # 1. 并行获取各策略推荐
    cf_results = collaborative_filtering(user_id, k=50)      # 协同过滤
    graph_results = graph_recommend(user_id, k=50)           # 图推荐
    content_results = content_recommend(user_id, k=50)       # 内容推荐
    hot_results = popular_recommend(user_id, k=20)           # 热门推荐

    # 2. 加权融合
    final_scores = {}
    for item_id, score in cf_results:
        final_scores[item_id] = final_scores.get(item_id, 0) + 0.4 * score

    for item_id, score in graph_results:
        final_scores[item_id] = final_scores.get(item_id, 0) + 0.3 * score

    for item_id, score in content_results:
        final_scores[item_id] = final_scores.get(item_id, 0) + 0.2 * score

    for item_id, score in hot_results:
        final_scores[item_id] = final_scores.get(item_id, 0) + 0.1 * score

    # 3. 排序 + 去重 + 多样性
    recommendations = diversify(
        sorted(final_scores.items(), key=lambda x: x[1], reverse=True),
        top_k=20,
        diversity_factor=0.3
    )

    return recommendations
```

---

## 4. 数据模型

### 4.1 核心实体

#### 用户 (User)

```sql
用户属性:
├─ 基础信息: ID、昵称、注册时间
├─ 画像: 性别、年龄、地域、偏好类目
├─ 行为特征: 浏览频率、购买力、活跃度
└─ 向量表示: 用户兴趣向量 (384维)
```

#### 商品 (Product)

```sql
商品属性:
├─ 基础信息: ID、标题、价格、类目
├─ 内容特征: 描述、标签、属性
├─ 统计信息: 销量、评分、浏览量
└─ 向量表示: 商品特征向量 (384维)
```

#### 交互 (Interaction)

```sql
交互类型:
├─ 浏览 (view): 权重 1.0
├─ 收藏 (favorite): 权重 3.0
├─ 加购 (cart): 权重 5.0
└─ 购买 (purchase): 权重 10.0

交互属性:
├─ 用户ID
├─ 商品ID
├─ 交互类型
├─ 交互时间
└─ 上下文（设备、渠道）
```

### 4.2 图模型

```cypher
// Apache AGE图模型

节点类型:
├─ (:User)     - 用户节点
├─ (:Product)  - 商品节点
└─ (:Category) - 类目节点

关系类型:
├─ (User)-[:VIEWED]->(Product)      权重: 1.0
├─ (User)-[:FAVORITED]->(Product)   权重: 3.0
├─ (User)-[:CARTED]->(Product)      权重: 5.0
├─ (User)-[:PURCHASED]->(Product)   权重: 10.0
├─ (Product)-[:BELONGS_TO]->(Category)
└─ (Product)-[:SIMILAR_TO]->(Product)  相似度
```

---

## 5. 非功能需求

### 5.1 性能需求

```
推荐查询:
├─ QPS: 10,000
├─ 延迟: P95 < 100ms, P99 < 200ms
└─ 超时: 500ms

行为记录:
├─ TPS: 5,000
├─ 延迟: P95 < 50ms
└─ 数据一致性: 最终一致

模型更新:
├─ 延迟: <5分钟
├─ 频率: 实时增量
└─ 准确性: 增量更新不降低效果
```

### 5.2 可用性需求

```
SLA: 99.95%
├─ 年度停机时间: <4.38小时
├─ 故障恢复: <5分钟 (RTO)
└─ 数据丢失: <1分钟 (RPO)

容灾:
├─ 主备切换: <30秒
├─ 数据同步: 实时
└─ 多机房部署: 支持
```

### 5.3 扩展性需求

```
用户增长:
├─ 当前: 1000万
├─ 1年后: 3000万
└─ 3年后: 1亿

数据增长:
├─ 当前: 10亿交互
├─ 增长率: 每月+5%
└─ 3年后: 50亿交互

性能要求:
├─ 线性扩展
├─ 分片支持
└─ 读写分离
```

---

## 6. 技术选型

### 6.1 核心技术栈

```yaml
数据库:
  主库: PostgreSQL 18
  图扩展: Apache AGE 1.5+
  向量扩展: pgvector 0.7+

缓存:
  Redis: 7.2+
  用途: 推荐结果缓存、会话管理

计算:
  Python: 3.11+
  FastAPI: 0.104+
  Celery: 5.3+ (异步任务)

监控:
  Prometheus + Grafana
```

### 6.2 PostgreSQL 18特性应用

| 特性 | 应用场景 | 价值 |
|------|----------|------|
| **Apache AGE** | 图推荐算法 | 关联推荐 |
| **pgvector HNSW** | 向量相似搜索 | 内容推荐 |
| **异步I/O** | 高并发查询 | 性能+200% |
| **并行查询** | OLAP聚合分析 | 计算加速 |
| **分区表** | 历史数据管理 | 查询优化 |
| **增量排序** | Top-K排序 | 内存优化 |

---

## 7. 数据流设计

### 7.1 在线推荐流程

```
用户请求
   ↓
API网关
   ↓
推荐服务
   ├─→ 缓存查询 (Redis)
   │   └─ 命中 → 返回结果
   │
   └─→ 缓存未命中
       ↓
   ┌─────────────────────────┐
   │   并行策略执行            │
   ├─────────────────────────┤
   │  1. 协同过滤 (SQL)       │
   │  2. 图推荐 (Cypher)      │
   │  3. 内容推荐 (pgvector)  │
   │  4. 热门推荐 (SQL)       │
   └─────────────────────────┘
       ↓
   结果融合 + 多样性
       ↓
   写入缓存 (TTL=5min)
       ↓
   返回推荐列表
```

### 7.2 离线计算流程

```
定时任务 (Celery)
   ↓
1. 用户相似度计算
   ├─ 读取用户交互数据
   ├─ 计算余弦相似度
   └─ 存储到user_similarity表
   ↓
2. 商品相似度计算
   ├─ 读取商品特征
   ├─ 计算向量相似度
   └─ 存储到product_similarity表
   ↓
3. 图模型更新
   ├─ 增量写入用户行为边
   ├─ 更新商品相似边
   └─ Apache AGE图更新
   ↓
4. 模型训练
   ├─ 用户Embedding更新
   ├─ 商品Embedding更新
   └─ 存储到pgvector
```

---

## 8. 推荐算法设计

### 8.1 协同过滤算法

#### User-Based CF

```python
def user_based_cf(target_user_id, k_neighbors=50, top_n=20):
    """
    基于用户的协同过滤

    算法:
    1. 找到与目标用户最相似的K个用户
    2. 统计这K个用户喜欢的商品
    3. 过滤掉目标用户已交互的商品
    4. 按相似度加权评分排序
    """

    # SQL实现
    query = """
        WITH similar_users AS (
            SELECT
                other_user_id,
                similarity
            FROM user_similarity
            WHERE user_id = %(user_id)s
            ORDER BY similarity DESC
            LIMIT %(k)s
        ),
        candidate_products AS (
            SELECT
                i.product_id,
                SUM(su.similarity * i.weight) AS score
            FROM similar_users su
            JOIN user_interactions i ON su.other_user_id = i.user_id
            WHERE NOT EXISTS (
                SELECT 1 FROM user_interactions ui
                WHERE ui.user_id = %(user_id)s
                  AND ui.product_id = i.product_id
            )
            GROUP BY i.product_id
        )
        SELECT
            cp.product_id,
            p.title,
            cp.score
        FROM candidate_products cp
        JOIN products p ON cp.product_id = p.product_id
        ORDER BY cp.score DESC
        LIMIT %(top_n)s;
    """

    return execute_query(query, {
        'user_id': target_user_id,
        'k': k_neighbors,
        'top_n': top_n
    })
```

#### Item-Based CF

```python
def item_based_cf(target_user_id, top_n=20):
    """
    基于物品的协同过滤

    算法:
    1. 获取用户已交互的商品
    2. 查找这些商品的相似商品
    3. 聚合相似度分数
    4. 排序返回
    """

    query = """
        WITH user_products AS (
            SELECT product_id, weight
            FROM user_interactions
            WHERE user_id = %(user_id)s
        ),
        candidate_products AS (
            SELECT
                ps.similar_product_id AS product_id,
                SUM(up.weight * ps.similarity) AS score
            FROM user_products up
            JOIN product_similarity ps ON up.product_id = ps.product_id
            WHERE ps.similar_product_id NOT IN (
                SELECT product_id FROM user_products
            )
            GROUP BY ps.similar_product_id
        )
        SELECT
            cp.product_id,
            p.title,
            cp.score
        FROM candidate_products cp
        JOIN products p ON cp.product_id = p.product_id
        ORDER BY cp.score DESC
        LIMIT %(top_n)s;
    """

    return execute_query(query, {
        'user_id': target_user_id,
        'top_n': top_n
    })
```

### 8.2 图推荐算法

```python
# 使用Apache AGE的图遍历
def graph_recommend(user_id, top_n=20):
    """
    图推荐: 基于共同购买关系
    """

    cypher_query = """
        MATCH (u:User {id: $user_id})-[r1:PURCHASED]->(p1:Product)
        MATCH (p1)<-[r2:PURCHASED]-(other:User)-[r3:PURCHASED]->(p2:Product)
        WHERE NOT (u)-[:PURCHASED]->(p2)
          AND u <> other
        WITH p2,
             COUNT(DISTINCT other) AS共同用户数,
             AVG(r3.weight) AS平均权重
        RETURN
            id(p2) AS product_id,
            共同用户数,
            平均权重,
            共同用户数 * 平均权重 AS score
        ORDER BY score DESC
        LIMIT $top_n
    """

    return execute_age_query(cypher_query, {
        'user_id': user_id,
        'top_n': top_n
    })
```

### 8.3 内容推荐算法

```python
def content_recommend(user_id, top_n=20):
    """
    内容推荐: 基于向量相似度
    """

    # 1. 获取用户兴趣向量
    user_vector = get_user_embedding(user_id)

    # 2. pgvector相似度搜索
    query = """
        SELECT
            product_id,
            title,
            1 - (embedding <=> %(user_vector)s::vector) AS similarity
        FROM product_embeddings
        WHERE product_id NOT IN (
            SELECT product_id
            FROM user_interactions
            WHERE user_id = %(user_id)s
        )
        ORDER BY embedding <=> %(user_vector)s::vector
        LIMIT %(top_n)s;
    """

    return execute_query(query, {
        'user_id': user_id,
        'user_vector': user_vector.tolist(),
        'top_n': top_n
    })
```

---

## 9. 评估指标

### 9.1 在线指标

```python
# A/B测试指标

指标1: 点击率 (CTR)
CTR = 点击数 / 曝光数
目标: >3%

指标2: 转化率 (CVR)
CVR = 购买数 / 点击数
目标: >0.8%

指标3: 人均点击数
人均点击数 = 总点击数 / 活跃用户数
目标: >2次

指标4: 推荐贡献GMV
推荐GMV占比 = 推荐产生GMV / 总GMV
目标: >30%
```

### 9.2 离线指标

```python
# 离线评估指标

指标1: 准确率 (Precision@K)
Precision@20 = 命中数 / 20
目标: >35%

指标2: 召回率 (Recall@K)
Recall@20 = 命中数 / 用户实际喜欢的商品总数
目标: >15%

指标3: 覆盖率 (Coverage)
Coverage = 被推荐过的商品数 / 总商品数
目标: >60%

指标4: 多样性 (Diversity)
Diversity = 推荐列表中类目数 / 推荐数量
目标: >0.5
```

---

## 10. 预期成果

### 10.1 性能目标

| 指标 | 目标 | 说明 |
|------|------|------|
| 推荐QPS | 10,000 | P95 |
| 推荐延迟 | <100ms | P95 |
| 行为记录TPS | 5,000 | 写入 |
| 缓存命中率 | >80% | Redis |
| CTR | >3% | 点击率 |
| CVR | >0.8% | 转化率 |
| 准确率 | >35% | Precision@20 |

### 10.2 技术验证

✅ **Apache AGE图推荐**: 验证图遍历性能
✅ **pgvector向量检索**: 验证HNSW索引效果
✅ **混合策略融合**: 验证多策略加权效果
✅ **实时计算**: 验证增量更新机制
✅ **缓存策略**: 验证Redis集成效果

---

## 11. 下一步

**进入**: [02-架构设计](./02-架构设计.md)

**返回**: [案例库首页](../README.md)
