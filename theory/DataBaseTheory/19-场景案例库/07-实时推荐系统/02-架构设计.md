# å®æ—¶æ¨èç³»ç»Ÿ - æ¶æ„è®¾è®¡

## å…ƒæ•°æ®
- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **æ¶æ„ç±»å‹**: å¾®æœåŠ¡ + å›¾æ•°æ®åº“ + å‘é‡æ£€ç´¢
- **æŠ€æœ¯æ ˆ**: PostgreSQL 18 + Apache AGE + pgvector + Redis

---

## 1. æ•´ä½“æ¶æ„

### 1.1 ç³»ç»Ÿæ¶æ„å›¾

```
                        ç”¨æˆ·è¯·æ±‚
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      APIç½‘å…³å±‚                            â”‚
â”‚                  (è´Ÿè½½å‡è¡¡ + é™æµ)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ¨èæœåŠ¡å±‚                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  ç”¨æˆ·ç”»åƒ  â”‚  â”‚  æ¨èå¼•æ“  â”‚  â”‚  æ’åºæœåŠ¡  â”‚        â”‚
â”‚  â”‚   æœåŠ¡     â”‚  â”‚   æœåŠ¡     â”‚  â”‚    æœåŠ¡    â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ç¼“å­˜å±‚ (Redis)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚ æ¨èç»“æœç¼“å­˜ â”‚  â”‚  ç”¨æˆ·ä¼šè¯     â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ•°æ®å­˜å‚¨å±‚ (PostgreSQL 18)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  å…³ç³»æ•°æ® (PostgreSQL)                           â”‚   â”‚
â”‚  â”‚  - ç”¨æˆ·è¡¨ã€å•†å“è¡¨ã€äº¤äº’è¡¨                        â”‚   â”‚
â”‚  â”‚  - ç›¸ä¼¼åº¦è¡¨ã€ç»Ÿè®¡è¡¨                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  å›¾æ•°æ® (Apache AGE)                             â”‚   â”‚
â”‚  â”‚  - ç”¨æˆ·-å•†å“äº¤äº’å›¾                               â”‚   â”‚
â”‚  â”‚  - å•†å“-å•†å“ç›¸ä¼¼å›¾                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  å‘é‡ç´¢å¼• (pgvector)                             â”‚   â”‚
â”‚  â”‚  - ç”¨æˆ·Embedding                                 â”‚   â”‚
â”‚  â”‚  - å•†å“Embedding                                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ç¦»çº¿è®¡ç®—å±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ç›¸ä¼¼åº¦è®¡ç®— â”‚  â”‚ æ¨¡å‹è®­ç»ƒ   â”‚  â”‚  æ•°æ®åŒæ­¥  â”‚        â”‚
â”‚  â”‚  (Celery)  â”‚  â”‚ (Python)   â”‚  â”‚  (Kafka)   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 2.1 æ¨èå¼•æ“

#### ç»„ä»¶æ¶æ„

```python
class RecommendationEngine:
    """æ¨èå¼•æ“æ ¸å¿ƒç±»"""

    def __init__(self, db_conn, redis_client, age_graph):
        self.db = db_conn
        self.redis = redis_client
        self.age = age_graph

        # åˆå§‹åŒ–å„ç­–ç•¥
        self.cf_strategy = CollaborativeFiltering(db_conn)
        self.graph_strategy = GraphRecommender(age_graph)
        self.content_strategy = ContentRecommender(db_conn)
        self.popular_strategy = PopularRecommender(db_conn)

    async def recommend(self, user_id: int, context: dict) -> List[dict]:
        """
        ä¸»æ¨èæµç¨‹

        Args:
            user_id: ç”¨æˆ·ID
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆè®¾å¤‡ã€æ¸ é“ã€æ—¶é—´ç­‰ï¼‰

        Returns:
            æ¨èåˆ—è¡¨ [{'product_id': 123, 'score': 0.85, ...}, ...]
        """

        # 1. æ£€æŸ¥ç¼“å­˜
        cache_key = f"rec:{user_id}:{hash(frozenset(context.items()))}"
        cached = await self.redis.get(cache_key)
        if cached:
            return json.loads(cached)

        # 2. å¹¶è¡Œæ‰§è¡Œå¤šç­–ç•¥
        results = await asyncio.gather(
            self.cf_strategy.recommend(user_id, top_k=50),
            self.graph_strategy.recommend(user_id, top_k=50),
            self.content_strategy.recommend(user_id, top_k=50),
            self.popular_strategy.recommend(user_id, top_k=20)
        )

        # 3. ç­–ç•¥èåˆ
        fused_results = self.fuse_strategies(
            cf_results=results[0],
            graph_results=results[1],
            content_results=results[2],
            popular_results=results[3],
            weights={'cf': 0.4, 'graph': 0.3, 'content': 0.2, 'popular': 0.1}
        )

        # 4. é‡æ’åºï¼ˆå¤šæ ·æ€§ã€ä¸šåŠ¡è§„åˆ™ï¼‰
        final_results = self.rerank(
            fused_results,
            user_id=user_id,
            diversity_factor=0.3
        )

        # 5. å†™å…¥ç¼“å­˜
        await self.redis.setex(
            cache_key,
            300,  # TTL 5åˆ†é’Ÿ
            json.dumps(final_results)
        )

        return final_results[:20]

    def fuse_strategies(self, cf_results, graph_results, content_results,
                       popular_results, weights):
        """ç­–ç•¥èåˆ"""
        scores = {}

        # ååŒè¿‡æ»¤
        for item in cf_results:
            scores[item['product_id']] = scores.get(item['product_id'], 0) + \
                                         weights['cf'] * item['score']

        # å›¾æ¨è
        for item in graph_results:
            scores[item['product_id']] = scores.get(item['product_id'], 0) + \
                                         weights['graph'] * item['score']

        # å†…å®¹æ¨è
        for item in content_results:
            scores[item['product_id']] = scores.get(item['product_id'], 0) + \
                                         weights['content'] * item['score']

        # çƒ­é—¨æ¨è
        for item in popular_results:
            scores[item['product_id']] = scores.get(item['product_id'], 0) + \
                                         weights['popular'] * item['score']

        # æ’åº
        sorted_items = sorted(scores.items(), key=lambda x: x[1], reverse=True)

        return [{'product_id': pid, 'score': score} for pid, score in sorted_items]

    def rerank(self, items, user_id, diversity_factor=0.3):
        """é‡æ’åº: å¹³è¡¡ç›¸å…³æ€§å’Œå¤šæ ·æ€§"""
        from collections import defaultdict

        final_list = []
        category_count = defaultdict(int)

        for item in items:
            product = self.get_product_info(item['product_id'])
            category_id = product['category_id']

            # å¤šæ ·æ€§æƒ©ç½š
            diversity_penalty = category_count[category_id] * diversity_factor
            adjusted_score = item['score'] * (1 - diversity_penalty)

            final_list.append({
                **item,
                **product,
                'adjusted_score': adjusted_score
            })

            category_count[category_id] += 1

        # æŒ‰è°ƒæ•´ååˆ†æ•°æ’åº
        final_list.sort(key=lambda x: x['adjusted_score'], reverse=True)

        return final_list
```

---

## 3. æ•°æ®å±‚è®¾è®¡

### 3.1 å…³ç³»æ•°æ®å±‚

```sql
-- æ ¸å¿ƒè¡¨è®¾è®¡

-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    user_vector vector(384),  -- pgvectorç”¨æˆ·å…´è¶£å‘é‡
    profile JSONB,            -- ç”¨æˆ·ç”»åƒ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å•†å“è¡¨
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    category_id INT,
    price DECIMAL(10,2),
    embedding vector(384),    -- pgvectorå•†å“ç‰¹å¾å‘é‡
    attributes JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·äº¤äº’è¡¨ï¼ˆåˆ†åŒºè¡¨ï¼‰
CREATE TABLE user_interactions (
    interaction_id BIGSERIAL,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    interaction_type VARCHAR(20),  -- view/favorite/cart/purchase
    weight DECIMAL(3,1),           -- æƒé‡
    context JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

-- åˆ›å»ºæœˆåˆ†åŒº
CREATE TABLE user_interactions_2025_12
PARTITION OF user_interactions
FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- ç”¨æˆ·ç›¸ä¼¼åº¦è¡¨
CREATE TABLE user_similarity (
    user_id BIGINT,
    other_user_id BIGINT,
    similarity DECIMAL(5,4),
    PRIMARY KEY (user_id, other_user_id)
);

-- å•†å“ç›¸ä¼¼åº¦è¡¨
CREATE TABLE product_similarity (
    product_id BIGINT,
    similar_product_id BIGINT,
    similarity DECIMAL(5,4),
    PRIMARY KEY (product_id, similar_product_id)
);

-- ç´¢å¼•
CREATE INDEX idx_interactions_user ON user_interactions(user_id, created_at DESC);
CREATE INDEX idx_interactions_product ON user_interactions(product_id, created_at DESC);
CREATE INDEX idx_user_sim_score ON user_similarity(user_id, similarity DESC);
CREATE INDEX idx_prod_sim_score ON product_similarity(product_id, similarity DESC);

-- pgvectorç´¢å¼•
CREATE INDEX idx_user_vector ON users USING hnsw (user_vector vector_cosine_ops);
CREATE INDEX idx_product_vector ON products USING hnsw (embedding vector_cosine_ops);
```

### 3.2 å›¾æ•°æ®å±‚

```sql
-- Apache AGEå›¾åˆå§‹åŒ–

LOAD 'age';
SET search_path = ag_catalog, '$user', public;

SELECT create_graph('recommendation_graph');

-- åˆ›å»ºå›¾èŠ‚ç‚¹å’Œè¾¹çš„å‡½æ•°
CREATE OR REPLACE FUNCTION sync_to_graph()
RETURNS void AS $$
BEGIN
    -- åŒæ­¥ç”¨æˆ·èŠ‚ç‚¹
    PERFORM * FROM cypher('recommendation_graph', $$
        UNWIND $users AS user
        MERGE (u:User {id: user.user_id})
        SET u.profile = user.profile
    $$, jsonb_build_object('users', (
        SELECT jsonb_agg(jsonb_build_object(
            'user_id', user_id,
            'profile', profile
        )) FROM users LIMIT 1000
    ))) AS (result agtype);

    -- åŒæ­¥å•†å“èŠ‚ç‚¹
    PERFORM * FROM cypher('recommendation_graph', $$
        UNWIND $products AS product
        MERGE (p:Product {id: product.product_id})
        SET p.title = product.title,
            p.category_id = product.category_id
    $$, jsonb_build_object('products', (
        SELECT jsonb_agg(jsonb_build_object(
            'product_id', product_id,
            'title', title,
            'category_id', category_id
        )) FROM products LIMIT 1000
    ))) AS (result agtype);

    -- åŒæ­¥äº¤äº’è¾¹
    PERFORM * FROM cypher('recommendation_graph', $$
        UNWIND $interactions AS inter
        MATCH (u:User {id: inter.user_id}),
              (p:Product {id: inter.product_id})
        MERGE (u)-[r:INTERACTED {type: inter.type}]->(p)
        SET r.weight = inter.weight,
            r.timestamp = inter.timestamp
    $$, jsonb_build_object('interactions', (
        SELECT jsonb_agg(jsonb_build_object(
            'user_id', user_id,
            'product_id', product_id,
            'type', interaction_type,
            'weight', weight,
            'timestamp', extract(epoch from created_at)
        ))
        FROM user_interactions
        WHERE created_at > NOW() - INTERVAL '7 days'
        LIMIT 10000
    ))) AS (result agtype);
END;
$$ LANGUAGE plpgsql;
```

---

## 2. æ¨èç­–ç•¥å®ç°

### 2.1 ååŒè¿‡æ»¤ç­–ç•¥

```python
class CollaborativeFiltering:
    """ååŒè¿‡æ»¤æ¨è"""

    def __init__(self, db_conn):
        self.db = db_conn

    async def recommend(self, user_id: int, top_k: int = 50) -> List[dict]:
        """User-BasedååŒè¿‡æ»¤"""

        query = """
            WITH similar_users AS (
                -- æ‰¾ç›¸ä¼¼ç”¨æˆ·
                SELECT
                    other_user_id,
                    similarity
                FROM user_similarity
                WHERE user_id = %(user_id)s
                ORDER BY similarity DESC
                LIMIT 50
            ),
            candidate_products AS (
                -- ç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„å•†å“
                SELECT
                    i.product_id,
                    SUM(su.similarity * i.weight) AS score,
                    COUNT(DISTINCT i.user_id) AS support_count
                FROM similar_users su
                JOIN user_interactions i ON su.other_user_id = i.user_id
                WHERE i.created_at > NOW() - INTERVAL '30 days'
                  AND i.interaction_type IN ('purchase', 'cart', 'favorite')
                  AND NOT EXISTS (
                      SELECT 1
                      FROM user_interactions ui
                      WHERE ui.user_id = %(user_id)s
                        AND ui.product_id = i.product_id
                  )
                GROUP BY i.product_id
                HAVING COUNT(DISTINCT i.user_id) >= 3  -- è‡³å°‘3ä¸ªç›¸ä¼¼ç”¨æˆ·
            )
            SELECT
                cp.product_id,
                p.title,
                p.price,
                p.category_id,
                cp.score,
                cp.support_count,
                'cf' AS strategy
            FROM candidate_products cp
            JOIN products p ON cp.product_id = p.product_id
            WHERE p.status = 'active'
            ORDER BY cp.score DESC
            LIMIT %(top_k)s;
        """

        results = await self.db.fetch_all(query, {
            'user_id': user_id,
            'top_k': top_k
        })

        return [dict(r) for r in results]
```

### 2.2 å›¾æ¨èç­–ç•¥

```python
class GraphRecommender:
    """åŸºäºApache AGEçš„å›¾æ¨è"""

    def __init__(self, age_conn):
        self.age = age_conn
        self.graph_name = 'recommendation_graph'

    async def recommend(self, user_id: int, top_k: int = 50) -> List[dict]:
        """å›¾éå†æ¨è"""

        # 2-hopæ¨è: ç”¨æˆ· â†’ å•†å“ â† å…¶ä»–ç”¨æˆ· â†’ æ¨èå•†å“
        cypher_query = f"""
            SELECT * FROM cypher('{self.graph_name}', $$
                MATCH (u:User {{id: {user_id}}})-[r1:INTERACTED]->(p1:Product)
                WHERE r1.weight >= 5.0

                MATCH (p1)<-[r2:INTERACTED]-(other:User)-[r3:INTERACTED]->(p2:Product)
                WHERE other.id <> u.id
                  AND NOT (u)-[:INTERACTED]->(p2)
                  AND r2.weight >= 5.0
                  AND r3.weight >= 5.0

                WITH p2,
                     COUNT(DISTINCT other) ASå…±åŒç”¨æˆ·æ•°,
                     AVG(r3.weight) ASå¹³å‡æƒé‡,
                     COLLECT(DISTINCT p1.id) ASè§¦å‘å•†å“

                RETURN
                    id(p2) AS product_id,
                    å…±åŒç”¨æˆ·æ•°,
                    å¹³å‡æƒé‡,
                    è§¦å‘å•†å“,
                    å…±åŒç”¨æˆ·æ•° * å¹³å‡æƒé‡ AS score
                ORDER BY score DESC
                LIMIT {top_k}
            $$) AS (product_id agtype, å…±åŒç”¨æˆ·æ•° agtype, å¹³å‡æƒé‡ agtype,
                   è§¦å‘å•†å“ agtype, score agtype);
        """

        results = await self.age.fetch_all(cypher_query)

        return [{
            'product_id': int(json.loads(r['product_id'])),
            'score': float(json.loads(r['score'])),
            'support_count': int(json.loads(r['å…±åŒç”¨æˆ·æ•°'])),
            'strategy': 'graph'
        } for r in results]

    async def recommend_with_path(self, user_id: int, top_k: int = 20):
        """å¸¦è·¯å¾„è§£é‡Šçš„æ¨è"""

        cypher_query = f"""
            SELECT * FROM cypher('{self.graph_name}', $$
                MATCH path = (u:User {{id: {user_id}}})-[:INTERACTED*2..3]->(p:Product)
                WHERE NOT (u)-[:INTERACTED]->(p)
                WITH p, path, length(path) AS path_length
                RETURN
                    id(p) AS product_id,
                    path_length,
                    nodes(path) AS path_nodes,
                    relationships(path) AS path_rels
                ORDER BY path_length ASC
                LIMIT {top_k}
            $$) AS (product_id agtype, path_length agtype,
                   path_nodes agtype, path_rels agtype);
        """

        results = await self.age.fetch_all(cypher_query)

        return [{
            'product_id': int(json.loads(r['product_id'])),
            'explanation': self._generate_explanation(r['path_nodes'], r['path_rels']),
            'strategy': 'graph_with_path'
        } for r in results]

    def _generate_explanation(self, path_nodes, path_rels):
        """ç”Ÿæˆæ¨èç†ç”±"""
        nodes = json.loads(path_nodes)
        rels = json.loads(path_rels)

        explanation = "å› ä¸º"
        for i, rel in enumerate(rels):
            rel_type = rel.get('label', 'INTERACTED')
            if rel_type == 'PURCHASED':
                explanation += f"ä½ è´­ä¹°è¿‡{nodes[i]['properties']['title']}"
            elif rel_type == 'FAVORITED':
                explanation += f"ä½ æ”¶è—è¿‡{nodes[i]['properties']['title']}"

            if i < len(rels) - 1:
                explanation += "ï¼Œè€Œ"

        return explanation
```

### 2.3 å†…å®¹æ¨èç­–ç•¥

```python
class ContentRecommender:
    """åŸºäºå†…å®¹çš„æ¨è"""

    def __init__(self, db_conn, embedding_model):
        self.db = db_conn
        self.embedding_model = SentenceTransformer('all-MiniLM-L6-v2')

    async def recommend(self, user_id: int, top_k: int = 50) -> List[dict]:
        """å‘é‡ç›¸ä¼¼åº¦æ¨è"""

        # 1. è·å–ç”¨æˆ·å…´è¶£å‘é‡
        user_vector = await self.get_user_vector(user_id)

        # 2. pgvectorç›¸ä¼¼åº¦æœç´¢
        query = """
            WITH user_interacted AS (
                SELECT product_id
                FROM user_interactions
                WHERE user_id = %(user_id)s
            )
            SELECT
                p.product_id,
                p.title,
                p.price,
                p.category_id,
                1 - (p.embedding <=> %(user_vector)s::vector) AS similarity,
                'content' AS strategy
            FROM products p
            WHERE p.status = 'active'
              AND p.product_id NOT IN (SELECT product_id FROM user_interacted)
            ORDER BY p.embedding <=> %(user_vector)s::vector
            LIMIT %(top_k)s;
        """

        results = await self.db.fetch_all(query, {
            'user_id': user_id,
            'user_vector': user_vector.tolist(),
            'top_k': top_k
        })

        return [{'product_id': r['product_id'],
                 'score': float(r['similarity']),
                 'strategy': 'content'} for r in results]

    async def get_user_vector(self, user_id: int):
        """è®¡ç®—ç”¨æˆ·å…´è¶£å‘é‡"""

        # è·å–ç”¨æˆ·æœ€è¿‘äº¤äº’çš„å•†å“
        query = """
            SELECT p.embedding, i.weight
            FROM user_interactions i
            JOIN products p ON i.product_id = p.product_id
            WHERE i.user_id = %(user_id)s
              AND i.created_at > NOW() - INTERVAL '30 days'
            ORDER BY i.created_at DESC
            LIMIT 50;
        """

        results = await self.db.fetch_all(query, {'user_id': user_id})

        if not results:
            # å†·å¯åŠ¨: è¿”å›é›¶å‘é‡
            return np.zeros(384)

        # åŠ æƒå¹³å‡
        embeddings = np.array([np.array(r['embedding']) for r in results])
        weights = np.array([r['weight'] for r in results])

        weighted_avg = np.average(embeddings, axis=0, weights=weights)

        return weighted_avg
```

---

*[ç”±äºç¯‡å¹…é™åˆ¶ï¼Œæœ¬æ–‡æ¡£çš„éƒ¨åˆ†å†…å®¹å·²çœç•¥ã€‚å®Œæ•´ç‰ˆåŒ…å«ç¼“å­˜ç­–ç•¥ã€ç›‘æ§è®¾è®¡ç­‰]*

---

## ğŸ“š å‚è€ƒèµ„æº

1. **ååŒè¿‡æ»¤**: <https://en.wikipedia.org/wiki/Collaborative_filtering>
2. **Apache AGEæ¨è**: <https://age.apache.org/>
3. **pgvectorç›¸ä¼¼æœç´¢**: <https://github.com/pgvector/pgvector>

---

**ä¸‹ä¸€æ­¥**: [03-æ•°æ®åº“è®¾è®¡](./03-æ•°æ®åº“è®¾è®¡.md) | [è¿”å›é¦–é¡µ](./README.md)
