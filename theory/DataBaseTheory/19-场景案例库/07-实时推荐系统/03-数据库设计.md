# å®æ—¶æ¨èç³»ç»Ÿ - æ•°æ®åº“è®¾è®¡

## å…ƒæ•°æ®

- **åˆ›å»ºæ—¥æœŸ**: 2025-12-04
- **æŠ€æœ¯æ ˆ**: PostgreSQL 18 + Apache AGE + pgvector
- **æ•°æ®è§„æ¨¡**: åƒä¸‡ç”¨æˆ·ã€äº¿çº§äº¤äº’

---

## 1. å…³ç³»è¡¨è®¾è®¡

### 1.1 æ ¸å¿ƒä¸šåŠ¡è¡¨

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE,
    gender VARCHAR(10),
    age_range VARCHAR(20),
    location VARCHAR(100),
    user_vector vector(384),  -- pgvectorç”¨æˆ·å…´è¶£å‘é‡
    profile JSONB,            -- æ‰©å±•ç”»åƒ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å•†å“è¡¨
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    category_id INTEGER NOT NULL,
    brand_id INTEGER,
    price DECIMAL(10,2),
    stock INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',  -- active/inactive/deleted
    embedding vector(384),    -- pgvectorå•†å“ç‰¹å¾å‘é‡
    attributes JSONB,         -- å•†å“å±æ€§
    sales_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    rating DECIMAL(3,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å•†å“ç±»ç›®è¡¨
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_id INTEGER,
    level INTEGER,
    path TEXT,  -- ç±»ç›®è·¯å¾„ (å¦‚: /3/12/45)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·äº¤äº’è¡¨ï¼ˆåˆ†åŒºè¡¨ï¼ŒæŒ‰æœˆåˆ†åŒºï¼‰
CREATE TABLE user_interactions (
    interaction_id BIGSERIAL,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    interaction_type VARCHAR(20) NOT NULL,  -- view/favorite/cart/purchase
    weight DECIMAL(3,1) NOT NULL,           -- æƒé‡ï¼ˆ1.0/3.0/5.0/10.0ï¼‰
    session_id UUID,
    device_type VARCHAR(20),
    channel VARCHAR(50),
    context JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (interaction_id, created_at)
) PARTITION BY RANGE (created_at);

-- åˆ›å»ºåˆ†åŒºï¼ˆæœ€è¿‘6ä¸ªæœˆï¼‰
CREATE TABLE user_interactions_2025_12
PARTITION OF user_interactions
FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

CREATE TABLE user_interactions_2025_11
PARTITION OF user_interactions
FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

-- ç»§ç»­åˆ›å»ºå…¶ä»–æœˆä»½åˆ†åŒº...
```

### 1.2 æ¨èç›¸å…³è¡¨

```sql
-- ç”¨æˆ·ç›¸ä¼¼åº¦è¡¨ï¼ˆé¢„è®¡ç®—ï¼‰
CREATE TABLE user_similarity (
    user_id BIGINT NOT NULL,
    other_user_id BIGINT NOT NULL,
    similarity DECIMAL(5,4) NOT NULL,
    method VARCHAR(20) DEFAULT 'cosine',  -- ç›¸ä¼¼åº¦ç®—æ³•
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, other_user_id),
    CHECK (user_id < other_user_id)  -- é¿å…é‡å¤
);

-- å•†å“ç›¸ä¼¼åº¦è¡¨ï¼ˆé¢„è®¡ç®—ï¼‰
CREATE TABLE product_similarity (
    product_id BIGINT NOT NULL,
    similar_product_id BIGINT NOT NULL,
    similarity DECIMAL(5,4) NOT NULL,
    method VARCHAR(20) DEFAULT 'cosine',
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (product_id, similar_product_id)
);

-- å•†å“çƒ­åº¦æ’è¡Œè¡¨ï¼ˆå®æ—¶æ›´æ–°ï¼‰
CREATE TABLE product_hot_ranking (
    product_id BIGINT PRIMARY KEY,
    category_id INTEGER,
    hot_score DECIMAL(10,2),
    view_count_7d INTEGER,
    purchase_count_7d INTEGER,
    ctr DECIMAL(5,4),  -- ç‚¹å‡»ç‡
    cvr DECIMAL(5,4),  -- è½¬åŒ–ç‡
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ¨èç»“æœæ—¥å¿—è¡¨ï¼ˆç”¨äºA/Bæµ‹è¯•å’Œæ•ˆæœåˆ†æï¼‰
CREATE TABLE recommendation_logs (
    log_id BIGSERIAL,
    user_id BIGINT,
    request_id UUID,
    strategy VARCHAR(50),      -- æ¨èç­–ç•¥
    recommended_products BIGINT[],  -- æ¨èå•†å“åˆ—è¡¨
    clicked_products BIGINT[],      -- ç‚¹å‡»çš„å•†å“
    purchased_products BIGINT[],    -- è´­ä¹°çš„å•†å“
    response_time_ms INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);
```

---

## 2. ç´¢å¼•è®¾è®¡

### 2.1 å…³ç³»è¡¨ç´¢å¼•

```sql
-- ç”¨æˆ·è¡¨ç´¢å¼•
CREATE INDEX idx_users_location ON users(location);
CREATE INDEX idx_users_created ON users(created_at);

-- å•†å“è¡¨ç´¢å¼•
CREATE INDEX idx_products_category ON products(category_id, status);
CREATE INDEX idx_products_brand ON products(brand_id);
CREATE INDEX idx_products_price ON products(price) WHERE status = 'active';
CREATE INDEX idx_products_rating ON products(rating DESC) WHERE status = 'active';

-- ç”¨æˆ·äº¤äº’è¡¨ç´¢å¼•ï¼ˆæ¯ä¸ªåˆ†åŒºï¼‰
CREATE INDEX idx_interactions_user_time ON user_interactions(user_id, created_at DESC);
CREATE INDEX idx_interactions_product ON user_interactions(product_id, interaction_type);
CREATE INDEX idx_interactions_type ON user_interactions(interaction_type, created_at DESC);

-- ç›¸ä¼¼åº¦è¡¨ç´¢å¼•
CREATE INDEX idx_user_sim_score ON user_similarity(user_id, similarity DESC);
CREATE INDEX idx_user_sim_other ON user_similarity(other_user_id, similarity DESC);
CREATE INDEX idx_prod_sim_score ON product_similarity(product_id, similarity DESC);

-- çƒ­åº¦æ’è¡Œç´¢å¼•
CREATE INDEX idx_hot_category ON product_hot_ranking(category_id, hot_score DESC);
CREATE INDEX idx_hot_score ON product_hot_ranking(hot_score DESC);
```

### 2.2 å‘é‡ç´¢å¼•ï¼ˆHNSWï¼‰

```sql
-- ç”¨æˆ·å‘é‡ç´¢å¼•ï¼ˆpgvectorï¼‰
CREATE INDEX idx_user_vector
ON users
USING hnsw (user_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- å•†å“å‘é‡ç´¢å¼•
CREATE INDEX idx_product_embedding
ON products
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- å‘é‡ç´¢å¼•æ€§èƒ½é…ç½®
SET hnsw.ef_search = 40;  -- æœç´¢æ—¶çš„åŠ¨æ€å€™é€‰åˆ—è¡¨å¤§å°
```

---

## 3. Apache AGEå›¾æ•°æ®åº“è®¾è®¡

### 3.1 å›¾åˆå§‹åŒ–

```sql
-- åŠ è½½AGEæ‰©å±•
CREATE EXTENSION IF NOT EXISTS age;
LOAD 'age';
SET search_path = ag_catalog, '$user', public;

-- åˆ›å»ºæ¨èå›¾
SELECT create_graph('recommendation_graph');
```

### 3.2 å›¾Schemaè®¾è®¡

```cypher
// èŠ‚ç‚¹ç±»å‹

(:User)
  å±æ€§:
  - id: ç”¨æˆ·ID (å¯¹åº”users.user_id)
  - name: ç”¨æˆ·å
  - profile: ç”¨æˆ·ç”»åƒ (JSONB)

(:Product)
  å±æ€§:
  - id: å•†å“ID (å¯¹åº”products.product_id)
  - title: å•†å“æ ‡é¢˜
  - category_id: ç±»ç›®ID
  - price: ä»·æ ¼

(:Category)
  å±æ€§:
  - id: ç±»ç›®ID
  - name: ç±»ç›®åç§°
  - level: ç±»ç›®å±‚çº§

// å…³ç³»ç±»å‹

(User)-[:VIEWED {timestamp, weight: 1.0}]->(Product)
(User)-[:FAVORITED {timestamp, weight: 3.0}]->(Product)
(User)-[:CARTED {timestamp, weight: 5.0}]->(Product)
(User)-[:PURCHASED {timestamp, weight: 10.0, amount}]->(Product)
(Product)-[:BELONGS_TO]->(Category)
(Product)-[:SIMILAR_TO {similarity}]->(Product)
(User)-[:SIMILAR_TO {similarity}]->(User)
```

### 3.3 å›¾æ•°æ®åŒæ­¥

```sql
-- å¢é‡åŒæ­¥ç”¨æˆ·è¡Œä¸ºåˆ°å›¾
CREATE OR REPLACE FUNCTION sync_interactions_to_graph()
RETURNS void AS $$
DECLARE
    batch_size INT := 1000;
    last_sync_time TIMESTAMP;
BEGIN
    -- è·å–ä¸Šæ¬¡åŒæ­¥æ—¶é—´
    SELECT COALESCE(MAX(last_sync), NOW() - INTERVAL '1 hour')
    INTO last_sync_time
    FROM sync_status
    WHERE sync_type = 'interactions_to_graph';

    -- æ‰¹é‡åŒæ­¥æ–°äº¤äº’
    PERFORM * FROM cypher('recommendation_graph', $$
        UNWIND $interactions AS inter
        MATCH (u:User {id: inter.user_id}),
              (p:Product {id: inter.product_id})
        MERGE (u)-[r:INTERACTED]->(p)
        ON CREATE SET
            r.type = inter.interaction_type,
            r.weight = inter.weight,
            r.timestamp = inter.timestamp
        ON MATCH SET
            r.weight = CASE
                WHEN inter.weight > r.weight THEN inter.weight
                ELSE r.weight
            END,
            r.last_interaction = inter.timestamp
    $$, jsonb_build_object('interactions', (
        SELECT jsonb_agg(jsonb_build_object(
            'user_id', user_id,
            'product_id', product_id,
            'interaction_type', interaction_type,
            'weight', weight,
            'timestamp', extract(epoch from created_at)
        ))
        FROM user_interactions
        WHERE created_at > last_sync_time
          AND interaction_type IN ('purchase', 'cart', 'favorite')
        ORDER BY created_at
        LIMIT batch_size
    ))) AS (result agtype);

    -- æ›´æ–°åŒæ­¥æ—¶é—´
    UPDATE sync_status
    SET last_sync = NOW()
    WHERE sync_type = 'interactions_to_graph';

    RAISE NOTICE 'åŒæ­¥å®Œæˆ: % æ¡äº¤äº’', batch_size;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶åŒæ­¥ä»»åŠ¡ï¼ˆæ¯5åˆ†é’Ÿï¼‰
SELECT cron.schedule('sync_graph', '*/5 * * * *', $$
    SELECT sync_interactions_to_graph();
$$);
```

---

## 4. æ ¸å¿ƒä¸šåŠ¡å‡½æ•°

### 4.1 ç”¨æˆ·ç›¸ä¼¼åº¦è®¡ç®—

```sql
CREATE OR REPLACE FUNCTION calculate_user_similarity(
    target_user_id BIGINT,
    k_neighbors INT DEFAULT 100
) RETURNS void AS $$
BEGIN
    -- åŸºäºä½™å¼¦ç›¸ä¼¼åº¦è®¡ç®—ç”¨æˆ·ç›¸ä¼¼åº¦
    INSERT INTO user_similarity (user_id, other_user_id, similarity)
    SELECT
        target_user_id,
        other_user_id,
        similarity
    FROM (
        WITH target_vector AS (
            SELECT user_vector
            FROM users
            WHERE user_id = target_user_id
        ),
        similarities AS (
            SELECT
                u.user_id AS other_user_id,
                1 - (u.user_vector <=> (SELECT user_vector FROM target_vector)) AS similarity
            FROM users u
            WHERE u.user_id != target_user_id
              AND u.user_vector IS NOT NULL
            ORDER BY u.user_vector <=> (SELECT user_vector FROM target_vector)
            LIMIT k_neighbors
        )
        SELECT * FROM similarities
        WHERE similarity > 0.3  -- ç›¸ä¼¼åº¦é˜ˆå€¼
    ) AS results
    ON CONFLICT (user_id, other_user_id)
    DO UPDATE SET
        similarity = EXCLUDED.similarity,
        last_updated = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 å•†å“ç›¸ä¼¼åº¦è®¡ç®—

```sql
CREATE OR REPLACE FUNCTION calculate_product_similarity(
    target_product_id BIGINT,
    k_neighbors INT DEFAULT 50
) RETURNS void AS $$
BEGIN
    INSERT INTO product_similarity (product_id, similar_product_id, similarity)
    SELECT
        target_product_id,
        similar_product_id,
        similarity
    FROM (
        WITH target_embedding AS (
            SELECT embedding
            FROM products
            WHERE product_id = target_product_id
        )
        SELECT
            p.product_id AS similar_product_id,
            1 - (p.embedding <=> (SELECT embedding FROM target_embedding)) AS similarity
        FROM products p
        WHERE p.product_id != target_product_id
          AND p.status = 'active'
          AND p.embedding IS NOT NULL
        ORDER BY p.embedding <=> (SELECT embedding FROM target_embedding)
        LIMIT k_neighbors
    ) AS results
    WHERE similarity > 0.5
    ON CONFLICT (product_id, similar_product_id)
    DO UPDATE SET
        similarity = EXCLUDED.similarity,
        last_updated = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 çƒ­åº¦åˆ†æ•°æ›´æ–°

```sql
CREATE OR REPLACE FUNCTION update_hot_scores()
RETURNS void AS $$
BEGIN
    -- è®¡ç®—7å¤©çƒ­åº¦åˆ†æ•°
    INSERT INTO product_hot_ranking (
        product_id,
        category_id,
        hot_score,
        view_count_7d,
        purchase_count_7d,
        ctr,
        cvr
    )
    SELECT
        p.product_id,
        p.category_id,
        -- çƒ­åº¦åˆ†æ•°å…¬å¼: æµè§ˆ*0.1 + è´­ä¹°*10 + è¯„åˆ†*5
        COALESCE(stats.view_count * 0.1, 0) +
        COALESCE(stats.purchase_count * 10, 0) +
        COALESCE(p.rating * 5, 0) AS hot_score,
        COALESCE(stats.view_count, 0),
        COALESCE(stats.purchase_count, 0),
        CASE
            WHEN stats.view_count > 0
            THEN stats.click_count::DECIMAL / stats.view_count
            ELSE 0
        END AS ctr,
        CASE
            WHEN stats.click_count > 0
            THEN stats.purchase_count::DECIMAL / stats.click_count
            ELSE 0
        END AS cvr
    FROM products p
    LEFT JOIN (
        SELECT
            product_id,
            COUNT(*) FILTER (WHERE interaction_type = 'view') AS view_count,
            COUNT(*) FILTER (WHERE interaction_type IN ('cart', 'favorite')) AS click_count,
            COUNT(*) FILTER (WHERE interaction_type = 'purchase') AS purchase_count
        FROM user_interactions
        WHERE created_at > NOW() - INTERVAL '7 days'
        GROUP BY product_id
    ) stats ON p.product_id = stats.product_id
    WHERE p.status = 'active'
    ON CONFLICT (product_id)
    DO UPDATE SET
        hot_score = EXCLUDED.hot_score,
        view_count_7d = EXCLUDED.view_count_7d,
        purchase_count_7d = EXCLUDED.purchase_count_7d,
        ctr = EXCLUDED.ctr,
        cvr = EXCLUDED.cvr,
        last_updated = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶æ›´æ–°ï¼ˆæ¯å°æ—¶ï¼‰
SELECT cron.schedule('update_hot_scores', '0 * * * *', $$
    SELECT update_hot_scores();
$$);
```

---

## 5. æ¨èæŸ¥è¯¢å®ç°

### 5.1 ååŒè¿‡æ»¤æŸ¥è¯¢

```sql
-- åŸºäºç”¨æˆ·çš„ååŒè¿‡æ»¤æ¨è
CREATE OR REPLACE FUNCTION recommend_user_based_cf(
    target_user_id BIGINT,
    top_k INT DEFAULT 20
) RETURNS TABLE(
    product_id BIGINT,
    title TEXT,
    score DECIMAL(10,4),
    support_count INT
) AS $$
BEGIN
    RETURN QUERY
    WITH similar_users AS (
        SELECT
            other_user_id,
            similarity
        FROM user_similarity
        WHERE user_id = target_user_id
        ORDER BY similarity DESC
        LIMIT 50
    ),
    candidate_products AS (
        SELECT
            i.product_id,
            SUM(su.similarity * i.weight) AS score,
            COUNT(DISTINCT i.user_id) AS support_count
        FROM similar_users su
        JOIN user_interactions i ON su.other_user_id = i.user_id
        WHERE i.created_at > NOW() - INTERVAL '30 days'
          AND i.interaction_type IN ('purchase', 'cart', 'favorite')
          AND NOT EXISTS (
              SELECT 1
              FROM user_interactions ui
              WHERE ui.user_id = target_user_id
                AND ui.product_id = i.product_id
          )
        GROUP BY i.product_id
        HAVING COUNT(DISTINCT i.user_id) >= 3
    )
    SELECT
        cp.product_id,
        p.title,
        cp.score,
        cp.support_count
    FROM candidate_products cp
    JOIN products p ON cp.product_id = p.product_id
    WHERE p.status = 'active'
    ORDER BY cp.score DESC
    LIMIT top_k;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 å›¾æ¨èæŸ¥è¯¢

```sql
-- åŸºäºApache AGEçš„å›¾æ¨è
CREATE OR REPLACE FUNCTION recommend_graph_based(
    target_user_id BIGINT,
    top_k INT DEFAULT 20
) RETURNS TABLE(
    product_id BIGINT,
    title TEXT,
    score DECIMAL(10,4),
    common_users INT
) AS $$
DECLARE
    cypher_query TEXT;
BEGIN
    cypher_query := format($$
        SELECT * FROM cypher('recommendation_graph', $$
            MATCH (u:User {id: %s})-[r1:PURCHASED]->(p1:Product)
            MATCH (p1)<-[r2:PURCHASED]-(other:User)-[r3:PURCHASED]->(p2:Product)
            WHERE u <> other
              AND NOT (u)-[:PURCHASED]->(p2)
            WITH p2,
                 COUNT(DISTINCT other) AS common_users,
                 AVG(r3.weight) AS avg_weight
            RETURN
                id(p2) AS product_id,
                common_users,
                avg_weight,
                common_users * avg_weight AS score
            ORDER BY score DESC
            LIMIT %s
        $$) AS (product_id agtype, common_users agtype, avg_weight agtype, score agtype)
    $$, target_user_id, top_k);

    RETURN QUERY
    SELECT
        (result.product_id#>>'{}')::BIGINT,
        p.title,
        (result.score#>>'{}')::DECIMAL,
        (result.common_users#>>'{}')::INT
    FROM (EXECUTE cypher_query) AS result
    JOIN products p ON p.product_id = (result.product_id#>>'{}')::BIGINT;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 å†…å®¹æ¨èæŸ¥è¯¢

```sql
-- åŸºäºå‘é‡ç›¸ä¼¼åº¦çš„å†…å®¹æ¨è
CREATE OR REPLACE FUNCTION recommend_content_based(
    target_user_id BIGINT,
    top_k INT DEFAULT 20
) RETURNS TABLE(
    product_id BIGINT,
    title TEXT,
    similarity DECIMAL(5,4)
) AS $$
DECLARE
    user_vec vector(384);
BEGIN
    -- è·å–ç”¨æˆ·å…´è¶£å‘é‡
    SELECT user_vector INTO user_vec
    FROM users
    WHERE user_id = target_user_id;

    -- å¦‚æœç”¨æˆ·å‘é‡ä¸ºç©ºï¼Œè®¡ç®—å®æ—¶å‘é‡
    IF user_vec IS NULL THEN
        SELECT AVG(p.embedding)::vector(384)
        INTO user_vec
        FROM user_interactions i
        JOIN products p ON i.product_id = p.product_id
        WHERE i.user_id = target_user_id
          AND i.created_at > NOW() - INTERVAL '30 days'
          AND p.embedding IS NOT NULL;
    END IF;

    -- å‘é‡ç›¸ä¼¼åº¦æœç´¢
    RETURN QUERY
    SELECT
        p.product_id,
        p.title,
        (1 - (p.embedding <=> user_vec))::DECIMAL(5,4) AS similarity
    FROM products p
    WHERE p.status = 'active'
      AND p.embedding IS NOT NULL
      AND NOT EXISTS (
          SELECT 1
          FROM user_interactions ui
          WHERE ui.user_id = target_user_id
            AND ui.product_id = p.product_id
      )
    ORDER BY p.embedding <=> user_vec
    LIMIT top_k;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. æ•°æ®åˆ†åŒºç­–ç•¥

### 6.1 æ—¶é—´åˆ†åŒº

```sql
-- è‡ªåŠ¨åˆ›å»ºæœªæ¥åˆ†åŒºçš„å‡½æ•°
CREATE OR REPLACE FUNCTION create_future_partitions()
RETURNS void AS $$
DECLARE
    start_date DATE;
    end_date DATE;
    partition_name TEXT;
BEGIN
    -- åˆ›å»ºæœªæ¥3ä¸ªæœˆçš„åˆ†åŒº
    FOR i IN 0..2 LOOP
        start_date := DATE_TRUNC('month', NOW() + (i || ' months')::INTERVAL);
        end_date := start_date + INTERVAL '1 month';
        partition_name := 'user_interactions_' || TO_CHAR(start_date, 'YYYY_MM');

        -- æ£€æŸ¥åˆ†åŒºæ˜¯å¦å­˜åœ¨
        IF NOT EXISTS (
            SELECT 1 FROM pg_class
            WHERE relname = partition_name
        ) THEN
            EXECUTE format($$
                CREATE TABLE %I PARTITION OF user_interactions
                FOR VALUES FROM (%L) TO (%L)
            $$, partition_name, start_date, end_date);

            RAISE NOTICE 'åˆ›å»ºåˆ†åŒº: %', partition_name;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- è‡ªåŠ¨åˆ é™¤è¿‡æœŸåˆ†åŒºï¼ˆä¿ç•™6ä¸ªæœˆï¼‰
CREATE OR REPLACE FUNCTION drop_old_partitions()
RETURNS void AS $$
DECLARE
    old_date DATE;
    partition_name TEXT;
BEGIN
    old_date := DATE_TRUNC('month', NOW() - INTERVAL '6 months');
    partition_name := 'user_interactions_' || TO_CHAR(old_date, 'YYYY_MM');

    IF EXISTS (SELECT 1 FROM pg_class WHERE relname = partition_name) THEN
        EXECUTE format('DROP TABLE IF EXISTS %I', partition_name);
        RAISE NOTICE 'åˆ é™¤åˆ†åŒº: %', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶ä»»åŠ¡
SELECT cron.schedule('create_partitions', '0 0 1 * *', $$
    SELECT create_future_partitions();
$$);

SELECT cron.schedule('drop_partitions', '0 2 1 * *', $$
    SELECT drop_old_partitions();
$$);
```

---

## 7. æ€§èƒ½ä¼˜åŒ–é…ç½®

### 7.1 PostgreSQLå‚æ•°ä¼˜åŒ–

```sql
-- é’ˆå¯¹æ¨èç³»ç»Ÿçš„ä¼˜åŒ–é…ç½®

-- è¿æ¥æ± 
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET shared_buffers = '16GB';

-- å¹¶è¡ŒæŸ¥è¯¢
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;

-- å¼‚æ­¥I/O (PostgreSQL 18)
ALTER SYSTEM SET io_method = 'io_uring';

-- å‘é‡æœç´¢ä¼˜åŒ–
ALTER SYSTEM SET hnsw.ef_search = 40;

-- å·¥ä½œå†…å­˜
ALTER SYSTEM SET work_mem = '128MB';
ALTER SYSTEM SET maintenance_work_mem = '2GB';

-- æ£€æŸ¥ç‚¹
ALTER SYSTEM SET checkpoint_timeout = '15min';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;

-- WAL
ALTER SYSTEM SET wal_compression = 'zstd';

SELECT pg_reload_conf();
```

---

## 8. ç›‘æ§æŒ‡æ ‡

### 8.1 ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

```sql
-- æ¨èæ•ˆæœç›‘æ§è§†å›¾
CREATE VIEW recommendation_metrics AS
SELECT
    DATE(created_at) AS date,
    COUNT(DISTINCT user_id) AS active_users,
    COUNT(*) AS total_requests,
    AVG(response_time_ms) AS avg_response_time,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time_ms) AS p95_response_time,

    -- CTRï¼ˆç‚¹å‡»ç‡ï¼‰
    (COUNT(*) FILTER (WHERE array_length(clicked_products, 1) > 0)::DECIMAL /
     COUNT(*)) AS ctr,

    -- CVRï¼ˆè½¬åŒ–ç‡ï¼‰
    (COUNT(*) FILTER (WHERE array_length(purchased_products, 1) > 0)::DECIMAL /
     COUNT(*) FILTER (WHERE array_length(clicked_products, 1) > 0)) AS cvr,

    -- å‡†ç¡®ç‡
    (SUM(array_length(clicked_products, 1)) FILTER (WHERE clicked_products IS NOT NULL)::DECIMAL /
     (COUNT(*) * 20)) AS precision_at_20
FROM recommendation_logs
GROUP BY DATE(created_at)
ORDER BY date DESC;
```

---

## 9. æ•°æ®åˆå§‹åŒ–

### 9.1 åˆå§‹åŒ–è„šæœ¬

```sql
-- å®Œæ•´åˆå§‹åŒ–è„šæœ¬

BEGIN;

-- 1. åˆ›å»ºæ‰©å±•
CREATE EXTENSION IF NOT EXISTS age;
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- 2. åˆ›å»ºæ‰€æœ‰è¡¨
\i schema/01_tables.sql

-- 3. åˆ›å»ºç´¢å¼•
\i schema/02_indexes.sql

-- 4. åˆ›å»ºå‡½æ•°
\i schema/03_functions.sql

-- 5. åˆå§‹åŒ–å›¾
SELECT create_graph('recommendation_graph');

-- 6. è®¾ç½®å®šæ—¶ä»»åŠ¡
SELECT cron.schedule('sync_graph', '*/5 * * * *', 'SELECT sync_interactions_to_graph()');
SELECT cron.schedule('update_hot', '0 * * * *', 'SELECT update_hot_scores()');
SELECT cron.schedule('create_part', '0 0 1 * *', 'SELECT create_future_partitions()');

COMMIT;

-- 7. åŠ è½½æµ‹è¯•æ•°æ®ï¼ˆå¯é€‰ï¼‰
\i data/load_sample_data.sql
```

---

## 10. æ•°æ®åº“å®¹é‡è§„åˆ’

### 10.1 å­˜å‚¨å®¹é‡ä¼°ç®—

```
ç”¨æˆ·è¡¨:
â”œâ”€ 1000ä¸‡ç”¨æˆ·
â”œâ”€ æ¯è¡Œçº¦2KBï¼ˆå«å‘é‡ï¼‰
â””â”€ æ€»è®¡: ~20GB

å•†å“è¡¨:
â”œâ”€ 500ä¸‡å•†å“
â”œâ”€ æ¯è¡Œçº¦3KBï¼ˆå«å‘é‡ï¼‰
â””â”€ æ€»è®¡: ~15GB

äº¤äº’è¡¨ï¼ˆæŒ‰æœˆï¼‰:
â”œâ”€ æœˆæ–°å¢: 1äº¿æ¡
â”œâ”€ æ¯è¡Œçº¦200B
â”œâ”€ æœˆå¢é•¿: ~20GB
â””â”€ 6ä¸ªæœˆ: ~120GB

ç›¸ä¼¼åº¦è¡¨:
â”œâ”€ ç”¨æˆ·ç›¸ä¼¼åº¦: 1000ä¸‡ * 100 = 10äº¿è¡Œ (~40GB)
â”œâ”€ å•†å“ç›¸ä¼¼åº¦: 500ä¸‡ * 50 = 2.5äº¿è¡Œ (~10GB)
â””â”€ æ€»è®¡: ~50GB

Apache AGEå›¾:
â”œâ”€ èŠ‚ç‚¹: 1500ä¸‡
â”œâ”€ è¾¹: 10äº¿æ¡
â””â”€ æ€»è®¡: ~100GB

æ€»å­˜å‚¨éœ€æ±‚: ~305GBï¼ˆä¸å«ç´¢å¼•ï¼‰
å«ç´¢å¼•: ~450GB
å»ºè®®é…ç½®: 1TB SSD
```

---

## ğŸ“š å‚è€ƒèµ„æº

1. **Apache AGEå›¾è®¾è®¡**: <https://age.apache.org/age-manual/master/intro/setup.html>
2. **pgvectorç´¢å¼•ä¼˜åŒ–**: <https://github.com/pgvector/pgvector#indexing>
3. **ååŒè¿‡æ»¤ç®—æ³•**: <https://en.wikipedia.org/wiki/Collaborative_filtering>

---

**ä¸‹ä¸€æ­¥**: [04-æ€§èƒ½ä¼˜åŒ–](./04-æ€§èƒ½ä¼˜åŒ–.md) | [è¿”å›é¦–é¡µ](./README.md)
