# 智能客服系统 - 架构设计

## 元数据
- **创建日期**: 2025-12-04
- **架构类型**: RAG + 知识图谱 + 多轮对话
- **技术栈**: PostgreSQL 18 + pgvector + Apache AGE + GPT-4

---

## 1. 系统架构

```
              用户输入（文本/语音）
                      ↓
┌──────────────────────────────────────────────────────────┐
│                  智能客服前端                             │
│              (Web/App/微信/钉钉)                         │
└────────────────────┬─────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────────┐
│                对话管理服务                               │
│  ┌───────────────────────────────────────────────┐      │
│  │ - 会话管理（多轮对话）                         │      │
│  │ - 上下文维护                                   │      │
│  │ - 意图识别                                     │      │
│  │ - 槽位填充                                     │      │
│  └───────────────────────────────────────────────┘      │
└────────────────────┬─────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────────┐
│            RAG+KG混合检索引擎                             │
├──────────────────────────────────────────────────────────┤
│                                                            │
│  ┌────────────────┐         ┌────────────────┐          │
│  │  向量检索路径   │         │  图检索路径     │          │
│  │  (pgvector)    │         │  (Apache AGE)  │          │
│  └────────┬───────┘         └────────┬───────┘          │
│           │                          │                    │
│           ↓                          ↓                    │
│  ┌────────────────┐         ┌────────────────┐          │
│  │ FAQ向量索引    │         │ 知识图谱       │          │
│  │ (HNSW)         │         │ (节点+边)      │          │
│  └────────┬───────┘         └────────┬───────┘          │
│           │                          │                    │
│           └─────────┬────────────────┘                    │
│                     ↓                                     │
│         ┌───────────────────────┐                        │
│         │   结果融合模块         │                        │
│         │   (RRF/加权/上下文)    │                        │
│         └───────────┬───────────┘                        │
│                     ↓                                     │
└─────────────────────┼─────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────────────┐
│                答案生成服务 (LLM)                         │
│  ┌───────────────────────────────────────────────┐      │
│  │ - GPT-4生成自然语言答案                        │      │
│  │ - 多轮对话历史注入                            │      │
│  │ - 答案质量控制                                │      │
│  └───────────────────────────────────────────────┘      │
└────────────────────┬─────────────────────────────────────┘
                     ↓
              最终答案 + 相关链接
```

---

## 2. RAG+KG混合检索

### 2.1 向量检索路径

```python
class VectorRetriever:
    """FAQ向量检索"""

    def __init__(self, db_conn, embedding_model):
        self.db = db_conn
        self.embedding_model = embedding_model

    async def retrieve(self, query: str, top_k: int = 10) -> List[Dict]:
        """向量相似度检索"""

        # 生成查询向量
        query_emb = self.embedding_model.encode(query)

        # pgvector检索
        sql = """
            SELECT
                faq_id,
                question,
                answer,
                category,
                1 - (question_embedding <=> %(query_emb)s::vector) AS similarity
            FROM faq_embeddings
            WHERE status = 'active'
            ORDER BY question_embedding <=> %(query_emb)s::vector
            LIMIT %(top_k)s;
        """

        results = await self.db.fetch_all(sql, {
            'query_emb': query_emb.tolist(),
            'top_k': top_k
        })

        return [{
            'faq_id': r['faq_id'],
            'question': r['question'],
            'answer': r['answer'],
            'similarity': float(r['similarity']),
            'source': 'vector'
        } for r in results]
```

### 2.2 图检索路径

```python
class GraphRetriever:
    """知识图谱检索"""

    def __init__(self, age_conn, graph_name: str):
        self.age = age_conn
        self.graph_name = graph_name

    async def retrieve(self, entities: List[str], hops: int = 2) -> List[Dict]:
        """实体中心子图检索"""

        if not entities:
            return []

        # 构建Cypher查询
        entity_filter = " OR ".join([f"n.name = '{e}'" for e in entities])

        cypher = f"""
            SELECT * FROM cypher('{self.graph_name}', $$
                MATCH (n)
                WHERE {entity_filter}
                MATCH path = (n)-[*1..{hops}]-(related)
                RETURN DISTINCT
                    n.name AS entity,
                    related.name AS related_info,
                    type(relationships(path)[0]) AS relation,
                    length(path) AS distance
                ORDER BY distance
                LIMIT 50
            $$) AS (entity agtype, related_info agtype, relation agtype, distance agtype);
        """

        results = await self.age.fetch_all(cypher)

        return [{
            'entity': json.loads(r['entity']),
            'related_info': json.loads(r['related_info']),
            'relation': json.loads(r['relation']),
            'distance': int(json.loads(r['distance'])),
            'source': 'graph'
        } for r in results]
```

### 2.3 结果融合

```python
class HybridRetriever:
    """混合检索器"""

    def __init__(self, vector_retriever, graph_retriever):
        self.vector_retriever = vector_retriever
        self.graph_retriever = graph_retriever

    async def retrieve(self, query: str, entities: List[str],
                      alpha: float = 0.6) -> List[Dict]:
        """
        混合检索

        Args:
            alpha: 向量权重（0=纯图，1=纯向量）
        """

        # 并行检索
        vector_results, graph_results = await asyncio.gather(
            self.vector_retriever.retrieve(query, top_k=20),
            self.graph_retriever.retrieve(entities, hops=2)
        )

        # RRF融合
        fused = self._rrf_fusion(vector_results, graph_results, k=60)

        return fused[:10]

    def _rrf_fusion(self, vector_results, graph_results, k=60):
        """倒数排名融合"""
        scores = {}

        # 向量结果
        for rank, item in enumerate(vector_results, start=1):
            item_id = item['faq_id']
            if item_id not in scores:
                scores[item_id] = {'item': item, 'score': 0}
            scores[item_id]['score'] += 1 / (k + rank)

        # 图结果（转换为FAQ）
        for rank, item in enumerate(graph_results, start=1):
            # 从图结果找对应的FAQ
            faq_id = self._find_related_faq(item)
            if faq_id and faq_id in scores:
                scores[faq_id]['score'] += 1 / (k + rank)

        # 排序
        sorted_items = sorted(scores.values(), key=lambda x: x['score'], reverse=True)
        return [item['item'] for item in sorted_items]
```

---

## 3. 多轮对话管理

```python
class DialogueManager:
    """对话管理器"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.max_turns = 10
        self.context_window = 5  # 保留最近5轮对话

    async def process_turn(self, user_id: str, user_input: str,
                          rag_kg_system) -> Dict:
        """处理一轮对话"""

        # 1. 获取对话历史
        history = await self._get_history(user_id)

        # 2. 构建完整上下文
        full_context = self._build_context(user_input, history)

        # 3. RAG+KG检索并生成答案
        answer_data = await rag_kg_system.answer(full_context)

        # 4. 更新对话历史
        await self._update_history(user_id, {
            'turn': len(history) + 1,
            'user': user_input,
            'assistant': answer_data['answer'],
            'timestamp': time.time()
        })

        # 5. 检查是否需要转人工
        if self._should_transfer_to_human(answer_data):
            return {
                'answer': answer_data['answer'],
                'transfer_to_human': True,
                'reason': '问题较复杂，为您转接人工客服'
            }

        return {
            'answer': answer_data['answer'],
            'transfer_to_human': False,
            'suggestions': self._generate_suggestions(answer_data)
        }

    async def _get_history(self, user_id: str) -> List[Dict]:
        """获取对话历史"""
        key = f"dialogue:{user_id}"
        history_json = await self.redis.get(key)

        if history_json:
            history = json.loads(history_json)
            return history[-self.context_window:]  # 最近N轮

        return []

    async def _update_history(self, user_id: str, turn: Dict):
        """更新对话历史"""
        key = f"dialogue:{user_id}"
        history_json = await self.redis.get(key)

        history = json.loads(history_json) if history_json else []
        history.append(turn)

        # 只保留最近N轮
        history = history[-self.max_turns:]

        # 设置TTL（1小时）
        await self.redis.setex(key, 3600, json.dumps(history))

    def _build_context(self, current_input: str, history: List[Dict]) -> str:
        """构建完整上下文"""
        context = ""

        # 添加历史对话
        for turn in history:
            context += f"用户: {turn['user']}\n"
            context += f"客服: {turn['assistant']}\n\n"

        # 添加当前输入
        context += f"用户: {current_input}\n"

        return context

    def _should_transfer_to_human(self, answer_data: Dict) -> bool:
        """判断是否需要转人工"""

        # 规则1: 答案置信度低
        if answer_data.get('confidence', 1.0) < 0.5:
            return True

        # 规则2: 连续3轮未解决
        # (需要从历史记录中判断)

        # 规则3: 用户明确要求人工
        # (在前置逻辑中处理)

        return False

    def _generate_suggestions(self, answer_data: Dict) -> List[str]:
        """生成相关问题建议"""
        # 基于当前问题推荐相关FAQ
        return [
            "您可能还想了解：",
            "- 如何修改订单信息？",
            "- 退款多久到账？",
            "- 如何联系卖家？"
        ]
```

---

## 4. 数据库设计

### 4.1 FAQ表

```sql
-- FAQ知识库
CREATE TABLE faq_knowledge (
    faq_id SERIAL PRIMARY KEY,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    category VARCHAR(50),
    keywords TEXT[],
    status VARCHAR(20) DEFAULT 'active',
    view_count INTEGER DEFAULT 0,
    helpful_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- FAQ向量表
CREATE TABLE faq_embeddings (
    faq_id INTEGER PRIMARY KEY REFERENCES faq_knowledge(faq_id),
    question TEXT,
    question_embedding vector(384),
    answer_embedding vector(384),
    category VARCHAR(50),
    status VARCHAR(20)
);

-- HNSW索引
CREATE INDEX idx_faq_question_emb
ON faq_embeddings
USING hnsw (question_embedding vector_cosine_ops);

-- 对话记录表
CREATE TABLE dialogue_sessions (
    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id BIGINT,
    turns JSONB[],
    status VARCHAR(20),  -- active/closed/transferred
    satisfaction_score INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    closed_at TIMESTAMP
);
```

---

## 5. 完整RAG+KG系统

```python
class CustomerServiceRAG:
    """智能客服RAG系统"""

    def __init__(self, config):
        self.db = connect_database(config)
        self.vector_retriever = VectorRetriever(self.db, SentenceTransformer('all-MiniLM-L6-v2'))
        self.graph_retriever = GraphRetriever(self.db, 'faq_graph')
        self.hybrid_retriever = HybridRetriever(self.vector_retriever, self.graph_retriever)
        self.llm = OpenAI(api_key=config['openai_key'])
        self.dialogue_manager = DialogueManager(redis.Redis())

    async def answer(self, user_id: str, question: str) -> Dict:
        """处理用户问题"""

        # 1. 实体识别
        entities = await self._extract_entities(question)

        # 2. 混合检索
        retrieved_docs = await self.hybrid_retriever.retrieve(question, entities)

        # 3. 获取对话历史
        history = await self.dialogue_manager._get_history(user_id)

        # 4. 构建Prompt并生成答案
        answer = await self._generate_answer_with_context(
            question,
            retrieved_docs,
            history
        )

        # 5. 记录对话
        await self.dialogue_manager._update_history(user_id, {
            'user': question,
            'assistant': answer,
            'sources': [d['faq_id'] for d in retrieved_docs[:3]]
        })

        return {
            'answer': answer,
            'sources': retrieved_docs[:3],
            'confidence': self._calculate_confidence(retrieved_docs)
        }

    async def _generate_answer_with_context(self, question, docs, history):
        """基于检索结果和历史生成答案"""

        # 构建上下文
        context = "相关FAQ:\n"
        for i, doc in enumerate(docs[:5], 1):
            context += f"{i}. Q: {doc['question']}\n   A: {doc['answer']}\n\n"

        # 对话历史
        history_text = ""
        for turn in history[-3:]:  # 最近3轮
            history_text += f"用户: {turn['user']}\n客服: {turn['assistant']}\n\n"

        prompt = f"""你是友好的客服助手。

对话历史:
{history_text}

参考资料:
{context}

当前问题: {question}

请基于参考资料回答问题。如果参考资料不足，请礼貌说明并建议用户提供更多信息。
"""

        response = await self.llm.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=[
                {"role": "system", "content": "你是专业、友好的客服。"},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7
        )

        return response.choices[0].message.content
```

---

## 6. 监控指标

```python
# 业务指标监控
class MetricsCollector:
    """指标收集器"""

    @staticmethod
    async def collect_daily_metrics():
        """每日指标统计"""

        query = """
            SELECT
                DATE(created_at) AS date,

                -- 对话量
                COUNT(*) AS total_sessions,
                COUNT(*) FILTER (WHERE status = 'closed') AS closed_sessions,
                COUNT(*) FILTER (WHERE status = 'transferred') AS transferred_sessions,

                -- 自动解决率
                (COUNT(*) FILTER (WHERE status = 'closed')::DECIMAL /
                 COUNT(*)) AS auto_resolution_rate,

                -- 平均满意度
                AVG(satisfaction_score) FILTER (WHERE satisfaction_score IS NOT NULL) AS avg_satisfaction,

                -- 平均轮次
                AVG(array_length(turns, 1)) AS avg_turns
            FROM dialogue_sessions
            WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
            GROUP BY DATE(created_at)
            ORDER BY date DESC;
        """

        return await db.fetch_all(query)
```

---

**下一步**: [03-数据库设计](./03-数据库设计.md) | [返回首页](./README.md)
