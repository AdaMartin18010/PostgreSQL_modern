# æ•°æ®åº“å›¾æ•°æ®æ¨¡å‹-å›¾æŸ¥è¯¢è¯­è¨€ä¸å›¾ç®—æ³•çš„å½¢å¼åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“å›¾æ•°æ®æ¨¡å‹-å›¾æŸ¥è¯¢è¯­è¨€ä¸å›¾ç®—æ³•çš„å½¢å¼åŒ–](#æ•°æ®åº“å›¾æ•°æ®æ¨¡å‹-å›¾æŸ¥è¯¢è¯­è¨€ä¸å›¾ç®—æ³•çš„å½¢å¼åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 å›¾æ•°æ®æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°](#10-å›¾æ•°æ®æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 å›¾æ•°æ®æ¨¡å‹](#21-å›¾æ•°æ®æ¨¡å‹)
    - [2.2 å›¾æŸ¥è¯¢è¯­è¨€](#22-å›¾æŸ¥è¯¢è¯­è¨€)
    - [2.3 å›¾ç®—æ³•](#23-å›¾ç®—æ³•)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 å›¾æ•°æ®æ¨¡å‹å½¢å¼åŒ–](#31-å›¾æ•°æ®æ¨¡å‹å½¢å¼åŒ–)
    - [3.2 å›¾æŸ¥è¯¢è¯­è¨€å½¢å¼åŒ–](#32-å›¾æŸ¥è¯¢è¯­è¨€å½¢å¼åŒ–)
    - [3.3 å›¾ç®—æ³•å½¢å¼åŒ–](#33-å›¾ç®—æ³•å½¢å¼åŒ–)
  - [4. å®šç†ä¸è¯æ˜](#4-å®šç†ä¸è¯æ˜)
    - [4.1 å›¾æŸ¥è¯¢è¯­è¨€å®Œå¤‡æ€§å®šç†](#41-å›¾æŸ¥è¯¢è¯­è¨€å®Œå¤‡æ€§å®šç†)
    - [4.2 å›¾ç®—æ³•æ­£ç¡®æ€§å®šç†](#42-å›¾ç®—æ³•æ­£ç¡®æ€§å®šç†)
  - [5. å®é™…åº”ç”¨](#5-å®é™…åº”ç”¨)
    - [5.1 PostgreSQL 18å›¾æ•°æ®æ¨¡å‹å®ç°](#51-postgresql-18å›¾æ•°æ®æ¨¡å‹å®ç°)
      - [5.1.1 ä½¿ç”¨PostgreSQLæ‰©å±•](#511-ä½¿ç”¨postgresqlæ‰©å±•)
    - [5.2 å®é™…åº”ç”¨åœºæ™¯](#52-å®é™…åº”ç”¨åœºæ™¯)
      - [åœºæ™¯1ï¼šç¤¾äº¤ç½‘ç»œåˆ†æ](#åœºæ™¯1ç¤¾äº¤ç½‘ç»œåˆ†æ)
      - [åœºæ™¯2ï¼šæ¨èç³»ç»Ÿå›¾åˆ†æ](#åœºæ™¯2æ¨èç³»ç»Ÿå›¾åˆ†æ)
    - [5.3 PostgreSQL 18å›¾ç®—æ³•å®ç°](#53-postgresql-18å›¾ç®—æ³•å®ç°)
      - [5.3.1 æœ€çŸ­è·¯å¾„ç®—æ³•](#531-æœ€çŸ­è·¯å¾„ç®—æ³•)
    - [4.3 å›¾åˆ†æ](#43-å›¾åˆ†æ)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)
    - [5.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#51-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#61-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [6.2 å›¾ç®—æ³•ç›¸å…³](#62-å›¾ç®—æ³•ç›¸å…³)
    - [6.3 PostgreSQLå®ç°ç›¸å…³](#63-postgresqlå®ç°ç›¸å…³)
    - [6.4 ç›¸å…³æ–‡æ¡£](#64-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 å›¾æ•°æ®æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°

**å›¾æ•°æ®æ¨¡å‹**ï¼š

å›¾æ•°æ®æ¨¡å‹ä»¥èŠ‚ç‚¹å’Œè¾¹è¡¨ç¤ºå®ä½“åŠå…¶å…³ç³»ã€‚å›¾æŸ¥è¯¢è¯­è¨€æ”¯æŒè·¯å¾„æŸ¥è¯¢ã€æ¨¡å¼åŒ¹é…ç­‰æ“ä½œï¼Œå›¾ç®—æ³•ç”¨äºå›¾åˆ†æå’Œè®¡ç®—ã€‚

**å›¾æ•°æ®æ¨¡å‹ä½“ç³»æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((å›¾æ•°æ®æ¨¡å‹))
    æ•°æ®æ¨¡å‹
      å±æ€§å›¾
      æœ‰å‘å›¾
      æ— å‘å›¾
      å¤šé‡å›¾
    æŸ¥è¯¢è¯­è¨€
      è·¯å¾„æŸ¥è¯¢
      æ¨¡å¼åŒ¹é…
      å›¾éå†
      å­å›¾æŸ¥è¯¢
    å›¾ç®—æ³•
      æœ€çŸ­è·¯å¾„
      è¿é€šåˆ†é‡
      ä¸­å¿ƒæ€§
      ç¤¾åŒºæ£€æµ‹
    å­˜å‚¨ä¸ç´¢å¼•
      é‚»æ¥è¡¨
      é‚»æ¥çŸ©é˜µ
      å›¾ç´¢å¼•
      è·¯å¾„ç´¢å¼•
```

**å›¾æŸ¥è¯¢å¤„ç†å†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[å›¾æŸ¥è¯¢Q] --> B{æŸ¥è¯¢ç±»å‹}
    B -->|è·¯å¾„æŸ¥è¯¢| C[è·¯å¾„åŒ¹é…ç®—æ³•]
    B -->|æ¨¡å¼åŒ¹é…| D[å­å›¾åŒæ„ç®—æ³•]
    B -->|å›¾éå†| E[éå†ç®—æ³•]
    C --> F[ä½¿ç”¨å›¾ç´¢å¼•]
    D --> F
    E --> F
    F --> G[æ‰§è¡ŒæŸ¥è¯¢]
    G --> H[è¿”å›ç»“æœ]

    style A fill:#FFD700
    style H fill:#90EE90
```

**å›¾æŸ¥è¯¢è¯­è¨€å¯¹æ¯”çŸ©é˜µ**ï¼š

| è¯­è¨€ | è¡¨è¾¾èƒ½åŠ› | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|---------|--------|---------|
| **Cypher** | é«˜ | ä¸­ | å±æ€§å›¾æŸ¥è¯¢ |
| **Gremlin** | é«˜ | é«˜ | å›¾éå† |
| **SPARQL** | ä¸­ | ä¸­ | RDFå›¾æŸ¥è¯¢ |
| **SQLæ‰©å±•** | ä¸­ | ä½ | å…³ç³»å›¾æŸ¥è¯¢ |

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **å›¾æ•°æ®æ¨¡å‹**ï¼šå±æ€§å›¾ã€æœ‰å‘å›¾ã€æ— å‘å›¾çš„å½¢å¼åŒ–å®šä¹‰
- **å›¾æŸ¥è¯¢è¯­è¨€**ï¼šè·¯å¾„æŸ¥è¯¢ã€æ¨¡å¼åŒ¹é…çš„è¯­ä¹‰
- **å›¾ç®—æ³•**ï¼šæœ€çŸ­è·¯å¾„ã€è¿é€šåˆ†é‡ç­‰ç®—æ³•çš„å½¢å¼åŒ–
- **å®é™…åº”ç”¨**ï¼šPostgreSQLå›¾æ‰©å±•çš„å®ç°

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 å›¾æ•°æ®æ¨¡å‹

**å±æ€§å›¾å®šä¹‰**ï¼š

```haskell
-- å±æ€§å›¾
data PropertyGraph = PropertyGraph {
    nodes :: Set Node,
    edges :: Set Edge,
    nodeLabels :: Node -> Set Label,
    nodeProperties :: Node -> Map Property Value,
    edgeLabels :: Edge -> Set Label,
    edgeProperties :: Edge -> Map Property Value
}

-- èŠ‚ç‚¹
data Node = Node {
    nodeId :: NodeId,
    labels :: Set Label,
    properties :: Map Property Value
}

-- è¾¹
data Edge = Edge {
    edgeId :: EdgeId,
    source :: NodeId,
    target :: NodeId,
    label :: Label,
    properties :: Map Property Value
}
```

**å›¾æ¨¡å‹å¯¹æ¯”çŸ©é˜µ**ï¼š

| æ¨¡å‹ | èŠ‚ç‚¹å±æ€§ | è¾¹å±æ€§ | å¤šé‡è¾¹ | é€‚ç”¨åœºæ™¯ |
|------|---------|--------|--------|---------|
| **å±æ€§å›¾** | æ˜¯ | æ˜¯ | æ˜¯ | é€šç”¨å›¾æ•°æ® |
| **ç®€å•å›¾** | å¦ | å¦ | å¦ | ç†è®ºåˆ†æ |
| **æœ‰å‘å›¾** | å¯é€‰ | å¯é€‰ | å¯é€‰ | æœ‰å‘å…³ç³» |
| **æ— å‘å›¾** | å¯é€‰ | å¯é€‰ | å¯é€‰ | æ— å‘å…³ç³» |

### 2.2 å›¾æŸ¥è¯¢è¯­è¨€

**è·¯å¾„æŸ¥è¯¢**ï¼š

```haskell
-- è·¯å¾„æŸ¥è¯¢
pathQuery :: Node -> Pattern -> Node -> Query
pathQuery start pattern end =
    PathQuery {
        start = start,
        pattern = pattern,
        end = end
    }

-- è·¯å¾„æ¨¡å¼
data Pattern =
    Simple EdgeLabel
  | Sequence [Pattern]
  | Alternation [Pattern]
  | KleeneStar Pattern
  | Optional Pattern

-- è·¯å¾„åŒ¹é…
matchPath :: PropertyGraph -> PathQuery -> Set Path
matchPath graph query =
    findPaths(graph, query.start, query.pattern, query.end)
```

**æ¨¡å¼åŒ¹é…**ï¼š

```haskell
-- å­å›¾æ¨¡å¼
data SubgraphPattern = SubgraphPattern {
    nodePatterns :: [NodePattern],
    edgePatterns :: [EdgePattern]
}

-- æ¨¡å¼åŒ¹é…
matchPattern :: PropertyGraph -> SubgraphPattern -> Set Subgraph
matchPattern graph pattern =
    findSubgraphs(graph, pattern)
```

**å›¾æŸ¥è¯¢æ‰§è¡Œæµç¨‹**ï¼š

```mermaid
graph TD
    A[å›¾æŸ¥è¯¢Q] --> B[è§£ææŸ¥è¯¢]
    B --> C[æ„å»ºæŸ¥è¯¢è®¡åˆ’]
    C --> D{ä½¿ç”¨ç´¢å¼•?}
    D -->|æ˜¯| E[ç´¢å¼•æŸ¥æ‰¾]
    D -->|å¦| F[å…¨å›¾æ‰«æ]
    E --> G[æ‰§è¡ŒæŸ¥è¯¢]
    F --> G
    G --> H[è¿”å›ç»“æœ]

    style A fill:#FFD700
    style H fill:#90EE90
```

### 2.3 å›¾ç®—æ³•

**æœ€çŸ­è·¯å¾„ç®—æ³•**ï¼š

```haskell
-- æœ€çŸ­è·¯å¾„
shortestPath :: PropertyGraph -> Node -> Node -> Maybe Path
shortestPath graph start end =
    dijkstra(graph, start, end)

-- Dijkstraç®—æ³•
dijkstra :: PropertyGraph -> Node -> Node -> Maybe Path
dijkstra graph start end =
    -- ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—å®ç°
    let distances = initializeDistances(graph, start)
        queue = PriorityQueue [start]
    in searchPath(graph, queue, distances, end)
```

**è¿é€šåˆ†é‡ç®—æ³•**ï¼š

```haskell
-- è¿é€šåˆ†é‡
connectedComponents :: PropertyGraph -> Set (Set Node)
connectedComponents graph =
    -- ä½¿ç”¨DFSæˆ–BFS
    let visited = Set.empty
        components = []
    in findComponents(graph, visited, components)
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 å›¾æ•°æ®æ¨¡å‹å½¢å¼åŒ–

**å±æ€§å›¾**ï¼š

```haskell
-- å±æ€§å›¾
G = (V, E, L_V, L_E, P_V, P_E)

å…¶ä¸­:
  Væ˜¯èŠ‚ç‚¹é›†åˆ
  Eæ˜¯è¾¹é›†åˆ
  L_V: V -> 2^Labels æ˜¯èŠ‚ç‚¹æ ‡ç­¾å‡½æ•°
  L_E: E -> Labels æ˜¯è¾¹æ ‡ç­¾å‡½æ•°
  P_V: V -> Map(Property, Value) æ˜¯èŠ‚ç‚¹å±æ€§å‡½æ•°
  P_E: E -> Map(Property, Value) æ˜¯è¾¹å±æ€§å‡½æ•°
```

### 3.2 å›¾æŸ¥è¯¢è¯­è¨€å½¢å¼åŒ–

**è·¯å¾„æŸ¥è¯¢**ï¼š

```haskell
-- è·¯å¾„æŸ¥è¯¢è¯­ä¹‰
âŸ¦path(start, pattern, end)âŸ§(G) =
    {p | p is path in G,
         p starts at start,
         p matches pattern,
         p ends at end}
```

### 3.3 å›¾ç®—æ³•å½¢å¼åŒ–

**æœ€çŸ­è·¯å¾„**ï¼š

```haskell
-- æœ€çŸ­è·¯å¾„
shortestPath(G, u, v) =
    argmin_{p: path from u to v} weight(p)

å…¶ä¸­weight(p)æ˜¯è·¯å¾„pçš„æƒé‡
```

---

## 4. å®šç†ä¸è¯æ˜

### 4.1 å›¾æŸ¥è¯¢è¯­è¨€å®Œå¤‡æ€§å®šç†

**å®šç†1ï¼ˆå›¾æŸ¥è¯¢è¯­è¨€å®Œå¤‡æ€§ï¼‰**ï¼š

å›¾æŸ¥è¯¢è¯­è¨€æ˜¯å®Œå¤‡çš„ï¼Œå³å®ƒå¯ä»¥è¡¨è¾¾æ‰€æœ‰å¸¸è§çš„å›¾æŸ¥è¯¢æ“ä½œï¼ŒåŒ…æ‹¬è·¯å¾„æŸ¥è¯¢ã€æ¨¡å¼åŒ¹é…ã€èšåˆæŸ¥è¯¢ç­‰ï¼Œå¹¶èƒ½æ­£ç¡®å¤„ç†å›¾çš„ç»“æ„å’Œå±æ€§ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š

è®¾å›¾æŸ¥è¯¢è¯­è¨€GQLï¼Œå›¾æ•°æ®æ¨¡å‹Gã€‚åˆ™å¯¹äºä»»æ„å›¾æŸ¥è¯¢Qï¼Œå­˜åœ¨GQLè¡¨è¾¾å¼eï¼Œä½¿å¾—ï¼š

```text
âŸ¦eâŸ§(G) = Q(G)
```

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šåŸºæœ¬æ“ä½œå®Œå¤‡æ€§**ï¼š

- å›¾æŸ¥è¯¢è¯­è¨€åŒ…å«èŠ‚ç‚¹æŸ¥è¯¢ã€è¾¹æŸ¥è¯¢ã€è·¯å¾„æŸ¥è¯¢ç­‰åŸºæœ¬æ“ä½œ
- è¿™äº›åŸºæœ¬æ“ä½œå¯ä»¥ç»„åˆè¡¨è¾¾å¤æ‚çš„å›¾æŸ¥è¯¢

**æ­¥éª¤2ï¼šæ¨¡å¼åŒ¹é…å®Œå¤‡æ€§**ï¼š

- å›¾æŸ¥è¯¢è¯­è¨€æ”¯æŒæ¨¡å¼åŒ¹é…ï¼Œå¯ä»¥è¡¨è¾¾ä»»æ„å›¾æ¨¡å¼
- æ¨¡å¼åŒ¹é…å¯ä»¥å¤„ç†èŠ‚ç‚¹å’Œè¾¹çš„æ ‡ç­¾ã€å±æ€§ç­‰æ¡ä»¶

**æ­¥éª¤3ï¼šèšåˆæ“ä½œå®Œå¤‡æ€§**ï¼š

- å›¾æŸ¥è¯¢è¯­è¨€æ”¯æŒèšåˆæ“ä½œï¼ˆCOUNTã€SUMã€AVGç­‰ï¼‰
- èšåˆæ“ä½œå¯ä»¥åº”ç”¨äºèŠ‚ç‚¹ã€è¾¹ã€è·¯å¾„ç­‰å›¾å…ƒç´ 

**æ­¥éª¤4ï¼šç»“è®º**ï¼š

- å›¾æŸ¥è¯¢è¯­è¨€å®Œå¤‡æ€§å®šç†å¾—è¯

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[å›¾æŸ¥è¯¢è¯­è¨€å®Œå¤‡æ€§å®šç†] --> B[åŸºæœ¬æ“ä½œå®Œå¤‡æ€§]
    B --> C[æ¨¡å¼åŒ¹é…å®Œå¤‡æ€§]
    C --> D[èšåˆæ“ä½œå®Œå¤‡æ€§]
    D --> E[å®šç†å¾—è¯]

    style A fill:#FFD700
    style E fill:#90EE90
```

### 4.2 å›¾ç®—æ³•æ­£ç¡®æ€§å®šç†

**å®šç†2ï¼ˆå›¾ç®—æ³•æ­£ç¡®æ€§ï¼‰**ï¼š

å›¾ç®—æ³•ï¼ˆå¦‚æœ€çŸ­è·¯å¾„ã€è¿é€šåˆ†é‡ï¼‰æ˜¯æ­£ç¡®çš„ï¼Œå³ç®—æ³•èƒ½å¤Ÿå‡†ç¡®è®¡ç®—å›¾çš„æ€§è´¨ï¼Œå¹¶åœ¨æœ‰é™æ—¶é—´å†…ç»ˆæ­¢ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š

è®¾å›¾ç®—æ³•Aï¼Œè¾“å…¥å›¾Gï¼Œè¾“å‡ºOã€‚åˆ™ï¼š

```text
correct(A, G) âˆ§ terminates(A, G)
```

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šç®—æ³•æ­£ç¡®æ€§**ï¼š

- æœ€çŸ­è·¯å¾„ç®—æ³•ï¼ˆå¦‚Dijkstraï¼‰èƒ½å¤Ÿæ­£ç¡®è®¡ç®—æœ€çŸ­è·¯å¾„
- è¿é€šåˆ†é‡ç®—æ³•èƒ½å¤Ÿæ­£ç¡®è¯†åˆ«æ‰€æœ‰è¿é€šåˆ†é‡
- ç®—æ³•åŸºäºå›¾è®ºç†è®ºï¼Œå…·æœ‰æ•°å­¦ä¿è¯

**æ­¥éª¤2ï¼šç»ˆæ­¢æ€§**ï¼š

- å›¾ç®—æ³•åœ¨æœ‰é™å›¾ä¸Šæ˜¯ç»ˆæ­¢çš„
- ç®—æ³•å¤æ‚åº¦æ˜¯æœ‰é™çš„ï¼ˆå¦‚Dijkstraä¸ºO(VÂ²)ï¼‰

**æ­¥éª¤3ï¼šç»“è®º**ï¼š

- å›¾ç®—æ³•æ­£ç¡®æ€§å®šç†å¾—è¯

---

## 5. å®é™…åº”ç”¨

### 5.1 PostgreSQL 18å›¾æ•°æ®æ¨¡å‹å®ç°

#### 5.1.1 ä½¿ç”¨PostgreSQLæ‰©å±•

**PostgreSQL 18å›¾æ‰©å±•æ”¯æŒ**ï¼š

PostgreSQL 18é€šè¿‡æ‰©å±•ï¼ˆå¦‚pg_graphã€Ageï¼‰æ”¯æŒå›¾æ•°æ®æ¨¡å‹å’ŒæŸ¥è¯¢ã€‚

```sql
-- å®‰è£…å›¾æ‰©å±•ï¼ˆç¤ºä¾‹ï¼šä½¿ç”¨pgRoutingæˆ–è‡ªå®šä¹‰æ‰©å±•ï¼‰
-- CREATE EXTENSION pgrouting;

-- åˆ›å»ºå›¾è¡¨ç»“æ„
CREATE TABLE nodes (
    id SERIAL PRIMARY KEY,
    label VARCHAR(50),
    properties JSONB
);

CREATE TABLE edges (
    id SERIAL PRIMARY KEY,
    source INTEGER REFERENCES nodes(id),
    target INTEGER REFERENCES nodes(id),
    label VARCHAR(50),
    weight FLOAT,
    properties JSONB
);

-- åˆ›å»ºå›¾ç´¢å¼•
CREATE INDEX idx_edges_source ON edges(source);
CREATE INDEX idx_edges_target ON edges(target);
```

**å›¾æŸ¥è¯¢ç¤ºä¾‹**ï¼š

```sql
-- è·¯å¾„æŸ¥è¯¢ï¼ˆä½¿ç”¨é€’å½’CTEï¼‰
WITH RECURSIVE path AS (
    -- èµ·å§‹èŠ‚ç‚¹
    SELECT id, ARRAY[id] as path, 0 as depth
    FROM nodes
    WHERE id = 1

    UNION ALL

    -- é€’å½’æ‰©å±•è·¯å¾„
    SELECT e.target, p.path || e.target, p.depth + 1
    FROM path p
    JOIN edges e ON p.id = e.source
    WHERE e.target != ALL(p.path)  -- é¿å…å¾ªç¯
      AND p.depth < 10  -- é™åˆ¶æ·±åº¦
)
SELECT * FROM path WHERE id = 5;  -- æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹
```

### 5.2 å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šç¤¾äº¤ç½‘ç»œåˆ†æ

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

éœ€è¦åˆ†æç¤¾äº¤ç½‘ç»œä¸­çš„ç”¨æˆ·å…³ç³»ï¼ŒæŸ¥æ‰¾æœ€çŸ­è·¯å¾„ã€å…±åŒå¥½å‹ç­‰ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šç¤¾äº¤ç½‘ç»œåˆ†æ
-- 1. åˆ›å»ºå›¾æ•°æ®æ¨¡å‹
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    user_name VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE friendships (
    friendship_id SERIAL PRIMARY KEY,
    user1_id INTEGER REFERENCES users(user_id),
    user2_id INTEGER REFERENCES users(user2_id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user1_id, user2_id)
);

-- 2. æœ€çŸ­è·¯å¾„æŸ¥è¯¢ï¼ˆä½¿ç”¨é€’å½’CTEï¼‰
WITH RECURSIVE shortest_path AS (
    -- èµ·å§‹èŠ‚ç‚¹
    SELECT
        user1_id AS current_user,
        user2_id AS target_user,
        ARRAY[user1_id, user2_id] AS path,
        1 AS depth
    FROM friendships
    WHERE user1_id = $1  -- èµ·å§‹ç”¨æˆ·

    UNION ALL

    -- é€’å½’æŸ¥æ‰¾è·¯å¾„
    SELECT
        f.user1_id,
        sp.target_user,
        sp.path || f.user2_id,
        sp.depth + 1
    FROM shortest_path sp
    JOIN friendships f ON f.user1_id = sp.current_user
    WHERE f.user2_id = sp.target_user
      AND NOT (f.user2_id = ANY(sp.path))  -- é¿å…å¾ªç¯
      AND sp.depth < 6  -- é™åˆ¶æ·±åº¦
)
SELECT path, depth
FROM shortest_path
WHERE current_user = $2  -- ç›®æ ‡ç”¨æˆ·
ORDER BY depth
LIMIT 1;
```

#### åœºæ™¯2ï¼šæ¨èç³»ç»Ÿå›¾åˆ†æ

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

åŸºäºç”¨æˆ·è¡Œä¸ºå›¾ï¼ˆè´­ä¹°ã€æµè§ˆã€æ”¶è—ï¼‰è¿›è¡Œå•†å“æ¨èã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šæ¨èç³»ç»Ÿå›¾åˆ†æ
-- 1. åˆ›å»ºç”¨æˆ·-å•†å“å…³ç³»å›¾
CREATE TABLE user_product_interactions (
    interaction_id SERIAL PRIMARY KEY,
    user_id INTEGER,
    product_id INTEGER,
    interaction_type VARCHAR(50),  -- 'purchase', 'view', 'favorite'
    interaction_time TIMESTAMPTZ DEFAULT NOW()
);

-- 2. åŸºäºå›¾çš„æ¨èæŸ¥è¯¢
WITH user_similarity AS (
    -- è®¡ç®—ç”¨æˆ·ç›¸ä¼¼åº¦ï¼ˆåŸºäºå…±åŒäº¤äº’çš„å•†å“ï¼‰
    SELECT
        u1.user_id AS user1,
        u2.user_id AS user2,
        COUNT(DISTINCT u1.product_id) AS common_products,
        COUNT(DISTINCT u1.product_id)::DOUBLE PRECISION /
        NULLIF(SQRT(COUNT(DISTINCT u1.product_id) * COUNT(DISTINCT u2.product_id)), 0) AS similarity
    FROM user_product_interactions u1
    JOIN user_product_interactions u2 ON u1.product_id = u2.product_id
    WHERE u1.user_id < u2.user_id
      AND u1.interaction_type = 'purchase'
      AND u2.interaction_type = 'purchase'
    GROUP BY u1.user_id, u2.user_id
    HAVING COUNT(DISTINCT u1.product_id) >= 3
),
recommendations AS (
    -- åŸºäºç›¸ä¼¼ç”¨æˆ·æ¨èå•†å“
    SELECT DISTINCT
        us.user1 AS target_user,
        upi.product_id,
        SUM(us.similarity * CASE upi.interaction_type
            WHEN 'purchase' THEN 3
            WHEN 'favorite' THEN 2
            WHEN 'view' THEN 1
            ELSE 0
        END) AS recommendation_score
    FROM user_similarity us
    JOIN user_product_interactions upi ON us.user2 = upi.user_id
    WHERE upi.product_id NOT IN (
        SELECT product_id FROM user_product_interactions
        WHERE user_id = us.user1
    )
    GROUP BY us.user1, upi.product_id
)
SELECT
    target_user,
    product_id,
    recommendation_score
FROM recommendations
WHERE target_user = $1
ORDER BY recommendation_score DESC
LIMIT 10;
```

### 5.3 PostgreSQL 18å›¾ç®—æ³•å®ç°

#### 5.3.1 æœ€çŸ­è·¯å¾„ç®—æ³•

```sql
-- ä½¿ç”¨Dijkstraç®—æ³•æŸ¥æ‰¾æœ€çŸ­è·¯å¾„
WITH RECURSIVE shortest_path AS (
    SELECT
        source,
        target,
        weight,
        ARRAY[source, target] as path,
        weight as total_weight
    FROM edges
    WHERE source = 1

    UNION ALL

    SELECT
        e.source,
        e.target,
        e.weight,
        sp.path || e.target,
        sp.total_weight + e.weight
    FROM shortest_path sp
    JOIN edges e ON sp.target = e.source
    WHERE e.target != ALL(sp.path)
      AND sp.total_weight + e.weight < (
          SELECT MIN(total_weight)
          FROM shortest_path
          WHERE target = e.target
      )
)
SELECT * FROM shortest_path
WHERE target = 5
ORDER BY total_weight
LIMIT 1;
```

### 4.3 å›¾åˆ†æ

**è¿é€šåˆ†é‡åˆ†æ**ï¼š

```sql
-- æŸ¥æ‰¾è¿é€šåˆ†é‡
WITH RECURSIVE component AS (
    -- é€‰æ‹©èµ·å§‹èŠ‚ç‚¹
    SELECT id, id as component_id
    FROM nodes
    WHERE id = 1

    UNION

    -- é€’å½’æŸ¥æ‰¾è¿é€šèŠ‚ç‚¹
    SELECT n.id, c.component_id
    FROM component c
    JOIN edges e ON c.id = e.source OR c.id = e.target
    JOIN nodes n ON n.id = CASE
        WHEN e.source = c.id THEN e.target
        ELSE e.source
    END
    WHERE n.id NOT IN (SELECT id FROM component)
)
SELECT component_id, COUNT(*) as node_count
FROM component
GROUP BY component_id;
```

---

---

## 6. ç›¸å…³æ–‡æ¡£

### 5.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [çŸ¥è¯†å›¾è°±æ¨¡å‹-å›¾æ•°æ®åº“ä¸è¯­ä¹‰æŸ¥è¯¢çš„å½¢å¼åŒ–](./14.05-æ•°æ®åº“çŸ¥è¯†å›¾è°±æ¨¡å‹-å›¾æ•°æ®åº“ä¸è¯­ä¹‰æŸ¥è¯¢çš„å½¢å¼åŒ–.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

## 7. å‚è€ƒæ–‡çŒ®

### 6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Angles, R., & Gutierrez, C. (2008). "Survey of Graph Database Models."**
  - æœŸåˆŠ: ACM Computing Surveys 2008
  - **é‡è¦æ€§**: å›¾æ•°æ®åº“æ¨¡å‹çš„ç»¼è¿°
  - **æ ¸å¿ƒè´¡çŒ®**: ç³»ç»Ÿé˜è¿°äº†å›¾æ•°æ®æ¨¡å‹å’ŒæŸ¥è¯¢è¯­è¨€

- **Wood, P. T. (2012). "Query Languages for Graph Databases."**
  - æœŸåˆŠ: SIGMOD Record 2012
  - **é‡è¦æ€§**: å›¾æŸ¥è¯¢è¯­è¨€çš„ç»å…¸ç ”ç©¶
  - **æ ¸å¿ƒè´¡çŒ®**: æä¾›äº†å›¾æŸ¥è¯¢è¯­è¨€çš„å½¢å¼åŒ–è¯­ä¹‰

### 6.2 å›¾ç®—æ³•ç›¸å…³

- **Cormen, T. H., et al. (2009). "Introduction to Algorithms."**
  - å‡ºç‰ˆç¤¾: MIT Press 2009
  - **é‡è¦æ€§**: ç®—æ³•ç»å…¸æ•™æ
  - **æ ¸å¿ƒè´¡çŒ®**: è¯¦ç»†é˜è¿°äº†å›¾ç®—æ³•

### 6.3 PostgreSQLå®ç°ç›¸å…³

- **[PostgreSQLå®˜æ–¹æ–‡æ¡£ - é€’å½’æŸ¥è¯¢](<https://www.postgresql.org/docs/current/queries-with.html>)**
  - PostgreSQLé€’å½’æŸ¥è¯¢å®ç°è¯´æ˜

### 6.4 ç›¸å…³æ–‡æ¡£

- [çŸ¥è¯†å›¾è°±æ¨¡å‹-å›¾æ•°æ®åº“ä¸è¯­ä¹‰æŸ¥è¯¢çš„å½¢å¼åŒ–](./14.05-æ•°æ®åº“çŸ¥è¯†å›¾è°±æ¨¡å‹-å›¾æ•°æ®åº“ä¸è¯­ä¹‰æŸ¥è¯¢çš„å½¢å¼åŒ–.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ
