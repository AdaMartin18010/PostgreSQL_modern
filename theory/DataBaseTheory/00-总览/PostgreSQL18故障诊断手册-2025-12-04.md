# PostgreSQL 18故障诊断手册

> **快速诊断与解决**
> **版本**: PostgreSQL 18.x

---

## 一、性能问题

### 慢查询诊断

```sql
-- 1. 找出慢查询
SELECT
    queryid,
    left(query, 100) as query_preview,
    calls,
    mean_exec_time,
    max_exec_time,
    rows
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- >100ms
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 2. 查看执行计划
EXPLAIN (ANALYZE, BUFFERS, COSTS OFF)
SELECT * FROM orders WHERE customer_id = 12345;

-- 3. 检查索引
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- 从未使用的索引
ORDER BY pg_relation_size(indexrelid) DESC;

-- 解决方案：
-- - 创建缺失的索引
-- - 删除无用的索引
-- - 更新统计信息（ANALYZE）
```

### 连接耗尽

```sql
-- 查看当前连接
SELECT
    datname,
    usename,
    client_addr,
    state,
    COUNT(*)
FROM pg_stat_activity
GROUP BY datname, usename, client_addr, state;

-- 查看最大连接数
SHOW max_connections;

-- 查看空闲连接
SELECT COUNT(*)
FROM pg_stat_activity
WHERE state = 'idle';

-- ⭐ PostgreSQL 18解决方案：
-- 启用内置连接池
ALTER SYSTEM SET enable_builtin_connection_pooling = on;
ALTER SYSTEM SET connection_pool_size = 200;
SELECT pg_reload_conf();
```

### 磁盘I/O高

```sql
-- 检查表I/O
SELECT
    schemaname,
    tablename,
    heap_blks_read,
    heap_blks_hit,
    ROUND(
        heap_blks_hit * 100.0 / NULLIF(heap_blks_hit + heap_blks_read, 0),
        2
    ) as cache_hit_ratio
FROM pg_statio_user_tables
WHERE heap_blks_read > 1000
ORDER BY heap_blks_read DESC;

-- 解决方案：
-- 1. 增加shared_buffers
-- 2. 优化查询（减少扫描）
-- 3. ⭐ PostgreSQL 18：启用异步I/O
ALTER SYSTEM SET enable_async_io = on;
```

---

## 二、内存问题

### OOM诊断

```sql
-- ⭐ PostgreSQL 18：增强的内存诊断
SELECT
    name,
    type,  -- 新增：内存类型
    path,  -- 新增：分配路径
    total_bytes,
    free_bytes,
    used_bytes
FROM pg_backend_memory_contexts
WHERE used_bytes > 100 * 1024 * 1024  -- >100MB
ORDER BY used_bytes DESC;

-- 检查work_mem使用
SELECT
    pid,
    query,
    state,
    backend_type
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY query_start;

-- 解决方案：
-- 1. 降低work_mem
-- 2. 使用LIMIT减少结果集
-- 3. 分批处理大查询
```

### 表膨胀

```sql
-- 检查死元组
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_pct,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY dead_pct DESC;

-- ⭐ PostgreSQL 18：并行VACUUM
VACUUM (PARALLEL 8, VERBOSE) bloated_table;

-- 严重膨胀：VACUUM FULL（需要锁表）
VACUUM FULL bloated_table;
```

---

## 三、锁问题

### 锁等待诊断

```sql
-- 查看锁等待
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query,
    blocked_activity.wait_event_type,
    blocked_activity.wait_event
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- 杀死阻塞会话（谨慎）
SELECT pg_terminate_backend(blocking_pid);
```

### 死锁诊断

```sql
-- 查看死锁日志
-- 在postgresql.conf中启用
deadlock_timeout = 1s
log_lock_waits = on

-- 解决方案：
-- 1. 统一事务中的表访问顺序
-- 2. 缩短事务时间
-- 3. 使用SELECT FOR UPDATE NOWAIT
```

---

## 四、复制问题

### 复制延迟

```sql
-- 主库查看复制状态
SELECT
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) as send_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), write_lsn) as write_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), flush_lsn) as flush_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) as replay_lag
FROM pg_stat_replication;

-- 从库查看延迟
SELECT
    now() - pg_last_xact_replay_timestamp() as replication_delay;

-- ⭐ PostgreSQL 18：流复制压缩
ALTER SYSTEM SET wal_compression = lz4;
-- 带宽降低30-50%
```

---

## 五、数据损坏

### 检测损坏

```bash
# 安装pg_amcheck扩展
psql -d mydb -c "CREATE EXTENSION IF NOT EXISTS amcheck;"

# 检查索引完整性
psql -d mydb -c "
SELECT bt_index_check(index => c.oid, heapallindexed => true)
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'i'
  AND n.nspname = 'public';
"

# 系统级检查
pg_checksums --check -D /data/postgresql
```

### 修复损坏

```sql
-- 重建索引
REINDEX TABLE CONCURRENTLY damaged_table;

-- 重建所有索引
REINDEX DATABASE CONCURRENTLY mydb;

-- 严重损坏：从备份恢复
```

---

## 六、快速诊断流程

### 性能下降

```
1. 检查慢查询 → pg_stat_statements
2. 检查锁等待 → pg_locks
3. 检查I/O → pg_statio_*
4. 检查连接数 → pg_stat_activity
5. 检查autovacuum → pg_stat_user_tables
```

### CPU高

```
1. 找出消耗CPU的查询 → top + pg_stat_activity
2. 查看执行计划 → EXPLAIN ANALYZE
3. 检查是否缺索引
4. 检查是否需要VACUUM
```

### 内存高

```
1. 检查work_mem配置
2. 查看内存上下文 → pg_backend_memory_contexts
3. 检查是否有大结果集查询
4. 检查是否有内存泄漏（连接池）
```

---

## 七、常用诊断SQL

```sql
-- 创建诊断视图
CREATE VIEW v_pg_health_check AS
SELECT
    'Database Size' as metric,
    pg_size_pretty(pg_database_size(current_database())) as value
UNION ALL
SELECT
    'Active Connections',
    COUNT(*)::text
FROM pg_stat_activity
WHERE state = 'active'
UNION ALL
SELECT
    'Idle Connections',
    COUNT(*)::text
FROM pg_stat_activity
WHERE state = 'idle'
UNION ALL
SELECT
    'Cache Hit Ratio',
    ROUND(
        sum(heap_blks_hit) * 100.0 / NULLIF(sum(heap_blks_hit + heap_blks_read), 0),
        2
    )::text || '%'
FROM pg_statio_user_tables
UNION ALL
SELECT
    'Deadlocks',
    sum(deadlocks)::text
FROM pg_stat_database;

-- 查看健康状态
SELECT * FROM v_pg_health_check;
```

---

**文档完成** ✅
