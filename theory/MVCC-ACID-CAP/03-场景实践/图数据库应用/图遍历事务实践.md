# 图遍历事务实践

## 元数据

- **创建日期**: 2025-12-04
- **场景类型**: 图数据库 + ACID事务
- **技术栈**: Apache AGE + MVCC

---

## 1. 场景背景

### 1.1 业务需求

**社交网络推荐系统**:

- 好友推荐（2-3度关系）
- 实时更新用户关系
- 并发读写
- ACID保证准确性

---

## 2. 图遍历的ACID实践

### 2.1 好友推荐（快照隔离）

```python
# 场景: 并发安全的好友推荐

import psycopg2
import json

def friend_recommendation(user_id, limit=10):
    """
    推荐朋友的朋友（2度关系）
    使用快照隔离保证一致性
    """

    conn = psycopg2.connect(...)
    cursor = conn.cursor()

    try:
        # REPEATABLE READ隔离级别
        conn.set_isolation_level(
            psycopg2.extensions.ISOLATION_LEVEL_REPEATABLE_READ
        )

        # 图遍历查询
        cursor.execute("""
            SELECT * FROM cypher('social_network', $$
                MATCH (u:User {id: $user_id})-[:KNOWS]->(friend)-[:KNOWS]->(fof)
                WHERE NOT (u)-[:KNOWS]->(fof)
                  AND fof.id <> $user_id
                WITH fof, COUNT(*) AS mutual_friends
                ORDER BY mutual_friends DESC
                LIMIT $limit
                RETURN
                    fof.id AS user_id,
                    fof.name AS name,
                    mutual_friends
            $$) AS (user_id agtype, name agtype, mutual_friends agtype);
        """, {
            'user_id': user_id,
            'limit': limit
        })

        results = cursor.fetchall()
        conn.commit()

        return [
            {
                'user_id': int(row[0]),
                'name': str(row[1]),
                'mutual_friends': int(row[2])
            }
            for row in results
        ]

    except Exception as e:
        conn.rollback()
        print(f"Recommendation failed: {e}")
        return []
    finally:
        conn.close()


# ACID保证:
# A: 查询原子执行
# C: 看到一致的图结构
# I: 快照隔离，不受并发影响
# D: 结果可靠（读操作无持久性问题）
```

---

### 2.2 并发添加好友关系

```python
# 场景: 并发添加好友关系

def add_friendship(user1_id, user2_id):
    """
    添加好友关系（双向）
    使用事务保证原子性
    """

    conn = psycopg2.connect(...)
    cursor = conn.cursor()

    try:
        # 开始事务
        cursor.execute("BEGIN;")

        # 检查用户是否存在
        cursor.execute("""
            SELECT * FROM cypher('social_network', $$
                MATCH (u1:User {id: $id1}), (u2:User {id: $id2})
                RETURN u1, u2
            $$) AS (u1 agtype, u2 agtype);
        """, {'id1': user1_id, 'id2': user2_id})

        if not cursor.fetchone():
            raise ValueError("User not found")

        # 创建双向关系
        cursor.execute("""
            SELECT * FROM cypher('social_network', $$
                MATCH (u1:User {id: $id1}), (u2:User {id: $id2})
                CREATE (u1)-[:KNOWS {since: timestamp()}]->(u2)
                CREATE (u2)-[:KNOWS {since: timestamp()}]->(u1)
            $$) AS (result agtype);
        """, {'id1': user1_id, 'id2': user2_id})

        # 提交事务
        conn.commit()
        print(f"Added friendship: {user1_id} <-> {user2_id}")

        return True

    except Exception as e:
        conn.rollback()
        print(f"Failed to add friendship: {e}")
        return False
    finally:
        conn.close()


# ACID保证:
# A: 双向关系要么都创建，要么都不创建
# C: 不会出现单向关系
# I: 并发添加不会冲突（不同节点对）
# D: 提交后关系持久化
```

---

## 3. 复杂图算法的事务

### 3.1 PageRank计算

```python
# PageRank算法在ACID事务中执行

def compute_pagerank(graph_name, iterations=20, damping=0.85):
    """
    在ACID事务中计算PageRank
    保证计算的原子性和一致性
    """

    conn = psycopg2.connect(...)
    cursor = conn.cursor()

    try:
        # 开始事务
        cursor.execute("BEGIN;")

        # 1. 初始化PageRank分数
        cursor.execute(f"""
            SELECT * FROM cypher('{graph_name}', $$
                MATCH (n:User)
                SET n.pagerank = 1.0
                WITH COUNT(n) AS total_nodes
                MATCH (m:User)
                SET m.out_degree = size((m)-[:KNOWS]->())
                RETURN total_nodes
            $$) AS (total_nodes agtype);
        """)

        total_nodes = cursor.fetchone()[0]

        # 2. 迭代计算
        for i in range(iterations):
            cursor.execute(f"""
                SELECT * FROM cypher('{graph_name}', $$
                    MATCH (n:User)
                    OPTIONAL MATCH (m:User)-[:KNOWS]->(n)
                    WITH n,
                         CASE
                             WHEN m.out_degree > 0
                             THEN SUM(m.pagerank / m.out_degree)
                             ELSE 0
                         END AS rank_sum
                    SET n.pagerank = {1-damping} + {damping} * rank_sum
                $$) AS (result agtype);
            """)

            print(f"Iteration {i+1}/{iterations} completed")

        # 3. 提交事务
        conn.commit()
        print(f"PageRank computed successfully")

        return True

    except Exception as e:
        conn.rollback()
        print(f"PageRank computation failed: {e}")
        return False
    finally:
        conn.close()


# ACID保证:
# A: 所有迭代要么全部完成，要么全部回滚
# C: PageRank分数保持数学一致性
# I: 计算期间不受并发修改影响
# D: 计算完成后分数持久化
```

---

### 3.2 社区检测（Louvain算法）

```python
# Louvain社区检测算法

def detect_communities(graph_name, max_iterations=10):
    """
    使用Louvain算法检测社区
    在ACID事务中保证算法完整性
    """

    conn = psycopg2.connect(...)
    cursor = conn.cursor()

    try:
        # REPEATABLE READ隔离级别
        conn.set_isolation_level(
            psycopg2.extensions.ISOLATION_LEVEL_REPEATABLE_READ
        )

        # 1. 初始化：每个节点自成一个社区
        cursor.execute(f"""
            SELECT * FROM cypher('{graph_name}', $$
                MATCH (n:User)
                SET n.community = n.id
            $$) AS (result agtype);
        """)

        # 2. 迭代优化模块度
        for iteration in range(max_iterations):
            # 对每个节点，尝试加入邻居的社区
            cursor.execute(f"""
                SELECT * FROM cypher('{graph_name}', $$
                    MATCH (n:User)-[:KNOWS]-(neighbor:User)
                    WITH n, neighbor.community AS comm, COUNT(*) AS edges_to_comm
                    ORDER BY edges_to_comm DESC
                    WITH n, HEAD(COLLECT(comm)) AS best_comm
                    SET n.community = best_comm
                $$) AS (result agtype);
            """)

            print(f"Community detection iteration {iteration+1}")

        # 3. 统计社区
        cursor.execute(f"""
            SELECT * FROM cypher('{graph_name}', $$
                MATCH (n:User)
                RETURN n.community AS community, COUNT(*) AS size
                ORDER BY size DESC
            $$) AS (community agtype, size agtype);
        """)

        communities = cursor.fetchall()

        conn.commit()

        return [
            {'community': int(row[0]), 'size': int(row[1])}
            for row in communities
        ]

    except Exception as e:
        conn.rollback()
        print(f"Community detection failed: {e}")
        return []
    finally:
        conn.close()


# ACID保证:
# A: 社区分配原子性
# C: 每个节点属于一个社区
# I: 算法基于一致快照
# D: 社区分配持久化
```

---

## 4. 写写冲突处理

### 4.1 乐观锁更新

```python
# 使用版本号实现乐观锁

def update_user_profile_optimistic(user_id, new_profile):
    """
    使用乐观锁更新用户资料
    避免写写冲突
    """

    conn = psycopg2.connect(...)
    cursor = conn.cursor()

    max_retries = 3
    retry_count = 0

    while retry_count < max_retries:
        try:
            # 1. 读取当前版本
            cursor.execute("""
                SELECT * FROM cypher('social_network', $$
                    MATCH (u:User {id: $user_id})
                    RETURN u.profile, u.version
                $$) AS (profile agtype, version agtype);
            """, {'user_id': user_id})

            row = cursor.fetchone()
            if not row:
                raise ValueError("User not found")

            current_version = int(row[1])

            # 2. 乐观更新（检查版本）
            cursor.execute("""
                SELECT * FROM cypher('social_network', $$
                    MATCH (u:User {id: $user_id, version: $version})
                    SET u.profile = $new_profile,
                        u.version = $version + 1
                    RETURN u.version
                $$) AS (new_version agtype);
            """, {
                'user_id': user_id,
                'version': current_version,
                'new_profile': json.dumps(new_profile)
            })

            result = cursor.fetchone()

            if not result:
                # 版本冲突，重试
                retry_count += 1
                print(f"Version conflict, retry {retry_count}")
                conn.rollback()
                continue

            conn.commit()
            print(f"Updated user {user_id} profile")
            return True

        except Exception as e:
            conn.rollback()
            print(f"Update failed: {e}")
            return False

    print(f"Failed after {max_retries} retries")
    return False
```

---

## 5. 性能监控

### 5.1 图查询性能监控

```python
# 监控图遍历性能

import time

def monitored_graph_query(query, params):
    """
    执行图查询并记录性能指标
    """

    conn = psycopg2.connect(...)
    cursor = conn.cursor()

    try:
        # 记录开始时间
        start_time = time.time()

        # 执行查询
        cursor.execute(query, params)
        results = cursor.fetchall()

        # 记录结束时间
        elapsed = time.time() - start_time

        # 获取查询计划
        cursor.execute("EXPLAIN ANALYZE " + query, params)
        plan = cursor.fetchall()

        # 记录指标
        metrics = {
            'query': query,
            'params': params,
            'result_count': len(results),
            'elapsed_time': elapsed,
            'explain_plan': plan
        }

        print(f"Query completed in {elapsed:.3f}s, {len(results)} results")

        return results, metrics

    finally:
        conn.close()
```

---

## 6. 完整示例：社交网络系统

```python
# 完整的社交网络图数据库系统

import psycopg2
from psycopg2 import pool
import json
import time

class SocialNetworkSystem:
    """基于Apache AGE的社交网络系统"""

    def __init__(self, db_config):
        # 初始化连接池
        self.pool = pool.ThreadedConnectionPool(
            minconn=5,
            maxconn=50,
            **db_config
        )

        self.graph_name = 'social_network'

    def add_user(self, user_id, name, profile):
        """添加用户节点"""

        conn = self.pool.getconn()

        try:
            cursor = conn.cursor()

            cursor.execute(f"""
                SELECT * FROM cypher('{self.graph_name}', $$
                    CREATE (u:User {{
                        id: $user_id,
                        name: $name,
                        profile: $profile,
                        version: 1,
                        created_at: timestamp()
                    }})
                    RETURN u
                $$) AS (user agtype);
            """, {
                'user_id': user_id,
                'name': name,
                'profile': json.dumps(profile)
            })

            conn.commit()
            return True

        except Exception as e:
            conn.rollback()
            print(f"Failed to add user: {e}")
            return False
        finally:
            self.pool.putconn(conn)

    def add_friendship(self, user1_id, user2_id):
        """添加好友关系（双向）"""

        conn = self.pool.getconn()

        try:
            cursor = conn.cursor()

            # ACID事务
            cursor.execute(f"""
                SELECT * FROM cypher('{self.graph_name}', $$
                    MATCH (u1:User {{id: $id1}}), (u2:User {{id: $id2}})
                    CREATE (u1)-[:KNOWS {{since: timestamp()}}]->(u2)
                    CREATE (u2)-[:KNOWS {{since: timestamp()}}]->(u1)
                $$) AS (result agtype);
            """, {'id1': user1_id, 'id2': user2_id})

            conn.commit()
            return True

        except Exception as e:
            conn.rollback()
            return False
        finally:
            self.pool.putconn(conn)

    def recommend_friends(self, user_id, limit=10):
        """推荐好友（2度关系）"""

        conn = self.pool.getconn()

        try:
            cursor = conn.cursor()

            # 快照隔离查询
            conn.set_isolation_level(
                psycopg2.extensions.ISOLATION_LEVEL_REPEATABLE_READ
            )

            cursor.execute(f"""
                SELECT * FROM cypher('{self.graph_name}', $$
                    MATCH (u:User {{id: $user_id}})-[:KNOWS]->(f)-[:KNOWS]->(fof)
                    WHERE NOT (u)-[:KNOWS]->(fof)
                      AND fof.id <> $user_id
                    WITH fof, COUNT(*) AS mutual
                    ORDER BY mutual DESC
                    LIMIT $limit
                    RETURN fof.id, fof.name, mutual
                $$) AS (user_id agtype, name agtype, mutual agtype);
            """, {'user_id': user_id, 'limit': limit})

            results = cursor.fetchall()
            conn.commit()

            return [
                {
                    'user_id': int(row[0]),
                    'name': str(row[1]),
                    'mutual_friends': int(row[2])
                }
                for row in results
            ]

        finally:
            self.pool.putconn(conn)

    def get_user_stats(self, user_id):
        """获取用户统计信息"""

        conn = self.pool.getconn()

        try:
            cursor = conn.cursor()

            cursor.execute(f"""
                SELECT * FROM cypher('{self.graph_name}', $$
                    MATCH (u:User {{id: $user_id}})
                    OPTIONAL MATCH (u)-[:KNOWS]->(friend)
                    RETURN
                        u.name,
                        COUNT(friend) AS friend_count
                $$) AS (name agtype, friend_count agtype);
            """, {'user_id': user_id})

            row = cursor.fetchone()

            if row:
                return {
                    'name': str(row[0]),
                    'friend_count': int(row[1])
                }
            else:
                return None

        finally:
            self.pool.putconn(conn)

    def close(self):
        """关闭连接池"""
        self.pool.closeall()


# 使用示例
if __name__ == '__main__':
    system = SocialNetworkSystem({
        'host': 'localhost',
        'database': 'graphdb',
        'user': 'postgres',
        'password': 'password'
    })

    # 添加用户
    system.add_user(1, 'Alice', {'age': 25, 'city': 'Beijing'})
    system.add_user(2, 'Bob', {'age': 28, 'city': 'Shanghai'})
    system.add_user(3, 'Charlie', {'age': 30, 'city': 'Guangzhou'})

    # 添加好友关系
    system.add_friendship(1, 2)
    system.add_friendship(2, 3)

    # 好友推荐
    recommendations = system.recommend_friends(1)
    print(f"Recommendations for Alice: {recommendations}")

    # 用户统计
    stats = system.get_user_stats(1)
    print(f"Alice stats: {stats}")

    system.close()
```

---

## 7. 总结

### 核心要点

✅ **图遍历快照一致性**

- REPEATABLE READ隔离
- 看到一致的图结构
- 不受并发修改影响

✅ **图更新原子性**

- 批量节点/边创建
- 要么全部成功，要么全部回滚
- 双向关系原子创建

✅ **复杂算法ACID保证**

- PageRank迭代原子
- 社区检测一致性
- 算法结果持久化

✅ **并发控制**

- 乐观锁避免写冲突
- 版本号检测
- 重试机制

---

**创建日期**: 2025-12-04
**实践完整性**: ✅ 高
**代码可运行**: ✅ 是

**返回**: [场景实践首页](../README.md) | [MVCC-ACID-CAP主页](../../README.md)
