# PostgreSQL高可用最佳实践

> **文档编号**: SCENARIO-HA-BESTPRACTICES-001
> **主题**: 高可用最佳实践
> **版本**: PostgreSQL 17 & 18

---

## 📑 目录

- [PostgreSQL高可用最佳实践](#postgresql高可用最佳实践)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [🔍 第一部分：架构设计](#-第一部分架构设计)
    - [1.1 主从架构](#11-主从架构)
      - [流复制架构](#流复制架构)
      - [逻辑复制架构](#逻辑复制架构)
      - [混合架构](#混合架构)
    - [1.2 多节点架构](#12-多节点架构)
      - [一主多从](#一主多从)
      - [级联复制](#级联复制)
      - [多主架构](#多主架构)
    - [1.3 架构选择](#13-架构选择)
      - [选择原则](#选择原则)
      - [架构对比](#架构对比)
      - [适用场景](#适用场景)
  - [🚀 第二部分：配置优化](#-第二部分配置优化)
    - [2.1 流复制配置](#21-流复制配置)
      - [同步模式配置](#同步模式配置)
      - [复制槽配置](#复制槽配置)
      - [性能优化配置](#性能优化配置)
    - [2.2 逻辑复制配置](#22-逻辑复制配置)
      - [发布订阅配置](#发布订阅配置)
      - [冲突处理配置](#冲突处理配置)
      - [性能优化配置](#性能优化配置-1)
    - [2.3 MVCC优化配置](#23-mvcc优化配置)
      - [VACUUM配置](#vacuum配置)
      - [快照配置](#快照配置)
      - [版本链优化](#版本链优化)
  - [📊 第三部分：监控告警](#-第三部分监控告警)
    - [3.1 复制监控](#31-复制监控)
      - [延迟监控](#延迟监控)
      - [状态监控](#状态监控)
      - [性能监控](#性能监控)
    - [3.2 MVCC监控](#32-mvcc监控)
      - [快照监控](#快照监控)
      - [版本链监控](#版本链监控)
      - [VACUUM监控](#vacuum监控)
    - [3.3 告警规则](#33-告警规则)
      - [复制告警](#复制告警)
      - [MVCC告警](#mvcc告警)
      - [性能告警](#性能告警)
  - [🔧 第四部分：故障处理](#-第四部分故障处理)
    - [4.1 故障预防](#41-故障预防)
      - [预防措施](#预防措施)
      - [健康检查](#健康检查)
      - [容量规划](#容量规划)
    - [4.2 故障响应](#42-故障响应)
      - [故障检测](#故障检测)
      - [故障转移](#故障转移)
      - [故障恢复](#故障恢复)
    - [4.3 故障复盘](#43-故障复盘)
      - [故障分析](#故障分析)
      - [改进措施](#改进措施)
      - [预防措施](#预防措施-1)
  - [📝 总结](#-总结)
    - [核心原则](#核心原则)
    - [最佳实践](#最佳实践)

---

## 📋 概述

本文档总结PostgreSQL高可用最佳实践，包括架构设计、配置优化、监控告警和故障处理，为高可用系统设计提供完整指导。

---

## 🔍 第一部分：架构设计

### 1.1 主从架构

#### 流复制架构

```text
流复制架构设计：

1. 一主一从：
   - 主节点：写操作
   - 从节点：读操作 + 故障转移
   - 同步模式：根据需求选择

2. 一主多从：
   - 主节点：写操作
   - 多个从节点：读操作 + 故障转移
   - 负载均衡：读操作分散

3. MVCC影响：
   - 主节点：强一致性
   - 从节点：最终一致性（异步）或强一致性（同步）
   - 版本链：通过WAL同步
```

#### 逻辑复制架构

```text
逻辑复制架构设计：

1. 发布订阅：
   - 发布端：写操作
   - 订阅端：读操作 + 故障转移
   - 跨版本复制：支持

2. 多订阅：
   - 一个发布端，多个订阅端
   - 负载均衡：读操作分散
   - 故障转移：多个候选

3. MVCC影响：
   - 发布端：强一致性
   - 订阅端：最终一致性
   - 版本链：独立管理
```

#### 混合架构

```text
混合架构设计：

1. 流复制 + 逻辑复制：
   - 流复制：高可用
   - 逻辑复制：跨版本/跨数据库
   - 混合使用：灵活架构

2. 架构优势：
   - 高可用：流复制保证
   - 灵活性：逻辑复制支持
   - 性能：读写分离

3. MVCC影响：
   - 流复制：版本链同步
   - 逻辑复制：版本链独立
   - 混合：需要协调
```

### 1.2 多节点架构

#### 一主多从

```text
一主多从架构：

1. 架构设计：
   - 1个主节点：写操作
   - N个从节点：读操作
   - 故障转移：从节点提升

2. 优势：
   - 高可用：多个候选
   - 负载均衡：读操作分散
   - 性能：读写分离

3. MVCC影响：
   - 主节点：强一致性
   - 从节点：最终一致性
   - 版本链：通过WAL同步
```

#### 级联复制

```text
级联复制架构：

1. 架构设计：
   - 主节点 → 中间节点 → 从节点
   - 减少主节点负载
   - 提高扩展性

2. 优势：
   - 减少主节点负载
   - 提高扩展性
   - 灵活架构

3. MVCC影响：
   - 主节点：强一致性
   - 中间节点：最终一致性
   - 从节点：最终一致性
   - 版本链：级联同步
```

#### 多主架构

```text
多主架构设计：

1. 架构设计：
   - 多个主节点：双向复制
   - 冲突解决：应用层处理
   - 最终一致性：保证

2. 优势：
   - 高可用：无单点故障
   - 负载均衡：写操作分散
   - 地理分布：支持

3. MVCC影响：
   - 本地：强一致性
   - 跨节点：最终一致性
   - 版本链：独立管理
```

### 1.3 架构选择

#### 选择原则

```text
架构选择原则：

1. 可用性要求：
   - 高可用：一主多从
   - 极高可用：多主架构
   - 一般可用：一主一从

2. 一致性要求：
   - 强一致性：同步复制
   - 最终一致性：异步复制
   - 根据需求选择

3. 性能要求：
   - 高性能：异步复制
   - 平衡：同步复制
   - 根据需求选择
```

#### 架构对比

| 架构 | 可用性 | 一致性 | 性能 | 复杂度 |
|------|--------|--------|------|--------|
| 一主一从 | 中 | 高（同步） | 中 | 低 |
| 一主多从 | 高 | 高（同步） | 高 | 中 |
| 级联复制 | 高 | 中 | 高 | 中 |
| 多主架构 | 极高 | 低 | 高 | 高 |

#### 适用场景

```text
架构适用场景：

1. 一主一从：
   - 小型系统
   - 低可用性要求
   - 简单架构

2. 一主多从：
   - 中型系统
   - 高可用性要求
   - 读写分离

3. 多主架构：
   - 大型系统
   - 极高可用性要求
   - 地理分布
```

---

## 🚀 第二部分：配置优化

### 2.1 流复制配置

#### 同步模式配置

```sql
-- 同步模式配置优化
-- 平衡一致性和性能

-- 方案1：强一致性（金融系统）
synchronous_standby_names = 'standby1,standby2';
synchronous_commit = remote_apply;
-- 特点：强一致性，性能较低

-- 方案2：平衡（电商系统）
synchronous_standby_names = 'standby1';
synchronous_commit = remote_write;
-- 特点：平衡一致性和性能

-- 方案3：高性能（日志系统）
synchronous_commit = off;
-- 特点：高性能，最终一致性

-- MVCC影响：
-- 同步模式影响事务提交延迟
-- 影响MVCC快照可见性
```

#### 复制槽配置

```sql
-- 复制槽配置优化
-- 防止WAL被删除

-- 1. 创建复制槽
SELECT pg_create_physical_replication_slot('replica_slot');

-- 2. 配置WAL保留（PostgreSQL 17+）
max_slot_wal_keep_size = '10GB';  -- 最大WAL保留

-- 3. 监控复制槽
SELECT
    slot_name,
    active,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS wal_retained
FROM pg_replication_slots;

-- MVCC影响：
-- 复制槽保留WAL，影响WAL空间
-- 影响VACUUM和MVCC清理
```

#### 性能优化配置

```sql
-- 流复制性能优化配置
-- 1. WAL优化
wal_level = replica;
wal_compression = on;  -- WAL压缩
wal_buffers = '16MB';  -- WAL缓冲区

-- 2. 复制优化
max_wal_senders = 10;  -- 最大WAL发送者
wal_sender_timeout = 60s;  -- WAL发送超时

-- 3. 从节点优化
hot_standby = on;  -- 热备
max_standby_streaming_delay = 30s;  -- 最大延迟

-- MVCC影响：
-- WAL优化不影响MVCC机制
-- 但影响复制延迟和性能
```

### 2.2 逻辑复制配置

#### 发布订阅配置

```sql
-- 发布订阅配置优化
-- 1. 发布配置
CREATE PUBLICATION my_publication
FOR TABLE accounts, orders
WITH (publish = 'insert,update,delete');

-- 2. 订阅配置
CREATE SUBSCRIPTION my_subscription
CONNECTION 'host=primary dbname=postgres'
PUBLICATION my_publication
WITH (
    copy_data = true,
    create_slot = true,
    enabled = true
);

-- MVCC影响：
-- 发布订阅不影响MVCC机制
-- 但影响WAL生成和保留
```

#### 冲突处理配置

```sql
-- 冲突处理配置优化
ALTER SUBSCRIPTION my_subscription SET (
    conflict_resolution = 'error'  -- 冲突处理策略
);

-- 冲突处理策略：
-- 1. error：报错（默认）
-- 2. apply_remote：应用远程变更
-- 3. keep_local：保留本地变更

-- MVCC影响：
-- 冲突处理不影响MVCC机制
-- 但影响数据一致性
```

#### 性能优化配置

```sql
-- 逻辑复制性能优化配置
ALTER SUBSCRIPTION my_subscription SET (
    batch_size = 1000,  -- 批量大小
    batch_interval = '1s'  -- 批量间隔
);

-- 性能优化效果：
-- 1. 减少网络往返
-- 2. 提高吞吐量
-- 3. 降低延迟

-- MVCC影响：
-- 批量处理不影响MVCC机制
-- 但影响复制延迟
```

### 2.3 MVCC优化配置

#### VACUUM配置

```sql
-- VACUUM配置优化
-- 1. 全局配置
autovacuum = on;
autovacuum_max_workers = 3;
autovacuum_naptime = '1min';

-- 2. 表级配置
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.05,
    autovacuum_analyze_scale_factor = 0.02
);

-- MVCC影响：
-- VACUUM清理死亡元组
-- 减少版本链长度
-- 提高性能
```

#### 快照配置

```text
快照配置优化：

1. 快照管理：
   - 减少活跃事务数
   - 优化事务长度
   - 减少快照开销

2. 快照缓存：
   - 使用快照缓存
   - 减少快照创建开销
   - 提高性能

3. MVCC影响：
   - 快照优化不影响MVCC机制
   - 但影响快照创建性能
```

#### 版本链优化

```sql
-- 版本链优化配置
-- 1. fillfactor优化
ALTER TABLE orders SET (fillfactor = 80);  -- 提高HOT更新率

-- 2. VACUUM优化
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.05  -- 频繁VACUUM
);

-- MVCC影响：
-- fillfactor提高HOT更新率
-- VACUUM减少版本链长度
-- 提高性能
```

---

## 📊 第三部分：监控告警

### 3.1 复制监控

#### 延迟监控

```sql
-- 流复制延迟监控
SELECT
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS sent_lag_bytes,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS replay_lag_bytes,
    EXTRACT(EPOCH FROM (now() - replay_lag_time)) AS replay_lag_seconds
FROM pg_stat_replication;

-- 逻辑复制延迟监控
SELECT
    subname,
    received_lsn,
    latest_end_lsn,
    pg_wal_lsn_diff(pg_current_wal_lsn(), received_lsn) AS lag_bytes
FROM pg_stat_subscription;

-- 告警阈值：
-- sent_lag_bytes > 1GB：警告
-- replay_lag_seconds > 60s：警告
```

#### 状态监控

```sql
-- 复制状态监控
-- 1. 流复制状态
SELECT
    client_addr,
    state,
    sync_state,
    sync_priority
FROM pg_stat_replication;

-- 2. 逻辑复制状态
SELECT
    subname,
    pid,
    relid,
    received_lsn,
    latest_end_lsn
FROM pg_stat_subscription_stats;

-- 3. 复制槽状态
SELECT
    slot_name,
    slot_type,
    active,
    restart_lsn
FROM pg_replication_slots;

-- 告警规则：
-- state != 'streaming'：告警
-- active = false：告警
```

#### 性能监控

```sql
-- 复制性能监控
-- 1. 复制吞吐量
SELECT
    client_addr,
    sent_lsn,
    write_lsn,
    flush_lsn,
    replay_lsn
FROM pg_stat_replication;

-- 2. WAL生成速率
SELECT
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')) AS total_wal,
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            pg_stat_file('pg_wal/' || pg_walfile_name(pg_current_wal_lsn()))::text
        )
    ) AS current_wal;

-- MVCC影响：
-- 复制性能影响MVCC可见性
-- 需要监控和优化
```

### 3.2 MVCC监控

#### 快照监控

```sql
-- 快照监控
-- 1. 活跃事务数
SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active';

-- 2. 长事务
SELECT
    pid,
    usename,
    datname,
    state,
    now() - xact_start AS transaction_duration,
    query
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - xact_start > interval '5 minutes';

-- 3. 快照统计
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback
FROM pg_stat_database
WHERE datname = current_database();

-- 告警规则：
-- 活跃事务数 > 100：警告
-- 长事务 > 10分钟：警告
```

#### 版本链监控

```sql
-- 版本链监控
SELECT
    schemaname,
    relname,
    n_live_tup,
    n_dead_tup,
    round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY dead_ratio DESC;

-- 告警规则：
-- dead_ratio > 20%：警告
-- dead_ratio > 50%：严重告警
```

#### VACUUM监控

```sql
-- VACUUM监控
SELECT
    schemaname,
    relname,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count,
    n_dead_tup
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000;

-- 告警规则：
-- 超过7天未VACUUM：警告
-- dead_tup > 100万：警告
```

### 3.3 告警规则

#### 复制告警

```text
复制告警规则：

1. 复制延迟告警：
   - 流复制延迟 > 1GB：警告
   - 流复制延迟 > 10GB：严重告警
   - 逻辑复制延迟 > 1GB：警告

2. 复制状态告警：
   - 复制状态 != 'streaming'：告警
   - 复制槽不活跃：告警
   - 从节点断开：严重告警

3. 复制性能告警：
   - WAL生成速率异常：警告
   - 复制吞吐量异常：警告
```

#### MVCC告警

```text
MVCC告警规则：

1. 版本链告警：
   - dead_ratio > 20%：警告
   - dead_ratio > 50%：严重告警
   - 版本链长度 > 100：警告

2. VACUUM告警：
   - 超过7天未VACUUM：警告
   - dead_tup > 100万：警告
   - VACUUM失败：严重告警

3. 快照告警：
   - 活跃事务数 > 100：警告
   - 长事务 > 10分钟：警告
   - XID年龄 > 1亿：警告
```

#### 性能告警

```text
性能告警规则：

1. 查询性能告警：
   - 慢查询 > 1秒：警告
   - 慢查询 > 10秒：严重告警
   - 查询超时：严重告警

2. 资源告警：
   - CPU使用率 > 80%：警告
   - 内存使用率 > 90%：警告
   - 磁盘使用率 > 85%：警告

3. 连接告警：
   - 连接数 > 80%：警告
   - 连接数 > 95%：严重告警
```

---

## 🔧 第四部分：故障处理

### 4.1 故障预防

#### 预防措施

```text
故障预防措施：

1. 定期维护：
   - 定期VACUUM
   - 定期ANALYZE
   - 定期检查

2. 容量规划：
   - 监控磁盘使用
   - 监控WAL使用
   - 提前扩容

3. 健康检查：
   - 定期健康检查
   - 检查复制状态
   - 检查MVCC状态
```

#### 健康检查

```sql
-- 健康检查脚本
-- 1. 检查复制状态
SELECT
    CASE
        WHEN COUNT(*) = 0 THEN 'ERROR: No replication'
        WHEN COUNT(*) FILTER (WHERE state = 'streaming') = COUNT(*) THEN 'OK'
        ELSE 'WARNING: Some replication issues'
    END AS replication_status
FROM pg_stat_replication;

-- 2. 检查MVCC状态
SELECT
    CASE
        WHEN MAX(dead_ratio) > 50 THEN 'WARNING: High dead tuple ratio'
        WHEN MAX(dead_ratio) > 20 THEN 'CAUTION: Moderate dead tuple ratio'
        ELSE 'OK'
    END AS mvcc_status
FROM (
    SELECT
        round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_ratio
    FROM pg_stat_user_tables
) t;

-- 3. 检查XID年龄
SELECT
    CASE
        WHEN age(datfrozenxid) > 2000000000 THEN 'CRITICAL: XID wraparound risk'
        WHEN age(datfrozenxid) > 1000000000 THEN 'WARNING: High XID age'
        ELSE 'OK'
    END AS xid_status
FROM pg_database
WHERE datname = current_database();
```

#### 容量规划

```text
容量规划策略：

1. 磁盘容量：
   - 监控磁盘使用
   - 预留20-30%空间
   - 提前扩容

2. WAL容量：
   - 监控WAL使用
   - 配置WAL保留
   - 定期清理

3. 连接容量：
   - 监控连接数
   - 配置最大连接数
   - 使用连接池
```

### 4.2 故障响应

#### 故障检测

```text
故障检测流程：

1. 自动检测：
   - 监控系统自动检测
   - 触发告警
   - 通知运维

2. 手动检测：
   - 定期检查
   - 故障排查
   - 问题定位

3. 故障确认：
   - 确认故障类型
   - 评估影响范围
   - 制定处理方案
```

#### 故障转移

```text
故障转移流程：

1. 故障检测：
   - 检测主节点故障
   - 确认故障
   - 触发故障转移

2. 从节点提升：
   - 停止复制
   - 提升为主节点
   - 恢复服务

3. 验证恢复：
   - 验证数据一致性
   - 验证服务正常
   - 监控系统状态

4. MVCC处理：
   - MVCC状态正常
   - 版本链正常
   - 事务一致性保证
```

#### 故障恢复

```text
故障恢复流程：

1. 问题修复：
   - 修复故障原因
   - 恢复主节点
   - 验证修复

2. 重新同步：
   - 重新配置复制
   - 同步数据
   - 恢复正常

3. 切换回主：
   - 计划内切换
   - 验证数据一致性
   - 恢复正常架构

4. MVCC恢复：
   - MVCC状态恢复
   - 版本链同步
   - 事务一致性保证
```

### 4.3 故障复盘

#### 故障分析

```text
故障分析流程：

1. 故障记录：
   - 记录故障时间
   - 记录故障现象
   - 记录处理过程

2. 根因分析：
   - 分析故障原因
   - 分析影响范围
   - 分析处理效果

3. 改进措施：
   - 制定改进措施
   - 实施改进
   - 验证效果
```

#### 改进措施

```text
改进措施：

1. 预防措施：
   - 加强监控
   - 优化配置
   - 定期维护

2. 响应措施：
   - 优化故障检测
   - 优化故障转移
   - 优化恢复流程

3. MVCC优化：
   - 优化MVCC配置
   - 优化VACUUM策略
   - 优化版本链管理
```

#### 预防措施

```text
预防措施：

1. 监控加强：
   - 完善监控体系
   - 设置告警规则
   - 定期检查

2. 配置优化：
   - 优化复制配置
   - 优化MVCC配置
   - 优化性能配置

3. 演练测试：
   - 定期故障演练
   - 测试故障转移
   - 验证恢复流程
```

---

## 📝 总结

### 核心原则

1. **架构设计**: 根据需求选择合适的架构
2. **配置优化**: 优化复制和MVCC配置
3. **监控告警**: 完善的监控和告警体系
4. **故障处理**: 快速故障检测、转移和恢复

### 最佳实践

1. **架构设计**: 一主多从、同步模式、负载均衡
2. **配置优化**: 同步模式、复制槽、VACUUM优化
3. **监控告警**: 复制监控、MVCC监控、性能监控
4. **故障处理**: 故障预防、快速响应、持续改进

PostgreSQL高可用最佳实践提供了完整的指导，通过合理的设计和优化，可以在保证高可用的同时获得可接受的性能和一致性。
