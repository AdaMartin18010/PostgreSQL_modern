# 快照隔离理论 - PostgreSQL MVCC形式化论证

> **文档编号**: THEORY-SNAPSHOT-001
> **主题**: 快照隔离理论
> **版本**: PostgreSQL 17 & 18

---

## 📑 目录

- [快照隔离理论 - PostgreSQL MVCC形式化论证](#快照隔离理论---postgresql-mvcc形式化论证)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [🔍 第一部分：快照隔离定义](#-第一部分快照隔离定义)
    - [1.1 基本定义](#11-基本定义)
      - [快照](#快照)
      - [快照隔离历史](#快照隔离历史)
      - [可见性规则](#可见性规则)
    - [1.2 一致性保证](#12-一致性保证)
      - [读一致性](#读一致性)
      - [写一致性](#写一致性)
    - [1.3 PostgreSQL实现](#13-postgresql实现)
      - [快照结构](#快照结构)
      - [可见性判断](#可见性判断)
  - [🚀 第二部分：异常分析](#-第二部分异常分析)
    - [2.1 写偏序异常](#21-写偏序异常)
      - [定义](#定义)
      - [形式化描述](#形式化描述)
      - [PostgreSQL检测](#postgresql检测)
    - [2.2 只读事务异常](#22-只读事务异常)
      - [定义](#定义-1)
    - [2.3 其他异常](#23-其他异常)
      - [丢失更新](#丢失更新)
      - [脏读](#脏读)
  - [📊 第三部分：形式化证明](#-第三部分形式化证明)
    - [3.1 快照隔离正确性](#31-快照隔离正确性)
      - [读一致性证明](#读一致性证明)
      - [写一致性证明](#写一致性证明)
    - [3.2 异常存在性证明](#32-异常存在性证明)
      - [写偏序异常证明](#写偏序异常证明)
    - [3.3 与可串行化关系](#33-与可串行化关系)
      - [快照隔离不是可串行化](#快照隔离不是可串行化)
      - [SSI保证可串行化](#ssi保证可串行化)
  - [🔧 第四部分：实际案例分析](#-第四部分实际案例分析)
    - [4.1 快照隔离正常案例](#41-快照隔离正常案例)
    - [4.2 写偏序异常案例](#42-写偏序异常案例)
    - [4.3 SSI检测案例](#43-ssi检测案例)
  - [📝 总结](#-总结)
    - [核心理论](#核心理论)
    - [形式化关系](#形式化关系)
    - [PostgreSQL实现](#postgresql实现)
    - [性能影响](#性能影响)

---

## 📋 概述

快照隔离（Snapshot Isolation）是PostgreSQL REPEATABLE READ隔离级别的核心机制，提供读一致性和写一致性保证，但不保证可串行化。本文档深入分析快照隔离理论，包括形式化定义、异常分析和正确性证明。

---

## 🔍 第一部分：快照隔离定义

### 1.1 基本定义

#### 快照

```text
快照（Snapshot）S = (XID_min, XID_max, Active_XIDs)

其中：
- XID_min：快照创建时的最小活跃XID
- XID_max：快照创建时的最大XID
- Active_XIDs：快照创建时的活跃事务集合

形式化定义：
S = snapshot(Tᵢ) = {
  xid_min = min({xid(Tⱼ) | Tⱼ ∈ active_at(start(Tᵢ))}),
  xid_max = max({xid(Tⱼ) | Tⱼ ∈ active_at(start(Tᵢ))}),
  active_xids = {xid(Tⱼ) | Tⱼ ∈ active_at(start(Tᵢ))}
}
```

#### 快照隔离历史

```text
快照隔离历史H满足以下条件：

1. 每个事务Tᵢ获得快照Sᵢ = snapshot(Tᵢ)
2. 读操作rᵢ[x]读取Sᵢ中x的值
3. 写操作wᵢ[x]创建新版本
4. 提交时检查写-写冲突

形式化定义：
H是快照隔离历史 ⟺
  (∀Tᵢ: snapshot(Tᵢ) = snapshot_at(start(Tᵢ))) ∧
  (∀rᵢ[x]: value(rᵢ[x]) = value_at(snapshot(Tᵢ), x)) ∧
  (∀wᵢ[x], wⱼ[x]: i ≠ j ⟹ first_committer_wins)
```

#### 可见性规则

```text
可见性规则（Visibility Rule）：
元组t对事务Tᵢ可见 ⟺
  (xmin(t) < xid(Tᵢ) ∧ xmin(t) ∉ active_xids(Tᵢ)) ∧
  (xmax(t) = NULL ∨ xmax(t) > xid(Tᵢ) ∨ xmax(t) ∈ active_xids(Tᵢ))

形式化定义：
visible(t, Tᵢ) ⟺
  committed_before(xmin(t), start(Tᵢ)) ∧
  (xmax(t) = NULL ∨ not_committed_before(xmax(t), start(Tᵢ)))
```

### 1.2 一致性保证

#### 读一致性

```text
读一致性（Read Consistency）：
- 事务内的所有读操作看到相同的快照
- 不会看到其他事务的中间状态

形式化定义：
read_consistent(H, Tᵢ) ⟺
  ∀rᵢ[x], rᵢ[y]:
    value(rᵢ[x]) = value_at(snapshot(Tᵢ), x) ∧
    value(rᵢ[y]) = value_at(snapshot(Tᵢ), y)
```

#### 写一致性

```text
写一致性（Write Consistency）：
- 事务的写操作基于快照
- 提交时检查写-写冲突

形式化定义：
write_consistent(H, Tᵢ) ⟺
  (∀wᵢ[x]: based_on(snapshot(Tᵢ))) ∧
  (∀wᵢ[x], wⱼ[x]: i ≠ j ⟹ first_committer_wins(Tᵢ, Tⱼ))
```

### 1.3 PostgreSQL实现

#### 快照结构

```c
// PostgreSQL快照结构（简化）
typedef struct SnapshotData {
    TransactionId xmin;           // 最小活跃XID
    TransactionId xmax;           // 最大XID
    TransactionId *xip;           // 活跃XID数组
    int32 xcnt;                   // 活跃XID数量
    CommandId curcid;             // 当前命令ID
} SnapshotData;
```

#### 可见性判断

```c
// PostgreSQL可见性判断（简化）
bool HeapTupleSatisfiesVisibility(HeapTuple tuple, Snapshot snapshot) {
    TransactionId xmin = HeapTupleHeaderGetXmin(tuple);
    TransactionId xmax = HeapTupleHeaderGetXmax(tuple);

    // 检查xmin
    if (xmin >= snapshot->xmax ||
        XidInMVCCSnapshot(xmin, snapshot)) {
        return false;  // 不可见
    }

    // 检查xmax
    if (xmax != InvalidTransactionId) {
        if (xmax < snapshot->xmin ||
            !XidInMVCCSnapshot(xmax, snapshot)) {
            return false;  // 已删除
        }
    }

    return true;  // 可见
}
```

---

## 🚀 第二部分：异常分析

### 2.1 写偏序异常

#### 定义

```text
写偏序异常（Write Skew）：
- 两个事务读取不同的数据项
- 基于读取的值进行写入
- 结果违反全局约束

形式化定义：
write_skew(H) ⟺
  ∃Tᵢ, Tⱼ, x, y, constraint C:
    (rᵢ[x] ∈ H ∧ rⱼ[y] ∈ H) ∧
    (wᵢ[y] ∈ H ∧ wⱼ[x] ∈ H) ∧
    (satisfies(snapshot(Tᵢ), C) ∧ satisfies(snapshot(Tⱼ), C)) ∧
    (¬satisfies(final_state(H), C))
```

#### 形式化描述

```text
写偏序异常示例：

初始状态：
x = 50, y = 50
约束：x + y ≥ 0

事务T1：
r₁[x] → 50
r₁[y] → 50
w₁[x] → 100  // 满足约束：100 + 50 ≥ 0
c₁

事务T2：
r₂[x] → 50  // 基于快照
r₂[y] → 50  // 基于快照
w₂[y] → -100  // 满足约束：50 + (-100) ≥ 0
c₂

最终状态：
x = 100, y = -100
约束违反：100 + (-100) = 0 ≥ 0（实际可能违反更严格约束）
```

#### PostgreSQL检测

```text
PostgreSQL SSI检测写偏序：
- 使用SIREAD锁记录读操作
- 检测读写冲突
- 如果检测到冲突，中止事务

形式化描述：
ssi_detect(H, Tᵢ) ⟺
  ∃Tⱼ, x:
    (rᵢ[x] ∈ H ∧ wⱼ[x] ∈ H) ∧
    (commit(Tⱼ) > commit(Tᵢ)) ∧
    (conflict(Tᵢ, Tⱼ))
```

### 2.2 只读事务异常

#### 定义

```text
只读事务异常（Read-Only Transaction Anomaly）：
- 只读事务可能看到不一致的快照
- 违反可串行化

形式化定义：
read_only_anomaly(H) ⟺
  ∃Tᵢ (read-only), Tⱼ, Tₖ:
    (rᵢ[x] ∈ H ∧ rᵢ[y] ∈ H) ∧
    (wⱼ[x] ∈ H ∧ wₖ[y] ∈ H) ∧
    (commit(Tⱼ) < commit(Tₖ)) ∧
    (visible(wⱼ[x], Tᵢ) ∧ visible(wₖ[y], Tᵢ)) ∧
    (¬serializable(H))
```

### 2.3 其他异常

#### 丢失更新

```text
丢失更新（Lost Update）：
- 快照隔离通过写-写冲突检测防止
- 第一个提交者获胜

形式化定义：
lost_update_prevented(H) ⟺
  ∀wᵢ[x], wⱼ[x]:
    (i ≠ j ∧ commit(Tᵢ) < commit(Tⱼ)) ⟹
    (wⱼ[x] 覆盖 wᵢ[x] 或 Tⱼ 中止)
```

#### 脏读

```text
脏读（Dirty Read）：
- 快照隔离防止脏读
- 只读取已提交的数据

形式化定义：
dirty_read_prevented(H) ⟺
  ∀rᵢ[x]:
    value(rᵢ[x]) = value_at(snapshot(Tᵢ), x) ∧
    (∀wⱼ[x]: visible(wⱼ[x], Tᵢ) ⟹ committed(Tⱼ))
```

---

## 📊 第三部分：形式化证明

### 3.1 快照隔离正确性

#### 读一致性证明

```text
定理：快照隔离保证读一致性

证明：
1. 每个事务Tᵢ在开始时获得快照Sᵢ
2. 所有读操作rᵢ[x]基于Sᵢ
3. Sᵢ在事务期间不变
4. 因此所有读操作看到相同的快照

形式化证明：
∀rᵢ[x], rᵢ[y] ∈ H:
  snapshot(rᵢ[x]) = snapshot(Tᵢ) = snapshot(rᵢ[y])

因此：
  value(rᵢ[x]) = value_at(snapshot(Tᵢ), x)
  value(rᵢ[y]) = value_at(snapshot(Tᵢ), y)

读一致性得证。
```

#### 写一致性证明

```text
定理：快照隔离保证写一致性

证明：
1. 写操作基于快照
2. 提交时检查写-写冲突
3. 第一个提交者获胜

形式化证明：
∀wᵢ[x], wⱼ[x] ∈ H (i ≠ j):
  如果 commit(Tᵢ) < commit(Tⱼ):
    则 wⱼ[x] 覆盖 wᵢ[x] 或 Tⱼ 中止

写一致性得证。
```

### 3.2 异常存在性证明

#### 写偏序异常证明

```text
定理：快照隔离存在写偏序异常

证明（构造反例）：
初始状态：x = 50, y = 50，约束：x + y ≥ 0

事务T1：
  r₁[x] → 50
  r₁[y] → 50
  w₁[x] → 100  // 满足约束
  c₁

事务T2（并发）：
  r₂[x] → 50  // 基于快照
  r₂[y] → 50  // 基于快照
  w₂[y] → -100  // 满足约束
  c₂

最终状态：x = 100, y = -100
约束可能违反（取决于具体约束）

结论：快照隔离不保证可串行化。
```

### 3.3 与可串行化关系

#### 快照隔离不是可串行化

```text
定理：快照隔离不保证可串行化

证明：
- 存在写偏序异常
- 写偏序异常违反可串行化
- 因此快照隔离不保证可串行化

形式化证明：
∃H:
  (snapshot_isolation(H)) ∧
  (¬serializable(H))

因此：
  snapshot_isolation ⇏ serializable
```

#### SSI保证可串行化

```text
定理：SSI（可串行化快照隔离）保证可串行化

证明思路：
1. SSI检测写偏序异常
2. 通过SIREAD锁和谓词锁检测冲突
3. 中止冲突事务
4. 保证可串行化

形式化证明：
∀H:
  (ssi(H) ⟹ serializable(H))

其中：
  ssi(H) ⟺ snapshot_isolation(H) ∧ conflict_detection(H)
```

---

## 🔧 第四部分：实际案例分析

### 4.1 快照隔离正常案例

```sql
-- 案例1：快照隔离正常执行
-- T1: BEGIN; SELECT x FROM t; UPDATE t SET x = 100; COMMIT;
-- T2: BEGIN; SELECT x FROM t; COMMIT;

-- 执行顺序：
-- T1开始，获得快照S1（x=50）
-- T2开始，获得快照S2（x=50）
-- T1读取x=50（基于S1）
-- T1更新x=100
-- T1提交
-- T2读取x=50（基于S2，不看到T1的更新）
-- T2提交

-- 结果：
-- T1看到x=50，更新为100
-- T2看到x=50（快照隔离）
-- 最终x=100

-- 结论：快照隔离正常工作
```

### 4.2 写偏序异常案例

```sql
-- 案例2：写偏序异常
-- 账户表：account_id, balance
-- 约束：balance ≥ 0

-- T1:
BEGIN;
SELECT balance FROM accounts WHERE account_id = 1;  -- 50
SELECT balance FROM accounts WHERE account_id = 2;  -- 50
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;  -- -50
COMMIT;  -- 满足约束：-50 + 50 ≥ 0

-- T2（并发）:
BEGIN;
SELECT balance FROM accounts WHERE account_id = 1;  -- 50（快照）
SELECT balance FROM accounts WHERE account_id = 2;  -- 50（快照）
UPDATE accounts SET balance = balance - 100 WHERE account_id = 2;  -- -50
COMMIT;  -- 满足约束：50 + (-50) ≥ 0

-- 最终状态：
-- account_id=1: balance = -50
-- account_id=2: balance = -50
-- 约束违反：-50 + (-50) = -100 < 0

-- 结论：写偏序异常
```

### 4.3 SSI检测案例

```sql
-- 案例3：SSI检测写偏序异常
-- 设置隔离级别为SERIALIZABLE

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- T1:
BEGIN;
SELECT balance FROM accounts WHERE account_id = 1;  -- 50
SELECT balance FROM accounts WHERE account_id = 2;  -- 50
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
COMMIT;

-- T2（并发）:
BEGIN;
SELECT balance FROM accounts WHERE account_id = 1;  -- 50
SELECT balance FROM accounts WHERE account_id = 2;  -- 50
UPDATE accounts SET balance = balance - 100 WHERE account_id = 2;
COMMIT;  -- ERROR: could not serialize access due to read/write dependencies

-- SSI检测到冲突：
-- T1读取account_id=1,2
-- T2读取account_id=1,2
-- T1写入account_id=1
-- T2写入account_id=2
-- 检测到读写冲突，中止T2

-- 结论：SSI成功检测并防止写偏序异常
```

---

## 📝 总结

### 核心理论

1. **快照隔离**：提供读一致性和写一致性
2. **写偏序异常**：快照隔离的主要异常
3. **SSI机制**：通过冲突检测保证可串行化

### 形式化关系

```text
快照隔离 ⟹ 读一致性 ∧ 写一致性
快照隔离 ⇏ 可串行化
SSI ⟹ 可串行化
```

### PostgreSQL实现

- **REPEATABLE READ**：快照隔离，不保证可串行化
- **SERIALIZABLE**：SSI机制，保证可串行化

### 性能影响

| 隔离级别 | 一致性保证 | 性能开销 |
|---------|----------|---------|
| REPEATABLE READ | 读一致性、写一致性 | 低 |
| SERIALIZABLE | 可串行化 | 高（SSI检测） |

PostgreSQL通过快照隔离提供高性能的并发控制，通过SSI机制在需要时保证可串行化。
