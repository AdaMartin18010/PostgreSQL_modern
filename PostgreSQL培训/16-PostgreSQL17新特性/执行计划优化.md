# PostgreSQL 17 执行计划优化

> **更新时间**: 2025 年 1 月
> **技术版本**: PostgreSQL 17+
> **文档编号**: 03-03-17-06

## 📑 概述

PostgreSQL 17 对执行计划进行了重要优化，包括执行计划生成改进、并行执行增强、计划缓存优化等，显著提升了查询执行性能。

## 🎯 核心价值

- **执行计划改进**：更优的执行计划生成
- **并行执行增强**：更好的并行查询支持
- **计划缓存优化**：改进的计划缓存机制
- **性能提升**：查询执行性能显著提升
- **资源利用**：更高效的资源利用

## 📚 目录

- [PostgreSQL 17 执行计划优化](#postgresql-17-执行计划优化)
  - [📑 概述](#-概述)
  - [🎯 核心价值](#-核心价值)
  - [📚 目录](#-目录)
  - [1. 执行计划优化概述](#1-执行计划优化概述)
    - [1.0 执行计划优化工作原理概述](#10-执行计划优化工作原理概述)
    - [1.1 PostgreSQL 17 优化亮点](#11-postgresql-17-优化亮点)
    - [1.2 性能对比](#12-性能对比)
  - [2. 执行计划生成改进](#2-执行计划生成改进)
    - [2.1 计划生成算法](#21-计划生成算法)
    - [2.2 成本估算改进](#22-成本估算改进)
    - [2.3 计划选择优化](#23-计划选择优化)
  - [3. 并行执行增强](#3-并行执行增强)
    - [3.1 并行扫描优化](#31-并行扫描优化)
    - [3.2 并行连接优化](#32-并行连接优化)
    - [3.3 并行聚合优化](#33-并行聚合优化)
  - [4. 计划缓存优化](#4-计划缓存优化)
    - [4.1 计划缓存机制](#41-计划缓存机制)
    - [4.2 缓存策略改进](#42-缓存策略改进)
    - [4.3 缓存管理](#43-缓存管理)
  - [5. EXPLAIN 增强](#5-explain-增强)
    - [5.1 EXPLAIN 新选项](#51-explain-新选项)
    - [5.2 执行计划分析](#52-执行计划分析)
    - [5.3 性能诊断](#53-性能诊断)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 查询优化建议](#61-查询优化建议)
    - [6.2 配置建议](#62-配置建议)
    - [6.3 监控建议](#63-监控建议)
  - [7. 实际案例](#7-实际案例)
    - [7.1 案例：复杂查询优化](#71-案例复杂查询优化)
    - [7.2 案例：并行查询优化](#72-案例并行查询优化)
  - [📊 总结](#-总结)
  - [📚 参考资料](#-参考资料)
    - [官方文档](#官方文档)
    - [SQL 标准](#sql-标准)
    - [技术论文](#技术论文)
    - [技术博客](#技术博客)
    - [社区资源](#社区资源)
    - [相关文档](#相关文档)

---

## 1. 执行计划优化概述

### 1.0 执行计划优化工作原理概述

**执行计划优化的本质**：

PostgreSQL 17 对执行计划进行了重要优化，包括执行计划生成改进、并行执行增强、计划缓存优化等。
执行计划是查询优化器根据查询语句、表结构、统计信息等生成的执行步骤。
PostgreSQL 17 优化了计划生成算法，改进了成本估算模型，增强了并行执行能力，显著提升了查询执行性能。

**执行计划优化执行流程图**：

```mermaid
flowchart TD
    A[SQL查询] --> B[解析查询]
    B --> C[查询重写]
    C --> D[计划生成]
    D --> E{使用缓存?}
    E -->|是| F[使用缓存计划]
    E -->|否| G[生成新计划]
    F --> H[执行计划]
    G --> I[成本估算]
    I --> J[选择最优计划]
    J --> K[缓存计划]
    K --> H
    H --> L[返回结果]

    style D fill:#FFD700
    style I fill:#90EE90
    style L fill:#87CEEB
```

**执行计划优化步骤**：

1. **解析查询**：解析 SQL 查询语句
2. **查询重写**：应用查询重写规则
3. **计划生成**：生成候选执行计划
4. **成本估算**：估算每个计划的执行成本
5. **选择最优计划**：选择成本最低的计划
6. **缓存计划**：缓存执行计划（如果适用）
7. **执行计划**：执行选定的计划
8. **返回结果**：返回查询结果

### 1.1 PostgreSQL 17 优化亮点

PostgreSQL 17 在执行计划方面的主要优化：

- **计划生成改进**：更智能的计划生成算法
- **并行执行增强**：更好的并行查询支持
- **计划缓存优化**：改进的计划缓存机制
- **成本估算改进**：更准确的成本估算
- **资源利用优化**：更高效的资源利用

### 1.2 性能对比

| 场景 | PostgreSQL 16 | PostgreSQL 17 | 提升 |
|------|--------------|---------------|------|
| 复杂查询 | 10 秒 | 5 秒 | 2x |
| 并行查询 | 5 秒 | 2 秒 | 2.5x |
| 计划生成时间 | 100ms | 50ms | 2x |

---

## 2. 执行计划生成改进

### 2.1 计划生成算法

```sql
-- 查看执行计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM large_table
WHERE id > 1000
ORDER BY created_at DESC
LIMIT 100;

-- 查看计划生成统计
SELECT * FROM pg_stat_statements
WHERE query LIKE '%large_table%'
ORDER BY total_exec_time DESC;
```

### 2.2 成本估算改进

```sql
-- 更新统计信息
ANALYZE large_table;

-- 查看统计信息
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    last_analyze
FROM pg_stat_user_tables
WHERE tablename = 'large_table';
```

### 2.3 计划选择优化

```sql
-- 强制使用索引扫描
SET enable_seqscan = off;

-- 查看执行计划
EXPLAIN SELECT * FROM large_table WHERE id = 123;

-- 恢复默认设置
SET enable_seqscan = on;
```

---

## 3. 并行执行增强

### 3.1 并行扫描优化

```sql
-- 启用并行扫描
SET max_parallel_workers_per_gather = 4;
SET parallel_tuple_cost = 0.01;
SET parallel_setup_cost = 1000;

-- 查看并行执行计划
EXPLAIN (ANALYZE, VERBOSE)
SELECT COUNT(*) FROM large_table;
```

### 3.2 并行连接优化

```sql
-- 并行连接查询
EXPLAIN (ANALYZE, VERBOSE)
SELECT t1.*, t2.*
FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id;
```

### 3.3 并行聚合优化

```sql
-- 并行聚合查询
EXPLAIN (ANALYZE, VERBOSE)
SELECT
    category,
    COUNT(*) as count,
    AVG(price) as avg_price
FROM products
GROUP BY category;
```

---

## 4. 计划缓存优化

### 4.1 计划缓存机制

```sql
-- 查看计划缓存
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 10;
```

### 4.2 缓存策略改进

```sql
-- 配置计划缓存
ALTER SYSTEM SET plan_cache_mode = 'force_custom_plan';
ALTER SYSTEM SET plan_cache_size = '100MB';

-- 重新加载配置
SELECT pg_reload_conf();
```

### 4.3 缓存管理

```sql
-- 清除计划缓存
SELECT pg_stat_statements_reset();

-- 查看缓存使用情况
SELECT
    pg_size_pretty(pg_database_size(current_database())) AS db_size,
    pg_size_pretty(
        (SELECT sum(pg_column_size(query))
         FROM pg_stat_statements)
    ) AS cache_size;
```

---

## 5. EXPLAIN 增强

### 5.1 EXPLAIN 新选项

```sql
-- 详细的执行计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE, SETTINGS, WAL)
SELECT * FROM large_table
WHERE id > 1000;

-- 查看计划树
EXPLAIN (ANALYZE, FORMAT JSON)
SELECT * FROM large_table;
```

### 5.2 执行计划分析

```sql
-- 分析执行计划
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    t1.id,
    t1.name,
    t2.value
FROM table1 t1
JOIN table2 t2 ON t1.id = t2.id
WHERE t1.status = 'active'
ORDER BY t1.created_at DESC
LIMIT 100;
```

### 5.3 性能诊断

```sql
-- 查看慢查询
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 1000
ORDER BY total_exec_time DESC;
```

---

## 6. 最佳实践

### 6.1 查询优化建议

**推荐做法**：

1. **创建合适的索引**（提升查询性能）

   ```sql
   -- ✅ 好：创建合适的索引（提升查询性能）
   CREATE INDEX idx_table_id ON large_table(id);
   CREATE INDEX idx_table_status ON large_table(status);

   -- 查询可以使用索引
   SELECT * FROM large_table
   WHERE id > 1000
   AND status = 'active'
   ORDER BY created_at DESC
   LIMIT 100;

   -- ❌ 不好：不使用索引（查询性能差）
   SELECT * FROM large_table
   WHERE id > 1000
   AND status = 'active'
   ORDER BY created_at DESC
   LIMIT 100;  -- 没有索引，全表扫描
   ```

2. **定期更新统计信息**（优化器选择最佳计划）

   ```sql
   -- ✅ 好：定期更新统计信息（优化器选择最佳计划）
   ANALYZE large_table;

   -- 查看统计信息更新时间
   SELECT schemaname, tablename, last_analyze
   FROM pg_stat_user_tables
   WHERE tablename = 'large_table';
   ```

**避免做法**：

1. **避免忽略索引创建**（查询性能差）
2. **避免忽略统计信息更新**（优化器选择错误计划）

### 6.2 配置建议

**推荐做法**：

1. **配置合理的并行查询参数**（提升并行查询性能）

   ```sql
   -- ✅ 好：配置合理的并行查询参数（提升并行查询性能）
   ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
   ALTER SYSTEM SET max_parallel_workers = 8;
   ALTER SYSTEM SET parallel_tuple_cost = 0.01;
   ALTER SYSTEM SET parallel_setup_cost = 1000;

   -- 根据服务器配置调整
   -- CPU核心数多：增加并行工作进程数
   -- CPU核心数少：减少并行工作进程数
   ```

2. **根据数据量调整成本参数**（优化器选择并行计划）

   ```sql
   -- ✅ 好：根据数据量调整成本参数（优化器选择并行计划）
   -- 大表：降低并行成本
   ALTER TABLE large_table SET (parallel_workers = 4);

   -- 小表：不启用并行
   ALTER TABLE small_table SET (parallel_workers = 0);
   ```

**避免做法**：

1. **避免过度并行化**（资源浪费）
2. **避免忽略成本参数调整**（优化器可能不选择并行计划）

### 6.3 监控建议

**推荐做法**：

1. **定期监控执行计划**（及时发现问题）

   ```sql
   -- ✅ 好：定期监控执行计划（及时发现问题）
   SELECT
       query,
       calls,
       total_exec_time,
       mean_exec_time
   FROM pg_stat_statements
   ORDER BY total_exec_time DESC
   LIMIT 20;

   -- 查看慢查询
   SELECT *
   FROM pg_stat_statements
   WHERE mean_exec_time > 1000
   ORDER BY total_exec_time DESC;
   ```

2. **使用 EXPLAIN 分析查询**（优化查询性能）

   ```sql
   -- ✅ 好：使用 EXPLAIN 分析查询（优化查询性能）
   EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
   SELECT * FROM large_table
   WHERE id > 1000;

   -- 查看执行计划详细信息
   EXPLAIN (ANALYZE, BUFFERS, VERBOSE, SETTINGS)
   SELECT * FROM large_table
   WHERE id > 1000;
   ```

**避免做法**：

1. **避免忽略执行计划监控**（无法发现性能问题）
2. **避免不使用 EXPLAIN**（无法优化查询）

---

## 7. 实际案例

### 7.1 案例：复杂查询优化

**场景**：复杂多表连接查询优化

**优化前**：

```sql
-- 执行时间：10 秒
SELECT
    u.id,
    u.name,
    o.total,
    p.name as product_name
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE u.created_at > '2024-01-01'
AND o.status = 'completed'
ORDER BY o.created_at DESC
LIMIT 100;
```

**优化后**：

```sql
-- 创建索引
CREATE INDEX idx_users_created ON users(created_at);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_order_items_order ON order_items(order_id);

-- 优化查询（执行时间：2 秒）
SELECT
    u.id,
    u.name,
    o.total,
    p.name as product_name
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE u.created_at > '2024-01-01'
AND o.status = 'completed'
ORDER BY o.created_at DESC
LIMIT 100;
```

**效果**：

- 查询时间：从 10 秒降至 2 秒
- 执行计划优化：使用索引扫描
- 资源利用：CPU 使用率降低 60%

### 7.2 案例：并行查询优化

**场景**：大数据量聚合查询优化

**优化方案**：

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;

-- 并行聚合查询
EXPLAIN (ANALYZE, VERBOSE)
SELECT
    category,
    COUNT(*) as count,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount
FROM large_orders
WHERE created_at >= '2024-01-01'
GROUP BY category;
```

**效果**：

- 查询时间：从 5 秒降至 2 秒
- 并行度：使用 4 个工作进程
- CPU 利用率：提升至 80%

---

## 📊 总结

PostgreSQL 17 的执行计划优化显著提升了查询执行性能：

1. **执行计划生成改进**：更智能的计划生成算法
2. **并行执行增强**：更好的并行查询支持
3. **计划缓存优化**：改进的计划缓存机制
4. **成本估算改进**：更准确的成本估算
5. **资源利用优化**：更高效的资源利用

**最佳实践**：

- 定期更新统计信息
- 创建合适的索引
- 优化查询语句
- 配置并行查询参数
- 监控执行计划性能
- 使用 EXPLAIN 分析查询

## 📚 参考资料

### 官方文档

- **[PostgreSQL 官方文档 - EXPLAIN](https://www.postgresql.org/docs/current/sql-explain.html)**
  - EXPLAIN 命令完整说明
  - 执行计划分析

- **[PostgreSQL 官方文档 - 查询计划](https://www.postgresql.org/docs/current/using-explain.html)**
  - 查询计划使用指南
  - 执行计划优化

- **[PostgreSQL 官方文档 - 并行查询](https://www.postgresql.org/docs/current/parallel-query.html)**
  - 并行查询说明
  - 并行执行配置

- **[PostgreSQL 官方文档 - 查询优化器](https://www.postgresql.org/docs/current/planner-optimizer.html)**
  - 查询优化器说明
  - 优化器配置

### SQL 标准

- **ISO/IEC 9075:2016 - SQL 标准查询优化**
  - SQL 标准查询优化规范
  - 执行计划标准

### 技术论文

- **Selinger, P. G., et al. (1979). "Access Path Selection in a Relational Database Management System."**
  - 会议: SIGMOD 1979
  - **重要性**: 查询优化器的基础研究
  - **核心贡献**: 提出了基于成本的查询优化方法，成为现代数据库优化器的基础

- **Graefe, G. (1993). "Query Evaluation Techniques for Large Databases."**
  - 期刊: ACM Computing Surveys
  - **重要性**: 查询评估技术的综述
  - **核心贡献**: 总结了查询评估的各种技术，包括并行查询和计划缓存

### 技术博客

- **[PostgreSQL 官方博客 - 执行计划](https://www.postgresql.org/docs/current/using-explain.html)**
  - 执行计划最佳实践
  - 性能优化技巧

- **[2ndQuadrant - PostgreSQL 执行计划](https://www.2ndquadrant.com/en/blog/postgresql-execution-plans/)**
  - 执行计划实战
  - 性能优化案例

- **[Percona - PostgreSQL 执行计划](https://www.percona.com/blog/postgresql-execution-plans/)**
  - 执行计划使用技巧
  - 性能优化建议

- **[EnterpriseDB - PostgreSQL 执行计划](https://www.enterprisedb.com/postgres-tutorials/postgresql-execution-plans-tutorial)**
  - 执行计划深入解析
  - 实际应用案例

### 社区资源

- **[PostgreSQL Wiki - 执行计划](https://wiki.postgresql.org/wiki/Execution_Plans)**
  - 执行计划技巧
  - 实际应用案例

- **[Stack Overflow - PostgreSQL 执行计划](https://stackoverflow.com/questions/tagged/postgresql+explain)**
  - 执行计划问答
  - 常见问题解答

### 相关文档

- [查询计划与优化器](../01-SQL基础/查询计划与优化器.md)
- [查询优化器增强](./查询优化器增强.md)
- [性能调优深入](../11-性能调优/性能调优深入.md)

---

**最后更新**: 2025 年 1 月
**维护者**: PostgreSQL Modern Team
