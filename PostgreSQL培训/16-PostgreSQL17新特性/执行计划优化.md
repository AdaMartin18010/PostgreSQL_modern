# PostgreSQL 17 执行计划优化

> **更新时间**: 2025 年 1 月
> **技术版本**: PostgreSQL 17+
> **文档编号**: 03-03-17-06

## 📑 概述

PostgreSQL 17 对执行计划进行了重要优化，包括执行计划生成改进、并行执行增强、计划缓存优化等，显著提升了查询执行性能。

## 🎯 核心价值

- **执行计划改进**：更优的执行计划生成
- **并行执行增强**：更好的并行查询支持
- **计划缓存优化**：改进的计划缓存机制
- **性能提升**：查询执行性能显著提升
- **资源利用**：更高效的资源利用

## 📚 目录

- [PostgreSQL 17 执行计划优化](#postgresql-17-执行计划优化)
  - [📑 概述](#-概述)
  - [🎯 核心价值](#-核心价值)
  - [📚 目录](#-目录)
  - [1. 执行计划优化概述](#1-执行计划优化概述)
    - [1.1 PostgreSQL 17 优化亮点](#11-postgresql-17-优化亮点)
    - [1.2 性能对比](#12-性能对比)
  - [2. 执行计划生成改进](#2-执行计划生成改进)
    - [2.1 计划生成算法](#21-计划生成算法)
    - [2.2 成本估算改进](#22-成本估算改进)
    - [2.3 计划选择优化](#23-计划选择优化)
  - [3. 并行执行增强](#3-并行执行增强)
    - [3.1 并行扫描优化](#31-并行扫描优化)
    - [3.2 并行连接优化](#32-并行连接优化)
    - [3.3 并行聚合优化](#33-并行聚合优化)
  - [4. 计划缓存优化](#4-计划缓存优化)
    - [4.1 计划缓存机制](#41-计划缓存机制)
    - [4.2 缓存策略改进](#42-缓存策略改进)
    - [4.3 缓存管理](#43-缓存管理)
  - [5. EXPLAIN 增强](#5-explain-增强)
    - [5.1 EXPLAIN 新选项](#51-explain-新选项)
    - [5.2 执行计划分析](#52-执行计划分析)
    - [5.3 性能诊断](#53-性能诊断)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 查询优化建议](#61-查询优化建议)
    - [6.2 配置建议](#62-配置建议)
    - [6.3 监控建议](#63-监控建议)
  - [7. 实际案例](#7-实际案例)
    - [7.1 案例：复杂查询优化](#71-案例复杂查询优化)
    - [7.2 案例：并行查询优化](#72-案例并行查询优化)
  - [📊 总结](#-总结)

---

## 1. 执行计划优化概述

### 1.1 PostgreSQL 17 优化亮点

PostgreSQL 17 在执行计划方面的主要优化：

- **计划生成改进**：更智能的计划生成算法
- **并行执行增强**：更好的并行查询支持
- **计划缓存优化**：改进的计划缓存机制
- **成本估算改进**：更准确的成本估算
- **资源利用优化**：更高效的资源利用

### 1.2 性能对比

| 场景 | PostgreSQL 16 | PostgreSQL 17 | 提升 |
|------|--------------|---------------|------|
| 复杂查询 | 10 秒 | 5 秒 | 2x |
| 并行查询 | 5 秒 | 2 秒 | 2.5x |
| 计划生成时间 | 100ms | 50ms | 2x |

---

## 2. 执行计划生成改进

### 2.1 计划生成算法

```sql
-- 查看执行计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM large_table
WHERE id > 1000
ORDER BY created_at DESC
LIMIT 100;

-- 查看计划生成统计
SELECT * FROM pg_stat_statements
WHERE query LIKE '%large_table%'
ORDER BY total_exec_time DESC;
```

### 2.2 成本估算改进

```sql
-- 更新统计信息
ANALYZE large_table;

-- 查看统计信息
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    last_analyze
FROM pg_stat_user_tables
WHERE tablename = 'large_table';
```

### 2.3 计划选择优化

```sql
-- 强制使用索引扫描
SET enable_seqscan = off;

-- 查看执行计划
EXPLAIN SELECT * FROM large_table WHERE id = 123;

-- 恢复默认设置
SET enable_seqscan = on;
```

---

## 3. 并行执行增强

### 3.1 并行扫描优化

```sql
-- 启用并行扫描
SET max_parallel_workers_per_gather = 4;
SET parallel_tuple_cost = 0.01;
SET parallel_setup_cost = 1000;

-- 查看并行执行计划
EXPLAIN (ANALYZE, VERBOSE)
SELECT COUNT(*) FROM large_table;
```

### 3.2 并行连接优化

```sql
-- 并行连接查询
EXPLAIN (ANALYZE, VERBOSE)
SELECT t1.*, t2.*
FROM large_table1 t1
JOIN large_table2 t2 ON t1.id = t2.id;
```

### 3.3 并行聚合优化

```sql
-- 并行聚合查询
EXPLAIN (ANALYZE, VERBOSE)
SELECT
    category,
    COUNT(*) as count,
    AVG(price) as avg_price
FROM products
GROUP BY category;
```

---

## 4. 计划缓存优化

### 4.1 计划缓存机制

```sql
-- 查看计划缓存
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 10;
```

### 4.2 缓存策略改进

```sql
-- 配置计划缓存
ALTER SYSTEM SET plan_cache_mode = 'force_custom_plan';
ALTER SYSTEM SET plan_cache_size = '100MB';

-- 重新加载配置
SELECT pg_reload_conf();
```

### 4.3 缓存管理

```sql
-- 清除计划缓存
SELECT pg_stat_statements_reset();

-- 查看缓存使用情况
SELECT
    pg_size_pretty(pg_database_size(current_database())) AS db_size,
    pg_size_pretty(
        (SELECT sum(pg_column_size(query))
         FROM pg_stat_statements)
    ) AS cache_size;
```

---

## 5. EXPLAIN 增强

### 5.1 EXPLAIN 新选项

```sql
-- 详细的执行计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE, SETTINGS, WAL)
SELECT * FROM large_table
WHERE id > 1000;

-- 查看计划树
EXPLAIN (ANALYZE, FORMAT JSON)
SELECT * FROM large_table;
```

### 5.2 执行计划分析

```sql
-- 分析执行计划
EXPLAIN (ANALYZE, BUFFERS)
SELECT
    t1.id,
    t1.name,
    t2.value
FROM table1 t1
JOIN table2 t2 ON t1.id = t2.id
WHERE t1.status = 'active'
ORDER BY t1.created_at DESC
LIMIT 100;
```

### 5.3 性能诊断

```sql
-- 查看慢查询
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE mean_exec_time > 1000
ORDER BY total_exec_time DESC;
```

---

## 6. 最佳实践

### 6.1 查询优化建议

```sql
-- 使用索引
CREATE INDEX idx_table_id ON large_table(id);
CREATE INDEX idx_table_status ON large_table(status);

-- 优化查询
SELECT * FROM large_table
WHERE id > 1000
AND status = 'active'
ORDER BY created_at DESC
LIMIT 100;
```

### 6.2 配置建议

```sql
-- 并行查询配置
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
ALTER SYSTEM SET max_parallel_workers = 8;
ALTER SYSTEM SET parallel_tuple_cost = 0.01;
ALTER SYSTEM SET parallel_setup_cost = 1000;
```

### 6.3 监控建议

```sql
-- 监控执行计划
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 20;
```

---

## 7. 实际案例

### 7.1 案例：复杂查询优化

**场景**：复杂多表连接查询优化

**优化前**：

```sql
-- 执行时间：10 秒
SELECT
    u.id,
    u.name,
    o.total,
    p.name as product_name
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE u.created_at > '2024-01-01'
AND o.status = 'completed'
ORDER BY o.created_at DESC
LIMIT 100;
```

**优化后**：

```sql
-- 创建索引
CREATE INDEX idx_users_created ON users(created_at);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_order_items_order ON order_items(order_id);

-- 优化查询（执行时间：2 秒）
SELECT
    u.id,
    u.name,
    o.total,
    p.name as product_name
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE u.created_at > '2024-01-01'
AND o.status = 'completed'
ORDER BY o.created_at DESC
LIMIT 100;
```

**效果**：

- 查询时间：从 10 秒降至 2 秒
- 执行计划优化：使用索引扫描
- 资源利用：CPU 使用率降低 60%

### 7.2 案例：并行查询优化

**场景**：大数据量聚合查询优化

**优化方案**：

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;

-- 并行聚合查询
EXPLAIN (ANALYZE, VERBOSE)
SELECT
    category,
    COUNT(*) as count,
    SUM(amount) as total_amount,
    AVG(amount) as avg_amount
FROM large_orders
WHERE created_at >= '2024-01-01'
GROUP BY category;
```

**效果**：

- 查询时间：从 5 秒降至 2 秒
- 并行度：使用 4 个工作进程
- CPU 利用率：提升至 80%

---

## 📊 总结

PostgreSQL 17 的执行计划优化显著提升了查询执行性能：

1. **执行计划生成改进**：更智能的计划生成算法
2. **并行执行增强**：更好的并行查询支持
3. **计划缓存优化**：改进的计划缓存机制
4. **成本估算改进**：更准确的成本估算
5. **资源利用优化**：更高效的资源利用

**最佳实践**：

- 定期更新统计信息
- 创建合适的索引
- 优化查询语句
- 配置并行查询参数
- 监控执行计划性能
- 使用 EXPLAIN 分析查询

---

**最后更新**: 2025 年 1 月
**维护者**: PostgreSQL Modern Team
