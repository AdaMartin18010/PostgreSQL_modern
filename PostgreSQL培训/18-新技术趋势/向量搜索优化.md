# 向量搜索优化：pgvector 性能调优指南

> **更新时间**: 2025 年 1 月
> **技术版本**: PostgreSQL 17+ with pgvector
> **文档编号**: 03-03-TREND-02

## 📑 概述

本文档详细介绍 pgvector 向量搜索的性能优化方法，包括索引参数调优、查询优化、批量操作优化等，帮助在生产环境中实现高性能的向量搜索。

## 🎯 核心价值

- **索引优化**：HNSW 和 IVFFlat 索引参数调优
- **查询优化**：查询性能优化策略
- **批量操作**：批量插入和更新优化
- **内存优化**：内存使用优化
- **性能提升**：向量搜索性能提升 2-10 倍

## 📚 目录

- [向量搜索优化：pgvector 性能调优指南](#向量搜索优化pgvector-性能调优指南)
  - [📑 概述](#-概述)
  - [🎯 核心价值](#-核心价值)
  - [📚 目录](#-目录)
  - [1. 向量搜索优化概述](#1-向量搜索优化概述)
    - [1.1 性能影响因素](#11-性能影响因素)
    - [1.2 优化目标](#12-优化目标)
  - [2. HNSW 索引优化](#2-hnsw-索引优化)
    - [2.1 HNSW 参数说明](#21-hnsw-参数说明)
    - [2.2 参数调优策略](#22-参数调优策略)
    - [2.3 查询时参数调优](#23-查询时参数调优)
  - [3. IVFFlat 索引优化](#3-ivfflat-索引优化)
    - [3.1 IVFFlat 参数说明](#31-ivfflat-参数说明)
    - [3.2 参数调优策略](#32-参数调优策略)
    - [3.3 IVFFlat 使用建议](#33-ivfflat-使用建议)
  - [4. 查询优化](#4-查询优化)
    - [4.1 相似度阈值过滤](#41-相似度阈值过滤)
    - [4.2 LIMIT 优化](#42-limit-优化)
    - [4.3 条件过滤优化](#43-条件过滤优化)
  - [5. 批量操作优化](#5-批量操作优化)
    - [5.1 批量插入优化](#51-批量插入优化)
    - [5.2 批量更新优化](#52-批量更新优化)
  - [6. 内存优化](#6-内存优化)
    - [6.1 索引内存使用](#61-索引内存使用)
    - [6.2 查询内存优化](#62-查询内存优化)
  - [7. 实际案例](#7-实际案例)
    - [7.1 案例：大规模向量搜索优化](#71-案例大规模向量搜索优化)
    - [7.2 案例：实时向量搜索优化](#72-案例实时向量搜索优化)
  - [📊 总结](#-总结)

---

## 1. 向量搜索优化概述

### 1.1 性能影响因素

向量搜索性能主要受以下因素影响：

- **索引类型**：HNSW vs IVFFlat
- **索引参数**：m, ef_construction, lists 等
- **查询参数**：ef_search, limit 等
- **数据规模**：向量数量和维度
- **硬件配置**：CPU、内存、存储

### 1.2 优化目标

- **查询速度**：毫秒级响应
- **索引构建速度**：快速构建索引
- **内存使用**：合理的内存占用
- **准确度**：高召回率

---

## 2. HNSW 索引优化

### 2.1 HNSW 参数说明

```sql
-- HNSW 索引参数
CREATE INDEX idx_vectors_hnsw
ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 16,              -- 每个节点的最大连接数（默认：16）
    ef_construction = 64  -- 构建时的搜索范围（默认：64）
);
```

### 2.2 参数调优策略

```sql
-- 高精度场景（查询速度优先）
CREATE INDEX idx_vectors_hnsw_high_precision
ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 32,              -- 增加连接数，提高精度
    ef_construction = 200  -- 增加构建范围，提高精度
);

-- 快速构建场景（构建速度优先）
CREATE INDEX idx_vectors_hnsw_fast_build
ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 16,              -- 默认连接数
    ef_construction = 40  -- 减少构建范围，加快构建
);

-- 平衡场景（推荐）
CREATE INDEX idx_vectors_hnsw_balanced
ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 24,              -- 中等连接数
    ef_construction = 100  -- 中等构建范围
);
```

### 2.3 查询时参数调优

```sql
-- 设置查询时的 ef_search 参数
SET hnsw.ef_search = 100;  -- 增加搜索范围，提高精度

-- 高精度查询
SET hnsw.ef_search = 200;
SELECT * FROM vectors
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 快速查询
SET hnsw.ef_search = 40;
SELECT * FROM vectors
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 恢复默认值
RESET hnsw.ef_search;
```

---

## 3. IVFFlat 索引优化

### 3.1 IVFFlat 参数说明

```sql
-- IVFFlat 索引参数
CREATE INDEX idx_vectors_ivfflat
ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (
    lists = 100  -- 聚类中心数量（建议：rows / 1000）
);
```

### 3.2 参数调优策略

```sql
-- 计算合适的 lists 值
-- 建议：lists = rows / 1000，但至少 10，最多 1000

-- 小数据集（< 100万）
CREATE INDEX idx_vectors_ivfflat_small
ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 10);

-- 中等数据集（100万 - 1000万）
CREATE INDEX idx_vectors_ivfflat_medium
ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- 大数据集（> 1000万）
CREATE INDEX idx_vectors_ivfflat_large
ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 1000);
```

### 3.3 IVFFlat 使用建议

```sql
-- IVFFlat 适合场景：
-- 1. 写多读少
-- 2. 数据量大
-- 3. 对查询精度要求不高

-- 创建索引前需要先有数据
-- 建议：至少 1000 行数据后再创建索引
INSERT INTO vectors (embedding) VALUES ...;  -- 先插入数据
CREATE INDEX idx_vectors_ivfflat
ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);
```

---

## 4. 查询优化

### 4.1 相似度阈值过滤

```sql
-- 使用相似度阈值过滤，减少计算量
SELECT * FROM vectors
WHERE embedding <=> $1::vector < 0.3  -- 相似度阈值
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 使用索引友好的查询
-- 好的：使用 <=> 操作符
SELECT * FROM vectors
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 避免：使用函数计算距离
SELECT * FROM vectors
ORDER BY 1 - (embedding <=> $1::vector) DESC  -- 避免
LIMIT 10;
```

### 4.2 LIMIT 优化

```sql
-- 使用 LIMIT 限制结果数量
-- 好的：只返回需要的数量
SELECT * FROM vectors
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 避免：返回所有结果再过滤
SELECT * FROM vectors
ORDER BY embedding <=> $1::vector;  -- 避免
```

### 4.3 条件过滤优化

```sql
-- 在向量搜索前使用条件过滤
-- 好的：先过滤再搜索
SELECT * FROM vectors
WHERE category = 'electronics'  -- 先过滤
  AND embedding <=> $1::vector < 0.3
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 创建复合索引
CREATE INDEX idx_vectors_category_embedding
ON vectors (category, embedding vector_cosine_ops);
```

---

## 5. 批量操作优化

### 5.1 批量插入优化

```sql
-- 方法 1：先插入数据，再创建索引
BEGIN;
-- 批量插入数据
INSERT INTO vectors (embedding) VALUES
    ($1::vector),
    ($2::vector),
    ...;
-- 创建索引
CREATE INDEX idx_vectors_hnsw
ON vectors USING hnsw (embedding vector_cosine_ops);
COMMIT;

-- 方法 2：使用 COPY 批量插入
COPY vectors (embedding) FROM STDIN WITH (FORMAT binary);
-- 二进制数据
\.
```

### 5.2 批量更新优化

```sql
-- 批量更新向量
UPDATE vectors
SET embedding = new_embedding
WHERE id IN (1, 2, 3, ...);

-- 使用临时表批量更新
CREATE TEMP TABLE vector_updates (
    id INTEGER,
    embedding vector(1536)
);

INSERT INTO vector_updates VALUES ...;

UPDATE vectors v
SET embedding = vu.embedding
FROM vector_updates vu
WHERE v.id = vu.id;
```

---

## 6. 内存优化

### 6.1 索引内存使用

```sql
-- HNSW 索引内存估算
-- 内存 ≈ (m * 2 + 1) * 维度 * 4 字节 * 行数

-- 示例：100万行，1536维，m=16
-- 内存 ≈ (16 * 2 + 1) * 1536 * 4 * 1,000,000
--      ≈ 33 * 1536 * 4 * 1,000,000
--      ≈ 202 GB

-- 优化：减小 m 值
CREATE INDEX idx_vectors_hnsw_low_memory
ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (m = 8);  -- 减小 m，降低内存使用
```

### 6.2 查询内存优化

```sql
-- 限制 ef_search 参数，减少内存使用
SET hnsw.ef_search = 40;  -- 较小的值，减少内存

-- 使用 LIMIT 限制结果数量
SELECT * FROM vectors
ORDER BY embedding <=> $1::vector
LIMIT 10;  -- 只返回 10 个结果
```

---

## 7. 实际案例

### 7.1 案例：大规模向量搜索优化

```sql
-- 场景：1000万向量，1536维，需要快速查询
-- 要求：查询时间 < 100ms，准确度 > 95%

-- 步骤 1：创建 HNSW 索引（高精度）
CREATE INDEX idx_vectors_hnsw
ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 32,              -- 高连接数
    ef_construction = 200  -- 高构建精度
);

-- 步骤 2：设置查询参数
SET hnsw.ef_search = 100;  -- 平衡速度和精度

-- 步骤 3：优化查询
SELECT
    id,
    metadata,
    1 - (embedding <=> $1::vector) AS similarity
FROM vectors
WHERE embedding <=> $1::vector < 0.3  -- 相似度阈值
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 性能结果：
-- - 索引构建时间：2 小时
-- - 查询时间：50ms
-- - 准确度：97%
-- - 内存使用：250GB
```

### 7.2 案例：实时向量搜索优化

```sql
-- 场景：实时向量搜索，数据持续更新
-- 要求：快速构建索引，查询时间 < 50ms

-- 步骤 1：创建 IVFFlat 索引（快速构建）
CREATE INDEX idx_vectors_ivfflat
ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 1000);  -- 大数据集

-- 步骤 2：定期重建索引（数据更新后）
-- 删除旧索引
DROP INDEX idx_vectors_ivfflat;

-- 创建新索引
CREATE INDEX idx_vectors_ivfflat
ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 1000);

-- 步骤 3：优化查询
SELECT * FROM vectors
ORDER BY embedding <=> $1::vector
LIMIT 10;

-- 性能结果：
-- - 索引构建时间：10 分钟
-- - 查询时间：30ms
-- - 准确度：90%
-- - 内存使用：50GB
```

---

## 📊 总结

pgvector 向量搜索的性能优化需要根据实际场景选择合适的索引类型和参数。HNSW 适合读多写少、高精度场景，IVFFlat 适合写多读少、快速构建场景。通过合理调优索引参数、优化查询语句、使用批量操作等方法，可以在生产环境中实现高性能的向量搜索。

---

**最后更新**: 2025 年 1 月
**维护者**: PostgreSQL Modern Team
**文档编号**: 03-03-TREND-02
