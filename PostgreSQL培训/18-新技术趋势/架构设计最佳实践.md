# 架构设计最佳实践：PostgreSQL 系统架构设计指南

> **更新时间**: 2025 年 1 月
> **技术版本**: PostgreSQL 17+/18+ 架构设计
> **文档编号**: 03-03-TREND-32

## 📑 概述

本文档介绍 PostgreSQL 系统架构设计的最佳实践，包括高可用架构、读写分离、分库分表、缓存策略、监控体系等架构设计模式和最佳实践。

## 🎯 核心价值

- **高可用架构**：可靠的高可用架构设计
- **性能优化**：性能优化的架构模式
- **可扩展性**：可扩展的架构设计
- **安全性**：安全的架构设计
- **可维护性**：易于维护的架构设计

## 📚 目录

- [架构设计最佳实践：PostgreSQL 系统架构设计指南](#架构设计最佳实践postgresql-系统架构设计指南)
  - [📑 概述](#-概述)
  - [🎯 核心价值](#-核心价值)
  - [📚 目录](#-目录)
  - [1. 架构设计原则](#1-架构设计原则)
    - [1.1 设计原则](#11-设计原则)
    - [1.2 架构层次](#12-架构层次)
  - [2. 高可用架构](#2-高可用架构)
    - [2.1 主从复制架构](#21-主从复制架构)
    - [2.2 Patroni 高可用架构](#22-patroni-高可用架构)
    - [2.3 高可用方案对比](#23-高可用方案对比)
  - [3. 读写分离架构](#3-读写分离架构)
    - [3.1 读写分离架构](#31-读写分离架构)
    - [3.2 PgPool-II 配置](#32-pgpool-ii-配置)
    - [3.3 应用层读写分离](#33-应用层读写分离)
  - [4. 分库分表架构](#4-分库分表架构)
    - [4.1 垂直分库](#41-垂直分库)
    - [4.2 水平分表](#42-水平分表)
    - [4.3 分库分表中间件](#43-分库分表中间件)
  - [5. 缓存架构](#5-缓存架构)
    - [5.1 多级缓存架构](#51-多级缓存架构)
    - [5.2 Redis 缓存策略](#52-redis-缓存策略)
    - [5.3 缓存更新策略](#53-缓存更新策略)
  - [6. 监控架构](#6-监控架构)
    - [6.1 监控体系](#61-监控体系)
    - [6.2 监控指标](#62-监控指标)
    - [6.3 告警规则](#63-告警规则)
  - [7. 实际案例](#7-实际案例)
    - [7.1 案例：电商系统架构](#71-案例电商系统架构)
    - [7.2 案例：IoT 平台架构](#72-案例iot-平台架构)
  - [📊 总结](#-总结)

---

## 1. 架构设计原则

### 1.1 设计原则

- **高可用**：系统可用性 > 99.9%
- **高性能**：满足性能要求
- **可扩展**：支持水平扩展
- **安全性**：数据安全和访问控制
- **可维护**：易于运维和监控

### 1.2 架构层次

```text
应用层
    ↓
接入层（负载均衡）
    ↓
服务层（应用服务）
    ↓
数据层（PostgreSQL）
    ↓
存储层（磁盘/SSD）
```

---

## 2. 高可用架构

### 2.1 主从复制架构

```text
主库 (Primary)
    ↓ (流复制)
从库 (Standby) × N
    ↓
故障转移
    ↓
新主库
```

### 2.2 Patroni 高可用架构

```yaml
# Patroni 配置示例
scope: postgres-cluster
namespace: /db/
name: postgres-node1

restapi:
  listen: 0.0.0.0:8008
  connect_address: 192.168.1.10:8008

etcd3:
  hosts: 192.168.1.20:2379,192.168.1.21:2379,192.168.1.22:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 30
    maximum_lag_on_failover: 1048576
  initdb:
    - encoding: UTF8
    - locale: en_US.UTF-8
  pg_hba:
    - host replication replicator 0.0.0.0/0 md5
    - host all all 0.0.0.0/0 md5
  users:
    admin:
      password: admin
      options:
        - createrole
        - createdb

postgresql:
  listen: 0.0.0.0:5432
  connect_address: 192.168.1.10:5432
  data_dir: /var/lib/postgresql/17/main
  pgpass: /var/lib/postgresql/.pgpass
  authentication:
    replication:
      username: replicator
      password: replicator
    superuser:
      username: postgres
      password: postgres
  parameters:
    max_connections: 200
    shared_buffers: 2GB
    wal_level: replica
    hot_standby: on
```

### 2.3 高可用方案对比

| 方案 | 可用性 | 复杂度 | 成本 | 适用场景 |
|------|--------|--------|------|---------|
| **流复制** | 99.9% | 低 | 低 | 中小规模 |
| **Patroni** | 99.99% | 中 | 中 | 中大规模 |
| **PgPool-II** | 99.9% | 中 | 低 | 读写分离 |
| **云托管** | 99.99% | 低 | 高 | 云环境 |

---

## 3. 读写分离架构

### 3.1 读写分离架构

```text
应用
    ↓
读写分离中间件 (PgPool-II / HAProxy)
    ├── 写请求 → 主库
    └── 读请求 → 从库 × N
```

### 3.2 PgPool-II 配置

```conf
# pgpool.conf
listen_addresses = '*'
port = 9999
socket_dir = '/var/run/postgresql'

# 主从配置
backend_hostname0 = 'primary_host'
backend_port0 = 5432
backend_weight0 = 1
backend_flag0 = 'ALLOW_TO_FAILOVER'

backend_hostname1 = 'standby_host'
backend_port1 = 5432
backend_weight1 = 1
backend_flag1 = 'ALLOW_TO_FAILOVER'

# 负载均衡
load_balance_mode = on
master_slave_mode = on
master_slave_sub_mode = 'stream'
```

### 3.3 应用层读写分离

```python
# Python 应用层读写分离
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# 主库（写）
primary_engine = create_engine(
    'postgresql://user:password@primary_host:5432/dbname'
)

# 从库（读）
replica_engine = create_engine(
    'postgresql://user:password@replica_host:5432/dbname'
)

# 读写分离路由
class ReadWriteRouter:
    def get_engine(self, is_write=False):
        return primary_engine if is_write else replica_engine

# 使用示例
router = ReadWriteRouter()

# 写操作
write_session = sessionmaker(bind=router.get_engine(is_write=True))()

# 读操作
read_session = sessionmaker(bind=router.get_engine(is_write=False))()
```

---

## 4. 分库分表架构

### 4.1 垂直分库

```text
业务数据库
├── 用户库 (user_db)
├── 订单库 (order_db)
└── 商品库 (product_db)
```

### 4.2 水平分表

```sql
-- 按用户 ID 分表
CREATE TABLE orders_0 (LIKE orders INCLUDING ALL);
CREATE TABLE orders_1 (LIKE orders INCLUDING ALL);
-- ... orders_N

-- 分表路由函数
CREATE OR REPLACE FUNCTION get_order_table(user_id INTEGER)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN 'orders_' || (user_id % 10);
END;
$$;
```

### 4.3 分库分表中间件

```yaml
# ShardingSphere 配置示例
dataSources:
  ds0:
    url: jdbc:postgresql://host1:5432/db0
  ds1:
    url: jdbc:postgresql://host2:5432/db1

rules:
  - !SHARDING
    tables:
      orders:
        actualDataNodes: ds$->{0..1}.orders_$->{0..9}
        tableStrategy:
          standard:
            shardingColumn: user_id
            shardingAlgorithmName: mod_10
    shardingAlgorithms:
      mod_10:
        type: MOD
        props:
          sharding-count: 10
```

---

## 5. 缓存架构

### 5.1 多级缓存架构

```text
应用
    ↓
L1 缓存 (本地缓存)
    ↓
L2 缓存 (Redis)
    ↓
数据库 (PostgreSQL)
```

### 5.2 Redis 缓存策略

```python
# Python Redis 缓存示例
import redis
import json
from functools import wraps

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cache_result(expire=3600):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            cache_key = f"{func.__name__}:{args}:{kwargs}"

            # 尝试从缓存获取
            cached = redis_client.get(cache_key)
            if cached:
                return json.loads(cached)

            # 执行函数
            result = func(*args, **kwargs)

            # 写入缓存
            redis_client.setex(
                cache_key,
                expire,
                json.dumps(result)
            )

            return result
        return wrapper
    return decorator

# 使用示例
@cache_result(expire=3600)
def get_user_orders(user_id):
    # 数据库查询
    return db.query("SELECT * FROM orders WHERE user_id = %s", user_id)
```

### 5.3 缓存更新策略

```sql
-- 缓存失效策略
-- 1. 写入时失效
CREATE OR REPLACE FUNCTION invalidate_cache()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    -- 通知应用层失效缓存
    PERFORM pg_notify('cache_invalidate', TG_TABLE_NAME || ':' || NEW.id);
    RETURN NEW;
END;
$$;

-- 2. 定时刷新
SELECT cron.schedule(
    'refresh-cache',
    '0 * * * *',  -- 每小时
    'SELECT refresh_materialized_views();'
);
```

---

## 6. 监控架构

### 6.1 监控体系

```text
PostgreSQL
    ↓
Prometheus (指标收集)
    ↓
Grafana (可视化)
    ↓
Alertmanager (告警)
```

### 6.2 监控指标

```yaml
# Prometheus 配置
scrape_configs:
  - job_name: 'postgres'
    static_configs:
      - targets: ['localhost:9187']
    metrics_path: /metrics
```

### 6.3 告警规则

```yaml
# Alertmanager 规则
groups:
  - name: postgres_alerts
    rules:
      - alert: HighConnections
        expr: pg_stat_database_numbackends > 150
        for: 5m
        annotations:
          summary: "High database connections"

      - alert: SlowQueries
        expr: pg_stat_statements_mean_exec_time > 1000
        for: 5m
        annotations:
          summary: "Slow queries detected"
```

---

## 7. 实际案例

### 7.1 案例：电商系统架构

```text
架构设计：
├── 接入层
│   └── Nginx (负载均衡)
├── 应用层
│   ├── 用户服务
│   ├── 订单服务
│   └── 商品服务
├── 数据层
│   ├── 主库 (写)
│   ├── 从库 × 3 (读)
│   └── Redis (缓存)
└── 监控层
    ├── Prometheus
    └── Grafana
```

### 7.2 案例：IoT 平台架构

```text
架构设计：
├── 数据采集层
│   └── MQTT Broker
├── 数据处理层
│   └── 流处理服务
├── 数据存储层
│   ├── TimescaleDB (时序数据)
│   └── PostgreSQL (元数据)
└── 数据服务层
    └── API 服务
```

---

## 📊 总结

PostgreSQL 系统架构设计需要综合考虑高可用、性能、可扩展性、安全性等多个方面。
通过合理使用高可用架构、读写分离、分库分表、缓存策略等方法，可以在生产环境中构建稳定、高性能、可扩展的系统架构。
建议遵循架构设计原则，根据实际场景选择合适的架构模式，并建立完善的监控和告警体系。

---

**最后更新**: 2025 年 1 月
**维护者**: PostgreSQL Modern Team
**文档编号**: 03-03-TREND-32
