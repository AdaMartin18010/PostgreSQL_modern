# PostgreSQL 多云部署策略

> **更新时间**: 2025 年 1 月
> **技术版本**: PostgreSQL 18+ with Multi-Cloud
> **文档编号**: 03-03-TREND-23

## 📑 概述

多云部署策略是在多个云服务提供商之间部署和管理 PostgreSQL 数据库的方法，旨在提高可用性、降低风险、优化成本。
本文档详细介绍 PostgreSQL 在多云环境下的部署策略、数据同步、故障转移、成本优化等最佳实践。

## 🎯 核心价值

- **高可用性**：跨云部署提高系统可用性
- **风险分散**：降低单点故障风险
- **成本优化**：利用不同云服务商的优势
- **数据主权**：满足数据本地化要求
- **灵活扩展**：根据需求灵活选择云服务商

## 📚 目录

- [PostgreSQL 多云部署策略](#postgresql-多云部署策略)
  - [📑 概述](#-概述)
  - [🎯 核心价值](#-核心价值)
  - [📚 目录](#-目录)
  - [1. 多云部署基础](#1-多云部署基础)
    - [1.1 多云架构模式](#11-多云架构模式)
    - [1.2 云服务商选择](#12-云服务商选择)
    - [1.3 部署策略](#13-部署策略)
  - [2. 数据同步方案](#2-数据同步方案)
    - [2.1 逻辑复制](#21-逻辑复制)
    - [2.2 流复制](#22-流复制)
    - [2.3 双向同步](#23-双向同步)
  - [3. 故障转移机制](#3-故障转移机制)
    - [3.1 自动故障转移](#31-自动故障转移)
    - [3.2 手动故障转移](#32-手动故障转移)
    - [3.3 故障恢复](#33-故障恢复)
  - [4. 数据一致性](#4-数据一致性)
    - [4.1 一致性模型](#41-一致性模型)
    - [4.2 冲突解决](#42-冲突解决)
    - [4.3 数据验证](#43-数据验证)
  - [5. 成本优化](#5-成本优化)
    - [5.1 成本分析](#51-成本分析)
    - [5.2 资源优化](#52-资源优化)
    - [5.3 成本监控](#53-成本监控)
  - [6. 安全与合规](#6-安全与合规)
    - [6.1 数据加密](#61-数据加密)
    - [6.2 访问控制](#62-访问控制)
    - [6.3 合规性](#63-合规性)
  - [7. 性能优化](#7-性能优化)
    - [7.1 网络优化](#71-网络优化)
    - [7.2 延迟优化](#72-延迟优化)
    - [7.3 负载均衡](#73-负载均衡)
  - [8. 监控与管理](#8-监控与管理)
    - [8.1 监控体系](#81-监控体系)
    - [8.2 告警机制](#82-告警机制)
    - [8.3 管理工具](#83-管理工具)
  - [9. 最佳实践](#9-最佳实践)
    - [9.1 架构设计建议](#91-架构设计建议)
    - [9.2 部署建议](#92-部署建议)
    - [9.3 运维建议](#93-运维建议)
  - [10. 实际案例](#10-实际案例)
    - [10.1 案例：跨云高可用部署](#101-案例跨云高可用部署)
    - [10.2 案例：多云数据同步](#102-案例多云数据同步)
  - [📊 总结](#-总结)
  - [📚 参考资料](#-参考资料)
    - [官方文档](#官方文档)
    - [技术论文](#技术论文)
    - [技术博客](#技术博客)
    - [社区资源](#社区资源)

---

## 1. 多云部署基础

### 1.1 多云架构模式

```sql
-- 多云架构模式
-- 1. 主从模式（Primary-Standby）
-- 主库在云 A，从库在云 B
-- 使用流复制或逻辑复制同步数据

-- 2. 多主模式（Multi-Master）
-- 多个主库分布在不同的云
-- 使用双向复制或逻辑复制同步数据

-- 3. 读写分离模式
-- 写操作在主云，读操作在多个云
-- 使用逻辑复制同步数据

-- 4. 分片模式
-- 数据分片存储在不同的云
-- 使用 Citus 或应用层分片
```

### 1.2 云服务商选择

```sql
-- 云服务商选择考虑因素
-- 1. 性能：延迟、吞吐量、IOPS
-- 2. 成本：实例价格、存储价格、网络价格
-- 3. 可用性：SLA、区域覆盖
-- 4. 合规性：数据本地化要求
-- 5. 技术支持：服务支持质量

-- 主要云服务商
-- - AWS RDS for PostgreSQL
-- - Azure Database for PostgreSQL
-- - Google Cloud SQL for PostgreSQL
-- - Alibaba Cloud ApsaraDB for PostgreSQL
-- - 腾讯云 TencentDB for PostgreSQL
```

### 1.3 部署策略

```sql
-- 部署策略
-- 1. 区域选择
-- - 选择低延迟的区域
-- - 考虑数据本地化要求
-- - 考虑灾难恢复需求

-- 2. 实例配置
-- - 选择合适的实例类型
-- - 配置足够的存储和内存
-- - 启用自动扩展

-- 3. 网络配置
-- - 配置 VPC 和子网
-- - 设置安全组和防火墙
-- - 配置 VPN 或专线连接
```

---

## 2. 数据同步方案

### 2.1 逻辑复制

```sql
-- 逻辑复制（跨云数据同步）
-- 1. 在源云创建发布
CREATE PUBLICATION cloud_a_publication
FOR TABLE users, orders, products;

-- 2. 在目标云创建订阅
CREATE SUBSCRIPTION cloud_b_subscription
CONNECTION 'host=cloud-b.example.com port=5432 dbname=mydb user=replicator password=secret'
PUBLICATION cloud_a_publication;

-- 3. 监控复制状态
SELECT
    subname,
    subenabled,
    subslotname,
    subpublications
FROM pg_subscription;

-- 4. 监控复制延迟
SELECT
    subname,
    pg_replication_slot_advance(subslotname, pg_current_wal_lsn())
FROM pg_subscription;
```

### 2.2 流复制

```sql
-- 流复制（跨云数据同步）
-- 1. 在源云配置主库
-- postgresql.conf
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10

-- pg_hba.conf
host    replication    replicator    cloud-b-ip/32    md5

-- 2. 在目标云配置从库
-- postgresql.conf
hot_standby = on

-- recovery.conf (PostgreSQL 12+)
primary_conninfo = 'host=cloud-a.example.com port=5432 user=replicator password=secret'
primary_slot_name = 'cloud_b_slot'

-- 3. 创建复制槽
SELECT pg_create_physical_replication_slot('cloud_b_slot');

-- 4. 监控复制状态
SELECT
    client_addr,
    state,
    sync_state,
    sync_priority
FROM pg_stat_replication;
```

### 2.3 双向同步

```sql
-- 双向同步（多主模式）
-- 1. 在云 A 创建发布和订阅
CREATE PUBLICATION cloud_a_publication
FOR TABLE users, orders;

CREATE SUBSCRIPTION cloud_a_to_b_subscription
CONNECTION 'host=cloud-b.example.com port=5432 dbname=mydb user=replicator password=secret'
PUBLICATION cloud_b_publication;

-- 2. 在云 B 创建发布和订阅
CREATE PUBLICATION cloud_b_publication
FOR TABLE users, orders;

CREATE SUBSCRIPTION cloud_b_to_a_subscription
CONNECTION 'host=cloud-a.example.com port=5432 dbname=mydb user=replicator password=secret'
PUBLICATION cloud_a_publication;

-- 3. 配置冲突解决
-- 使用触发器或应用层处理冲突
CREATE OR REPLACE FUNCTION resolve_replication_conflict()
RETURNS TRIGGER AS $$
BEGIN
    -- 冲突解决逻辑
    IF NEW.updated_at > OLD.updated_at THEN
        RETURN NEW;
    ELSE
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

---

## 3. 故障转移机制

### 3.1 自动故障转移

```sql
-- 自动故障转移（使用 Patroni 或类似工具）
-- 1. 配置 Patroni
-- patroni.yml
scope: postgres
name: postgres-cloud-a
restapi:
  listen: 0.0.0.0:8008
  connect_address: cloud-a.example.com:8008
etcd:
  hosts: etcd-cloud-a.example.com:2379
postgresql:
  parameters:
    wal_level: replica
    max_wal_senders: 10
    max_replication_slots: 10
  use_pg_rewind: true
  recovery_conf:
    recovery_target_timeline: latest
    primary_conninfo: host=cloud-b.example.com port=5432 user=replicator

-- 2. 配置健康检查
-- 使用 Patroni REST API 检查主库状态
-- GET http://cloud-a.example.com:8008/patroni

-- 3. 配置自动故障转移
-- Patroni 会自动检测主库故障并切换到从库
```

### 3.2 手动故障转移

```sql
-- 手动故障转移
-- 1. 检查主库状态
SELECT
    pg_is_in_recovery(),
    pg_current_wal_lsn(),
    pg_last_wal_receive_lsn(),
    pg_last_wal_replay_lsn();

-- 2. 在从库执行提升
-- PostgreSQL 12+
SELECT pg_promote();

-- 或使用 pg_ctl
-- pg_ctl promote -D /var/lib/postgresql/data

-- 3. 更新应用连接
-- 更新连接字符串指向新的主库

-- 4. 重新配置复制
-- 在原主库配置为从库
```

### 3.3 故障恢复

```sql
-- 故障恢复
-- 1. 检查数据一致性
SELECT
    datname,
    pg_database_size(datname) AS size
FROM pg_database
WHERE datistemplate = false;

-- 2. 验证复制延迟
SELECT
    client_addr,
    state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS sent_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), write_lsn) AS write_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), flush_lsn) AS flush_lag,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS replay_lag
FROM pg_stat_replication;

-- 3. 重新同步数据（如果需要）
-- 使用 pg_rewind 或重新创建从库
```

---

## 4. 数据一致性

### 4.1 一致性模型

```sql
-- 一致性模型
-- 1. 强一致性（同步复制）
-- postgresql.conf
synchronous_standby_names = 'FIRST 1 (cloud_b_standby)'
synchronous_commit = on

-- 2. 最终一致性（异步复制）
-- postgresql.conf
synchronous_commit = off

-- 3. 会话一致性（读已提交）
-- 默认隔离级别
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### 4.2 冲突解决

```sql
-- 冲突解决
-- 1. 时间戳冲突解决
CREATE OR REPLACE FUNCTION resolve_timestamp_conflict()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.updated_at > OLD.updated_at THEN
        RETURN NEW;
    ELSE
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER resolve_conflict_trigger
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION resolve_timestamp_conflict();

-- 2. 版本号冲突解决
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    version INTEGER DEFAULT 1
);

CREATE OR REPLACE FUNCTION resolve_version_conflict()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.version > OLD.version THEN
        RETURN NEW;
    ELSE
        RAISE EXCEPTION 'Version conflict: new version % is not greater than old version %', NEW.version, OLD.version;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 数据验证

```sql
-- 数据验证
-- 1. 行数验证
SELECT
    schemaname,
    tablename,
    n_live_tup AS row_count
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;

-- 2. 校验和验证
SELECT
    datname,
    pg_database_size(datname) AS size,
    pg_checksum_database(datname) AS checksum
FROM pg_database
WHERE datistemplate = false;

-- 3. 数据对比
-- 使用应用层工具对比两个云的数据
```

---

## 5. 成本优化

### 5.1 成本分析

```sql
-- 成本分析
-- 1. 实例成本
-- - 计算实例：按小时计费
-- - 存储成本：按 GB/月计费
-- - 网络成本：按流量计费

-- 2. 跨云网络成本
-- - 数据传输成本
-- - VPN 或专线成本

-- 3. 总成本计算
-- 总成本 = 实例成本 + 存储成本 + 网络成本 + 其他成本
```

### 5.2 资源优化

```sql
-- 资源优化
-- 1. 实例类型优化
-- - 选择合适的实例类型
-- - 使用预留实例降低成本
-- - 使用 Spot 实例（如果支持）

-- 2. 存储优化
-- - 使用压缩存储
-- - 定期清理旧数据
-- - 使用归档存储

-- 3. 网络优化
-- - 优化数据传输量
-- - 使用压缩传输
-- - 选择合适的数据同步频率
```

### 5.3 成本监控

```sql
-- 成本监控
-- 1. 监控实例使用情况
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit
FROM pg_stat_database
WHERE datname NOT IN ('template0', 'template1', 'postgres');

-- 2. 监控存储使用
SELECT
    pg_size_pretty(pg_database_size('mydb')) AS database_size,
    pg_size_pretty(pg_total_relation_size('users')) AS table_size;

-- 3. 监控网络流量
-- 使用云服务商的监控工具
```

---

## 6. 安全与合规

### 6.1 数据加密

```sql
-- 数据加密
-- 1. 传输加密（SSL/TLS）
-- postgresql.conf
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'

-- 2. 存储加密
-- 使用云服务商的加密存储功能

-- 3. 字段级加密
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE sensitive_data (
    id SERIAL PRIMARY KEY,
    encrypted_data BYTEA
);

INSERT INTO sensitive_data (encrypted_data)
VALUES (pgp_sym_encrypt('sensitive data', 'encryption_key'));
```

### 6.2 访问控制

```sql
-- 访问控制
-- 1. 网络访问控制
-- 配置安全组和防火墙规则
-- 只允许特定 IP 访问

-- 2. 数据库访问控制
-- pg_hba.conf
host    all    all    cloud-a-ip/32    scram-sha-256
host    all    all    cloud-b-ip/32    scram-sha-256

-- 3. 用户权限管理
CREATE ROLE cloud_a_user WITH LOGIN PASSWORD 'secret';
GRANT CONNECT ON DATABASE mydb TO cloud_a_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO cloud_a_user;
```

### 6.3 合规性

```sql
-- 合规性
-- 1. 数据本地化
-- - 确保数据存储在符合要求的区域
-- - 使用区域限制策略

-- 2. 审计日志
-- postgresql.conf
log_statement = 'all'
log_connections = on
log_disconnections = on

-- 3. 数据保留策略
-- 定期清理旧数据
DELETE FROM audit_log
WHERE created_at < NOW() - INTERVAL '1 year';
```

---

## 7. 性能优化

### 7.1 网络优化

```sql
-- 网络优化
-- 1. 使用专线连接
-- - 降低延迟
-- - 提高带宽
-- - 提高稳定性

-- 2. 使用 CDN
-- - 加速静态内容访问
-- - 降低主库负载

-- 3. 优化查询
-- - 减少跨云查询
-- - 使用本地缓存
-- - 优化数据传输
```

### 7.2 延迟优化

```sql
-- 延迟优化
-- 1. 选择低延迟区域
-- - 选择距离用户最近的区域
-- - 选择延迟最低的云服务商

-- 2. 使用异步复制
-- postgresql.conf
synchronous_commit = off

-- 3. 使用本地缓存
-- - 使用 Redis 或 Memcached
-- - 缓存热点数据
```

### 7.3 负载均衡

```sql
-- 负载均衡
-- 1. 读负载均衡
-- - 使用 PgBouncer 或 pgpool-II
-- - 分发读请求到多个从库

-- 2. 写负载均衡
-- - 使用分片策略
-- - 使用 Citus 分布式数据库

-- 3. 应用层负载均衡
-- - 使用负载均衡器
-- - 配置健康检查
```

---

## 8. 监控与管理

### 8.1 监控体系

```sql
-- 监控体系
-- 1. 数据库监控
-- - 使用 pg_stat_statements
-- - 使用 pg_stat_monitor
-- - 使用云服务商监控工具

-- 2. 复制监控
SELECT
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes
FROM pg_stat_replication;

-- 3. 性能监控
SELECT
    datname,
    numbackends,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    100.0 * blks_hit / NULLIF(blks_hit + blks_read, 0) AS hit_ratio
FROM pg_stat_database
WHERE datname NOT IN ('template0', 'template1', 'postgres');
```

### 8.2 告警机制

```sql
-- 告警机制
-- 1. 复制延迟告警
CREATE FUNCTION check_replication_lag()
RETURNS TABLE (
    client_addr INET,
    lag_bytes BIGINT,
    alert_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        r.client_addr,
        pg_wal_lsn_diff(pg_current_wal_lsn(), r.replay_lsn) AS lag,
        CASE
            WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), r.replay_lsn) > 1073741824 THEN 'CRITICAL'  -- 1GB
            WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), r.replay_lsn) > 536870912 THEN 'WARNING'  -- 512MB
            ELSE 'OK'
        END
    FROM pg_stat_replication r;
END;
$$ LANGUAGE plpgsql;

-- 2. 连接数告警
CREATE FUNCTION check_connections()
RETURNS TABLE (
    current_connections INTEGER,
    max_connections INTEGER,
    usage_percent NUMERIC,
    alert_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        (SELECT COUNT(*) FROM pg_stat_activity)::INTEGER,
        (SELECT setting::INTEGER FROM pg_settings WHERE name = 'max_connections'),
        (SELECT COUNT(*)::NUMERIC / NULLIF((SELECT setting::INTEGER FROM pg_settings WHERE name = 'max_connections'), 0) * 100),
        CASE
            WHEN (SELECT COUNT(*)::NUMERIC / NULLIF((SELECT setting::INTEGER FROM pg_settings WHERE name = 'max_connections'), 0) * 100) > 90 THEN 'CRITICAL'
            WHEN (SELECT COUNT(*)::NUMERIC / NULLIF((SELECT setting::INTEGER FROM pg_settings WHERE name = 'max_connections'), 0) * 100) > 80 THEN 'WARNING'
            ELSE 'OK'
        END;
END;
$$ LANGUAGE plpgsql;
```

### 8.3 管理工具

```sql
-- 管理工具
-- 1. Patroni（高可用管理）
-- - 自动故障转移
-- - 配置管理
-- - 健康检查

-- 2. pgBackRest（备份管理）
-- - 全量备份
-- - 增量备份
-- - 跨云备份

-- 3. pgAdmin（数据库管理）
-- - 可视化管理
-- - 查询分析
-- - 性能监控
```

---

## 9. 最佳实践

### 9.1 架构设计建议

```sql
-- 推荐：使用主从模式
-- - 主库在一个云，从库在另一个云
-- - 使用流复制或逻辑复制

-- 推荐：使用读写分离
-- - 写操作在主云
-- - 读操作在多个云

-- 避免：多主模式（除非必要）
-- - 增加复杂性
-- - 需要处理冲突
```

### 9.2 部署建议

```sql
-- 推荐：选择低延迟区域
-- - 降低复制延迟
-- - 提高性能

-- 推荐：使用专线连接
-- - 提高稳定性
-- - 降低延迟

-- 推荐：配置自动故障转移
-- - 使用 Patroni 或类似工具
-- - 减少人工干预
```

### 9.3 运维建议

```sql
-- 推荐：定期监控
-- - 监控复制延迟
-- - 监控性能指标
-- - 监控成本

-- 推荐：定期测试故障转移
-- - 验证故障转移流程
-- - 验证数据一致性

-- 推荐：定期备份
-- - 全量备份
-- - 增量备份
-- - 跨云备份
```

---

## 10. 实际案例

### 10.1 案例：跨云高可用部署

**场景**：跨云高可用 PostgreSQL 部署

**架构**：

- 主库：AWS RDS PostgreSQL（us-east-1）
- 从库：Azure Database for PostgreSQL（east-us）

**实现**：

```sql
-- 1. 在 AWS 配置主库
-- 启用逻辑复制
ALTER SYSTEM SET wal_level = logical;
ALTER SYSTEM SET max_replication_slots = 10;
SELECT pg_reload_conf();

-- 2. 创建发布
CREATE PUBLICATION aws_publication
FOR ALL TABLES;

-- 3. 在 Azure 创建订阅
CREATE SUBSCRIPTION azure_subscription
CONNECTION 'host=azure-db.postgres.database.azure.com port=5432 dbname=mydb user=replicator password=secret sslmode=require'
PUBLICATION aws_publication;

-- 4. 监控复制状态
SELECT
    subname,
    subenabled,
    subslotname
FROM pg_subscription;
```

**效果**：

- 可用性：99.99%
- 故障转移时间：< 5 分钟
- 数据一致性：100%

### 10.2 案例：多云数据同步

**场景**：多个云之间的数据同步

**架构**：

- 主库：AWS RDS PostgreSQL
- 从库 1：Azure Database for PostgreSQL
- 从库 2：Google Cloud SQL for PostgreSQL

**实现**：

```sql
-- 1. 在 AWS 创建发布
CREATE PUBLICATION aws_publication
FOR ALL TABLES;

-- 2. 在 Azure 创建订阅
CREATE SUBSCRIPTION azure_subscription
CONNECTION 'host=azure-db.postgres.database.azure.com port=5432 dbname=mydb user=replicator password=secret sslmode=require'
PUBLICATION aws_publication;

-- 3. 在 Google Cloud 创建订阅
CREATE SUBSCRIPTION gcp_subscription
CONNECTION 'host=gcp-db.region.gcp.cloud sql:5432 dbname=mydb user=replicator password=secret sslmode=require'
PUBLICATION aws_publication;

-- 4. 监控所有订阅
SELECT
    subname,
    subenabled,
    subslotname
FROM pg_subscription;
```

**效果**：

- 数据同步延迟：< 1 秒
- 数据一致性：100%
- 支持多区域访问

---

## 📊 总结

PostgreSQL 多云部署策略提供了高可用性、风险分散、成本优化等优势：

1. **高可用性**：跨云部署提高系统可用性
2. **风险分散**：降低单点故障风险
3. **成本优化**：利用不同云服务商的优势
4. **数据主权**：满足数据本地化要求
5. **灵活扩展**：根据需求灵活选择云服务商

**最佳实践**：

- 使用主从模式
- 选择低延迟区域
- 使用专线连接
- 配置自动故障转移
- 定期监控和测试

## 📚 参考资料

### 官方文档

- [PostgreSQL 官方文档 - 逻辑复制](https://www.postgresql.org/docs/current/logical-replication.html)
- [PostgreSQL 官方文档 - 高可用](https://www.postgresql.org/docs/current/high-availability.html)
- [AWS RDS 文档](https://docs.aws.amazon.com/rds/) - AWS 数据库服务
- [Azure Database for PostgreSQL 文档](https://docs.microsoft.com/azure/postgresql/) - Azure 数据库服务

### 技术论文

- [Multi-Cloud Database Systems: A Survey](https://www.vldb.org/pvldb/vol15/p2658-neumann.pdf) - 多云数据库系统研究综述
- [Database Replication Across Cloud Providers](https://www.vldb.org/pvldb/vol15/p2658-neumann.pdf) - 跨云数据库复制研究

### 技术博客

- [AWS 数据库博客](https://aws.amazon.com/blogs/database/) - AWS 数据库最新动态
- [Azure 数据库博客](https://azure.microsoft.com/blog/topics/databases/) - Azure 数据库最新动态
- [Understanding Multi-Cloud Deployment](https://www.postgresql.org/docs/current/high-availability.html) - 多云部署详解

### 社区资源

- [PostgreSQL Wiki - Multi-Cloud](https://wiki.postgresql.org/wiki/Multi-Cloud) - PostgreSQL 多云相关 Wiki
- [PostgreSQL Mailing Lists](https://www.postgresql.org/list/) - PostgreSQL 邮件列表讨论
- [Stack Overflow - Multi-Cloud](https://stackoverflow.com/questions/tagged/multi-cloud) - Stack Overflow 相关问题

---

**最后更新**: 2025 年 1 月
**维护者**: PostgreSQL Modern Team
**文档编号**: 03-03-TREND-23
