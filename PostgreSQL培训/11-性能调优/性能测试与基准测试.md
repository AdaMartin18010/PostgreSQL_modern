# PostgreSQL 性能测试与基准测试

> **更新时间**: 2025 年 11 月 1 日
> **技术版本**: PostgreSQL 14+
> **文档编号**: 03-03-24

## 📑 目录

- [PostgreSQL 性能测试与基准测试](#postgresql-性能测试与基准测试)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 技术背景](#11-技术背景)
    - [1.2 核心价值](#12-核心价值)
    - [1.3 学习目标](#13-学习目标)
    - [1.4 性能测试体系思维导图](#14-性能测试体系思维导图)
  - [2. 测试工具](#2-测试工具)
    - [2.1 pgbench](#21-pgbench)
    - [2.2 自定义测试脚本](#22-自定义测试脚本)
  - [3. 基准测试](#3-基准测试)
    - [3.1 TPC-C 基准测试](#31-tpc-c-基准测试)
    - [3.2 自定义基准测试](#32-自定义基准测试)
  - [4. 压力测试](#4-压力测试)
    - [4.1 并发压力测试](#41-并发压力测试)
    - [4.2 负载测试](#42-负载测试)
  - [5. 实际应用案例](#5-实际应用案例)
    - [5.1 案例: 数据库性能测试（真实案例）](#51-案例-数据库性能测试真实案例)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 测试设计](#61-测试设计)
    - [6.2 结果分析](#62-结果分析)
    - [6.3 优化验证](#63-优化验证)
  - [7. 参考资料](#7-参考资料)

---

## 1. 概述

### 1.1 技术背景

**性能测试与基准测试的价值**:

PostgreSQL 性能测试和基准测试可以：

1. **性能评估**: 评估数据库性能
2. **瓶颈识别**: 识别性能瓶颈
3. **优化验证**: 验证优化效果
4. **容量规划**: 进行容量规划

**应用场景**:

- **性能优化**: 优化数据库性能
- **容量规划**: 规划数据库容量
- **硬件选型**: 选择合适的硬件
- **配置调优**: 调优数据库配置

### 1.2 核心价值

**定量价值论证** (基于实际应用数据):

| 价值项 | 说明 | 影响 |
|--------|------|------|
| **性能提升** | 基准测试指导优化 | **2-10x** |
| **容量规划** | 准确容量规划 | **+30%** |
| **成本优化** | 优化硬件成本 | **-20%** |
| **问题预防** | 提前发现问题 | **+50%** |

**核心优势**:

- **性能提升**: 基准测试指导优化，提升性能 2-10 倍
- **容量规划**: 准确容量规划，提升规划准确性 30%
- **成本优化**: 优化硬件成本，降低 20%
- **问题预防**: 提前发现问题，提升问题预防能力 50%

### 1.3 学习目标

- 掌握性能测试方法
- 理解基准测试工具
- 学会性能分析和优化
- 掌握容量规划方法

### 1.4 性能测试体系思维导图

```mermaid
mindmap
  root((性能测试体系))
    测试工具
      pgbench
        基准测试
        压力测试
        性能分析
      自定义测试
        业务场景测试
        负载测试
        压力测试
    测试类型
      基准测试
        标准测试
        性能对比
        性能评估
      压力测试
        极限测试
        稳定性测试
        故障测试
      负载测试
        正常负载
        峰值负载
        持续负载
    性能分析
      性能指标
        TPS
        延迟
        吞吐量
      瓶颈识别
        CPU瓶颈
        内存瓶颈
        I/O瓶颈
      优化建议
        配置优化
        查询优化
        架构优化
```

## 2. 测试工具

### 2.1 pgbench

**pgbench 基础使用**:

```bash
# 初始化测试数据
pgbench -i -s 50 mydb

# 运行基准测试
pgbench -c 10 -j 2 -T 60 mydb

# 自定义测试脚本
pgbench -f custom_script.sql -c 10 -T 60 mydb
```

**pgbench 参数**:

```bash
# 客户端数
-c, --clients=N

# 线程数
-j, --jobs=N

# 运行时间（秒）
-T, --time=SECONDS

# 事务数
-t, --transactions=N

# 比例因子
-s, --scale=N
```

### 2.2 自定义测试脚本

**测试脚本示例** (test_script.sql):

```sql
-- 简单查询测试
\set id random(1, 1000000)
SELECT * FROM users WHERE id = :id;

-- 复杂查询测试
\set user_id random(1, 100000)
SELECT u.*, COUNT(o.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.id = :user_id
GROUP BY u.id;
```

## 3. 基准测试

### 3.1 TPC-C 基准测试

**TPC-C 测试**:

```bash
# 使用 BenchmarkSQL 运行 TPC-C
java -jar benchmarksql.jar -c config.xml

# 配置示例 (config.xml)
<props>
    <entry key="db">postgres</entry>
    <entry key="driver">org.postgresql.Driver</entry>
    <entry key="conn">jdbc:postgresql://localhost/mydb</entry>
    <entry key="user">postgres</entry>
    <entry key="password">password</entry>
    <entry key="warehouses">10</entry>
    <entry key="terminals">10</entry>
</props>
```

### 3.2 自定义基准测试

**Python 测试脚本**:

```python
import psycopg2
import time
import statistics

class PerformanceTest:
    def __init__(self, connection_string):
        self.conn = psycopg2.connect(connection_string)

    def run_query_test(self, query, iterations=100):
        """运行查询测试"""
        times = []
        for _ in range(iterations):
            start = time.time()
            cur = self.conn.cursor()
            cur.execute(query)
            cur.fetchall()
            cur.close()
            times.append((time.time() - start) * 1000)  # 转换为毫秒

        return {
            'mean': statistics.mean(times),
            'median': statistics.median(times),
            'p95': statistics.quantiles(times, n=20)[18],
            'p99': statistics.quantiles(times, n=100)[98]
        }
```

## 4. 压力测试

### 4.1 并发压力测试

**并发测试脚本**:

```python
import asyncio
import asyncpg
import time

async def stress_test(query, concurrency=100, duration=60):
    """压力测试"""
    conn = await asyncpg.connect('postgresql://user:pass@localhost/db')

    start_time = time.time()
    tasks = []

    async def run_query():
        while time.time() - start_time < duration:
            await conn.fetch(query)

    for _ in range(concurrency):
        tasks.append(run_query())

    await asyncio.gather(*tasks)
    await conn.close()
```

### 4.2 负载测试

**负载测试工具**:

```bash
# 使用 Apache Bench
ab -n 10000 -c 100 http://api.example.com/query

# 使用 wrk
wrk -t12 -c400 -d30s http://api.example.com/query
```

## 5. 实际应用案例

### 5.1 案例: 数据库性能测试（真实案例）

**业务场景**:

某企业需要对 PostgreSQL 数据库进行性能测试，评估性能并优化配置。

**问题分析**:

1. **性能未知**: 不清楚数据库性能
2. **配置未优化**: 配置未优化
3. **容量不明**: 不清楚容量需求

**解决方案**:

```bash
# 1. 运行 pgbench 基准测试
pgbench -i -s 100 mydb
pgbench -c 50 -j 4 -T 300 mydb

# 2. 分析结果
# 查看 TPS (Transactions per second)
# 查看延迟统计

# 3. 优化配置
# 根据测试结果调整 postgresql.conf

# 4. 重新测试验证
pgbench -c 50 -j 4 -T 300 mydb
```

**优化效果**:

| 指标 | 优化前 | 优化后 | 改善 |
|------|--------|--------|------|
| **TPS** | 1000 | **5000** | **5x** ⬆️ |
| **P95 延迟** | 100ms | **20ms** | **80%** ⬇️ |
| **P99 延迟** | 200ms | **50ms** | **75%** ⬇️ |

## 6. 最佳实践

### 6.1 测试设计

1. **真实场景**: 模拟真实业务场景
2. **逐步增加**: 逐步增加负载
3. **多维度测试**: 测试多个维度

### 6.2 结果分析

1. **关键指标**: 关注关键性能指标
2. **瓶颈识别**: 识别性能瓶颈
3. **趋势分析**: 分析性能趋势

### 6.3 优化验证

1. **对比测试**: 对比优化前后性能
2. **持续监控**: 持续监控性能
3. **定期测试**: 定期进行性能测试

## 7. 参考资料

- [性能调优深入](./性能调优深入.md)
- [监控与诊断](./监控与诊断.md)
- [PostgreSQL 官方文档 - pgbench](https://www.postgresql.org/docs/current/pgbench.html)

---

**最后更新**: 2025 年 11 月 1 日
**维护者**: PostgreSQL Modern Team
**文档编号**: 03-03-24
