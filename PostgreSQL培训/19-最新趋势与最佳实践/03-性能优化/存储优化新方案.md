# PostgreSQL存储优化新方案

> **更新时间**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **文档编号**: 19-03-03

---

## 📑 目录

- [PostgreSQL存储优化新方案](#postgresql存储优化新方案)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 2024存储优化趋势](#11-2024存储优化趋势)
  - [2. 存储优化策略矩阵](#2-存储优化策略矩阵)
  - [3. TOAST机制优化](#3-toast机制优化)
    - [3.1 TOAST优化决策树](#31-toast优化决策树)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 案例：内容管理系统存储优化](#41-案例内容管理系统存储优化)
  - [5. TOAST机制深度解析](#5-toast机制深度解析)
    - [5.1 TOAST存储策略](#51-toast存储策略)
    - [5.2 TOAST压缩算法](#52-toast压缩算法)
    - [5.3 TOAST表管理](#53-toast表管理)
  - [6. 表压缩技术](#6-表压缩技术)
    - [6.1 表压缩配置](#61-表压缩配置)
    - [6.2 压缩效果分析](#62-压缩效果分析)
  - [7. 分区表存储优化](#7-分区表存储优化)
    - [7.1 分区表存储策略](#71-分区表存储策略)
    - [7.2 分区表维护](#72-分区表维护)
  - [8. 常见问题（FAQ）](#8-常见问题faq)
    - [8.1 存储优化基础常见问题](#81-存储优化基础常见问题)
      - [Q1: 如何选择TOAST存储策略？](#q1-如何选择toast存储策略)
      - [Q2: 如何优化TOAST表性能？](#q2-如何优化toast表性能)
    - [8.2 存储空间优化常见问题](#82-存储空间优化常见问题)
      - [Q3: 如何减少存储空间占用？](#q3-如何减少存储空间占用)

---

## 1. 概述

### 1.1 2024存储优化趋势

**PostgreSQL 18存储优化改进**：

| 优化项 | PostgreSQL 17 | PostgreSQL 18 | 提升 |
|--------|--------------|---------------|------|
| **TOAST压缩** | 基础 | 增强 | **+30%** |
| **存储格式** | 标准 | 优化 | **+20%** |
| **I/O性能** | 标准 | 异步I/O | **+100%** |

---

## 2. 存储优化策略矩阵

| 优化策略 | 性能提升 | 存储节省 | 实施难度 | 优先级 |
|---------|---------|---------|---------|--------|
| **TOAST优化** | 20-30% | 30-50% | ⭐⭐ | P0 |
| **表压缩** | 10-20% | 50-70% | ⭐⭐⭐ | P1 |
| **分区表** | 10-100x | 无 | ⭐⭐⭐ | P0 |
| **索引优化** | 10-100x | -20% | ⭐⭐ | P0 |

---

## 3. TOAST机制优化

### 3.1 TOAST优化决策树

```text
大字段存储？
├─ 是
│  ├─ 字段大小？
│  │  ├─ < 2KB → 行内存储
│  │  ├─ 2KB-8KB → TOAST压缩
│  │  └─ > 8KB → TOAST外部存储
│  └─ 访问频率？
│     ├─ 高频 → 行内存储
│     └─ 低频 → TOAST存储
└─ 否 → 正常存储
```

---

## 4. 实际应用案例

### 4.1 案例：内容管理系统存储优化

**业务场景**：

- 内容管理系统
- 1000万+文章
- 文章内容平均50KB

**实施方案**：

```sql
-- 1. 创建表（使用TOAST）
CREATE TABLE articles (
    id BIGSERIAL PRIMARY KEY,
    title TEXT,
    content TEXT,  -- 大字段，自动使用TOAST
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. 检查TOAST使用情况
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS toast_size
FROM pg_tables
WHERE tablename = 'articles';

-- 3. 优化TOAST压缩
ALTER TABLE articles
ALTER COLUMN content SET STORAGE EXTENDED;  -- 使用TOAST压缩

-- 4. 创建部分索引（只索引常用字段）
CREATE INDEX idx_articles_title ON articles (title);
CREATE INDEX idx_articles_created ON articles (created_at);
```

**实施效果**：

| 指标 | 实施前 | 实施后 | 提升 |
|------|--------|--------|------|
| **存储空间** | 500GB | 200GB | **-60%** |
| **查询性能** | 500ms | 150ms | **3.3x** |
| **I/O性能** | 1000 IOPS | 300 IOPS | **-70%** |

---

## 5. TOAST机制深度解析

### 5.1 TOAST存储策略

**TOAST（The Oversized-Attribute Storage Technique）**是PostgreSQL处理大字段的机制。

**存储策略**：

| 策略 | 说明 | 适用场景 |
|------|------|---------|
| **PLAIN** | 行内存储，不压缩 | 小字段（< 2KB） |
| **EXTENDED** | TOAST存储，压缩 | 大字段（> 2KB），默认 |
| **EXTERNAL** | TOAST存储，不压缩 | 需要快速访问的大字段 |
| **MAIN** | 行内存储，压缩 | 中等字段（2-8KB） |

**配置示例**：

```sql
-- 1. 查看当前存储策略
SELECT
    attname,
    attstorage,
    CASE attstorage
        WHEN 'p' THEN 'PLAIN'
        WHEN 'e' THEN 'EXTENDED'
        WHEN 'x' THEN 'EXTERNAL'
        WHEN 'm' THEN 'MAIN'
    END AS storage_strategy
FROM pg_attribute
WHERE attrelid = 'articles'::regclass
  AND attnum > 0;

-- 2. 修改存储策略
ALTER TABLE articles
ALTER COLUMN content SET STORAGE EXTENDED;  -- 使用TOAST压缩

-- 3. 优化大字段存储
ALTER TABLE articles
ALTER COLUMN content SET STORAGE EXTERNAL;  -- 不压缩，快速访问
```

### 5.2 TOAST压缩算法

**PostgreSQL 18压缩改进**：

1. **LZ4压缩**（默认）：
   - 压缩速度快
   - 压缩率中等
   - CPU占用低

2. **PGLZ压缩**（传统）：
   - 压缩率高
   - 压缩速度慢
   - CPU占用高

**性能对比**：

| 压缩算法 | 压缩速度 | 压缩率 | CPU占用 | 推荐场景 |
|---------|---------|--------|---------|---------|
| **LZ4** | 快 | 中 | 低 | 实时写入 |
| **PGLZ** | 慢 | 高 | 高 | 批量导入 |

### 5.3 TOAST表管理

**TOAST表操作**：

```sql
-- 1. 查看TOAST表
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS toast_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename||'_toast')) AS toast_table_size
FROM pg_tables
WHERE schemaname = 'public'
  AND tablename = 'articles';

-- 2. 清理TOAST表
VACUUM FULL articles;

-- 3. 重建TOAST表
ALTER TABLE articles SET (toast_tuple_target = 128);
```

---

## 6. 表压缩技术

### 6.1 表压缩配置

**PostgreSQL 18表压缩**：

```sql
-- 1. 创建压缩表
CREATE TABLE articles_compressed (
    id BIGSERIAL PRIMARY KEY,
    title TEXT,
    content TEXT COMPRESSION lz4,  -- 使用LZ4压缩
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. 修改现有表启用压缩
ALTER TABLE articles
ALTER COLUMN content SET COMPRESSION lz4;

-- 3. 重新压缩数据
VACUUM FULL articles;
```

### 6.2 压缩效果分析

**压缩性能数据**：

| 数据类型 | 原始大小 | LZ4压缩后 | PGLZ压缩后 | 压缩率 |
|---------|---------|----------|-----------|--------|
| **文本内容** | 100MB | 35MB | 25MB | 65-75% |
| **JSON数据** | 100MB | 40MB | 30MB | 60-70% |
| **二进制数据** | 100MB | 95MB | 90MB | 5-10% |

---

## 7. 分区表存储优化

### 7.1 分区表存储策略

**分区表存储优化**：

```sql
-- 1. 创建分区表
CREATE TABLE orders (
    id BIGSERIAL,
    user_id BIGINT,
    amount DECIMAL(10, 2),
    created_at TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- 2. 创建分区（使用不同存储策略）
CREATE TABLE orders_2024_01 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01')
    WITH (fillfactor = 90);  -- 减少填充因子，预留更新空间

CREATE TABLE orders_2024_02 PARTITION OF orders
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01')
    WITH (fillfactor = 90);

-- 3. 为旧分区启用压缩
ALTER TABLE orders_2024_01
ALTER COLUMN metadata SET COMPRESSION lz4;
```

### 7.2 分区表维护

**自动分区管理**：

```sql
-- 1. 创建自动分区函数
CREATE OR REPLACE FUNCTION create_monthly_partition(
    table_name TEXT,
    start_date DATE
)
RETURNS void AS $$
DECLARE
    partition_name TEXT;
    end_date DATE;
BEGIN
    partition_name := table_name || '_' || to_char(start_date, 'YYYY_MM');
    end_date := start_date + INTERVAL '1 month';

    EXECUTE format('CREATE TABLE IF NOT EXISTS %I PARTITION OF %I
        FOR VALUES FROM (%L) TO (%L)
        WITH (fillfactor = 90)',
        partition_name, table_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;

-- 2. 使用pg_cron自动创建分区
SELECT cron.schedule(
    'create-monthly-partition',
    '0 0 1 * *',
    $$SELECT create_monthly_partition('orders', date_trunc('month', CURRENT_DATE + INTERVAL '1 month'))$$
);
```

---

## 8. 常见问题（FAQ）

### 8.1 存储优化基础常见问题

#### Q1: 如何选择TOAST存储策略？

**选择决策树**：

```text
字段大小？
├─ < 2KB → PLAIN（行内存储）
├─ 2KB-8KB → MAIN（行内压缩）
├─ > 8KB
│  ├─ 访问频率？
│  │  ├─ 高频 → EXTERNAL（不压缩）
│  │  └─ 低频 → EXTENDED（压缩）
│  └─ 压缩效果？
│     ├─ 好 → EXTENDED
│     └─ 差 → EXTERNAL
```

#### Q2: 如何优化TOAST表性能？

**优化方案**：

1. **调整TOAST阈值**：

    ```sql
    ALTER TABLE articles SET (toast_tuple_target = 128);
    ```

2. **使用合适的压缩算法**：

    ```sql
    ALTER TABLE articles
    ALTER COLUMN content SET COMPRESSION lz4;  -- 快速压缩
    ```

3. **定期清理TOAST表**：

    ```sql
    VACUUM FULL articles;
    ```

### 8.2 存储空间优化常见问题

#### Q3: 如何减少存储空间占用？

**优化方案**：

1. **启用表压缩**：

    ```sql
    ALTER TABLE articles
    ALTER COLUMN content SET COMPRESSION lz4;
    VACUUM FULL articles;
    ```

2. **使用分区表**：

    ```sql
    -- 将旧数据移到压缩分区
    CREATE TABLE orders_archive PARTITION OF orders
        FOR VALUES FROM ('2020-01-01') TO ('2024-01-01')
        WITH (fillfactor = 100);
    ```

3. **清理无用数据**：

    ```sql
    -- 删除旧数据
    DELETE FROM articles WHERE created_at < '2020-01-01';

    -- 清理空间
    VACUUM FULL articles;
    ```

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档编号**: 19-03-03
