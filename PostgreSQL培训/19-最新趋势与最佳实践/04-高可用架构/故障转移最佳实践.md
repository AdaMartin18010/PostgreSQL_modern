# PostgreSQL故障转移最佳实践

> **更新时间**: 2025年1月
> **技术版本**: PostgreSQL 17+/18+
> **文档编号**: 19-04-03

---

## 📑 目录

- [PostgreSQL故障转移最佳实践](#postgresql故障转移最佳实践)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 故障转移价值](#11-故障转移价值)
  - [2. 故障转移策略矩阵](#2-故障转移策略矩阵)
  - [3. 故障转移决策树](#3-故障转移决策树)
  - [4. 实际应用案例](#4-实际应用案例)
    - [4.1 案例：电商平台高可用架构](#41-案例电商平台高可用架构)
  - [5. pg\_auto\_failover配置详解](#5-pg_auto_failover配置详解)
    - [5.1 pg\_auto\_failover架构](#51-pg_auto_failover架构)
    - [5.2 pg\_auto\_failover监控](#52-pg_auto_failover监控)
  - [6. 故障转移测试](#6-故障转移测试)
    - [6.1 故障转移测试脚本](#61-故障转移测试脚本)
    - [6.2 故障转移性能测试](#62-故障转移性能测试)
  - [7. 数据一致性保证](#7-数据一致性保证)
    - [7.1 同步复制配置](#71-同步复制配置)
    - [7.2 数据一致性验证](#72-数据一致性验证)
  - [8. 常见问题（FAQ）](#8-常见问题faq)
    - [8.1 故障转移基础常见问题](#81-故障转移基础常见问题)
      - [Q1: Patroni和pg\_auto\_failover有什么区别？](#q1-patroni和pg_auto_failover有什么区别)
      - [Q2: 如何测试故障转移？](#q2-如何测试故障转移)
    - [8.2 故障转移优化常见问题](#82-故障转移优化常见问题)
      - [Q3: 如何减少故障转移时间？](#q3-如何减少故障转移时间)

---

## 1. 概述

### 1.1 故障转移价值

**自动故障转移的核心价值**：

| 价值维度 | 说明 | 量化数据 |
|---------|------|---------|
| **可用性** | 自动故障恢复 | **99.9%** 可用性 |
| **恢复时间** | 快速故障恢复 | **< 30秒** |
| **数据一致性** | 强一致性保证 | **100%** |
| **运维效率** | 自动化运维 | **+300%** 效率 |

---

## 2. 故障转移策略矩阵

| 策略 | 恢复时间 | 数据一致性 | 复杂度 | 成本 | 综合评分 |
|------|---------|-----------|--------|------|---------|
| **Patroni自动切换** | < 30秒 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | **4.1** |
| **pg_auto_failover** | < 1分钟 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | **4.3** |
| **手动故障转移** | 5-10分钟 | ⭐⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ | **2.8** |

---

## 3. 故障转移决策树

```text
故障转移需求？
├─ 自动故障转移
│  ├─ 数据规模？
│  │  ├─ 中小型 → pg_auto_failover
│  │  └─ 大型 → Patroni
│  └─ 恢复时间要求？
│     ├─ < 30秒 → Patroni
│     └─ < 1分钟 → pg_auto_failover
└─ 手动故障转移
   └─ 流复制 + 监控告警
```

---

## 4. 实际应用案例

### 4.1 案例：电商平台高可用架构

**业务场景**：

- 电商平台数据库
- 1000万+用户
- 99.9%可用性要求

**实施方案（Patroni）**：

```yaml
# patroni.yml
scope: postgres-cluster
namespace: /db/
name: postgres-node1

restapi:
  listen: 0.0.0.0:8008
  connect_address: 192.168.1.10:8008

etcd:
  hosts: 192.168.1.20:2379,192.168.1.21:2379,192.168.1.22:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 30
    maximum_lag_on_failover: 1048576
    postgresql:
      use_pg_rewind: true
      parameters:
        wal_level: replica
        hot_standby: "on"
        max_connections: 100
        max_wal_senders: 10
        wal_keep_segments: 8

postgresql:
  listen: 0.0.0.0:5432
  connect_address: 192.168.1.10:5432
  data_dir: /var/lib/postgresql/17/main
  pgpass: /var/lib/postgresql/.pgpass
  authentication:
    replication:
      username: replicator
      password: replicator_password
    superuser:
      username: postgres
      password: postgres_password
  parameters:
    unix_socket_directories: '/var/run/postgresql'
```

**实施效果**：

| 指标 | 实施前 | 实施后 | 提升 |
|------|--------|--------|------|
| **可用性** | 99.5% | 99.99% | **+0.49%** |
| **故障恢复时间** | 10分钟 | 25秒 | **-96%** |
| **数据丢失风险** | 中等 | 极低 | **-95%** |

---

## 5. pg_auto_failover配置详解

### 5.1 pg_auto_failover架构

**pg_auto_failover**是PostgreSQL的自动故障转移工具，配置简单，适合中小规模部署。

**架构组件**：

1. **Monitor节点**：
   - 监控PostgreSQL节点状态
   - 执行故障转移决策
   - 管理节点状态

2. **PostgreSQL节点**：
   - 主节点：处理读写请求
   - 从节点：复制数据，可读

**部署配置**：

```bash
# 1. 安装pg_auto_failover
sudo apt-get install postgresql-auto-failover

# 2. 初始化Monitor节点
pg_autoctl create monitor \
  --pgdata /var/lib/postgresql/monitor \
  --pgport 5432 \
  --pgctl /usr/lib/postgresql/17/bin/pg_ctl

# 3. 初始化主节点
pg_autoctl create postgres \
  --pgdata /var/lib/postgresql/primary \
  --pgport 5433 \
  --monitor 'postgres://autoctl_node@monitor:5432/pg_auto_failover' \
  --pgctl /usr/lib/postgresql/17/bin/pg_ctl

# 4. 添加从节点
pg_autoctl create postgres \
  --pgdata /var/lib/postgresql/standby \
  --pgport 5434 \
  --monitor 'postgres://autoctl_node@monitor:5432/pg_auto_failover' \
  --pgctl /usr/lib/postgresql/17/bin/pg_ctl
```

### 5.2 pg_auto_failover监控

**监控命令**：

```bash
# 1. 查看节点状态
pg_autoctl show state

# 输出示例：
#   Name |  Node |  Host:Port |       LSN | Reachable |       Current State |      Assigned State
# -------+-------+------------+-----------+-----------+---------------------+--------------------
#  node1 |     1 |  localhost:5433 | 0/3000000 |       yes |             primary |             primary
#  node2 |     2 |  localhost:5434 | 0/3000000 |       yes |           secondary |           secondary

# 2. 查看故障转移历史
pg_autoctl show events

# 3. 手动故障转移
pg_autoctl perform failover
```

---

## 6. 故障转移测试

### 6.1 故障转移测试脚本

**测试脚本**：

```bash
#!/bin/bash
# 故障转移测试脚本

# 1. 检查当前主节点
PRIMARY=$(pg_autoctl show state | grep primary | awk '{print $3}')

# 2. 模拟主节点故障
echo "模拟主节点故障..."
sudo systemctl stop postgresql@17-main

# 3. 等待故障转移
sleep 5

# 4. 检查新主节点
NEW_PRIMARY=$(pg_autoctl show state | grep primary | awk '{print $3}')

if [ "$PRIMARY" != "$NEW_PRIMARY" ]; then
    echo "故障转移成功！"
    echo "原主节点: $PRIMARY"
    echo "新主节点: $NEW_PRIMARY"
else
    echo "故障转移失败！"
    exit 1
fi

# 5. 恢复原主节点
sudo systemctl start postgresql@17-main
```

### 6.2 故障转移性能测试

**性能测试数据**：

| 故障类型 | 检测时间 | 转移时间 | 总恢复时间 |
|---------|---------|---------|-----------|
| **主节点崩溃** | 5秒 | 20秒 | 25秒 |
| **网络分区** | 10秒 | 20秒 | 30秒 |
| **磁盘故障** | 5秒 | 25秒 | 30秒 |

---

## 7. 数据一致性保证

### 7.1 同步复制配置

**同步复制配置**：

```sql
-- 1. 主库配置
ALTER SYSTEM SET synchronous_commit = "on";
ALTER SYSTEM SET synchronous_standby_names = "ANY 2 (standby1, standby2)";
SELECT pg_reload_conf();

-- 2. 验证同步复制
SELECT
    application_name,
    sync_state,
    sync_priority
FROM pg_stat_replication;

-- 输出示例：
--   application_name | sync_state | sync_priority
-- -------------------+------------+---------------
--  standby1          | sync       |             1
--  standby2          | sync       |             2
```

### 7.2 数据一致性验证

**一致性检查脚本**：

```sql
-- 1. 检查主从数据一致性
CREATE OR REPLACE FUNCTION check_replication_consistency()
RETURNS TABLE (
    table_name TEXT,
    primary_count BIGINT,
    standby_count BIGINT,
    is_consistent BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.table_name::TEXT,
        (SELECT COUNT(*) FROM primary_db.orders) AS primary_count,
        (SELECT COUNT(*) FROM standby_db.orders) AS standby_count,
        (SELECT COUNT(*) FROM primary_db.orders) =
        (SELECT COUNT(*) FROM standby_db.orders) AS is_consistent
    FROM information_schema.tables t
    WHERE t.table_schema = 'public'
      AND t.table_type = 'BASE TABLE';
END;
$$ LANGUAGE plpgsql;

-- 2. 执行检查
SELECT * FROM check_replication_consistency();
```

---

## 8. 常见问题（FAQ）

### 8.1 故障转移基础常见问题

#### Q1: Patroni和pg_auto_failover有什么区别？

**对比矩阵**：

| 特性 | Patroni | pg_auto_failover | 推荐场景 |
|------|---------|------------------|---------|
| **配置复杂度** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 简单配置 → pg_auto_failover |
| **功能完整性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 复杂需求 → Patroni |
| **故障转移时间** | < 30秒 | < 1分钟 | 快速恢复 → Patroni |
| **社区支持** | ⭐⭐⭐⭐ | ⭐⭐⭐ | 企业支持 → Patroni |

#### Q2: 如何测试故障转移？

**测试步骤**：

1. **模拟主节点故障**：

    ```bash
    # 停止主节点PostgreSQL
    sudo systemctl stop postgresql@17-main
    ```

2. **观察故障转移**：

    ```bash
    # 监控节点状态
    watch -n 1 'pg_autoctl show state'
    ```

3. **验证数据一致性**：

```sql
-- 在新主节点验证数据
SELECT COUNT(*) FROM orders;
```

### 8.2 故障转移优化常见问题

#### Q3: 如何减少故障转移时间？

**优化方案**：

1. **调整检测间隔**：

    ```yaml
    # Patroni配置
    loop_wait: 5  # 减少检测间隔（默认10秒）
    ```

2. **优化流复制**：

    ```sql
    ALTER SYSTEM SET wal_keep_size = '2GB';
    ALTER SYSTEM SET max_wal_senders = 20;
    ```

3. **使用SSD存储**：

- 提升WAL写入速度
- 减少故障恢复时间

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档编号**: 19-04-03
