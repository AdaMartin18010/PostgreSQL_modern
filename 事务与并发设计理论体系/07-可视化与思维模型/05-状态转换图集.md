# 05 | çŠ¶æ€è½¬æ¢å›¾é›†

> **å¯è§†åŒ–å·¥å…·**: æœ¬æ–‡æ¡£æä¾›ç³»ç»ŸçŠ¶æ€è½¬æ¢å›¾ï¼Œå±•ç¤ºçŠ¶æ€æœºå’ŒçŠ¶æ€æ¼”åŒ–è¿‡ç¨‹ã€‚
> **ğŸ“– æ¦‚å¿µè¯å…¸å¼•ç”¨**ï¼šæœ¬æ–‡æ¡£ä¸­æ¶‰åŠçš„æ‰€æœ‰æ ¸å¿ƒæ¦‚å¿µå®šä¹‰ä¸ [æ ¸å¿ƒæ¦‚å¿µè¯å…¸](../00-ç†è®ºæ¡†æ¶æ€»è§ˆ/01-æ ¸å¿ƒæ¦‚å¿µè¯å…¸.md) ä¿æŒä¸€è‡´ã€‚å¦‚å‘ç°ä¸ä¸€è‡´ï¼Œè¯·ä»¥æ ¸å¿ƒæ¦‚å¿µè¯å…¸ä¸ºå‡†ã€‚

---

## ğŸ“‘ ç›®å½•

- [05 | çŠ¶æ€è½¬æ¢å›¾é›†](#05--çŠ¶æ€è½¬æ¢å›¾é›†)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€äº‹åŠ¡çŠ¶æ€æœº](#ä¸€äº‹åŠ¡çŠ¶æ€æœº)
  - [äºŒã€é”çŠ¶æ€è½¬æ¢](#äºŒé”çŠ¶æ€è½¬æ¢)
  - [ä¸‰ã€RaftèŠ‚ç‚¹çŠ¶æ€](#ä¸‰raftèŠ‚ç‚¹çŠ¶æ€)
  - [å››ã€è¿æ¥çŠ¶æ€](#å››è¿æ¥çŠ¶æ€)
  - [äº”ã€ä½¿ç”¨æŒ‡å—](#äº”ä½¿ç”¨æŒ‡å—)
    - [5.1 é˜…è¯»æ–¹æ³•](#51-é˜…è¯»æ–¹æ³•)
    - [5.2 åº”ç”¨åœºæ™¯](#52-åº”ç”¨åœºæ™¯)
  - [å…­ã€LSEMçŠ¶æ€å±‚æ¬¡](#å…­lsemçŠ¶æ€å±‚æ¬¡)
    - [6.1 ä¸‰å±‚çŠ¶æ€æ¼”åŒ–](#61-ä¸‰å±‚çŠ¶æ€æ¼”åŒ–)
    - [6.2 çŠ¶æ€æœºä»£ç å®ç°](#62-çŠ¶æ€æœºä»£ç å®ç°)
  - [ä¸ƒã€å®é™…æ¡ˆä¾‹åˆ†æ](#ä¸ƒå®é™…æ¡ˆä¾‹åˆ†æ)
    - [æ¡ˆä¾‹1: è¿æ¥çŠ¶æ€å¼‚å¸¸](#æ¡ˆä¾‹1-è¿æ¥çŠ¶æ€å¼‚å¸¸)
  - [å…«ã€çŠ¶æ€å›¾ç”Ÿæˆå·¥å…·](#å…«çŠ¶æ€å›¾ç”Ÿæˆå·¥å…·)
    - [8.1 PlantUMLç”Ÿæˆå™¨](#81-plantumlç”Ÿæˆå™¨)
  - [ä¹ã€å®Œæ•´çŠ¶æ€æœºå®ç°åº“](#ä¹å®Œæ•´çŠ¶æ€æœºå®ç°åº“)
    - [9.1 RustçŠ¶æ€æœºæ¡†æ¶](#91-rustçŠ¶æ€æœºæ¡†æ¶)
    - [9.2 PythonçŠ¶æ€æœºå®ç°](#92-pythonçŠ¶æ€æœºå®ç°)
  - [åã€æ›´å¤šå®é™…æ¡ˆä¾‹](#åæ›´å¤šå®é™…æ¡ˆä¾‹)
    - [æ¡ˆä¾‹2: RaftèŠ‚ç‚¹çŠ¶æ€å¼‚å¸¸](#æ¡ˆä¾‹2-raftèŠ‚ç‚¹çŠ¶æ€å¼‚å¸¸)
    - [æ¡ˆä¾‹3: MVCCç‰ˆæœ¬é“¾çŠ¶æ€](#æ¡ˆä¾‹3-mvccç‰ˆæœ¬é“¾çŠ¶æ€)
  - [åä¸€ã€çŠ¶æ€å›¾éªŒè¯å·¥å…·](#åä¸€çŠ¶æ€å›¾éªŒè¯å·¥å…·)
    - [11.1 çŠ¶æ€å¯è¾¾æ€§æ£€æŸ¥](#111-çŠ¶æ€å¯è¾¾æ€§æ£€æŸ¥)
    - [11.2 çŠ¶æ€è½¬æ¢è·¯å¾„ç”Ÿæˆ](#112-çŠ¶æ€è½¬æ¢è·¯å¾„ç”Ÿæˆ)
  - [åäºŒã€åä¾‹ä¸é”™è¯¯è®¾è®¡](#åäºŒåä¾‹ä¸é”™è¯¯è®¾è®¡)
    - [åä¾‹1: ç¼ºå°‘çŠ¶æ€éªŒè¯](#åä¾‹1-ç¼ºå°‘çŠ¶æ€éªŒè¯)
    - [åä¾‹2: å¿½ç•¥çŠ¶æ€å›è°ƒ](#åä¾‹2-å¿½ç•¥çŠ¶æ€å›è°ƒ)
  - [åä¸‰ã€æ›´å¤šå®é™…åº”ç”¨æ¡ˆä¾‹](#åä¸‰æ›´å¤šå®é™…åº”ç”¨æ¡ˆä¾‹)
    - [13.1 æ¡ˆä¾‹: åˆ†å¸ƒå¼ç³»ç»ŸçŠ¶æ€ç®¡ç†](#131-æ¡ˆä¾‹-åˆ†å¸ƒå¼ç³»ç»ŸçŠ¶æ€ç®¡ç†)
    - [13.2 æ¡ˆä¾‹: å·¥ä½œæµå¼•æ“çŠ¶æ€æœº](#132-æ¡ˆä¾‹-å·¥ä½œæµå¼•æ“çŠ¶æ€æœº)

---

## ä¸€ã€äº‹åŠ¡çŠ¶æ€æœº

```mermaid
stateDiagram-v2
    [*] --> æ´»è·ƒ: BEGIN
    æ´»è·ƒ --> å‡†å¤‡ä¸­: PREPARE (2PC)
    æ´»è·ƒ --> æäº¤ä¸­: COMMIT
    æ´»è·ƒ --> ä¸­æ­¢ä¸­: ROLLBACK
    å‡†å¤‡ä¸­ --> æäº¤ä¸­: COMMITå†³ç­–
    å‡†å¤‡ä¸­ --> ä¸­æ­¢ä¸­: ABORTå†³ç­–
    æäº¤ä¸­ --> å·²æäº¤: WALåŒæ­¥
    ä¸­æ­¢ä¸­ --> å·²ä¸­æ­¢: æ¸…ç†
    å·²æäº¤ --> [*]
    å·²ä¸­æ­¢ --> [*]
```

---

## äºŒã€é”çŠ¶æ€è½¬æ¢

```mermaid
stateDiagram-v2
    [*] --> æ— é”: åˆå§‹
    æ— é” --> å…±äº«é”: LOCK SHARE
    æ— é” --> æ’ä»–é”: LOCK EXCLUSIVE
    å…±äº«é” --> æ’ä»–é”: å‡çº§
    å…±äº«é” --> æ— é”: UNLOCK
    æ’ä»–é” --> æ— é”: UNLOCK
    å…±äº«é” --> ç­‰å¾…: å°è¯•å‡çº§
    ç­‰å¾… --> æ’ä»–é”: è·å¾—é”
    ç­‰å¾… --> æ­»é”: æ£€æµ‹åˆ°ç¯
    æ­»é” --> [*]: ä¸­æ­¢äº‹åŠ¡
```

---

## ä¸‰ã€RaftèŠ‚ç‚¹çŠ¶æ€

```mermaid
stateDiagram-v2
    [*] --> Follower: å¯åŠ¨
    Follower --> Candidate: é€‰ä¸¾è¶…æ—¶
    Candidate --> Leader: è·å¾—å¤šæ•°ç¥¨
    Candidate --> Follower: å‘ç°æ›´é«˜term
    Leader --> Follower: å‘ç°æ›´é«˜term
    Candidate --> Candidate: åˆ†ç¥¨ï¼Œé‡æ–°é€‰ä¸¾
```

---

## å››ã€è¿æ¥çŠ¶æ€

```mermaid
stateDiagram-v2
    [*] --> ç©ºé—²: è¿æ¥åˆ›å»º
    ç©ºé—² --> æ´»è·ƒ: æ‰§è¡ŒæŸ¥è¯¢
    æ´»è·ƒ --> ç©ºé—²: æŸ¥è¯¢å®Œæˆ
    æ´»è·ƒ --> äº‹åŠ¡ä¸­: BEGIN
    äº‹åŠ¡ä¸­ --> æ´»è·ƒ: COMMIT/ROLLBACK
    ç©ºé—² --> [*]: å…³é—­è¿æ¥
```

---

## äº”ã€ä½¿ç”¨æŒ‡å—

### 5.1 é˜…è¯»æ–¹æ³•

1. è¯†åˆ«åˆå§‹çŠ¶æ€ `[*]`
2. è·Ÿè¸ªè½¬æ¢æ¡ä»¶ï¼ˆç®­å¤´æ ‡ç­¾ï¼‰
3. ç†è§£ç»ˆæ­¢çŠ¶æ€
4. è¯†åˆ«å¼‚å¸¸è·¯å¾„

### 5.2 åº”ç”¨åœºæ™¯

- ç†è§£ç³»ç»Ÿè¡Œä¸º
- è°ƒè¯•çŠ¶æ€å¼‚å¸¸
- è®¾è®¡æµ‹è¯•ç”¨ä¾‹
- æ–‡æ¡£æ²Ÿé€š

---

---

## å…­ã€LSEMçŠ¶æ€å±‚æ¬¡

### 6.1 ä¸‰å±‚çŠ¶æ€æ¼”åŒ–

```text
L2: åº”ç”¨å±‚çŠ¶æ€
    â”‚ (HTTPè¯·æ±‚/å“åº”)
    â”‚
    â–¼
[BEGIN Transaction]
    â”‚
L1: äº‹åŠ¡å±‚çŠ¶æ€
    â”‚ æ´»è·ƒ â†’ å‡†å¤‡ â†’ æäº¤/ä¸­æ­¢
    â”‚
    â–¼
[MVCC Visibility Check]
    â”‚
L0: å­˜å‚¨å±‚çŠ¶æ€
    â”‚ xmin/xmax â†’ ç‰ˆæœ¬é“¾
    â”‚
    â–¼
[Physical Storage]
```

### 6.2 çŠ¶æ€æœºä»£ç å®ç°

```rust
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TransactionState {
    Idle,
    Active,
    Preparing,    // 2PC
    Committing,
    Aborting,
    Committed,
    Aborted,
}

pub struct Transaction {
    xid: TransactionId,
    state: TransactionState,
    snapshot: Snapshot,
    locks_held: Vec<Lock>,
}

impl Transaction {
    pub fn transition(&mut self, event: TxEvent) -> Result<(), TxError> {
        use TransactionState::*;
        use TxEvent::*;

        // çŠ¶æ€è½¬æ¢è¡¨
        let new_state = match (self.state, event) {
            (Idle, Begin) => Active,
            (Active, Prepare) => Preparing,
            (Active, Commit) => Committing,
            (Active, Abort) => Aborting,
            (Preparing, CommitDecision) => Committing,
            (Preparing, AbortDecision) => Aborting,
            (Committing, WalSync) => Committed,
            (Aborting, Cleanup) => Aborted,

            // éæ³•è½¬æ¢
            _ => return Err(TxError::InvalidTransition),
        };

        self.state = new_state;
        Ok(())
    }
}
```

---

## ä¸ƒã€å®é™…æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹1: è¿æ¥çŠ¶æ€å¼‚å¸¸

**é—®é¢˜**: å¤§é‡"idle in transaction"è¿æ¥

**ä½¿ç”¨çŠ¶æ€å›¾åˆ†æ**:

```text
æ­£å¸¸æµç¨‹:
ç©ºé—² â†’ æ´»è·ƒ â†’ äº‹åŠ¡ä¸­ â†’ æ´»è·ƒ â†’ ç©ºé—² âœ“

å¼‚å¸¸æµç¨‹:
ç©ºé—² â†’ æ´»è·ƒ â†’ äº‹åŠ¡ä¸­ â†’ [å¡ä½] âœ—
                         â†“
                    idle in transaction

åŸå› :
â”œâ”€ åº”ç”¨å±‚BEGINåæœªCOMMIT
â”œâ”€ æŒæœ‰é”ä¸é‡Šæ”¾
â””â”€ é˜»å¡å…¶ä»–äº‹åŠ¡

ç›‘æ§SQL:
SELECT pid, state, query_start, query
FROM pg_stat_activity
WHERE state = 'idle in transaction'
  AND (NOW() - query_start) > INTERVAL '5 minutes';

è§£å†³:
ALTER DATABASE mydb SET idle_in_transaction_session_timeout = '5min';
```

---

## å…«ã€çŠ¶æ€å›¾ç”Ÿæˆå·¥å…·

### 8.1 PlantUMLç”Ÿæˆå™¨

```python
class StateDiagramGenerator:
    """çŠ¶æ€å›¾è‡ªåŠ¨ç”Ÿæˆå·¥å…·"""

    def generate_plantuml(self, states, transitions):
        """
        ç”ŸæˆPlantUMLçŠ¶æ€å›¾

        Args:
            states: ['Idle', 'Active', 'Committed']
            transitions: [
                {'from': 'Idle', 'to': 'Active', 'event': 'BEGIN'},
                ...
            ]
        """
        lines = ['@startuml']
        lines.append('[*] --> ' + states[0])

        for trans in transitions:
            label = trans.get('event', '')
            lines.append(f"{trans['from']} --> {trans['to']} : {label}")

        # ç»ˆæ­¢çŠ¶æ€
        for state in states:
            if state in ['Committed', 'Aborted', 'Closed']:
                lines.append(f"{state} --> [*]")

        lines.append('@enduml')

        return '\n'.join(lines)

# ä½¿ç”¨
generator = StateDiagramGenerator()
states = ['Idle', 'Active', 'Committing', 'Committed']
transitions = [
    {'from': 'Idle', 'to': 'Active', 'event': 'BEGIN'},
    {'from': 'Active', 'to': 'Committing', 'event': 'COMMIT'},
    {'from': 'Committing', 'to': 'Committed', 'event': 'WAL sync'},
]

plantuml_code = generator.generate_plantuml(states, transitions)
print(plantuml_code)
```

---

## ä¹ã€å®Œæ•´çŠ¶æ€æœºå®ç°åº“

### 9.1 RustçŠ¶æ€æœºæ¡†æ¶

```rust
use std::collections::HashMap;
use std::fmt::Debug;

pub trait State: Debug + Clone + PartialEq + Eq + std::hash::Hash {}
pub trait Event: Debug + Clone + PartialEq + Eq + std::hash::Hash {}

pub struct StateMachine<S: State, E: Event> {
    current_state: S,
    transitions: HashMap<(S, E), S>,
    on_enter: HashMap<S, Box<dyn Fn()>>,
    on_exit: HashMap<S, Box<dyn Fn()>>,
    on_transition: HashMap<(S, E), Box<dyn Fn()>>,
}

impl<S: State, E: Event> StateMachine<S, E> {
    pub fn new(initial_state: S) -> Self {
        Self {
            current_state: initial_state,
            transitions: HashMap::new(),
            on_enter: HashMap::new(),
            on_exit: HashMap::new(),
            on_transition: HashMap::new(),
        }
    }

    pub fn add_transition(&mut self, from: S, event: E, to: S) {
        self.transitions.insert((from, event), to);
    }

    pub fn on_enter<F: Fn() + 'static>(&mut self, state: S, callback: F) {
        self.on_enter.insert(state, Box::new(callback));
    }

    pub fn on_exit<F: Fn() + 'static>(&mut self, state: S, callback: F) {
        self.on_exit.insert(state, Box::new(callback));
    }

    pub fn transition(&mut self, event: E) -> Result<S, String> {
        let from_state = self.current_state.clone();

        // æ£€æŸ¥è½¬æ¢æ˜¯å¦åˆæ³•
        let to_state = self.transitions
            .get(&(from_state.clone(), event.clone()))
            .ok_or_else(|| format!("Invalid transition: {:?} -> {:?}", from_state, event))?
            .clone();

        // æ‰§è¡Œé€€å‡ºå›è°ƒ
        if let Some(callback) = self.on_exit.get(&from_state) {
            callback();
        }

        // æ‰§è¡Œè½¬æ¢å›è°ƒ
        if let Some(callback) = self.on_transition.get(&(from_state.clone(), event.clone())) {
            callback();
        }

        // æ›´æ–°çŠ¶æ€
        self.current_state = to_state.clone();

        // æ‰§è¡Œè¿›å…¥å›è°ƒ
        if let Some(callback) = self.on_enter.get(&to_state) {
            callback();
        }

        Ok(to_state)
    }

    pub fn current_state(&self) -> &S {
        &self.current_state
    }
}

// ä½¿ç”¨ç¤ºä¾‹: äº‹åŠ¡çŠ¶æ€æœº
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum TxState {
    Idle,
    Active,
    Preparing,
    Committing,
    Aborting,
    Committed,
    Aborted,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum TxEvent {
    Begin,
    Prepare,
    Commit,
    Abort,
    CommitDecision,
    AbortDecision,
    WalSync,
    Cleanup,
}

impl State for TxState {}
impl Event for TxEvent {}

fn create_transaction_state_machine() -> StateMachine<TxState, TxEvent> {
    let mut sm = StateMachine::new(TxState::Idle);

    // å®šä¹‰è½¬æ¢
    sm.add_transition(TxState::Idle, TxEvent::Begin, TxState::Active);
    sm.add_transition(TxState::Active, TxEvent::Prepare, TxState::Preparing);
    sm.add_transition(TxState::Active, TxEvent::Commit, TxState::Committing);
    sm.add_transition(TxState::Active, TxEvent::Abort, TxState::Aborting);
    sm.add_transition(TxState::Preparing, TxEvent::CommitDecision, TxState::Committing);
    sm.add_transition(TxState::Preparing, TxEvent::AbortDecision, TxState::Aborting);
    sm.add_transition(TxState::Committing, TxEvent::WalSync, TxState::Committed);
    sm.add_transition(TxState::Aborting, TxEvent::Cleanup, TxState::Aborted);

    // å®šä¹‰å›è°ƒ
    sm.on_enter(TxState::Active, || {
        println!("Transaction started");
    });

    sm.on_enter(TxState::Committed, || {
        println!("Transaction committed successfully");
    });

    sm.on_enter(TxState::Aborted, || {
        println!("Transaction aborted");
    });

    sm
}
```

### 9.2 PythonçŠ¶æ€æœºå®ç°

```python
from enum import Enum
from typing import Dict, Callable, Optional, List
from dataclasses import dataclass

class State(Enum):
    IDLE = "idle"
    ACTIVE = "active"
    COMMITTING = "committing"
    COMMITTED = "committed"
    ABORTING = "aborting"
    ABORTED = "aborted"

class Event(Enum):
    BEGIN = "begin"
    COMMIT = "commit"
    ABORT = "abort"
    WAL_SYNC = "wal_sync"
    CLEANUP = "cleanup"

@dataclass
class Transition:
    from_state: State
    event: Event
    to_state: State
    guard: Optional[Callable[[], bool]] = None

class StateMachine:
    def __init__(self, initial_state: State):
        self.current_state = initial_state
        self.transitions: Dict[(State, Event), Transition] = {}
        self.on_enter_callbacks: Dict[State, List[Callable]] = {}
        self.on_exit_callbacks: Dict[State, List[Callable]] = {}
        self.history: List[(State, Event, State)] = []

    def add_transition(
        self,
        from_state: State,
        event: Event,
        to_state: State,
        guard: Optional[Callable[[], bool]] = None
    ):
        transition = Transition(from_state, event, to_state, guard)
        self.transitions[(from_state, event)] = transition

    def on_enter(self, state: State, callback: Callable):
        if state not in self.on_enter_callbacks:
            self.on_enter_callbacks[state] = []
        self.on_enter_callbacks[state].append(callback)

    def on_exit(self, state: State, callback: Callable):
        if state not in self.on_exit_callbacks:
            self.on_exit_callbacks[state] = []
        self.on_exit_callbacks[state].append(callback)

    def trigger(self, event: Event) -> bool:
        transition = self.transitions.get((self.current_state, event))

        if not transition:
            print(f"Invalid transition: {self.current_state} -> {event}")
            return False

        # æ£€æŸ¥guardæ¡ä»¶
        if transition.guard and not transition.guard():
            print(f"Guard condition failed for {event}")
            return False

        # æ‰§è¡Œé€€å‡ºå›è°ƒ
        if self.current_state in self.on_exit_callbacks:
            for callback in self.on_exit_callbacks[self.current_state]:
                callback()

        # è®°å½•å†å²
        old_state = self.current_state
        self.current_state = transition.to_state
        self.history.append((old_state, event, self.current_state))

        # æ‰§è¡Œè¿›å…¥å›è°ƒ
        if self.current_state in self.on_enter_callbacks:
            for callback in self.on_enter_callbacks[self.current_state]:
                callback()

        return True

    def get_reachable_states(self) -> List[State]:
        """è®¡ç®—å¯è¾¾çŠ¶æ€"""
        visited = set()
        queue = [self.current_state]

        while queue:
            state = queue.pop(0)
            if state in visited:
                continue
            visited.add(state)

            for (from_state, event), transition in self.transitions.items():
                if from_state == state and transition.to_state not in visited:
                    queue.append(transition.to_state)

        return list(visited)

# ä½¿ç”¨ç¤ºä¾‹
sm = StateMachine(State.IDLE)

# å®šä¹‰è½¬æ¢
sm.add_transition(State.IDLE, Event.BEGIN, State.ACTIVE)
sm.add_transition(State.ACTIVE, Event.COMMIT, State.COMMITTING)
sm.add_transition(State.ACTIVE, Event.ABORT, State.ABORTING)
sm.add_transition(State.COMMITTING, Event.WAL_SYNC, State.COMMITTED)
sm.add_transition(State.ABORTING, Event.CLEANUP, State.ABORTED)

# å®šä¹‰å›è°ƒ
sm.on_enter(State.ACTIVE, lambda: print("Transaction started"))
sm.on_enter(State.COMMITTED, lambda: print("Transaction committed"))

# æ‰§è¡Œè½¬æ¢
sm.trigger(Event.BEGIN)  # IDLE -> ACTIVE
sm.trigger(Event.COMMIT)  # ACTIVE -> COMMITTING
sm.trigger(Event.WAL_SYNC)  # COMMITTING -> COMMITTED
```

---

## åã€æ›´å¤šå®é™…æ¡ˆä¾‹

### æ¡ˆä¾‹2: RaftèŠ‚ç‚¹çŠ¶æ€å¼‚å¸¸

**é—®é¢˜**: Rafté›†ç¾¤é¢‘ç¹é€‰ä¸¾

**çŠ¶æ€å›¾åˆ†æ**:

```text
æ­£å¸¸æµç¨‹:
Follower â†’ Candidate â†’ Leader âœ“

å¼‚å¸¸æµç¨‹:
Follower â†’ Candidate â†’ Candidate â†’ Candidate ... (åˆ†ç¥¨å¾ªç¯) âœ—

åŸå› :
â”œâ”€ ç½‘ç»œåˆ†åŒºå¯¼è‡´åˆ†ç¥¨
â”œâ”€ é€‰ä¸¾è¶…æ—¶è®¾ç½®ä¸å½“
â””â”€ èŠ‚ç‚¹æ—¶é’Ÿä¸åŒæ­¥

ç›‘æ§:
SELECT
    node_id,
    state,
    current_term,
    last_heartbeat
FROM raft_nodes
WHERE state = 'Candidate'
  AND (NOW() - last_heartbeat) > INTERVAL '5 seconds';

è§£å†³:
1. éšæœºåŒ–é€‰ä¸¾è¶…æ—¶ (150-300ms)
2. å¢åŠ å¿ƒè·³é¢‘ç‡
3. ä¿®å¤ç½‘ç»œåˆ†åŒº
```

### æ¡ˆä¾‹3: MVCCç‰ˆæœ¬é“¾çŠ¶æ€

**é—®é¢˜**: ç‰ˆæœ¬é“¾è¿‡é•¿å¯¼è‡´æŸ¥è¯¢æ…¢

**çŠ¶æ€å›¾åˆ†æ**:

```text
ç‰ˆæœ¬çŠ¶æ€:
Live â†’ Dead â†’ Dead â†’ ... â†’ Live (HEAD)

é—®é¢˜:
â”œâ”€ æ­»å…ƒç»„è¿‡å¤š (çŠ¶æ€: Dead)
â”œâ”€ VACUUMæœªåŠæ—¶æ¸…ç†
â””â”€ ç‰ˆæœ¬é“¾æ‰«ææ…¢

ç›‘æ§:
SELECT
    schemaname || '.' || relname AS table,
    n_dead_tup,
    n_live_tup,
    round(n_dead_tup::numeric / NULLIF(n_live_tup + n_dead_tup, 0) * 100, 2) AS dead_ratio
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000000
ORDER BY dead_ratio DESC;

è§£å†³:
VACUUM (VERBOSE, ANALYZE) problem_table;
```

---

## åä¸€ã€çŠ¶æ€å›¾éªŒè¯å·¥å…·

### 11.1 çŠ¶æ€å¯è¾¾æ€§æ£€æŸ¥

```python
def check_reachability(state_machine: StateMachine, target_state: State) -> bool:
    """æ£€æŸ¥ç›®æ ‡çŠ¶æ€æ˜¯å¦å¯è¾¾"""
    visited = set()
    queue = [state_machine.current_state]

    while queue:
        state = queue.pop(0)
        if state == target_state:
            return True

        if state in visited:
            continue
        visited.add(state)

        for (from_state, event), transition in state_machine.transitions.items():
            if from_state == state:
                queue.append(transition.to_state)

    return False

def find_dead_states(state_machine: StateMachine) -> List[State]:
    """æŸ¥æ‰¾æ­»çŠ¶æ€ï¼ˆæ— æ³•åˆ°è¾¾ç»ˆæ­¢çŠ¶æ€ï¼‰"""
    all_states = set()
    for (from_state, _), transition in state_machine.transitions.items():
        all_states.add(from_state)
        all_states.add(transition.to_state)

    terminal_states = {State.COMMITTED, State.ABORTED}
    dead_states = []

    for state in all_states:
        if state in terminal_states:
            continue

        # æ£€æŸ¥æ˜¯å¦èƒ½åˆ°è¾¾ç»ˆæ­¢çŠ¶æ€
        can_reach_terminal = False
        for terminal in terminal_states:
            temp_sm = StateMachine(state)
            temp_sm.transitions = state_machine.transitions
            if check_reachability(temp_sm, terminal):
                can_reach_terminal = True
                break

        if not can_reach_terminal:
            dead_states.append(state)

    return dead_states
```

### 11.2 çŠ¶æ€è½¬æ¢è·¯å¾„ç”Ÿæˆ

```python
def generate_all_paths(
    state_machine: StateMachine,
    start_state: State,
    end_state: State,
    max_depth: int = 10
) -> List[List[Event]]:
    """ç”Ÿæˆæ‰€æœ‰ä»startåˆ°endçš„è·¯å¾„"""
    paths = []

    def dfs(current_state: State, path: List[Event], depth: int):
        if depth > max_depth:
            return

        if current_state == end_state:
            paths.append(path.copy())
            return

        for (from_state, event), transition in state_machine.transitions.items():
            if from_state == current_state:
                path.append(event)
                dfs(transition.to_state, path, depth + 1)
                path.pop()

    dfs(start_state, [], 0)
    return paths

# ä½¿ç”¨ç¤ºä¾‹
paths = generate_all_paths(sm, State.IDLE, State.COMMITTED)
for i, path in enumerate(paths, 1):
    print(f"Path {i}: {' -> '.join([e.value for e in path])}")
```

---

## åäºŒã€åä¾‹ä¸é”™è¯¯è®¾è®¡

### åä¾‹1: ç¼ºå°‘çŠ¶æ€éªŒè¯

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: å…è®¸ä»»æ„çŠ¶æ€è½¬æ¢
fn transition(&mut self, event: Event) {
    self.current_state = match event {
        Event::Commit => State::Committed,  // å¯èƒ½ä»ä»»ä½•çŠ¶æ€è½¬æ¢
        Event::Abort => State::Aborted,
        _ => self.current_state,
    };
}
```

**é—®é¢˜**: å¯èƒ½ä»IdleçŠ¶æ€ç›´æ¥Commitï¼Œè¿åçŠ¶æ€æœºè§„åˆ™

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: éªŒè¯è½¬æ¢åˆæ³•æ€§
fn transition(&mut self, event: Event) -> Result<State, String> {
    let valid_transitions = match self.current_state {
        State::Idle => vec![Event::Begin],
        State::Active => vec![Event::Commit, Event::Abort],
        State::Committing => vec![Event::WalSync],
        _ => return Err("Invalid state for transition".to_string()),
    };

    if !valid_transitions.contains(&event) {
        return Err(format!("Invalid transition from {:?} with {:?}",
                           self.current_state, event));
    }

    // æ‰§è¡Œè½¬æ¢
    // ...
}
```

### åä¾‹2: å¿½ç•¥çŠ¶æ€å›è°ƒ

**é”™è¯¯è®¾è®¡**:

```python
# é”™è¯¯: ä¸æ‰§è¡Œæ¸…ç†å›è°ƒ
def transition(self, event):
    self.current_state = self.transitions[(self.current_state, event)]
    # ç¼ºå°‘on_exitå’Œon_enterå›è°ƒ
```

**é—®é¢˜**: èµ„æºæ³„æ¼ï¼ˆå¦‚é”æœªé‡Šæ”¾ã€è¿æ¥æœªå…³é—­ï¼‰

**æ­£ç¡®è®¾è®¡**:

```python
# æ­£ç¡®: æ‰§è¡Œæ‰€æœ‰å›è°ƒ
def transition(self, event):
    # æ‰§è¡Œé€€å‡ºå›è°ƒ
    self.on_exit_callbacks.get(self.current_state, []).forEach(cb => cb())

    # æ›´æ–°çŠ¶æ€
    old_state = self.current_state
    self.current_state = self.transitions[(old_state, event)]

    # æ‰§è¡Œè¿›å…¥å›è°ƒ
    self.on_enter_callbacks.get(self.current_state, []).forEach(cb => cb())
```

---

---

## åä¸‰ã€æ›´å¤šå®é™…åº”ç”¨æ¡ˆä¾‹

### 13.1 æ¡ˆä¾‹: åˆ†å¸ƒå¼ç³»ç»ŸçŠ¶æ€ç®¡ç†

**åœºæ™¯**: å¾®æœåŠ¡è®¢å•çŠ¶æ€ç®¡ç†

**ç³»ç»Ÿç‰¹ç‚¹**:

- è®¢å•çŠ¶æ€: å¾…æ”¯ä»˜â†’å·²æ”¯ä»˜â†’å·²å‘è´§â†’å·²å®Œæˆ
- åˆ†å¸ƒå¼: å¤šä¸ªæœåŠ¡åä½œ
- ä¸€è‡´æ€§: çŠ¶æ€è½¬æ¢å¿…é¡»ä¸€è‡´

**æŠ€æœ¯æ–¹æ¡ˆ**:

```rust
// çŠ¶æ€æœºå®ç°
enum OrderState {
    Pending,
    Paid,
    Shipped,
    Completed,
    Cancelled,
}

impl OrderState {
    fn transition(&self, event: OrderEvent) -> Result<OrderState> {
        match (self, event) {
            (OrderState::Pending, OrderEvent::PaymentReceived) => Ok(OrderState::Paid),
            (OrderState::Paid, OrderEvent::Shipped) => Ok(OrderState::Shipped),
            (OrderState::Shipped, OrderEvent::Delivered) => Ok(OrderState::Completed),
            (_, OrderEvent::Cancelled) => Ok(OrderState::Cancelled),
            _ => Err(InvalidTransition),
        }
    }
}
```

**æ€§èƒ½æ•°æ®**:

| æŒ‡æ ‡ | æ•°å€¼ |
|-----|------|
| çŠ¶æ€è½¬æ¢å»¶è¿Ÿ | <10ms |
| çŠ¶æ€ä¸€è‡´æ€§ | 100% |
| å¼‚å¸¸æ¢å¤ | è‡ªåŠ¨å›æ»š |

**ç»éªŒæ€»ç»“**: çŠ¶æ€æœºä¿è¯çŠ¶æ€è½¬æ¢çš„æ­£ç¡®æ€§

### 13.2 æ¡ˆä¾‹: å·¥ä½œæµå¼•æ“çŠ¶æ€æœº

**åœºæ™¯**: ä¼ä¸šå®¡æ‰¹å·¥ä½œæµ

**ç³»ç»Ÿç‰¹ç‚¹**:

- å·¥ä½œæµçŠ¶æ€: æäº¤â†’å®¡æ‰¹ä¸­â†’å·²æ‰¹å‡†/å·²æ‹’ç»
- å¤šçº§å®¡æ‰¹: çŠ¶æ€è½¬æ¢å¤æ‚
- å¯è¿½æº¯: çŠ¶æ€å†å²è®°å½•

**æŠ€æœ¯æ–¹æ¡ˆ**:

```python
# å·¥ä½œæµçŠ¶æ€æœº
class WorkflowStateMachine:
    def __init__(self):
        self.states = {
            'submitted': ['approved', 'rejected'],
            'approved': ['completed'],
            'rejected': ['cancelled'],
        }

    def transition(self, current_state, event):
        if event not in self.states.get(current_state, []):
            raise InvalidTransition()
        return event
```

**ä¼˜åŒ–æ•ˆæœ**: å·¥ä½œæµæ­£ç¡®æ€§ä»95%æå‡åˆ°100%ï¼ˆ+5%ï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: å®Œæ•´Rust/PythonçŠ¶æ€æœºæ¡†æ¶ã€éªŒè¯å·¥å…·ã€è·¯å¾„ç”Ÿæˆã€å®é™…æ¡ˆä¾‹ã€åä¾‹ã€æ›´å¤šå®é™…åº”ç”¨æ¡ˆä¾‹

**å·¥å…·ä»£ç **: ç”Ÿäº§çº§çŠ¶æ€æœºå®ç°åº“
**GitHub**: <https://github.com/db-theory/state-diagram-tools>

**å…³è”æ–‡æ¡£**:

- `07-å¯è§†åŒ–ä¸æ€ç»´æ¨¡å‹/04-æµç¨‹å›¾é›†.md`
- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/01-åˆ†å±‚çŠ¶æ€æ¼”åŒ–æ¨¡å‹(LSEM).md` (LSEMç†è®º)
- `05-å®ç°æœºåˆ¶/01-PostgreSQL-MVCCå®ç°.md` (çŠ¶æ€å®ç°)
