# Runbook：增量备份与恢复（PostgreSQL 18）

## 目标

利用 PostgreSQL 18 的增量备份功能与 WAL 归档，构建高效、可演练的备份恢复流程，实现 RTO/RPO 目标。

## 前置条件

- PostgreSQL 18+ 版本
- 配置 WAL 归档（archive_mode、archive_command）
- 配置 WAL Summarizer（PostgreSQL 18 默认启用）
- 备份存储空间规划
- 监控告警配置

### 前置配置

```sql
-- 1. 启用WAL归档
-- postgresql.conf
archive_mode = on
archive_command = 'test ! -f /archive/%f && cp %p /archive/%f'
wal_level = replica

-- 2. 验证WAL Summarizer状态（PostgreSQL 18）
SELECT * FROM pg_stat_wal_summarizer;

-- 3. 检查归档状态
SELECT * FROM pg_stat_archiver;
```

## 步骤

### 步骤1: 基础全量备份

```bash
# 创建全量备份（作为增量备份的基准）
pg_basebackup \
    -D /backup/base/$(date +%Y%m%d_%H%M%S) \
    -X stream \
    -P \
    -v \
    -F plain

# 记录备份LSN（用于后续增量备份）
psql -c "SELECT pg_current_wal_lsn();" > /backup/base/backup_lsn.txt

# 验证备份
ls -lh /backup/base/
```

### 步骤2: 增量备份（PostgreSQL 18）

```bash
# PostgreSQL 18增量备份
pg_basebackup \
    -D /backup/incremental/$(date +%Y%m%d_%H%M%S) \
    --incremental \
    --incremental-base=/backup/base/20241122_020000 \
    -X stream \
    -P \
    -v \
    -F plain

# 增量备份选项说明：
# --incremental: 启用增量备份
# --incremental-base: 指定基准备份路径
# -X stream: 同时备份WAL文件
# -P: 显示进度
# -v: 详细输出
```

### 步骤3: 备份验证

```bash
# 1. 检查备份目录结构
ls -lh /backup/incremental/

# 2. 验证备份完整性
pg_checksums -D /backup/incremental/20241122_120000 --check

# 3. 检查备份大小
du -sh /backup/incremental/20241122_120000

# 4. 验证WAL文件
ls -lh /backup/incremental/20241122_120000/pg_wal/
```

### 步骤4: 恢复准备

```bash
# 1. 停止PostgreSQL服务（如果恢复）
systemctl stop postgresql

# 2. 备份当前数据目录（如果存在）
mv /var/lib/postgresql/data /var/lib/postgresql/data.old

# 3. 准备恢复目录
mkdir -p /var/lib/postgresql/data
```

### 步骤5: 执行恢复

```bash
# 方法1: 从全量备份恢复
cp -r /backup/base/20241122_020000/* /var/lib/postgresql/data/

# 方法2: 从增量备份恢复（需要先恢复基准备份）
# 步骤1: 恢复基准备份
cp -r /backup/base/20241122_020000/* /var/lib/postgresql/data/

# 步骤2: 应用增量备份
rsync -av /backup/incremental/20241122_120000/ /var/lib/postgresql/data/

# 3. 配置恢复参数
cat > /var/lib/postgresql/data/postgresql.auto.conf <<EOF
restore_command = 'cp /archive/%f %p'
recovery_target_time = '2024-11-22 12:00:00'  # 可选：时间点恢复
# recovery_target_lsn = '0/1234567'  # 可选：LSN恢复
# recovery_target_name = 'backup_point'  # 可选：命名恢复点
EOF

# 4. 创建恢复信号文件
touch /var/lib/postgresql/data/recovery.signal

# 5. 启动PostgreSQL
systemctl start postgresql

# 6. 监控恢复进度
tail -f /var/log/postgresql/postgresql.log
```

### 步骤6: 恢复验证

```sql
-- 1. 检查恢复状态
SELECT pg_is_in_recovery();

-- 2. 验证数据一致性
SELECT
    schemaname,
    tablename,
    n_live_tup
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC
LIMIT 10;

-- 3. 检查恢复点
SELECT
    pg_last_wal_replay_lsn(),
    pg_last_wal_replay_timestamp();

-- 4. 业务数据验证（示例）
SELECT COUNT(*) FROM orders;
SELECT COUNT(*) FROM users;
SELECT MAX(created_at) FROM orders;

-- 5. 完成恢复（如果使用recovery.signal）
-- 恢复完成后，PostgreSQL会自动重命名recovery.signal为recovery.done
```

## 验证清单

- 备份可读、校验通过（hash/大小/目录结构）
- 恢复后系统一致（系统表与业务表计数/抽样对比）
- 监控事件完整（备份时长、WAL 量、错误日志）
- RTO/RPO 达标并留存记录

### 详细验证步骤

```bash
# 1. 备份完整性验证
pg_checksums -D /backup/incremental/20241122_120000 --check
# 输出：Checksum operation completed
# 输出：Files scanned: XXXX
# 输出：Blocks scanned: XXXX
# 输出：Bad checksums: 0

# 2. 备份大小验证
du -sh /backup/base/20241122_020000
du -sh /backup/incremental/20241122_120000
# 增量备份应该明显小于全量备份（通常节省90%+空间）

# 3. WAL文件验证
ls -lh /backup/incremental/20241122_120000/pg_wal/
# 应该包含必要的WAL文件

# 4. 恢复后数据验证
psql -c "SELECT pg_database_size('postgres');"
psql -c "SELECT COUNT(*) FROM pg_stat_user_tables;"
psql -c "SELECT COUNT(*) FROM orders WHERE created_at >= '2024-11-22';"
```

## 自动化脚本

### 全量备份脚本

```bash
#!/bin/bash
# full_backup.sh

BACKUP_BASE="/backup/base"
BACKUP_DIR="${BACKUP_BASE}/$(date +%Y%m%d_%H%M%S)"
LOG_FILE="/var/log/postgresql/backup.log"

echo "$(date): Starting full backup to ${BACKUP_DIR}" >> ${LOG_FILE}

pg_basebackup \
    -D ${BACKUP_DIR} \
    -X stream \
    -P \
    -v \
    -F plain \
    2>&1 | tee -a ${LOG_FILE}

if [ $? -eq 0 ]; then
    # 记录备份LSN
    psql -t -c "SELECT pg_current_wal_lsn();" > ${BACKUP_DIR}/backup_lsn.txt

    # 记录备份元数据
    echo "$(date): Backup completed: ${BACKUP_DIR}" >> ${LOG_FILE}
    echo "Backup size: $(du -sh ${BACKUP_DIR} | cut -f1)" >> ${LOG_FILE}

    # 清理旧备份（保留最近7天）
    find ${BACKUP_BASE} -type d -mtime +7 -exec rm -rf {} \;
else
    echo "$(date): Backup failed!" >> ${LOG_FILE}
    exit 1
fi
```

### 增量备份脚本

```bash
#!/bin/bash
# incremental_backup.sh

BACKUP_BASE="/backup/base"
BACKUP_INCREMENTAL="/backup/incremental"
LATEST_BASE=$(ls -td ${BACKUP_BASE}/*/ | head -1)
BACKUP_DIR="${BACKUP_INCREMENTAL}/$(date +%Y%m%d_%H%M%S)"
LOG_FILE="/var/log/postgresql/backup.log"

if [ -z "${LATEST_BASE}" ]; then
    echo "$(date): No base backup found, running full backup first" >> ${LOG_FILE}
    /usr/local/bin/full_backup.sh
    LATEST_BASE=$(ls -td ${BACKUP_BASE}/*/ | head -1)
fi

echo "$(date): Starting incremental backup to ${BACKUP_DIR}" >> ${LOG_FILE}
echo "$(date): Base backup: ${LATEST_BASE}" >> ${LOG_FILE}

pg_basebackup \
    -D ${BACKUP_DIR} \
    --incremental \
    --incremental-base=${LATEST_BASE} \
    -X stream \
    -P \
    -v \
    -F plain \
    2>&1 | tee -a ${LOG_FILE}

if [ $? -eq 0 ]; then
    echo "$(date): Incremental backup completed: ${BACKUP_DIR}" >> ${LOG_FILE}
    echo "Backup size: $(du -sh ${BACKUP_DIR} | cut -f1)" >> ${LOG_FILE}

    # 清理旧增量备份（保留最近30天）
    find ${BACKUP_INCREMENTAL} -type d -mtime +30 -exec rm -rf {} \;
else
    echo "$(date): Incremental backup failed!" >> ${LOG_FILE}
    exit 1
fi
```

### 恢复脚本

```bash
#!/bin/bash
# restore.sh

BACKUP_PATH=$1
RECOVERY_TIME=$2  # 可选：时间点恢复
DATA_DIR="/var/lib/postgresql/data"

if [ -z "${BACKUP_PATH}" ]; then
    echo "Usage: $0 <backup_path> [recovery_time]"
    exit 1
fi

echo "Stopping PostgreSQL..."
systemctl stop postgresql

echo "Backing up current data directory..."
mv ${DATA_DIR} ${DATA_DIR}.old.$(date +%Y%m%d_%H%M%S)

echo "Restoring from backup: ${BACKUP_PATH}"
cp -r ${BACKUP_PATH}/* ${DATA_DIR}/

echo "Configuring recovery..."
cat > ${DATA_DIR}/postgresql.auto.conf <<EOF
restore_command = 'cp /archive/%f %p'
EOF

if [ -n "${RECOVERY_TIME}" ]; then
    echo "recovery_target_time = '${RECOVERY_TIME}'" >> ${DATA_DIR}/postgresql.auto.conf
fi

touch ${DATA_DIR}/recovery.signal

echo "Starting PostgreSQL..."
systemctl start postgresql

echo "Monitoring recovery..."
tail -f /var/log/postgresql/postgresql.log
```

## 监控与告警

### 备份监控

```sql
-- 1. 检查WAL Summarizer状态
SELECT * FROM pg_stat_wal_summarizer;

-- 2. 检查归档状态
SELECT
    archived_count,
    last_archived_wal,
    last_archived_time,
    failed_count,
    last_failed_wal,
    last_failed_time
FROM pg_stat_archiver;

-- 3. 检查备份目录
SELECT
    pg_size_pretty(pg_database_size(current_database())) as db_size,
    pg_size_pretty(
        (SELECT sum(pg_tablespace_size(spcname)) FROM pg_tablespace)
    ) as total_size;
```

### Prometheus告警规则

```yaml
groups:
  - name: postgresql_backup
    rules:
      - alert: PostgreSQLBackupFailed
        expr: increase(pg_stat_archiver_failed_count[1h]) > 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "PostgreSQL备份失败"
          description: "归档失败次数: {{ $value }}"

      - alert: PostgreSQLBackupLag
        expr: (now() - pg_stat_archiver_last_archived_time) > 1h
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "PostgreSQL备份延迟"
          description: "最后归档时间: {{ $value }}"
```

## 最佳实践

### 备份策略

```bash
# 推荐策略：周全量 + 日增量
# 周一：全量备份
0 2 * * 1 /usr/local/bin/full_backup.sh

# 周二至周日：增量备份
0 2 * * 2-7 /usr/local/bin/incremental_backup.sh

# 清理策略
# 全量备份：保留4周
# 增量备份：保留30天
# WAL归档：保留7天
```

### 恢复演练

```bash
# 每月执行一次恢复演练
# 1. 在测试环境恢复最新备份
# 2. 验证数据完整性
# 3. 测试时间点恢复
# 4. 记录RTO/RPO指标
```

## 故障排查

### 问题1: 增量备份失败

**常见错误和解决方法**:

```bash
# 错误1: could not open file "backup_manifest": No such file or directory
# 原因: 基础备份的manifest文件不存在或损坏

# 解决方法1: 检查manifest文件
ls -lh /backup/base/*/backup_manifest
cat /backup/base/*/backup_manifest | head -20

# 解决方法2: 验证备份完整性
pg_verifybackup -D /backup/base/20241122_020000

# 解决方法3: 重新创建全量备份
pg_basebackup \
    -D /backup/base/$(date +%Y%m%d_%H%M%S) \
    -X stream \
    -P \
    -F plain

# 错误2: WAL summarizer is not running
# 原因: WAL Summarizer未启用或已停止

# 解决方法1: 检查WAL Summarizer状态
psql -c "SELECT * FROM pg_stat_wal_summarizer;"

# 解决方法2: 检查配置
psql -c "SHOW wal_level;"
psql -c "SHOW archive_mode;"

# 解决方法3: 启用WAL Summarizer（PostgreSQL 18默认启用）
# 在postgresql.conf中确保：
# wal_level = replica  # 或 logical
# archive_mode = on

# 错误3: No space left on device
# 原因: 备份目录空间不足

# 解决方法1: 检查磁盘空间
df -h /backup
du -sh /backup/base/*
du -sh /backup/incremental/*

# 解决方法2: 清理旧备份
find /backup/base -type d -mtime +30 -exec rm -rf {} \;
find /backup/incremental -type d -mtime +7 -exec rm -rf {} \;

# 解决方法3: 使用压缩备份
pg_basebackup \
    -D /backup/incremental/$(date +%Y%m%d_%H%M%S) \
    --incremental \
    --incremental-base=/backup/base/20241122_020000 \
    -X stream \
    -F tar \
    -z

# 错误4: could not read incremental backup manifest
# 原因: 增量备份的manifest文件损坏或格式错误

# 解决方法1: 检查manifest文件
cat /backup/incremental/*/backup_manifest | head -50

# 解决方法2: 验证备份
pg_verifybackup -D /backup/incremental/20241122_120000

# 解决方法3: 重新创建增量备份
# 删除损坏的增量备份，重新创建

# 错误5: base backup is too old
# 原因: 基础备份太旧，WAL文件已清理

# 解决方法1: 检查基础备份年龄
ls -lh /backup/base/
psql -c "SELECT pg_current_wal_lsn();"

# 解决方法2: 创建新的基础备份
pg_basebackup \
    -D /backup/base/$(date +%Y%m%d_%H%M%S) \
    -X stream \
    -P \
    -F plain

# 解决方法3: 调整WAL保留策略
# 在postgresql.conf中：
# max_wal_size = 4GB  # 增加WAL保留大小
# min_wal_size = 1GB
```

**诊断脚本**:

```bash
#!/bin/bash
# diagnose_incremental_backup.sh
# 增量备份故障诊断脚本

BASE_BACKUP="${1:-/backup/base/$(ls -td /backup/base/*/ | head -1 | xargs basename)}"
INCREMENTAL_BACKUP="${2:-/backup/incremental/$(ls -td /backup/incremental/*/ | head -1 | xargs basename)}"

echo "=== 增量备份诊断 ==="
echo "基础备份: $BASE_BACKUP"
echo "增量备份: $INCREMENTAL_BACKUP"
echo ""

# 检查1: 基础备份是否存在
echo "1. 检查基础备份..."
if [ -d "$BASE_BACKUP" ]; then
    echo "   ✓ 基础备份目录存在"
    if [ -f "$BASE_BACKUP/backup_manifest" ]; then
        echo "   ✓ backup_manifest文件存在"
        MANIFEST_SIZE=$(stat -f%z "$BASE_BACKUP/backup_manifest" 2>/dev/null || stat -c%s "$BASE_BACKUP/backup_manifest" 2>/dev/null)
        echo "   - manifest大小: $MANIFEST_SIZE 字节"
    else
        echo "   ✗ backup_manifest文件不存在"
    fi
else
    echo "   ✗ 基础备份目录不存在"
fi

# 检查2: WAL Summarizer状态
echo ""
echo "2. 检查WAL Summarizer状态..."
WAL_SUM=$(psql -t -c "SELECT COUNT(*) FROM pg_stat_wal_summarizer;" 2>/dev/null | xargs)
if [ "$WAL_SUM" -gt 0 ]; then
    echo "   ✓ WAL Summarizer正在运行"
    psql -c "SELECT * FROM pg_stat_wal_summarizer;" 2>/dev/null
else
    echo "   ✗ WAL Summarizer未运行"
    echo "   检查配置: wal_level, archive_mode"
fi

# 检查3: 磁盘空间
echo ""
echo "3. 检查磁盘空间..."
df -h /backup | tail -1

# 检查4: 增量备份完整性
echo ""
echo "4. 检查增量备份..."
if [ -d "$INCREMENTAL_BACKUP" ]; then
    echo "   ✓ 增量备份目录存在"
    if [ -f "$INCREMENTAL_BACKUP/backup_manifest" ]; then
        echo "   ✓ backup_manifest文件存在"
        # 验证备份
        pg_verifybackup -D "$INCREMENTAL_BACKUP" 2>&1 | head -20
    else
        echo "   ✗ backup_manifest文件不存在"
    fi
else
    echo "   ✗ 增量备份目录不存在"
fi

# 检查5: PostgreSQL日志
echo ""
echo "5. 检查PostgreSQL日志（最近错误）..."
tail -50 /var/log/postgresql/postgresql.log | grep -i "error\|fail\|backup" | tail -10
```

### 问题2: 恢复时缺少WAL文件

**常见错误和解决方法**:

```bash
# 错误1: could not open WAL file
# 原因: WAL文件不存在或路径错误

# 解决方法1: 检查WAL归档目录
ls -lh /archive/ | head -20
ls -lh /archive/ | grep "$(psql -t -c "SELECT pg_walfile_name(pg_last_wal_replay_lsn());" | xargs)"

# 解决方法2: 检查恢复配置
cat /var/lib/postgresql/data/postgresql.auto.conf | grep restore_command

# 解决方法3: 手动复制缺失的WAL文件
# 查找需要的WAL文件
psql -t -c "SELECT pg_walfile_name(pg_last_wal_replay_lsn());" | xargs -I {} cp /archive/{} /var/lib/postgresql/data/pg_wal/

# 错误2: WAL file is from different database system
# 原因: WAL文件来自不同的数据库实例

# 解决方法1: 检查数据库系统标识符
psql -c "SELECT system_identifier FROM pg_control_system();"
# 与备份的系统标识符对比

# 解决方法2: 确保使用正确的备份和WAL文件
# 不要混用不同实例的备份和WAL文件

# 错误3: requested WAL segment has already been removed
# 原因: 需要的WAL文件已被清理

# 解决方法1: 检查WAL保留策略
psql -c "SHOW max_wal_size;"
psql -c "SHOW min_wal_size;"
psql -c "SELECT * FROM pg_stat_archiver;"

# 解决方法2: 使用更近的基础备份
# 如果WAL文件已被清理，需要使用包含所需WAL的基础备份

# 解决方法3: 从归档恢复WAL文件
# 如果有异地归档，从归档恢复WAL文件

# 错误4: restore_command failed
# 原因: restore_command配置错误或命令执行失败

# 解决方法1: 测试restore_command
# 手动执行restore_command测试
test ! -f /archive/000000010000000000000001 && \
    cp /var/lib/postgresql/data/pg_wal/000000010000000000000001 /archive/000000010000000000000001

# 解决方法2: 检查权限
ls -ld /archive
ls -l /archive/000000010000000000000001

# 解决方法3: 使用绝对路径
# 在postgresql.auto.conf中：
restore_command = 'cp /archive/%f %p'
# 而不是相对路径

# 错误5: timeline mismatch
# 原因: 时间线不匹配

# 解决方法1: 检查时间线
psql -c "SELECT timeline_id FROM pg_control_checkpoint();"

# 解决方法2: 使用正确的时间线
# 在postgresql.auto.conf中：
recovery_target_timeline = 'latest'
# 或指定具体时间线
recovery_target_timeline = '2'
```

**诊断脚本**:

```bash
#!/bin/bash
# diagnose_wal_restore.sh
# WAL恢复故障诊断脚本

PGDATA="${PGDATA:-/var/lib/postgresql/data}"
ARCHIVE_DIR="${ARCHIVE_DIR:-/archive}"

echo "=== WAL恢复诊断 ==="
echo "数据目录: $PGDATA"
echo "归档目录: $ARCHIVE_DIR"
echo ""

# 检查1: 恢复状态
echo "1. 检查恢复状态..."
if [ -f "$PGDATA/recovery.signal" ]; then
    echo "   ✓ 恢复模式已启用"
    RECOVERY_LSN=$(psql -t -c "SELECT pg_last_wal_replay_lsn();" 2>/dev/null | xargs)
    echo "   - 当前恢复LSN: $RECOVERY_LSN"
    if [ -n "$RECOVERY_LSN" ]; then
        WAL_FILE=$(psql -t -c "SELECT pg_walfile_name('$RECOVERY_LSN');" 2>/dev/null | xargs)
        echo "   - 需要的WAL文件: $WAL_FILE"

        # 检查WAL文件是否存在
        if [ -f "$ARCHIVE_DIR/$WAL_FILE" ]; then
            echo "   ✓ WAL文件存在于归档目录"
        else
            echo "   ✗ WAL文件不存在于归档目录"
            echo "   查找相似文件:"
            ls -lh "$ARCHIVE_DIR" | grep "${WAL_FILE:0:8}" | head -5
        fi
    fi
else
    echo "   ✗ 未在恢复模式"
fi

# 检查2: restore_command配置
echo ""
echo "2. 检查restore_command配置..."
RESTORE_CMD=$(grep restore_command "$PGDATA/postgresql.auto.conf" 2>/dev/null | cut -d"'" -f2)
if [ -n "$RESTORE_CMD" ]; then
    echo "   - restore_command: $RESTORE_CMD"
    # 测试命令
    TEST_WAL="000000010000000000000001"
    TEST_CMD=$(echo "$RESTORE_CMD" | sed "s|%f|$TEST_WAL|g" | sed "s|%p|$PGDATA/pg_wal/$TEST_WAL|g")
    echo "   - 测试命令: $TEST_CMD"
else
    echo "   ✗ restore_command未配置"
fi

# 检查3: WAL归档目录
echo ""
echo "3. 检查WAL归档目录..."
if [ -d "$ARCHIVE_DIR" ]; then
    echo "   ✓ 归档目录存在"
    WAL_COUNT=$(find "$ARCHIVE_DIR" -name "*.wal" -o -name "*.gz" | wc -l)
    echo "   - WAL文件数: $WAL_COUNT"
    echo "   - 最新WAL文件:"
    ls -lht "$ARCHIVE_DIR" | head -5
else
    echo "   ✗ 归档目录不存在"
fi

# 检查4: PostgreSQL日志
echo ""
echo "4. 检查PostgreSQL日志（WAL相关错误）..."
if [ -f /var/log/postgresql/postgresql.log ]; then
    tail -100 /var/log/postgresql/postgresql.log | grep -i "wal\|restore\|archive" | tail -10
fi
```

### 问题3: 恢复后数据不一致

**验证步骤**:

```sql
-- 步骤1: 检查恢复点
SELECT
    pg_last_wal_replay_lsn() as replay_lsn,
    pg_last_wal_replay_timestamp() as replay_time,
    pg_is_in_recovery() as in_recovery;

-- 步骤2: 检查数据库大小
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) as db_size
FROM pg_database
WHERE datistemplate = false
ORDER BY pg_database_size(datname) DESC;

-- 步骤3: 检查表数据
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC
LIMIT 20;

-- 步骤4: 检查关键表数据完整性
-- 对比源库和目标库的记录数
SELECT COUNT(*) FROM orders;
SELECT COUNT(*) FROM users;
SELECT COUNT(*) FROM products;

-- 步骤5: 检查数据校验和（如果启用）
SELECT
    schemaname,
    tablename,
    attname,
    checksum
FROM pg_stat_user_tables t
JOIN pg_attribute a ON a.attrelid = t.relid
WHERE t.schemaname = 'public'
AND a.attnum > 0
AND NOT a.attisdropped;
```

**常见不一致问题和解决方法**:

```sql
-- 问题1: 表记录数不匹配
-- 原因: 恢复未完成或部分数据丢失

-- 解决方法1: 检查恢复是否完成
SELECT pg_is_in_recovery();
-- 如果返回true，说明恢复仍在进行

-- 解决方法2: 检查恢复目标
SELECT
    recovery_target_time,
    recovery_target_lsn,
    recovery_target_name
FROM pg_settings
WHERE name LIKE 'recovery_target%';

-- 解决方法3: 重新执行恢复
-- 停止PostgreSQL，重新配置恢复参数，重新启动

-- 问题2: 外键约束失败
-- 原因: 数据恢复顺序问题或数据不完整

-- 解决方法1: 检查外键约束
SELECT
    conname,
    conrelid::regclass,
    confrelid::regclass
FROM pg_constraint
WHERE contype = 'f'
AND NOT convalidated;

-- 解决方法2: 验证外键
ALTER TABLE orders VALIDATE CONSTRAINT orders_user_id_fkey;

-- 解决方法3: 重新加载数据
-- 如果外键验证失败，可能需要重新恢复

-- 问题3: 索引不一致
-- 原因: 索引损坏或未正确重建

-- 解决方法1: 检查索引
SELECT
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY tablename, indexname;

-- 解决方法2: 重建索引
REINDEX TABLE CONCURRENTLY orders;
REINDEX TABLE CONCURRENTLY users;

-- 解决方法3: 检查索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- 问题4: 序列值不匹配
-- 原因: 序列未正确恢复

-- 解决方法1: 检查序列值
SELECT
    schemaname,
    sequencename,
    last_value
FROM pg_sequences
WHERE schemaname = 'public';

-- 解决方法2: 重置序列值
SELECT setval('orders_id_seq', (SELECT MAX(id) FROM orders));

-- 问题5: 统计信息过时
-- 原因: 统计信息未更新

-- 解决方法1: 更新统计信息
ANALYZE;

-- 解决方法2: 检查统计信息更新时间
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY last_analyze DESC NULLS LAST;
```

**数据一致性验证脚本**:

```bash
#!/bin/bash
# verify_restore_consistency.sh
# 恢复后数据一致性验证脚本

SOURCE_DB="${1:-source_db}"
TARGET_DB="${2:-target_db}"
SOURCE_HOST="${3:-localhost}"
TARGET_HOST="${4:-localhost}"

echo "=== 数据一致性验证 ==="
echo "源库: $SOURCE_HOST/$SOURCE_DB"
echo "目标库: $TARGET_HOST/$TARGET_DB"
echo ""

# 检查1: 数据库大小对比
echo "1. 数据库大小对比..."
SOURCE_SIZE=$(psql -h "$SOURCE_HOST" -d "$SOURCE_DB" -t -c "SELECT pg_database_size('$SOURCE_DB');" | xargs)
TARGET_SIZE=$(psql -h "$TARGET_HOST" -d "$TARGET_DB" -t -c "SELECT pg_database_size('$TARGET_DB');" | xargs)
echo "   源库大小: $SOURCE_SIZE 字节"
echo "   目标库大小: $TARGET_SIZE 字节"
SIZE_DIFF=$((SOURCE_SIZE - TARGET_SIZE))
if [ $SIZE_DIFF -lt 0 ]; then
    SIZE_DIFF=$((SIZE_DIFF * -1))
fi
SIZE_DIFF_PCT=$((SIZE_DIFF * 100 / SOURCE_SIZE))
echo "   差异: $SIZE_DIFF 字节 ($SIZE_DIFF_PCT%)"

# 检查2: 表记录数对比
echo ""
echo "2. 表记录数对比..."
psql -h "$SOURCE_HOST" -d "$SOURCE_DB" -t -c "
SELECT tablename FROM pg_tables WHERE schemaname = 'public';
" | while read table; do
    if [ -n "$table" ]; then
        SOURCE_COUNT=$(psql -h "$SOURCE_HOST" -d "$SOURCE_DB" -t -c "SELECT COUNT(*) FROM $table;" | xargs)
        TARGET_COUNT=$(psql -h "$TARGET_HOST" -d "$TARGET_DB" -t -c "SELECT COUNT(*) FROM $table;" | xargs)
        if [ "$SOURCE_COUNT" != "$TARGET_COUNT" ]; then
            echo "   ✗ $table: 源=$SOURCE_COUNT, 目标=$TARGET_COUNT"
        else
            echo "   ✓ $table: $SOURCE_COUNT"
        fi
    fi
done

# 检查3: 关键表数据采样对比
echo ""
echo "3. 关键表数据采样对比..."
for table in orders users products; do
    echo "   检查表: $table"
    SOURCE_SAMPLE=$(psql -h "$SOURCE_HOST" -d "$SOURCE_DB" -t -c "SELECT COUNT(*) FROM $table WHERE id < 1000;" | xargs)
    TARGET_SAMPLE=$(psql -h "$TARGET_HOST" -d "$TARGET_DB" -t -c "SELECT COUNT(*) FROM $table WHERE id < 1000;" | xargs)
    if [ "$SOURCE_SAMPLE" = "$TARGET_SAMPLE" ]; then
        echo "     ✓ 采样数据一致"
    else
        echo "     ✗ 采样数据不一致: 源=$SOURCE_SAMPLE, 目标=$TARGET_SAMPLE"
    fi
done

echo ""
echo "验证完成"
```
