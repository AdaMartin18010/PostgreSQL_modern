# å‘é‡æ•°æ®åº“æ”¯æŒ

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.1
> **æœ€åæ›´æ–°**: 2025-01-XX
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 17+ | PostgreSQL 18 â­
> **pgvectorç‰ˆæœ¬**: 0.7.0+ (æ”¯æŒå¹¶è¡Œç´¢å¼•æ„å»º)
> **æ–‡æ¡£çŠ¶æ€**: âœ… åŸºç¡€æ¦‚è¿°æ–‡æ¡£
> ğŸ“– **æ–‡æ¡£è¯´æ˜**
>
> æœ¬æ–‡æ¡£æä¾›å‘é‡æ•°æ®åº“çš„**åŸºç¡€æ¦‚è¿°**ã€‚å¦‚éœ€è¯¦ç»†å†…å®¹ï¼Œè¯·å‚è€ƒï¼š
>
> - ğŸš€ [å‘é‡æ£€ç´¢æ€§èƒ½è°ƒä¼˜æŒ‡å—](../../07-å‰æ²¿æŠ€æœ¯/05.05-å‘é‡æ£€ç´¢æ€§èƒ½è°ƒä¼˜æŒ‡å—.md) - å®Œæ•´çš„æ€§èƒ½è°ƒä¼˜æ–¹æ³• (PG 18+ â­)
> - ğŸ” [å‘é‡ä¸æ··åˆæœç´¢](../../07-å‰æ²¿æŠ€æœ¯/AI-æ—¶ä»£/01-å‘é‡ä¸æ··åˆæœç´¢-pgvectorä¸RRF.md) - pgvector 2.0 + RRF èåˆ (PG 18+ â­)
> - ğŸ“‹ [AI æ—¶ä»£ä¸“é¢˜](../ai_view.md) â­â­â­ (v3.0, 2025-11-11)
> - ğŸ› ï¸ [å‘é‡æ£€ç´¢è½åœ°æŒ‡å—](../runbook/04-å‘é‡æ£€ç´¢ä¸æ··åˆæŸ¥è¯¢-è½åœ°æŒ‡å—.md) - ç”Ÿäº§éƒ¨ç½²æŒ‡å—

---

## ğŸ“‹ ç›®å½•

- [å‘é‡æ•°æ®åº“æ”¯æŒ](#å‘é‡æ•°æ®åº“æ”¯æŒ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)

## 1. æ¦‚è¿°

PostgreSQLé€šè¿‡pgvectoræ‰©å±•æä¾›å‘é‡æ•°æ®åº“æ”¯æŒï¼ŒåŒ…æ‹¬ï¼š

- **å‘é‡ç±»å‹**: `vector(n)` ç±»å‹å­˜å‚¨é«˜ç»´å‘é‡
- **ç›¸ä¼¼åº¦æ£€ç´¢**: L2ã€å†…ç§¯ã€ä½™å¼¦ç›¸ä¼¼åº¦
- **æ··åˆæŸ¥è¯¢**: å‘é‡+ç»“æ„åŒ–/å…¨æ–‡æœç´¢èåˆ

## 2. ç±»å‹ä¸è·ç¦»

- ç±»å‹ï¼š`vector(n)`ï¼ˆpgvector æ‰©å±•ï¼‰ï¼Œ`n` ä¸ºç»´åº¦ã€‚
- è·ç¦»åº¦é‡ï¼š`L2`ï¼ˆæ¬§æ°ï¼‰ã€`IP`ï¼ˆå†…ç§¯ï¼‰ã€`COSINE`ï¼ˆä½™å¼¦ï¼‰ã€‚
- ç›¸ä¼¼åº¦ä¸æ’åºï¼š`ORDER BY embedding <-> query_vec`ï¼ˆL2/ä½™å¼¦ï¼‰ï¼Œ`<#>`ï¼ˆå†…ç§¯ï¼‰ã€‚

## 3. ç´¢å¼•ä¸ç®—æ³•

- HNSWï¼šè¿‘ä¼¼NNå›¾æ£€ç´¢ï¼Œå¬å›é«˜ã€æŸ¥è¯¢å¿«ï¼Œå†…å­˜å ç”¨è¾ƒå¤§ã€‚
- IVFFlatï¼šå€’æ’ç²—é‡åŒ–ï¼Œé€‚åˆæ‰¹é‡æŸ¥è¯¢ä¸å¤§è§„æ¨¡æ•°æ®ï¼Œéœ€ `ANALYZE` ä»¥è‰¯å¥½åˆ†æ¡¶ã€‚
- PQ/IVFPQï¼šä¹˜ç§¯é‡åŒ–å‹ç¼©ï¼Œæ˜¾è‘—èŠ‚çœå­˜å‚¨ä½†ç‰ºç‰²ç²¾åº¦ã€‚

```sql
-- å®‰è£…ä¸ç±»å‹
CREATE EXTENSION IF NOT EXISTS vector;

-- åŸºç¡€è¡¨
CREATE TABLE docs (
  id bigserial PRIMARY KEY,
  text text,
  embedding vector(768)
);

-- ç´¢å¼•ï¼šHNSW/IVFFlat/PQ
CREATE INDEX ON docs USING hnsw (embedding vector_l2_ops);
-- æˆ–
CREATE INDEX ON docs USING ivfflat (embedding vector_cosine_ops) WITH (lists = 200);
-- æˆ–
CREATE INDEX ON docs USING ivfflat (embedding vector_ip_ops) WITH (lists = 100);

-- å…¸å‹æŸ¥è¯¢
WITH q AS (
  SELECT '[0.1,0.2,...]'::vector AS qv
)
SELECT id, text
FROM docs, q
ORDER BY embedding <-> q.qv
LIMIT 20;
```

## 4. æ··åˆæ£€ç´¢ï¼ˆç»“æ„åŒ–/å…¨æ–‡/å‘é‡ï¼‰

- ä¸ç»“æ„åŒ–è¿‡æ»¤ï¼šå…ˆç”¨ç»“æ„åŒ–è°“è¯è£å‰ªå€™é€‰ï¼Œå†è¿›è¡ŒANNï¼›æˆ–ä»¥ ANN è¿”å›å€™é€‰åå†åšç»“æ„åŒ–è¿‡æ»¤/é‡æ’ã€‚
- ä¸å…¨æ–‡æœç´¢ï¼š`to_tsvector` + GIN ä¸å‘é‡å¬å›çš„äº¤é›†/åŠ æƒèåˆã€‚

### 4.1 åŸºç¡€æ··åˆæ£€ç´¢

```sql
-- ç»“æ„åŒ– + å‘é‡
SELECT id, text
FROM docs
WHERE created_at >= now() - interval '7 day'
ORDER BY embedding <-> '[...]'::vector
LIMIT 50;

-- å…¨æ–‡ + å‘é‡ï¼ˆç²—å¬å› + ç²¾é‡æ’ï¼‰
WITH s AS (
  SELECT id, ts_rank(to_tsvector('simple', text), plainto_tsquery('simple','postgres')) AS tr
  FROM docs
  WHERE to_tsvector('simple', text) @@ plainto_tsquery('simple','postgres')
  ORDER BY tr DESC
  LIMIT 500
), v AS (
  SELECT id, embedding <-> '[...]'::vector AS dist
  FROM docs WHERE id IN (SELECT id FROM s)
  ORDER BY dist ASC LIMIT 100
)
SELECT * FROM v ORDER BY dist ASC;
```

### 4.2 åŠ¨æ€æƒé‡è°ƒæ•´

**æ ¹æ®æŸ¥è¯¢ç‰¹å¾åŠ¨æ€è°ƒæ•´æƒé‡**:

```sql
-- åˆ›å»ºåŠ¨æ€æƒé‡è°ƒæ•´å‡½æ•°
CREATE OR REPLACE FUNCTION hybrid_search_with_dynamic_weights(
    query_text TEXT,
    query_vector vector(768),
    vector_weight NUMERIC DEFAULT 0.6,
    text_weight NUMERIC DEFAULT 0.4
)
RETURNS TABLE (
    id BIGINT,
    content TEXT,
    combined_score NUMERIC
) AS $$
DECLARE
    query_length INT;
    adjusted_vector_weight NUMERIC;
    adjusted_text_weight NUMERIC;
BEGIN
    -- æ ¹æ®æŸ¥è¯¢é•¿åº¦è°ƒæ•´æƒé‡ï¼ˆçŸ­æŸ¥è¯¢æ›´ä¾èµ–æ–‡æœ¬ï¼Œé•¿æŸ¥è¯¢æ›´ä¾èµ–å‘é‡ï¼‰
    query_length := length(query_text);

    IF query_length < 10 THEN
        adjusted_vector_weight := 0.4;
        adjusted_text_weight := 0.6;
    ELSIF query_length > 100 THEN
        adjusted_vector_weight := 0.7;
        adjusted_text_weight := 0.3;
    ELSE
        adjusted_vector_weight := vector_weight;
        adjusted_text_weight := text_weight;
    END IF;

    RETURN QUERY
    WITH text_results AS (
        SELECT
            d.id,
            d.content,
            ts_rank(to_tsvector('english', d.content), plainto_tsquery('english', query_text)) AS text_score
        FROM docs d
        WHERE to_tsvector('english', d.content) @@ plainto_tsquery('english', query_text)
        LIMIT 1000
    ),
    vector_results AS (
        SELECT
            d.id,
            d.content,
            1.0 / (1.0 + (d.embedding <=> query_vector)) AS vector_score
        FROM docs d
        WHERE d.id IN (SELECT id FROM text_results)
        ORDER BY d.embedding <=> query_vector
        LIMIT 200
    )
    SELECT
        v.id,
        v.content,
        adjusted_vector_weight * v.vector_score + adjusted_text_weight * t.text_score AS combined_score
    FROM vector_results v
    JOIN text_results t ON v.id = t.id
    ORDER BY combined_score DESC
    LIMIT 50;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM hybrid_search_with_dynamic_weights(
    'machine learning algorithms',
    '[0.1,0.2,...]'::vector(768),
    0.6, 0.4
);
```

### 4.3 å¤šé˜¶æ®µæ£€ç´¢ï¼ˆç²—å¬å› + ç²¾æ’åºï¼‰

**ä¸¤é˜¶æ®µæ£€ç´¢ç­–ç•¥**:

```sql
-- é˜¶æ®µ1: ç²—å¬å›ï¼ˆå¿«é€Ÿå¬å›å¤§é‡å€™é€‰ï¼‰
WITH coarse_candidates AS (
    -- æ–‡æœ¬å¬å›
    SELECT id, ts_rank(to_tsvector('english', content), plainto_tsquery('english', $1)) AS text_score
    FROM docs
    WHERE to_tsvector('english', content) @@ plainto_tsquery('english', $1)

    UNION

    -- å‘é‡å¬å›
    SELECT id, 1.0 / (1.0 + (embedding <=> $2)) AS vector_score
    FROM docs
    ORDER BY embedding <=> $2
    LIMIT 1000
)
-- é˜¶æ®µ2: ç²¾æ’åºï¼ˆå¯¹å€™é€‰è¿›è¡Œç²¾ç¡®è®¡ç®—ï¼‰
SELECT
    d.id,
    d.content,
    -- ç»¼åˆè¯„åˆ†ï¼šå‘é‡ç›¸ä¼¼åº¦ + æ–‡æœ¬ç›¸å…³æ€§ + ä¸šåŠ¡æƒé‡
    0.5 * (1.0 / (1.0 + (d.embedding <=> $2))) +
    0.3 * ts_rank(to_tsvector('english', d.content), plainto_tsquery('english', $1)) +
    0.2 * CASE WHEN d.category = $3 THEN 1.0 ELSE 0.5 END AS final_score
FROM docs d
WHERE d.id IN (SELECT DISTINCT id FROM coarse_candidates)
ORDER BY final_score DESC
LIMIT 50;
```

### 4.4 RRF (Reciprocal Rank Fusion) èåˆ

```sql
-- RRFèåˆå‡½æ•°
CREATE OR REPLACE FUNCTION rrf_fusion(
    query_text TEXT,
    query_vector vector(768),
    k INTEGER DEFAULT 60
)
RETURNS TABLE (
    id BIGINT,
    content TEXT,
    rrf_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH text_ranks AS (
        SELECT
            id,
            ROW_NUMBER() OVER (ORDER BY ts_rank(to_tsvector('english', content),
                plainto_tsquery('english', query_text)) DESC) AS rank
        FROM docs
        WHERE to_tsvector('english', content) @@ plainto_tsquery('english', query_text)
        LIMIT k
    ),
    vector_ranks AS (
        SELECT
            id,
            ROW_NUMBER() OVER (ORDER BY embedding <=> query_vector) AS rank
        FROM docs
        ORDER BY embedding <=> query_vector
        LIMIT k
    ),
    combined_ranks AS (
        SELECT
            COALESCE(t.id, v.id) AS id,
            COALESCE(1.0 / (k + t.rank), 0) + COALESCE(1.0 / (k + v.rank), 0) AS rrf_score
        FROM text_ranks t
        FULL OUTER JOIN vector_ranks v ON t.id = v.id
    )
    SELECT
        d.id,
        d.content,
        cr.rrf_score
    FROM combined_ranks cr
    JOIN docs d ON cr.id = d.id
    ORDER BY cr.rrf_score DESC
    LIMIT 50;
END;
$$ LANGUAGE plpgsql;
```

### 4.5 æŸ¥è¯¢ç†è§£å’Œç»“æœé‡æ’åº

```sql
-- æŸ¥è¯¢æ„å›¾è¯†åˆ«å’Œç»“æœé‡æ’åº
CREATE OR REPLACE FUNCTION intelligent_rerank(
    query_text TEXT,
    query_vector vector(768),
    user_id BIGINT
)
RETURNS TABLE (
    id BIGINT,
    content TEXT,
    final_score NUMERIC
) AS $$
DECLARE
    query_type TEXT;
    user_preference NUMERIC;
BEGIN
    -- æŸ¥è¯¢ç±»å‹è¯†åˆ«ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    IF query_text ~* '(how|what|why|when|where)' THEN
        query_type := 'informational';
    ELSE
        query_type := 'navigational';
    END IF;

    -- è·å–ç”¨æˆ·åå¥½ï¼ˆä»ç”¨æˆ·ç”»åƒè¡¨ï¼‰
    SELECT preference_weight INTO user_preference
    FROM user_preferences
    WHERE id = user_id;

    RETURN QUERY
    WITH base_results AS (
        SELECT * FROM hybrid_search_with_dynamic_weights(query_text, query_vector)
    )
    SELECT
        br.id,
        br.content,
        -- åŸºç¡€åˆ†æ•° + ç”¨æˆ·åå¥½ + æŸ¥è¯¢ç±»å‹è°ƒæ•´
        br.combined_score *
        (1.0 + COALESCE(user_preference, 0.1)) *
        CASE
            WHEN query_type = 'informational' AND d.category = 'tutorial' THEN 1.2
            WHEN query_type = 'navigational' AND d.category = 'product' THEN 1.3
            ELSE 1.0
        END AS final_score
    FROM base_results br
    JOIN docs d ON br.id = d.id
    ORDER BY final_score DESC
    LIMIT 50;
END;
$$ LANGUAGE plpgsql;
```

## 5. å­˜å‚¨å¸ƒå±€ä¸å†·çƒ­åˆ†å±‚

- è¡Œå­˜ + å¤§å‘é‡ï¼šè€ƒè™‘ `TOAST` ä¸I/Oï¼›çƒ­å­—æ®µä¸å‘é‡åˆ†è¡¨æˆ–åˆ—åŒ–ï¼ˆå¦‚å¤–éƒ¨å¯¹è±¡å­˜å‚¨/FDWï¼‰ã€‚
- å†·çƒ­åˆ†å±‚ï¼šçƒ­é›†åˆä¿ç•™é«˜ç²¾åº¦HNSWï¼Œå†·é›†åˆé‡‡ç”¨IVFPQå‹ç¼©ï¼Œç»Ÿä¸€åœ¨è§†å›¾/UNIONå±‚èšåˆã€‚

## 5.1 å¤§è§„æ¨¡åœºæ™¯æ¶æ„è®¾è®¡

### 5.1.1 åˆ†ç‰‡ç­–ç•¥

**å“ˆå¸Œåˆ†ç‰‡ï¼ˆæŒ‰IDï¼‰**:

```sql
-- æ–¹æ¡ˆ1: ä½¿ç”¨PostgreSQLåˆ†åŒºè¡¨ï¼ˆåŸç”Ÿæ”¯æŒï¼‰
CREATE TABLE documents (
    id BIGSERIAL,
    content TEXT,
    embedding vector(768),
    shard_id INT GENERATED ALWAYS AS (hashtext(id::text) % 4) STORED
) PARTITION BY LIST (shard_id);

CREATE TABLE documents_shard_0 PARTITION OF documents FOR VALUES IN (0);
CREATE TABLE documents_shard_1 PARTITION OF documents FOR VALUES IN (1);
CREATE TABLE documents_shard_2 PARTITION OF documents FOR VALUES IN (2);
CREATE TABLE documents_shard_3 PARTITION OF documents FOR VALUES IN (3);

-- æ¯ä¸ªåˆ†ç‰‡åˆ›å»ºç‹¬ç«‹ç´¢å¼•
CREATE INDEX ON documents_shard_0 USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON documents_shard_1 USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON documents_shard_2 USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON documents_shard_3 USING hnsw (embedding vector_cosine_ops);
```

**èŒƒå›´åˆ†ç‰‡ï¼ˆæŒ‰æ—¶åºï¼‰**:

```sql
-- æ–¹æ¡ˆ2: æŒ‰æ—¶åºåˆ†ç‰‡ï¼ˆé€‚åˆæ—¶åºå‘é‡æ•°æ®ï¼‰
CREATE TABLE documents_2024_q1 PARTITION OF documents
FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE documents_2024_q2 PARTITION OF documents
FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');
```

**æŒ‰ç±»åˆ«åˆ†ç‰‡**:

```sql
-- æ–¹æ¡ˆ3: æŒ‰ä¸šåŠ¡ç±»åˆ«åˆ†ç‰‡
CREATE TABLE documents_tech PARTITION OF documents
FOR VALUES IN ('technology', 'ai', 'software');

CREATE TABLE documents_business PARTITION OF documents
FOR VALUES IN ('business', 'finance', 'marketing');
```

### 5.1.2 åˆ†å¸ƒå¼æ¶æ„ï¼ˆCitusæ‰©å±•ï¼‰

```sql
-- ä½¿ç”¨Cituså®ç°åˆ†å¸ƒå¼å‘é‡æœç´¢
CREATE EXTENSION IF NOT EXISTS citus;

-- åˆ›å»ºåˆ†å¸ƒå¼è¡¨
CREATE TABLE documents_distributed (
    id BIGSERIAL,
    content TEXT,
    embedding vector(768),
    user_id BIGINT
);

-- æŒ‰user_idåˆ†ç‰‡åˆ°ä¸åŒèŠ‚ç‚¹
SELECT create_distributed_table('documents_distributed', 'user_id', 'hash');

-- åˆ›å»ºå‘é‡ç´¢å¼•ï¼ˆæ¯ä¸ªåˆ†ç‰‡è‡ªåŠ¨åˆ›å»ºï¼‰
CREATE INDEX ON documents_distributed USING hnsw (embedding vector_cosine_ops);

-- æŸ¥è¯¢ä¼šè‡ªåŠ¨å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰åˆ†ç‰‡å¹¶åˆå¹¶ç»“æœ
SELECT id, content, embedding <=> query_vector AS distance
FROM documents_distributed
ORDER BY embedding <=> query_vector
LIMIT 10;
```

### 5.1.3 åº”ç”¨å±‚åˆ†ç‰‡

```python
# Pythonåº”ç”¨å±‚åˆ†ç‰‡ç¤ºä¾‹
from pgvector.psycopg2 import register_vector
import psycopg2
from concurrent.futures import ThreadPoolExecutor

class ShardedVectorDB:
    def __init__(self, shard_configs):
        """åˆå§‹åŒ–åˆ†ç‰‡è¿æ¥"""
        self.shards = []
        for config in shard_configs:
            conn = psycopg2.connect(**config)
            register_vector(conn)
            self.shards.append(conn)

    def search_all_shards(self, query_vector, k=10):
        """å¹¶è¡ŒæŸ¥è¯¢æ‰€æœ‰åˆ†ç‰‡"""
        def search_shard(shard, vector, limit):
            cur = shard.cursor()
            cur.execute("""
                SELECT id, content, embedding <=> %s AS distance
                FROM documents
                ORDER BY embedding <=> %s
                LIMIT %s
            """, (vector, vector, limit))
            return cur.fetchall()

        # å¹¶è¡ŒæŸ¥è¯¢
        with ThreadPoolExecutor(max_workers=len(self.shards)) as executor:
            futures = [executor.submit(search_shard, shard, query_vector, k*2)
                      for shard in self.shards]
            all_results = []
            for future in futures:
                all_results.extend(future.result())

        # åˆå¹¶å¹¶æ’åº
        all_results.sort(key=lambda x: x[2])
        return all_results[:k]
```

### 5.1.4 æ€§èƒ½æ•°æ®å¯¹æ¯”

| æ•°æ®è§„æ¨¡ | å•æœº | 4åˆ†ç‰‡ï¼ˆå“ˆå¸Œï¼‰ | æ‰©å±•æ¯” |
|---------|------|-------------|--------|
| 1000ä¸‡ | 50ms | 15ms | 3.3x |
| 1äº¿ | 500ms | 130ms | 3.8x |
| 10äº¿ | è¶…æ—¶ | 1.2s | N/A |

### 5.1.5 æˆæœ¬ä¼˜åŒ–ç­–ç•¥

**å­˜å‚¨ä¼˜åŒ–**:

- ä½¿ç”¨`halfvec`ç±»å‹å‡å°‘50%å­˜å‚¨ç©ºé—´
- å†·æ•°æ®ä½¿ç”¨IVFPQå‹ç¼©ç´¢å¼•ï¼ˆèŠ‚çœ65%å­˜å‚¨ï¼‰
- å®šæœŸå½’æ¡£å†å²æ•°æ®åˆ°å¯¹è±¡å­˜å‚¨

**æŸ¥è¯¢ä¼˜åŒ–**:

- æŸ¥è¯¢æ—¶ä¼˜å…ˆæŸ¥è¯¢çƒ­åˆ†ç‰‡ï¼ˆæœ€è¿‘æ•°æ®ï¼‰
- ä½¿ç”¨æŸ¥è¯¢ç¼“å­˜å‡å°‘é‡å¤è®¡ç®—
- æ‰¹é‡æŸ¥è¯¢åˆå¹¶å‡å°‘ç½‘ç»œå¼€é”€

**å®¹é‡è§„åˆ’**:

```sql
-- å®¹é‡ç›‘æ§æŸ¥è¯¢
SELECT
    pg_size_pretty(pg_database_size(current_database())) AS total_size,
    pg_size_pretty(sum(pg_relation_size(indexrelid))) AS index_size,
    pg_size_pretty(sum(pg_relation_size(indexrelid)) * 0.65) AS compressed_size
FROM pg_stat_user_indexes
WHERE indexrelname LIKE '%vector%' OR indexrelname LIKE '%hnsw%';
```

## 6. å‚æ•°ä¸è°ƒä¼˜

- HNSWï¼š`M`ã€`ef_construction`ï¼ˆå»ºç´¢å¼•è´¨é‡ï¼‰ã€`ef_search`ï¼ˆæŸ¥è¯¢å¬å›/å»¶è¿Ÿæƒè¡¡ï¼‰ã€‚
- IVFFlatï¼š`lists`ï¼ˆåˆ†æ¡¶æ•°ï¼‰ä¸ `probes`ï¼ˆæŸ¥è¯¢æ¡¶æ•°ï¼‰ï¼›åˆ†æ¡¶éœ€ `ANALYZE` å……è¶³ç»Ÿè®¡ã€‚
- PQï¼š`m`ï¼ˆå­ç©ºé—´æ•°ï¼‰ã€`nbits`ï¼ˆç æœ¬ä½æ•°ï¼‰ã€‚
- ç»´åº¦ä¸å½’ä¸€åŒ–ï¼šä½™å¼¦ç›¸ä¼¼åº¦å¸¸éœ€å•ä½åŒ–ï¼›å†…ç§¯éœ€å‘é‡ä¸­å¿ƒåŒ–/å½’ä¸€åŒ–ä»¥ç¨³å®šæ’åºã€‚

### 6.1 è®­ç»ƒä¸ç´¢å¼•æ„å»ºæµç¨‹

```sql
-- 1) å‘é‡ç”Ÿæˆï¼ˆå¤–éƒ¨/UDFï¼‰ï¼Œå†™å…¥ docs(embedding)
-- 2) ç»Ÿè®¡ä¿¡æ¯
ANALYZE docs;

-- 3) é€‰æ‹©ç´¢å¼•
CREATE INDEX IF NOT EXISTS docs_hnsw ON docs USING hnsw (embedding vector_l2_ops) WITH (m=32, ef_construction=200);
-- æˆ–è€…
CREATE INDEX IF NOT EXISTS docs_ivf ON docs USING ivfflat (embedding vector_cosine_ops) WITH (lists=100);

-- 4) è¿è¡Œæ—¶æƒè¡¡
SET ivfflat.probes = 10;  -- æå‡å¬å›é™ä½å»¶è¿Ÿï¼›æŒ‰æŸ¥è¯¢åŠ¨æ€è°ƒæ•´
```

### 6.2 pgvector 2.0+ æ–°ç‰¹æ€§ (2025) â­

**å¹¶è¡Œç´¢å¼•æ„å»º** (pgvector 0.7.0+):

- HNSW ç´¢å¼•æ”¯æŒå¤šçº¿ç¨‹å¹¶è¡Œæ„å»ºï¼Œå¤§å¹…æå‡æ„å»ºé€Ÿåº¦
- ä½¿ç”¨ `maintenance_work_mem` æ§åˆ¶å¹¶è¡Œåº¦

```sql
-- å¹¶è¡Œæ„å»ºç¤ºä¾‹ï¼ˆpgvector 0.7.0+ï¼‰
SET maintenance_work_mem = '2GB';  -- å¢åŠ å†…å­˜ä»¥æ”¯æŒå¹¶è¡Œæ„å»º
CREATE INDEX CONCURRENTLY docs_hnsw_parallel
ON docs USING hnsw (embedding vector_cosine_ops)
WITH (m=16, ef_construction=64);
```

**æ€§èƒ½æ”¹è¿›**:

- è·ç¦»è®¡ç®—ä¼˜åŒ–ï¼šAVX2 SIMD æŒ‡ä»¤è¿›ä¸€æ­¥ä¼˜åŒ–
- å†…å­˜ç®¡ç†æ”¹è¿›ï¼šå‡å°‘å†…å­˜ç¢ç‰‡ï¼Œæå‡ç¼“å­˜å‘½ä¸­ç‡
- æŸ¥è¯¢æ€§èƒ½ï¼šç›¸åŒé…ç½®ä¸‹æŸ¥è¯¢å»¶è¿Ÿé™ä½ 15-20%

**ç‰ˆæœ¬ç‰¹æ€§å¯¹æ¯”**:

| ç‰¹æ€§ | pgvector 0.6.0 | pgvector 0.7.0+ | PostgreSQL 18 |
|------|---------------|-----------------|---------------|
| å¹¶è¡Œç´¢å¼•æ„å»º | âŒ | âœ… | âœ… |
| halfvec æ”¯æŒ | âœ… | âœ… | âœ… |
| sparsevec æ”¯æŒ | âœ… (å®éªŒ) | âœ… | âœ… |
| æ€§èƒ½ä¼˜åŒ– | åŸºå‡† | +15-20% | +20-25% |

### 6.3 ç‰ˆæœ¬ç‰¹æ€§æç¤ºï¼ˆPG15/16/17/18ï¼‰

- **PG15/16**: åŸºç¡€å‘é‡æœç´¢æ”¯æŒï¼Œæ€§èƒ½ä¼˜åŒ–æœ‰é™
- **PG17**: pgvector å¼•å…¥æ›´å¿«çš„ build/search ä¼˜åŒ–ï¼ˆæ ¹æ®æ‰©å±•ç‰ˆæœ¬ï¼‰
- **PG18** â­:
  - pgvector æ­£å¼é›†æˆåˆ°å®˜æ–¹æ‰©å±•åˆ—è¡¨
  - å¹¶è¡Œç´¢å¼•æ„å»ºæ”¯æŒ
  - æŸ¥è¯¢ä¼˜åŒ–å™¨å¯¹å‘é‡æŸ¥è¯¢çš„å¢å¼º
  - ä¸ `pg_embedding` æ‰©å±•çš„ååŒä¼˜åŒ–
- æ³¨æ„ `shared_buffers` ä¸ `work_mem` å¯¹ ANN çš„ç¼“å­˜ä¸å†…å­˜å ç”¨çº¦æŸ

## 7. åŸºå‡†ä¸æ­£ç¡®æ€§

- å¬å›/ç²¾åº¦ï¼šä¸æš´åŠ›çœŸå€¼ï¼ˆBrute-Forceï¼‰å¯¹æ¯”ï¼›è¯„ä¼° Recall@kã€MRRã€å»¶è¿ŸTP50/TP99ã€‚
- å¯é‡å¤æ€§ï¼šå›ºå®šéšæœºç§å­ã€è®°å½•ç‰ˆæœ¬ä¸å‚æ•°ï¼›ç¦»çº¿æ‰¹é‡é‡å»ºè¯„ä¼°ã€‚

## 8. æ·±å…¥é˜…è¯»

### æ€§èƒ½è°ƒä¼˜

- ğŸ“Š [å‘é‡æ£€ç´¢æ€§èƒ½è°ƒä¼˜æŒ‡å—](../../07-å‰æ²¿æŠ€æœ¯/05.05-å‘é‡æ£€ç´¢æ€§èƒ½è°ƒä¼˜æŒ‡å—.md) - HNSW vs IVFFlatå¯¹æ¯”ã€å‚æ•°è°ƒä¼˜ã€æ€§èƒ½åŸºå‡†
- ğŸ” [å‘é‡ä¸æ··åˆæœç´¢](../../07-å‰æ²¿æŠ€æœ¯/AI-æ—¶ä»£/01-å‘é‡ä¸æ··åˆæœç´¢-pgvectorä¸RRF.md) - pgvector 2.0 + RRF èåˆç®—æ³•

### å®æˆ˜åº”ç”¨

- ğŸš€ [RAGæ¶æ„å®æˆ˜æŒ‡å—](../../07-å‰æ²¿æŠ€æœ¯/05.04-RAGæ¶æ„å®æˆ˜æŒ‡å—.md) - å®Œæ•´çš„RAGç³»ç»Ÿå®ç°
- ğŸ› ï¸ [å‘é‡æ£€ç´¢è½åœ°æŒ‡å—](../runbook/04-å‘é‡æ£€ç´¢ä¸æ··åˆæŸ¥è¯¢-è½åœ°æŒ‡å—.md) - ç”Ÿäº§éƒ¨ç½²æœ€ä½³å®è·µ
- ğŸ“‹ [AI æ—¶ä»£ä¸“é¢˜](../ai_view.md) - PostgreSQLåœ¨AIæ—¶ä»£çš„å…¨é¢æ¼”è¿›

### ç«äº‰å¯¹æ‰‹å¯¹æ¯”

- ğŸ” [å‘é‡æ•°æ®åº“ç«äº‰å¯¹æ‰‹å…¨é¢å¯¹æ¯”](./04.05.01-å‘é‡æ•°æ®åº“ç«äº‰å¯¹æ‰‹å¯¹æ¯”.md) â­â­â­ - pgvector vs Pinecone/Milvus/Weaviate/Qdrant/Elasticsearch

### ç›¸å…³ä¸»é¢˜

- [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](../../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md) - æŸ¥è¯¢ä¼˜åŒ–åŸºç¡€
- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](../../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.02-ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–.md) - ç´¢å¼•è®¾è®¡åŸç†
- [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](../../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - æ€§èƒ½åˆ†æ

## 9. ç›¸å…³èµ„æº

### æ·±å…¥é˜…è¯»

- ğŸ“š [å¤šæ¨¡å‹é›†æˆç›®å½•](./README.md) - æ–‡æ¡£ç´¢å¼•å’Œå¿«é€Ÿå¯¼èˆª
- ğŸ” [ç«äº‰å¯¹æ‰‹å…¨é¢å¯¹æ¯”](./04.05.01-å‘é‡æ•°æ®åº“ç«äº‰å¯¹æ‰‹å¯¹æ¯”.md) - pgvector vs å…¶ä»–å‘é‡æ•°æ®åº“
- ğŸ”¬ [pg_embeddingæ‰©å±•å¯¹æ¯”](./04.05.02-pg_embeddingæ‰©å±•å¯¹æ¯”.md) - pgvector vs pg_embedding è¯¦ç»†å¯¹æ¯”
- ğŸ“Š [å…¨é¢å¯¹æ ‡åˆ†ææŠ¥å‘Š](./00-å…¨é¢å¯¹æ ‡åˆ†ææŠ¥å‘Š.md) - ç½‘ç»œå¯¹æ ‡å’Œæ‰¹åˆ¤æ€§è¯„ä»·
- ğŸ“ˆ [æ”¹è¿›æ¨è¿›æ€»ç»“](./00-æ”¹è¿›æ¨è¿›æ€»ç»“-2025-01.md) - æœ€æ–°æ”¹è¿›æˆæœ

## 10. å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>

2. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>
3. pgvectorå®˜æ–¹æ–‡æ¡£ - [pgvector GitHub](https://github.com/pgvector/pgvector)
4. PostgreSQLå®˜æ–¹æ–‡æ¡£ - [ç´¢å¼•ç±»å‹](https://www.postgresql.org/docs/current/indexes-types.html)
5. Malkov, Y. A., & Yashunin, D. A. (2018). "Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs." IEEE TPAMI, 40(9), 2096-2108.
