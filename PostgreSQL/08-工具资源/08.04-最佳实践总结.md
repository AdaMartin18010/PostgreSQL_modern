# PostgreSQL最佳实践总结：从建模到运维的完整指南

> **版本**: v1.0
> **最后更新**: 2025-01-15
> **难度**: ⭐⭐⭐⭐
> **应用场景**: 数据库设计、性能优化、运维管理、安全加固

---

## 📑 目录

- [PostgreSQL最佳实践总结：从建模到运维的完整指南](#postgresql最佳实践总结从建模到运维的完整指南)
  - [📑 目录](#-目录)
  - [一、概述](#一概述)
    - [1.1 最佳实践目标](#11-最佳实践目标)
    - [1.2 适用范围](#12-适用范围)
    - [1.3 实践原则](#13-实践原则)
  - [二、数据建模最佳实践](#二数据建模最佳实践)
    - [2.1 数据类型选择](#21-数据类型选择)
    - [2.2 约束设计](#22-约束设计)
    - [2.3 分区设计](#23-分区设计)
    - [2.4 索引设计](#24-索引设计)
  - [三、查询优化最佳实践](#三查询优化最佳实践)
    - [3.1 查询编写规范](#31-查询编写规范)
    - [3.2 执行计划分析](#32-执行计划分析)
    - [3.3 统计信息管理](#33-统计信息管理)
    - [3.4 窗口函数优化](#34-窗口函数优化)
  - [四、并发控制最佳实践](#四并发控制最佳实践)
    - [4.1 事务设计](#41-事务设计)
    - [4.2 锁管理](#42-锁管理)
    - [4.3 热点处理](#43-热点处理)
    - [4.4 隔离级别选择](#44-隔离级别选择)
  - [五、运维管理最佳实践](#五运维管理最佳实践)
    - [5.1 自动化维护](#51-自动化维护)
    - [5.2 监控体系](#52-监控体系)
    - [5.3 备份恢复](#53-备份恢复)
    - [5.4 变更管理](#54-变更管理)
  - [六、安全加固最佳实践](#六安全加固最佳实践)
    - [6.1 访问控制](#61-访问控制)
    - [6.2 数据加密](#62-数据加密)
    - [6.3 审计日志](#63-审计日志)
  - [七、知识矩阵对比](#七知识矩阵对比)
    - [7.1 数据类型选择对比](#71-数据类型选择对比)
    - [7.2 索引策略对比](#72-索引策略对比)
    - [7.3 隔离级别对比](#73-隔离级别对比)
  - [八、实践案例](#八实践案例)
    - [8.1 高并发系统设计](#81-高并发系统设计)
    - [8.2 大数据量系统设计](#82-大数据量系统设计)
    - [8.3 高可用系统设计](#83-高可用系统设计)
  - [九、常见问题与解决方案](#九常见问题与解决方案)
    - [9.1 性能问题](#91-性能问题)
    - [9.2 数据问题](#92-数据问题)
    - [9.3 运维问题](#93-运维问题)
  - [十、参考资源](#十参考资源)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 网络资源](#102-网络资源)
    - [10.3 相关文档](#103-相关文档)

---

## 一、概述

### 1.1 最佳实践目标

PostgreSQL最佳实践总结旨在提供从数据建模到运维管理的完整指南，帮助开发者和运维人员构建高性能、高可用、安全的PostgreSQL系统。

**核心目标**：

- **性能优化**：提升数据库查询和写入性能
- **可靠性保证**：确保系统稳定可靠运行
- **安全性保障**：保护数据安全和访问控制
- **可维护性**：建立可维护的运维体系

### 1.2 适用范围

本指南适用于：

- **数据库设计**：新系统设计和现有系统优化
- **性能调优**：查询优化和系统调优
- **运维管理**：日常运维和故障处理
- **安全加固**：安全策略和访问控制

### 1.3 实践原则

**最佳实践核心原则**：

1. **性能优先**：在保证功能的前提下优化性能
2. **安全第一**：安全是系统设计的第一要务
3. **可维护性**：设计要考虑长期维护成本
4. **可扩展性**：设计要考虑未来扩展需求

---

## 二、数据建模最佳实践

### 2.1 数据类型选择

**选择恰当的数据类型**：

```sql
-- ✅ 正确：使用合适的数据类型
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    age SMALLINT CHECK (age >= 0 AND age <= 150),
    balance NUMERIC(15, 2) NOT NULL DEFAULT 0,
    status user_status_enum DEFAULT 'active',
    tags TEXT[],
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ❌ 错误：使用不合适的数据类型
CREATE TABLE users_bad (
    id INTEGER,  -- 可能溢出
    email TEXT,  -- 没有长度限制
    age INTEGER,  -- 范围过大
    balance REAL,  -- 精度问题
    created_at TIMESTAMP  -- 没有时区信息
);
```

**数据类型选择指南**：

| 场景 | 推荐类型 | 原因 |
|------|---------|------|
| **整数ID** | BIGSERIAL | 避免溢出 |
| **金额/精确数值** | NUMERIC | 避免精度丢失 |
| **时间戳** | TIMESTAMPTZ | 支持时区 |
| **枚举值** | ENUM | 类型安全 |
| **数组数据** | ARRAY | 原生支持 |
| **JSON数据** | JSONB | 高效查询 |
| **范围值** | RANGE | 原生支持范围操作 |

**范围类型使用**：

```sql
-- 使用范围类型存储时间段
CREATE TABLE reservations (
    id BIGSERIAL PRIMARY KEY,
    room_id INTEGER,
    period TSTZRANGE NOT NULL,
    EXCLUDE USING GIST (room_id WITH =, period WITH &&)  -- 排他约束
);

-- 查询重叠时间段
SELECT * FROM reservations
WHERE period && '[2025-01-15 10:00, 2025-01-15 12:00]'::TSTZRANGE;
```

**JSONB使用**：

```sql
-- 使用JSONB存储灵活属性
CREATE TABLE products (
    id BIGSERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    attributes JSONB DEFAULT '{}'::jsonb
);

-- 创建GIN索引支持JSONB查询
CREATE INDEX idx_products_attributes ON products USING GIN (attributes);

-- JSONB查询
SELECT * FROM products
WHERE attributes @> '{"color": "red", "size": "large"}'::jsonb;
```

### 2.2 约束设计

**主外键与唯一约束**：

```sql
-- ✅ 完善的主外键设计
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
    order_no VARCHAR(50) UNIQUE NOT NULL,
    total_amount NUMERIC(15, 2) NOT NULL CHECK (total_amount >= 0),
    status order_status_enum NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ✅ 排他约束（防止时间重叠）
CREATE TABLE bookings (
    id BIGSERIAL PRIMARY KEY,
    resource_id INTEGER NOT NULL,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ NOT NULL,
    EXCLUDE USING GIST (
        resource_id WITH =,
        TSTZRANGE(start_time, end_time) WITH &&
    )
);
```

**约束设计原则**：

- **主键**：每个表必须有主键
- **外键**：建立表间关系，保证数据完整性
- **唯一约束**：防止重复数据
- **检查约束**：保证数据有效性
- **排他约束**：防止逻辑冲突（如时间重叠）

### 2.3 分区设计

**分区策略**：

```sql
-- ✅ 按时间分区（推荐用于时序数据）
CREATE TABLE events (
    id BIGSERIAL,
    event_type TEXT NOT NULL,
    event_data JSONB,
    created_at TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- 创建月度分区
CREATE TABLE events_2025_01 PARTITION OF events
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE events_2025_02 PARTITION OF events
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- ✅ 按范围分区（推荐用于数值范围）
CREATE TABLE sales (
    id BIGSERIAL,
    region_id INTEGER NOT NULL,
    amount NUMERIC(15, 2),
    sale_date DATE NOT NULL,
    PRIMARY KEY (id, region_id)
) PARTITION BY RANGE (region_id);

CREATE TABLE sales_region_1_10 PARTITION OF sales
    FOR VALUES FROM (1) TO (11);
```

**分区设计原则**：

- **分区键选择**：选择查询常用的列作为分区键
- **分区数量**：避免过多分区（建议 < 1000）
- **分区裁剪**：确保查询能利用分区裁剪
- **自动管理**：使用函数自动创建和删除分区

### 2.4 索引设计

**高频路径冗余列 + 表达式索引**：

```sql
-- ✅ 覆盖索引（包含查询所需的所有列）
CREATE INDEX idx_orders_user_status_covering ON orders(user_id, status)
INCLUDE (order_no, total_amount, created_at);

-- ✅ 表达式索引（优化函数查询）
CREATE INDEX idx_users_email_lower ON users(LOWER(email));

-- ✅ 部分索引（只索引活跃数据）
CREATE INDEX idx_orders_active ON orders(user_id, created_at DESC)
WHERE status = 'active';

-- ✅ 复合索引（优化多列查询）
CREATE INDEX idx_orders_user_date_status ON orders(user_id, created_at DESC, status);
```

**索引设计原则**：

- **覆盖索引**：包含查询所需的所有列
- **表达式索引**：优化函数和表达式查询
- **部分索引**：只索引需要的数据
- **复合索引**：优化多列查询
- **避免过度索引**：索引会增加写入成本

---

## 三、查询优化最佳实践

### 3.1 查询编写规范

**避免SELECT ***：

```sql
-- ❌ 错误：使用SELECT *
SELECT * FROM users WHERE id = 1;

-- ✅ 正确：只选择需要的列
SELECT id, name, email FROM users WHERE id = 1;
```

**使用LIMIT限制结果集**：

```sql
-- ✅ 使用LIMIT减少数据传输
SELECT id, name, email
FROM users
WHERE status = 'active'
ORDER BY created_at DESC
LIMIT 100;
```

**避免在WHERE子句中使用函数**：

```sql
-- ❌ 错误：函数阻止索引使用
SELECT * FROM users WHERE LOWER(email) = 'user@example.com';

-- ✅ 正确：使用表达式索引
CREATE INDEX idx_users_email_lower ON users(LOWER(email));
SELECT * FROM users WHERE LOWER(email) = 'user@example.com';
```

### 3.2 执行计划分析

**使用EXPLAIN ANALYZE**：

```sql
-- ✅ 完整的执行计划分析
EXPLAIN (ANALYZE, BUFFERS, VERBOSE, COSTS, TIMING)
SELECT u.name, o.order_no, o.total_amount
FROM users u
JOIN orders o ON o.user_id = u.id
WHERE u.status = 'active'
  AND o.created_at >= NOW() - INTERVAL '30 days'
ORDER BY o.created_at DESC
LIMIT 100;
```

**执行计划分析要点**：

- **执行时间**：关注实际执行时间
- **行数估算**：检查估算行数与实际行数是否接近
- **索引使用**：确认使用了合适的索引
- **连接顺序**：检查连接顺序是否合理
- **缓冲区使用**：检查缓冲区命中率

### 3.3 统计信息管理

**保持统计信息新鲜**：

```sql
-- ✅ 定期更新统计信息
ANALYZE users;
ANALYZE orders;

-- ✅ 更新特定表的统计信息
ANALYZE VERBOSE users;

-- ✅ 设置自动ANALYZE
ALTER TABLE users SET (autovacuum_analyze_scale_factor = 0.05);
```

**统计信息管理原则**：

- **自动ANALYZE**：启用autovacuum自动更新统计信息
- **手动ANALYZE**：大数据变更后手动更新
- **统计信息准确性**：确保统计信息准确反映数据分布

### 3.4 窗口函数优化

**窗口函数排序唯一性**：

```sql
-- ❌ 错误：排序不唯一可能导致结果不稳定
SELECT
    user_id,
    order_no,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at) AS rn
FROM orders;

-- ✅ 正确：确保排序唯一性
SELECT
    user_id,
    order_no,
    ROW_NUMBER() OVER (
        PARTITION BY user_id
        ORDER BY created_at, id  -- 添加唯一列确保排序唯一
    ) AS rn
FROM orders;
```

---

## 四、并发控制最佳实践

### 4.1 事务设计

**短事务、幂等重试**：

```sql
-- ✅ 短事务设计
BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    INSERT INTO transactions (account_id, amount) VALUES (1, -100);
COMMIT;

-- ✅ 幂等重试机制
CREATE OR REPLACE FUNCTION transfer_money(
    p_transaction_id VARCHAR(50),
    p_from_account_id BIGINT,
    p_to_account_id BIGINT,
    p_amount NUMERIC
)
RETURNS void AS $$
BEGIN
    -- 检查幂等性
    IF EXISTS (SELECT 1 FROM transactions WHERE transaction_id = p_transaction_id) THEN
        RETURN;  -- 已处理，直接返回
    END IF;

    -- 执行转账
    UPDATE accounts SET balance = balance - p_amount WHERE id = p_from_account_id;
    UPDATE accounts SET balance = balance + p_amount WHERE id = p_to_account_id;
    INSERT INTO transactions (transaction_id, from_account_id, to_account_id, amount)
    VALUES (p_transaction_id, p_from_account_id, p_to_account_id, p_amount);
END;
$$ LANGUAGE plpgsql;
```

**避免长时间持锁**：

```sql
-- ❌ 错误：长时间持锁
BEGIN;
    -- 复杂计算（不涉及数据库）
    PERFORM complex_calculation();
    UPDATE accounts SET balance = balance + 100 WHERE id = 1;
COMMIT;

-- ✅ 正确：先计算，后更新
DECLARE
    v_result NUMERIC;
BEGIN
    -- 在事务外计算
    v_result := complex_calculation();

    -- 短事务更新
    BEGIN;
        UPDATE accounts SET balance = balance + v_result WHERE id = 1;
    COMMIT;
END;
```

### 4.2 锁管理

**谨慎使用SKIP LOCKED**：

```sql
-- ✅ 使用SKIP LOCKED处理队列
SELECT * FROM job_queue
WHERE status = 'pending'
ORDER BY priority DESC, created_at
FOR UPDATE SKIP LOCKED
LIMIT 1;

-- ⚠️ 注意事项：
-- 1. 配合监控使用
-- 2. 确保不会遗漏任务
-- 3. 处理死锁情况
```

**锁监控**：

```sql
-- 查看当前锁信息
SELECT
    locktype,
    relation::regclass,
    mode,
    granted,
    pid,
    query
FROM pg_locks l
JOIN pg_stat_activity a ON a.pid = l.pid
WHERE NOT granted;

-- 查看等待锁的查询
SELECT
    blocked_locks.pid AS blocked_pid,
    blocking_locks.pid AS blocking_pid,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query
FROM pg_locks blocked_locks
JOIN pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted
  AND blocking_locks.granted;
```

### 4.3 热点处理

**热点拆分**：

```sql
-- ✅ 热点账户拆分
CREATE TABLE accounts (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    shard_id INTEGER NOT NULL,  -- 分片ID
    balance NUMERIC(15, 2) NOT NULL,
    UNIQUE(user_id, shard_id)
) PARTITION BY LIST (shard_id);

-- 创建多个分片
CREATE TABLE accounts_shard_0 PARTITION OF accounts FOR VALUES IN (0);
CREATE TABLE accounts_shard_1 PARTITION OF accounts FOR VALUES IN (1);
CREATE TABLE accounts_shard_2 PARTITION OF accounts FOR VALUES IN (2);
```

**队列化处理**：

```sql
-- ✅ 使用队列处理热点写入
CREATE TABLE write_queue (
    id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation JSONB NOT NULL,
    status TEXT DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 后台处理队列
CREATE OR REPLACE FUNCTION process_write_queue()
RETURNS void AS $$
DECLARE
    v_record RECORD;
BEGIN
    FOR v_record IN
        SELECT * FROM write_queue
        WHERE status = 'pending'
        ORDER BY created_at
        FOR UPDATE SKIP LOCKED
        LIMIT 100
    LOOP
        -- 处理写入操作
        PERFORM execute_operation(v_record.operation);

        -- 更新状态
        UPDATE write_queue SET status = 'completed' WHERE id = v_record.id;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 4.4 隔离级别选择

**需要可串行化时优先使用SSI**：

```sql
-- ✅ 使用SSI（Serializable Snapshot Isolation）
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN;
    -- 复杂事务
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- ⚠️ 注意事项：
-- 1. SSI可能导致序列化错误，需要重试
-- 2. 监控序列化失败率
-- 3. 对于简单事务，READ COMMITTED通常足够
```

**隔离级别选择指南**：

| 场景 | 推荐隔离级别 | 原因 |
|------|------------|------|
| **一般事务** | READ COMMITTED | 性能好，满足大多数需求 |
| **需要可重复读** | REPEATABLE READ | 避免幻读 |
| **需要最高一致性** | SERIALIZABLE | 保证可串行化 |
| **只读查询** | READ COMMITTED | 性能最优 |

---

## 五、运维管理最佳实践

### 5.1 自动化维护

**自动化VACUUM/ANALYZE**：

```sql
-- ✅ 配置自动VACUUM
ALTER TABLE users SET (
    autovacuum_vacuum_scale_factor = 0.1,
    autovacuum_analyze_scale_factor = 0.05,
    autovacuum_vacuum_cost_delay = 10ms
);

-- ✅ 手动VACUUM（必要时）
VACUUM ANALYZE users;

-- ✅ 并发VACUUM（PostgreSQL 13+）
VACUUM (ANALYZE, VERBOSE) users;
```

**VACUUM配置原则**：

- **自动VACUUM**：启用autovacuum自动维护
- **参数调优**：根据数据变更频率调整参数
- **监控VACUUM**：监控VACUUM执行情况
- **定期维护**：定期执行VACUUM FULL（谨慎使用）

### 5.2 监控体系

**关键监控指标**：

```sql
-- 1. 连接数监控
SELECT
    COUNT(*) AS total_connections,
    COUNT(*) FILTER (WHERE state = 'active') AS active_connections,
    COUNT(*) FILTER (WHERE state = 'idle') AS idle_connections,
    COUNT(*) FILTER (WHERE state = 'idle in transaction') AS idle_in_transaction
FROM pg_stat_activity;

-- 2. 缓存命中率
SELECT
    sum(heap_blks_read) AS heap_read,
    sum(heap_blks_hit) AS heap_hit,
    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) AS cache_hit_ratio
FROM pg_statio_user_tables;

-- 3. WAL监控
SELECT
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) AS replication_lag
FROM pg_stat_replication;

-- 4. 检查点监控
SELECT
    checkpoints_timed,
    checkpoints_req,
    checkpoint_write_time,
    checkpoint_sync_time
FROM pg_stat_bgwriter;

-- 5. Autovacuum监控
SELECT
    schemaname,
    tablename,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    n_dead_tup,
    n_live_tup
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;
```

**监控告警阈值**：

| 指标 | 警告阈值 | 严重阈值 | 说明 |
|------|---------|---------|------|
| **连接数** | 80% max_connections | 90% max_connections | 接近最大连接数 |
| **缓存命中率** | < 95% | < 90% | 缓存命中率低 |
| **WAL延迟** | > 1GB | > 10GB | 复制延迟 |
| **死元组比例** | > 20% | > 50% | 需要VACUUM |
| **长事务** | > 1分钟 | > 5分钟 | 长时间运行的事务 |

### 5.3 备份恢复

**备份策略：全量 + WAL归档**：

```bash
# 1. 全量备份
pg_basebackup -D /backup/basebackup -Ft -z -P

# 2. WAL归档配置（postgresql.conf）
wal_level = replica
archive_mode = on
archive_command = 'cp %p /backup/wal/%f'

# 3. 定期备份脚本
#!/bin/bash
# backup.sh
BACKUP_DIR="/backup/$(date +%Y%m%d)"
mkdir -p $BACKUP_DIR

# 全量备份
pg_basebackup -D $BACKUP_DIR/basebackup -Ft -z -P

# 清理旧备份（保留30天）
find /backup -type d -mtime +30 -exec rm -rf {} \;
```

**恢复演练**：

```bash
# 1. 恢复全量备份
pg_ctl stop
rm -rf $PGDATA/*
tar -xzf /backup/basebackup/base.tar.gz -C $PGDATA

# 2. 配置恢复（postgresql.conf）
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2025-01-15 12:00:00'

# 3. 启动恢复
pg_ctl start
```

### 5.4 变更管理

**版本与参数变更流程**：

```sql
-- ✅ 变更前检查
-- 1. 检查当前配置
SHOW all;

-- 2. 检查参数影响
SELECT name, setting, unit, context
FROM pg_settings
WHERE name IN ('shared_buffers', 'work_mem', 'maintenance_work_mem');

-- 3. 预生产验证
-- 在测试环境验证变更效果

-- ✅ 变更执行
-- 1. 修改配置文件
ALTER SYSTEM SET shared_buffers = '4GB';

-- 2. 重新加载配置（无需重启）
SELECT pg_reload_conf();

-- 3. 验证变更
SHOW shared_buffers;
```

**变更管理原则**：

- **灰度验证**：先在测试环境验证
- **逐步推进**：分阶段推进变更
- **回滚准备**：准备回滚方案
- **监控验证**：变更后监控系统状态

---

## 六、安全加固最佳实践

### 6.1 访问控制

**RLS与最小权限**：

```sql
-- ✅ 启用RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- ✅ 创建RLS策略
CREATE POLICY user_access_policy ON users
    FOR ALL
    TO app_user
    USING (user_id = current_setting('app.user_id')::BIGINT);

-- ✅ 最小权限原则
-- 创建只读用户
CREATE USER readonly_user WITH PASSWORD 'password';
GRANT CONNECT ON DATABASE mydb TO readonly_user;
GRANT USAGE ON SCHEMA public TO readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_user;

-- 创建应用用户（只允许特定操作）
CREATE USER app_user WITH PASSWORD 'password';
GRANT CONNECT ON DATABASE mydb TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE ON users TO app_user;
GRANT SELECT ON orders TO app_user;
```

### 6.2 数据加密

**传输加密**：

```conf
# postgresql.conf
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file = 'server.key'

# pg_hba.conf
hostssl    all    all    0.0.0.0/0    md5
```

**静态加密**：

```sql
-- ✅ 使用pgcrypto扩展加密敏感数据
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255),
    password_hash TEXT,  -- 存储哈希值，不存储明文
    credit_card_encrypted BYTEA  -- 加密存储
);

-- 加密数据
INSERT INTO users (email, credit_card_encrypted)
VALUES (
    'user@example.com',
    pgp_sym_encrypt('1234-5678-9012-3456', 'encryption_key')
);

-- 解密数据
SELECT email, pgp_sym_decrypt(credit_card_encrypted, 'encryption_key')
FROM users WHERE id = 1;
```

**敏感数据脱敏**：

```sql
-- ✅ 创建脱敏视图
CREATE VIEW users_masked AS
SELECT
    id,
    email,
    SUBSTRING(email FROM 1 FOR 3) || '***' AS email_masked,
    '***' AS password_hash,
    created_at
FROM users;
```

### 6.3 审计日志

**审计与告警留痕**：

```sql
-- ✅ 启用审计日志
ALTER SYSTEM SET log_statement = 'all';
ALTER SYSTEM SET log_min_duration_statement = 1000;  -- 记录超过1秒的查询
SELECT pg_reload_conf();

-- ✅ 创建审计表
CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    username TEXT NOT NULL,
    operation_type TEXT NOT NULL,
    table_name TEXT,
    old_values JSONB,
    new_values JSONB,
    query_text TEXT,
    ip_address INET,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ✅ 审计触发器
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (
        username, operation_type, table_name,
        old_values, new_values, query_text
    ) VALUES (
        current_user,
        TG_OP,
        TG_TABLE_NAME,
        CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN to_jsonb(NEW) ELSE NULL END,
        current_query()
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- 应用审计触发器
CREATE TRIGGER audit_users
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW EXECUTE FUNCTION audit_trigger();
```

---

## 七、知识矩阵对比

### 7.1 数据类型选择对比

| 场景 | 推荐类型 | 替代方案 | 选择原因 |
|------|---------|---------|---------|
| **整数ID** | BIGSERIAL | INTEGER | 避免溢出 |
| **金额** | NUMERIC | REAL/DOUBLE | 精度要求 |
| **时间戳** | TIMESTAMPTZ | TIMESTAMP | 时区支持 |
| **枚举** | ENUM | VARCHAR | 类型安全 |
| **数组** | ARRAY | JSONB | 原生支持 |
| **JSON** | JSONB | JSON | 查询性能 |
| **范围** | RANGE | 两个字段 | 原生操作 |

### 7.2 索引策略对比

| 场景 | 推荐索引 | 性能提升 | 存储成本 |
|------|---------|---------|---------|
| **单列查询** | B-Tree | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **全文搜索** | GIN | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **数组查询** | GIN | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **JSONB查询** | GIN | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **范围查询** | GiST | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **时序数据** | BRIN | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **覆盖查询** | INCLUDE | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

### 7.3 隔离级别对比

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 推荐场景 |
|---------|------|-----------|------|------|---------|
| **READ UNCOMMITTED** | ❌ | ❌ | ❌ | ⭐⭐⭐⭐⭐ | PostgreSQL不支持 |
| **READ COMMITTED** | ✅ | ❌ | ❌ | ⭐⭐⭐⭐⭐ | 默认，大多数场景 |
| **REPEATABLE READ** | ✅ | ✅ | ❌ | ⭐⭐⭐⭐ | 需要可重复读 |
| **SERIALIZABLE** | ✅ | ✅ | ✅ | ⭐⭐⭐ | 最高一致性要求 |

---

## 八、实践案例

### 8.1 高并发系统设计

**场景**：电商订单系统，支持高并发下单

**设计要点**：

```sql
-- 1. 表设计
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    order_no VARCHAR(50) UNIQUE NOT NULL,
    user_id BIGINT NOT NULL,
    total_amount NUMERIC(15, 2) NOT NULL,
    status order_status_enum NOT NULL DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- 2. 索引设计
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_orders_order_no ON orders(order_no);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);

-- 3. 连接池配置
-- max_connections = 200
-- shared_buffers = 4GB
-- work_mem = 16MB

-- 4. 事务设计（短事务）
BEGIN;
    INSERT INTO orders (order_no, user_id, total_amount) VALUES (...);
    UPDATE inventory SET stock = stock - 1 WHERE product_id = ...;
COMMIT;
```

### 8.2 大数据量系统设计

**场景**：日志分析系统，每天产生TB级数据

**设计要点**：

```sql
-- 1. 分区设计
CREATE TABLE logs (
    id BIGSERIAL,
    log_level TEXT,
    message TEXT,
    created_at TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- 2. BRIN索引
CREATE INDEX idx_logs_created_at ON logs USING BRIN (created_at)
WITH (pages_per_range = 128);

-- 3. 压缩策略
ALTER TABLE logs_2024_01 SET (
    toast_tuple_target = 128,
    fillfactor = 100
);

-- 4. 归档策略
-- 定期将旧分区移动到归档存储
```

### 8.3 高可用系统设计

**场景**：金融系统，要求99.99%可用性

**设计要点**：

```sql
-- 1. 主从复制
-- 主库配置
wal_level = replica
max_wal_senders = 3
wal_keep_size = 1GB

-- 从库配置
hot_standby = on
primary_conninfo = 'host=master port=5432 user=repl'

-- 2. 自动故障转移
-- 使用Patroni或pg_auto_failover

-- 3. 备份策略
-- 全量备份：每天
-- WAL归档：实时
-- 备份保留：30天

-- 4. 监控告警
-- 连接数、复制延迟、磁盘空间等
```

---

## 九、常见问题与解决方案

### 9.1 性能问题

**问题1：查询慢**:

**解决方案**：

- 检查执行计划
- 创建合适的索引
- 优化查询语句
- 更新统计信息

**问题2：连接数过多**:

**解决方案**：

- 使用连接池（pgBouncer）
- 优化应用连接管理
- 增加max_connections（谨慎）

**问题3：锁等待**:

**解决方案**：

- 缩短事务时间
- 优化锁粒度
- 使用SKIP LOCKED
- 避免长事务

### 9.2 数据问题

**问题1：数据不一致**:

**解决方案**：

- 使用事务保证一致性
- 添加约束检查
- 定期数据校验

**问题2：数据丢失**:

**解决方案**：

- 完善备份策略
- 启用WAL归档
- 定期恢复演练

### 9.3 运维问题

**问题1：VACUUM不及时**:

**解决方案**：

- 调整autovacuum参数
- 手动执行VACUUM
- 监控死元组数量

**问题2：磁盘空间不足**:

**解决方案**：

- 定期清理旧数据
- 压缩历史数据
- 扩展存储空间

---

## 十、参考资源

### 10.1 官方文档

- [PostgreSQL官方文档](https://www.postgresql.org/docs/)
- [PostgreSQL性能调优](https://www.postgresql.org/docs/current/performance-tips.html)
- [PostgreSQL运维指南](https://www.postgresql.org/docs/current/admin.html)

### 10.2 网络资源

- [PostgreSQL最佳实践](https://wiki.postgresql.org/wiki/Don%27t_Do_This)
- [高性能PostgreSQL实战](https://www.postgresql.org/docs/current/high-availability.html)
- [PostgreSQL安全指南](https://www.postgresql.org/docs/current/security.html)

### 10.3 相关文档

- `04-部署运维/04.04-监控与诊断.md`
- `04-部署运维/04.05-备份与恢复.md`
- `01-核心基础/01.04-事务管理与ACID特性.md`
- `01-核心基础/01.05-并发控制与MVCC机制.md`

---

**维护者**: Data-Science Team
**最后更新**: 2025-01-15
**版本**: 1.0
