# PostgreSQLæ•°æ®è´¨é‡ç®¡ç†å®Œæ•´æŒ‡å—

> **ç‰ˆæœ¬**: v1.1
> **æœ€åæ›´æ–°**: 2025-11-22
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­â­
> **åº”ç”¨åœºæ™¯**: æ•°æ®è´¨é‡ã€æ•°æ®æ²»ç†ã€æ•°æ®æ¸…æ´—ã€æ•°æ®éªŒè¯ã€æ•°æ®ç›‘æ§

---

## ğŸ“‹ ç›®å½•

- [PostgreSQLæ•°æ®è´¨é‡ç®¡ç†å®Œæ•´æŒ‡å—](#postgresqlæ•°æ®è´¨é‡ç®¡ç†å®Œæ•´æŒ‡å—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 æ•°æ®è´¨é‡æ¦‚å¿µ](#11-æ•°æ®è´¨é‡æ¦‚å¿µ)
    - [1.2 æ•°æ®è´¨é‡ç»´åº¦](#12-æ•°æ®è´¨é‡ç»´åº¦)
    - [1.3 PostgreSQLæ•°æ®è´¨é‡ä¼˜åŠ¿](#13-postgresqlæ•°æ®è´¨é‡ä¼˜åŠ¿)
    - [1.4 ç‰ˆæœ¬è¦æ±‚](#14-ç‰ˆæœ¬è¦æ±‚)
  - [äºŒã€æ•°æ®è´¨é‡ç»´åº¦](#äºŒæ•°æ®è´¨é‡ç»´åº¦)
    - [2.1 å®Œæ•´æ€§ï¼ˆCompletenessï¼‰](#21-å®Œæ•´æ€§completeness)
    - [2.2 å‡†ç¡®æ€§ï¼ˆAccuracyï¼‰](#22-å‡†ç¡®æ€§accuracy)
    - [2.3 ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰](#23-ä¸€è‡´æ€§consistency)
    - [2.4 åŠæ—¶æ€§ï¼ˆTimelinessï¼‰](#24-åŠæ—¶æ€§timeliness)
    - [2.5 æœ‰æ•ˆæ€§ï¼ˆValidityï¼‰](#25-æœ‰æ•ˆæ€§validity)
    - [2.6 å”¯ä¸€æ€§ï¼ˆUniquenessï¼‰](#26-å”¯ä¸€æ€§uniqueness)
  - [ä¸‰ã€æ•°æ®è´¨é‡æ£€æµ‹](#ä¸‰æ•°æ®è´¨é‡æ£€æµ‹)
    - [3.1 å®Œæ•´æ€§æ£€æµ‹](#31-å®Œæ•´æ€§æ£€æµ‹)
    - [3.2 å‡†ç¡®æ€§æ£€æµ‹](#32-å‡†ç¡®æ€§æ£€æµ‹)
    - [3.3 ä¸€è‡´æ€§æ£€æµ‹](#33-ä¸€è‡´æ€§æ£€æµ‹)
    - [3.4 æœ‰æ•ˆæ€§æ£€æµ‹](#34-æœ‰æ•ˆæ€§æ£€æµ‹)
  - [å››ã€æ•°æ®æ¸…æ´—](#å››æ•°æ®æ¸…æ´—)
    - [4.1 ç¼ºå¤±å€¼å¤„ç†](#41-ç¼ºå¤±å€¼å¤„ç†)
    - [4.2 å¼‚å¸¸å€¼å¤„ç†](#42-å¼‚å¸¸å€¼å¤„ç†)
    - [4.3 é‡å¤æ•°æ®å¤„ç†](#43-é‡å¤æ•°æ®å¤„ç†)
    - [4.4 æ ¼å¼æ ‡å‡†åŒ–](#44-æ ¼å¼æ ‡å‡†åŒ–)
  - [äº”ã€æ•°æ®è´¨é‡ç›‘æ§](#äº”æ•°æ®è´¨é‡ç›‘æ§)
    - [5.1 è´¨é‡æŒ‡æ ‡ç›‘æ§](#51-è´¨é‡æŒ‡æ ‡ç›‘æ§)
    - [5.2 è´¨é‡æŠ¥å‘Šç”Ÿæˆ](#52-è´¨é‡æŠ¥å‘Šç”Ÿæˆ)
    - [5.3 è´¨é‡å‘Šè­¦](#53-è´¨é‡å‘Šè­¦)
  - [å…­ã€æ•°æ®è´¨é‡å·¥å…·](#å…­æ•°æ®è´¨é‡å·¥å…·)
    - [6.1 å†…ç½®å·¥å…·](#61-å†…ç½®å·¥å…·)
    - [6.2 è‡ªå®šä¹‰å‡½æ•°](#62-è‡ªå®šä¹‰å‡½æ•°)
    - [6.3 å¤–éƒ¨å·¥å…·é›†æˆ](#63-å¤–éƒ¨å·¥å…·é›†æˆ)
  - [å…­ã€AIè¾…åŠ©æ•°æ®è´¨é‡ç®¡ç† ğŸ†•](#å…­aiè¾…åŠ©æ•°æ®è´¨é‡ç®¡ç†-)
    - [6.4 AIè¾…åŠ©å¼‚å¸¸æ£€æµ‹](#64-aiè¾…åŠ©å¼‚å¸¸æ£€æµ‹)
    - [6.5 è‡ªåŠ¨åŒ–æ•°æ®è´¨é‡è§„åˆ™ç”Ÿæˆ](#65-è‡ªåŠ¨åŒ–æ•°æ®è´¨é‡è§„åˆ™ç”Ÿæˆ)
    - [6.6 æ•°æ®è´¨é‡å¯è§£é‡Šæ€§](#66-æ•°æ®è´¨é‡å¯è§£é‡Šæ€§)
  - [ä¸ƒã€å®è·µæ¡ˆä¾‹](#ä¸ƒå®è·µæ¡ˆä¾‹)
    - [7.1 æ•°æ®è´¨é‡æ£€æŸ¥æµç¨‹](#71-æ•°æ®è´¨é‡æ£€æŸ¥æµç¨‹)
    - [7.2 è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—](#72-è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—)
    - [7.3 æ•°æ®è´¨é‡æŠ¥å‘Š](#73-æ•°æ®è´¨é‡æŠ¥å‘Š)
  - [ä¹ã€æœ€ä½³å®è·µ](#ä¹æœ€ä½³å®è·µ)
  - [åã€å‚è€ƒèµ„æº](#åå‚è€ƒèµ„æº)
    - [9.1 å®˜æ–¹æ–‡æ¡£](#91-å®˜æ–¹æ–‡æ¡£)
    - [9.2 ç›¸å…³æ–‡æ¡£](#92-ç›¸å…³æ–‡æ¡£)
    - [9.3 å¤–éƒ¨èµ„æº](#93-å¤–éƒ¨èµ„æº)
  - [åä¸€ã€äº¤å‰å¼•ç”¨](#åä¸€äº¤å‰å¼•ç”¨)
    - [ç›¸å…³æ–‡æ¡£](#ç›¸å…³æ–‡æ¡£)
    - [å¤–éƒ¨èµ„æº](#å¤–éƒ¨èµ„æº)

---

## ä¸€ã€æ¦‚è¿°

### 1.1 æ•°æ®è´¨é‡æ¦‚å¿µ

**æ•°æ®è´¨é‡**æ˜¯æŒ‡æ•°æ®æ»¡è¶³ç‰¹å®šç”¨é€”çš„ç¨‹åº¦ï¼ŒåŒ…æ‹¬æ•°æ®çš„å‡†ç¡®æ€§ã€å®Œæ•´æ€§ã€ä¸€è‡´æ€§ã€åŠæ—¶æ€§ç­‰ç‰¹å¾ã€‚

**æ•°æ®è´¨é‡çš„é‡è¦æ€§**ï¼š

- **å†³ç­–æ”¯æŒ**ï¼šé«˜è´¨é‡æ•°æ®æ”¯æŒå‡†ç¡®å†³ç­–
- **ä¸šåŠ¡ä»·å€¼**ï¼šæ•°æ®è´¨é‡ç›´æ¥å½±å“ä¸šåŠ¡ä»·å€¼
- **åˆè§„è¦æ±‚**ï¼šæ»¡è¶³æ³•è§„å’Œåˆè§„è¦æ±‚
- **æˆæœ¬æ§åˆ¶**ï¼šå‡å°‘æ•°æ®è´¨é‡é—®é¢˜å¸¦æ¥çš„æˆæœ¬

### 1.2 æ•°æ®è´¨é‡ç»´åº¦

**æ•°æ®è´¨é‡å…­å¤§ç»´åº¦**ï¼š

1. **å®Œæ•´æ€§ï¼ˆCompletenessï¼‰**ï¼šæ•°æ®æ˜¯å¦å®Œæ•´
2. **å‡†ç¡®æ€§ï¼ˆAccuracyï¼‰**ï¼šæ•°æ®æ˜¯å¦å‡†ç¡®
3. **ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰**ï¼šæ•°æ®æ˜¯å¦ä¸€è‡´
4. **åŠæ—¶æ€§ï¼ˆTimelinessï¼‰**ï¼šæ•°æ®æ˜¯å¦åŠæ—¶
5. **æœ‰æ•ˆæ€§ï¼ˆValidityï¼‰**ï¼šæ•°æ®æ˜¯å¦ç¬¦åˆè§„åˆ™
6. **å”¯ä¸€æ€§ï¼ˆUniquenessï¼‰**ï¼šæ•°æ®æ˜¯å¦å”¯ä¸€

### 1.3 PostgreSQLæ•°æ®è´¨é‡ä¼˜åŠ¿

**PostgreSQLåœ¨æ•°æ®è´¨é‡ç®¡ç†ä¸­çš„ä¼˜åŠ¿**ï¼š

- âœ… **å¼ºå¤§çš„çº¦æŸç³»ç»Ÿ**ï¼šæ”¯æŒå¤šç§çº¦æŸä¿è¯æ•°æ®è´¨é‡
- âœ… **è§¦å‘å™¨æ”¯æŒ**ï¼šæ”¯æŒæ•°æ®è´¨é‡æ£€æŸ¥è§¦å‘å™¨
- âœ… **å‡½æ•°æ”¯æŒ**ï¼šæ”¯æŒè‡ªå®šä¹‰æ•°æ®è´¨é‡æ£€æŸ¥å‡½æ•°
- âœ… **è§„åˆ™æ”¯æŒ**ï¼šæ”¯æŒæ•°æ®è´¨é‡è§„åˆ™
- âœ… **å®¡è®¡æ”¯æŒ**ï¼šæ”¯æŒæ•°æ®å˜æ›´å®¡è®¡

### 1.4 ç‰ˆæœ¬è¦æ±‚

- **PostgreSQL 18.x**ï¼ˆæ¨èï¼‰- åŠŸèƒ½å®Œæ•´
- **PostgreSQL 17.x**ï¼ˆæ¨èï¼‰- åŠŸèƒ½å®Œæ•´
- **PostgreSQL 16.x**ï¼ˆå…¼å®¹ï¼‰- åŸºç¡€åŠŸèƒ½æ”¯æŒ

---

## äºŒã€æ•°æ®è´¨é‡ç»´åº¦

### 2.1 å®Œæ•´æ€§ï¼ˆCompletenessï¼‰

**å®Œæ•´æ€§**æŒ‡æ•°æ®çš„å®Œæ•´ç¨‹åº¦ã€‚

```sql
-- å®Œæ•´æ€§æ£€æŸ¥ï¼šå¿…å¡«å­—æ®µ
SELECT
    'users' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE username IS NULL) AS null_username,
    COUNT(*) FILTER (WHERE email IS NULL) AS null_email,
    COUNT(*) FILTER (WHERE username IS NULL OR email IS NULL) AS incomplete_rows,
    (COUNT(*) FILTER (WHERE username IS NULL OR email IS NULL) * 100.0 / COUNT(*)) AS incompleteness_rate
FROM users;

-- å®Œæ•´æ€§æ£€æŸ¥ï¼šå…³è”å®Œæ•´æ€§
SELECT
    'orders' AS table_name,
    COUNT(*) AS total_orders,
    COUNT(*) FILTER (WHERE user_id NOT IN (SELECT user_id FROM users)) AS orphan_orders,
    (COUNT(*) FILTER (WHERE user_id NOT IN (SELECT user_id FROM users)) * 100.0 / COUNT(*)) AS orphan_rate
FROM orders;
```

### 2.2 å‡†ç¡®æ€§ï¼ˆAccuracyï¼‰

**å‡†ç¡®æ€§**æŒ‡æ•°æ®çš„å‡†ç¡®ç¨‹åº¦ã€‚

```sql
-- å‡†ç¡®æ€§æ£€æŸ¥ï¼šæ•°å€¼èŒƒå›´
SELECT
    'orders' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE amount < 0) AS negative_amount,
    COUNT(*) FILTER (WHERE amount > 1000000) AS excessive_amount,
    COUNT(*) FILTER (WHERE amount < 0 OR amount > 1000000) AS inaccurate_rows,
    (COUNT(*) FILTER (WHERE amount < 0 OR amount > 1000000) * 100.0 / COUNT(*)) AS inaccuracy_rate
FROM orders;

-- å‡†ç¡®æ€§æ£€æŸ¥ï¼šé€»è¾‘ä¸€è‡´æ€§
SELECT
    'order_items' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE quantity <= 0) AS invalid_quantity,
    COUNT(*) FILTER (WHERE unit_price <= 0) AS invalid_price,
    COUNT(*) FILTER (WHERE subtotal != quantity * unit_price) AS calculation_error
FROM order_items;
```

### 2.3 ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰

**ä¸€è‡´æ€§**æŒ‡æ•°æ®çš„ä¸€è‡´æ€§ã€‚

```sql
-- ä¸€è‡´æ€§æ£€æŸ¥ï¼šè·¨è¡¨ä¸€è‡´æ€§
SELECT
    'orders vs order_items' AS check_name,
    o.order_id,
    o.total_amount AS order_total,
    SUM(oi.subtotal) AS items_total,
    ABS(o.total_amount - SUM(oi.subtotal)) AS difference
FROM orders o
JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY o.order_id, o.total_amount
HAVING ABS(o.total_amount - SUM(oi.subtotal)) > 0.01;

-- ä¸€è‡´æ€§æ£€æŸ¥ï¼šæ—¶é—´ä¸€è‡´æ€§
SELECT
    'orders' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE created_at > updated_at) AS time_inconsistency,
    COUNT(*) FILTER (WHERE order_date > CURRENT_DATE) AS future_date
FROM orders;
```

### 2.4 åŠæ—¶æ€§ï¼ˆTimelinessï¼‰

**åŠæ—¶æ€§**æŒ‡æ•°æ®çš„åŠæ—¶ç¨‹åº¦ã€‚

```sql
-- åŠæ—¶æ€§æ£€æŸ¥ï¼šæ•°æ®æ›´æ–°å»¶è¿Ÿ
SELECT
    'orders' AS table_name,
    COUNT(*) AS total_rows,
    AVG(EXTRACT(EPOCH FROM (NOW() - updated_at))) / 3600 AS avg_update_delay_hours,
    MAX(EXTRACT(EPOCH FROM (NOW() - updated_at))) / 3600 AS max_update_delay_hours,
    COUNT(*) FILTER (WHERE updated_at < NOW() - INTERVAL '7 days') AS stale_rows
FROM orders;

-- åŠæ—¶æ€§æ£€æŸ¥ï¼šæ•°æ®åŒæ­¥å»¶è¿Ÿ
SELECT
    'replication' AS check_name,
    application_name,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) / 1024 / 1024 AS lag_mb
FROM pg_stat_replication;
```

### 2.5 æœ‰æ•ˆæ€§ï¼ˆValidityï¼‰

**æœ‰æ•ˆæ€§**æŒ‡æ•°æ®æ˜¯å¦ç¬¦åˆè§„åˆ™ã€‚

```sql
-- æœ‰æ•ˆæ€§æ£€æŸ¥ï¼šæ ¼å¼éªŒè¯
SELECT
    'users' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') AS invalid_email,
    COUNT(*) FILTER (WHERE phone !~ '^[0-9]{11}$') AS invalid_phone
FROM users;

-- æœ‰æ•ˆæ€§æ£€æŸ¥ï¼šæšä¸¾å€¼éªŒè¯
SELECT
    'orders' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) FILTER (WHERE status NOT IN ('pending', 'paid', 'shipped', 'delivered', 'cancelled')) AS invalid_status
FROM orders;
```

### 2.6 å”¯ä¸€æ€§ï¼ˆUniquenessï¼‰

**å”¯ä¸€æ€§**æŒ‡æ•°æ®çš„å”¯ä¸€ç¨‹åº¦ã€‚

```sql
-- å”¯ä¸€æ€§æ£€æŸ¥ï¼šé‡å¤æ•°æ®æ£€æµ‹
SELECT
    'users' AS table_name,
    COUNT(*) AS total_rows,
    COUNT(*) - COUNT(DISTINCT email) AS duplicate_emails,
    COUNT(*) - COUNT(DISTINCT username) AS duplicate_usernames
FROM users;

-- å”¯ä¸€æ€§æ£€æŸ¥ï¼šé‡å¤è®°å½•æ£€æµ‹
SELECT
    order_id,
    user_id,
    order_date,
    COUNT(*) AS duplicate_count
FROM orders
GROUP BY order_id, user_id, order_date
HAVING COUNT(*) > 1;
```

---

## ä¸‰ã€æ•°æ®è´¨é‡æ£€æµ‹

### 3.1 å®Œæ•´æ€§æ£€æµ‹

**å®Œæ•´æ€§æ£€æµ‹å‡½æ•°**ï¼š

```sql
-- å®Œæ•´æ€§æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION check_completeness(
    p_table_name TEXT,
    p_required_columns TEXT[]
)
RETURNS TABLE (
    column_name TEXT,
    total_rows BIGINT,
    null_count BIGINT,
    completeness_rate NUMERIC
) AS $$
DECLARE
    v_col TEXT;
    v_sql TEXT;
BEGIN
    FOREACH v_col IN ARRAY p_required_columns
    LOOP
        v_sql := format('
            SELECT
                %L AS column_name,
                COUNT(*) AS total_rows,
                COUNT(*) FILTER (WHERE %I IS NULL) AS null_count,
                (COUNT(*) FILTER (WHERE %I IS NULL) * 100.0 / COUNT(*)) AS completeness_rate
            FROM %I',
            v_col, v_col, v_col, p_table_name);

        RETURN QUERY EXECUTE v_sql;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM check_completeness('users', ARRAY['username', 'email', 'phone']);
```

### 3.2 å‡†ç¡®æ€§æ£€æµ‹

**å‡†ç¡®æ€§æ£€æµ‹å‡½æ•°**ï¼š

```sql
-- å‡†ç¡®æ€§æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION check_accuracy(
    p_table_name TEXT,
    p_column_name TEXT,
    p_min_value NUMERIC DEFAULT NULL,
    p_max_value NUMERIC DEFAULT NULL
)
RETURNS TABLE (
    total_rows BIGINT,
    accurate_rows BIGINT,
    inaccurate_rows BIGINT,
    accuracy_rate NUMERIC
) AS $$
DECLARE
    v_sql TEXT;
BEGIN
    v_sql := format('
        SELECT
            COUNT(*) AS total_rows,
            COUNT(*) FILTER (WHERE %I >= COALESCE(%L, -999999999) AND %I <= COALESCE(%L, 999999999)) AS accurate_rows,
            COUNT(*) FILTER (WHERE %I < COALESCE(%L, -999999999) OR %I > COALESCE(%L, 999999999)) AS inaccurate_rows,
            (COUNT(*) FILTER (WHERE %I >= COALESCE(%L, -999999999) AND %I <= COALESCE(%L, 999999999)) * 100.0 / COUNT(*)) AS accuracy_rate
        FROM %I',
        p_column_name, p_min_value, p_column_name, p_max_value,
        p_column_name, p_min_value, p_column_name, p_max_value,
        p_column_name, p_min_value, p_column_name, p_max_value,
        p_table_name);

    RETURN QUERY EXECUTE v_sql;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM check_accuracy('orders', 'amount', 0, 1000000);
```

### 3.3 ä¸€è‡´æ€§æ£€æµ‹

**ä¸€è‡´æ€§æ£€æµ‹å‡½æ•°**ï¼š

```sql
-- ä¸€è‡´æ€§æ£€æµ‹å‡½æ•°ï¼šè®¢å•æ€»é‡‘é¢ä¸€è‡´æ€§
CREATE OR REPLACE FUNCTION check_order_consistency()
RETURNS TABLE (
    order_id BIGINT,
    order_total NUMERIC,
    items_total NUMERIC,
    difference NUMERIC,
    is_consistent BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        o.order_id,
        o.total_amount AS order_total,
        COALESCE(SUM(oi.subtotal), 0) AS items_total,
        ABS(o.total_amount - COALESCE(SUM(oi.subtotal), 0)) AS difference,
        ABS(o.total_amount - COALESCE(SUM(oi.subtotal), 0)) < 0.01 AS is_consistent
    FROM orders o
    LEFT JOIN order_items oi ON oi.order_id = o.order_id
    GROUP BY o.order_id, o.total_amount
    HAVING ABS(o.total_amount - COALESCE(SUM(oi.subtotal), 0)) >= 0.01;
END;
$$ LANGUAGE plpgsql;
```

### 3.4 æœ‰æ•ˆæ€§æ£€æµ‹

**æœ‰æ•ˆæ€§æ£€æµ‹å‡½æ•°**ï¼š

```sql
-- æœ‰æ•ˆæ€§æ£€æµ‹å‡½æ•°ï¼šé‚®ç®±æ ¼å¼
CREATE OR REPLACE FUNCTION check_email_validity()
RETURNS TABLE (
    user_id BIGINT,
    email TEXT,
    is_valid BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.user_id,
        u.email,
        u.email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' AS is_valid
    FROM users u
    WHERE u.email IS NOT NULL
      AND u.email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
END;
$$ LANGUAGE plpgsql;
```

---

## å››ã€æ•°æ®æ¸…æ´—

### 4.1 ç¼ºå¤±å€¼å¤„ç†

**ç¼ºå¤±å€¼å¤„ç†ç­–ç•¥**ï¼š

```sql
-- ç­–ç•¥1ï¼šåˆ é™¤ç¼ºå¤±å€¼
DELETE FROM users
WHERE username IS NULL OR email IS NULL;

-- ç­–ç•¥2ï¼šå¡«å……é»˜è®¤å€¼
UPDATE users
SET phone = '00000000000'
WHERE phone IS NULL;

-- ç­–ç•¥3ï¼šå¡«å……å¹³å‡å€¼
UPDATE orders
SET amount = (SELECT AVG(amount) FROM orders WHERE amount IS NOT NULL)
WHERE amount IS NULL;

-- ç­–ç•¥4ï¼šå¡«å……ä¸­ä½æ•°
UPDATE orders
SET amount = (
    SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount)
    FROM orders
    WHERE amount IS NOT NULL
)
WHERE amount IS NULL;

-- ç­–ç•¥5ï¼šä½¿ç”¨å‰ä¸€ä¸ªå€¼å¡«å……ï¼ˆæ—¶é—´åºåˆ—ï¼‰
UPDATE metrics m1
SET value = (
    SELECT value
    FROM metrics m2
    WHERE m2.metric_name = m1.metric_name
      AND m2.timestamp < m1.timestamp
    ORDER BY m2.timestamp DESC
    LIMIT 1
)
WHERE m1.value IS NULL;
```

### 4.2 å¼‚å¸¸å€¼å¤„ç†

**å¼‚å¸¸å€¼å¤„ç†ç­–ç•¥**ï¼š

```sql
-- å¼‚å¸¸å€¼æ£€æµ‹ï¼šä½¿ç”¨IQRæ–¹æ³•
WITH stats AS (
    SELECT
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) AS q3,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) -
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) AS iqr
    FROM orders
    WHERE amount IS NOT NULL
)
SELECT
    o.order_id,
    o.amount,
    CASE
        WHEN o.amount < stats.q1 - 1.5 * stats.iqr THEN 'Low Outlier'
        WHEN o.amount > stats.q3 + 1.5 * stats.iqr THEN 'High Outlier'
        ELSE 'Normal'
    END AS outlier_type
FROM orders o, stats
WHERE o.amount IS NOT NULL;

-- å¼‚å¸¸å€¼å¤„ç†ï¼šåˆ é™¤å¼‚å¸¸å€¼
DELETE FROM orders
WHERE amount < (
    SELECT PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount) -
           1.5 * (PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) -
                  PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount))
    FROM orders
)
OR amount > (
    SELECT PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) +
           1.5 * (PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY amount) -
                  PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY amount))
    FROM orders
);

-- å¼‚å¸¸å€¼å¤„ç†ï¼šé™åˆ¶å¼‚å¸¸å€¼
UPDATE orders
SET amount = LEAST(GREATEST(amount, 0), 1000000)
WHERE amount < 0 OR amount > 1000000;
```

### 4.3 é‡å¤æ•°æ®å¤„ç†

**é‡å¤æ•°æ®å¤„ç†ç­–ç•¥**ï¼š

```sql
-- é‡å¤æ•°æ®æ£€æµ‹
SELECT
    email,
    COUNT(*) AS duplicate_count,
    ARRAY_AGG(user_id ORDER BY created_at) AS user_ids
FROM users
GROUP BY email
HAVING COUNT(*) > 1;

-- é‡å¤æ•°æ®å¤„ç†ï¼šä¿ç•™æœ€æ–°è®°å½•
DELETE FROM users u1
WHERE EXISTS (
    SELECT 1 FROM users u2
    WHERE u2.email = u1.email
      AND u2.created_at > u1.created_at
);

-- é‡å¤æ•°æ®å¤„ç†ï¼šåˆå¹¶é‡å¤è®°å½•
WITH duplicates AS (
    SELECT
        email,
        MIN(user_id) AS keep_user_id,
        ARRAY_AGG(user_id ORDER BY created_at) AS all_user_ids
    FROM users
    GROUP BY email
    HAVING COUNT(*) > 1
)
UPDATE orders o
SET user_id = d.keep_user_id
FROM duplicates d
WHERE o.user_id = ANY(d.all_user_ids[2:]);
```

### 4.4 æ ¼å¼æ ‡å‡†åŒ–

**æ ¼å¼æ ‡å‡†åŒ–å¤„ç†**ï¼š

```sql
-- æ ¼å¼æ ‡å‡†åŒ–ï¼šå»é™¤ç©ºæ ¼
UPDATE users
SET username = TRIM(username),
    email = LOWER(TRIM(email));

-- æ ¼å¼æ ‡å‡†åŒ–ï¼šç»Ÿä¸€æ—¥æœŸæ ¼å¼
UPDATE orders
SET order_date = DATE(order_date);

-- æ ¼å¼æ ‡å‡†åŒ–ï¼šç»Ÿä¸€çŠ¶æ€æ ¼å¼
UPDATE orders
SET status = UPPER(TRIM(status));

-- æ ¼å¼æ ‡å‡†åŒ–ï¼šç»Ÿä¸€ç”µè¯å·ç æ ¼å¼
UPDATE users
SET phone = REGEXP_REPLACE(phone, '[^0-9]', '', 'g')
WHERE phone IS NOT NULL;
```

---

## äº”ã€æ•°æ®è´¨é‡ç›‘æ§

### 5.1 è´¨é‡æŒ‡æ ‡ç›‘æ§

**è´¨é‡æŒ‡æ ‡ç›‘æ§è¡¨**ï¼š

```sql
-- æ•°æ®è´¨é‡æŒ‡æ ‡è¡¨
CREATE TABLE data_quality_metrics (
    metric_id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    metric_name TEXT NOT NULL,
    metric_type VARCHAR(50) NOT NULL,  -- completeness, accuracy, consistency, etc.
    metric_value NUMERIC NOT NULL,
    threshold NUMERIC,
    status VARCHAR(20) NOT NULL,  -- pass, warning, fail
    check_time TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    details JSONB
);

CREATE INDEX idx_dqm_table_time ON data_quality_metrics(table_name, check_time DESC);

-- è´¨é‡æŒ‡æ ‡ç›‘æ§å‡½æ•°
CREATE OR REPLACE FUNCTION monitor_data_quality()
RETURNS INTEGER AS $$
DECLARE
    v_metric_count INTEGER := 0;
    v_completeness_rate NUMERIC;
    v_accuracy_rate NUMERIC;
BEGIN
    -- ç›‘æ§å®Œæ•´æ€§
    SELECT
        (COUNT(*) FILTER (WHERE username IS NOT NULL AND email IS NOT NULL) * 100.0 / COUNT(*))
    INTO v_completeness_rate
    FROM users;

    INSERT INTO data_quality_metrics (
        table_name, metric_name, metric_type, metric_value, threshold, status
    ) VALUES (
        'users', 'completeness', 'completeness', v_completeness_rate, 95.0,
        CASE
            WHEN v_completeness_rate >= 95.0 THEN 'pass'
            WHEN v_completeness_rate >= 90.0 THEN 'warning'
            ELSE 'fail'
        END
    );
    v_metric_count := v_metric_count + 1;

    -- ç›‘æ§å‡†ç¡®æ€§
    SELECT
        (COUNT(*) FILTER (WHERE amount >= 0 AND amount <= 1000000) * 100.0 / COUNT(*))
    INTO v_accuracy_rate
    FROM orders;

    INSERT INTO data_quality_metrics (
        table_name, metric_name, metric_type, metric_value, threshold, status
    ) VALUES (
        'orders', 'accuracy', 'accuracy', v_accuracy_rate, 99.0,
        CASE
            WHEN v_accuracy_rate >= 99.0 THEN 'pass'
            WHEN v_accuracy_rate >= 95.0 THEN 'warning'
            ELSE 'fail'
        END
    );
    v_metric_count := v_metric_count + 1;

    RETURN v_metric_count;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 è´¨é‡æŠ¥å‘Šç”Ÿæˆ

**è´¨é‡æŠ¥å‘Šç”Ÿæˆå‡½æ•°**ï¼š

```sql
-- è´¨é‡æŠ¥å‘Šç”Ÿæˆå‡½æ•°
CREATE OR REPLACE FUNCTION generate_quality_report(
    p_table_name TEXT DEFAULT NULL,
    p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '7 days',
    p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
    table_name TEXT,
    metric_type TEXT,
    avg_metric_value NUMERIC,
    min_metric_value NUMERIC,
    max_metric_value NUMERIC,
    pass_count BIGINT,
    warning_count BIGINT,
    fail_count BIGINT,
    overall_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        dqm.table_name,
        dqm.metric_type,
        AVG(dqm.metric_value) AS avg_metric_value,
        MIN(dqm.metric_value) AS min_metric_value,
        MAX(dqm.metric_value) AS max_metric_value,
        COUNT(*) FILTER (WHERE dqm.status = 'pass') AS pass_count,
        COUNT(*) FILTER (WHERE dqm.status = 'warning') AS warning_count,
        COUNT(*) FILTER (WHERE dqm.status = 'fail') AS fail_count,
        CASE
            WHEN COUNT(*) FILTER (WHERE dqm.status = 'fail') > 0 THEN 'fail'
            WHEN COUNT(*) FILTER (WHERE dqm.status = 'warning') > 0 THEN 'warning'
            ELSE 'pass'
        END AS overall_status
    FROM data_quality_metrics dqm
    WHERE (p_table_name IS NULL OR dqm.table_name = p_table_name)
      AND dqm.check_time BETWEEN p_start_date AND p_end_date
    GROUP BY dqm.table_name, dqm.metric_type
    ORDER BY dqm.table_name, dqm.metric_type;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 è´¨é‡å‘Šè­¦

**è´¨é‡å‘Šè­¦å‡½æ•°**ï¼š

```sql
-- è´¨é‡å‘Šè­¦å‡½æ•°
CREATE OR REPLACE FUNCTION check_quality_alerts()
RETURNS TABLE (
    alert_id BIGINT,
    table_name TEXT,
    metric_name TEXT,
    metric_value NUMERIC,
    threshold NUMERIC,
    status TEXT,
    alert_time TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        dqm.metric_id,
        dqm.table_name,
        dqm.metric_name,
        dqm.metric_value,
        dqm.threshold,
        dqm.status,
        dqm.check_time
    FROM data_quality_metrics dqm
    WHERE dqm.status IN ('warning', 'fail')
      AND dqm.check_time >= NOW() - INTERVAL '1 hour'
    ORDER BY dqm.check_time DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## å…­ã€æ•°æ®è´¨é‡å·¥å…·

### 6.1 å†…ç½®å·¥å…·

**PostgreSQLå†…ç½®æ•°æ®è´¨é‡å·¥å…·**ï¼š

```sql
-- 1. çº¦æŸï¼šä¿è¯æ•°æ®è´¨é‡
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    amount NUMERIC(10,2) NOT NULL CHECK (amount >= 0),
    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'paid', 'shipped', 'delivered', 'cancelled'))
);

-- 2. è§¦å‘å™¨ï¼šæ•°æ®è´¨é‡æ£€æŸ¥
CREATE OR REPLACE FUNCTION check_order_quality()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.amount < 0 THEN
        RAISE EXCEPTION 'è®¢å•é‡‘é¢ä¸èƒ½ä¸ºè´Ÿæ•°';
    END IF;

    IF NEW.status NOT IN ('pending', 'paid', 'shipped', 'delivered', 'cancelled') THEN
        RAISE EXCEPTION 'æ— æ•ˆçš„è®¢å•çŠ¶æ€';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_order_quality
BEFORE INSERT OR UPDATE ON orders
FOR EACH ROW EXECUTE FUNCTION check_order_quality();

-- 3. è§„åˆ™ï¼šæ•°æ®è´¨é‡è§„åˆ™
CREATE RULE check_order_amount AS
ON INSERT TO orders
WHERE amount < 0
DO INSTEAD NOTHING;
```

### 6.2 è‡ªå®šä¹‰å‡½æ•°

**è‡ªå®šä¹‰æ•°æ®è´¨é‡æ£€æŸ¥å‡½æ•°**ï¼š

```sql
-- ç»¼åˆæ•°æ®è´¨é‡æ£€æŸ¥å‡½æ•°
CREATE OR REPLACE FUNCTION comprehensive_quality_check(p_table_name TEXT)
RETURNS TABLE (
    quality_dimension TEXT,
    metric_name TEXT,
    metric_value NUMERIC,
    threshold NUMERIC,
    status TEXT,
    details TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- å®Œæ•´æ€§æ£€æŸ¥
    SELECT
        'Completeness'::TEXT,
        'Required Fields'::TEXT,
        (COUNT(*) FILTER (WHERE username IS NOT NULL AND email IS NOT NULL) * 100.0 / COUNT(*)),
        95.0,
        CASE
            WHEN (COUNT(*) FILTER (WHERE username IS NOT NULL AND email IS NOT NULL) * 100.0 / COUNT(*)) >= 95.0 THEN 'pass'
            ELSE 'fail'
        END,
        format('å®Œæ•´æ€§: %.2f%%', (COUNT(*) FILTER (WHERE username IS NOT NULL AND email IS NOT NULL) * 100.0 / COUNT(*)))
    FROM users
    WHERE p_table_name = 'users'
    UNION ALL
    -- å‡†ç¡®æ€§æ£€æŸ¥
    SELECT
        'Accuracy'::TEXT,
        'Value Range'::TEXT,
        (COUNT(*) FILTER (WHERE amount >= 0 AND amount <= 1000000) * 100.0 / COUNT(*)),
        99.0,
        CASE
            WHEN (COUNT(*) FILTER (WHERE amount >= 0 AND amount <= 1000000) * 100.0 / COUNT(*)) >= 99.0 THEN 'pass'
            ELSE 'fail'
        END,
        format('å‡†ç¡®æ€§: %.2f%%', (COUNT(*) FILTER (WHERE amount >= 0 AND amount <= 1000000) * 100.0 / COUNT(*)))
    FROM orders
    WHERE p_table_name = 'orders';
END;
$$ LANGUAGE plpgsql;
```

### 6.3 å¤–éƒ¨å·¥å…·é›†æˆ

**å¤–éƒ¨æ•°æ®è´¨é‡å·¥å…·é›†æˆ**ï¼š

```sql
-- é›†æˆGreat Expectations
-- ä½¿ç”¨Pythonè°ƒç”¨Great Expectations API

-- é›†æˆApache Griffin
-- ä½¿ç”¨REST APIè°ƒç”¨Griffinæ•°æ®è´¨é‡æœåŠ¡

-- é›†æˆè‡ªå®šä¹‰æ•°æ®è´¨é‡æœåŠ¡
-- ä½¿ç”¨HTTPæ‰©å±•è°ƒç”¨å¤–éƒ¨æœåŠ¡
CREATE EXTENSION IF NOT EXISTS http;

CREATE OR REPLACE FUNCTION call_quality_service(p_data JSONB)
RETURNS JSONB AS $$
DECLARE
    v_response JSONB;
BEGIN
    SELECT content::jsonb INTO v_response
    FROM http((
        'POST',
        'http://quality-service:8000/check',
        ARRAY[http_header('Content-Type', 'application/json')],
        'application/json',
        p_data::text
    )::http_request);

    RETURN v_response;
END;
$$ LANGUAGE plpgsql;
```

---

## å…­ã€AIè¾…åŠ©æ•°æ®è´¨é‡ç®¡ç† ğŸ†•

### 6.4 AIè¾…åŠ©å¼‚å¸¸æ£€æµ‹

**AIè¾…åŠ©å¼‚å¸¸æ£€æµ‹**åˆ©ç”¨æœºå™¨å­¦ä¹ æŠ€æœ¯è‡ªåŠ¨è¯†åˆ«æ•°æ®å¼‚å¸¸ï¼Œæé«˜æ•°æ®è´¨é‡æ£€æµ‹çš„å‡†ç¡®æ€§å’Œæ•ˆç‡ã€‚

**PostgreSQLä¸­çš„AIå¼‚å¸¸æ£€æµ‹**ï¼š

```sql
-- 1. ç»Ÿè®¡å¼‚å¸¸æ£€æµ‹ï¼šåŸºäºç»Ÿè®¡åˆ†å¸ƒ
CREATE OR REPLACE FUNCTION detect_statistical_anomalies(
    p_table_name TEXT,
    p_column_name TEXT,
    p_threshold NUMERIC DEFAULT 3.0  -- 3å€æ ‡å‡†å·®
)
RETURNS TABLE (
    row_id BIGINT,
    column_value NUMERIC,
    z_score NUMERIC,
    is_anomaly BOOLEAN
) AS $$
DECLARE
    v_mean NUMERIC;
    v_stddev NUMERIC;
BEGIN
    -- è®¡ç®—å‡å€¼å’Œæ ‡å‡†å·®
    EXECUTE format('
        SELECT AVG(%I), STDDEV(%I)
        INTO v_mean, v_stddev
        FROM %I
        WHERE %I IS NOT NULL
    ', p_column_name, p_column_name, p_table_name, p_column_name);

    -- æ£€æµ‹å¼‚å¸¸å€¼
    RETURN QUERY
    EXECUTE format('
        SELECT
            ctid::text::bigint AS row_id,
            %I AS column_value,
            ABS((%I - %L) / NULLIF(%L, 0)) AS z_score,
            ABS((%I - %L) / NULLIF(%L, 0)) > %L AS is_anomaly
        FROM %I
        WHERE %I IS NOT NULL
        ORDER BY z_score DESC
    ', p_column_name, p_column_name, v_mean, v_stddev,
       p_column_name, v_mean, v_stddev, p_threshold,
       p_table_name, p_column_name);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM detect_statistical_anomalies('orders', 'amount', 3.0)
WHERE is_anomaly = TRUE;

-- 2. æ¨¡å¼å¼‚å¸¸æ£€æµ‹ï¼šåŸºäºæ•°æ®æ¨¡å¼
CREATE OR REPLACE FUNCTION detect_pattern_anomalies(
    p_table_name TEXT,
    p_column_name TEXT
)
RETURNS TABLE (
    pattern TEXT,
    pattern_count BIGINT,
    anomaly_score NUMERIC,
    is_anomaly BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    EXECUTE format('
        WITH pattern_stats AS (
            SELECT
                %I::TEXT AS pattern,
                COUNT(*) AS pattern_count,
                COUNT(*) * 100.0 / SUM(COUNT(*)) OVER () AS pattern_percentage
            FROM %I
            WHERE %I IS NOT NULL
            GROUP BY %I
        ),
        avg_pattern_count AS (
            SELECT AVG(pattern_count) AS avg_count
            FROM pattern_stats
        )
        SELECT
            ps.pattern,
            ps.pattern_count,
            ABS(ps.pattern_count - apc.avg_count) / NULLIF(apc.avg_count, 0) AS anomaly_score,
            ABS(ps.pattern_count - apc.avg_count) / NULLIF(apc.avg_count, 0) > 2.0 AS is_anomaly
        FROM pattern_stats ps
        CROSS JOIN avg_pattern_count apc
        ORDER BY anomaly_score DESC
    ', p_column_name, p_table_name, p_column_name, p_column_name);
END;
$$ LANGUAGE plpgsql;

-- 3. æ—¶é—´åºåˆ—å¼‚å¸¸æ£€æµ‹ï¼šåŸºäºæ—¶é—´åºåˆ—æ¨¡å¼
CREATE OR REPLACE FUNCTION detect_timeseries_anomalies(
    p_table_name TEXT,
    p_time_column TEXT,
    p_value_column TEXT,
    p_window_size INTEGER DEFAULT 7  -- 7å¤©çª—å£
)
RETURNS TABLE (
    time_point TIMESTAMPTZ,
    value NUMERIC,
    expected_value NUMERIC,
    deviation NUMERIC,
    is_anomaly BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    EXECUTE format('
        WITH time_series AS (
            SELECT
                %I AS time_point,
                %I AS value,
                AVG(%I) OVER (
                    ORDER BY %I
                    ROWS BETWEEN %s PRECEDING AND 1 PRECEDING
                ) AS expected_value,
                STDDEV(%I) OVER (
                    ORDER BY %I
                    ROWS BETWEEN %s PRECEDING AND 1 PRECEDING
                ) AS stddev_value
            FROM %I
            ORDER BY %I
        )
        SELECT
            time_point,
            value,
            expected_value,
            ABS(value - expected_value) AS deviation,
            ABS(value - expected_value) > (2 * COALESCE(stddev_value, 0)) AS is_anomaly
        FROM time_series
        WHERE expected_value IS NOT NULL
        ORDER BY time_point
    ', p_time_column, p_value_column, p_value_column, p_time_column,
       p_window_size, p_value_column, p_time_column, p_window_size,
       p_table_name, p_time_column);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹ï¼šæ£€æµ‹è®¢å•é‡‘é¢å¼‚å¸¸
SELECT * FROM detect_timeseries_anomalies('orders', 'order_date', 'amount', 7)
WHERE is_anomaly = TRUE;
```

### 6.5 è‡ªåŠ¨åŒ–æ•°æ®è´¨é‡è§„åˆ™ç”Ÿæˆ

**è‡ªåŠ¨åŒ–è§„åˆ™ç”Ÿæˆ**åŸºäºæ•°æ®ç‰¹å¾å’Œå†å²æ¨¡å¼è‡ªåŠ¨ç”Ÿæˆæ•°æ®è´¨é‡è§„åˆ™ã€‚

**PostgreSQLä¸­çš„è‡ªåŠ¨åŒ–è§„åˆ™ç”Ÿæˆ**ï¼š

```sql
-- 1. è‡ªåŠ¨ç”Ÿæˆå®Œæ•´æ€§è§„åˆ™
CREATE OR REPLACE FUNCTION generate_completeness_rules(p_table_name TEXT)
RETURNS TABLE (
    column_name TEXT,
    null_percentage NUMERIC,
    suggested_rule TEXT,
    rule_type TEXT
) AS $$
BEGIN
    RETURN QUERY
    EXECUTE format('
        SELECT
            column_name::TEXT,
            (null_count * 100.0 / total_count) AS null_percentage,
            CASE
                WHEN null_count = 0 THEN format(''ALTER TABLE %s ALTER COLUMN %%s SET NOT NULL'', %L)
                WHEN null_count * 100.0 / total_count < 5 THEN format(''å»ºè®®è®¾ç½®NOT NULLçº¦æŸ: %%s'', column_name)
                ELSE format(''å»ºè®®æ£€æŸ¥æ•°æ®å®Œæ•´æ€§: %%s (ç©ºå€¼æ¯”ä¾‹: %.2f%%)'', column_name, null_count * 100.0 / total_count)
            END AS suggested_rule,
            CASE
                WHEN null_count = 0 THEN ''NOT NULL Constraint''
                WHEN null_count * 100.0 / total_count < 5 THEN ''Warning''
                ELSE ''Investigation Required''
            END AS rule_type
        FROM (
            SELECT
                column_name,
                COUNT(*) FILTER (WHERE column_value IS NULL) AS null_count,
                COUNT(*) AS total_count
            FROM (
                SELECT unnest(ARRAY[''column1'', ''column2'']) AS column_name,
                       unnest(ARRAY[column1, column2]) AS column_value
                FROM %I
            ) t
            GROUP BY column_name
        ) stats
    ', p_table_name, p_table_name);
END;
$$ LANGUAGE plpgsql;

-- 2. è‡ªåŠ¨ç”ŸæˆèŒƒå›´è§„åˆ™
CREATE OR REPLACE FUNCTION generate_range_rules(
    p_table_name TEXT,
    p_column_name TEXT
)
RETURNS TABLE (
    min_value NUMERIC,
    max_value NUMERIC,
    avg_value NUMERIC,
    stddev_value NUMERIC,
    suggested_min NUMERIC,
    suggested_max NUMERIC,
    suggested_rule TEXT
) AS $$
BEGIN
    RETURN QUERY
    EXECUTE format('
        WITH stats AS (
            SELECT
                MIN(%I) AS min_val,
                MAX(%I) AS max_val,
                AVG(%I) AS avg_val,
                STDDEV(%I) AS stddev_val
            FROM %I
            WHERE %I IS NOT NULL
        )
        SELECT
            min_val,
            max_val,
            avg_val,
            stddev_val,
            GREATEST(avg_val - 3 * stddev_val, min_val) AS suggested_min,
            LEAST(avg_val + 3 * stddev_val, max_val) AS suggested_max,
            format(''CHECK (%s BETWEEN %%s AND %%s)'', %L, GREATEST(avg_val - 3 * stddev_val, min_val), LEAST(avg_val + 3 * stddev_val, max_val)) AS suggested_rule
        FROM stats
    ', p_column_name, p_column_name, p_column_name, p_column_name,
       p_table_name, p_column_name, p_column_name);
END;
$$ LANGUAGE plpgsql;

-- 3. è‡ªåŠ¨ç”Ÿæˆæ ¼å¼è§„åˆ™
CREATE OR REPLACE FUNCTION generate_format_rules(
    p_table_name TEXT,
    p_column_name TEXT
)
RETURNS TABLE (
    pattern TEXT,
    pattern_count BIGINT,
    pattern_percentage NUMERIC,
    suggested_rule TEXT
) AS $$
BEGIN
    RETURN QUERY
    EXECUTE format('
        WITH pattern_analysis AS (
            SELECT
                CASE
                    WHEN %I ~ ''^[0-9]+$'' THEN ''Numeric''
                    WHEN %I ~ ''^[A-Za-z]+$'' THEN ''Alphabetic''
                    WHEN %I ~ ''^[A-Za-z0-9]+$'' THEN ''Alphanumeric''
                    WHEN %I ~ ''^[0-9]{4}-[0-9]{2}-[0-9]{2}$'' THEN ''Date (YYYY-MM-DD)''
                    WHEN %I ~ ''^[0-9]{3}-[0-9]{3}-[0-9]{4}$'' THEN ''Phone (XXX-XXX-XXXX)''
                    WHEN %I ~ ''^[A-Za-z0-9._%%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'' THEN ''Email''
                    ELSE ''Other''
                END AS pattern,
                COUNT(*) AS pattern_count
            FROM %I
            WHERE %I IS NOT NULL
            GROUP BY pattern
        )
        SELECT
            pattern::TEXT,
            pattern_count,
            (pattern_count * 100.0 / SUM(pattern_count) OVER ()) AS pattern_percentage,
            CASE
                WHEN pattern_percentage > 90 THEN format(''å»ºè®®ç»Ÿä¸€æ ¼å¼: %%s (å æ¯”: %.2f%%)'', pattern, pattern_percentage)
                ELSE format(''æ ¼å¼ä¸ä¸€è‡´: %%s (å æ¯”: %.2f%%)'', pattern, pattern_percentage)
            END AS suggested_rule
        FROM pattern_analysis
        ORDER BY pattern_count DESC
    ', p_column_name, p_column_name, p_column_name, p_column_name,
       p_column_name, p_column_name, p_table_name, p_column_name);
END;
$$ LANGUAGE plpgsql;
```

### 6.6 æ•°æ®è´¨é‡å¯è§£é‡Šæ€§

**æ•°æ®è´¨é‡å¯è§£é‡Šæ€§**æä¾›æ•°æ®è´¨é‡é—®é¢˜çš„è¯¦ç»†è§£é‡Šå’Œä¿®å¤å»ºè®®ã€‚

**PostgreSQLä¸­çš„æ•°æ®è´¨é‡å¯è§£é‡Šæ€§**ï¼š

```sql
-- 1. æ•°æ®è´¨é‡é—®é¢˜è§£é‡Šå‡½æ•°
CREATE OR REPLACE FUNCTION explain_quality_issue(
    p_table_name TEXT,
    p_column_name TEXT,
    p_issue_type TEXT
)
RETURNS TABLE (
    issue_description TEXT,
    root_cause TEXT,
    impact_assessment TEXT,
    recommended_action TEXT,
    priority TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        CASE p_issue_type
            WHEN 'completeness' THEN format('è¡¨ %s çš„åˆ— %s å­˜åœ¨æ•°æ®å®Œæ•´æ€§é—®é¢˜', p_table_name, p_column_name)
            WHEN 'accuracy' THEN format('è¡¨ %s çš„åˆ— %s å­˜åœ¨æ•°æ®å‡†ç¡®æ€§é—®é¢˜', p_table_name, p_column_name)
            WHEN 'consistency' THEN format('è¡¨ %s çš„åˆ— %s å­˜åœ¨æ•°æ®ä¸€è‡´æ€§é—®é¢˜', p_table_name, p_column_name)
            ELSE format('è¡¨ %s çš„åˆ— %s å­˜åœ¨æ•°æ®è´¨é‡é—®é¢˜', p_table_name, p_column_name)
        END AS issue_description,
        CASE p_issue_type
            WHEN 'completeness' THEN 'æ•°æ®æºç¼ºå¤±ã€ETLå¤„ç†é”™è¯¯ã€ä¸šåŠ¡è§„åˆ™æœªæ‰§è¡Œ'
            WHEN 'accuracy' THEN 'æ•°æ®è¾“å…¥é”™è¯¯ã€è®¡ç®—é”™è¯¯ã€æ•°æ®è½¬æ¢é”™è¯¯'
            WHEN 'consistency' THEN 'æ•°æ®åŒæ­¥å»¶è¿Ÿã€å¤šæ•°æ®æºä¸ä¸€è‡´ã€ä¸šåŠ¡è§„åˆ™å†²çª'
            ELSE 'æœªçŸ¥åŸå› '
        END AS root_cause,
        CASE p_issue_type
            WHEN 'completeness' THEN 'å½±å“æ•°æ®åˆ†æå’ŒæŠ¥è¡¨å‡†ç¡®æ€§ï¼Œå¯èƒ½å¯¼è‡´å†³ç­–é”™è¯¯'
            WHEN 'accuracy' THEN 'å½±å“ä¸šåŠ¡æŒ‡æ ‡è®¡ç®—ï¼Œå¯èƒ½å¯¼è‡´è´¢åŠ¡æŸå¤±'
            WHEN 'consistency' THEN 'å½±å“æ•°æ®å¯ä¿¡åº¦ï¼Œå¯èƒ½å¯¼è‡´ä¸šåŠ¡å†²çª'
            ELSE 'å½±å“æ•°æ®æ•´ä½“è´¨é‡'
        END AS impact_assessment,
        CASE p_issue_type
            WHEN 'completeness' THEN '1. æ£€æŸ¥æ•°æ®æºå®Œæ•´æ€§ 2. éªŒè¯ETLæµç¨‹ 3. æ·»åŠ NOT NULLçº¦æŸ'
            WHEN 'accuracy' THEN '1. éªŒè¯æ•°æ®è¾“å…¥ 2. æ£€æŸ¥è®¡ç®—é€»è¾‘ 3. æ·»åŠ CHECKçº¦æŸ'
            WHEN 'consistency' THEN '1. åŒæ­¥æ•°æ®æº 2. ç»Ÿä¸€ä¸šåŠ¡è§„åˆ™ 3. æ·»åŠ å¤–é”®çº¦æŸ'
            ELSE '1. åˆ†æé—®é¢˜åŸå›  2. åˆ¶å®šä¿®å¤è®¡åˆ’ 3. å®æ–½è´¨é‡æ”¹è¿›'
        END AS recommended_action,
        CASE p_issue_type
            WHEN 'completeness' THEN 'High'
            WHEN 'accuracy' THEN 'Critical'
            WHEN 'consistency' THEN 'Medium'
            ELSE 'Medium'
        END AS priority;
END;
$$ LANGUAGE plpgsql;

-- 2. æ•°æ®è´¨é‡ä¿®å¤å»ºè®®å‡½æ•°
CREATE OR REPLACE FUNCTION suggest_quality_fixes(
    p_table_name TEXT,
    p_column_name TEXT
)
RETURNS TABLE (
    fix_type TEXT,
    fix_description TEXT,
    fix_sql TEXT,
    estimated_impact TEXT,
    risk_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'Constraint'::TEXT AS fix_type,
        format('ä¸ºåˆ— %s æ·»åŠ NOT NULLçº¦æŸ', p_column_name) AS fix_description,
        format('ALTER TABLE %s ALTER COLUMN %s SET NOT NULL;', p_table_name, p_column_name) AS fix_sql,
        'é˜²æ­¢æœªæ¥æ’å…¥ç©ºå€¼ï¼Œä½†éœ€è¦å…ˆæ¸…ç†ç°æœ‰ç©ºå€¼' AS estimated_impact,
        'Medium'::TEXT AS risk_level
    UNION ALL
    SELECT
        'Data Cleaning'::TEXT AS fix_type,
        format('æ¸…ç†åˆ— %s ä¸­çš„å¼‚å¸¸å€¼', p_column_name) AS fix_description,
        format('UPDATE %s SET %s = NULL WHERE %s < 0 OR %s > 1000000;',
               p_table_name, p_column_name, p_column_name, p_column_name) AS fix_sql,
        'æ¸…ç†å¼‚å¸¸æ•°æ®ï¼Œä½†å¯èƒ½ä¸¢å¤±éƒ¨åˆ†ä¿¡æ¯' AS estimated_impact,
        'High'::TEXT AS risk_level
    UNION ALL
    SELECT
        'Validation'::TEXT AS fix_type,
        format('ä¸ºåˆ— %s æ·»åŠ CHECKçº¦æŸ', p_column_name) AS fix_description,
        format('ALTER TABLE %s ADD CONSTRAINT check_%s CHECK (%s >= 0 AND %s <= 1000000);',
               p_table_name, p_column_name, p_column_name, p_column_name) AS fix_sql,
        'é˜²æ­¢æœªæ¥æ’å…¥æ— æ•ˆæ•°æ®' AS estimated_impact,
        'Low'::TEXT AS risk_level;
END;
$$ LANGUAGE plpgsql;
```

**AIè¾…åŠ©æ•°æ®è´¨é‡ç®¡ç†ä¼˜åŠ¿**ï¼š

- **è‡ªåŠ¨åŒ–æ£€æµ‹**ï¼šè‡ªåŠ¨è¯†åˆ«æ•°æ®å¼‚å¸¸å’Œè´¨é‡é—®é¢˜
- **æ™ºèƒ½è§„åˆ™ç”Ÿæˆ**ï¼šåŸºäºæ•°æ®ç‰¹å¾è‡ªåŠ¨ç”Ÿæˆè´¨é‡è§„åˆ™
- **å¯è§£é‡Šæ€§**ï¼šæä¾›è¯¦ç»†çš„é—®é¢˜è§£é‡Šå’Œä¿®å¤å»ºè®®
- **æ•ˆç‡æå‡**ï¼šå‡å°‘æ‰‹åŠ¨æ£€æŸ¥å’Œåˆ†ææ—¶é—´

---

## ä¸ƒã€å®è·µæ¡ˆä¾‹

### 7.1 æ•°æ®è´¨é‡æ£€æŸ¥æµç¨‹

**å®Œæ•´çš„æ•°æ®è´¨é‡æ£€æŸ¥æµç¨‹**ï¼š

```sql
-- 1. åˆ›å»ºè´¨é‡æ£€æŸ¥è¡¨
CREATE TABLE quality_check_results (
    check_id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    check_type TEXT NOT NULL,
    check_result JSONB NOT NULL,
    check_time TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- 2. æ‰§è¡Œè´¨é‡æ£€æŸ¥
CREATE OR REPLACE FUNCTION run_quality_checks()
RETURNS INTEGER AS $$
DECLARE
    v_check_count INTEGER := 0;
    v_result JSONB;
BEGIN
    -- æ£€æŸ¥å®Œæ•´æ€§
    SELECT jsonb_build_object(
        'completeness_rate', (
            SELECT COUNT(*) FILTER (WHERE username IS NOT NULL AND email IS NOT NULL) * 100.0 / COUNT(*)
            FROM users
        ),
        'status', CASE
            WHEN (SELECT COUNT(*) FILTER (WHERE username IS NOT NULL AND email IS NOT NULL) * 100.0 / COUNT(*) FROM users) >= 95.0 THEN 'pass'
            ELSE 'fail'
        END
    ) INTO v_result;

    INSERT INTO quality_check_results (table_name, check_type, check_result)
    VALUES ('users', 'completeness', v_result);
    v_check_count := v_check_count + 1;

    -- æ£€æŸ¥å‡†ç¡®æ€§
    SELECT jsonb_build_object(
        'accuracy_rate', (
            SELECT COUNT(*) FILTER (WHERE amount >= 0 AND amount <= 1000000) * 100.0 / COUNT(*)
            FROM orders
        ),
        'status', CASE
            WHEN (SELECT COUNT(*) FILTER (WHERE amount >= 0 AND amount <= 1000000) * 100.0 / COUNT(*) FROM orders) >= 99.0 THEN 'pass'
            ELSE 'fail'
        END
    ) INTO v_result;

    INSERT INTO quality_check_results (table_name, check_type, check_result)
    VALUES ('orders', 'accuracy', v_result);
    v_check_count := v_check_count + 1;

    RETURN v_check_count;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—

**è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—æµç¨‹**ï¼š

```sql
-- è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—å‡½æ•°
CREATE OR REPLACE FUNCTION auto_clean_data()
RETURNS TABLE (
    table_name TEXT,
    cleaned_count INTEGER,
    error_count INTEGER
) AS $$
DECLARE
    v_cleaned_count INTEGER;
    v_error_count INTEGER;
BEGIN
    -- æ¸…æ´—usersè¡¨
    UPDATE users
    SET username = TRIM(username),
        email = LOWER(TRIM(email)),
        phone = REGEXP_REPLACE(phone, '[^0-9]', '', 'g')
    WHERE username IS NOT NULL OR email IS NOT NULL OR phone IS NOT NULL;
    GET DIAGNOSTICS v_cleaned_count = ROW_COUNT;

    DELETE FROM users
    WHERE username IS NULL OR email IS NULL;
    GET DIAGNOSTICS v_error_count = ROW_COUNT;

    RETURN QUERY SELECT 'users'::TEXT, v_cleaned_count, v_error_count;

    -- æ¸…æ´—ordersè¡¨
    UPDATE orders
    SET amount = GREATEST(amount, 0)
    WHERE amount < 0;
    GET DIAGNOSTICS v_cleaned_count = ROW_COUNT;

    DELETE FROM orders
    WHERE amount < 0 OR order_date > CURRENT_DATE;
    GET DIAGNOSTICS v_error_count = ROW_COUNT;

    RETURN QUERY SELECT 'orders'::TEXT, v_cleaned_count, v_error_count;
END;
$$ LANGUAGE plpgsql;
```

### 7.3 æ•°æ®è´¨é‡æŠ¥å‘Š

**æ•°æ®è´¨é‡æŠ¥å‘Šç”Ÿæˆ**ï¼š

```sql
-- æ•°æ®è´¨é‡æŠ¥å‘Š
CREATE OR REPLACE FUNCTION generate_quality_report()
RETURNS TABLE (
    table_name TEXT,
    total_checks INTEGER,
    pass_count INTEGER,
    warning_count INTEGER,
    fail_count INTEGER,
    overall_score NUMERIC,
    report_time TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        qcr.table_name,
        COUNT(*) AS total_checks,
        COUNT(*) FILTER (WHERE qcr.check_result->>'status' = 'pass') AS pass_count,
        COUNT(*) FILTER (WHERE qcr.check_result->>'status' = 'warning') AS warning_count,
        COUNT(*) FILTER (WHERE qcr.check_result->>'status' = 'fail') AS fail_count,
        (COUNT(*) FILTER (WHERE qcr.check_result->>'status' = 'pass') * 100.0 / COUNT(*)) AS overall_score,
        MAX(qcr.check_time) AS report_time
    FROM quality_check_results qcr
    WHERE qcr.check_time >= NOW() - INTERVAL '1 day'
    GROUP BY qcr.table_name
    ORDER BY overall_score DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## ä¹ã€æœ€ä½³å®è·µ

1. **æ•°æ®è´¨é‡è®¾è®¡**ï¼š
   - åœ¨æ•°æ®åº“è®¾è®¡é˜¶æ®µè€ƒè™‘æ•°æ®è´¨é‡
   - ä½¿ç”¨çº¦æŸä¿è¯æ•°æ®è´¨é‡
   - è®¾è®¡æ•°æ®è´¨é‡æ£€æŸ¥æµç¨‹

2. **æ•°æ®è´¨é‡ç›‘æ§**ï¼š
   - å®šæœŸæ‰§è¡Œæ•°æ®è´¨é‡æ£€æŸ¥
   - è®°å½•æ•°æ®è´¨é‡æŒ‡æ ‡
   - è®¾ç½®æ•°æ®è´¨é‡å‘Šè­¦

3. **æ•°æ®æ¸…æ´—**ï¼š
   - å»ºç«‹æ•°æ®æ¸…æ´—æµç¨‹
   - è®°å½•æ¸…æ´—æ“ä½œæ—¥å¿—
   - éªŒè¯æ¸…æ´—ç»“æœ

4. **æŒç»­æ”¹è¿›**ï¼š
   - åˆ†ææ•°æ®è´¨é‡é—®é¢˜
   - ä¼˜åŒ–æ•°æ®è´¨é‡è§„åˆ™
   - æå‡æ•°æ®è´¨é‡æ°´å¹³

---

## åã€å‚è€ƒèµ„æº

### 9.1 å®˜æ–¹æ–‡æ¡£

- [PostgreSQLçº¦æŸ](https://www.postgresql.org/docs/current/ddl-constraints.html)
- [PostgreSQLè§¦å‘å™¨](https://www.postgresql.org/docs/current/triggers.html)
- [PostgreSQLè§„åˆ™](https://www.postgresql.org/docs/current/sql-createrule.html)

### 9.2 ç›¸å…³æ–‡æ¡£

- [ETLæµç¨‹å®Œæ•´æŒ‡å—](./09.04-ETLæµç¨‹å®Œæ•´æŒ‡å—.md) - ETLæµç¨‹ä¸­çš„æ•°æ®è´¨é‡
- [æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—](./09.02-æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—.md) - æ•°æ®å»ºæ¨¡ä¸­çš„æ•°æ®è´¨é‡è€ƒè™‘
- [æ•°æ®åˆ†æå®Œæ•´æŒ‡å—](./09.01-æ•°æ®åˆ†æå®Œæ•´æŒ‡å—.md) - æ•°æ®åˆ†æä¸­çš„æ•°æ®è´¨é‡

### 9.3 å¤–éƒ¨èµ„æº

- [æ•°æ®è´¨é‡ç®¡ç†æœ€ä½³å®è·µ](https://www.postgresql.org/docs/current/)
- [Great Expectationsæ–‡æ¡£](https://docs.greatexpectations.io/)
- [Apache Griffinæ–‡æ¡£](https://griffin.apache.org/)

---

## åä¸€ã€äº¤å‰å¼•ç”¨

### ç›¸å…³æ–‡æ¡£

- â­â­â­ [ETLæµç¨‹å®Œæ•´æŒ‡å—](./09.04-ETLæµç¨‹å®Œæ•´æŒ‡å—.md) - ETLæµç¨‹ä¸­çš„æ•°æ®è´¨é‡
- â­â­â­ [æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—](./09.02-æ•°æ®å»ºæ¨¡å®Œæ•´æŒ‡å—.md) - æ•°æ®å»ºæ¨¡ä¸­çš„æ•°æ®è´¨é‡è€ƒè™‘
- â­â­ [æ•°æ®åˆ†æå®Œæ•´æŒ‡å—](./09.01-æ•°æ®åˆ†æå®Œæ•´æŒ‡å—.md) - æ•°æ®åˆ†æä¸­çš„æ•°æ®è´¨é‡
- â­â­ [æ•°æ®ä»“åº“è®¾è®¡æŒ‡å—](./09.03-æ•°æ®ä»“åº“è®¾è®¡æŒ‡å—.md) - æ•°æ®ä»“åº“ä¸­çš„æ•°æ®è´¨é‡
- â­ [æ•°æ®ç§‘å­¦å®è·µ](../åº”ç”¨æ¶æ„/07.06-æ•°æ®ç§‘å­¦å®è·µ.md) - æ•°æ®ç§‘å­¦ä¸­çš„æ•°æ®è´¨é‡

### å¤–éƒ¨èµ„æº

- [PostgreSQLçº¦æŸæ–‡æ¡£](https://www.postgresql.org/docs/current/ddl-constraints.html)
- [PostgreSQLè§¦å‘å™¨æ–‡æ¡£](https://www.postgresql.org/docs/current/triggers.html)
- [PostgreSQLè§„åˆ™æ–‡æ¡£](https://www.postgresql.org/docs/current/sql-createrule.html)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1
**æœ€åæ›´æ–°**: 2025-11-22
**PostgreSQLç‰ˆæœ¬**: 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
**ç»´æŠ¤è€…**: Documentation Team
