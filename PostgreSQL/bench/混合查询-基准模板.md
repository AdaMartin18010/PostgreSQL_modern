# 混合查询-基准模板

> **PostgreSQL版本**: 18 ⭐ | 17 | 16
> **pgvector版本**: 2.0 ⭐ | 0.7+
> **最后更新**: 2025-11-12

---

## 1. 目标

- 同时覆盖结构化筛选、全文、向量召回的组合性能，度量 TP50/TP95/TP99 与吞吐。
- 评估不同混合查询策略（RRF、加权融合、分阶段召回）的性能差异。
- 测试不同索引参数（HNSW、IVFFlat）对混合查询性能的影响。

---

## 2. 环境准备

### 2.1 前置条件

- PostgreSQL 16+ with pgvector extension
- 足够的测试数据（建议 100万+ 文档）
- 全文索引（GIN）和向量索引（HNSW/IVFFlat）已创建

### 2.2 数据准备

参考 `sql/vector_examples.sql` 创建测试表：

```sql
-- 创建测试表
CREATE TABLE IF NOT EXISTS docs (
    id bigserial PRIMARY KEY,
    text text NOT NULL,
    embedding vector(768),  -- 根据实际模型调整维度
    category text,
    created_at timestamptz DEFAULT now()
);

-- 创建全文索引
CREATE INDEX IF NOT EXISTS docs_text_gin
ON docs USING gin (to_tsvector('simple', text));

-- 创建向量索引（HNSW）
CREATE INDEX IF NOT EXISTS docs_hnsw
ON docs USING hnsw (embedding vector_l2_ops)
WITH (m = 32, ef_construction = 200);

-- 创建向量索引（IVFFlat，可选）
CREATE INDEX IF NOT EXISTS docs_ivfflat
ON docs USING ivfflat (embedding vector_l2_ops)
WITH (lists = 100);

-- 更新统计信息
ANALYZE docs;
```

### 2.3 数据生成（示例）

```sql
-- 生成测试数据（示例，实际应使用真实数据）
INSERT INTO docs (text, embedding, category)
SELECT
    'Document ' || generate_series || ' about ' ||
    (ARRAY['postgres', 'database', 'vector', 'search', 'ai'])[floor(random() * 5 + 1)],
    (SELECT array_agg(random())::vector(768) FROM generate_series(1, 768)),
    (ARRAY['tech', 'ai', 'database'])[floor(random() * 3 + 1)]
FROM generate_series(1, 1000000);
```

---

## 3. 测试脚本

### 3.1 基础混合查询（全文 + 向量）

```sql
-- mix_basic.sql
\set qv random(1, 1000)
\set kw random(1, 5)
\set keyword :kw
\set query_vector :qv

WITH s AS (
  SELECT id, ts_rank(to_tsvector('simple', text), plainto_tsquery('simple', :keyword)) AS tr
  FROM docs
  WHERE to_tsvector('simple', text) @@ plainto_tsquery('simple', :keyword)
  ORDER BY tr DESC LIMIT 500
), v AS (
  SELECT id, embedding <-> (SELECT embedding FROM docs WHERE id = :query_vector LIMIT 1) AS dist
  FROM docs
  WHERE id IN (SELECT id FROM s)
  ORDER BY dist ASC LIMIT 100
)
SELECT count(*) FROM v;
```

### 3.2 RRF 融合查询

```sql
-- mix_rrf.sql
\set qv random(1, 1000)
\set kw random(1, 5)
\set keyword :kw
\set query_vector :qv

WITH vector_results AS (
    SELECT id,
           ROW_NUMBER() OVER (ORDER BY embedding <-> (SELECT embedding FROM docs WHERE id = :query_vector LIMIT 1)) AS vec_rank
    FROM docs
    WHERE embedding IS NOT NULL
    ORDER BY embedding <-> (SELECT embedding FROM docs WHERE id = :query_vector LIMIT 1)
    LIMIT 50
),
fulltext_results AS (
    SELECT id,
           ROW_NUMBER() OVER (
               ORDER BY ts_rank(to_tsvector('simple', text), plainto_tsquery('simple', :keyword)) DESC
           ) AS text_rank
    FROM docs
    WHERE to_tsvector('simple', text) @@ plainto_tsquery('simple', :keyword)
    LIMIT 50
)
SELECT
    COALESCE(v.id, f.id) AS id,
    COALESCE(1.0 / (60 + v.vec_rank), 0) + COALESCE(1.0 / (60 + f.text_rank), 0) AS rrf_score
FROM vector_results v
FULL OUTER JOIN fulltext_results f ON v.id = f.id
ORDER BY rrf_score DESC
LIMIT 10;
```

### 3.3 加权融合查询

```sql
-- mix_weighted.sql
\set qv random(1, 1000)
\set kw random(1, 5)
\set keyword :kw
\set query_vector :qv

WITH s AS (
    SELECT id, ts_rank(to_tsvector('simple', text), plainto_tsquery('simple', :keyword)) AS tr
    FROM docs
    WHERE to_tsvector('simple', text) @@ plainto_tsquery('simple', :keyword)
    ORDER BY tr DESC LIMIT 500
), v AS (
    SELECT id,
           embedding <-> (SELECT embedding FROM docs WHERE id = :query_vector LIMIT 1) AS dist,
           (SELECT tr FROM s WHERE s.id = docs.id) AS tr
    FROM docs
    WHERE id IN (SELECT id FROM s)
    ORDER BY dist ASC LIMIT 100
)
SELECT id, 0.6 * (1.0 / (dist + 0.001)) + 0.4 * tr AS combined_score
FROM v
ORDER BY combined_score DESC
LIMIT 50;
```

### 3.4 结构化过滤 + 混合查询

```sql
-- mix_filtered.sql
\set qv random(1, 1000)
\set kw random(1, 5)
\set keyword :kw
\set query_vector :qv

WITH filtered AS (
    SELECT id, text, embedding
    FROM docs
    WHERE created_at >= now() - interval '30 days'
      AND category = 'tech'
),
text_search AS (
    SELECT id, ts_rank(to_tsvector('simple', text), plainto_tsquery('simple', :keyword)) AS tr
    FROM filtered
    WHERE to_tsvector('simple', text) @@ plainto_tsquery('simple', :keyword)
    ORDER BY tr DESC LIMIT 500
),
vector_search AS (
    SELECT id, embedding <-> (SELECT embedding FROM docs WHERE id = :query_vector LIMIT 1) AS dist
    FROM filtered
    WHERE id IN (SELECT id FROM text_search)
    ORDER BY dist ASC LIMIT 100
)
SELECT count(*) FROM vector_search;
```

---

## 4. 运行测试

### 4.1 基础压测

```bash
# 单脚本测试
pgbench -c 32 -j 32 -T 300 -f mix_basic.sql postgres

# 多脚本对比测试
pgbench -c 32 -j 32 -T 300 -f mix_basic.sql postgres > result_basic.log 2>&1
pgbench -c 32 -j 32 -T 300 -f mix_rrf.sql postgres > result_rrf.log 2>&1
pgbench -c 32 -j 32 -T 300 -f mix_weighted.sql postgres > result_weighted.log 2>&1
```

### 4.2 参数调优测试

```sql
-- 测试不同 HNSW ef_search 参数
SET hnsw.ef_search = 40;
\i mix_basic.sql

SET hnsw.ef_search = 100;
\i mix_basic.sql

SET hnsw.ef_search = 200;
\i mix_basic.sql
```

```sql
-- 测试不同 IVFFlat probes 参数
SET ivfflat.probes = 10;
\i mix_basic.sql

SET ivfflat.probes = 50;
\i mix_basic.sql

SET ivfflat.probes = 100;
\i mix_basic.sql
```

### 4.3 并发度测试

```bash
# 不同并发度测试
for clients in 8 16 32 64 128; do
    pgbench -c $clients -j $clients -T 300 -f mix_basic.sql postgres > result_c${clients}.log 2>&1
done
```

---

## 5. 监控指标

### 5.1 PostgreSQL 指标

```sql
-- 查询性能统计（需启用 pg_stat_statements）
SELECT
    queryid,
    calls,
    total_exec_time,
    mean_exec_time,
    stddev_exec_time,
    min_exec_time,
    max_exec_time,
    substring(query, 1, 100) AS query_preview
FROM pg_stat_statements
WHERE query LIKE '%mix%' OR query LIKE '%docs%'
ORDER BY total_exec_time DESC
LIMIT 10;

-- 索引使用统计
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'docs'
ORDER BY idx_scan DESC;

-- 表统计
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    n_tup_ins,
    n_tup_upd,
    n_tup_del
FROM pg_stat_user_tables
WHERE tablename = 'docs';
```

### 5.2 系统资源监控

```bash
# CPU 和内存监控
sar -u 1 300 > cpu.log &
sar -r 1 300 > memory.log &

# IO 监控
iostat -x 1 300 > io.log &

# 网络监控（如适用）
sar -n DEV 1 300 > network.log &
```

### 5.3 查询计划分析

```sql
-- 分析查询计划
EXPLAIN (ANALYZE, BUFFERS, WAL, SUMMARY, VERBOSE)
WITH s AS (
  SELECT id, ts_rank(to_tsvector('simple', text), plainto_tsquery('simple', 'postgres')) AS tr
  FROM docs
  WHERE to_tsvector('simple', text) @@ plainto_tsquery('simple', 'postgres')
  ORDER BY tr DESC LIMIT 500
), v AS (
  SELECT id, embedding <-> (SELECT embedding FROM docs LIMIT 1) AS dist
  FROM docs
  WHERE id IN (SELECT id FROM s)
  ORDER BY dist ASC LIMIT 100
)
SELECT count(*) FROM v;
```

---

## 6. 结果记录

### 6.1 性能指标记录表

| 测试场景 | TPS | TP50 (ms) | TP95 (ms) | TP99 (ms) | 平均延迟 (ms) | CPU (%) | IO (MB/s) |
|---------|-----|-----------|-----------|-----------|---------------|---------|-----------|
| 基础混合查询 | | | | | | | |
| RRF 融合 | | | | | | | |
| 加权融合 | | | | | | | |
| 结构化过滤+混合 | | | | | | | |

### 6.2 索引参数对比

| 索引类型 | 参数 | TPS | TP95 (ms) | 召回率@100 | 备注 |
|---------|------|-----|-----------|------------|------|
| HNSW | ef_search=40 | | | | |
| HNSW | ef_search=100 | | | | |
| HNSW | ef_search=200 | | | | |
| IVFFlat | probes=10 | | | | |
| IVFFlat | probes=50 | | | | |
| IVFFlat | probes=100 | | | | |

### 6.3 并发度测试结果

| 并发数 | TPS | TP95 (ms) | TP99 (ms) | 错误率 | 备注 |
|--------|-----|-----------|-----------|--------|------|
| 8 | | | | | |
| 16 | | | | | |
| 32 | | | | | |
| 64 | | | | | |
| 128 | | | | | |

### 6.4 记录模板

```markdown
## 测试环境
- **硬件**: CPU型号、内存、存储类型
- **系统**: OS版本、内核版本
- **PostgreSQL版本**: 18.x
- **pgvector版本**: 2.0.x
- **数据规模**: 文档数量、向量维度、索引大小

## 配置参数
- **shared_buffers**:
- **work_mem**:
- **maintenance_work_mem**:
- **effective_cache_size**:
- **max_connections**:

## 测试结果
- **测试时间**:
- **测试脚本**:
- **TPS**:
- **延迟分位**: TP50=, TP95=, TP99=
- **系统资源**: CPU=%, Memory=%, IO=MB/s

## 关键发现
-
-

## 优化建议
-
-
```

---

## 7. 性能调优建议

### 7.1 索引优化

- **HNSW 索引**：适合高精度、低延迟场景
  - `m`: 控制图连接数，建议 16-32
  - `ef_construction`: 构建时精度，建议 100-200
  - `ef_search`: 查询时精度，建议 40-200（越大越慢但越准）

- **IVFFlat 索引**：适合大规模数据、可接受近似结果
  - `lists`: 控制聚类数，建议 `sqrt(rows)`
  - `probes`: 查询时扫描列表数，建议 10-100

### 7.2 查询优化

- **分阶段召回**：先用全文搜索缩小候选集，再用向量搜索精排
- **限制候选集大小**：全文搜索 LIMIT 建议 500-1000
- **使用 RRF**：无需调参，自动融合多路召回结果
- **结构化过滤前置**：在向量搜索前应用时间、分类等过滤条件

### 7.3 系统参数调优

```sql
-- 增加工作内存（用于排序和哈希）
SET work_mem = '256MB';

-- 增加维护工作内存（用于索引构建）
SET maintenance_work_mem = '2GB';

-- 启用并行查询
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;
```

---

## 8. 验证与回归

### 8.1 召回率验证

```sql
-- 对比暴力搜索（真值）与索引搜索的召回率
WITH brute_force AS (
    SELECT id, embedding <-> :query_vector AS dist
    FROM docs
    ORDER BY dist ASC
    LIMIT 100
),
index_search AS (
    SELECT id, embedding <-> :query_vector AS dist
    FROM docs
    ORDER BY embedding <-> :query_vector
    LIMIT 100
)
SELECT
    COUNT(DISTINCT bf.id) AS recall_count,
    COUNT(DISTINCT bf.id)::float / 100.0 AS recall_rate
FROM brute_force bf
INNER JOIN index_search idx ON bf.id = idx.id;
```

### 8.2 性能基线

- 建立性能基线，记录关键指标
- 每次配置变更后对比基线，确保无性能回归
- 定期运行基准测试，监控性能趋势

---

## 9. 参考资源

- **SQL 示例**: `sql/vector_examples.sql`
- **落地指南**: `runbook/04-向量检索与混合查询-落地指南.md`
- **AI 时代专题**: `05-前沿技术/AI-时代/01-向量与混合搜索-pgvector与RRF.md`
- **pgvector 文档**: <https://github.com/pgvector/pgvector>
