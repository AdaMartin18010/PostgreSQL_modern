# 复制延迟-基准模板

> **PostgreSQL版本**: 18 ⭐ | 17 | 16
> **最后更新**: 2025-11-12

---

## 1. 目标

- 在主从架构下测量写负载下的复制延迟（byte_lag / time_lag）与 RPO 影响
- 评估不同同步策略（sync/async）对延迟的影响
- 测试不同写负载下的复制性能
- 评估网络带宽和 IO 对复制延迟的影响

---

## 2. 环境准备

### 2.1 前置条件

- 已配置主从复制（流复制）
- 主库和从库网络连通
- 有足够的写负载生成能力
- 监控工具可用（sar、iostat 等）

### 2.2 复制配置检查

```sql
-- 在主库检查复制配置
SELECT
    name,
    setting,
    unit,
    context
FROM pg_settings
WHERE name IN (
    'wal_level',
    'max_wal_senders',
    'max_replication_slots',
    'synchronous_commit',
    'synchronous_standby_names'
);

-- 检查复制连接状态
SELECT
    application_name,
    client_addr,
    state,
    sync_state,
    sync_priority
FROM pg_stat_replication;
```

### 2.3 从库状态检查

```sql
-- 在从库检查恢复状态
SELECT
    pg_is_in_recovery() AS is_standby,
    pg_last_wal_receive_lsn() AS last_receive_lsn,
    pg_last_wal_replay_lsn() AS last_replay_lsn,
    pg_wal_lsn_diff(
        pg_last_wal_receive_lsn(),
        pg_last_wal_replay_lsn()
    ) AS replay_lag_bytes;
```

---

## 3. 测试方法

### 3.1 基础延迟监控

在主库持续写入，从库监测复制延迟：

```bash
# 在主库运行写负载（只写模式，跳过 SELECT）
pgbench -N -c 32 -j 32 -T 300 postgres
```

```sql
-- 在主库监控复制延迟（定期执行，如每 5 秒）
SELECT
    application_name,
    client_addr,
    state,
    sync_state,
    -- 字节延迟
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS byte_lag,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) AS lag_size,
    -- 时间延迟
    write_lag,
    flush_lag,
    replay_lag,
    -- WAL 位置
    pg_current_wal_lsn() AS current_lsn,
    replay_lsn
FROM pg_stat_replication
ORDER BY byte_lag DESC;
```

### 3.2 延迟趋势监控脚本

创建监控脚本持续记录延迟：

```sql
-- monitor_replication_lag.sql
-- 在主库执行，定期记录延迟数据

CREATE TABLE IF NOT EXISTS replication_lag_history (
    id bigserial PRIMARY KEY,
    recorded_at timestamptz DEFAULT now(),
    application_name text,
    client_addr inet,
    state text,
    sync_state text,
    byte_lag bigint,
    write_lag interval,
    flush_lag interval,
    replay_lag interval,
    current_lsn pg_lsn,
    replay_lsn pg_lsn
);

-- 插入当前延迟数据
INSERT INTO replication_lag_history (
    application_name,
    client_addr,
    state,
    sync_state,
    byte_lag,
    write_lag,
    flush_lag,
    replay_lag,
    current_lsn,
    replay_lsn
)
SELECT
    application_name,
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS byte_lag,
    write_lag,
    flush_lag,
    replay_lag,
    pg_current_wal_lsn() AS current_lsn,
    replay_lsn
FROM pg_stat_replication;
```

```bash
# 定期执行监控脚本（每 5 秒）
watch -n 5 'psql -d postgres -f monitor_replication_lag.sql'
```

---

## 4. 测试场景

### 4.1 不同写负载测试

```bash
# 低负载（8 并发）
pgbench -N -c 8 -j 8 -T 300 postgres > write_low.log 2>&1 &

# 中等负载（32 并发）
pgbench -N -c 32 -j 32 -T 300 postgres > write_medium.log 2>&1 &

# 高负载（64 并发）
pgbench -N -c 64 -j 64 -T 300 postgres > write_high.log 2>&1 &

# 极高负载（128 并发）
pgbench -N -c 128 -j 128 -T 300 postgres > write_extreme.log 2>&1 &
```

### 4.2 不同同步策略测试

#### 异步复制（async）

```sql
-- 在主库设置异步复制
ALTER SYSTEM SET synchronous_commit = 'off';
SELECT pg_reload_conf();

-- 或针对特定会话
SET synchronous_commit = 'off';
```

#### 同步复制（sync）

```sql
-- 在主库设置同步复制
ALTER SYSTEM SET synchronous_commit = 'on';
ALTER SYSTEM SET synchronous_standby_names = 'FIRST 1 (standby1)';
SELECT pg_reload_conf();
```

#### 远程应用（remote_apply）

```sql
-- 等待从库应用完成
ALTER SYSTEM SET synchronous_commit = 'remote_apply';
ALTER SYSTEM SET synchronous_standby_names = 'FIRST 1 (standby1)';
SELECT pg_reload_conf();
```

### 4.3 批量写入测试

```sql
-- 创建批量写入脚本
-- batch_write.sql
\set batch_size 1000
\set batches 100

DO $$
DECLARE
    i int;
BEGIN
    FOR i IN 1..:batches LOOP
        INSERT INTO test_table (data)
        SELECT md5(random()::text)
        FROM generate_series(1, :batch_size);
        COMMIT;
    END LOOP;
END $$;
```

```bash
# 运行批量写入测试
pgbench -f batch_write.sql -c 1 -j 1 -T 300 postgres
```

---

## 5. 监控指标

### 5.1 复制延迟指标

```sql
-- 实时延迟查询
SELECT
    application_name,
    -- 字节延迟（最重要）
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS byte_lag,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) AS lag_size,
    -- 时间延迟
    write_lag AS write_delay,
    flush_lag AS flush_delay,
    replay_lag AS replay_delay,
    -- 延迟评估
    CASE
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) > 1024*1024*1024 THEN 'HIGH'  -- > 1GB
        WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) > 100*1024*1024 THEN 'MEDIUM'  -- > 100MB
        ELSE 'LOW'
    END AS lag_severity
FROM pg_stat_replication
ORDER BY byte_lag DESC;
```

### 5.2 延迟趋势分析

```sql
-- 分析延迟趋势（使用之前创建的历史表）
SELECT
    recorded_at,
    application_name,
    byte_lag,
    replay_lag,
    -- 计算延迟变化率
    byte_lag - LAG(byte_lag) OVER (PARTITION BY application_name ORDER BY recorded_at) AS byte_lag_delta,
    -- 计算平均延迟
    AVG(byte_lag) OVER (
        PARTITION BY application_name
        ORDER BY recorded_at
        ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
    ) AS avg_byte_lag_10s
FROM replication_lag_history
WHERE recorded_at >= now() - interval '1 hour'
ORDER BY recorded_at DESC;
```

### 5.3 WAL 生成速率

```sql
-- 监控 WAL 生成速率
SELECT
    pg_size_pretty(pg_current_wal_lsn() - '0/0') AS current_wal_size,
    pg_walfile_name(pg_current_wal_lsn()) AS current_wal_file;

-- 定期采样计算 WAL 生成速率
-- 需要定期执行并记录时间戳
```

### 5.4 系统资源监控

```bash
# 在主库监控
sar -u 1 300 > master_cpu.log &
sar -r 1 300 > master_memory.log &
iostat -x 1 300 > master_io.log &
sar -n DEV 1 300 > master_network.log &

# 在从库监控
sar -u 1 300 > replica_cpu.log &
sar -r 1 300 > replica_memory.log &
iostat -x 1 300 > replica_io.log &
sar -n DEV 1 300 > replica_network.log &
```

### 5.5 PostgreSQL 指标

```sql
-- 主库 WAL 统计
SELECT
    wal_records,
    wal_fpi,
    wal_bytes,
    wal_buffers_full,
    wal_write,
    wal_sync,
    wal_write_time,
    wal_sync_time
FROM pg_stat_wal;

-- 从库恢复统计
SELECT
    pg_stat_get_wal_receiver() AS wal_receiver_stats;

-- 复制槽状态（如使用）
SELECT
    slot_name,
    slot_type,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) AS retained_wal_bytes,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS retained_wal_size
FROM pg_replication_slots;
```

---

## 6. 结果记录

### 6.1 延迟记录表

| 测试场景 | 写负载 (TPS) | 平均字节延迟 (MB) | 最大字节延迟 (MB) | 平均时间延迟 (ms) | 最大时间延迟 (ms) | 同步策略 |
|---------|-------------|-----------------|-----------------|-----------------|-----------------|---------|
| 低负载 (c=8) | | | | | | async |
| 中等负载 (c=32) | | | | | | async |
| 高负载 (c=64) | | | | | | async |
| 中等负载 (c=32) | | | | | | sync |
| 中等负载 (c=32) | | | | | | remote_apply |

### 6.2 延迟曲线数据

记录不同时间点的延迟值，用于绘制延迟曲线：

```sql
-- 导出延迟历史数据
COPY (
    SELECT
        recorded_at,
        application_name,
        byte_lag,
        EXTRACT(EPOCH FROM replay_lag) * 1000 AS replay_lag_ms
    FROM replication_lag_history
    WHERE recorded_at >= now() - interval '1 hour'
    ORDER BY recorded_at
) TO '/tmp/replication_lag.csv' WITH CSV HEADER;
```

### 6.3 同步策略对比

| 同步策略 | 平均延迟 (ms) | 最大延迟 (ms) | TPS 影响 (%) | RPO | RTO |
|---------|--------------|--------------|-------------|-----|-----|
| async | | | 0% | 可能丢失数据 | 较快 |
| sync | | | -X% | 无数据丢失 | 较慢 |
| remote_apply | | | -Y% | 无数据丢失 | 最慢 |

### 6.4 记录模板

```markdown
## 测试环境
- **硬件（主库）**: CPU型号、内存、存储类型
- **硬件（从库）**: CPU型号、内存、存储类型
- **网络**: 带宽、延迟
- **系统**: OS版本、内核版本
- **PostgreSQL版本**: 18.x

## 配置参数
- **wal_level**:
- **max_wal_senders**:
- **synchronous_commit**:
- **synchronous_standby_names**:
- **wal_buffers**:
- **max_wal_size**:

## 测试结果
- **测试时间**:
- **写负载**: TPS=
- **平均字节延迟**:
- **最大字节延迟**:
- **平均时间延迟**:
- **最大时间延迟**:
- **系统资源**: CPU=%, Memory=%, IO=MB/s, Network=MB/s

## 关键发现
-
-

## 优化建议
-
-
```

---

## 7. 性能调优建议

### 7.1 减少复制延迟

1. **优化网络**：
   - 使用低延迟网络连接
   - 增加网络带宽
   - 减少网络跳数

2. **优化从库性能**：
   - 提高从库 CPU 和 IO 性能
   - 优化 `max_wal_senders` 和 `wal_receiver_timeout`
   - 使用 SSD 存储

3. **优化 WAL 设置**：
   - 调整 `wal_buffers` 和 `max_wal_size`
   - 考虑使用 `wal_compression`

### 7.2 同步策略选择

- **异步复制（async）**：性能最好，但可能丢失数据
- **同步复制（sync）**：保证数据不丢失，但影响主库性能
- **远程应用（remote_apply）**：最安全，但延迟最高

### 7.3 监控告警

```sql
-- 创建延迟告警查询
SELECT
    'REPLICATION_LAG_ALERT' AS alert_type,
    application_name,
    client_addr,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS byte_lag,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) AS lag_size
FROM pg_stat_replication
WHERE pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) > 100*1024*1024  -- > 100MB
ORDER BY byte_lag DESC;
```

---

## 8. 故障排查

### 8.1 延迟突然增加

- 检查从库是否正常运行
- 检查网络连接是否正常
- 检查从库 IO 性能
- 检查是否有长时间运行的查询阻塞恢复

### 8.2 复制连接断开

```sql
-- 检查复制槽状态
SELECT * FROM pg_replication_slots WHERE active = false;

-- 检查 WAL 保留
SELECT
    slot_name,
    pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS retained_wal
FROM pg_replication_slots;
```

### 8.3 从库恢复慢

```sql
-- 在从库检查恢复进度
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    sync_state,
    sync_priority,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS byte_lag
FROM pg_stat_replication;
```

---

## 9. 参考资源

- **SQL 监控脚本**: `../sql/ha_monitoring.sql`
- **高可用部署**: `../04-部署运维/`
- **PostgreSQL 官方文档**: <https://www.postgresql.org/docs/current/high-availability.html>
- **流复制配置**: <https://www.postgresql.org/docs/current/warm-standby.html>
