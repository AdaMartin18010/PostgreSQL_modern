# PostgreSQLæµå¤„ç†ä¸CEPå®Œæ•´æŒ‡å—

> **ç‰ˆæœ¬**: v3.0
> **æœ€åæ›´æ–°**: 2025-01-15
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­â­
> **åº”ç”¨åœºæ™¯**: å®æ—¶æ•°æ®å¤„ç†ã€å¤æ‚äº‹ä»¶å¤„ç†ã€æµå¼åˆ†æã€IoTæ•°æ®å¤„ç†ã€å®æ—¶ç›‘æ§

---

## ğŸ“‘ ç›®å½•

- [PostgreSQLæµå¤„ç†ä¸CEPå®Œæ•´æŒ‡å—](#postgresqlæµå¤„ç†ä¸cepå®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 æµå¤„ç†æ¦‚å¿µ](#11-æµå¤„ç†æ¦‚å¿µ)
    - [1.2 CEPæ¦‚å¿µ](#12-cepæ¦‚å¿µ)
    - [1.3 PostgreSQLæµå¤„ç†èƒ½åŠ›](#13-postgresqlæµå¤„ç†èƒ½åŠ›)
    - [1.4 é€‚ç”¨åœºæ™¯](#14-é€‚ç”¨åœºæ™¯)
  - [äºŒã€æ—¶é—´ä¸çª—å£æ¨¡å‹](#äºŒæ—¶é—´ä¸çª—å£æ¨¡å‹)
    - [2.1 æ—¶é—´è¯­ä¹‰](#21-æ—¶é—´è¯­ä¹‰)
    - [2.2 çª—å£ç±»å‹](#22-çª—å£ç±»å‹)
      - [2.2.1 æ»šåŠ¨çª—å£ï¼ˆTumbling Windowï¼‰](#221-æ»šåŠ¨çª—å£tumbling-window)
      - [2.2.2 æ»‘åŠ¨çª—å£ï¼ˆSliding Windowï¼‰](#222-æ»‘åŠ¨çª—å£sliding-window)
      - [2.2.3 ä¼šè¯çª—å£ï¼ˆSession Windowï¼‰](#223-ä¼šè¯çª—å£session-window)
    - [2.3 æ°´å°æœºåˆ¶](#23-æ°´å°æœºåˆ¶)
    - [2.4 è¿Ÿåˆ°æ•°æ®å¤„ç†](#24-è¿Ÿåˆ°æ•°æ®å¤„ç†)
  - [ä¸‰ã€PostgreSQLå®ç°è·¯å¾„](#ä¸‰postgresqlå®ç°è·¯å¾„)
    - [3.1 å¢é‡ç‰©åŒ–è§†å›¾](#31-å¢é‡ç‰©åŒ–è§†å›¾)
      - [3.1.1 åˆ›å»ºç‰©åŒ–è§†å›¾](#311-åˆ›å»ºç‰©åŒ–è§†å›¾)
      - [3.1.2 å¢é‡åˆ·æ–°](#312-å¢é‡åˆ·æ–°)
      - [3.1.3 å¢é‡æ›´æ–°ç­–ç•¥](#313-å¢é‡æ›´æ–°ç­–ç•¥)
    - [3.2 LISTEN/NOTIFYæœºåˆ¶](#32-listennotifyæœºåˆ¶)
      - [3.2.1 å‘é€é€šçŸ¥](#321-å‘é€é€šçŸ¥)
      - [3.2.2 ç›‘å¬é€šçŸ¥](#322-ç›‘å¬é€šçŸ¥)
    - [3.3 å¤–éƒ¨æ•°æ®åŒ…è£…å™¨ï¼ˆFDWï¼‰](#33-å¤–éƒ¨æ•°æ®åŒ…è£…å™¨fdw)
      - [3.3.1 Kafka FDWé›†æˆ](#331-kafka-fdwé›†æˆ)
    - [3.4 æµå¼è§†å›¾](#34-æµå¼è§†å›¾)
    - [3.5 è§¦å‘å™¨é©±åŠ¨å¤„ç†](#35-è§¦å‘å™¨é©±åŠ¨å¤„ç†)
  - [å››ã€CEPæ¨¡å¼åŒ¹é…](#å››cepæ¨¡å¼åŒ¹é…)
    - [4.1 ç®€å•æ¨¡å¼åŒ¹é…](#41-ç®€å•æ¨¡å¼åŒ¹é…)
    - [4.2 åºåˆ—æ¨¡å¼](#42-åºåˆ—æ¨¡å¼)
    - [4.3 å¤æ‚æ¨¡å¼](#43-å¤æ‚æ¨¡å¼)
    - [4.4 æ¨¡å¼ä¼˜åŒ–](#44-æ¨¡å¼ä¼˜åŒ–)
  - [äº”ã€PostgreSQL 18ä¼˜åŒ–](#äº”postgresql-18ä¼˜åŒ–)
    - [5.1 å¼‚æ­¥I/Oä¼˜åŒ–](#51-å¼‚æ­¥ioä¼˜åŒ–)
    - [5.2 å¹¶è¡ŒæŸ¥è¯¢å¢å¼º](#52-å¹¶è¡ŒæŸ¥è¯¢å¢å¼º)
    - [5.3 ç‰©åŒ–è§†å›¾ä¼˜åŒ–](#53-ç‰©åŒ–è§†å›¾ä¼˜åŒ–)
  - [å…­ã€çŸ¥è¯†çŸ©é˜µå¯¹æ¯”](#å…­çŸ¥è¯†çŸ©é˜µå¯¹æ¯”)
    - [6.1 æµå¤„ç†æ–¹æ¡ˆå¯¹æ¯”](#61-æµå¤„ç†æ–¹æ¡ˆå¯¹æ¯”)
    - [6.2 çª—å£ç±»å‹å¯¹æ¯”](#62-çª—å£ç±»å‹å¯¹æ¯”)
    - [6.3 CEPå¼•æ“å¯¹æ¯”](#63-cepå¼•æ“å¯¹æ¯”)
  - [ä¸ƒã€å®è·µæ¡ˆä¾‹](#ä¸ƒå®è·µæ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: å®æ—¶è®¢å•çŠ¶æ€ç›‘æ§](#æ¡ˆä¾‹1-å®æ—¶è®¢å•çŠ¶æ€ç›‘æ§)
    - [æ¡ˆä¾‹2: IoTè®¾å¤‡å¼‚å¸¸æ£€æµ‹](#æ¡ˆä¾‹2-iotè®¾å¤‡å¼‚å¸¸æ£€æµ‹)
    - [æ¡ˆä¾‹3: ç”¨æˆ·è¡Œä¸ºåºåˆ—åˆ†æ](#æ¡ˆä¾‹3-ç”¨æˆ·è¡Œä¸ºåºåˆ—åˆ†æ)
  - [å…«ã€æ€§èƒ½ä¼˜åŒ–](#å…«æ€§èƒ½ä¼˜åŒ–)
    - [8.1 æŸ¥è¯¢ä¼˜åŒ–](#81-æŸ¥è¯¢ä¼˜åŒ–)
    - [8.2 ç´¢å¼•ä¼˜åŒ–](#82-ç´¢å¼•ä¼˜åŒ–)
    - [8.3 åˆ†åŒºä¼˜åŒ–](#83-åˆ†åŒºä¼˜åŒ–)
  - [ä¹ã€ç›‘æ§ä¸è¯Šæ–­](#ä¹ç›‘æ§ä¸è¯Šæ–­)
    - [9.1 å»¶è¿Ÿç›‘æ§](#91-å»¶è¿Ÿç›‘æ§)
    - [9.2 ååé‡ç›‘æ§](#92-ååé‡ç›‘æ§)
    - [9.3 é—®é¢˜æ’æŸ¥](#93-é—®é¢˜æ’æŸ¥)
  - [åã€æœ€ä½³å®è·µ](#åæœ€ä½³å®è·µ)
    - [10.1 è®¾è®¡æœ€ä½³å®è·µ](#101-è®¾è®¡æœ€ä½³å®è·µ)
    - [10.2 å¼€å‘æœ€ä½³å®è·µ](#102-å¼€å‘æœ€ä½³å®è·µ)
  - [åä¸€ã€å‚è€ƒèµ„æº](#åä¸€å‚è€ƒèµ„æº)
    - [11.1 å®˜æ–¹æ–‡æ¡£](#111-å®˜æ–¹æ–‡æ¡£)
    - [11.2 ç›¸å…³æ–‡æ¡£](#112-ç›¸å…³æ–‡æ¡£)
    - [11.3 å¤–éƒ¨èµ„æº](#113-å¤–éƒ¨èµ„æº)
  - [åäºŒã€å‚è€ƒæ–‡çŒ®](#åäºŒå‚è€ƒæ–‡çŒ®)

---

## ä¸€ã€æ¦‚è¿°

### 1.1 æµå¤„ç†æ¦‚å¿µ

**æµå¤„ç†ï¼ˆStream Processingï¼‰**æ˜¯ä¸€ç§æ•°æ®å¤„ç†èŒƒå¼ï¼Œç”¨äºå¤„ç†è¿ç»­ä¸æ–­çš„æ•°æ®æµã€‚ä¸æ‰¹å¤„ç†ä¸åŒï¼Œæµå¤„ç†æ˜¯å®æ—¶æˆ–è¿‘å®æ—¶çš„æ•°æ®å¤„ç†æ–¹å¼ã€‚

**æµå¤„ç†çš„æ ¸å¿ƒç‰¹å¾**ï¼š

- **æ— ç•Œæ•°æ®æµ**ï¼šæ•°æ®æŒç»­äº§ç”Ÿï¼Œæ²¡æœ‰æ˜ç¡®çš„ç»“æŸ
- **ä½å»¶è¿Ÿ**ï¼šè¦æ±‚æ¯«ç§’çº§æˆ–ç§’çº§çš„å¤„ç†å»¶è¿Ÿ
- **é«˜åå**ï¼šèƒ½å¤Ÿå¤„ç†å¤§é‡æ•°æ®æµ
- **äº‹ä»¶é©±åŠ¨**ï¼šåŸºäºäº‹ä»¶è§¦å‘å¤„ç†é€»è¾‘

**æµå¤„ç†çš„åº”ç”¨åœºæ™¯**ï¼š

- å®æ—¶ç›‘æ§å’Œå‘Šè­¦
- å®æ—¶æ•°æ®åˆ†æå’Œç»Ÿè®¡
- å®æ—¶æ¨èç³»ç»Ÿ
- IoTæ•°æ®å¤„ç†
- æ—¥å¿—å®æ—¶åˆ†æ

### 1.2 CEPæ¦‚å¿µ

**å¤æ‚äº‹ä»¶å¤„ç†ï¼ˆComplex Event Processing, CEPï¼‰**æ˜¯ä¸€ç§ä»å¤šä¸ªäº‹ä»¶æµä¸­è¯†åˆ«å¤æ‚æ¨¡å¼çš„æŠ€æœ¯ã€‚CEPç”¨äºæ£€æµ‹äº‹ä»¶åºåˆ—ä¸­çš„ç‰¹å®šæ¨¡å¼ï¼Œå¹¶è§¦å‘ç›¸åº”çš„åŠ¨ä½œã€‚

**CEPçš„æ ¸å¿ƒæ¦‚å¿µ**ï¼š

- **äº‹ä»¶ï¼ˆEventï¼‰**ï¼šæ•°æ®æµä¸­çš„å•ä¸ªæ•°æ®é¡¹
- **æ¨¡å¼ï¼ˆPatternï¼‰**ï¼šäº‹ä»¶åºåˆ—çš„è§„åˆ™å®šä¹‰
- **çª—å£ï¼ˆWindowï¼‰**ï¼šæ¨¡å¼åŒ¹é…çš„æ—¶é—´èŒƒå›´
- **è§„åˆ™ï¼ˆRuleï¼‰**ï¼šæ¨¡å¼åŒ¹é…çš„æ¡ä»¶å’ŒåŠ¨ä½œ

**CEPçš„åº”ç”¨åœºæ™¯**ï¼š

- å¼‚å¸¸æ£€æµ‹å’Œå‘Šè­¦
- æ¬ºè¯ˆæ£€æµ‹
- ä¸šåŠ¡æµç¨‹ç›‘æ§
- å®æ—¶æ¨èè§¦å‘

### 1.3 PostgreSQLæµå¤„ç†èƒ½åŠ›

PostgreSQLè™½ç„¶ä¸æ˜¯ä¸“é—¨çš„æµå¤„ç†æ•°æ®åº“ï¼Œä½†æä¾›äº†å¤šç§æœºåˆ¶æ”¯æŒæµå¼æ•°æ®å¤„ç†ï¼š

**æ ¸å¿ƒèƒ½åŠ›**ï¼š

1. **ç‰©åŒ–è§†å›¾**ï¼šæ”¯æŒå¢é‡åˆ·æ–°ï¼Œå®ç°è¿‘å®æ—¶èšåˆ
2. **LISTEN/NOTIFY**ï¼šäº‹ä»¶é€šçŸ¥æœºåˆ¶ï¼Œæ”¯æŒäº‹ä»¶é©±åŠ¨å¤„ç†
3. **å¤–éƒ¨æ•°æ®åŒ…è£…å™¨ï¼ˆFDWï¼‰**ï¼šé›†æˆKafkaã€Redisç­‰æµæ•°æ®æº
4. **è§¦å‘å™¨**ï¼šå®æ—¶å“åº”æ•°æ®å˜æ›´
5. **é€’å½’CTE**ï¼šæ”¯æŒå¤æ‚æ¨¡å¼åŒ¹é…
6. **çª—å£å‡½æ•°**ï¼šæ”¯æŒæ»‘åŠ¨çª—å£è®¡ç®—

**PostgreSQL 18å¢å¼º**ï¼š

- å¼‚æ­¥I/Oï¼šæå‡æµå¤„ç†æ€§èƒ½
- å¹¶è¡ŒæŸ¥è¯¢å¢å¼ºï¼šåŠ é€Ÿèšåˆè®¡ç®—
- ç‰©åŒ–è§†å›¾ä¼˜åŒ–ï¼šæ›´é«˜æ•ˆçš„å¢é‡åˆ·æ–°

### 1.4 é€‚ç”¨åœºæ™¯

**PostgreSQLæµå¤„ç†é€‚ç”¨äº**ï¼š

- âœ… **è¿‘å®æ—¶åˆ†æ**ï¼šç§’çº§åˆ°åˆ†é’Ÿçº§çš„å®æ—¶ç»Ÿè®¡
- âœ… **äº‹ä»¶é©±åŠ¨åº”ç”¨**ï¼šåŸºäºäº‹ä»¶è§¦å‘çš„ä¸šåŠ¡é€»è¾‘
- âœ… **IoTæ•°æ®å¤„ç†**ï¼šè®¾å¤‡æ•°æ®å®æ—¶å¤„ç†å’Œåˆ†æ
- âœ… **æ—¥å¿—åˆ†æ**ï¼šå®æ—¶æ—¥å¿—èšåˆå’Œå‘Šè­¦
- âœ… **ä¸šåŠ¡ç›‘æ§**ï¼šå®æ—¶ä¸šåŠ¡æŒ‡æ ‡è®¡ç®—

**ä¸é€‚ç”¨åœºæ™¯**ï¼š

- âŒ æ¯«ç§’çº§å»¶è¿Ÿè¦æ±‚çš„åœºæ™¯ï¼ˆå»ºè®®ä½¿ç”¨Flinkã€Kafka Streamsï¼‰
- âŒ è¶…å¤§è§„æ¨¡æµå¤„ç†ï¼ˆå»ºè®®ä½¿ç”¨ä¸“é—¨çš„æµå¤„ç†å¼•æ“ï¼‰
- âŒ å¤æ‚çš„æµå¼SQLæŸ¥è¯¢ï¼ˆå»ºè®®ä½¿ç”¨Flink SQLï¼‰

---

## äºŒã€æ—¶é—´ä¸çª—å£æ¨¡å‹

### 2.1 æ—¶é—´è¯­ä¹‰

**äº‹ä»¶æ—¶é—´ï¼ˆEvent Timeï¼‰**ï¼šäº‹ä»¶å®é™…å‘ç”Ÿçš„æ—¶é—´ï¼Œé€šå¸¸ç”±äº‹ä»¶æ•°æ®ä¸­çš„æ—¶é—´æˆ³å­—æ®µè¡¨ç¤ºã€‚

**å¤„ç†æ—¶é—´ï¼ˆProcessing Timeï¼‰**ï¼šäº‹ä»¶è¢«ç³»ç»Ÿå¤„ç†çš„æ—¶é—´ï¼Œé€šå¸¸æ˜¯å½“å‰ç³»ç»Ÿæ—¶é—´ã€‚

**å¯¹æ¯”**ï¼š

| æ—¶é—´ç±»å‹ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|------|------|---------|
| äº‹ä»¶æ—¶é—´ | å‡†ç¡®åæ˜ äº‹ä»¶å‘ç”Ÿæ—¶é—´ | éœ€è¦å¤„ç†ä¹±åºå’Œè¿Ÿåˆ°æ•°æ® | å†å²æ•°æ®åˆ†æã€ç²¾ç¡®æ—¶é—´è¦æ±‚ |
| å¤„ç†æ—¶é—´ | ç®€å•ï¼Œæ— éœ€å¤„ç†ä¹±åº | ä¸å‡†ç¡®ï¼Œå—å¤„ç†å»¶è¿Ÿå½±å“ | å®æ—¶ç›‘æ§ã€ä½å»¶è¿Ÿè¦æ±‚ |

**PostgreSQLå®ç°**ï¼š

```sql
-- ä½¿ç”¨äº‹ä»¶æ—¶é—´
SELECT
    event_time,  -- äº‹ä»¶æ—¶é—´
    COUNT(*) AS event_count
FROM events
WHERE event_time >= now() - interval '1 hour'
GROUP BY date_trunc('minute', event_time);

-- ä½¿ç”¨å¤„ç†æ—¶é—´
SELECT
    now() AS processing_time,  -- å¤„ç†æ—¶é—´
    COUNT(*) AS event_count
FROM events
WHERE created_at >= now() - interval '1 hour';
```

### 2.2 çª—å£ç±»å‹

#### 2.2.1 æ»šåŠ¨çª—å£ï¼ˆTumbling Windowï¼‰

æ»šåŠ¨çª—å£æ˜¯å›ºå®šå¤§å°ã€ä¸é‡å çš„æ—¶é—´çª—å£ã€‚

```sql
-- æ»šåŠ¨çª—å£ï¼ˆæŒ‰åˆ†é’Ÿèšåˆï¼‰
SELECT
    date_trunc('minute', event_time) AS window_start,
    COUNT(*) AS event_count,
    SUM(value) AS total_value
FROM events
WHERE event_time >= now() - interval '1 hour'
GROUP BY date_trunc('minute', event_time)
ORDER BY window_start;
```

#### 2.2.2 æ»‘åŠ¨çª—å£ï¼ˆSliding Windowï¼‰

æ»‘åŠ¨çª—å£æ˜¯å›ºå®šå¤§å°ã€æœ‰é‡å çš„æ—¶é—´çª—å£ã€‚

```sql
-- æ»‘åŠ¨çª—å£ï¼ˆ5åˆ†é’Ÿçª—å£ï¼Œ1åˆ†é’Ÿæ»‘åŠ¨ï¼‰
WITH time_windows AS (
    SELECT
        generate_series(
            date_trunc('minute', now() - interval '1 hour'),
            date_trunc('minute', now()),
            interval '1 minute'
        ) AS window_start
)
SELECT
    tw.window_start,
    COUNT(e.*) AS event_count,
    SUM(e.value) AS total_value
FROM time_windows tw
LEFT JOIN events e ON
    e.event_time >= tw.window_start
    AND e.event_time < tw.window_start + interval '5 minutes'
GROUP BY tw.window_start
ORDER BY tw.window_start;
```

#### 2.2.3 ä¼šè¯çª—å£ï¼ˆSession Windowï¼‰

ä¼šè¯çª—å£åŸºäºäº‹ä»¶ä¹‹é—´çš„æ—¶é—´é—´éš”ï¼Œå½“é—´éš”è¶…è¿‡é˜ˆå€¼æ—¶åˆ›å»ºæ–°çª—å£ã€‚

```sql
-- ä¼šè¯çª—å£ï¼ˆ30åˆ†é’Ÿæ— æ´»åŠ¨åˆ™æ–°ä¼šè¯ï¼‰
WITH session_events AS (
    SELECT
        user_id,
        event_time,
        LAG(event_time) OVER (PARTITION BY user_id ORDER BY event_time) AS prev_time,
        CASE
            WHEN event_time - LAG(event_time) OVER (PARTITION BY user_id ORDER BY event_time) > interval '30 minutes'
            THEN 1
            ELSE 0
        END AS new_session
    FROM events
    WHERE user_id IS NOT NULL
),
session_ids AS (
    SELECT
        user_id,
        event_time,
        SUM(new_session) OVER (PARTITION BY user_id ORDER BY event_time) AS session_id
    FROM session_events
)
SELECT
    user_id,
    session_id,
    MIN(event_time) AS session_start,
    MAX(event_time) AS session_end,
    COUNT(*) AS event_count
FROM session_ids
GROUP BY user_id, session_id;
```

### 2.3 æ°´å°æœºåˆ¶

**æ°´å°ï¼ˆWatermarkï¼‰**ç”¨äºå¤„ç†ä¹±åºå’Œè¿Ÿåˆ°æ•°æ®ï¼Œå®šä¹‰äº‹ä»¶æ—¶é—´çš„æœ€å¤§å…è®¸å»¶è¿Ÿã€‚

```sql
-- æ°´å°å®ç°ï¼šåªå¤„ç†äº‹ä»¶æ—¶é—´åœ¨é˜ˆå€¼å†…çš„æ•°æ®
SELECT
    date_trunc('minute', event_time) AS window_start,
    COUNT(*) AS event_count
FROM events
WHERE event_time >= now() - interval '1 hour'  -- æ°´å°ï¼šåªå¤„ç†1å°æ—¶å†…çš„æ•°æ®
  AND event_time <= now() - interval '5 minutes'  -- å…è®¸5åˆ†é’Ÿå»¶è¿Ÿ
GROUP BY date_trunc('minute', event_time);
```

### 2.4 è¿Ÿåˆ°æ•°æ®å¤„ç†

**è¿Ÿåˆ°æ•°æ®å¤„ç†ç­–ç•¥**ï¼š

1. **ä¸¢å¼ƒï¼ˆDropï¼‰**ï¼šç›´æ¥ä¸¢å¼ƒè¿Ÿåˆ°æ•°æ®
2. **è¡¥å‘ï¼ˆSide Outputï¼‰**ï¼šå°†è¿Ÿåˆ°æ•°æ®å‘é€åˆ°ä¾§è¾“å‡ºæµ
3. **æ›´æ­£ï¼ˆUpdateï¼‰**ï¼šæ›´æ–°ä¹‹å‰çš„ç»“æœ

```sql
-- è¿Ÿåˆ°æ•°æ®å¤„ç†ï¼šä¿ç•™å®½æ¾çª—å£ç”¨äºå›è¡¥
CREATE MATERIALIZED VIEW event_stats_5min AS
SELECT
    date_trunc('minute', event_time) -
    (EXTRACT(MINUTE FROM event_time)::int % 5) * interval '1 minute' AS window_start,
    COUNT(*) AS event_count,
    MAX(event_time) AS latest_event_time
FROM events
WHERE event_time >= now() - interval '2 hours'  -- ä¿ç•™2å°æ—¶çª—å£ç”¨äºå›è¡¥
GROUP BY window_start;

-- å®šæœŸåˆ·æ–°ä»¥å¤„ç†è¿Ÿåˆ°æ•°æ®
REFRESH MATERIALIZED VIEW CONCURRENTLY event_stats_5min;
```

## ä¸‰ã€PostgreSQLå®ç°è·¯å¾„

### 3.1 å¢é‡ç‰©åŒ–è§†å›¾

**ç‰©åŒ–è§†å›¾**æ˜¯PostgreSQLå®ç°æµå¤„ç†çš„æ ¸å¿ƒæœºåˆ¶ï¼Œæ”¯æŒå¢é‡åˆ·æ–°ã€‚

#### 3.1.1 åˆ›å»ºç‰©åŒ–è§†å›¾

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾ç”¨äºå®æ—¶ç»Ÿè®¡
CREATE MATERIALIZED VIEW order_stats_5min AS
SELECT
    date_trunc('minute', created_at) -
    (EXTRACT(MINUTE FROM created_at)::int % 5) * interval '1 minute' AS time_window,
    status,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount
FROM orders
WHERE created_at >= now() - interval '1 hour'
GROUP BY time_window, status;

-- åˆ›å»ºå”¯ä¸€ç´¢å¼•æ”¯æŒå¹¶å‘åˆ·æ–°
CREATE UNIQUE INDEX ON order_stats_5min (time_window, status);
```

#### 3.1.2 å¢é‡åˆ·æ–°

```sql
-- å¹¶å‘åˆ·æ–°ï¼ˆä¸é˜»å¡æŸ¥è¯¢ï¼‰
REFRESH MATERIALIZED VIEW CONCURRENTLY order_stats_5min;

-- ä½¿ç”¨pg_cronå®šæ—¶åˆ·æ–°
SELECT cron.schedule(
    'refresh-order-stats',
    '*/1 * * * *',  -- æ¯åˆ†é’Ÿæ‰§è¡Œ
    $$REFRESH MATERIALIZED VIEW CONCURRENTLY order_stats_5min$$
);
```

#### 3.1.3 å¢é‡æ›´æ–°ç­–ç•¥

```sql
-- ä½¿ç”¨è§¦å‘å™¨å®ç°å¢é‡æ›´æ–°
CREATE OR REPLACE FUNCTION update_order_stats()
RETURNS TRIGGER AS $$
DECLARE
    window_start TIMESTAMPTZ;
BEGIN
    window_start := date_trunc('minute', NEW.created_at) -
        (EXTRACT(MINUTE FROM NEW.created_at)::int % 5) * interval '1 minute';

    INSERT INTO order_stats_5min (time_window, status, order_count, total_amount, avg_amount)
    VALUES (window_start, NEW.status, 1, NEW.amount, NEW.amount)
    ON CONFLICT (time_window, status)
    DO UPDATE SET
        order_count = order_stats_5min.order_count + 1,
        total_amount = order_stats_5min.total_amount + NEW.amount,
        avg_amount = (order_stats_5min.total_amount + NEW.amount) / (order_stats_5min.order_count + 1);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER order_stats_trigger
AFTER INSERT ON orders
FOR EACH ROW
EXECUTE FUNCTION update_order_stats();
```

### 3.2 LISTEN/NOTIFYæœºåˆ¶

**LISTEN/NOTIFY**æ˜¯PostgreSQLçš„äº‹ä»¶é€šçŸ¥æœºåˆ¶ï¼Œæ”¯æŒäº‹ä»¶é©±åŠ¨å¤„ç†ã€‚

#### 3.2.1 å‘é€é€šçŸ¥

```sql
-- åœ¨è§¦å‘å™¨ä¸­å‘é€é€šçŸ¥
CREATE OR REPLACE FUNCTION notify_order_event()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        'order_events',
        json_build_object(
            'order_id', NEW.order_id,
            'status', NEW.status,
            'amount', NEW.amount,
            'timestamp', NEW.created_at
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER order_notify_trigger
AFTER INSERT OR UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION notify_order_event();
```

#### 3.2.2 ç›‘å¬é€šçŸ¥

```python
# Pythonç¤ºä¾‹ï¼šç›‘å¬PostgreSQLé€šçŸ¥
import psycopg2
import select

conn = psycopg2.connect(
    host="localhost",
    database="mydb",
    user="postgres",
    password="password"
)
conn.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)

cur = conn.cursor()
cur.execute("LISTEN order_events;")

while True:
    if select.select([conn], [], [], 5) == ([], [], []):
        print("Timeout")
    else:
        conn.poll()
        while conn.notifies:
            notify = conn.notifies.pop(0)
            print(f"Got NOTIFY: {notify.payload}")
            # å¤„ç†äº‹ä»¶
```

### 3.3 å¤–éƒ¨æ•°æ®åŒ…è£…å™¨ï¼ˆFDWï¼‰

**FDW**å…è®¸PostgreSQLè®¿é—®å¤–éƒ¨æ•°æ®æºï¼Œå¦‚Kafkaã€Redisç­‰ã€‚

#### 3.3.1 Kafka FDWé›†æˆ

```sql
-- å®‰è£…kafka_fdwæ‰©å±•ï¼ˆéœ€è¦å•ç‹¬å®‰è£…ï¼‰
CREATE EXTENSION IF NOT EXISTS kafka_fdw;

-- åˆ›å»ºKafkaæœåŠ¡å™¨
CREATE SERVER kafka_server
FOREIGN DATA WRAPPER kafka_fdw
OPTIONS (
    broker 'localhost:9092',
    format 'json'
);

-- åˆ›å»ºå¤–éƒ¨è¡¨
CREATE FOREIGN TABLE kafka_events (
    event_id BIGINT,
    event_type VARCHAR(50),
    event_data JSONB,
    event_time TIMESTAMPTZ
)
SERVER kafka_server
OPTIONS (
    topic 'events',
    partition '0'
);

-- æŸ¥è¯¢Kafkaæ•°æ®
SELECT * FROM kafka_events
WHERE event_time >= now() - interval '1 hour';
```

### 3.4 æµå¼è§†å›¾

**æµå¼è§†å›¾**åŸºäºæ—¶é—´åˆ†åŒºå’Œç´¢å¼•æ‰«æå®ç°è¿‘å®æ—¶æŸ¥è¯¢ã€‚

```sql
-- åˆ›å»ºæ—¶é—´åˆ†åŒºè¡¨
CREATE TABLE events (
    event_id BIGSERIAL,
    event_type VARCHAR(50),
    event_data JSONB,
    event_time TIMESTAMPTZ NOT NULL
) PARTITION BY RANGE (event_time);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE events_2025_01 PARTITION OF events
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON events (event_time, event_type);

-- æµå¼æŸ¥è¯¢
SELECT
    date_trunc('minute', event_time) AS window_start,
    event_type,
    COUNT(*) AS event_count
FROM events
WHERE event_time >= now() - interval '30 minutes'
GROUP BY window_start, event_type
ORDER BY window_start;
```

### 3.5 è§¦å‘å™¨é©±åŠ¨å¤„ç†

**è§¦å‘å™¨**å¯ä»¥åœ¨æ•°æ®å˜æ›´æ—¶è‡ªåŠ¨æ‰§è¡Œå¤„ç†é€»è¾‘ã€‚

```sql
-- åˆ›å»ºæµå¤„ç†è¡¨
CREATE TABLE event_stream (
    event_id BIGSERIAL PRIMARY KEY,
    event_type VARCHAR(50),
    event_data JSONB,
    processed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå¤„ç†å‡½æ•°
CREATE OR REPLACE FUNCTION process_event_stream()
RETURNS TRIGGER AS $$
BEGIN
    -- å®æ—¶å¤„ç†é€»è¾‘
    INSERT INTO event_aggregates (event_type, event_count, last_updated)
    VALUES (NEW.event_type, 1, NOW())
    ON CONFLICT (event_type)
    DO UPDATE SET
        event_count = event_aggregates.event_count + 1,
        last_updated = NOW();

    -- æ ‡è®°ä¸ºå·²å¤„ç†
    NEW.processed = TRUE;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER process_event_trigger
BEFORE INSERT ON event_stream
FOR EACH ROW
EXECUTE FUNCTION process_event_stream();
```

## å››ã€CEPæ¨¡å¼åŒ¹é…

### 4.1 ç®€å•æ¨¡å¼åŒ¹é…

**ç®€å•æ¨¡å¼**ï¼šæ£€æµ‹å•ä¸ªäº‹ä»¶æˆ–ç®€å•æ¡ä»¶ã€‚

```sql
-- æ£€æµ‹å¼‚å¸¸äº‹ä»¶
SELECT
    device_id,
    event_time,
    value
FROM device_events
WHERE value > 80  -- æ¸©åº¦è¶…è¿‡80åº¦
  AND event_time >= now() - interval '1 hour';
```

### 4.2 åºåˆ—æ¨¡å¼

**åºåˆ—æ¨¡å¼**ï¼šæ£€æµ‹äº‹ä»¶åºåˆ—ï¼Œå¦‚Aäº‹ä»¶åå‡ºç°Bäº‹ä»¶ã€‚

```sql
-- A->B æ¨¡å¼ï¼šåŒç”¨æˆ·1åˆ†é’Ÿå†…
WITH a_events AS (
    SELECT user_id, event_time AS a_time
    FROM events
    WHERE event_type = 'A'
      AND event_time >= now() - interval '1 hour'
),
b_events AS (
    SELECT user_id, event_time AS b_time
    FROM events
    WHERE event_type = 'B'
      AND event_time >= now() - interval '1 hour'
)
SELECT
    a.user_id,
    a.a_time,
    b.b_time,
    b.b_time - a.a_time AS time_diff
FROM a_events a
JOIN b_events b USING (user_id)
WHERE b.b_time >= a.a_time
  AND b.b_time < a.a_time + interval '1 minute';
```

### 4.3 å¤æ‚æ¨¡å¼

**å¤æ‚æ¨¡å¼**ï¼šä½¿ç”¨é€’å½’CTEå®ç°å¤æ‚åºåˆ—æ¨¡å¼ã€‚

```sql
-- A->B->C æ¨¡å¼ï¼šæ£€æµ‹ä¸‰äº‹ä»¶åºåˆ—
WITH RECURSIVE event_sequence AS (
    -- åˆå§‹äº‹ä»¶A
    SELECT
        user_id,
        event_time,
        event_type,
        1 AS sequence_pos,
        ARRAY[event_type] AS sequence
    FROM events
    WHERE event_type = 'A'
      AND event_time >= now() - interval '1 hour'

    UNION ALL

    -- é€’å½’æŸ¥æ‰¾åç»­äº‹ä»¶
    SELECT
        e.user_id,
        e.event_time,
        e.event_type,
        es.sequence_pos + 1,
        es.sequence || e.event_type
    FROM event_sequence es
    JOIN events e ON
        e.user_id = es.user_id
        AND e.event_time > es.event_time
        AND e.event_time < es.event_time + interval '5 minutes'
    WHERE es.sequence_pos < 3
      AND (
          (es.sequence_pos = 1 AND e.event_type = 'B') OR
          (es.sequence_pos = 2 AND e.event_type = 'C')
      )
)
SELECT
    user_id,
    sequence,
    MIN(event_time) AS sequence_start,
    MAX(event_time) AS sequence_end
FROM event_sequence
WHERE sequence_pos = 3
GROUP BY user_id, sequence;
```

### 4.4 æ¨¡å¼ä¼˜åŒ–

**ä¼˜åŒ–ç­–ç•¥**ï¼š

1. **ç´¢å¼•ä¼˜åŒ–**ï¼šåœ¨(user_id, event_time)ä¸Šåˆ›å»ºç´¢å¼•
2. **åˆ†åŒºä¼˜åŒ–**ï¼šæŒ‰æ—¶é—´åˆ†åŒºå‡å°‘æ‰«æèŒƒå›´
3. **ç‰©åŒ–ä¸­é—´ç»“æœ**ï¼šç¼“å­˜å¸¸ç”¨æ¨¡å¼åŒ¹é…ç»“æœ

```sql
-- åˆ›å»ºä¼˜åŒ–ç´¢å¼•
CREATE INDEX ON events (user_id, event_time, event_type);

-- åˆ›å»ºåˆ†åŒºè¡¨
CREATE TABLE events (
    event_id BIGSERIAL,
    user_id UUID,
    event_type VARCHAR(50),
    event_time TIMESTAMPTZ NOT NULL
) PARTITION BY RANGE (event_time);
```

## äº”ã€PostgreSQL 18ä¼˜åŒ–

### 5.1 å¼‚æ­¥I/Oä¼˜åŒ–

PostgreSQL 18å¼•å…¥å¼‚æ­¥I/Oå­ç³»ç»Ÿï¼Œæ˜¾è‘—æå‡æµå¤„ç†æ€§èƒ½ã€‚

```sql
-- å¯ç”¨å¼‚æ­¥I/Oï¼ˆPostgreSQL 18+ï¼‰
ALTER SYSTEM SET io_direct = on;
ALTER SYSTEM SET io_direct_threshold = 0;
SELECT pg_reload_conf();
```

**æ€§èƒ½æå‡**ï¼š

- æµå¤„ç†I/Oæ€§èƒ½æå‡2-3å€
- å‡å°‘é˜»å¡ç­‰å¾…æ—¶é—´
- æé«˜å¹¶å‘å¤„ç†èƒ½åŠ›

### 5.2 å¹¶è¡ŒæŸ¥è¯¢å¢å¼º

PostgreSQL 18ä¼˜åŒ–äº†å¹¶è¡ŒæŸ¥è¯¢ï¼Œæå‡èšåˆè®¡ç®—æ€§èƒ½ã€‚

```sql
-- å¯ç”¨å¹¶è¡ŒæŸ¥è¯¢
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 100;
SET parallel_tuple_cost = 0.01;

-- å¹¶è¡ŒèšåˆæŸ¥è¯¢
SELECT
    date_trunc('minute', event_time) AS window_start,
    COUNT(*) AS event_count
FROM events
WHERE event_time >= now() - interval '1 hour'
GROUP BY window_start;
```

### 5.3 ç‰©åŒ–è§†å›¾ä¼˜åŒ–

PostgreSQL 18ä¼˜åŒ–äº†ç‰©åŒ–è§†å›¾çš„å¢é‡åˆ·æ–°æœºåˆ¶ã€‚

```sql
-- ä½¿ç”¨å¢é‡åˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY event_stats;

-- æ£€æŸ¥åˆ·æ–°ç»Ÿè®¡
SELECT * FROM pg_stat_progress_create_index;
```

## å…­ã€çŸ¥è¯†çŸ©é˜µå¯¹æ¯”

### 6.1 æµå¤„ç†æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | å»¶è¿Ÿ | ååé‡ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------|--------|--------|---------|
| ç‰©åŒ–è§†å›¾ | ç§’çº§-åˆ†é’Ÿçº§ | ä¸­ | ä½ | è¿‘å®æ—¶ç»Ÿè®¡ |
| LISTEN/NOTIFY | æ¯«ç§’çº§ | ä¸­ | ä¸­ | äº‹ä»¶é©±åŠ¨ |
| FDWé›†æˆ | ç§’çº§ | é«˜ | é«˜ | å¤–éƒ¨æ•°æ®æº |
| è§¦å‘å™¨ | æ¯«ç§’çº§ | ä½ | ä¸­ | å®æ—¶å¤„ç† |
| ä¸“ç”¨æµå¤„ç†å¼•æ“ | æ¯«ç§’çº§ | å¾ˆé«˜ | å¾ˆé«˜ | å¤§è§„æ¨¡æµå¤„ç† |

### 6.2 çª—å£ç±»å‹å¯¹æ¯”

| çª—å£ç±»å‹ | é‡å  | å›ºå®šå¤§å° | é€‚ç”¨åœºæ™¯ |
|---------|------|---------|---------|
| æ»šåŠ¨çª—å£ | å¦ | æ˜¯ | å›ºå®šæ—¶é—´é—´éš”ç»Ÿè®¡ |
| æ»‘åŠ¨çª—å£ | æ˜¯ | æ˜¯ | è¿ç»­æ—¶é—´åºåˆ—åˆ†æ |
| ä¼šè¯çª—å£ | å¦ | å¦ | ç”¨æˆ·è¡Œä¸ºåˆ†æ |

### 6.3 CEPå¼•æ“å¯¹æ¯”

| å¼•æ“ | æ¨¡å¼å¤æ‚åº¦ | æ€§èƒ½ | é›†æˆéš¾åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|------|---------|---------|
| PostgreSQL SQL | ä¸­ | ä¸­ | ä½ | ç®€å•åˆ°ä¸­ç­‰å¤æ‚åº¦ |
| Flink CEP | é«˜ | é«˜ | é«˜ | å¤æ‚æ¨¡å¼åŒ¹é… |
| Esper | é«˜ | ä¸­ | ä¸­ | ä¼ä¸šçº§CEP |

## ä¸ƒã€å®è·µæ¡ˆä¾‹

### æ¡ˆä¾‹1: å®æ—¶è®¢å•çŠ¶æ€ç›‘æ§

```sql
-- âœ… [å¯è¿è¡Œ] å®æ—¶è®¢å•çŠ¶æ€æµå¤„ç†
CREATE TABLE orders (
    order_id UUID PRIMARY KEY,
    user_id UUID,
    status VARCHAR(50),
    amount DECIMAL(10,2),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç‰©åŒ–è§†å›¾ç”¨äºå®æ—¶ç»Ÿè®¡
CREATE MATERIALIZED VIEW order_stats_5min AS
SELECT
    date_trunc('minute', created_at) -
    (EXTRACT(MINUTE FROM created_at)::int % 5) * interval '1 minute' AS time_window,
    status,
    COUNT(*) AS order_count,
    SUM(amount) AS total_amount
FROM orders
WHERE created_at >= now() - interval '1 hour'
GROUP BY 1, 2;

CREATE UNIQUE INDEX ON order_stats_5min (time_window, status);

-- å®šæ—¶åˆ·æ–°ï¼ˆé€šè¿‡pg_cronæˆ–å¤–éƒ¨è°ƒåº¦ï¼‰
REFRESH MATERIALIZED VIEW CONCURRENTLY order_stats_5min;
```

### æ¡ˆä¾‹2: IoTè®¾å¤‡å¼‚å¸¸æ£€æµ‹

```sql
-- âœ… [å¯è¿è¡Œ] IoTè®¾å¤‡å¼‚å¸¸æ£€æµ‹CEP
CREATE TABLE device_events (
    device_id VARCHAR(100),
    event_type VARCHAR(50),
    value FLOAT,
    event_time TIMESTAMPTZ DEFAULT NOW()
);

-- æ£€æµ‹æ¨¡å¼ï¼šæ¸©åº¦å¼‚å¸¸å5åˆ†é’Ÿå†…å‡ºç°å‘Šè­¦
WITH temp_anomaly AS (
    SELECT device_id, event_time AS anomaly_time
    FROM device_events
    WHERE event_type = 'temperature' AND value > 80
),
alert_events AS (
    SELECT device_id, event_time AS alert_time
    FROM device_events
    WHERE event_type = 'alert'
)
SELECT
    t.device_id,
    t.anomaly_time,
    a.alert_time,
    a.alert_time - t.anomaly_time AS time_to_alert
FROM temp_anomaly t
JOIN alert_events a USING (device_id)
WHERE a.alert_time >= t.anomaly_time
  AND a.alert_time < t.anomaly_time + interval '5 minutes';
```

### æ¡ˆä¾‹3: ç”¨æˆ·è¡Œä¸ºåºåˆ—åˆ†æ

```sql
-- âœ… [å¯è¿è¡Œ] ç”¨æˆ·è¡Œä¸ºåºåˆ—æ¨¡å¼åŒ¹é…
CREATE TABLE user_actions (
    user_id UUID,
    action_type VARCHAR(50),
    action_time TIMESTAMPTZ DEFAULT NOW()
);

-- æ£€æµ‹æ¨¡å¼ï¼šç”¨æˆ·ç™»å½•å1å°æ—¶å†…å®Œæˆè´­ä¹°
WITH login_events AS (
    SELECT user_id, action_time AS login_time
    FROM user_actions
    WHERE action_type = 'login'
),
purchase_events AS (
    SELECT user_id, action_time AS purchase_time
    FROM user_actions
    WHERE action_type = 'purchase'
)
SELECT
    l.user_id,
    l.login_time,
    p.purchase_time,
    p.purchase_time - l.login_time AS conversion_time
FROM login_events l
JOIN purchase_events p USING (user_id)
WHERE p.purchase_time >= l.login_time
  AND p.purchase_time < l.login_time + interval '1 hour';
```

---

## å…«ã€æ€§èƒ½ä¼˜åŒ–

### 8.1 æŸ¥è¯¢ä¼˜åŒ–

**ä¼˜åŒ–ç­–ç•¥**ï¼š

1. **ä½¿ç”¨ç´¢å¼•**ï¼šåœ¨æ—¶é—´å­—æ®µå’Œåˆ†ç»„å­—æ®µä¸Šåˆ›å»ºç´¢å¼•
2. **åˆ†åŒºè¡¨**ï¼šæŒ‰æ—¶é—´åˆ†åŒºå‡å°‘æ‰«æèŒƒå›´
3. **ç‰©åŒ–è§†å›¾**ï¼šé¢„è®¡ç®—å¸¸ç”¨èšåˆç»“æœ
4. **å¹¶è¡ŒæŸ¥è¯¢**ï¼šå¯ç”¨å¹¶è¡ŒæŸ¥è¯¢åŠ é€Ÿèšåˆ

```sql
-- åˆ›å»ºä¼˜åŒ–ç´¢å¼•
CREATE INDEX ON events (event_time, event_type);
CREATE INDEX ON events (user_id, event_time);

-- ä½¿ç”¨åˆ†åŒºè¡¨
CREATE TABLE events (
    event_id BIGSERIAL,
    event_time TIMESTAMPTZ NOT NULL
) PARTITION BY RANGE (event_time);
```

### 8.2 ç´¢å¼•ä¼˜åŒ–

**ç´¢å¼•ç­–ç•¥**ï¼š

- æ—¶é—´å­—æ®µç´¢å¼•ï¼šæ”¯æŒæ—¶é—´èŒƒå›´æŸ¥è¯¢
- å¤åˆç´¢å¼•ï¼šæ”¯æŒå¤šå­—æ®µæŸ¥è¯¢
- éƒ¨åˆ†ç´¢å¼•ï¼šåªç´¢å¼•æ´»è·ƒæ•°æ®

```sql
-- åˆ›å»ºéƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æœ€è¿‘çš„æ•°æ®ï¼‰
CREATE INDEX ON events (event_time, event_type)
WHERE event_time >= now() - interval '7 days';
```

### 8.3 åˆ†åŒºä¼˜åŒ–

**åˆ†åŒºç­–ç•¥**ï¼š

- æŒ‰æ—¶é—´åˆ†åŒºï¼šæé«˜æŸ¥è¯¢æ€§èƒ½
- è‡ªåŠ¨åˆ†åŒºï¼šä½¿ç”¨pg_partmanè‡ªåŠ¨ç®¡ç†åˆ†åŒº
- åˆ†åŒºè£å‰ªï¼šä¼˜åŒ–å™¨è‡ªåŠ¨è£å‰ªæ— å…³åˆ†åŒº

```sql
-- åˆ›å»ºæ—¶é—´åˆ†åŒºè¡¨
CREATE TABLE events (
    event_id BIGSERIAL,
    event_time TIMESTAMPTZ NOT NULL
) PARTITION BY RANGE (event_time);

-- åˆ›å»ºæœˆåº¦åˆ†åŒº
CREATE TABLE events_2025_01 PARTITION OF events
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

## ä¹ã€ç›‘æ§ä¸è¯Šæ–­

### 9.1 å»¶è¿Ÿç›‘æ§

**ç›‘æ§æŒ‡æ ‡**ï¼š

- å¤„ç†å»¶è¿Ÿï¼šäº‹ä»¶äº§ç”Ÿåˆ°å¤„ç†å®Œæˆçš„æ—¶é—´
- ç«¯åˆ°ç«¯å»¶è¿Ÿï¼šä»æ•°æ®æºåˆ°ç»“æœè¾“å‡ºçš„æ—¶é—´
- çª—å£å»¶è¿Ÿï¼šçª—å£è®¡ç®—å®Œæˆçš„æ—¶é—´

```sql
-- ç›‘æ§å¤„ç†å»¶è¿Ÿ
SELECT
    AVG(processed_at - event_time) AS avg_latency,
    MAX(processed_at - event_time) AS max_latency,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY processed_at - event_time) AS p95_latency
FROM events
WHERE processed_at >= now() - interval '1 hour';
```

### 9.2 ååé‡ç›‘æ§

**ç›‘æ§æŒ‡æ ‡**ï¼š

- äº‹ä»¶å¤„ç†é€Ÿç‡ï¼šæ¯ç§’å¤„ç†çš„äº‹ä»¶æ•°
- çª—å£å¤„ç†é€Ÿç‡ï¼šæ¯ç§’å¤„ç†çš„çª—å£æ•°
- ç³»ç»Ÿååé‡ï¼šæ•´ä½“å¤„ç†èƒ½åŠ›

```sql
-- ç›‘æ§ååé‡
SELECT
    date_trunc('minute', processed_at) AS minute,
    COUNT(*) AS events_per_minute,
    COUNT(*) / 60.0 AS events_per_second
FROM events
WHERE processed_at >= now() - interval '1 hour'
GROUP BY minute
ORDER BY minute;
```

### 9.3 é—®é¢˜æ’æŸ¥

**å¸¸è§é—®é¢˜**ï¼š

1. **å»¶è¿Ÿè¿‡é«˜**ï¼šæ£€æŸ¥ç´¢å¼•ã€åˆ†åŒºã€æŸ¥è¯¢è®¡åˆ’
2. **ååé‡ä½**ï¼šæ£€æŸ¥èµ„æºä½¿ç”¨ã€å¹¶å‘è®¾ç½®
3. **å†…å­˜ä¸è¶³**ï¼šè°ƒæ•´work_memã€ç»´æŠ¤work_mem

```sql
-- æ£€æŸ¥æŸ¥è¯¢è®¡åˆ’
EXPLAIN ANALYZE
SELECT * FROM events
WHERE event_time >= now() - interval '1 hour';

-- æ£€æŸ¥èµ„æºä½¿ç”¨
SELECT * FROM pg_stat_activity
WHERE state = 'active';
```

## åã€æœ€ä½³å®è·µ

### 10.1 è®¾è®¡æœ€ä½³å®è·µ

1. **æ—¶é—´åˆ†åŒº**ï¼šæŒ‰æ—¶é—´åˆ†åŒºæé«˜æŸ¥è¯¢æ€§èƒ½
2. **ç´¢å¼•ç­–ç•¥**ï¼šåœ¨å¸¸ç”¨æŸ¥è¯¢å­—æ®µä¸Šåˆ›å»ºç´¢å¼•
3. **ç‰©åŒ–è§†å›¾**ï¼šé¢„è®¡ç®—å¸¸ç”¨èšåˆç»“æœ
4. **æ°´å°æœºåˆ¶**ï¼šå¤„ç†ä¹±åºå’Œè¿Ÿåˆ°æ•°æ®
5. **å¹‚ç­‰æ€§**ï¼šç¡®ä¿é‡å¤å¤„ç†ä¸ä¼šäº§ç”Ÿé”™è¯¯ç»“æœ

### 10.2 å¼€å‘æœ€ä½³å®è·µ

1. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
2. **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§å»¶è¿Ÿå’Œååé‡
3. **æµ‹è¯•éªŒè¯**ï¼šå……åˆ†æµ‹è¯•å„ç§åœºæ™¯
4. **æ–‡æ¡£ç»´æŠ¤**ï¼šä¿æŒæ–‡æ¡£æ›´æ–°
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šæŒç»­ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½

## åä¸€ã€å‚è€ƒèµ„æº

### 11.1 å®˜æ–¹æ–‡æ¡£

- [PostgreSQL LISTEN/NOTIFY](https://www.postgresql.org/docs/current/sql-notify.html)
- [PostgreSQL Materialized Views](https://www.postgresql.org/docs/current/sql-creatematerializedview.html)
- [PostgreSQL Foreign Data Wrappers](https://www.postgresql.org/docs/current/fdwhandler.html)
- [PostgreSQL Window Functions](https://www.postgresql.org/docs/current/tutorial-window.html)

### 11.2 ç›¸å…³æ–‡æ¡£

- [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - å¢é‡æ›´æ–°ç­–ç•¥
- [ç›‘æ§ä¸è¯Šæ–­](../04-éƒ¨ç½²è¿ç»´/04.04-ç›‘æ§ä¸è¯Šæ–­.md) - æµå¤„ç†ç›‘æ§
- [AI æ—¶ä»£ä¸“é¢˜](../ai_view.md) - å¤šæ¨¡ä¸€ä½“åŒ–åœºæ™¯

### 11.3 å¤–éƒ¨èµ„æº

- [TimescaleDB Continuous Aggregates](https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/)
- [Apache Flink CEP](https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/libs/cep/)
- [Kafka Streams](https://kafka.apache.org/documentation/streams/)

---

## åäºŒã€å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>
2. PostgreSQLå®˜æ–¹æ–‡æ¡£ - [LISTEN/NOTIFY](https://www.postgresql.org/docs/current/sql-notify.html)
3. TimescaleDBæ–‡æ¡£ - [Continuous Aggregates](https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/)
4. Apache Flink - [Complex Event Processing](https://nightlies.apache.org/flink/flink-docs-release-1.17/docs/libs/cep/)
5. PostgreSQLå®˜æ–¹æ–‡æ¡£ - [Materialized Views](https://www.postgresql.org/docs/current/sql-creatematerializedview.html)
6. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

---

**æœ€åæ›´æ–°**: 2025-01-15
**ç»´æŠ¤è€…**: Data Science Team
