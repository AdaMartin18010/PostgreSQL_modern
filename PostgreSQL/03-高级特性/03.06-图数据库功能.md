# PostgreSQLå›¾æ•°æ®åº“åŠŸèƒ½å®Œæ•´æŒ‡å—

> **ç‰ˆæœ¬**: v3.0
> **æœ€åæ›´æ–°**: 2025-01-15
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **éš¾åº¦**: â­â­â­â­â­
> **åº”ç”¨åœºæ™¯**: ç¤¾äº¤ç½‘ç»œã€çŸ¥è¯†å›¾è°±ã€æ¨èç³»ç»Ÿã€è·¯å¾„åˆ†æã€å…³ç³»æŒ–æ˜

---

## ğŸ“‘ ç›®å½•

- [PostgreSQLå›¾æ•°æ®åº“åŠŸèƒ½å®Œæ•´æŒ‡å—](#postgresqlå›¾æ•°æ®åº“åŠŸèƒ½å®Œæ•´æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 å›¾æ•°æ®åº“æ¦‚å¿µ](#11-å›¾æ•°æ®åº“æ¦‚å¿µ)
    - [1.2 PostgreSQLå›¾æ•°æ®åº“èƒ½åŠ›](#12-postgresqlå›¾æ•°æ®åº“èƒ½åŠ›)
    - [1.3 åº”ç”¨åœºæ™¯](#13-åº”ç”¨åœºæ™¯)
    - [1.4 ç‰ˆæœ¬è¦æ±‚](#14-ç‰ˆæœ¬è¦æ±‚)
  - [äºŒã€æ ¸å¿ƒæ¦‚å¿µ](#äºŒæ ¸å¿ƒæ¦‚å¿µ)
    - [2.1 å±æ€§å›¾æ¨¡å‹](#21-å±æ€§å›¾æ¨¡å‹)
    - [2.2 å›¾æ•°æ®å­˜å‚¨](#22-å›¾æ•°æ®å­˜å‚¨)
    - [2.3 å›¾æŸ¥è¯¢è¯­è¨€](#23-å›¾æŸ¥è¯¢è¯­è¨€)
    - [2.4 æ€ç»´å¯¼å›¾](#24-æ€ç»´å¯¼å›¾)
  - [ä¸‰ã€æ•°æ®æ¨¡å‹è®¾è®¡](#ä¸‰æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 é¡¶ç‚¹è¡¨è®¾è®¡](#31-é¡¶ç‚¹è¡¨è®¾è®¡)
    - [3.2 è¾¹è¡¨è®¾è®¡](#32-è¾¹è¡¨è®¾è®¡)
    - [3.3 ç´¢å¼•è®¾è®¡](#33-ç´¢å¼•è®¾è®¡)
    - [3.4 çº¦æŸè®¾è®¡](#34-çº¦æŸè®¾è®¡)
  - [å››ã€SQLå›¾æŸ¥è¯¢](#å››sqlå›¾æŸ¥è¯¢)
    - [4.1 ç›´æ¥é‚»å±…æŸ¥è¯¢](#41-ç›´æ¥é‚»å±…æŸ¥è¯¢)
    - [4.2 é€’å½’æŸ¥è¯¢](#42-é€’å½’æŸ¥è¯¢)
    - [4.3 è·¯å¾„æŸ¥è¯¢](#43-è·¯å¾„æŸ¥è¯¢)
    - [4.4 æœ€çŸ­è·¯å¾„ç®—æ³•](#44-æœ€çŸ­è·¯å¾„ç®—æ³•)
  - [äº”ã€Apache AGEæ‰©å±•](#äº”apache-ageæ‰©å±•)
    - [5.1 å®‰è£…ä¸é…ç½®](#51-å®‰è£…ä¸é…ç½®)
    - [5.2 CypheræŸ¥è¯¢](#52-cypheræŸ¥è¯¢)
    - [5.3 å›¾ç®¡ç†](#53-å›¾ç®¡ç†)
    - [5.4 é«˜çº§åŠŸèƒ½](#54-é«˜çº§åŠŸèƒ½)
  - [å…­ã€å›¾ç®—æ³•å®ç°](#å…­å›¾ç®—æ³•å®ç°)
    - [6.1 æœ€çŸ­è·¯å¾„ç®—æ³•](#61-æœ€çŸ­è·¯å¾„ç®—æ³•)
    - [6.2 PageRankç®—æ³•](#62-pagerankç®—æ³•)
    - [6.3 è¿é€šåˆ†é‡ç®—æ³•](#63-è¿é€šåˆ†é‡ç®—æ³•)
    - [6.4 ç¤¾åŒºæ£€æµ‹ç®—æ³•](#64-ç¤¾åŒºæ£€æµ‹ç®—æ³•)
  - [ä¸ƒã€æ··åˆæŸ¥è¯¢](#ä¸ƒæ··åˆæŸ¥è¯¢)
    - [7.1 å›¾+å‘é‡æ··åˆ](#71-å›¾å‘é‡æ··åˆ)
    - [7.2 å›¾+å…¨æ–‡æ··åˆ](#72-å›¾å…¨æ–‡æ··åˆ)
    - [7.3 å›¾+JSONæ··åˆ](#73-å›¾jsonæ··åˆ)
  - [å…«ã€PostgreSQL 18ä¼˜åŒ–](#å…«postgresql-18ä¼˜åŒ–)
    - [8.1 é€’å½’æŸ¥è¯¢ä¼˜åŒ–](#81-é€’å½’æŸ¥è¯¢ä¼˜åŒ–)
    - [8.2 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–](#82-å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–)
    - [8.3 JSONBæ€§èƒ½æå‡](#83-jsonbæ€§èƒ½æå‡)
  - [ä¹ã€çŸ¥è¯†çŸ©é˜µå¯¹æ¯”](#ä¹çŸ¥è¯†çŸ©é˜µå¯¹æ¯”)
    - [9.1 å›¾å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”](#91-å›¾å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”)
    - [9.2 æŸ¥è¯¢è¯­è¨€å¯¹æ¯”](#92-æŸ¥è¯¢è¯­è¨€å¯¹æ¯”)
    - [9.3 å›¾ç®—æ³•å¯¹æ¯”](#93-å›¾ç®—æ³•å¯¹æ¯”)
  - [åã€å®è·µæ¡ˆä¾‹](#åå®è·µæ¡ˆä¾‹)
    - [10.1 ç¤¾äº¤ç½‘ç»œåˆ†æ](#101-ç¤¾äº¤ç½‘ç»œåˆ†æ)
    - [10.2 çŸ¥è¯†å›¾è°±æ„å»º](#102-çŸ¥è¯†å›¾è°±æ„å»º)
    - [10.3 æ¨èç³»ç»Ÿ](#103-æ¨èç³»ç»Ÿ)
  - [åä¸€ã€æ€§èƒ½ä¼˜åŒ–](#åä¸€æ€§èƒ½ä¼˜åŒ–)
    - [11.1 æŸ¥è¯¢ä¼˜åŒ–](#111-æŸ¥è¯¢ä¼˜åŒ–)
    - [11.2 ç´¢å¼•ä¼˜åŒ–](#112-ç´¢å¼•ä¼˜åŒ–)
    - [11.3 å­˜å‚¨ä¼˜åŒ–](#113-å­˜å‚¨ä¼˜åŒ–)
  - [åäºŒã€ç›‘æ§ä¸è¯Šæ–­](#åäºŒç›‘æ§ä¸è¯Šæ–­)
    - [12.1 æ€§èƒ½ç›‘æ§](#121-æ€§èƒ½ç›‘æ§)
    - [12.2 å›¾ç»Ÿè®¡](#122-å›¾ç»Ÿè®¡)
    - [12.3 é—®é¢˜æ’æŸ¥](#123-é—®é¢˜æ’æŸ¥)
  - [åä¸‰ã€æœ€ä½³å®è·µ](#åä¸‰æœ€ä½³å®è·µ)
    - [13.1 è®¾è®¡æœ€ä½³å®è·µ](#131-è®¾è®¡æœ€ä½³å®è·µ)
    - [13.2 å¼€å‘æœ€ä½³å®è·µ](#132-å¼€å‘æœ€ä½³å®è·µ)
  - [åå››ã€å‚è€ƒèµ„æº](#åå››å‚è€ƒèµ„æº)
    - [14.1 å®˜æ–¹æ–‡æ¡£](#141-å®˜æ–¹æ–‡æ¡£)
    - [14.2 ç½‘ç»œèµ„æº](#142-ç½‘ç»œèµ„æº)
    - [14.3 ç›¸å…³æ–‡æ¡£](#143-ç›¸å…³æ–‡æ¡£)
  - [åäº”ã€å‚è€ƒæ–‡çŒ®](#åäº”å‚è€ƒæ–‡çŒ®)

---

## ä¸€ã€æ¦‚è¿°

### 1.1 å›¾æ•°æ®åº“æ¦‚å¿µ

å›¾æ•°æ®åº“æ˜¯ä¸“é—¨ç”¨äºå­˜å‚¨å’ŒæŸ¥è¯¢å›¾ç»“æ„æ•°æ®çš„æ•°æ®åº“ç³»ç»Ÿã€‚å›¾ç”±é¡¶ç‚¹ï¼ˆVertex/Nodeï¼‰å’Œè¾¹ï¼ˆEdge/Relationshipï¼‰ç»„æˆï¼Œç”¨äºè¡¨ç¤ºå®ä½“ä¹‹é—´çš„å…³ç³»ã€‚

**å›¾æ•°æ®åº“çš„æ ¸å¿ƒæ¦‚å¿µ**ï¼š

- **é¡¶ç‚¹ï¼ˆVertexï¼‰**ï¼šå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œè¡¨ç¤ºå®ä½“
- **è¾¹ï¼ˆEdgeï¼‰**ï¼šé¡¶ç‚¹ä¹‹é—´çš„è¿æ¥ï¼Œè¡¨ç¤ºå…³ç³»
- **å±æ€§ï¼ˆPropertyï¼‰**ï¼šé¡¶ç‚¹å’Œè¾¹çš„å±æ€§ä¿¡æ¯
- **æ ‡ç­¾ï¼ˆLabelï¼‰**ï¼šé¡¶ç‚¹å’Œè¾¹çš„ç±»å‹åˆ†ç±»

**å›¾æ•°æ®åº“çš„ä¼˜åŠ¿**ï¼š

- âœ… **å…³ç³»æŸ¥è¯¢é«˜æ•ˆ**ï¼šç›´æ¥æŸ¥è¯¢å…³ç³»ï¼Œæ— éœ€JOIN
- âœ… **å¤æ‚å…³ç³»åˆ†æ**ï¼šæ”¯æŒå¤šè·³æŸ¥è¯¢å’Œè·¯å¾„åˆ†æ
- âœ… **çµæ´»çš„æ•°æ®æ¨¡å‹**ï¼šæ”¯æŒåŠ¨æ€æ·»åŠ å±æ€§å’Œå…³ç³»
- âœ… **å›¾ç®—æ³•æ”¯æŒ**ï¼šå†…ç½®å›¾ç®—æ³•ï¼ˆæœ€çŸ­è·¯å¾„ã€PageRankç­‰ï¼‰

### 1.2 PostgreSQLå›¾æ•°æ®åº“èƒ½åŠ›

**PostgreSQLåœ¨å›¾æ•°æ®åº“æ–¹é¢çš„èƒ½åŠ›**ï¼š

- âœ… **é€’å½’CTE**ï¼šæ”¯æŒå¤æ‚çš„å›¾éå†æŸ¥è¯¢
- âœ… **JSONBæ”¯æŒ**ï¼šçµæ´»å­˜å‚¨å›¾å±æ€§
- âœ… **ç´¢å¼•æ”¯æŒ**ï¼šé«˜æ•ˆçš„å›¾æŸ¥è¯¢ç´¢å¼•
- âœ… **Apache AGEæ‰©å±•**ï¼šæ”¯æŒCypheræŸ¥è¯¢è¯­è¨€
- âœ… **æ··åˆæŸ¥è¯¢**ï¼šå›¾+å‘é‡+å…¨æ–‡+ç»“æ„åŒ–æŸ¥è¯¢

### 1.3 åº”ç”¨åœºæ™¯

**å…¸å‹åº”ç”¨åœºæ™¯**ï¼š

- **ç¤¾äº¤ç½‘ç»œ**ï¼šç”¨æˆ·å…³ç³»ã€å¥½å‹æ¨èã€å½±å“åŠ›åˆ†æ
- **çŸ¥è¯†å›¾è°±**ï¼šå®ä½“å…³ç³»ã€çŸ¥è¯†æ¨ç†ã€è¯­ä¹‰æœç´¢
- **æ¨èç³»ç»Ÿ**ï¼šåŸºäºå›¾çš„æ¨èç®—æ³•
- **è·¯å¾„åˆ†æ**ï¼šæœ€çŸ­è·¯å¾„ã€è·¯å¾„è§„åˆ’
- **æ¬ºè¯ˆæ£€æµ‹**ï¼šå…³ç³»ç½‘ç»œåˆ†æ
- **ä¾›åº”é“¾ç®¡ç†**ï¼šä¾›åº”å•†å…³ç³»ç½‘ç»œ

### 1.4 ç‰ˆæœ¬è¦æ±‚

- **PostgreSQL 18.x**ï¼šæ¨èï¼Œé€’å½’æŸ¥è¯¢ä¼˜åŒ–ã€JSONBæ€§èƒ½æå‡
- **PostgreSQL 17.x**ï¼šæ¨èï¼ŒåŠŸèƒ½å®Œæ•´
- **PostgreSQL 16.x**ï¼šå…¼å®¹ï¼ŒåŸºç¡€åŠŸèƒ½æ”¯æŒ
- **Apache AGE**ï¼šå¯é€‰ï¼Œæ”¯æŒCypheræŸ¥è¯¢

---

## äºŒã€æ ¸å¿ƒæ¦‚å¿µ

### 2.1 å±æ€§å›¾æ¨¡å‹

**å±æ€§å›¾æ¨¡å‹ç»„æˆ**ï¼š

- **é¡¶ç‚¹ï¼ˆVertexï¼‰**ï¼š`V = (id, label, properties)`
- **è¾¹ï¼ˆEdgeï¼‰**ï¼š`E = (id, src, dst, label, properties)`
- **å›¾ï¼ˆGraphï¼‰**ï¼š`G = (V, E)`

**å±æ€§å›¾ç¤ºä¾‹**ï¼š

```text
é¡¶ç‚¹ï¼š
- User(id=1, name="Alice", age=30)
- User(id=2, name="Bob", age=25)
- Post(id=3, title="Hello", content="...")

è¾¹ï¼š
- FOLLOWS(src=1, dst=2, since="2024-01-01")
- LIKES(src=1, dst=3, timestamp="2024-01-15")
```

### 2.2 å›¾æ•°æ®å­˜å‚¨

**PostgreSQLå›¾æ•°æ®å­˜å‚¨æ–¹å¼**ï¼š

1. **å…³ç³»å‹å­˜å‚¨**ï¼šä½¿ç”¨è¡¨å’ŒJOINè¡¨ç¤ºå›¾
2. **JSONBå­˜å‚¨**ï¼šä½¿ç”¨JSONBå­˜å‚¨å›¾å±æ€§
3. **ä¸“ç”¨æ‰©å±•**ï¼šä½¿ç”¨Apache AGEç­‰æ‰©å±•

### 2.3 å›¾æŸ¥è¯¢è¯­è¨€

**å›¾æŸ¥è¯¢è¯­è¨€ç±»å‹**ï¼š

- **SQL**ï¼šä½¿ç”¨é€’å½’CTEè¿›è¡Œå›¾æŸ¥è¯¢
- **Cypher**ï¼šå›¾æ•°æ®åº“ä¸“ç”¨æŸ¥è¯¢è¯­è¨€ï¼ˆApache AGEï¼‰
- **Gremlin**ï¼šå›¾éå†è¯­è¨€ï¼ˆé€šè¿‡FDWï¼‰

### 2.4 æ€ç»´å¯¼å›¾

```mermaid
graph TD
    A[PostgreSQLå›¾æ•°æ®åº“] --> B[æ•°æ®æ¨¡å‹]
    A --> C[æŸ¥è¯¢æ–¹å¼]
    A --> D[å›¾ç®—æ³•]
    A --> E[æ‰©å±•æ”¯æŒ]

    B --> B1[é¡¶ç‚¹è¡¨]
    B --> B2[è¾¹è¡¨]
    B --> B3[å±æ€§å­˜å‚¨]

    C --> C1[SQLé€’å½’CTE]
    C --> C2[CypheræŸ¥è¯¢]
    C --> C3[æ··åˆæŸ¥è¯¢]

    D --> D1[æœ€çŸ­è·¯å¾„]
    D --> D2[PageRank]
    D --> D3[è¿é€šåˆ†é‡]

    E --> E1[Apache AGE]
    E --> E2[FDWé›†æˆ]
```

---

## ä¸‰ã€æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 é¡¶ç‚¹è¡¨è®¾è®¡

**åŸºç¡€é¡¶ç‚¹è¡¨**ï¼š

```sql
-- é¡¶ç‚¹è¡¨
CREATE TABLE vertices (
    id BIGSERIAL PRIMARY KEY,
    label TEXT NOT NULL,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_vertices_label ON vertices(label);
CREATE INDEX idx_vertices_props_gin ON vertices USING GIN (props);
CREATE INDEX idx_vertices_id_label ON vertices(id, label);

-- å¸¸ç”¨å±æ€§ç´¢å¼•ï¼ˆæ ¹æ®ä¸šåŠ¡éœ€æ±‚ï¼‰
CREATE INDEX idx_vertices_name ON vertices((props->>'name'));
CREATE INDEX idx_vertices_type ON vertices((props->>'type'));
```

**æ‰©å±•é¡¶ç‚¹è¡¨ï¼ˆæ”¯æŒå‘é‡ï¼‰**ï¼š

```sql
-- æ”¯æŒå‘é‡çš„é¡¶ç‚¹è¡¨
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE vertices_with_vector (
    id BIGSERIAL PRIMARY KEY,
    label TEXT NOT NULL,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    embedding vector(384),  -- å‘é‡åµŒå…¥
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_vertices_vector_hnsw ON vertices_with_vector
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

**é¡¶ç‚¹è¡¨åˆ†åŒº**ï¼š

```sql
-- æŒ‰æ ‡ç­¾åˆ†åŒºé¡¶ç‚¹è¡¨
CREATE TABLE vertices_partitioned (
    id BIGSERIAL,
    label TEXT NOT NULL,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (id, label)
) PARTITION BY LIST (label);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE vertices_user PARTITION OF vertices_partitioned
    FOR VALUES IN ('User');

CREATE TABLE vertices_post PARTITION OF vertices_partitioned
    FOR VALUES IN ('Post');

CREATE TABLE vertices_comment PARTITION OF vertices_partitioned
    FOR VALUES IN ('Comment');
```

### 3.2 è¾¹è¡¨è®¾è®¡

**åŸºç¡€è¾¹è¡¨**ï¼š

```sql
-- è¾¹è¡¨
CREATE TABLE edges (
    id BIGSERIAL PRIMARY KEY,
    src BIGINT NOT NULL,
    dst BIGINT NOT NULL,
    label TEXT NOT NULL,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- å¤–é”®çº¦æŸ
    CONSTRAINT fk_edges_src FOREIGN KEY (src) REFERENCES vertices(id) ON DELETE CASCADE,
    CONSTRAINT fk_edges_dst FOREIGN KEY (dst) REFERENCES vertices(id) ON DELETE CASCADE,
    -- é¿å…é‡å¤è¾¹ï¼ˆå¯é€‰ï¼‰
    CONSTRAINT uk_edges_src_dst_label UNIQUE (src, dst, label)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_edges_src ON edges(src);
CREATE INDEX idx_edges_dst ON edges(dst);
CREATE INDEX idx_edges_label ON edges(label);
CREATE INDEX idx_edges_src_label ON edges(src, label);
CREATE INDEX idx_edges_dst_label ON edges(dst, label);
CREATE INDEX idx_edges_props_gin ON edges USING GIN (props);

-- å¤åˆç´¢å¼•ï¼ˆä¼˜åŒ–å¸¸è§æŸ¥è¯¢ï¼‰
CREATE INDEX idx_edges_src_dst ON edges(src, dst);
CREATE INDEX idx_edges_label_src ON edges(label, src);
```

**åŠ æƒè¾¹è¡¨**ï¼š

```sql
-- æ”¯æŒæƒé‡çš„è¾¹è¡¨
CREATE TABLE weighted_edges (
    id BIGSERIAL PRIMARY KEY,
    src BIGINT NOT NULL,
    dst BIGINT NOT NULL,
    label TEXT NOT NULL,
    weight NUMERIC(10,4) DEFAULT 1.0,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT fk_weighted_edges_src FOREIGN KEY (src) REFERENCES vertices(id) ON DELETE CASCADE,
    CONSTRAINT fk_weighted_edges_dst FOREIGN KEY (dst) REFERENCES vertices(id) ON DELETE CASCADE
);

-- æƒé‡ç´¢å¼•
CREATE INDEX idx_weighted_edges_weight ON weighted_edges(weight);
CREATE INDEX idx_weighted_edges_src_weight ON weighted_edges(src, weight DESC);
```

**è¾¹è¡¨åˆ†åŒº**ï¼š

```sql
-- æŒ‰æ ‡ç­¾åˆ†åŒºè¾¹è¡¨
CREATE TABLE edges_partitioned (
    id BIGSERIAL,
    src BIGINT NOT NULL,
    dst BIGINT NOT NULL,
    label TEXT NOT NULL,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    PRIMARY KEY (id, label)
) PARTITION BY LIST (label);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE edges_follows PARTITION OF edges_partitioned
    FOR VALUES IN ('FOLLOWS');

CREATE TABLE edges_likes PARTITION OF edges_partitioned
    FOR VALUES IN ('LIKES');

CREATE TABLE edges_comments PARTITION OF edges_partitioned
    FOR VALUES IN ('COMMENTS');
```

### 3.3 ç´¢å¼•è®¾è®¡

**å›¾æŸ¥è¯¢ç´¢å¼•ç­–ç•¥**ï¼š

```sql
-- 1. å‡ºè¾¹ç´¢å¼•ï¼ˆä»é¡¶ç‚¹å‡ºå‘çš„è¾¹ï¼‰
CREATE INDEX idx_edges_src_label ON edges(src, label);

-- 2. å…¥è¾¹ç´¢å¼•ï¼ˆæŒ‡å‘é¡¶ç‚¹çš„è¾¹ï¼‰
CREATE INDEX idx_edges_dst_label ON edges(dst, label);

-- 3. åŒå‘ç´¢å¼•ï¼ˆæ”¯æŒåŒå‘æŸ¥è¯¢ï¼‰
CREATE INDEX idx_edges_src_dst_label ON edges(src, dst, label);

-- 4. å±æ€§ç´¢å¼•ï¼ˆJSONBå±æ€§æŸ¥è¯¢ï¼‰
CREATE INDEX idx_edges_props_gin ON edges USING GIN (props);
CREATE INDEX idx_edges_weight ON edges((props->>'weight')::numeric);

-- 5. è¦†ç›–ç´¢å¼•ï¼ˆåŒ…å«å¸¸ç”¨å±æ€§ï¼‰
CREATE INDEX idx_edges_cover ON edges(src, dst, label)
INCLUDE (props);
```

**ç´¢å¼•é€‰æ‹©å»ºè®®**ï¼š

| æŸ¥è¯¢æ¨¡å¼ | æ¨èç´¢å¼• | è¯´æ˜ |
|---------|---------|------|
| **å‡ºè¾¹æŸ¥è¯¢** | `(src, label)` | æŸ¥è¯¢ä»é¡¶ç‚¹å‡ºå‘çš„è¾¹ |
| **å…¥è¾¹æŸ¥è¯¢** | `(dst, label)` | æŸ¥è¯¢æŒ‡å‘é¡¶ç‚¹çš„è¾¹ |
| **åŒå‘æŸ¥è¯¢** | `(src, dst, label)` | æŸ¥è¯¢ç‰¹å®šé¡¶ç‚¹å¯¹ä¹‹é—´çš„è¾¹ |
| **å±æ€§è¿‡æ»¤** | `GIN(props)` | JSONBå±æ€§æŸ¥è¯¢ |
| **æƒé‡æ’åº** | `(src, weight DESC)` | æŒ‰æƒé‡æ’åºçš„è¾¹æŸ¥è¯¢ |

### 3.4 çº¦æŸè®¾è®¡

**æ•°æ®å®Œæ•´æ€§çº¦æŸ**ï¼š

```sql
-- å”¯ä¸€çº¦æŸ
ALTER TABLE vertices ADD CONSTRAINT uk_vertices_id_label UNIQUE (id, label);

-- å¤–é”®çº¦æŸ
ALTER TABLE edges ADD CONSTRAINT fk_edges_src
    FOREIGN KEY (src) REFERENCES vertices(id) ON DELETE CASCADE;
ALTER TABLE edges ADD CONSTRAINT fk_edges_dst
    FOREIGN KEY (dst) REFERENCES vertices(id) ON DELETE CASCADE;

-- é¿å…è‡ªç¯çº¦æŸ
ALTER TABLE edges ADD CONSTRAINT chk_edges_no_self_loop
    CHECK (src != dst);

-- é¿å…é‡å¤è¾¹çº¦æŸ
ALTER TABLE edges ADD CONSTRAINT uk_edges_src_dst_label
    UNIQUE (src, dst, label);

-- è¾¹æ ‡ç­¾çº¦æŸ
ALTER TABLE edges ADD CONSTRAINT chk_edges_label
    CHECK (label IN ('FOLLOWS', 'LIKES', 'COMMENTS', 'SHARES'));
```

---

## å››ã€SQLå›¾æŸ¥è¯¢

### 4.1 ç›´æ¥é‚»å±…æŸ¥è¯¢

**æŸ¥è¯¢ç›´æ¥é‚»å±…**ï¼š

```sql
-- æŸ¥è¯¢é¡¶ç‚¹çš„æ‰€æœ‰å‡ºè¾¹é‚»å±…
CREATE OR REPLACE FUNCTION get_out_neighbors(
    p_vertex_id BIGINT,
    p_edge_label TEXT DEFAULT NULL
)
RETURNS TABLE (
    neighbor_id BIGINT,
    neighbor_label TEXT,
    neighbor_props JSONB,
    edge_props JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        v.id,
        v.label,
        v.props,
        e.props
    FROM edges e
    JOIN vertices v ON v.id = e.dst
    WHERE e.src = p_vertex_id
      AND (p_edge_label IS NULL OR e.label = p_edge_label);
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢é¡¶ç‚¹çš„æ‰€æœ‰å…¥è¾¹é‚»å±…
CREATE OR REPLACE FUNCTION get_in_neighbors(
    p_vertex_id BIGINT,
    p_edge_label TEXT DEFAULT NULL
)
RETURNS TABLE (
    neighbor_id BIGINT,
    neighbor_label TEXT,
    neighbor_props JSONB,
    edge_props JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        v.id,
        v.label,
        v.props,
        e.props
    FROM edges e
    JOIN vertices v ON v.id = e.src
    WHERE e.dst = p_vertex_id
      AND (p_edge_label IS NULL OR e.label = p_edge_label);
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢åŒå‘é‚»å±…
CREATE OR REPLACE FUNCTION get_neighbors(
    p_vertex_id BIGINT,
    p_edge_label TEXT DEFAULT NULL
)
RETURNS TABLE (
    neighbor_id BIGINT,
    neighbor_label TEXT,
    neighbor_props JSONB,
    edge_props JSONB,
    direction TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- å‡ºè¾¹é‚»å±…
    SELECT
        v.id,
        v.label,
        v.props,
        e.props,
        'out'::TEXT
    FROM edges e
    JOIN vertices v ON v.id = e.dst
    WHERE e.src = p_vertex_id
      AND (p_edge_label IS NULL OR e.label = p_edge_label)
    UNION ALL
    -- å…¥è¾¹é‚»å±…
    SELECT
        v.id,
        v.label,
        v.props,
        e.props,
        'in'::TEXT
    FROM edges e
    JOIN vertices v ON v.id = e.src
    WHERE e.dst = p_vertex_id
      AND (p_edge_label IS NULL OR e.label = p_edge_label);
END;
$$ LANGUAGE plpgsql;
```

### 4.2 é€’å½’æŸ¥è¯¢

**Kæ­¥å¯è¾¾æŸ¥è¯¢**ï¼š

```sql
-- Kæ­¥å¯è¾¾æŸ¥è¯¢ï¼ˆé™åˆ¶æ·±åº¦ï¼‰
CREATE OR REPLACE FUNCTION k_hop_reachable(
    p_start_id BIGINT,
    p_max_depth INTEGER DEFAULT 3,
    p_edge_label TEXT DEFAULT NULL
)
RETURNS TABLE (
    vertex_id BIGINT,
    depth INTEGER,
    path BIGINT[]
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE reach AS (
        -- åˆå§‹é¡¶ç‚¹
        SELECT
            p_start_id AS id,
            0 AS depth,
            ARRAY[p_start_id] AS path
        UNION ALL
        -- é€’å½’æ‰©å±•
        SELECT
            e.dst,
            r.depth + 1,
            r.path || e.dst
        FROM reach r
        JOIN edges e ON e.src = r.id
        WHERE r.depth < p_max_depth
          AND NOT e.dst = ANY(r.path)  -- é¿å…å¾ªç¯
          AND (p_edge_label IS NULL OR e.label = p_edge_label)
    )
    SELECT id, depth, path FROM reach;
END;
$$ LANGUAGE plpgsql;
```

**è·¯å¾„æšä¸¾**ï¼š

```sql
-- æšä¸¾æ‰€æœ‰è·¯å¾„
CREATE OR REPLACE FUNCTION enumerate_paths(
    p_start_id BIGINT,
    p_end_id BIGINT,
    p_max_depth INTEGER DEFAULT 5
)
RETURNS TABLE (
    path BIGINT[],
    depth INTEGER,
    total_weight NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE paths AS (
        -- åˆå§‹è·¯å¾„
        SELECT
            ARRAY[p_start_id] AS path,
            0 AS depth,
            0::NUMERIC AS total_weight
        UNION ALL
        -- æ‰©å±•è·¯å¾„
        SELECT
            p.path || e.dst,
            p.depth + 1,
            p.total_weight + COALESCE((e.props->>'weight')::NUMERIC, 1.0)
        FROM paths p
        JOIN edges e ON e.src = p.path[array_length(p.path, 1)]
        WHERE p.depth < p_max_depth
          AND NOT e.dst = ANY(p.path)  -- é¿å…å¾ªç¯
          AND e.dst != p_start_id
    )
    SELECT path, depth, total_weight
    FROM paths
    WHERE path[array_length(path, 1)] = p_end_id
    ORDER BY depth, total_weight;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 è·¯å¾„æŸ¥è¯¢

**ç®€å•è·¯å¾„æŸ¥è¯¢**ï¼š

```sql
-- æŸ¥æ‰¾ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„ç®€å•è·¯å¾„
CREATE OR REPLACE FUNCTION find_simple_paths(
    p_start_id BIGINT,
    p_end_id BIGINT,
    p_max_depth INTEGER DEFAULT 5
)
RETURNS TABLE (
    path BIGINT[],
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE simple_paths AS (
        SELECT
            ARRAY[p_start_id] AS path,
            0 AS depth
        UNION ALL
        SELECT
            sp.path || e.dst,
            sp.depth + 1
        FROM simple_paths sp
        JOIN edges e ON e.src = sp.path[array_length(sp.path, 1)]
        WHERE sp.depth < p_max_depth
          AND NOT e.dst = ANY(sp.path)  -- ç®€å•è·¯å¾„ï¼šä¸é‡å¤é¡¶ç‚¹
          AND e.dst != p_start_id
    )
    SELECT path, depth
    FROM simple_paths
    WHERE path[array_length(path, 1)] = p_end_id
    ORDER BY depth;
END;
$$ LANGUAGE plpgsql;
```

**å¸¦æƒè·¯å¾„æŸ¥è¯¢**ï¼š

```sql
-- æŸ¥æ‰¾å¸¦æƒé‡çš„æœ€çŸ­è·¯å¾„
CREATE OR REPLACE FUNCTION find_weighted_shortest_path(
    p_start_id BIGINT,
    p_end_id BIGINT,
    p_max_depth INTEGER DEFAULT 10
)
RETURNS TABLE (
    path BIGINT[],
    total_weight NUMERIC,
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE weighted_paths AS (
        SELECT
            ARRAY[p_start_id] AS path,
            0::NUMERIC AS total_weight,
            0 AS depth
        UNION ALL
        SELECT
            wp.path || e.dst,
            wp.total_weight + COALESCE((e.props->>'weight')::NUMERIC, 1.0),
            wp.depth + 1
        FROM weighted_paths wp
        JOIN edges e ON e.src = wp.path[array_length(wp.path, 1)]
        WHERE wp.depth < p_max_depth
          AND NOT e.dst = ANY(wp.path)
          AND e.dst != p_start_id
    )
    SELECT path, total_weight, depth
    FROM weighted_paths
    WHERE path[array_length(path, 1)] = p_end_id
    ORDER BY total_weight, depth
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;
```

### 4.4 æœ€çŸ­è·¯å¾„ç®—æ³•

**æ— æƒæœ€çŸ­è·¯å¾„ï¼ˆBFSï¼‰**ï¼š

```sql
-- BFSæœ€çŸ­è·¯å¾„ç®—æ³•
CREATE OR REPLACE FUNCTION shortest_path_bfs(
    p_start_id BIGINT,
    p_end_id BIGINT
)
RETURNS TABLE (
    path BIGINT[],
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE bfs AS (
        SELECT
            p_start_id AS node,
            0 AS depth,
            ARRAY[p_start_id] AS path
        UNION ALL
        SELECT
            e.dst,
            b.depth + 1,
            b.path || e.dst
        FROM bfs b
        JOIN edges e ON e.src = b.node
        WHERE NOT e.dst = ANY(b.path)
          AND b.depth < 20  -- é˜²æ­¢æ— é™é€’å½’
    )
    SELECT path, depth
    FROM bfs
    WHERE node = p_end_id
    ORDER BY depth
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;
```

**Dijkstraæœ€çŸ­è·¯å¾„ï¼ˆæœ‰æƒå›¾ï¼‰**ï¼š

```sql
-- Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
CREATE OR REPLACE FUNCTION shortest_path_dijkstra(
    p_start_id BIGINT,
    p_end_id BIGINT
)
RETURNS TABLE (
    path BIGINT[],
    total_weight NUMERIC
) AS $$
DECLARE
    v_current_id BIGINT;
    v_min_weight NUMERIC;
    v_path BIGINT[];
BEGIN
    -- åˆ›å»ºä¸´æ—¶è¡¨å­˜å‚¨è·ç¦»
    CREATE TEMP TABLE IF NOT EXISTS distances (
        vertex_id BIGINT PRIMARY KEY,
        distance NUMERIC,
        previous BIGINT,
        visited BOOLEAN DEFAULT FALSE
    ) ON COMMIT DROP;

    -- åˆå§‹åŒ–è·ç¦»
    INSERT INTO distances (vertex_id, distance, previous)
    SELECT id, CASE WHEN id = p_start_id THEN 0 ELSE 'Infinity'::NUMERIC END, NULL
    FROM vertices;

    -- Dijkstraä¸»å¾ªç¯ï¼ˆç®€åŒ–å®ç°ï¼‰
    -- æ³¨æ„ï¼šå®Œæ•´å®ç°éœ€è¦æ›´å¤æ‚çš„é€»è¾‘

    -- è¿”å›è·¯å¾„
    RETURN QUERY
    WITH RECURSIVE path_reconstruction AS (
        SELECT p_end_id AS vertex_id, ARRAY[p_end_id] AS path
        UNION ALL
        SELECT d.previous, pr.path || d.previous
        FROM path_reconstruction pr
        JOIN distances d ON d.vertex_id = pr.vertex_id
        WHERE d.previous IS NOT NULL
    )
    SELECT path, (SELECT distance FROM distances WHERE vertex_id = p_end_id) AS total_weight
    FROM path_reconstruction
    WHERE vertex_id = p_start_id
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;
```

---

## äº”ã€Apache AGEæ‰©å±•

### 5.1 å®‰è£…ä¸é…ç½®

**å®‰è£…Apache AGE**ï¼š

```bash
# ä»æºç å®‰è£…Apache AGE
git clone https://github.com/apache/age.git
cd age
git checkout release/PG16/1.5.0  # é€‰æ‹©å¯¹åº”PostgreSQLç‰ˆæœ¬çš„release

# ç¼–è¯‘å®‰è£…
make install

# åœ¨PostgreSQLä¸­åˆ›å»ºæ‰©å±•
psql -d mydb -c "CREATE EXTENSION IF NOT EXISTS age;"
psql -d mydb -c "LOAD 'age';"
```

**éªŒè¯å®‰è£…**ï¼š

```sql
-- æŸ¥çœ‹AGEç‰ˆæœ¬
SELECT * FROM age.version();

-- æŸ¥çœ‹AGEé…ç½®
SELECT * FROM age.config();
```

### 5.2 CypheræŸ¥è¯¢

**åˆ›å»ºå›¾**ï¼š

```sql
-- åˆ›å»ºå›¾
SELECT * FROM create_graph('social_network');

-- æŸ¥çœ‹æ‰€æœ‰å›¾
SELECT * FROM age_graphs();
```

**åˆ›å»ºé¡¶ç‚¹å’Œè¾¹**ï¼š

```sql
-- åˆ›å»ºé¡¶ç‚¹
SELECT * FROM cypher('social_network', $$
    CREATE (a:User {id: 1, name: 'Alice', age: 30}),
           (b:User {id: 2, name: 'Bob', age: 25}),
           (c:User {id: 3, name: 'Charlie', age: 35})
$$) AS (v agtype);

-- åˆ›å»ºè¾¹
SELECT * FROM cypher('social_network', $$
    MATCH (a:User {id: 1}), (b:User {id: 2})
    CREATE (a)-[r:FOLLOWS {since: '2024-01-01'}]->(b)
    RETURN r
$$) AS (r agtype);
```

**CypheræŸ¥è¯¢ç¤ºä¾‹**ï¼š

```sql
-- æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·
SELECT * FROM cypher('social_network', $$
    MATCH (u:User)
    RETURN u
$$) AS (u agtype);

-- æŸ¥è¯¢ç”¨æˆ·çš„å…³æ³¨å…³ç³»
SELECT * FROM cypher('social_network', $$
    MATCH (a:User {id: 1})-[r:FOLLOWS]->(b:User)
    RETURN a, r, b
$$) AS (a agtype, r agtype, b agtype);

-- å¤šè·³æŸ¥è¯¢
SELECT * FROM cypher('social_network', $$
    MATCH (a:User {id: 1})-[*1..3]->(x)
    RETURN x
    LIMIT 10
$$) AS (x agtype);

-- è·¯å¾„æŸ¥è¯¢
SELECT * FROM cypher('social_network', $$
    MATCH path = (a:User {id: 1})-[*1..5]->(b:User {id: 3})
    RETURN path
    LIMIT 5
$$) AS (path agtype);
```

### 5.3 å›¾ç®¡ç†

**å›¾æ“ä½œ**ï¼š

```sql
-- åˆ é™¤å›¾
SELECT * FROM drop_graph('social_network', true);

-- é‡å‘½åå›¾
SELECT * FROM rename_graph('old_name', 'new_name');

-- æŸ¥çœ‹å›¾ç»Ÿè®¡
SELECT * FROM age_graph_stats('social_network');
```

**æ•°æ®å¯¼å…¥å¯¼å‡º**ï¼š

```sql
-- ä»SQLè¡¨å¯¼å…¥åˆ°AGEå›¾
SELECT * FROM cypher('social_network', $$
    LOAD CSV FROM 'file:///path/to/vertices.csv' AS row
    CREATE (v:User {id: toInteger(row[0]), name: row[1]})
$$) AS (v agtype);
```

### 5.4 é«˜çº§åŠŸèƒ½

**èšåˆæŸ¥è¯¢**ï¼š

```sql
-- ç»Ÿè®¡æ¯ä¸ªç”¨æˆ·çš„å…³æ³¨æ•°
SELECT * FROM cypher('social_network', $$
    MATCH (u:User)-[r:FOLLOWS]->()
    RETURN u.name, count(r) AS following_count
    ORDER BY following_count DESC
$$) AS (name agtype, count agtype);

-- æŸ¥æ‰¾æœ€å—æ¬¢è¿çš„ç”¨æˆ·
SELECT * FROM cypher('social_network', $$
    MATCH (u:User)<-[r:FOLLOWS]-()
    RETURN u.name, count(r) AS followers_count
    ORDER BY followers_count DESC
    LIMIT 10
$$) AS (name agtype, count agtype);
```

**å¤æ‚æ¨¡å¼åŒ¹é…**ï¼š

```sql
-- æŸ¥æ‰¾ä¸‰è§’å½¢ï¼ˆä¸‰ä¸ªç”¨æˆ·äº’ç›¸å…³æ³¨ï¼‰
SELECT * FROM cypher('social_network', $$
    MATCH (a:User)-[:FOLLOWS]->(b:User),
          (b:User)-[:FOLLOWS]->(c:User),
          (c:User)-[:FOLLOWS]->(a:User)
    RETURN a.name, b.name, c.name
$$) AS (a agtype, b agtype, c agtype);
```

---

## å…­ã€å›¾ç®—æ³•å®ç°

### 6.1 æœ€çŸ­è·¯å¾„ç®—æ³•

**æ— æƒæœ€çŸ­è·¯å¾„**ï¼š

```sql
-- ä½¿ç”¨é€’å½’CTEå®ç°BFSæœ€çŸ­è·¯å¾„
CREATE OR REPLACE FUNCTION shortest_path_unweighted(
    p_start_id BIGINT,
    p_end_id BIGINT
)
RETURNS TABLE (
    path BIGINT[],
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE bfs AS (
        SELECT
            p_start_id AS node,
            0 AS depth,
            ARRAY[p_start_id] AS path
        UNION ALL
        SELECT
            e.dst,
            b.depth + 1,
            b.path || e.dst
        FROM bfs b
        JOIN edges e ON e.src = b.node
        WHERE NOT e.dst = ANY(b.path)
          AND b.depth < 20
    )
    SELECT path, depth
    FROM bfs
    WHERE node = p_end_id
    ORDER BY depth
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 PageRankç®—æ³•

**PageRankå®ç°**ï¼š

```sql
-- PageRankç®—æ³•å®ç°
CREATE OR REPLACE FUNCTION calculate_pagerank(
    p_iterations INTEGER DEFAULT 20,
    p_damping_factor NUMERIC DEFAULT 0.85
)
RETURNS TABLE (
    vertex_id BIGINT,
    pagerank NUMERIC
) AS $$
DECLARE
    v_total_vertices BIGINT;
    v_iteration INTEGER := 0;
BEGIN
    -- åˆ›å»ºä¸´æ—¶è¡¨å­˜å‚¨PageRankå€¼
    CREATE TEMP TABLE IF NOT EXISTS pagerank_values (
        vertex_id BIGINT PRIMARY KEY,
        rank NUMERIC,
        new_rank NUMERIC
    ) ON COMMIT DROP;

    -- åˆå§‹åŒ–PageRankå€¼
    SELECT COUNT(*) INTO v_total_vertices FROM vertices;
    INSERT INTO pagerank_values (vertex_id, rank, new_rank)
    SELECT id, 1.0 / v_total_vertices, 0.0
    FROM vertices;

    -- PageRankè¿­ä»£
    WHILE v_iteration < p_iterations LOOP
        -- è®¡ç®—æ–°çš„PageRankå€¼
        UPDATE pagerank_values pv
        SET new_rank = (1 - p_damping_factor) / v_total_vertices +
            p_damping_factor * (
                SELECT COALESCE(SUM(pv2.rank / NULLIF((
                    SELECT COUNT(*) FROM edges WHERE src = pv2.vertex_id
                ), 0)), 0)
                FROM pagerank_values pv2
                JOIN edges e ON e.src = pv2.vertex_id
                WHERE e.dst = pv.vertex_id
            );

        -- æ›´æ–°PageRankå€¼
        UPDATE pagerank_values SET rank = new_rank;

        v_iteration := v_iteration + 1;
    END LOOP;

    -- è¿”å›ç»“æœ
    RETURN QUERY
    SELECT vertex_id, rank
    FROM pagerank_values
    ORDER BY rank DESC;
END;
$$ LANGUAGE plpgsql;
```

### 6.3 è¿é€šåˆ†é‡ç®—æ³•

**è¿é€šåˆ†é‡æ£€æµ‹**ï¼š

```sql
-- ä½¿ç”¨å¹¶æŸ¥é›†ç®—æ³•æ£€æµ‹è¿é€šåˆ†é‡
CREATE OR REPLACE FUNCTION find_connected_components()
RETURNS TABLE (
    component_id BIGINT,
    vertex_id BIGINT
) AS $$
DECLARE
    v_vertex RECORD;
    v_component_id BIGINT := 0;
BEGIN
    -- åˆ›å»ºä¸´æ—¶è¡¨å­˜å‚¨è¿é€šåˆ†é‡
    CREATE TEMP TABLE IF NOT EXISTS components (
        vertex_id BIGINT PRIMARY KEY,
        component_id BIGINT
    ) ON COMMIT DROP;

    -- å¯¹æ¯ä¸ªæœªè®¿é—®çš„é¡¶ç‚¹è¿›è¡ŒBFS
    FOR v_vertex IN SELECT id FROM vertices ORDER BY id
    LOOP
        IF NOT EXISTS (SELECT 1 FROM components WHERE vertex_id = v_vertex.id) THEN
            v_component_id := v_component_id + 1;

            -- BFSéå†è¿é€šåˆ†é‡
            INSERT INTO components (vertex_id, component_id)
            WITH RECURSIVE component_bfs AS (
                SELECT v_vertex.id AS node
                UNION ALL
                SELECT e.dst
                FROM component_bfs cb
                JOIN edges e ON e.src = cb.node
                WHERE NOT EXISTS (
                    SELECT 1 FROM components WHERE vertex_id = e.dst
                )
                UNION ALL
                SELECT e.src
                FROM component_bfs cb
                JOIN edges e ON e.dst = cb.node
                WHERE NOT EXISTS (
                    SELECT 1 FROM components WHERE vertex_id = e.src
                )
            )
            SELECT node, v_component_id
            FROM component_bfs;
        END IF;
    END LOOP;

    -- è¿”å›ç»“æœ
    RETURN QUERY
    SELECT component_id, vertex_id
    FROM components
    ORDER BY component_id, vertex_id;
END;
$$ LANGUAGE plpgsql;
```

### 6.4 ç¤¾åŒºæ£€æµ‹ç®—æ³•

**Louvainç¤¾åŒºæ£€æµ‹ï¼ˆç®€åŒ–ç‰ˆï¼‰**ï¼š

```sql
-- ç¤¾åŒºæ£€æµ‹ç®—æ³•ï¼ˆç®€åŒ–å®ç°ï¼‰
CREATE OR REPLACE FUNCTION detect_communities()
RETURNS TABLE (
    vertex_id BIGINT,
    community_id BIGINT
) AS $$
DECLARE
    v_iteration INTEGER := 0;
    v_max_iterations INTEGER := 10;
    v_changed BOOLEAN := TRUE;
BEGIN
    -- åˆ›å»ºä¸´æ—¶è¡¨å­˜å‚¨ç¤¾åŒºåˆ†é…
    CREATE TEMP TABLE IF NOT EXISTS communities (
        vertex_id BIGINT PRIMARY KEY,
        community_id BIGINT
    ) ON COMMIT DROP;

    -- åˆå§‹åŒ–ï¼šæ¯ä¸ªé¡¶ç‚¹ä¸€ä¸ªç¤¾åŒº
    INSERT INTO communities (vertex_id, community_id)
    SELECT id, id FROM vertices;

    -- Louvainç®—æ³•è¿­ä»£ï¼ˆç®€åŒ–ç‰ˆï¼‰
    WHILE v_changed AND v_iteration < v_max_iterations LOOP
        v_changed := FALSE;
        v_iteration := v_iteration + 1;

        -- å¯¹æ¯ä¸ªé¡¶ç‚¹ï¼Œå°è¯•ç§»åŠ¨åˆ°é‚»å±…çš„ç¤¾åŒº
        -- è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è®¡ç®—æ¨¡å—åº¦å¢ç›Š

        -- æ›´æ–°ç¤¾åŒºåˆ†é…
        -- ...ï¼ˆç®€åŒ–å®ç°ï¼‰
    END LOOP;

    -- è¿”å›ç»“æœ
    RETURN QUERY
    SELECT vertex_id, community_id
    FROM communities
    ORDER BY community_id, vertex_id;
END;
$$ LANGUAGE plpgsql;
```

---

## ä¸ƒã€æ··åˆæŸ¥è¯¢

### 7.1 å›¾+å‘é‡æ··åˆ

**å›¾å†…è¯­ä¹‰æœç´¢**ï¼š

```sql
-- å›¾+å‘é‡æ··åˆæŸ¥è¯¢
CREATE EXTENSION IF NOT EXISTS vector;

-- å¸¦å‘é‡çš„é¡¶ç‚¹è¡¨
CREATE TABLE vertices_with_embedding (
    id BIGSERIAL PRIMARY KEY,
    label TEXT NOT NULL,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    embedding vector(384),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_vertices_embed_hnsw ON vertices_with_embedding
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- å›¾+å‘é‡æ··åˆæŸ¥è¯¢å‡½æ•°
CREATE OR REPLACE FUNCTION graph_vector_search(
    p_start_id BIGINT,
    p_query_vector vector(384),
    p_max_depth INTEGER DEFAULT 2,
    p_limit INTEGER DEFAULT 10
)
RETURNS TABLE (
    vertex_id BIGINT,
    label TEXT,
    props JSONB,
    similarity NUMERIC,
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH graph_reachable AS (
        -- å›¾éå†ï¼šæ‰¾åˆ°å¯è¾¾çš„é¡¶ç‚¹
        WITH RECURSIVE reach AS (
            SELECT p_start_id AS id, 0 AS depth
            UNION ALL
            SELECT e.dst, r.depth + 1
            FROM reach r
            JOIN edges e ON e.src = r.id
            WHERE r.depth < p_max_depth
        )
        SELECT id, depth FROM reach
    )
    SELECT
        v.id,
        v.label,
        v.props,
        1 - (v.embedding <=> p_query_vector) AS similarity,
        gr.depth
    FROM graph_reachable gr
    JOIN vertices_with_embedding v ON v.id = gr.id
    WHERE v.embedding IS NOT NULL
    ORDER BY v.embedding <=> p_query_vector
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 å›¾+å…¨æ–‡æ··åˆ

**å›¾+å…¨æ–‡æœç´¢æ··åˆ**ï¼š

```sql
-- å¸¦å…¨æ–‡æœç´¢çš„é¡¶ç‚¹è¡¨
CREATE TABLE vertices_with_text (
    id BIGSERIAL PRIMARY KEY,
    label TEXT NOT NULL,
    props JSONB NOT NULL DEFAULT '{}'::jsonb,
    content TEXT,
    search_vector tsvector GENERATED ALWAYS AS (
        to_tsvector('simple', COALESCE(content, '') || ' ' || COALESCE(props->>'name', ''))
    ) STORED,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•
CREATE INDEX idx_vertices_search_gin ON vertices_with_text
USING GIN (search_vector);

-- å›¾+å…¨æ–‡æ··åˆæŸ¥è¯¢
CREATE OR REPLACE FUNCTION graph_fulltext_search(
    p_start_id BIGINT,
    p_query_text TEXT,
    p_max_depth INTEGER DEFAULT 2,
    p_limit INTEGER DEFAULT 10
)
RETURNS TABLE (
    vertex_id BIGINT,
    label TEXT,
    content TEXT,
    text_rank NUMERIC,
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH graph_reachable AS (
        -- å›¾éå†
        WITH RECURSIVE reach AS (
            SELECT p_start_id AS id, 0 AS depth
            UNION ALL
            SELECT e.dst, r.depth + 1
            FROM reach r
            JOIN edges e ON e.src = r.id
            WHERE r.depth < p_max_depth
        )
        SELECT id, depth FROM reach
    ),
    fulltext_matched AS (
        -- å…¨æ–‡æœç´¢
        SELECT
            v.id,
            ts_rank(v.search_vector, plainto_tsquery('simple', p_query_text)) AS rank
        FROM vertices_with_text v
        WHERE v.search_vector @@ plainto_tsquery('simple', p_query_text)
    )
    SELECT
        v.id,
        v.label,
        v.content,
        ft.rank AS text_rank,
        gr.depth
    FROM graph_reachable gr
    JOIN vertices_with_text v ON v.id = gr.id
    JOIN fulltext_matched ft ON ft.id = v.id
    ORDER BY ft.rank DESC, gr.depth
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

### 7.3 å›¾+JSONæ··åˆ

**å›¾+JSONBå±æ€§æŸ¥è¯¢**ï¼š

```sql
-- å›¾+JSONBå±æ€§æ··åˆæŸ¥è¯¢
CREATE OR REPLACE FUNCTION graph_json_filter(
    p_start_id BIGINT,
    p_json_filter JSONB,
    p_max_depth INTEGER DEFAULT 2
)
RETURNS TABLE (
    vertex_id BIGINT,
    label TEXT,
    props JSONB,
    depth INTEGER
) AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE graph_traverse AS (
        SELECT p_start_id AS id, 0 AS depth
        UNION ALL
        SELECT e.dst, gt.depth + 1
        FROM graph_traverse gt
        JOIN edges e ON e.src = gt.id
        WHERE gt.depth < p_max_depth
    )
    SELECT
        v.id,
        v.label,
        v.props,
        gt.depth
    FROM graph_traverse gt
    JOIN vertices v ON v.id = gt.id
    WHERE v.props @> p_json_filter  -- JSONBåŒ…å«æŸ¥è¯¢
    ORDER BY gt.depth;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨ç¤ºä¾‹
SELECT * FROM graph_json_filter(
    1,
    '{"type": "User", "age": 30}'::jsonb,
    2
);
```

---

## å…«ã€PostgreSQL 18ä¼˜åŒ–

### 8.1 é€’å½’æŸ¥è¯¢ä¼˜åŒ–

**PostgreSQL 18é€’å½’æŸ¥è¯¢æ”¹è¿›**ï¼š

```sql
-- PostgreSQL 18: ä¼˜åŒ–çš„é€’å½’æŸ¥è¯¢
-- è‡ªåŠ¨ä½¿ç”¨å¹¶è¡Œæ‰§è¡Œï¼ˆå¦‚æœå¯èƒ½ï¼‰
SET max_parallel_workers_per_gather = 4;

WITH RECURSIVE optimized_reach AS (
    SELECT $1 AS id, 0 AS depth
    UNION ALL
    SELECT e.dst, or.depth + 1
    FROM optimized_reach or
    JOIN edges e ON e.src = or.id
    WHERE or.depth < 3
)
SELECT * FROM optimized_reach;
-- PostgreSQL 18è‡ªåŠ¨ä¼˜åŒ–é€’å½’æŸ¥è¯¢æ€§èƒ½
```

### 8.2 å¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–

**å¹¶è¡Œå›¾æŸ¥è¯¢**ï¼š

```sql
-- PostgreSQL 18: å¹¶è¡Œå›¾æŸ¥è¯¢
SET enable_parallel = on;
SET max_parallel_workers_per_gather = 4;

-- å¹¶è¡Œè®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„åº¦
SELECT
    v.id,
    v.label,
    (SELECT COUNT(*) FROM edges WHERE src = v.id) AS out_degree,
    (SELECT COUNT(*) FROM edges WHERE dst = v.id) AS in_degree
FROM vertices v
ORDER BY (out_degree + in_degree) DESC;
-- PostgreSQL 18è‡ªåŠ¨å¹¶è¡Œæ‰§è¡Œ
```

### 8.3 JSONBæ€§èƒ½æå‡

**JSONBå›¾å±æ€§æŸ¥è¯¢ä¼˜åŒ–**ï¼š

```sql
-- PostgreSQL 18: JSONBæ€§èƒ½æå‡
-- åˆ›å»ºJSONBè¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_vertices_props_name ON vertices((props->>'name'));
CREATE INDEX idx_vertices_props_type ON vertices((props->>'type'));
CREATE INDEX idx_vertices_props_age ON vertices(((props->>'age')::integer));

-- é«˜æ•ˆçš„JSONBæŸ¥è¯¢
SELECT *
FROM vertices
WHERE props->>'type' = 'User'
  AND (props->>'age')::integer > 25
  AND props @> '{"active": true}'::jsonb;
-- PostgreSQL 18 JSONBæŸ¥è¯¢æ€§èƒ½æå‡
```

---

## ä¹ã€çŸ¥è¯†çŸ©é˜µå¯¹æ¯”

### 9.1 å›¾å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | æŸ¥è¯¢æ€§èƒ½ | å­˜å‚¨æ•ˆç‡ | çµæ´»æ€§ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ | æ¨èåº¦ |
|------|---------|---------|--------|--------|---------|--------|
| **å…³ç³»å‹è¡¨** | â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­ | ä¸­å°è§„æ¨¡ | â­â­â­â­ |
| **JSONBå­˜å‚¨** | â­â­â­â­ | â­â­â­ | â­â­â­â­â­ | â­â­â­ | çµæ´»å±æ€§ | â­â­â­â­â­ |
| **Apache AGE** | â­â­â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­â­ | å¤§è§„æ¨¡å›¾ | â­â­â­â­â­ |
| **FDWé›†æˆ** | â­â­â­â­ | â­â­ | â­â­â­ | â­â­â­â­â­ | ä¸“ç”¨å›¾å¼•æ“ | â­â­â­ |

### 9.2 æŸ¥è¯¢è¯­è¨€å¯¹æ¯”

| æŸ¥è¯¢è¯­è¨€ | æ˜“ç”¨æ€§ | è¡¨è¾¾èƒ½åŠ› | æ€§èƒ½ | å­¦ä¹ æ›²çº¿ | æ¨èåº¦ |
|---------|--------|---------|------|---------|--------|
| **SQLé€’å½’CTE** | â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­â­ |
| **Cypher** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­ | â­â­â­â­â­ |
| **Gremlin** | â­â­â­ | â­â­â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­â­ |

### 9.3 å›¾ç®—æ³•å¯¹æ¯”

| ç®—æ³• | å¤æ‚åº¦ | é€‚ç”¨è§„æ¨¡ | ç²¾åº¦ | å®ç°éš¾åº¦ | æ¨èåº¦ |
|------|--------|---------|------|---------|--------|
| **BFSæœ€çŸ­è·¯å¾„** | O(V+E) | ä¸­å°è§„æ¨¡ | â­â­â­â­â­ | â­â­ | â­â­â­â­â­ |
| **Dijkstra** | O((V+E)logV) | ä¸­å°è§„æ¨¡ | â­â­â­â­â­ | â­â­â­ | â­â­â­â­ |
| **PageRank** | O(V+E) | å¤§è§„æ¨¡ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­ |
| **è¿é€šåˆ†é‡** | O(V+E) | å¤§è§„æ¨¡ | â­â­â­â­â­ | â­â­â­ | â­â­â­â­â­ |

---

## åã€å®è·µæ¡ˆä¾‹

### 10.1 ç¤¾äº¤ç½‘ç»œåˆ†æ

**ç¤¾äº¤ç½‘ç»œå›¾æ¨¡å‹**ï¼š

```sql
-- ç”¨æˆ·è¡¨ï¼ˆé¡¶ç‚¹ï¼‰
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username TEXT NOT NULL UNIQUE,
    email TEXT,
    profile JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å…³æ³¨å…³ç³»è¡¨ï¼ˆè¾¹ï¼‰
CREATE TABLE follows (
    id BIGSERIAL PRIMARY KEY,
    follower_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    followee_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT uk_follows UNIQUE (follower_id, followee_id),
    CONSTRAINT chk_follows_no_self CHECK (follower_id != followee_id)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_follows_follower ON follows(follower_id);
CREATE INDEX idx_follows_followee ON follows(followee_id);

-- æŸ¥è¯¢ç”¨æˆ·çš„å…³æ³¨è€…
CREATE OR REPLACE FUNCTION get_followers(p_user_id BIGINT)
RETURNS TABLE (
    user_id BIGINT,
    username TEXT,
    followed_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.id,
        u.username,
        f.created_at
    FROM follows f
    JOIN users u ON u.id = f.follower_id
    WHERE f.followee_id = p_user_id
    ORDER BY f.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢å…±åŒå…³æ³¨
CREATE OR REPLACE FUNCTION get_common_followers(
    p_user1_id BIGINT,
    p_user2_id BIGINT
)
RETURNS TABLE (
    user_id BIGINT,
    username TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.username
    FROM follows f1
    JOIN follows f2 ON f2.follower_id = f1.follower_id
    JOIN users u ON u.id = f1.follower_id
    WHERE f1.followee_id = p_user1_id
      AND f2.followee_id = p_user2_id;
END;
$$ LANGUAGE plpgsql;
```

### 10.2 çŸ¥è¯†å›¾è°±æ„å»º

**çŸ¥è¯†å›¾è°±æ¨¡å‹**ï¼š

```sql
-- å®ä½“è¡¨ï¼ˆé¡¶ç‚¹ï¼‰
CREATE TABLE entities (
    id BIGSERIAL PRIMARY KEY,
    label TEXT NOT NULL,
    type TEXT NOT NULL,  -- Person, Organization, Location, etc.
    name TEXT NOT NULL,
    properties JSONB DEFAULT '{}'::jsonb,
    embedding vector(384),  -- å®ä½“å‘é‡
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å…³ç³»è¡¨ï¼ˆè¾¹ï¼‰
CREATE TABLE relations (
    id BIGSERIAL PRIMARY KEY,
    subject_id BIGINT NOT NULL REFERENCES entities(id) ON DELETE CASCADE,
    predicate TEXT NOT NULL,  -- WORKS_AT, LOCATED_IN, etc.
    object_id BIGINT NOT NULL REFERENCES entities(id) ON DELETE CASCADE,
    properties JSONB DEFAULT '{}'::jsonb,
    confidence NUMERIC(5,4),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_relations_subject ON relations(subject_id, predicate);
CREATE INDEX idx_relations_object ON relations(object_id, predicate);
CREATE INDEX idx_entities_type ON entities(type);
CREATE INDEX idx_entities_name ON entities(name);

-- çŸ¥è¯†å›¾è°±æŸ¥è¯¢ï¼šæŸ¥æ‰¾å®ä½“çš„æ‰€æœ‰å…³ç³»
CREATE OR REPLACE FUNCTION get_entity_relations(p_entity_id BIGINT)
RETURNS TABLE (
    relation_type TEXT,
    related_entity_id BIGINT,
    related_entity_name TEXT,
    direction TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- å‡ºè¾¹å…³ç³»
    SELECT
        r.predicate,
        r.object_id,
        e.name,
        'out'::TEXT
    FROM relations r
    JOIN entities e ON e.id = r.object_id
    WHERE r.subject_id = p_entity_id
    UNION ALL
    -- å…¥è¾¹å…³ç³»
    SELECT
        r.predicate,
        r.subject_id,
        e.name,
        'in'::TEXT
    FROM relations r
    JOIN entities e ON e.id = r.subject_id
    WHERE r.object_id = p_entity_id;
END;
$$ LANGUAGE plpgsql;
```

### 10.3 æ¨èç³»ç»Ÿ

**åŸºäºå›¾çš„æ¨è**ï¼š

```sql
-- ç”¨æˆ·-ç‰©å“å›¾æ¨¡å‹
CREATE TABLE items (
    id BIGSERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    category TEXT,
    properties JSONB DEFAULT '{}'::jsonb
);

-- ç”¨æˆ·-ç‰©å“äº¤äº’ï¼ˆè¾¹ï¼‰
CREATE TABLE interactions (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    item_id BIGINT NOT NULL REFERENCES items(id) ON DELETE CASCADE,
    interaction_type TEXT NOT NULL,  -- VIEW, LIKE, PURCHASE
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT uk_interactions UNIQUE (user_id, item_id, interaction_type)
);

-- åŸºäºå›¾çš„æ¨èï¼šæŸ¥æ‰¾ç›¸ä¼¼ç”¨æˆ·çš„åå¥½ç‰©å“
CREATE OR REPLACE FUNCTION recommend_by_similar_users(
    p_user_id BIGINT,
    p_limit INTEGER DEFAULT 10
)
RETURNS TABLE (
    item_id BIGINT,
    item_name TEXT,
    score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH user_items AS (
        -- å½“å‰ç”¨æˆ·çš„ç‰©å“
        SELECT DISTINCT item_id
        FROM interactions
        WHERE user_id = p_user_id
    ),
    similar_users AS (
        -- ç›¸ä¼¼ç”¨æˆ·ï¼ˆæœ‰å…±åŒç‰©å“çš„ç”¨æˆ·ï¼‰
        SELECT DISTINCT i2.user_id, COUNT(*) AS common_items
        FROM interactions i1
        JOIN interactions i2 ON i2.item_id = i1.item_id
        WHERE i1.user_id = p_user_id
          AND i2.user_id != p_user_id
          AND i2.item_id IN (SELECT item_id FROM user_items)
        GROUP BY i2.user_id
        HAVING COUNT(*) >= 2
        ORDER BY COUNT(*) DESC
        LIMIT 100
    ),
    recommended_items AS (
        -- ç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„ç‰©å“
        SELECT
            i.item_id,
            SUM(su.common_items) AS score
        FROM similar_users su
        JOIN interactions i ON i.user_id = su.user_id
        WHERE i.item_id NOT IN (SELECT item_id FROM user_items)
        GROUP BY i.item_id
    )
    SELECT
        ri.item_id,
        it.name,
        ri.score
    FROM recommended_items ri
    JOIN items it ON it.id = ri.item_id
    ORDER BY ri.score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

## åä¸€ã€æ€§èƒ½ä¼˜åŒ–

### 11.1 æŸ¥è¯¢ä¼˜åŒ–

**é€’å½’æŸ¥è¯¢ä¼˜åŒ–**ï¼š

```sql
-- é™åˆ¶é€’å½’æ·±åº¦
WITH RECURSIVE reach AS (
    SELECT $1 AS id, 0 AS depth
    UNION ALL
    SELECT e.dst, r.depth + 1
    FROM reach r
    JOIN edges e ON e.src = r.id
    WHERE r.depth < 3  -- é™åˆ¶æ·±åº¦
      AND NOT e.dst = ANY(SELECT id FROM reach)  -- é¿å…å¾ªç¯
)
SELECT * FROM reach;

-- ä½¿ç”¨ç‰©åŒ–CTEä¼˜åŒ–
WITH RECURSIVE reach AS (
    SELECT $1 AS id, 0 AS depth
    UNION ALL
    SELECT e.dst, r.depth + 1
    FROM reach r
    JOIN edges e ON e.src = r.id
    WHERE r.depth < 3
)
SELECT * FROM reach
WHERE id IN (
    SELECT id FROM vertices WHERE label = 'User'  -- æå‰è¿‡æ»¤
);
```

### 11.2 ç´¢å¼•ä¼˜åŒ–

**å›¾æŸ¥è¯¢ç´¢å¼•ä¼˜åŒ–**ï¼š

```sql
-- è¦†ç›–ç´¢å¼•ï¼ˆåŒ…å«å¸¸ç”¨å±æ€§ï¼‰
CREATE INDEX idx_edges_cover ON edges(src, dst, label)
INCLUDE (props);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒè¾¹ï¼‰
CREATE INDEX idx_edges_active ON edges(src, dst)
WHERE (props->>'active')::boolean = true;

-- è¡¨è¾¾å¼ç´¢å¼•ï¼ˆä¼˜åŒ–å±æ€§æŸ¥è¯¢ï¼‰
CREATE INDEX idx_edges_weight ON edges(((props->>'weight')::numeric))
WHERE (props->>'weight') IS NOT NULL;
```

### 11.3 å­˜å‚¨ä¼˜åŒ–

**å›¾æ•°æ®åˆ†åŒº**ï¼š

```sql
-- æŒ‰æ ‡ç­¾åˆ†åŒºè¾¹è¡¨
CREATE TABLE edges_partitioned (
    id BIGSERIAL,
    src BIGINT NOT NULL,
    dst BIGINT NOT NULL,
    label TEXT NOT NULL,
    props JSONB DEFAULT '{}'::jsonb,
    PRIMARY KEY (id, label)
) PARTITION BY LIST (label);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE edges_follows PARTITION OF edges_partitioned
    FOR VALUES IN ('FOLLOWS');

CREATE TABLE edges_likes PARTITION OF edges_partitioned
    FOR VALUES IN ('LIKES');
```

**æ‰¹é‡å¯¼å…¥ä¼˜åŒ–**ï¼š

```sql
-- æ‰¹é‡å¯¼å…¥å›¾æ•°æ®
BEGIN;

-- 1. ç¦ç”¨ç´¢å¼•
ALTER TABLE edges DISABLE TRIGGER ALL;

-- 2. æ‰¹é‡æ’å…¥
COPY edges (src, dst, label, props) FROM '/path/to/edges.csv' WITH CSV;

-- 3. é‡æ–°å¯ç”¨ç´¢å¼•
ALTER TABLE edges ENABLE TRIGGER ALL;

-- 4. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
ANALYZE edges;

COMMIT;
```

---

## åäºŒã€ç›‘æ§ä¸è¯Šæ–­

### 12.1 æ€§èƒ½ç›‘æ§

**å›¾æŸ¥è¯¢æ€§èƒ½ç›‘æ§**ï¼š

```sql
-- å¯ç”¨pg_stat_statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- æŸ¥çœ‹é€’å½’æŸ¥è¯¢æ€§èƒ½
SELECT
    query,
    calls,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%RECURSIVE%' OR query LIKE '%WITH RECURSIVE%'
ORDER BY mean_exec_time DESC
LIMIT 20;
```

**å›¾ç»Ÿè®¡ä¿¡æ¯**ï¼š

```sql
-- å›¾ç»Ÿè®¡æŸ¥è¯¢
CREATE OR REPLACE FUNCTION graph_statistics()
RETURNS TABLE (
    metric_name TEXT,
    metric_value BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 'total_vertices'::TEXT, COUNT(*)::BIGINT FROM vertices
    UNION ALL
    SELECT 'total_edges'::TEXT, COUNT(*)::BIGINT FROM edges
    UNION ALL
    SELECT 'avg_out_degree'::TEXT,
        (SELECT AVG(degree) FROM (
            SELECT COUNT(*) AS degree FROM edges GROUP BY src
        ) deg)::BIGINT
    UNION ALL
    SELECT 'avg_in_degree'::TEXT,
        (SELECT AVG(degree) FROM (
            SELECT COUNT(*) AS degree FROM edges GROUP BY dst
        ) deg)::BIGINT;
END;
$$ LANGUAGE plpgsql;
```

### 12.2 å›¾ç»Ÿè®¡

**åº¦åˆ†å¸ƒç»Ÿè®¡**ï¼š

```sql
-- è®¡ç®—åº¦åˆ†å¸ƒ
SELECT
    degree_range,
    COUNT(*) AS vertex_count
FROM (
    SELECT
        v.id,
        CASE
            WHEN (out_degree + in_degree) = 0 THEN '0'
            WHEN (out_degree + in_degree) < 10 THEN '1-9'
            WHEN (out_degree + in_degree) < 100 THEN '10-99'
            ELSE '100+'
        END AS degree_range
    FROM vertices v
    LEFT JOIN (
        SELECT src AS id, COUNT(*) AS out_degree
        FROM edges GROUP BY src
    ) out_deg ON out_deg.id = v.id
    LEFT JOIN (
        SELECT dst AS id, COUNT(*) AS in_degree
        FROM edges GROUP BY dst
    ) in_deg ON in_deg.id = v.id
) degree_stats
GROUP BY degree_range
ORDER BY degree_range;
```

### 12.3 é—®é¢˜æ’æŸ¥

**å¸¸è§é—®é¢˜è¯Šæ–­**ï¼š

```sql
-- æ£€æŸ¥å­¤ç«‹é¡¶ç‚¹
SELECT v.id, v.label
FROM vertices v
WHERE NOT EXISTS (
    SELECT 1 FROM edges WHERE src = v.id OR dst = v.id
);

-- æ£€æŸ¥è‡ªç¯
SELECT * FROM edges WHERE src = dst;

-- æ£€æŸ¥é‡å¤è¾¹
SELECT src, dst, label, COUNT(*) AS count
FROM edges
GROUP BY src, dst, label
HAVING COUNT(*) > 1;

-- æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read
FROM pg_stat_user_indexes
WHERE tablename IN ('vertices', 'edges')
ORDER BY idx_scan DESC;
```

---

## åä¸‰ã€æœ€ä½³å®è·µ

### 13.1 è®¾è®¡æœ€ä½³å®è·µ

1. **æ•°æ®æ¨¡å‹è®¾è®¡**ï¼š
   - åˆç†è®¾è®¡é¡¶ç‚¹å’Œè¾¹çš„ç»“æ„
   - ä½¿ç”¨JSONBå­˜å‚¨çµæ´»å±æ€§
   - å»ºç«‹é€‚å½“çš„ç´¢å¼•

2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼š
   - é™åˆ¶é€’å½’æ·±åº¦
   - ä½¿ç”¨ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
   - é¿å…å…¨å›¾æ‰«æ

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - åˆ†åŒºå¤§å›¾
   - æ‰¹é‡å¯¼å…¥ä¼˜åŒ–
   - å®šæœŸç»´æŠ¤ç´¢å¼•

### 13.2 å¼€å‘æœ€ä½³å®è·µ

1. **æŸ¥è¯¢ç¼–å†™**ï¼š
   - ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
   - é¿å…æ·±åº¦é€’å½’
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾ç¼“å­˜

2. **é”™è¯¯å¤„ç†**ï¼š
   - å¤„ç†å¾ªç¯æ£€æµ‹
   - é™åˆ¶æŸ¥è¯¢æ·±åº¦
   - è¶…æ—¶æ§åˆ¶

---

## åå››ã€å‚è€ƒèµ„æº

### 14.1 å®˜æ–¹æ–‡æ¡£

- [PostgreSQLé€’å½’æŸ¥è¯¢](https://www.postgresql.org/docs/current/queries-with.html)
- [PostgreSQL JSONB](https://www.postgresql.org/docs/current/datatype-json.html)
- [Apache AGEæ–‡æ¡£](https://age.apache.org/)

### 14.2 ç½‘ç»œèµ„æº

- [Apache AGE GitHub](https://github.com/apache/age)
- [CypheræŸ¥è¯¢è¯­è¨€](https://neo4j.com/developer/cypher/)
- [å›¾æ•°æ®åº“æœ€ä½³å®è·µ](https://www.postgresql.org/docs/current/)

### 14.3 ç›¸å…³æ–‡æ¡£

- [å‘é‡æ•°æ®åº“æ”¯æŒ](./03.05-å‘é‡æ•°æ®åº“æ”¯æŒ.md) - å‘é‡æ•°æ®åº“æ”¯æŒ
- [æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†](../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.01-æŸ¥è¯¢ä¼˜åŒ–å™¨åŸç†.md) - æŸ¥è¯¢ä¼˜åŒ–
- [æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜](../03-æŸ¥è¯¢ä¸ä¼˜åŒ–/02.04-æ‰§è¡Œè®¡åˆ’ä¸æ€§èƒ½è°ƒä¼˜.md) - æ€§èƒ½è°ƒä¼˜

---

## åäº”ã€å‚è€ƒæ–‡çŒ®

1. PostgreSQL Global Development Group. (2025). PostgreSQL 18 Documentation. <https://www.postgresql.org/docs/18/>

2. Apache Software Foundation. (2025). Apache AGE Documentation. <https://age.apache.org/>

3. Neo4j, Inc. (2025). Cypher Query Language Reference. <https://neo4j.com/docs/cypher-manual/>

4. Robinson, I., Webber, J., & Eifrem, E. (2015). Graph Databases (2nd ed.). O'Reilly Media.

5. PostgreSQL Global Development Group. (2024). PostgreSQL 17 Documentation. <https://www.postgresql.org/docs/17/>

---

**æœ€åæ›´æ–°**: 2025-01-15
**ç»´æŠ¤è€…**: Data Science Team
