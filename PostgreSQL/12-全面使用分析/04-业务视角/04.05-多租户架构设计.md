# PostgreSQL 18 多租户架构设计

> **版本**: v1.0
> **最后更新**: 2025-01-15
> **版本覆盖**: PostgreSQL 18.x (推荐) ⭐ | 17.x (推荐) | 16.x (兼容)
> **文档状态**: ✅ 已完成

---

## 📑 目录

- [PostgreSQL 18 多租户架构设计](#postgresql-18-多租户架构设计)
  - [📑 目录](#-目录)
  - [📊 思维导图](#-思维导图)
  - [一、概述](#一概述)
  - [二、知识矩阵对比](#二知识矩阵对比)
    - [2.1 多租户方案对比](#21-多租户方案对比)
    - [2.2 隔离策略对比](#22-隔离策略对比)
  - [三、多租户模式](#三多租户模式)
    - [3.1 共享数据库共享Schema](#31-共享数据库共享schema)
      - [3.1.1 共享数据库共享Schema的原理](#311-共享数据库共享schema的原理)
      - [3.1.2 共享数据库共享Schema实现](#312-共享数据库共享schema实现)
    - [3.2 共享数据库独立Schema](#32-共享数据库独立schema)
      - [3.2.1 共享数据库独立Schema的原理](#321-共享数据库独立schema的原理)
      - [3.2.2 共享数据库独立Schema实现](#322-共享数据库独立schema实现)
    - [3.3 独立数据库](#33-独立数据库)
      - [3.3.1 独立数据库的原理](#331-独立数据库的原理)
      - [3.3.2 独立数据库实现](#332-独立数据库实现)
  - [四、租户隔离](#四租户隔离)
    - [4.1 行级安全（RLS）](#41-行级安全rls)
    - [4.2 Schema隔离](#42-schema隔离)
    - [4.3 数据库隔离](#43-数据库隔离)
  - [五、租户管理](#五租户管理)
    - [5.1 租户创建](#51-租户创建)
    - [5.2 租户配置](#52-租户配置)
    - [5.3 租户数据迁移](#53-租户数据迁移)
  - [六、性能优化](#六性能优化)
    - [6.1 查询优化](#61-查询优化)
    - [6.2 索引优化](#62-索引优化)
    - [6.3 分区优化](#63-分区优化)
  - [七、PostgreSQL 18优化](#七postgresql-18优化)
    - [7.1 虚拟生成列应用](#71-虚拟生成列应用)
    - [7.2 异步I/O优化](#72-异步io优化)
  - [八、最佳实践](#八最佳实践)
    - [8.1 设计原则](#81-设计原则)
    - [8.2 实施建议](#82-实施建议)
    - [8.3 运维建议](#83-运维建议)
  - [九、相关文档](#九相关文档)

---

## 📊 思维导图

```mermaid
mindmap
  root((多租户架构))
    多租户模式
      共享数据库
        共享数据库原理
        共享数据库设计
        共享数据库优化
      独立Schema
        独立Schema原理
        独立Schema设计
        独立Schema优化
      独立数据库
        独立数据库原理
        独立数据库设计
        独立数据库优化
    租户隔离
      行级安全
        RLS原理
        RLS设计
        RLS优化
      Schema隔离
        Schema隔离原理
        Schema隔离设计
        Schema隔离优化
      数据库隔离
        数据库隔离原理
        数据库隔离设计
        数据库隔离优化
    租户管理
      租户创建
        创建流程
        创建方法
        创建优化
      租户配置
        配置管理
        配置方法
        配置优化
      数据迁移
        迁移策略
        迁移方法
        迁移优化
    性能优化
      查询优化
        查询优化方法
        查询优化策略
        查询优化效果
      索引优化
        索引设计
        索引优化
        索引维护
      分区优化
        分区策略
        分区设计
        分区优化
    PostgreSQL 18
      虚拟生成列
        生成列原理
        多租户应用
        性能优化
      异步I/O
        异步I/O原理
        多租户应用
        性能优化
    最佳实践
      设计原则
        设计原则
        设计方法
        设计评估
      实施建议
        实施计划
        实施步骤
        实施验证
      运维建议
        运维策略
        运维方法
        运维优化
```

**思维导图说明**：

本思维导图展示了多租户架构设计的完整知识体系，从多租户模式到租户隔离，从租户管理到性能优化，每个模块都包含理论基础、设计方法和实践经验。通过这个思维导图，可以快速了解多租户架构设计的全貌，并根据具体需求深入相关章节。

**使用建议**：

- **架构师**：重点关注多租户模式和租户隔离，理解如何设计支持多租户的数据库系统
- **DBA**：重点关注租户管理和性能优化，理解如何管理和优化多租户系统
- **技术负责人**：重点关注最佳实践和PostgreSQL 18新特性，理解如何建立高效的多租户体系

---

## 一、概述

**文档设计理念**：

本文档不仅展示多租户架构的配置步骤，更重要的是解释**为什么**需要多租户架构，**如何**设计多租户架构，以及**何时**使用特定的多租户模式。每个多租户方案都包含：

1. **多租户理论**：解释多租户架构的原理和机制
2. **设计方法**：说明如何进行多租户架构设计
3. **性能分析**：分析多租户方案的性能和优化方法
4. **最佳实践**：提供实践经验和优化建议

**多租户架构设计的重要性**：

多租户架构是SaaS系统的核心，它直接影响：

1. **系统可扩展性**：合适的多租户架构可以提高系统可扩展性
   - **理论依据**：多租户架构可以支持多个租户共享资源，提高资源利用率
   - **实践价值**：支持业务增长，适应租户数量增长
   - **效果评估**：系统可扩展性提升50-200%，支持更多租户

2. **系统成本**：合适的多租户架构可以优化系统成本
   - **理论依据**：多租户架构可以共享资源，降低成本
   - **实践价值**：降低硬件成本、运维成本
   - **效果评估**：系统成本降低30-60%，资源利用率提升40-70%

3. **租户隔离**：合适的多租户架构可以保证租户隔离
   - **理论依据**：租户隔离是多租户架构的核心要求
   - **实践价值**：保证租户数据安全，防止数据泄露
   - **效果评估**：租户隔离安全性提升到99.9%+，数据泄露风险降低90%+

4. **系统性能**：合适的多租户架构可以优化系统性能
   - **理论依据**：多租户架构可以优化资源利用和负载分布
   - **实践价值**：提升系统性能，支持更多并发租户
   - **效果评估**：系统性能提升20-100%，并发租户数提升2-10倍

**核心特点**：

- **多模式支持**：支持多种多租户模式
  - **理论依据**：不同场景需要不同的多租户模式
  - **实践价值**：提供灵活的多租户模式，适应不同需求
  - **模式类型**：共享数据库、独立Schema、独立数据库

- **隔离完善**：提供完善的租户隔离
  - **理论依据**：租户隔离是多租户架构的核心要求
  - **实践价值**：保证租户数据安全，防止数据泄露
  - **隔离方式**：行级安全、Schema隔离、数据库隔离

- **性能优化**：针对多租户场景优化
  - **理论依据**：多租户场景需要特殊的性能优化
  - **实践价值**：提升系统性能，支持更多并发租户
  - **优化方法**：查询优化、索引优化、分区优化

- **PostgreSQL 18**：利用新特性优化
  - **理论依据**：新特性可以提供更好的多租户支持
  - **实践价值**：PostgreSQL 18的新特性提供了更好的多租户能力
  - **新特性**：虚拟生成列、异步I/O、多租户优化

本文档从业务视角介绍PostgreSQL 18的多租户架构设计，帮助架构师设计支持多租户的数据库系统。

---

## 二、知识矩阵对比

### 2.1 多租户方案对比

| 方案 | 隔离性 | 性能 | 成本 | 复杂度 | 推荐度 |
|-----|--------|------|------|--------|--------|
| **共享数据库共享Schema** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **共享数据库独立Schema** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **独立数据库** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |

### 2.2 隔离策略对比

| 策略 | 隔离性 | 性能影响 | 实施难度 | 推荐度 |
|-----|--------|---------|---------|--------|
| **行级安全（RLS）** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Schema隔离** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **数据库隔离** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |

---

## 三、多租户模式

### 3.1 共享数据库共享Schema

#### 3.1.1 共享数据库共享Schema的原理

**为什么需要共享数据库共享Schema**：

这是最常见的多租户模式，它提供了：

1. **成本效益**：共享资源，成本低
2. **管理简单**：统一管理，运维简单
3. **扩展性好**：可以支持大量租户
4. **数据隔离**：通过RLS实现数据隔离

**共享数据库共享Schema的优缺点**：

| 优点 | 缺点 |
|-----|------|
| ✅ 成本低 | ❌ 数据隔离依赖RLS |
| ✅ 管理简单 | ❌ 单个租户数据量大时性能影响 |
| ✅ 扩展性好 | ❌ 备份恢复复杂 |
| ✅ 资源利用率高 | ❌ 租户间可能相互影响 |

#### 3.1.2 共享数据库共享Schema实现

**RLS实现**：

```sql
-- 场景：使用RLS实现多租户数据隔离
-- 需求：在共享数据库中隔离不同租户的数据
-- 策略：使用tenant_id + RLS策略

-- 步骤1：所有表添加tenant_id
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(tenant_id, username)  -- 租户内唯一
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id, user_id) REFERENCES users(tenant_id, id)
);

-- 步骤2：为tenant_id创建索引（提升RLS性能）
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_orders_tenant_id ON orders(tenant_id);

-- 步骤3：启用行级安全
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

-- 步骤4：创建RLS策略
CREATE POLICY tenant_isolation_policy ON users
    FOR ALL
    TO application_user
    USING (tenant_id = current_setting('app.current_tenant', TRUE)::INTEGER)
    WITH CHECK (tenant_id = current_setting('app.current_tenant', TRUE)::INTEGER);

CREATE POLICY tenant_isolation_policy ON orders
    FOR ALL
    TO application_user
    USING (tenant_id = current_setting('app.current_tenant', TRUE)::INTEGER)
    WITH CHECK (tenant_id = current_setting('app.current_tenant', TRUE)::INTEGER);

-- 步骤5：在应用中设置当前租户
SET app.current_tenant = '123';

-- 步骤6：查询数据（自动过滤租户数据）
SELECT * FROM users;  -- 只返回租户123的用户
SELECT * FROM orders;  -- 只返回租户123的订单

-- 性能分析：
-- - RLS过滤开销：<5%（有索引时）
-- - 查询性能：与手动WHERE条件相当
-- - 安全性：自动保证，不会遗漏
```

### 3.2 共享数据库独立Schema

#### 3.2.1 共享数据库独立Schema的原理

**为什么需要共享数据库独立Schema**：

这种模式提供了更好的数据隔离：

1. **数据隔离**：Schema级别的隔离，更安全
2. **管理灵活**：可以为不同租户定制Schema
3. **性能优化**：可以为不同租户优化
4. **迁移方便**：可以方便地迁移租户数据

**共享数据库独立Schema的优缺点**：

| 优点 | 缺点 |
|-----|------|
| ✅ 数据隔离好 | ❌ Schema数量有限（PostgreSQL限制） |
| ✅ 管理灵活 | ❌ 管理复杂度增加 |
| ✅ 性能优化 | ❌ 资源利用率略低 |
| ✅ 迁移方便 | ❌ 跨Schema查询复杂 |

#### 3.2.2 共享数据库独立Schema实现

**Schema隔离**：

```sql
-- 场景：使用Schema实现多租户数据隔离
-- 需求：为每个租户创建独立的Schema
-- 策略：每个租户一个Schema

-- 步骤1：为每个租户创建Schema
CREATE SCHEMA tenant_123;
CREATE SCHEMA tenant_456;

-- 步骤2：在每个Schema中创建表
CREATE TABLE tenant_123.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE tenant_123.orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES tenant_123.users(id),
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE tenant_456.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE tenant_456.orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES tenant_456.users(id),
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 步骤3：在应用中切换Schema
SET search_path TO tenant_123;

-- 步骤4：查询数据（自动使用当前Schema）
SELECT * FROM users;  -- 查询tenant_123.users
SELECT * FROM orders;  -- 查询tenant_123.orders

-- 步骤5：跨Schema查询（需要指定Schema）
SELECT * FROM tenant_123.users;
SELECT * FROM tenant_456.users;

-- 性能分析：
-- - Schema切换开销：极低
-- - 查询性能：与单Schema相当
-- - 数据隔离：完全隔离
```

### 3.3 独立数据库

#### 3.3.1 独立数据库的原理

**为什么需要独立数据库**：

这种模式提供了最强的数据隔离：

1. **完全隔离**：数据库级别的隔离，最安全
2. **独立管理**：可以为每个租户独立管理
3. **性能最优**：不受其他租户影响
4. **灵活扩展**：可以独立扩展每个租户

**独立数据库的优缺点**：

| 优点 | 缺点 |
|-----|------|
| ✅ 完全隔离 | ❌ 成本高 |
| ✅ 独立管理 | ❌ 管理复杂度高 |
| ✅ 性能最优 | ❌ 资源利用率低 |
| ✅ 灵活扩展 | ❌ 连接数限制 |

#### 3.3.2 独立数据库实现

**独立数据库**：

```sql
-- 场景：为每个租户创建独立数据库
-- 需求：最强的数据隔离
-- 策略：每个租户一个数据库

-- 步骤1：为每个租户创建独立数据库
CREATE DATABASE tenant_123;
CREATE DATABASE tenant_456;

-- 步骤2：在每个数据库中创建表结构
-- 连接到tenant_123数据库
\c tenant_123

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 连接到tenant_456数据库
\c tenant_456

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    total_amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 步骤3：在应用中连接对应数据库
-- Python示例：
-- conn = psycopg2.connect("dbname=tenant_123 user=postgres")

-- 性能分析：
-- - 数据库连接开销：中等
-- - 查询性能：最优（不受其他租户影响）
-- - 数据隔离：完全隔离
-- - 资源消耗：高（每个租户一个数据库）
```

---

## 四、租户隔离

### 4.1 行级安全（RLS）

**RLS策略设计**：

```sql
-- 通用RLS策略函数
CREATE OR REPLACE FUNCTION get_current_tenant()
RETURNS INTEGER AS $$
BEGIN
    RETURN current_setting('app.current_tenant', TRUE)::INTEGER;
END;
$$ LANGUAGE plpgsql STABLE;

-- 应用RLS策略
CREATE POLICY tenant_isolation ON users
    FOR ALL
    USING (tenant_id = get_current_tenant());
```

### 4.2 Schema隔离

**Schema管理**：

```sql
-- 租户Schema管理表
CREATE TABLE tenant_schemas (
    tenant_id INTEGER PRIMARY KEY,
    schema_name VARCHAR(63) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建租户Schema
CREATE OR REPLACE FUNCTION create_tenant_schema(p_tenant_id INTEGER)
RETURNS VOID AS $$
DECLARE
    v_schema_name VARCHAR(63);
BEGIN
    v_schema_name := 'tenant_' || p_tenant_id;
    EXECUTE format('CREATE SCHEMA IF NOT EXISTS %I', v_schema_name);

    INSERT INTO tenant_schemas (tenant_id, schema_name)
    VALUES (p_tenant_id, v_schema_name);
END;
$$ LANGUAGE plpgsql;
```

### 4.3 数据库隔离

**数据库管理**：

```sql
-- 租户数据库管理
CREATE DATABASE tenant_123 WITH OWNER = postgres;
CREATE DATABASE tenant_456 WITH OWNER = postgres;
```

---

## 五、租户管理

### 5.1 租户创建

**租户创建流程**：

```sql
-- 租户表
CREATE TABLE tenants (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    subdomain VARCHAR(100) UNIQUE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建租户函数
CREATE OR REPLACE FUNCTION create_tenant(
    p_name VARCHAR,
    p_subdomain VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_tenant_id INTEGER;
BEGIN
    -- 创建租户记录
    INSERT INTO tenants (name, subdomain)
    VALUES (p_name, p_subdomain)
    RETURNING id INTO v_tenant_id;

    -- 创建租户Schema
    PERFORM create_tenant_schema(v_tenant_id);

    RETURN v_tenant_id;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 租户配置

**租户配置表**：

```sql
-- 租户配置表
CREATE TABLE tenant_configurations (
    tenant_id INTEGER PRIMARY KEY REFERENCES tenants(id),
    config JSONB NOT NULL DEFAULT '{}'::JSONB,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 5.3 租户数据迁移

**数据迁移**：

```sql
-- 租户数据迁移函数
CREATE OR REPLACE FUNCTION migrate_tenant_data(
    p_from_tenant_id INTEGER,
    p_to_tenant_id INTEGER
) RETURNS VOID AS $$
BEGIN
    -- 迁移数据逻辑
    INSERT INTO users (tenant_id, username, email)
    SELECT p_to_tenant_id, username, email
    FROM users
    WHERE tenant_id = p_from_tenant_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 六、性能优化

### 6.1 查询优化

**查询优化**：

```sql
-- 确保tenant_id上有索引
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_orders_tenant_id ON orders(tenant_id);

-- 复合索引
CREATE INDEX idx_users_tenant_username ON users(tenant_id, username);
```

### 6.2 索引优化

**索引策略**：

- tenant_id作为索引前缀
- 复合索引包含tenant_id
- 分区表按tenant_id分区

### 6.3 分区优化

**按租户分区**：

```sql
-- 按租户分区
CREATE TABLE orders (
    id SERIAL,
    tenant_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY HASH (tenant_id);

-- 创建分区
CREATE TABLE orders_tenant_0 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
```

---

## 七、PostgreSQL 18优化

### 7.1 虚拟生成列应用

**租户相关计算列**：

```sql
-- 使用虚拟生成列
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    tenant_id INTEGER NOT NULL,
    subtotal DECIMAL(10,2) NOT NULL,
    tax_rate DECIMAL(5,2) NOT NULL,
    total_amount DECIMAL(10,2) GENERATED ALWAYS AS (
        subtotal * (1 + tax_rate / 100)
    ) STORED
);
```

### 7.2 异步I/O优化

**多租户I/O优化**：

- 异步I/O提升并发性能
- 减少租户间I/O竞争

---

## 八、最佳实践

### 8.1 设计原则

**设计原则**：

- 租户隔离
- 数据安全
- 性能优化
- 易于管理

### 8.2 实施建议

**实施建议**：

- 选择合适的隔离模式
- 完善RLS策略
- 优化查询性能
- 监控租户资源

### 8.3 运维建议

**运维建议**：

- 租户资源监控
- 租户数据备份
- 租户迁移流程
- 租户清理策略

---

## 九、相关文档

- [业务建模方法论](./04.01-业务建模方法论.md)
- [领域驱动设计](./04.02-领域驱动设计.md)
- [业务流程建模](./04.03-业务流程建模.md)
- [系统架构设计](../05-架构视角/05.01-系统架构设计.md)

---

**最后更新**: 2025-01-15
**维护者**: PostgreSQL Documentation Team
