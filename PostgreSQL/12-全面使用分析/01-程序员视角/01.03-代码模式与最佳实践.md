# PostgreSQL 18 ä»£ç æ¨¡å¼ä¸æœ€ä½³å®è·µ

> **ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-15
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ ç›®å½•

- [PostgreSQL 18 ä»£ç æ¨¡å¼ä¸æœ€ä½³å®è·µ](#postgresql-18-ä»£ç æ¨¡å¼ä¸æœ€ä½³å®è·µ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ğŸ“Š æ€ç»´å¯¼å›¾](#-æ€ç»´å¯¼å›¾)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
  - [äºŒã€çŸ¥è¯†çŸ©é˜µå¯¹æ¯”](#äºŒçŸ¥è¯†çŸ©é˜µå¯¹æ¯”)
    - [2.1 ä»£ç ç»„ç»‡æ¨¡å¼å¯¹æ¯”](#21-ä»£ç ç»„ç»‡æ¨¡å¼å¯¹æ¯”)
    - [2.2 æ•°æ®è®¿é—®æ¨¡å¼å¯¹æ¯”](#22-æ•°æ®è®¿é—®æ¨¡å¼å¯¹æ¯”)
  - [ä¸‰ã€ä»£ç ç»„ç»‡](#ä¸‰ä»£ç ç»„ç»‡)
    - [3.1 Schemaç»„ç»‡](#31-schemaç»„ç»‡)
      - [3.1.1 Schemaç»„ç»‡çš„é‡è¦æ€§](#311-schemaç»„ç»‡çš„é‡è¦æ€§)
      - [3.1.2 æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡](#312-æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡)
      - [3.1.3 æŒ‰æ•°æ®ç‰¹æ€§ç»„ç»‡](#313-æŒ‰æ•°æ®ç‰¹æ€§ç»„ç»‡)
    - [3.2 å‘½åè§„èŒƒ](#32-å‘½åè§„èŒƒ)
      - [3.2.1 å‘½åè§„èŒƒçš„é‡è¦æ€§](#321-å‘½åè§„èŒƒçš„é‡è¦æ€§)
      - [3.2.2 è¡¨å‘½åè§„èŒƒ](#322-è¡¨å‘½åè§„èŒƒ)
      - [3.2.3 å‡½æ•°å‘½åè§„èŒƒ](#323-å‡½æ•°å‘½åè§„èŒƒ)
      - [3.2.4 ç´¢å¼•å‘½åè§„èŒƒ](#324-ç´¢å¼•å‘½åè§„èŒƒ)
    - [3.3 æ¨¡å—åŒ–è®¾è®¡](#33-æ¨¡å—åŒ–è®¾è®¡)
  - [å››ã€æ•°æ®è®¿é—®æ¨¡å¼](#å››æ•°æ®è®¿é—®æ¨¡å¼)
    - [4.1 Repositoryæ¨¡å¼](#41-repositoryæ¨¡å¼)
      - [4.1.1 Repositoryæ¨¡å¼çš„è®¾è®¡åŸç†](#411-repositoryæ¨¡å¼çš„è®¾è®¡åŸç†)
      - [4.1.2 Repositoryæ¨¡å¼å®ç°](#412-repositoryæ¨¡å¼å®ç°)
    - [4.2 Data Mapperæ¨¡å¼](#42-data-mapperæ¨¡å¼)
    - [4.3 Active Recordæ¨¡å¼](#43-active-recordæ¨¡å¼)
  - [äº”ã€äº‹åŠ¡ç®¡ç†æ¨¡å¼](#äº”äº‹åŠ¡ç®¡ç†æ¨¡å¼)
    - [5.1 Unit of Workæ¨¡å¼](#51-unit-of-workæ¨¡å¼)
    - [5.2 äº‹åŠ¡è„šæœ¬æ¨¡å¼](#52-äº‹åŠ¡è„šæœ¬æ¨¡å¼)
    - [5.3 é¢†åŸŸæœåŠ¡æ¨¡å¼](#53-é¢†åŸŸæœåŠ¡æ¨¡å¼)
  - [å…­ã€æŸ¥è¯¢æ¨¡å¼](#å…­æŸ¥è¯¢æ¨¡å¼)
    - [6.1 æŸ¥è¯¢å¯¹è±¡æ¨¡å¼](#61-æŸ¥è¯¢å¯¹è±¡æ¨¡å¼)
    - [6.2 è§„èŒƒæ¨¡å¼](#62-è§„èŒƒæ¨¡å¼)
    - [6.3 æŸ¥è¯¢æ„å»ºå™¨æ¨¡å¼](#63-æŸ¥è¯¢æ„å»ºå™¨æ¨¡å¼)
  - [ä¸ƒã€é”™è¯¯å¤„ç†æ¨¡å¼](#ä¸ƒé”™è¯¯å¤„ç†æ¨¡å¼)
    - [7.1 å¼‚å¸¸å¤„ç†æ¨¡å¼](#71-å¼‚å¸¸å¤„ç†æ¨¡å¼)
    - [7.2 ç»“æœå¯¹è±¡æ¨¡å¼](#72-ç»“æœå¯¹è±¡æ¨¡å¼)
    - [7.3 é‡è¯•æ¨¡å¼](#73-é‡è¯•æ¨¡å¼)
  - [å…«ã€æ€§èƒ½ä¼˜åŒ–æ¨¡å¼](#å…«æ€§èƒ½ä¼˜åŒ–æ¨¡å¼)
    - [8.1 æ‰¹é‡æ“ä½œæ¨¡å¼](#81-æ‰¹é‡æ“ä½œæ¨¡å¼)
    - [8.2 ç¼“å­˜æ¨¡å¼](#82-ç¼“å­˜æ¨¡å¼)
    - [8.3 å»¶è¿ŸåŠ è½½æ¨¡å¼](#83-å»¶è¿ŸåŠ è½½æ¨¡å¼)
  - [ä¹ã€ä»£ç è´¨é‡](#ä¹ä»£ç è´¨é‡)
    - [9.1 ä»£ç å®¡æŸ¥æ¸…å•](#91-ä»£ç å®¡æŸ¥æ¸…å•)
    - [9.2 æµ‹è¯•ç­–ç•¥](#92-æµ‹è¯•ç­–ç•¥)
    - [9.3 æ–‡æ¡£è§„èŒƒ](#93-æ–‡æ¡£è§„èŒƒ)
  - [åã€ç›¸å…³æ–‡æ¡£](#åç›¸å…³æ–‡æ¡£)

---

## ğŸ“Š æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((ä»£ç æ¨¡å¼ä¸æœ€ä½³å®è·µ))
    ä»£ç ç»„ç»‡
      Schemaç»„ç»‡
        æŒ‰åŠŸèƒ½æ¨¡å—
        æŒ‰æ•°æ®ç‰¹æ€§
        å‘½åè§„èŒƒ
      å‘½åè§„èŒƒ
        è¡¨å‘½å
        å‡½æ•°å‘½å
        ç´¢å¼•å‘½å
        çº¦æŸå‘½å
      æ¨¡å—åŒ–è®¾è®¡
        æ¨¡å—åˆ’åˆ†
        æ¨¡å—ä¾èµ–
        æ¨¡å—å¤ç”¨
    æ•°æ®è®¿é—®æ¨¡å¼
      Repository
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        é€‚ç”¨åœºæ™¯
      Data Mapper
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        é€‚ç”¨åœºæ™¯
      Active Record
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        é€‚ç”¨åœºæ™¯
    äº‹åŠ¡ç®¡ç†
      Unit of Work
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        æ€§èƒ½ä¼˜åŒ–
      äº‹åŠ¡è„šæœ¬
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        é€‚ç”¨åœºæ™¯
      é¢†åŸŸæœåŠ¡
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        é€‚ç”¨åœºæ™¯
    æŸ¥è¯¢æ¨¡å¼
      æŸ¥è¯¢å¯¹è±¡
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        æŸ¥è¯¢ä¼˜åŒ–
      è§„èŒƒæ¨¡å¼
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        é€‚ç”¨åœºæ™¯
      æŸ¥è¯¢æ„å»ºå™¨
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        æ€§èƒ½ä¼˜åŒ–
    é”™è¯¯å¤„ç†
      å¼‚å¸¸å¤„ç†
        å¼‚å¸¸ç±»å‹
        å¤„ç†ç­–ç•¥
        é”™è¯¯æ¢å¤
      ç»“æœå¯¹è±¡
        è®¾è®¡åŸç†
        å®ç°æ–¹å¼
        é€‚ç”¨åœºæ™¯
      é‡è¯•æ¨¡å¼
        é‡è¯•ç­–ç•¥
        é€€é¿ç®—æ³•
        é€‚ç”¨åœºæ™¯
    æ€§èƒ½ä¼˜åŒ–
      æ‰¹é‡æ“ä½œ
        æ‰¹é‡æ’å…¥
        æ‰¹é‡æ›´æ–°
        æ‰¹é‡åˆ é™¤
      ç¼“å­˜
        ç¼“å­˜ç­–ç•¥
        ç¼“å­˜å¤±æ•ˆ
        ç¼“å­˜æ›´æ–°
      å»¶è¿ŸåŠ è½½
        å»¶è¿ŸåŠ è½½åŸç†
        å®ç°æ–¹å¼
        æ€§èƒ½ä¼˜åŒ–
    ä»£ç è´¨é‡
      ä»£ç å®¡æŸ¥
        å®¡æŸ¥æ¸…å•
        å®¡æŸ¥æµç¨‹
        å®¡æŸ¥å·¥å…·
      æµ‹è¯•ç­–ç•¥
        å•å…ƒæµ‹è¯•
        é›†æˆæµ‹è¯•
        æ€§èƒ½æµ‹è¯•
      æ–‡æ¡£è§„èŒƒ
        ä»£ç æ³¨é‡Š
        APIæ–‡æ¡£
        è®¾è®¡æ–‡æ¡£
```

**æ€ç»´å¯¼å›¾è¯´æ˜**ï¼š

æœ¬æ€ç»´å¯¼å›¾å±•ç¤ºäº†ä»£ç æ¨¡å¼ä¸æœ€ä½³å®è·µçš„å®Œæ•´çŸ¥è¯†ä½“ç³»ï¼Œä»ä»£ç ç»„ç»‡åˆ°æ•°æ®è®¿é—®æ¨¡å¼ï¼Œä»äº‹åŠ¡ç®¡ç†åˆ°æ€§èƒ½ä¼˜åŒ–ï¼Œæ¯ä¸ªæ¨¡å—éƒ½åŒ…å«ç†è®ºåŸºç¡€ã€å®ç°æ–¹æ³•å’Œå®è·µç»éªŒã€‚é€šè¿‡è¿™ä¸ªæ€ç»´å¯¼å›¾ï¼Œå¯ä»¥å¿«é€Ÿäº†è§£PostgreSQLå¼€å‘ä¸­çš„ä»£ç æ¨¡å¼ï¼Œå¹¶æ ¹æ®å…·ä½“éœ€æ±‚æ·±å…¥ç›¸å…³ç« èŠ‚ã€‚

**ä½¿ç”¨å»ºè®®**ï¼š

- **å¼€å‘äººå‘˜**ï¼šé‡ç‚¹å…³æ³¨ä»£ç ç»„ç»‡å’Œæ•°æ®è®¿é—®æ¨¡å¼ï¼Œç†è§£å¦‚ä½•ç¼–å†™é«˜è´¨é‡çš„æ•°æ®åº“ä»£ç 
- **æ¶æ„å¸ˆ**ï¼šé‡ç‚¹å…³æ³¨è®¾è®¡æ¨¡å¼å’Œæœ€ä½³å®è·µï¼Œç†è§£å¦‚ä½•è®¾è®¡å¯ç»´æŠ¤çš„ç³»ç»Ÿæ¶æ„
- **æŠ€æœ¯è´Ÿè´£äºº**ï¼šé‡ç‚¹å…³æ³¨ä»£ç è´¨é‡å’Œæµ‹è¯•ç­–ç•¥ï¼Œç†è§£å¦‚ä½•ä¿è¯ä»£ç è´¨é‡

---

## ä¸€ã€æ¦‚è¿°

**æ–‡æ¡£è®¾è®¡ç†å¿µ**ï¼š

æœ¬æ–‡æ¡£ä¸ä»…å±•ç¤ºä»£ç æ¨¡å¼çš„å®ç°ä»£ç ï¼Œæ›´é‡è¦çš„æ˜¯è§£é‡Š**ä¸ºä»€ä¹ˆ**éœ€è¦è¿™äº›ä»£ç æ¨¡å¼ï¼Œ**å¦‚ä½•**åº”ç”¨è¿™äº›æ¨¡å¼ï¼Œä»¥åŠ**ä½•æ—¶**é€‰æ‹©ç‰¹å®šçš„æ¨¡å¼ã€‚æ¯ä¸ªæ¨¡å¼éƒ½åŒ…å«ï¼š

1. **ç†è®ºåŸºç¡€**ï¼šè§£é‡Šæ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³å’ŒåŸç†
2. **å®ç°æ–¹æ³•**ï¼šè¯´æ˜å¦‚ä½•åœ¨PostgreSQLä¸­å®ç°
3. **åº”ç”¨åœºæ™¯**ï¼šåˆ†æé€‚ç”¨åœºæ™¯å’Œæƒè¡¡è€ƒè™‘
4. **æœ€ä½³å®è·µ**ï¼šæä¾›å®è·µç»éªŒå’Œä¼˜åŒ–å»ºè®®

**ä»£ç æ¨¡å¼ä¸æœ€ä½³å®è·µçš„é‡è¦æ€§**ï¼š

ä»£ç æ¨¡å¼æ˜¯è½¯ä»¶å¼€å‘çš„åŸºç¡€ï¼Œå®ƒç›´æ¥å½±å“ï¼š

1. **ä»£ç è´¨é‡**ï¼šåˆé€‚çš„ä»£ç æ¨¡å¼å¯ä»¥æé«˜ä»£ç è´¨é‡
   - **ç†è®ºä¾æ®**ï¼šæ¨¡å¼æä¾›äº†ç»è¿‡éªŒè¯çš„ä»£ç ç»„ç»‡æ–¹å¼
   - **å®è·µä»·å€¼**ï¼šæé«˜ä»£ç å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§ã€å¯æµ‹è¯•æ€§
   - **æ•ˆæœè¯„ä¼°**ï¼šä»£ç è´¨é‡æå‡30-50%ï¼Œç»´æŠ¤æˆæœ¬é™ä½40-60%

2. **å¼€å‘æ•ˆç‡**ï¼šåˆé€‚çš„ä»£ç æ¨¡å¼å¯ä»¥æé«˜å¼€å‘æ•ˆç‡
   - **ç†è®ºä¾æ®**ï¼šæ¨¡å¼æä¾›äº†å¯å¤ç”¨çš„ä»£ç ç»“æ„
   - **å®è·µä»·å€¼**ï¼šå‡å°‘é‡å¤ä»£ç ï¼Œæé«˜å¼€å‘é€Ÿåº¦
   - **æ•ˆæœè¯„ä¼°**ï¼šå¼€å‘æ•ˆç‡æå‡40-70%

3. **ç³»ç»Ÿæ€§èƒ½**ï¼šåˆé€‚çš„ä»£ç æ¨¡å¼å¯ä»¥ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½
   - **ç†è®ºä¾æ®**ï¼šæ¨¡å¼æä¾›äº†æ€§èƒ½ä¼˜åŒ–çš„æœ€ä½³å®è·µ
   - **å®è·µä»·å€¼**ï¼šé€‰æ‹©æ€§èƒ½å‹å¥½çš„æ¨¡å¼å¯ä»¥æå‡ç³»ç»Ÿæ€§èƒ½
   - **æ•ˆæœè¯„ä¼°**ï¼šæ€§èƒ½æå‡20-40%

4. **ç³»ç»Ÿå¯ç»´æŠ¤æ€§**ï¼šåˆé€‚çš„ä»£ç æ¨¡å¼å¯ä»¥æé«˜ç³»ç»Ÿå¯ç»´æŠ¤æ€§
   - **ç†è®ºä¾æ®**ï¼šæ¨¡å¼æä¾›äº†æ¸…æ™°çš„ä»£ç ç»“æ„
   - **å®è·µä»·å€¼**ï¼šæé«˜ä»£ç çš„å¯ç†è§£æ€§å’Œå¯ä¿®æ”¹æ€§
   - **æ•ˆæœè¯„ä¼°**ï¼šç»´æŠ¤æˆæœ¬é™ä½30-50%

**æ ¸å¿ƒç‰¹ç‚¹**ï¼š

- **æ¨¡å¼å…¨é¢**ï¼šè¦†ç›–PostgreSQLå¼€å‘ä¸­çš„ä¸»è¦ä»£ç æ¨¡å¼
  - **ç†è®ºä¾æ®**ï¼šå…¨é¢çš„æ¨¡å¼è¦†ç›–å¯ä»¥æé«˜ä»£ç è´¨é‡
  - **å®è·µä»·å€¼**ï¼šå¸®åŠ©å¼€å‘äººå‘˜é€‰æ‹©æœ€é€‚åˆçš„ä»£ç æ¨¡å¼
  - **æ¨¡å¼ç±»å‹**ï¼šä»£ç ç»„ç»‡ã€æ•°æ®è®¿é—®ã€äº‹åŠ¡ç®¡ç†ã€æŸ¥è¯¢ã€é”™è¯¯å¤„ç†ã€æ€§èƒ½ä¼˜åŒ–

- **å®è·µå¯¼å‘**ï¼šåŸºäºå®é™…é¡¹ç›®ç»éªŒ
  - **ç†è®ºä¾æ®**ï¼šåŸºäºå®é™…é¡¹ç›®çš„ç»éªŒæ€»ç»“
  - **å®è·µä»·å€¼**ï¼šé¿å…å¸¸è§é™·é˜±ï¼Œæé«˜å¼€å‘æ•ˆç‡
  - **å®è·µå†…å®¹**ï¼šä»£ç å®¡æŸ¥æ¸…å•ã€æµ‹è¯•ç­–ç•¥ã€æ–‡æ¡£è§„èŒƒ

- **è´¨é‡ä¿è¯**ï¼šæä¾›ä»£ç è´¨é‡ä¿è¯æ–¹æ³•
  - **ç†è®ºä¾æ®**ï¼šè´¨é‡ä¿è¯å¯ä»¥æé«˜ä»£ç å¯é æ€§
  - **å®è·µä»·å€¼**ï¼šå‡å°‘bugï¼Œæé«˜ç³»ç»Ÿç¨³å®šæ€§
  - **è´¨é‡æ–¹æ³•**ï¼šä»£ç å®¡æŸ¥ã€æµ‹è¯•ç­–ç•¥ã€æ–‡æ¡£è§„èŒƒ

æœ¬æ–‡æ¡£ä»‹ç»PostgreSQLå¼€å‘ä¸­çš„å¸¸ç”¨ä»£ç æ¨¡å¼ã€è®¾è®¡æ¨¡å¼å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å¼€å‘è€…ç¼–å†™é«˜è´¨é‡ã€å¯ç»´æŠ¤ã€é«˜æ€§èƒ½çš„æ•°æ®åº“ä»£ç ã€‚

**æ ¸å¿ƒç‰¹ç‚¹**ï¼š

- **æ¨¡å¼åŒ–è®¾è®¡**ï¼šæä¾›å¯å¤ç”¨çš„ä»£ç æ¨¡å¼
- **æœ€ä½³å®è·µ**ï¼šåŸºäºå®é™…é¡¹ç›®ç»éªŒæ€»ç»“
- **æ€§èƒ½ä¼˜åŒ–**ï¼šç»“åˆPostgreSQL 18æ–°ç‰¹æ€§
- **å¯ç»´æŠ¤æ€§**ï¼šå…³æ³¨ä»£ç è´¨é‡å’Œå¯è¯»æ€§

**PostgreSQL 18 æ–°ç‰¹æ€§æ”¯æŒ**ï¼š

- âœ… **è™šæ‹Ÿç”Ÿæˆåˆ—**ï¼šç®€åŒ–è®¡ç®—åˆ—çš„å®ç°
- âœ… **å¼‚æ­¥I/O**ï¼šæå‡æ‰¹é‡æ“ä½œæ€§èƒ½
- âœ… **MERGEä¼˜åŒ–**ï¼šæ”¹è¿›æ•°æ®åŒæ­¥æ¨¡å¼
- âœ… **JSONBå¢å¼º**ï¼šä¼˜åŒ–æ–‡æ¡£æ•°æ®è®¿é—®æ¨¡å¼

---

## äºŒã€çŸ¥è¯†çŸ©é˜µå¯¹æ¯”

### 2.1 ä»£ç ç»„ç»‡æ¨¡å¼å¯¹æ¯”

| æ¨¡å¼ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ | å¯ç»´æŠ¤æ€§ | æ¨èåº¦ |
|-----|------|---------|--------|---------|--------|
| **Schemaåˆ†ç¦»** | æŒ‰åŠŸèƒ½æ¨¡å—åˆ†ç¦» | å¤§å‹ç³»ç»Ÿã€å¤šç§Ÿæˆ· | â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **å‘½åç©ºé—´** | ä½¿ç”¨Schemaä½œä¸ºå‘½åç©ºé—´ | æ¨¡å—åŒ–ç³»ç»Ÿ | â­â­ | â­â­â­â­ | â­â­â­â­ |
| **å•ä¸€Schema** | æ‰€æœ‰å¯¹è±¡åœ¨ä¸€ä¸ªSchema | å°å‹ç³»ç»Ÿ | â­ | â­â­â­ | â­â­ |

### 2.2 æ•°æ®è®¿é—®æ¨¡å¼å¯¹æ¯”

| æ¨¡å¼ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ | æ€§èƒ½ | å¤æ‚åº¦ | æ¨èåº¦ |
|-----|------|---------|------|--------|--------|
| **Repository** | æ•°æ®è®¿é—®æŠ½è±¡ | å¤æ‚ä¸šåŠ¡é€»è¾‘ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **Data Mapper** | å¯¹è±¡-å…³ç³»æ˜ å°„ | ORMæ¡†æ¶ | â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |
| **Active Record** | å¯¹è±¡åŒ…å«æ•°æ®å’Œè¡Œä¸º | ç®€å•CRUD | â­â­â­â­ | â­â­ | â­â­â­ |

---

## ä¸‰ã€ä»£ç ç»„ç»‡

### 3.1 Schemaç»„ç»‡

#### 3.1.1 Schemaç»„ç»‡çš„é‡è¦æ€§

**ä¸ºä»€ä¹ˆéœ€è¦Schemaç»„ç»‡**ï¼š

åœ¨å¤§å‹PostgreSQLé¡¹ç›®ä¸­ï¼ŒSchemaç»„ç»‡æ˜¯ä»£ç ç»„ç»‡çš„åŸºç¡€ï¼Œå®ƒæä¾›äº†ä»¥ä¸‹ä¼˜åŠ¿ï¼š

1. **å‘½åç©ºé—´éš”ç¦»**ï¼šé¿å…å¯¹è±¡åç§°å†²çªï¼Œä¸åŒæ¨¡å—å¯ä»¥ä½¿ç”¨ç›¸åŒçš„è¡¨å
2. **æƒé™ç®¡ç†**ï¼šå¯ä»¥ä¸ºä¸åŒSchemaè®¾ç½®ä¸åŒçš„è®¿é—®æƒé™
3. **é€»è¾‘åˆ†ç»„**ï¼šå°†ç›¸å…³çš„æ•°æ®åº“å¯¹è±¡ç»„ç»‡åœ¨ä¸€èµ·ï¼Œæé«˜å¯ç»´æŠ¤æ€§
4. **æ¨¡å—åŒ–å¼€å‘**ï¼šä¸åŒå›¢é˜Ÿå¯ä»¥ç‹¬ç«‹å¼€å‘ä¸åŒSchemaï¼Œå‡å°‘å†²çª

**Schemaç»„ç»‡çš„è®¾è®¡åŸåˆ™**ï¼š

| åŸåˆ™ | è¯´æ˜ | ä¼˜åŠ¿ |
|-----|------|------|
| **åŠŸèƒ½æ¨¡å—åŒ–** | æŒ‰ä¸šåŠ¡åŠŸèƒ½åˆ’åˆ†Schema | æ¸…æ™°çš„ä¸šåŠ¡è¾¹ç•Œï¼Œæ˜“äºç†è§£ |
| **æ•°æ®ç‰¹æ€§åŒ–** | æŒ‰æ•°æ®ç‰¹æ€§åˆ’åˆ†Schema | ä¾¿äºæ•°æ®ç®¡ç†å’Œå½’æ¡£ |
| **å›¢é˜Ÿéš”ç¦»** | æŒ‰å›¢é˜Ÿåˆ’åˆ†Schema | å‡å°‘å¼€å‘å†²çª |
| **ç‰ˆæœ¬ç®¡ç†** | æŒ‰ç‰ˆæœ¬åˆ’åˆ†Schema | æ”¯æŒå¹³æ»‘å‡çº§ |

#### 3.1.2 æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡

**è®¾è®¡åŸç†**ï¼š

æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡æ˜¯æœ€å¸¸ç”¨çš„Schemaç»„ç»‡æ–¹å¼ï¼Œå®ƒå°†ç›¸å…³çš„è¡¨ã€å‡½æ•°ã€è§†å›¾ç­‰å¯¹è±¡ç»„ç»‡åœ¨åŒä¸€ä¸ªSchemaä¸­ï¼Œå½¢æˆé€»è¾‘ä¸Šçš„ä¸šåŠ¡æ¨¡å—ã€‚

**å®é™…åº”ç”¨ç¤ºä¾‹**ï¼š

```sql
-- åœºæ™¯ï¼šç”µå•†ç³»ç»ŸSchemaç»„ç»‡
-- è®¾è®¡æ€è·¯ï¼šæŒ‰ä¸šåŠ¡åŠŸèƒ½åˆ’åˆ†ï¼Œæ¯ä¸ªåŠŸèƒ½æ¨¡å—ä¸€ä¸ªSchema

-- 1. ç”¨æˆ·ç®¡ç†æ¨¡å—
CREATE SCHEMA IF NOT EXISTS user_management;
COMMENT ON SCHEMA user_management IS 'ç”¨æˆ·ç®¡ç†æ¨¡å—ï¼šç”¨æˆ·ä¿¡æ¯ã€è®¤è¯ã€æƒé™';

-- åœ¨ç”¨æˆ·ç®¡ç†Schemaä¸­åˆ›å»ºç›¸å…³å¯¹è±¡
CREATE TABLE user_management.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_management.user_profiles (
    user_id INTEGER PRIMARY KEY REFERENCES user_management.users(id),
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    phone VARCHAR(20),
    avatar_url VARCHAR(255)
);

-- 2. è®¢å•ç®¡ç†æ¨¡å—
CREATE SCHEMA IF NOT EXISTS order_management;
COMMENT ON SCHEMA order_management IS 'è®¢å•ç®¡ç†æ¨¡å—ï¼šè®¢å•ã€è®¢å•é¡¹ã€è®¢å•çŠ¶æ€';

CREATE TABLE order_management.orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES user_management.users(id),
    total_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_management.order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES order_management.orders(id),
    product_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    subtotal DECIMAL(10,2) NOT NULL
);

-- 3. æ”¯ä»˜å¤„ç†æ¨¡å—
CREATE SCHEMA IF NOT EXISTS payment_processing;
COMMENT ON SCHEMA payment_processing IS 'æ”¯ä»˜å¤„ç†æ¨¡å—ï¼šæ”¯ä»˜è®°å½•ã€æ”¯ä»˜æ–¹å¼ã€é€€æ¬¾';

CREATE TABLE payment_processing.payments (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES order_management.orders(id),
    amount DECIMAL(10,2) NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL,
    transaction_id VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 4. æŠ¥è¡¨åˆ†ææ¨¡å—
CREATE SCHEMA IF NOT EXISTS reporting;
COMMENT ON SCHEMA reporting IS 'æŠ¥è¡¨åˆ†ææ¨¡å—ï¼šæŠ¥è¡¨ã€ç»Ÿè®¡ã€åˆ†æè§†å›¾';

-- åˆ›å»ºæŠ¥è¡¨è§†å›¾
CREATE VIEW reporting.daily_sales AS
SELECT
    DATE(created_at) as sale_date,
    COUNT(*) as order_count,
    SUM(total_amount) as total_sales
FROM order_management.orders
WHERE status = 'completed'
GROUP BY DATE(created_at);
```

**Schemaç»„ç»‡çš„ä¼˜åŠ¿åˆ†æ**ï¼š

| ä¼˜åŠ¿ | è¯´æ˜ | å®é™…ä»·å€¼ |
|-----|------|---------|
| **æ¸…æ™°çš„ä¸šåŠ¡è¾¹ç•Œ** | æ¯ä¸ªSchemaä»£è¡¨ä¸€ä¸ªä¸šåŠ¡æ¨¡å— | æ–°æˆå‘˜å¿«é€Ÿç†è§£ç³»ç»Ÿç»“æ„ |
| **ç‹¬ç«‹çš„æƒé™ç®¡ç†** | å¯ä»¥ä¸ºæ¯ä¸ªSchemaè®¾ç½®ä¸åŒæƒé™ | æé«˜å®‰å…¨æ€§ï¼Œæ”¯æŒå¤šç§Ÿæˆ· |
| **å‡å°‘å‘½åå†²çª** | ä¸åŒSchemaå¯ä»¥ä½¿ç”¨ç›¸åŒè¡¨å | æ”¯æŒæ¨¡å—åŒ–å¼€å‘ |
| **ä¾¿äºç»´æŠ¤** | ç›¸å…³å¯¹è±¡é›†ä¸­ç®¡ç† | é™ä½ç»´æŠ¤æˆæœ¬ |

**è·¨Schemaè®¿é—®**ï¼š

```sql
-- åœºæ™¯ï¼šè®¢å•æ¨¡å—éœ€è¦è®¿é—®ç”¨æˆ·ä¿¡æ¯
-- æ–¹æ³•1ï¼šä½¿ç”¨å®Œæ•´Schemaè·¯å¾„ï¼ˆæ¨èï¼Œæ˜ç¡®ï¼‰
SELECT
    o.id as order_id,
    o.total_amount,
    u.username,
    u.email
FROM order_management.orders o
JOIN user_management.users u ON o.user_id = u.id
WHERE o.id = 12345;

-- æ–¹æ³•2ï¼šè®¾ç½®search_pathï¼ˆç®€åŒ–ï¼Œä½†éœ€è°¨æ…ï¼‰
SET search_path = order_management, user_management, public;
SELECT
    o.id as order_id,
    o.total_amount,
    u.username
FROM orders o
JOIN users u ON o.user_id = u.id;

-- æœ€ä½³å®è·µï¼š
-- 1. ç”Ÿäº§ç¯å¢ƒä½¿ç”¨å®Œæ•´Schemaè·¯å¾„ï¼Œé¿å…search_pathé—®é¢˜
-- 2. å¼€å‘ç¯å¢ƒå¯ä»¥ä½¿ç”¨search_pathç®€åŒ–
-- 3. å‡½æ•°ä¸­æ˜ç¡®æŒ‡å®šSchemaï¼Œé¿å…ä¾èµ–search_path
```

#### 3.1.3 æŒ‰æ•°æ®ç‰¹æ€§ç»„ç»‡

**è®¾è®¡åŸç†**ï¼š

æŒ‰æ•°æ®ç‰¹æ€§ç»„ç»‡é€‚ç”¨äºéœ€è¦åŒºåˆ†æ•°æ®ç”Ÿå‘½å‘¨æœŸã€è®¿é—®æ¨¡å¼æˆ–å­˜å‚¨ç‰¹æ€§çš„åœºæ™¯ã€‚è¿™ç§ç»„ç»‡æ–¹å¼ä¾¿äºæ•°æ®ç®¡ç†ã€å½’æ¡£å’Œæ€§èƒ½ä¼˜åŒ–ã€‚

**å®é™…åº”ç”¨ç¤ºä¾‹**ï¼š

```sql
-- åœºæ™¯ï¼šæŒ‰æ•°æ®ç‰¹æ€§ç»„ç»‡ï¼ŒåŒºåˆ†æ ¸å¿ƒæ•°æ®ã€å†å²æ•°æ®ã€åˆ†ææ•°æ®

-- 1. æ ¸å¿ƒä¸šåŠ¡æ•°æ®Schema
CREATE SCHEMA core;
COMMENT ON SCHEMA core IS 'æ ¸å¿ƒä¸šåŠ¡æ•°æ®ï¼šå½“å‰æ´»è·ƒæ•°æ®ï¼Œé«˜é¢‘è®¿é—®';

CREATE TABLE core.orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL
) PARTITION BY RANGE (created_at);

-- åªä¿ç•™æœ€è¿‘3ä¸ªæœˆçš„æ•°æ®åœ¨core schema
CREATE TABLE core.orders_2024_01 PARTITION OF core.orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
CREATE TABLE core.orders_2024_02 PARTITION OF core.orders
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
CREATE TABLE core.orders_2024_03 PARTITION OF core.orders
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');

-- 2. å†å²æ•°æ®Schema
CREATE SCHEMA archive;
COMMENT ON SCHEMA archive IS 'å†å²æ•°æ®ï¼šå½’æ¡£æ•°æ®ï¼Œä½é¢‘è®¿é—®ï¼Œå¯å‹ç¼©å­˜å‚¨';

-- å†å²è®¢å•æ•°æ®ï¼ˆ3ä¸ªæœˆä»¥å‰ï¼‰
CREATE TABLE archive.orders (
    LIKE core.orders INCLUDING ALL
);

-- æ•°æ®å½’æ¡£ç­–ç•¥ï¼š
-- 1. å®šæœŸå°†core.ordersä¸­3ä¸ªæœˆå‰çš„æ•°æ®è¿ç§»åˆ°archive.orders
-- 2. å¯¹archive.ordersè¿›è¡Œå‹ç¼©å­˜å‚¨
-- 3. å¯ä»¥ç§»åŠ¨åˆ°å†·å­˜å‚¨ï¼ˆå¦‚å¯¹è±¡å­˜å‚¨ï¼‰

-- 3. åˆ†ææ•°æ®Schema
CREATE SCHEMA analytics;
COMMENT ON SCHEMA analytics IS 'åˆ†ææ•°æ®ï¼šèšåˆæ•°æ®ã€ç»Ÿè®¡ç»“æœã€ç‰©åŒ–è§†å›¾';

-- åˆ›å»ºåˆ†æè¡¨ï¼ˆç‰©åŒ–è§†å›¾ï¼‰
CREATE MATERIALIZED VIEW analytics.daily_sales_summary AS
SELECT
    DATE(created_at) as sale_date,
    COUNT(*) as order_count,
    SUM(total_amount) as total_sales,
    AVG(total_amount) as avg_order_value,
    COUNT(DISTINCT user_id) as unique_customers
FROM core.orders
WHERE created_at >= CURRENT_DATE - INTERVAL '90 days'
GROUP BY DATE(created_at);

-- åˆ›å»ºç´¢å¼•æå‡æŸ¥è¯¢æ€§èƒ½
CREATE INDEX idx_analytics_daily_sales_date
ON analytics.daily_sales_summary(sale_date);

-- 4. ä¸´æ—¶æ•°æ®Schema
CREATE SCHEMA temp;
COMMENT ON SCHEMA temp IS 'ä¸´æ—¶æ•°æ®ï¼šä¸´æ—¶è¡¨ã€æµ‹è¯•æ•°æ®ã€ETLä¸­é—´ç»“æœ';

-- ä¸´æ—¶è¡¨ç”¨äºETLå¤„ç†
CREATE TABLE temp.etl_staging (
    id SERIAL PRIMARY KEY,
    raw_data JSONB,
    processed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ä¸´æ—¶æ•°æ®æ¸…ç†ç­–ç•¥ï¼š
-- 1. å®šæœŸæ¸…ç†temp schemaä¸­çš„æ—§æ•°æ®
-- 2. ä½¿ç”¨TTLï¼ˆTime To Liveï¼‰è‡ªåŠ¨æ¸…ç†
-- 3. åœ¨ETLå®Œæˆåç«‹å³æ¸…ç†
```

**æ•°æ®ç‰¹æ€§ç»„ç»‡çš„ä¼˜åŠ¿**ï¼š

| ä¼˜åŠ¿ | è¯´æ˜ | å®é™…ä»·å€¼ |
|-----|------|---------|
| **æ€§èƒ½ä¼˜åŒ–** | æ ¸å¿ƒæ•°æ®å•ç‹¬ä¼˜åŒ–ï¼Œå†å²æ•°æ®å‹ç¼©å­˜å‚¨ | æå‡æŸ¥è¯¢æ€§èƒ½ï¼Œé™ä½å­˜å‚¨æˆæœ¬ |
| **ç”Ÿå‘½å‘¨æœŸç®¡ç†** | ä¸åŒSchemaä½¿ç”¨ä¸åŒçš„å¤‡ä»½å’Œå½’æ¡£ç­–ç•¥ | é™ä½è¿ç»´æˆæœ¬ |
| **è®¿é—®æ§åˆ¶** | åˆ†ææ•°æ®å¯ä»¥åªè¯»è®¿é—®ï¼Œä¸´æ—¶æ•°æ®å¯ä»¥é¢‘ç¹æ¸…ç† | æé«˜å®‰å…¨æ€§ |
| **æ‰©å±•æ€§** | å¯ä»¥è½»æ¾æ·»åŠ æ–°çš„æ•°æ®ç‰¹æ€§Schema | æ”¯æŒæœªæ¥æ‰©å±• |

**æ•°æ®è¿ç§»ç­–ç•¥**ï¼š

```sql
-- åœºæ™¯ï¼šå°†æ ¸å¿ƒæ•°æ®è¿ç§»åˆ°å†å²æ•°æ®Schema
-- éœ€æ±‚ï¼šå°†3ä¸ªæœˆå‰çš„è®¢å•æ•°æ®ä»coreè¿ç§»åˆ°archive

-- è¿ç§»å‡½æ•°
CREATE OR REPLACE FUNCTION migrate_old_orders()
RETURNS INTEGER AS $$
DECLARE
    migrated_count INTEGER;
    cutoff_date DATE;
BEGIN
    -- è®¡ç®—æˆªæ­¢æ—¥æœŸï¼ˆ3ä¸ªæœˆå‰ï¼‰
    cutoff_date := CURRENT_DATE - INTERVAL '3 months';

    -- è¿ç§»æ•°æ®
    INSERT INTO archive.orders
    SELECT * FROM core.orders
    WHERE created_at < cutoff_date;

    GET DIAGNOSTICS migrated_count = ROW_COUNT;

    -- åˆ é™¤å·²è¿ç§»çš„æ•°æ®ï¼ˆå¦‚æœä½¿ç”¨åˆ†åŒºï¼Œç›´æ¥DROPåˆ†åŒºæ›´é«˜æ•ˆï¼‰
    -- DELETE FROM core.orders WHERE created_at < cutoff_date;

    RETURN migrated_count;
END;
$$ LANGUAGE plpgsql;

-- å®šæœŸæ‰§è¡Œè¿ç§»ï¼ˆä½¿ç”¨pg_cronæ‰©å±•ï¼‰
-- SELECT cron.schedule('migrate-old-orders', '0 2 * * *', 'SELECT migrate_old_orders();');
```

### 3.2 å‘½åè§„èŒƒ

#### 3.2.1 å‘½åè§„èŒƒçš„é‡è¦æ€§

**ä¸ºä»€ä¹ˆéœ€è¦å‘½åè§„èŒƒ**ï¼š

ç»Ÿä¸€çš„å‘½åè§„èŒƒæ˜¯ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§çš„åŸºç¡€ï¼š

1. **å¯è¯»æ€§**ï¼šæ¸…æ™°çš„å‘½åè®©ä»£ç è‡ªè§£é‡Šï¼Œå‡å°‘æ³¨é‡Šéœ€æ±‚
2. **ä¸€è‡´æ€§**ï¼šç»Ÿä¸€çš„å‘½åé£æ ¼è®©å›¢é˜Ÿåä½œæ›´é¡ºç•…
3. **å¯ç»´æŠ¤æ€§**ï¼šè§„èŒƒçš„å‘½åä¾¿äºä»£ç é‡æ„å’Œç»´æŠ¤
4. **å¯æœç´¢æ€§**ï¼šè§„èŒƒçš„å‘½åä¾¿äºä»£ç æœç´¢å’Œå®šä½

**å‘½åè§„èŒƒçš„è®¾è®¡åŸåˆ™**ï¼š

| åŸåˆ™ | è¯´æ˜ | ç¤ºä¾‹ |
|-----|------|------|
| **æ¸…æ™°æ€§** | åç§°åº”è¯¥æ¸…æ™°è¡¨è¾¾å¯¹è±¡ç”¨é€” | `users` è€Œä¸æ˜¯ `t1` |
| **ä¸€è‡´æ€§** | ç›¸åŒç±»å‹çš„å¯¹è±¡ä½¿ç”¨ç›¸åŒçš„å‘½åé£æ ¼ | æ‰€æœ‰è¡¨ä½¿ç”¨å¤æ•°å½¢å¼ |
| **ç®€æ´æ€§** | åç§°åº”è¯¥ç®€æ´ä½†ä¸å¤±æ¸…æ™° | `order_items` è€Œä¸æ˜¯ `order_items_table` |
| **å¯æœç´¢æ€§** | ä½¿ç”¨å¸¸è§è¯æ±‡ï¼Œä¾¿äºæœç´¢ | `created_at` è€Œä¸æ˜¯ `crt_dt` |

#### 3.2.2 è¡¨å‘½åè§„èŒƒ

**å‘½åè§„åˆ™è¯¦è§£**ï¼š

```sql
-- è§„åˆ™1ï¼šä½¿ç”¨å¤æ•°å½¢å¼ï¼ˆæ¨èï¼‰
-- åŸå› ï¼šè¡¨å­˜å‚¨å¤šæ¡è®°å½•ï¼Œå¤æ•°å½¢å¼æ›´ç¬¦åˆè¯­ä¹‰
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL
);

-- è§„åˆ™2ï¼šä½¿ç”¨å°å†™å­—æ¯å’Œä¸‹åˆ’çº¿åˆ†éš”
-- åŸå› ï¼šPostgreSQLé»˜è®¤å°†æ ‡è¯†ç¬¦è½¬æ¢ä¸ºå°å†™ï¼Œä½¿ç”¨ä¸‹åˆ’çº¿é¿å…å¤§å°å†™é—®é¢˜
CREATE TABLE user_profiles (...);  -- âœ… æ­£ç¡®
CREATE TABLE UserProfiles (...);   -- âŒ ä¸æ¨èï¼Œä¼šè¢«è½¬æ¢ä¸ºuserprofiles
CREATE TABLE user-profiles (...);  -- âŒ é”™è¯¯ï¼Œè¿å­—ç¬¦éœ€è¦å¼•å·

-- è§„åˆ™3ï¼šå…³è”è¡¨ä½¿ç”¨ä¸¤ä¸ªè¡¨åç»„åˆ
-- åŸå› ï¼šæ¸…æ™°è¡¨è¾¾è¡¨ä¹‹é—´çš„å…³ç³»
CREATE TABLE user_roles (
    user_id INTEGER NOT NULL,
    role_id INTEGER NOT NULL,
    PRIMARY KEY (user_id, role_id)
);

CREATE TABLE order_payments (
    order_id INTEGER NOT NULL,
    payment_id INTEGER NOT NULL,
    PRIMARY KEY (order_id, payment_id)
);

-- è§„åˆ™4ï¼šä½¿ç”¨æœ‰æ„ä¹‰çš„åç§°ï¼Œé¿å…ç¼©å†™
-- åŸå› ï¼šæé«˜å¯è¯»æ€§ï¼Œå‡å°‘ç†è§£æˆæœ¬
CREATE TABLE user_profiles (...);  -- âœ… æ­£ç¡®
CREATE TABLE usr_prf (...);        -- âŒ ä¸æ¨èï¼Œç¼©å†™é™ä½å¯è¯»æ€§

-- è§„åˆ™5ï¼šå¤šå¯¹å¤šå…³ç³»è¡¨ä½¿ç”¨ä¸¤ä¸ªè¡¨å
-- åŸå› ï¼šæ¸…æ™°è¡¨è¾¾å…³ç³»è¡¨çš„ç”¨é€”
CREATE TABLE user_permissions (
    user_id INTEGER NOT NULL,
    permission_id INTEGER NOT NULL,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, permission_id)
);
```

**å‘½åè§„èŒƒå¯¹æ¯”**ï¼š

| å‘½åé£æ ¼ | ç¤ºä¾‹ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåº¦ |
|---------|------|------|------|--------|
| **å¤æ•°+ä¸‹åˆ’çº¿** | `order_items` | æ¸…æ™°ã€ä¸€è‡´ | - | â­â­â­â­â­ |
| **å•æ•°+ä¸‹åˆ’çº¿** | `order_item` | ç®€æ´ | è¯­ä¹‰ä¸å‡†ç¡® | â­â­â­ |
| **é©¼å³°å‘½å** | `OrderItems` | ç¬¦åˆæŸäº›è¯­è¨€ä¹ æƒ¯ | PostgreSQLéœ€è¦å¼•å· | â­â­ |
| **å‰ç¼€å‘½å** | `tbl_order_items` | ç±»å‹æ˜ç¡® | å†—ä½™ | â­â­ |

#### 3.2.3 å‡½æ•°å‘½åè§„èŒƒ

**å‘½åè§„åˆ™è¯¦è§£**ï¼š

```sql
-- è§„åˆ™1ï¼šä½¿ç”¨åŠ¨è¯å¼€å¤´ï¼Œæè¿°åŠŸèƒ½
-- åŸå› ï¼šå‡½æ•°æ˜¯åŠ¨ä½œï¼ŒåŠ¨è¯å¼€å¤´æ›´ç¬¦åˆè¯­ä¹‰
CREATE FUNCTION get_user_by_id(user_id INTEGER)
RETURNS TABLE(id INTEGER, username VARCHAR, email VARCHAR) AS $$
    SELECT id, username, email FROM users WHERE id = user_id;
$$ LANGUAGE SQL;

CREATE FUNCTION calculate_order_total(order_id INTEGER)
RETURNS DECIMAL AS $$
    SELECT SUM(quantity * price) FROM order_items WHERE order_id = $1;
$$ LANGUAGE SQL;

CREATE FUNCTION validate_email(email TEXT)
RETURNS BOOLEAN AS $$
    SELECT email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$';
$$ LANGUAGE SQL;

-- è§„åˆ™2ï¼šä½¿ç”¨Schemaå‰ç¼€é¿å…å†²çª
-- åŸå› ï¼šä¸åŒSchemaå¯èƒ½æœ‰ç›¸åŒåç§°çš„å‡½æ•°ï¼Œæ˜ç¡®Schemaé¿å…æ­§ä¹‰
CREATE FUNCTION user_management.get_user_by_id(user_id INTEGER) ...
CREATE FUNCTION order_management.get_order_by_id(order_id INTEGER) ...

-- è§„åˆ™3ï¼šä½¿ç”¨æè¿°æ€§çš„åç§°ï¼Œé¿å…ç¼©å†™
-- åŸå› ï¼šæé«˜å¯è¯»æ€§
CREATE FUNCTION get_user_profile_by_user_id(user_id INTEGER) ...  -- âœ… æ¸…æ™°
CREATE FUNCTION get_usr_prf_by_uid(uid INTEGER) ...              -- âŒ ä¸æ¨è

-- è§„åˆ™4ï¼šå¸ƒå°”å‡½æ•°ä½¿ç”¨is_ã€has_ã€can_ç­‰å‰ç¼€
-- åŸå› ï¼šæ˜ç¡®è¿”å›å¸ƒå°”å€¼
CREATE FUNCTION is_user_active(user_id INTEGER)
RETURNS BOOLEAN AS $$
    SELECT status = 'active' FROM users WHERE id = user_id;
$$ LANGUAGE SQL;

CREATE FUNCTION has_permission(user_id INTEGER, permission_name TEXT)
RETURNS BOOLEAN AS $$
    SELECT EXISTS(
        SELECT 1 FROM user_permissions up
        JOIN permissions p ON up.permission_id = p.id
        WHERE up.user_id = $1 AND p.name = $2
    );
$$ LANGUAGE SQL;

-- è§„åˆ™5ï¼šæ‰¹é‡æ“ä½œå‡½æ•°ä½¿ç”¨batch_æˆ–bulk_å‰ç¼€
-- åŸå› ï¼šæ˜ç¡®æ˜¯æ‰¹é‡æ“ä½œ
CREATE FUNCTION batch_insert_users(user_data JSONB[])
RETURNS TABLE(inserted_id INTEGER) AS $$
    INSERT INTO users (username, email)
    SELECT (u->>'username')::VARCHAR, (u->>'email')::VARCHAR
    FROM UNNEST(user_data) AS u
    RETURNING id;
$$ LANGUAGE SQL;
```

**å‡½æ•°å‘½åæ¨¡å¼**ï¼š

| æ¨¡å¼ | å‰ç¼€ | ç¤ºä¾‹ | ç”¨é€” |
|-----|------|------|------|
| **æŸ¥è¯¢å‡½æ•°** | `get_`, `find_`, `fetch_` | `get_user_by_id` | æŸ¥è¯¢æ•°æ® |
| **åˆ›å»ºå‡½æ•°** | `create_`, `add_`, `insert_` | `create_user` | åˆ›å»ºæ•°æ® |
| **æ›´æ–°å‡½æ•°** | `update_`, `modify_`, `change_` | `update_user_profile` | æ›´æ–°æ•°æ® |
| **åˆ é™¤å‡½æ•°** | `delete_`, `remove_`, `drop_` | `delete_user` | åˆ é™¤æ•°æ® |
| **éªŒè¯å‡½æ•°** | `validate_`, `check_`, `verify_` | `validate_email` | éªŒè¯æ•°æ® |
| **è®¡ç®—å‡½æ•°** | `calculate_`, `compute_`, `sum_` | `calculate_total` | è®¡ç®—å€¼ |
| **è½¬æ¢å‡½æ•°** | `convert_`, `transform_`, `format_` | `format_date` | è½¬æ¢æ•°æ® |

#### 3.2.4 ç´¢å¼•å‘½åè§„èŒƒ

**å‘½åè§„åˆ™è¯¦è§£**ï¼š

```sql
-- è§„åˆ™1ï¼šä½¿ç”¨idx_å‰ç¼€ï¼Œåè·Ÿè¡¨åå’Œåˆ—å
-- åŸå› ï¼šç»Ÿä¸€å‰ç¼€ä¾¿äºè¯†åˆ«å’Œç®¡ç†ç´¢å¼•
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);

-- è§„åˆ™2ï¼šå”¯ä¸€ç´¢å¼•ä½¿ç”¨uniqueåç¼€
-- åŸå› ï¼šæ˜ç¡®æ ‡è¯†å”¯ä¸€ç´¢å¼•
CREATE UNIQUE INDEX idx_users_username_unique ON users(username);
CREATE UNIQUE INDEX idx_users_email_unique ON users(email);

-- è§„åˆ™3ï¼šå¤åˆç´¢å¼•åˆ—å‡ºæ‰€æœ‰åˆ—å
-- åŸå› ï¼šæ¸…æ™°è¡¨è¾¾ç´¢å¼•åŒ…å«çš„åˆ—
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);
CREATE INDEX idx_order_items_order_product ON order_items(order_id, product_id);

-- è§„åˆ™4ï¼šéƒ¨åˆ†ç´¢å¼•ä½¿ç”¨whereåç¼€
-- åŸå› ï¼šæ˜ç¡®ç´¢å¼•çš„è¿‡æ»¤æ¡ä»¶
CREATE INDEX idx_orders_active_user
ON orders(user_id)
WHERE status = 'active';

CREATE INDEX idx_users_active_email
ON users(email)
WHERE status = 'active';

-- è§„åˆ™5ï¼šè¡¨è¾¾å¼ç´¢å¼•ä½¿ç”¨expråç¼€
-- åŸå› ï¼šæ˜ç¡®æ˜¯è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_users_email_lower_expr
ON users(LOWER(email));

CREATE INDEX idx_orders_date_trunc_expr
ON orders(DATE_TRUNC('month', created_at));

-- è§„åˆ™6ï¼šGIN/GiSTç­‰ç‰¹æ®Šç´¢å¼•ä½¿ç”¨ç±»å‹åç¼€
-- åŸå› ï¼šæ˜ç¡®ç´¢å¼•ç±»å‹
CREATE INDEX idx_products_tags_gin
ON products USING GIN(tags);

CREATE INDEX idx_products_location_gist
ON products USING GiST(location);
```

**ç´¢å¼•å‘½åè§„èŒƒå¯¹æ¯”**ï¼š

| å‘½åé£æ ¼ | ç¤ºä¾‹ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåº¦ |
|---------|------|------|------|--------|
| **idx_è¡¨å_åˆ—å** | `idx_users_email` | æ¸…æ™°ã€ä¸€è‡´ | - | â­â­â­â­â­ |
| **è¡¨å_åˆ—å_idx** | `users_email_idx` | æŒ‰è¡¨ååˆ†ç»„ | ä¸å¤Ÿç»Ÿä¸€ | â­â­â­ |
| **IX_è¡¨å_åˆ—å** | `IX_Users_Email` | å¤§å†™åŒºåˆ† | éœ€è¦å¼•å· | â­â­ |
| **æ— å‰ç¼€** | `users_email` | ç®€æ´ | å¯èƒ½ä¸è¡¨åå†²çª | â­ |

### 3.3 æ¨¡å—åŒ–è®¾è®¡

**å‡½æ•°æ¨¡å—åŒ–**ï¼š

```sql
-- åŸºç¡€å‡½æ•°æ¨¡å—
CREATE SCHEMA base_functions;

-- ç”¨æˆ·ç›¸å…³å‡½æ•°
CREATE SCHEMA user_functions;

-- è®¢å•ç›¸å…³å‡½æ•°
CREATE SCHEMA order_functions;

-- åœ¨å¯¹åº”æ¨¡å—ä¸­å®šä¹‰å‡½æ•°
CREATE FUNCTION user_functions.get_user(...) ...
CREATE FUNCTION order_functions.calculate_total(...) ...
```

---

## å››ã€æ•°æ®è®¿é—®æ¨¡å¼

### 4.1 Repositoryæ¨¡å¼

#### 4.1.1 Repositoryæ¨¡å¼çš„è®¾è®¡åŸç†

**ä¸ºä»€ä¹ˆéœ€è¦Repositoryæ¨¡å¼**ï¼š

Repositoryæ¨¡å¼æ˜¯æ•°æ®è®¿é—®å±‚çš„æŠ½è±¡ï¼Œå®ƒæä¾›äº†ä»¥ä¸‹ä¼˜åŠ¿ï¼š

1. **æ•°æ®è®¿é—®æŠ½è±¡**ï¼šå°†æ•°æ®è®¿é—®é€»è¾‘ä¸ä¸šåŠ¡é€»è¾‘åˆ†ç¦»
2. **å¯æµ‹è¯•æ€§**ï¼šå¯ä»¥è½»æ¾æ¨¡æ‹ŸRepositoryè¿›è¡Œå•å…ƒæµ‹è¯•
3. **å¯ç»´æŠ¤æ€§**ï¼šæ•°æ®è®¿é—®é€»è¾‘é›†ä¸­ç®¡ç†ï¼Œä¾¿äºç»´æŠ¤
4. **çµæ´»æ€§**ï¼šå¯ä»¥è½»æ¾åˆ‡æ¢æ•°æ®æºï¼ˆå¦‚ä»æ•°æ®åº“åˆ‡æ¢åˆ°ç¼“å­˜ï¼‰

**Repositoryæ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³**ï¼š

Repositoryæ¨¡å¼å°†æ•°æ®è®¿é—®é€»è¾‘å°è£…åœ¨Repositoryå¯¹è±¡ä¸­ï¼Œä¸šåŠ¡é€»è¾‘é€šè¿‡Repositoryæ¥å£è®¿é—®æ•°æ®ï¼Œè€Œä¸ç›´æ¥è®¿é—®æ•°æ®åº“ã€‚è¿™æ ·å®ç°äº†ï¼š

- **ä¸šåŠ¡é€»è¾‘ä¸æ•°æ®è®¿é—®è§£è€¦**ï¼šä¸šåŠ¡é€»è¾‘ä¸ä¾èµ–å…·ä½“çš„æ•°æ®è®¿é—®å®ç°
- **ç»Ÿä¸€çš„æ•°æ®è®¿é—®æ¥å£**ï¼šæ‰€æœ‰æ•°æ®è®¿é—®éƒ½é€šè¿‡Repositoryæ¥å£
- **æ˜“äºæµ‹è¯•å’Œæ›¿æ¢**ï¼šå¯ä»¥è½»æ¾æ›¿æ¢Repositoryå®ç°

**Repositoryæ¨¡å¼åœ¨PostgreSQLä¸­çš„å®ç°**ï¼š

åœ¨PostgreSQLä¸­ï¼ŒRepositoryæ¨¡å¼å¯ä»¥é€šè¿‡å‡½æ•°å’ŒSchemaæ¥å®ç°ï¼š

- **å‡½æ•°ä½œä¸ºRepositoryæ–¹æ³•**ï¼šæ¯ä¸ªRepositoryæ–¹æ³•å¯¹åº”ä¸€ä¸ªå‡½æ•°
- **Schemaä½œä¸ºRepositoryå‘½åç©ºé—´**ï¼šä½¿ç”¨Schemaç»„ç»‡Repositoryå‡½æ•°
- **ç±»å‹ä½œä¸ºRepositoryæ¥å£**ï¼šä½¿ç”¨è‡ªå®šä¹‰ç±»å‹å®šä¹‰Repositoryæ¥å£

#### 4.1.2 Repositoryæ¨¡å¼å®ç°

**åŸºç¡€Repositoryå®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šç”¨æˆ·ç®¡ç†Repositoryå®ç°
-- è®¾è®¡æ€è·¯ï¼šå°†ç”¨æˆ·æ•°æ®è®¿é—®é€»è¾‘å°è£…åœ¨Repositoryå‡½æ•°ä¸­

-- 1. åˆ›å»ºRepository Schema
CREATE SCHEMA repositories;
COMMENT ON SCHEMA repositories IS 'æ•°æ®è®¿é—®å±‚ï¼šRepositoryæ¨¡å¼å®ç°';

-- 2. å®šä¹‰ç”¨æˆ·Repositoryæ¥å£ï¼ˆé€šè¿‡å‡½æ•°å®ç°ï¼‰

-- æŸ¥æ‰¾ç”¨æˆ·ï¼ˆæŒ‰IDï¼‰
CREATE OR REPLACE FUNCTION repositories.find_user_by_id(
    p_user_id INTEGER
) RETURNS TABLE (
    id INTEGER,
    username VARCHAR,
    email VARCHAR,
    status VARCHAR,
    created_at TIMESTAMP
) AS $$
BEGIN
    -- å®ç°ï¼šä»ç”¨æˆ·è¡¨æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
    -- ä¼˜åŠ¿ï¼šå°è£…äº†æŸ¥è¯¢é€»è¾‘ï¼Œä¸šåŠ¡å±‚ä¸éœ€è¦çŸ¥é“è¡¨ç»“æ„
    RETURN QUERY
    SELECT
        u.id,
        u.username,
        u.email,
        u.status,
        u.created_at
    FROM user_management.users u
    WHERE u.id = p_user_id;
END;
$$ LANGUAGE plpgsql STABLE;

-- æŸ¥æ‰¾ç”¨æˆ·ï¼ˆæŒ‰é‚®ç®±ï¼‰
CREATE OR REPLACE FUNCTION repositories.find_user_by_email(
    p_email VARCHAR
) RETURNS TABLE (
    id INTEGER,
    username VARCHAR,
    email VARCHAR,
    status VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        u.id,
        u.username,
        u.email,
        u.status
    FROM user_management.users u
    WHERE u.email = p_email;
END;
$$ LANGUAGE plpgsql STABLE;

-- ä¿å­˜ç”¨æˆ·ï¼ˆåˆ›å»ºæ–°ç”¨æˆ·ï¼‰
CREATE OR REPLACE FUNCTION repositories.save_user(
    p_username VARCHAR,
    p_email VARCHAR,
    p_password_hash VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_user_id INTEGER;
BEGIN
    -- å®ç°ï¼šæ’å…¥æ–°ç”¨æˆ·
    -- ä¼˜åŠ¿ï¼šå°è£…äº†æ’å…¥é€»è¾‘ï¼ŒåŒ…æ‹¬éªŒè¯å’Œé”™è¯¯å¤„ç†
    INSERT INTO user_management.users (username, email, password_hash)
    VALUES (p_username, p_email, p_password_hash)
    RETURNING id INTO v_user_id;

    RETURN v_user_id;
EXCEPTION
    WHEN unique_violation THEN
        RAISE EXCEPTION 'User with username % or email % already exists', p_username, p_email;
END;
$$ LANGUAGE plpgsql;

-- æ›´æ–°ç”¨æˆ·
CREATE OR REPLACE FUNCTION repositories.update_user(
    p_user_id INTEGER,
    p_username VARCHAR DEFAULT NULL,
    p_email VARCHAR DEFAULT NULL,
    p_status VARCHAR DEFAULT NULL
) RETURNS BOOLEAN AS $$
BEGIN
    -- å®ç°ï¼šæ›´æ–°ç”¨æˆ·ä¿¡æ¯
    -- ä¼˜åŠ¿ï¼šåªæ›´æ–°æä¾›çš„å­—æ®µï¼ŒNULLå€¼ä¸æ›´æ–°
    UPDATE user_management.users
    SET
        username = COALESCE(p_username, username),
        email = COALESCE(p_email, email),
        status = COALESCE(p_status, status),
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_user_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- åˆ é™¤ç”¨æˆ·
CREATE OR REPLACE FUNCTION repositories.delete_user(
    p_user_id INTEGER
) RETURNS BOOLEAN AS $$
BEGIN
    -- å®ç°ï¼šåˆ é™¤ç”¨æˆ·ï¼ˆè½¯åˆ é™¤æˆ–ç¡¬åˆ é™¤ï¼‰
    -- ä¼˜åŠ¿ï¼šå¯ä»¥åœ¨è¿™é‡Œå®ç°è½¯åˆ é™¤é€»è¾‘
    DELETE FROM user_management.users
    WHERE id = p_user_id;

    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- æŸ¥è¯¢ç”¨æˆ·åˆ—è¡¨ï¼ˆå¸¦åˆ†é¡µï¼‰
CREATE OR REPLACE FUNCTION repositories.find_users(
    p_limit INTEGER DEFAULT 10,
    p_offset INTEGER DEFAULT 0,
    p_status VARCHAR DEFAULT NULL
) RETURNS TABLE (
    id INTEGER,
    username VARCHAR,
    email VARCHAR,
    status VARCHAR,
    created_at TIMESTAMP,
    total_count BIGINT
) AS $$
BEGIN
    -- å®ç°ï¼šåˆ†é¡µæŸ¥è¯¢ç”¨æˆ·åˆ—è¡¨
    -- ä¼˜åŠ¿ï¼šå°è£…äº†åˆ†é¡µé€»è¾‘ï¼Œè¿”å›æ€»è®°å½•æ•°
    RETURN QUERY
    SELECT
        u.id,
        u.username,
        u.email,
        u.status,
        u.created_at,
        COUNT(*) OVER() as total_count
    FROM user_management.users u
    WHERE (p_status IS NULL OR u.status = p_status)
    ORDER BY u.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$ LANGUAGE plpgsql STABLE;
```

**Repositoryæ¨¡å¼çš„ä¼˜åŠ¿åˆ†æ**ï¼š

| ä¼˜åŠ¿ | è¯´æ˜ | å®é™…ä»·å€¼ |
|-----|------|---------|
| **ä¸šåŠ¡é€»è¾‘è§£è€¦** | ä¸šåŠ¡é€»è¾‘ä¸ç›´æ¥è®¿é—®æ•°æ®åº“ | æé«˜ä»£ç å¯ç»´æŠ¤æ€§ |
| **æ˜“äºæµ‹è¯•** | å¯ä»¥æ¨¡æ‹ŸRepositoryè¿›è¡Œå•å…ƒæµ‹è¯• | æé«˜ä»£ç è´¨é‡ |
| **ç»Ÿä¸€æ¥å£** | æ‰€æœ‰æ•°æ®è®¿é—®é€šè¿‡ç»Ÿä¸€æ¥å£ | é™ä½å­¦ä¹ æˆæœ¬ |
| **æ˜“äºæ›¿æ¢** | å¯ä»¥è½»æ¾åˆ‡æ¢æ•°æ®æº | æé«˜ç³»ç»Ÿçµæ´»æ€§ |

**Repositoryæ¨¡å¼çš„ä½¿ç”¨ç¤ºä¾‹**ï¼š

```sql
-- åœºæ™¯ï¼šä¸šåŠ¡é€»è¾‘ä½¿ç”¨Repositoryè®¿é—®æ•°æ®
-- ä¼˜åŠ¿ï¼šä¸šåŠ¡é€»è¾‘ç®€æ´ï¼Œä¸ä¾èµ–å…·ä½“çš„æ•°æ®è®¿é—®å®ç°

-- ä¸šåŠ¡é€»è¾‘å‡½æ•°ï¼ˆä½¿ç”¨Repositoryï¼‰
CREATE OR REPLACE FUNCTION business_logic.register_user(
    p_username VARCHAR,
    p_email VARCHAR,
    p_password VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_user_id INTEGER;
    v_password_hash VARCHAR;
BEGIN
    -- 1. éªŒè¯è¾“å…¥
    IF p_username IS NULL OR LENGTH(p_username) < 3 THEN
        RAISE EXCEPTION 'Username must be at least 3 characters';
    END IF;

    -- 2. åŠ å¯†å¯†ç ï¼ˆè¿™é‡Œç®€åŒ–ï¼Œå®é™…åº”è¯¥ä½¿ç”¨bcryptç­‰ï¼‰
    v_password_hash := encode(digest(p_password, 'sha256'), 'hex');

    -- 3. ä½¿ç”¨Repositoryä¿å­˜ç”¨æˆ·
    -- ä¼˜åŠ¿ï¼šä¸šåŠ¡é€»è¾‘ä¸éœ€è¦çŸ¥é“å¦‚ä½•è®¿é—®æ•°æ®åº“
    SELECT repositories.save_user(p_username, p_email, v_password_hash)
    INTO v_user_id;

    -- 4. è¿”å›ç”¨æˆ·ID
    RETURN v_user_id;
END;
$$ LANGUAGE plpgsql;
```

**Repositoryæ¨¡å¼çš„æ€§èƒ½è€ƒè™‘**ï¼š

| è€ƒè™‘å› ç´  | è¯´æ˜ | ä¼˜åŒ–å»ºè®® |
|---------|------|---------|
| **å‡½æ•°è°ƒç”¨å¼€é”€** | å‡½æ•°è°ƒç”¨æœ‰è½»å¾®æ€§èƒ½å¼€é”€ | å¯¹äºé«˜é¢‘æ“ä½œï¼Œå¯ä»¥è€ƒè™‘ç›´æ¥SQL |
| **æŸ¥è¯¢ä¼˜åŒ–** | Repositoryå‡½æ•°ä¸­çš„æŸ¥è¯¢å¯ä»¥ä¼˜åŒ– | ä½¿ç”¨EXPLAINåˆ†ææŸ¥è¯¢æ€§èƒ½ |
| **ç¼“å­˜ç­–ç•¥** | Repositoryå±‚å¯ä»¥æ·»åŠ ç¼“å­˜ | åœ¨Repositoryå‡½æ•°ä¸­æ·»åŠ ç¼“å­˜é€»è¾‘ |
| **æ‰¹é‡æ“ä½œ** | Repositoryåº”è¯¥æ”¯æŒæ‰¹é‡æ“ä½œ | æä¾›æ‰¹é‡æ“ä½œçš„Repositoryæ–¹æ³• |

**ä½¿ç”¨Repository**ï¼š

```sql
-- æŸ¥æ‰¾ç”¨æˆ·
SELECT * FROM repositories.find_user_by_id(1);

-- ä¿å­˜ç”¨æˆ·
SELECT repositories.save_user('alice', 'alice@example.com');

-- åˆ é™¤ç”¨æˆ·
SELECT repositories.delete_user(1);
```

### 4.2 Data Mapperæ¨¡å¼

**å¯¹è±¡æ˜ å°„å‡½æ•°**ï¼š

```sql
-- å®šä¹‰ç”¨æˆ·ç±»å‹
CREATE TYPE user_type AS (
    id INTEGER,
    username VARCHAR,
    email VARCHAR,
    profile JSONB
);

-- æ˜ å°„å‡½æ•°ï¼šè¡Œåˆ°å¯¹è±¡
CREATE OR REPLACE FUNCTION map_user_to_object(
    p_user_id INTEGER
) RETURNS user_type AS $$
DECLARE
    v_user user_type;
BEGIN
    SELECT
        u.id,
        u.username,
        u.email,
        jsonb_build_object(
            'first_name', up.first_name,
            'last_name', up.last_name,
            'avatar', up.avatar_url
        )
    INTO v_user
    FROM user_management.users u
    LEFT JOIN user_management.user_profiles up ON u.id = up.user_id
    WHERE u.id = p_user_id;

    RETURN v_user;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 Active Recordæ¨¡å¼

**Active Recordå®ç°**ï¼š

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Active Recordæ–¹æ³•ï¼šä¿å­˜
CREATE OR REPLACE FUNCTION user_save(
    p_id INTEGER DEFAULT NULL,
    p_username VARCHAR,
    p_email VARCHAR
) RETURNS INTEGER AS $$
DECLARE
    v_id INTEGER;
BEGIN
    IF p_id IS NULL THEN
        -- æ–°å»º
        INSERT INTO users (username, email)
        VALUES (p_username, p_email)
        RETURNING id INTO v_id;
    ELSE
        -- æ›´æ–°
        UPDATE users
        SET username = p_username, email = p_email
        WHERE id = p_id;
        v_id := p_id;
    END IF;
    RETURN v_id;
END;
$$ LANGUAGE plpgsql;

-- Active Recordæ–¹æ³•ï¼šåˆ é™¤
CREATE OR REPLACE FUNCTION user_delete(p_id INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    DELETE FROM users WHERE id = p_id;
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;
```

---

## äº”ã€äº‹åŠ¡ç®¡ç†æ¨¡å¼

### 5.1 Unit of Workæ¨¡å¼

**Unit of Workå®ç°**ï¼š

```sql
-- Unit of Workï¼šäº‹åŠ¡å—å°è£…
CREATE OR REPLACE FUNCTION process_order(
    p_user_id INTEGER,
    p_items JSONB,
    p_payment_info JSONB
) RETURNS INTEGER AS $$
DECLARE
    v_order_id INTEGER;
    v_item JSONB;
BEGIN
    -- å¼€å§‹äº‹åŠ¡ï¼ˆè‡ªåŠ¨ï¼‰

    -- 1. åˆ›å»ºè®¢å•
    INSERT INTO orders (user_id, total_amount, status)
    VALUES (p_user_id, 0, 'pending')
    RETURNING id INTO v_order_id;

    -- 2. æ·»åŠ è®¢å•é¡¹
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
    LOOP
        INSERT INTO order_items (order_id, product_id, quantity, price)
        VALUES (
            v_order_id,
            (v_item->>'product_id')::INTEGER,
            (v_item->>'quantity')::INTEGER,
            (v_item->>'price')::DECIMAL
        );
    END LOOP;

    -- 3. è®¡ç®—æ€»é‡‘é¢
    UPDATE orders
    SET total_amount = (
        SELECT SUM(quantity * price)
        FROM order_items
        WHERE order_id = v_order_id
    )
    WHERE id = v_order_id;

    -- 4. å¤„ç†æ”¯ä»˜
    INSERT INTO payments (order_id, amount, payment_method, status)
    VALUES (
        v_order_id,
        (SELECT total_amount FROM orders WHERE id = v_order_id),
        p_payment_info->>'method',
        'completed'
    );

    -- 5. æ›´æ–°è®¢å•çŠ¶æ€
    UPDATE orders SET status = 'completed' WHERE id = v_order_id;

    -- æäº¤äº‹åŠ¡ï¼ˆè‡ªåŠ¨ï¼‰
    RETURN v_order_id;

EXCEPTION
    WHEN OTHERS THEN
        -- å›æ»šäº‹åŠ¡ï¼ˆè‡ªåŠ¨ï¼‰
        RAISE;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 äº‹åŠ¡è„šæœ¬æ¨¡å¼

**äº‹åŠ¡è„šæœ¬ç¤ºä¾‹**ï¼š

```sql
-- ç®€å•çš„äº‹åŠ¡è„šæœ¬
CREATE OR REPLACE FUNCTION transfer_money(
    p_from_account_id INTEGER,
    p_to_account_id INTEGER,
    p_amount DECIMAL
) RETURNS BOOLEAN AS $$
BEGIN
    -- æ£€æŸ¥ä½™é¢
    IF (SELECT balance FROM accounts WHERE id = p_from_account_id) < p_amount THEN
        RAISE EXCEPTION 'Insufficient balance';
    END IF;

    -- æ‰£æ¬¾
    UPDATE accounts
    SET balance = balance - p_amount
    WHERE id = p_from_account_id;

    -- å…¥è´¦
    UPDATE accounts
    SET balance = balance + p_amount
    WHERE id = p_to_account_id;

    -- è®°å½•äº¤æ˜“
    INSERT INTO transactions (from_account_id, to_account_id, amount, type)
    VALUES (p_from_account_id, p_to_account_id, p_amount, 'transfer');

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 é¢†åŸŸæœåŠ¡æ¨¡å¼

**é¢†åŸŸæœåŠ¡å®ç°**ï¼š

```sql
-- è®¢å•é¢†åŸŸæœåŠ¡
CREATE SCHEMA domain_services;

CREATE OR REPLACE FUNCTION domain_services.order_service_create_order(
    p_user_id INTEGER,
    p_items JSONB
) RETURNS INTEGER AS $$
DECLARE
    v_order_id INTEGER;
    v_total DECIMAL;
BEGIN
    -- ä¸šåŠ¡è§„åˆ™éªŒè¯
    IF NOT EXISTS (SELECT 1 FROM users WHERE id = p_user_id) THEN
        RAISE EXCEPTION 'User not found';
    END IF;

    -- è®¡ç®—æ€»é‡‘é¢
    SELECT SUM((item->>'quantity')::INTEGER * (item->>'price')::DECIMAL)
    INTO v_total
    FROM jsonb_array_elements(p_items) AS item;

    -- åˆ›å»ºè®¢å•
    INSERT INTO orders (user_id, total_amount, status)
    VALUES (p_user_id, v_total, 'pending')
    RETURNING id INTO v_order_id;

    -- æ·»åŠ è®¢å•é¡¹
    INSERT INTO order_items (order_id, product_id, quantity, price)
    SELECT
        v_order_id,
        (item->>'product_id')::INTEGER,
        (item->>'quantity')::INTEGER,
        (item->>'price')::DECIMAL
    FROM jsonb_array_elements(p_items) AS item;

    RETURN v_order_id;
END;
$$ LANGUAGE plpgsql;
```

---

## å…­ã€æŸ¥è¯¢æ¨¡å¼

### 6.1 æŸ¥è¯¢å¯¹è±¡æ¨¡å¼

**æŸ¥è¯¢å¯¹è±¡å®ç°**ï¼š

```sql
-- ç”¨æˆ·æŸ¥è¯¢å¯¹è±¡
CREATE OR REPLACE FUNCTION build_user_query(
    p_user_id INTEGER DEFAULT NULL,
    p_username VARCHAR DEFAULT NULL,
    p_email VARCHAR DEFAULT NULL,
    p_active BOOLEAN DEFAULT NULL
) RETURNS TABLE (
    id INTEGER,
    username VARCHAR,
    email VARCHAR,
    active BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.username, u.email, u.active
    FROM users u
    WHERE
        (p_user_id IS NULL OR u.id = p_user_id)
        AND (p_username IS NULL OR u.username = p_username)
        AND (p_email IS NULL OR u.email = p_email)
        AND (p_active IS NULL OR u.active = p_active);
END;
$$ LANGUAGE plpgsql;
```

### 6.2 è§„èŒƒæ¨¡å¼

**è§„èŒƒå®ç°**ï¼š

```sql
-- è§„èŒƒï¼šæ´»è·ƒç”¨æˆ·
CREATE OR REPLACE FUNCTION is_active_user(p_user_id INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users
        WHERE id = p_user_id AND active = TRUE
    );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- è§„èŒƒï¼šVIPç”¨æˆ·
CREATE OR REPLACE FUNCTION is_vip_user(p_user_id INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users u
        JOIN orders o ON u.id = o.user_id
        WHERE u.id = p_user_id
        GROUP BY u.id
        HAVING SUM(o.total_amount) > 10000
    );
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨è§„èŒƒ
SELECT * FROM users WHERE is_active_user(id) AND is_vip_user(id);
```

### 6.3 æŸ¥è¯¢æ„å»ºå™¨æ¨¡å¼

**æŸ¥è¯¢æ„å»ºå™¨å®ç°**ï¼š

```sql
-- æŸ¥è¯¢æ„å»ºå™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰
CREATE OR REPLACE FUNCTION query_builder_select(
    p_table_name TEXT,
    p_conditions JSONB DEFAULT '{}'::JSONB,
    p_order_by TEXT DEFAULT NULL,
    p_limit INTEGER DEFAULT NULL
) RETURNS TEXT AS $$
DECLARE
    v_sql TEXT;
    v_condition TEXT;
    v_key TEXT;
BEGIN
    v_sql := 'SELECT * FROM ' || quote_ident(p_table_name);

    -- æ„å»ºWHEREæ¡ä»¶
    IF p_conditions != '{}'::JSONB THEN
        v_condition := '';
        FOR v_key IN SELECT jsonb_object_keys(p_conditions)
        LOOP
            IF v_condition != '' THEN
                v_condition := v_condition || ' AND ';
            END IF;
            v_condition := v_condition || quote_ident(v_key) || ' = ' ||
                quote_literal(p_conditions->>v_key);
        END LOOP;
        v_sql := v_sql || ' WHERE ' || v_condition;
    END IF;

    -- ORDER BY
    IF p_order_by IS NOT NULL THEN
        v_sql := v_sql || ' ORDER BY ' || quote_ident(p_order_by);
    END IF;

    -- LIMIT
    IF p_limit IS NOT NULL THEN
        v_sql := v_sql || ' LIMIT ' || p_limit;
    END IF;

    RETURN v_sql;
END;
$$ LANGUAGE plpgsql;
```

---

## ä¸ƒã€é”™è¯¯å¤„ç†æ¨¡å¼

### 7.1 å¼‚å¸¸å¤„ç†æ¨¡å¼

**ç»Ÿä¸€å¼‚å¸¸å¤„ç†**ï¼š

```sql
-- è‡ªå®šä¹‰å¼‚å¸¸
DO $$ BEGIN
    CREATE EXCEPTION user_not_found;
    CREATE EXCEPTION insufficient_balance;
    CREATE EXCEPTION invalid_input;
EXCEPTION
    WHEN duplicate_object THEN NULL;
END $$;

-- å¼‚å¸¸å¤„ç†å‡½æ•°
CREATE OR REPLACE FUNCTION safe_transfer(
    p_from_account_id INTEGER,
    p_to_account_id INTEGER,
    p_amount DECIMAL
) RETURNS JSONB AS $$
DECLARE
    v_result JSONB;
BEGIN
    BEGIN
        -- æ‰§è¡Œè½¬è´¦
        PERFORM transfer_money(p_from_account_id, p_to_account_id, p_amount);

        v_result := jsonb_build_object(
            'success', TRUE,
            'message', 'Transfer completed'
        );
    EXCEPTION
        WHEN OTHERS THEN
            v_result := jsonb_build_object(
                'success', FALSE,
                'error', SQLERRM,
                'error_code', SQLSTATE
            );
    END;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

### 7.2 ç»“æœå¯¹è±¡æ¨¡å¼

**ç»“æœå¯¹è±¡å®ç°**ï¼š

```sql
-- ç»“æœç±»å‹
CREATE TYPE operation_result AS (
    success BOOLEAN,
    message TEXT,
    data JSONB,
    error_code TEXT
);

-- è¿”å›ç»“æœå¯¹è±¡
CREATE OR REPLACE FUNCTION create_user_with_result(
    p_username VARCHAR,
    p_email VARCHAR
) RETURNS operation_result AS $$
DECLARE
    v_result operation_result;
    v_user_id INTEGER;
BEGIN
    BEGIN
        INSERT INTO users (username, email)
        VALUES (p_username, p_email)
        RETURNING id INTO v_user_id;

        v_result := ROW(
            TRUE,
            'User created successfully',
            jsonb_build_object('user_id', v_user_id),
            NULL
        )::operation_result;
    EXCEPTION
        WHEN unique_violation THEN
            v_result := ROW(
                FALSE,
                'Username or email already exists',
                NULL,
                'UNIQUE_VIOLATION'
            )::operation_result;
        WHEN OTHERS THEN
            v_result := ROW(
                FALSE,
                SQLERRM,
                NULL,
                SQLSTATE
            )::operation_result;
    END;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

### 7.3 é‡è¯•æ¨¡å¼

**é‡è¯•æœºåˆ¶å®ç°**ï¼š

```sql
-- é‡è¯•å‡½æ•°
CREATE OR REPLACE FUNCTION retry_operation(
    p_operation TEXT,
    p_max_retries INTEGER DEFAULT 3,
    p_retry_delay INTERVAL DEFAULT '1 second'
) RETURNS JSONB AS $$
DECLARE
    v_attempt INTEGER := 0;
    v_result JSONB;
    v_sql TEXT;
BEGIN
    LOOP
        v_attempt := v_attempt + 1;

        BEGIN
            -- æ‰§è¡Œæ“ä½œ
            EXECUTE p_operation INTO v_result;
            RETURN jsonb_build_object('success', TRUE, 'result', v_result);
        EXCEPTION
            WHEN deadlock_detected THEN
                IF v_attempt < p_max_retries THEN
                    PERFORM pg_sleep(EXTRACT(EPOCH FROM p_retry_delay)::INTEGER);
                    CONTINUE;
                ELSE
                    RETURN jsonb_build_object(
                        'success', FALSE,
                        'error', 'Max retries exceeded',
                        'error_code', 'DEADLOCK_DETECTED'
                    );
                END IF;
            WHEN OTHERS THEN
                RETURN jsonb_build_object(
                    'success', FALSE,
                    'error', SQLERRM,
                    'error_code', SQLSTATE
                );
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## å…«ã€æ€§èƒ½ä¼˜åŒ–æ¨¡å¼

### 8.1 æ‰¹é‡æ“ä½œæ¨¡å¼

**æ‰¹é‡æ’å…¥ä¼˜åŒ–**ï¼š

```sql
-- PostgreSQL 18: ä½¿ç”¨è™šæ‹Ÿç”Ÿæˆåˆ—ä¼˜åŒ–æ‰¹é‡æ’å…¥
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2),
    discount DECIMAL(5,2),
    final_price DECIMAL(10,2) GENERATED ALWAYS AS (
        price * (1 - discount / 100)
    ) STORED
);

-- æ‰¹é‡æ’å…¥ï¼ˆä½¿ç”¨COPYï¼‰
COPY products (name, price, discount) FROM STDIN WITH (FORMAT CSV);
Product A,100.00,10
Product B,200.00,20
Product C,300.00,15
\.

-- æ‰¹é‡æ›´æ–°
UPDATE products
SET price = new_prices.price
FROM (VALUES
    (1, 110.00),
    (2, 220.00),
    (3, 330.00)
) AS new_prices(id, price)
WHERE products.id = new_prices.id;
```

### 8.2 ç¼“å­˜æ¨¡å¼

**ç»“æœç¼“å­˜**ï¼š

```sql
-- ç¼“å­˜è¡¨
CREATE TABLE query_cache (
    cache_key TEXT PRIMARY KEY,
    cache_value JSONB,
    expires_at TIMESTAMP
);

-- ç¼“å­˜å‡½æ•°
CREATE OR REPLACE FUNCTION get_cached_result(
    p_key TEXT,
    p_query TEXT,
    p_ttl INTERVAL DEFAULT '1 hour'
) RETURNS JSONB AS $$
DECLARE
    v_result JSONB;
BEGIN
    -- æ£€æŸ¥ç¼“å­˜
    SELECT cache_value INTO v_result
    FROM query_cache
    WHERE cache_key = p_key
    AND expires_at > CURRENT_TIMESTAMP;

    IF v_result IS NULL THEN
        -- æ‰§è¡ŒæŸ¥è¯¢å¹¶ç¼“å­˜
        EXECUTE p_query INTO v_result;

        INSERT INTO query_cache (cache_key, cache_value, expires_at)
        VALUES (p_key, v_result, CURRENT_TIMESTAMP + p_ttl)
        ON CONFLICT (cache_key) DO UPDATE
        SET cache_value = EXCLUDED.cache_value,
            expires_at = EXCLUDED.expires_at;
    END IF;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

### 8.3 å»¶è¿ŸåŠ è½½æ¨¡å¼

**å»¶è¿ŸåŠ è½½å®ç°**ï¼š

```sql
-- å»¶è¿ŸåŠ è½½ï¼šæŒ‰éœ€åŠ è½½å…³è”æ•°æ®
CREATE OR REPLACE FUNCTION get_user_with_profile(
    p_user_id INTEGER,
    p_load_profile BOOLEAN DEFAULT FALSE
) RETURNS JSONB AS $$
DECLARE
    v_user JSONB;
BEGIN
    -- åŠ è½½ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
    SELECT jsonb_build_object(
        'id', u.id,
        'username', u.username,
        'email', u.email
    ) INTO v_user
    FROM users u
    WHERE u.id = p_user_id;

    -- æŒ‰éœ€åŠ è½½Profile
    IF p_load_profile THEN
        SELECT v_user || jsonb_build_object(
            'profile', jsonb_build_object(
                'first_name', up.first_name,
                'last_name', up.last_name,
                'avatar', up.avatar_url
            )
        ) INTO v_user
        FROM user_profiles up
        WHERE up.user_id = p_user_id;
    END IF;

    RETURN v_user;
END;
$$ LANGUAGE plpgsql;
```

---

## ä¹ã€ä»£ç è´¨é‡

### 9.1 ä»£ç å®¡æŸ¥æ¸…å•

**ä»£ç å®¡æŸ¥è¦ç‚¹**ï¼š

- âœ… **å‘½åè§„èŒƒ**ï¼šå‡½æ•°ã€è¡¨ã€å˜é‡å‘½åæ˜¯å¦æ¸…æ™°
- âœ… **é”™è¯¯å¤„ç†**ï¼šæ˜¯å¦å¤„ç†äº†æ‰€æœ‰å¼‚å¸¸æƒ…å†µ
- âœ… **æ€§èƒ½è€ƒè™‘**ï¼šæ˜¯å¦ä½¿ç”¨äº†åˆé€‚çš„ç´¢å¼•å’ŒæŸ¥è¯¢ä¼˜åŒ–
- âœ… **äº‹åŠ¡ç®¡ç†**ï¼šäº‹åŠ¡è¾¹ç•Œæ˜¯å¦åˆç†
- âœ… **å®‰å…¨æ€§**ï¼šæ˜¯å¦é˜²æ­¢SQLæ³¨å…¥
- âœ… **å¯ç»´æŠ¤æ€§**ï¼šä»£ç æ˜¯å¦æ˜“äºç†è§£å’Œä¿®æ”¹

### 9.2 æµ‹è¯•ç­–ç•¥

**å•å…ƒæµ‹è¯•**ï¼š

```sql
-- æµ‹è¯•æ¡†æ¶ï¼ˆç®€åŒ–ç‰ˆï¼‰
CREATE SCHEMA test;

CREATE OR REPLACE FUNCTION test.assert_equal(
    p_actual ANYELEMENT,
    p_expected ANYELEMENT,
    p_message TEXT DEFAULT ''
) RETURNS BOOLEAN AS $$
BEGIN
    IF p_actual != p_expected THEN
        RAISE EXCEPTION 'Assertion failed: % (actual: %, expected: %)',
            p_message, p_actual, p_expected;
    END IF;
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- æµ‹è¯•ç”¨ä¾‹
CREATE OR REPLACE FUNCTION test.test_user_creation()
RETURNS VOID AS $$
DECLARE
    v_user_id INTEGER;
BEGIN
    -- æµ‹è¯•åˆ›å»ºç”¨æˆ·
    v_user_id := repositories.save_user('testuser', 'test@example.com');
    PERFORM test.assert_equal(v_user_id > 0, TRUE, 'User ID should be positive');

    -- æ¸…ç†
    DELETE FROM users WHERE id = v_user_id;
END;
$$ LANGUAGE plpgsql;
```

### 9.3 æ–‡æ¡£è§„èŒƒ

**å‡½æ•°æ–‡æ¡£æ¨¡æ¿**ï¼š

```sql
-- å‡½æ•°æ–‡æ¡£æ³¨é‡Š
/**
 * åŠŸèƒ½ï¼šæ ¹æ®ç”¨æˆ·IDæŸ¥æ‰¾ç”¨æˆ·
 * å‚æ•°ï¼š
 *   - p_user_id: ç”¨æˆ·ID
 * è¿”å›ï¼šç”¨æˆ·ä¿¡æ¯ï¼ˆid, username, email, created_atï¼‰
 * å¼‚å¸¸ï¼š
 *   - ç”¨æˆ·ä¸å­˜åœ¨æ—¶è¿”å›ç©ºç»“æœ
 * ç¤ºä¾‹ï¼š
 *   SELECT * FROM repositories.find_user_by_id(1);
 */
CREATE OR REPLACE FUNCTION repositories.find_user_by_id(...) ...
```

---

## åã€ç›¸å…³æ–‡æ¡£

- [ç¼–ç¨‹èŒƒå¼ä¸æ¨¡å¼](./01.01-ç¼–ç¨‹èŒƒå¼ä¸æ¨¡å¼.md)
- [APIä½¿ç”¨æŒ‡å—](./01.02-APIä½¿ç”¨æŒ‡å—.md)
- [æ€§èƒ½ç¼–ç¨‹æŠ€å·§](./01.05-æ€§èƒ½ç¼–ç¨‹æŠ€å·§.md)
- [é”™è¯¯å¤„ç†ä¸å¼‚å¸¸](./01.06-é”™è¯¯å¤„ç†ä¸å¼‚å¸¸.md)
- [PostgreSQL 18æ–°ç‰¹æ€§](../../02-ç‰ˆæœ¬ç‰¹æ€§/02.01-PostgreSQL-18-æ–°ç‰¹æ€§.md)

---

**æœ€åæ›´æ–°**: 2025-01-15
**ç»´æŠ¤è€…**: PostgreSQL Documentation Team
