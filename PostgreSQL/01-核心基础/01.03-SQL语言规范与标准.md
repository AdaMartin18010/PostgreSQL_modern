# PostgreSQL SQLè¯­è¨€è§„èŒƒä¸æ ‡å‡†

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0
> **æœ€åæ›´æ–°**: 2025-11-12
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å·²æ›´æ–°
> ğŸ†• **PostgreSQL 18 SQLæ”¹è¿›**: æŸ¥è¯¢æ€§èƒ½æå‡30-40%ã€JSONBå¢å¼º15-20%ã€MERGEè¯­å¥ä¼˜åŒ–20%ã€è™šæ‹Ÿç”Ÿæˆåˆ—æ”¯æŒ

---

## ğŸ“‹ ç›®å½•

- [PostgreSQL SQLè¯­è¨€è§„èŒƒä¸æ ‡å‡†](#postgresql-sqlè¯­è¨€è§„èŒƒä¸æ ‡å‡†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®šä¹‰ä¸å½¢å¼åŒ–](#1-å®šä¹‰ä¸å½¢å¼åŒ–)
    - [1.1 æ¦‚å¿µå®šä¹‰](#11-æ¦‚å¿µå®šä¹‰)
    - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
    - [1.3 ç†è®ºåŸºç¡€](#13-ç†è®ºåŸºç¡€)
      - [1.3.1 å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»](#131-å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»)
      - [1.3.2 SQLå®Œå¤‡æ€§å®šç†](#132-sqlå®Œå¤‡æ€§å®šç†)
  - [2. æ ¸å¿ƒè¯­æ³•è§„èŒƒ](#2-æ ¸å¿ƒè¯­æ³•è§„èŒƒ)
    - [2.1 æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰](#21-æ•°æ®å®šä¹‰è¯­è¨€ddl)
      - [2.1.1 è¡¨å®šä¹‰](#211-è¡¨å®šä¹‰)
      - [2.1.2 è§†å›¾å®šä¹‰](#212-è§†å›¾å®šä¹‰)
    - [2.2 æ•°æ®æ“ä½œè¯­è¨€ï¼ˆDMLï¼‰](#22-æ•°æ®æ“ä½œè¯­è¨€dml)
      - [2.2.1 æ’å…¥æ“ä½œ](#221-æ’å…¥æ“ä½œ)
      - [2.2.2 æ›´æ–°æ“ä½œ](#222-æ›´æ–°æ“ä½œ)
      - [2.2.3 åˆ é™¤æ“ä½œ](#223-åˆ é™¤æ“ä½œ)
    - [2.3 æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆDQLï¼‰](#23-æ•°æ®æŸ¥è¯¢è¯­è¨€dql)
      - [2.3.1 åŸºæœ¬æŸ¥è¯¢](#231-åŸºæœ¬æŸ¥è¯¢)
      - [2.3.2 è¿æ¥æŸ¥è¯¢](#232-è¿æ¥æŸ¥è¯¢)
      - [2.3.3 å­æŸ¥è¯¢](#233-å­æŸ¥è¯¢)
    - [2.4 é«˜çº§æŸ¥è¯¢ç‰¹æ€§](#24-é«˜çº§æŸ¥è¯¢ç‰¹æ€§)
      - [2.4.1 çª—å£å‡½æ•°](#241-çª—å£å‡½æ•°)
      - [2.4.2 é€’å½’æŸ¥è¯¢](#242-é€’å½’æŸ¥è¯¢)
      - [2.4.3 å…¬å…±è¡¨è¡¨è¾¾å¼ï¼ˆCTEï¼‰](#243-å…¬å…±è¡¨è¡¨è¾¾å¼cte)
    - [2.5 äº‹åŠ¡æ§åˆ¶è¯­è¨€ï¼ˆTCLï¼‰](#25-äº‹åŠ¡æ§åˆ¶è¯­è¨€tcl)
      - [2.5.1 äº‹åŠ¡ç®¡ç†](#251-äº‹åŠ¡ç®¡ç†)
    - [2.6 æ•°æ®æ§åˆ¶è¯­è¨€ï¼ˆDCLï¼‰](#26-æ•°æ®æ§åˆ¶è¯­è¨€dcl)
      - [2.6.1 æƒé™ç®¡ç†](#261-æƒé™ç®¡ç†)
  - [3. PostgreSQLæ‰©å±•ç‰¹æ€§](#3-postgresqlæ‰©å±•ç‰¹æ€§)
    - [3.1 æ•°æ®ç±»å‹æ‰©å±•](#31-æ•°æ®ç±»å‹æ‰©å±•)
    - [3.2 å‡½æ•°å’Œæ“ä½œç¬¦](#32-å‡½æ•°å’Œæ“ä½œç¬¦)
    - [3.3 ç´¢å¼•ç±»å‹](#33-ç´¢å¼•ç±»å‹)
  - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 æŸ¥è¯¢ä¼˜åŒ–](#41-æŸ¥è¯¢ä¼˜åŒ–)
    - [4.2 ç´¢å¼•ä¼˜åŒ–](#42-ç´¢å¼•ä¼˜åŒ–)
  - [5. ç›¸å…³æ¦‚å¿µ](#5-ç›¸å…³æ¦‚å¿µ)
    - [5.1 ä¸Šä½æ¦‚å¿µ](#51-ä¸Šä½æ¦‚å¿µ)
    - [5.2 ä¸‹ä½æ¦‚å¿µ](#52-ä¸‹ä½æ¦‚å¿µ)
    - [5.3 å¹³è¡Œæ¦‚å¿µ](#53-å¹³è¡Œæ¦‚å¿µ)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [8. Wikidataå¯¹é½](#8-wikidataå¯¹é½)

---

## 1. å®šä¹‰ä¸å½¢å¼åŒ–

### 1.1 æ¦‚å¿µå®šä¹‰

**ä¸­æ–‡å®šä¹‰**: SQLï¼ˆStructured Query Languageï¼‰æ˜¯ä¸€ç§å£°æ˜å¼çš„å…³ç³»æ•°æ®åº“æŸ¥è¯¢è¯­è¨€ï¼Œæ”¯æŒæ•°æ®å®šä¹‰ã€æ“ä½œã€æŸ¥è¯¢å’Œæ§åˆ¶åŠŸèƒ½ï¼Œæ˜¯å…³ç³»æ•°æ®åº“çš„æ ‡å‡†è¯­è¨€ã€‚PostgreSQLå®ç°äº†å®Œæ•´çš„SQL:2023æ ‡å‡†ï¼Œå¹¶æä¾›äº†ä¸°å¯Œçš„æ‰©å±•åŠŸèƒ½ã€‚

**English Definition**: SQL (Structured Query Language) is a declarative relational database query language that supports data definition, manipulation, query, and control functions, serving as the standard language for relational databases. PostgreSQL implements the complete SQL:2023 standard and provides rich extension capabilities.

### 1.2 å½¢å¼åŒ–å®šä¹‰

```latex
% æ•°å­¦ç¬¦å·å®šä¹‰
\newcommand{\sql}{\mathcal{SQL}}
\newcommand{\rel}{\mathcal{R}}
\newcommand{\attr}{\mathcal{A}}
\newcommand{\tuple}{\mathcal{T}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\result}{\mathcal{Result}}
\newcommand{\db}{\mathcal{D}}
\newcommand{\schema}{\mathcal{S}}

% SQLè¯­è¨€çš„å½¢å¼åŒ–å®šä¹‰
\sql = (DDL, DML, DQL, DCL, TCL)

å…¶ä¸­ï¼š
DDL = \{CREATE, ALTER, DROP, TRUNCATE\} \text{ æ•°æ®å®šä¹‰è¯­è¨€}
DML = \{INSERT, UPDATE, DELETE, MERGE\} \text{ æ•°æ®æ“ä½œè¯­è¨€}
DQL = \{SELECT\} \text{ æ•°æ®æŸ¥è¯¢è¯­è¨€}
DCL = \{GRANT, REVOKE, DENY\} \text{ æ•°æ®æ§åˆ¶è¯­è¨€}
TCL = \{BEGIN, COMMIT, ROLLBACK, SAVEPOINT\} \text{ äº‹åŠ¡æ§åˆ¶è¯­è¨€}
```

### 1.3 ç†è®ºåŸºç¡€

#### 1.3.1 å…³ç³»ä»£æ•°å¯¹åº”å…³ç³»

```latex
\begin{theorem}[SQLä¸å…³ç³»ä»£æ•°ç­‰ä»·æ€§]
SQLè¯­è¨€åœ¨è¡¨è¾¾èƒ½åŠ›ä¸Šç­‰ä»·äºå…³ç³»ä»£æ•°ï¼Œå³ï¼š
\forall q \in \query, \exists \sigma, \pi, \bowtie, \cup, \cap, - \text{ ä½¿å¾— }
\result(q) = f(\sigma, \pi, \bowtie, \cup, \cap, -)
\end{theorem}

\begin{proof}
1. SELECTå¯¹åº”æŠ•å½±æ“ä½œ \pi
2. WHEREå¯¹åº”é€‰æ‹©æ“ä½œ \sigma
3. JOINå¯¹åº”è¿æ¥æ“ä½œ \bowtie
4. UNIONå¯¹åº”å¹¶é›†æ“ä½œ \cup
5. INTERSECTå¯¹åº”äº¤é›†æ“ä½œ \cap
6. EXCEPTå¯¹åº”å·®é›†æ“ä½œ -

å› æ­¤ï¼ŒSQLçš„æ¯ä¸ªæ“ä½œéƒ½å¯ä»¥ç”¨å…³ç³»ä»£æ•°è¡¨ç¤ºï¼Œåä¹‹äº¦ç„¶ã€‚
\end{proof}
```

#### 1.3.2 SQLå®Œå¤‡æ€§å®šç†

```latex
\begin{theorem}[SQLå®Œå¤‡æ€§]
SQLè¯­è¨€æ˜¯å…³ç³»å®Œå¤‡çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
1. æ”¯æŒå…³ç³»ä»£æ•°çš„æ‰€æœ‰åŸºæœ¬æ“ä½œ
2. æ”¯æŒé€’å½’æŸ¥è¯¢ï¼ˆWITH RECURSIVEï¼‰
3. æ”¯æŒèšåˆå‡½æ•°å’Œåˆ†ç»„æ“ä½œ
4. æ”¯æŒå­æŸ¥è¯¢å’ŒåµŒå¥—æŸ¥è¯¢
5. æ”¯æŒçª—å£å‡½æ•°å’ŒOLAPåŠŸèƒ½
\end{theorem}

\begin{proof}
åŸºäºCoddå®šç†ï¼Œå…³ç³»å®Œå¤‡æ€§è¦æ±‚ï¼š
- èƒ½å¤Ÿè¡¨è¾¾å…³ç³»ä»£æ•°çš„æ‰€æœ‰æ“ä½œ
- èƒ½å¤Ÿå¤„ç†é€’å½’å…³ç³»
- èƒ½å¤Ÿè¿›è¡Œå¤æ‚çš„æ•°æ®æ“ä½œ
- èƒ½å¤Ÿæ”¯æŒåˆ†ææŸ¥è¯¢

PostgreSQLçš„SQLå®ç°æ»¡è¶³ä»¥ä¸Šæ‰€æœ‰æ¡ä»¶ï¼Œå› æ­¤æ˜¯å…³ç³»å®Œå¤‡çš„ã€‚
\end{proof}
```

## 2. æ ¸å¿ƒè¯­æ³•è§„èŒƒ

### 2.1 æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰

#### 2.1.1 è¡¨å®šä¹‰

```sql
-- æ ‡å‡†è¡¨å®šä¹‰
CREATE TABLE employees (
    emp_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    dept_id INTEGER REFERENCES departments(dept_id),
    salary DECIMAL(10,2) CHECK (salary > 0),
    hire_date DATE DEFAULT CURRENT_DATE,
    manager_id INTEGER REFERENCES employees(emp_id),
    CONSTRAINT emp_salary_check CHECK (salary >= 0 AND salary <= 1000000)
);

-- ç´¢å¼•å®šä¹‰
CREATE INDEX idx_emp_dept ON employees(dept_id);
CREATE UNIQUE INDEX idx_emp_email ON employees(email);
CREATE INDEX idx_emp_salary ON employees(salary) WHERE salary > 50000;
```

#### 2.1.2 è§†å›¾å®šä¹‰

```sql
-- ç®€å•è§†å›¾
CREATE VIEW emp_summary AS
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary,
    MAX(salary) as max_salary
FROM employees
GROUP BY dept_id;

-- å¯æ›´æ–°è§†å›¾
CREATE VIEW emp_public AS
SELECT emp_id, name, dept_id
FROM employees
WHERE active = true;

-- ç‰©åŒ–è§†å›¾
CREATE MATERIALIZED VIEW emp_stats AS
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary
FROM employees
GROUP BY dept_id;
```

### 2.2 æ•°æ®æ“ä½œè¯­è¨€ï¼ˆDMLï¼‰

#### 2.2.1 æ’å…¥æ“ä½œ

```sql
-- å•è¡Œæ’å…¥
INSERT INTO employees (emp_id, name, dept_id, salary)
VALUES (1001, 'å¼ ä¸‰', 1, 50000);

-- å¤šè¡Œæ’å…¥
INSERT INTO employees (emp_id, name, dept_id, salary) VALUES
    (1002, 'æå››', 1, 55000),
    (1003, 'ç‹äº”', 2, 60000);

-- ä½¿ç”¨RETURNINGå­å¥ï¼ˆPostgreSQLç‰¹æ€§ï¼‰
INSERT INTO employees (name, dept_id, salary)
VALUES ('æ–°å‘˜å·¥', 1, 45000)
RETURNING emp_id, name, salary;

-- ä»æŸ¥è¯¢ç»“æœæ’å…¥
INSERT INTO employees (name, dept_id, salary)
SELECT name, dept_id, salary * 1.1
FROM temp_employees
WHERE salary < 50000;
```

#### 2.2.2 æ›´æ–°æ“ä½œ

```sql
-- ç®€å•æ›´æ–°
UPDATE employees
SET salary = salary * 1.05
WHERE dept_id = 1;

-- ä½¿ç”¨å­æŸ¥è¯¢æ›´æ–°
UPDATE employees
SET salary = (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.dept_id = employees.dept_id
)
WHERE salary < (
    SELECT AVG(salary)
    FROM employees e3
    WHERE e3.dept_id = employees.dept_id
);

-- ä½¿ç”¨RETURNINGå­å¥
UPDATE employees
SET salary = salary * 1.1
WHERE dept_id = 2
RETURNING emp_id, name, salary;
```

#### 2.2.3 åˆ é™¤æ“ä½œ

```sql
-- ç®€å•åˆ é™¤
DELETE FROM employees
WHERE emp_id = 1001;

-- ä½¿ç”¨å­æŸ¥è¯¢åˆ é™¤
DELETE FROM employees
WHERE dept_id IN (
    SELECT dept_id
    FROM departments
    WHERE status = 'inactive'
);

-- ä½¿ç”¨RETURNINGå­å¥
DELETE FROM employees
WHERE hire_date < '2020-01-01'
RETURNING emp_id, name, hire_date;
```

### 2.3 æ•°æ®æŸ¥è¯¢è¯­è¨€ï¼ˆDQLï¼‰

#### 2.3.1 åŸºæœ¬æŸ¥è¯¢

```sql
-- åŸºæœ¬SELECT
SELECT emp_id, name, salary
FROM employees
WHERE dept_id = 1
ORDER BY salary DESC;

-- èšåˆæŸ¥è¯¢
SELECT
    dept_id,
    COUNT(*) as emp_count,
    AVG(salary) as avg_salary,
    MIN(salary) as min_salary,
    MAX(salary) as max_salary
FROM employees
GROUP BY dept_id
HAVING COUNT(*) > 5
ORDER BY avg_salary DESC;
```

#### 2.3.2 è¿æ¥æŸ¥è¯¢

```sql
-- å†…è¿æ¥
SELECT e.name, d.dept_name, e.salary
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- å·¦å¤–è¿æ¥
SELECT e.name, d.dept_name, e.salary
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

-- è‡ªè¿æ¥
SELECT e1.name as employee, e2.name as manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.emp_id;
```

#### 2.3.3 å­æŸ¥è¯¢

```sql
-- æ ‡é‡å­æŸ¥è¯¢
SELECT name, salary,
    (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id) as dept_avg
FROM employees e1;

-- å­˜åœ¨æ€§æŸ¥è¯¢
SELECT name, salary
FROM employees e
WHERE EXISTS (
    SELECT 1 FROM departments d
    WHERE d.dept_id = e.dept_id AND d.status = 'active'
);

-- INå­æŸ¥è¯¢
SELECT name, salary
FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments WHERE budget > 1000000
);
```

### 2.4 é«˜çº§æŸ¥è¯¢ç‰¹æ€§

#### 2.4.1 çª—å£å‡½æ•°

```sql
-- æ’åå‡½æ•°
SELECT
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as salary_rank,
    RANK() OVER (ORDER BY salary DESC) as rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank
FROM employees;

-- åˆ†åŒºçª—å£å‡½æ•°
SELECT
    name,
    dept_id,
    salary,
    AVG(salary) OVER (PARTITION BY dept_id) as dept_avg,
    salary - AVG(salary) OVER (PARTITION BY dept_id) as diff_from_avg
FROM employees;
```

#### 2.4.2 é€’å½’æŸ¥è¯¢

```sql
-- é€’å½’CTE
WITH RECURSIVE emp_hierarchy AS (
    -- åŸºç¡€æƒ…å†µï¼šé¡¶çº§ç®¡ç†è€…
    SELECT emp_id, name, manager_id, 1 as level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- é€’å½’æƒ…å†µï¼šä¸‹å±å‘˜å·¥
    SELECT e.emp_id, e.name, e.manager_id, eh.level + 1
    FROM employees e
    INNER JOIN emp_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT * FROM emp_hierarchy ORDER BY level, name;
```

#### 2.4.3 å…¬å…±è¡¨è¡¨è¾¾å¼ï¼ˆCTEï¼‰

```sql
-- ç®€å•CTE
WITH high_earners AS (
    SELECT emp_id, name, salary
    FROM employees
    WHERE salary > 80000
),
dept_stats AS (
    SELECT dept_id, COUNT(*) as emp_count
    FROM employees
    GROUP BY dept_id
)
SELECT h.name, h.salary, d.emp_count
FROM high_earners h
JOIN employees e ON h.emp_id = e.emp_id
JOIN dept_stats d ON e.dept_id = d.dept_id;
```

### 2.5 äº‹åŠ¡æ§åˆ¶è¯­è¨€ï¼ˆTCLï¼‰

#### 2.5.1 äº‹åŠ¡ç®¡ç†

```sql
-- åŸºæœ¬äº‹åŠ¡
BEGIN;
INSERT INTO employees (name, dept_id, salary) VALUES ('æ–°å‘˜å·¥', 1, 50000);
UPDATE departments SET emp_count = emp_count + 1 WHERE dept_id = 1;
COMMIT;

-- ä¿å­˜ç‚¹
BEGIN;
INSERT INTO employees (name, dept_id, salary) VALUES ('å‘˜å·¥1', 1, 50000);
SAVEPOINT sp1;
INSERT INTO employees (name, dept_id, salary) VALUES ('å‘˜å·¥2', 1, 60000);
ROLLBACK TO sp1;  -- å›æ»šåˆ°ä¿å­˜ç‚¹
COMMIT;  -- åªæäº¤ç¬¬ä¸€ä¸ªæ’å…¥
```

### 2.6 æ•°æ®æ§åˆ¶è¯­è¨€ï¼ˆDCLï¼‰

#### 2.6.1 æƒé™ç®¡ç†

```sql
-- åˆ›å»ºè§’è‰²
CREATE ROLE hr_manager;
CREATE ROLE data_analyst;

-- æˆäºˆæƒé™
GRANT SELECT, INSERT, UPDATE ON employees TO hr_manager;
GRANT SELECT ON employees TO data_analyst;
GRANT USAGE ON SCHEMA public TO hr_manager, data_analyst;

-- æ’¤é”€æƒé™
REVOKE UPDATE ON employees FROM hr_manager;

-- è§’è‰²ç»§æ‰¿
GRANT hr_manager TO data_analyst;
```

## 3. PostgreSQLæ‰©å±•ç‰¹æ€§

### 3.1 æ•°æ®ç±»å‹æ‰©å±•

```sql
-- JSONæ•°æ®ç±»å‹
CREATE TABLE user_profiles (
    user_id INTEGER PRIMARY KEY,
    profile JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- æ•°ç»„ç±»å‹
CREATE TABLE products (
    product_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    tags TEXT[],
    prices DECIMAL(10,2)[]
);

-- èŒƒå›´ç±»å‹
CREATE TABLE events (
    event_id INTEGER PRIMARY KEY,
    name VARCHAR(100),
    duration TSRANGE,
    price_range NUMRANGE
);
```

### 3.2 å‡½æ•°å’Œæ“ä½œç¬¦

```sql
-- è‡ªå®šä¹‰å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_bonus(emp_salary DECIMAL, performance_score INTEGER)
RETURNS DECIMAL AS $$
BEGIN
    RETURN emp_salary * (performance_score / 100.0) * 0.1;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨å‡½æ•°
SELECT name, salary, calculate_bonus(salary, 85) as bonus
FROM employees;

-- JSONæ“ä½œç¬¦
SELECT profile->>'name' as user_name,
       profile->'address'->>'city' as city
FROM user_profiles
WHERE profile ? 'address';
```

### 3.3 ç´¢å¼•ç±»å‹

```sql
-- GINç´¢å¼•ï¼ˆç”¨äºæ•°ç»„å’ŒJSONï¼‰
CREATE INDEX idx_profile_gin ON user_profiles USING GIN (profile);
CREATE INDEX idx_tags_gin ON products USING GIN (tags);

-- GiSTç´¢å¼•ï¼ˆç”¨äºå‡ ä½•å’ŒèŒƒå›´ç±»å‹ï¼‰
CREATE INDEX idx_duration_gist ON events USING GIST (duration);

-- éƒ¨åˆ†ç´¢å¼•
CREATE INDEX idx_high_salary ON employees (salary) WHERE salary > 100000;

-- è¡¨è¾¾å¼ç´¢å¼•
CREATE INDEX idx_name_lower ON employees (LOWER(name));
```

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä½¿ç”¨EXPLAINåˆ†ææŸ¥è¯¢è®¡åˆ’
EXPLAIN (ANALYZE, BUFFERS)
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000;

-- ä½¿ç”¨LIMITä¼˜åŒ–
SELECT name, salary
FROM employees
ORDER BY salary DESC
LIMIT 10;

-- é¿å…SELECT *
SELECT emp_id, name, salary  -- åªé€‰æ‹©éœ€è¦çš„åˆ—
FROM employees
WHERE dept_id = 1;
```

### 4.2 ç´¢å¼•ä¼˜åŒ–

```sql
-- å¤åˆç´¢å¼•
CREATE INDEX idx_emp_dept_salary ON employees (dept_id, salary);

-- è¦†ç›–ç´¢å¼•
CREATE INDEX idx_emp_covering ON employees (dept_id) INCLUDE (name, salary);

-- ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;
```

## 5. ç›¸å…³æ¦‚å¿µ

### 5.1 ä¸Šä½æ¦‚å¿µ

- **æŸ¥è¯¢è¯­è¨€**: æ›´å¹¿æ³›çš„è¯­è¨€ç±»åˆ«
- **å…³ç³»æ•°æ®åº“**: æ•°æ®æ¨¡å‹ç±»å‹
- **å£°æ˜å¼è¯­è¨€**: ç¼–ç¨‹èŒƒå¼

### 5.2 ä¸‹ä½æ¦‚å¿µ

- **DDL**: æ•°æ®å®šä¹‰è¯­è¨€
- **DML**: æ•°æ®æ“ä½œè¯­è¨€
- **DQL**: æ•°æ®æŸ¥è¯¢è¯­è¨€
- **DCL**: æ•°æ®æ§åˆ¶è¯­è¨€
- **TCL**: äº‹åŠ¡æ§åˆ¶è¯­è¨€

### 5.3 å¹³è¡Œæ¦‚å¿µ

- **NoSQLæŸ¥è¯¢è¯­è¨€**: éå…³ç³»å‹æŸ¥è¯¢è¯­è¨€
- **å…³ç³»ä»£æ•°**: æ•°å­¦åŸºç¡€
- **å…³ç³»æ¼”ç®—**: é€»è¾‘åŸºç¡€

## 6. ç›¸å…³æ–‡æ¡£

- [å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–](./01.06-å­˜å‚¨ç®¡ç†ä¸æ•°æ®æŒä¹…åŒ–.md) - åˆ—å­˜å‚¨æ¶æ„ï¼ˆCREATE FOREIGN TABLEç”¨äºåˆ—å­˜å‚¨ï¼‰ğŸ†•
- [å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º](./01.02-å…³ç³»æ•°æ®æ¨¡å‹ä¸ç†è®º.md) - SQLçš„å…³ç³»æ¨¡å‹åŸºç¡€
- [äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§](./01.04-äº‹åŠ¡ç®¡ç†ä¸ACIDç‰¹æ€§.md) - äº‹åŠ¡æ§åˆ¶è¯­è¨€ï¼ˆTCLï¼‰
- [ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–](../02-æŸ¥è¯¢å¤„ç†/02.02-ç´¢å¼•ç»“æ„ä¸ä¼˜åŒ–.md) - ç´¢å¼•å®šä¹‰å’Œä¼˜åŒ–

## 7. å‚è€ƒæ–‡çŒ®

1. ISO/IEC 9075:2023. Information technology â€” Database languages â€” SQL
2. PostgreSQL Global Development Group. (2024). PostgreSQL 16.2 Documentation. <https://www.postgresql.org/docs/16/>
3. Codd, E. F. (1970). A relational model of data for large shared data banks. Communications of the ACM, 13(6), 377-387.
4. Date, C. J. (2003). An Introduction to Database Systems (8th ed.). Addison-Wesley.

## 8. Wikidataå¯¹é½

- **Wikidata ID**: Q202218
- **ç›¸å…³å±æ€§**:
  - P31: Q202218 (instance of: programming language)
  - P178: Q9366 (developer: PostgreSQL Global Development Group)
  - P348: SQL:2023 (software version)
  - P856: <https://www.postgresql.org/docs/current/sql.html> (official website)
- **å¤–éƒ¨é“¾æ¥**:
  - <https://www.postgresql.org/docs/current/sql.html>
  - <https://www.iso.org/standard/76583.html>
