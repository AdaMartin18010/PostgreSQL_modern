# æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-ç¼–æ’å®¹é”™ä¸æ•…éšœæ¢å¤çš„å½¢å¼åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-ç¼–æ’å®¹é”™ä¸æ•…éšœæ¢å¤çš„å½¢å¼åŒ–](#æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹-ç¼–æ’å®¹é”™ä¸æ•…éšœæ¢å¤çš„å½¢å¼åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°](#10-æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 æ•…éšœæ¢å¤](#21-æ•…éšœæ¢å¤)
    - [2.2 å®¹é”™æœºåˆ¶](#22-å®¹é”™æœºåˆ¶)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 å®¹é”™å½¢å¼åŒ–](#31-å®¹é”™å½¢å¼åŒ–)
  - [4. å®šç†ä¸è¯æ˜](#4-å®šç†ä¸è¯æ˜)
    - [4.1 æ•…éšœæ¢å¤æ­£ç¡®æ€§å®šç†](#41-æ•…éšœæ¢å¤æ­£ç¡®æ€§å®šç†)
  - [5. å®é™…åº”ç”¨](#5-å®é™…åº”ç”¨)
    - [5.1 PostgreSQL 18ç¼–æ’å®¹é”™å®ç°](#51-postgresql-18ç¼–æ’å®¹é”™å®ç°)
      - [5.1.1 å®¹é”™ç³»ç»Ÿ](#511-å®¹é”™ç³»ç»Ÿ)
    - [5.2 å®é™…åº”ç”¨åœºæ™¯](#52-å®é™…åº”ç”¨åœºæ™¯)
      - [åœºæ™¯1ï¼šè‡ªåŠ¨æ•…éšœæ¢å¤](#åœºæ™¯1è‡ªåŠ¨æ•…éšœæ¢å¤)
      - [åœºæ™¯2ï¼šæ£€æŸ¥ç‚¹ç­–ç•¥](#åœºæ™¯2æ£€æŸ¥ç‚¹ç­–ç•¥)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)
    - [5.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#51-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#61-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [6.2 PostgreSQLå®ç°ç›¸å…³](#62-postgresqlå®ç°ç›¸å…³)
    - [6.3 ç›¸å…³æ–‡æ¡£](#63-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 æ•°æ®åº“æ•°æ®ç¼–æ’æ¨¡å‹å·¥ä½œåŸç†æ¦‚è¿°

**ç¼–æ’å®¹é”™**ï¼š

ç¼–æ’å®¹é”™é€šè¿‡æ•…éšœæ¢å¤æœºåˆ¶æ¥ä¿è¯ç³»ç»Ÿå¯é æ€§ã€‚

**å®¹é”™æ¨¡å‹æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((ç¼–æ’å®¹é”™))
    æ•…éšœç±»å‹
      èŠ‚ç‚¹æ•…éšœ
      ç½‘ç»œæ•…éšœ
      æ•°æ®æ•…éšœ
    æ¢å¤ç­–ç•¥
      é‡è¯•
      å›æ»š
      è¡¥å¿
    å®¹é”™æœºåˆ¶
      æ£€æŸ¥ç‚¹
      çŠ¶æ€ä¿å­˜
      æ•…éšœè½¬ç§»
```

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **æ•…éšœç±»å‹**ï¼šå„ç§æ•…éšœç±»å‹
- **æ¢å¤ç­–ç•¥**ï¼šæ•…éšœæ¢å¤æ–¹æ³•
- **å®é™…åº”ç”¨**ï¼šå®¹é”™ç³»ç»Ÿ

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 æ•…éšœæ¢å¤

**æ¢å¤ç­–ç•¥**ï¼š

```haskell
-- æ•…éšœæ¢å¤
recover :: Failure -> State -> State
recover failure state =
    case failure.type of
        Transient -> retry(state)
        Permanent -> rollback(state)
        Partial -> compensate(state)
```

### 2.2 å®¹é”™æœºåˆ¶

**å®¹é”™æ–¹æ³•**ï¼š

| æ–¹æ³• | å®šä¹‰ | é€‚ç”¨åœºæ™¯ |
|------|------|---------|
| **é‡è¯•** | é‡æ–°æ‰§è¡Œ | ä¸´æ—¶æ•…éšœ |
| **å›æ»š** | å›é€€çŠ¶æ€ | æ°¸ä¹…æ•…éšœ |
| **è¡¥å¿** | è¡¥å¿æ“ä½œ | éƒ¨åˆ†æ•…éšœ |

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 å®¹é”™å½¢å¼åŒ–

**å®¹é”™**ï¼š

```haskell
-- å®¹é”™å½¢å¼åŒ–
FaultTolerant = (S, F, R)
where
    S = state set
    F = failure set
    R = recovery function: F Ã— S â†’ S

-- æ•…éšœæ¢å¤
recover :: Failure -> State -> State
recover failure state =
    case failure.type of
        Transient -> retry(state)
        Permanent -> rollback(state)
        Partial -> compensate(state)
```

---

## 4. å®šç†ä¸è¯æ˜

### 4.1 æ•…éšœæ¢å¤æ­£ç¡®æ€§å®šç†

**å®šç†1ï¼ˆæ•…éšœæ¢å¤æ­£ç¡®æ€§ï¼‰**ï¼š

å¯¹äºå®¹é”™ç³»ç»ŸFaultTolerant = (S, F, R)å’Œæ•…éšœf âˆˆ Fï¼Œå¦‚æœæ¢å¤å‡½æ•°Ræ­£ç¡®ï¼Œåˆ™æ¢å¤åçš„çŠ¶æ€æ˜¯æœ‰æ•ˆçš„ï¼Œä¸”ç³»ç»Ÿå¯ä»¥ç»§ç»­æ‰§è¡Œã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š

è®¾å®¹é”™ç³»ç»ŸFaultTolerant = (S, F, R)ï¼Œæ•…éšœf âˆˆ Fï¼ŒçŠ¶æ€s âˆˆ Sã€‚å¦‚æœæ¢å¤å‡½æ•°Ræ­£ç¡®ï¼Œåˆ™ï¼š

```text
valid(R(f, s)) âˆ§ canContinue(R(f, s))
```

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šæ¢å¤å‡½æ•°æ­£ç¡®æ€§**ï¼š

- æ¢å¤å‡½æ•°Rå°†æ•…éšœçŠ¶æ€æ¢å¤åˆ°æœ‰æ•ˆçŠ¶æ€
- å¯¹äºä¸´æ—¶æ•…éšœï¼šretry(s)è¿”å›é‡è¯•åçš„æœ‰æ•ˆçŠ¶æ€
- å¯¹äºæ°¸ä¹…æ•…éšœï¼šrollback(s)å›é€€åˆ°ä¹‹å‰çš„æœ‰æ•ˆçŠ¶æ€
- å¯¹äºéƒ¨åˆ†æ•…éšœï¼šcompensate(s)è¡¥å¿æ“ä½œï¼Œæ¢å¤åˆ°ä¸€è‡´çŠ¶æ€

**æ­¥éª¤2ï¼šçŠ¶æ€æœ‰æ•ˆæ€§**ï¼š

- æ¢å¤åçš„çŠ¶æ€valid(R(f, s))ï¼Œå› ä¸ºæ¢å¤å‡½æ•°ç¡®ä¿çŠ¶æ€æœ‰æ•ˆ

**æ­¥éª¤3ï¼šå¯ç»§ç»­æ€§**ï¼š

- æ¢å¤åçš„çŠ¶æ€canContinue(R(f, s))ï¼Œå› ä¸ºç³»ç»Ÿå¯ä»¥ä»æ¢å¤çŠ¶æ€ç»§ç»­æ‰§è¡Œ

**æ­¥éª¤4ï¼šç»“è®º**ï¼š

- æ•…éšœæ¢å¤æ­£ç¡®æ€§å®šç†å¾—è¯

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[æ•…éšœæ¢å¤æ­£ç¡®æ€§å®šç†] --> B[æ¢å¤å‡½æ•°æ­£ç¡®æ€§]
    B --> C[çŠ¶æ€æœ‰æ•ˆæ€§]
    C --> D[å¯ç»§ç»­æ€§]
    D --> E[å®šç†å¾—è¯]

    style A fill:#FFD700
    style E fill:#90EE90
```

---

## 5. å®é™…åº”ç”¨

### 5.1 PostgreSQL 18ç¼–æ’å®¹é”™å®ç°

#### 5.1.1 å®¹é”™ç³»ç»Ÿ

**PostgreSQL 18å®¹é”™æ”¯æŒ**ï¼š

PostgreSQL 18é€šè¿‡äº‹åŠ¡ã€æ£€æŸ¥ç‚¹å’Œè¡¥å¿æ“ä½œå®ç°ç¼–æ’å®¹é”™ã€‚

**å®¹é”™ç³»ç»Ÿ**ï¼š

```sql
-- åœºæ™¯ï¼šç¼–æ’å®¹é”™ç³»ç»Ÿ
-- 1. åˆ›å»ºæ£€æŸ¥ç‚¹è¡¨
CREATE TABLE orchestration_checkpoints (
    checkpoint_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    orchestration_id UUID NOT NULL,
    execution_id UUID NOT NULL,
    checkpoint_time TIMESTAMPTZ DEFAULT NOW(),
    state_data JSONB NOT NULL,
    task_progress JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_checkpoints_exec ON orchestration_checkpoints(execution_id, checkpoint_time DESC);

-- 2. æ•…éšœè®°å½•è¡¨
CREATE TABLE orchestration_failures (
    failure_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    execution_id UUID NOT NULL,
    failure_type VARCHAR(50) NOT NULL,  -- 'TRANSIENT', 'PERMANENT', 'PARTIAL'
    failure_message TEXT,
    failure_timestamp TIMESTAMPTZ DEFAULT NOW(),
    recovery_strategy VARCHAR(50),
    recovered BOOLEAN DEFAULT FALSE
);

CREATE INDEX idx_failures_exec ON orchestration_failures(execution_id, failure_timestamp DESC);

-- 3. æ•…éšœæ¢å¤å‡½æ•°
CREATE OR REPLACE FUNCTION recover_from_failure(
    p_execution_id UUID,
    p_failure_type VARCHAR
)
RETURNS UUID AS $$
DECLARE
    v_checkpoint_id UUID;
    v_state_data JSONB;
BEGIN
    -- é€‰æ‹©æœ€è¿‘çš„æ£€æŸ¥ç‚¹
    SELECT checkpoint_id, state_data INTO v_checkpoint_id, v_state_data
    FROM orchestration_checkpoints
    WHERE execution_id = p_execution_id
    ORDER BY checkpoint_time DESC
    LIMIT 1;

    IF v_checkpoint_id IS NULL THEN
        RAISE EXCEPTION 'No checkpoint found for execution: %', p_execution_id;
    END IF;

    -- æ ¹æ®æ•…éšœç±»å‹é€‰æ‹©æ¢å¤ç­–ç•¥
    CASE p_failure_type
        WHEN 'TRANSIENT' THEN
            -- é‡è¯•ï¼šä»æ£€æŸ¥ç‚¹ç»§ç»­æ‰§è¡Œ
            PERFORM retry_from_checkpoint(v_checkpoint_id, v_state_data);
        WHEN 'PERMANENT' THEN
            -- å›æ»šï¼šæ¢å¤åˆ°æ£€æŸ¥ç‚¹çŠ¶æ€
            PERFORM rollback_to_checkpoint(v_checkpoint_id, v_state_data);
        WHEN 'PARTIAL' THEN
            -- è¡¥å¿ï¼šæ‰§è¡Œè¡¥å¿æ“ä½œ
            PERFORM compensate_from_checkpoint(v_checkpoint_id, v_state_data);
    END CASE;

    RETURN v_checkpoint_id;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 å®é™…åº”ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šè‡ªåŠ¨æ•…éšœæ¢å¤

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

ç¼–æ’ç³»ç»Ÿéœ€è¦è‡ªåŠ¨æ£€æµ‹æ•…éšœå¹¶æ¢å¤ï¼Œä¿è¯ç³»ç»Ÿå¯ç”¨æ€§ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šè‡ªåŠ¨æ•…éšœæ¢å¤
-- 1. æ•…éšœæ£€æµ‹å’Œæ¢å¤å‡½æ•°
CREATE OR REPLACE FUNCTION auto_recover_failures()
RETURNS TABLE (
    recovered_count BIGINT
) AS $$
DECLARE
    v_failure RECORD;
    v_recovered_count BIGINT := 0;
BEGIN
    FOR v_failure IN
        SELECT * FROM orchestration_failures
        WHERE recovered = FALSE
          AND failure_timestamp >= NOW() - INTERVAL '1 hour'
        ORDER BY failure_timestamp
        FOR UPDATE SKIP LOCKED
    LOOP
        BEGIN
            -- å°è¯•æ¢å¤
            PERFORM recover_from_failure(
                v_failure.execution_id,
                v_failure.failure_type
            );

            -- æ ‡è®°ä¸ºå·²æ¢å¤
            UPDATE orchestration_failures
            SET recovered = TRUE, recovery_strategy = 'AUTO'
            WHERE failure_id = v_failure.failure_id;

            v_recovered_count := v_recovered_count + 1;
        EXCEPTION WHEN OTHERS THEN
            -- æ¢å¤å¤±è´¥ï¼Œè®°å½•é”™è¯¯
            UPDATE orchestration_failures
            SET recovery_strategy = 'FAILED', recovered = FALSE
            WHERE failure_id = v_failure.failure_id;
        END;
    END LOOP;

    RETURN QUERY SELECT v_recovered_count;
END;
$$ LANGUAGE plpgsql;

-- 2. å®šæœŸæ‰§è¡Œæ¢å¤ï¼ˆä½¿ç”¨pg_cronï¼‰
-- SELECT cron.schedule('auto-recover-failures', '*/5 * * * *',
--     'SELECT auto_recover_failures();');
```

#### åœºæ™¯2ï¼šæ£€æŸ¥ç‚¹ç­–ç•¥

**ä¸šåŠ¡èƒŒæ™¯**ï¼š

éœ€è¦åœ¨å…³é”®æ­¥éª¤åˆ›å»ºæ£€æŸ¥ç‚¹ï¼Œæ”¯æŒå¿«é€Ÿæ•…éšœæ¢å¤ã€‚

**PostgreSQL 18å®ç°**ï¼š

```sql
-- åœºæ™¯ï¼šæ£€æŸ¥ç‚¹ç­–ç•¥
-- 1. åˆ›å»ºæ£€æŸ¥ç‚¹å‡½æ•°
CREATE OR REPLACE FUNCTION create_checkpoint(
    p_execution_id UUID,
    p_task_id UUID
)
RETURNS UUID AS $$
DECLARE
    v_checkpoint_id UUID;
    v_state_data JSONB;
BEGIN
    -- æ”¶é›†å½“å‰çŠ¶æ€
    SELECT jsonb_build_object(
        'execution_id', p_execution_id,
        'task_id', p_task_id,
        'completed_tasks', (
            SELECT jsonb_agg(task_id)
            FROM orchestration_tasks
            WHERE execution_id = p_execution_id
              AND status = 'COMPLETED'
        ),
        'pending_tasks', (
            SELECT jsonb_agg(task_id)
            FROM orchestration_tasks
            WHERE execution_id = p_execution_id
              AND status = 'PENDING'
        ),
        'state', 'CHECKPOINT'
    ) INTO v_state_data;

    -- åˆ›å»ºæ£€æŸ¥ç‚¹
    INSERT INTO orchestration_checkpoints (
        orchestration_id, execution_id, state_data, task_progress
    )
    SELECT
        orchestration_id, p_execution_id, v_state_data,
        jsonb_build_object('task_id', p_task_id, 'status', 'CHECKPOINT')
    FROM orchestration_executions
    WHERE execution_id = p_execution_id
    RETURNING checkpoint_id INTO v_checkpoint_id;

    RETURN v_checkpoint_id;
END;
$$ LANGUAGE plpgsql;

-- 2. åœ¨å…³é”®ä»»åŠ¡å®Œæˆåè‡ªåŠ¨åˆ›å»ºæ£€æŸ¥ç‚¹
CREATE OR REPLACE FUNCTION trigger_checkpoint()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'COMPLETED' AND OLD.status != 'COMPLETED' THEN
        -- å…³é”®ä»»åŠ¡å®Œæˆååˆ›å»ºæ£€æŸ¥ç‚¹
        PERFORM create_checkpoint(NEW.execution_id, NEW.task_id);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

---

## 6. ç›¸å…³æ–‡æ¡£

### 5.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [å½¢å¼è¯­è¨€ä¸è¯æ˜ï¼šæ€»è®º](./1.1.25-å½¢å¼è¯­è¨€ä¸è¯æ˜-æ€»è®º.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](./README.md)

---

## 7. å‚è€ƒæ–‡çŒ®

### 6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Lamport, L., et al. (1982). "The Byzantine Generals Problem."**
  - ä¼šè®®: TOPLAS 1982
  - **é‡è¦æ€§**: æ‹œå åº­æ•…éšœçš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: å®šä¹‰äº†æ•…éšœæ¨¡å‹

- **Cristian, F. (1991). "Understanding Fault-Tolerant Distributed Systems."**
  - ä¼šè®®: CACM 1991
  - **é‡è¦æ€§**: å®¹é”™åˆ†å¸ƒå¼ç³»ç»Ÿç»¼è¿°
  - **æ ¸å¿ƒè´¡çŒ®**: æ€»ç»“äº†æ•…éšœæ¢å¤ç­–ç•¥

### 6.2 PostgreSQLå®ç°ç›¸å…³

- **PostgreSQLå®˜æ–¹æ–‡æ¡£ - é«˜å¯ç”¨](<https://www.postgresql.org/docs/current/high-availability.html>)**
  - PostgreSQLé«˜å¯ç”¨å®ç°è¯´æ˜

### 6.3 ç›¸å…³æ–‡æ¡£

- [æ•°æ®åº“å®¹é”™ä¸é«˜å¯ç”¨-æ•…éšœæ¨¡å‹ä¸æ¢å¤ç­–ç•¥çš„å½¢å¼åŒ–](../06-å­˜å‚¨ä¸æ¢å¤/06.08-æ•°æ®åº“å®¹é”™ä¸é«˜å¯ç”¨-æ•…éšœæ¨¡å‹ä¸æ¢å¤ç­–ç•¥çš„å½¢å¼åŒ–.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: âœ… å†…å®¹å·²å®Œæˆ
