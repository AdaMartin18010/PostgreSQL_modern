# æ•°æ®åº“ç¼“å­˜ç­–ç•¥-å·¥ä½œé›†ç†è®ºä¸æœ€ä¼˜æ›¿æ¢ç®—æ³•

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: ğŸŸ¡ æ¡†æ¶å·²åˆ›å»ºï¼Œå†…å®¹å¾…å®Œå–„

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“ç¼“å­˜ç­–ç•¥-å·¥ä½œé›†ç†è®ºä¸æœ€ä¼˜æ›¿æ¢ç®—æ³•](#æ•°æ®åº“ç¼“å­˜ç­–ç•¥-å·¥ä½œé›†ç†è®ºä¸æœ€ä¼˜æ›¿æ¢ç®—æ³•)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 æ•°æ®åº“ç¼“å­˜ç­–ç•¥å·¥ä½œåŸç†æ¦‚è¿°](#10-æ•°æ®åº“ç¼“å­˜ç­–ç•¥å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 å·¥ä½œé›†ç†è®º](#21-å·¥ä½œé›†ç†è®º)
    - [2.2 æ›¿æ¢ç®—æ³•](#22-æ›¿æ¢ç®—æ³•)
    - [2.3 æœ€ä¼˜æ›¿æ¢ç®—æ³•](#23-æœ€ä¼˜æ›¿æ¢ç®—æ³•)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 å·¥ä½œé›†å½¢å¼åŒ–](#31-å·¥ä½œé›†å½¢å¼åŒ–)
    - [3.2 æ›¿æ¢ç®—æ³•å½¢å¼åŒ–](#32-æ›¿æ¢ç®—æ³•å½¢å¼åŒ–)
    - [3.3 æœ€ä¼˜æ€§å½¢å¼åŒ–](#33-æœ€ä¼˜æ€§å½¢å¼åŒ–)
  - [4. å®é™…åº”ç”¨](#4-å®é™…åº”ç”¨)
    - [4.1 PostgreSQLç¼“å­˜](#41-postgresqlç¼“å­˜)
    - [4.2 é¢„å–ç­–ç•¥](#42-é¢„å–ç­–ç•¥)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)
    - [5.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#51-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [6. å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)
    - [6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#61-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [6.2 æ›¿æ¢ç®—æ³•ç›¸å…³](#62-æ›¿æ¢ç®—æ³•ç›¸å…³)
    - [6.3 PostgreSQLå®ç°ç›¸å…³](#63-postgresqlå®ç°ç›¸å…³)
    - [6.4 ç›¸å…³æ–‡æ¡£](#64-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 æ•°æ®åº“ç¼“å­˜ç­–ç•¥å·¥ä½œåŸç†æ¦‚è¿°

**ç¼“å­˜ç­–ç•¥**ï¼š

æ•°æ®åº“ç¼“å­˜ä½¿ç”¨å·¥ä½œé›†ç†è®ºæ¥é¢„æµ‹è®¿é—®æ¨¡å¼ï¼Œå¹¶ä½¿ç”¨æœ€ä¼˜æ›¿æ¢ç®—æ³•ï¼ˆå¦‚LRUã€LFUï¼‰æ¥ç®¡ç†ç¼“å­˜ç©ºé—´ã€‚

**ç¼“å­˜ç­–ç•¥æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((ç¼“å­˜ç­–ç•¥))
    å·¥ä½œé›†ç†è®º
      å·¥ä½œé›†å®šä¹‰
      å·¥ä½œé›†å¤§å°
      å±€éƒ¨æ€§åŸç†
    æ›¿æ¢ç®—æ³•
      LRUæœ€è¿‘æœ€å°‘ä½¿ç”¨
      LFUæœ€ä¸ç»å¸¸ä½¿ç”¨
      FIFOå…ˆè¿›å…ˆå‡º
      OPTæœ€ä¼˜ç®—æ³•
    ç¼“å­˜ç®¡ç†
      é¢„å–ç­–ç•¥
      å†™å›ç­–ç•¥
      ä¸€è‡´æ€§ä¿è¯
```

**ç¼“å­˜å·¥ä½œæµç¨‹**ï¼š

```mermaid
flowchart TD
    A[æ•°æ®è¯·æ±‚] --> B{åœ¨ç¼“å­˜ä¸­?}
    B -->|æ˜¯| C[ç¼“å­˜å‘½ä¸­]
    B -->|å¦| D[ç¼“å­˜æœªå‘½ä¸­]
    D --> E[ä»ç£ç›˜åŠ è½½]
    E --> F[æ›´æ–°ç¼“å­˜]
    F --> G{ç¼“å­˜æ»¡?}
    G -->|æ˜¯| H[æ›¿æ¢ç®—æ³•]
    G -->|å¦| I[ç›´æ¥æ’å…¥]
    H --> J[é€‰æ‹©æ›¿æ¢é¡µ]
    J --> F
    C --> K[è¿”å›æ•°æ®]
    I --> K

    style A fill:#FFD700
    style C fill:#90EE90
    style D fill:#FF6B6B
```

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **å·¥ä½œé›†ç†è®º**ï¼šå·¥ä½œé›†çš„å®šä¹‰å’Œæ€§è´¨
- **æ›¿æ¢ç®—æ³•**ï¼šLRUã€LFUã€OPTç­‰ç®—æ³•
- **æœ€ä¼˜æ€§åˆ†æ**ï¼šæ›¿æ¢ç®—æ³•çš„æœ€ä¼˜æ€§è¯æ˜
- **å®é™…åº”ç”¨**ï¼šPostgreSQLç¼“å­˜å®ç°

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 å·¥ä½œé›†ç†è®º

**å·¥ä½œé›†å®šä¹‰**ï¼š

```haskell
-- å·¥ä½œé›†
workingSet :: TimeWindow -> AccessSequence -> Set Page
workingSet window accesses =
    let recentAccesses = take window accesses
    in set(recentAccesses)

-- å·¥ä½œé›†å¤§å°
workingSetSize :: TimeWindow -> AccessSequence -> Int
workingSetSize window accesses =
    size(workingSet window accesses)
```

**å·¥ä½œé›†æ€§è´¨**ï¼š

```haskell
-- å·¥ä½œé›†å•è°ƒæ€§
workingSetMonotonic :: TimeWindow1 -> TimeWindow2 -> Bool
workingSetMonotonic w1 w2 =
    if w1 <= w2 then
        workingSet w1 âŠ† workingSet w2
    else
        True
```

### 2.2 æ›¿æ¢ç®—æ³•

**LRUç®—æ³•**ï¼š

```haskell
-- LRUç¼“å­˜
data LRUCache = LRUCache {
    pages :: Map Page Timestamp,
    capacity :: Int
}

-- LRUæ›¿æ¢
lruReplace :: LRUCache -> Page -> LRUCache
lruReplace cache newPage =
    if size(cache.pages) >= cache.capacity then
        let oldestPage = findOldest(cache.pages)
            newPages = remove oldestPage cache.pages
        in cache {pages = insert newPage (currentTime()) newPages}
    else
        cache {pages = insert newPage (currentTime()) cache.pages}
```

**æ›¿æ¢ç®—æ³•å¯¹æ¯”**ï¼š

| ç®—æ³• | ç­–ç•¥ | å¤æ‚åº¦ | å‘½ä¸­ç‡ | é€‚ç”¨åœºæ™¯ |
|------|------|--------|--------|---------|
| **LRU** | æœ€è¿‘æœ€å°‘ä½¿ç”¨ | O(1) | é«˜ | é€šç”¨ |
| **LFU** | æœ€ä¸ç»å¸¸ä½¿ç”¨ | O(log n) | ä¸­ | ç¨³å®šè®¿é—®æ¨¡å¼ |
| **FIFO** | å…ˆè¿›å…ˆå‡º | O(1) | ä½ | ç®€å•åœºæ™¯ |
| **OPT** | æœ€ä¼˜ç®—æ³• | O(nÂ²) | æœ€é«˜ | ç†è®ºåˆ†æ |

### 2.3 æœ€ä¼˜æ›¿æ¢ç®—æ³•

**OPTç®—æ³•**ï¼š

```haskell
-- OPTç®—æ³•ï¼ˆç†è®ºæœ€ä¼˜ï¼‰
optReplace :: Cache -> AccessSequence -> Page
optReplace cache futureAccesses =
    let pagesInCache = keys(cache.pages)
        futureAccesses = drop (currentIndex) allAccesses
        replacePage = findPageNotUsedLongest(pagesInCache, futureAccesses)
    in replacePage
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 å·¥ä½œé›†å½¢å¼åŒ–

**å·¥ä½œé›†**ï¼š

```haskell
-- å·¥ä½œé›†å½¢å¼åŒ–
W(t, Î”) = {pages accessed in time window [t-Î”, t]}
where
    t = current time
    Î” = time window size
```

### 3.2 æ›¿æ¢ç®—æ³•å½¢å¼åŒ–

**æ›¿æ¢ç®—æ³•**ï¼š

```haskell
-- æ›¿æ¢ç®—æ³•å½¢å¼åŒ–
ReplaceAlgorithm = (C, R, f)
where
    C = cache state
    R = replacement rule
    f: C Ã— Request â†’ C' = replacement function
```

### 3.3 æœ€ä¼˜æ€§å½¢å¼åŒ–

**æœ€ä¼˜æ›¿æ¢**ï¼š

```haskell
-- æœ€ä¼˜æ›¿æ¢
optimal(replace) =
    forall access sequence A:
        missCount(replace, A) â‰¤ missCount(anyReplace, A)
```

---

## 4. å®é™…åº”ç”¨

### 4.1 PostgreSQLç¼“å­˜

**PostgreSQLå…±äº«ç¼“å†²åŒº**ï¼š

```sql
-- æŸ¥çœ‹å…±äº«ç¼“å†²åŒºé…ç½®
SHOW shared_buffers;
SHOW effective_cache_size;

-- æŸ¥çœ‹ç¼“å­˜ç»Ÿè®¡
SELECT * FROM pg_stat_bgwriter;

-- æŸ¥çœ‹è¡¨ç¼“å­˜ç»Ÿè®¡
SELECT
    schemaname,
    relname,
    heap_blks_read,
    heap_blks_hit,
    ROUND(100.0 * heap_blks_hit / NULLIF(heap_blks_hit + heap_blks_read, 0), 2) AS hit_rate
FROM pg_statio_user_tables
ORDER BY heap_blks_read DESC;
```

**ç¼“å­˜å‘½ä¸­ç‡ä¼˜åŒ–**ï¼š

```sql
-- è°ƒæ•´å…±äº«ç¼“å†²åŒº
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';

-- æŸ¥çœ‹ç¼“å­˜å‘½ä¸­ç‡
SELECT
    SUM(heap_blks_hit) / NULLIF(SUM(heap_blks_hit) + SUM(heap_blks_read), 0) * 100 AS cache_hit_rate
FROM pg_statio_user_tables;
```

### 4.2 é¢„å–ç­–ç•¥

**é¡ºåºé¢„å–**ï¼š

```sql
-- å¯ç”¨é¡ºåºæ‰«æé¢„å–
ALTER SYSTEM SET effective_io_concurrency = 2;

-- æŸ¥çœ‹I/Oç»Ÿè®¡
SELECT * FROM pg_stat_io;
```

---

## 5. ç›¸å…³æ–‡æ¡£

### 5.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

## 6. å‚è€ƒæ–‡çŒ®

### 6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Denning, P. J. (1968). "The Working Set Model for Program Behavior."**
  - æœŸåˆŠ: Communications of the ACM 1968
  - **é‡è¦æ€§**: å·¥ä½œé›†ç†è®ºçš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†å·¥ä½œé›†æ¨¡å‹
  - **æ‰¹åˆ¤æ€§åˆ†æ**: å·¥ä½œé›†ç†è®ºä¸ºç¼“å­˜ç®¡ç†æä¾›äº†ç†è®ºåŸºç¡€ï¼Œä½†å®é™…åº”ç”¨ä¸­éœ€è¦ç»“åˆå…·ä½“è®¿é—®æ¨¡å¼

- **Belady, L. A. (1966). "A Study of Replacement Algorithms for a Virtual-Storage Computer."**
  - æœŸåˆŠ: IBM Systems Journal 1966
  - **é‡è¦æ€§**: é¡µé¢æ›¿æ¢ç®—æ³•çš„ç»å…¸ç ”ç©¶
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†OPTç®—æ³•å’ŒBeladyå¼‚å¸¸

### 6.2 æ›¿æ¢ç®—æ³•ç›¸å…³

- **O'Neil, E. J., et al. (1993). "The LRU-K Page Replacement Algorithm for Database Disk Buffering."**
  - ä¼šè®®: SIGMOD 1993
  - **é‡è¦æ€§**: LRU-Kç®—æ³•çš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†æ”¹è¿›çš„LRUç®—æ³•

### 6.3 PostgreSQLå®ç°ç›¸å…³

- **[PostgreSQLå®˜æ–¹æ–‡æ¡£ - å…±äº«ç¼“å†²åŒº](<https://www.postgresql.org/docs/current/runtime-config-resource.html#GUC-SHARED-BUFFERS>)**
  - PostgreSQLå…±äº«ç¼“å†²åŒºé…ç½®è¯´æ˜

### 6.4 ç›¸å…³æ–‡æ¡£

- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: ğŸŸ¡ æ¡†æ¶å·²åˆ›å»ºï¼Œå†…å®¹å¾…å®Œå–„
