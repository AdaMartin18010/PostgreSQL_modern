# æ•°æ®åº“åŒºå—é“¾æ¨¡å‹-åˆ†å¸ƒå¼è´¦æœ¬ä¸å…±è¯†æœºåˆ¶çš„å½¢å¼åŒ–

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: ğŸŸ¡ æ¡†æ¶å·²åˆ›å»ºï¼Œå†…å®¹å¾…å®Œå–„

---

## ğŸ“‹ ç›®å½•

- [æ•°æ®åº“åŒºå—é“¾æ¨¡å‹-åˆ†å¸ƒå¼è´¦æœ¬ä¸å…±è¯†æœºåˆ¶çš„å½¢å¼åŒ–](#æ•°æ®åº“åŒºå—é“¾æ¨¡å‹-åˆ†å¸ƒå¼è´¦æœ¬ä¸å…±è¯†æœºåˆ¶çš„å½¢å¼åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 åŒºå—é“¾æ•°æ®åº“å·¥ä½œåŸç†æ¦‚è¿°](#10-åŒºå—é“¾æ•°æ®åº“å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 åˆ†å¸ƒå¼è´¦æœ¬](#21-åˆ†å¸ƒå¼è´¦æœ¬)
    - [2.2 å…±è¯†æœºåˆ¶](#22-å…±è¯†æœºåˆ¶)
    - [2.3 æ•°æ®æ¨¡å‹](#23-æ•°æ®æ¨¡å‹)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 åŒºå—é“¾å½¢å¼åŒ–](#31-åŒºå—é“¾å½¢å¼åŒ–)
    - [3.2 å…±è¯†æœºåˆ¶å½¢å¼åŒ–](#32-å…±è¯†æœºåˆ¶å½¢å¼åŒ–)
    - [3.3 å®‰å…¨æ€§å½¢å¼åŒ–](#33-å®‰å…¨æ€§å½¢å¼åŒ–)
  - [4. å®é™…åº”ç”¨](#4-å®é™…åº”ç”¨)
    - [4.1 PostgreSQLåŒºå—é“¾å®ç°](#41-postgresqlåŒºå—é“¾å®ç°)
    - [4.2 å…±è¯†æœºåˆ¶å®ç°](#42-å…±è¯†æœºåˆ¶å®ç°)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)
    - [5.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#51-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [6. å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)
    - [6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#61-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [6.2 åŒºå—é“¾æ•°æ®åº“ç›¸å…³](#62-åŒºå—é“¾æ•°æ®åº“ç›¸å…³)
    - [6.3 ç›¸å…³æ–‡æ¡£](#63-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 åŒºå—é“¾æ•°æ®åº“å·¥ä½œåŸç†æ¦‚è¿°

**åŒºå—é“¾æ•°æ®åº“**ï¼š

åŒºå—é“¾æ•°æ®åº“ç»“åˆäº†åŒºå—é“¾çš„ä¸å¯ç¯¡æ”¹æ€§å’Œæ•°æ®åº“çš„æŸ¥è¯¢èƒ½åŠ›ï¼Œæä¾›åˆ†å¸ƒå¼è´¦æœ¬å’Œå…±è¯†æœºåˆ¶çš„å½¢å¼åŒ–æ¨¡å‹ã€‚

**åŒºå—é“¾æ¶æ„æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((åŒºå—é“¾æ•°æ®åº“))
    åˆ†å¸ƒå¼è´¦æœ¬
      åŒºå—é“¾
      å“ˆå¸Œé“¾æ¥
      ä¸å¯ç¯¡æ”¹
    å…±è¯†æœºåˆ¶
      PoWå·¥ä½œé‡è¯æ˜
      PoSæƒç›Šè¯æ˜
      PBFTå®ç”¨æ‹œå åº­å®¹é”™
    æ•°æ®æ¨¡å‹
      äº¤æ˜“
      åŒºå—
      çŠ¶æ€
    æŸ¥è¯¢èƒ½åŠ›
      SQLæŸ¥è¯¢
      ç´¢å¼•
      äº‹åŠ¡
```

**åŒºå—é“¾å·¥ä½œæµç¨‹**ï¼š

```mermaid
flowchart TD
    A[æ–°äº¤æ˜“] --> B[éªŒè¯äº¤æ˜“]
    B --> C{æœ‰æ•ˆ?}
    C -->|æ˜¯| D[æ‰“åŒ…åˆ°åŒºå—]
    C -->|å¦| E[æ‹’ç»]
    D --> F[å…±è¯†æœºåˆ¶]
    F --> G{è¾¾æˆå…±è¯†?}
    G -->|æ˜¯| H[æ·»åŠ åˆ°é“¾]
    G -->|å¦| I[é‡æ–°å…±è¯†]
    H --> J[æ›´æ–°çŠ¶æ€]

    style A fill:#FFD700
    style H fill:#90EE90
    style E fill:#FF6B6B
```

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **åˆ†å¸ƒå¼è´¦æœ¬**ï¼šåŒºå—é“¾è´¦æœ¬çš„å½¢å¼åŒ–æ¨¡å‹
- **å…±è¯†æœºåˆ¶**ï¼šPoWã€PoSã€PBFTç­‰å…±è¯†ç®—æ³•çš„å½¢å¼åŒ–
- **æ•°æ®æ¨¡å‹**ï¼šåŒºå—é“¾æ•°æ®æ¨¡å‹å’ŒæŸ¥è¯¢èƒ½åŠ›
- **å®é™…åº”ç”¨**ï¼šåŒºå—é“¾æ•°æ®åº“çš„å®ç°å’Œåº”ç”¨

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 åˆ†å¸ƒå¼è´¦æœ¬

**åŒºå—ç»“æ„**ï¼š

```haskell
-- åŒºå—
data Block = Block {
    index :: Integer,
    timestamp :: Timestamp,
    transactions :: [Transaction],
    previousHash :: Hash,
    hash :: Hash,
    nonce :: Integer
}

-- åŒºå—é“¾
data Blockchain = Blockchain {
    blocks :: [Block],
    currentState :: State
}
```

**åŒºå—é“¾éªŒè¯**ï¼š

```haskell
-- éªŒè¯åŒºå—
validateBlock :: Block -> Block -> Bool
validateBlock prev current =
    current.previousHash == hash(prev) &&
    hash(current) == calculateHash(current) &&
    validateTransactions(current.transactions)
```

### 2.2 å…±è¯†æœºåˆ¶

**å…±è¯†æœºåˆ¶å¯¹æ¯”**ï¼š

| æœºåˆ¶ | ç±»å‹ | èƒ½è€— | å»¶è¿Ÿ | é€‚ç”¨åœºæ™¯ |
|------|------|------|------|---------|
| **PoW** | ç«äº‰æ€§ | é«˜ | é«˜ | å…¬é“¾ |
| **PoS** | ç«äº‰æ€§ | ä½ | ä¸­ | å…¬é“¾/è”ç›Ÿé“¾ |
| **PBFT** | åä½œæ€§ | ä½ | ä½ | è”ç›Ÿé“¾ |
| **Raft** | åä½œæ€§ | ä½ | ä½ | ç§æœ‰é“¾ |

**å…±è¯†æœºåˆ¶é€‰æ‹©å†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[é€‰æ‹©å…±è¯†æœºåˆ¶] --> B{å…¬å¼€ç½‘ç»œ?}
    B -->|æ˜¯| C{éœ€è¦å»ä¸­å¿ƒåŒ–?}
    B -->|å¦| D[PBFT/Raft]
    C -->|æ˜¯| E[PoW/PoS]
    C -->|å¦| F[PoS]
    E --> G[é«˜èƒ½è€—]
    F --> H[ä½èƒ½è€—]
    D --> I[ä½å»¶è¿Ÿ]

    style A fill:#FFD700
    style G fill:#FFA500
    style H fill:#90EE90
    style I fill:#87CEEB
```

### 2.3 æ•°æ®æ¨¡å‹

**åŒºå—é“¾æ•°æ®æ¨¡å‹**ï¼š

```haskell
-- äº¤æ˜“
data Transaction = Transaction {
    from :: Address,
    to :: Address,
    value :: Amount,
    data :: Data,
    signature :: Signature
}

-- çŠ¶æ€
data State = State {
    accounts :: Map Address Account,
    contracts :: Map Address Contract
}
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 åŒºå—é“¾å½¢å¼åŒ–

**åŒºå—é“¾**ï¼š

```haskell
-- åŒºå—é“¾å½¢å¼åŒ–
Blockchain = (B, â‰¤, H, V)
where
    B = {b0, b1, ..., bn}  -- åŒºå—é›†åˆ
    â‰¤ = chain order  -- é“¾é¡ºåº
    H = hash function  -- å“ˆå¸Œå‡½æ•°
    V = validation function  -- éªŒè¯å‡½æ•°
```

### 3.2 å…±è¯†æœºåˆ¶å½¢å¼åŒ–

**PoWå…±è¯†**ï¼š

```haskell
-- PoWå…±è¯†
PoW(block, difficulty) =
    exists nonce such that:
        hash(block || nonce) < 2^(256 - difficulty)
```

**PBFTå…±è¯†**ï¼š

```haskell
-- PBFTå…±è¯†
PBFT(request, replicas) =
    if 2f + 1 replicas agree then
        commit
    else
        abort
    where f = number of faulty replicas
```

### 3.3 å®‰å…¨æ€§å½¢å¼åŒ–

**å®‰å…¨æ€§**ï¼š

```haskell
-- å®‰å…¨æ€§
secure(blockchain) =
    forall block b:
        if b in chain then
            validate(b) = true
            and
            cannot modify b without breaking chain
```

---

## 4. å®é™…åº”ç”¨

### 4.1 PostgreSQLåŒºå—é“¾å®ç°

**ä½¿ç”¨PostgreSQLå®ç°åŒºå—é“¾**ï¼š

```sql
-- åˆ›å»ºåŒºå—è¡¨
CREATE TABLE blocks (
    index BIGINT PRIMARY KEY,
    timestamp TIMESTAMP NOT NULL,
    previous_hash VARCHAR(64) NOT NULL,
    hash VARCHAR(64) NOT NULL UNIQUE,
    nonce BIGINT,
    merkle_root VARCHAR(64)
);

-- åˆ›å»ºäº¤æ˜“è¡¨
CREATE TABLE transactions (
    id UUID PRIMARY KEY,
    block_index BIGINT REFERENCES blocks(index),
    from_address VARCHAR(42),
    to_address VARCHAR(42),
    value NUMERIC(20, 8),
    data JSONB,
    signature TEXT,
    created_at TIMESTAMP
);

-- åˆ›å»ºçŠ¶æ€è¡¨
CREATE TABLE state (
    address VARCHAR(42) PRIMARY KEY,
    balance NUMERIC(20, 8) DEFAULT 0,
    nonce BIGINT DEFAULT 0,
    data JSONB
);

-- éªŒè¯åŒºå—å‡½æ•°
CREATE OR REPLACE FUNCTION validate_block(
    p_index BIGINT,
    p_previous_hash VARCHAR,
    p_hash VARCHAR
) RETURNS BOOLEAN AS $$
DECLARE
    v_prev_hash VARCHAR;
BEGIN
    -- æ£€æŸ¥å‰ä¸€ä¸ªåŒºå—çš„å“ˆå¸Œ
    SELECT hash INTO v_prev_hash
    FROM blocks
    WHERE index = p_index - 1;

    RETURN v_prev_hash = p_previous_hash;
END;
$$ LANGUAGE plpgsql;

-- æ·»åŠ åŒºå—
CREATE OR REPLACE FUNCTION add_block(
    p_index BIGINT,
    p_timestamp TIMESTAMP,
    p_previous_hash VARCHAR,
    p_hash VARCHAR,
    p_nonce BIGINT
) RETURNS VOID AS $$
BEGIN
    -- éªŒè¯åŒºå—
    IF NOT validate_block(p_index, p_previous_hash, p_hash) THEN
        RAISE EXCEPTION 'Invalid block';
    END IF;

    -- æ’å…¥åŒºå—
    INSERT INTO blocks (index, timestamp, previous_hash, hash, nonce)
    VALUES (p_index, p_timestamp, p_previous_hash, p_hash, p_nonce);
END;
$$ LANGUAGE plpgsql;
```

### 4.2 å…±è¯†æœºåˆ¶å®ç°

**PoWå®ç°**ï¼š

```sql
-- PoWæŒ–çŸ¿å‡½æ•°
CREATE OR REPLACE FUNCTION mine_block(
    p_previous_hash VARCHAR,
    p_transactions JSONB,
    p_difficulty INTEGER
) RETURNS JSONB AS $$
DECLARE
    v_nonce BIGINT := 0;
    v_hash VARCHAR;
    v_target VARCHAR;
BEGIN
    -- è®¡ç®—ç›®æ ‡å“ˆå¸Œ
    v_target := LPAD('', p_difficulty, '0');

    -- æŒ–çŸ¿å¾ªç¯
    LOOP
        v_hash := encode(
            digest(p_previous_hash || p_transactions::TEXT || v_nonce::TEXT, 'sha256'),
            'hex'
        );

        IF LEFT(v_hash, p_difficulty) = v_target THEN
            EXIT;
        END IF;

        v_nonce := v_nonce + 1;
    END LOOP;

    RETURN jsonb_build_object(
        'hash', v_hash,
        'nonce', v_nonce
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 5. ç›¸å…³æ–‡æ¡£

### 5.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [åˆ†å¸ƒå¼ä¸€è‡´æ€§ä¸CAP-å½¢å¼åŒ–åˆ»ç”»ä¸æƒè¡¡](./04.02-åˆ†å¸ƒå¼ä¸€è‡´æ€§ä¸CAP-å½¢å¼åŒ–åˆ»ç”»ä¸æƒè¡¡.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

## 6. å‚è€ƒæ–‡çŒ®

### 6.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Nakamoto, S. (2008). "Bitcoin: A Peer-to-Peer Electronic Cash System."**
  - ä¼šè®®: Bitcoin Whitepaper
  - **é‡è¦æ€§**: åŒºå—é“¾çš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†åŒºå—é“¾å’ŒPoWå…±è¯†æœºåˆ¶
  - **æ‰¹åˆ¤æ€§åˆ†æ**: PoWèƒ½è€—é—®é¢˜å¯¼è‡´åç»­ç ”ç©¶è½¬å‘PoSç­‰æ›´é«˜æ•ˆçš„å…±è¯†æœºåˆ¶

- **Castro, M., & Liskov, B. (1999). "Practical Byzantine Fault Tolerance."**
  - ä¼šè®®: OSDI 1999
  - **é‡è¦æ€§**: PBFTå…±è¯†çš„ç»å…¸è®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†å®ç”¨çš„æ‹œå åº­å®¹é”™ç®—æ³•
  - **æ‰¹åˆ¤æ€§åˆ†æ**: PBFTé€‚ç”¨äºè”ç›Ÿé“¾ï¼Œä½†ä¸é€‚ç”¨äºå¤§è§„æ¨¡å…¬é“¾

### 6.2 åŒºå—é“¾æ•°æ®åº“ç›¸å…³

- **Zheng, Z., et al. (2017). "An Overview of Blockchain Technology: Architecture, Consensus, and Future Trends."**
  - ä¼šè®®: IEEE BigData 2017
  - **é‡è¦æ€§**: åŒºå—é“¾æŠ€æœ¯ç»¼è¿°
  - **æ ¸å¿ƒè´¡çŒ®**: ç³»ç»Ÿé˜è¿°äº†åŒºå—é“¾æ¶æ„å’Œå…±è¯†æœºåˆ¶

### 6.3 ç›¸å…³æ–‡æ¡£

- [åˆ†å¸ƒå¼ä¸€è‡´æ€§ä¸CAP-å½¢å¼åŒ–åˆ»ç”»ä¸æƒè¡¡](./04.02-åˆ†å¸ƒå¼ä¸€è‡´æ€§ä¸CAP-å½¢å¼åŒ–åˆ»ç”»ä¸æƒè¡¡.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: ğŸŸ¡ æ¡†æ¶å·²åˆ›å»ºï¼Œå†…å®¹å¾…å®Œå–„
