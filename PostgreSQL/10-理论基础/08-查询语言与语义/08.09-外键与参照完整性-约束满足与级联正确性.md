# å¤–é”®ä¸å‚ç…§å®Œæ•´æ€§-çº¦æŸæ»¡è¶³ä¸çº§è”æ­£ç¡®æ€§

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
> **æœ€åæ›´æ–°**: 2025-01-16
> **ç‰ˆæœ¬è¦†ç›–**: PostgreSQL 18.x (æ¨è) â­ | 17.x (æ¨è) | 16.x (å…¼å®¹)
> **æ–‡æ¡£çŠ¶æ€**: ğŸŸ¡ æ¡†æ¶å·²åˆ›å»ºï¼Œå†…å®¹å¾…å®Œå–„

---

## ğŸ“‹ ç›®å½•

- [å¤–é”®ä¸å‚ç…§å®Œæ•´æ€§-çº¦æŸæ»¡è¶³ä¸çº§è”æ­£ç¡®æ€§](#å¤–é”®ä¸å‚ç…§å®Œæ•´æ€§-çº¦æŸæ»¡è¶³ä¸çº§è”æ­£ç¡®æ€§)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.0 å¤–é”®ä¸å‚ç…§å®Œæ•´æ€§å·¥ä½œåŸç†æ¦‚è¿°](#10-å¤–é”®ä¸å‚ç…§å®Œæ•´æ€§å·¥ä½œåŸç†æ¦‚è¿°)
    - [1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´](#11-æœ¬æ–‡æ¡£çš„èŒƒå›´)
  - [2. æ ¸å¿ƒå†…å®¹](#2-æ ¸å¿ƒå†…å®¹)
    - [2.1 å¤–é”®çº¦æŸ](#21-å¤–é”®çº¦æŸ)
    - [2.2 çº§è”æ“ä½œ](#22-çº§è”æ“ä½œ)
    - [2.3 çº¦æŸæ»¡è¶³](#23-çº¦æŸæ»¡è¶³)
  - [3. å½¢å¼åŒ–å®šä¹‰](#3-å½¢å¼åŒ–å®šä¹‰)
    - [3.1 å¤–é”®çº¦æŸå½¢å¼åŒ–](#31-å¤–é”®çº¦æŸå½¢å¼åŒ–)
    - [3.2 çº§è”æ“ä½œå½¢å¼åŒ–](#32-çº§è”æ“ä½œå½¢å¼åŒ–)
    - [3.3 çº¦æŸæ»¡è¶³å½¢å¼åŒ–](#33-çº¦æŸæ»¡è¶³å½¢å¼åŒ–)
  - [4. å®šç†ä¸è¯æ˜](#4-å®šç†ä¸è¯æ˜)
    - [4.1 çº§è”æ“ä½œæ­£ç¡®æ€§å®šç†](#41-çº§è”æ“ä½œæ­£ç¡®æ€§å®šç†)
    - [4.2 çº¦æŸæ»¡è¶³åˆ¤å®šå®šç†](#42-çº¦æŸæ»¡è¶³åˆ¤å®šå®šç†)
  - [5. å®é™…åº”ç”¨](#5-å®é™…åº”ç”¨)
    - [5.1 PostgreSQLå¤–é”®çº¦æŸ](#51-postgresqlå¤–é”®çº¦æŸ)
    - [5.2 çº§è”æ“ä½œç¤ºä¾‹](#52-çº§è”æ“ä½œç¤ºä¾‹)
    - [5.3 çº¦æŸéªŒè¯](#53-çº¦æŸéªŒè¯)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)
    - [6.1 ç†è®ºåŸºç¡€æ–‡æ¡£](#61-ç†è®ºåŸºç¡€æ–‡æ¡£)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [7.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®](#71-æ ¸å¿ƒç†è®ºæ–‡çŒ®)
    - [7.2 çº¦æŸä¸å®Œæ•´æ€§ç›¸å…³](#72-çº¦æŸä¸å®Œæ•´æ€§ç›¸å…³)
    - [7.3 PostgreSQLå®ç°ç›¸å…³](#73-postgresqlå®ç°ç›¸å…³)
    - [7.4 ç›¸å…³æ–‡æ¡£](#74-ç›¸å…³æ–‡æ¡£)

---

## 1. æ¦‚è¿°

### 1.0 å¤–é”®ä¸å‚ç…§å®Œæ•´æ€§å·¥ä½œåŸç†æ¦‚è¿°

**å‚ç…§å®Œæ•´æ€§**ï¼š

å‚ç…§å®Œæ•´æ€§é€šè¿‡å¤–é”®çº¦æŸä¿è¯å¼•ç”¨å…³ç³»çš„ä¸€è‡´æ€§ã€‚çº§è”æ“ä½œç¡®ä¿åœ¨æ›´æ–°æˆ–åˆ é™¤è¢«å¼•ç”¨è¡Œæ—¶ï¼Œå¼•ç”¨è¡Œçš„è¡Œä¸ºæ­£ç¡®ã€‚

**å‚ç…§å®Œæ•´æ€§ä½“ç³»æ€ç»´å¯¼å›¾**ï¼š

```mermaid
mindmap
  root((å‚ç…§å®Œæ•´æ€§))
    å¤–é”®çº¦æŸ
      ä¸»é”®å¼•ç”¨
      å”¯ä¸€é”®å¼•ç”¨
      çº¦æŸæ£€æŸ¥
    çº§è”æ“ä½œ
      CASCADE
      SET NULL
      SET DEFAULT
      RESTRICT
      NO ACTION
    çº¦æŸæ»¡è¶³
      æ’å…¥æ£€æŸ¥
      æ›´æ–°æ£€æŸ¥
      åˆ é™¤æ£€æŸ¥
    æ­£ç¡®æ€§
      çº¦æŸä¿æŒ
      çº§è”æ­£ç¡®æ€§
      äº‹åŠ¡ä¸€è‡´æ€§
```

**çº§è”æ“ä½œå†³ç­–æ ‘**ï¼š

```mermaid
flowchart TD
    A[æ›´æ–°/åˆ é™¤ä¸»è¡¨è¡Œ] --> B{å¤–é”®çº¦æŸ?}
    B -->|æ— | C[ç›´æ¥æ‰§è¡Œ]
    B -->|æœ‰| D{çº§è”ç­–ç•¥}
    D -->|CASCADE| E[çº§è”æ›´æ–°/åˆ é™¤]
    D -->|SET NULL| F[è®¾ç½®å¤–é”®ä¸ºNULL]
    D -->|SET DEFAULT| G[è®¾ç½®å¤–é”®ä¸ºé»˜è®¤å€¼]
    D -->|RESTRICT| H{æœ‰å¼•ç”¨?}
    D -->|NO ACTION| I[å»¶è¿Ÿæ£€æŸ¥]
    H -->|æœ‰| J[æ‹’ç»æ“ä½œ]
    H -->|æ— | C
    I --> K[äº‹åŠ¡æäº¤æ—¶æ£€æŸ¥]
    E --> L[æ‰§è¡ŒæˆåŠŸ]
    F --> L
    G --> L
    J --> M[æ“ä½œå¤±è´¥]
    K --> N{ä»æœ‰å¼•ç”¨?}
    N -->|æ˜¯| M
    N -->|å¦| L

    style A fill:#FFD700
    style L fill:#90EE90
    style M fill:#FF6B6B
```

**çº§è”ç­–ç•¥å¯¹æ¯”çŸ©é˜µ**ï¼š

| ç­–ç•¥ | è¡Œä¸º | é€‚ç”¨åœºæ™¯ | é£é™© |
|------|------|---------|------|
| **CASCADE** | çº§è”æ›´æ–°/åˆ é™¤ | å¼ºä¾èµ–å…³ç³» | å¯èƒ½è¯¯åˆ æ•°æ® |
| **SET NULL** | è®¾ç½®å¤–é”®ä¸ºNULL | å¯é€‰ä¾èµ– | éœ€è¦NULLçº¦æŸ |
| **SET DEFAULT** | è®¾ç½®å¤–é”®ä¸ºé»˜è®¤å€¼ | æœ‰é»˜è®¤å€¼ | éœ€è¦é»˜è®¤å€¼ |
| **RESTRICT** | ç¦æ­¢æ“ä½œ | ä¸¥æ ¼ä¾èµ– | å¯èƒ½é˜»å¡æ“ä½œ |
| **NO ACTION** | å»¶è¿Ÿæ£€æŸ¥ | äº‹åŠ¡å†…æ£€æŸ¥ | äº‹åŠ¡å›æ»šé£é™© |

### 1.1 æœ¬æ–‡æ¡£çš„èŒƒå›´

æœ¬æ–‡æ¡£æ¶µç›–ï¼š

- **å¤–é”®çº¦æŸ**ï¼šå¤–é”®çº¦æŸçš„å®šä¹‰å’Œæ£€æŸ¥æœºåˆ¶
- **çº§è”æ“ä½œ**ï¼šçº§è”æ›´æ–°å’Œåˆ é™¤çš„è¯­ä¹‰å’Œæ­£ç¡®æ€§
- **çº¦æŸæ»¡è¶³**ï¼šçº¦æŸæ»¡è¶³çš„åˆ¤å®šå’ŒéªŒè¯
- **å®é™…åº”ç”¨**ï¼šPostgreSQLå¤–é”®å’Œçº§è”æ“ä½œçš„å®ç°

---

## 2. æ ¸å¿ƒå†…å®¹

### 2.1 å¤–é”®çº¦æŸ

**å¤–é”®å®šä¹‰**ï¼š

```haskell
-- å¤–é”®çº¦æŸ
foreignKey :: Table -> Attributes -> Table -> Attributes -> Constraint
foreignKey T1 attrs1 T2 attrs2 =
    ForeignKey {
        referencing = (T1, attrs1),
        referenced = (T2, attrs2),
        onUpdate = CASCADE,
        onDelete = CASCADE
    }

-- çº¦æŸæ£€æŸ¥
checkForeignKey :: ForeignKey -> Database -> Bool
checkForeignKey fk db =
    forall t âˆˆ T1:
      if t[attrs1] is not NULL then
        exists t' âˆˆ T2: t'[attrs2] = t[attrs1]
```

**çº¦æŸæ£€æŸ¥æµç¨‹**ï¼š

```mermaid
graph TD
    A[æ’å…¥/æ›´æ–°æ“ä½œ] --> B{æ¶‰åŠå¤–é”®è¡¨?}
    B -->|å¦| C[ç›´æ¥æ‰§è¡Œ]
    B -->|æ˜¯| D[æå–å¤–é”®å€¼]
    D --> E{å¤–é”®å€¼éNULL?}
    E -->|å¦| C
    E -->|æ˜¯| F[æ£€æŸ¥å¼•ç”¨è¡¨]
    F --> G{å¼•ç”¨å­˜åœ¨?}
    G -->|æ˜¯| C
    G -->|å¦| H[è¿åçº¦æŸ]
    H --> I[æ‹’ç»æ“ä½œ]

    style A fill:#FFD700
    style C fill:#90EE90
    style I fill:#FF6B6B
```

### 2.2 çº§è”æ“ä½œ

**çº§è”æ›´æ–°**ï¼š

```haskell
-- çº§è”æ›´æ–°
cascadeUpdate :: ForeignKey -> Update -> Database -> Database
cascadeUpdate fk (Update T2 attrs2 newVal) db =
    let T1 = fk.referencing.table
        attrs1 = fk.referencing.attrs
        affected = {t âˆˆ T1 | t[attrs1] = oldVal}
    in if fk.onUpdate == CASCADE then
        updateAll affected (attrs1, newVal) db
    else
        db
```

**çº§è”åˆ é™¤**ï¼š

```haskell
-- çº§è”åˆ é™¤
cascadeDelete :: ForeignKey -> Delete -> Database -> Database
cascadeDelete fk (Delete T2 condition) db =
    let T1 = fk.referencing.table
        attrs1 = fk.referencing.attrs
        deleted = select T2 condition db
        affected = {t âˆˆ T1 | t[attrs1] âˆˆ deleted[attrs2]}
    in if fk.onDelete == CASCADE then
        deleteAll affected db
    else if fk.onDelete == SET_NULL then
        setNullAll affected attrs1 db
    else
        db
```

**çº§è”æ“ä½œæµç¨‹å›¾**ï¼š

```mermaid
graph TD
    A[ä¸»è¡¨æ›´æ–°/åˆ é™¤] --> B{å¤–é”®çº§è”ç­–ç•¥}
    B -->|CASCADE| C[çº§è”æ‰§è¡Œç›¸åŒæ“ä½œ]
    B -->|SET NULL| D[è®¾ç½®å¤–é”®ä¸ºNULL]
    B -->|SET DEFAULT| E[è®¾ç½®å¤–é”®ä¸ºé»˜è®¤å€¼]
    B -->|RESTRICT| F{æœ‰å¼•ç”¨?}
    B -->|NO ACTION| G[å»¶è¿Ÿæ£€æŸ¥]
    F -->|æœ‰| H[æ‹’ç»æ“ä½œ]
    F -->|æ— | I[å…è®¸æ“ä½œ]
    C --> J[æ“ä½œå®Œæˆ]
    D --> J
    E --> J
    I --> J
    G --> K[äº‹åŠ¡æäº¤æ—¶æ£€æŸ¥]
    K --> L{ä»æœ‰å¼•ç”¨?}
    L -->|æ˜¯| H
    L -->|å¦| J

    style A fill:#FFD700
    style J fill:#90EE90
    style H fill:#FF6B6B
```

### 2.3 çº¦æŸæ»¡è¶³

**çº¦æŸæ»¡è¶³åˆ¤å®š**ï¼š

```haskell
-- çº¦æŸæ»¡è¶³
satisfies :: Database -> ForeignKey -> Bool
satisfies db fk =
    forall t âˆˆ fk.referencing.table:
      if t[fk.referencing.attrs] is not NULL then
        exists t' âˆˆ fk.referenced.table:
          t'[fk.referenced.attrs] = t[fk.referencing.attrs]
```

---

## 3. å½¢å¼åŒ–å®šä¹‰

### 3.1 å¤–é”®çº¦æŸå½¢å¼åŒ–

**å¤–é”®çº¦æŸ**ï¼š

```haskell
-- å¤–é”®çº¦æŸ
FK(T1, A1, T2, A2) iff
    forall t1 âˆˆ T1:
      if t1[A1] is not NULL then
        exists t2 âˆˆ T2: t2[A2] = t1[A1]
```

### 3.2 çº§è”æ“ä½œå½¢å¼åŒ–

**çº§è”æ›´æ–°**ï¼š

```haskell
-- CASCADEæ›´æ–°
if FK(T1, A1, T2, A2) and UPDATE T2 SET A2 = v WHERE condition then
    UPDATE T1 SET A1 = v WHERE A1 âˆˆ (SELECT A2 FROM T2 WHERE condition)
```

**çº§è”åˆ é™¤**ï¼š

```haskell
-- CASCADEåˆ é™¤
if FK(T1, A1, T2, A2) and DELETE FROM T2 WHERE condition then
    DELETE FROM T1 WHERE A1 âˆˆ (SELECT A2 FROM T2 WHERE condition)
```

### 3.3 çº¦æŸæ»¡è¶³å½¢å¼åŒ–

**çº¦æŸä¿æŒ**ï¼š

```haskell
-- çº¦æŸä¿æŒ
preserves(db, op, fk) iff
    if satisfies(db, fk) then
        satisfies(execute(op, db), fk)
```

---

## 4. å®šç†ä¸è¯æ˜

### 4.1 çº§è”æ“ä½œæ­£ç¡®æ€§å®šç†

**å®šç†**ï¼šçº§è”æ“ä½œä¿æŒå‚ç…§å®Œæ•´æ€§çº¦æŸã€‚

**è¯æ˜æ ‘**ï¼š

```mermaid
graph TD
    A[çº§è”æ“ä½œæ­£ç¡®æ€§] --> B[çº§è”æ›´æ–°æ­£ç¡®æ€§]
    A --> C[çº§è”åˆ é™¤æ­£ç¡®æ€§]
    B --> D[æ›´æ–°ä¸»è¡¨]
    B --> E[çº§è”æ›´æ–°ä»è¡¨]
    E --> F[å¤–é”®å€¼åŒæ­¥]
    F --> G[çº¦æŸä¿æŒ]
    C --> H[åˆ é™¤ä¸»è¡¨]
    C --> I[çº§è”åˆ é™¤ä»è¡¨]
    I --> J[å¼•ç”¨æ¶ˆé™¤]
    J --> G
    G --> K[å®šç†å¾—è¯]

    style A fill:#FFD700
    style K fill:#90EE90
```

**è¯æ˜**ï¼š

1. **çº§è”æ›´æ–°**ï¼šå½“ä¸»è¡¨é”®å€¼æ›´æ–°æ—¶ï¼Œçº§è”æ›´æ–°ä»è¡¨å¤–é”®å€¼ï¼Œä¿è¯å¼•ç”¨å…³ç³»ä¸€è‡´
2. **çº§è”åˆ é™¤**ï¼šå½“ä¸»è¡¨è¡Œåˆ é™¤æ—¶ï¼Œçº§è”åˆ é™¤ä»è¡¨å¼•ç”¨è¡Œï¼Œæ¶ˆé™¤æ‚¬ç©ºå¼•ç”¨
3. å› æ­¤çº§è”æ“ä½œä¿æŒå‚ç…§å®Œæ•´æ€§çº¦æŸ

### 4.2 çº¦æŸæ»¡è¶³åˆ¤å®šå®šç†

**å®šç†**ï¼šçº¦æŸæ»¡è¶³åˆ¤å®šæ˜¯NPå®Œå…¨çš„ã€‚

**è¯æ˜**ï¼š

1. çº¦æŸæ»¡è¶³å¯ä»¥å½’çº¦ä¸ºå›¾åŒæ„é—®é¢˜
2. å›¾åŒæ„æ˜¯NPå®Œå…¨çš„
3. å› æ­¤çº¦æŸæ»¡è¶³åˆ¤å®šæ˜¯NPå®Œå…¨çš„

---

## 5. å®é™…åº”ç”¨

### 5.1 PostgreSQLå¤–é”®çº¦æŸ

**åˆ›å»ºå¤–é”®çº¦æŸ**ï¼š

```sql
-- åˆ›å»ºä¸»è¡¨
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    customer_name VARCHAR(100) NOT NULL
);

-- åˆ›å»ºä»è¡¨ï¼Œå¸¦å¤–é”®çº¦æŸ
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date DATE NOT NULL,
    FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);

-- æ’å…¥æ•°æ®
INSERT INTO customers (customer_name) VALUES ('Alice');
INSERT INTO orders (customer_id, order_date)
VALUES (1, '2024-01-15');  -- æˆåŠŸ

-- å°è¯•æ’å…¥æ— æ•ˆå¤–é”®
INSERT INTO orders (customer_id, order_date)
VALUES (999, '2024-01-15');  -- å¤±è´¥ï¼šè¿åå¤–é”®çº¦æŸ
```

### 5.2 çº§è”æ“ä½œç¤ºä¾‹

**çº§è”æ›´æ–°**ï¼š

```sql
-- æ›´æ–°ä¸»è¡¨é”®å€¼
UPDATE customers
SET customer_id = 100
WHERE customer_id = 1;

-- ç”±äºON UPDATE CASCADEï¼Œordersè¡¨ä¸­çš„customer_idè‡ªåŠ¨æ›´æ–°
SELECT * FROM orders WHERE customer_id = 100;  -- å¯ä»¥çœ‹åˆ°æ›´æ–°çš„è®¢å•
```

**çº§è”åˆ é™¤**ï¼š

```sql
-- å°è¯•åˆ é™¤æœ‰å¼•ç”¨çš„ä¸»è¡¨è¡Œ
DELETE FROM customers WHERE customer_id = 1;
-- å¤±è´¥ï¼šç”±äºON DELETE RESTRICTï¼Œæœ‰å¼•ç”¨æ—¶ç¦æ­¢åˆ é™¤

-- å…ˆåˆ é™¤ä»è¡¨å¼•ç”¨
DELETE FROM orders WHERE customer_id = 1;

-- ç°åœ¨å¯ä»¥åˆ é™¤ä¸»è¡¨è¡Œ
DELETE FROM customers WHERE customer_id = 1;  -- æˆåŠŸ
```

### 5.3 çº¦æŸéªŒè¯

**æ£€æŸ¥çº¦æŸçŠ¶æ€**ï¼š

```sql
-- æŸ¥çœ‹å¤–é”®çº¦æŸ
SELECT
    tc.constraint_name,
    tc.table_name,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name,
    rc.update_rule,
    rc.delete_rule
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
JOIN information_schema.referential_constraints AS rc
    ON rc.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_name = 'orders';

-- éªŒè¯çº¦æŸå®Œæ•´æ€§
SELECT
    COUNT(*) as violations
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE o.customer_id IS NOT NULL
  AND c.customer_id IS NULL;  -- åº”è¯¥è¿”å›0
```

---

## 6. ç›¸å…³æ–‡æ¡£

### 6.1 ç†è®ºåŸºç¡€æ–‡æ¡£

- [å…³ç³»çº¦æŸä¸è§„èŒƒåŒ–-å‡½æ•°ä¾èµ–ä¸èŒƒå¼è¯æ˜](../09-æ•°æ®æ¨¡å‹ä¸è§„èŒƒåŒ–/09.01-å…³ç³»çº¦æŸä¸è§„èŒƒåŒ–-å‡½æ•°ä¾èµ–ä¸èŒƒå¼è¯æ˜.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

## 7. å‚è€ƒæ–‡çŒ®

### 7.1 æ ¸å¿ƒç†è®ºæ–‡çŒ®

- **Codd, E. F. (1970). "A Relational Model of Data for Large Shared Data Banks."**
  - æœŸåˆŠ: Communications of the ACM 1970
  - **é‡è¦æ€§**: å…³ç³»æ¨¡å‹çš„å¥ åŸºè®ºæ–‡
  - **æ ¸å¿ƒè´¡çŒ®**: æå‡ºäº†å‚ç…§å®Œæ•´æ€§çš„æ¦‚å¿µ

- **Date, C. J., & Darwen, H. (1992). "A Guide to the SQL Standard."**
  - å‡ºç‰ˆç¤¾: Addison-Wesley 1992
  - **é‡è¦æ€§**: SQLæ ‡å‡†çš„æƒå¨æŒ‡å—
  - **æ ¸å¿ƒè´¡çŒ®**: è¯¦ç»†é˜è¿°äº†å¤–é”®çº¦æŸå’Œçº§è”æ“ä½œ

### 7.2 çº¦æŸä¸å®Œæ•´æ€§ç›¸å…³

- **Abiteboul, S., et al. (1995). "Foundations of Databases."**
  - å‡ºç‰ˆç¤¾: Addison-Wesley 1995
  - **é‡è¦æ€§**: æ•°æ®åº“ç†è®ºçš„ç»å…¸æ•™æ
  - **æ ¸å¿ƒè´¡çŒ®**: æä¾›äº†çº¦æŸæ»¡è¶³çš„å½¢å¼åŒ–ç†è®º

### 7.3 PostgreSQLå®ç°ç›¸å…³

- **[PostgreSQLå®˜æ–¹æ–‡æ¡£ - å¤–é”®çº¦æŸ](<https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK>)**
  - PostgreSQLå¤–é”®çº¦æŸå®ç°è¯´æ˜

### 7.4 ç›¸å…³æ–‡æ¡£

- [å…³ç³»çº¦æŸä¸è§„èŒƒåŒ–-å‡½æ•°ä¾èµ–ä¸èŒƒå¼è¯æ˜](../09-æ•°æ®æ¨¡å‹ä¸è§„èŒƒåŒ–/09.01-å…³ç³»çº¦æŸä¸è§„èŒƒåŒ–-å‡½æ•°ä¾èµ–ä¸èŒƒå¼è¯æ˜.md)
- [ç†è®ºåŸºç¡€å¯¼èˆª](../README.md)

---

**æœ€åæ›´æ–°**: 2025-01-16
**ç»´æŠ¤è€…**: Documentation Team
**çŠ¶æ€**: ğŸŸ¡ æ¡†æ¶å·²åˆ›å»ºï¼Œå†…å®¹å¾…å®Œå–„
