# 文档格式统一处理计划

**制定日期**: 2025-10-30
**预计完成**: 分阶段执行
**状态**: 待执行

---

## 1. 现状分析

### 1.1 统计数据

根据扫描结果：

| 目录 | 总文件数 | 有TOC | 有序号 | 需处理 |
|------|---------|-------|--------|--------|
| 00-项目导航 | 33 | 少数 | 部分 | 30+ |
| 01-核心基础 | 18 | 0 | 大部分 | 18 |
| 02-查询处理 | 7 | 0 | 大部分 | 7 |
| 03-高级特性 | 9 | 0 | 部分 | 9 |
| 04-部署运维 | 10 | 4 | 部分 | 6 |
| 05-前沿技术 | 23 | 0 | 少数 | 23 |
| 06-实战案例 | 3 | 0 | 0 | 3 |
| 07-应用实践 | 3 | 0 | 0 | 3 |
| 08-工具资源 | 8 | 0 | 少数 | 8 |
| **总计** | **114** | **~5** | **~40** | **~107** |

### 1.2 主要问题

1. **缺少目录**: 约95%的文档没有目录
2. **序号不统一**: 约60%的文档序号不规范
3. **结构混乱**: 部分文档标题层级不清晰
4. **命名混乱**: 1.1.X系列文件混杂

---

## 2. 处理策略

### 2.1 优先级分类

**P0 - 最高优先级（核心文档）**:

- 06-实战案例/ (3个) - 用户最常访问
- 05-前沿技术/ 主要文档 (RAG、向量检索、Azure AI等8个)

**P1 - 高优先级（基础文档）**:

- 01-核心基础/ (18个)
- 02-查询处理/ (7个)

**P2 - 中优先级（功能文档）**:

- 03-高级特性/ (9个)
- 04-部署运维/ (10个)

**P3 - 低优先级（辅助文档）**:

- 07-应用实践/ (3个)
- 08-工具资源/ (8个)
- 00-项目导航/ (部分)

### 2.2 处理原则

1. **保留内容**: 只调整格式，不改变内容
2. **统一序号**: 所有H2用数字序号
3. **添加目录**: 自动生成或手动添加
4. **验证链接**: 确保内部链接有效
5. **更新时间**: 标注格式更新时间

---

## 3. 执行计划

### 3.1 第一阶段（P0 - 最高优先级）

**目标**: 11个核心文档

**实战案例 (3个)**:

- [ ] 06.01-语义搜索系统端到端实现.md
- [ ] 06.02-RAG知识库完整项目.md
- [ ] 06.03-智能推荐系统.md

**前沿技术核心 (8个)**:

- [ ] 05.04-RAG架构实战指南.md
- [ ] 05.05-向量检索性能调优指南.md
- [ ] 05.03-Azure-AI扩展实战.md
- [ ] 05.01-PostgreSQL-2025新特性.md
- [ ] 05.02-AI模型深度集成.md
- [ ] 1.1.6-AI与PostgreSQL集成.md
- [ ] 1.1.19-PostgreSQL向量数据库深度集成.md
- [ ] 1.1.20-PostgreSQL与AI模型深度集成架构.md

**预计时间**: 2-3小时

### 3.2 第二阶段（P1 - 高优先级）

**目标**: 25个基础文档

**核心基础 (18个)**:

- [ ] 01.01-系统架构与设计原理.md
- [ ] 01.02-关系数据模型与理论.md
- [ ] 01.03-SQL语言规范与标准.md
- [ ] 01.04-事务管理与ACID特性.md
- [ ] 01.05-并发控制与MVCC机制.md
- [ ] 01.06-存储管理与数据持久化.md
- [ ] 其他12个文件

**查询处理 (7个)**:

- [ ] 02.01-查询优化器原理.md
- [ ] 02.02-索引结构与优化.md
- [ ] 02.03-统计信息与代价模型.md
- [ ] 02.04-执行计划与性能调优.md
- [ ] 02.05-并行查询处理.md
- [ ] 其他2个文件

**预计时间**: 4-5小时

### 3.3 第三阶段（P2 - 中优先级）

**目标**: 19个功能文档

**高级特性 (9个)**:

- [ ] 03.01-扩展系统与插件开发.md
- [ ] 03.02-安全机制与访问控制.md
- [ ] 03.03-流处理与CEP.md
- [ ] 03.04-机器学习集成.md
- [ ] 03.05-向量数据库支持.md
- [ ] 其他4个文件

**部署运维 (10个)**:

- [ ] 04.01-单机部署与配置.md
- [ ] 04.02-集群部署与高可用.md
- [ ] 04.03-云原生与容器化.md
- [ ] 04.04-监控与诊断.md
- [ ] 04.05-备份与恢复.md
- [ ] 其他5个文件

**预计时间**: 3-4小时

### 3.4 第四阶段（P3 - 低优先级）

**目标**: 剩余文档

**应用实践 (3个)**:

- [ ] 07.04-内容管理系统.md
- [ ] 07.05-实时推荐系统.md
- [ ] 07.06-数据科学实践.md

**工具资源 (8个)**:

- [ ] 08.01-质量检查工具.md
- [ ] 08.02-知识图谱构建.md
- [ ] 08.03-国际化标准指南.md
- [ ] 08.04-最佳实践总结.md
- [ ] 08.05-学习资源导航.md
- [ ] 其他3个文件

**项目导航（选择性）**:

- 核心导航文档已更新
- 其他文档按需处理

**预计时间**: 2-3小时

---

## 4. 处理流程

### 4.1 单个文件处理步骤

1. **读取文件**: 读取原始内容
2. **分析结构**: 识别标题层级
3. **规范序号**:
   - H2添加数字序号
   - H3添加两级序号
   - H4添加三级序号
4. **生成目录**: 基于规范后的标题
5. **插入目录**: 在H1标题后
6. **验证链接**: 检查内部链接
7. **添加元信息**: 更新时间戳
8. **保存文件**: 写回磁盘

### 4.2 批量处理流程

```bash
# 第一阶段：实战案例
python format_docs.py 06-实战案例/*.md

# 第二阶段：前沿技术核心
python format_docs.py 05-前沿技术/05.04*.md 05-前沿技术/05.05*.md

# 第三阶段：核心基础
python format_docs.py 01-核心基础/*.md

# 第四阶段：查询处理
python format_docs.py 02-查询处理/*.md

# 其他阶段依次执行
```

---

## 5. 自动化工具

### 5.1 Python脚本

```python
#!/usr/bin/env python3
"""
文档格式统一处理工具
"""
import re
import sys
from pathlib import Path

class DocFormatter:
    def __init__(self):
        self.h2_counter = 0
        self.h3_counters = {}
        self.h4_counters = {}

    def reset_counters(self):
        self.h2_counter = 0
        self.h3_counters = {}
        self.h4_counters = {}

    def add_number_to_heading(self, line):
        """为标题添加序号"""
        # H2标题
        if line.startswith('## ') and not re.match(r'##\s+\d+\.', line):
            if '目录' in line or 'Table of Contents' in line or 'TOC' in line:
                return line  # 保持目录标题不变
            self.h2_counter += 1
            self.h3_counters[self.h2_counter] = 0
            title = line[3:].strip()
            return f"## {self.h2_counter}. {title}"

        # H3标题
        elif line.startswith('### ') and not re.match(r'###\s+\d+\.\d+', line):
            if self.h2_counter > 0:
                self.h3_counters[self.h2_counter] = self.h3_counters.get(self.h2_counter, 0) + 1
                h3_num = self.h3_counters[self.h2_counter]
                self.h4_counters[f"{self.h2_counter}.{h3_num}"] = 0
                title = line[4:].strip()
                return f"### {self.h2_counter}.{h3_num} {title}"

        # H4标题
        elif line.startswith('#### ') and not re.match(r'####\s+\d+\.\d+\.\d+', line):
            if self.h2_counter > 0 and self.h3_counters.get(self.h2_counter, 0) > 0:
                h3_num = self.h3_counters[self.h2_counter]
                key = f"{self.h2_counter}.{h3_num}"
                self.h4_counters[key] = self.h4_counters.get(key, 0) + 1
                h4_num = self.h4_counters[key]
                title = line[5:].strip()
                return f"#### {self.h2_counter}.{h3_num}.{h4_num} {title}"

        return line

    def generate_toc(self, lines):
        """生成目录"""
        toc = ["## 目录\n"]
        for line in lines:
            # 匹配已有序号的标题
            match_h2 = re.match(r'^##\s+(\d+)\.\s+(.+)$', line)
            match_h3 = re.match(r'^###\s+(\d+\.\d+)\s+(.+)$', line)
            match_h4 = re.match(r'^####\s+(\d+\.\d+\.\d+)\s+(.+)$', line)

            if match_h2 and '目录' not in line:
                num, title = match_h2.groups()
                anchor = f"{num}-{title}".lower().replace(' ', '-')
                anchor = re.sub(r'[^\w\-\u4e00-\u9fa5]', '', anchor)
                toc.append(f"- [{num}. {title}](#{anchor})")

            elif match_h3:
                num, title = match_h3.groups()
                anchor = f"{num}-{title}".lower().replace(' ', '-')
                anchor = re.sub(r'[^\w\-\u4e00-\u9fa5]', '', anchor)
                toc.append(f"  - [{num} {title}](#{anchor})")

            elif match_h4:
                num, title = match_h4.groups()
                anchor = f"{num}-{title}".lower().replace(' ', '-')
                anchor = re.sub(r'[^\w\-\u4e00-\u9fa5]', '', anchor)
                toc.append(f"    - [{num} {title}](#{anchor})")

        return '\n'.join(toc) + '\n'

    def format_document(self, filepath):
        """格式化单个文档"""
        print(f"\n处理: {filepath}")

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()

            lines = content.split('\n')

            # 重置计数器
            self.reset_counters()

            # 为标题添加序号
            formatted_lines = []
            for line in lines:
                formatted_lines.append(self.add_number_to_heading(line))

            # 检查是否已有目录
            has_toc = any('## 目录' in line for line in formatted_lines)

            # 生成目录
            toc = self.generate_toc(formatted_lines)

            # 找到H1标题位置
            h1_index = -1
            for i, line in enumerate(formatted_lines):
                if line.startswith('# '):
                    h1_index = i
                    break

            # 插入或更新目录
            if not has_toc and h1_index >= 0:
                # 插入目录
                formatted_lines.insert(h1_index + 1, '\n' + toc)
                print("  ✅ 已添加目录")
            elif has_toc:
                # 更新现有目录
                toc_start = -1
                toc_end = -1
                for i, line in enumerate(formatted_lines):
                    if '## 目录' in line:
                        toc_start = i
                    elif toc_start >= 0 and line.startswith('## ') and '目录' not in line:
                        toc_end = i
                        break

                if toc_start >= 0 and toc_end > toc_start:
                    # 替换目录
                    formatted_lines[toc_start:toc_end] = [toc]
                    print("  ✅ 已更新目录")

            # 添加更新时间
            if '**最后更新**' not in content:
                formatted_lines.append('\n---\n')
                formatted_lines.append('**最后更新**: 2025-10-30')
                formatted_lines.append('**格式版本**: 1.0')

            # 写回文件
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write('\n'.join(formatted_lines))

            print(f"  ✅ 完成处理")
            return True

        except Exception as e:
            print(f"  ❌ 处理失败: {e}")
            return False

def main():
    if len(sys.argv) < 2:
        print("用法: python format_docs.py <文件路径>...")
        sys.exit(1)

    formatter = DocFormatter()
    success_count = 0
    fail_count = 0

    for filepath in sys.argv[1:]:
        path = Path(filepath)
        if path.is_file() and path.suffix == '.md':
            if formatter.format_document(filepath):
                success_count += 1
            else:
                fail_count += 1
        elif path.is_dir():
            for md_file in path.glob('*.md'):
                if formatter.format_document(md_file):
                    success_count += 1
                else:
                    fail_count += 1

    print(f"\n{'='*60}")
    print(f"处理完成: 成功 {success_count} 个, 失败 {fail_count} 个")
    print(f"{'='*60}")

if __name__ == '__main__':
    main()
```

保存为: `format_docs.py`

### 5.2 使用示例

```bash
# 处理单个文件
python format_docs.py 06-实战案例/06.01-语义搜索系统端到端实现.md

# 处理整个目录
python format_docs.py 06-实战案例/

# 批量处理多个文件
python format_docs.py 05-前沿技术/05.04*.md 05-前沿技术/05.05*.md

# 处理所有技术目录
python format_docs.py 01-核心基础/ 02-查询处理/ 03-高级特性/ 04-部署运维/ 05-前沿技术/ 06-实战案例/ 07-应用实践/ 08-工具资源/
```

---

## 6. 质量验证

### 6.1 自动检查

```python
#!/usr/bin/env python3
"""
文档质量检查工具
"""
def check_document(filepath):
    """检查文档质量"""
    issues = []

    with open(filepath, 'r', encoding='utf-8') as f:
        content = f.read()
        lines = content.split('\n')

    # 检查H1标题
    h1_count = sum(1 for line in lines if line.startswith('# '))
    if h1_count == 0:
        issues.append("缺少H1标题")
    elif h1_count > 1:
        issues.append("有多个H1标题")

    # 检查目录
    if '## 目录' not in content and '## Table of Contents' not in content:
        issues.append("缺少目录")

    # 检查H2序号
    for line in lines:
        if line.startswith('## ') and not line.startswith('## 目录'):
            if not re.match(r'##\s+\d+\.', line):
                issues.append(f"H2标题缺少序号: {line}")
                break

    # 检查代码块
    if '```' in content:
        code_blocks = content.count('```')
        if code_blocks % 2 != 0:
            issues.append("代码块未闭合")

    return issues

def main():
    import sys
    if len(sys.argv) < 2:
        print("用法: python check_docs.py <文件路径>")
        sys.exit(1)

    for filepath in sys.argv[1:]:
        print(f"\n检查: {filepath}")
        issues = check_document(filepath)
        if issues:
            for issue in issues:
                print(f"  ⚠️  {issue}")
        else:
            print("  ✅ 无问题")

if __name__ == '__main__':
    main()
```

保存为: `check_docs.py`

### 6.2 检查清单

处理后验证：

- [ ] 有清晰的H1标题
- [ ] 有完整的目录
- [ ] H2标题都有数字序号
- [ ] H3标题都有两级序号
- [ ] 目录链接与标题匹配
- [ ] 代码块正确闭合
- [ ] 没有破坏原有链接

---

## 7. 风险控制

### 7.1 备份策略

```bash
# 执行前备份
cp -r 01-核心基础 01-核心基础.backup
cp -r 02-查询处理 02-查询处理.backup
# ... 其他目录

# 或使用Git
git add -A
git commit -m "格式化前备份"
```

### 7.2 回滚方案

如果处理出现问题：

```bash
# 恢复备份
rm -rf 01-核心基础
cp -r 01-核心基础.backup 01-核心基础

# 或使用Git
git reset --hard HEAD^
```

### 7.3 分批执行

建议按优先级分批执行，每批完成后：

1. 检查处理结果
2. 验证文档可读性
3. 确认无问题后再继续

---

## 8. 时间估算

| 阶段 | 文件数 | 预计时间 | 累计时间 |
|------|--------|---------|---------|
| P0 | 11 | 2-3小时 | 2-3小时 |
| P1 | 25 | 4-5小时 | 6-8小时 |
| P2 | 19 | 3-4小时 | 9-12小时 |
| P3 | 11 | 2-3小时 | 11-15小时 |
| 验证 | 全部 | 2小时 | 13-17小时 |
| **总计** | **66+** | **13-17小时** | - |

**建议**: 分3-5天完成，每天2-4小时

---

## 9. 执行记录

### 9.1 进度跟踪

| 日期 | 阶段 | 处理文件 | 状态 | 备注 |
|------|------|---------|------|------|
| 2025-10-30 | 规划 | - | ✅ 完成 | 制定计划 |
| TBD | P0 | 11个 | ⏳ 待执行 | 核心文档 |
| TBD | P1 | 25个 | ⏳ 待执行 | 基础文档 |
| TBD | P2 | 19个 | ⏳ 待执行 | 功能文档 |
| TBD | P3 | 11个 | ⏳ 待执行 | 辅助文档 |

### 9.2 问题记录

| 文件 | 问题 | 解决方案 | 状态 |
|------|------|---------|------|
| - | - | - | - |

---

## 10. 完成标准

### 10.1 量化指标

- [ ] 100%的文档有H1标题
- [ ] 95%+的文档有目录
- [ ] 95%+的H2标题有序号
- [ ] 90%+的H3标题有序号
- [ ] 0个代码块未闭合
- [ ] 0个破坏的内部链接

### 10.2 定性目标

- [ ] 文档结构清晰统一
- [ ] 导航便捷高效
- [ ] 易于维护更新
- [ ] 用户反馈良好

---

**计划状态**: 待执行
**优先级**: 高
**负责人**: Documentation Team
**审核人**: TBD

---

**下一步**: 执行P0阶段，处理11个核心文档
