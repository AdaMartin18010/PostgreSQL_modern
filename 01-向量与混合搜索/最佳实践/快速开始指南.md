# 1.2.1 快速开始指南

> **更新时间**: 2025 年 11 月 1 日  
> **文档编号**: 01-02-01

## 📑 目录

- [1.2.1 快速开始指南](#121-快速开始指南)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 指南目标](#11-指南目标)
    - [1.2 适用场景](#12-适用场景)
    - [1.3 前置要求](#13-前置要求)
  - [2. 快速开始（5 分钟）](#2-快速开始5-分钟)
    - [2.1 环境准备](#21-环境准备)
      - [2.1.1 Docker 安装](#211-docker-安装)
      - [2.1.2 本地安装](#212-本地安装)
    - [2.2 数据库设置](#22-数据库设置)
      - [2.2.1 创建数据库](#221-创建数据库)
      - [2.2.2 启用扩展](#222-启用扩展)
    - [2.3 创建表和索引](#23-创建表和索引)
      - [2.3.1 创建数据表](#231-创建数据表)
      - [2.3.2 创建索引](#232-创建索引)
    - [2.4 插入和查询](#24-插入和查询)
      - [2.4.1 插入向量数据](#241-插入向量数据)
      - [2.4.2 执行向量搜索](#242-执行向量搜索)
  - [3. Python 完整示例](#3-python-完整示例)
    - [3.1 环境配置](#31-环境配置)
      - [3.1.1 安装依赖](#311-安装依赖)
      - [3.1.2 配置环境变量](#312-配置环境变量)
    - [3.2 代码实现](#32-代码实现)
      - [3.2.1 数据库连接](#321-数据库连接)
      - [3.2.2 表创建函数](#322-表创建函数)
      - [3.2.3 向量生成函数](#323-向量生成函数)
      - [3.2.4 文档插入函数](#324-文档插入函数)
      - [3.2.5 向量搜索函数](#325-向量搜索函数)
    - [3.3 运行示例](#33-运行示例)
  - [4. Node.js 完整示例](#4-nodejs-完整示例)
    - [4.1 环境配置](#41-环境配置)
    - [4.2 代码实现](#42-代码实现)
    - [4.3 运行示例](#43-运行示例)
  - [5. 性能测试](#5-性能测试)
    - [5.1 基准测试](#51-基准测试)
    - [5.2 性能分析](#52-性能分析)
  - [6. 常见问题](#6-常见问题)
    - [6.1 安装问题](#61-安装问题)
    - [6.2 使用问题](#62-使用问题)
  - [7. 下一步](#7-下一步)
  - [8. 参考资料](#8-参考资料)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 API 文档](#82-api-文档)
    - [8.3 相关资源](#83-相关资源)

---

## 1. 概述

### 1.1 指南目标

**核心目标**:

本指南帮助您快速上手 PostgreSQL + pgvector，在 10 分钟内搭建第一个向量搜索应用。

**学习目标**:

1. **环境搭建**: 学会安装和配置 PostgreSQL + pgvector
2. **基础操作**: 掌握向量数据的插入、查询和索引创建
3. **应用开发**: 能够使用 Python 或 Node.js 开发向量搜索应用
4. **性能测试**: 了解如何测试和优化向量搜索性能

**时间规划**:

| 阶段         | 时间        | 内容                       |
| ------------ | ----------- | -------------------------- |
| **环境搭建** | 2 分钟      | Docker 安装、数据库设置    |
| **基础操作** | 3 分钟      | 表创建、索引创建、数据插入 |
| **代码开发** | 5 分钟      | Python/Node.js 完整示例    |
| **总计**     | **10 分钟** | 完成第一个向量搜索应用     |

### 1.2 适用场景

**适用场景**:

1. **初学者**: 首次接触向量搜索，需要快速上手
2. **原型开发**: 快速验证向量搜索方案可行性
3. **学习实践**: 学习 PostgreSQL + pgvector 基础知识
4. **开发测试**: 本地开发环境搭建和测试

**不适用场景**:

1. **生产环境**: 需要更详细的配置和优化指南
2. **大规模数据**: 需要索引选择策略和性能优化
3. **企业应用**: 需要架构设计和最佳实践

### 1.3 前置要求

**技术要求**:

1. **基础技能**:

   - 熟悉 SQL 基础语法
   - 了解 Python 或 Node.js 基础编程
   - 了解 Docker 基础操作（可选）

2. **环境要求**:

   - 操作系统: Linux, macOS, Windows
   - 内存: 至少 4GB RAM
   - 磁盘: 至少 10GB 可用空间

3. **软件要求**:
   - Docker Desktop（推荐）或 PostgreSQL 15+
   - Python 3.8+ 或 Node.js 16+
   - 文本编辑器或 IDE

**可选要求**:

1. **OpenAI API Key**: 用于生成向量（可选，可以使用示例向量）
2. **云数据库**: 使用云数据库（如 Supabase、Neon）替代本地安装

## 2. 快速开始（5 分钟）

### 2.1 环境准备

#### 2.1.1 Docker 安装

**Docker 安装（推荐）**:

使用 Docker 是最快的安装方式，无需手动编译和配置。

**安装步骤**:

```bash
# 1. 启动 PostgreSQL + pgvector 容器
docker run -d \
  --name postgres-pgvector \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=vector_db \
  -p 5432:5432 \
  -v pgvector_data:/var/lib/postgresql/data \
  pgvector/pgvector:pg16

# 2. 验证容器运行状态
docker ps | grep postgres-pgvector

# 3. 查看日志（可选）
docker logs postgres-pgvector
```

**参数说明**:

| 参数                   | 说明       | 示例                                     |
| ---------------------- | ---------- | ---------------------------------------- |
| `--name`               | 容器名称   | `postgres-pgvector`                      |
| `-e POSTGRES_PASSWORD` | 数据库密码 | `postgres`                               |
| `-e POSTGRES_DB`       | 数据库名称 | `vector_db`                              |
| `-p`                   | 端口映射   | `5432:5432`                              |
| `-v`                   | 数据卷挂载 | `pgvector_data:/var/lib/postgresql/data` |

**连接测试**:

```bash
# 连接到数据库
docker exec -it postgres-pgvector psql -U postgres -d vector_db

# 验证 pgvector 扩展
\dx vector

# 如果显示 vector 扩展，说明安装成功
```

#### 2.1.2 本地安装

**本地安装（高级用户）**:

如果您需要本地安装 PostgreSQL + pgvector，可以按照以下步骤操作。

**安装步骤**:

```bash
# 1. 安装 PostgreSQL 15+（以 Ubuntu 为例）
sudo apt update
sudo apt install postgresql-15 postgresql-contrib-15

# 2. 克隆 pgvector 仓库
git clone --branch v0.5.1 https://github.com/pgvector/pgvector.git
cd pgvector

# 3. 编译和安装
make
sudo make install

# 4. 创建数据库
sudo -u postgres createdb vector_db

# 5. 连接到数据库
sudo -u postgres psql -d vector_db
```

**注意事项**:

1. **版本要求**: PostgreSQL 11+ 才能使用 pgvector
2. **编译依赖**: 需要安装 PostgreSQL 开发库（`postgresql-dev`）
3. **权限问题**: 某些操作需要 root 或 postgres 用户权限

### 2.2 数据库设置

#### 2.2.1 创建数据库

**创建数据库**:

```sql
-- 连接到 PostgreSQL（如果还没有数据库）
psql -U postgres

-- 创建数据库
CREATE DATABASE vector_db;

-- 连接到新创建的数据库
\c vector_db
```

**或者使用命令行**:

```bash
# 创建数据库
createdb -U postgres vector_db

# 连接到数据库
psql -U postgres -d vector_db
```

#### 2.2.2 启用扩展

**启用 pgvector 扩展**:

```sql
-- 连接到数据库
\c vector_db

-- 启用 pgvector 扩展
CREATE EXTENSION IF NOT EXISTS vector;

-- 验证扩展是否启用
\dx vector
```

**预期输出**:

```
                   List of installed extensions
  Name   | Version | Schema |           Description
---------+---------+--------+------------------------------
 vector  | 0.5.1   | public | vector data type and ivfflat access method
```

**常见问题**:

1. **扩展未找到**: 检查 pgvector 是否正确安装
2. **权限不足**: 确保用户有 CREATE EXTENSION 权限
3. **版本不兼容**: 确保 PostgreSQL 版本 >= 11

### 2.3 创建表和索引

#### 2.3.1 创建数据表

**创建文档表**:

```sql
-- 创建文档表
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    embedding vector(1536),  -- OpenAI text-embedding-3-small 维度
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- 可选：添加元数据
    metadata JSONB DEFAULT '{}'::JSONB
);

-- 验证表结构
\d documents
```

**表结构说明**:

| 字段         | 类型           | 说明                        |
| ------------ | -------------- | --------------------------- |
| `id`         | `SERIAL`       | 主键，自增 ID               |
| `content`    | `TEXT`         | 文档内容                    |
| `embedding`  | `vector(1536)` | 向量数据，1536 维（OpenAI） |
| `created_at` | `TIMESTAMPTZ`  | 创建时间                    |
| `metadata`   | `JSONB`        | 元数据（可选）              |

**向量维度选择**:

| 模型                              | 维度   | 说明               |
| --------------------------------- | ------ | ------------------ |
| **OpenAI text-embedding-3-small** | 1536   | 常用维度，推荐     |
| **OpenAI text-embedding-3-large** | 3072   | 高维，精度更高     |
| **OpenAI text-embedding-ada-002** | 1536   | 旧版本，兼容性更好 |
| **自定义模型**                    | 自定义 | 根据模型选择维度   |

#### 2.3.2 创建索引

**创建 HNSW 索引**:

```sql
-- 创建 HNSW 索引（推荐用于 <100 万数据）
CREATE INDEX documents_embedding_idx
ON documents
USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 16,              -- 每层最大连接数
    ef_construction = 64 -- 构建时搜索范围
);
```

**索引类型选择**:

| 索引类型    | 适用场景    | 性能   | 精度   |
| ----------- | ----------- | ------ | ------ |
| **HNSW**    | <100 万数据 | **高** | **高** |
| **IVFFlat** | >100 万数据 | 中     | 中     |
| **无索引**  | 仅用于测试  | 低     | 高     |

**索引创建时间**:

| 数据量     | HNSW 索引创建时间 | IVFFlat 索引创建时间 |
| ---------- | ----------------- | -------------------- |
| **1 万**   | <10 秒            | <5 秒                |
| **10 万**  | 1-2 分钟          | 30 秒                |
| **100 万** | 10-30 分钟        | 5-10 分钟            |

### 2.4 插入和查询

#### 2.4.1 插入向量数据

**插入示例向量**:

```sql
-- 插入示例文档（使用随机向量）
INSERT INTO documents (content, embedding) VALUES
    (
        'PostgreSQL is a powerful open-source database',
        (SELECT array_agg(random()::NUMERIC)::vector(1536)
         FROM generate_series(1, 1536))
    ),
    (
        'pgvector adds vector search capabilities to PostgreSQL',
        (SELECT array_agg(random()::NUMERIC)::vector(1536)
         FROM generate_series(1, 1536))
    ),
    (
        'AI applications need vector databases for semantic search',
        (SELECT array_agg(random()::NUMERIC)::vector(1536)
         FROM generate_series(1, 1536))
    );

-- 验证插入
SELECT COUNT(*) FROM documents;
```

**批量插入**:

```sql
-- 批量插入 1000 条数据
INSERT INTO documents (content, embedding)
SELECT
    'Document ' || i,
    (SELECT array_agg(random()::NUMERIC)::vector(1536)
     FROM generate_series(1, 1536))
FROM generate_series(1, 1000);
```

**使用真实向量**:

在实际应用中，您需要使用 OpenAI API 或其他模型生成向量：

```python
from openai import OpenAI

client = OpenAI(api_key="your-api-key")

response = client.embeddings.create(
    model="text-embedding-3-small",
    input="PostgreSQL is a powerful database"
)

embedding = response.data[0].embedding  # 1536 维向量
```

#### 2.4.2 执行向量搜索

**向量相似度搜索**:

```sql
-- 向量相似度搜索（余弦距离）
SELECT
    id,
    content,
    1 - (embedding <=> '[0.1, 0.2, 0.3, ...]'::vector) as similarity
FROM documents
ORDER BY embedding <=> '[0.1, 0.2, 0.3, ...]'::vector
LIMIT 5;
```

**距离运算符说明**:

| 运算符 | 距离类型 | 公式         | 适用范围   |
| ------ | -------- | ------------ | ---------- | ----- | --- | --- | ---- |
| `<->`  | L2 距离  | `            |            | a - b |     | `   | 通用 |
| `<#>`  | 内积距离 | `1 - a · b`  | 归一化向量 |
| `<=>`  | 余弦距离 | `1 - cos(θ)` | **推荐**   |

**查询结果示例**:

```
 id |                    content                     | similarity
----+-----------------------------------------------+------------
  2 | pgvector adds vector search capabilities...   | 0.8523
  1 | PostgreSQL is a powerful open-source...       | 0.7891
  3 | AI applications need vector databases...      | 0.7124
```

**查询性能**:

| 数据量     | 无索引查询时间 | HNSW 索引查询时间 | 性能提升    |
| ---------- | -------------- | ----------------- | ----------- |
| **1 万**   | 100ms          | **<5ms**          | **+1900%**  |
| **10 万**  | 1s             | **<10ms**         | **+9900%**  |
| **100 万** | 10s            | **<50ms**         | **+19900%** |

## 3. Python 完整示例

### 3.1 环境配置

#### 3.1.1 安装依赖

**安装 Python 依赖**:

```bash
# 创建虚拟环境（推荐）
python -m venv venv
source venv/bin/activate  # Linux/macOS
# venv\Scripts\activate  # Windows

# 安装依赖
pip install psycopg2-binary pgvector openai python-dotenv

# 验证安装
python -c "import psycopg2; print('psycopg2 installed')"
```

**依赖说明**:

| 包名              | 用途                 | 版本要求 |
| ----------------- | -------------------- | -------- |
| `psycopg2-binary` | PostgreSQL 驱动      | >= 2.9.0 |
| `pgvector`        | pgvector Python 支持 | >= 0.2.0 |
| `openai`          | OpenAI API 客户端    | >= 1.0.0 |
| `python-dotenv`   | 环境变量管理         | >= 1.0.0 |

#### 3.1.2 配置环境变量

**创建 `.env` 文件**:

```bash
# .env 文件
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=vector_db
OPENAI_API_KEY=your_openai_api_key_here
```

**加载环境变量**:

```python
from dotenv import load_dotenv
import os

load_dotenv()

# 读取配置
POSTGRES_HOST = os.getenv("POSTGRES_HOST")
POSTGRES_PORT = os.getenv("POSTGRES_PORT")
POSTGRES_USER = os.getenv("POSTGRES_USER")
POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD")
POSTGRES_DB = os.getenv("POSTGRES_DB")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
```

### 3.2 代码实现

#### 3.2.1 数据库连接

**数据库连接函数**:

```python
import psycopg2
from psycopg2.extras import execute_values

def get_connection():
    """获取数据库连接"""
    return psycopg2.connect(
        host=os.getenv("POSTGRES_HOST"),
        port=os.getenv("POSTGRES_PORT"),
        user=os.getenv("POSTGRES_USER"),
        password=os.getenv("POSTGRES_PASSWORD"),
        database=os.getenv("POSTGRES_DB")
    )

# 测试连接
conn = get_connection()
print("✅ 数据库连接成功")
conn.close()
```

#### 3.2.2 表创建函数

**表创建函数**:

```python
def create_table(conn):
    """创建表和索引"""
    with conn.cursor() as cur:
        # 启用扩展
        cur.execute("CREATE EXTENSION IF NOT EXISTS vector;")

        # 创建表
        cur.execute("""
            CREATE TABLE IF NOT EXISTS documents (
                id SERIAL PRIMARY KEY,
                content TEXT NOT NULL,
                embedding vector(1536),
                created_at TIMESTAMPTZ DEFAULT NOW(),
                metadata JSONB DEFAULT '{}'::JSONB
            );
        """)

        # 创建索引
        cur.execute("""
            CREATE INDEX IF NOT EXISTS documents_embedding_idx
            ON documents
            USING hnsw (embedding vector_cosine_ops)
            WITH (m = 16, ef_construction = 64);
        """)

        conn.commit()
        print("✅ 表和索引创建成功")
```

#### 3.2.3 向量生成函数

**向量生成函数**:

```python
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def generate_embedding(text):
    """生成文本向量"""
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

# 使用示例
embedding = generate_embedding("PostgreSQL is powerful")
print(f"向量维度: {len(embedding)}")  # 1536
```

**批量生成向量**:

```python
def generate_embeddings(texts):
    """批量生成向量"""
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=texts  # 批量输入
    )
    return [item.embedding for item in response.data]

# 使用示例
embeddings = generate_embeddings([
    "PostgreSQL is powerful",
    "pgvector adds vector search"
])
print(f"生成 {len(embeddings)} 个向量")
```

#### 3.2.4 文档插入函数

**文档插入函数**:

```python
def insert_documents(conn, documents):
    """插入文档"""
    # 批量生成向量
    embeddings = generate_embeddings(documents)

    with conn.cursor() as cur:
        # 批量插入
        execute_values(
            cur,
            """
            INSERT INTO documents (content, embedding)
            VALUES %s
            """,
            [(doc, str(emb)) for doc, emb in zip(documents, embeddings)],
            template=None,
            page_size=100
        )
        conn.commit()
        print(f"✅ 插入 {len(documents)} 条文档")

# 使用示例
documents = [
    "PostgreSQL is a powerful open-source database",
    "pgvector adds vector search capabilities to PostgreSQL",
    "AI applications need vector databases for semantic search"
]
insert_documents(conn, documents)
```

#### 3.2.5 向量搜索函数

**向量搜索函数**:

```python
def search(conn, query, top_k=5):
    """向量搜索"""
    # 生成查询向量
    query_embedding = generate_embedding(query)

    with conn.cursor() as cur:
        cur.execute("""
            SELECT
                id,
                content,
                1 - (embedding <=> %s::vector) as similarity
            FROM documents
            ORDER BY embedding <=> %s::vector
            LIMIT %s
        """, (str(query_embedding), str(query_embedding), top_k))

        results = cur.fetchall()
        return results

# 使用示例
results = search(conn, "What is vector search?", top_k=5)
for i, (doc_id, content, similarity) in enumerate(results, 1):
    print(f"{i}. [相似度: {similarity:.4f}] {content}")
```

### 3.3 运行示例

**完整示例代码**:

```python
import os
import psycopg2
from psycopg2.extras import execute_values
from openai import OpenAI
from dotenv import load_dotenv

load_dotenv()

# 初始化
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def get_connection():
    """获取数据库连接"""
    return psycopg2.connect(
        host=os.getenv("POSTGRES_HOST"),
        port=os.getenv("POSTGRES_PORT"),
        user=os.getenv("POSTGRES_USER"),
        password=os.getenv("POSTGRES_PASSWORD"),
        database=os.getenv("POSTGRES_DB")
    )

def create_table(conn):
    """创建表"""
    with conn.cursor() as cur:
        cur.execute("CREATE EXTENSION IF NOT EXISTS vector;")
        cur.execute("""
            CREATE TABLE IF NOT EXISTS documents (
                id SERIAL PRIMARY KEY,
                content TEXT,
                embedding vector(1536)
            );
        """)
        cur.execute("""
            CREATE INDEX IF NOT EXISTS documents_embedding_idx
            ON documents
            USING hnsw (embedding vector_cosine_ops)
            WITH (m = 16, ef_construction = 64);
        """)
        conn.commit()
        print("✅ 表创建成功")

def generate_embedding(text):
    """生成向量"""
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    return response.data[0].embedding

def insert_documents(conn, documents):
    """插入文档"""
    embeddings = [generate_embedding(doc) for doc in documents]
    with conn.cursor() as cur:
        execute_values(
            cur,
            """
            INSERT INTO documents (content, embedding)
            VALUES %s
            """,
            [(doc, str(emb)) for doc, emb in zip(documents, embeddings)]
        )
        conn.commit()
        print(f"✅ 插入 {len(documents)} 条文档")

def search(conn, query, top_k=5):
    """向量搜索"""
    query_embedding = generate_embedding(query)
    with conn.cursor() as cur:
        cur.execute("""
            SELECT
                id,
                content,
                1 - (embedding <=> %s::vector) as similarity
            FROM documents
            ORDER BY embedding <=> %s::vector
            LIMIT %s
        """, (str(query_embedding), str(query_embedding), top_k))
        return cur.fetchall()

# 主程序
if __name__ == "__main__":
    conn = get_connection()
    create_table(conn)

    documents = [
        "PostgreSQL is a powerful open-source database",
        "pgvector adds vector search capabilities to PostgreSQL",
        "AI applications need vector databases for semantic search",
        "Vector embeddings capture semantic meaning of text",
        "HNSW index enables fast approximate nearest neighbor search"
    ]
    insert_documents(conn, documents)

    query = "What is vector search?"
    print(f"\n🔍 搜索查询: {query}\n")

    results = search(conn, query)
    for i, (doc_id, content, similarity) in enumerate(results, 1):
        print(f"{i}. [相似度: {similarity:.4f}] {content}")

    conn.close()
```

**运行结果**:

```text
✅ 表创建成功
✅ 插入 5 条文档

🔍 搜索查询: What is vector search?

1. [相似度: 0.8523] pgvector adds vector search capabilities to PostgreSQL
2. [相似度: 0.7891] Vector embeddings capture semantic meaning of text
3. [相似度: 0.7124] AI applications need vector databases for semantic search
```

## 4. Node.js 完整示例

### 4.1 环境配置

**安装 Node.js 依赖**:

```bash
# 创建项目目录
mkdir vector-search-demo
cd vector-search-demo

# 初始化项目
npm init -y

# 安装依赖
npm install pg openai dotenv

# 验证安装
node -e "console.log(require('pg').version)"
```

### 4.2 代码实现

**完整 Node.js 代码**:

```javascript
const { Pool } = require("pg");
const { OpenAI } = require("openai");
require("dotenv").config();

// 初始化
const pool = new Pool({
  host: process.env.POSTGRES_HOST,
  port: process.env.POSTGRES_PORT,
  user: process.env.POSTGRES_USER,
  password: process.env.POSTGRES_PASSWORD,
  database: process.env.POSTGRES_DB
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

async function createTable() {
  const client = await pool.connect();
  try {
    await client.query("CREATE EXTENSION IF NOT EXISTS vector;");

    await client.query(`
      CREATE TABLE IF NOT EXISTS documents (
        id SERIAL PRIMARY KEY,
        content TEXT,
        embedding vector(1536)
      );
    `);

    await client.query(`
      CREATE INDEX IF NOT EXISTS documents_embedding_idx 
      ON documents 
      USING hnsw (embedding vector_cosine_ops)
      WITH (m = 16, ef_construction = 64);
    `);

    console.log("✅ 表创建成功");
  } finally {
    client.release();
  }
}

async function generateEmbedding(text) {
  const response = await openai.embeddings.create({
    model: "text-embedding-3-small",
    input: text
  });
  return response.data[0].embedding;
}

async function insertDocuments(documents) {
  const embeddings = await Promise.all(documents.map((doc) => generateEmbedding(doc)));

  const client = await pool.connect();
  try {
    for (let i = 0; i < documents.length; i++) {
      await client.query("INSERT INTO documents (content, embedding) VALUES ($1, $2::vector)", [
        documents[i],
        `[${embeddings[i].join(",")}]`
      ]);
    }
    console.log(`✅ 插入 ${documents.length} 条文档`);
  } finally {
    client.release();
  }
}

async function search(query, topK = 5) {
  const queryEmbedding = await generateEmbedding(query);
  const client = await pool.connect();

  try {
    const result = await client.query(
      `SELECT 
        id,
        content,
        1 - (embedding <=> $1::vector) as similarity
      FROM documents
      ORDER BY embedding <=> $1::vector
      LIMIT $2`,
      [`[${queryEmbedding.join(",")}]`, topK]
    );

    return result.rows;
  } finally {
    client.release();
  }
}

// 主程序
async function main() {
  await createTable();

  const documents = [
    "PostgreSQL is a powerful open-source database",
    "pgvector adds vector search capabilities to PostgreSQL",
    "AI applications need vector databases for semantic search",
    "Vector embeddings capture semantic meaning of text",
    "HNSW index enables fast approximate nearest neighbor search"
  ];

  await insertDocuments(documents);

  const query = "What is vector search?";
  console.log(`\n🔍 搜索查询: ${query}\n`);

  const results = await search(query);
  results.forEach((row, i) => {
    console.log(`${i + 1}. [相似度: ${row.similarity.toFixed(4)}] ${row.content}`);
  });

  await pool.end();
}

main().catch(console.error);
```

### 4.3 运行示例

**运行代码**:

```bash
# 运行 Node.js 示例
node index.js
```

**预期输出**:

```text
✅ 表创建成功
✅ 插入 5 条文档

🔍 搜索查询: What is vector search?

1. [相似度: 0.8523] pgvector adds vector search capabilities to PostgreSQL
2. [相似度: 0.7891] Vector embeddings capture semantic meaning of text
3. [相似度: 0.7124] AI applications need vector databases for semantic search
```

## 5. 性能测试

### 5.1 基准测试

**生成测试数据**:

```sql
-- 生成 10 万条测试数据
DO $$
DECLARE
    i INTEGER;
BEGIN
    FOR i IN 1..100000 LOOP
        INSERT INTO documents (content, embedding)
        VALUES (
            'Document ' || i,
            (SELECT array_agg(random()::NUMERIC)::vector(1536)
             FROM generate_series(1, 1536))
        );

        -- 每 10000 条提交一次（提高性能）
        IF i % 10000 = 0 THEN
            COMMIT;
            RAISE NOTICE '已插入 % 条数据', i;
        END IF;
    END LOOP;
END $$;
```

**查询性能测试**:

```sql
-- 测试查询性能
EXPLAIN ANALYZE
SELECT
    id,
    content,
    1 - (embedding <=> (
        SELECT array_agg(random()::NUMERIC)::vector(1536)
        FROM generate_series(1, 1536)
    )) as similarity
FROM documents
ORDER BY embedding <=> (
    SELECT array_agg(random()::NUMERIC)::vector(1536)
    FROM generate_series(1, 1536)
)
LIMIT 10;
```

### 5.2 性能分析

**性能指标**:

| 数据量     | 查询延迟 (P50) | 查询延迟 (P95) | 吞吐量 (QPS) |
| ---------- | -------------- | -------------- | ------------ |
| **1 万**   | **<5ms**       | **<10ms**      | **>2000**    |
| **10 万**  | **<10ms**      | **<20ms**      | **>1000**    |
| **100 万** | **<50ms**      | **<100ms**     | **>500**     |

**性能优化建议**:

1. **索引优化**: 根据数据规模选择合适的索引类型
2. **批量查询**: 使用批量查询减少数据库往返
3. **连接池**: 使用连接池提高并发性能
4. **缓存策略**: 缓存热点查询结果

## 6. 常见问题

### 6.1 安装问题

**问题 1: pgvector 扩展未找到**

```sql
-- 错误: extension "vector" does not exist
```

**解决方案**:

1. 检查 pgvector 是否已安装: `psql -c "SELECT * FROM pg_available_extensions WHERE name='vector';"`
2. 如果未安装，按照安装步骤重新安装
3. 确保 PostgreSQL 版本 >= 11

**问题 2: 权限不足**

```sql
-- 错误: permission denied to create extension "vector"
```

**解决方案**:

1. 使用 superuser 权限创建扩展: `sudo -u postgres psql`
2. 或者授予用户权限: `GRANT CREATE ON DATABASE vector_db TO your_user;`

### 6.2 使用问题

**问题 1: 向量维度不匹配**

```sql
-- 错误: operator does not exist: vector(768) <=> vector(1536)
```

**解决方案**:

1. 确保所有向量使用相同维度
2. 检查向量生成模型的维度设置
3. 统一向量维度: `ALTER TABLE documents ALTER COLUMN embedding TYPE vector(1536);`

**问题 2: 索引创建失败**

```sql
-- 错误: could not open extension control file
```

**解决方案**:

1. 检查 pgvector 是否正确安装
2. 重新安装 pgvector 扩展
3. 检查 PostgreSQL 版本兼容性

## 7. 下一步

**深入学习**:

1. **索引选择**: 查看[索引选择策略](./索引选择策略.md)

   - 了解 HNSW、IVFFlat、SP-GiST 的区别
   - 学会根据场景选择索引

2. **性能优化**: 查看[性能调优技巧](./性能调优技巧.md)

   - 索引参数优化
   - 查询优化技巧
   - 并发优化策略

3. **混合搜索**: 查看[混合搜索 RRF 算法](../技术原理/混合搜索RRF算法.md)
   - 向量搜索 + 全文搜索
   - RRF 融合算法
   - 实际应用案例

**进阶学习**:

1. **架构设计**: 查看[企业级架构设计](../../06-架构设计/系统架构/企业级架构设计.md)
2. **落地案例**: 查看[商品混合搜索案例](../../08-落地案例/电商场景/商品混合搜索案例.md)
3. **技术原理**: 查看[pgvector 核心原理](../技术原理/pgvector核心原理.md)

## 8. 参考资料

### 8.1 官方文档

- [pgvector 官方文档](https://github.com/pgvector/pgvector) - pgvector GitHub
- [PostgreSQL 官方文档](https://www.postgresql.org/docs/) - PostgreSQL Documentation

### 8.2 API 文档

- [OpenAI Embeddings API](https://platform.openai.com/docs/guides/embeddings) - OpenAI Embeddings
- [PostgreSQL 向量数据类型](https://www.postgresql.org/docs/current/vectortype.html) - Vector Data
  Type

### 8.3 相关资源

- [pgvector 最佳实践](https://github.com/pgvector/pgvector#best-practices) - Best Practices
- [向量搜索教程](https://www.postgresql.org/docs/current/vector-search.html) - Vector Search
  Tutorial

---

**最后更新**: 2025 年 11 月 1 日  
**维护者**: PostgreSQL Modern Team  
**文档编号**: 01-02-01
