# 查询性能优化

> **更新时间**: 2025 年 11 月 1 日  
> **技术版本**: PostgreSQL 16+ / pgvector 0.7.0+  
> **文档编号**: 01-04-02

## 📑 目录

- [查询性能优化](#查询性能优化)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
  - [2. 查询优化策略](#2-查询优化策略)
    - [2.1 查询计划优化](#21-查询计划优化)
    - [2.2 过滤条件优化](#22-过滤条件优化)
  - [3. 索引优化](#3-索引优化)
    - [3.1 复合索引](#31-复合索引)
  - [4. 并行查询优化](#4-并行查询优化)
  - [5. 缓存优化](#5-缓存优化)
  - [6. 最佳实践](#6-最佳实践)
  - [7. 参考资料](#7-参考资料)

---

## 1. 概述

查询性能优化是向量搜索系统的核心，需要从多个维度进行优化。

---

## 2. 查询优化策略

### 2.1 查询计划优化

```sql
-- 查看查询计划
EXPLAIN ANALYZE
SELECT id, content, embedding <=> $1 as distance
FROM documents
ORDER BY embedding <=> $1
LIMIT 10;

-- 强制使用索引
SET enable_seqscan = off;
```

### 2.2 过滤条件优化

```sql
-- 先过滤后搜索（推荐）
SELECT id, embedding <=> $1 as distance
FROM documents
WHERE category = 'electronics'
  AND price BETWEEN 100 AND 500
ORDER BY embedding <=> $1
LIMIT 10;
```

---

## 3. 索引优化

### 3.1 复合索引

```sql
-- 创建复合索引
CREATE INDEX ON documents (category, price)
WHERE category IS NOT NULL;

-- 向量索引
CREATE INDEX ON documents
USING hnsw (embedding vector_cosine_ops);
```

---

## 4. 并行查询优化

```sql
-- 启用并行查询
SET max_parallel_workers_per_gather = 4;
SET parallel_tuple_cost = 0.1;
```

---

## 5. 缓存优化

```python
# 查询结果缓存
from functools import lru_cache

@lru_cache(maxsize=1000)
def cached_search(query_vector):
    return execute_search(query_vector)
```

---

## 6. 最佳实践

1. **索引优先**: 确保所有查询都使用索引
2. **过滤优化**: 先过滤后搜索
3. **并行查询**: 启用并行查询提升性能
4. **结果缓存**: 缓存热点查询结果

---

## 7. 参考资料

- [HNSW 性能优化](./HNSW性能优化.md)
- [性能调优技巧](../最佳实践/性能调优技巧.md)

---

**最后更新**: 2025 年 11 月 1 日  
**维护者**: PostgreSQL Modern Team
