# å¤§è§„æ¨¡å‘é‡å­˜å‚¨æ–¹æ¡ˆ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 01-03-03

## ğŸ“‘ ç›®å½•

- [å¤§è§„æ¨¡å‘é‡å­˜å‚¨æ–¹æ¡ˆ](#å¤§è§„æ¨¡å‘é‡å­˜å‚¨æ–¹æ¡ˆ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æŠ€æœ¯èƒŒæ™¯](#11-æŠ€æœ¯èƒŒæ™¯)
    - [1.2 å­˜å‚¨è§„æ¨¡åˆ†ç±»](#12-å­˜å‚¨è§„æ¨¡åˆ†ç±»)
  - [2. å­˜å‚¨æ¶æ„](#2-å­˜å‚¨æ¶æ„)
    - [2.1 å•æœºå­˜å‚¨æ¶æ„](#21-å•æœºå­˜å‚¨æ¶æ„)
    - [2.2 åˆ†ç‰‡å­˜å‚¨æ¶æ„](#22-åˆ†ç‰‡å­˜å‚¨æ¶æ„)
  - [3. åˆ†ç‰‡ç­–ç•¥](#3-åˆ†ç‰‡ç­–ç•¥)
    - [3.1 å“ˆå¸Œåˆ†ç‰‡](#31-å“ˆå¸Œåˆ†ç‰‡)
    - [3.2 èŒƒå›´åˆ†ç‰‡](#32-èŒƒå›´åˆ†ç‰‡)
    - [3.3 å‘é‡èšç±»åˆ†ç‰‡](#33-å‘é‡èšç±»åˆ†ç‰‡)
  - [4. æ•°æ®åˆ†å¸ƒ](#4-æ•°æ®åˆ†å¸ƒ)
    - [4.1 å‡åŒ€åˆ†å¸ƒ](#41-å‡åŒ€åˆ†å¸ƒ)
  - [5. æŸ¥è¯¢è·¯ç”±](#5-æŸ¥è¯¢è·¯ç”±)
    - [5.1 å•åˆ†ç‰‡æŸ¥è¯¢](#51-å•åˆ†ç‰‡æŸ¥è¯¢)
    - [5.2 å¤šåˆ†ç‰‡æŸ¥è¯¢](#52-å¤šåˆ†ç‰‡æŸ¥è¯¢)
  - [6. å®è·µæ¡ˆä¾‹](#6-å®è·µæ¡ˆä¾‹)
    - [6.1 åäº¿çº§å‘é‡å­˜å‚¨](#61-åäº¿çº§å‘é‡å­˜å‚¨)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 æŠ€æœ¯èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

å¤§è§„æ¨¡å‘é‡å­˜å‚¨é¢ä¸´çš„æŒ‘æˆ˜ï¼š

- **æ•°æ®é‡**: åäº¿çº§å‘é‡å­˜å‚¨
- **æŸ¥è¯¢æ€§èƒ½**: æ¯«ç§’çº§å“åº”æ—¶é—´
- **å­˜å‚¨æˆæœ¬**: ä¼˜åŒ–å­˜å‚¨ç©ºé—´
- **æ‰©å±•æ€§**: æ”¯æŒåŠ¨æ€æ‰©å®¹

**æŠ€æœ¯æ¼”è¿›**:

1. **2020 å¹´**: å•æœºå­˜å‚¨æ–¹æ¡ˆ
2. **2023 å¹´**: åˆ†ç‰‡å­˜å‚¨æ–¹æ¡ˆ
3. **2025 å¹´**: åˆ†å¸ƒå¼å­˜å‚¨æ–¹æ¡ˆ

### 1.2 å­˜å‚¨è§„æ¨¡åˆ†ç±»

| è§„æ¨¡ | å‘é‡æ•°é‡ | å­˜å‚¨æ–¹æ¡ˆ | æ¶æ„æ¨¡å¼ |
|------|---------|---------|---------|
| å°è§„æ¨¡ | < 1000 ä¸‡ | å•æœºå­˜å‚¨ | å•æœºæ¶æ„ |
| ä¸­è§„æ¨¡ | 1000 ä¸‡ - 1 äº¿ | ä¸»ä»å­˜å‚¨ | ä¸»ä»æ¶æ„ |
| å¤§è§„æ¨¡ | > 1 äº¿ | åˆ†ç‰‡å­˜å‚¨ | åˆ†ç‰‡æ¶æ„ |

## 2. å­˜å‚¨æ¶æ„

### 2.1 å•æœºå­˜å‚¨æ¶æ„

```sql
-- å•æœºå­˜å‚¨è¡¨è®¾è®¡
CREATE TABLE vectors (
    id BIGSERIAL PRIMARY KEY,
    embedding vector(1536),
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY HASH (id);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE vectors_0 PARTITION OF vectors
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE vectors_1 PARTITION OF vectors
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE vectors_2 PARTITION OF vectors
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE vectors_3 PARTITION OF vectors
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);

-- æ¯ä¸ªåˆ†åŒºåˆ›å»ºç´¢å¼•
CREATE INDEX ON vectors_0 USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON vectors_1 USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON vectors_2 USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON vectors_3 USING hnsw (embedding vector_cosine_ops);
```

### 2.2 åˆ†ç‰‡å­˜å‚¨æ¶æ„

```python
# åˆ†ç‰‡å­˜å‚¨ç®¡ç†
class ShardedVectorStorage:
    def __init__(self, shard_configs):
        self.shards = []
        for config in shard_configs:
            shard = VectorShard(config)
            self.shards.append(shard)

    async def insert(self, vectors):
        """æ’å…¥å‘é‡åˆ°å¯¹åº”åˆ†ç‰‡"""
        shard_vectors = {}
        for vector in vectors:
            shard_id = self._get_shard_id(vector['id'])
            if shard_id not in shard_vectors:
                shard_vectors[shard_id] = []
            shard_vectors[shard_id].append(vector)

        # å¹¶è¡Œæ’å…¥åˆ°å„åˆ†ç‰‡
        tasks = []
        for shard_id, vectors in shard_vectors.items():
            task = self.shards[shard_id].insert(vectors)
            tasks.append(task)

        await asyncio.gather(*tasks)

    def _get_shard_id(self, vector_id):
        """æ ¹æ®å‘é‡ ID è®¡ç®—åˆ†ç‰‡ ID"""
        return vector_id % len(self.shards)
```

## 3. åˆ†ç‰‡ç­–ç•¥

### 3.1 å“ˆå¸Œåˆ†ç‰‡

```python
# å“ˆå¸Œåˆ†ç‰‡ç­–ç•¥
class HashShardingStrategy:
    def __init__(self, num_shards):
        self.num_shards = num_shards

    def get_shard(self, vector_id):
        """æ ¹æ®å‘é‡ ID å“ˆå¸Œå€¼é€‰æ‹©åˆ†ç‰‡"""
        return hash(vector_id) % self.num_shards
```

### 3.2 èŒƒå›´åˆ†ç‰‡

```python
# èŒƒå›´åˆ†ç‰‡ç­–ç•¥
class RangeShardingStrategy:
    def __init__(self, ranges):
        """
        ranges: [(start_id, end_id, shard_id), ...]
        """
        self.ranges = sorted(ranges, key=lambda x: x[0])

    def get_shard(self, vector_id):
        """æ ¹æ®å‘é‡ ID èŒƒå›´é€‰æ‹©åˆ†ç‰‡"""
        for start, end, shard_id in self.ranges:
            if start <= vector_id < end:
                return shard_id
        raise ValueError(f"Vector ID {vector_id} out of range")
```

### 3.3 å‘é‡èšç±»åˆ†ç‰‡

```python
# åŸºäºå‘é‡èšç±»çš„åˆ†ç‰‡ç­–ç•¥
class ClusteringShardingStrategy:
    def __init__(self, centroids):
        """
        centroids: æ¯ä¸ªåˆ†ç‰‡çš„ä¸­å¿ƒå‘é‡
        """
        self.centroids = centroids

    def get_shard(self, vector):
        """æ ¹æ®å‘é‡ä¸ä¸­å¿ƒå‘é‡çš„è·ç¦»é€‰æ‹©åˆ†ç‰‡"""
        min_distance = float('inf')
        best_shard = 0

        for shard_id, centroid in enumerate(self.centroids):
            distance = self._cosine_distance(vector, centroid)
            if distance < min_distance:
                min_distance = distance
                best_shard = shard_id

        return best_shard
```

## 4. æ•°æ®åˆ†å¸ƒ

### 4.1 å‡åŒ€åˆ†å¸ƒ

```python
# ç¡®ä¿æ•°æ®å‡åŒ€åˆ†å¸ƒ
class UniformDistribution:
    def __init__(self, num_shards):
        self.num_shards = num_shards
        self.shard_counts = [0] * num_shards

    def get_shard(self, vector_id):
        """è½®è¯¢åˆ†é…ï¼Œç¡®ä¿å‡åŒ€åˆ†å¸ƒ"""
        shard_id = vector_id % self.num_shards
        self.shard_counts[shard_id] += 1
        return shard_id

    def get_distribution_stats(self):
        """è·å–åˆ†å¸ƒç»Ÿè®¡"""
        total = sum(self.shard_counts)
        return {
            'shard_counts': self.shard_counts,
            'average': total / self.num_shards,
            'variance': self._calculate_variance(self.shard_counts)
        }
```

## 5. æŸ¥è¯¢è·¯ç”±

### 5.1 å•åˆ†ç‰‡æŸ¥è¯¢

```python
# å•åˆ†ç‰‡æŸ¥è¯¢è·¯ç”±
class SingleShardQueryRouter:
    def __init__(self, shard_manager):
        self.shard_manager = shard_manager

    async def search(self, query_vector, limit=10):
        """å¦‚æœçŸ¥é“å‘é‡ IDï¼Œç›´æ¥è·¯ç”±åˆ°å¯¹åº”åˆ†ç‰‡"""
        # å‡è®¾å¯ä»¥é€šè¿‡æŸç§æ–¹å¼ç¡®å®šç›®æ ‡åˆ†ç‰‡
        target_shard = self._determine_target_shard(query_vector)

        return await self.shard_manager.shards[target_shard].search(
            query_vector,
            limit
        )
```

### 5.2 å¤šåˆ†ç‰‡æŸ¥è¯¢

```python
# å¤šåˆ†ç‰‡æŸ¥è¯¢è·¯ç”±
class MultiShardQueryRouter:
    def __init__(self, shard_manager):
        self.shard_manager = shard_manager

    async def search(self, query_vector, limit=10):
        """åœ¨æ‰€æœ‰åˆ†ç‰‡ä¸Šæœç´¢ï¼Œç„¶ååˆå¹¶ç»“æœ"""
        # 1. å¹¶è¡Œåœ¨æ‰€æœ‰åˆ†ç‰‡ä¸Šæœç´¢
        tasks = []
        for shard in self.shard_manager.shards:
            task = shard.search(query_vector, limit * 2)
            tasks.append(task)

        results = await asyncio.gather(*tasks)

        # 2. åˆå¹¶ç»“æœ
        merged_results = self._merge_results(results, limit)

        return merged_results

    def _merge_results(self, results, limit):
        """åˆå¹¶å¤šä¸ªåˆ†ç‰‡çš„æœç´¢ç»“æœ"""
        all_results = []
        for shard_results in results:
            all_results.extend(shard_results)

        # æŒ‰ç›¸ä¼¼åº¦æ’åº
        all_results.sort(key=lambda x: x['similarity'], reverse=True)

        return all_results[:limit]
```

## 6. å®è·µæ¡ˆä¾‹

### 6.1 åäº¿çº§å‘é‡å­˜å‚¨

```python
# åäº¿çº§å‘é‡å­˜å‚¨æ–¹æ¡ˆ
class BillionVectorStorage:
    def __init__(self):
        # 100 ä¸ªåˆ†ç‰‡ï¼Œæ¯ä¸ªåˆ†ç‰‡å­˜å‚¨ 1000 ä¸‡å‘é‡
        self.num_shards = 100
        self.shards = self._initialize_shards()

    def _initialize_shards(self):
        """åˆå§‹åŒ–åˆ†ç‰‡"""
        shards = []
        for i in range(self.num_shards):
            shard_config = {
                'host': f'shard-{i}.example.com',
                'database': 'vectordb',
                'table': 'vectors'
            }
            shards.append(VectorShard(shard_config))
        return shards

    async def insert_batch(self, vectors, batch_size=10000):
        """æ‰¹é‡æ’å…¥"""
        for i in range(0, len(vectors), batch_size):
            batch = vectors[i:i + batch_size]
            await self.insert(batch)

    async def search(self, query_vector, limit=10):
        """å…¨å±€æœç´¢"""
        router = MultiShardQueryRouter(self)
        return await router.search(query_vector, limit)
```

## 7. å‚è€ƒèµ„æ–™

- [å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡](./å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡.md)
- [PostgreSQL åˆ†åŒºè¡¨](../03-Serverlessä¸åˆ†æ”¯/PostgreSQLåŸ¹è®­/åˆ†åŒºè¡¨ç®¡ç†.md)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 01-03-03
