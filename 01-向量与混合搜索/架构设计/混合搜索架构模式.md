# æ··åˆæœç´¢æ¶æ„æ¨¡å¼

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 01-03-02

## ğŸ“‘ ç›®å½•

- [æ··åˆæœç´¢æ¶æ„æ¨¡å¼](#æ··åˆæœç´¢æ¶æ„æ¨¡å¼)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æŠ€æœ¯èƒŒæ™¯](#11-æŠ€æœ¯èƒŒæ™¯)
    - [1.2 æ¶æ„å®šä½](#12-æ¶æ„å®šä½)
  - [2. æ¶æ„æ¨¡å¼](#2-æ¶æ„æ¨¡å¼)
    - [2.1 åŒæ­¥èåˆæ¨¡å¼](#21-åŒæ­¥èåˆæ¨¡å¼)
    - [2.2 å¼‚æ­¥èåˆæ¨¡å¼](#22-å¼‚æ­¥èåˆæ¨¡å¼)
  - [3. èåˆç­–ç•¥](#3-èåˆç­–ç•¥)
    - [3.1 RRF èåˆå®ç°](#31-rrf-èåˆå®ç°)
    - [3.2 åŠ æƒèåˆç­–ç•¥](#32-åŠ æƒèåˆç­–ç•¥)
  - [4. æ€§èƒ½ä¼˜åŒ–](#4-æ€§èƒ½ä¼˜åŒ–)
    - [4.1 ç¼“å­˜ç­–ç•¥](#41-ç¼“å­˜ç­–ç•¥)
    - [4.2 æŸ¥è¯¢ä¼˜åŒ–](#42-æŸ¥è¯¢ä¼˜åŒ–)
  - [5. å®è·µæ¡ˆä¾‹](#5-å®è·µæ¡ˆä¾‹)
    - [5.1 ç”µå•†æœç´¢æ¶æ„](#51-ç”µå•†æœç´¢æ¶æ„)
  - [6. å‚è€ƒèµ„æ–™](#6-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 æŠ€æœ¯èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

å•ä¸€æœç´¢æ–¹å¼æ— æ³•æ»¡è¶³å¤æ‚æŸ¥è¯¢éœ€æ±‚ï¼š

- **æ–‡æœ¬æœç´¢**: ç²¾ç¡®åŒ¹é…å…³é”®è¯ï¼Œä½†æ— æ³•ç†è§£è¯­ä¹‰
- **å‘é‡æœç´¢**: ç†è§£è¯­ä¹‰ï¼Œä½†å¯èƒ½é—æ¼ç²¾ç¡®åŒ¹é…
- **æ··åˆæœç´¢**: ç»“åˆä¸¤è€…ä¼˜åŠ¿ï¼Œæå‡å¬å›ç‡å’Œå‡†ç¡®ç‡

**æŠ€æœ¯æ¼”è¿›**:

1. **2020 å¹´**: å‘é‡æœç´¢å…´èµ·
2. **2023 å¹´**: RRF èåˆç®—æ³•æ ‡å‡†åŒ–
3. **2025 å¹´**: æ··åˆæœç´¢æˆä¸ºä¸»æµæ¶æ„

### 1.2 æ¶æ„å®šä½

**æ··åˆæœç´¢æ¶æ„**:

```text
æŸ¥è¯¢è¯·æ±‚
  â†“
æŸ¥è¯¢è§£æå±‚
  â”œâ”€â”€ æå–å…³é”®è¯
  â””â”€â”€ ç”Ÿæˆå‘é‡åµŒå…¥
  â†“
å¹¶è¡Œæœç´¢å±‚
  â”œâ”€â”€ å…¨æ–‡æœç´¢ï¼ˆPostgreSQL tsvectorï¼‰
  â””â”€â”€ å‘é‡æœç´¢ï¼ˆpgvectorï¼‰
  â†“
ç»“æœèåˆå±‚ï¼ˆRRFï¼‰
  â”œâ”€â”€ åˆ†æ•°å½’ä¸€åŒ–
  â”œâ”€â”€ RRF èåˆ
  â””â”€â”€ ç»“æœæ’åº
  â†“
ç»“æœè¿”å›
```

## 2. æ¶æ„æ¨¡å¼

### 2.1 åŒæ­¥èåˆæ¨¡å¼

```python
# åŒæ­¥æ‰§è¡Œä¸¤ç§æœç´¢ï¼Œç„¶åèåˆ
class SynchronousHybridSearch:
    async def search(self, query: str, limit: int = 10):
        # 1. å¹¶è¡Œæ‰§è¡Œä¸¤ç§æœç´¢
        text_results, vector_results = await asyncio.gather(
            self.text_search(query, limit * 2),
            self.vector_search(query, limit * 2)
        )

        # 2. RRF èåˆ
        fused_results = self.rrf_fusion(
            text_results,
            vector_results,
            k=60
        )

        return fused_results[:limit]
```

### 2.2 å¼‚æ­¥èåˆæ¨¡å¼

```python
# å…ˆè¿”å›å¿«é€Ÿç»“æœï¼Œå†å¼‚æ­¥ä¼˜åŒ–
class AsynchronousHybridSearch:
    async def search(self, query: str, limit: int = 10):
        # 1. å¿«é€Ÿè¿”å›æ–‡æœ¬æœç´¢ç»“æœ
        text_results = await self.text_search(query, limit)

        # 2. å¼‚æ­¥æ‰§è¡Œå‘é‡æœç´¢
        vector_task = asyncio.create_task(
            self.vector_search(query, limit * 2)
        )

        # 3. å…ˆè¿”å›æ–‡æœ¬ç»“æœ
        yield text_results

        # 4. ç­‰å¾…å‘é‡æœç´¢å®Œæˆå¹¶èåˆ
        vector_results = await vector_task
        fused_results = self.rrf_fusion(
            text_results,
            vector_results,
            k=60
        )

        yield fused_results
```

## 3. èåˆç­–ç•¥

### 3.1 RRF èåˆå®ç°

```sql
-- PostgreSQL å‡½æ•°å®ç°
CREATE OR REPLACE FUNCTION rrf_fusion(
    text_rank BIGINT,
    vector_rank BIGINT,
    k INTEGER DEFAULT 60
) RETURNS FLOAT AS $$
BEGIN
    RETURN 1.0 / (k + text_rank) + 1.0 / (k + vector_rank);
END;
$$ LANGUAGE plpgsql;

-- æ··åˆæœç´¢æŸ¥è¯¢
WITH text_search AS (
    SELECT id, ts_rank_cd(to_tsvector('english', content), query) AS rank
    FROM documents, to_tsquery('english', 'query') query
    ORDER BY rank DESC
    LIMIT 20
),
vector_search AS (
    SELECT id, 1 - (embedding <=> query_vector) AS similarity
    FROM documents
    ORDER BY embedding <=> query_vector
    LIMIT 20
),
combined AS (
    SELECT
        COALESCE(t.id, v.id) AS id,
        COALESCE(t.rank, 0) AS text_rank,
        COALESCE(v.similarity, 0) AS vector_similarity,
        rrf_fusion(
            ROW_NUMBER() OVER (ORDER BY t.rank DESC),
            ROW_NUMBER() OVER (ORDER BY v.similarity DESC)
        ) AS rrf_score
    FROM text_search t
    FULL OUTER JOIN vector_search v ON t.id = v.id
)
SELECT id, rrf_score
FROM combined
ORDER BY rrf_score DESC
LIMIT 10;
```

### 3.2 åŠ æƒèåˆç­–ç•¥

```python
# åŠ æƒèåˆ
class WeightedHybridSearch:
    def __init__(self, text_weight=0.4, vector_weight=0.6):
        self.text_weight = text_weight
        self.vector_weight = vector_weight

    def fuse(self, text_results, vector_results):
        # å½’ä¸€åŒ–åˆ†æ•°
        text_scores = self._normalize(text_results)
        vector_scores = self._normalize(vector_results)

        # åŠ æƒèåˆ
        fused_scores = {}
        for doc_id, score in text_scores.items():
            fused_scores[doc_id] = self.text_weight * score

        for doc_id, score in vector_scores.items():
            if doc_id in fused_scores:
                fused_scores[doc_id] += self.vector_weight * score
            else:
                fused_scores[doc_id] = self.vector_weight * score

        # æ’åºè¿”å›
        return sorted(
            fused_scores.items(),
            key=lambda x: x[1],
            reverse=True
        )
```

## 4. æ€§èƒ½ä¼˜åŒ–

### 4.1 ç¼“å­˜ç­–ç•¥

```python
# æ··åˆæœç´¢ç¼“å­˜
class HybridSearchCache:
    def __init__(self):
        self.cache = {}

    async def search(self, query: str):
        # æ£€æŸ¥ç¼“å­˜
        cache_key = self._get_cache_key(query)
        if cache_key in self.cache:
            return self.cache[cache_key]

        # æ‰§è¡Œæœç´¢
        result = await self._execute_search(query)

        # ç¼“å­˜ç»“æœ
        self.cache[cache_key] = result
        return result
```

### 4.2 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä¼˜åŒ–åçš„æ··åˆæœç´¢æŸ¥è¯¢
WITH text_search AS (
    SELECT id, ts_rank_cd(to_tsvector('english', content), query) AS rank
    FROM documents
    WHERE to_tsvector('english', content) @@ to_tsquery('english', 'query')
    ORDER BY rank DESC
    LIMIT 20
),
vector_search AS (
    SELECT id, embedding <=> query_vector AS distance
    FROM documents
    ORDER BY embedding <=> query_vector
    LIMIT 20
)
-- ä½¿ç”¨ç´¢å¼•æç¤ºä¼˜åŒ–
SELECT * FROM (
    SELECT id FROM text_search
    UNION
    SELECT id FROM vector_search
) combined
LIMIT 10;
```

## 5. å®è·µæ¡ˆä¾‹

### 5.1 ç”µå•†æœç´¢æ¶æ„

```python
# ç”µå•†æ··åˆæœç´¢
class ECommerceHybridSearch:
    async def search_products(self, query: str):
        # 1. æ–‡æœ¬æœç´¢ï¼ˆç²¾ç¡®åŒ¹é…ï¼‰
        text_results = await self.db.execute("""
            SELECT id, name, price
            FROM products
            WHERE name ILIKE $1 OR description ILIKE $1
            ORDER BY
                CASE WHEN name ILIKE $1 THEN 1 ELSE 2 END,
                price ASC
            LIMIT 20
        """, f"%{query}%")

        # 2. å‘é‡æœç´¢ï¼ˆè¯­ä¹‰åŒ¹é…ï¼‰
        query_vector = await self.embedder.embed(query)
        vector_results = await self.db.execute("""
            SELECT id, name, price,
                   1 - (embedding <=> $1::vector) AS similarity
            FROM products
            ORDER BY embedding <=> $1::vector
            LIMIT 20
        """, query_vector)

        # 3. RRF èåˆ
        fused_results = self.rrf_fusion(text_results, vector_results)

        return fused_results
```

## 6. å‚è€ƒèµ„æ–™

- [æ··åˆæœç´¢ RRF ç®—æ³•](../æŠ€æœ¯åŸç†/æ··åˆæœç´¢RRFç®—æ³•.md)
- [PostgreSQL å…¨æ–‡æœç´¢](https://www.postgresql.org/docs/current/textsearch.html)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 01-03-02
