# å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 01-03-01

## ğŸ“‘ ç›®å½•

- [å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡](#å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æŠ€æœ¯èƒŒæ™¯](#11-æŠ€æœ¯èƒŒæ™¯)
    - [1.2 æ¶æ„å®šä½](#12-æ¶æ„å®šä½)
  - [2. æ¶æ„è®¾è®¡åŸåˆ™](#2-æ¶æ„è®¾è®¡åŸåˆ™)
    - [2.1 è®¾è®¡åŸåˆ™](#21-è®¾è®¡åŸåˆ™)
    - [2.2 æ¶æ„æ¨¡å¼](#22-æ¶æ„æ¨¡å¼)
  - [3. æ ¸å¿ƒæ¶æ„ç»„ä»¶](#3-æ ¸å¿ƒæ¶æ„ç»„ä»¶)
    - [3.1 æ•°æ®å±‚æ¶æ„](#31-æ•°æ®å±‚æ¶æ„)
    - [3.2 æŸ¥è¯¢å±‚æ¶æ„](#32-æŸ¥è¯¢å±‚æ¶æ„)
    - [3.3 ç´¢å¼•ç®¡ç†æ¶æ„](#33-ç´¢å¼•ç®¡ç†æ¶æ„)
  - [4. éƒ¨ç½²æ¶æ„æ¨¡å¼](#4-éƒ¨ç½²æ¶æ„æ¨¡å¼)
    - [4.1 å•æœºéƒ¨ç½²](#41-å•æœºéƒ¨ç½²)
    - [4.2 ä¸»ä»éƒ¨ç½²](#42-ä¸»ä»éƒ¨ç½²)
    - [4.3 åˆ†ç‰‡éƒ¨ç½²](#43-åˆ†ç‰‡éƒ¨ç½²)
  - [5. æ€§èƒ½ä¼˜åŒ–æ¶æ„](#5-æ€§èƒ½ä¼˜åŒ–æ¶æ„)
    - [5.1 ç¼“å­˜æ¶æ„](#51-ç¼“å­˜æ¶æ„)
    - [5.2 è¿æ¥æ± æ¶æ„](#52-è¿æ¥æ± æ¶æ„)
  - [6. å®è·µæ¡ˆä¾‹](#6-å®è·µæ¡ˆä¾‹)
    - [6.1 RAG åº”ç”¨æ¶æ„](#61-rag-åº”ç”¨æ¶æ„)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 æŠ€æœ¯èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

åœ¨ AI æ—¶ä»£ï¼Œå‘é‡æ•°æ®åº“éœ€è¦æ”¯æŒï¼š

- **å¤§è§„æ¨¡æ•°æ®**: ç™¾ä¸‡åˆ°åäº¿çº§å‘é‡å­˜å‚¨
- **é«˜å¹¶å‘æŸ¥è¯¢**: æ¯ç§’æ•°åƒåˆ°æ•°ä¸‡æ¬¡æŸ¥è¯¢
- **ä½å»¶è¿Ÿ**: P99 å»¶è¿Ÿ < 100ms
- **é«˜å¯ç”¨**: 99.9%+ å¯ç”¨æ€§
- **å¯æ‰©å±•**: æ”¯æŒæ°´å¹³æ‰©å±•

**æŠ€æœ¯æ¼”è¿›**:

1. **2020 å¹´**: ä¸“ç”¨å‘é‡æ•°æ®åº“ï¼ˆMilvusã€Pineconeï¼‰å…´èµ·
2. **2023 å¹´**: PostgreSQL + pgvector æˆä¸ºä¸»æµé€‰æ‹©
3. **2025 å¹´**: å‘é‡æ•°æ®åº“æ¶æ„æ ‡å‡†åŒ–ï¼Œæ”¯æŒæ··åˆæœç´¢

### 1.2 æ¶æ„å®šä½

**åœ¨æŠ€æœ¯æ ˆä¸­çš„ä½ç½®**:

```text
åº”ç”¨å±‚
  â”œâ”€â”€ RAG åº”ç”¨
  â”œâ”€â”€ æ¨èç³»ç»Ÿ
  â””â”€â”€ è¯­ä¹‰æœç´¢
  â†“
API ç½‘å…³å±‚
  â”œâ”€â”€ æŸ¥è¯¢è·¯ç”±
  â”œâ”€â”€ è´Ÿè½½å‡è¡¡
  â””â”€â”€ ç¼“å­˜å±‚
  â†“
å‘é‡æ•°æ®åº“å±‚ â† æœ¬æ–‡æ¡£
  â”œâ”€â”€ PostgreSQL + pgvector
  â”œâ”€â”€ ç´¢å¼•ç®¡ç†
  â””â”€â”€ æŸ¥è¯¢ä¼˜åŒ–
  â†“
å­˜å‚¨å±‚
  â”œâ”€â”€ æœ¬åœ°å­˜å‚¨
  â””â”€â”€ å¯¹è±¡å­˜å‚¨
```

## 2. æ¶æ„è®¾è®¡åŸåˆ™

### 2.1 è®¾è®¡åŸåˆ™

1. **å¯æ‰©å±•æ€§**: æ”¯æŒæ°´å¹³æ‰©å±•ï¼Œæ·»åŠ èŠ‚ç‚¹æå‡æ€§èƒ½
2. **é«˜å¯ç”¨æ€§**: ä¸»ä»å¤åˆ¶ã€è‡ªåŠ¨æ•…éšœè½¬ç§»
3. **æ€§èƒ½ä¼˜å…ˆ**: ç´¢å¼•ä¼˜åŒ–ã€æŸ¥è¯¢ä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥
4. **æ•°æ®ä¸€è‡´æ€§**: ACID ä¿è¯ã€æœ€ç»ˆä¸€è‡´æ€§é€‰æ‹©
5. **è¿ç»´å‹å¥½**: ç›‘æ§ã€å‘Šè­¦ã€è‡ªåŠ¨åŒ–è¿ç»´

### 2.2 æ¶æ„æ¨¡å¼

**å•æœºæ¶æ„**:

- é€‚ç”¨äº: å°è§„æ¨¡æ•°æ®ï¼ˆ< 1000 ä¸‡å‘é‡ï¼‰
- ä¼˜åŠ¿: ç®€å•ã€ä½å»¶è¿Ÿ
- åŠ£åŠ¿: æ‰©å±•æ€§æœ‰é™

**ä¸»ä»æ¶æ„**:

- é€‚ç”¨äº: ä¸­ç­‰è§„æ¨¡æ•°æ®ï¼ˆ1000 ä¸‡ - 1 äº¿å‘é‡ï¼‰
- ä¼˜åŠ¿: è¯»å†™åˆ†ç¦»ã€é«˜å¯ç”¨
- åŠ£åŠ¿: ä¸»èŠ‚ç‚¹å‹åŠ›å¤§

**åˆ†ç‰‡æ¶æ„**:

- é€‚ç”¨äº: å¤§è§„æ¨¡æ•°æ®ï¼ˆ> 1 äº¿å‘é‡ï¼‰
- ä¼˜åŠ¿: æ°´å¹³æ‰©å±•ã€é«˜å¹¶å‘
- åŠ£åŠ¿: å¤æ‚åº¦é«˜ã€è·¨åˆ†ç‰‡æŸ¥è¯¢

## 3. æ ¸å¿ƒæ¶æ„ç»„ä»¶

### 3.1 æ•°æ®å±‚æ¶æ„

```sql
-- è¡¨ç»“æ„è®¾è®¡
CREATE TABLE vectors (
    id BIGSERIAL PRIMARY KEY,
    embedding vector(1536),  -- å‘é‡ç»´åº¦
    metadata JSONB,          -- å…ƒæ•°æ®
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç´¢å¼•è®¾è®¡
CREATE INDEX ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

### 3.2 æŸ¥è¯¢å±‚æ¶æ„

```python
# æŸ¥è¯¢æœåŠ¡æ¶æ„
class VectorQueryService:
    def __init__(self):
        self.connection_pool = create_pool()
        self.cache = RedisCache()

    async def search(self, query_vector, limit=10):
        # 1. æ£€æŸ¥ç¼“å­˜
        cache_key = self._get_cache_key(query_vector, limit)
        cached_result = await self.cache.get(cache_key)
        if cached_result:
            return cached_result

        # 2. æ‰§è¡ŒæŸ¥è¯¢
        async with self.connection_pool.acquire() as conn:
            result = await conn.fetch("""
                SELECT id, metadata, 1 - (embedding <=> $1::vector) AS similarity
                FROM vectors
                ORDER BY embedding <=> $1::vector
                LIMIT $2
            """, query_vector, limit)

        # 3. ç¼“å­˜ç»“æœ
        await self.cache.set(cache_key, result, ttl=300)
        return result
```

### 3.3 ç´¢å¼•ç®¡ç†æ¶æ„

```python
# ç´¢å¼•ç®¡ç†æœåŠ¡
class IndexManager:
    def __init__(self, db_connection):
        self.db = db_connection

    async def create_index(self, table_name, column_name, index_type='hnsw'):
        """åˆ›å»ºç´¢å¼•"""
        if index_type == 'hnsw':
            await self.db.execute(f"""
                CREATE INDEX ON {table_name}
                USING hnsw ({column_name} vector_cosine_ops)
                WITH (m = 16, ef_construction = 64)
            """)
        elif index_type == 'ivfflat':
            await self.db.execute(f"""
                CREATE INDEX ON {table_name}
                USING ivfflat ({column_name} vector_cosine_ops)
                WITH (lists = 100)
            """)

    async def rebuild_index(self, table_name, index_name):
        """é‡å»ºç´¢å¼•"""
        await self.db.execute(f"REINDEX INDEX {index_name}")
```

## 4. éƒ¨ç½²æ¶æ„æ¨¡å¼

### 4.1 å•æœºéƒ¨ç½²

```yaml
# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: pgvector/pgvector:pg16
    environment:
      POSTGRES_DB: vectordb
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    command:
      - "postgres"
      - "-c"
      - "shared_buffers=2GB"
      - "-c"
      - "work_mem=64MB"

volumes:
  postgres_data:
```

### 4.2 ä¸»ä»éƒ¨ç½²

```yaml
# ä¸»ä»æ¶æ„
services:
  postgres-master:
    image: pgvector/pgvector:pg16
    environment:
      POSTGRES_REPLICATION_USER: replicator
      POSTGRES_REPLICATION_PASSWORD: replicator_password
    volumes:
      - ./master.conf:/etc/postgresql/postgresql.conf

  postgres-replica:
    image: pgvector/pgvector:pg16
    environment:
      PGUSER: replicator
      PGPASSWORD: replicator_password
    command: >
      bash -c "
      until pg_basebackup -h postgres-master -D /var/lib/postgresql/data -U replicator -v -P -W; do
        sleep 1s
      done
      postgres
      "
```

### 4.3 åˆ†ç‰‡éƒ¨ç½²

```python
# åˆ†ç‰‡ç®¡ç†
class ShardManager:
    def __init__(self):
        self.shards = [
            {'id': 0, 'connection': 'postgresql://shard0'},
            {'id': 1, 'connection': 'postgresql://shard1'},
            {'id': 2, 'connection': 'postgresql://shard2'},
        ]

    def get_shard(self, vector_id):
        """æ ¹æ®å‘é‡ ID é€‰æ‹©åˆ†ç‰‡"""
        return self.shards[vector_id % len(self.shards)]

    async def search_all_shards(self, query_vector, limit):
        """åœ¨æ‰€æœ‰åˆ†ç‰‡ä¸Šæœç´¢"""
        tasks = []
        for shard in self.shards:
            task = self._search_shard(shard, query_vector, limit)
            tasks.append(task)

        results = await asyncio.gather(*tasks)
        # åˆå¹¶ç»“æœå¹¶æ’åº
        return self._merge_results(results, limit)
```

## 5. æ€§èƒ½ä¼˜åŒ–æ¶æ„

### 5.1 ç¼“å­˜æ¶æ„

```python
# å¤šçº§ç¼“å­˜æ¶æ„
class CacheArchitecture:
    def __init__(self):
        self.l1_cache = {}  # å†…å­˜ç¼“å­˜ï¼ˆæœ€è¿‘æŸ¥è¯¢ï¼‰
        self.l2_cache = RedisCache()  # Redis ç¼“å­˜ï¼ˆçƒ­é—¨æŸ¥è¯¢ï¼‰

    async def get(self, key):
        # L1 ç¼“å­˜
        if key in self.l1_cache:
            return self.l1_cache[key]

        # L2 ç¼“å­˜
        result = await self.l2_cache.get(key)
        if result:
            self.l1_cache[key] = result
            return result

        return None
```

### 5.2 è¿æ¥æ± æ¶æ„

```python
# è¿æ¥æ± é…ç½®
from asyncpg import create_pool

class ConnectionPoolManager:
    def __init__(self):
        self.pools = {}

    async def get_pool(self, database_url):
        if database_url not in self.pools:
            self.pools[database_url] = await create_pool(
                database_url,
                min_size=10,
                max_size=100,
                max_queries=50000,
                max_inactive_connection_lifetime=300.0
            )
        return self.pools[database_url]
```

## 6. å®è·µæ¡ˆä¾‹

### 6.1 RAG åº”ç”¨æ¶æ„

```python
# RAG åº”ç”¨å®Œæ•´æ¶æ„
class RAGApplication:
    def __init__(self):
        self.vector_db = VectorDatabase()
        self.llm = LLMClient()
        self.embedder = EmbeddingModel()

    async def query(self, question: str):
        # 1. ç”Ÿæˆé—®é¢˜å‘é‡
        question_vector = await self.embedder.embed(question)

        # 2. å‘é‡æœç´¢
        documents = await self.vector_db.search(
            question_vector,
            limit=5
        )

        # 3. æ„å»ºä¸Šä¸‹æ–‡
        context = "\n".join([doc['content'] for doc in documents])

        # 4. LLM ç”Ÿæˆç­”æ¡ˆ
        answer = await self.llm.generate(
            prompt=f"Context: {context}\nQuestion: {question}"
        )

        return answer
```

## 7. å‚è€ƒèµ„æ–™

- [PostgreSQL å®˜æ–¹æ–‡æ¡£ - é«˜å¯ç”¨](https://www.postgresql.org/docs/current/high-availability.html)
- [pgvector å®˜æ–¹æ–‡æ¡£](https://github.com/pgvector/pgvector)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 01-03-01
