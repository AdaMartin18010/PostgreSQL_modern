# æ™ºèƒ½äº¤é€šç®¡ç†ç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, TimescaleDB 2.11+, PostGIS 3.0+
> **æ–‡æ¡£ç¼–å·**: 08-12-01

## ğŸ“‘ ç›®å½•

- [æ™ºèƒ½äº¤é€šç®¡ç†ç³»ç»Ÿ](#æ™ºèƒ½äº¤é€šç®¡ç†ç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

æ™ºèƒ½äº¤é€šç®¡ç†ç³»ç»Ÿéœ€è¦ï¼š

- **å®æ—¶ç›‘æ§**: å®æ—¶ç›‘æ§äº¤é€šæµé‡å’Œè·¯å†µ
- **ä¿¡å·ä¼˜åŒ–**: ä¼˜åŒ–äº¤é€šä¿¡å·ç¯æ§åˆ¶
- **è·¯å¾„è§„åˆ’**: ä¸ºè½¦è¾†æä¾›æœ€ä¼˜è·¯å¾„
- **äº‹æ•…é¢„è­¦**: é¢„è­¦äº¤é€šäº‹æ•…å’Œæ‹¥å µ

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **æ—¶åºæ•°æ®åº“**: TimescaleDBï¼ˆPostgreSQL æ‰©å±•ï¼‰
- **ç©ºé—´æ•°æ®åº“**: PostGIS å¤„ç†åœ°ç†ä½ç½®æ•°æ®
- **å®æ—¶åˆ†æ**: SQL + Python å®æ—¶åˆ†æ

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
|--------|------|------|
| **é€šè¡Œæ•ˆç‡** | ä¿¡å·ä¼˜åŒ–æå‡é€šè¡Œæ•ˆç‡ | **+35%** |
| **æ‹¥å µæ—¶é—´** | å‡å°‘æ‹¥å µæ—¶é—´ | **-40%** |
| **äº‹æ•…ç‡** | é™ä½äº¤é€šäº‹æ•…ç‡ | **-25%** |
| **æŸ¥è¯¢æ€§èƒ½** | å®æ—¶æŸ¥è¯¢å“åº”æ—¶é—´ | **< 50ms** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **é€šè¡Œæ•ˆç‡**: ä¿¡å·ä¼˜åŒ–æå‡é€šè¡Œæ•ˆç‡ 35%
- **æ‹¥å µæ—¶é—´**: å‡å°‘æ‹¥å µæ—¶é—´ 40%
- **äº‹æ•…ç‡**: é™ä½äº¤é€šäº‹æ•…ç‡ 25%
- **æŸ¥è¯¢æ€§èƒ½**: å®æ—¶æŸ¥è¯¢å“åº”æ—¶é—´ < 50ms

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ¶æ„è®¾è®¡

```text
äº¤é€šæ•°æ®é‡‡é›†
  â”œâ”€â”€ æ‘„åƒå¤´æ•°æ®
  â”œâ”€â”€ ä¼ æ„Ÿå™¨æ•°æ®
  â””â”€â”€ GPS æ•°æ®
  â†“
æ—¶åºæ•°æ®å­˜å‚¨ï¼ˆTimescaleDBï¼‰
  â”œâ”€â”€ äº¤é€šæµé‡æ•°æ®
  â””â”€â”€ è·¯å†µæ•°æ®
  â†“
ç©ºé—´æ•°æ®å­˜å‚¨ï¼ˆPostGISï¼‰
  â”œâ”€â”€ é“è·¯ç½‘ç»œ
  â””â”€â”€ ä¿¡å·ç¯ä½ç½®
  â†“
äº¤é€šç®¡ç†å¼•æ“
  â”œâ”€â”€ ä¿¡å·ä¼˜åŒ–
  â”œâ”€â”€ è·¯å¾„è§„åˆ’
  â””â”€â”€ é¢„è­¦ç³»ç»Ÿ
```

### 2.2 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + TimescaleDB + PostGIS
- **æ•°æ®é‡‡é›†**: äº¤é€šæ‘„åƒå¤´ã€ä¼ æ„Ÿå™¨ã€GPS
- **å®æ—¶åˆ†æ**: Python + SQL
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 äº¤é€šæµé‡æ—¶åºè¡¨

```sql
-- åˆ›å»ºäº¤é€šæµé‡æ—¶åºè¡¨
CREATE TABLE traffic_flow (
    time TIMESTAMPTZ NOT NULL,
    sensor_id TEXT NOT NULL,
    road_segment_id TEXT NOT NULL,
    vehicle_count INTEGER,
    average_speed DECIMAL(10, 2),
    occupancy_rate DECIMAL(10, 2),
    location GEOGRAPHY(POINT, 4326)
);

-- è½¬æ¢ä¸ºæ—¶åºè¡¨
SELECT create_hypertable('traffic_flow', 'time');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX traffic_flow_road_time_idx ON traffic_flow (road_segment_id, time DESC);
CREATE INDEX traffic_flow_location_idx ON traffic_flow USING GIST (location);
```

### 3.2 ä¿¡å·ç¯çŠ¶æ€è¡¨

```sql
CREATE TABLE traffic_lights (
    id SERIAL PRIMARY KEY,
    light_id TEXT UNIQUE NOT NULL,
    location GEOGRAPHY(POINT, 4326),
    current_state TEXT,  -- 'red', 'yellow', 'green'
    cycle_duration INTEGER,
    metadata JSONB,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX traffic_lights_location_idx ON traffic_lights USING GIST (location);
```

### 3.3 é“è·¯ç½‘ç»œè¡¨

```sql
CREATE TABLE road_network (
    id SERIAL PRIMARY KEY,
    road_id TEXT UNIQUE NOT NULL,
    road_name TEXT,
    road_type TEXT,
    geometry GEOGRAPHY(LINESTRING, 4326),
    speed_limit INTEGER,
    lanes INTEGER,
    metadata JSONB
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX road_network_geometry_idx ON road_network USING GIST (geometry);
```

## 4. äº¤é€šä¼˜åŒ–ç®—æ³•

### 4.1 ä¿¡å·ä¼˜åŒ–

```python
# ä¿¡å·ä¼˜åŒ–ç®—æ³•
class TrafficSignalOptimizer:
    async def optimize_signals(self, intersection_id):
        """ä¼˜åŒ–äº¤é€šä¿¡å·"""
        # 1. è·å–å„æ–¹å‘äº¤é€šæµé‡
        flows = await self.db.fetch("""
            SELECT
                direction,
                SUM(vehicle_count) AS total_vehicles,
                AVG(average_speed) AS avg_speed
            FROM traffic_flow
            WHERE road_segment_id IN (
                SELECT road_id FROM road_network
                WHERE ST_Intersects(geometry, (
                    SELECT location FROM traffic_lights WHERE light_id = $1
                ))
            )
            AND time > NOW() - INTERVAL '15 minutes'
            GROUP BY direction
        """, intersection_id)

        # 2. è®¡ç®—æœ€ä¼˜ä¿¡å·æ—¶é•¿
        optimal_durations = self.calculate_optimal_durations(flows)

        # 3. æ›´æ–°ä¿¡å·ç¯é…ç½®
        await self.update_traffic_lights(intersection_id, optimal_durations)

        return optimal_durations
```

### 4.2 è·¯å¾„è§„åˆ’

```python
# è·¯å¾„è§„åˆ’ç®—æ³•
class RoutePlanner:
    async def find_optimal_route(self, start_location, end_location):
        """æŸ¥æ‰¾æœ€ä¼˜è·¯å¾„"""
        # 1. ä½¿ç”¨ PostGIS æŸ¥æ‰¾æœ€çŸ­è·¯å¾„
        route = await self.db.fetchrow("""
            SELECT
                ST_Length(geometry::geography) AS distance,
                ST_AsText(geometry) AS route_geometry
            FROM road_network
            WHERE ST_DWithin(
                geometry::geography,
                ST_MakePoint($1, $2)::geography,
                1000
            )
            ORDER BY ST_Distance(geometry::geography, ST_MakePoint($1, $2)::geography)
            LIMIT 1
        """, start_location[0], start_location[1])

        # 2. è€ƒè™‘å®æ—¶äº¤é€šçŠ¶å†µ
        route_with_traffic = await self.adjust_route_for_traffic(route)

        return route_with_traffic
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: æ™ºèƒ½äº¤é€šç®¡ç†ç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸåŸå¸‚éœ€è¦æ„å»ºæ™ºèƒ½äº¤é€šç®¡ç†ç³»ç»Ÿï¼Œä¼˜åŒ–äº¤é€šæµé‡ï¼Œå‡å°‘æ‹¥å µã€‚

**é—®é¢˜åˆ†æ**:

1. **æ‹¥å µä¸¥é‡**: äº¤é€šæ‹¥å µä¸¥é‡ï¼Œå½±å“é€šè¡Œæ•ˆç‡
2. **ä¿¡å·ä¸ä¼˜åŒ–**: äº¤é€šä¿¡å·ç¯æ§åˆ¶ä¸ä¼˜åŒ–
3. **äº‹æ•…é¢‘å‘**: äº¤é€šäº‹æ•…é¢‘å‘
4. **æ•°æ®åˆ†æ•£**: äº¤é€šæ•°æ®åˆ†æ•£ï¼Œéš¾ä»¥ç»Ÿä¸€åˆ†æ

**è§£å†³æ–¹æ¡ˆ**:

```python
# æ™ºèƒ½äº¤é€šç®¡ç†ç³»ç»Ÿ
class IntelligentTrafficManagementSystem:
    def __init__(self):
        self.signal_optimizer = TrafficSignalOptimizer()
        self.route_planner = RoutePlanner()
        self.alert_system = AlertSystem()

    async def realtime_management(self):
        """å®æ—¶äº¤é€šç®¡ç†"""
        # 1. ä¼˜åŒ–æ‰€æœ‰ä¿¡å·ç¯
        intersections = await self.get_all_intersections()
        for intersection in intersections:
            await self.signal_optimizer.optimize_signals(intersection['id'])

        # 2. æ£€æŸ¥æ‹¥å µå’Œäº‹æ•…
        alerts = await self.alert_system.check_alerts()

        # 3. æ›´æ–°è·¯å¾„è§„åˆ’
        await self.update_route_recommendations()
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **é€šè¡Œæ•ˆç‡** | åŸºå‡† | **+35%** | **æå‡** |
| **æ‹¥å µæ—¶é—´** | åŸºå‡† | **-40%** | **å‡å°‘** |
| **äº‹æ•…ç‡** | åŸºå‡† | **-25%** | **é™ä½** |
| **æŸ¥è¯¢æ€§èƒ½** | 500ms | **< 50ms** | **90%** â¬‡ï¸ |

## 6. æœ€ä½³å®è·µ

### 6.1 æ•°æ®é‡‡é›†

1. **ä¼ æ„Ÿå™¨éƒ¨ç½²**: åˆç†éƒ¨ç½²äº¤é€šä¼ æ„Ÿå™¨
2. **æ•°æ®è´¨é‡**: ç¡®ä¿æ•°æ®è´¨é‡å’Œå®æ—¶æ€§
3. **æ•°æ®èåˆ**: èåˆå¤šæºäº¤é€šæ•°æ®

### 6.2 ä¿¡å·ä¼˜åŒ–

1. **å®æ—¶è°ƒæ•´**: æ ¹æ®å®æ—¶æµé‡è°ƒæ•´ä¿¡å·
2. **åè°ƒæ§åˆ¶**: åè°ƒå¤šä¸ªä¿¡å·ç¯
3. **é¢„æµ‹ä¼˜åŒ–**: ä½¿ç”¨é¢„æµ‹æ¨¡å‹ä¼˜åŒ–ä¿¡å·

### 6.3 è·¯å¾„è§„åˆ’

1. **å®æ—¶æ›´æ–°**: å®æ—¶æ›´æ–°è·¯å¾„è§„åˆ’
2. **å¤šç›®æ ‡ä¼˜åŒ–**: è€ƒè™‘æ—¶é—´ã€è·ç¦»ã€è´¹ç”¨ç­‰å¤šç›®æ ‡
3. **åŠ¨æ€è°ƒæ•´**: æ ¹æ®å®æ—¶è·¯å†µåŠ¨æ€è°ƒæ•´

## 7. å‚è€ƒèµ„æ–™

- [æ™ºèƒ½è·¯å¾„ä¼˜åŒ–ç³»ç»Ÿ](../ç‰©æµåœºæ™¯/æ™ºèƒ½è·¯å¾„ä¼˜åŒ–ç³»ç»Ÿ.md)
- [PostGIS ç©ºé—´æ•°æ®](../../07-æŠ€æœ¯å †æ ˆ/ç”Ÿæ€ç³»ç»Ÿé›†æˆ/PostGISç©ºé—´æ•°æ®.md)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-12-01
