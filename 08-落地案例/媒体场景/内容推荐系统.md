# å†…å®¹æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-09-01

## ğŸ“‘ ç›®å½•

- [å†…å®¹æ¨èç³»ç»Ÿ](#å†…å®¹æ¨èç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
  - [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
    - [2.1 æ¶æ„è®¾è®¡](#21-æ¶æ„è®¾è®¡)
    - [2.2 æŠ€æœ¯æ ˆ](#22-æŠ€æœ¯æ ˆ)
  - [3. æ•°æ®æ¨¡å‹è®¾è®¡](#3-æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 å†…å®¹è¡¨](#31-å†…å®¹è¡¨)
    - [3.2 ç”¨æˆ·è¡¨](#32-ç”¨æˆ·è¡¨)
    - [3.3 ç”¨æˆ·è¡Œä¸ºè¡¨](#33-ç”¨æˆ·è¡Œä¸ºè¡¨)
  - [4. æ¨èç®—æ³•å®ç°](#4-æ¨èç®—æ³•å®ç°)
    - [4.1 åŸºäºå†…å®¹çš„æ¨è](#41-åŸºäºå†…å®¹çš„æ¨è)
    - [4.2 ååŒè¿‡æ»¤æ¨è](#42-ååŒè¿‡æ»¤æ¨è)
    - [4.3 æ··åˆæ¨è](#43-æ··åˆæ¨è)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 æ¡ˆä¾‹: è§†é¢‘å¹³å°å†…å®¹æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-è§†é¢‘å¹³å°å†…å®¹æ¨èç³»ç»ŸçœŸå®æ¡ˆä¾‹)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

å†…å®¹æ¨èç³»ç»Ÿéœ€è¦ï¼š

- **ä¸ªæ€§åŒ–æ¨è**: æ ¹æ®ç”¨æˆ·å…´è¶£æ¨èå†…å®¹
- **å†…å®¹åŒ¹é…**: åŒ¹é…ç”¨æˆ·åå¥½å’Œå†…å®¹ç‰¹å¾
- **å®æ—¶æ€§**: å®æ—¶å“åº”ç”¨æˆ·è¡Œä¸º
- **å¤šæ ·æ€§**: ä¿è¯æ¨èå†…å®¹çš„å¤šæ ·æ€§

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å‘é‡åŒ–**: å†…å®¹å’Œç”¨æˆ·å‘é‡åŒ–è¡¨ç¤º
- **ç›¸ä¼¼åº¦è®¡ç®—**: ä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦è®¡ç®—æ¨è
- **æ··åˆæ¨è**: ç»“åˆååŒè¿‡æ»¤å’Œå†…å®¹æ¨è

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
|--------|------|------|
| **ç‚¹å‡»ç‡** | ä¸ªæ€§åŒ–æ¨èæå‡ç‚¹å‡»ç‡ | **+45%** |
| **è§‚çœ‹æ—¶é•¿** | æ¨èå†…å®¹è§‚çœ‹æ—¶é•¿ | **+35%** |
| **ç”¨æˆ·ç•™å­˜** | æå‡ç”¨æˆ·ç•™å­˜ç‡ | **+25%** |
| **æŸ¥è¯¢æ€§èƒ½** | æ¨èæŸ¥è¯¢å“åº”æ—¶é—´ | **< 50ms** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **ç‚¹å‡»ç‡**: ä¸ªæ€§åŒ–æ¨èæå‡ç‚¹å‡»ç‡ 45%
- **è§‚çœ‹æ—¶é•¿**: æ¨èå†…å®¹è§‚çœ‹æ—¶é•¿æå‡ 35%
- **ç”¨æˆ·ç•™å­˜**: æå‡ç”¨æˆ·ç•™å­˜ç‡ 25%
- **æŸ¥è¯¢æ€§èƒ½**: æ¨èæŸ¥è¯¢å“åº”æ—¶é—´ < 50ms

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ¶æ„è®¾è®¡

```text
ç”¨æˆ·è¡Œä¸ºé‡‡é›†
  â†“
è¡Œä¸ºæ•°æ®é¢„å¤„ç†
  â†“
å‘é‡ç”ŸæˆæœåŠ¡
  â”œâ”€â”€ å†…å®¹å‘é‡åŒ–
  â””â”€â”€ ç”¨æˆ·å‘é‡åŒ–
  â†“
æ¨èå¼•æ“
  â”œâ”€â”€ å‘é‡ç›¸ä¼¼åº¦è®¡ç®—
  â”œâ”€â”€ ååŒè¿‡æ»¤
  â””â”€â”€ æ··åˆæ¨è
  â†“
æ¨èç»“æœè¿”å›
```

### 2.2 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + pgvector
- **å‘é‡ç”Ÿæˆ**: OpenAI Embeddings / Sentence Transformers
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot
- **ç¼“å­˜**: Redis

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 å†…å®¹è¡¨

```sql
CREATE TABLE contents (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    category TEXT,
    tags TEXT[],
    duration INTEGER,
    embedding vector(1536),
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON contents USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON contents (category);
CREATE INDEX ON contents USING GIN (tags);
```

### 3.2 ç”¨æˆ·è¡¨

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    embedding vector(1536),
    preferences JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON users USING hnsw (embedding vector_cosine_ops);
```

### 3.3 ç”¨æˆ·è¡Œä¸ºè¡¨

```sql
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    content_id INTEGER REFERENCES contents(id),
    behavior_type TEXT,  -- 'view', 'like', 'share', 'complete'
    duration INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON user_behaviors (user_id, timestamp DESC);
CREATE INDEX ON user_behaviors (content_id);
```

## 4. æ¨èç®—æ³•å®ç°

### 4.1 åŸºäºå†…å®¹çš„æ¨è

```python
# åŸºäºå†…å®¹ç›¸ä¼¼åº¦çš„æ¨è
class ContentBasedRecommendation:
    async def recommend(self, content_id, limit=10):
        """åŸºäºå†…å®¹ç›¸ä¼¼åº¦æ¨è"""
        # 1. è·å–å†…å®¹å‘é‡
        content = await self.db.fetchrow("""
            SELECT embedding FROM contents WHERE id = $1
        """, content_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼å†…å®¹
        recommendations = await self.db.fetch("""
            SELECT c.id, c.title, c.category,
                   1 - (c.embedding <=> $1::vector) AS similarity
            FROM contents c
            WHERE c.id != $2
            ORDER BY c.embedding <=> $1::vector
            LIMIT $3
        """, content['embedding'], content_id, limit)

        return recommendations
```

### 4.2 ååŒè¿‡æ»¤æ¨è

```python
# ååŒè¿‡æ»¤æ¨è
class CollaborativeFiltering:
    async def update_user_embedding(self, user_id):
        """æ›´æ–°ç”¨æˆ·å‘é‡"""
        # 1. è·å–ç”¨æˆ·è¡Œä¸º
        behaviors = await self.db.fetch("""
            SELECT content_id, behavior_type, duration, timestamp
            FROM user_behaviors
            WHERE user_id = $1
            ORDER BY timestamp DESC
            LIMIT 100
        """, user_id)

        # 2. è·å–å†…å®¹å‘é‡
        content_ids = [b['content_id'] for b in behaviors]
        contents = await self.db.fetch("""
            SELECT id, embedding FROM contents WHERE id = ANY($1::int[])
        """, content_ids)

        # 3. åŠ æƒå¹³å‡
        weights = {
            'complete': 3.0,
            'like': 2.5,
            'share': 2.0,
            'view': 1.0
        }

        weighted_vectors = []
        for behavior in behaviors:
            content_embedding = next(
                c['embedding'] for c in contents
                if c['id'] == behavior['content_id']
            )
            weight = weights.get(behavior['behavior_type'], 1.0)
            # è€ƒè™‘è§‚çœ‹æ—¶é•¿
            if behavior['duration']:
                weight *= min(behavior['duration'] / 300, 2.0)  # 5åˆ†é’Ÿä¸ºåŸºå‡†
            weighted_vectors.append(content_embedding * weight)

        user_embedding = np.mean(weighted_vectors, axis=0)

        # 4. æ›´æ–°ç”¨æˆ·å‘é‡
        await self.db.execute("""
            UPDATE users
            SET embedding = $1::vector
            WHERE id = $2
        """, user_embedding.tolist(), user_id)

    async def recommend(self, user_id, limit=10):
        """åŸºäºç”¨æˆ·å‘é‡æ¨è"""
        # 1. è·å–ç”¨æˆ·å‘é‡
        user = await self.db.fetchrow("""
            SELECT embedding FROM users WHERE id = $1
        """, user_id)

        # 2. æŸ¥æ‰¾ç”¨æˆ·æœªè§‚çœ‹è¿‡çš„ç›¸ä¼¼å†…å®¹
        recommendations = await self.db.fetch("""
            SELECT c.id, c.title, c.category, c.duration,
                   1 - (c.embedding <=> $1::vector) AS similarity
            FROM contents c
            WHERE c.id NOT IN (
                SELECT content_id FROM user_behaviors
                WHERE user_id = $2 AND behavior_type = 'complete'
            )
            ORDER BY c.embedding <=> $1::vector
            LIMIT $3
        """, user['embedding'], user_id, limit)

        return recommendations
```

### 4.3 æ··åˆæ¨è

```python
# æ··åˆæ¨è
class HybridRecommendation:
    async def recommend(self, user_id, limit=10):
        """æ··åˆæ¨è"""
        # 1. å†…å®¹æ¨èï¼ˆåŸºäºæœ€è¿‘è§‚çœ‹çš„å†…å®¹ï¼‰
        recent_content = await self.db.fetchrow("""
            SELECT content_id FROM user_behaviors
            WHERE user_id = $1
            ORDER BY timestamp DESC
            LIMIT 1
        """, user_id)

        content_results = []
        if recent_content:
            content_service = ContentBasedRecommendation()
            content_results = await content_service.recommend(
                recent_content['content_id'],
                limit * 2
            )

        # 2. ååŒè¿‡æ»¤æ¨è
        cf_service = CollaborativeFiltering()
        cf_results = await cf_service.recommend(user_id, limit * 2)

        # 3. RRF èåˆ
        fused_results = self.rrf_fusion(content_results, cf_results, k=60)

        # 4. å¤šæ ·æ€§è¿‡æ»¤
        diverse_results = self.diversity_filter(fused_results, limit)

        return diverse_results

    def rrf_fusion(self, results1, results2, k=60):
        """RRF èåˆ"""
        scores = {}

        for rank, item in enumerate(results1, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {'item': item, 'score': 0}
            scores[item_id]['score'] += 1.0 / (k + rank)

        for rank, item in enumerate(results2, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {'item': item, 'score': 0}
            scores[item_id]['score'] += 1.0 / (k + rank)

        sorted_results = sorted(
            scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )

        return [r['item'] for r in sorted_results]

    def diversity_filter(self, results, limit):
        """å¤šæ ·æ€§è¿‡æ»¤"""
        diverse_results = []
        used_categories = set()

        for item in results:
            if len(diverse_results) >= limit:
                break
            if item['category'] not in used_categories or len(used_categories) >= 5:
                diverse_results.append(item)
                used_categories.add(item['category'])

        # å¦‚æœè¿˜ä¸å¤Ÿï¼Œæ·»åŠ å‰©ä½™ç»“æœ
        for item in results:
            if len(diverse_results) >= limit:
                break
            if item['id'] not in [r['id'] for r in diverse_results]:
                diverse_results.append(item)

        return diverse_results
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: è§†é¢‘å¹³å°å†…å®¹æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸè§†é¢‘å¹³å°éœ€è¦æ„å»ºå†…å®¹æ¨èç³»ç»Ÿï¼Œæå‡ç”¨æˆ·è§‚çœ‹æ—¶é•¿å’Œå¹³å°æ´»è·ƒåº¦ã€‚

**é—®é¢˜åˆ†æ**:

1. **æ¨èå‡†ç¡®ç‡ä½**: ä¼ ç»Ÿæ¨èå‡†ç¡®ç‡åªæœ‰ 60%
2. **è§‚çœ‹æ—¶é•¿çŸ­**: ç”¨æˆ·è§‚çœ‹æ—¶é•¿çŸ­
3. **ç”¨æˆ·ç•™å­˜ä½**: ç”¨æˆ·ç•™å­˜ç‡ä½
4. **å®æ—¶æ€§è¦æ±‚**: éœ€è¦å®æ—¶å“åº”ç”¨æˆ·è¡Œä¸º

**è§£å†³æ–¹æ¡ˆ**:

```python
# å†…å®¹æ¨èç³»ç»Ÿ
class ContentRecommendationSystem:
    def __init__(self):
        self.hybrid_service = HybridRecommendation()
        self.cache_service = CachedRecommendation(redis_client)

    async def get_recommendations(self, user_id, limit=10):
        """è·å–ä¸ªæ€§åŒ–æ¨è"""
        # 1. æ£€æŸ¥ç¼“å­˜
        cached = await self.cache_service.get_recommendations(user_id, limit)
        if cached:
            return cached

        # 2. ç”Ÿæˆæ¨è
        recommendations = await self.hybrid_service.recommend(user_id, limit)

        # 3. ç¼“å­˜ç»“æœ
        await self.cache_service.cache_recommendations(user_id, recommendations)

        return recommendations

    async def update_user_preferences(self, user_id, behavior):
        """æ›´æ–°ç”¨æˆ·åå¥½"""
        # 1. è®°å½•ç”¨æˆ·è¡Œä¸º
        await self.record_behavior(user_id, behavior)

        # 2. æ›´æ–°ç”¨æˆ·å‘é‡
        await self.update_user_embedding(user_id)

        # 3. æ¸…é™¤ç¼“å­˜
        await self.cache_service.invalidate_cache(user_id)
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **æ¨èå‡†ç¡®ç‡** | 60% | **82%** | **37%** â¬†ï¸ |
| **ç‚¹å‡»ç‡** | åŸºå‡† | **+45%** | **æå‡** |
| **è§‚çœ‹æ—¶é•¿** | åŸºå‡† | **+35%** | **æå‡** |
| **ç”¨æˆ·ç•™å­˜ç‡** | åŸºå‡† | **+25%** | **æå‡** |
| **æŸ¥è¯¢å»¶è¿Ÿ** | 200ms | **< 50ms** | **75%** â¬‡ï¸ |

## 6. æœ€ä½³å®è·µ

### 6.1 å‘é‡è´¨é‡

1. **é«˜è´¨é‡å‘é‡**: ä½¿ç”¨é«˜è´¨é‡çš„å†…å®¹å’Œç”¨æˆ·å‘é‡
2. **å®æ—¶æ›´æ–°**: å®æ—¶æ›´æ–°ç”¨æˆ·å‘é‡ï¼Œå“åº”ç”¨æˆ·è¡Œä¸º
3. **å‘é‡ç»´åº¦**: é€‰æ‹©åˆé€‚çš„å‘é‡ç»´åº¦ï¼ˆå¦‚ 1536ï¼‰

### 6.2 æ¨èç­–ç•¥

1. **æ··åˆæ¨è**: ç»“åˆååŒè¿‡æ»¤å’Œå†…å®¹æ¨è
2. **å¤šæ ·æ€§ä¿è¯**: ä¿è¯æ¨èç»“æœçš„å¤šæ ·æ€§
3. **å†·å¯åŠ¨å¤„ç†**: å¤„ç†æ–°ç”¨æˆ·å’Œæ–°å†…å®¹çš„å†·å¯åŠ¨é—®é¢˜

### 6.3 æ€§èƒ½ä¼˜åŒ–

1. **ç¼“å­˜ç­–ç•¥**: ä½¿ç”¨ç¼“å­˜æé«˜æŸ¥è¯¢æ€§èƒ½
2. **æ‰¹é‡æ›´æ–°**: æ‰¹é‡æ›´æ–°ç”¨æˆ·å‘é‡
3. **ç´¢å¼•ä¼˜åŒ–**: ä¸ºå‘é‡æŸ¥è¯¢åˆ›å»ºåˆé€‚çš„ç´¢å¼•

## 7. å‚è€ƒèµ„æ–™

- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](../ç”µå•†åœºæ™¯/ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)
- [å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡](../../01-å‘é‡ä¸æ··åˆæœç´¢/æ¶æ„è®¾è®¡/å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡.md)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-09-01
