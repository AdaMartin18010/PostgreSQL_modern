# 政务数据脱敏实践

> **更新时间**: 2025 年 11 月 1 日
> **技术版本**: PostgreSQL 14+
> **文档编号**: 08-05-03

## 📑 目录

- [政务数据脱敏实践](#政务数据脱敏实践)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 业务背景](#11-业务背景)
    - [1.2 核心价值](#12-核心价值)
  - [2. 脱敏策略](#2-脱敏策略)
    - [2.1 静态脱敏](#21-静态脱敏)
    - [2.2 动态脱敏](#22-动态脱敏)
    - [2.3 格式保留脱敏](#23-格式保留脱敏)
  - [3. 实现方案](#3-实现方案)
    - [3.1 函数式脱敏](#31-函数式脱敏)
    - [3.2 视图脱敏](#32-视图脱敏)
    - [3.3 触发器脱敏](#33-触发器脱敏)
  - [4. 实践案例](#4-实践案例)
    - [4.1 社保数据脱敏](#41-社保数据脱敏)
  - [5. 参考资料](#5-参考资料)

---

## 1. 概述

### 1.1 业务背景

**问题需求**:

政务数据脱敏需要：

- **隐私保护**: 保护公民隐私信息
- **合规要求**: 满足数据保护法规
- **数据可用性**: 保持数据可用性
- **性能要求**: 脱敏不影响查询性能

**技术方案**:

- **静态脱敏**: 数据导出时脱敏
- **动态脱敏**: 查询时实时脱敏
- **格式保留**: 保持数据格式

### 1.2 核心价值

- **隐私保护**: 100% 保护敏感信息
- **合规性**: 满足 GDPR、个人信息保护法等
- **性能影响**: <5% 性能损失

## 2. 脱敏策略

### 2.1 静态脱敏

```sql
-- 静态脱敏：导出数据时脱敏
CREATE OR REPLACE FUNCTION static_mask(data TEXT, mask_type TEXT)
RETURNS TEXT AS $$
BEGIN
    CASE mask_type
        WHEN 'phone' THEN
            RETURN regexp_replace(data, '(\d{3})\d{4}(\d{4})', '\1****\2');
        WHEN 'id_card' THEN
            RETURN regexp_replace(data, '(\d{6})\d{8}(\d{4})', '\1********\2');
        WHEN 'name' THEN
            RETURN LEFT(data, 1) || '**';
        WHEN 'email' THEN
            RETURN regexp_replace(data, '(.{2}).*(@.*)', '\1***\2');
        ELSE
            RETURN '***';
    END CASE;
END;
$$ LANGUAGE plpgsql;

-- 导出脱敏数据
COPY (
    SELECT
        id,
        static_mask(name, 'name') AS name,
        static_mask(phone, 'phone') AS phone,
        static_mask(id_card, 'id_card') AS id_card
    FROM citizen_data
) TO '/tmp/masked_data.csv' WITH CSV HEADER;
```

### 2.2 动态脱敏

```sql
-- 动态脱敏：查询时实时脱敏
CREATE OR REPLACE FUNCTION dynamic_mask(
    data TEXT,
    user_role TEXT,
    mask_type TEXT
)
RETURNS TEXT AS $$
BEGIN
    -- 根据用户角色决定脱敏程度
    IF user_role = 'admin' THEN
        RETURN data;  -- 管理员不脱敏
    ELSIF user_role = 'analyst' THEN
        -- 分析师部分脱敏
        CASE mask_type
            WHEN 'phone' THEN
                RETURN regexp_replace(data, '(\d{3})\d{4}(\d{4})', '\1****\2');
            ELSE
                RETURN data;
        END CASE;
    ELSE
        -- 普通用户完全脱敏
        CASE mask_type
            WHEN 'phone' THEN
                RETURN '***-****-****';
            WHEN 'id_card' THEN
                RETURN '********-****-****';
            WHEN 'name' THEN
                RETURN '***';
            ELSE
                RETURN '***';
        END CASE;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 使用动态脱敏查询
SELECT
    id,
    dynamic_mask(name, current_user_role(), 'name') AS name,
    dynamic_mask(phone, current_user_role(), 'phone') AS phone
FROM citizen_data;
```

### 2.3 格式保留脱敏

```sql
-- 格式保留脱敏：保持数据格式
CREATE OR REPLACE FUNCTION format_preserving_mask(
    data TEXT,
    mask_type TEXT
)
RETURNS TEXT AS $$
DECLARE
    masked_data TEXT;
BEGIN
    CASE mask_type
        WHEN 'phone' THEN
            -- 保持电话号码格式：138-1234-5678 -> 138-****-5678
            masked_data := regexp_replace(data, '(\d{3})-(\d{4})-(\d{4})', '\1-****-\3');
        WHEN 'id_card' THEN
            -- 保持身份证格式：110101199001011234 -> 110101********1234
            masked_data := regexp_replace(data, '(\d{6})(\d{8})(\d{4})', '\1********\3');
        WHEN 'bank_card' THEN
            -- 保持银行卡格式：6222 1234 5678 9012 -> 6222 **** **** 9012
            masked_data := regexp_replace(data, '(\d{4})\s+(\d{4})\s+(\d{4})\s+(\d{4})', '\1 **** **** \4');
        ELSE
            masked_data := '***';
    END CASE;

    RETURN masked_data;
END;
$$ LANGUAGE plpgsql;
```

## 3. 实现方案

### 3.1 函数式脱敏

```sql
-- 创建脱敏函数库
CREATE SCHEMA IF NOT EXISTS data_masking;

-- 手机号脱敏
CREATE OR REPLACE FUNCTION data_masking.mask_phone(phone TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN regexp_replace(phone, '(\d{3})\d{4}(\d{4})', '\1****\2');
END;
$$ LANGUAGE plpgsql;

-- 身份证脱敏
CREATE OR REPLACE FUNCTION data_masking.mask_id_card(id_card TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN regexp_replace(id_card, '(\d{6})\d{8}(\d{4})', '\1********\2');
END;
$$ LANGUAGE plpgsql;

-- 姓名脱敏
CREATE OR REPLACE FUNCTION data_masking.mask_name(name TEXT)
RETURNS TEXT AS $$
BEGIN
    IF length(name) <= 2 THEN
        RETURN LEFT(name, 1) || '*';
    ELSE
        RETURN LEFT(name, 1) || repeat('*', length(name) - 2) || RIGHT(name, 1);
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 视图脱敏

```sql
-- 创建脱敏视图
CREATE VIEW citizen_data_masked AS
SELECT
    id,
    data_masking.mask_name(name) AS name,
    data_masking.mask_phone(phone) AS phone,
    data_masking.mask_id_card(id_card) AS id_card,
    address,  -- 地址不脱敏
    created_at
FROM citizen_data;

-- 授予视图访问权限
GRANT SELECT ON citizen_data_masked TO public_user_role;
```

### 3.3 触发器脱敏

```sql
-- 创建脱敏触发器
CREATE OR REPLACE FUNCTION mask_sensitive_data()
RETURNS TRIGGER AS $$
BEGIN
    -- 在插入前脱敏
    NEW.phone := data_masking.mask_phone(NEW.phone);
    NEW.id_card := data_masking.mask_id_card(NEW.id_card);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建脱敏表
CREATE TABLE citizen_data_masked (
    LIKE citizen_data INCLUDING ALL
);

-- 添加触发器
CREATE TRIGGER mask_on_insert
    BEFORE INSERT ON citizen_data_masked
    FOR EACH ROW
    EXECUTE FUNCTION mask_sensitive_data();
```

## 4. 实践案例

### 4.1 社保数据脱敏

**案例背景**:

某社保系统（2025 年 11 月）：

- **数据规模**: 1000 万条公民数据
- **敏感字段**: 姓名、身份证、手机号
- **需求**: 查询时自动脱敏

**实现方案**:

```sql
-- 1. 创建脱敏视图
CREATE VIEW v_citizen_data_masked AS
SELECT
    id,
    data_masking.mask_name(name) AS name,
    data_masking.mask_phone(phone) AS phone,
    data_masking.mask_id_card(id_card) AS id_card,
    region_id,
    status
FROM citizen_data;

-- 2. 授予权限
GRANT SELECT ON v_citizen_data_masked TO analyst_role;

-- 3. 查询使用视图
SELECT * FROM v_citizen_data_masked
WHERE region_id = $1
LIMIT 100;
```

**效果**:

- **隐私保护**: 100% 保护敏感信息
- **性能影响**: <3% 性能损失
- **合规性**: 100% 满足合规要求

## 5. 参考资料

- [社保大数据系统](./社保大数据系统.md)
- [合规查询优化](./合规查询优化.md)
- [数据库合规架构](../../05-合规与可信/技术原理/数据库合规架构.md)

---

**最后更新**: 2025 年 11 月 1 日
**维护者**: PostgreSQL Modern Team
**文档编号**: 08-05-03
