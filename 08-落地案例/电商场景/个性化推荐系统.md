# ç”µå•†ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-01-02

## ğŸ“‘ ç›®å½•

- [ç”µå•†ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](#ç”µå•†ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
  - [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
    - [2.1 æ¶æ„è®¾è®¡](#21-æ¶æ„è®¾è®¡)
    - [2.2 æŠ€æœ¯æ ˆ](#22-æŠ€æœ¯æ ˆ)
  - [3. æ•°æ®æ¨¡å‹è®¾è®¡](#3-æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 å•†å“è¡¨](#31-å•†å“è¡¨)
    - [3.2 ç”¨æˆ·è¡¨](#32-ç”¨æˆ·è¡¨)
    - [3.3 ç”¨æˆ·è¡Œä¸ºè¡¨](#33-ç”¨æˆ·è¡Œä¸ºè¡¨)
  - [4. æ¨èç®—æ³•å®ç°](#4-æ¨èç®—æ³•å®ç°)
    - [4.1 åŸºäºå†…å®¹çš„æ¨è](#41-åŸºäºå†…å®¹çš„æ¨è)
    - [4.2 ååŒè¿‡æ»¤æ¨è](#42-ååŒè¿‡æ»¤æ¨è)
    - [4.3 æ··åˆæ¨è](#43-æ··åˆæ¨è)
  - [5. æ€§èƒ½ä¼˜åŒ–](#5-æ€§èƒ½ä¼˜åŒ–)
    - [5.1 ç¼“å­˜ç­–ç•¥](#51-ç¼“å­˜ç­–ç•¥)
    - [5.2 æ‰¹é‡æ›´æ–°ç”¨æˆ·å‘é‡](#52-æ‰¹é‡æ›´æ–°ç”¨æˆ·å‘é‡)
  - [6. æ•ˆæœè¯„ä¼°](#6-æ•ˆæœè¯„ä¼°)
    - [6.1 A/B æµ‹è¯•](#61-ab-æµ‹è¯•)
    - [6.2 æŒ‡æ ‡ç›‘æ§](#62-æŒ‡æ ‡ç›‘æ§)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

- **ä¸ªæ€§åŒ–æ¨è**: æ ¹æ®ç”¨æˆ·å†å²è¡Œä¸ºæ¨èå•†å“
- **å®æ—¶æ€§**: å®æ—¶å“åº”ç”¨æˆ·è¡Œä¸º
- **å‡†ç¡®æ€§**: æé«˜æ¨èå‡†ç¡®ç‡å’Œè½¬åŒ–ç‡
- **å¯æ‰©å±•æ€§**: æ”¯æŒå¤§è§„æ¨¡ç”¨æˆ·å’Œå•†å“

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å‘é‡åŒ–**: å•†å“å’Œç”¨æˆ·å‘é‡åŒ–è¡¨ç¤º
- **ç›¸ä¼¼åº¦è®¡ç®—**: ä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦è®¡ç®—æ¨è
- **æ··åˆæ¨è**: ç»“åˆååŒè¿‡æ»¤å’Œå†…å®¹æ¨è

### 1.2 æ ¸å¿ƒä»·å€¼

- **è½¬åŒ–ç‡æå‡**: å®é™…æ¡ˆä¾‹æ˜¾ç¤ºè½¬åŒ–ç‡æå‡ 35%
- **ç”¨æˆ·ä½“éªŒ**: ä¸ªæ€§åŒ–æ¨èæå‡ç”¨æˆ·ä½“éªŒ
- **æ”¶å…¥å¢é•¿**: æ¨èå•†å“å¸¦æ¥é¢å¤–æ”¶å…¥

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ¶æ„è®¾è®¡

```text
ç”¨æˆ·è¡Œä¸ºé‡‡é›†
  â†“
è¡Œä¸ºæ•°æ®é¢„å¤„ç†
  â†“
å‘é‡ç”ŸæˆæœåŠ¡
  â”œâ”€â”€ å•†å“å‘é‡åŒ–
  â””â”€â”€ ç”¨æˆ·å‘é‡åŒ–
  â†“
æ¨èå¼•æ“
  â”œâ”€â”€ å‘é‡ç›¸ä¼¼åº¦è®¡ç®—
  â”œâ”€â”€ ååŒè¿‡æ»¤
  â””â”€â”€ æ··åˆæ¨è
  â†“
æ¨èç»“æœè¿”å›
```

### 2.2 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + pgvector
- **å‘é‡ç”Ÿæˆ**: OpenAI Embeddings / Sentence Transformers
- **åº”ç”¨æ¡†æ¶**: Spring Boot / FastAPI
- **ç¼“å­˜**: Redis

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 å•†å“è¡¨

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    price DECIMAL(10, 2),
    embedding vector(1536),  -- å•†å“å‘é‡
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON products USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON products (category);
```

### 3.2 ç”¨æˆ·è¡¨

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    embedding vector(1536),  -- ç”¨æˆ·å‘é‡ï¼ˆåŸºäºå†å²è¡Œä¸ºï¼‰
    preferences JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON users USING hnsw (embedding vector_cosine_ops);
```

### 3.3 ç”¨æˆ·è¡Œä¸ºè¡¨

```sql
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    product_id INTEGER REFERENCES products(id),
    behavior_type TEXT,  -- 'view', 'cart', 'purchase'
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON user_behaviors (user_id, timestamp DESC);
CREATE INDEX ON user_behaviors (product_id);
```

## 4. æ¨èç®—æ³•å®ç°

### 4.1 åŸºäºå†…å®¹çš„æ¨è

```python
# åŸºäºå•†å“ç›¸ä¼¼åº¦çš„æ¨è
class ContentBasedRecommendation:
    async def recommend(self, product_id, limit=10):
        """åŸºäºå•†å“ç›¸ä¼¼åº¦æ¨è"""
        # 1. è·å–å•†å“å‘é‡
        product = await self.db.fetchrow("""
            SELECT embedding FROM products WHERE id = $1
        """, product_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼å•†å“
        similar_products = await self.db.fetch("""
            SELECT id, name, price,
                   1 - (embedding <=> $1::vector) AS similarity
            FROM products
            WHERE id != $2
            ORDER BY embedding <=> $1::vector
            LIMIT $3
        """, product['embedding'], product_id, limit)

        return similar_products
```

### 4.2 ååŒè¿‡æ»¤æ¨è

```python
# åŸºäºç”¨æˆ·ç›¸ä¼¼åº¦çš„æ¨è
class CollaborativeFiltering:
    async def update_user_embedding(self, user_id):
        """æ›´æ–°ç”¨æˆ·å‘é‡ï¼ˆåŸºäºå†å²è¡Œä¸ºï¼‰"""
        # 1. è·å–ç”¨æˆ·è¡Œä¸ºå•†å“
        behaviors = await self.db.fetch("""
            SELECT product_id, behavior_type, timestamp
            FROM user_behaviors
            WHERE user_id = $1
            ORDER BY timestamp DESC
            LIMIT 100
        """, user_id)

        # 2. è®¡ç®—åŠ æƒå¹³å‡å‘é‡
        product_ids = [b['product_id'] for b in behaviors]
        products = await self.db.fetch("""
            SELECT embedding FROM products WHERE id = ANY($1::int[])
        """, product_ids)

        # 3. åŠ æƒå¹³å‡ï¼ˆè´­ä¹°æƒé‡ > åŠ è´­æƒé‡ > æµè§ˆæƒé‡ï¼‰
        weights = {
            'purchase': 3.0,
            'cart': 2.0,
            'view': 1.0
        }

        weighted_vectors = []
        for i, behavior in enumerate(behaviors):
            product_embedding = next(
                p['embedding'] for p in products
                if p['id'] == behavior['product_id']
            )
            weight = weights.get(behavior['behavior_type'], 1.0)
            weighted_vectors.append(product_embedding * weight)

        user_embedding = np.mean(weighted_vectors, axis=0)

        # 4. æ›´æ–°ç”¨æˆ·å‘é‡
        await self.db.execute("""
            UPDATE users
            SET embedding = $1::vector
            WHERE id = $2
        """, user_embedding.tolist(), user_id)

    async def recommend(self, user_id, limit=10):
        """åŸºäºç”¨æˆ·å‘é‡æ¨è"""
        # 1. è·å–ç”¨æˆ·å‘é‡
        user = await self.db.fetchrow("""
            SELECT embedding FROM users WHERE id = $1
        """, user_id)

        # 2. æŸ¥æ‰¾ç”¨æˆ·æœªè´­ä¹°è¿‡çš„ç›¸ä¼¼å•†å“
        recommendations = await self.db.fetch("""
            SELECT p.id, p.name, p.price,
                   1 - (p.embedding <=> $1::vector) AS similarity
            FROM products p
            WHERE p.id NOT IN (
                SELECT product_id FROM user_behaviors
                WHERE user_id = $2 AND behavior_type = 'purchase'
            )
            ORDER BY p.embedding <=> $1::vector
            LIMIT $3
        """, user['embedding'], user_id, limit)

        return recommendations
```

### 4.3 æ··åˆæ¨è

```python
# æ··åˆæ¨èï¼ˆå†…å®¹ + ååŒè¿‡æ»¤ï¼‰
class HybridRecommendation:
    async def recommend(self, user_id, limit=10):
        """æ··åˆæ¨è"""
        # 1. å†…å®¹æ¨èï¼ˆåŸºäºæœ€è¿‘æµè§ˆçš„å•†å“ï¼‰
        recent_product = await self.db.fetchrow("""
            SELECT product_id FROM user_behaviors
            WHERE user_id = $1
            ORDER BY timestamp DESC
            LIMIT 1
        """, user_id)

        content_results = []
        if recent_product:
            content_service = ContentBasedRecommendation()
            content_results = await content_service.recommend(
                recent_product['product_id'],
                limit * 2
            )

        # 2. ååŒè¿‡æ»¤æ¨è
        cf_service = CollaborativeFiltering()
        cf_results = await cf_service.recommend(user_id, limit * 2)

        # 3. RRF èåˆ
        fused_results = self.rrf_fusion(content_results, cf_results, k=60)

        return fused_results[:limit]

    def rrf_fusion(self, results1, results2, k=60):
        """RRF èåˆ"""
        scores = {}

        for rank, item in enumerate(results1, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {'item': item, 'score': 0}
            scores[item_id]['score'] += 1.0 / (k + rank)

        for rank, item in enumerate(results2, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {'item': item, 'score': 0}
            scores[item_id]['score'] += 1.0 / (k + rank)

        # æŒ‰åˆ†æ•°æ’åº
        sorted_results = sorted(
            scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )

        return [r['item'] for r in sorted_results]
```

## 5. æ€§èƒ½ä¼˜åŒ–

### 5.1 ç¼“å­˜ç­–ç•¥

```python
# æ¨èç»“æœç¼“å­˜
class CachedRecommendation:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.cache_ttl = 3600  # 1å°æ—¶

    async def get_recommendations(self, user_id, limit=10):
        """è·å–æ¨èï¼ˆå¸¦ç¼“å­˜ï¼‰"""
        cache_key = f"recommendations:{user_id}:{limit}"

        # æ£€æŸ¥ç¼“å­˜
        cached = await self.redis.get(cache_key)
        if cached:
            return json.loads(cached)

        # ç”Ÿæˆæ¨è
        recommendations = await self._generate_recommendations(user_id, limit)

        # ç¼“å­˜ç»“æœ
        await self.redis.setex(
            cache_key,
            self.cache_ttl,
            json.dumps(recommendations)
        )

        return recommendations
```

### 5.2 æ‰¹é‡æ›´æ–°ç”¨æˆ·å‘é‡

```python
# æ‰¹é‡æ›´æ–°ç”¨æˆ·å‘é‡ï¼ˆå®šæ—¶ä»»åŠ¡ï¼‰
class UserEmbeddingUpdater:
    async def update_all_users(self):
        """æ‰¹é‡æ›´æ–°æ‰€æœ‰ç”¨æˆ·å‘é‡"""
        users = await self.db.fetch("SELECT id FROM users")

        batch_size = 100
        for i in range(0, len(users), batch_size):
            batch = users[i:i + batch_size]

            tasks = [
                self.update_user_embedding(user['id'])
                for user in batch
            ]

            await asyncio.gather(*tasks)
```

## 6. æ•ˆæœè¯„ä¼°

### 6.1 A/B æµ‹è¯•

```python
# A/B æµ‹è¯•æ¡†æ¶
class ABTest:
    async def get_recommendations(self, user_id, limit=10):
        """æ ¹æ® A/B æµ‹è¯•è¿”å›æ¨è"""
        # åˆ†é…ç”¨æˆ·åˆ°å®éªŒç»„
        experiment_group = self._assign_group(user_id)

        if experiment_group == 'A':
            # å¯¹ç…§ç»„ï¼šä¼ ç»Ÿæ¨è
            return await self.traditional_recommend(user_id, limit)
        else:
            # å®éªŒç»„ï¼šå‘é‡æ¨è
            return await self.vector_recommend(user_id, limit)

    def _assign_group(self, user_id):
        """åˆ†é…å®éªŒç»„ï¼ˆ50/50ï¼‰"""
        return 'A' if user_id % 2 == 0 else 'B'
```

### 6.2 æŒ‡æ ‡ç›‘æ§

```sql
-- æ¨èæ•ˆæœç»Ÿè®¡
SELECT
    DATE(timestamp) AS date,
    COUNT(*) AS total_recommendations,
    SUM(CASE WHEN behavior_type = 'purchase' THEN 1 ELSE 0 END) AS purchases,
    SUM(CASE WHEN behavior_type = 'cart' THEN 1 ELSE 0 END) AS carts,
    SUM(CASE WHEN behavior_type = 'view' THEN 1 ELSE 0 END) AS views
FROM user_behaviors
WHERE timestamp >= NOW() - INTERVAL '7 days'
GROUP BY DATE(timestamp)
ORDER BY date DESC;
```

## 7. å‚è€ƒèµ„æ–™

- [å•†å“æ··åˆæœç´¢æ¡ˆä¾‹](./å•†å“æ··åˆæœç´¢æ¡ˆä¾‹.md)
- [å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡](../../01-å‘é‡ä¸æ··åˆæœç´¢/æ¶æ„è®¾è®¡/å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡.md)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-01-02
