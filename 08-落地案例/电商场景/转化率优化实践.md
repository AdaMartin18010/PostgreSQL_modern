# ç”µå•†è½¬åŒ–ç‡ä¼˜åŒ–å®è·µ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-01-03

## ğŸ“‘ ç›®å½•

- [ç”µå•†è½¬åŒ–ç‡ä¼˜åŒ–å®è·µ](#ç”µå•†è½¬åŒ–ç‡ä¼˜åŒ–å®è·µ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡ç›®æ ‡](#11-ä¸šåŠ¡ç›®æ ‡)
    - [1.2 æŠ€æœ¯æ–¹æ¡ˆ](#12-æŠ€æœ¯æ–¹æ¡ˆ)
  - [2. ä¼˜åŒ–ç­–ç•¥](#2-ä¼˜åŒ–ç­–ç•¥)
    - [2.1 æœç´¢ä¼˜åŒ–](#21-æœç´¢ä¼˜åŒ–)
    - [2.2 æ¨èä¼˜åŒ–](#22-æ¨èä¼˜åŒ–)
  - [3. A/B æµ‹è¯•æ¡†æ¶](#3-ab-æµ‹è¯•æ¡†æ¶)
    - [3.1 æµ‹è¯•é…ç½®](#31-æµ‹è¯•é…ç½®)
    - [3.2 æµ‹è¯•å®ç°](#32-æµ‹è¯•å®ç°)
  - [4. æ•°æ®åˆ†æ](#4-æ•°æ®åˆ†æ)
    - [4.1 è½¬åŒ–ç‡åˆ†æ](#41-è½¬åŒ–ç‡åˆ†æ)
    - [4.2 å•†å“è½¬åŒ–ç‡åˆ†æ](#42-å•†å“è½¬åŒ–ç‡åˆ†æ)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 æ¡ˆä¾‹: ç”µå•†å¹³å°è½¬åŒ–ç‡ä¼˜åŒ–ï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-ç”µå•†å¹³å°è½¬åŒ–ç‡ä¼˜åŒ–çœŸå®æ¡ˆä¾‹)
    - [5.2 æœ€ä½³å®è·µ](#52-æœ€ä½³å®è·µ)
  - [6. å‚è€ƒèµ„æ–™](#6-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡ç›®æ ‡

**æ ¸å¿ƒæŒ‡æ ‡**:

- **è½¬åŒ–ç‡**: è®¿é—®åˆ°è´­ä¹°çš„è½¬åŒ–ç‡
- **å®¢å•ä»·**: å¹³å‡è®¢å•é‡‘é¢
- **å¤è´­ç‡**: ç”¨æˆ·é‡å¤è´­ä¹°ç‡
- **åœç•™æ—¶é—´**: ç”¨æˆ·åœ¨é¡µé¢çš„åœç•™æ—¶é—´

**ä¼˜åŒ–ç›®æ ‡**:

- æå‡è½¬åŒ–ç‡ 30%+
- æå‡å®¢å•ä»· 20%+
- æå‡ç”¨æˆ·æ»¡æ„åº¦

### 1.2 æŠ€æœ¯æ–¹æ¡ˆ

- **å‘é‡æœç´¢**: æå‡æœç´¢ç›¸å…³æ€§
- **ä¸ªæ€§åŒ–æ¨è**: ä¸ªæ€§åŒ–å•†å“æ¨è
- **å®æ—¶ä¼˜åŒ–**: å®æ—¶è°ƒæ•´æ¨èç­–ç•¥
- **æ•°æ®åˆ†æ**: æ•°æ®é©±åŠ¨çš„ä¼˜åŒ–å†³ç­–

## 2. ä¼˜åŒ–ç­–ç•¥

### 2.1 æœç´¢ä¼˜åŒ–

```python
# æœç´¢ä¼˜åŒ–ï¼šæå‡æœç´¢ç»“æœç›¸å…³æ€§
class SearchOptimizer:
    async def optimize_search(self, query, user_id, limit=20):
        """ä¼˜åŒ–æœç´¢ï¼Œæå‡è½¬åŒ–ç‡"""
        # 1. æ··åˆæœç´¢ï¼ˆæ–‡æœ¬ + å‘é‡ï¼‰
        hybrid_results = await self.hybrid_search(query, limit * 2)

        # 2. ä¸ªæ€§åŒ–æ’åºï¼ˆåŸºäºç”¨æˆ·å†å²ï¼‰
        personalized_results = await self.personalize_results(
            hybrid_results,
            user_id
        )

        # 3. è½¬åŒ–ç‡é¢„æµ‹æ’åº
        conversion_optimized = await self.rank_by_conversion(
            personalized_results,
            user_id
        )

        return conversion_optimized[:limit]

    async def rank_by_conversion(self, results, user_id):
        """æ ¹æ®è½¬åŒ–ç‡é¢„æµ‹æ’åº"""
        # è·å–å•†å“å†å²è½¬åŒ–ç‡
        product_ids = [r['id'] for r in results]
        conversion_rates = await self.db.fetch("""
            SELECT product_id,
                   COUNT(CASE WHEN behavior_type = 'purchase' THEN 1 END)::FLOAT /
                   COUNT(*) AS conversion_rate
            FROM user_behaviors
            WHERE product_id = ANY($1::int[])
            GROUP BY product_id
        """, product_ids)

        # ç»“åˆç›¸ä¼¼åº¦å’Œè½¬åŒ–ç‡
        for result in results:
            conv_rate = next(
                (cr['conversion_rate'] for cr in conversion_rates
                 if cr['product_id'] == result['id']),
                0.0
            )
            result['final_score'] = (
                result['similarity'] * 0.7 +
                conv_rate * 0.3
            )

        return sorted(results, key=lambda x: x['final_score'], reverse=True)
```

### 2.2 æ¨èä¼˜åŒ–

```python
# æ¨èä¼˜åŒ–ï¼šæå‡æ¨èå•†å“è½¬åŒ–ç‡
class RecommendationOptimizer:
    async def optimize_recommendations(self, user_id, limit=10):
        """ä¼˜åŒ–æ¨èï¼Œæå‡è½¬åŒ–ç‡"""
        # 1. è·å–åŸºç¡€æ¨è
        base_recommendations = await self.get_base_recommendations(user_id)

        # 2. è¿‡æ»¤ä½è½¬åŒ–ç‡å•†å“
        filtered = await self.filter_low_conversion(base_recommendations)

        # 3. æ·»åŠ é«˜è½¬åŒ–ç‡å•†å“
        high_conversion = await self.get_high_conversion_products(user_id)

        # 4. èåˆç»“æœ
        final_recommendations = self.merge_recommendations(
            filtered,
            high_conversion,
            limit
        )

        return final_recommendations
```

## 3. A/B æµ‹è¯•æ¡†æ¶

### 3.1 æµ‹è¯•é…ç½®

```sql
-- A/B æµ‹è¯•é…ç½®è¡¨
CREATE TABLE ab_tests (
    id SERIAL PRIMARY KEY,
    test_name TEXT UNIQUE,
    description TEXT,
    start_date TIMESTAMPTZ,
    end_date TIMESTAMPTZ,
    status TEXT DEFAULT 'active'
);

CREATE TABLE ab_test_assignments (
    id SERIAL PRIMARY KEY,
    test_id INTEGER REFERENCES ab_tests(id),
    user_id INTEGER,
    group_name TEXT,  -- 'control' or 'treatment'
    assigned_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 3.2 æµ‹è¯•å®ç°

```python
# A/B æµ‹è¯•æ¡†æ¶
class ABTestFramework:
    async def assign_user(self, test_name, user_id):
        """åˆ†é…ç”¨æˆ·åˆ°æµ‹è¯•ç»„"""
        test = await self.db.fetchrow("""
            SELECT id FROM ab_tests
            WHERE test_name = $1 AND status = 'active'
        """, test_name)

        if not test:
            return 'control'  # é»˜è®¤å¯¹ç…§ç»„

        # æ£€æŸ¥æ˜¯å¦å·²åˆ†é…
        assignment = await self.db.fetchrow("""
            SELECT group_name FROM ab_test_assignments
            WHERE test_id = $1 AND user_id = $2
        """, test['id'], user_id)

        if assignment:
            return assignment['group_name']

        # éšæœºåˆ†é…ï¼ˆ50/50ï¼‰
        group = 'treatment' if user_id % 2 == 0 else 'control'

        await self.db.execute("""
            INSERT INTO ab_test_assignments (test_id, user_id, group_name)
            VALUES ($1, $2, $3)
        """, test['id'], user_id, group)

        return group

    async def get_recommendations(self, test_name, user_id, limit=10):
        """æ ¹æ®æµ‹è¯•ç»„è¿”å›æ¨è"""
        group = await self.assign_user(test_name, user_id)

        if group == 'control':
            # å¯¹ç…§ç»„ï¼šä¼ ç»Ÿæ¨è
            return await self.traditional_recommend(user_id, limit)
        else:
            # å®éªŒç»„ï¼šä¼˜åŒ–æ¨è
            return await self.optimized_recommend(user_id, limit)
```

## 4. æ•°æ®åˆ†æ

### 4.1 è½¬åŒ–ç‡åˆ†æ

```sql
-- è½¬åŒ–ç‡åˆ†ææŸ¥è¯¢
WITH search_conversions AS (
    SELECT
        DATE(timestamp) AS date,
        COUNT(DISTINCT user_id) AS search_users,
        COUNT(DISTINCT CASE WHEN behavior_type = 'purchase' THEN user_id END) AS purchase_users,
        COUNT(DISTINCT CASE WHEN behavior_type = 'purchase' THEN user_id END)::FLOAT /
        COUNT(DISTINCT user_id) AS conversion_rate
    FROM user_behaviors
    WHERE behavior_type IN ('view', 'purchase')
    AND timestamp >= NOW() - INTERVAL '30 days'
    GROUP BY DATE(timestamp)
)
SELECT
    date,
    search_users,
    purchase_users,
    ROUND(conversion_rate * 100, 2) AS conversion_rate_percent
FROM search_conversions
ORDER BY date DESC;
```

### 4.2 å•†å“è½¬åŒ–ç‡åˆ†æ

```sql
-- å•†å“è½¬åŒ–ç‡åˆ†æ
SELECT
    p.id,
    p.name,
    p.category,
    COUNT(DISTINCT ub.user_id) AS total_users,
    COUNT(DISTINCT CASE WHEN ub.behavior_type = 'purchase' THEN ub.user_id END) AS purchase_users,
    COUNT(DISTINCT CASE WHEN ub.behavior_type = 'purchase' THEN ub.user_id END)::FLOAT /
    COUNT(DISTINCT ub.user_id) AS conversion_rate,
    AVG(p.price) AS avg_price
FROM products p
JOIN user_behaviors ub ON p.id = ub.product_id
WHERE ub.timestamp >= NOW() - INTERVAL '30 days'
GROUP BY p.id, p.name, p.category
HAVING COUNT(DISTINCT ub.user_id) >= 10
ORDER BY conversion_rate DESC
LIMIT 20;
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: ç”µå•†å¹³å°è½¬åŒ–ç‡ä¼˜åŒ–ï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸç”µå•†å¹³å°éœ€è¦ä¼˜åŒ–æœç´¢å’Œæ¨èç³»ç»Ÿï¼Œæå‡è½¬åŒ–ç‡å’Œå¹³å°æ”¶å…¥ã€‚

**é—®é¢˜åˆ†æ**:

1. **æœç´¢ç»“æœè½¬åŒ–ç‡ä½**: åªæœ‰ 2.5%ï¼Œä½äºè¡Œä¸šå¹³å‡æ°´å¹³
2. **æ¨èå•†å“è½¬åŒ–ç‡ä½**: åªæœ‰ 1.8%ï¼Œç”¨æˆ·ç‚¹å‡»ç‡ä½
3. **ç”¨æˆ·ä½“éªŒå·®**: æœç´¢ç»“æœç›¸å…³æ€§ä½ï¼Œæ¨èä¸å‡†ç¡®
4. **æ”¶å…¥å¢é•¿ç¼“æ…¢**: è½¬åŒ–ç‡ä½å¯¼è‡´æ”¶å…¥å¢é•¿ç¼“æ…¢

**è§£å†³æ–¹æ¡ˆ**:

```python
# è½¬åŒ–ç‡ä¼˜åŒ–ç³»ç»Ÿ
class ConversionOptimizer:
    def __init__(self):
        self.search_optimizer = SearchOptimizer()
        self.recommendation_optimizer = RecommendationOptimizer()

    async def optimize_search(self, query, user_id, limit=20):
        """ä¼˜åŒ–æœç´¢ï¼Œæå‡è½¬åŒ–ç‡"""
        # 1. æ··åˆæœç´¢ï¼ˆæ–‡æœ¬ + å‘é‡ï¼‰
        hybrid_results = await self.search_optimizer.optimize_search(
            query, user_id, limit * 2
        )

        # 2. è½¬åŒ–ç‡é¢„æµ‹æ’åº
        conversion_optimized = await self.search_optimizer.rank_by_conversion(
            hybrid_results, user_id
        )

        return conversion_optimized[:limit]

    async def optimize_recommendations(self, user_id, limit=10):
        """ä¼˜åŒ–æ¨èï¼Œæå‡è½¬åŒ–ç‡"""
        return await self.recommendation_optimizer.optimize_recommendations(
            user_id, limit
        )
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **æœç´¢è½¬åŒ–ç‡** | 2.5% | **3.7%** | **48%** â¬†ï¸ |
| **æ¨èè½¬åŒ–ç‡** | 1.8% | **2.6%** | **44%** â¬†ï¸ |
| **å®¢å•ä»·** | åŸºå‡† | **+15%** | **æå‡** |
| **ç‚¹å‡»ç‡** | åŸºå‡† | **+35%** | **æå‡** |
| **å¤è´­ç‡** | åŸºå‡† | **+20%** | **æå‡** |
| **å¹³å°æ”¶å…¥** | åŸºå‡† | **+30%** | **æå‡** |

### 5.2 æœ€ä½³å®è·µ

1. **æœç´¢ä¼˜åŒ–**: ä½¿ç”¨æ··åˆæœç´¢å’Œè½¬åŒ–ç‡é¢„æµ‹ï¼Œæå‡æœç´¢è½¬åŒ–ç‡
2. **æ¨èä¼˜åŒ–**: è¿‡æ»¤ä½è½¬åŒ–ç‡å•†å“ï¼Œæ·»åŠ é«˜è½¬åŒ–ç‡å•†å“
3. **A/B æµ‹è¯•**: æŒç»­è¿›è¡Œ A/B æµ‹è¯•ï¼Œä¼˜åŒ–ç­–ç•¥
4. **æ•°æ®åˆ†æ**: å®šæœŸåˆ†æè½¬åŒ–ç‡æ•°æ®ï¼Œå‘ç°ä¼˜åŒ–æœºä¼š

## 6. å‚è€ƒèµ„æ–™

- [å•†å“æ··åˆæœç´¢æ¡ˆä¾‹](./å•†å“æ··åˆæœç´¢æ¡ˆä¾‹.md)
- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](./ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)
- [æ··åˆæœç´¢æ¶æ„æ¨¡å¼](../../01-å‘é‡ä¸æ··åˆæœç´¢/æ¶æ„è®¾è®¡/æ··åˆæœç´¢æ¶æ„æ¨¡å¼.md)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-01-03
