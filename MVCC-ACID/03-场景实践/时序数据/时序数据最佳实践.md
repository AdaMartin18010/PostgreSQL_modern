# PostgreSQL时序数据最佳实践

> **文档编号**: SCENARIO-TIMESERIES-BESTPRACTICES-001
> **主题**: 时序数据最佳实践
> **版本**: PostgreSQL 17 & 18

---

## 📑 目录

- [PostgreSQL时序数据最佳实践](#postgresql时序数据最佳实践)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [🔍 第一部分：设计模式](#-第一部分设计模式)
    - [1.1 表设计](#11-表设计)
    - [1.2 分区设计](#12-分区设计)
    - [1.3 索引设计](#13-索引设计)
  - [🚀 第二部分：性能优化](#-第二部分性能优化)
    - [2.1 写入优化](#21-写入优化)
    - [2.2 查询优化](#22-查询优化)
    - [2.3 维护优化](#23-维护优化)
  - [📊 第三部分：MVCC优化](#-第三部分mvcc优化)
    - [3.1 版本链优化](#31-版本链优化)
    - [3.2 VACUUM优化](#32-vacuum优化)
    - [3.3 快照优化](#33-快照优化)
  - [📝 总结](#-总结)
    - [核心原则](#核心原则)
    - [最佳实践](#最佳实践)

---

## 📋 概述

本文档总结PostgreSQL时序数据场景的最佳实践，包括设计模式、性能优化和MVCC优化，为时序数据系统设计提供完整指导。

---

## 🔍 第一部分：设计模式

### 1.1 表设计

```sql
-- 时序数据表设计最佳实践
CREATE TABLE metrics (
    time TIMESTAMP NOT NULL,           -- 时间戳（必需，NOT NULL）
    device_id INTEGER NOT NULL,        -- 设备ID（必需，NOT NULL）
    value DOUBLE PRECISION,            -- 值（根据需求）
    tags JSONB,                        -- 标签（可选）
    metadata JSONB                      -- 元数据（可选）
) PARTITION BY RANGE (time);

-- 设计原则：
-- 1. 时间戳NOT NULL
-- 2. 列顺序优化（常用列在前）
-- 3. 使用合适的数据类型
-- 4. 避免大字段（使用TOAST）

-- MVCC影响：
-- 表设计影响存储
-- 影响TOAST使用
-- 影响查询性能
```

### 1.2 分区设计

```sql
-- 分区设计最佳实践
-- 1. 时间范围分区（推荐）
CREATE TABLE metrics (
    time TIMESTAMP NOT NULL,
    device_id INTEGER NOT NULL,
    value DOUBLE PRECISION
) PARTITION BY RANGE (time);

-- 2. 月分区（推荐粒度）
CREATE TABLE metrics_2024_01 PARTITION OF metrics
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 3. 自动分区管理
-- 使用pg_partman或自定义脚本

-- MVCC影响：
-- 分区设计减少单分区数据量
-- 提高VACUUM效率
-- 提高查询性能
```

### 1.3 索引设计

```sql
-- 索引设计最佳实践
-- 1. 时间索引（必需）
CREATE INDEX idx_metrics_time ON metrics (time);

-- 2. 复合索引（根据查询模式）
CREATE INDEX idx_metrics_device_time ON metrics (device_id, time DESC);

-- 3. 部分索引（优化热点数据）
CREATE INDEX idx_metrics_recent ON metrics (time)
WHERE time > NOW() - INTERVAL '7 days';

-- MVCC影响：
-- 索引设计影响写入性能
-- 影响查询性能
-- 需要平衡
```

---

## 🚀 第二部分：性能优化

### 2.1 写入优化

```sql
-- 写入优化最佳实践
-- 1. 批量INSERT（推荐）
INSERT INTO metrics (time, device_id, value)
VALUES
    (NOW(), 1, 100.0),
    (NOW(), 2, 200.0),
    (NOW(), 3, 300.0);

-- 2. COPY（最高性能）
COPY metrics (time, device_id, value) FROM STDIN;
2024-01-01 00:00:00,1,100.0
2024-01-01 00:00:01,2,200.0
\.

-- 3. fillfactor优化
ALTER TABLE metrics SET (fillfactor = 90);

-- MVCC影响：
-- 批量写入减少事务开销
-- fillfactor提高HOT更新率
-- 提高写入性能
```

### 2.2 查询优化

```sql
-- 查询优化最佳实践
-- 1. 时间范围查询（利用分区裁剪）
SELECT * FROM metrics
WHERE time BETWEEN '2024-01-01' AND '2024-01-02';

-- 2. 使用索引
SELECT * FROM metrics
WHERE device_id = 1
AND time BETWEEN '2024-01-01' AND '2024-01-02';

-- 3. 避免SELECT *
SELECT time, device_id, value FROM metrics
WHERE time BETWEEN '2024-01-01' AND '2024-01-02';

-- MVCC影响：
-- 查询优化减少扫描数据量
-- 减少MVCC开销
-- 提高查询性能
```

### 2.3 维护优化

```sql
-- 维护优化最佳实践
-- 1. 定期VACUUM
VACUUM ANALYZE metrics;

-- 2. 分区级VACUUM
VACUUM ANALYZE metrics_2024_01;

-- 3. 自动归档
-- 归档3个月前的数据

-- MVCC影响：
-- 维护优化减少数据量
-- 提高VACUUM效率
-- 提高性能
```

---

## 📊 第三部分：MVCC优化

### 3.1 版本链优化

```sql
-- 版本链优化最佳实践
-- 1. 减少UPDATE/DELETE
-- 时序数据很少UPDATE/DELETE
-- 使用归档代替DELETE

-- 2. HOT更新优化
ALTER TABLE metrics SET (fillfactor = 90);

-- 3. 监控版本链长度
SELECT
    relname,
    n_live_tup,
    n_dead_tup,
    round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
FROM pg_stat_user_tables
WHERE relname LIKE 'metrics_%';

-- MVCC影响：
-- 版本链优化减少版本链长度
-- 提高VACUUM效率
-- 提高查询性能
```

### 3.2 VACUUM优化

```sql
-- VACUUM优化最佳实践
-- 1. 分区级VACUUM
VACUUM ANALYZE metrics_2024_01;

-- 2. 自动VACUUM配置
ALTER TABLE metrics_2024_01 SET (
    autovacuum_vacuum_scale_factor = 0.05,
    autovacuum_analyze_scale_factor = 0.02
);

-- 3. 定期归档
-- 归档旧数据，减少VACUUM需求

-- MVCC影响：
-- VACUUM优化减少死亡元组
-- 提高VACUUM效率
-- 提高性能
```

### 3.3 快照优化

```text
快照优化最佳实践：

1. 减少事务长度：
   - 短事务
   - 快速提交
   - 减少快照开销

2. 减少活跃事务数：
   - 连接池
   - 事务管理
   - 减少快照开销

3. MVCC影响：
   - 快照优化减少快照开销
   - 提高查询性能
   - 性能提升
```

---

## 📝 总结

### 核心原则

1. **设计模式**: 表设计、分区设计、索引设计
2. **性能优化**: 写入优化、查询优化、维护优化
3. **MVCC优化**: 版本链优化、VACUUM优化、快照优化

### 最佳实践

1. **表设计**: 时间戳NOT NULL、列顺序优化、合适的数据类型
2. **分区设计**: 时间范围分区、月分区、自动分区管理
3. **索引设计**: 时间索引、复合索引、部分索引
4. **写入优化**: 批量INSERT、COPY、fillfactor优化
5. **查询优化**: 时间范围查询、使用索引、避免SELECT *
6. **维护优化**: 定期VACUUM、分区级VACUUM、自动归档
7. **MVCC优化**: 版本链优化、VACUUM优化、快照优化

时序数据最佳实践通过合理的设计和优化，可以在保证数据一致性的同时获得优异的性能，是时序数据场景的核心指导原则。
