# PostgreSQL 18 故障排查完整手册

## 1. 连接问题

### 1.1 无法连接

**现象**: `psql: could not connect to server`

**排查步骤**:

```bash
# 1. 检查PostgreSQL是否运行
sudo systemctl status postgresql
ps aux | grep postgres

# 2. 检查监听端口
sudo netstat -tlnp | grep 5432
sudo ss -tlnp | grep 5432

# 3. 检查监听地址
sudo -u postgres psql -c "SHOW listen_addresses;"

# 4. 检查防火墙
sudo ufw status
sudo iptables -L -n | grep 5432

# 5. 测试连接
telnet localhost 5432
psql -h localhost -U postgres -d postgres
```

**常见原因与解决**:

```text
原因1: PostgreSQL未启动
解决: sudo systemctl start postgresql

原因2: 监听地址错误
解决: postgresql.conf设置 listen_addresses = '*'

原因3: pg_hba.conf拒绝连接
解决: 添加允许规则
host all all 0.0.0.0/0 scram-sha-256

原因4: 防火墙阻止
解决: sudo ufw allow 5432

原因5: 连接数已满
解决: 增大max_connections或使用连接池
```

### 1.2 连接缓慢

```sql
-- 查看当前连接数
SELECT COUNT(*) FROM pg_stat_activity;

-- 查看连接详情
SELECT
    datname,
    usename,
    client_addr,
    state,
    COUNT(*)
FROM pg_stat_activity
GROUP BY datname, usename, client_addr, state;

-- 查看空闲连接
SELECT * FROM pg_stat_activity
WHERE state = 'idle'
AND state_change < now() - INTERVAL '5 minutes';

-- 终止空闲连接
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle'
  AND state_change < now() - INTERVAL '10 minutes';
```

---

## 2. 性能问题

### 2.1 查询慢

```sql
-- 查看正在执行的查询
SELECT
    pid,
    now() - query_start AS duration,
    usename,
    datname,
    state,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY duration DESC;

-- 分析慢查询（pg_stat_statements）
SELECT
    query,
    calls,
    total_exec_time / 1000 AS total_sec,
    mean_exec_time AS avg_ms,
    max_exec_time AS max_ms,
    stddev_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;

-- EXPLAIN分析
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM users WHERE email = 'test@example.com';

-- 检查是否缺少索引
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    seq_tup_read / NULLIF(seq_scan, 0) AS avg_seq_tup
FROM pg_stat_user_tables
WHERE seq_scan > 0
ORDER BY seq_tup_read DESC
LIMIT 20;
```

**优化方案**:

```text
1. 添加索引
CREATE INDEX idx_users_email ON users(email);

2. 更新统计信息
ANALYZE users;

3. 调整配置
work_mem = 256MB
effective_cache_size = 4GB

4. 优化SQL
- 避免SELECT *
- 使用JOIN代替子查询
- 添加WHERE条件

5. 分区表
- 时序数据按时间分区
- 大表哈希分区
```

### 2.2 TPS/QPS下降

```bash
# 实时监控TPS
watch -n 1 'psql -U postgres -c "
SELECT
    xact_commit + xact_rollback AS tps,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    ROUND(blks_hit * 100.0 / NULLIF(blks_hit + blks_read, 0), 2) AS cache_hit_ratio
FROM pg_stat_database
WHERE datname = '\''mydb'\'';
"'

# 检查锁等待
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.query AS blocked_query,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.query AS blocking_query
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

---

## 3. 磁盘问题

### 3.1 磁盘满

```bash
# 检查磁盘使用
df -h /var/lib/postgresql

# 查看数据库大小
psql -U postgres -c "
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC;
"

# 查看表大小
psql -U postgres -d mydb -c "
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS index_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;
"

# 查看WAL大小
du -sh /var/lib/postgresql/18/main/pg_wal

# 清理建议
# 1. VACUUM FULL大表
# 2. 删除旧WAL（调整wal_keep_size）
# 3. 清理旧备份
# 4. pg_dump导出后DROP旧表
```

### 3.2 磁盘I/O高

```bash
# 检查I/O使用
iostat -x 1 10

# 查看读写最多的表
SELECT
    schemaname,
    tablename,
    heap_blks_read + heap_blks_hit AS total_reads,
    heap_blks_read,
    ROUND(heap_blks_hit * 100.0 / NULLIF(heap_blks_read + heap_blks_hit, 0), 2) AS cache_hit_ratio,
    idx_blks_read + idx_blks_hit AS total_idx_reads
FROM pg_statio_user_tables
ORDER BY heap_blks_read DESC
LIMIT 20;

# PostgreSQL 18 I/O优化
ALTER SYSTEM SET io_direct = 'data';
ALTER SYSTEM SET io_combine_limit = '128kB';
SELECT pg_reload_conf();
```

---

## 4. 内存问题

### 4.1 内存不足

```bash
# 检查系统内存
free -h
vmstat 1 10

# 检查PostgreSQL内存使用
ps aux | grep postgres | awk '{sum+=$6} END {print sum/1024 "MB"}'

# 查看shared_buffers配置
psql -U postgres -c "SHOW shared_buffers;"

# 查看临时文件使用
SELECT
    datname,
    temp_files,
    pg_size_pretty(temp_bytes) AS temp_size
FROM pg_stat_database
WHERE temp_files > 0;
```

**优化建议**:

```ini
# 内存配置（64GB服务器）
shared_buffers = 16GB
work_mem = 256MB
maintenance_work_mem = 2GB
effective_cache_size = 48GB

# 减少临时文件
ALTER SYSTEM SET work_mem = '512MB';
```

### 4.2 OOM Killer

```bash
# 查看OOM日志
sudo dmesg | grep -i oom
sudo grep -i oom /var/log/syslog

# 禁用OOM Killer（谨慎）
echo -17 > /proc/$(pgrep -f 'postgres: checkpointer')/oom_adj

# 配置overcommit
sudo sysctl vm.overcommit_memory=2
sudo sysctl vm.overcommit_ratio=80
```

---

## 5. 复制问题

### 5.1 主从延迟

```sql
-- Primary查看复制状态
SELECT
    client_addr,
    application_name,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS send_lag,
    pg_wal_lsn_diff(sent_lsn, write_lsn) AS write_lag,
    pg_wal_lsn_diff(write_lsn, flush_lsn) AS flush_lag,
    pg_wal_lsn_diff(flush_lsn, replay_lsn) AS replay_lag
FROM pg_stat_replication;

-- Standby查看延迟
SELECT
    now() - pg_last_xact_replay_timestamp() AS replication_lag,
    pg_is_in_recovery();
```

**排查步骤**:

```bash
# 1. 检查网络
ping standby-server
iperf3 -c standby-server

# 2. 检查WAL发送速率
# Primary
SELECT pg_current_wal_lsn();
# 等待10秒
SELECT pg_current_wal_lsn();
# 计算速率

# 3. 检查Standby负载
ssh standby-server 'top -bn1 | head -20'

# 4. 检查复制槽
SELECT
    slot_name,
    slot_type,
    active,
    pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) AS lag_bytes
FROM pg_replication_slots;
```

### 5.2 复制中断

```bash
# 检查复制状态
SELECT * FROM pg_stat_wal_receiver;  # Standby

# 重建Standby
# 1. 在Standby上
sudo systemctl stop postgresql
sudo rm -rf /var/lib/postgresql/18/main/*

# 2. pg_basebackup
pg_basebackup -h primary-server -U replication \
  -D /var/lib/postgresql/18/main \
  -Fp -Xs -P

# 3. 配置standby.signal
touch /var/lib/postgresql/18/main/standby.signal

# 4. 启动
sudo systemctl start postgresql
```

---

## 6. 事务问题

### 6.1 长事务

```sql
-- 查看长事务
SELECT
    pid,
    usename,
    datname,
    state,
    now() - xact_start AS duration,
    query
FROM pg_stat_activity
WHERE xact_start < now() - INTERVAL '5 minutes'
  AND state != 'idle'
ORDER BY duration DESC;

-- 终止长事务
SELECT pg_terminate_backend(pid);

-- 查看事务ID使用情况
SELECT
    datname,
    age(datfrozenxid) AS xid_age,
    2^31 - 1000000 - age(datfrozenxid) AS xids_remaining
FROM pg_database
ORDER BY xid_age DESC;

-- VACUUM FREEZE
VACUUM (FREEZE, VERBOSE) large_table;
```

### 6.2 死锁

```sql
-- 启用死锁日志
ALTER SYSTEM SET deadlock_timeout = '1s';
ALTER SYSTEM SET log_lock_waits = on;

-- 查看锁
SELECT
    locktype,
    database,
    relation::regclass,
    mode,
    granted,
    pid
FROM pg_locks
WHERE NOT granted;

-- 查看死锁历史
# 检查日志文件
sudo grep -i deadlock /var/log/postgresql/postgresql-*.log
```

---

## 7. VACUUM问题

### 7.1 表膨胀

```sql
-- 检查膨胀
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    n_dead_tup,
    n_live_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;

-- 手动VACUUM
VACUUM (VERBOSE, ANALYZE) bloated_table;

-- VACUUM FULL（锁表）
VACUUM FULL bloated_table;

-- 检查autovacuum
SELECT * FROM pg_stat_progress_vacuum;

-- autovacuum配置
ALTER SYSTEM SET autovacuum_naptime = '1min';
ALTER SYSTEM SET autovacuum_vacuum_threshold = 50;
ALTER SYSTEM SET autovacuum_analyze_threshold = 50;
```

---

## 8. 检查点问题

### 8.1 检查点过频繁

```bash
# 查看检查点日志
sudo grep checkpoint /var/log/postgresql/postgresql-*.log

# 检查点统计
SELECT
    checkpoints_timed,
    checkpoints_req,
    checkpoint_write_time,
    checkpoint_sync_time,
    buffers_checkpoint
FROM pg_stat_bgwriter;
```

**优化**:

```ini
# 增大WAL大小
max_wal_size = 4GB
checkpoint_timeout = 15min
checkpoint_completion_target = 0.9
```

---

## 9. 扩展问题

### 9.1 扩展加载失败

```sql
-- 查看已安装扩展
SELECT * FROM pg_available_extensions;

-- 查看已启用扩展
SELECT * FROM pg_extension;

-- 安装扩展
CREATE EXTENSION pg_stat_statements;

-- 扩展位置
SHOW dynamic_library_path;
```

```bash
# 手动安装扩展（pgvector示例）
cd /tmp
git clone https://github.com/pgvector/pgvector.git
cd pgvector
make
sudo make install PG_CONFIG=/usr/lib/postgresql/18/bin/pg_config

# 在数据库中创建
psql -U postgres -d mydb -c "CREATE EXTENSION vector;"
```

---

## 10. 日志分析

### 10.1 常见错误

```bash
# 错误1: too many clients
sudo grep "too many clients" /var/log/postgresql/postgresql-*.log
# 解决: 增大max_connections或使用连接池

# 错误2: out of memory
sudo grep "out of memory" /var/log/postgresql/postgresql-*.log
# 解决: 增加系统内存或调整work_mem

# 错误3: could not extend file
sudo grep "could not extend" /var/log/postgresql/postgresql-*.log
# 解决: 磁盘空间不足，清理或扩容

# 错误4: checkpoint timeout
sudo grep "checkpoints are occurring too frequently" /var/log/postgresql/postgresql-*.log
# 解决: 增大max_wal_size
```

---

## 11. 故障排查工具

### 11.1 常用工具

```bash
# pg_top - 实时监控
sudo apt install ptop
pg_top -h localhost -U postgres

# pgBadger - 日志分析
pgbadger /var/log/postgresql/postgresql-*.log -o report.html

# pg_stat_statements - 查询分析
psql -U postgres -c "
SELECT query, calls, total_exec_time
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
"

# pg_activity - 活动监控
sudo pip install pg_activity
pg_activity -h localhost -U postgres
```

---

## 12. 应急处理

### 12.1 数据库崩溃

```bash
# 1. 检查日志
sudo tail -100 /var/log/postgresql/postgresql-*.log

# 2. 尝试启动
sudo systemctl start postgresql

# 3. 如果启动失败
# 检查数据目录权限
ls -la /var/lib/postgresql/18/main

# 检查pg_wal
ls -la /var/lib/postgresql/18/main/pg_wal

# 4. 恢复模式
# 创建recovery.signal，从WAL恢复

# 5. 最后手段：从备份恢复
```

### 12.2 紧急停机

```bash
# Fast shutdown（等待客户端断开）
sudo pg_ctl stop -D /var/lib/postgresql/18/main -m fast

# Immediate shutdown（立即终止连接）
sudo pg_ctl stop -D /var/lib/postgresql/18/main -m immediate

# Smart shutdown（等待所有事务完成）
sudo pg_ctl stop -D /var/lib/postgresql/18/main -m smart
```

---

## 13. 故障排查流程

```text
故障排查标准流程:

1. 确认现象
├─ 收集用户反馈
├─ 确认影响范围
└─ 记录时间点

2. 快速诊断
├─ 检查服务状态
├─ 查看监控图表
├─ 分析日志文件
└─ 检查系统资源

3. 问题定位
├─ 连接层
├─ 查询层
├─ 存储层
└─ 系统层

4. 应急处理
├─ 限流/降级
├─ 重启服务
├─ 扩容资源
└─ 切换备库

5. 根因分析
├─ 复现问题
├─ 代码审查
├─ 配置检查
└─ 容量规划

6. 预防措施
├─ 优化配置
├─ 完善监控
├─ 更新文档
└─ 应急演练
```

---

**完成**: PostgreSQL 18故障排查完整手册
**字数**: ~10,000字
**涵盖**: 连接、性能、磁盘、内存、复制、事务、应急处理
