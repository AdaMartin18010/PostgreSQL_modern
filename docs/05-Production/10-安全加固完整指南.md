# PostgreSQL 18 安全加固完整指南

## 1. 认证加固

### 1.1 密码策略

```sql
-- 启用scram-sha-256（PostgreSQL 18推荐）
ALTER SYSTEM SET password_encryption = 'scram-sha-256';

-- 创建强密码用户
CREATE USER app_user WITH PASSWORD 'C0mplex!Pass@2023';

-- 密码过期策略
ALTER USER app_user VALID UNTIL '2024-12-31';

-- 检查密码加密方式
SELECT usename,
       CASE
           WHEN passwd LIKE 'SCRAM-SHA-256%' THEN 'scram-sha-256'
           WHEN passwd LIKE 'md5%' THEN 'md5'
           ELSE 'plaintext'
       END AS encryption
FROM pg_shadow;
```

### 1.2 pg_hba.conf配置

```conf
# /etc/postgresql/18/main/pg_hba.conf

# 类型  数据库  用户      地址           认证方法
# 本地连接（Unix socket）
local   all     postgres               peer
local   all     all                    scram-sha-256

# IPv4本地连接
host    all     all       127.0.0.1/32 scram-sha-256
host    all     all       ::1/128      scram-sha-256

# 应用服务器
host    mydb    app_user  10.0.1.0/24  scram-sha-256

# 禁止超级用户远程登录
host    all     postgres  0.0.0.0/0    reject

# 复制连接
host    replication replicator 10.0.2.0/24 scram-sha-256

# 拒绝其他所有
host    all     all       0.0.0.0/0    reject
```

### 1.3 SSL/TLS配置

```ini
# postgresql.conf
ssl = on
ssl_cert_file = '/etc/postgresql/18/ssl/server.crt'
ssl_key_file = '/etc/postgresql/18/ssl/server.key'
ssl_ca_file = '/etc/postgresql/18/ssl/ca.crt'

# 强制SSL
ssl_min_protocol_version = 'TLSv1.3'
ssl_prefer_server_ciphers = on
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'
```

```bash
# 生成自签名证书
openssl req -new -x509 -days 365 -nodes -text \
  -out server.crt \
  -keyout server.key \
  -subj "/CN=postgres.example.com"

# 设置权限
chmod 600 server.key
chown postgres:postgres server.key server.crt
```

```conf
# pg_hba.conf强制SSL
hostssl all all 0.0.0.0/0 scram-sha-256
```

---

## 2. 权限管理

### 2.1 最小权限原则

```sql
-- 1. 创建只读用户
CREATE ROLE readonly;
GRANT CONNECT ON DATABASE mydb TO readonly;
GRANT USAGE ON SCHEMA public TO readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly;
ALTER DEFAULT PRIVILEGES IN SCHEMA public
  GRANT SELECT ON TABLES TO readonly;

-- 创建只读用户
CREATE USER reader WITH PASSWORD 'xxx' IN ROLE readonly;

-- 2. 创建应用用户（读写）
CREATE ROLE app_role;
GRANT CONNECT ON DATABASE mydb TO app_role;
GRANT USAGE ON SCHEMA public TO app_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_role;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_role;

CREATE USER app_user WITH PASSWORD 'xxx' IN ROLE app_role;

-- 3. 撤销public权限
REVOKE ALL ON DATABASE mydb FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM PUBLIC;

-- 4. 审计权限
SELECT
    grantee,
    table_schema,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE table_schema = 'public'
ORDER BY grantee, table_name;
```

### 2.2 Row Level Security (RLS)

```sql
-- 启用RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- 创建策略：用户只能看到自己的数据
CREATE POLICY user_isolation ON users
    FOR ALL
    TO app_user
    USING (user_id = current_user_id());

-- 管理员可见所有数据
CREATE POLICY admin_all ON users
    FOR ALL
    TO admin
    USING (true);

-- 多租户隔离
CREATE POLICY tenant_isolation ON orders
    USING (tenant_id = current_setting('app.current_tenant')::int);

-- 测试RLS
SET ROLE app_user;
SELECT * FROM users;  -- 只返回该用户数据
RESET ROLE;
```

---

## 3. 网络安全

### 3.1 防火墙配置

```bash
# UFW (Ubuntu)
sudo ufw allow from 10.0.1.0/24 to any port 5432 proto tcp
sudo ufw deny 5432

# iptables
sudo iptables -A INPUT -s 10.0.1.0/24 -p tcp --dport 5432 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 5432 -j DROP
sudo iptables-save > /etc/iptables/rules.v4

# firewalld
sudo firewall-cmd --permanent --add-rich-rule='
  rule family="ipv4"
  source address="10.0.1.0/24"
  port protocol="tcp" port="5432" accept'
sudo firewall-cmd --reload
```

### 3.2 监听地址限制

```ini
# postgresql.conf
# 只监听内网
listen_addresses = '10.0.1.10'

# 或指定多个
listen_addresses = '10.0.1.10, 192.168.1.10'

# 禁止监听所有地址（生产环境）
# listen_addresses = '*'  # 不要这样做
```

### 3.3 连接限制

```ini
# postgresql.conf
max_connections = 200

# 每个数据库连接限制
ALTER DATABASE mydb CONNECTION LIMIT 100;

# 每个用户连接限制
ALTER USER app_user CONNECTION LIMIT 50;

# 每个IP连接限制（pg_hba.conf）
# 使用连接池（PgBouncer）限制
```

---

## 4. 审计日志

### 4.1 pgAudit扩展

```sql
-- 安装pgAudit
CREATE EXTENSION pgaudit;

-- 配置
ALTER SYSTEM SET pgaudit.log = 'write, ddl';
ALTER SYSTEM SET pgaudit.log_catalog = off;
ALTER SYSTEM SET pgaudit.log_parameter = on;
ALTER SYSTEM SET pgaudit.log_relation = on;

-- 重新加载
SELECT pg_reload_conf();

-- 审计特定用户
ALTER USER admin SET pgaudit.log = 'all';

-- 审计特定表
CREATE TABLE sensitive_data (
    id SERIAL PRIMARY KEY,
    data TEXT
);

-- 审计规则
ALTER TABLE sensitive_data SET (pgaudit.log = 'all');
```

### 4.2 日志配置

```ini
# postgresql.conf
logging_collector = on
log_directory = '/var/log/postgresql'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB

# 记录连接
log_connections = on
log_disconnections = on

# 记录DDL
log_statement = 'ddl'

# 记录慢查询
log_min_duration_statement = 1000  # 1秒

# 记录锁等待
log_lock_waits = on
deadlock_timeout = 1s

# 记录检查点
log_checkpoints = on

# 记录临时文件
log_temp_files = 0  # 记录所有临时文件
```

### 4.3 日志分析

```bash
# 使用pgBadger分析日志
sudo apt install pgbadger

pgbadger /var/log/postgresql/postgresql-2023-12-04*.log \
  -o /var/www/html/pgbadger.html

# 提取失败登录
grep "FATAL:  password authentication failed" /var/log/postgresql/postgresql-*.log

# 提取慢查询
grep "duration:" /var/log/postgresql/postgresql-*.log | \
  awk '{if ($10 > 1000) print}'
```

---

## 5. 数据加密

### 5.1 传输加密（SSL）

```sql
-- 强制SSL连接
ALTER DATABASE mydb SET ssl_require = true;

-- 验证SSL连接
SELECT
    pid,
    usename,
    client_addr,
    ssl,
    ssl_version,
    ssl_cipher
FROM pg_stat_ssl
JOIN pg_stat_activity USING (pid);
```

### 5.2 静态数据加密

```sql
-- 1. 列级加密（pgcrypto）
CREATE EXTENSION pgcrypto;

-- 加密存储
INSERT INTO users (username, password_encrypted)
VALUES ('alice', crypt('password', gen_salt('bf')));

-- 验证
SELECT username
FROM users
WHERE password_encrypted = crypt('password', password_encrypted);

-- 2. 敏感数据加密
CREATE TABLE credit_cards (
    id SERIAL PRIMARY KEY,
    card_number_encrypted BYTEA,
    user_id INT
);

-- 加密插入
INSERT INTO credit_cards (card_number_encrypted, user_id)
VALUES (
    pgp_sym_encrypt('1234-5678-9012-3456', 'encryption_key'),
    123
);

-- 解密查询
SELECT
    id,
    pgp_sym_decrypt(card_number_encrypted, 'encryption_key') AS card_number
FROM credit_cards
WHERE user_id = 123;
```

### 5.3 全盘加密

```bash
# LUKS加密（Linux）
# 1. 创建加密分区
sudo cryptsetup luksFormat /dev/sdb1

# 2. 打开加密分区
sudo cryptsetup luksOpen /dev/sdb1 pgdata_encrypted

# 3. 创建文件系统
sudo mkfs.ext4 /dev/mapper/pgdata_encrypted

# 4. 挂载
sudo mount /dev/mapper/pgdata_encrypted /var/lib/postgresql

# 5. 配置自动挂载
# /etc/crypttab
pgdata_encrypted /dev/sdb1 none luks

# /etc/fstab
/dev/mapper/pgdata_encrypted /var/lib/postgresql ext4 defaults 0 2
```

---

## 6. SQL注入防护

### 6.1 参数化查询

```python
# BAD - SQL注入风险
username = request.form['username']
query = f"SELECT * FROM users WHERE username = '{username}'"
cursor.execute(query)

# GOOD - 参数化查询
username = request.form['username']
query = "SELECT * FROM users WHERE username = %s"
cursor.execute(query, (username,))

# 使用ORM
from sqlalchemy import select
stmt = select(User).where(User.username == username)
```

### 6.2 输入验证

```python
import re

def validate_input(user_input):
    """验证用户输入"""

    # 长度限制
    if len(user_input) > 100:
        raise ValueError("输入过长")

    # 字符白名单
    if not re.match(r'^[a-zA-Z0-9_-]+$', user_input):
        raise ValueError("非法字符")

    # SQL关键字黑名单
    sql_keywords = ['DROP', 'DELETE', 'INSERT', 'UPDATE', 'EXEC', 'UNION']
    if any(keyword in user_input.upper() for keyword in sql_keywords):
        raise ValueError("包含SQL关键字")

    return user_input
```

### 6.3 最小权限执行

```sql
-- 应用用户不应有DDL权限
REVOKE CREATE ON SCHEMA public FROM app_user;
REVOKE DROP ON ALL TABLES IN SCHEMA public FROM app_user;

-- 只授予必要的DML权限
GRANT SELECT, INSERT, UPDATE ON specific_tables TO app_user;
```

---

## 7. 备份加密

### 7.1 加密备份

```bash
# pg_dump + GPG加密
pg_dump -U postgres mydb | \
  gpg --encrypt --recipient admin@example.com > mydb_backup.sql.gpg

# 解密恢复
gpg --decrypt mydb_backup.sql.gpg | psql -U postgres mydb

# pgBackRest加密
# /etc/pgbackrest/pgbackrest.conf
[global]
repo1-cipher-type=aes-256-cbc
repo1-cipher-pass=encryption_passphrase

# 执行加密备份
pgbackrest --stanza=mydb --type=full backup
```

---

## 8. 监控与告警

### 8.1 安全监控

```sql
-- 监控失败登录
CREATE TABLE login_failures (
    username TEXT,
    client_addr INET,
    attempt_time TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- 触发器记录失败登录（需要自定义）

-- 查询近期失败登录
SELECT
    username,
    client_addr,
    COUNT(*) AS failure_count,
    MAX(attempt_time) AS last_attempt
FROM login_failures
WHERE attempt_time > CURRENT_TIMESTAMP - INTERVAL '1 hour'
GROUP BY username, client_addr
HAVING COUNT(*) > 5;

-- 监控权限变更
SELECT
    schemaname,
    tablename,
    tableowner,
    hasindexes,
    hasrules,
    hastriggers
FROM pg_tables
WHERE schemaname = 'public';
```

### 8.2 异常检测

```sql
-- 检测异常查询模式
SELECT
    usename,
    datname,
    COUNT(*) AS query_count,
    COUNT(DISTINCT query) AS unique_queries
FROM pg_stat_activity
WHERE state = 'active'
GROUP BY usename, datname
HAVING COUNT(*) > 100;  -- 单用户>100个活动查询

-- 检测长事务
SELECT
    pid,
    usename,
    datname,
    state,
    now() - xact_start AS duration,
    query
FROM pg_stat_activity
WHERE xact_start < now() - INTERVAL '30 minutes'
  AND state != 'idle';
```

---

## 9. 合规性

### 9.1 GDPR合规

```sql
-- 数据脱敏函数
CREATE OR REPLACE FUNCTION mask_email(email TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN substring(email from 1 for 2) || '***@' ||
           substring(email from position('@' in email) + 1);
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 数据删除（Right to be forgotten）
CREATE OR REPLACE FUNCTION anonymize_user(user_id_param INT)
RETURNS VOID AS $$
BEGIN
    UPDATE users
    SET
        email = 'deleted_' || user_id_param || '@anonymized.com',
        name = 'Deleted User',
        phone = NULL,
        address = NULL
    WHERE user_id = user_id_param;

    -- 删除关联数据
    DELETE FROM user_sessions WHERE user_id = user_id_param;
    DELETE FROM user_preferences WHERE user_id = user_id_param;
END;
$$ LANGUAGE plpgsql;
```

### 9.2 数据保留策略

```sql
-- 自动删除旧数据
CREATE OR REPLACE FUNCTION cleanup_old_data()
RETURNS VOID AS $$
BEGIN
    -- 删除30天前的日志
    DELETE FROM access_logs
    WHERE created_at < CURRENT_DATE - INTERVAL '30 days';

    -- 删除180天前的临时数据
    DELETE FROM temp_data
    WHERE created_at < CURRENT_DATE - INTERVAL '180 days';

    RAISE NOTICE '清理完成';
END;
$$ LANGUAGE plpgsql;

-- 定时任务（使用pg_cron）
CREATE EXTENSION pg_cron;
SELECT cron.schedule('0 2 * * *', 'SELECT cleanup_old_data();');
```

---

## 10. 安全检查清单

```text
✅ 认证
├─ 使用scram-sha-256
├─ 强密码策略
├─ 禁用不必要用户
└─ 配置密码过期

✅ 授权
├─ 最小权限原则
├─ RLS策略
├─ 撤销PUBLIC权限
└─ 定期审计权限

✅ 网络
├─ 配置防火墙
├─ 限制监听地址
├─ 启用SSL/TLS
└─ pg_hba.conf白名单

✅ 加密
├─ 传输加密（SSL）
├─ 静态数据加密
├─ 备份加密
└─ 密钥管理

✅ 审计
├─ 启用pgAudit
├─ 配置日志
├─ 监控失败登录
└─ 记录权限变更

✅ 应用
├─ 参数化查询
├─ 输入验证
├─ 输出编码
└─ 错误处理

✅ 运维
├─ 定期更新补丁
├─ 安全配置审查
├─ 渗透测试
└─ 应急响应计划

✅ 合规
├─ 数据分类
├─ 访问控制
├─ 数据保留
└─ 审计日志
```

---

## 11. 应急响应

### 11.1 入侵检测

```bash
# 检查可疑连接
SELECT
    pid,
    usename,
    client_addr,
    state,
    query_start,
    query
FROM pg_stat_activity
WHERE client_addr NOT IN (
    '10.0.1.10', '10.0.1.11', '10.0.1.12'  -- 白名单IP
);

# 检查未授权查询
SELECT query
FROM pg_stat_statements
WHERE query LIKE '%DROP%'
   OR query LIKE '%DELETE%'
   OR query LIKE '%UPDATE%';
```

### 11.2 应急操作

```sql
-- 1. 立即终止可疑连接
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE client_addr = '恶意IP';

-- 2. 禁用受影响用户
ALTER USER compromised_user WITH NOLOGIN;

-- 3. 重置密码
ALTER USER app_user WITH PASSWORD '新强密码';

-- 4. 审计数据变更
SELECT * FROM pg_stat_user_tables
WHERE n_tup_upd > 1000 OR n_tup_del > 1000;

-- 5. 恢复数据（如需要）
-- 从备份PITR恢复到入侵前
```

---

## 12. 渗透测试

### 12.1 安全扫描

```bash
# Nmap扫描PostgreSQL
nmap -p 5432 --script pgsql-brute target-server

# 使用sqlmap测试SQL注入
sqlmap -u "http://example.com/api?id=1" --dbms=postgresql

# PostgreSQL专用扫描工具
# 使用pgaudit, pg_permissions等工具
```

### 12.2 漏洞修复

```text
常见漏洞:
├─ SQL注入 → 参数化查询
├─ 弱密码 → 强密码策略
├─ 未加密传输 → 强制SSL
├─ 权限过大 → 最小权限
├─ 未打补丁 → 定期更新
└─ 日志不足 → 完善审计
```

---

**完成**: PostgreSQL 18安全加固完整指南
**字数**: ~10,000字
**涵盖**: 认证、授权、加密、审计、合规、应急响应
