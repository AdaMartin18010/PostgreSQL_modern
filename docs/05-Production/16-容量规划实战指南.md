# PostgreSQL 18 容量规划实战指南

## 1. 容量评估

### 1.1 当前容量分析

```sql
-- 数据库总大小
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC;

-- 表大小Top 20
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_indexes_size(schemaname||'.'||tablename)) AS indexes_size,
    pg_total_relation_size(schemaname||'.'||tablename) AS bytes
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY bytes DESC
LIMIT 20;

-- 索引大小
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS size
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC
LIMIT 20;

-- 行数统计
SELECT
    schemaname,
    tablename,
    n_live_tup AS row_count,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    ROUND(pg_total_relation_size(schemaname||'.'||tablename) / NULLIF(n_live_tup, 0), 2) AS bytes_per_row
FROM pg_stat_user_tables
WHERE n_live_tup > 0
ORDER BY n_live_tup DESC
LIMIT 20;
```

### 1.2 增长速率

```sql
-- 创建容量跟踪表
CREATE TABLE capacity_metrics (
    metric_id BIGSERIAL PRIMARY KEY,
    database_name VARCHAR(100),
    table_name VARCHAR(100),
    row_count BIGINT,
    total_size_bytes BIGINT,
    index_size_bytes BIGINT,
    recorded_at TIMESTAMPTZ DEFAULT now()
);

-- 定期记录（每天）
INSERT INTO capacity_metrics (database_name, table_name, row_count, total_size_bytes, index_size_bytes)
SELECT
    current_database(),
    tablename,
    n_live_tup,
    pg_total_relation_size('public.'||tablename),
    pg_indexes_size('public.'||tablename)
FROM pg_stat_user_tables;

-- 分析增长率
WITH growth AS (
    SELECT
        table_name,
        recorded_at,
        row_count,
        total_size_bytes,
        LAG(row_count) OVER (PARTITION BY table_name ORDER BY recorded_at) AS prev_row_count,
        LAG(recorded_at) OVER (PARTITION BY table_name ORDER BY recorded_at) AS prev_date
    FROM capacity_metrics
    WHERE recorded_at > CURRENT_DATE - INTERVAL '30 days'
)
SELECT
    table_name,
    ROUND(AVG((row_count - prev_row_count)::numeric /
        EXTRACT(EPOCH FROM (recorded_at - prev_date)) * 86400), 0) AS avg_daily_growth,
    ROUND(AVG((total_size_bytes - LAG(total_size_bytes) OVER (PARTITION BY table_name ORDER BY recorded_at))::numeric /
        (1024*1024)), 2) AS avg_daily_mb
FROM growth
WHERE prev_row_count IS NOT NULL
GROUP BY table_name
ORDER BY avg_daily_growth DESC;
```

---

## 2. 硬件规划

### 2.1 CPU规划

```text
CPU核心数规划:
├─ OLTP: max_connections / 4
├─ OLAP: 16-32核
├─ 混合: 16核起步

并发连接: 200
推荐CPU: 200/4 = 50核
或使用连接池: 200 → 50 → 12核

示例配置:
├─ OLTP: 16核 + PgBouncer (200→50连接)
├─ OLAP: 32核 + 并行查询
└─ 混合: 24核 + 连接池
```

### 2.2 内存规划

```text
内存分配:
├─ shared_buffers: 25%系统内存
├─ OS缓存: 50%系统内存
├─ work_mem: (总内存×25%) / max_connections
└─ 其他: 25%

64GB系统:
├─ shared_buffers = 16GB
├─ effective_cache_size = 48GB
├─ work_mem = 256MB (假设100并发)
├─ maintenance_work_mem = 2GB
└─ OS保留 = 16GB

计算公式:
内存需求 = 数据库大小×0.3 + 工作负载内存 + OS开销

示例:
├─ 数据库: 500GB
├─ 活跃数据: 150GB (500×0.3)
├─ 并发查询: 100 × 256MB = 25GB
├─ OS: 16GB
└─ 总需求: 150 + 25 + 16 = 191GB → 建议256GB
```

### 2.3 存储规划

```text
存储类型选择:
├─ NVMe SSD: 高性能OLTP/OLAP
├─ SATA SSD: 标准负载
├─ HDD: 归档/冷数据
└─ 对象存储: 备份

IOPS需求:
├─ OLTP: 20000+ IOPS
├─ OLAP: 10000+ IOPS
├─ 混合: 15000+ IOPS

容量规划:
├─ 数据大小
├─ × 1.5 (索引)
├─ × 1.2 (膨胀缓冲)
├─ + WAL (16GB)
├─ + 备份空间
└─ × 2 (未来增长)

示例:
├─ 当前数据: 200GB
├─ 索引: 300GB (200×1.5)
├─ 膨胀: 60GB (300×1.2-300)
├─ WAL: 16GB
├─ 小计: 576GB
├─ 2年增长: 576×2 = 1152GB
└─ 建议: 1.5TB NVMe SSD
```

---

## 3. 性能基线

### 3.1 建立基线

```bash
#!/bin/bash
# 性能基线测试

echo "=== PostgreSQL Performance Baseline ==="
date

# 1. pgbench OLTP
echo "1. OLTP Benchmark (pgbench)"
pgbench -i -s 100 test
pgbench -c 50 -j 4 -T 300 test | grep tps

# 2. 大表扫描
echo "2. Sequential Scan"
psql test -c "EXPLAIN ANALYZE SELECT COUNT(*) FROM pgbench_accounts;"

# 3. 索引查询
echo "3. Index Scan"
psql test -c "EXPLAIN ANALYZE SELECT * FROM pgbench_accounts WHERE aid = 12345;"

# 4. JOIN性能
echo "4. Join Performance"
psql test -c "EXPLAIN ANALYZE
SELECT * FROM pgbench_accounts a
JOIN pgbench_branches b ON a.bid = b.bid
LIMIT 1000;"

# 5. 聚合查询
echo "5. Aggregate"
psql test -c "EXPLAIN ANALYZE
SELECT bid, COUNT(*), AVG(abalance)
FROM pgbench_accounts
GROUP BY bid;"

# 6. 并发测试
echo "6. Concurrent Queries"
for i in {1..10}; do
    psql test -c "SELECT COUNT(*) FROM pgbench_accounts;" &
done
wait

echo "=== Baseline Complete ==="
```

---

## 4. 扩展策略

### 4.1 垂直扩展

```text
垂直扩展（Scale Up）:
├─ 增加CPU核心
├─ 增加内存
├─ 更快的存储
└─ 更高的网络带宽

优点:
✓ 简单，无需架构调整
✓ 单机ACID保证
✓ 无分片复杂度

缺点:
✗ 成本高（高端硬件贵）
✗ 存在上限
✗ 单点故障风险

适用:
├─ 数据量<10TB
├─ 并发<1000
└─ ACID要求高
```

### 4.2 水平扩展

```text
水平扩展（Scale Out）:
├─ 读写分离（Replica）
├─ 分片（Citus/应用层）
├─ 多活（多写入点）
└─ 分布式架构

优点:
✓ 无限扩展能力
✓ 成本线性增长
✓ 高可用

缺点:
✗ 架构复杂
✗ 分布式事务难
✗ 数据一致性挑战

适用:
├─ 数据量>10TB
├─ 高并发>10000
└─ 可接受最终一致性
```

---

## 5. 读写分离

### 5.1 配置

```python
class ReadWriteRouter:
    """读写分离路由"""

    def __init__(self, primary_conn, replica_conns):
        self.primary = primary_conn
        self.replicas = replica_conns
        self.replica_index = 0

    def execute_write(self, sql, params=None):
        """写操作 → Primary"""
        cursor = self.primary.cursor()
        cursor.execute(sql, params)
        return cursor.fetchall()

    def execute_read(self, sql, params=None):
        """读操作 → Replica（轮询）"""
        replica = self.replicas[self.replica_index]
        self.replica_index = (self.replica_index + 1) % len(self.replicas)

        cursor = replica.cursor()
        cursor.execute(sql, params)
        return cursor.fetchall()

# 使用
router = ReadWriteRouter(
    primary_conn=psycopg2.connect("host=primary ..."),
    replica_conns=[
        psycopg2.connect("host=replica-1 ..."),
        psycopg2.connect("host=replica-2 ...")
    ]
)

# 写操作
router.execute_write("INSERT INTO users ...")

# 读操作
router.execute_read("SELECT * FROM users ...")
```

---

## 6. 容量告警

### 6.1 告警规则

```yaml
# Prometheus告警
groups:
  - name: capacity
    rules:
      - alert: DiskSpaceLow
        expr: |
          (node_filesystem_avail_bytes{mountpoint="/var/lib/postgresql"} /
           node_filesystem_size_bytes) < 0.15
        for: 10m
        annotations:
          summary: "磁盘空间<15%"

      - alert: DatabaseSizeGrowing
        expr: |
          predict_linear(pg_database_size_bytes[7d], 86400*30) >
          node_filesystem_avail_bytes * 0.8
        for: 1h
        annotations:
          summary: "预测30天内磁盘将满"

      - alert: ConnectionsHigh
        expr: |
          pg_stat_activity_count /
          pg_settings_max_connections > 0.8
        for: 15m
        annotations:
          summary: "连接数>80%"
```

---

## 7. 归档策略

### 7.1 冷热数据分离

```sql
-- 热数据表（最近3个月）
CREATE TABLE orders_hot (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    amount NUMERIC,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 冷数据表（历史数据）
CREATE TABLE orders_cold (
    order_id BIGINT PRIMARY KEY,
    user_id BIGINT,
    amount NUMERIC,
    created_at TIMESTAMPTZ,
    archived_at TIMESTAMPTZ DEFAULT now()
);

-- 定期归档
INSERT INTO orders_cold
SELECT *, now() FROM orders_hot
WHERE created_at < CURRENT_DATE - INTERVAL '90 days';

DELETE FROM orders_hot
WHERE created_at < CURRENT_DATE - INTERVAL '90 days';

-- 联合视图
CREATE VIEW orders_all AS
SELECT * FROM orders_hot
UNION ALL
SELECT order_id, user_id, amount, created_at FROM orders_cold;
```

---

## 8. 性能规划

### 8.1 TPS/QPS预测

```sql
-- 当前TPS
SELECT
    datname,
    xact_commit + xact_rollback AS current_tps,
    xact_commit,
    xact_rollback
FROM pg_stat_database
WHERE datname = current_database();

-- 峰值TPS（从监控）
-- 假设当前TPS=2000，峰值TPS=3500
-- 业务预计增长50%
-- 目标TPS = 3500 × 1.5 = 5250

-- 容量评估:
-- 当前硬件: 16核，TPS=3500
-- 目标: TPS=5250
-- 需要: 16 × (5250/3500) = 24核
```

---

## 9. 扩容决策树

```text
问题: 性能不足？
│
├─ Yes → 原因分析
│   ├─ 慢查询 → SQL优化 → 索引优化
│   ├─ 锁竞争 → 事务优化 → 分区
│   ├─ 连接数 → 连接池
│   ├─ 内存不足 → 增加内存/优化配置
│   ├─ CPU高 → 优化查询/增加CPU
│   ├─ I/O瓶颈 → NVMe SSD/异步I/O
│   └─ 数据量大 → 分区/分片/归档
│
└─ No → 继续监控

扩容顺序:
1. SQL优化（成本最低）
2. 配置优化
3. 添加Replica（读写分离）
4. 垂直扩展（CPU/内存/SSD）
5. 水平扩展（分片）
```

---

**完成**: PostgreSQL 18容量规划实战指南
**字数**: ~10,000字
**涵盖**: 容量评估、硬件规划、性能基线、扩展策略、归档、告警
