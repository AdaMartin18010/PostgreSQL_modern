# PostgreSQL 18 备份恢复完整实战

## 1. 备份策略

### 1.1 备份类型

```text
备份方式对比:
┌────────────┬──────────┬──────────┬─────────┬─────────┐
│ 类型        │ 数据完整 │ 恢复时间  │ 存储空间 │ 适用场景│
├────────────┼──────────┼──────────┼─────────┼─────────┤
│ 逻辑备份    │ 是       │ 慢       │ 小      │ 小库    │
│ 物理备份    │ 是       │ 快       │ 大      │ 大库    │
│ WAL归档     │ 增量     │ 快       │ 中      │ PITR    │
│ 快照        │ 是       │ 极快     │ 中      │ 云环境  │
└────────────┴──────────┴──────────┴─────────┴─────────┘
```

### 1.2 3-2-1原则

```text
3份备份副本
2种不同存储介质
1份异地备份

示例:
├─ 本地磁盘: pgBackRest（主备份）
├─ 对象存储: S3/MinIO（冷备份）
└─ 异地机房: 定期同步
```

---

## 2. pg_dump逻辑备份

### 2.1 基础备份

```bash
# 完整数据库备份
pg_dump -h localhost -U postgres -d mydb -F c -f mydb_backup.dump

# 参数说明
# -F c: custom格式（推荐，支持并行恢复）
# -F p: plain格式（纯SQL）
# -F t: tar格式
# -F d: directory格式（支持并行）

# 所有数据库
pg_dumpall -h localhost -U postgres -f all_databases.sql

# 只导出schema
pg_dump -h localhost -U postgres -d mydb -s -f schema.sql

# 只导出数据
pg_dump -h localhost -U postgres -d mydb -a -f data.sql

# 指定表
pg_dump -h localhost -U postgres -d mydb -t users -t orders -f tables.dump

# 排除表
pg_dump -h localhost -U postgres -d mydb -T logs -F c -f mydb_no_logs.dump
```

### 2.2 并行备份

```bash
# 并行导出（directory格式）
pg_dump -h localhost -U postgres -d mydb \
  -F d -j 8 -f mydb_backup_dir

# -j 8: 使用8个并行job

# 压缩备份
pg_dump -h localhost -U postgres -d mydb -F c -Z 9 -f mydb_backup.dump.gz
# -Z 9: 最高压缩级别
```

### 2.3 恢复

```bash
# 从custom格式恢复
pg_restore -h localhost -U postgres -d newdb -F c mydb_backup.dump

# 并行恢复
pg_restore -h localhost -U postgres -d newdb -j 8 -F d mydb_backup_dir

# 只恢复特定表
pg_restore -h localhost -U postgres -d newdb -t users mydb_backup.dump

# 只恢复schema
pg_restore -h localhost -U postgres -d newdb -s mydb_backup.dump

# 清空现有数据
pg_restore -h localhost -U postgres -d newdb -c mydb_backup.dump

# 从plain格式恢复
psql -h localhost -U postgres -d newdb -f mydb_backup.sql
```

---

## 3. pg_basebackup物理备份

### 3.1 基础物理备份

```bash
# 完整物理备份
pg_basebackup -h localhost -U replication \
  -D /backup/base/$(date +%Y%m%d) \
  -Fp -Xs -P

# 参数说明
# -D: 目标目录
# -Fp: plain格式
# -Ft: tar格式
# -Xs: 包含WAL（stream）
# -Xf: 包含WAL（fetch）
# -P: 显示进度

# tar格式备份
pg_basebackup -h localhost -U replication \
  -D /backup/base -Ft -z -P

# 指定表空间映射
pg_basebackup -h localhost -U replication \
  -D /backup/base \
  -T /old_tablespace=/new_tablespace \
  -Fp -Xs -P
```

### 3.2 恢复流程

```bash
# 1. 停止PostgreSQL
sudo systemctl stop postgresql

# 2. 清空数据目录
sudo rm -rf /var/lib/postgresql/18/main/*

# 3. 恢复备份
sudo -u postgres cp -a /backup/base/20231204/* /var/lib/postgresql/18/main/

# 4. 创建recovery信号文件（PITR）
sudo -u postgres touch /var/lib/postgresql/18/main/recovery.signal

# 5. 配置recovery
sudo -u postgres tee /var/lib/postgresql/18/main/postgresql.auto.conf <<EOF
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2023-12-04 12:00:00'
EOF

# 6. 启动PostgreSQL
sudo systemctl start postgresql

# 7. 验证恢复
psql -U postgres -c "SELECT pg_is_in_recovery();"
```

---

## 4. pgBackRest（推荐）

### 4.1 安装配置

```bash
# 安装
sudo apt install pgbackrest

# 配置 /etc/pgbackrest/pgbackrest.conf
[global]
repo1-path=/var/lib/pgbackrest
repo1-retention-full=2
repo1-retention-diff=7
repo1-retention-full-type=count

[mydb]
pg1-path=/var/lib/postgresql/18/main
pg1-port=5432
pg1-socket-path=/var/run/postgresql

# PostgreSQL配置
archive_mode = on
archive_command = 'pgbackrest --stanza=mydb archive-push %p'
```

### 4.2 创建备份

```bash
# 创建stanza
sudo -u postgres pgbackrest --stanza=mydb stanza-create

# 验证配置
sudo -u postgres pgbackrest --stanza=mydb check

# 完整备份
sudo -u postgres pgbackrest --stanza=mydb --type=full backup

# 差异备份
sudo -u postgres pgbackrest --stanza=mydb --type=diff backup

# 增量备份
sudo -u postgres pgbackrest --stanza=mydb --type=incr backup

# 查看备份
sudo -u postgres pgbackrest --stanza=mydb info
```

### 4.3 恢复

```bash
# 停止PostgreSQL
sudo systemctl stop postgresql

# 恢复最新备份
sudo -u postgres pgbackrest --stanza=mydb --delta restore

# PITR恢复
sudo -u postgres pgbackrest --stanza=mydb \
  --type=time \
  --target="2023-12-04 12:00:00" \
  --delta restore

# 启动PostgreSQL
sudo systemctl start postgresql
```

---

## 5. WAL归档

### 5.1 配置WAL归档

```ini
# postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /backup/wal/%f && cp %p /backup/wal/%f'
archive_timeout = 300  # 5分钟

# WAL压缩
wal_compression = on

# WAL大小
max_wal_size = 4GB
min_wal_size = 1GB
```

### 5.2 归档到S3

```bash
# 使用wal-g
# 安装
wget https://github.com/wal-g/wal-g/releases/download/v2.0.1/wal-g-pg-ubuntu-20.04-amd64.tar.gz
tar -zxvf wal-g-pg-ubuntu-20.04-amd64.tar.gz
sudo mv wal-g-pg-ubuntu-20.04-amd64 /usr/local/bin/wal-g

# 配置环境变量
export AWS_ACCESS_KEY_ID=your_key
export AWS_SECRET_ACCESS_KEY=your_secret
export AWS_REGION=us-east-1
export WALG_S3_PREFIX=s3://my-backups/pg

# PostgreSQL配置
archive_command = 'wal-g wal-push %p'
restore_command = 'wal-g wal-fetch %f %p'

# 完整备份到S3
wal-g backup-push /var/lib/postgresql/18/main

# 查看备份
wal-g backup-list

# 恢复
wal-g backup-fetch /var/lib/postgresql/18/main LATEST
```

---

## 6. PITR（时间点恢复）

### 6.1 配置PITR

```bash
# 1. 准备基础备份
pg_basebackup -h localhost -U replication -D /backup/base -Fp -Xs -P

# 2. 持续归档WAL
# postgresql.conf已配置archive_command

# 3. 模拟数据丢失
psql -U postgres -d mydb -c "DROP TABLE important_table;"

# 4. 恢复到删除前
sudo systemctl stop postgresql
sudo rm -rf /var/lib/postgresql/18/main/*
sudo cp -a /backup/base/* /var/lib/postgresql/18/main/

# 5. 配置recovery
sudo -u postgres tee /var/lib/postgresql/18/main/postgresql.auto.conf <<EOF
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2023-12-04 11:59:00'  # 删除前1分钟
recovery_target_action = 'promote'
EOF

# 6. 创建recovery信号
sudo -u postgres touch /var/lib/postgresql/18/main/recovery.signal

# 7. 启动并验证
sudo systemctl start postgresql
psql -U postgres -d mydb -c "\dt important_table"
```

### 6.2 其他恢复目标

```ini
# 恢复到特定事务
recovery_target_xid = '123456'

# 恢复到特定LSN
recovery_target_lsn = '0/12345678'

# 恢复到特定命名点
recovery_target_name = 'before_update'

# 立即恢复（最近一致点）
recovery_target = 'immediate'

# 恢复到最新
# 不设置recovery_target
```

---

## 7. 流复制备份

### 7.1 配置

```ini
# Primary配置
listen_addresses = '*'
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
wal_keep_size = 1GB

# pg_hba.conf
host replication replicator 192.168.1.0/24 scram-sha-256
```

### 7.2 从Standby备份

```bash
# Standby可以直接备份，不影响Primary
pg_basebackup -h standby-server -U replication -D /backup -Fp -Xs -P

# 或使用pgBackRest
pgbackrest --stanza=mydb --type=full --backup-standby backup
```

---

## 8. 快照备份（云环境）

### 8.1 AWS EBS快照

```bash
# 创建快照前冻结I/O
psql -U postgres -c "SELECT pg_start_backup('snapshot', false, false);"

# 创建EBS快照
aws ec2 create-snapshot \
  --volume-id vol-1234567890abcdef0 \
  --description "PostgreSQL backup $(date +%Y%m%d)"

# 解冻
psql -U postgres -c "SELECT pg_stop_backup();"
```

### 8.2 ZFS快照

```bash
# 创建快照
sudo zfs snapshot tank/postgres@backup_$(date +%Y%m%d_%H%M%S)

# 查看快照
sudo zfs list -t snapshot

# 恢复快照
sudo systemctl stop postgresql
sudo zfs rollback tank/postgres@backup_20231204_120000
sudo systemctl start postgresql

# 删除快照
sudo zfs destroy tank/postgres@backup_20231204_120000
```

---

## 9. 备份验证

### 9.1 验证完整性

```bash
# 验证备份文件
pg_restore -l mydb_backup.dump | head -20

# 测试恢复到临时数据库
createdb test_restore
pg_restore -d test_restore mydb_backup.dump

# 数据一致性检查
psql -d test_restore -c "SELECT COUNT(*) FROM users;"
psql -d mydb -c "SELECT COUNT(*) FROM users;"

# 清理
dropdb test_restore
```

### 9.2 定期恢复演练

```bash
#!/bin/bash
# restore_test.sh - 每周自动恢复测试

# 1. 获取最新备份
LATEST_BACKUP=$(pgbackrest --stanza=mydb --output=json info | jq -r '.[0].backup[-1].label')

# 2. 恢复到测试实例
pgbackrest --stanza=mydb --set=$LATEST_BACKUP \
  --pg1-path=/var/lib/postgresql/test \
  --delta restore

# 3. 启动测试实例
pg_ctl -D /var/lib/postgresql/test start

# 4. 验证数据
psql -h localhost -p 5433 -U postgres -d mydb -c "
SELECT COUNT(*) AS total_users FROM users;
SELECT COUNT(*) AS total_orders FROM orders;
"

# 5. 停止并清理
pg_ctl -D /var/lib/postgresql/test stop
rm -rf /var/lib/postgresql/test

# 6. 发送报告
mail -s "Backup Restore Test - $(date)" admin@example.com < /tmp/restore_test.log
```

---

## 10. 生产备份方案

### 10.1 完整方案

```text
备份策略:
├─ 每日全量备份 (pgBackRest)
│  ├─ 时间: 凌晨2点
│  ├─ 保留: 30天
│  └─ 存储: 本地SSD

├─ 每小时差异备份
│  ├─ 保留: 7天
│  └─ 存储: 本地SSD

├─ 实时WAL归档
│  ├─ 归档到: S3
│  └─ 保留: 90天

├─ 每周异地同步
│  ├─ 目标: 异地机房
│  └─ 方式: rsync

└─ 每月冷备份
   ├─ 介质: 磁带/对象存储
   └─ 保留: 1年
```

### 10.2 自动化脚本

```bash
#!/bin/bash
# daily_backup.sh

DATE=$(date +%Y%m%d)
LOG="/var/log/pgbackup_${DATE}.log"

{
    echo "=== Backup Started: $(date) ==="

    # 1. pgBackRest完整备份
    pgbackrest --stanza=mydb --type=full backup

    # 2. 验证备份
    pgbackrest --stanza=mydb check

    # 3. 同步到S3
    aws s3 sync /var/lib/pgbackrest s3://pg-backups/$(hostname)/ \
        --exclude "*.tmp" \
        --storage-class STANDARD_IA

    # 4. 清理旧备份
    pgbackrest --stanza=mydb expire

    # 5. 生成备份报告
    pgbackrest --stanza=mydb info

    echo "=== Backup Completed: $(date) ==="

} 2>&1 | tee $LOG

# 发送通知
if [ $? -eq 0 ]; then
    mail -s "Backup Success - $(date)" admin@example.com < $LOG
else
    mail -s "Backup FAILED - $(date)" admin@example.com < $LOG
fi
```

---

## 11. 故障恢复场景

### 11.1 误删除表

```sql
-- 场景: 误删除users表
DROP TABLE users;  -- 错误操作！

-- 恢复方案1: PITR
-- 恢复到删除前1分钟

-- 恢复方案2: 从备份恢复单表
pg_restore -h localhost -U postgres -d tempdb -t users latest_backup.dump
pg_dump -h localhost -U postgres -d tempdb -t users | psql -d mydb
```

### 11.2 数据损坏

```bash
# 检测数据损坏
psql -U postgres -c "SELECT * FROM pg_database_check();"

# 使用pg_checksums验证
sudo -u postgres pg_checksums -D /var/lib/postgresql/18/main --check

# 恢复方案: 从最近备份恢复
```

### 11.3 整库故障

```bash
# 完整恢复流程
# 1. 评估损坏程度
# 2. 选择恢复点
# 3. 执行PITR
# 4. 验证数据完整性
# 5. 切换应用连接
```

---

## 12. 监控告警

### 12.1 备份监控

```sql
-- 监控归档延迟
SELECT
    CASE
        WHEN pg_is_in_recovery() THEN 'Standby'
        ELSE 'Primary'
    END AS role,
    pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::bigint / 1024 / 1024 AS wal_generated_mb,
    count(*) AS wal_files
FROM pg_ls_waldir()
WHERE name ~ '^[0-9A-F]{24}$';

-- 监控备份状态（pgBackRest）
-- 使用pgbackrest info --output=json
```

### 12.2 告警规则

```yaml
# Prometheus alerts
groups:
  - name: backup
    rules:
      - alert: BackupFailed
        expr: pgbackrest_backup_error_count > 0
        for: 5m
        annotations:
          summary: "备份失败"

      - alert: BackupTooOld
        expr: time() - pgbackrest_last_full_backup_timestamp > 86400
        for: 1h
        annotations:
          summary: "超过24小时未进行全量备份"

      - alert: WALArchiveLag
        expr: pg_stat_archiver_failed_count > 0
        for: 5m
        annotations:
          summary: "WAL归档失败"
```

---

**完成**: PostgreSQL 18备份恢复完整实战
**字数**: ~10,000字
**涵盖**: 逻辑备份、物理备份、PITR、自动化、监控
