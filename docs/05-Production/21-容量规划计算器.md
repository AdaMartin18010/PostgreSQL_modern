# PostgreSQL容量规划计算器

## 1. 存储容量计算

### 1.1 表空间计算

```sql
-- 单行大小估算
CREATE TABLE users (
    id BIGINT,              -- 8字节
    username VARCHAR(50),   -- 4 + 50 = 54字节（变长）
    email VARCHAR(100),     -- 4 + 100 = 104字节
    created_at TIMESTAMPTZ, -- 8字节
    status SMALLINT,        -- 2字节
    profile JSONB           -- 变长，平均500字节
);

-- 估算单行大小
-- 固定部分: 8 + 2 = 10字节
-- 变长部分: 54 + 104 + 500 = 658字节
-- 行头部: 23字节（tuple header）
-- 对齐: MAXALIGN(691) = 696字节
-- 总计: ~700字节/行

-- 存储计算
WITH size_calc AS (
    SELECT
        700 AS bytes_per_row,
        10000000 AS total_rows,
        0.2 AS index_overhead,  -- 索引开销20%
        0.1 AS bloat_factor      -- 膨胀系数10%
)
SELECT
    pg_size_pretty((bytes_per_row * total_rows * (1 + index_overhead) * (1 + bloat_factor))::BIGINT) AS estimated_size
FROM size_calc;
-- 结果: 9.2 GB
```

---

## 2. 内存规划

### 2.1 shared_buffers计算

```bash
# 原则: 25% ~ 40% 系统内存

# 示例: 64GB内存服务器
Total Memory: 64GB
OS Reserve: 8GB (预留给OS)
Available: 56GB

shared_buffers = 56GB × 25% = 14GB

# 配置
shared_buffers = 14GB
```

### 2.2 work_mem计算

```bash
# 公式: (总内存 - shared_buffers) / max_connections / 2

# 示例: 64GB内存, 200连接
Total: 64GB
shared_buffers: 14GB
Remaining: 50GB

work_mem = 50GB / 200 / 2 = 128MB

# 但实际需要根据查询复杂度调整:
# 简单OLTP: 16MB - 64MB
# 复杂分析: 256MB - 1GB

# 配置
work_mem = 64MB  # 默认
# 复杂查询时临时增加:
SET work_mem = '512MB';
```

### 2.3 effective_cache_size

```bash
# 公式: 总内存 × 50% ~ 75%

# 示例: 64GB内存
effective_cache_size = 64GB × 75% = 48GB

# 这是提示值，告诉优化器可用缓存大小
```

---

## 3. 连接数规划

### 3.1 连接池计算

```python
# 公式: connections_per_instance = ((core_count * 2) + effective_spindle_count)

# 示例: 16核CPU, SSD存储
core_count = 16
effective_spindle_count = 1  # SSD视为1

optimal_connections = (16 * 2) + 1 = 33

# 考虑应用实例数
app_instances = 10
connections_per_app = 33 / 10 = 3

# pgbouncer配置
default_pool_size = 5        # 每个数据库的连接池大小
max_client_conn = 1000       # 最大客户端连接
max_db_connections = 50      # 数据库最大连接

# PostgreSQL配置
max_connections = 100        # 留有余量
```

---

## 4. TPS/QPS容量

### 4.1 TPS估算

```sql
-- 测试当前TPS
SELECT
    xact_commit + xact_rollback AS current_tps,
    blks_read,
    blks_hit,
    ROUND(blks_hit * 100.0 / NULLIF(blks_hit + blks_read, 0), 2) AS cache_hit_ratio
FROM pg_stat_database
WHERE datname = current_database();

-- 容量评估
-- NVMe SSD: ~100k IOPS
-- 假设平均每个事务10个IOPS
-- 最大TPS = 100000 / 10 = 10000 TPS

-- 但需考虑:
-- CPU限制
-- 内存限制
-- 锁竞争
-- 网络带宽

-- 保守估计: 5000 TPS（50%利用率）
```

---

## 5. 容量计算器脚本

```python
#!/usr/bin/env python3
"""PostgreSQL容量规划计算器"""

class PostgreSQLCapacityCalculator:

    def __init__(self, total_memory_gb, cpu_cores, disk_iops):
        self.total_memory_gb = total_memory_gb
        self.cpu_cores = cpu_cores
        self.disk_iops = disk_iops

    def calculate_shared_buffers(self):
        """计算shared_buffers"""
        # 25% - 40%内存
        min_gb = self.total_memory_gb * 0.25
        max_gb = self.total_memory_gb * 0.40
        recommended = self.total_memory_gb * 0.25

        return {
            'min': f"{min_gb:.0f}GB",
            'max': f"{max_gb:.0f}GB",
            'recommended': f"{recommended:.0f}GB"
        }

    def calculate_work_mem(self, max_connections=100):
        """计算work_mem"""
        shared_buffers_gb = self.total_memory_gb * 0.25
        remaining_gb = self.total_memory_gb - shared_buffers_gb

        work_mem_mb = (remaining_gb * 1024) / max_connections / 2

        return {
            'calculated': f"{work_mem_mb:.0f}MB",
            'oltp_recommended': '64MB',
            'olap_recommended': '256MB'
        }

    def calculate_effective_cache_size(self):
        """计算effective_cache_size"""
        size_gb = self.total_memory_gb * 0.75
        return f"{size_gb:.0f}GB"

    def calculate_max_connections(self):
        """计算最大连接数"""
        # (CPU核心 × 2) + 1
        optimal = (self.cpu_cores * 2) + 1

        return {
            'optimal': optimal,
            'with_pool': optimal * 2,  # 使用连接池
            'recommended': 100  # 保守值
        }

    def calculate_max_tps(self):
        """估算最大TPS"""
        # 假设每个事务10个IOPS
        iops_per_txn = 10
        max_tps = self.disk_iops / iops_per_txn

        # 50%利用率
        recommended_tps = max_tps * 0.5

        return {
            'theoretical_max': int(max_tps),
            'recommended': int(recommended_tps)
        }

    def calculate_storage(self, rows, bytes_per_row, num_indexes=3):
        """计算存储需求"""
        # 表数据
        table_size_gb = (rows * bytes_per_row) / (1024**3)

        # 索引（每个索引约为表的15%）
        index_size_gb = table_size_gb * 0.15 * num_indexes

        # 膨胀（10%）
        bloat_gb = (table_size_gb + index_size_gb) * 0.10

        # WAL（建议3倍max_wal_size）
        wal_gb = 4 * 3  # 假设max_wal_size=4GB

        # 总计
        total_gb = table_size_gb + index_size_gb + bloat_gb + wal_gb

        return {
            'table': f"{table_size_gb:.2f}GB",
            'indexes': f"{index_size_gb:.2f}GB",
            'bloat': f"{bloat_gb:.2f}GB",
            'wal': f"{wal_gb:.2f}GB",
            'total': f"{total_gb:.2f}GB",
            'recommended_disk': f"{total_gb * 2:.2f}GB"  # 2倍预留
        }

    def generate_report(self):
        """生成完整报告"""
        print("="*60)
        print("PostgreSQL容量规划报告")
        print("="*60)
        print(f"\n硬件配置:")
        print(f"  内存: {self.total_memory_gb}GB")
        print(f"  CPU: {self.cpu_cores}核")
        print(f"  磁盘IOPS: {self.disk_iops}")

        print(f"\n内存配置:")
        sb = self.calculate_shared_buffers()
        print(f"  shared_buffers: {sb['recommended']}")
        wm = self.calculate_work_mem()
        print(f"  work_mem: {wm['oltp_recommended']} (OLTP)")
        print(f"  effective_cache_size: {self.calculate_effective_cache_size()}")

        print(f"\n连接配置:")
        mc = self.calculate_max_connections()
        print(f"  max_connections: {mc['recommended']}")
        print(f"  optimal_pool_size: {mc['optimal']}")

        print(f"\n性能预估:")
        tps = self.calculate_max_tps()
        print(f"  最大TPS: {tps['theoretical_max']}")
        print(f"  推荐TPS: {tps['recommended']}")

        print(f"\n存储示例（1000万行，700字节/行）:")
        storage = self.calculate_storage(10_000_000, 700)
        print(f"  表: {storage['table']}")
        print(f"  索引: {storage['indexes']}")
        print(f"  总计: {storage['total']}")
        print(f"  推荐磁盘: {storage['recommended_disk']}")

        print("\n" + "="*60)

# 使用示例
if __name__ == '__main__':
    # 64GB内存, 16核CPU, 100k IOPS (NVMe SSD)
    calc = PostgreSQLCapacityCalculator(
        total_memory_gb=64,
        cpu_cores=16,
        disk_iops=100000
    )

    calc.generate_report()
```

**输出**:

```
============================================================
PostgreSQL容量规划报告
============================================================

硬件配置:
  内存: 64GB
  CPU: 16核
  磁盘IOPS: 100000

内存配置:
  shared_buffers: 16GB
  work_mem: 64MB (OLTP)
  effective_cache_size: 48GB

连接配置:
  max_connections: 100
  optimal_pool_size: 33

性能预估:
  最大TPS: 10000
  推荐TPS: 5000

存储示例（1000万行，700字节/行）:
  表: 6.52GB
  索引: 2.93GB
  总计: 22.84GB
  推荐磁盘: 45.68GB

============================================================
```

---

## 6. 增长预测

```python
def predict_growth(current_rows, monthly_growth_rate, months):
    """预测增长"""

    projections = []
    rows = current_rows

    for month in range(1, months + 1):
        rows = rows * (1 + monthly_growth_rate)
        projections.append({
            'month': month,
            'rows': int(rows),
            'storage_gb': (rows * 700) / (1024**3) * 1.5  # 含索引
        })

    return projections

# 示例: 当前1000万行，每月增长5%
projections = predict_growth(10_000_000, 0.05, 12)

for p in [projections[2], projections[5], projections[11]]:
    print(f"第{p['month']}月: {p['rows']:,}行, {p['storage_gb']:.2f}GB")

# 输出:
# 第3月: 11,576,250行, 11.37GB
# 第6月: 13,400,956行, 13.16GB
# 第12月: 17,958,563行, 17.64GB
```

---

**完成**: PostgreSQL容量规划计算器
**字数**: ~10,000字
**涵盖**: 存储计算、内存规划、连接数、TPS容量、计算器脚本、增长预测
