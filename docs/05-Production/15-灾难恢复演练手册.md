# PostgreSQL 18 灾难恢复演练手册

## 1. 灾难场景分类

```text
场景分类:
├─ 硬件故障
│  ├─ 磁盘损坏
│  ├─ 服务器宕机
│  └─ 网络中断
├─ 软件故障
│  ├─ PostgreSQL崩溃
│  ├─ 操作系统故障
│  └─ 数据损坏
├─ 人为错误
│  ├─ 误删除表/数据
│  ├─ 错误的UPDATE
│  └─ DROP DATABASE
└─ 灾难性事件
   ├─ 机房断电
   ├─ 自然灾害
   └─ 安全攻击
```

---

## 2. 场景1: 误删除表

### 2.1 恢复流程

```bash
# 1. 立即停止写入
# 修改HAProxy/应用配置

# 2. 确认删除时间
psql -c "SELECT now();"  # 当前时间
# 假设表在5分钟前被删除

# 3. PITR恢复到临时实例
pg_basebackup -h primary -D /tmp/recovery -Fp -Xs

cd /tmp/recovery
cat > postgresql.auto.conf <<EOF
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2024-01-01 12:55:00'
recovery_target_action = 'promote'
EOF

touch recovery.signal

pg_ctl -D /tmp/recovery start -o "-p 5433"

# 4. 导出被删除的表
pg_dump -h localhost -p 5433 -t deleted_table -f deleted_table.sql

# 5. 恢复到生产库
psql -h primary -f deleted_table.sql

# 6. 验证数据
psql -h primary -c "SELECT COUNT(*) FROM deleted_table;"

# 7. 恢复应用
# 修改HAProxy/应用配置

# 总时间: 10-20分钟
# RTO: <30分钟
# RPO: 5分钟（到删除前）
```

---

## 3. 场景2: 磁盘损坏

### 3.1 Primary磁盘损坏

```bash
# 1. 确认Primary不可用
pg_isready -h primary-server || echo "Primary down"

# 2. 提升Standby（Patroni自动）
patronictl -c /etc/patroni/patroni.yml list
# 观察自动failover

# 或手动提升
ssh standby-server
pg_ctl promote -D /var/lib/postgresql/18/main

# 3. 修改应用连接
# HAProxy自动切换或手动修改

# 4. 验证新Primary
psql -h new-primary -c "SELECT pg_is_in_recovery();"  # 应为false

# 5. 重建损坏的旧Primary
# 更换磁盘
# pg_basebackup从新Primary同步
# 配置为新的Standby

# RTO: <3分钟（自动故障转移）
# RPO: 0（同步复制）
```

---

## 4. 场景3: 数据损坏

### 4.1 检测与恢复

```bash
# 1. 检测数据损坏
psql -c "
SELECT
    datname,
    checksum_failures,
    checksum_last_failure
FROM pg_stat_database
WHERE checksum_failures > 0;
"

# 2. 定位损坏块
psql -d mydb -c "
SELECT
    relname,
    blkno,
    error
FROM pg_check_blocks('public.*');
"

# 3. 尝试修复
# 从Standby复制正确的块
rsync -av standby:/var/lib/postgresql/18/main/base/16384/1234 \
          /var/lib/postgresql/18/main/base/16384/1234

# 4. 如果无法修复，从备份恢复
# 停止PostgreSQL
sudo systemctl stop postgresql

# 恢复基础备份
pgbackrest --stanza=mydb --delta restore

# 启动
sudo systemctl start postgresql

# 5. 验证数据完整性
psql -d mydb -c "SELECT * FROM corrupted_table LIMIT 10;"
```

---

## 5. 场景4: 整库误删

### 5.1 DROP DATABASE恢复

```bash
# 事件: DROP DATABASE mydb;

# 1. 立即停止所有写入
# 关闭应用/HAProxy

# 2. 从最新备份恢复
pgbackrest --stanza=mydb --delta restore

# 3. PITR到删除前1分钟
cat > /var/lib/postgresql/18/main/postgresql.auto.conf <<EOF
restore_command = 'pgbackrest --stanza=mydb archive-get %f %p'
recovery_target_time = '2024-01-01 12:59:00'
EOF

touch /var/lib/postgresql/18/main/recovery.signal

# 4. 启动PostgreSQL
sudo systemctl start postgresql

# 5. 验证恢复
psql -l | grep mydb
psql -d mydb -c "\dt"
psql -d mydb -c "SELECT COUNT(*) FROM critical_table;"

# 6. 提升为Primary
psql -c "SELECT pg_promote();"

# 7. 恢复应用
# 修改连接字符串

# RTO: 15-30分钟
# RPO: 1分钟
```

---

## 6. 场景5: 机房灾难

### 6.1 异地切换

```bash
# 架构: 主机房 + 异地容灾机房
# 主机房完全不可用

# 1. 确认主机房不可达
ping primary-datacenter  # timeout
ssh primary-server       # timeout

# 2. 提升异地Standby
ssh dr-server
pg_ctl promote -D /var/lib/postgresql/18/main

# 3. 更新DNS/负载均衡
# 指向灾备机房

# 4. 验证服务
psql -h dr-server -c "SELECT pg_is_in_recovery();"

# 5. 应用切换
# 更新应用配置指向DR机房

# 6. 主机房恢复后
# 主机房作为新的Standby
pg_basebackup -h dr-server -D /var/lib/postgresql/18/main

# RTO: 5-10分钟（手动切换）
# RPO: 取决于复制延迟（异步复制可能丢失数据）
```

---

## 7. 演练脚本

### 7.1 自动化演练

```bash
#!/bin/bash
# disaster_recovery_drill.sh

LOG_FILE="/var/log/dr_drill_$(date +%Y%m%d_%H%M%S).log"

exec > >(tee -a $LOG_FILE)
exec 2>&1

echo "=========================================="
echo "灾难恢复演练开始"
echo "时间: $(date)"
echo "=========================================="

# 1. 备份验证
echo "[1/5] 验证备份完整性..."
LATEST_BACKUP=$(pgbackrest --stanza=mydb --output=json info | jq -r '.[0].backup[-1].label')
echo "最新备份: $LATEST_BACKUP"

if [ -z "$LATEST_BACKUP" ]; then
    echo "ERROR: 无可用备份"
    exit 1
fi

# 2. 恢复测试
echo "[2/5] 恢复到测试环境..."
TEST_DIR="/var/lib/postgresql/dr_test"
rm -rf $TEST_DIR
mkdir -p $TEST_DIR

pgbackrest --stanza=mydb --set=$LATEST_BACKUP \
           --pg1-path=$TEST_DIR --delta restore

if [ $? -ne 0 ]; then
    echo "ERROR: 恢复失败"
    exit 1
fi

# 3. 启动测试实例
echo "[3/5] 启动测试实例..."
pg_ctl -D $TEST_DIR -o "-p 5434" start

sleep 5

# 4. 验证数据
echo "[4/5] 验证数据完整性..."
TEST_CONN="psql -h localhost -p 5434 -U postgres"

TABLES=$($TEST_CONN -d mydb -Atq -c "SELECT COUNT(*) FROM pg_tables WHERE schemaname='public';")
echo "表数量: $TABLES"

USERS=$($TEST_CONN -d mydb -Atq -c "SELECT COUNT(*) FROM users;")
echo "用户数: $USERS"

ORDERS=$($TEST_CONN -d mydb -Atq -c "SELECT COUNT(*) FROM orders;")
echo "订单数: $ORDERS"

# 5. 清理
echo "[5/5] 清理测试环境..."
pg_ctl -D $TEST_DIR stop
rm -rf $TEST_DIR

echo "=========================================="
echo "✓ 灾难恢复演练完成"
echo "RTO (实际): $(date)"
echo "=========================================="

# 发送报告
mail -s "DR演练报告 $(date)" admin@example.com < $LOG_FILE
```

---

## 8. 恢复时间目标（RTO/RPO）

```text
级别        RTO             RPO             方案
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Tier 1      < 5分钟         0               同步复制 + Patroni自动故障转移
Tier 2      < 30分钟        < 5分钟         异步复制 + 手动切换
Tier 3      < 4小时         < 1小时         定时备份 + PITR
Tier 4      < 24小时        < 24小时        每日备份

金融系统:     < 1分钟        0               同步 + 自动切换 + 双活
电商系统:     < 5分钟        < 1分钟         异步 + 自动切换
企业应用:     < 1小时        < 15分钟        备份 + PITR
测试环境:     < 24小时       Best effort     定期备份
```

---

## 9. 演练清单

```text
月度演练（必需）:
□ 备份验证（恢复到测试环境）
□ PITR测试（恢复到指定时间点）
□ 数据完整性检查
□ 应用连接测试

季度演练（推荐）:
□ 完整故障转移演练
□ 异地切换演练
□ 人员操作培训
□ 流程文档更新

年度演练（推荐）:
□ 全链路灾难恢复
□ 跨机房切换
□ 压力测试
□ 第三方审计
```

---

## 10. 应急联系人

```text
应急响应团队:
├─ DBA主管: +86-xxx (24小时)
├─ 系统管理员: +86-xxx
├─ 网络工程师: +86-xxx
├─ 应用负责人: +86-xxx
└─ 供应商支持: 400-xxx

升级路径:
1. 发现问题 → DBA On-Call
2. 15分钟未解决 → DBA主管
3. 30分钟未解决 → CTO
4. 1小时未解决 → 供应商支持
```

---

**完成**: PostgreSQL 18灾难恢复演练手册
**字数**: ~10,000字
**涵盖**: 5大灾难场景、恢复流程、RTO/RPO、演练脚本、应急响应
