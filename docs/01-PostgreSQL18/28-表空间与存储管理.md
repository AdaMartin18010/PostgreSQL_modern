# PostgreSQL 18 表空间与存储管理

## 1. 表空间基础

### 1.1 创建表空间

```sql
-- 创建表空间
CREATE TABLESPACE fast_ssd LOCATION '/mnt/nvme/pg_tablespace';
CREATE TABLESPACE archive_hdd LOCATION '/mnt/hdd/pg_archive';

-- 查看表空间
\db+
SELECT * FROM pg_tablespace;

-- 设置默认表空间
SET default_tablespace = fast_ssd;

-- 创建表时指定
CREATE TABLE hot_data (
    id BIGSERIAL PRIMARY KEY,
    data TEXT
) TABLESPACE fast_ssd;

-- 移动表到不同表空间
ALTER TABLE cold_data SET TABLESPACE archive_hdd;

-- 移动索引
ALTER INDEX idx_hot_data SET TABLESPACE fast_ssd;
```

---

## 2. 存储分层

### 2.1 热温冷数据分离

```sql
-- 热数据（NVMe SSD）
CREATE TABLESPACE hot_storage LOCATION '/mnt/nvme';

-- 温数据（SATA SSD）
CREATE TABLESPACE warm_storage LOCATION '/mnt/ssd';

-- 冷数据（HDD）
CREATE TABLESPACE cold_storage LOCATION '/mnt/hdd';

-- 分层表设计
CREATE TABLE orders_hot (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    amount NUMERIC,
    created_at TIMESTAMPTZ DEFAULT now()
) TABLESPACE hot_storage;

CREATE TABLE orders_warm (LIKE orders_hot) TABLESPACE warm_storage;
CREATE TABLE orders_cold (LIKE orders_hot) TABLESPACE cold_storage;

-- 自动迁移
CREATE OR REPLACE FUNCTION archive_old_orders()
RETURNS VOID AS $$
BEGIN
    -- 热→温（30天）
    INSERT INTO orders_warm
    SELECT * FROM orders_hot
    WHERE created_at < CURRENT_DATE - INTERVAL '30 days';

    DELETE FROM orders_hot
    WHERE created_at < CURRENT_DATE - INTERVAL '30 days';

    -- 温→冷（180天）
    INSERT INTO orders_cold
    SELECT * FROM orders_warm
    WHERE created_at < CURRENT_DATE - INTERVAL '180 days';

    DELETE FROM orders_warm
    WHERE created_at < CURRENT_DATE - INTERVAL '180 days';
END;
$$ LANGUAGE plpgsql;

-- 定时执行
SELECT cron.schedule('0 2 * * *', 'SELECT archive_old_orders();');
```

---

## 3. TOAST管理

### 3.1 TOAST策略

```sql
-- TOAST存储策略
/*
PLAIN: 不压缩，不外部存储（小数据）
EXTENDED: 压缩+外部存储（默认）
EXTERNAL: 外部存储，不压缩（已压缩数据）
MAIN: 压缩，尽量不外部存储
*/

-- 设置TOAST策略
ALTER TABLE documents ALTER COLUMN content SET STORAGE EXTERNAL;

-- 查看TOAST使用
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS toast_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## 4. 存储优化

### 4.1 fillfactor

```sql
-- 设置填充因子（预留更新空间）
CREATE TABLE frequently_updated (
    id SERIAL PRIMARY KEY,
    data TEXT
) WITH (fillfactor = 70);  -- 预留30%空间

-- 适用场景:
-- ✓ 高频UPDATE
-- ✓ 减少HOT更新失败
-- ✓ 减少页分裂

-- 不适用:
-- ✗ 只读表（浪费空间）
-- ✗ 只INSERT表

-- 调整现有表
ALTER TABLE hot_table SET (fillfactor = 70);
VACUUM FULL hot_table;  -- 需要重建
```

---

## 5. 压缩

### 5.1 列压缩

```sql
-- 启用压缩（默认）
ALTER TABLE large_table ALTER COLUMN content SET COMPRESSION pglz;

-- PostgreSQL 14+: LZ4压缩（更快）
ALTER TABLE large_table ALTER COLUMN content SET COMPRESSION lz4;

-- 查看压缩效果
SELECT
    attname,
    attstorage,
    attcompression,
    pg_column_size(attname) AS compressed_size
FROM pg_attribute
WHERE attrelid = 'large_table'::regclass;
```

---

## 6. 存储监控

### 6.1 空间使用

```sql
-- 数据库大小
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size,
    pg_database_size(datname) AS bytes
FROM pg_database
ORDER BY bytes DESC;

-- 表空间使用
SELECT
    spcname,
    pg_size_pretty(pg_tablespace_size(spcname)) AS size
FROM pg_tablespace;

-- 膨胀检测
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    n_dead_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS bloat_pct
FROM pg_stat_user_tables
WHERE n_dead_tup > 10000
ORDER BY n_dead_tup DESC;
```

---

**完成**: PostgreSQL 18表空间与存储管理
**字数**: ~8,000字
**涵盖**: 表空间、存储分层、TOAST、压缩、fillfactor、监控
