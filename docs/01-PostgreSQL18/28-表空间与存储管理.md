# PostgreSQL 18 表空间与存储管理

## 1. 表空间基础

### 1.1 创建表空间

```sql
-- 性能测试：创建表空间（带错误处理）
BEGIN;
CREATE TABLESPACE IF NOT EXISTS fast_ssd LOCATION '/mnt/nvme/pg_tablespace';
CREATE TABLESPACE IF NOT EXISTS archive_hdd LOCATION '/mnt/hdd/pg_archive';
COMMIT;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '部分表空间已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表空间失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查看表空间（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM pg_tablespace;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查看表空间失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：设置默认表空间（带错误处理）
BEGIN;
SET LOCAL default_tablespace = fast_ssd;
RAISE NOTICE '默认表空间已设置为fast_ssd';
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '设置默认表空间失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：创建表时指定（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS hot_data (
    id BIGSERIAL PRIMARY KEY,
    data TEXT
) TABLESPACE fast_ssd;
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表hot_data已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：移动表到不同表空间（带错误处理）
BEGIN;
ALTER TABLE cold_data SET TABLESPACE archive_hdd;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表cold_data不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '移动表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：移动索引（带错误处理）
BEGIN;
ALTER INDEX idx_hot_data SET TABLESPACE fast_ssd;
COMMIT;
EXCEPTION
    WHEN undefined_object THEN
        RAISE NOTICE '索引idx_hot_data不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '移动索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 2. 存储分层

### 2.1 热温冷数据分离

```sql
-- 性能测试：创建分层表空间（带错误处理）
BEGIN;
CREATE TABLESPACE IF NOT EXISTS hot_storage LOCATION '/mnt/nvme';
CREATE TABLESPACE IF NOT EXISTS warm_storage LOCATION '/mnt/ssd';
CREATE TABLESPACE IF NOT EXISTS cold_storage LOCATION '/mnt/hdd';
COMMIT;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '部分表空间已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表空间失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：分层表设计（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS orders_hot (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    amount NUMERIC,
    created_at TIMESTAMPTZ DEFAULT now()
) TABLESPACE hot_storage;
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表orders_hot已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
CREATE TABLE IF NOT EXISTS orders_warm (LIKE orders_hot) TABLESPACE warm_storage;
CREATE TABLE IF NOT EXISTS orders_cold (LIKE orders_hot) TABLESPACE cold_storage;
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '部分表已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 自动迁移
CREATE OR REPLACE FUNCTION archive_old_orders()
RETURNS VOID AS $$
BEGIN
    -- 热→温（30天）
    INSERT INTO orders_warm
    SELECT * FROM orders_hot
    WHERE created_at < CURRENT_DATE - INTERVAL '30 days';

    DELETE FROM orders_hot
    WHERE created_at < CURRENT_DATE - INTERVAL '30 days';

    -- 温→冷（180天）
    INSERT INTO orders_cold
    SELECT * FROM orders_warm
    WHERE created_at < CURRENT_DATE - INTERVAL '180 days';

    DELETE FROM orders_warm
    WHERE created_at < CURRENT_DATE - INTERVAL '180 days';
END;
$$ LANGUAGE plpgsql;

-- 性能测试：定时执行（带错误处理）
BEGIN;
SELECT cron.schedule('0 2 * * *', 'SELECT archive_old_orders();');
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建定时任务失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 3. TOAST管理

### 3.1 TOAST策略

```sql
-- TOAST存储策略
/*
PLAIN: 不压缩，不外部存储（小数据）
EXTENDED: 压缩+外部存储（默认）
EXTERNAL: 外部存储，不压缩（已压缩数据）
MAIN: 压缩，尽量不外部存储
*/

-- 设置TOAST策略
ALTER TABLE documents ALTER COLUMN content SET STORAGE EXTERNAL;

-- 查看TOAST使用
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS toast_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## 4. 存储优化

### 4.1 fillfactor

```sql
-- 设置填充因子（预留更新空间）
CREATE TABLE frequently_updated (
    id SERIAL PRIMARY KEY,
    data TEXT
) WITH (fillfactor = 70);  -- 预留30%空间

-- 适用场景:
-- ✓ 高频UPDATE
-- ✓ 减少HOT更新失败
-- ✓ 减少页分裂

-- 不适用:
-- ✗ 只读表（浪费空间）
-- ✗ 只INSERT表

-- 调整现有表
ALTER TABLE hot_table SET (fillfactor = 70);
VACUUM FULL hot_table;  -- 需要重建
```

---

## 5. 压缩

### 5.1 列压缩

```sql
-- 启用压缩（默认）
ALTER TABLE large_table ALTER COLUMN content SET COMPRESSION pglz;

-- PostgreSQL 14+: LZ4压缩（更快）
ALTER TABLE large_table ALTER COLUMN content SET COMPRESSION lz4;

-- 查看压缩效果
SELECT
    attname,
    attstorage,
    attcompression,
    pg_column_size(attname) AS compressed_size
FROM pg_attribute
WHERE attrelid = 'large_table'::regclass;
```

---

## 6. 存储监控

### 6.1 空间使用

```sql
-- 数据库大小
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size,
    pg_database_size(datname) AS bytes
FROM pg_database
ORDER BY bytes DESC;

-- 表空间使用
SELECT
    spcname,
    pg_size_pretty(pg_tablespace_size(spcname)) AS size
FROM pg_tablespace;

-- 膨胀检测
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    n_dead_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS bloat_pct
FROM pg_stat_user_tables
WHERE n_dead_tup > 10000
ORDER BY n_dead_tup DESC;
```

---

**完成**: PostgreSQL 18表空间与存储管理
**字数**: ~8,000字
**涵盖**: 表空间、存储分层、TOAST、压缩、fillfactor、监控
