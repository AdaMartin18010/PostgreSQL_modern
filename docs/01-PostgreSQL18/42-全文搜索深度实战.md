# PostgreSQL 18 å…¨æ–‡æœç´¢æ·±åº¦å®æˆ˜

PostgreSQLå†…ç½®å¼ºå¤§çš„å…¨æ–‡æœç´¢åŠŸèƒ½ï¼Œæ— éœ€Elasticsearchå³å¯å®ç°é«˜æ€§èƒ½æœç´¢ã€‚

---

## ğŸ“‹ ç›®å½•

1. [å…¨æ–‡æœç´¢åŸºç¡€](#å…¨æ–‡æœç´¢åŸºç¡€)
2. [é«˜çº§æœç´¢æŠ€å·§](#é«˜çº§æœç´¢æŠ€å·§)
3. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
4. [å¤šè¯­è¨€æ”¯æŒ](#å¤šè¯­è¨€æ”¯æŒ)
5. [å®æˆ˜æ¡ˆä¾‹](#å®æˆ˜æ¡ˆä¾‹)

---

## å…¨æ–‡æœç´¢åŸºç¡€

### tsvectorä¸tsquery

```sql
-- tsvector: æ–‡æ¡£å‘é‡
SELECT to_tsvector('english', 'The quick brown fox jumps over the lazy dog');
-- ç»“æœ: 'brown':3 'dog':9 'fox':4 'jump':5 'lazi':8 'quick':2

-- tsquery: æŸ¥è¯¢è¡¨è¾¾å¼
SELECT to_tsquery('english', 'quick & fox');
-- ç»“æœ: 'quick' & 'fox'

-- åŒ¹é…
SELECT to_tsvector('english', 'The quick brown fox') @@
       to_tsquery('english', 'quick & fox');
-- ç»“æœ: true
```

### åŸºç¡€æœç´¢

```sql
-- åˆ›å»ºæ–‡ç« è¡¨
CREATE TABLE articles (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- ç®€å•æœç´¢
SELECT * FROM articles
WHERE to_tsvector('english', title || ' ' || content) @@
      to_tsquery('english', 'postgresql & performance');
```

---

## é«˜çº§æœç´¢æŠ€å·§

### 1. é¢„è®¡ç®—tsvectorï¼ˆæ¨èï¼‰

```sql
-- æ·»åŠ tsvectoråˆ—
ALTER TABLE articles ADD COLUMN tsv tsvector;

-- ç”Ÿæˆtsvector
UPDATE articles SET tsv =
    to_tsvector('english', coalesce(title, '') || ' ' || coalesce(content, ''));

-- åˆ›å»ºGINç´¢å¼•ï¼ˆæ€§èƒ½å…³é”®ï¼ï¼‰
CREATE INDEX idx_articles_tsv ON articles USING GIN(tsv);

-- æŸ¥è¯¢ï¼ˆå¿«é€Ÿï¼‰
SELECT * FROM articles
WHERE tsv @@ to_tsquery('english', 'postgresql & performance');
```

### 2. è‡ªåŠ¨æ›´æ–°tsvector

```sql
-- è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION articles_tsv_trigger()
RETURNS TRIGGER AS $$
BEGIN
    NEW.tsv := to_tsvector('english',
        coalesce(NEW.title, '') || ' ' || coalesce(NEW.content, '')
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER articles_tsv_update
BEFORE INSERT OR UPDATE ON articles
FOR EACH ROW
EXECUTE FUNCTION articles_tsv_trigger();

-- ç°åœ¨æ’å…¥è‡ªåŠ¨ç”Ÿæˆtsvector
INSERT INTO articles (title, content) VALUES
    ('PostgreSQL Performance', 'Tips for optimizing queries...');
```

### 3. åŠ æƒæœç´¢

```sql
-- ä¸åŒå­—æ®µä¸åŒæƒé‡
UPDATE articles SET tsv =
    setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(content, '')), 'B');

-- æŸ¥è¯¢æ—¶è€ƒè™‘æƒé‡
SELECT
    id,
    title,
    ts_rank(tsv, query) AS rank
FROM articles, to_tsquery('english', 'postgresql') query
WHERE tsv @@ query
ORDER BY rank DESC;
```

### 4. ç›¸å…³æ€§æ’åº

```sql
-- ts_rank: åŸºç¡€æ’åº
SELECT
    title,
    ts_rank(tsv, query) AS rank
FROM articles, to_tsquery('english', 'postgresql & performance') query
WHERE tsv @@ query
ORDER BY rank DESC;

-- ts_rank_cd: è€ƒè™‘ä½ç½®çš„æ’åº
SELECT
    title,
    ts_rank_cd(tsv, query) AS rank
FROM articles, to_tsquery('english', 'postgresql & performance') query
WHERE tsv @@ query
ORDER BY rank DESC;

-- è‡ªå®šä¹‰æƒé‡
SELECT
    title,
    ts_rank('{0.1, 0.2, 0.4, 1.0}', tsv, query) AS rank
FROM articles, to_tsquery('english', 'postgresql') query
WHERE tsv @@ query
ORDER BY rank DESC;
```

### 5. æŸ¥è¯¢è¯­æ³•

```sql
-- ANDæŸ¥è¯¢
to_tsquery('postgresql & performance')

-- ORæŸ¥è¯¢
to_tsquery('postgresql | mysql')

-- NOTæŸ¥è¯¢
to_tsquery('postgresql & !mysql')

-- çŸ­è¯­æŸ¥è¯¢
to_tsquery('postgresql <-> performance')  -- ç›¸é‚»
to_tsquery('postgresql <2> performance')  -- è·ç¦»<=2

-- ç»„åˆæŸ¥è¯¢
to_tsquery('(postgresql | mysql) & performance & !slow')
```

### 6. é«˜äº®æ˜¾ç¤º

```sql
-- é«˜äº®åŒ¹é…è¯
SELECT
    title,
    ts_headline('english', content, query, 'MaxWords=50, MinWords=20') AS snippet
FROM articles, to_tsquery('english', 'postgresql') query
WHERE tsv @@ query;

-- è‡ªå®šä¹‰é«˜äº®æ ‡ç­¾
SELECT
    ts_headline('english', content, query,
        'StartSel=<mark>, StopSel=</mark>'
    ) AS snippet
FROM articles, to_tsquery('english', 'postgresql') query
WHERE tsv @@ query;
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. GIN vs GiSTç´¢å¼•

```sql
-- GINç´¢å¼•ï¼ˆæ¨èï¼‰ï¼šæ›´å¿«æŸ¥è¯¢ï¼Œè¾ƒæ…¢æ›´æ–°
CREATE INDEX idx_articles_gin ON articles USING GIN(tsv);

-- GiSTç´¢å¼•ï¼šè¾ƒå¿«æ›´æ–°ï¼Œè¾ƒæ…¢æŸ¥è¯¢
CREATE INDEX idx_articles_gist ON articles USING GIST(tsv);

-- æ€§èƒ½å¯¹æ¯”
EXPLAIN ANALYZE
SELECT * FROM articles WHERE tsv @@ to_tsquery('postgresql');
```

### 2. GINç´¢å¼•ä¼˜åŒ–

```sql
-- è°ƒæ•´GINå‚æ•°ï¼ˆPostgreSQL 18ï¼‰
CREATE INDEX idx_articles_gin ON articles
USING GIN(tsv) WITH (fastupdate = on, gin_pending_list_limit = 4096);

-- fastupdate: æ‰¹é‡æ›´æ–°pending list
-- gin_pending_list_limit: pending listå¤§å°
```

### 3. åˆ†åŒºè¡¨ä¼˜åŒ–

```sql
-- æŒ‰æ—¶é—´åˆ†åŒº
CREATE TABLE articles_2024_01 PARTITION OF articles
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE articles_2024_02 PARTITION OF articles
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- æ¯ä¸ªåˆ†åŒºåˆ›å»ºç´¢å¼•
CREATE INDEX idx_articles_2024_01_tsv ON articles_2024_01 USING GIN(tsv);
CREATE INDEX idx_articles_2024_02_tsv ON articles_2024_02 USING GIN(tsv);
```

### 4. æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä½¿ç”¨LIMIT
SELECT * FROM articles
WHERE tsv @@ to_tsquery('postgresql')
ORDER BY ts_rank(tsv, to_tsquery('postgresql')) DESC
LIMIT 20;

-- ä½¿ç”¨CTEé¢„è¿‡æ»¤
WITH matched AS (
    SELECT id, title, tsv
    FROM articles
    WHERE tsv @@ to_tsquery('postgresql')
    LIMIT 100
)
SELECT
    id,
    title,
    ts_rank(tsv, query) AS rank
FROM matched, to_tsquery('postgresql') query
ORDER BY rank DESC
LIMIT 20;
```

---

## å¤šè¯­è¨€æ”¯æŒ

### ä¸­æ–‡å…¨æ–‡æœç´¢

#### 1. å®‰è£…zhparser

```bash
# Ubuntu/Debian
sudo apt-get install postgresql-18-zhparser

# ç¼–è¯‘å®‰è£…
git clone https://github.com/amutu/zhparser.git
cd zhparser
make && sudo make install
```

#### 2. é…ç½®ä¸­æ–‡åˆ†è¯

```sql
-- åˆ›å»ºæ‰©å±•
CREATE EXTENSION zhparser;

-- åˆ›å»ºä¸­æ–‡æ–‡æœ¬æœç´¢é…ç½®
CREATE TEXT SEARCH CONFIGURATION chinese (PARSER = zhparser);

-- æ·»åŠ tokenæ˜ å°„
ALTER TEXT SEARCH CONFIGURATION chinese ADD MAPPING FOR
    n,v,a,i,e,l WITH simple;

-- æµ‹è¯•
SELECT to_tsvector('chinese', 'æˆ‘çˆ±PostgreSQLæ•°æ®åº“');
-- ç»“æœ: 'postgresql':2 'love':1 'database':3
```

#### 3. ä¸­æ–‡æœç´¢ç¤ºä¾‹

```sql
-- åˆ›å»ºå¸¦ä¸­æ–‡çš„æ–‡ç« è¡¨
CREATE TABLE cn_articles (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    tsv tsvector
);

-- è§¦å‘å™¨ï¼ˆä¸­æ–‡ï¼‰
CREATE OR REPLACE FUNCTION cn_articles_tsv_trigger()
RETURNS TRIGGER AS $$
BEGIN
    NEW.tsv := to_tsvector('chinese',
        coalesce(NEW.title, '') || ' ' || coalesce(NEW.content, '')
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER cn_articles_tsv_update
BEFORE INSERT OR UPDATE ON cn_articles
FOR EACH ROW
EXECUTE FUNCTION cn_articles_tsv_trigger();

-- ç´¢å¼•
CREATE INDEX idx_cn_articles_tsv ON cn_articles USING GIN(tsv);

-- æ’å…¥æ•°æ®
INSERT INTO cn_articles (title, content) VALUES
    ('PostgreSQLæ€§èƒ½ä¼˜åŒ–', 'PostgreSQLæ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„å¼€æºæ•°æ®åº“...'),
    ('æ•°æ®åº“ç´¢å¼•åŸç†', 'ç´¢å¼•å¯ä»¥æ˜¾è‘—æå‡æŸ¥è¯¢æ€§èƒ½...');

-- æœç´¢
SELECT title, ts_rank(tsv, query) AS rank
FROM cn_articles, to_tsquery('chinese', 'PostgreSQL & æ€§èƒ½') query
WHERE tsv @@ query
ORDER BY rank DESC;
```

### å¤šè¯­è¨€æ··åˆ

```sql
-- æ£€æµ‹è¯­è¨€å¹¶ä½¿ç”¨ç›¸åº”é…ç½®
CREATE OR REPLACE FUNCTION detect_language(text TEXT)
RETURNS regconfig AS $$
BEGIN
    -- ç®€å•æ£€æµ‹ï¼šæ˜¯å¦åŒ…å«ä¸­æ–‡
    IF text ~ '[\u4e00-\u9fa5]' THEN
        RETURN 'chinese'::regconfig;
    ELSE
        RETURN 'english'::regconfig;
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ä½¿ç”¨
SELECT to_tsvector(detect_language(content), content)
FROM articles;
```

---

## å®æˆ˜æ¡ˆä¾‹

### æ¡ˆä¾‹1: åšå®¢æœç´¢ç³»ç»Ÿ

```sql
-- å®Œæ•´çš„åšå®¢æœç´¢è¡¨
CREATE TABLE blog_posts (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT NOT NULL,
    category VARCHAR(50),
    tags TEXT[],
    published_at TIMESTAMPTZ,
    tsv tsvector,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- ç»¼åˆtsvectorï¼ˆæ ‡é¢˜æƒé‡Aï¼Œå†…å®¹Bï¼Œæ ‡ç­¾Cï¼‰
CREATE OR REPLACE FUNCTION blog_posts_tsv_trigger()
RETURNS TRIGGER AS $$
BEGIN
    NEW.tsv :=
        setweight(to_tsvector('english', coalesce(NEW.title, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(NEW.content, '')), 'B') ||
        setweight(to_tsvector('english', coalesce(array_to_string(NEW.tags, ' '), '')), 'C');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER blog_posts_tsv_update
BEFORE INSERT OR UPDATE ON blog_posts
FOR EACH ROW
EXECUTE FUNCTION blog_posts_tsv_trigger();

CREATE INDEX idx_blog_posts_tsv ON blog_posts USING GIN(tsv);

-- é«˜çº§æœç´¢æŸ¥è¯¢
CREATE OR REPLACE FUNCTION search_blog_posts(
    search_query TEXT,
    category_filter VARCHAR DEFAULT NULL,
    author_filter BIGINT DEFAULT NULL,
    limit_count INT DEFAULT 20
)
RETURNS TABLE(
    id BIGINT,
    title TEXT,
    snippet TEXT,
    rank REAL,
    published_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        bp.id,
        bp.title,
        ts_headline('english', bp.content, query,
            'MaxWords=50, MinWords=20'
        ) AS snippet,
        ts_rank('{0.1, 0.2, 0.4, 1.0}', bp.tsv, query) AS rank,
        bp.published_at
    FROM blog_posts bp, to_tsquery('english', search_query) query
    WHERE bp.tsv @@ query
      AND (category_filter IS NULL OR bp.category = category_filter)
      AND (author_filter IS NULL OR bp.author_id = author_filter)
    ORDER BY rank DESC, published_at DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨
SELECT * FROM search_blog_posts('postgresql & performance', 'Technology', NULL, 10);
```

### æ¡ˆä¾‹2: ç”µå•†äº§å“æœç´¢

```sql
CREATE TABLE products (
    id BIGSERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    brand VARCHAR(100),
    category VARCHAR(100),
    price NUMERIC(10, 2),
    stock INT,
    tsv tsvector
);

-- äº§å“æœç´¢ï¼ˆæ”¯æŒä»·æ ¼èŒƒå›´ï¼‰
CREATE OR REPLACE FUNCTION search_products(
    search_query TEXT,
    min_price NUMERIC DEFAULT NULL,
    max_price NUMERIC DEFAULT NULL,
    category_filter VARCHAR DEFAULT NULL
)
RETURNS TABLE(
    id BIGINT,
    name TEXT,
    brand VARCHAR,
    price NUMERIC,
    rank REAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.name,
        p.brand,
        p.price,
        ts_rank(p.tsv, query) AS rank
    FROM products p, to_tsquery('english', search_query) query
    WHERE p.tsv @@ query
      AND p.stock > 0
      AND (min_price IS NULL OR p.price >= min_price)
      AND (max_price IS NULL OR p.price <= max_price)
      AND (category_filter IS NULL OR p.category = category_filter)
    ORDER BY rank DESC, p.price ASC;
END;
$$ LANGUAGE plpgsql;
```

### æ¡ˆä¾‹3: æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ

```sql
-- æ–‡æ¡£è¡¨ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼‰
CREATE TABLE documents (
    id BIGSERIAL PRIMARY KEY,
    filename TEXT NOT NULL,
    file_type VARCHAR(20),
    content TEXT,  -- æå–çš„æ–‡æœ¬å†…å®¹
    metadata JSONB,
    uploaded_by BIGINT,
    uploaded_at TIMESTAMPTZ DEFAULT now(),
    tsv tsvector
);

-- ç´¢å¼•
CREATE INDEX idx_documents_tsv ON documents USING GIN(tsv);
CREATE INDEX idx_documents_metadata ON documents USING GIN(metadata);

-- æœç´¢å‡½æ•°ï¼ˆæ”¯æŒå…ƒæ•°æ®è¿‡æ»¤ï¼‰
CREATE OR REPLACE FUNCTION search_documents(
    search_query TEXT,
    file_type_filter VARCHAR DEFAULT NULL,
    metadata_filter JSONB DEFAULT NULL
)
RETURNS TABLE(
    id BIGINT,
    filename TEXT,
    snippet TEXT,
    rank REAL,
    uploaded_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        d.id,
        d.filename,
        ts_headline('english', d.content, query, 'MaxWords=30') AS snippet,
        ts_rank(d.tsv, query) AS rank,
        d.uploaded_at
    FROM documents d, to_tsquery('english', search_query) query
    WHERE d.tsv @@ query
      AND (file_type_filter IS NULL OR d.file_type = file_type_filter)
      AND (metadata_filter IS NULL OR d.metadata @> metadata_filter)
    ORDER BY rank DESC
    LIMIT 50;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨
SELECT * FROM search_documents(
    'contract & agreement',
    'pdf',
    '{"department": "legal"}'::jsonb
);
```

---

## ç›‘æ§ä¸ç»Ÿè®¡

### ç´¢å¼•ä½¿ç”¨æƒ…å†µ

```sql
-- æŸ¥çœ‹ç´¢å¼•å¤§å°
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS size
FROM pg_stat_user_indexes
WHERE indexname LIKE '%tsv%';

-- æŸ¥çœ‹ç´¢å¼•æ‰«ææ¬¡æ•°
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname LIKE '%tsv%';
```

### æœç´¢æ€§èƒ½åˆ†æ

```sql
-- è®°å½•æœç´¢æ—¥å¿—
CREATE TABLE search_logs (
    id BIGSERIAL PRIMARY KEY,
    query TEXT,
    results_count INT,
    execution_time_ms REAL,
    searched_at TIMESTAMPTZ DEFAULT now()
);

-- åœ¨æœç´¢å‡½æ•°ä¸­è®°å½•
CREATE OR REPLACE FUNCTION search_with_logging(search_query TEXT)
RETURNS TABLE(...) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    results_count INT;
BEGIN
    start_time := clock_timestamp();

    -- æ‰§è¡Œæœç´¢
    RETURN QUERY ...;

    GET DIAGNOSTICS results_count = ROW_COUNT;
    end_time := clock_timestamp();

    -- è®°å½•æ—¥å¿—
    INSERT INTO search_logs (query, results_count, execution_time_ms)
    VALUES (
        search_query,
        results_count,
        EXTRACT(MILLISECONDS FROM (end_time - start_time))
    );
END;
$$ LANGUAGE plpgsql;
```

---

## æœ€ä½³å®è·µ

### âœ… æ¨è

1. **å§‹ç»ˆä½¿ç”¨GINç´¢å¼•**

   ```sql
   CREATE INDEX idx_tsv ON table_name USING GIN(tsv);
   ```

2. **é¢„è®¡ç®—tsvector**

   ```sql
   ALTER TABLE table_name ADD COLUMN tsv tsvector;
   -- ä½¿ç”¨è§¦å‘å™¨è‡ªåŠ¨æ›´æ–°
   ```

3. **åˆç†è®¾ç½®æƒé‡**

   ```sql
   setweight(to_tsvector('english', title), 'A') ||  -- æ ‡é¢˜æœ€é‡è¦
   setweight(to_tsvector('english', content), 'B')   -- å†…å®¹æ¬¡ä¹‹
   ```

4. **ä½¿ç”¨ts_rankæ’åº**

   ```sql
   ORDER BY ts_rank(tsv, query) DESC
   ```

### âŒ é¿å…

1. âŒ æ¯æ¬¡æŸ¥è¯¢éƒ½ç”Ÿæˆtsvector
2. âŒ ä¸ä½¿ç”¨ç´¢å¼•
3. âŒ ä¸é™åˆ¶ç»“æœæ•°é‡
4. âŒ å¿½ç•¥è¯­è¨€é…ç½®

---

## æ€»ç»“

PostgreSQLå…¨æ–‡æœç´¢:

- âœ… å†…ç½®æ”¯æŒï¼Œæ— éœ€é¢å¤–ç»„ä»¶
- âœ… é«˜æ€§èƒ½GINç´¢å¼•
- âœ… çµæ´»çš„æŸ¥è¯¢è¯­æ³•
- âœ… å¤šè¯­è¨€æ”¯æŒ
- âœ… ä¸SQLå®Œç¾é›†æˆ

**é€‚ç”¨åœºæ™¯**: åšå®¢æœç´¢ã€äº§å“æœç´¢ã€æ–‡æ¡£ç®¡ç†ã€å†…å®¹ç®¡ç†ç³»ç»Ÿ

---

**PostgreSQLå…¨æ–‡æœç´¢ - ç®€å•è€Œå¼ºå¤§ï¼**
