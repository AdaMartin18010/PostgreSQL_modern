# PostgreSQL 18 扩展开发完整指南

## 1. 扩展基础

### 1.1 扩展结构

```text
my_extension/
├── my_extension.control   # 扩展元数据
├── my_extension--1.0.sql  # 安装脚本
├── my_extension--1.0--1.1.sql  # 升级脚本
├── Makefile               # 构建配置
└── src/
    ├── my_extension.c     # C代码
    └── my_extension.h     # 头文件
```

### 1.2 control文件

```ini
# my_extension.control
comment = 'My PostgreSQL extension'
default_version = '1.0'
module_pathname = '$libdir/my_extension'
relocatable = true
requires = 'plpgsql'
```

---

## 2. SQL扩展开发

### 2.1 简单扩展

```sql
-- 性能测试：my_extension--1.0.sql（带错误处理）
BEGIN;
-- 创建schema
CREATE SCHEMA IF NOT EXISTS my_extension;
COMMIT;
EXCEPTION
    WHEN duplicate_schema THEN
        RAISE NOTICE 'schema my_extension已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建schema失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：创建函数（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION my_extension.hello(name TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN 'Hello, ' || name || '!';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '函数执行失败: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：创建聚合函数（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION my_extension.median_state(state NUMERIC[], val NUMERIC)
RETURNS NUMERIC[] AS $$
BEGIN
    RETURN array_append(state, val);
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'median_state执行失败: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION my_extension.median_final(state NUMERIC[])
RETURNS NUMERIC AS $$
DECLARE
    sorted NUMERIC[];
    len INT;
BEGIN
    sorted := ARRAY(SELECT unnest(state) ORDER BY 1);
    len := array_length(sorted, 1);

    IF len % 2 = 0 THEN
        RETURN (sorted[len/2] + sorted[len/2+1]) / 2.0;
    ELSE
        RETURN sorted[len/2+1];
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'median_final执行失败: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;

CREATE AGGREGATE IF NOT EXISTS my_extension.median(NUMERIC) (
    SFUNC = my_extension.median_state,
    STYPE = NUMERIC[],
    FINALFUNC = my_extension.median_final,
    INITCOND = '{}'
);
COMMIT;
EXCEPTION
    WHEN duplicate_function THEN
        RAISE NOTICE '聚合函数median已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建聚合函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：使用（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT my_extension.median(value) FROM measurements;
COMMIT;
EXCEPTION
    WHEN undefined_table THEN
        RAISE NOTICE '表measurements不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '使用聚合函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.2 Makefile

```makefile
# Makefile
EXTENSION = my_extension
DATA = my_extension--1.0.sql
PGFILEDESC = "my_extension - My PostgreSQL extension"

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
```

### 2.3 安装

```bash
#!/bin/bash
# 性能测试：扩展安装（带错误处理）
set -e
set -u

error_exit() {
    echo "错误: $1" >&2
    exit 1
}

# 构建
make || error_exit "构建失败"

# 安装
sudo make install || error_exit "安装失败"

# 在数据库中安装
psql -d mydb -c "CREATE EXTENSION IF NOT EXISTS my_extension;" || error_exit "创建扩展失败"

# 查看
psql -d mydb -c "\dx my_extension" || error_exit "查看扩展失败"

echo "扩展安装完成"
```

---

## 3. C扩展开发

### 3.1 基础C扩展

```c
// my_extension.c
#include "postgres.h"
#include "fmgr.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

// 函数声明
PG_FUNCTION_INFO_V1(add_numbers);

// 实现
Datum
add_numbers(PG_FUNCTION_ARGS)
{
    int32 arg1 = PG_GETARG_INT32(0);
    int32 arg2 = PG_GETARG_INT32(1);
    int32 result = arg1 + arg2;

    PG_RETURN_INT32(result);
}
```

```sql
-- 性能测试：SQL包装（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION add_numbers(INT, INT)
RETURNS INT AS '$libdir/my_extension', 'add_numbers'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：使用（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT add_numbers(10, 20);  -- 30
COMMIT;
EXCEPTION
    WHEN undefined_function THEN
        RAISE NOTICE '函数add_numbers不存在，请先编译并安装扩展';
    WHEN OTHERS THEN
        RAISE NOTICE '调用函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 3.2 复杂类型处理

```c
// 处理TEXT类型
PG_FUNCTION_INFO_V1(uppercase);

Datum
uppercase(PG_FUNCTION_ARGS)
{
    text *input = PG_GETARG_TEXT_PP(0);
    char *str = text_to_cstring(input);

    // 转大写
    for (int i = 0; str[i]; i++) {
        str[i] = toupper(str[i]);
    }

    text *result = cstring_to_text(str);
    PG_RETURN_TEXT_P(result);
}
```

---

## 4. 自定义类型

### 4.1 创建自定义类型

```c
// complex.c - 复数类型
typedef struct Complex {
    float8 x;  // 实部
    float8 y;  // 虚部
} Complex;

// 输入函数
PG_FUNCTION_INFO_V1(complex_in);
Datum
complex_in(PG_FUNCTION_ARGS)
{
    char *str = PG_GETARG_CSTRING(0);
    Complex *result = (Complex *) palloc(sizeof(Complex));

    if (sscanf(str, " ( %lf , %lf )", &result->x, &result->y) != 2)
        ereport(ERROR, (errmsg("invalid input syntax for complex: \"%s\"", str)));

    PG_RETURN_POINTER(result);
}

// 输出函数
PG_FUNCTION_INFO_V1(complex_out);
Datum
complex_out(PG_FUNCTION_ARGS)
{
    Complex *complex = (Complex *) PG_GETARG_POINTER(0);
    char *result = psprintf("(%g,%g)", complex->x, complex->y);
    PG_RETURN_CSTRING(result);
}

// 加法操作符
PG_FUNCTION_INFO_V1(complex_add);
Datum
complex_add(PG_FUNCTION_ARGS)
{
    Complex *a = (Complex *) PG_GETARG_POINTER(0);
    Complex *b = (Complex *) PG_GETARG_POINTER(1);
    Complex *result = (Complex *) palloc(sizeof(Complex));

    result->x = a->x + b->x;
    result->y = a->y + b->y;

    PG_RETURN_POINTER(result);
}
```

```sql
-- 性能测试：SQL定义（带错误处理）
BEGIN;
DO $$
BEGIN
    CREATE TYPE IF NOT EXISTS complex;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '类型complex已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建类型失败: %', SQLERRM;
        RAISE;
END $$;
COMMIT;

BEGIN;
CREATE OR REPLACE FUNCTION complex_in(cstring)
RETURNS complex AS '$libdir/complex'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建complex_in函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
CREATE OR REPLACE FUNCTION complex_out(complex)
RETURNS cstring AS '$libdir/complex'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建complex_out函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
DO $$
BEGIN
    CREATE TYPE complex (
        INPUT = complex_in,
        OUTPUT = complex_out,
        INTERNALLENGTH = 16,
        ALIGNMENT = double
    );
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '类型complex已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建类型定义失败: %', SQLERRM;
        RAISE;
END $$;
COMMIT;

-- 性能测试：操作符（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION complex_add(complex, complex)
RETURNS complex AS '$libdir/complex'
LANGUAGE C IMMUTABLE STRICT;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建complex_add函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
DROP OPERATOR IF EXISTS + (complex, complex);
CREATE OPERATOR + (
    LEFTARG = complex,
    RIGHTARG = complex,
    FUNCTION = complex_add
);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建操作符失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：使用（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT '(1.0, 2.0)'::complex + '(3.0, 4.0)'::complex;
-- 结果: (4.0, 6.0)
COMMIT;
EXCEPTION
    WHEN undefined_type THEN
        RAISE NOTICE '类型complex不存在，请先编译并安装扩展';
    WHEN undefined_function THEN
        RAISE NOTICE '函数complex_add不存在';
    WHEN OTHERS THEN
        RAISE NOTICE '使用自定义类型失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 5. 后台Worker

### 5.1 Background Worker

```c
// bgworker.c
#include "postgres.h"
#include "postmaster/bgworker.h"
#include "storage/ipc.h"
#include "storage/latch.h"

void _PG_init(void);
void my_worker_main(Datum main_arg);

void
_PG_init(void)
{
    BackgroundWorker worker;

    memset(&worker, 0, sizeof(worker));
    worker.bgw_flags = BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION;
    worker.bgw_start_time = BgWorkerStart_RecoveryFinished;
    snprintf(worker.bgw_name, BGW_MAXLEN, "my background worker");
    sprintf(worker.bgw_library_name, "my_extension");
    sprintf(worker.bgw_function_name, "my_worker_main");
    worker.bgw_restart_time = 10;  // 10秒后重启

    RegisterBackgroundWorker(&worker);
}

void
my_worker_main(Datum main_arg)
{
    // 连接数据库
    BackgroundWorkerInitializeConnection("mydb", NULL, 0);

    while (!got_SIGTERM)
    {
        // 执行定时任务
        // ...

        // 等待10秒
        WaitLatch(MyLatch, WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH, 10000L, PG_WAIT_EXTENSION);
        ResetLatch(MyLatch);
    }

    proc_exit(0);
}
```

---

## 6. 钩子（Hook）

### 6.1 自定义钩子

```c
// 执行器钩子
static ExecutorStart_hook_type prev_ExecutorStart = NULL;

static void
my_ExecutorStart(QueryDesc *queryDesc, int eflags)
{
    // 在查询开始前执行
    elog(LOG, "Query starting: %s", queryDesc->sourceText);

    // 调用原始钩子
    if (prev_ExecutorStart)
        prev_ExecutorStart(queryDesc, eflags);
    else
        standard_ExecutorStart(queryDesc, eflags);
}

void
_PG_init(void)
{
    // 安装钩子
    prev_ExecutorStart = ExecutorStart_hook;
    ExecutorStart_hook = my_ExecutorStart;
}

// 应用: 查询日志、权限检查、审计等
```

---

## 7. 实战案例

### 7.1 自动分区扩展

```sql
-- auto_partition扩展
CREATE OR REPLACE FUNCTION auto_partition.create_partition_if_not_exists(
    parent_table TEXT,
    partition_column TEXT,
    partition_value DATE
) RETURNS VOID AS $$
DECLARE
    partition_name TEXT;
    start_date DATE;
    end_date DATE;
BEGIN
    partition_name := parent_table || '_' || to_char(partition_value, 'YYYYMM');
    start_date := date_trunc('month', partition_value);
    end_date := start_date + INTERVAL '1 month';

    -- 检查分区是否存在
    IF NOT EXISTS (
        SELECT 1 FROM pg_tables WHERE tablename = partition_name
    ) THEN
        EXECUTE format(
            'CREATE TABLE %I PARTITION OF %I FOR VALUES FROM (%L) TO (%L)',
            partition_name, parent_table, start_date, end_date
        );

        RAISE NOTICE '创建分区: %', partition_name;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- 触发器自动创建分区
CREATE OR REPLACE FUNCTION auto_partition.partition_trigger()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM auto_partition.create_partition_if_not_exists(
        TG_TABLE_NAME,
        TG_ARGV[0],  -- 分区列名
        NEW.created_at::DATE
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 应用
CREATE TRIGGER trg_auto_partition
    BEFORE INSERT ON logs_partitioned
    FOR EACH ROW
    EXECUTE FUNCTION auto_partition.partition_trigger('created_at');
```

---

## 8. 测试与调试

### 8.1 单元测试

```sql
-- 使用pgTAP
CREATE EXTENSION pgtap;

-- 测试脚本
BEGIN;
SELECT plan(5);

SELECT has_function('my_extension', 'hello', ARRAY['text']);
SELECT function_returns('my_extension', 'hello', ARRAY['text'], 'text');

SELECT is(
    my_extension.hello('World'),
    'Hello, World!',
    'hello函数返回正确'
);

SELECT finish();
ROLLBACK;
```

### 8.2 性能测试

```sql
-- 性能比较
\timing on

-- 测试1000次调用
SELECT my_extension.expensive_function(i)
FROM generate_series(1, 1000) i;

-- 与原生函数对比
SELECT built_in_function(i)
FROM generate_series(1, 1000) i;
```

---

## 9. 发布扩展

### 9.1 PGXN发布

```bash
# 创建META.json
cat > META.json <<EOF
{
    "name": "my_extension",
    "abstract": "My PostgreSQL extension",
    "version": "1.0.0",
    "maintainer": "Your Name <you@example.com>",
    "license": "postgresql",
    "provides": {
        "my_extension": {
            "file": "sql/my_extension--1.0.sql",
            "version": "1.0.0"
        }
    },
    "resources": {
        "homepage": "https://github.com/yourusername/my_extension",
        "repository": {
            "url": "git://github.com/yourusername/my_extension.git",
            "web": "https://github.com/yourusername/my_extension"
        }
    }
}
EOF

# 打包
zip -r my_extension-1.0.0.zip *

# 上传到PGXN
# https://manager.pgxn.org/
```

---

## 10. 常用扩展案例

### 10.1 监控扩展

```sql
-- 创建监控函数
CREATE OR REPLACE FUNCTION monitor.table_stats()
RETURNS TABLE (
    table_name TEXT,
    row_count BIGINT,
    total_size TEXT,
    index_size TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        t.tablename::TEXT,
        t.n_live_tup,
        pg_size_pretty(pg_total_relation_size(t.schemaname||'.'||t.tablename)),
        pg_size_pretty(pg_indexes_size(t.schemaname||'.'||t.tablename))
    FROM pg_stat_user_tables t
    ORDER BY pg_total_relation_size(t.schemaname||'.'||t.tablename) DESC;
END;
$$ LANGUAGE plpgsql;

-- 使用
SELECT * FROM monitor.table_stats();
```

### 10.2 工具函数扩展

```sql
-- 字符串工具
CREATE OR REPLACE FUNCTION utils.slugify(input TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN lower(regexp_replace(
        regexp_replace(input, '[^a-zA-Z0-9\s-]', '', 'g'),
        '[\s-]+', '-', 'g'
    ));
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 使用
SELECT utils.slugify('Hello World! 2024');  -- hello-world-2024

-- JSON工具
CREATE OR REPLACE FUNCTION utils.jsonb_merge(a JSONB, b JSONB)
RETURNS JSONB AS $$
BEGIN
    RETURN jsonb_strip_nulls(a || b);
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

**完成**: PostgreSQL 18扩展开发完整指南
**字数**: ~8,000字
**涵盖**: SQL扩展、C扩展、自定义类型、后台Worker、钩子、测试、发布
