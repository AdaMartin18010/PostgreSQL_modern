# PostgreSQL 18 窗口函数完整实战

## 1. 窗口函数基础

### 1.1 语法结构

```sql
-- 基础语法
function_name() OVER (
    PARTITION BY column1, column2
    ORDER BY column3
    ROWS/RANGE BETWEEN ... AND ...
)

-- 示例
SELECT
    employee_id,
    department,
    salary,
    AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_in_dept
FROM employees;
```

---

## 2. 排名函数

### 2.1 RANK vs DENSE_RANK vs ROW_NUMBER

```sql
CREATE TABLE scores (
    student_id INT,
    subject VARCHAR(50),
    score INT
);

INSERT INTO scores VALUES
(1, 'Math', 95),
(2, 'Math', 95),
(3, 'Math', 90),
(4, 'Math', 85);

SELECT
    student_id,
    score,
    ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num,
    RANK() OVER (ORDER BY score DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank
FROM scores;

/*
 student_id | score | row_num | rank | dense_rank
------------+-------+---------+------+------------
     1      |  95   |    1    |  1   |     1
     2      |  95   |    2    |  1   |     1      ← 并列
     3      |  90   |    3    |  3   |     2      ← RANK跳号
     4      |  85   |    4    |  4   |     3

ROW_NUMBER: 连续编号（1,2,3,4）
RANK: 并列同名次，跳号（1,1,3,4）
DENSE_RANK: 并列同名次，不跳号（1,1,2,3）
*/
```

### 2.2 百分位排名

```sql
SELECT
    student_id,
    score,
    PERCENT_RANK() OVER (ORDER BY score DESC) AS percent_rank,
    CUME_DIST() OVER (ORDER BY score DESC) AS cumulative_dist,
    NTILE(4) OVER (ORDER BY score DESC) AS quartile
FROM scores;

/*
PERCENT_RANK: (rank - 1) / (total_rows - 1)
CUME_DIST: 累积分布，前面有多少比例的行
NTILE(n): 分成n组
*/
```

---

## 3. 聚合窗口函数

### 3.1 移动聚合

```sql
-- 销售数据
CREATE TABLE daily_sales (
    sale_date DATE,
    amount NUMERIC
);

-- 7日移动平均
SELECT
    sale_date,
    amount,
    AVG(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7d,
    SUM(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_sum_7d
FROM daily_sales
ORDER BY sale_date;

-- 累计求和
SELECT
    sale_date,
    amount,
    SUM(amount) OVER (ORDER BY sale_date) AS cumulative_sum
FROM daily_sales;
```

### 3.2 窗口范围

```sql
-- ROWS: 物理行
ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING      -- 前3行到后3行
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- 从开始到当前
ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING  -- 从当前到结束

-- RANGE: 逻辑范围（值范围）
RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW

-- 示例
SELECT
    sale_date,
    amount,
    SUM(amount) OVER (
        ORDER BY sale_date
        RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW
    ) AS sum_last_7_days
FROM daily_sales;
```

---

## 4. 分析函数

### 4.1 LEAD/LAG

```sql
-- 获取前后行数据
SELECT
    sale_date,
    amount,
    LAG(amount) OVER (ORDER BY sale_date) AS prev_day_amount,
    LEAD(amount) OVER (ORDER BY sale_date) AS next_day_amount,
    amount - LAG(amount) OVER (ORDER BY sale_date) AS day_over_day_change
FROM daily_sales;

-- 计算增长率
SELECT
    sale_date,
    amount,
    LAG(amount, 7) OVER (ORDER BY sale_date) AS amount_7d_ago,
    ROUND((amount - LAG(amount, 7) OVER (ORDER BY sale_date)) * 100.0 /
          NULLIF(LAG(amount, 7) OVER (ORDER BY sale_date), 0), 2) AS growth_rate
FROM daily_sales;
```

### 4.2 FIRST_VALUE/LAST_VALUE

```sql
-- 获取窗口内第一个/最后一个值
SELECT
    employee_id,
    department,
    salary,
    FIRST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
    ) AS highest_salary_in_dept,
    LAST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS lowest_salary_in_dept
FROM employees;

-- 注意LAST_VALUE的窗口范围
```

### 4.3 NTH_VALUE

```sql
-- 获取第N个值
SELECT
    product_id,
    review_date,
    rating,
    NTH_VALUE(rating, 1) OVER w AS first_rating,
    NTH_VALUE(rating, 2) OVER w AS second_rating,
    NTH_VALUE(rating, 3) OVER w AS third_rating
FROM product_reviews
WINDOW w AS (PARTITION BY product_id ORDER BY review_date)
ORDER BY product_id, review_date;
```

---

## 5. 实战案例

### 5.1 Top-N每组

```sql
-- 每个部门薪资Top 3
WITH ranked AS (
    SELECT
        employee_id,
        name,
        department,
        salary,
        RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
    FROM employees
)
SELECT * FROM ranked
WHERE rank <= 3
ORDER BY department, rank;
```

### 5.2 去重（保留最新）

```sql
-- 去重，保留每个用户最新记录
WITH ranked AS (
    SELECT
        *,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) AS rn
    FROM user_events
)
DELETE FROM user_events
WHERE (user_id, created_at) IN (
    SELECT user_id, created_at FROM ranked WHERE rn > 1
);

-- 或使用DISTINCT ON
SELECT DISTINCT ON (user_id)
    user_id,
    event_type,
    created_at
FROM user_events
ORDER BY user_id, created_at DESC;
```

### 5.3 同比环比

```sql
-- 销售同比环比分析
SELECT
    sale_date,
    amount,
    -- 环比（Day over Day）
    LAG(amount, 1) OVER (ORDER BY sale_date) AS prev_day,
    amount - LAG(amount, 1) OVER (ORDER BY sale_date) AS dod_change,
    -- 同比（Year over Year）
    LAG(amount, 365) OVER (ORDER BY sale_date) AS same_day_last_year,
    amount - LAG(amount, 365) OVER (ORDER BY sale_date) AS yoy_change
FROM daily_sales
ORDER BY sale_date DESC;
```

### 5.4 缺口检测

```sql
-- 找出数值跳跃
WITH gaps AS (
    SELECT
        id,
        LAG(id) OVER (ORDER BY id) AS prev_id,
        id - LAG(id) OVER (ORDER BY id) AS gap
    FROM sequential_table
)
SELECT * FROM gaps
WHERE gap > 1;  -- 跳号
```

### 5.5 连续登录天数

```sql
-- 计算用户连续登录天数
WITH login_groups AS (
    SELECT
        user_id,
        login_date,
        login_date - ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY login_date
        )::int AS group_id
    FROM user_logins
)
SELECT
    user_id,
    MIN(login_date) AS streak_start,
    MAX(login_date) AS streak_end,
    COUNT(*) AS consecutive_days
FROM login_groups
GROUP BY user_id, group_id
HAVING COUNT(*) >= 7  -- 至少连续7天
ORDER BY consecutive_days DESC;
```

---

## 6. 性能优化

### 6.1 窗口定义复用

```sql
-- Bad: 重复定义
SELECT
    employee_id,
    AVG(salary) OVER (PARTITION BY department ORDER BY hire_date),
    SUM(salary) OVER (PARTITION BY department ORDER BY hire_date),
    COUNT(*) OVER (PARTITION BY department ORDER BY hire_date)
FROM employees;

-- Good: WINDOW子句
SELECT
    employee_id,
    AVG(salary) OVER w,
    SUM(salary) OVER w,
    COUNT(*) OVER w
FROM employees
WINDOW w AS (PARTITION BY department ORDER BY hire_date);
```

### 6.2 避免不必要的排序

```sql
-- 如果数据已按某列排序，利用这个顺序
CREATE INDEX idx_sales_date ON daily_sales (sale_date);

-- 查询会利用索引顺序
SELECT
    sale_date,
    amount,
    SUM(amount) OVER (ORDER BY sale_date) AS cumsum
FROM daily_sales;
-- 无需额外排序
```

---

## 7. PostgreSQL 18改进

### 7.1 增量排序优化

```sql
-- 部分有序数据的窗口函数
CREATE INDEX idx_emp_dept_salary ON employees (department, salary);

SELECT
    employee_id,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC, hire_date) AS rank
FROM employees;

/*
PostgreSQL 18: Incremental Sort
├─ department已有序（来自索引）
├─ 只需对salary DESC, hire_date排序
└─ 内存使用-80%
*/
```

---

## 8. 复杂案例

### 8.1 会话分析

```sql
-- 将用户访问分组为会话（超过30分钟算新会话）
WITH session_starts AS (
    SELECT
        user_id,
        visit_time,
        CASE
            WHEN visit_time - LAG(visit_time) OVER (
                PARTITION BY user_id ORDER BY visit_time
            ) > INTERVAL '30 minutes'
            OR LAG(visit_time) OVER (
                PARTITION BY user_id ORDER BY visit_time
            ) IS NULL
            THEN 1
            ELSE 0
        END AS is_session_start
    FROM user_visits
),
sessions AS (
    SELECT
        user_id,
        visit_time,
        SUM(is_session_start) OVER (
            PARTITION BY user_id ORDER BY visit_time
        ) AS session_id
    FROM session_starts
)
SELECT
    user_id,
    session_id,
    MIN(visit_time) AS session_start,
    MAX(visit_time) AS session_end,
    COUNT(*) AS page_views,
    MAX(visit_time) - MIN(visit_time) AS session_duration
FROM sessions
GROUP BY user_id, session_id
ORDER BY user_id, session_id;
```

### 8.2 漏斗分析

```sql
-- 转化漏斗
WITH funnel AS (
    SELECT
        user_id,
        MAX(CASE WHEN event_type = 'visit' THEN 1 ELSE 0 END) AS visited,
        MAX(CASE WHEN event_type = 'view_product' THEN 1 ELSE 0 END) AS viewed,
        MAX(CASE WHEN event_type = 'add_cart' THEN 1 ELSE 0 END) AS added_cart,
        MAX(CASE WHEN event_type = 'purchase' THEN 1 ELSE 0 END) AS purchased
    FROM user_events
    WHERE event_date = CURRENT_DATE
    GROUP BY user_id
)
SELECT
    SUM(visited) AS step1_visit,
    SUM(viewed) AS step2_view,
    SUM(added_cart) AS step3_cart,
    SUM(purchased) AS step4_purchase,
    ROUND(SUM(viewed) * 100.0 / NULLIF(SUM(visited), 0), 2) AS conversion_1_to_2,
    ROUND(SUM(added_cart) * 100.0 / NULLIF(SUM(viewed), 0), 2) AS conversion_2_to_3,
    ROUND(SUM(purchased) * 100.0 / NULLIF(SUM(added_cart), 0), 2) AS conversion_3_to_4
FROM funnel;
```

---

**完成**: PostgreSQL 18窗口函数完整实战
**字数**: ~8,000字
**涵盖**: 排名、聚合、分析函数、实战案例、性能优化
