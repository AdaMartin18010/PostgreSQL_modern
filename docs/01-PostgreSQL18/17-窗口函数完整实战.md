# PostgreSQL 18 窗口函数完整实战

## 1. 窗口函数基础

### 1.1 语法结构

```sql
-- 性能测试：基础语法示例（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    employee_id,
    department,
    salary,
    AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_in_dept
FROM employees;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '窗口函数查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 2. 排名函数

### 2.1 RANK vs DENSE_RANK vs ROW_NUMBER

```sql
-- 性能测试：创建测试表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS scores (
    student_id INT,
    subject VARCHAR(50),
    score INT
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表scores已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

BEGIN;
INSERT INTO scores VALUES
(1, 'Math', 95),
(2, 'Math', 95),
(3, 'Math', 90),
(4, 'Math', 85)
ON CONFLICT DO NOTHING;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '插入数据失败: %', SQLERRM;
        ROLLBACK;
        RAISE;


SELECT
    student_id,
    score,
    ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num,
    RANK() OVER (ORDER BY score DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank
FROM scores;

/*
 student_id | score | row_num | rank | dense_rank
------------+-------+---------+------+------------
     1      |  95   |    1    |  1   |     1
     2      |  95   |    2    |  1   |     1      ← 并列
     3      |  90   |    3    |  3   |     2      ← RANK跳号
     4      |  85   |    4    |  4   |     3

ROW_NUMBER: 连续编号（1,2,3,4）
RANK: 并列同名次，跳号（1,1,3,4）
DENSE_RANK: 并列同名次，不跳号（1,1,2,3）
*/
```

### 2.2 百分位排名

```sql
-- 性能测试：百分位排名（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    student_id,
    score,
    PERCENT_RANK() OVER (ORDER BY score DESC) AS percent_rank,
    CUME_DIST() OVER (ORDER BY score DESC) AS cumulative_dist,
    NTILE(4) OVER (ORDER BY score DESC) AS quartile
FROM scores;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '百分位排名查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
PERCENT_RANK: (rank - 1) / (total_rows - 1)
CUME_DIST: 累积分布，前面有多少比例的行
NTILE(n): 分成n组
*/

```

---

## 3. 聚合窗口函数

### 3.1 移动聚合

```sql
-- 性能测试：销售数据（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS daily_sales (
    sale_date DATE,
    amount NUMERIC
);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表daily_sales已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：7日移动平均（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sale_date,
    amount,
    AVG(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7d,
    SUM(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_sum_7d
FROM daily_sales
ORDER BY sale_date;

-- 累计求和
SELECT
    sale_date,
    amount,
    SUM(amount) OVER (ORDER BY sale_date) AS cumulative_sum
FROM daily_sales;
```

### 3.2 窗口范围

```sql
-- 性能测试：窗口范围（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sale_date,
    amount,
    SUM(amount) OVER (
        ORDER BY sale_date
        RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW
    ) AS sum_last_7_days
FROM daily_sales;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '窗口范围查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 4. 分析函数

### 4.1 LEAD/LAG

```sql
-- 性能测试：获取前后行数据（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sale_date,
    amount,
    LAG(amount) OVER (ORDER BY sale_date) AS prev_day_amount,
    LEAD(amount) OVER (ORDER BY sale_date) AS next_day_amount,
    amount - LAG(amount) OVER (ORDER BY sale_date) AS day_over_day_change
FROM daily_sales;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'LEAD/LAG查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：计算增长率（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sale_date,
    amount,
    LAG(amount, 7) OVER (ORDER BY sale_date) AS amount_7d_ago,
    ROUND((amount - LAG(amount, 7) OVER (ORDER BY sale_date)) * 100.0 /
          NULLIF(LAG(amount, 7) OVER (ORDER BY sale_date), 0), 2) AS growth_rate
FROM daily_sales;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '增长率计算失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 4.2 FIRST_VALUE/LAST_VALUE

```sql
-- 性能测试：获取窗口内第一个/最后一个值（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    employee_id,
    department,
    salary,
    FIRST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
    ) AS highest_salary_in_dept,
    LAST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS lowest_salary_in_dept
FROM employees;

-- 注意LAST_VALUE的窗口范围
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'FIRST_VALUE/LAST_VALUE查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 4.3 NTH_VALUE

```sql
-- 性能测试：获取第N个值（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    product_id,
    review_date,
    rating,
    NTH_VALUE(rating, 1) OVER w AS first_rating,
    NTH_VALUE(rating, 2) OVER w AS second_rating,
    NTH_VALUE(rating, 3) OVER w AS third_rating
FROM product_reviews
WINDOW w AS (PARTITION BY product_id ORDER BY review_date)
ORDER BY product_id, review_date;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'NTH_VALUE查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 5. 实战案例

### 5.1 Top-N每组

```sql
-- 性能测试：每个部门薪资Top 3（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH ranked AS (
    SELECT
        employee_id,
        name,
        department,
        salary,
        RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
    FROM employees
)
SELECT * FROM ranked
WHERE rank <= 3
ORDER BY department, rank;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Top-N查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 5.2 去重（保留最新）

```sql
-- 性能测试：去重，保留每个用户最新记录（带错误处理）
BEGIN;
WITH ranked AS (
    SELECT
        *,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) AS rn
    FROM user_events
)
DELETE FROM user_events
WHERE (user_id, created_at) IN (
    SELECT user_id, created_at FROM ranked WHERE rn > 1
);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '去重删除失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：或使用DISTINCT ON（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT DISTINCT ON (user_id)
    user_id,
    event_type,
    created_at
FROM user_events
ORDER BY user_id, created_at DESC;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'DISTINCT ON查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 5.3 同比环比

```sql
-- 性能测试：销售同比环比分析（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sale_date,
    amount,
    -- 环比（Day over Day）
    LAG(amount, 1) OVER (ORDER BY sale_date) AS prev_day,
    amount - LAG(amount, 1) OVER (ORDER BY sale_date) AS dod_change,
    -- 同比（Year over Year）
    LAG(amount, 365) OVER (ORDER BY sale_date) AS same_day_last_year,
    amount - LAG(amount, 365) OVER (ORDER BY sale_date) AS yoy_change
FROM daily_sales
ORDER BY sale_date DESC;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '同比环比分析失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 5.4 缺口检测

```sql
-- 性能测试：找出数值跳跃（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH gaps AS (
    SELECT
        id,
        LAG(id) OVER (ORDER BY id) AS prev_id,
        id - LAG(id) OVER (ORDER BY id) AS gap
    FROM sequential_table
)
SELECT * FROM gaps
WHERE gap > 1;  -- 跳号
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '缺口检测失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 5.5 连续登录天数

```sql
-- 性能测试：计算用户连续登录天数（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH login_groups AS (
    SELECT
        user_id,
        login_date,
        login_date - ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY login_date
        )::int AS group_id
    FROM user_logins
)
SELECT
    user_id,
    MIN(login_date) AS streak_start,
    MAX(login_date) AS streak_end,
    COUNT(*) AS consecutive_days
FROM login_groups
GROUP BY user_id, group_id
HAVING COUNT(*) >= 7  -- 至少连续7天
ORDER BY consecutive_days DESC;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '连续登录天数计算失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 6. 性能优化

### 6.1 窗口定义复用

```sql
-- 性能测试：Bad: 重复定义（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    employee_id,
    AVG(salary) OVER (PARTITION BY department ORDER BY hire_date),
    SUM(salary) OVER (PARTITION BY department ORDER BY hire_date),
    COUNT(*) OVER (PARTITION BY department ORDER BY hire_date)
FROM employees;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '重复定义窗口查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：Good: WINDOW子句（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    employee_id,
    AVG(salary) OVER w,
    SUM(salary) OVER w,
    COUNT(*) OVER w
FROM employees
WINDOW w AS (PARTITION BY department ORDER BY hire_date);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'WINDOW子句查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 6.2 避免不必要的排序

```sql
-- 性能测试：如果数据已按某列排序，利用这个顺序（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_sales_date ON daily_sales (sale_date);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_sales_date已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查询会利用索引顺序（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    sale_date,
    amount,
    SUM(amount) OVER (ORDER BY sale_date) AS cumsum
FROM daily_sales;
-- 无需额外排序
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '窗口函数查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 7. PostgreSQL 18改进

### 7.1 增量排序优化

```sql
-- 性能测试：部分有序数据的窗口函数（带错误处理）
BEGIN;
CREATE INDEX IF NOT EXISTS idx_emp_dept_salary ON employees (department, salary);
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '索引idx_emp_dept_salary已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建索引失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：增量排序优化（带性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    employee_id,
    department,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC, hire_date) AS rank
FROM employees;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '增量排序查询失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

/*
PostgreSQL 18: Incremental Sort
├─ department已有序（来自索引）
├─ 只需对salary DESC, hire_date排序
└─ 内存使用-80%
*/

```

---

## 8. 复杂案例

### 8.1 会话分析

```sql
-- 性能测试：将用户访问分组为会话（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH session_starts AS (
    SELECT
        user_id,
        visit_time,
        CASE
            WHEN visit_time - LAG(visit_time) OVER (
                PARTITION BY user_id ORDER BY visit_time
            ) > INTERVAL '30 minutes'
            OR LAG(visit_time) OVER (
                PARTITION BY user_id ORDER BY visit_time
            ) IS NULL
            THEN 1
            ELSE 0
        END AS is_session_start
    FROM user_visits
),
sessions AS (
    SELECT
        user_id,
        visit_time,
        SUM(is_session_start) OVER (
            PARTITION BY user_id ORDER BY visit_time
        ) AS session_id
    FROM session_starts
)
SELECT
    user_id,
    session_id,
    MIN(visit_time) AS session_start,
    MAX(visit_time) AS session_end,
    COUNT(*) AS page_views,
    MAX(visit_time) - MIN(visit_time) AS session_duration
FROM sessions
GROUP BY user_id, session_id
ORDER BY user_id, session_id;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '会话分析失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 8.2 漏斗分析

```sql
-- 性能测试：转化漏斗（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
WITH funnel AS (
    SELECT
        user_id,
        MAX(CASE WHEN event_type = 'visit' THEN 1 ELSE 0 END) AS visited,
        MAX(CASE WHEN event_type = 'view_product' THEN 1 ELSE 0 END) AS viewed,
        MAX(CASE WHEN event_type = 'add_cart' THEN 1 ELSE 0 END) AS added_cart,
        MAX(CASE WHEN event_type = 'purchase' THEN 1 ELSE 0 END) AS purchased
    FROM user_events
    WHERE event_date = CURRENT_DATE
    GROUP BY user_id
)
SELECT
    SUM(visited) AS step1_visit,
    SUM(viewed) AS step2_view,
    SUM(added_cart) AS step3_cart,
    SUM(purchased) AS step4_purchase,
    ROUND(SUM(viewed) * 100.0 / NULLIF(SUM(visited), 0), 2) AS conversion_1_to_2,
    ROUND(SUM(added_cart) * 100.0 / NULLIF(SUM(viewed), 0), 2) AS conversion_2_to_3,
    ROUND(SUM(purchased) * 100.0 / NULLIF(SUM(added_cart), 0), 2) AS conversion_3_to_4
FROM funnel;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '漏斗分析失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

**完成**: PostgreSQL 18窗口函数完整实战
**字数**: ~8,000字
**涵盖**: 排名、聚合、分析函数、实战案例、性能优化
