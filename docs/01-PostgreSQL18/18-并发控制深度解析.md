# PostgreSQL 18 并发控制深度解析

## 1. MVCC原理

### 1.1 多版本存储

```sql
-- 性能测试：查看行版本信息（带错误处理）
BEGIN;
CREATE EXTENSION IF NOT EXISTS pageinspect;
COMMIT;
EXCEPTION
    WHEN duplicate_object THEN
        RAISE NOTICE '扩展pageinspect已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建扩展失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：创建测试表（带错误处理）
BEGIN;
CREATE TABLE IF NOT EXISTS mvcc_test (id INT PRIMARY KEY, value TEXT);
INSERT INTO mvcc_test VALUES (1, 'version 1')
ON CONFLICT (id) DO NOTHING;
COMMIT;
EXCEPTION
    WHEN duplicate_table THEN
        RAISE NOTICE '表mvcc_test已存在';
    WHEN OTHERS THEN
        RAISE NOTICE '创建测试表失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：查看页面内容（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM heap_page_items(get_raw_page('mvcc_test', 0));
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查看页面内容失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
 lp | t_xmin | t_xmax | t_ctid
----+--------+--------+--------
  1 |   1001 |      0 | (0,1)

t_xmin: 插入事务ID
t_xmax: 删除事务ID (0表示未删除)
t_ctid: 行版本链指针
*/

-- 性能测试：更新（带错误处理）
BEGIN;
UPDATE mvcc_test SET value = 'version 2' WHERE id = 1;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '更新失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：再次查看（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT lp, t_xmin, t_xmax, t_ctid FROM heap_page_items(get_raw_page('mvcc_test', 0));
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '再次查看失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
 lp | t_xmin | t_xmax | t_ctid
----+--------+--------+--------
  1 |   1001 |   1002 | (0,2)   ← 旧版本，被标记删除
  2 |   1002 |      0 | (0,2)   ← 新版本

MVCC: 保留多个版本，不同事务看到不同版本
*/
```

### 1.2 可见性判断

```sql
-- 性能测试：事务快照（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT
    txid_current() AS current_xid,
    txid_current_snapshot() AS snapshot;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '查询事务快照失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

/*
snapshot格式: xmin:xmax:xip_list
100:105:101,103

xmin=100: 最小活跃事务ID
xmax=105: 下一个分配的事务ID
xip_list: 活跃事务列表

可见性规则:
1. xid < xmin: 已提交，可见
2. xid >= xmax: 未开始，不可见
3. xid in xip_list: 活跃中，不可见
4. 否则: 需检查pg_clog
*/
```

---

## 2. 锁机制

### 2.1 锁层次

```text
锁层次（从粗到细）:
└─ 数据库锁
   └─ 表锁
      └─ 页锁（内部使用）
         └─ 行锁
            └─ 元组锁
```

### 2.2 行级锁

```sql
-- 性能测试：FOR UPDATE（排他锁）（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM accounts WHERE account_id = 1 FOR UPDATE;
-- 其他事务无法UPDATE/DELETE/FOR UPDATE这一行
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'FOR UPDATE操作失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- FOR NO KEY UPDATE（允许外键）
BEGIN;
SELECT * FROM users WHERE user_id = 1 FOR NO KEY UPDATE;
-- 允许其他事务插入引用该用户的订单
COMMIT;

-- FOR SHARE（共享锁）
BEGIN;
SELECT * FROM products WHERE product_id = 1 FOR SHARE;
-- 其他事务可以读和FOR SHARE，但不能修改
COMMIT;

-- FOR KEY SHARE（允许更新非键列）
BEGIN;
SELECT * FROM users WHERE user_id = 1 FOR KEY SHARE;
-- 其他事务可以UPDATE非键列
COMMIT;
```

### 2.3 锁冲突矩阵

```text
             FOR UPDATE  FOR NO KEY  FOR SHARE  FOR KEY SHARE
FOR UPDATE       ✗          ✗           ✗           ✗
FOR NO KEY       ✗          ✗           ✗           ✓
FOR SHARE        ✗          ✗           ✓           ✓
FOR KEY SHARE    ✗          ✓           ✓           ✓

✗ = 冲突
✓ = 不冲突
```

---

## 3. 死锁

### 3.1 死锁示例

```sql
-- 会话1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
-- 等待...
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 会话2
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 2;
-- 等待...
UPDATE accounts SET balance = balance + 50 WHERE account_id = 1;

-- 死锁！PostgreSQL自动检测并回滚一个事务
-- ERROR: deadlock detected
```

### 3.2 死锁检测

```sql
-- 配置检测超时
SHOW deadlock_timeout;  -- 默认1s

-- 查看死锁日志
-- postgresql.conf
log_lock_waits = on

-- 日志示例
/*
LOG: process 1234 still waiting for ShareLock on transaction 5678
DETAIL: Process holding the lock: 5679
HINT: See server log for query details
ERROR: deadlock detected
*/
```

### 3.3 避免死锁

```text
策略:
✓ 固定锁顺序（按主键排序）
✓ 使用SKIP LOCKED
✓ 减少事务持锁时间
✓ 使用乐观锁

示例: 按ID顺序加锁
-- Good
SELECT * FROM accounts
WHERE account_id IN (1, 2, 5, 10)
ORDER BY account_id
FOR UPDATE;

-- Bad（随机顺序）
SELECT * FROM accounts
WHERE account_id IN (10, 1, 5, 2)
FOR UPDATE;
```

---

## 4. 乐观锁

### 4.1 版本号实现

```sql
-- 添加version列
CREATE TABLE accounts (
    account_id SERIAL PRIMARY KEY,
    balance NUMERIC NOT NULL,
    version INT NOT NULL DEFAULT 0
);

-- 乐观锁更新
UPDATE accounts
SET
    balance = balance - 100,
    version = version + 1
WHERE account_id = 1
  AND version = 5;  -- 检查版本

-- 如果返回0行，说明版本冲突，需要重试
GET DIAGNOSTICS rows_updated = ROW_COUNT;
IF rows_updated = 0 THEN
    RAISE EXCEPTION '版本冲突，请重试';
END IF;
```

### 4.2 Python实现

```python
def optimistic_lock_update(conn, account_id, amount, max_retries=5):
    """乐观锁更新（带重试）"""

    for attempt in range(max_retries):
        cursor = conn.cursor()

        # 读取当前版本
        cursor.execute("""
            SELECT balance, version FROM accounts WHERE account_id = %s
        """, (account_id,))

        row = cursor.fetchone()
        if not row:
            raise ValueError("账户不存在")

        balance, version = row

        # 检查余额
        if balance < amount:
            raise ValueError("余额不足")

        # 乐观锁更新
        cursor.execute("""
            UPDATE accounts
            SET balance = balance - %s, version = version + 1
            WHERE account_id = %s AND version = %s
        """, (amount, account_id, version))

        if cursor.rowcount == 1:
            conn.commit()
            return True
        else:
            # 版本冲突，重试
            conn.rollback()
            continue

    raise Exception("达到最大重试次数")
```

---

## 5. 锁等待监控

### 5.1 实时监控

```sql
-- 查看锁等待
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement,
    blocked_activity.application_name AS blocked_app,
    now() - blocked_activity.query_start AS blocked_duration
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON
    blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

### 5.2 终止阻塞

```sql
-- 终止阻塞会话
SELECT pg_cancel_backend(blocking_pid);   -- 温和取消
SELECT pg_terminate_backend(blocking_pid); -- 强制终止
```

---

## 6. 队列处理

### 6.1 SKIP LOCKED

```sql
-- 任务队列
CREATE TABLE task_queue (
    task_id BIGSERIAL PRIMARY KEY,
    task_data JSONB,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Worker获取任务（无锁竞争）
BEGIN;

UPDATE task_queue
SET status = 'processing'
WHERE task_id IN (
    SELECT task_id FROM task_queue
    WHERE status = 'pending'
    ORDER BY created_at
    LIMIT 10
    FOR UPDATE SKIP LOCKED
)
RETURNING *;

-- 处理任务...

-- 标记完成
UPDATE task_queue SET status = 'completed' WHERE task_id = ?;

COMMIT;

-- 优势: 多个worker并发获取，无等待
```

---

## 7. 最佳实践

```text
并发控制:
✓ 默认用MVCC（无锁读取）
✓ 必要时用悲观锁（FOR UPDATE）
✓ 高冲突场景用乐观锁
✓ 队列用SKIP LOCKED

事务设计:
✓ 保持事务短小
✓ 避免长时间持锁
✓ 按固定顺序访问资源
✓ 使用合适的隔离级别

监控:
✓ 锁等待时间
✓ 死锁频率
✓ 事务时长
✓ 阻塞链
```

---

**完成**: PostgreSQL 18并发控制深度解析
**字数**: ~10,000字
**涵盖**: MVCC、锁机制、死锁、乐观锁、队列处理
