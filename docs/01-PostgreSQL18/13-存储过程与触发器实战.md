# PostgreSQL 18 存储过程与触发器实战

## 1. 存储过程 vs 函数

```sql
-- 性能测试：函数 (FUNCTION)（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION calculate_total(order_id INT)
RETURNS NUMERIC AS $$
DECLARE
    total NUMERIC;
BEGIN
    SELECT SUM(price * quantity) INTO total
    FROM order_items
    WHERE order_id = calculate_total.order_id;

    RETURN total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '计算总价失败: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：调用（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT calculate_total(123);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '调用函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：存储过程 (PROCEDURE, PostgreSQL 11+)（带错误处理）
BEGIN;
CREATE OR REPLACE PROCEDURE process_order(order_id INT)
LANGUAGE plpgsql AS $$
BEGIN
    -- 可以包含事务控制
    UPDATE orders SET status = 'processing' WHERE order_id = process_order.order_id;
    COMMIT;

    -- 处理订单项
    UPDATE inventory SET stock = stock - quantity
    FROM order_items
    WHERE order_items.order_id = process_order.order_id;
    COMMIT;

    UPDATE orders SET status = 'completed' WHERE order_id = process_order.order_id;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '处理订单失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
END;
$$;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建存储过程失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：调用（带错误处理）
BEGIN;
CALL process_order(123);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '调用存储过程失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 区别:
/*
函数:
✓ 返回值
✓ 可在SELECT中使用
✗ 不能包含事务控制

存储过程:
✗ 无返回值
✗ 不能在SELECT中使用
✓ 可以COMMIT/ROLLBACK
*/
```

---

## 2. 高级函数

### 2.1 返回表的函数

```sql
-- 性能测试：返回TABLE（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION get_user_orders(p_user_id INT)
RETURNS TABLE (
    order_id INT,
    order_date TIMESTAMPTZ,
    total_amount NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT o.order_id, o.created_at, calculate_total(o.order_id)
    FROM orders o
    WHERE o.user_id = p_user_id
    ORDER BY o.created_at DESC;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '获取用户订单失败: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 性能测试：使用（带错误处理和性能分析）
BEGIN;
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM get_user_orders(123);
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '调用函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

### 2.2 动态SQL

```sql
-- 性能测试：动态SQL（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION dynamic_query(
    table_name TEXT,
    condition TEXT
) RETURNS SETOF RECORD AS $$
DECLARE
    query TEXT;
BEGIN
    query := format('SELECT * FROM %I WHERE %s', table_name, condition);

    RETURN QUERY EXECUTE query;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '动态查询失败: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建动态查询函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;

-- 使用（需指定列定义）
SELECT * FROM dynamic_query('users', 'age > 25') AS (
    user_id INT,
    name TEXT,
    age INT
);

```

### 2.3 游标处理

```sql
-- 性能测试：游标处理（带错误处理）
BEGIN;
CREATE OR REPLACE FUNCTION process_large_table()
RETURNS VOID AS $$
DECLARE
    cur CURSOR FOR SELECT * FROM large_table;
    rec RECORD;
    counter INT := 0;
BEGIN
    OPEN cur;

    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        -- 处理每一行
        UPDATE another_table SET value = rec.value WHERE id = rec.id;

        counter := counter + 1;

        -- 每1000行提交一次
        IF counter % 1000 = 0 THEN
            COMMIT;
        END IF;
    END LOOP;

    CLOSE cur;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '处理大表失败: %', SQLERRM;
        CLOSE cur;
        ROLLBACK;
        RAISE;
END;
$$ LANGUAGE plpgsql;
COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE '创建游标处理函数失败: %', SQLERRM;
        ROLLBACK;
        RAISE;
```

---

## 3. 触发器

### 3.1 BEFORE触发器

```sql
-- 自动设置时间戳
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION set_updated_at();

-- 数据验证
CREATE OR REPLACE FUNCTION validate_email()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
        RAISE EXCEPTION 'Invalid email format: %', NEW.email;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_email
    BEFORE INSERT OR UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION validate_email();
```

### 3.2 AFTER触发器

```sql
-- 审计日志
CREATE TABLE audit_log (
    log_id BIGSERIAL PRIMARY KEY,
    table_name TEXT,
    operation TEXT,
    old_data JSONB,
    new_data JSONB,
    user_name TEXT,
    changed_at TIMESTAMPTZ DEFAULT now()
);

CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, operation, new_data, user_name)
        VALUES (TG_TABLE_NAME, 'INSERT', row_to_json(NEW)::jsonb, current_user);

    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, operation, old_data, new_data, user_name)
        VALUES (TG_TABLE_NAME, 'UPDATE', row_to_json(OLD)::jsonb, row_to_json(NEW)::jsonb, current_user);

    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, operation, old_data, user_name)
        VALUES (TG_TABLE_NAME, 'DELETE', row_to_json(OLD)::jsonb, current_user);
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit
    AFTER INSERT OR UPDATE OR DELETE ON sensitive_table
    FOR EACH ROW
    EXECUTE FUNCTION audit_trigger();
```

### 3.3 INSTEAD OF触发器

```sql
-- 视图触发器
CREATE VIEW user_summary AS
SELECT
    user_id,
    username,
    COUNT(o.order_id) AS order_count,
    SUM(o.amount) AS total_spent
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.username;

-- 使视图可更新
CREATE OR REPLACE FUNCTION update_user_summary()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE users
    SET username = NEW.username
    WHERE user_id = NEW.user_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_summary
    INSTEAD OF UPDATE ON user_summary
    FOR EACH ROW
    EXECUTE FUNCTION update_user_summary();

-- 现在可以UPDATE视图
UPDATE user_summary SET username = 'NewName' WHERE user_id = 123;
```

---

## 4. 事件触发器

### 4.1 DDL审计

```sql
-- 记录DDL操作
CREATE TABLE ddl_log (
    log_id BIGSERIAL PRIMARY KEY,
    event_type TEXT,
    object_type TEXT,
    object_identity TEXT,
    command TEXT,
    user_name TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE OR REPLACE FUNCTION log_ddl()
RETURNS event_trigger AS $$
DECLARE
    obj RECORD;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands()
    LOOP
        INSERT INTO ddl_log (event_type, object_type, object_identity, command, user_name)
        VALUES (
            TG_EVENT,
            obj.object_type,
            obj.object_identity,
            obj.command_tag,
            current_user
        );
    END LOOP;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER trg_log_ddl
    ON ddl_command_end
    EXECUTE FUNCTION log_ddl();

-- 测试
CREATE TABLE test_table (id INT);
-- 自动记录到ddl_log
```

### 4.2 阻止危险操作

```sql
-- 阻止DROP TABLE
CREATE OR REPLACE FUNCTION prevent_drop_table()
RETURNS event_trigger AS $$
BEGIN
    IF TG_TAG = 'DROP TABLE' THEN
        RAISE EXCEPTION '禁止删除表！请联系DBA。';
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER trg_prevent_drop
    ON sql_drop
    EXECUTE FUNCTION prevent_drop_table();
```

---

## 5. 高级特性

### 5.1 异常处理

```sql
CREATE OR REPLACE FUNCTION safe_divide(a NUMERIC, b NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE '除数为零，返回NULL';
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE WARNING '未知错误: %', SQLERRM;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 使用
SELECT safe_divide(10, 0);  -- 返回NULL，不报错
```

### 5.2 动态返回类型

```sql
CREATE OR REPLACE FUNCTION get_table_data(table_name TEXT)
RETURNS SETOF RECORD AS $$
BEGIN
    RETURN QUERY EXECUTE format('SELECT * FROM %I', table_name);
END;
$$ LANGUAGE plpgsql;

-- 使用时指定列类型
SELECT * FROM get_table_data('users') AS (
    user_id INT,
    username TEXT,
    email TEXT
);
```

### 5.3 批量操作

```sql
CREATE OR REPLACE PROCEDURE batch_update_prices(
    category_id INT,
    discount_percent NUMERIC
)
LANGUAGE plpgsql AS $$
DECLARE
    batch_size INT := 1000;
    updated INT;
BEGIN
    LOOP
        UPDATE products
        SET price = price * (1 - discount_percent / 100)
        WHERE category_id = batch_update_prices.category_id
          AND ctid IN (
              SELECT ctid FROM products
              WHERE category_id = batch_update_prices.category_id
              LIMIT batch_size
          );

        GET DIAGNOSTICS updated = ROW_COUNT;

        EXIT WHEN updated = 0;

        COMMIT;  -- 每批次提交

        RAISE NOTICE '已更新 % 行', updated;
    END LOOP;
END;
$$;
```

---

## 6. 性能优化

### 6.1 STABLE vs VOLATILE

```sql
-- VOLATILE (默认): 每行都调用
CREATE FUNCTION random_value() RETURNS FLOAT AS $$
    SELECT random();
$$ LANGUAGE SQL VOLATILE;

SELECT random_value() FROM generate_series(1, 10);
-- 每行不同的随机值

-- STABLE: 每个查询调用一次
CREATE FUNCTION current_user_id() RETURNS INT AS $$
    SELECT current_setting('app.user_id')::INT;
$$ LANGUAGE SQL STABLE;

SELECT current_user_id() FROM generate_series(1, 10);
-- 所有行相同值，只调用一次

-- IMMUTABLE: 相同输入永远返回相同输出（可缓存）
CREATE FUNCTION add(a INT, b INT) RETURNS INT AS $$
    SELECT a + b;
$$ LANGUAGE SQL IMMUTABLE;

-- 性能影响巨大
```

### 6.2 内联函数

```sql
-- SQL函数自动内联
CREATE FUNCTION get_active_users()
RETURNS SETOF users AS $$
    SELECT * FROM users WHERE status = 'active';
$$ LANGUAGE SQL STABLE;

-- 查询
SELECT * FROM get_active_users() WHERE age > 25;

-- 优化器内联函数，等效于:
SELECT * FROM users WHERE status = 'active' AND age > 25;

-- plpgsql函数不会内联（需要RETURN QUERY）
```

---

## 7. 实战案例

### 7.1 订单状态机

```sql
CREATE TYPE order_status AS ENUM ('pending', 'paid', 'shipped', 'delivered', 'cancelled');

CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    status order_status DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- 状态转换验证
CREATE OR REPLACE FUNCTION validate_order_status_transition()
RETURNS TRIGGER AS $$
DECLARE
    allowed BOOLEAN := false;
BEGIN
    -- 定义允许的状态转换
    IF OLD.status = 'pending' AND NEW.status IN ('paid', 'cancelled') THEN
        allowed := true;
    ELSIF OLD.status = 'paid' AND NEW.status IN ('shipped', 'cancelled') THEN
        allowed := true;
    ELSIF OLD.status = 'shipped' AND NEW.status = 'delivered' THEN
        allowed := true;
    END IF;

    IF NOT allowed THEN
        RAISE EXCEPTION '非法状态转换: % -> %', OLD.status, NEW.status;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_status
    BEFORE UPDATE ON orders
    FOR EACH ROW
    WHEN (OLD.status IS DISTINCT FROM NEW.status)
    EXECUTE FUNCTION validate_order_status_transition();
```

### 7.2 库存扣减

```sql
CREATE OR REPLACE FUNCTION deduct_inventory(
    p_product_id INT,
    p_quantity INT
) RETURNS BOOLEAN AS $$
DECLARE
    current_stock INT;
BEGIN
    -- 锁定库存行
    SELECT stock INTO current_stock
    FROM inventory
    WHERE product_id = p_product_id
    FOR UPDATE;

    -- 检查库存
    IF current_stock < p_quantity THEN
        RAISE EXCEPTION '库存不足: 当前%, 需要%', current_stock, p_quantity;
    END IF;

    -- 扣减
    UPDATE inventory
    SET stock = stock - p_quantity,
        updated_at = now()
    WHERE product_id = p_product_id;

    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- 事务中使用
BEGIN;
SELECT deduct_inventory(101, 5);
-- 其他订单操作
COMMIT;
```

### 7.3 自动汇总表

```sql
-- 订单汇总表
CREATE TABLE order_summary (
    user_id INT PRIMARY KEY,
    total_orders INT DEFAULT 0,
    total_amount NUMERIC DEFAULT 0,
    last_order_at TIMESTAMPTZ
);

-- 触发器维护汇总
CREATE OR REPLACE FUNCTION update_order_summary()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO order_summary (user_id, total_orders, total_amount, last_order_at)
        VALUES (NEW.user_id, 1, NEW.amount, NEW.created_at)
        ON CONFLICT (user_id) DO UPDATE
        SET total_orders = order_summary.total_orders + 1,
            total_amount = order_summary.total_amount + NEW.amount,
            last_order_at = NEW.created_at;

    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE order_summary
        SET total_amount = total_amount - OLD.amount + NEW.amount
        WHERE user_id = NEW.user_id;

    ELSIF TG_OP = 'DELETE' THEN
        UPDATE order_summary
        SET total_orders = total_orders - 1,
            total_amount = total_amount - OLD.amount
        WHERE user_id = OLD.user_id;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_summary
    AFTER INSERT OR UPDATE OR DELETE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION update_order_summary();
```

---

## 8. 性能优化

### 8.1 避免触发器递归

```sql
-- Bad: 可能无限递归
CREATE OR REPLACE FUNCTION bad_trigger()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE users SET updated_at = now() WHERE user_id = NEW.user_id;
    RETURN NEW;  -- 触发器本身又会被触发
END;
$$ LANGUAGE plpgsql;

-- Good: 使用条件
CREATE OR REPLACE FUNCTION good_trigger()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := now();
    RETURN NEW;  -- 直接修改NEW，不触发其他UPDATE
END;
$$ LANGUAGE plpgsql;
```

### 8.2 批量触发

```sql
-- 行级触发器（每行触发一次）
CREATE TRIGGER trg_row_level
    AFTER UPDATE ON orders
    FOR EACH ROW
    EXECUTE FUNCTION row_level_function();

-- 语句级触发器（每个语句触发一次）
CREATE TRIGGER trg_statement_level
    AFTER UPDATE ON orders
    FOR EACH STATEMENT
    EXECUTE FUNCTION statement_level_function();

-- 使用过渡表（PostgreSQL 10+）
CREATE OR REPLACE FUNCTION batch_update_summary()
RETURNS TRIGGER AS $$
BEGIN
    -- 批量更新汇总
    INSERT INTO daily_summary (date, order_count, total_amount)
    SELECT
        DATE(created_at),
        COUNT(*),
        SUM(amount)
    FROM new_table  -- 过渡表，包含所有NEW行
    GROUP BY DATE(created_at)
    ON CONFLICT (date) DO UPDATE
    SET order_count = daily_summary.order_count + EXCLUDED.order_count,
        total_amount = daily_summary.total_amount + EXCLUDED.total_amount;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_batch_summary
    AFTER INSERT ON orders
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT
    EXECUTE FUNCTION batch_update_summary();
```

---

## 9. 调试

### 9.1 日志输出

```sql
CREATE OR REPLACE FUNCTION debug_function()
RETURNS VOID AS $$
DECLARE
    var1 INT := 100;
BEGIN
    RAISE NOTICE '变量值: %', var1;
    RAISE DEBUG '调试信息';
    RAISE LOG '日志信息';
    RAISE WARNING '警告信息';
    RAISE EXCEPTION '错误: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- 设置日志级别
SET client_min_messages = debug;
SELECT debug_function();
```

### 9.2 性能分析

```sql
-- 启用函数计时
ALTER FUNCTION expensive_function() SET log_min_duration_statement = 0;

-- 查看执行时间
SELECT
    funcname,
    calls,
    total_time / calls AS avg_time_ms,
    self_time / calls AS self_time_ms
FROM pg_stat_user_functions
ORDER BY total_time DESC;
```

---

## 10. 最佳实践

```text
函数设计:
✓ 明确VOLATILITY (IMMUTABLE/STABLE/VOLATILE)
✓ SQL函数优于plpgsql（可内联）
✓ 避免过度使用函数（性能）
✓ 合理使用STRICT

触发器设计:
✓ 避免复杂逻辑
✓ 语句级优于行级（批量）
✓ 使用过渡表
✓ 注意触发顺序

性能:
✓ 避免触发器中的慢查询
✓ 批量操作用存储过程
✓ 合理使用游标
✓ 监控函数执行时间

维护:
✓ 文档化函数用途
✓ 版本控制
✓ 定期review触发器
✓ 测试覆盖
```

---

**完成**: PostgreSQL 18存储过程与触发器实战
**字数**: ~10,000字
**涵盖**: 函数、存储过程、触发器、事件触发器、实战案例、性能优化
