# PostgreSQL分布式事务实战

## 1. 两阶段提交（2PC）

### 1.1 基础实现

```sql
-- 准备阶段
-- 节点A
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
PREPARE TRANSACTION 'tx_001_node_a';

-- 节点B
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
PREPARE TRANSACTION 'tx_001_node_b';

-- 提交阶段
-- 协调者确认所有节点准备成功后
COMMIT PREPARED 'tx_001_node_a';  -- 节点A
COMMIT PREPARED 'tx_001_node_b';  -- 节点B

-- 或回滚
ROLLBACK PREPARED 'tx_001_node_a';
ROLLBACK PREPARED 'tx_001_node_b';
```

### 1.2 Python实现

```python
import psycopg2
import uuid

class TwoPhaseCommitCoordinator:
    """2PC协调器"""

    def __init__(self, connections: dict):
        self.connections = connections  # {'node_a': conn_a, 'node_b': conn_b}

    def distributed_transaction(self, operations: dict):
        """
        执行分布式事务

        Args:
            operations: {'node_a': 'UPDATE ...', 'node_b': 'UPDATE ...'}
        """

        tx_id = str(uuid.uuid4())
        prepared_nodes = []

        try:
            # 阶段1: 准备
            for node_name, sql in operations.items():
                conn = self.connections[node_name]
                cursor = conn.cursor()

                cursor.execute("BEGIN;")
                cursor.execute(sql)
                cursor.execute(f"PREPARE TRANSACTION '{tx_id}_{node_name}';")

                prepared_nodes.append(node_name)
                print(f"✓ {node_name} 准备完成")

            # 阶段2: 提交
            for node_name in prepared_nodes:
                conn = self.connections[node_name]
                cursor = conn.cursor()
                cursor.execute(f"COMMIT PREPARED '{tx_id}_{node_name}';")
                print(f"✓ {node_name} 提交完成")

            return True

        except Exception as e:
            # 回滚所有已准备的节点
            print(f"错误: {e}, 回滚事务")

            for node_name in prepared_nodes:
                try:
                    conn = self.connections[node_name]
                    cursor = conn.cursor()
                    cursor.execute(f"ROLLBACK PREPARED '{tx_id}_{node_name}';")
                    print(f"✓ {node_name} 回滚完成")
                except Exception as rollback_error:
                    print(f"✗ {node_name} 回滚失败: {rollback_error}")

            return False

# 使用
coordinator = TwoPhaseCommitCoordinator({
    'node_a': psycopg2.connect("host=node-a ..."),
    'node_b': psycopg2.connect("host=node-b ...")
})

success = coordinator.distributed_transaction({
    'node_a': "UPDATE accounts SET balance = balance - 100 WHERE account_id = 1",
    'node_b': "UPDATE accounts SET balance = balance + 100 WHERE account_id = 2"
})
```

### 1.3 监控prepared事务

```sql
-- 查看prepared事务
SELECT
    gid,
    prepared,
    owner,
    database,
    transaction AS xid
FROM pg_prepared_xacts;

-- 清理僵尸prepared事务
-- 如果协调者崩溃，需要手动处理
ROLLBACK PREPARED 'orphan_tx_id';
```

---

## 2. Saga模式

### 2.1 补偿事务

```sql
-- 订单处理Saga
-- 步骤1: 创建订单
INSERT INTO orders (user_id, amount) VALUES (123, 999.99) RETURNING order_id;
-- 补偿: DELETE FROM orders WHERE order_id = ?

-- 步骤2: 扣减库存
UPDATE inventory SET stock = stock - 1 WHERE product_id = 456;
-- 补偿: UPDATE inventory SET stock = stock + 1 WHERE product_id = 456

-- 步骤3: 扣款
UPDATE accounts SET balance = balance - 999.99 WHERE user_id = 123;
-- 补偿: UPDATE accounts SET balance = balance + 999.99 WHERE user_id = 123

-- 如果任一步骤失败，执行所有已完成步骤的补偿操作
```

### 2.2 Saga协调器

```python
class SagaCoordinator:
    """Saga协调器"""

    def __init__(self, conn):
        self.conn = conn
        self.steps = []

    def add_step(self, forward_func, compensate_func):
        """添加Saga步骤"""
        self.steps.append({
            'forward': forward_func,
            'compensate': compensate_func
        })

    def execute(self):
        """执行Saga"""

        completed_steps = []

        try:
            # 正向执行
            for i, step in enumerate(self.steps):
                print(f"执行步骤 {i+1}/{len(self.steps)}")
                step['forward'](self.conn)
                completed_steps.append(step)

            return True

        except Exception as e:
            print(f"步骤失败: {e}")
            print(f"开始补偿...")

            # 反向补偿
            for step in reversed(completed_steps):
                try:
                    step['compensate'](self.conn)
                    print(f"✓ 补偿成功")
                except Exception as comp_error:
                    print(f"✗ 补偿失败: {comp_error}")

            return False

# 使用
saga = SagaCoordinator(conn)

# 定义步骤
saga.add_step(
    forward=lambda c: c.cursor().execute("INSERT INTO orders ..."),
    compensate=lambda c: c.cursor().execute("DELETE FROM orders WHERE order_id = ?")
)

saga.add_step(
    forward=lambda c: c.cursor().execute("UPDATE inventory SET stock = stock - 1 ..."),
    compensate=lambda c: c.cursor().execute("UPDATE inventory SET stock = stock + 1 ...")
)

# 执行
success = saga.execute()
```

---

## 3. 最终一致性

### 3.1 异步消息队列

```sql
-- 外发事件表
CREATE TABLE outbox_events (
    event_id BIGSERIAL PRIMARY KEY,
    aggregate_id BIGINT,
    event_type VARCHAR(100),
    event_data JSONB,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT now(),
    processed_at TIMESTAMPTZ
);

CREATE INDEX ON outbox_events (status, created_at) WHERE status = 'pending';

-- 本地事务+发布事件
BEGIN;

-- 业务操作
INSERT INTO orders (user_id, amount) VALUES (123, 999.99) RETURNING order_id;

-- 发布事件
INSERT INTO outbox_events (aggregate_id, event_type, event_data)
VALUES (currval('orders_order_id_seq'), 'OrderCreated', '{"amount": 999.99}');

COMMIT;

-- 后台Worker发送事件到消息队列
SELECT * FROM outbox_events WHERE status = 'pending' ORDER BY created_at FOR UPDATE SKIP LOCKED LIMIT 100;
-- 发送到Kafka/RabbitMQ
-- UPDATE outbox_events SET status = 'sent', processed_at = now() WHERE event_id = ?
```

---

## 4. FDW（外部数据包装器）

### 4.1 postgres_fdw

```sql
-- 安装
CREATE EXTENSION postgres_fdw;

-- 创建外部服务器
CREATE SERVER remote_db
FOREIGN DATA WRAPPER postgres_fdw
OPTIONS (host 'remote-host', port '5432', dbname 'remotedb');

-- 创建用户映射
CREATE USER MAPPING FOR postgres
SERVER remote_db
OPTIONS (user 'remote_user', password 'password');

-- 导入外部表
IMPORT FOREIGN SCHEMA public
FROM SERVER remote_db
INTO public;

-- 或单独创建
CREATE FOREIGN TABLE remote_users (
    user_id INT,
    username VARCHAR(100),
    email VARCHAR(255)
)
SERVER remote_db
OPTIONS (schema_name 'public', table_name 'users');

-- 跨库查询
SELECT
    local.order_id,
    remote.username
FROM orders local
JOIN remote_users remote ON local.user_id = remote.user_id;

-- 跨库写入
INSERT INTO remote_users (username, email) VALUES ('alice', 'alice@example.com');
```

### 4.2 性能优化

```sql
-- 启用远程聚合下推
ALTER SERVER remote_db OPTIONS (ADD extensions 'postgres_fdw');

-- 启用远程排序
ALTER SERVER remote_db OPTIONS (ADD use_remote_estimate 'true');

-- 批量fetch
ALTER FOREIGN TABLE remote_users OPTIONS (ADD fetch_size '10000');
```

---

## 5. 幂等性设计

### 5.1 幂等操作

```sql
-- 使用唯一约束保证幂等
CREATE TABLE payments (
    payment_id BIGSERIAL PRIMARY KEY,
    idempotency_key VARCHAR(100) UNIQUE NOT NULL,
    order_id BIGINT,
    amount NUMERIC,
    status VARCHAR(20),
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 幂等插入
INSERT INTO payments (idempotency_key, order_id, amount, status)
VALUES ('pay_abc123', 789, 99.99, 'success')
ON CONFLICT (idempotency_key) DO NOTHING;

-- 客户端重试安全
-- 相同idempotency_key多次调用，只会插入一次
```

---

## 6. 分布式锁

### 6.1 PostgreSQL advisory lock

```sql
-- 获取锁
SELECT pg_try_advisory_lock(12345);  -- true表示获取成功

-- 业务逻辑
UPDATE limited_resource SET ...;

-- 释放锁
SELECT pg_advisory_unlock(12345);

-- 会话级锁（连接断开自动释放）
SELECT pg_advisory_lock(12345);  -- 阻塞直到获取

-- 事务级锁
SELECT pg_try_advisory_xact_lock(12345);  -- 事务结束自动释放
```

### 6.2 分布式锁实现

```python
class DistributedLock:
    """基于PostgreSQL的分布式锁"""

    def __init__(self, conn, lock_id: int, timeout: int = 30):
        self.conn = conn
        self.lock_id = lock_id
        self.timeout = timeout
        self.acquired = False

    def __enter__(self):
        cursor = self.conn.cursor()

        # 尝试获取锁（带超时）
        cursor.execute(f"SET lock_timeout = '{self.timeout}s';")
        cursor.execute("SELECT pg_advisory_lock(%s);", (self.lock_id,))

        self.acquired = True
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.acquired:
            cursor = self.conn.cursor()
            cursor.execute("SELECT pg_advisory_unlock(%s);", (self.lock_id,))

# 使用
with DistributedLock(conn, 12345):
    # 临界区代码
    cursor.execute("UPDATE global_counter SET value = value + 1;")
    conn.commit()
```

---

## 7. 容量规划

### 7.1 数据增长预测

```sql
-- 查询历史增长趋势
WITH daily_growth AS (
    SELECT
        DATE(created_at) AS date,
        COUNT(*) AS new_records,
        SUM(COUNT(*)) OVER (ORDER BY DATE(created_at)) AS cumulative
    FROM large_table
    WHERE created_at > CURRENT_DATE - INTERVAL '90 days'
    GROUP BY DATE(created_at)
),
growth_stats AS (
    SELECT
        AVG(new_records) AS avg_daily,
        STDDEV(new_records) AS stddev_daily,
        MAX(new_records) AS max_daily
    FROM daily_growth
)
SELECT
    avg_daily,
    avg_daily * 30 AS projected_monthly,
    avg_daily * 365 AS projected_yearly,
    max_daily AS peak_daily
FROM growth_stats;

-- 存储预测
WITH current_size AS (
    SELECT pg_total_relation_size('large_table') AS bytes
),
growth AS (
    SELECT 125000 AS daily_rows  -- 从上面查询获取
)
SELECT
    pg_size_pretty(bytes) AS current_size,
    pg_size_pretty(bytes + (daily_rows * 30 * avg_row_size)) AS size_1_month,
    pg_size_pretty(bytes + (daily_rows * 365 * avg_row_size)) AS size_1_year
FROM current_size, growth,
     (SELECT pg_relation_size('large_table') / NULLIF(COUNT(*), 0) AS avg_row_size
      FROM large_table) row_size;
```

---

## 8. 跨数据库查询

### 8.1 dblink

```sql
CREATE EXTENSION dblink;

-- 跨库查询
SELECT * FROM dblink(
    'host=remote-server port=5432 dbname=remotedb user=postgres password=xxx',
    'SELECT user_id, username FROM users'
) AS remote_users(user_id INT, username TEXT);

-- 跨库JOIN
SELECT
    local.order_id,
    remote.username
FROM orders local
JOIN dblink(
    'host=remote-server ...',
    'SELECT user_id, username FROM users'
) AS remote(user_id INT, username TEXT)
ON local.user_id = remote.user_id;

-- 跨库写入
SELECT * FROM dblink_exec(
    'host=remote-server ...',
    'INSERT INTO users (username) VALUES (''alice'')'
);
```

---

## 9. 分片策略

### 9.1 应用层分片

```python
class ShardRouter:
    """分片路由器"""

    def __init__(self, shard_connections: list):
        self.shards = shard_connections
        self.shard_count = len(shard_connections)

    def get_shard(self, user_id: int):
        """根据user_id路由到分片"""
        shard_id = user_id % self.shard_count
        return self.shards[shard_id]

    def execute(self, user_id: int, sql: str, params=None):
        """在正确的分片执行"""
        conn = self.get_shard(user_id)
        cursor = conn.cursor()
        cursor.execute(sql, params)
        return cursor.fetchall()

    def broadcast(self, sql: str):
        """广播到所有分片"""
        results = []
        for conn in self.shards:
            cursor = conn.cursor()
            cursor.execute(sql)
            results.extend(cursor.fetchall())
        return results

# 使用
router = ShardRouter([
    psycopg2.connect("host=shard-0 ..."),
    psycopg2.connect("host=shard-1 ..."),
    psycopg2.connect("host=shard-2 ..."),
    psycopg2.connect("host=shard-3 ...")
])

# 单分片查询
result = router.execute(123, "SELECT * FROM users WHERE user_id = %s", (123,))

# 广播查询（聚合）
results = router.broadcast("SELECT COUNT(*) FROM users")
total = sum(r[0] for r in results)
```

---

## 10. 最终一致性验证

### 10.1 数据对账

```sql
-- 对账任务表
CREATE TABLE reconciliation_tasks (
    task_id BIGSERIAL PRIMARY KEY,
    source_system VARCHAR(50),
    target_system VARCHAR(50),
    entity_type VARCHAR(50),
    check_date DATE,
    status VARCHAR(20) DEFAULT 'pending',
    inconsistencies JSONB,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 对账函数
CREATE OR REPLACE FUNCTION reconcile_accounts(check_date DATE)
RETURNS TABLE (
    account_id BIGINT,
    source_balance NUMERIC,
    computed_balance NUMERIC,
    difference NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH computed AS (
        SELECT
            account_id,
            COALESCE(SUM(
                CASE
                    WHEN transaction_type = 'credit' THEN amount
                    WHEN transaction_type = 'debit' THEN -amount
                END
            ), 0) AS balance
        FROM transactions
        WHERE DATE(created_at) <= check_date
        GROUP BY account_id
    )
    SELECT
        a.account_id,
        a.balance AS source_balance,
        c.balance AS computed_balance,
        a.balance - c.balance AS difference
    FROM accounts a
    LEFT JOIN computed c ON a.account_id = c.account_id
    WHERE ABS(a.balance - COALESCE(c.balance, 0)) > 0.01;
END;
$$ LANGUAGE plpgsql;

-- 执行对账
SELECT * FROM reconcile_accounts(CURRENT_DATE);
```

---

**完成**: PostgreSQL分布式事务实战
**字数**: ~10,000字
**涵盖**: 2PC、Saga、最终一致性、FDW、分片、分布式锁、对账
