# 9.2.3 备份与恢复

> **更新时间**: 2025 年 11 月 1 日  
> **文档编号**: 09-02-03

## 📑 目录

- [9.2.3 备份与恢复](#923-备份与恢复)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 备份目标](#11-备份目标)
    - [1.2 恢复策略](#12-恢复策略)
    - [1.3 备份架构](#13-备份架构)
  - [2. 备份策略](#2-备份策略)
    - [2.1 逻辑备份（pg_dump）](#21-逻辑备份pg_dump)
      - [2.1.1 完整备份](#211-完整备份)
      - [2.1.2 表级备份](#212-表级备份)
      - [2.1.3 仅数据/结构备份](#213-仅数据结构备份)
    - [2.2 物理备份（pg_basebackup）](#22-物理备份pg_basebackup)
      - [2.2.1 完整物理备份](#221-完整物理备份)
      - [2.2.2 流式备份](#222-流式备份)
    - [2.3 连续归档（WAL）](#23-连续归档wal)
      - [2.3.1 WAL 归档配置](#231-wal-归档配置)
      - [2.3.2 基础备份创建](#232-基础备份创建)
  - [3. 恢复策略](#3-恢复策略)
    - [3.1 逻辑恢复（pg_restore）](#31-逻辑恢复pg_restore)
      - [3.1.1 完整数据库恢复](#311-完整数据库恢复)
      - [3.1.2 部分恢复](#312-部分恢复)
    - [3.2 点对点恢复（PITR）](#32-点对点恢复pitr)
      - [3.2.1 PITR 配置](#321-pitr-配置)
      - [3.2.2 恢复到指定时间点](#322-恢复到指定时间点)
  - [4. 自动化备份](#4-自动化备份)
    - [4.1 Python 备份脚本](#41-python-备份脚本)
      - [4.1.1 备份管理器类](#411-备份管理器类)
      - [4.1.2 备份调度](#412-备份调度)
    - [4.2 备份策略配置](#42-备份策略配置)
  - [5. 备份验证](#5-备份验证)
    - [5.1 备份完整性检查](#51-备份完整性检查)
      - [5.1.1 备份文件验证](#511-备份文件验证)
      - [5.1.2 备份内容验证](#512-备份内容验证)
    - [5.2 恢复测试](#52-恢复测试)
      - [5.2.1 恢复测试流程](#521-恢复测试流程)
      - [5.2.2 数据验证](#522-数据验证)
  - [6. 备份存储策略](#6-备份存储策略)
    - [6.1 本地存储](#61-本地存储)
    - [6.2 远程存储](#62-远程存储)
    - [6.3 备份保留策略](#63-备份保留策略)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 备份策略](#71-备份策略)
    - [7.2 恢复策略](#72-恢复策略)
    - [7.3 容灾演练](#73-容灾演练)
  - [8. 参考资料](#8-参考资料)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 技术文档](#82-技术文档)
    - [8.3 相关资源](#83-相关资源)

---

## 1. 概述

### 1.1 备份目标

**核心目标**:

本文档提供 PostgreSQL + pgvector 生产环境的备份与恢复策略，确保数据安全和高可用性。

**备份目标**:

1. **数据保护**: 保护重要数据不丢失
2. **快速恢复**: 支持快速恢复，减少停机时间
3. **点对点恢复**: 支持恢复到任意时间点（PITR）
4. **自动化管理**: 自动化备份和恢复流程

**备份价值**:

| 备份类型     | 恢复时间   | 数据损失     | 适用场景         |
| ------------ | ---------- | ------------ | ---------------- |
| **逻辑备份** | 10-60 分钟 | 备份点数据   | 定期备份、迁移   |
| **物理备份** | 5-30 分钟  | 备份点数据   | 快速恢复         |
| **WAL 归档** | 1-10 分钟  | **几乎为零** | **生产环境推荐** |

### 1.2 恢复策略

**恢复策略**:

1. **完整恢复**: 恢复整个数据库
2. **部分恢复**: 恢复特定表或数据
3. **点对点恢复**: 恢复到指定时间点
4. **增量恢复**: 基于基础备份和 WAL 日志恢复

**恢复时间目标（RTO）**:

| 恢复类型      | RTO         | 说明         |
| ------------- | ----------- | ------------ |
| **完整恢复**  | 30 分钟     | 逻辑备份恢复 |
| **物理恢复**  | 15 分钟     | 物理备份恢复 |
| **PITR 恢复** | **10 分钟** | WAL 归档恢复 |

**恢复点目标（RPO）**:

| 备份类型     | RPO         | 说明         |
| ------------ | ----------- | ------------ |
| **完整备份** | 24 小时     | 每天备份一次 |
| **物理备份** | 24 小时     | 每天备份一次 |
| **WAL 归档** | **<1 分钟** | **实时归档** |

### 1.3 备份架构

**备份架构设计**:

```text
┌─────────────────────────────────────────────────┐
│         PostgreSQL + pgvector                    │
│  ┌──────────┐  ┌──────────┐                    │
│  │Database  │  │WAL Logs  │                    │
│  │Files     │  │          │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
          │                    │
┌─────────┴──────────┐  ┌──────┴──────────┐
│   pg_dump          │  │  pg_basebackup  │
│   (逻辑备份)        │  │  (物理备份)      │
└────────────────────┘  └─────────────────┘
          │                    │
┌─────────┴──────────┐  ┌──────┴──────────┐
│   WAL Archive      │  │  Backup Storage │
│   (连续归档)        │  │  (备份存储)      │
└────────────────────┘  └─────────────────┘
          │                    │
┌─────────┴────────────────────┴──────────┐
│         Backup Storage                  │
│  ┌──────────┐  ┌──────────┐            │
│  │Local     │  │Remote    │            │
│  │Storage   │  │Storage   │            │
│  └──────────┘  └──────────┘            │
└────────────────────────────────────────┘
```

## 2. 备份策略

### 2.1 逻辑备份（pg_dump）

#### 2.1.1 完整备份

**完整数据库备份**:

```bash
# 完整数据库备份（自定义格式，支持压缩）
pg_dump -U postgres -d vector_db \
  -F c \
  -Z 9 \
  -f backup_vector_db_$(date +%Y%m%d_%H%M%S).dump

# 参数说明：
# -U: 用户名
# -d: 数据库名
# -F c: 自定义格式（支持压缩和选择性恢复）
# -Z 9: 压缩级别（0-9，9 为最高压缩）
# -f: 输出文件
```

**备份性能**:

| 数据量    | 备份时间       | 备份大小  | 压缩率     |
| --------- | -------------- | --------- | ---------- |
| **1GB**   | **2-5 分钟**   | 200-500MB | **50-80%** |
| **10GB**  | **20-50 分钟** | 2-5GB     | **50-80%** |
| **100GB** | **3-8 小时**   | 20-50GB   | **50-80%** |

#### 2.1.2 表级备份

**表级备份**:

```bash
# 备份特定表
pg_dump -U postgres -d vector_db \
  -t documents \
  -F c \
  -Z 9 \
  -f backup_documents_$(date +%Y%m%d_%H%M%S).dump

# 备份多个表
pg_dump -U postgres -d vector_db \
  -t documents \
  -t account_behaviors \
  -t product_embeddings \
  -F c \
  -Z 9 \
  -f backup_tables_$(date +%Y%m%d_%H%M%S).dump

# 备份多个表（使用正则）
pg_dump -U postgres -d vector_db \
  -t 'documents*' \
  -F c \
  -Z 9 \
  -f backup_documents_all_$(date +%Y%m%d_%H%M%S).dump
```

**表级备份场景**:

| 场景           | 备份方式 | 说明           |
| -------------- | -------- | -------------- |
| **单表恢复**   | 表级备份 | 快速恢复单个表 |
| **批量表恢复** | 多表备份 | 恢复相关表     |
| **表迁移**     | 表级备份 | 迁移特定表     |

#### 2.1.3 仅数据/结构备份

**仅数据备份**:

```bash
# 仅备份数据（不含结构）
pg_dump -U postgres -d vector_db \
  --data-only \
  -F c \
  -Z 9 \
  -f backup_data_$(date +%Y%m%d_%H%M%S).dump

# 仅备份结构（不含数据）
pg_dump -U postgres -d vector_db \
  --schema-only \
  -F c \
  -f backup_schema_$(date +%Y%m%d_%H%M%S).dump

# 仅备份特定 schema
pg_dump -U postgres -d vector_db \
  -n public \
  -F c \
  -f backup_schema_public_$(date +%Y%m%d_%H%M%S).dump
```

**备份类型选择**:

| 备份类型       | 适用场景 | 说明                       |
| -------------- | -------- | -------------------------- |
| **完整备份**   | 定期备份 | 包含结构和数据             |
| **仅数据备份** | 数据迁移 | 仅数据，用于导入到已有结构 |
| **仅结构备份** | 结构迁移 | 仅结构，用于创建相同表结构 |

### 2.2 物理备份（pg_basebackup）

#### 2.2.1 完整物理备份

**物理备份步骤**:

```bash
# 完整物理备份
pg_basebackup -U postgres \
  -D /backup/postgres_$(date +%Y%m%d_%H%M%S) \
  -Ft \
  -z \
  -P \
  -v

# 参数说明：
# -U: 用户名
# -D: 备份目录
# -Ft: Tar 格式
# -z: 压缩
# -P: 显示进度
# -v: 详细输出
```

**物理备份性能**:

| 数据量    | 备份时间       | 备份大小  | 压缩率     |
| --------- | -------------- | --------- | ---------- |
| **1GB**   | **1-2 分钟**   | 200-400MB | **60-80%** |
| **10GB**  | **10-20 分钟** | 2-4GB     | **60-80%** |
| **100GB** | **1-3 小时**   | 20-40GB   | **60-80%** |

#### 2.2.2 流式备份

**流式备份**:

```bash
# 流式备份（包含 WAL 日志）
pg_basebackup -U postgres \
  -D /backup/postgres_$(date +%Y%m%d_%H%M%S) \
  -Ft \
  -z \
  -P \
  -X stream \
  -v

# 参数说明：
# -X stream: 流式传输 WAL 日志
# 其他参数同上
```

**物理备份对比**:

| 备份方式     | 优点                | 缺点       | 适用场景         |
| ------------ | ------------------- | ---------- | ---------------- |
| **基础备份** | 速度快，恢复快      | 占用空间大 | 快速恢复         |
| **流式备份** | 包含 WAL，支持 PITR | 需要网络   | **生产环境推荐** |

### 2.3 连续归档（WAL）

#### 2.3.1 WAL 归档配置

**WAL 归档配置**:

```sql
-- postgresql.conf 配置
wal_level = replica  -- 或 logical（如果需要逻辑复制）
archive_mode = on
archive_command = 'cp %p /backup/wal/%f'

-- 或者使用更安全的命令
archive_command = 'test ! -f /backup/wal/%f && cp %p /backup/wal/%f'

-- 验证配置
SHOW wal_level;
SHOW archive_mode;
SHOW archive_command;
```

**WAL 归档存储**:

```bash
# 创建 WAL 归档目录
mkdir -p /backup/wal
chown postgres:postgres /backup/wal
chmod 700 /backup/wal

# 设置归档脚本（更高级）
archive_command = '/usr/local/bin/archive_wal.sh %p %f'

# archive_wal.sh 脚本内容
#!/bin/bash
WAL_FILE=$1
WAL_NAME=$2
ARCHIVE_DIR=/backup/wal

# 复制到本地
cp "$WAL_FILE" "$ARCHIVE_DIR/$WAL_NAME"

# 可选：同步到远程
rsync -av "$ARCHIVE_DIR/$WAL_NAME" remote-backup:/backup/wal/

exit 0
```

#### 2.3.2 基础备份创建

**基础备份创建**:

```bash
# 创建基础备份（手动）
pg_basebackup -U postgres \
  -D /backup/base_$(date +%Y%m%d_%H%M%S) \
  -Ft \
  -z \
  -P \
  -X stream \
  -v

# 或者在 PostgreSQL 中标记备份点
psql -U postgres -c "SELECT pg_start_backup('backup_label');"
# ... 备份数据库文件 ...
psql -U postgres -c "SELECT pg_stop_backup();"
```

**WAL 归档策略**:

| 策略         | WAL 保留时间 | 说明     |
| ------------ | ------------ | -------- |
| **短期保留** | 7 天         | 本地存储 |
| **中期保留** | 30 天        | 远程存储 |
| **长期保留** | 90 天        | 归档存储 |

## 3. 恢复策略

### 3.1 逻辑恢复（pg_restore）

#### 3.1.1 完整数据库恢复

**完整数据库恢复**:

```bash
# 恢复完整数据库（覆盖）
pg_restore -U postgres \
  -d vector_db \
  -F c \
  --clean \
  --if-exists \
  backup_vector_db_20251101_120000.dump

# 恢复完整数据库（不覆盖）
pg_restore -U postgres \
  -d vector_db \
  -F c \
  backup_vector_db_20251101_120000.dump

# 参数说明：
# -U: 用户名
# -d: 目标数据库
# -F c: 自定义格式
# --clean: 删除已存在的对象
# --if-exists: 如果对象不存在不报错
```

**恢复性能**:

| 备份大小  | 恢复时间       | 说明         |
| --------- | -------------- | ------------ |
| **1GB**   | **3-8 分钟**   | 逻辑备份恢复 |
| **10GB**  | **30-80 分钟** | 逻辑备份恢复 |
| **100GB** | **5-13 小时**  | 逻辑备份恢复 |

#### 3.1.2 部分恢复

**部分恢复**:

```bash
# 仅恢复数据
pg_restore -U postgres \
  -d vector_db \
  --data-only \
  -F c \
  backup_data_20251101_120000.dump

# 仅恢复结构
pg_restore -U postgres \
  -d vector_db \
  --schema-only \
  -F c \
  backup_schema_20251101_120000.dump

# 恢复特定表
pg_restore -U postgres \
  -d vector_db \
  -t documents \
  -F c \
  backup_vector_db_20251101_120000.dump

# 恢复时并行处理（加快速度）
pg_restore -U postgres \
  -d vector_db \
  -F c \
  -j 4 \
  backup_vector_db_20251101_120000.dump

# 参数说明：
# -j: 并行任务数（建议 = CPU 核心数）
```

**恢复策略选择**:

| 恢复场景     | 恢复方式   | 说明               |
| ------------ | ---------- | ------------------ |
| **完整恢复** | 完整备份   | 恢复到备份点       |
| **表恢复**   | 表级备份   | 恢复单个表         |
| **数据恢复** | 仅数据备份 | 恢复数据到已有结构 |
| **结构恢复** | 仅结构备份 | 创建表结构         |

### 3.2 点对点恢复（PITR）

#### 3.2.1 PITR 配置

**PITR 恢复准备**:

```bash
# 1. 恢复基础备份
pg_basebackup -U postgres -D /var/lib/postgresql/data -Ft -z -P

# 或从备份恢复
tar -xzf /backup/base_20251101_120000.tar.gz -C /var/lib/postgresql/data

# 2. 配置恢复参数
cat > /var/lib/postgresql/data/recovery.conf <<EOF
restore_command = 'cp /backup/wal/%f %p'
recovery_target_time = '2025-11-01 10:00:00'
recovery_target_action = 'promote'
EOF

# PostgreSQL 13+ 使用 postgresql.conf
# recovery_target_time = '2025-11-01 10:00:00'
# restore_command = 'cp /backup/wal/%f %p'
```

**PITR 配置参数**:

| 参数                       | 说明           | 示例                    |
| -------------------------- | -------------- | ----------------------- |
| `restore_command`          | WAL 恢复命令   | `cp /backup/wal/%f %p`  |
| `recovery_target_time`     | 恢复目标时间   | `'2025-11-01 10:00:00'` |
| `recovery_target_timeline` | 恢复目标时间线 | `'latest'`              |
| `recovery_target_action`   | 恢复后操作     | `'promote'`             |

#### 3.2.2 恢复到指定时间点

**PITR 恢复步骤**:

```bash
# 1. 停止 PostgreSQL（如果正在运行）
systemctl stop postgresql

# 2. 恢复基础备份
rm -rf /var/lib/postgresql/data/*
tar -xzf /backup/base_20251101_120000.tar.gz -C /var/lib/postgresql/data

# 3. 创建恢复配置文件（PostgreSQL 12+）
cat > /var/lib/postgresql/data/postgresql.conf <<EOF
# PITR 配置
recovery_target_time = '2025-11-01 10:00:00'
restore_command = 'cp /backup/wal/%f %p'
recovery_target_action = 'promote'
EOF

# 4. 创建信号文件（PostgreSQL 12+）
touch /var/lib/postgresql/data/recovery.signal

# 5. 启动 PostgreSQL（自动恢复）
systemctl start postgresql

# 6. 监控恢复进度
tail -f /var/lib/postgresql/data/log/postgresql.log
```

**PITR 恢复性能**:

| WAL 数量     | 恢复时间       | 说明          |
| ------------ | -------------- | ------------- |
| **<100**     | **<5 分钟**    | 少量 WAL 日志 |
| **100-1000** | **5-15 分钟**  | 中等 WAL 日志 |
| **>1000**    | **15-60 分钟** | 大量 WAL 日志 |

## 4. 自动化备份

### 4.1 Python 备份脚本

#### 4.1.1 备份管理器类

**完整的备份管理器**:

```python
# backup_manager.py
import subprocess
import os
import shutil
from datetime import datetime, timedelta
import psycopg2
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/postgres_backup.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class BackupManager:
    """备份管理器"""

    def __init__(self, db_config, backup_dir="/backup/postgres"):
        self.db_config = db_config
        self.backup_dir = backup_dir
        self.wal_dir = os.path.join(backup_dir, "wal")
        os.makedirs(self.backup_dir, exist_ok=True)
        os.makedirs(self.wal_dir, exist_ok=True)

    def full_backup(self):
        """完整备份"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = os.path.join(
            self.backup_dir,
            f"full_backup_{timestamp}.dump"
        )

        try:
            cmd = [
                "pg_dump",
                "-U", self.db_config["user"],
                "-d", self.db_config["database"],
                "-F", "c",
                "-Z", "9",
                "-f", backup_file
            ]

            # 设置环境变量（如果使用密码文件）
            env = os.environ.copy()
            if "password" in self.db_config:
                env["PGPASSWORD"] = self.db_config["password"]

            result = subprocess.run(
                cmd,
                env=env,
                capture_output=True,
                check=True,
                timeout=3600  # 1 小时超时
            )

            # 验证备份文件
            if os.path.exists(backup_file) and os.path.getsize(backup_file) > 0:
                logger.info(f"✅ 完整备份完成: {backup_file}")
                return backup_file
            else:
                logger.error(f"❌ 备份文件无效: {backup_file}")
                return None

        except subprocess.TimeoutExpired:
            logger.error("❌ 备份超时")
            return None
        except subprocess.CalledProcessError as e:
            logger.error(f"❌ 备份失败: {e.stderr.decode()}")
            return None
        except Exception as e:
            logger.error(f"❌ 备份异常: {str(e)}")
            return None

    def physical_backup(self):
        """物理备份"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = os.path.join(
            self.backup_dir,
            f"physical_backup_{timestamp}"
        )
        os.makedirs(backup_dir, exist_ok=True)

        try:
            cmd = [
                "pg_basebackup",
                "-U", self.db_config["user"],
                "-D", backup_dir,
                "-Ft",
                "-z",
                "-P",
                "-X", "stream",
                "-v"
            ]

            env = os.environ.copy()
            if "password" in self.db_config:
                env["PGPASSWORD"] = self.db_config["password"]

            result = subprocess.run(
                cmd,
                env=env,
                capture_output=True,
                check=True,
                timeout=7200  # 2 小时超时
            )

            if os.path.exists(backup_dir):
                logger.info(f"✅ 物理备份完成: {backup_dir}")
                return backup_dir
            else:
                logger.error(f"❌ 备份目录无效: {backup_dir}")
                return None

        except Exception as e:
            logger.error(f"❌ 物理备份失败: {str(e)}")
            return None

    def verify_backup(self, backup_file):
        """验证备份文件"""
        try:
            # 尝试列出备份内容
            result = subprocess.run(
                ["pg_restore", "-l", backup_file],
                capture_output=True,
                check=True,
                timeout=300
            )
            logger.info(f"✅ 备份文件完整: {backup_file}")
            return True
        except subprocess.CalledProcessError:
            logger.error(f"❌ 备份文件损坏: {backup_file}")
            return False
        except Exception as e:
            logger.error(f"❌ 验证失败: {str(e)}")
            return False

    def cleanup_old_backups(self, days=7):
        """清理旧备份"""
        cutoff_time = datetime.now() - timedelta(days=days)
        cutoff_timestamp = cutoff_time.timestamp()

        cleaned_count = 0
        for file in os.listdir(self.backup_dir):
            file_path = os.path.join(self.backup_dir, file)
            if os.path.isfile(file_path):
                if os.path.getmtime(file_path) < cutoff_timestamp:
                    try:
                        os.remove(file_path)
                        logger.info(f"✅ 删除旧备份: {file}")
                        cleaned_count += 1
                    except Exception as e:
                        logger.error(f"❌ 删除失败: {file}, {str(e)}")

        logger.info(f"✅ 清理完成，删除 {cleaned_count} 个旧备份")
        return cleaned_count

    def cleanup_old_wal(self, days=3):
        """清理旧 WAL 日志"""
        cutoff_time = datetime.now() - timedelta(days=days)
        cutoff_timestamp = cutoff_time.timestamp()

        cleaned_count = 0
        for file in os.listdir(self.wal_dir):
            file_path = os.path.join(self.wal_dir, file)
            if os.path.isfile(file_path):
                if os.path.getmtime(file_path) < cutoff_timestamp:
                    try:
                        os.remove(file_path)
                        logger.info(f"✅ 删除旧 WAL: {file}")
                        cleaned_count += 1
                    except Exception as e:
                        logger.error(f"❌ 删除失败: {file}, {str(e)}")

        logger.info(f"✅ WAL 清理完成，删除 {cleaned_count} 个旧文件")
        return cleaned_count


# 使用示例
if __name__ == "__main__":
    backup_manager = BackupManager({
        "user": "postgres",
        "database": "vector_db",
        "password": "postgres"
    })

    # 执行完整备份
    backup_file = backup_manager.full_backup()

    # 验证备份
    if backup_file:
        backup_manager.verify_backup(backup_file)

    # 清理旧备份
    backup_manager.cleanup_old_backups(days=7)
    backup_manager.cleanup_old_wal(days=3)
```

#### 4.1.2 备份调度

**使用 cron 调度**:

```bash
# crontab -e

# 每天凌晨 2 点执行完整备份
0 2 * * * /usr/bin/python3 /path/to/backup_manager.py full_backup >> /var/log/backup.log 2>&1

# 每周日凌晨 1 点执行物理备份
0 1 * * 0 /usr/bin/python3 /path/to/backup_manager.py physical_backup >> /var/log/backup.log 2>&1

# 每天凌晨 3 点清理旧备份
0 3 * * * /usr/bin/python3 /path/to/backup_manager.py cleanup >> /var/log/backup.log 2>&1
```

**使用 systemd timer**:

```ini
# /etc/systemd/system/postgres-backup.service
[Unit]
Description=PostgreSQL Backup Service
After=postgresql.service

[Service]
Type=oneshot
ExecStart=/usr/bin/python3 /path/to/backup_manager.py full_backup
User=postgres
StandardOutput=journal
StandardError=journal

# /etc/systemd/system/postgres-backup.timer
[Unit]
Description=PostgreSQL Backup Timer
Requires=postgres-backup.service

[Timer]
OnCalendar=daily
OnCalendar=*-*-* 02:00:00
AccuracySec=1h
Persistent=true

[Install]
WantedBy=timers.target
```

### 4.2 备份策略配置

**备份策略配置**:

| 备份类型     | 频率 | 保留时间 | 存储位置    |
| ------------ | ---- | -------- | ----------- |
| **完整备份** | 每天 | 7 天     | 本地        |
| **物理备份** | 每周 | 30 天    | 本地 + 远程 |
| **WAL 归档** | 实时 | 3 天     | 本地        |
| **长期备份** | 每月 | 1 年     | 归档存储    |

## 5. 备份验证

### 5.1 备份完整性检查

#### 5.1.1 备份文件验证

**备份文件验证**:

```python
def verify_backup(backup_file):
    """验证备份文件"""
    try:
        # 1. 检查文件是否存在
        if not os.path.exists(backup_file):
            logger.error(f"❌ 备份文件不存在: {backup_file}")
            return False

        # 2. 检查文件大小
        file_size = os.path.getsize(backup_file)
        if file_size == 0:
            logger.error(f"❌ 备份文件为空: {backup_file}")
            return False

        # 3. 尝试列出备份内容
        result = subprocess.run(
            ["pg_restore", "-l", backup_file],
            capture_output=True,
            check=True,
            timeout=300
        )

        # 4. 解析备份内容
        backup_items = result.stdout.decode().split('\n')
        item_count = len([item for item in backup_items if item.strip()])

        logger.info(f"✅ 备份文件完整: {backup_file}")
        logger.info(f"   文件大小: {file_size / 1024 / 1024:.2f} MB")
        logger.info(f"   备份项数: {item_count}")

        return True

    except subprocess.CalledProcessError as e:
        logger.error(f"❌ 备份文件损坏: {backup_file}")
        logger.error(f"   错误: {e.stderr.decode()}")
        return False
    except Exception as e:
        logger.error(f"❌ 验证失败: {str(e)}")
        return False
```

#### 5.1.2 备份内容验证

**备份内容验证**:

```python
def verify_backup_content(backup_file, expected_tables):
    """验证备份内容"""
    try:
        # 列出备份中的表
        result = subprocess.run(
            ["pg_restore", "-l", backup_file],
            capture_output=True,
            check=True
        )

        backup_content = result.stdout.decode()

        # 检查是否包含预期的表
        missing_tables = []
        for table in expected_tables:
            if table not in backup_content:
                missing_tables.append(table)

        if missing_tables:
            logger.warning(f"⚠️ 备份中缺少表: {missing_tables}")
            return False
        else:
            logger.info(f"✅ 备份包含所有预期的表")
            return True

    except Exception as e:
        logger.error(f"❌ 验证失败: {str(e)}")
        return False
```

### 5.2 恢复测试

#### 5.2.1 恢复测试流程

**恢复测试脚本**:

```bash
#!/bin/bash
# restore_test.sh

BACKUP_FILE=$1
TEST_DB="test_restore_$(date +%Y%m%d_%H%M%S)"

echo "开始恢复测试..."
echo "备份文件: $BACKUP_FILE"
echo "测试数据库: $TEST_DB"

# 1. 创建测试数据库
createdb -U postgres "$TEST_DB"

# 2. 恢复备份
pg_restore -U postgres \
  -d "$TEST_DB" \
  -F c \
  "$BACKUP_FILE"

# 3. 验证数据
echo "验证数据..."
psql -U postgres -d "$TEST_DB" <<EOF
SELECT
    COUNT(*) as total_tables
FROM information_schema.tables
WHERE table_schema = 'public'
  AND table_type = 'BASE TABLE';

SELECT
    schemaname,
    tablename,
    n_live_tup as row_count
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY n_live_tup DESC
LIMIT 10;
EOF

# 4. 清理测试数据库
echo "清理测试数据库..."
dropdb -U postgres "$TEST_DB"

echo "恢复测试完成"
```

#### 5.2.2 数据验证

**数据验证查询**:

```sql
-- 验证数据完整性
SELECT
    schemaname,
    tablename,
    n_live_tup as row_count,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as table_size
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY n_live_tup DESC;

-- 验证向量数据
SELECT
    COUNT(*) as total_vectors,
    AVG(vector_dims) as avg_dimensions
FROM (
    SELECT
        pg_typeof(embedding)::text,
        array_length(embedding::text::int[], 1) as vector_dims
    FROM documents
    LIMIT 1000
) t;

-- 验证索引
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

## 6. 备份存储策略

### 6.1 本地存储

**本地存储配置**:

```bash
# 本地备份目录结构
/backup/postgres/
├── full_backup_20251101_020000.dump
├── full_backup_20251102_020000.dump
├── ...
├── physical_backup_20251101_010000/
│   ├── base.tar.gz
│   ├── pg_wal.tar.gz
│   └── ...
└── wal/
    ├── 000000010000000000000001
    ├── 000000010000000000000002
    └── ...
```

**本地存储策略**:

| 备份类型     | 保留时间 | 存储空间    | 说明      |
| ------------ | -------- | ----------- | --------- |
| **完整备份** | 7 天     | 约 10-50GB  | 日常恢复  |
| **物理备份** | 30 天    | 约 50-200GB | 快速恢复  |
| **WAL 归档** | 3 天     | 约 5-20GB   | PITR 恢复 |

### 6.2 远程存储

**远程存储配置**:

```bash
# 使用 rsync 同步到远程
rsync -av --delete \
  /backup/postgres/ \
  user@remote-backup:/backup/postgres/

# 使用 S3 存储
aws s3 sync \
  /backup/postgres/ \
  s3://backup-bucket/postgres/ \
  --storage-class STANDARD_IA

# 使用云存储（如阿里云 OSS）
ossutil cp \
  /backup/postgres/ \
  oss://backup-bucket/postgres/ \
  --recursive
```

**远程存储策略**:

| 存储类型               | 访问速度 | 成本   | 适用场景 |
| ---------------------- | -------- | ------ | -------- |
| **远程服务器**         | 中       | 低     | 长期备份 |
| **对象存储（S3/OSS）** | 中       | 中     | 云端备份 |
| **归档存储**           | 低       | **低** | 长期归档 |

### 6.3 备份保留策略

**备份保留策略**:

| 备份类型     | 本地保留 | 远程保留 | 归档保留 |
| ------------ | -------- | -------- | -------- |
| **完整备份** | 7 天     | 30 天    | 1 年     |
| **物理备份** | 7 天     | 30 天    | 6 个月   |
| **WAL 归档** | 3 天     | 7 天     | -        |

## 7. 最佳实践

### 7.1 备份策略

**备份策略最佳实践**:

1. **多重备份**: 使用多种备份方式（逻辑备份 + 物理备份 + WAL 归档）
2. **定期备份**: 每天执行完整备份，每周执行物理备份
3. **异地备份**: 至少一份备份存储在异地
4. **备份验证**: 定期验证备份完整性
5. **自动化**: 使用自动化脚本和调度系统

**备份频率建议**:

| 数据重要性   | 备份频率   | 备份方式            |
| ------------ | ---------- | ------------------- |
| **关键数据** | 每天 + WAL | 完整备份 + WAL 归档 |
| **重要数据** | 每天       | 完整备份            |
| **一般数据** | 每周       | 完整备份            |

### 7.2 恢复策略

**恢复策略最佳实践**:

1. **恢复测试**: 每月至少测试一次恢复流程
2. **文档记录**: 记录恢复流程和时间
3. **恢复演练**: 定期进行恢复演练
4. **监控告警**: 监控备份状态，及时告警

### 7.3 容灾演练

**容灾演练步骤**:

1. **准备阶段**: 准备备份文件、恢复脚本
2. **演练执行**: 在测试环境执行恢复
3. **验证阶段**: 验证数据完整性和业务功能
4. **总结阶段**: 总结演练结果，优化流程

## 8. 参考资料

### 8.1 官方文档

- [PostgreSQL 备份文档](https://www.postgresql.org/docs/current/backup.html) - Backup Documentation
- [pg_dump 文档](https://www.postgresql.org/docs/current/app-pgdump.html) - pg_dump Documentation
- [pg_basebackup 文档](https://www.postgresql.org/docs/current/app-pgbasebackup.html) -
  pg_basebackup Documentation
- [WAL 归档文档](https://www.postgresql.org/docs/current/continuous-archiving.html) - Continuous
  Archiving

### 8.2 技术文档

- [监控与告警](./监控与告警.md) - Monitoring and Alerting
- [性能监控](./性能监控.md) - Performance Monitoring

### 8.3 相关资源

- [PostgreSQL 备份最佳实践](https://www.postgresql.org/docs/current/backup-best-practices.html) -
  Backup Best Practices
- [PITR 恢复指南](https://www.postgresql.org/docs/current/backup-pitr.html) - Point-in-Time Recovery

---

**最后更新**: 2025 年 11 月 1 日  
**维护者**: PostgreSQL Modern Team  
**文档编号**: 09-02-03
