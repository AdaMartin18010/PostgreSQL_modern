# 9.2.1 监控与告警

> **更新时间**: 2025 年 11 月 1 日  
> **文档编号**: 09-02-01

## 📑 目录

- [9.2.1 监控与告警](#921-监控与告警)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 监控目标](#11-监控目标)
    - [1.2 告警策略](#12-告警策略)
    - [1.3 监控架构](#13-监控架构)
  - [2. 监控指标](#2-监控指标)
    - [2.1 数据库性能指标](#21-数据库性能指标)
      - [2.1.1 关键指标](#211-关键指标)
      - [2.1.2 向量查询性能](#212-向量查询性能)
      - [2.1.3 查询统计](#213-查询统计)
    - [2.2 索引使用情况](#22-索引使用情况)
      - [2.2.1 索引扫描统计](#221-索引扫描统计)
      - [2.2.2 索引效率分析](#222-索引效率分析)
    - [2.3 表大小监控](#23-表大小监控)
      - [2.3.1 表大小统计](#231-表大小统计)
      - [2.3.2 索引大小分析](#232-索引大小分析)
  - [3. Prometheus 监控](#3-prometheus-监控)
    - [3.1 postgres_exporter 配置](#31-postgres_exporter-配置)
      - [3.1.1 Exporter 安装](#311-exporter-安装)
      - [3.1.2 配置文件](#312-配置文件)
    - [3.2 关键监控指标](#32-关键监控指标)
      - [3.2.1 PromQL 查询](#321-promql-查询)
      - [3.2.2 指标说明](#322-指标说明)
    - [3.3 Grafana 仪表盘](#33-grafana-仪表盘)
      - [3.3.1 仪表盘配置](#331-仪表盘配置)
      - [3.3.2 可视化面板](#332-可视化面板)
  - [4. 告警配置](#4-告警配置)
    - [4.1 告警规则](#41-告警规则)
      - [4.1.1 Prometheus 告警规则](#411-prometheus-告警规则)
      - [4.1.2 告警阈值设置](#412-告警阈值设置)
    - [4.2 告警通知](#42-告警通知)
      - [4.2.1 Alertmanager 配置](#421-alertmanager-配置)
      - [4.2.2 通知渠道设置](#422-通知渠道设置)
  - [5. 自动化监控脚本](#5-自动化监控脚本)
    - [5.1 Python 监控脚本](#51-python-监控脚本)
    - [5.2 监控指标采集](#52-监控指标采集)
  - [6. 监控仪表盘示例](#6-监控仪表盘示例)
    - [6.1 Grafana SQL 查询](#61-grafana-sql-查询)
    - [6.2 仪表盘模板](#62-仪表盘模板)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 监控指标选择](#71-监控指标选择)
    - [7.2 告警阈值设置](#72-告警阈值设置)
  - [8. 参考资料](#8-参考资料)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 技术文档](#82-技术文档)
    - [8.3 相关资源](#83-相关资源)

---

## 1. 概述

### 1.1 监控目标

**核心目标**:

本文档提供 PostgreSQL + pgvector 生产环境的监控与告警配置指南，帮助您实时掌握系统状态。

**监控目标**:

1. **性能监控**: 实时监控数据库查询性能，包括向量查询延迟、吞吐量等
2. **资源监控**: 监控数据库连接数、内存使用、磁盘 I/O 等资源使用情况
3. **健康监控**: 监控数据库可用性、错误率、缓存命中率等健康指标
4. **告警通知**: 及时发现并通知异常情况，减少故障影响

**监控价值**:

| 监控项       | 价值             | 影响             |
| ------------ | ---------------- | ---------------- |
| **性能监控** | 及时发现性能瓶颈 | 减少用户体验影响 |
| **资源监控** | 预测资源需求     | 避免资源耗尽     |
| **健康监控** | 及时发现问题     | 减少故障时间     |
| **告警通知** | 快速响应问题     | 降低业务损失     |

### 1.2 告警策略

**告警策略**:

1. **告警分级**:

   - **Critical**: 严重影响系统可用性，需要立即处理
   - **Warning**: 潜在问题，需要关注但不需要立即处理
   - **Info**: 信息通知，用于记录和分析

2. **告警规则**:

   - **阈值告警**: 超过阈值触发告警
   - **趋势告警**: 趋势异常触发告警
   - **组合告警**: 多个指标组合触发告警

3. **告警通知**:
   - **邮件通知**: 用于重要告警
   - **短信通知**: 用于紧急告警
   - **Webhook 通知**: 用于系统集成

**告警阈值建议**:

| 指标               | Warning | Critical | 说明             |
| ------------------ | ------- | -------- | ---------------- |
| **查询延迟 (P95)** | >100ms  | >500ms   | 向量查询延迟     |
| **连接数**         | >80%    | >95%     | 最大连接数百分比 |
| **缓存命中率**     | <90%    | <80%     | 缓存效率         |
| **数据库大小**     | >500GB  | >1TB     | 存储空间         |

### 1.3 监控架构

**监控架构设计**:

```text
┌─────────────────────────────────────────────────┐
│         PostgreSQL + pgvector                    │
│  ┌──────────┐  ┌──────────┐                    │
│  │pg_stat   │  │pg_stat   │                    │
│  │_statements│ │_database │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────┐
│         postgres_exporter                        │
│  ┌──────────┐  ┌──────────┐                    │
│  │Metric    │  │Exporter  │                    │
│  │Collector │  │Server    │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────┐
│         Prometheus                               │
│  ┌──────────┐  ┌──────────┐                    │
│  │Time      │  │Alert      │                    │
│  │Series DB │  │Rules      │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
          │                    │
┌─────────┴──────────┐  ┌──────┴──────────┐
│   Grafana          │  │  Alertmanager   │
│   (可视化)          │  │  (告警管理)      │
└────────────────────┘  └─────────────────┘
```

## 2. 监控指标

### 2.1 数据库性能指标

#### 2.1.1 关键指标

**启用 pg_stat_statements**:

```sql
-- 启用 pg_stat_statements 扩展
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 配置统计参数（postgresql.conf）
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all
pg_stat_statements.max = 10000
pg_stat_statements.track_utility = on
```

**查看慢查询**:

```sql
-- 查看慢查询（超过 100ms）
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    stddev_exec_time,
    rows,
    100.0 * shared_blks_hit / NULLIF(shared_blks_hit + shared_blks_read, 0) AS cache_hit_rate
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- 超过 100ms
ORDER BY mean_exec_time DESC
LIMIT 10;
```

**查询统计说明**:

| 指标              | 说明         | 重要性 |
| ----------------- | ------------ | ------ |
| `calls`           | 查询执行次数 | 高     |
| `total_exec_time` | 总执行时间   | 高     |
| `mean_exec_time`  | 平均执行时间 | **高** |
| `max_exec_time`   | 最大执行时间 | 中     |
| `cache_hit_rate`  | 缓存命中率   | **高** |

#### 2.1.2 向量查询性能

**监控向量查询性能**:

```sql
-- 监控向量查询性能
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    (shared_blks_hit::float / NULLIF(shared_blks_hit + shared_blks_read, 0)) * 100 as cache_hit_rate,
    (shared_blks_hit + shared_blks_read) as total_blks,
    shared_blks_hit as hit_blks
FROM pg_stat_statements
WHERE query LIKE '%<=>%' OR query LIKE '%<->%' OR query LIKE '%<#%'  -- 向量查询
ORDER BY mean_exec_time DESC
LIMIT 10;
```

**向量查询性能分析**:

| 数据量     | 平均延迟  | P95 延迟   | P99 延迟   |
| ---------- | --------- | ---------- | ---------- |
| **1 万**   | **<5ms**  | **<10ms**  | **<20ms**  |
| **10 万**  | **<10ms** | **<20ms**  | **<50ms**  |
| **100 万** | **<50ms** | **<100ms** | **<200ms** |

#### 2.1.3 查询统计

**查询统计信息**:

```sql
-- 查看查询统计总览
SELECT
    COUNT(*) as total_queries,
    SUM(calls) as total_calls,
    SUM(total_exec_time) as total_time,
    AVG(mean_exec_time) as avg_exec_time,
    SUM(shared_blks_hit + shared_blks_read) as total_blks
FROM pg_stat_statements;

-- 查看向量查询统计
SELECT
    COUNT(*) as vector_queries,
    SUM(calls) as vector_calls,
    SUM(total_exec_time) as vector_time,
    AVG(mean_exec_time) as vector_avg_time
FROM pg_stat_statements
WHERE query LIKE '%<=>%' OR query LIKE '%<->%' OR query LIKE '%<#%';
```

### 2.2 索引使用情况

#### 2.2.1 索引扫描统计

**查看索引使用情况**:

```sql
-- 查看索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan as scan_count,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

**索引使用效率**:

| 索引类型    | 扫描次数 | 效率   | 建议     |
| ----------- | -------- | ------ | -------- |
| **HNSW**    | >1000    | **高** | 保持     |
| **IVFFlat** | >100     | **中** | 监控     |
| **未使用**  | <10      | **低** | 考虑删除 |

#### 2.2.2 索引效率分析

**索引效率分析**:

```sql
-- 分析索引效率
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    CASE
        WHEN idx_scan = 0 THEN '未使用'
        WHEN idx_scan < 10 THEN '低使用'
        WHEN idx_scan < 100 THEN '中使用'
        ELSE '高使用'
    END as usage_status
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan;
```

### 2.3 表大小监控

#### 2.3.1 表大小统计

**查看表大小**:

```sql
-- 查看表大小和索引大小
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) as index_size,
    pg_total_relation_size(schemaname||'.'||tablename) as total_bytes
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

**表大小监控指标**:

| 表大小       | 状态 | 建议     |
| ------------ | ---- | -------- |
| **<10GB**    | 正常 | 继续监控 |
| **10-100GB** | 注意 | 考虑分区 |
| **>100GB**   | 警告 | 需要优化 |

#### 2.3.2 索引大小分析

**索引大小分析**:

```sql
-- 分析索引大小占比
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) as index_size,
    ROUND(
        100.0 * (pg_total_relation_size(schemaname||'.'||tablename) -
                 pg_relation_size(schemaname||'.'||tablename)) /
        pg_total_relation_size(schemaname||'.'||tablename),
        2
    ) as index_ratio
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

**索引大小占比**:

| 索引占比    | 状态 | 建议         |
| ----------- | ---- | ------------ |
| **<50%**    | 正常 | 继续监控     |
| **50-100%** | 注意 | 考虑优化索引 |
| **>100%**   | 警告 | 需要重建索引 |

## 3. Prometheus 监控

### 3.1 postgres_exporter 配置

#### 3.1.1 Exporter 安装

**安装 postgres_exporter**:

```bash
# 下载 postgres_exporter
wget https://github.com/prometheus-community/postgres_exporter/releases/download/v0.14.0/postgres_exporter-0.14.0.linux-amd64.tar.gz

# 解压
tar -xzf postgres_exporter-0.14.0.linux-amd64.tar.gz

# 复制到系统目录
sudo cp postgres_exporter-0.14.0.linux-amd64/postgres_exporter /usr/local/bin/

# 创建 systemd 服务
sudo cat > /etc/systemd/system/postgres_exporter.service <<EOF
[Unit]
Description=PostgreSQL Exporter
After=network.target

[Service]
Type=simple
User=postgres
Environment="DATA_SOURCE_NAME=postgresql://postgres:postgres@localhost:5432/vector_db?sslmode=disable"
ExecStart=/usr/local/bin/postgres_exporter
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 启动服务
sudo systemctl enable postgres_exporter
sudo systemctl start postgres_exporter

# 验证服务
curl http://localhost:9187/metrics
```

#### 3.1.2 配置文件

**Prometheus 配置**:

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: "postgres"
    static_configs:
      - targets: ["localhost:9187"]
        labels:
          instance: "postgres-vector"

  - job_name: "postgres-vector"
    metrics_path: "/metrics"
    static_configs:
      - targets: ["localhost:5432"]
        labels:
          instance: "vector-db"
```

### 3.2 关键监控指标

#### 3.2.1 PromQL 查询

**关键监控指标**:

```promql
# 数据库连接数
pg_stat_database_numbackends{datname="vector_db"}

# 慢查询数（超过 100ms）
rate(pg_stat_statements_mean_exec_time[5m]) > 0.1

# 向量查询延迟 P95
histogram_quantile(0.95,
  rate(pg_stat_statements_mean_exec_time{query=~".*<=>.*"}[5m])
)

# 向量查询 QPS
rate(pg_stat_statements_calls{query=~".*<=>.*"}[5m])

# 缓存命中率
pg_stat_database_blks_hit{datname="vector_db"} /
(pg_stat_database_blks_hit{datname="vector_db"} +
 pg_stat_database_blks_read{datname="vector_db"})

# 数据库大小
pg_database_size_bytes{datname="vector_db"}

# 索引使用率
rate(pg_stat_user_indexes_idx_scan[5m])
```

#### 3.2.2 指标说明

**关键指标说明**:

| 指标             | 说明               | 阈值                              |
| ---------------- | ------------------ | --------------------------------- |
| **连接数**       | 当前数据库连接数   | Warning: >80, Critical: >95       |
| **查询延迟 P95** | 95% 查询的延迟     | Warning: >100ms, Critical: >500ms |
| **向量查询 QPS** | 向量查询每秒请求数 | 根据业务需求设置                  |
| **缓存命中率**   | 缓存命中百分比     | Warning: <90%, Critical: <80%     |
| **数据库大小**   | 数据库总大小       | Warning: >500GB, Critical: >1TB   |

### 3.3 Grafana 仪表盘

#### 3.3.1 仪表盘配置

**Grafana 仪表盘 JSON**:

```json
{
  "dashboard": {
    "title": "PostgreSQL Vector Search",
    "panels": [
      {
        "id": 1,
        "title": "查询延迟 (P95)",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(pg_stat_statements_mean_exec_time[5m]))",
            "legendFormat": "P95 延迟"
          }
        ]
      },
      {
        "id": 2,
        "title": "向量查询 QPS",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(pg_stat_statements_calls{query=~'.*<=>.*'}[5m])",
            "legendFormat": "QPS"
          }
        ]
      },
      {
        "id": 3,
        "title": "数据库连接数",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends{datname='vector_db'}",
            "legendFormat": "连接数"
          }
        ]
      },
      {
        "id": 4,
        "title": "缓存命中率",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_stat_database_blks_hit{datname='vector_db'} / (pg_stat_database_blks_hit{datname='vector_db'} + pg_stat_database_blks_read{datname='vector_db'})",
            "legendFormat": "命中率"
          }
        ]
      },
      {
        "id": 5,
        "title": "数据库大小",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_database_size_bytes{datname='vector_db'}",
            "legendFormat": "大小"
          }
        ]
      }
    ]
  }
}
```

#### 3.3.2 可视化面板

**仪表盘面板说明**:

| 面板             | 类型   | 指标       | 更新频率 |
| ---------------- | ------ | ---------- | -------- |
| **查询延迟**     | 折线图 | P95 延迟   | 5 分钟   |
| **向量查询 QPS** | 折线图 | QPS        | 5 分钟   |
| **连接数**       | 折线图 | 当前连接数 | 1 分钟   |
| **缓存命中率**   | 折线图 | 命中率     | 5 分钟   |
| **数据库大小**   | 折线图 | 总大小     | 1 小时   |

## 4. 告警配置

### 4.1 告警规则

#### 4.1.1 Prometheus 告警规则

**告警规则配置**:

```yaml
# alerts.yml
groups:
  - name: postgres_vector
    interval: 30s
    rules:
      # 慢查询告警
      - alert: SlowVectorQuery
        expr: |
          histogram_quantile(0.95,
            rate(pg_stat_statements_mean_exec_time{query=~".*<=>.*"}[5m])
          ) > 0.5
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "向量查询延迟过高"
          description: "向量查询 P95 延迟超过 500ms，当前值: {{ $value }}ms"

      # 连接数告警
      - alert: HighConnectionCount
        expr: |
          pg_stat_database_numbackends{datname="vector_db"} > 80
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "数据库连接数过高"
          description: "当前连接数: {{ $value }}/100"

      # 缓存命中率告警
      - alert: LowCacheHitRate
        expr: |
          (
            pg_stat_database_blks_hit{datname="vector_db"} / 
            (pg_stat_database_blks_hit{datname="vector_db"} + 
             pg_stat_database_blks_read{datname="vector_db"})
          ) < 0.9
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "缓存命中率过低"
          description: "当前缓存命中率: {{ $value | humanizePercentage }}"

      # 数据库大小告警
      - alert: LargeDatabaseSize
        expr: |
          pg_database_size_bytes{datname="vector_db"} > 500000000000
        for: 1h
        labels:
          severity: warning
        annotations:
          summary: "数据库大小过大"
          description: "当前大小: {{ $value | humanizeBytes }}"

      # 索引未使用告警
      - alert: UnusedIndex
        expr: |
          pg_stat_user_indexes_idx_scan == 0
        for: 24h
        labels:
          severity: info
        annotations:
          summary: "索引未使用"
          description: "索引 {{ $labels.indexname }} 在 24 小时内未被使用"
```

#### 4.1.2 告警阈值设置

**告警阈值建议**:

| 告警类型       | 指标       | Warning | Critical | 持续时间 |
| -------------- | ---------- | ------- | -------- | -------- |
| **慢查询**     | P95 延迟   | >100ms  | >500ms   | 5 分钟   |
| **连接数**     | 当前连接数 | >80     | >95      | 2 分钟   |
| **缓存命中率** | 命中率     | <90%    | <80%     | 5 分钟   |
| **数据库大小** | 总大小     | >500GB  | >1TB     | 1 小时   |

### 4.2 告警通知

#### 4.2.1 Alertmanager 配置

**Alertmanager 配置**:

```yaml
# alertmanager.yml
global:
  resolve_timeout: 5m

route:
  receiver: "default"
  group_by: ["alertname", "severity"]
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 12h

  routes:
    - match:
        severity: critical
      receiver: "critical-alerts"
      continue: true

    - match:
        severity: warning
      receiver: "warning-alerts"

    - match:
        alertname: UnusedIndex
      receiver: "info-alerts"
      repeat_interval: 24h

receivers:
  - name: "default"
    webhook_configs:
      - url: "http://alert-handler:8080/alerts"

  - name: "critical-alerts"
    email_configs:
      - to: "ops@example.com"
        from: "alertmanager@example.com"
        smarthost: "smtp.example.com:587"
        auth_username: "alertmanager"
        auth_password: "password"
        subject: "PostgreSQL 严重告警: {{ .GroupLabels.alertname }}"
        html: |
          <h2>告警详情</h2>
          <p><strong>告警名称:</strong> {{ .GroupLabels.alertname }}</p>
          <p><strong>告警描述:</strong> {{ .CommonAnnotations.description }}</p>
          <p><strong>告警时间:</strong> {{ .StartsAt }}</p>
    webhook_configs:
      - url: "http://slack-webhook:8080/critical"

  - name: "warning-alerts"
    email_configs:
      - to: "dev@example.com"
        from: "alertmanager@example.com"
        smarthost: "smtp.example.com:587"
        subject: "PostgreSQL 警告: {{ .GroupLabels.alertname }}"
    webhook_configs:
      - url: "http://slack-webhook:8080/warning"

  - name: "info-alerts"
    webhook_configs:
      - url: "http://alert-handler:8080/info"
```

#### 4.2.2 通知渠道设置

**通知渠道配置**:

| 告警级别     | 通知渠道              | 响应时间 |
| ------------ | --------------------- | -------- |
| **Critical** | 邮件 + 短信 + Webhook | <1 分钟  |
| **Warning**  | 邮件 + Webhook        | <5 分钟  |
| **Info**     | Webhook               | <1 小时  |

## 5. 自动化监控脚本

### 5.1 Python 监控脚本

**Python 监控脚本**:

```python
# monitor.py
import psycopg2
import time
from prometheus_client import Gauge, Counter, Histogram, start_http_server
from prometheus_client.core import REGISTRY

# Prometheus 指标
vector_query_duration = Histogram(
    'vector_query_duration_seconds',
    '向量查询耗时',
    ['query_type']
)

vector_query_count = Counter(
    'vector_query_total',
    '向量查询总数',
    ['status']
)

db_connections = Gauge(
    'postgres_connections',
    '数据库连接数',
    ['database']
)

cache_hit_rate = Gauge(
    'postgres_cache_hit_rate',
    '缓存命中率',
    ['database']
)

def monitor_vector_queries(conn):
    """监控向量查询"""
    cur = conn.cursor()

    while True:
        try:
            # 查询慢查询
            cur.execute("""
                SELECT
                    query,
                    mean_exec_time,
                    calls
                FROM pg_stat_statements
                WHERE query LIKE '%<=>%' OR query LIKE '%<->%' OR query LIKE '%<#%'
                ORDER BY mean_exec_time DESC
                LIMIT 10
            """)

            results = cur.fetchall()

            for query, mean_time, calls in results:
                # 记录查询耗时
                vector_query_duration.labels(query_type='vector').observe(mean_time / 1000)
                # 记录查询次数
                vector_query_count.labels(status='success').inc(calls)

        except Exception as e:
            print(f"监控错误: {e}")

        time.sleep(60)  # 每分钟监控一次

def monitor_connections(conn):
    """监控连接数"""
    cur = conn.cursor()

    while True:
        try:
            cur.execute("""
                SELECT
                    datname,
                    numbackends
                FROM pg_stat_database
                WHERE datname = 'vector_db'
            """)

            result = cur.fetchone()
            if result:
                db_connections.labels(database=result[0]).set(result[1])

        except Exception as e:
            print(f"监控错误: {e}")

        time.sleep(30)  # 每30秒监控一次

def monitor_cache_hit_rate(conn):
    """监控缓存命中率"""
    cur = conn.cursor()

    while True:
        try:
            cur.execute("""
                SELECT
                    datname,
                    100.0 * blks_hit / NULLIF(blks_hit + blks_read, 0) as hit_rate
                FROM pg_stat_database
                WHERE datname = 'vector_db'
            """)

            result = cur.fetchone()
            if result:
                cache_hit_rate.labels(database=result[0]).set(result[1])

        except Exception as e:
            print(f"监控错误: {e}")

        time.sleep(60)  # 每分钟监控一次

if __name__ == "__main__":
    # 启动 Prometheus HTTP 服务器
    start_http_server(8000)

    # 连接数据库
    conn = psycopg2.connect(
        host="localhost",
        port=5432,
        user="postgres",
        password="postgres",
        database="vector_db"
    )

    # 启动监控线程
    import threading

    t1 = threading.Thread(target=monitor_vector_queries, args=(conn,))
    t2 = threading.Thread(target=monitor_connections, args=(conn,))
    t3 = threading.Thread(target=monitor_cache_hit_rate, args=(conn,))

    t1.start()
    t2.start()
    t3.start()

    t1.join()
    t2.join()
    t3.join()
```

### 5.2 监控指标采集

**监控指标采集频率**:

| 指标           | 采集频率 | 说明         |
| -------------- | -------- | ------------ |
| **查询延迟**   | 1 分钟   | 向量查询性能 |
| **连接数**     | 30 秒    | 数据库连接   |
| **缓存命中率** | 1 分钟   | 缓存效率     |
| **数据库大小** | 1 小时   | 存储使用     |

## 6. 监控仪表盘示例

### 6.1 Grafana SQL 查询

**查询延迟趋势**:

```sql
-- 查询延迟趋势
SELECT
    time_bucket('5 minutes', timestamp) as time,
    AVG(duration_ms) as avg_duration,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY duration_ms) as p95_duration,
    PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY duration_ms) as p99_duration
FROM query_logs
WHERE query_type = 'vector_search'
  AND timestamp > NOW() - INTERVAL '1 hour'
GROUP BY time
ORDER BY time;
```

**向量查询 QPS**:

```sql
-- 向量查询 QPS
SELECT
    time_bucket('1 minute', timestamp) as time,
    COUNT(*) as qps
FROM query_logs
WHERE query_type = 'vector_search'
  AND timestamp > NOW() - INTERVAL '1 hour'
GROUP BY time
ORDER BY time;
```

**索引使用情况**:

```sql
-- 索引使用情况
SELECT
    tablename,
    indexname,
    idx_scan as scan_count,
    idx_tup_read as tuples_read,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

### 6.2 仪表盘模板

**仪表盘模板配置**:

| 面板             | 查询类型 | 数据源     | 更新频率 |
| ---------------- | -------- | ---------- | -------- |
| **查询延迟**     | SQL      | PostgreSQL | 5 分钟   |
| **向量查询 QPS** | SQL      | PostgreSQL | 1 分钟   |
| **索引使用**     | SQL      | PostgreSQL | 1 小时   |

## 7. 最佳实践

### 7.1 监控指标选择

**监控指标选择原则**:

1. **关键指标优先**: 优先监控影响业务的关键指标
2. **全面覆盖**: 覆盖性能、资源、健康等各个方面
3. **合理频率**: 根据指标特性设置合理的采集频率
4. **成本控制**: 平衡监控成本和监控价值

### 7.2 告警阈值设置

**告警阈值设置原则**:

1. **基于基线**: 根据历史数据设置基线阈值
2. **分级告警**: 设置 Warning 和 Critical 两级阈值
3. **避免告警风暴**: 设置合理的持续时间，避免频繁告警
4. **持续优化**: 根据实际情况持续优化阈值

## 8. 参考资料

### 8.1 官方文档

- [PostgreSQL 监控最佳实践](https://www.postgresql.org/docs/current/monitoring-stats.html) -
  Monitoring Stats
- [Prometheus 监控指南](https://prometheus.io/docs/guides/) - Prometheus Guides
- [Grafana 仪表盘配置](https://grafana.com/docs/grafana/latest/dashboards/) - Grafana Dashboards

### 8.2 技术文档

- [postgres_exporter GitHub](https://github.com/prometheus-community/postgres_exporter) -
  postgres_exporter
- [Alertmanager 文档](https://prometheus.io/docs/alerting/latest/alertmanager/) - Alertmanager
  Documentation

### 8.3 相关资源

- [监控指标最佳实践](https://www.postgresql.org/docs/current/monitoring-best-practices.html) -
  Monitoring Best Practices
- [告警策略设计](https://prometheus.io/docs/practices/alerting/) - Alerting Practices

---

**最后更新**: 2025 年 11 月 1 日  
**维护者**: PostgreSQL Modern Team  
**文档编号**: 09-02-01
