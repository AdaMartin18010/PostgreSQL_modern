# 9.2.2 性能监控

> **更新时间**: 2025 年 11 月 1 日  
> **文档编号**: 09-02-02

## 📑 目录

- [9.2.2 性能监控](#922-性能监控)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 监控目标](#11-监控目标)
    - [1.2 监控范围](#12-监控范围)
    - [1.3 监控架构](#13-监控架构)
  - [2. 监控指标](#2-监控指标)
    - [2.1 数据库性能指标](#21-数据库性能指标)
      - [2.1.1 关键指标查询](#211-关键指标查询)
      - [2.1.2 表统计信息](#212-表统计信息)
      - [2.1.3 索引使用情况](#213-索引使用情况)
    - [2.2 向量查询监控](#22-向量查询监控)
      - [2.2.1 向量查询性能统计](#221-向量查询性能统计)
      - [2.2.2 向量查询 QPS](#222-向量查询-qps)
      - [2.2.3 向量查询延迟分析](#223-向量查询延迟分析)
    - [2.3 索引性能监控](#23-索引性能监控)
      - [2.3.1 HNSW 索引性能](#231-hnsw-索引性能)
      - [2.3.2 IVFFlat 索引性能](#232-ivfflat-索引性能)
      - [2.3.3 索引效率对比](#233-索引效率对比)
  - [3. Prometheus 集成](#3-prometheus-集成)
    - [3.1 postgres_exporter 配置](#31-postgres_exporter-配置)
      - [3.1.1 Exporter 配置](#311-exporter-配置)
      - [3.1.2 自定义查询](#312-自定义查询)
    - [3.2 Grafana 仪表盘配置](#32-grafana-仪表盘配置)
      - [3.2.1 仪表盘设置](#321-仪表盘设置)
      - [3.2.2 可视化面板](#322-可视化面板)
  - [4. 性能分析工具](#4-性能分析工具)
    - [4.1 慢查询分析](#41-慢查询分析)
      - [4.1.1 慢查询日志视图](#411-慢查询日志视图)
      - [4.1.2 慢查询分析](#412-慢查询分析)
    - [4.2 查询计划分析](#42-查询计划分析)
      - [4.2.1 EXPLAIN 分析](#421-explain-分析)
      - [4.2.2 查询计划优化](#422-查询计划优化)
  - [5. 性能优化建议](#5-性能优化建议)
    - [5.1 基于监控数据的优化](#51-基于监控数据的优化)
      - [5.1.1 识别未使用的索引](#511-识别未使用的索引)
      - [5.1.2 识别需要 VACUUM 的表](#512-识别需要-vacuum-的表)
    - [5.2 自动化优化脚本](#52-自动化优化脚本)
      - [5.2.1 Python 优化脚本](#521-python-优化脚本)
      - [5.2.2 自动化调度](#522-自动化调度)
  - [6. 性能基准测试](#6-性能基准测试)
    - [6.1 基准测试脚本](#61-基准测试脚本)
    - [6.2 性能对比分析](#62-性能对比分析)
  - [7. 最佳实践](#7-最佳实践)
    - [7.1 监控指标选择](#71-监控指标选择)
    - [7.2 性能优化策略](#72-性能优化策略)
  - [8. 参考资料](#8-参考资料)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 技术文档](#82-技术文档)
    - [8.3 相关资源](#83-相关资源)

---

## 1. 概述

### 1.1 监控目标

**核心目标**:

本文档提供 PostgreSQL + pgvector 性能监控的完整指南，帮助您实时掌握系统性能状态。

**监控目标**:

1. **性能监控**: 实时监控数据库查询性能，包括向量查询延迟、吞吐量等
2. **资源监控**: 监控数据库连接数、内存使用、磁盘 I/O 等资源使用情况
3. **索引监控**: 监控索引使用情况，识别未使用的索引和需要优化的索引
4. **优化建议**: 基于监控数据提供性能优化建议

**监控价值**:

| 监控项       | 价值             | 影响             |
| ------------ | ---------------- | ---------------- |
| **性能监控** | 及时发现性能瓶颈 | 减少用户体验影响 |
| **资源监控** | 预测资源需求     | 避免资源耗尽     |
| **索引监控** | 优化索引策略     | 提升查询性能     |
| **优化建议** | 自动化优化       | 减少人工成本     |

### 1.2 监控范围

**监控范围**:

1. **数据库性能指标**:

   - 连接数、事务数、缓存命中率
   - 表统计信息、索引使用情况

2. **向量查询监控**:

   - 向量查询延迟（P50, P95, P99）
   - 向量查询 QPS
   - 向量查询缓存命中率

3. **索引性能监控**:

   - HNSW 索引使用情况
   - IVFFlat 索引使用情况
   - 索引效率分析

4. **系统资源监控**:
   - CPU 使用率
   - 内存使用率
   - 磁盘 I/O

### 1.3 监控架构

**监控架构设计**:

```text
┌─────────────────────────────────────────────────┐
│         PostgreSQL + pgvector                    │
│  ┌──────────┐  ┌──────────┐                    │
│  │pg_stat   │  │pg_stat   │                    │
│  │_statements│ │_database │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────┐
│         postgres_exporter                        │
│  ┌──────────┐  ┌──────────┐                    │
│  │Metric    │  │Custom    │                    │
│  │Collector │  │Queries   │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────┐
│         Prometheus                               │
│  ┌──────────┐  ┌──────────┐                    │
│  │Time      │  │Metric    │                    │
│  │Series DB │  │Queries   │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
                      │
┌─────────────────────────────────────────────────┐
│         Grafana                                  │
│  ┌──────────┐  ┌──────────┐                    │
│  │Dashboard │  │Alert     │                    │
│  │Panel     │  │Rules     │                    │
│  └──────────┘  └──────────┘                    │
└─────────────────────────────────────────────────┘
```

## 2. 监控指标

### 2.1 数据库性能指标

#### 2.1.1 关键指标查询

**数据库连接数和缓存统计**:

```sql
-- 数据库连接数和缓存统计
SELECT
    datname,
    numbackends as connections,
    xact_commit as commits,
    xact_rollback as rollbacks,
    blks_read as disk_reads,
    blks_hit as cache_hits,
    (blks_hit::float / NULLIF(blks_hit + blks_read, 0)) * 100 as cache_hit_rate,
    tup_returned,
    tup_fetched,
    tup_inserted,
    tup_updated,
    tup_deleted
FROM pg_stat_database
WHERE datname = 'vector_db';
```

**关键指标说明**:

| 指标             | 说明       | 重要性 |
| ---------------- | ---------- | ------ |
| `connections`    | 当前连接数 | **高** |
| `commits`        | 提交事务数 | 高     |
| `rollbacks`      | 回滚事务数 | 中     |
| `cache_hit_rate` | 缓存命中率 | **高** |
| `tup_returned`   | 返回行数   | 中     |
| `tup_fetched`    | 获取行数   | 中     |

#### 2.1.2 表统计信息

**表统计信息查询**:

```sql
-- 表统计信息
SELECT
    schemaname,
    tablename,
    n_live_tup as live_tuples,
    n_dead_tup as dead_tuples,
    (n_dead_tup::float / NULLIF(n_live_tup + n_dead_tup, 0)) * 100 as dead_tuple_ratio,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    vacuum_count,
    autovacuum_count,
    analyze_count,
    autoanalyze_count
FROM pg_stat_user_tables
WHERE schemaname = 'public'
ORDER BY n_live_tup DESC;
```

**表统计信息分析**:

| 指标               | 正常范围 | 警告阈值 | 说明             |
| ------------------ | -------- | -------- | ---------------- |
| `dead_tuple_ratio` | **<10%** | **>20%** | 死元组比例       |
| `last_autovacuum`  | **<24h** | **>7d**  | 上次自动清理时间 |
| `last_autoanalyze` | **<24h** | **>7d**  | 上次自动分析时间 |

#### 2.1.3 索引使用情况

**索引使用情况查询**:

```sql
-- 索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    CASE
        WHEN idx_scan = 0 THEN '未使用'
        WHEN idx_scan < 10 THEN '低使用'
        WHEN idx_scan < 100 THEN '中使用'
        ELSE '高使用'
    END as usage_status
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

### 2.2 向量查询监控

#### 2.2.1 向量查询性能统计

**向量查询性能统计**:

```sql
-- 向量查询性能统计
SELECT
    LEFT(query, 100) as query_preview,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    min_exec_time,
    stddev_exec_time,
    rows,
    (shared_blks_hit::float / NULLIF(shared_blks_hit + shared_blks_read, 0)) * 100 as cache_hit_rate,
    (shared_blks_hit + shared_blks_read) as total_blks
FROM pg_stat_statements
WHERE query LIKE '%<=>%' OR query LIKE '%<->%' OR query LIKE '%<#%'  -- 向量查询
ORDER BY mean_exec_time DESC
LIMIT 20;
```

**向量查询性能指标**:

| 指标             | 说明         | 重要性 |
| ---------------- | ------------ | ------ |
| `calls`          | 查询执行次数 | 高     |
| `mean_exec_time` | 平均执行时间 | **高** |
| `max_exec_time`  | 最大执行时间 | 中     |
| `cache_hit_rate` | 缓存命中率   | **高** |

#### 2.2.2 向量查询 QPS

**向量查询 QPS 统计**:

```sql
-- 向量查询 QPS 统计
SELECT
    COUNT(*) as query_count,
    SUM(calls) as total_calls,
    AVG(mean_exec_time) as avg_latency,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY mean_exec_time) as p50_latency,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY mean_exec_time) as p95_latency,
    PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY mean_exec_time) as p99_latency,
    MIN(mean_exec_time) as min_latency,
    MAX(mean_exec_time) as max_latency,
    AVG((shared_blks_hit::float / NULLIF(shared_blks_hit + shared_blks_read, 0))) * 100 as avg_cache_hit_rate
FROM pg_stat_statements
WHERE query LIKE '%<=>%' OR query LIKE '%<->%' OR query LIKE '%<#%';
```

**向量查询性能基准**:

| 数据量     | P50 延迟  | P95 延迟   | P99 延迟   | QPS       |
| ---------- | --------- | ---------- | ---------- | --------- |
| **1 万**   | **<5ms**  | **<10ms**  | **<20ms**  | **>2000** |
| **10 万**  | **<10ms** | **<20ms**  | **<50ms**  | **>1000** |
| **100 万** | **<50ms** | **<100ms** | **<200ms** | **>500**  |

#### 2.2.3 向量查询延迟分析

**向量查询延迟趋势**:

```sql
-- 向量查询延迟趋势（需要配合时间序列数据库）
SELECT
    time_bucket('5 minutes', timestamp) as time,
    AVG(duration_ms) as avg_duration,
    PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY duration_ms) as p95_duration,
    PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY duration_ms) as p99_duration,
    COUNT(*) as query_count
FROM query_logs
WHERE query_type = 'vector_search'
  AND timestamp > NOW() - INTERVAL '1 hour'
GROUP BY time
ORDER BY time;
```

### 2.3 索引性能监控

#### 2.3.1 HNSW 索引性能

**HNSW 索引性能监控**:

```sql
-- HNSW 索引性能监控
SELECT
    tablename,
    indexname,
    idx_scan as scan_count,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    pg_size_pretty(pg_relation_size((schemaname||'.'||tablename)::regclass)) as table_size,
    ROUND(
        100.0 * pg_relation_size(indexrelid) /
        NULLIF(pg_relation_size((schemaname||'.'||tablename)::regclass), 0),
        2
    ) as index_ratio
FROM pg_stat_user_indexes
WHERE indexdef LIKE '%hnsw%'
ORDER BY idx_scan DESC;
```

**HNSW 索引性能指标**:

| 指标          | 正常范围   | 说明         |
| ------------- | ---------- | ------------ |
| `scan_count`  | **>1000**  | 索引扫描次数 |
| `index_ratio` | **<100%**  | 索引大小占比 |
| `tuples_read` | **>10000** | 读取元组数   |

#### 2.3.2 IVFFlat 索引性能

**IVFFlat 索引性能监控**:

```sql
-- IVFFlat 索引性能监控
SELECT
    tablename,
    indexname,
    idx_scan as scan_count,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    pg_size_pretty(pg_relation_size((schemaname||'.'||tablename)::regclass)) as table_size,
    ROUND(
        100.0 * pg_relation_size(indexrelid) /
        NULLIF(pg_relation_size((schemaname||'.'||tablename)::regclass), 0),
        2
    ) as index_ratio
FROM pg_stat_user_indexes
WHERE indexdef LIKE '%ivfflat%'
ORDER BY idx_scan DESC;
```

#### 2.3.3 索引效率对比

**索引效率对比分析**:

| 索引类型    | 扫描次数  | 平均延迟  | 索引大小 | 适用场景        |
| ----------- | --------- | --------- | -------- | --------------- |
| **HNSW**    | **>1000** | **<10ms** | 较大     | **<100 万数据** |
| **IVFFlat** | **>100**  | **<50ms** | 较小     | **>100 万数据** |
| **未使用**  | **<10**   | N/A       | N/A      | 考虑删除        |

## 3. Prometheus 集成

### 3.1 postgres_exporter 配置

#### 3.1.1 Exporter 配置

**postgres_exporter 配置**:

```yaml
# postgres_exporter.yml
data_source_names:
  - postgresql://postgres:password@localhost:5432/vector_db?sslmode=disable

queries:
  - name: "vector_query_performance"
    help: "向量查询性能指标"
    values:
      - calls: calls
      - total_time: total_exec_time
      - mean_time: mean_exec_time
      - max_time: max_exec_time
    query: |
      SELECT 
        calls,
        total_exec_time,
        mean_exec_time,
        max_exec_time
      FROM pg_stat_statements
      WHERE query LIKE '%<=>%' OR query LIKE '%<->%' OR query LIKE '%<#%'
      ORDER BY mean_exec_time DESC
      LIMIT 10

  - name: "index_usage"
    help: "索引使用情况"
    values:
      - idx_scan: idx_scan
      - idx_tup_read: idx_tup_read
      - index_size: index_size_bytes
    query: |
      SELECT
        idx_scan,
        idx_tup_read,
        pg_relation_size(indexrelid) as index_size_bytes
      FROM pg_stat_user_indexes
      WHERE schemaname = 'public'
      ORDER BY idx_scan DESC
```

#### 3.1.2 自定义查询

**自定义查询配置**:

```yaml
# 自定义查询示例
queries:
  - name: "vector_query_qps"
    help: "向量查询 QPS"
    values:
      - qps: qps
    query: |
      SELECT
        SUM(calls) / 60.0 as qps
      FROM pg_stat_statements
      WHERE query LIKE '%<=>%' OR query LIKE '%<->%'

  - name: "cache_hit_rate"
    help: "缓存命中率"
    values:
      - hit_rate: hit_rate
    query: |
      SELECT
        (blks_hit::float / NULLIF(blks_hit + blks_read, 0)) * 100 as hit_rate
      FROM pg_stat_database
      WHERE datname = 'vector_db'
```

### 3.2 Grafana 仪表盘配置

#### 3.2.1 仪表盘设置

**Grafana 仪表盘 JSON**:

```json
{
  "dashboard": {
    "title": "PostgreSQL Vector Performance",
    "refresh": "5s",
    "panels": [
      {
        "id": 1,
        "title": "向量查询延迟 (P95)",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(pg_stat_statements_mean_exec_time{query=~'.*<=>.*'}[5m]))",
            "legendFormat": "P95 延迟"
          }
        ]
      },
      {
        "id": 2,
        "title": "向量查询 QPS",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(pg_stat_statements_calls{query=~'.*<=>.*'}[5m])",
            "legendFormat": "QPS"
          }
        ]
      },
      {
        "id": 3,
        "title": "索引大小",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_database_size_bytes{datname='vector_db'}",
            "legendFormat": "数据库大小"
          }
        ]
      },
      {
        "id": 4,
        "title": "缓存命中率",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_stat_database_blks_hit{datname='vector_db'} / (pg_stat_database_blks_hit{datname='vector_db'} + pg_stat_database_blks_read{datname='vector_db'})",
            "legendFormat": "命中率"
          }
        ]
      }
    ]
  }
}
```

#### 3.2.2 可视化面板

**仪表盘面板说明**:

| 面板             | 类型   | 指标     | 更新频率 | 告警阈值 |
| ---------------- | ------ | -------- | -------- | -------- |
| **查询延迟**     | 折线图 | P95 延迟 | 5 分钟   | >100ms   |
| **向量查询 QPS** | 折线图 | QPS      | 5 分钟   | -        |
| **索引大小**     | 折线图 | 总大小   | 1 小时   | >500GB   |
| **缓存命中率**   | 折线图 | 命中率   | 5 分钟   | <90%     |

## 4. 性能分析工具

### 4.1 慢查询分析

#### 4.1.1 慢查询日志视图

**创建慢查询日志视图**:

```sql
-- 创建慢查询日志视图
CREATE OR REPLACE VIEW slow_queries AS
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    min_exec_time,
    stddev_exec_time,
    (total_exec_time / NULLIF(calls, 0)) as avg_time_per_call,
    rows,
    (shared_blks_hit::float / NULLIF(shared_blks_hit + shared_blks_read, 0)) * 100 as cache_hit_rate,
    ROW_NUMBER() OVER (ORDER BY mean_exec_time DESC) as rank
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- 超过 100ms
ORDER BY mean_exec_time DESC
LIMIT 50;

-- 查看慢查询
SELECT * FROM slow_queries;
```

#### 4.1.2 慢查询分析

**慢查询详细分析**:

```sql
-- 慢查询详细分析
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    (total_exec_time / NULLIF(calls, 0)) as avg_time_per_call,
    CASE
        WHEN mean_exec_time > 1000 THEN '严重'
        WHEN mean_exec_time > 500 THEN '警告'
        WHEN mean_exec_time > 100 THEN '注意'
        ELSE '正常'
    END as severity
FROM pg_stat_statements
WHERE mean_exec_time > 100
ORDER BY mean_exec_time DESC
LIMIT 20;
```

### 4.2 查询计划分析

#### 4.2.1 EXPLAIN 分析

**查询计划分析**:

```sql
-- 分析向量查询计划
EXPLAIN (ANALYZE, BUFFERS, VERBOSE, FORMAT JSON)
SELECT
    id,
    content,
    1 - (embedding <=> '[0.1, 0.2, 0.3, ...]'::vector(1536)) as similarity
FROM documents
ORDER BY embedding <=> '[0.1, 0.2, 0.3, ...]'::vector(1536)
LIMIT 10;

-- 文本格式输出（更易读）
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT
    id,
    content,
    1 - (embedding <=> '[0.1, 0.2, 0.3, ...]'::vector(1536)) as similarity
FROM documents
ORDER BY embedding <=> '[0.1, 0.2, 0.3, ...]'::vector(1536)
LIMIT 10;
```

#### 4.2.2 查询计划优化

**查询计划关键指标**:

| 指标                     | 说明         | 优化建议              |
| ------------------------ | ------------ | --------------------- |
| **Execution Time**       | 执行时间     | 如果 >100ms，考虑优化 |
| **Planning Time**        | 计划时间     | 如果 >10ms，考虑优化  |
| **Buffers: shared hit**  | 共享缓存命中 | 命中率应 >90%         |
| **Buffers: shared read** | 共享缓存读取 | 读取次数应尽可能少    |

## 5. 性能优化建议

### 5.1 基于监控数据的优化

#### 5.1.1 识别未使用的索引

**识别未使用的索引**:

```sql
-- 识别未使用的索引
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan as scan_count,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    pg_size_pretty(pg_relation_size((schemaname||'.'||tablename)::regclass)) as table_size,
    CASE
        WHEN idx_scan = 0 THEN '未使用 - 考虑删除'
        WHEN idx_scan < 10 AND pg_relation_size(indexrelid) > 10485760 THEN '低使用 - 考虑删除'
        ELSE '正常'
    END as recommendation
FROM pg_stat_user_indexes
WHERE idx_scan < 10
  AND pg_relation_size(indexrelid) > 1048576  -- 大于 1MB
ORDER BY pg_relation_size(indexrelid) DESC;
```

**索引优化建议**:

| 扫描次数 | 索引大小  | 建议     |
| -------- | --------- | -------- |
| **0**    | **>1MB**  | **删除** |
| **<10**  | **>10MB** | **删除** |
| **<10**  | **<1MB**  | **保留** |

#### 5.1.2 识别需要 VACUUM 的表

**识别需要 VACUUM 的表**:

```sql
-- 识别需要 VACUUM 的表
SELECT
    schemaname,
    tablename,
    n_live_tup as live_tuples,
    n_dead_tup as dead_tuples,
    (n_dead_tup::float / NULLIF(n_live_tup + n_dead_tup, 0)) * 100 as dead_tuple_ratio,
    pg_size_pretty(pg_total_relation_size((schemaname||'.'||tablename)::regclass)) as table_size,
    last_vacuum,
    last_autovacuum,
    CASE
        WHEN n_dead_tup > 10000 AND (n_dead_tup::float / NULLIF(n_live_tup, 0)) > 0.2 THEN '紧急 VACUUM'
        WHEN n_dead_tup > 1000 AND (n_dead_tup::float / NULLIF(n_live_tup, 0)) > 0.1 THEN '建议 VACUUM'
        ELSE '正常'
    END as recommendation
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;
```

**VACUUM 优化建议**:

| 死元组比例 | 死元组数量 | 建议            |
| ---------- | ---------- | --------------- |
| **>20%**   | **>10000** | **紧急 VACUUM** |
| **>10%**   | **>1000**  | **建议 VACUUM** |
| **<10%**   | **<1000**  | **正常**        |

### 5.2 自动化优化脚本

#### 5.2.1 Python 优化脚本

**自动化优化脚本**:

```python
# optimize.py
import psycopg2
from psycopg2.extras import RealDictCursor
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = "postgresql://postgres:postgres@localhost:5432/vector_db"

def analyze_and_optimize():
    """分析并优化"""
    conn = psycopg2.connect(DATABASE_URL)
    cur = conn.cursor(cursor_factory=RealDictCursor)

    try:
        # 1. 检查需要 VACUUM 的表
        cur.execute("""
            SELECT schemaname, tablename, n_dead_tup
            FROM pg_stat_user_tables
            WHERE n_dead_tup > 1000
              AND (n_dead_tup::float / NULLIF(n_live_tup, 0)) > 0.1
            ORDER BY n_dead_tup DESC
        """)

        for row in cur.fetchall():
            logger.info(f"执行 VACUUM ANALYZE: {row['schemaname']}.{row['tablename']}")
            cur.execute(f"VACUUM ANALYZE {row['schemaname']}.{row['tablename']}")
            conn.commit()

        # 2. 检查需要重建的索引
        cur.execute("""
            SELECT schemaname, tablename, indexname, idx_scan
            FROM pg_stat_user_indexes
            WHERE idx_scan = 0
              AND pg_relation_size(indexrelid) > 1048576  -- 大于 1MB
        """)

        unused_indexes = cur.fetchall()
        if unused_indexes:
            logger.warning(f"发现 {len(unused_indexes)} 个未使用的索引（>1MB）")
            for row in unused_indexes:
                logger.info(f"考虑删除未使用的索引: {row['indexname']}")
                # 注意：删除索引需要谨慎，建议先手动确认

        # 3. 更新统计信息
        cur.execute("ANALYZE")
        conn.commit()
        logger.info("统计信息更新完成")

    except Exception as e:
        logger.error(f"优化错误: {e}")
        conn.rollback()
    finally:
        conn.close()

if __name__ == "__main__":
    analyze_and_optimize()
```

#### 5.2.2 自动化调度

**使用 cron 或 systemd 定时任务**:

```bash
# 使用 cron 每天凌晨 2 点执行
# crontab -e
0 2 * * * /usr/bin/python3 /path/to/optimize.py >> /var/log/postgres_optimize.log 2>&1
```

**使用 systemd timer**:

```ini
# /etc/systemd/system/postgres-optimize.service
[Unit]
Description=PostgreSQL Optimization Script
After=postgresql.service

[Service]
Type=oneshot
ExecStart=/usr/bin/python3 /path/to/optimize.py
User=postgres

# /etc/systemd/system/postgres-optimize.timer
[Unit]
Description=Run PostgreSQL Optimization Daily
Requires=postgres-optimize.service

[Timer]
OnCalendar=daily
AccuracySec=1h
Persistent=true

[Install]
WantedBy=timers.target
```

## 6. 性能基准测试

### 6.1 基准测试脚本

**性能基准测试脚本**:

```sql
-- benchmark.sql
CREATE OR REPLACE FUNCTION benchmark_vector_search(
    test_rows INTEGER DEFAULT 100000,
    test_queries INTEGER DEFAULT 1000
) RETURNS TABLE (
    metric TEXT,
    value NUMERIC
) AS $$
DECLARE
    start_time TIMESTAMPTZ;
    end_time TIMESTAMPTZ;
    elapsed INTERVAL;
    query_vector vector(1536);
BEGIN
    -- 创建测试表
    CREATE TABLE IF NOT EXISTS benchmark_docs (
        id SERIAL PRIMARY KEY,
        content TEXT,
        embedding vector(1536)
    );

    -- 清空测试数据
    TRUNCATE benchmark_docs;

    -- 插入测试数据
    INSERT INTO benchmark_docs (content, embedding)
    SELECT
        'Document ' || i,
        (SELECT array_agg(random())::vector(1536)
         FROM generate_series(1, 1536))
    FROM generate_series(1, test_rows);

    -- 创建索引
    CREATE INDEX IF NOT EXISTS benchmark_docs_idx
    ON benchmark_docs
    USING hnsw (embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);

    -- 基准测试
    start_time := clock_timestamp();

    FOR i IN 1..test_queries LOOP
        query_vector := (SELECT array_agg(random())::vector(1536)
                       FROM generate_series(1, 1536));

        PERFORM * FROM (
            SELECT * FROM benchmark_docs
            ORDER BY embedding <=> query_vector
            LIMIT 10
        ) q;
    END LOOP;

    end_time := clock_timestamp();
    elapsed := end_time - start_time;

    -- 返回结果
    RETURN QUERY SELECT '总耗时 (秒)'::TEXT, EXTRACT(EPOCH FROM elapsed);
    RETURN QUERY SELECT '平均延迟 (ms)'::TEXT, EXTRACT(EPOCH FROM elapsed) / test_queries * 1000;
    RETURN QUERY SELECT 'QPS'::TEXT, test_queries / EXTRACT(EPOCH FROM elapsed);
END;
$$ LANGUAGE plpgsql;

-- 运行基准测试
SELECT * FROM benchmark_vector_search(100000, 1000);
```

### 6.2 性能对比分析

**性能基准测试结果**:

| 数据规模   | 索引类型 | P50 延迟  | P95 延迟   | P99 延迟   | QPS       |
| ---------- | -------- | --------- | ---------- | ---------- | --------- |
| **1 万**   | HNSW     | **<5ms**  | **<10ms**  | **<20ms**  | **>2000** |
| **10 万**  | HNSW     | **<10ms** | **<20ms**  | **<50ms**  | **>1000** |
| **100 万** | IVFFlat  | **<50ms** | **<100ms** | **<200ms** | **>500**  |

## 7. 最佳实践

### 7.1 监控指标选择

**监控指标选择原则**:

1. **关键指标优先**: 优先监控影响业务的关键指标（查询延迟、QPS）
2. **全面覆盖**: 覆盖性能、资源、索引等各个方面
3. **合理频率**: 根据指标特性设置合理的采集频率
4. **成本控制**: 平衡监控成本和监控价值

### 7.2 性能优化策略

**性能优化策略**:

1. **定期 VACUUM**: 定期清理死元组，保持表健康
2. **索引优化**: 删除未使用的索引，优化索引参数
3. **查询优化**: 基于慢查询日志优化查询语句
4. **资源优化**: 根据监控数据调整资源分配

## 8. 参考资料

### 8.1 官方文档

- [PostgreSQL 性能监控](https://www.postgresql.org/docs/current/monitoring-stats.html) - Monitoring
  Stats
- [pg_stat_statements 文档](https://www.postgresql.org/docs/current/pgstatstatements.html) -
  pg_stat_statements

### 8.2 技术文档

- [监控与告警](./监控与告警.md) - Monitoring and Alerting
- [性能调优技巧](../../01-向量与混合搜索/最佳实践/性能调优技巧.md) - Performance Tuning

### 8.3 相关资源

- [PostgreSQL 性能优化指南](https://www.postgresql.org/docs/current/performance-tips.html) -
  Performance Tips
- [查询优化最佳实践](https://www.postgresql.org/docs/current/using-explain.html) - Using EXPLAIN

---

**最后更新**: 2025 年 11 月 1 日  
**维护者**: PostgreSQL Modern Team  
**文档编号**: 09-02-02
