# æ•°æ®æ³¨å…¥ä¸æ²»ç†

> **æ–‡æ¡£ç¼–å·**: AI-03-06
> **æœ€åæ›´æ–°**: 2025å¹´1æœˆ
> **ä¸»é¢˜**: 03-æ ¸å¿ƒèƒ½åŠ›
> **å­ä¸»é¢˜**: 06-æ•°æ®æ³¨å…¥ä¸æ²»ç†

## ğŸ“‘ ç›®å½•

- [æ•°æ®æ³¨å…¥ä¸æ²»ç†](#æ•°æ®æ³¨å…¥ä¸æ²»ç†)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
  - [äºŒã€æ•°æ®æ³¨å…¥æ–¹å¼](#äºŒæ•°æ®æ³¨å…¥æ–¹å¼)
    - [2.1 CDCå˜æ›´æ•°æ®æ•è·](#21-cdcå˜æ›´æ•°æ®æ•è·)
    - [2.2 æ‰¹é‡ETLå¤„ç†](#22-æ‰¹é‡etlå¤„ç†)
    - [2.3 å®æ—¶æµå¼å¤„ç†](#23-å®æ—¶æµå¼å¤„ç†)
  - [ä¸‰ã€æ•°æ®è´¨é‡ä¿è¯](#ä¸‰æ•°æ®è´¨é‡ä¿è¯)
    - [3.1 æ•°æ®éªŒè¯](#31-æ•°æ®éªŒè¯)
    - [3.2 æ•°æ®æ¸…æ´—](#32-æ•°æ®æ¸…æ´—)
    - [3.3 æ•°æ®æ ‡å‡†åŒ–](#33-æ•°æ®æ ‡å‡†åŒ–)
  - [å››ã€æ•°æ®ç‰ˆæœ¬ç®¡ç†](#å››æ•°æ®ç‰ˆæœ¬ç®¡ç†)
    - [4.1 ç‰ˆæœ¬æ§åˆ¶ç­–ç•¥](#41-ç‰ˆæœ¬æ§åˆ¶ç­–ç•¥)
    - [4.2 æ•°æ®å¿«ç…§](#42-æ•°æ®å¿«ç…§)
    - [4.3 æ•°æ®å›æ»š](#43-æ•°æ®å›æ»š)
  - [äº”ã€è‡ªåŠ¨åŒ–å‘é‡åŒ–ç®¡é“](#äº”è‡ªåŠ¨åŒ–å‘é‡åŒ–ç®¡é“)
    - [5.1 pgai Vectorizer](#51-pgai-vectorizer)
    - [5.2 æ‰¹é‡å¤„ç†](#52-æ‰¹é‡å¤„ç†)
    - [5.3 å¢é‡æ›´æ–°](#53-å¢é‡æ›´æ–°)
  - [å…­ã€ç›‘æ§ä¸å‘Šè­¦](#å…­ç›‘æ§ä¸å‘Šè­¦)
    - [6.1 æ•°æ®è´¨é‡ç›‘æ§](#61-æ•°æ®è´¨é‡ç›‘æ§)
    - [6.2 å¤„ç†è¿›åº¦ç›‘æ§](#62-å¤„ç†è¿›åº¦ç›‘æ§)
    - [6.3 å¼‚å¸¸å‘Šè­¦](#63-å¼‚å¸¸å‘Šè­¦)
  - [ä¸ƒã€æœ€ä½³å®è·µ](#ä¸ƒæœ€ä½³å®è·µ)
  - [å…«ã€å…³è”ä¸»é¢˜](#å…«å…³è”ä¸»é¢˜)
  - [ä¹ã€å¯¹æ ‡èµ„æº](#ä¹å¯¹æ ‡èµ„æº)
    - [æŠ€æœ¯æ–‡æ¡£](#æŠ€æœ¯æ–‡æ¡£)
    - [ä¼ä¸šæ¡ˆä¾‹](#ä¼ä¸šæ¡ˆä¾‹)

## ä¸€ã€æ¦‚è¿°

PostgreSQL AIåº”ç”¨çš„æ•°æ®æ³¨å…¥ä¸æ²»ç†èƒ½åŠ›ï¼ŒåŒ…æ‹¬CDCå˜æ›´æ•è·ã€æ‰¹é‡ETLã€å®æ—¶æµå¤„ç†ã€æ•°æ®è´¨é‡ä¿è¯ã€ç‰ˆæœ¬ç®¡ç†å’Œè‡ªåŠ¨åŒ–å‘é‡åŒ–ç®¡é“ï¼Œç¡®ä¿æ•°æ®ä»æºå¤´åˆ°AIåº”ç”¨çš„å®Œæ•´æ²»ç†é“¾è·¯ã€‚

## äºŒã€æ•°æ®æ³¨å…¥æ–¹å¼

### 2.1 CDCå˜æ›´æ•°æ®æ•è·

**ä½¿ç”¨Debeziumå®ç°CDC**:

```sql
-- é…ç½®é€»è¾‘å¤åˆ¶
ALTER SYSTEM SET wal_level = logical;
SELECT pg_reload_conf();

-- åˆ›å»ºé€»è¾‘å¤åˆ¶æ§½
SELECT pg_create_logical_replication_slot('debezium_slot', 'pgoutput');

-- ä½¿ç”¨Debeziumæ•è·å˜æ›´
-- Debeziumä¼šè‡ªåŠ¨åˆ›å»ºå˜æ›´è¡¨
CREATE TABLE products_cdc (
    id INTEGER PRIMARY KEY,
    title TEXT,
    description TEXT,
    created_at TIMESTAMPTZ
);

-- å˜æ›´æ•°æ®è‡ªåŠ¨åŒæ­¥åˆ°å‘é‡è¡¨
CREATE OR REPLACE FUNCTION sync_cdc_to_vector()
RETURNS TRIGGER AS $$
BEGIN
    -- è‡ªåŠ¨ç”Ÿæˆå‘é‡
    INSERT INTO product_embeddings (product_id, embedding)
    VALUES (
        NEW.id,
        ai.embedding('text-embedding-3-small', NEW.description)
    )
    ON CONFLICT (product_id) DO UPDATE
    SET embedding = ai.embedding('text-embedding-3-small', NEW.description);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER cdc_vector_sync
AFTER INSERT OR UPDATE ON products_cdc
FOR EACH ROW
EXECUTE FUNCTION sync_cdc_to_vector();
```

### 2.2 æ‰¹é‡ETLå¤„ç†

**ä½¿ç”¨Airflowè°ƒåº¦ETLä»»åŠ¡**:

```python
# Airflow DAGç¤ºä¾‹
from airflow.providers.postgres.operators.postgres import PostgresOperator
from airflow.operators.python import PythonOperator

def generate_embeddings(**context):
    """æ‰¹é‡ç”ŸæˆEmbedding"""
    import psycopg2
    import openai

    conn = psycopg2.connect("postgresql://...")
    cur = conn.cursor()

    # è·å–æœªå¤„ç†çš„æ–‡æ¡£
    cur.execute("""
        SELECT id, content
        FROM documents
        WHERE embedding IS NULL
        LIMIT 1000
    """)

    docs = cur.fetchall()

    # æ‰¹é‡ç”Ÿæˆå‘é‡
    for doc_id, content in docs:
        embedding = openai.Embedding.create(
            input=content,
            model="text-embedding-3-small"
        )

        # æ›´æ–°å‘é‡
        cur.execute("""
            UPDATE documents
            SET embedding = %s
            WHERE id = %s
        """, (embedding['data'][0]['embedding'], doc_id))

    conn.commit()
    conn.close()

with DAG('ai_data_pipeline', schedule_interval='@hourly') as dag:
    extract = PostgresOperator(
        task_id='extract',
        sql="SELECT * FROM raw_documents WHERE processed=false"
    )

    transform = PythonOperator(
        task_id='generate_embeddings',
        python_callable=generate_embeddings
    )

    load = PostgresOperator(
        task_id='load',
        sql="UPDATE raw_documents SET processed=true"
    )

    extract >> transform >> load
```

### 2.3 å®æ—¶æµå¼å¤„ç†

**ä½¿ç”¨Kafka + Flinkå®ç°å®æ—¶å¤„ç†**:

```sql
-- ä½¿ç”¨kafka_fdwè¿æ¥Kafka
CREATE EXTENSION kafka_fdw;

CREATE SERVER kafka_server
FOREIGN DATA WRAPPER kafka_fdw
OPTIONS (
    broker 'localhost:9092',
    topic 'documents'
);

-- åˆ›å»ºå¤–éƒ¨è¡¨
CREATE FOREIGN TABLE kafka_documents (
    id INTEGER,
    content TEXT,
    timestamp TIMESTAMPTZ
) SERVER kafka_server;

-- å®æ—¶å¤„ç†æµæ•°æ®
CREATE OR REPLACE FUNCTION process_stream_data()
RETURNS void AS $$
DECLARE
    v_record RECORD;
BEGIN
    FOR v_record IN
        SELECT * FROM kafka_documents
        WHERE processed = false
    LOOP
        -- ç”Ÿæˆå‘é‡
        INSERT INTO document_embeddings (document_id, embedding)
        VALUES (
            v_record.id,
            ai.embedding('text-embedding-3-small', v_record.content)
        );

        -- æ ‡è®°å·²å¤„ç†
        UPDATE kafka_documents
        SET processed = true
        WHERE id = v_record.id;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## ä¸‰ã€æ•°æ®è´¨é‡ä¿è¯

### 3.1 æ•°æ®éªŒè¯

```sql
-- æ•°æ®éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_document(
    p_content TEXT,
    p_metadata JSONB
) RETURNS BOOLEAN AS $$
BEGIN
    -- æ£€æŸ¥å†…å®¹éç©º
    IF p_content IS NULL OR LENGTH(TRIM(p_content)) = 0 THEN
        RETURN false;
    END IF;

    -- æ£€æŸ¥å†…å®¹é•¿åº¦
    IF LENGTH(p_content) < 10 THEN
        RETURN false;
    END IF;

    -- æ£€æŸ¥å…ƒæ•°æ®æ ¼å¼
    IF p_metadata IS NOT NULL AND NOT (p_metadata ? 'source') THEN
        RETURN false;
    END IF;

    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION insert_validated_document(
    p_content TEXT,
    p_metadata JSONB
) RETURNS INTEGER AS $$
DECLARE
    v_doc_id INTEGER;
BEGIN
    -- éªŒè¯æ•°æ®
    IF NOT validate_document(p_content, p_metadata) THEN
        RAISE EXCEPTION 'Invalid document data';
    END IF;

    -- æ’å…¥æ•°æ®
    INSERT INTO documents (content, metadata)
    VALUES (p_content, p_metadata)
    RETURNING id INTO v_doc_id;

    RETURN v_doc_id;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 æ•°æ®æ¸…æ´—

```sql
-- æ•°æ®æ¸…æ´—å‡½æ•°
CREATE OR REPLACE FUNCTION clean_document_content(
    p_content TEXT
) RETURNS TEXT AS $$
BEGIN
    -- ç§»é™¤HTMLæ ‡ç­¾
    p_content := regexp_replace(p_content, '<[^>]+>', '', 'g');

    -- ç§»é™¤å¤šä½™ç©ºç™½
    p_content := regexp_replace(p_content, '\s+', ' ', 'g');

    -- ç§»é™¤ç‰¹æ®Šå­—ç¬¦
    p_content := regexp_replace(p_content, '[^\w\s]', '', 'g');

    -- è½¬æ¢ä¸ºå°å†™
    p_content := LOWER(p_content);

    RETURN TRIM(p_content);
END;
$$ LANGUAGE plpgsql;

-- ä½¿ç”¨æ¸…æ´—å‡½æ•°
UPDATE documents
SET content = clean_document_content(content)
WHERE content != clean_document_content(content);
```

### 3.3 æ•°æ®æ ‡å‡†åŒ–

```sql
-- æ•°æ®æ ‡å‡†åŒ–è¡¨
CREATE TABLE data_quality_rules (
    id SERIAL PRIMARY KEY,
    rule_name TEXT UNIQUE,
    rule_type TEXT,  -- 'validation', 'transformation', 'normalization'
    rule_definition JSONB,
    enabled BOOLEAN DEFAULT true
);

-- åº”ç”¨æ ‡å‡†åŒ–è§„åˆ™
CREATE OR REPLACE FUNCTION apply_quality_rules(
    p_data JSONB
) RETURNS JSONB AS $$
DECLARE
    v_rule RECORD;
    v_result JSONB := p_data;
BEGIN
    FOR v_rule IN
        SELECT * FROM data_quality_rules
        WHERE enabled = true
        ORDER BY id
    LOOP
        -- åº”ç”¨è§„åˆ™
        CASE v_rule.rule_type
            WHEN 'normalization' THEN
                -- æ ‡å‡†åŒ–å¤„ç†
                v_result := jsonb_normalize(v_result, v_rule.rule_definition);
            WHEN 'transformation' THEN
                -- è½¬æ¢å¤„ç†
                v_result := jsonb_transform(v_result, v_rule.rule_definition);
        END CASE;
    END LOOP;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

## å››ã€æ•°æ®ç‰ˆæœ¬ç®¡ç†

### 4.1 ç‰ˆæœ¬æ§åˆ¶ç­–ç•¥

```sql
-- ç‰ˆæœ¬æ§åˆ¶è¡¨
CREATE TABLE document_versions (
    id SERIAL PRIMARY KEY,
    document_id INTEGER REFERENCES documents(id),
    version INTEGER,
    content TEXT,
    embedding vector(1536),
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by TEXT,
    UNIQUE(document_id, version)
);

-- ç‰ˆæœ¬æ§åˆ¶å‡½æ•°
CREATE OR REPLACE FUNCTION create_document_version(
    p_document_id INTEGER,
    p_content TEXT,
    p_metadata JSONB
) RETURNS INTEGER AS $$
DECLARE
    v_version INTEGER;
    v_embedding vector(1536);
BEGIN
    -- è·å–ä¸‹ä¸€ä¸ªç‰ˆæœ¬å·
    SELECT COALESCE(MAX(version), 0) + 1
    INTO v_version
    FROM document_versions
    WHERE document_id = p_document_id;

    -- ç”Ÿæˆå‘é‡
    v_embedding := ai.embedding('text-embedding-3-small', p_content);

    -- åˆ›å»ºç‰ˆæœ¬
    INSERT INTO document_versions (
        document_id,
        version,
        content,
        embedding,
        metadata
    ) VALUES (
        p_document_id,
        v_version,
        p_content,
        v_embedding,
        p_metadata
    );

    RETURN v_version;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 æ•°æ®å¿«ç…§

```sql
-- ä½¿ç”¨è¡¨ç»§æ‰¿å®ç°å¿«ç…§
CREATE TABLE documents_snapshot_20240101 (
    LIKE documents INCLUDING ALL
) INHERITS (documents);

-- åˆ›å»ºå¿«ç…§
CREATE OR REPLACE FUNCTION create_snapshot(
    p_table_name TEXT,
    p_snapshot_name TEXT
) RETURNS void AS $$
BEGIN
    EXECUTE format('
        CREATE TABLE %I (
            LIKE %I INCLUDING ALL
        ) INHERITS (%I)
    ', p_snapshot_name, p_table_name, p_table_name);

    EXECUTE format('
        INSERT INTO %I SELECT * FROM %I
    ', p_snapshot_name, p_table_name);
END;
$$ LANGUAGE plpgsql;
```

### 4.3 æ•°æ®å›æ»š

```sql
-- å›æ»šåˆ°æŒ‡å®šç‰ˆæœ¬
CREATE OR REPLACE FUNCTION rollback_document(
    p_document_id INTEGER,
    p_version INTEGER
) RETURNS void AS $$
DECLARE
    v_version_data RECORD;
BEGIN
    -- è·å–ç‰ˆæœ¬æ•°æ®
    SELECT * INTO v_version_data
    FROM document_versions
    WHERE document_id = p_document_id
      AND version = p_version;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Version % not found', p_version;
    END IF;

    -- å›æ»šæ•°æ®
    UPDATE documents
    SET
        content = v_version_data.content,
        embedding = v_version_data.embedding,
        metadata = v_version_data.metadata
    WHERE id = p_document_id;
END;
$$ LANGUAGE plpgsql;
```

## äº”ã€è‡ªåŠ¨åŒ–å‘é‡åŒ–ç®¡é“

### 5.1 pgai Vectorizer

```sql
-- åˆ›å»ºè‡ªåŠ¨å‘é‡åŒ–å™¨
SELECT ai.create_vectorizer(
    'news_articles'::regclass,
    destination => 'news_embeddings',
    embedding => ai.embedding_openai('text-embedding-3-small', 'content'),
    chunking => ai.chunking_recursive_character_text_splitter(
        'content',
        chunk_size => 500,
        chunk_overlap => 50
    )
);

-- åç»­INSERTè‡ªåŠ¨è§¦å‘å‘é‡åŒ–
INSERT INTO news_articles (title, content)
VALUES ('Fed Raises Rates', 'The Federal Reserve...');
-- è‡ªåŠ¨åŒæ­¥ç”Ÿæˆå‘é‡åˆ°news_embeddingsè¡¨
```

### 5.2 æ‰¹é‡å¤„ç†

```sql
-- æ‰¹é‡å¤„ç†å†å²æ•°æ®
SELECT ai.vectorize_table(
    source_table => 'news_articles',
    destination_table => 'news_embeddings',
    batch_size => 1000
);

-- ç›‘æ§å¤„ç†è¿›åº¦
SELECT
    COUNT(*) FILTER (WHERE processed = true) AS processed,
    COUNT(*) AS total,
    ROUND(100.0 * COUNT(*) FILTER (WHERE processed = true) / COUNT(*), 2) AS progress_pct
FROM news_articles;
```

### 5.3 å¢é‡æ›´æ–°

```sql
-- å¢é‡æ›´æ–°å‘é‡
CREATE OR REPLACE FUNCTION incremental_vectorize()
RETURNS void AS $$
BEGIN
    -- å¤„ç†æ–°å¢æ•°æ®
    INSERT INTO news_embeddings (article_id, embedding)
    SELECT
        id,
        ai.embedding('text-embedding-3-small', content)
    FROM news_articles
    WHERE id NOT IN (SELECT article_id FROM news_embeddings)
      AND content IS NOT NULL;

    -- å¤„ç†æ›´æ–°æ•°æ®
    UPDATE news_embeddings ne
    SET embedding = ai.embedding('text-embedding-3-small', na.content)
    FROM news_articles na
    WHERE ne.article_id = na.id
      AND na.updated_at > ne.updated_at;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶æ‰§è¡Œå¢é‡æ›´æ–°
SELECT cron.schedule(
    'incremental-vectorize',
    '*/30 * * * *',  -- æ¯30åˆ†é’Ÿ
    'SELECT incremental_vectorize()'
);
```

## å…­ã€ç›‘æ§ä¸å‘Šè­¦

### 6.1 æ•°æ®è´¨é‡ç›‘æ§

```sql
-- æ•°æ®è´¨é‡ç›‘æ§è§†å›¾
CREATE VIEW data_quality_metrics AS
SELECT
    'documents' AS table_name,
    COUNT(*) AS total_records,
    COUNT(*) FILTER (WHERE content IS NOT NULL) AS valid_records,
    COUNT(*) FILTER (WHERE embedding IS NULL) AS missing_embeddings,
    AVG(LENGTH(content)) AS avg_content_length
FROM documents;

-- è´¨é‡å‘Šè­¦
CREATE OR REPLACE FUNCTION check_data_quality()
RETURNS void AS $$
DECLARE
    v_quality_metrics RECORD;
BEGIN
    SELECT * INTO v_quality_metrics FROM data_quality_metrics;

    -- æ£€æŸ¥ç¼ºå¤±å‘é‡æ¯”ä¾‹
    IF v_quality_metrics.missing_embeddings::DECIMAL /
       NULLIF(v_quality_metrics.total_records, 0) > 0.1 THEN
        PERFORM pg_notify('data_quality_alert',
            format('High missing embedding rate: %s%%',
                ROUND(100.0 * v_quality_metrics.missing_embeddings /
                      NULLIF(v_quality_metrics.total_records, 0), 2)));
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 6.2 å¤„ç†è¿›åº¦ç›‘æ§

```sql
-- å¤„ç†è¿›åº¦ç›‘æ§
CREATE OR REPLACE FUNCTION monitor_processing_progress()
RETURNS TABLE (
    table_name TEXT,
    total_count BIGINT,
    processed_count BIGINT,
    progress_pct DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'news_articles'::TEXT,
        COUNT(*)::BIGINT,
        COUNT(*) FILTER (WHERE id IN (
            SELECT article_id FROM news_embeddings
        ))::BIGINT,
        ROUND(100.0 * COUNT(*) FILTER (WHERE id IN (
            SELECT article_id FROM news_embeddings
        )) / NULLIF(COUNT(*), 0), 2)::DECIMAL
    FROM news_articles;
END;
$$ LANGUAGE plpgsql;
```

### 6.3 å¼‚å¸¸å‘Šè­¦

```sql
-- å¼‚å¸¸å‘Šè­¦å‡½æ•°
CREATE OR REPLACE FUNCTION check_processing_errors()
RETURNS void AS $$
DECLARE
    v_error_count INTEGER;
BEGIN
    -- æ£€æŸ¥å¤„ç†å¤±è´¥çš„æ•°æ®
    SELECT COUNT(*) INTO v_error_count
    FROM news_articles
    WHERE content IS NOT NULL
      AND id NOT IN (SELECT article_id FROM news_embeddings)
      AND created_at < NOW() - INTERVAL '1 hour';

    IF v_error_count > 10 THEN
        PERFORM pg_notify('processing_error_alert',
            format('Processing errors detected: %s records', v_error_count));
    END IF;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶æ£€æŸ¥
SELECT cron.schedule(
    'check-processing-errors',
    '*/15 * * * *',
    'SELECT check_processing_errors()'
);
```

## ä¸ƒã€æœ€ä½³å®è·µ

1. **æ•°æ®æ³¨å…¥**:
   - ä½¿ç”¨CDCå®ç°å®æ—¶åŒæ­¥
   - æ‰¹é‡ETLå¤„ç†å†å²æ•°æ®
   - æµå¼å¤„ç†å®æ—¶æ•°æ®

2. **æ•°æ®è´¨é‡**:
   - åœ¨å…¥å£å¤„éªŒè¯æ•°æ®
   - è‡ªåŠ¨æ¸…æ´—å’Œæ ‡å‡†åŒ–
   - ç›‘æ§æ•°æ®è´¨é‡æŒ‡æ ‡

3. **ç‰ˆæœ¬ç®¡ç†**:
   - ä¿ç•™é‡è¦æ•°æ®ç‰ˆæœ¬
   - æ”¯æŒå¿«é€Ÿå›æ»š
   - è®°å½•å˜æ›´å†å²

4. **è‡ªåŠ¨åŒ–**:
   - ä½¿ç”¨pgai Vectorizerè‡ªåŠ¨å‘é‡åŒ–
   - å®šæ—¶å¢é‡æ›´æ–°
   - ç›‘æ§å’Œå‘Šè­¦è‡ªåŠ¨åŒ–

## å…«ã€å…³è”ä¸»é¢˜

- [AIåŸç”Ÿè°ƒç”¨ (pgai)](./AIåŸç”Ÿè°ƒç”¨-pgai.md) - VectorizeråŠŸèƒ½
- [æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯](./æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯.md) - æ‰¹é‡å¤„ç†ä¼˜åŒ–
- [Timescale MarketReaderæ¡ˆä¾‹](../05-å®è·µæ¡ˆä¾‹/Timescale-MarketReaderæ¡ˆä¾‹.md) - è‡ªåŠ¨åŒ–åº”ç”¨

## ä¹ã€å¯¹æ ‡èµ„æº

### æŠ€æœ¯æ–‡æ¡£

- [Debeziumæ–‡æ¡£](https://debezium.io/documentation/)
- [Airflowæ–‡æ¡£](https://airflow.apache.org/docs/)
- [pgai Vectorizeræ–‡æ¡£](https://github.com/pgai/pgai)

### ä¼ä¸šæ¡ˆä¾‹

- **Timescale MarketReader**: è‡ªåŠ¨åŒ–Embeddingç”Ÿæˆ
- **å¼€å‘å‘¨æœŸ**: 3ä¸ªæœˆ â†’ 2å‘¨ (ç¼©çŸ­85%)

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: AI-03-06
