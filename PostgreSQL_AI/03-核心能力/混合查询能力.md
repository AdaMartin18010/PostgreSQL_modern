# 混合查询能力

> **文档编号**: AI-03-03
> **最后更新**: 2025年1月
> **主题**: 03-核心能力
> **子主题**: 03-混合查询能力

## 📑 目录

- [混合查询能力](#混合查询能力)
  - [📑 目录](#-目录)
  - [一、概述](#一概述)
  - [二、混合查询类型](#二混合查询类型)
    - [2.1 向量+SQL联合查询](#21-向量sql联合查询)
    - [2.2 向量+全文搜索](#22-向量全文搜索)
    - [2.3 向量+地理空间查询](#23-向量地理空间查询)
    - [2.4 多模态数据查询](#24-多模态数据查询)
  - [三、查询优化策略](#三查询优化策略)
    - [3.1 索引组合策略](#31-索引组合策略)
    - [3.2 查询计划优化](#32-查询计划优化)
    - [3.3 结果融合算法](#33-结果融合算法)
  - [四、性能优化](#四性能优化)
    - [4.1 查询性能优化](#41-查询性能优化)
    - [4.2 索引优化](#42-索引优化)
    - [4.3 缓存策略](#43-缓存策略)
  - [五、最佳实践](#五最佳实践)
  - [六、关联主题](#六关联主题)
  - [七、对标资源](#七对标资源)
    - [技术文档](#技术文档)
    - [学术论文](#学术论文)

## 一、概述

PostgreSQL的混合查询能力允许在单条SQL语句中同时使用向量相似度搜索、传统SQL查询、全文搜索、地理空间查询等多种查询方式，实现复杂业务场景的统一查询接口。

## 二、混合查询类型

### 2.1 向量+SQL联合查询

结合向量相似度和传统SQL条件：

```sql
-- 向量相似度 + 条件过滤
SELECT
    id,
    title,
    category,
    price,
    description_vector <=> query_vector AS similarity
FROM products
WHERE category = 'electronics'
  AND price < 1000
  AND description_vector <=> query_vector < 0.8
ORDER BY description_vector <=> query_vector
LIMIT 20;
```

**优化技巧**:

- 先使用条件过滤减少搜索空间
- 再执行向量相似度计算
- 使用复合索引优化

### 2.2 向量+全文搜索

结合向量语义搜索和关键词全文搜索：

```sql
-- 向量搜索 + 全文搜索
WITH vector_results AS (
    SELECT
        id, content,
        description_vector <=> query_vector AS vector_distance
    FROM documents
    WHERE description_vector <=> query_vector < 0.8
    ORDER BY description_vector <=> query_vector
    LIMIT 50
),
text_results AS (
    SELECT
        id, content,
        ts_rank(content_tsv, plainto_tsquery(:query_text)) AS text_rank
    FROM documents
    WHERE content_tsv @@ plainto_tsquery(:query_text)
    ORDER BY text_rank DESC
    LIMIT 50
)
SELECT DISTINCT
    COALESCE(v.id, t.id) AS id,
    COALESCE(v.content, t.content) AS content,
    COALESCE(1 - v.vector_distance, 0) * 0.7 +
    COALESCE(t.text_rank, 0) * 0.3 AS combined_score
FROM vector_results v
FULL OUTER JOIN text_results t ON v.id = t.id
ORDER BY combined_score DESC
LIMIT 20;
```

### 2.3 向量+地理空间查询

结合向量相似度和地理位置过滤：

```sql
-- 向量搜索 + 地理空间查询
SELECT
    l.id,
    l.title,
    l.description_vector <=> query_vector AS similarity,
    ST_Distance(l.geom, user_location) / 1000.0 AS distance_km
FROM listings l
WHERE l.description_vector <=> query_vector < 0.8
  AND ST_DWithin(l.geom, user_location, 5000)  -- 5公里内
  AND l.rating > 4.5
ORDER BY
    (l.description_vector <=> query_vector) * 0.6 +  -- 相似度权重60%
    (ST_Distance(l.geom, user_location) / 5000.0) * 0.4  -- 距离权重40%
LIMIT 20;
```

### 2.4 多模态数据查询

同时查询文本、图像、JSON等多种数据类型：

```sql
-- 多模态查询：文本向量 + 图像向量 + JSON过滤
SELECT
    p.id,
    p.title,
    p.description_vector <=> text_query_vector AS text_similarity,
    p.image_vector <=> image_query_vector AS image_similarity,
    p.metadata->>'brand' AS brand
FROM products p
WHERE p.description_vector <=> text_query_vector < 0.8
  AND p.image_vector <=> image_query_vector < 0.8
  AND p.metadata->>'brand' = 'Apple'
  AND (p.metadata->>'price')::numeric < 1000
ORDER BY
    (p.description_vector <=> text_query_vector) * 0.5 +
    (p.image_vector <=> image_query_vector) * 0.5
LIMIT 20;
```

## 三、查询优化策略

### 3.1 索引组合策略

```sql
-- 复合索引：条件 + 向量
CREATE INDEX ON products
USING btree (category, price, (description_vector <=> query_vector));

-- GIN索引：全文搜索
CREATE INDEX ON documents
USING gin (content_tsv);

-- GIST索引：地理空间
CREATE INDEX ON listings
USING gist (geom);

-- 覆盖索引：包含常用列
CREATE INDEX ON products
USING btree (category)
INCLUDE (title, price, description_vector);
```

### 3.2 查询计划优化

```sql
-- 使用EXPLAIN分析查询计划
EXPLAIN ANALYZE
SELECT * FROM products
WHERE category = 'electronics'
  AND description_vector <=> query_vector < 0.8
ORDER BY description_vector <=> query_vector
LIMIT 20;

-- 优化建议：
-- 1. 确保条件过滤在向量搜索之前
-- 2. 使用LIMIT减少结果集
-- 3. 合理设置work_mem
SET work_mem = '256MB';
```

### 3.3 结果融合算法

```sql
-- RRF (Reciprocal Rank Fusion) 算法
CREATE OR REPLACE FUNCTION rrf_fusion(
    vector_ranks INTEGER[],
    text_ranks INTEGER[],
    k INTEGER DEFAULT 60
) RETURNS DECIMAL AS $$
BEGIN
    RETURN (
        SELECT SUM(1.0 / (k + rank))
        FROM (
            SELECT unnest(vector_ranks) AS rank
            UNION ALL
            SELECT unnest(text_ranks) AS rank
        ) ranks
    );
END;
$$ LANGUAGE plpgsql;

-- 使用RRF融合结果
WITH vector_ranked AS (
    SELECT id, ROW_NUMBER() OVER (ORDER BY vector_distance) AS rank
    FROM vector_results
),
text_ranked AS (
    SELECT id, ROW_NUMBER() OVER (ORDER BY text_rank DESC) AS rank
    FROM text_results
)
SELECT
    COALESCE(v.id, t.id) AS id,
    rrf_fusion(
        ARRAY[v.rank],
        ARRAY[t.rank]
    ) AS rrf_score
FROM vector_ranked v
FULL OUTER JOIN text_ranked t ON v.id = t.id
ORDER BY rrf_score DESC;
```

## 四、性能优化

### 4.1 查询性能优化

```sql
-- 1. 使用子查询先过滤
SELECT * FROM (
    SELECT * FROM products
    WHERE category = 'electronics'
      AND price < 1000
) filtered
WHERE description_vector <=> query_vector < 0.8
ORDER BY description_vector <=> query_vector
LIMIT 20;

-- 2. 使用物化CTE
WITH filtered_products AS MATERIALIZED (
    SELECT * FROM products
    WHERE category = 'electronics'
)
SELECT * FROM filtered_products
WHERE description_vector <=> query_vector < 0.8
ORDER BY description_vector <=> query_vector
LIMIT 20;
```

### 4.2 索引优化

```sql
-- 分区表 + 分区索引
CREATE TABLE products_2024 PARTITION OF products
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE INDEX ON products_2024
USING hnsw (description_vector vector_cosine_ops);

-- 部分索引（只索引活跃数据）
CREATE INDEX ON products
USING hnsw (description_vector vector_cosine_ops)
WHERE status = 'active';
```

### 4.3 缓存策略

```sql
-- 查询结果缓存
CREATE TABLE query_cache (
    query_hash TEXT PRIMARY KEY,
    query_vector vector(1536),
    filter_conditions JSONB,
    result_ids INTEGER[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

-- 使用缓存
CREATE OR REPLACE FUNCTION get_cached_results(
    p_query_vector vector(1536),
    p_filters JSONB
) RETURNS INTEGER[] AS $$
DECLARE
    v_hash TEXT;
    v_results INTEGER[];
BEGIN
    v_hash := md5(p_query_vector::text || p_filters::text);

    SELECT result_ids INTO v_results
    FROM query_cache
    WHERE query_hash = v_hash
      AND expires_at > NOW();

    IF v_results IS NOT NULL THEN
        RETURN v_results;
    END IF;

    -- 执行查询并缓存结果
    -- ...

    RETURN v_results;
END;
$$ LANGUAGE plpgsql;
```

## 五、最佳实践

1. **查询顺序优化**:
   - 先执行选择性高的条件过滤
   - 再执行向量相似度搜索
   - 最后进行结果排序

2. **索引策略**:
   - 为常用过滤条件创建B-tree索引
   - 为向量列创建HNSW索引
   - 使用复合索引优化混合查询

3. **权重设置**:
   - 根据业务需求调整各维度权重
   - 使用A/B测试优化权重参数

4. **性能监控**:

   ```sql
   -- 监控混合查询性能
   SELECT
       query_type,
       AVG(execution_time) AS avg_time,
       P95(execution_time) AS p95_time
   FROM query_log
   WHERE query_type = 'hybrid'
   GROUP BY query_type;
   ```

## 六、关联主题

- [向量处理能力 (pgvector)](./向量处理能力-pgvector.md) - 向量搜索基础
- [智能推荐系统](../04-应用场景/智能推荐系统.md) - 混合推荐应用
- [Qunar途家案例](../05-实践案例/Qunar途家案例.md) - 实际应用案例

## 七、对标资源

### 技术文档

- [PostgreSQL全文搜索文档](https://www.postgresql.org/docs/current/textsearch.html)
- [PostGIS空间查询文档](https://postgis.net/docs/)
- [pgvector混合查询示例](https://github.com/pgvector/pgvector/tree/master/examples)

### 学术论文

- Reciprocal Rank Fusion算法论文
- 多模态检索技术研究

---

**最后更新**: 2025年1月
**维护者**: PostgreSQL Modern Team
**文档编号**: AI-03-03
