# é‡‘èé£æ§ç³»ç»Ÿ

> **æ–‡æ¡£ç¼–å·**: AI-04-03
> **æœ€åæ›´æ–°**: 2025å¹´1æœˆ
> **ä¸»é¢˜**: 04-åº”ç”¨åœºæ™¯
> **å­ä¸»é¢˜**: 03-é‡‘èé£æ§ç³»ç»Ÿ

## ğŸ“‘ ç›®å½•

- [é‡‘èé£æ§ç³»ç»Ÿ](#é‡‘èé£æ§ç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
  - [äºŒã€æ¶æ„è®¾è®¡](#äºŒæ¶æ„è®¾è®¡)
    - [2.1 ç³»ç»Ÿæ¶æ„](#21-ç³»ç»Ÿæ¶æ„)
    - [2.2 æ•°æ®æµ](#22-æ•°æ®æµ)
  - [ä¸‰ã€æ•°æ®æ¨¡å‹è®¾è®¡](#ä¸‰æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 äº¤æ˜“è¡¨](#31-äº¤æ˜“è¡¨)
    - [3.2 ç”¨æˆ·è¡Œä¸ºè¡¨](#32-ç”¨æˆ·è¡Œä¸ºè¡¨)
    - [3.3 é£é™©ç‰¹å¾è¡¨](#33-é£é™©ç‰¹å¾è¡¨)
    - [3.4 é£é™©å†³ç­–è¡¨](#34-é£é™©å†³ç­–è¡¨)
  - [å››ã€é£é™©è¯†åˆ«ç®—æ³•](#å››é£é™©è¯†åˆ«ç®—æ³•)
    - [4.1 å®æ—¶é£é™©æ£€æµ‹](#41-å®æ—¶é£é™©æ£€æµ‹)
    - [4.2 è¡Œä¸ºæ¨¡å¼åˆ†æ](#42-è¡Œä¸ºæ¨¡å¼åˆ†æ)
    - [4.3 æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹](#43-æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹)
    - [4.4 å†³ç­–å¼•æ“](#44-å†³ç­–å¼•æ“)
  - [äº”ã€å®æ—¶å¤„ç†æµç¨‹](#äº”å®æ—¶å¤„ç†æµç¨‹)
    - [5.1 å®æ—¶ç‰¹å¾è®¡ç®—](#51-å®æ—¶ç‰¹å¾è®¡ç®—)
    - [5.2 å®æ—¶é£é™©è¯„ä¼°](#52-å®æ—¶é£é™©è¯„ä¼°)
    - [5.3 å®æ—¶å†³ç­–æ‰§è¡Œ](#53-å®æ—¶å†³ç­–æ‰§è¡Œ)
  - [å…­ã€æ€§èƒ½ä¼˜åŒ–](#å…­æ€§èƒ½ä¼˜åŒ–)
    - [6.1 æŸ¥è¯¢ä¼˜åŒ–](#61-æŸ¥è¯¢ä¼˜åŒ–)
    - [6.2 ç´¢å¼•ä¼˜åŒ–](#62-ç´¢å¼•ä¼˜åŒ–)
    - [6.3 ç¼“å­˜ç­–ç•¥](#63-ç¼“å­˜ç­–ç•¥)
  - [ä¸ƒã€ç›‘æ§ä¸å‘Šè­¦](#ä¸ƒç›‘æ§ä¸å‘Šè­¦)
    - [7.1 æ€§èƒ½ç›‘æ§](#71-æ€§èƒ½ç›‘æ§)
    - [7.2 é£é™©ç›‘æ§](#72-é£é™©ç›‘æ§)
    - [7.3 å‘Šè­¦æœºåˆ¶](#73-å‘Šè­¦æœºåˆ¶)
  - [å…«ã€å…³è”ä¸»é¢˜](#å…«å…³è”ä¸»é¢˜)
  - [ä¹ã€å¯¹æ ‡èµ„æº](#ä¹å¯¹æ ‡èµ„æº)
    - [ä¼ä¸šæ¡ˆä¾‹](#ä¼ä¸šæ¡ˆä¾‹)
    - [æŠ€æœ¯æ–‡æ¡£](#æŠ€æœ¯æ–‡æ¡£)
    - [å­¦æœ¯è®ºæ–‡](#å­¦æœ¯è®ºæ–‡)

## ä¸€ã€æ¦‚è¿°

åŸºäºPostgreSQLæ„å»ºçš„é‡‘èé£æ§ç³»ç»Ÿï¼Œç»“åˆpgvectorã€PostgresMLå’ŒTimescaleDBï¼Œå®ç°å®æ—¶é£é™©è¯†åˆ«ã€æ¬ºè¯ˆæ£€æµ‹å’Œæ™ºèƒ½å†³ç­–ï¼Œæ»¡è¶³é‡‘èè¡Œä¸šå¯¹é«˜ä¸€è‡´æ€§ã€ä½å»¶è¿Ÿå’Œå¼ºå®‰å…¨æ€§çš„è¦æ±‚ã€‚

## äºŒã€æ¶æ„è®¾è®¡

### 2.1 ç³»ç»Ÿæ¶æ„

```mermaid
graph TD
    A[äº¤æ˜“è¯·æ±‚] --> B[å®æ—¶ç‰¹å¾æå–]
    B --> C[PostgreSQL]
    C --> D[é£é™©ç‰¹å¾è®¡ç®—]
    D --> E[PostgresMLæ¨¡å‹æ¨ç†]
    E --> F[å†³ç­–å¼•æ“]
    F --> G{é£é™©ç­‰çº§}
    G -->|ä½é£é™©| H[é€šè¿‡]
    G -->|ä¸­é£é™©| I[äººå·¥å®¡æ ¸]
    G -->|é«˜é£é™©| J[æ‹’ç»]

    C --> K[TimescaleDBæ—¶åºæ•°æ®]
    C --> L[pgvectorè¡Œä¸ºå‘é‡]
    C --> M[PostgresMLæ¨¡å‹]
```

### 2.2 æ•°æ®æµ

1. **å®æ—¶æ•°æ®æµ**:
   - äº¤æ˜“è¯·æ±‚ â†’ ç‰¹å¾æå– â†’ é£é™©è®¡ç®— â†’ å†³ç­–æ‰§è¡Œ

2. **æ¨¡å‹è®­ç»ƒæµ**:
   - å†å²äº¤æ˜“æ•°æ® â†’ ç‰¹å¾å·¥ç¨‹ â†’ æ¨¡å‹è®­ç»ƒ â†’ æ¨¡å‹éƒ¨ç½²

3. **ç›‘æ§åé¦ˆæµ**:
   - é£é™©äº‹ä»¶ â†’ æ¨¡å‹è¯„ä¼° â†’ æ¨¡å‹ä¼˜åŒ– â†’ é‡æ–°éƒ¨ç½²

## ä¸‰ã€æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 äº¤æ˜“è¡¨

```sql
-- äº¤æ˜“è¡¨ï¼ˆä½¿ç”¨TimescaleDBï¼‰
CREATE TABLE transactions (
    id BIGSERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    amount DECIMAL(15,2) NOT NULL,
    merchant_id INTEGER,
    transaction_type TEXT,
    status TEXT DEFAULT 'pending',
    risk_score DECIMAL(5,4),
    fraud_flag BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è½¬æ¢ä¸ºæ—¶åºè¡¨
SELECT create_hypertable('transactions', 'created_at');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON transactions (user_id, created_at DESC);
CREATE INDEX ON transactions (status, created_at DESC);
```

### 3.2 ç”¨æˆ·è¡Œä¸ºè¡¨

```sql
-- ç”¨æˆ·è¡Œä¸ºå‘é‡è¡¨
CREATE TABLE user_behavior_vectors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    behavior_vector vector(1536),  -- è¡Œä¸ºæ¨¡å¼å‘é‡
    time_window TIMESTAMPTZ,
    behavior_count INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å‘é‡ç´¢å¼•
CREATE INDEX ON user_behavior_vectors
USING hnsw (behavior_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 100);

-- æ—¶åºç´¢å¼•
CREATE INDEX ON user_behavior_vectors (user_id, time_window DESC);
```

### 3.3 é£é™©ç‰¹å¾è¡¨

```sql
-- é£é™©ç‰¹å¾è¡¨
CREATE TABLE risk_features (
    transaction_id BIGINT PRIMARY KEY REFERENCES transactions(id),
    user_id INTEGER,
    amount DECIMAL(15,2),
    user_age INTEGER,
    transaction_count_24h INTEGER,
    transaction_count_7d INTEGER,
    avg_amount_7d DECIMAL(15,2),
    max_amount_7d DECIMAL(15,2),
    location_change BOOLEAN,
    device_change BOOLEAN,
    behavior_similarity DECIMAL(5,4),  -- ä¸å†å²è¡Œä¸ºç›¸ä¼¼åº¦
    features REAL[],  -- ç‰¹å¾å‘é‡
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ç‰¹å¾ç´¢å¼•
CREATE INDEX ON risk_features (user_id, created_at DESC);
```

### 3.4 é£é™©å†³ç­–è¡¨

```sql
-- é£é™©å†³ç­–è¡¨
CREATE TABLE risk_decisions (
    id SERIAL PRIMARY KEY,
    transaction_id BIGINT REFERENCES transactions(id),
    risk_score DECIMAL(5,4),
    risk_level TEXT,  -- 'low', 'medium', 'high'
    decision TEXT,  -- 'approve', 'review', 'reject'
    model_version TEXT,
    decision_time TIMESTAMPTZ DEFAULT NOW(),
    review_result TEXT,
    reviewer_id INTEGER
);

-- å†³ç­–ç´¢å¼•
CREATE INDEX ON risk_decisions (transaction_id);
CREATE INDEX ON risk_decisions (risk_level, decision_time DESC);
```

## å››ã€é£é™©è¯†åˆ«ç®—æ³•

### 4.1 å®æ—¶é£é™©æ£€æµ‹

```sql
-- å®æ—¶é£é™©æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION realtime_risk_check(
    p_transaction_id BIGINT
) RETURNS DECIMAL AS $$
DECLARE
    v_features REAL[];
    v_risk_score DECIMAL;
    v_behavior_similarity DECIMAL;
BEGIN
    -- æå–å®æ—¶ç‰¹å¾
    SELECT ARRAY[
        amount,
        user_age,
        transaction_count_24h,
        transaction_count_7d,
        avg_amount_7d,
        CASE WHEN location_change THEN 1.0 ELSE 0.0 END,
        CASE WHEN device_change THEN 1.0 ELSE 0.0 END
    ] INTO v_features
    FROM risk_features
    WHERE transaction_id = p_transaction_id;

    -- MLæ¨¡å‹é¢„æµ‹
    v_risk_score := pgml.predict('fraud_detection', v_features);

    -- è¡Œä¸ºç›¸ä¼¼åº¦æ£€æŸ¥
    SELECT 1 - (current_behavior <=> historical_behavior)
    INTO v_behavior_similarity
    FROM (
        SELECT behavior_vector AS current_behavior
        FROM user_behavior_vectors
        WHERE user_id = (SELECT user_id FROM transactions WHERE id = p_transaction_id)
        ORDER BY created_at DESC
        LIMIT 1
    ) current
    CROSS JOIN (
        SELECT AVG(behavior_vector) AS historical_behavior
        FROM user_behavior_vectors
        WHERE user_id = (SELECT user_id FROM transactions WHERE id = p_transaction_id)
          AND created_at < NOW() - INTERVAL '7 days'
    ) historical;

    -- ç»¼åˆé£é™©åˆ†æ•°
    v_risk_score := v_risk_score * 0.7 + (1 - v_behavior_similarity) * 0.3;

    -- æ›´æ–°äº¤æ˜“é£é™©åˆ†æ•°
    UPDATE transactions
    SET risk_score = v_risk_score
    WHERE id = p_transaction_id;

    RETURN v_risk_score;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 è¡Œä¸ºæ¨¡å¼åˆ†æ

```sql
-- æ£€æµ‹å¼‚å¸¸è¡Œä¸ºæ¨¡å¼
CREATE OR REPLACE FUNCTION detect_anomalous_behavior(
    p_user_id INTEGER,
    p_current_behavior vector(1536)
) RETURNS DECIMAL AS $$
DECLARE
    v_similarity DECIMAL;
    v_avg_similarity DECIMAL;
BEGIN
    -- è®¡ç®—ä¸å†å²è¡Œä¸ºçš„ç›¸ä¼¼åº¦
    SELECT AVG(1 - (p_current_behavior <=> behavior_vector))
    INTO v_avg_similarity
    FROM user_behavior_vectors
    WHERE user_id = p_user_id
      AND created_at > NOW() - INTERVAL '30 days';

    -- å¦‚æœç›¸ä¼¼åº¦ä½äºé˜ˆå€¼ï¼Œæ ‡è®°ä¸ºå¼‚å¸¸
    IF v_avg_similarity < 0.6 THEN
        RETURN 1.0;  -- é«˜é£é™©
    END IF;

    RETURN 1 - v_avg_similarity;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹

```sql
-- è®­ç»ƒæ¬ºè¯ˆæ£€æµ‹æ¨¡å‹
SELECT * FROM pgml.train(
    project_name => 'fraud_detection',
    task => 'classification',
    relation_name => 'risk_features',
    y_column_name => 'is_fraud',
    algorithm => 'xgboost',
    hyperparams => '{
        "n_estimators": 200,
        "max_depth": 8,
        "learning_rate": 0.1
    }'::jsonb
);

-- å®æ—¶æ¬ºè¯ˆæ£€æµ‹
SELECT
    transaction_id,
    amount,
    pgml.predict('fraud_detection', features) AS fraud_probability
FROM risk_features
WHERE transaction_id = :transaction_id;
```

### 4.4 å†³ç­–å¼•æ“

```sql
-- å†³ç­–å¼•æ“å‡½æ•°
CREATE OR REPLACE FUNCTION risk_decision_engine(
    p_transaction_id BIGINT
) RETURNS TEXT AS $$
DECLARE
    v_risk_score DECIMAL;
    v_decision TEXT;
BEGIN
    -- è®¡ç®—é£é™©åˆ†æ•°
    v_risk_score := realtime_risk_check(p_transaction_id);

    -- å†³ç­–é€»è¾‘
    IF v_risk_score < 0.3 THEN
        v_decision := 'approve';
    ELSIF v_risk_score < 0.7 THEN
        v_decision := 'review';
    ELSE
        v_decision := 'reject';
    END IF;

    -- è®°å½•å†³ç­–
    INSERT INTO risk_decisions (
        transaction_id,
        risk_score,
        risk_level,
        decision,
        model_version
    ) VALUES (
        p_transaction_id,
        v_risk_score,
        CASE
            WHEN v_risk_score < 0.3 THEN 'low'
            WHEN v_risk_score < 0.7 THEN 'medium'
            ELSE 'high'
        END,
        v_decision,
        (SELECT version FROM pgml.models WHERE project_name = 'fraud_detection' AND deployed = true)
    );

    -- æ›´æ–°äº¤æ˜“çŠ¶æ€
    UPDATE transactions
    SET status = v_decision
    WHERE id = p_transaction_id;

    RETURN v_decision;
END;
$$ LANGUAGE plpgsql;
```

## äº”ã€å®æ—¶å¤„ç†æµç¨‹

### 5.1 å®æ—¶ç‰¹å¾è®¡ç®—

```sql
-- å®æ—¶ç‰¹å¾è®¡ç®—è§¦å‘å™¨
CREATE OR REPLACE FUNCTION calculate_risk_features()
RETURNS TRIGGER AS $$
DECLARE
    v_features REAL[];
BEGIN
    -- è®¡ç®—ç‰¹å¾
    SELECT ARRAY[
        NEW.amount,
        (SELECT age FROM users WHERE id = NEW.user_id),
        (SELECT COUNT(*) FROM transactions
         WHERE user_id = NEW.user_id
           AND created_at > NOW() - INTERVAL '24 hours'),
        (SELECT COUNT(*) FROM transactions
         WHERE user_id = NEW.user_id
           AND created_at > NOW() - INTERVAL '7 days'),
        (SELECT AVG(amount) FROM transactions
         WHERE user_id = NEW.user_id
           AND created_at > NOW() - INTERVAL '7 days'),
        (SELECT MAX(amount) FROM transactions
         WHERE user_id = NEW.user_id
           AND created_at > NOW() - INTERVAL '7 days'),
        CASE WHEN (SELECT location FROM transactions
                   WHERE user_id = NEW.user_id
                   ORDER BY created_at DESC LIMIT 1) != NEW.location
             THEN 1.0 ELSE 0.0 END
    ] INTO v_features;

    -- æ’å…¥é£é™©ç‰¹å¾
    INSERT INTO risk_features (
        transaction_id,
        user_id,
        amount,
        features
    ) VALUES (
        NEW.id,
        NEW.user_id,
        NEW.amount,
        v_features
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER calculate_features_trigger
AFTER INSERT ON transactions
FOR EACH ROW
EXECUTE FUNCTION calculate_risk_features();
```

### 5.2 å®æ—¶é£é™©è¯„ä¼°

```sql
-- å®æ—¶é£é™©è¯„ä¼°ï¼ˆä½¿ç”¨FOR UPDATE SKIP LOCKEDé¿å…å¹¶å‘å†²çªï¼‰
CREATE OR REPLACE FUNCTION process_pending_transactions()
RETURNS void AS $$
DECLARE
    v_transaction_id BIGINT;
    v_decision TEXT;
BEGIN
    LOOP
        -- è·å–å¾…å¤„ç†äº¤æ˜“ï¼ˆä½¿ç”¨SKIP LOCKEDé¿å…é”ç­‰å¾…ï¼‰
        SELECT id INTO v_transaction_id
        FROM transactions
        WHERE status = 'pending'
        FOR UPDATE SKIP LOCKED
        LIMIT 1;

        EXIT WHEN v_transaction_id IS NULL;

        -- æ‰§è¡Œé£é™©è¯„ä¼°
        v_decision := risk_decision_engine(v_transaction_id);

        -- è®°å½•å¤„ç†ç»“æœ
        RAISE NOTICE 'Transaction % processed with decision: %',
            v_transaction_id, v_decision;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 å®æ—¶å†³ç­–æ‰§è¡Œ

```sql
-- ä½¿ç”¨pg_cronå®šæ—¶æ‰§è¡Œé£é™©è¯„ä¼°
SELECT cron.schedule(
    'process-transactions',
    '* * * * *',  -- æ¯åˆ†é’Ÿæ‰§è¡Œ
    'SELECT process_pending_transactions()'
);

-- æˆ–ä½¿ç”¨NOTIFY/LISTENå®ç°å®æ—¶å¤„ç†
CREATE OR REPLACE FUNCTION notify_new_transaction()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify('new_transaction', NEW.id::text);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER notify_transaction_trigger
AFTER INSERT ON transactions
FOR EACH ROW
EXECUTE FUNCTION notify_new_transaction();
```

## å…­ã€æ€§èƒ½ä¼˜åŒ–

### 6.1 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä½¿ç”¨ç‰©åŒ–è§†å›¾é¢„è®¡ç®—å¸¸ç”¨ç‰¹å¾
CREATE MATERIALIZED VIEW user_risk_profiles AS
SELECT
    user_id,
    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') AS tx_count_24h,
    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') AS tx_count_7d,
    AVG(amount) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') AS avg_amount_7d,
    MAX(amount) FILTER (WHERE created_at > NOW() - INTERVAL '7 days') AS max_amount_7d,
    LAST_UPDATED = NOW()
FROM transactions
GROUP BY user_id;

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY user_risk_profiles;
```

### 6.2 ç´¢å¼•ä¼˜åŒ–

```sql
-- å¤åˆç´¢å¼•ä¼˜åŒ–å®æ—¶æŸ¥è¯¢
CREATE INDEX ON transactions (status, created_at DESC)
WHERE status = 'pending';

-- éƒ¨åˆ†ç´¢å¼•ä¼˜åŒ–
CREATE INDEX ON risk_features (user_id, created_at DESC)
WHERE created_at > NOW() - INTERVAL '30 days';
```

### 6.3 ç¼“å­˜ç­–ç•¥

```sql
-- ç”¨æˆ·é£é™©ç”»åƒç¼“å­˜
CREATE TABLE user_risk_cache (
    user_id INTEGER PRIMARY KEY,
    risk_profile JSONB,
    last_updated TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '1 hour'
);

-- ä½¿ç”¨ç¼“å­˜çš„é£é™©æ£€æŸ¥
CREATE OR REPLACE FUNCTION get_cached_risk_profile(p_user_id INTEGER)
RETURNS JSONB AS $$
DECLARE
    v_profile JSONB;
BEGIN
    SELECT risk_profile INTO v_profile
    FROM user_risk_cache
    WHERE user_id = p_user_id
      AND expires_at > NOW();

    IF v_profile IS NULL THEN
        -- è®¡ç®—å¹¶ç¼“å­˜
        SELECT jsonb_build_object(
            'tx_count_24h', tx_count_24h,
            'tx_count_7d', tx_count_7d,
            'avg_amount_7d', avg_amount_7d
        ) INTO v_profile
        FROM user_risk_profiles
        WHERE user_id = p_user_id;

        INSERT INTO user_risk_cache (user_id, risk_profile)
        VALUES (p_user_id, v_profile)
        ON CONFLICT (user_id) DO UPDATE
        SET risk_profile = v_profile,
            last_updated = NOW(),
            expires_at = NOW() + INTERVAL '1 hour';
    END IF;

    RETURN v_profile;
END;
$$ LANGUAGE plpgsql;
```

## ä¸ƒã€ç›‘æ§ä¸å‘Šè­¦

### 7.1 æ€§èƒ½ç›‘æ§

```sql
-- ç›‘æ§æŸ¥è¯¢æ€§èƒ½
SELECT
    query,
    calls,
    mean_exec_time,
    max_exec_time,
    total_exec_time
FROM pg_stat_statements
WHERE query LIKE '%risk%'
ORDER BY total_exec_time DESC
LIMIT 10;
```

### 7.2 é£é™©ç›‘æ§

```sql
-- é£é™©äº‹ä»¶ç»Ÿè®¡
SELECT
    DATE_TRUNC('hour', decision_time) AS hour,
    risk_level,
    decision,
    COUNT(*) AS count,
    AVG(risk_score) AS avg_score
FROM risk_decisions
WHERE decision_time > NOW() - INTERVAL '24 hours'
GROUP BY hour, risk_level, decision
ORDER BY hour DESC, risk_level;
```

### 7.3 å‘Šè­¦æœºåˆ¶

```sql
-- é«˜é£é™©äº¤æ˜“å‘Šè­¦
CREATE OR REPLACE FUNCTION check_high_risk_alerts()
RETURNS void AS $$
DECLARE
    v_high_risk_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_high_risk_count
    FROM risk_decisions
    WHERE risk_level = 'high'
      AND decision_time > NOW() - INTERVAL '1 hour';

    IF v_high_risk_count > 100 THEN
        -- å‘é€å‘Šè­¦ï¼ˆé€šè¿‡pg_netæˆ–pg_curlï¼‰
        PERFORM pg_notify('high_risk_alert',
            format('High risk transactions: %s in last hour', v_high_risk_count));
    END IF;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶æ£€æŸ¥å‘Šè­¦
SELECT cron.schedule(
    'check-alerts',
    '*/5 * * * *',  -- æ¯5åˆ†é’Ÿ
    'SELECT check_high_risk_alerts()'
);
```

## å…«ã€å…³è”ä¸»é¢˜

- [å†…ç½®æœºå™¨å­¦ä¹  (PostgresML)](../03-æ ¸å¿ƒèƒ½åŠ›/å†…ç½®æœºå™¨å­¦ä¹ -PostgresML.md) - æ¨¡å‹è®­ç»ƒä¸æ¨ç†
- [å‘é‡å¤„ç†èƒ½åŠ› (pgvector)](../03-æ ¸å¿ƒèƒ½åŠ›/å‘é‡å¤„ç†èƒ½åŠ›-pgvector.md) - è¡Œä¸ºæ¨¡å¼åˆ†æ
- [é˜¿é‡Œäº‘PolarDBæ¡ˆä¾‹](../05-å®è·µæ¡ˆä¾‹/é˜¿é‡Œäº‘PolarDBæ¡ˆä¾‹.md) - å®é™…åº”ç”¨æ¡ˆä¾‹

## ä¹ã€å¯¹æ ‡èµ„æº

### ä¼ä¸šæ¡ˆä¾‹

- **é˜¿é‡Œäº‘PolarDB**: é‡‘èé£æ§ç³»ç»Ÿåº”ç”¨
- **æ€§èƒ½æå‡**: å¤æ‚æŠ¥è¡¨æŸ¥è¯¢ä»2å°æ—¶ç¼©çŸ­è‡³15åˆ†é’Ÿ
- **æˆæœ¬é™ä½**: DBAäººåŠ›æˆæœ¬é™ä½70%

### æŠ€æœ¯æ–‡æ¡£

- [PostgresMLæ–‡æ¡£](https://postgresml.org/docs/)
- [TimescaleDBæ–‡æ¡£](https://docs.timescale.com/)
- [pgvectoræ–‡æ¡£](https://github.com/pgvector/pgvector)

### å­¦æœ¯è®ºæ–‡

- å®æ—¶æ¬ºè¯ˆæ£€æµ‹ç®—æ³•ç ”ç©¶
- é‡‘èé£æ§ç³»ç»Ÿæ¶æ„è®¾è®¡

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: AI-04-03
