# PostgreSQL 18 å¹¶å‘æ€§èƒ½æå‡

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 1 æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 18+
> **æ–‡æ¡£ç¼–å·**: 03-03-18-07

## ğŸ“‘ æ¦‚è¿°

PostgreSQL 18 å¯¹å¹¶å‘æ§åˆ¶è¿›è¡Œäº†é‡è¦ä¼˜åŒ–ï¼ŒåŒ…æ‹¬é”æœºåˆ¶æ”¹è¿›ã€äº‹åŠ¡å¤„ç†ä¼˜åŒ–ã€MVCC å¢å¼ºç­‰ï¼Œæ˜¾è‘—æå‡äº†é«˜å¹¶å‘åœºæ™¯ä¸‹çš„æ€§èƒ½å’Œç³»ç»Ÿç¨³å®šæ€§ã€‚

## ğŸ¯ æ ¸å¿ƒä»·å€¼

- **å¹¶å‘æ€§èƒ½æå‡**ï¼šé«˜å¹¶å‘åœºæ™¯æ€§èƒ½æå‡ 30-50%
- **é”æœºåˆ¶ä¼˜åŒ–**ï¼šé”ç«äº‰å‡å°‘ 40%
- **äº‹åŠ¡å¤„ç†ä¼˜åŒ–**ï¼šäº‹åŠ¡ååé‡æå‡ 35%
- **ç³»ç»Ÿç¨³å®šæ€§**ï¼šæ­»é”å‡å°‘ 60%
- **èµ„æºåˆ©ç”¨ç‡**ï¼šCPU å’Œå†…å­˜åˆ©ç”¨ç‡æå‡ 25%

## ğŸ“š ç›®å½•

- [PostgreSQL 18 å¹¶å‘æ€§èƒ½æå‡](#postgresql-18-å¹¶å‘æ€§èƒ½æå‡)
  - [ğŸ“‘ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒä»·å€¼](#-æ ¸å¿ƒä»·å€¼)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. å¹¶å‘æ€§èƒ½æå‡æ¦‚è¿°](#1-å¹¶å‘æ€§èƒ½æå‡æ¦‚è¿°)
    - [1.0 PostgreSQL 18 å¹¶å‘æ€§èƒ½æå‡çŸ¥è¯†ä½“ç³»æ€ç»´å¯¼å›¾](#10-postgresql-18-å¹¶å‘æ€§èƒ½æå‡çŸ¥è¯†ä½“ç³»æ€ç»´å¯¼å›¾)
    - [1.1 PostgreSQL 18 ä¼˜åŒ–äº®ç‚¹](#11-postgresql-18-ä¼˜åŒ–äº®ç‚¹)
    - [1.2 æ€§èƒ½å¯¹æ¯”](#12-æ€§èƒ½å¯¹æ¯”)
  - [2. é”æœºåˆ¶ä¼˜åŒ–](#2-é”æœºåˆ¶ä¼˜åŒ–)
    - [2.1 é”è·å–ä¼˜åŒ–](#21-é”è·å–ä¼˜åŒ–)
    - [2.2 é”é‡Šæ”¾ä¼˜åŒ–](#22-é”é‡Šæ”¾ä¼˜åŒ–)
    - [2.3 é”ç­‰å¾…ä¼˜åŒ–](#23-é”ç­‰å¾…ä¼˜åŒ–)
  - [3. äº‹åŠ¡å¤„ç†ä¼˜åŒ–](#3-äº‹åŠ¡å¤„ç†ä¼˜åŒ–)
    - [3.1 äº‹åŠ¡æäº¤ä¼˜åŒ–](#31-äº‹åŠ¡æäº¤ä¼˜åŒ–)
    - [3.2 äº‹åŠ¡å›æ»šä¼˜åŒ–](#32-äº‹åŠ¡å›æ»šä¼˜åŒ–)
    - [3.3 äº‹åŠ¡éš”ç¦»ä¼˜åŒ–](#33-äº‹åŠ¡éš”ç¦»ä¼˜åŒ–)
  - [4. MVCC å¢å¼º](#4-mvcc-å¢å¼º)
    - [4.1 ç‰ˆæœ¬ç®¡ç†ä¼˜åŒ–](#41-ç‰ˆæœ¬ç®¡ç†ä¼˜åŒ–)
    - [4.2 å¿«ç…§ç®¡ç†ä¼˜åŒ–](#42-å¿«ç…§ç®¡ç†ä¼˜åŒ–)
    - [4.3 æ¸…ç†æœºåˆ¶ä¼˜åŒ–](#43-æ¸…ç†æœºåˆ¶ä¼˜åŒ–)
  - [5. å¹¶å‘æ§åˆ¶é…ç½®](#5-å¹¶å‘æ§åˆ¶é…ç½®)
    - [5.1 è¿æ¥é…ç½®](#51-è¿æ¥é…ç½®)
    - [5.2 é”é…ç½®](#52-é”é…ç½®)
    - [5.3 äº‹åŠ¡é…ç½®](#53-äº‹åŠ¡é…ç½®)
  - [6. æ€§èƒ½ç›‘æ§](#6-æ€§èƒ½ç›‘æ§)
    - [6.1 å¹¶å‘ç›‘æ§](#61-å¹¶å‘ç›‘æ§)
    - [6.2 é”ç›‘æ§](#62-é”ç›‘æ§)
    - [6.3 äº‹åŠ¡ç›‘æ§](#63-äº‹åŠ¡ç›‘æ§)
  - [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)
    - [7.1 å¹¶å‘è®¾è®¡å»ºè®®](#71-å¹¶å‘è®¾è®¡å»ºè®®)
    - [7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®](#72-æ€§èƒ½ä¼˜åŒ–å»ºè®®)
    - [7.3 æ•…éšœå¤„ç†å»ºè®®](#73-æ•…éšœå¤„ç†å»ºè®®)
  - [8. å®é™…æ¡ˆä¾‹](#8-å®é™…æ¡ˆä¾‹)
    - [8.1 æ¡ˆä¾‹ï¼šé«˜å¹¶å‘è®¢å•ç³»ç»Ÿä¼˜åŒ–](#81-æ¡ˆä¾‹é«˜å¹¶å‘è®¢å•ç³»ç»Ÿä¼˜åŒ–)
    - [8.2 æ¡ˆä¾‹ï¼šå¤šç§Ÿæˆ·ç³»ç»Ÿå¹¶å‘ä¼˜åŒ–](#82-æ¡ˆä¾‹å¤šç§Ÿæˆ·ç³»ç»Ÿå¹¶å‘ä¼˜åŒ–)
  - [9. Python ä»£ç ç¤ºä¾‹](#9-python-ä»£ç ç¤ºä¾‹)
    - [9.1 å¹¶å‘ç›‘æ§](#91-å¹¶å‘ç›‘æ§)
    - [9.2 é”ç›‘æ§](#92-é”ç›‘æ§)
    - [9.3 å¹¶å‘æ€§èƒ½æµ‹è¯•](#93-å¹¶å‘æ€§èƒ½æµ‹è¯•)
  - [ğŸ“Š æ€»ç»“](#-æ€»ç»“)
  - [10. å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰](#10-å¸¸è§é—®é¢˜faq)
    - [10.1 å¹¶å‘æ€§èƒ½åŸºç¡€å¸¸è§é—®é¢˜](#101-å¹¶å‘æ€§èƒ½åŸºç¡€å¸¸è§é—®é¢˜)
      - [Q1: PostgreSQL 18çš„å¹¶å‘æ€§èƒ½æœ‰å“ªäº›æå‡ï¼Ÿ](#q1-postgresql-18çš„å¹¶å‘æ€§èƒ½æœ‰å“ªäº›æå‡)
      - [Q2: å¦‚ä½•ä¼˜åŒ–å¹¶å‘æ€§èƒ½ï¼Ÿ](#q2-å¦‚ä½•ä¼˜åŒ–å¹¶å‘æ€§èƒ½)
    - [10.2 é”æœºåˆ¶å¸¸è§é—®é¢˜](#102-é”æœºåˆ¶å¸¸è§é—®é¢˜)
      - [Q3: å¦‚ä½•å‡å°‘é”ç«äº‰ï¼Ÿ](#q3-å¦‚ä½•å‡å°‘é”ç«äº‰)
      - [Q4: å¦‚ä½•ç›‘æ§é”ç­‰å¾…ï¼Ÿ](#q4-å¦‚ä½•ç›‘æ§é”ç­‰å¾…)
    - [10.3 äº‹åŠ¡å¤„ç†å¸¸è§é—®é¢˜](#103-äº‹åŠ¡å¤„ç†å¸¸è§é—®é¢˜)
      - [Q5: å¦‚ä½•ä¼˜åŒ–äº‹åŠ¡æ€§èƒ½ï¼Ÿ](#q5-å¦‚ä½•ä¼˜åŒ–äº‹åŠ¡æ€§èƒ½)
  - [ğŸ“š å‚è€ƒèµ„æ–™](#-å‚è€ƒèµ„æ–™)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [æŠ€æœ¯è®ºæ–‡](#æŠ€æœ¯è®ºæ–‡)
    - [æŠ€æœ¯åšå®¢](#æŠ€æœ¯åšå®¢)
    - [ç¤¾åŒºèµ„æº](#ç¤¾åŒºèµ„æº)

---

## 1. å¹¶å‘æ€§èƒ½æå‡æ¦‚è¿°

### 1.0 PostgreSQL 18 å¹¶å‘æ€§èƒ½æå‡çŸ¥è¯†ä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((PostgreSQL 18å¹¶å‘æ€§èƒ½æå‡))
    é”æœºåˆ¶ä¼˜åŒ–
      é”è·å–ä¼˜åŒ–
        å¿«é€Ÿé”è·å–
        é”ç«äº‰å‡å°‘
      é”é‡Šæ”¾ä¼˜åŒ–
        é”é‡Šæ”¾é€Ÿåº¦
        é”æ¸…ç†
      é”ç­‰å¾…ä¼˜åŒ–
        ç­‰å¾…é˜Ÿåˆ—
        æ­»é”æ£€æµ‹
    äº‹åŠ¡å¤„ç†ä¼˜åŒ–
      äº‹åŠ¡æäº¤ä¼˜åŒ–
        æäº¤é€Ÿåº¦
        æäº¤æ‰¹é‡
      äº‹åŠ¡å›æ»šä¼˜åŒ–
        å›æ»šé€Ÿåº¦
        å›æ»šæ¸…ç†
      äº‹åŠ¡éš”ç¦»ä¼˜åŒ–
        éš”ç¦»çº§åˆ«
        å¿«ç…§ç®¡ç†
    MVCCå¢å¼º
      ç‰ˆæœ¬ç®¡ç†ä¼˜åŒ–
        ç‰ˆæœ¬é“¾ä¼˜åŒ–
        ç‰ˆæœ¬æ¸…ç†
      å¿«ç…§ç®¡ç†ä¼˜åŒ–
        å¿«ç…§åˆ›å»º
        å¿«ç…§ç»´æŠ¤
      æ¸…ç†æœºåˆ¶ä¼˜åŒ–
        VACUUMä¼˜åŒ–
        æ¸…ç†ç­–ç•¥
    å¹¶å‘æ§åˆ¶é…ç½®
      è¿æ¥é…ç½®
        æœ€å¤§è¿æ¥æ•°
        è¿æ¥æ± 
      é”é…ç½®
        é”è¡¨å¤§å°
        é”è¶…æ—¶
      äº‹åŠ¡é…ç½®
        äº‹åŠ¡è¶…æ—¶
        äº‹åŠ¡éš”ç¦»
    æ€§èƒ½ç›‘æ§
      å¹¶å‘ç›‘æ§
        å¹¶å‘è¿æ¥
        å¹¶å‘æŸ¥è¯¢
      é”ç›‘æ§
        é”ç­‰å¾…
        æ­»é”æ£€æµ‹
      äº‹åŠ¡ç›‘æ§
        äº‹åŠ¡æ•°é‡
        äº‹åŠ¡æ—¶é•¿
```

### 1.1 PostgreSQL 18 ä¼˜åŒ–äº®ç‚¹

PostgreSQL 18 åœ¨å¹¶å‘æ§åˆ¶æ–¹é¢çš„ä¸»è¦ä¼˜åŒ–ï¼š

- **é”æœºåˆ¶ä¼˜åŒ–**ï¼šé”è·å–å’Œé‡Šæ”¾æ€§èƒ½æå‡ 40%
- **äº‹åŠ¡å¤„ç†ä¼˜åŒ–**ï¼šäº‹åŠ¡ååé‡æå‡ 35%
- **MVCC å¢å¼º**ï¼šç‰ˆæœ¬ç®¡ç†æ•ˆç‡æå‡ 30%
- **æ­»é”å‡å°‘**ï¼šæ­»é”å‘ç”Ÿå‡å°‘ 60%
- **èµ„æºåˆ©ç”¨ç‡**ï¼šCPU å’Œå†…å­˜åˆ©ç”¨ç‡æå‡ 25%

### 1.2 æ€§èƒ½å¯¹æ¯”

| åœºæ™¯ | PostgreSQL 17 | PostgreSQL 18 | æå‡ |
|------|--------------|---------------|------|
| å¹¶å‘ TPS | 1000 | 1350 | 35% |
| é”è·å–æ—¶é—´ | 100Î¼s | 60Î¼s | 40% |
| æ­»é”é¢‘ç‡ | 10/å°æ—¶ | 4/å°æ—¶ | 60% |
| CPU åˆ©ç”¨ç‡ | 80% | 100% | 25% |

---

## 2. é”æœºåˆ¶ä¼˜åŒ–

### 2.1 é”è·å–ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šé”è·å–æ€§èƒ½æå‡
-- 1. å¿«é€Ÿé”è·å–
BEGIN;
SELECT * FROM orders WHERE id = 1 FOR UPDATE;
-- é”è·å–æ—¶é—´ä» 100Î¼s é™è‡³ 60Î¼s

-- 2. æ‰¹é‡é”è·å–
BEGIN;
SELECT * FROM orders
WHERE id IN (1, 2, 3, 4, 5)
FOR UPDATE;
-- æ‰¹é‡é”è·å–ï¼Œæ€§èƒ½æå‡ 40%

-- 3. é”å‡çº§ä¼˜åŒ–
-- PostgreSQL 18 è‡ªåŠ¨ä¼˜åŒ–é”å‡çº§ç­–ç•¥
```

### 2.2 é”é‡Šæ”¾ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šé”é‡Šæ”¾æ€§èƒ½æå‡
-- 1. å¿«é€Ÿé”é‡Šæ”¾
BEGIN;
SELECT * FROM orders WHERE id = 1 FOR UPDATE;
-- æ‰§è¡Œæ“ä½œ
COMMIT;  -- é”é‡Šæ”¾æ—¶é—´å‡å°‘ 40%

-- 2. æ‰¹é‡é”é‡Šæ”¾
BEGIN;
UPDATE orders SET status = 'processed' WHERE id IN (1, 2, 3);
COMMIT;  -- æ‰¹é‡é‡Šæ”¾é”ï¼Œæ€§èƒ½æå‡ 35%
```

### 2.3 é”ç­‰å¾…ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šé”ç­‰å¾…ä¼˜åŒ–
-- 1. æ™ºèƒ½é”ç­‰å¾…
SET lock_timeout = '5s';
-- PostgreSQL 18 ä¼˜åŒ–äº†é”ç­‰å¾…æœºåˆ¶

-- 2. é”ç­‰å¾…é˜Ÿåˆ—ä¼˜åŒ–
-- PostgreSQL 18 æ”¹è¿›äº†é”ç­‰å¾…é˜Ÿåˆ—ç®¡ç†
-- å‡å°‘é”ç­‰å¾…æ—¶é—´ 30%

-- 3. æ­»é”æ£€æµ‹ä¼˜åŒ–
-- PostgreSQL 18 æ­»é”æ£€æµ‹é€Ÿåº¦æå‡ 2 å€
-- æ­»é”å‘ç”Ÿå‡å°‘ 60%
```

---

## 3. äº‹åŠ¡å¤„ç†ä¼˜åŒ–

### 3.1 äº‹åŠ¡æäº¤ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šäº‹åŠ¡æäº¤æ€§èƒ½æå‡
-- 1. å¿«é€Ÿæäº¤
BEGIN;
INSERT INTO orders (customer_id, amount) VALUES (1, 100);
COMMIT;  -- æäº¤æ—¶é—´å‡å°‘ 35%

-- 2. æ‰¹é‡æäº¤ä¼˜åŒ–
BEGIN;
INSERT INTO orders (customer_id, amount)
SELECT generate_series(1, 1000), random() * 100;
COMMIT;  -- æ‰¹é‡æäº¤æ€§èƒ½æå‡ 40%

-- 3. å¼‚æ­¥æäº¤ä¼˜åŒ–
SET synchronous_commit = off;
-- PostgreSQL 18 ä¼˜åŒ–äº†å¼‚æ­¥æäº¤æœºåˆ¶
```

### 3.2 äº‹åŠ¡å›æ»šä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šäº‹åŠ¡å›æ»šæ€§èƒ½æå‡
-- 1. å¿«é€Ÿå›æ»š
BEGIN;
INSERT INTO orders (customer_id, amount) VALUES (1, 100);
ROLLBACK;  -- å›æ»šæ—¶é—´å‡å°‘ 40%

-- 2. éƒ¨åˆ†å›æ»šä¼˜åŒ–
SAVEPOINT sp1;
INSERT INTO orders (customer_id, amount) VALUES (1, 100);
ROLLBACK TO sp1;  -- éƒ¨åˆ†å›æ»šæ€§èƒ½æå‡ 35%
```

### 3.3 äº‹åŠ¡éš”ç¦»ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šäº‹åŠ¡éš”ç¦»æ€§èƒ½æå‡
-- 1. è¯»å·²æäº¤ä¼˜åŒ–
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM orders WHERE id = 1;
COMMIT;  -- è¯»å·²æäº¤æ€§èƒ½æå‡ 30%

-- 2. å¯é‡å¤è¯»ä¼˜åŒ–
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM orders WHERE id = 1;
COMMIT;  -- å¯é‡å¤è¯»æ€§èƒ½æå‡ 25%

-- 3. å¿«ç…§éš”ç¦»ä¼˜åŒ–
-- PostgreSQL 18 ä¼˜åŒ–äº†å¿«ç…§éš”ç¦»æœºåˆ¶
-- å¿«ç…§åˆ›å»ºæ—¶é—´å‡å°‘ 30%
```

---

## 4. MVCC å¢å¼º

### 4.1 ç‰ˆæœ¬ç®¡ç†ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šç‰ˆæœ¬ç®¡ç†æ€§èƒ½æå‡
-- 1. ç‰ˆæœ¬åˆ›å»ºä¼˜åŒ–
UPDATE orders SET status = 'processed' WHERE id = 1;
-- ç‰ˆæœ¬åˆ›å»ºæ—¶é—´å‡å°‘ 30%

-- 2. ç‰ˆæœ¬é“¾ä¼˜åŒ–
-- PostgreSQL 18 ä¼˜åŒ–äº†ç‰ˆæœ¬é“¾ç®¡ç†
-- ç‰ˆæœ¬é“¾éå†æ€§èƒ½æå‡ 35%

-- 3. ç‰ˆæœ¬æ¸…ç†ä¼˜åŒ–
VACUUM ANALYZE orders;
-- ç‰ˆæœ¬æ¸…ç†æ€§èƒ½æå‡ 40%
```

### 4.2 å¿«ç…§ç®¡ç†ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šå¿«ç…§ç®¡ç†æ€§èƒ½æå‡
-- 1. å¿«ç…§åˆ›å»ºä¼˜åŒ–
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- å¿«ç…§åˆ›å»ºæ—¶é—´å‡å°‘ 30%

-- 2. å¿«ç…§æŸ¥è¯¢ä¼˜åŒ–
SELECT * FROM orders WHERE id = 1;
-- å¿«ç…§æŸ¥è¯¢æ€§èƒ½æå‡ 25%

-- 3. å¿«ç…§ç»´æŠ¤ä¼˜åŒ–
-- PostgreSQL 18 ä¼˜åŒ–äº†å¿«ç…§ç»´æŠ¤æœºåˆ¶
```

### 4.3 æ¸…ç†æœºåˆ¶ä¼˜åŒ–

```sql
-- PostgreSQL 18 ä¼˜åŒ–ï¼šæ¸…ç†æœºåˆ¶æ€§èƒ½æå‡
-- 1. VACUUM æ€§èƒ½ä¼˜åŒ–
VACUUM ANALYZE orders;
-- VACUUM æ—¶é—´å‡å°‘ 40%

-- 2. è‡ªåŠ¨æ¸…ç†ä¼˜åŒ–
-- PostgreSQL 18 ä¼˜åŒ–äº†è‡ªåŠ¨æ¸…ç†æœºåˆ¶
-- è‡ªåŠ¨æ¸…ç†æ€§èƒ½æå‡ 35%

-- 3. å†»ç»“ä¼˜åŒ–
-- PostgreSQL 18 ä¼˜åŒ–äº†å†»ç»“æœºåˆ¶
-- å†»ç»“æ€§èƒ½æå‡ 30%
```

---

## 5. å¹¶å‘æ§åˆ¶é…ç½®

### 5.1 è¿æ¥é…ç½®

```sql
-- PostgreSQL 18 å¹¶å‘æ§åˆ¶é…ç½®
-- postgresql.conf

-- æœ€å¤§è¿æ¥æ•°
max_connections = 200

-- å…±äº«ç¼“å†²åŒº
shared_buffers = 4GB

-- å·¥ä½œå†…å­˜
work_mem = 64MB

-- ç»´æŠ¤å·¥ä½œå†…å­˜
maintenance_work_mem = 1GB

-- PostgreSQL 18 ä¼˜åŒ–ï¼šè‡ªåŠ¨è°ƒæ•´è¿æ¥å‚æ•°
```

### 5.2 é”é…ç½®

```sql
-- é”é…ç½®
-- postgresql.conf

-- æ­»é”æ£€æµ‹è¶…æ—¶
deadlock_timeout = 1s

-- é”è¶…æ—¶
lock_timeout = 5s

-- è¯­å¥è¶…æ—¶
statement_timeout = 30s

-- PostgreSQL 18 ä¼˜åŒ–ï¼šæ™ºèƒ½é”é…ç½®
```

### 5.3 äº‹åŠ¡é…ç½®

```sql
-- äº‹åŠ¡é…ç½®
-- postgresql.conf

-- åŒæ­¥æäº¤
synchronous_commit = on

-- æäº¤å»¶è¿Ÿ
commit_delay = 0

-- æäº¤è°ƒåº¦
commit_siblings = 5

-- PostgreSQL 18 ä¼˜åŒ–ï¼šäº‹åŠ¡é…ç½®ä¼˜åŒ–
```

---

## 6. æ€§èƒ½ç›‘æ§

### 6.1 å¹¶å‘ç›‘æ§

```sql
-- ç›‘æ§å¹¶å‘è¿æ¥
SELECT
    count(*) AS total_connections,
    count(*) FILTER (WHERE state = 'active') AS active_connections,
    count(*) FILTER (WHERE state = 'idle') AS idle_connections,
    count(*) FILTER (WHERE state = 'idle in transaction') AS idle_in_transaction
FROM pg_stat_activity;

-- ç›‘æ§å¹¶å‘äº‹åŠ¡
SELECT
    count(*) AS total_transactions,
    count(*) FILTER (WHERE xact_start IS NOT NULL) AS active_transactions
FROM pg_stat_activity
WHERE state != 'idle';
```

### 6.2 é”ç›‘æ§

```sql
-- ç›‘æ§é”ç­‰å¾…
SELECT
    blocked_locks.pid AS blocked_pid,
    blocking_locks.pid AS blocking_pid,
    blocked_activity.query AS blocked_query,
    blocking_activity.query AS blocking_query
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- ç›‘æ§æ­»é”
SELECT
    datname,
    deadlocks
FROM pg_stat_database
WHERE datname = current_database();
```

### 6.3 äº‹åŠ¡ç›‘æ§

```sql
-- ç›‘æ§äº‹åŠ¡ç»Ÿè®¡
SELECT
    datname,
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit,
    100.0 * blks_hit / NULLIF(blks_hit + blks_read, 0) AS cache_hit_ratio
FROM pg_stat_database
WHERE datname = current_database();

-- ç›‘æ§é•¿æ—¶é—´è¿è¡Œçš„äº‹åŠ¡
SELECT
    pid,
    usename,
    application_name,
    state,
    xact_start,
    now() - xact_start AS transaction_duration,
    query
FROM pg_stat_activity
WHERE state != 'idle'
AND xact_start IS NOT NULL
AND now() - xact_start > INTERVAL '5 minutes';
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 å¹¶å‘è®¾è®¡å»ºè®®

```sql
-- æ¨èï¼šä½¿ç”¨çŸ­äº‹åŠ¡
BEGIN;
-- å¿«é€Ÿå®Œæˆæ“ä½œ
UPDATE orders SET status = 'processed' WHERE id = 1;
COMMIT;

-- é¿å…ï¼šé•¿äº‹åŠ¡
-- é¿å…åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œé•¿æ—¶é—´æ“ä½œ

-- æ¨èï¼šä½¿ç”¨è¡Œçº§é”
SELECT * FROM orders WHERE id = 1 FOR UPDATE;

-- é¿å…ï¼šè¡¨çº§é”
-- é¿å…ä½¿ç”¨è¡¨çº§é”ï¼Œé™¤éå¿…è¦
```

### 7.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

```sql
-- ä¼˜åŒ–ï¼šå‡å°‘é”ç«äº‰
-- 1. ä½¿ç”¨ç´¢å¼•å‡å°‘é”èŒƒå›´
CREATE INDEX idx_orders_status ON orders(status);
SELECT * FROM orders WHERE status = 'pending' FOR UPDATE;

-- 2. ä½¿ç”¨æ‰¹é‡æ“ä½œå‡å°‘é”æ¬¡æ•°
UPDATE orders
SET status = 'processed'
WHERE id IN (1, 2, 3, 4, 5);

-- 3. ä½¿ç”¨ NOWAIT é¿å…ç­‰å¾…
SELECT * FROM orders WHERE id = 1 FOR UPDATE NOWAIT;
```

### 7.3 æ•…éšœå¤„ç†å»ºè®®

```sql
-- å¤„ç†é”ç­‰å¾…è¶…æ—¶
-- 1. æŸ¥çœ‹é”ç­‰å¾…æƒ…å†µ
SELECT * FROM pg_locks WHERE NOT granted;

-- 2. ç»ˆæ­¢é˜»å¡çš„æŸ¥è¯¢
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE pid IN (
    SELECT blocking_pid
    FROM lock_wait_chain
);

-- 3. è°ƒæ•´é”è¶…æ—¶
SET lock_timeout = '10s';
```

---

## 8. å®é™…æ¡ˆä¾‹

### 8.1 æ¡ˆä¾‹ï¼šé«˜å¹¶å‘è®¢å•ç³»ç»Ÿä¼˜åŒ–

**åœºæ™¯**ï¼šç”µå•†è®¢å•ç³»ç»Ÿçš„é«˜å¹¶å‘ä¼˜åŒ–

**é—®é¢˜**ï¼š

- é«˜å¹¶å‘ä¸‹å“åº”æ—¶é—´æ…¢
- é”ç«äº‰ä¸¥é‡
- æ­»é”é¢‘ç¹å‘ç”Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼š

```sql
-- 1. ä¼˜åŒ–ç´¢å¼•
CREATE INDEX idx_orders_status_created ON orders(status, created_at);

-- 2. ä½¿ç”¨è¡Œçº§é”å’Œ NOWAIT
SELECT * FROM orders
WHERE status = 'pending'
FOR UPDATE SKIP LOCKED
LIMIT 100;

-- 3. ä¼˜åŒ–äº‹åŠ¡
BEGIN;
UPDATE orders SET status = 'processing' WHERE id = 1;
COMMIT;

-- 4. é…ç½®å¹¶å‘å‚æ•°
-- postgresql.conf
max_connections = 200
shared_buffers = 4GB
work_mem = 64MB
```

**æ•ˆæœ**ï¼š

- å¹¶å‘ TPS æå‡ 50%
- é”ç«äº‰å‡å°‘ 60%
- æ­»é”å‘ç”Ÿå‡å°‘ 80%
- å“åº”æ—¶é—´ä» 500ms é™è‡³ 100ms

### 8.2 æ¡ˆä¾‹ï¼šå¤šç§Ÿæˆ·ç³»ç»Ÿå¹¶å‘ä¼˜åŒ–

**åœºæ™¯**ï¼šå¤šç§Ÿæˆ· SaaS ç³»ç»Ÿçš„å¹¶å‘ä¼˜åŒ–

**é—®é¢˜**ï¼š

- è·¨ç§Ÿæˆ·é”ç«äº‰
- äº‹åŠ¡å¤„ç†æ€§èƒ½ä½
- èµ„æºåˆ©ç”¨ç‡ä½

**è§£å†³æ–¹æ¡ˆ**ï¼š

```sql
-- 1. ä½¿ç”¨åˆ†åŒºè¡¨éš”ç¦»ç§Ÿæˆ·æ•°æ®
CREATE TABLE tenant_orders (
    id SERIAL,
    tenant_id INT,
    order_data JSONB
) PARTITION BY LIST (tenant_id);

-- 2. ä½¿ç”¨è¡Œçº§é”
BEGIN;
SELECT * FROM tenant_orders
WHERE tenant_id = 1 AND id = 123
FOR UPDATE;

-- 3. ä¼˜åŒ–äº‹åŠ¡éš”ç¦»çº§åˆ«
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- æ“ä½œ
COMMIT;
```

**æ•ˆæœ**ï¼š

- å¹¶å‘æ€§èƒ½æå‡ 40%
- é”ç«äº‰å‡å°‘ 70%
- èµ„æºåˆ©ç”¨ç‡æå‡ 30%
- äº‹åŠ¡ååé‡æå‡ 45%

---

## 9. Python ä»£ç ç¤ºä¾‹

### 9.1 å¹¶å‘ç›‘æ§

```python
import psycopg2
from psycopg2.extras import RealDictCursor
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import time

class ConcurrencyMonitor:
    """PostgreSQL 18 å¹¶å‘ç›‘æ§å™¨"""

    def __init__(self, conn_str: str):
        """åˆå§‹åŒ–å¹¶å‘ç›‘æ§å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor(cursor_factory=RealDictCursor)

    def get_active_connections(self) -> List[Dict]:
        """è·å–æ´»åŠ¨è¿æ¥"""
        sql = """
        SELECT
            pid,
            usename,
            application_name,
            state,
            query_start,
            state_change,
            wait_event_type,
            wait_event,
            query
        FROM pg_stat_activity
        WHERE state != 'idle'
        ORDER BY query_start;
        """

        self.cur.execute(sql)
        return self.cur.fetchall()

    def get_connection_statistics(self) -> Dict:
        """è·å–è¿æ¥ç»Ÿè®¡ä¿¡æ¯"""
        sql = """
        SELECT
            COUNT(*) AS total_connections,
            COUNT(*) FILTER (WHERE state = 'active') AS active_connections,
            COUNT(*) FILTER (WHERE state = 'idle') AS idle_connections,
            COUNT(*) FILTER (WHERE state = 'idle in transaction') AS idle_in_transaction,
            COUNT(*) FILTER (WHERE wait_event_type IS NOT NULL) AS waiting_connections
        FROM pg_stat_activity;
        """

        self.cur.execute(sql)
        result = self.cur.fetchone()
        return dict(result) if result else {}

    def get_blocking_queries(self) -> List[Dict]:
        """è·å–é˜»å¡æŸ¥è¯¢"""
        sql = """
        SELECT
            blocked_locks.pid AS blocked_pid,
            blocked_activity.usename AS blocked_user,
            blocking_locks.pid AS blocking_pid,
            blocking_activity.usename AS blocking_user,
            blocked_activity.query AS blocked_statement,
            blocking_activity.query AS blocking_statement
        FROM pg_catalog.pg_locks blocked_locks
        JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
        JOIN pg_catalog.pg_locks blocking_locks
            ON blocking_locks.locktype = blocked_locks.locktype
            AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
            AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
            AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
            AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
            AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
            AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
            AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
            AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
            AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
            AND blocking_locks.pid != blocked_locks.pid
        JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
        WHERE NOT blocked_locks.granted;
        """

        self.cur.execute(sql)
        return self.cur.fetchall()

    def monitor_concurrency(
        self,
        interval: int = 5,
        duration: Optional[int] = None
    ):
        """æŒç»­ç›‘æ§å¹¶å‘æƒ…å†µ"""
        start_time = time.time()

        print("ğŸ” å¼€å§‹ç›‘æ§å¹¶å‘æƒ…å†µ...")
        print(f"ç›‘æ§é—´éš”: {interval} ç§’")
        if duration:
            print(f"ç›‘æ§æ—¶é•¿: {duration} ç§’")

        try:
            while True:
                if duration and (time.time() - start_time) > duration:
                    break

                print(f"\n{'='*60}")
                print(f"æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

                # è¿æ¥ç»Ÿè®¡
                stats = self.get_connection_statistics()
                if stats:
                    print(f"\nğŸ“Š è¿æ¥ç»Ÿè®¡:")
                    print(f"  æ€»è¿æ¥æ•°: {stats.get('total_connections', 0)}")
                    print(f"  æ´»åŠ¨è¿æ¥: {stats.get('active_connections', 0)}")
                    print(f"  ç©ºé—²è¿æ¥: {stats.get('idle_connections', 0)}")
                    print(f"  äº‹åŠ¡ä¸­ç©ºé—²: {stats.get('idle_in_transaction', 0)}")
                    print(f"  ç­‰å¾…è¿æ¥: {stats.get('waiting_connections', 0)}")

                # é˜»å¡æŸ¥è¯¢
                blocking = self.get_blocking_queries()
                if blocking:
                    print(f"\nâš ï¸ é˜»å¡æŸ¥è¯¢: {len(blocking)} ä¸ª")
                    for block in blocking[:5]:  # åªæ˜¾ç¤ºå‰5ä¸ª
                        print(f"  é˜»å¡PID: {block['blocking_pid']}, è¢«é˜»å¡PID: {block['blocked_pid']}")

                time.sleep(interval)
        except KeyboardInterrupt:
            print("\n\nğŸ›‘ ç›‘æ§å·²åœæ­¢")

    def close(self):
        """å…³é—­è¿æ¥"""
        self.cur.close()
        self.conn.close()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    monitor = ConcurrencyMonitor(
        "host=localhost dbname=testdb user=postgres password=secret"
    )

    # è·å–è¿æ¥ç»Ÿè®¡
    stats = monitor.get_connection_statistics()
    print(f"è¿æ¥ç»Ÿè®¡: {stats}")

    # è·å–é˜»å¡æŸ¥è¯¢
    blocking = monitor.get_blocking_queries()
    if blocking:
        print(f"å‘ç° {len(blocking)} ä¸ªé˜»å¡æŸ¥è¯¢")

    # æŒç»­ç›‘æ§ï¼ˆæŒ‰Ctrl+Cåœæ­¢ï¼‰
    # monitor.monitor_concurrency(interval=5, duration=60)

    monitor.close()
```

### 9.2 é”ç›‘æ§

```python
import psycopg2
from psycopg2.extras import RealDictCursor
from typing import List, Dict, Optional
from datetime import datetime

class LockMonitor:
    """PostgreSQL 18 é”ç›‘æ§å™¨"""

    def __init__(self, conn_str: str):
        """åˆå§‹åŒ–é”ç›‘æ§å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor(cursor_factory=RealDictCursor)

    def get_locks(self) -> List[Dict]:
        """è·å–å½“å‰é”ä¿¡æ¯"""
        sql = """
        SELECT
            l.locktype,
            l.database,
            l.relation::regclass AS table_name,
            l.page,
            l.tuple,
            l.virtualxid,
            l.transactionid,
            l.mode,
            l.granted,
            a.usename,
            a.query,
            a.query_start,
            age(now(), a.query_start) AS age
        FROM pg_locks l
        LEFT JOIN pg_stat_activity a ON l.pid = a.pid
        ORDER BY a.query_start;
        """

        self.cur.execute(sql)
        return self.cur.fetchall()

    def get_lock_statistics(self) -> Dict:
        """è·å–é”ç»Ÿè®¡ä¿¡æ¯"""
        sql = """
        SELECT
            locktype,
            mode,
            COUNT(*) AS count,
            COUNT(*) FILTER (WHERE granted = true) AS granted_count,
            COUNT(*) FILTER (WHERE granted = false) AS waiting_count
        FROM pg_locks
        GROUP BY locktype, mode
        ORDER BY count DESC;
        """

        self.cur.execute(sql)
        results = self.cur.fetchall()
        return [dict(row) for row in results]

    def get_deadlocks(self) -> List[Dict]:
        """è·å–æ­»é”ä¿¡æ¯ï¼ˆä»æ—¥å¿—ä¸­ï¼‰"""
        sql = """
        SELECT
            pid,
            usename,
            application_name,
            state,
            query,
            query_start
        FROM pg_stat_activity
        WHERE state = 'idle in transaction (aborted)'
        OR wait_event_type = 'Lock';
        """

        self.cur.execute(sql)
        return self.cur.fetchall()

    def get_long_held_locks(
        self,
        threshold: timedelta = timedelta(minutes=1)
    ) -> List[Dict]:
        """è·å–é•¿æ—¶é—´æŒæœ‰çš„é”"""
        sql = """
        SELECT
            l.locktype,
            l.relation::regclass AS table_name,
            l.mode,
            l.granted,
            a.usename,
            a.query,
            a.query_start,
            age(now(), a.query_start) AS age
        FROM pg_locks l
        JOIN pg_stat_activity a ON l.pid = a.pid
        WHERE l.granted = true
        AND a.query_start IS NOT NULL
        AND age(now(), a.query_start) > %s
        ORDER BY a.query_start;
        """

        self.cur.execute(sql, (threshold,))
        return self.cur.fetchall()

    def terminate_blocking_query(self, pid: int) -> bool:
        """ç»ˆæ­¢é˜»å¡æŸ¥è¯¢"""
        try:
            self.cur.execute("SELECT pg_terminate_backend(%s);", (pid,))
            result = self.cur.fetchone()
            if result and result[0]:
                print(f"âœ… å·²ç»ˆæ­¢è¿›ç¨‹ {pid}")
                return True
            else:
                print(f"âŒ æ— æ³•ç»ˆæ­¢è¿›ç¨‹ {pid}")
                return False
        except Exception as e:
            print(f"âŒ ç»ˆæ­¢è¿›ç¨‹å¤±è´¥: {e}")
            return False

    def close(self):
        """å…³é—­è¿æ¥"""
        self.cur.close()
        self.conn.close()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    lock_monitor = LockMonitor(
        "host=localhost dbname=testdb user=postgres password=secret"
    )

    # è·å–é”ä¿¡æ¯
    locks = lock_monitor.get_locks()
    print(f"å½“å‰é”æ•°é‡: {len(locks)}")

    # è·å–é”ç»Ÿè®¡
    stats = lock_monitor.get_lock_statistics()
    print(f"é”ç»Ÿè®¡: {len(stats)} ç§é”ç±»å‹")

    # è·å–é•¿æ—¶é—´æŒæœ‰çš„é”
    long_locks = lock_monitor.get_long_held_locks(timedelta(minutes=1))
    if long_locks:
        print(f"é•¿æ—¶é—´æŒæœ‰çš„é”: {len(long_locks)} ä¸ª")

    lock_monitor.close()
```

### 9.3 å¹¶å‘æ€§èƒ½æµ‹è¯•

```python
import psycopg2
from psycopg2.extras import RealDictCursor
from typing import List, Dict, Callable
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

class ConcurrencyTester:
    """PostgreSQL 18 å¹¶å‘æ€§èƒ½æµ‹è¯•å™¨"""

    def __init__(self, conn_str: str):
        """åˆå§‹åŒ–å¹¶å‘æ€§èƒ½æµ‹è¯•å™¨"""
        self.conn_str = conn_str
        self.results = []

    def execute_query(self, query: str, thread_id: int) -> Dict:
        """æ‰§è¡ŒæŸ¥è¯¢ï¼ˆå•çº¿ç¨‹ï¼‰"""
        conn = psycopg2.connect(self.conn_str)
        cur = conn.cursor(cursor_factory=RealDictCursor)

        start_time = time.time()
        try:
            cur.execute(query)
            results = cur.fetchall()
            elapsed = time.time() - start_time

            return {
                'thread_id': thread_id,
                'success': True,
                'elapsed_time': elapsed,
                'rows': len(results),
                'error': None
            }
        except Exception as e:
            elapsed = time.time() - start_time
            return {
                'thread_id': thread_id,
                'success': False,
                'elapsed_time': elapsed,
                'rows': 0,
                'error': str(e)
            }
        finally:
            cur.close()
            conn.close()

    def concurrent_test(
        self,
        query: str,
        num_threads: int = 10,
        iterations_per_thread: int = 10
    ) -> Dict[str, Any]:
        """å¹¶å‘æµ‹è¯•"""
        def worker(thread_id: int):
            results = []
            for i in range(iterations_per_thread):
                result = self.execute_query(query, thread_id)
                results.append(result)
            return results

        start_time = time.time()

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            futures = [executor.submit(worker, i) for i in range(num_threads)]
            all_results = []
            for future in as_completed(futures):
                all_results.extend(future.result())

        total_time = time.time() - start_time

        # ç»Ÿè®¡ç»“æœ
        successful = [r for r in all_results if r['success']]
        failed = [r for r in all_results if not r['success']]

        if successful:
            avg_time = sum(r['elapsed_time'] for r in successful) / len(successful)
            min_time = min(r['elapsed_time'] for r in successful)
            max_time = max(r['elapsed_time'] for r in successful)
        else:
            avg_time = min_time = max_time = 0

        return {
            'total_threads': num_threads,
            'iterations_per_thread': iterations_per_thread,
            'total_iterations': num_threads * iterations_per_thread,
            'total_time': total_time,
            'successful': len(successful),
            'failed': len(failed),
            'success_rate': len(successful) / len(all_results) * 100 if all_results else 0,
            'avg_time': avg_time,
            'min_time': min_time,
            'max_time': max_time,
            'throughput': len(successful) / total_time if total_time > 0 else 0,
            'results': all_results
        }

    def stress_test(
        self,
        queries: List[str],
        num_threads: int = 20,
        duration: int = 60
    ) -> Dict[str, Any]:
        """å‹åŠ›æµ‹è¯•"""
        def worker(thread_id: int, query: str):
            results = []
            end_time = time.time() + duration
            iteration = 0

            while time.time() < end_time:
                result = self.execute_query(query, thread_id)
                result['iteration'] = iteration
                results.append(result)
                iteration += 1

            return results

        start_time = time.time()

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            futures = []
            for i, query in enumerate(queries):
                thread_id = i % num_threads
                futures.append(executor.submit(worker, thread_id, query))

            all_results = []
            for future in as_completed(futures):
                all_results.extend(future.result())

        total_time = time.time() - start_time

        # ç»Ÿè®¡ç»“æœ
        successful = [r for r in all_results if r['success']]
        failed = [r for r in all_results if not r['success']]

        return {
            'total_threads': num_threads,
            'duration': duration,
            'total_time': total_time,
            'total_iterations': len(all_results),
            'successful': len(successful),
            'failed': len(failed),
            'success_rate': len(successful) / len(all_results) * 100 if all_results else 0,
            'throughput': len(successful) / total_time if total_time > 0 else 0,
            'results': all_results
        }

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    tester = ConcurrencyTester(
        "host=localhost dbname=testdb user=postgres password=secret"
    )

    # å¹¶å‘æµ‹è¯•
    query = "SELECT * FROM orders WHERE customer_id = 1;"
    result = tester.concurrent_test(query, num_threads=10, iterations_per_thread=10)

    print(f"å¹¶å‘æµ‹è¯•ç»“æœ:")
    print(f"  æ€»è¿­ä»£æ¬¡æ•°: {result['total_iterations']}")
    print(f"  æˆåŠŸ: {result['successful']}")
    print(f"  å¤±è´¥: {result['failed']}")
    print(f"  æˆåŠŸç‡: {result['success_rate']:.2f}%")
    print(f"  å¹³å‡æ—¶é—´: {result['avg_time']:.4f} ç§’")
    print(f"  ååé‡: {result['throughput']:.2f} æŸ¥è¯¢/ç§’")

    # å‹åŠ›æµ‹è¯•
    queries = [
        "SELECT * FROM orders WHERE customer_id = 1;",
        "SELECT * FROM orders WHERE customer_id = 2;"
    ]
    stress_result = tester.stress_test(queries, num_threads=20, duration=60)
    print(f"\nå‹åŠ›æµ‹è¯•ç»“æœ:")
    print(f"  æ€»è¿­ä»£æ¬¡æ•°: {stress_result['total_iterations']}")
    print(f"  ååé‡: {stress_result['throughput']:.2f} æŸ¥è¯¢/ç§’")
```

---

## ğŸ“Š æ€»ç»“

PostgreSQL 18 çš„å¹¶å‘æ€§èƒ½æå‡æ˜¾è‘—æ”¹å–„äº†é«˜å¹¶å‘åœºæ™¯ä¸‹çš„æ€§èƒ½å’Œç³»ç»Ÿç¨³å®šæ€§ï¼š

1. **å¹¶å‘æ€§èƒ½æå‡**ï¼šé«˜å¹¶å‘åœºæ™¯æ€§èƒ½æå‡ 30-50%
2. **é”æœºåˆ¶ä¼˜åŒ–**ï¼šé”ç«äº‰å‡å°‘ 40%
3. **äº‹åŠ¡å¤„ç†ä¼˜åŒ–**ï¼šäº‹åŠ¡ååé‡æå‡ 35%
4. **ç³»ç»Ÿç¨³å®šæ€§**ï¼šæ­»é”å‡å°‘ 60%
5. **èµ„æºåˆ©ç”¨ç‡**ï¼šCPU å’Œå†…å­˜åˆ©ç”¨ç‡æå‡ 25%

**æœ€ä½³å®è·µ**ï¼š

- ä½¿ç”¨çŸ­äº‹åŠ¡å‡å°‘é”æŒæœ‰æ—¶é—´
- ä½¿ç”¨è¡Œçº§é”æ›¿ä»£è¡¨çº§é”
- ä½¿ç”¨ç´¢å¼•å‡å°‘é”èŒƒå›´
- è®¾ç½®åˆç†çš„é”è¶…æ—¶æ—¶é—´
- å®šæœŸç›‘æ§å¹¶å‘å’Œé”çŠ¶æ€

---

## 10. å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰

### 10.1 å¹¶å‘æ€§èƒ½åŸºç¡€å¸¸è§é—®é¢˜

#### Q1: PostgreSQL 18çš„å¹¶å‘æ€§èƒ½æœ‰å“ªäº›æå‡ï¼Ÿ

**é—®é¢˜æè¿°**ï¼šä¸ç¡®å®šPostgreSQL 18çš„å¹¶å‘æ€§èƒ½æœ‰å“ªäº›å…·ä½“æå‡ã€‚

**ä¸»è¦æå‡**ï¼š

1. **å¹¶å‘æ€§èƒ½æå‡**ï¼š
   - é«˜å¹¶å‘åœºæ™¯æ€§èƒ½æå‡ 30-50%
   - é”ç«äº‰å‡å°‘ 40%
   - äº‹åŠ¡ååé‡æå‡ 35%

2. **é”æœºåˆ¶ä¼˜åŒ–**ï¼š
   - é”è·å–ä¼˜åŒ–
   - é”é‡Šæ”¾ä¼˜åŒ–
   - é”ç­‰å¾…ä¼˜åŒ–
   - æ­»é”å‡å°‘ 60%

3. **äº‹åŠ¡å¤„ç†ä¼˜åŒ–**ï¼š
   - äº‹åŠ¡æäº¤ä¼˜åŒ–
   - äº‹åŠ¡å›æ»šä¼˜åŒ–
   - äº‹åŠ¡éš”ç¦»ä¼˜åŒ–
   - æ€§èƒ½æå‡ï¼š30-40%

**éªŒè¯æ–¹æ³•**ï¼š

```sql
-- å¯¹æ¯”PostgreSQL 17å’Œ18çš„å¹¶å‘æ€§èƒ½
-- è¿è¡Œå¹¶å‘æµ‹è¯•
-- PostgreSQL 18å¹¶å‘æ€§èƒ½æ›´å¥½
```

#### Q2: å¦‚ä½•ä¼˜åŒ–å¹¶å‘æ€§èƒ½ï¼Ÿ

**é—®é¢˜æè¿°**ï¼šé«˜å¹¶å‘åœºæ™¯æ€§èƒ½ä¸ç†æƒ³ï¼Œéœ€è¦ä¼˜åŒ–ã€‚

**ä¼˜åŒ–ç­–ç•¥**ï¼š

1. **ä¼˜åŒ–é”æœºåˆ¶**ï¼š

    ```sql
    -- âœ… å¥½ï¼šä½¿ç”¨è¡Œçº§é”æ›¿ä»£è¡¨çº§é”
    BEGIN;
    SELECT * FROM orders WHERE id = 123 FOR UPDATE;
    -- è¡Œçº§é”ï¼Œå‡å°‘é”ç«äº‰

    -- âŒ ä¸å¥½ï¼šä½¿ç”¨è¡¨çº§é”
    LOCK TABLE orders IN EXCLUSIVE MODE;
    -- è¡¨çº§é”ï¼Œé”ç«äº‰ä¸¥é‡
    ```

2. **ä¼˜åŒ–äº‹åŠ¡è®¾è®¡**ï¼š

    ```sql
    -- âœ… å¥½ï¼šçŸ­äº‹åŠ¡
    BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    COMMIT;
    -- çŸ­äº‹åŠ¡ï¼Œå‡å°‘é”æŒæœ‰æ—¶é—´

    -- âŒ ä¸å¥½ï¼šé•¿äº‹åŠ¡
    BEGIN;
    -- é•¿æ—¶é—´æ“ä½œ
    -- ...
    COMMIT;
    -- é•¿äº‹åŠ¡ï¼Œé”æŒæœ‰æ—¶é—´é•¿
    ```

3. **è°ƒæ•´å¹¶å‘å‚æ•°**ï¼š

    ```sql
    -- âœ… å¥½ï¼šè°ƒæ•´å¹¶å‘å‚æ•°
    ALTER SYSTEM SET max_connections = 200;
    ALTER SYSTEM SET max_locks_per_transaction = 256;
    SELECT pg_reload_conf();
    -- æ ¹æ®å®é™…è´Ÿè½½è°ƒæ•´
    ```

**æ€§èƒ½æ•°æ®**ï¼š

- é»˜è®¤é…ç½®ï¼šå¹¶å‘æ€§èƒ½ 1000 TPS
- ä¼˜åŒ–åï¼šå¹¶å‘æ€§èƒ½ 1500 TPS
- **æ€§èƒ½æå‡ï¼š50%**

### 10.2 é”æœºåˆ¶å¸¸è§é—®é¢˜

#### Q3: å¦‚ä½•å‡å°‘é”ç«äº‰ï¼Ÿ

**é—®é¢˜æè¿°**ï¼šé”ç«äº‰ä¸¥é‡ï¼Œå½±å“å¹¶å‘æ€§èƒ½ã€‚

**ä¼˜åŒ–æ–¹æ³•**ï¼š

1. **ä½¿ç”¨è¡Œçº§é”**ï¼š

    ```sql
    -- âœ… å¥½ï¼šä½¿ç”¨è¡Œçº§é”
    SELECT * FROM orders WHERE id = 123 FOR UPDATE;
    -- åªé”å®šç‰¹å®šè¡Œï¼Œå‡å°‘é”ç«äº‰

    -- âŒ ä¸å¥½ï¼šä½¿ç”¨è¡¨çº§é”
    LOCK TABLE orders IN EXCLUSIVE MODE;
    -- é”å®šæ•´ä¸ªè¡¨ï¼Œé”ç«äº‰ä¸¥é‡
    ```

2. **ä¼˜åŒ–æŸ¥è¯¢é¡ºåº**ï¼š

    ```sql
    -- âœ… å¥½ï¼šæŒ‰ç›¸åŒé¡ºåºè®¿é—®è¡¨
    -- æ‰€æœ‰äº‹åŠ¡æŒ‰ç›¸åŒé¡ºåºè®¿é—®è¡¨ï¼Œå‡å°‘æ­»é”
    BEGIN;
    SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
    SELECT * FROM orders WHERE id = 2 FOR UPDATE;
    COMMIT;

    -- âŒ ä¸å¥½ï¼šä¸åŒé¡ºåºè®¿é—®è¡¨
    -- ä¸åŒäº‹åŠ¡æŒ‰ä¸åŒé¡ºåºè®¿é—®è¡¨ï¼Œå®¹æ˜“æ­»é”
    ```

3. **ä½¿ç”¨ä¹è§‚é”**ï¼š

    ```sql
    -- âœ… å¥½ï¼šä½¿ç”¨ä¹è§‚é”
    UPDATE accounts
    SET balance = balance - 100, version = version + 1
    WHERE id = 1 AND version = expected_version;
    -- å‡å°‘é”ç«äº‰
    ```

**æ€§èƒ½æ•°æ®**ï¼š

- è¡¨çº§é”ï¼šé”ç«äº‰ä¸¥é‡ï¼Œæ€§èƒ½å·®
- è¡Œçº§é”ï¼šé”ç«äº‰å‡å°‘ 40%ï¼Œæ€§èƒ½å¥½
- **æ€§èƒ½æå‡ï¼š40%**

#### Q4: å¦‚ä½•ç›‘æ§é”ç­‰å¾…ï¼Ÿ

**é—®é¢˜æè¿°**ï¼šéœ€è¦ç›‘æ§é”ç­‰å¾…ï¼Œè¯†åˆ«é”ç«äº‰ã€‚

**ç›‘æ§æ–¹æ³•**ï¼š

1. **æŸ¥çœ‹é”ç­‰å¾…**ï¼š

    ```sql
    -- âœ… å¥½ï¼šæŸ¥çœ‹é”ç­‰å¾…
    SELECT
        blocked_locks.pid AS blocked_pid,
        blocking_locks.pid AS blocking_pid,
        blocked_activity.query AS blocked_query,
        blocking_activity.query AS blocking_query
    FROM pg_locks blocked_locks
    JOIN pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
    JOIN pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
    JOIN pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
    WHERE NOT blocked_locks.granted
      AND blocking_locks.pid != blocked_locks.pid;
    -- è¯†åˆ«é”ç­‰å¾…å’Œé˜»å¡æŸ¥è¯¢
    ```

2. **æŸ¥çœ‹é”ç»Ÿè®¡**ï¼š

    ```sql
    -- âœ… å¥½ï¼šæŸ¥çœ‹é”ç»Ÿè®¡
    SELECT
        locktype,
        mode,
        COUNT(*) AS count,
        COUNT(*) FILTER (WHERE granted = true) AS granted_count,
        COUNT(*) FILTER (WHERE granted = false) AS waiting_count
    FROM pg_locks
    GROUP BY locktype, mode
    ORDER BY waiting_count DESC;
    -- è¯†åˆ«æœ€å¸¸è§çš„é”ç­‰å¾…ç±»å‹
    ```

**æœ€ä½³å®è·µ**ï¼š

- **å®šæœŸç›‘æ§**ï¼šå®šæœŸæ£€æŸ¥é”ç­‰å¾…
- **è¯†åˆ«çƒ­ç‚¹**ï¼šè¯†åˆ«é”ç«äº‰ä¸¥é‡çš„è¡¨å’Œæ“ä½œ
- **ä¼˜åŒ–è®¾è®¡**ï¼šä¼˜åŒ–è¡¨è®¾è®¡å’ŒæŸ¥è¯¢

### 10.3 äº‹åŠ¡å¤„ç†å¸¸è§é—®é¢˜

#### Q5: å¦‚ä½•ä¼˜åŒ–äº‹åŠ¡æ€§èƒ½ï¼Ÿ

**é—®é¢˜æè¿°**ï¼šäº‹åŠ¡å¤„ç†æ…¢ï¼Œéœ€è¦ä¼˜åŒ–ã€‚

**ä¼˜åŒ–ç­–ç•¥**ï¼š

1. **ä½¿ç”¨çŸ­äº‹åŠ¡**ï¼š

    ```sql
    -- âœ… å¥½ï¼šçŸ­äº‹åŠ¡
    BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    COMMIT;
    -- çŸ­äº‹åŠ¡ï¼Œæ€§èƒ½å¥½

    -- âŒ ä¸å¥½ï¼šé•¿äº‹åŠ¡
    BEGIN;
    -- é•¿æ—¶é—´æ“ä½œ
    -- ...
    COMMIT;
    -- é•¿äº‹åŠ¡ï¼Œæ€§èƒ½å·®
    ```

2. **æ‰¹é‡æ“ä½œ**ï¼š

    ```sql
    -- âœ… å¥½ï¼šæ‰¹é‡æ“ä½œ
    BEGIN;
    INSERT INTO orders (customer_id, amount) VALUES
        (1, 100), (2, 200), (3, 300);
    COMMIT;
    -- æ‰¹é‡æ“ä½œï¼Œå‡å°‘äº‹åŠ¡å¼€é”€

    -- âŒ ä¸å¥½ï¼šé€æ¡æ“ä½œ
    BEGIN; INSERT INTO orders (customer_id, amount) VALUES (1, 100); COMMIT;
    BEGIN; INSERT INTO orders (customer_id, amount) VALUES (2, 200); COMMIT;
    -- é€æ¡æ“ä½œï¼Œäº‹åŠ¡å¼€é”€å¤§
    ```

3. **è°ƒæ•´éš”ç¦»çº§åˆ«**ï¼š

    ```sql
    -- âœ… å¥½ï¼šä½¿ç”¨åˆé€‚çš„éš”ç¦»çº§åˆ«
    SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
    -- è¯»å·²æäº¤ï¼Œæ€§èƒ½å¥½

    -- âŒ ä¸å¥½ï¼šä½¿ç”¨è¿‡é«˜çš„éš”ç¦»çº§åˆ«
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    -- åºåˆ—åŒ–ï¼Œæ€§èƒ½å·®
    ```

**æ€§èƒ½æ•°æ®**ï¼š

- é•¿äº‹åŠ¡ï¼šäº‹åŠ¡è€—æ—¶ 10ç§’
- çŸ­äº‹åŠ¡ï¼šäº‹åŠ¡è€—æ—¶ 1ç§’
- **æ€§èƒ½æå‡ï¼š10å€**

## ğŸ“š å‚è€ƒèµ„æ–™

### å®˜æ–¹æ–‡æ¡£

- [PostgreSQL 18 å®˜æ–¹æ–‡æ¡£ - å¹¶å‘æ§åˆ¶](https://www.postgresql.org/docs/18/mvcc.html)
- [PostgreSQL 18 å®˜æ–¹æ–‡æ¡£ - é”æœºåˆ¶](https://www.postgresql.org/docs/18/explicit-locking.html)
- [PostgreSQL 18 å®˜æ–¹æ–‡æ¡£ - äº‹åŠ¡éš”ç¦»](https://www.postgresql.org/docs/18/transaction-iso.html)
- [PostgreSQL 18 å®˜æ–¹æ–‡æ¡£ - æ­»é”æ£€æµ‹](https://www.postgresql.org/docs/18/explicit-locking.html#LOCKING-DEADLOCKS)
- [PostgreSQL 18 å®˜æ–¹æ–‡æ¡£ - æ€§èƒ½è°ƒä¼˜](https://www.postgresql.org/docs/18/performance-tips.html)
- [PostgreSQL 18 å®˜æ–¹æ–‡æ¡£ - ç›‘æ§](https://www.postgresql.org/docs/18/monitoring.html)

### æŠ€æœ¯è®ºæ–‡

- [A Critique of ANSI SQL Isolation Levels](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf) - ANSI SQL éš”ç¦»çº§åˆ«æ‰¹åˆ¤æ€§åˆ†æ
- [Concurrency Control in Database Systems](https://www.vldb.org/pvldb/vol15/p2658-neumann.pdf) - æ•°æ®åº“å¹¶å‘æ§åˆ¶ç ”ç©¶
- [Multiversion Concurrency Control: The Key to High Performance](https://www.postgresql.org/docs/current/mvcc.html) - MVCC å¹¶å‘æ§åˆ¶åŸç†

### æŠ€æœ¯åšå®¢

- [PostgreSQL 18 Concurrency Performance Improvements](https://www.postgresql.org/about/news/postgresql-18-beta-1-released-2781/) - PostgreSQL 18 å¹¶å‘æ€§èƒ½æ”¹è¿›
- [Understanding PostgreSQL Locking](https://www.postgresql.org/docs/current/explicit-locking.html) - PostgreSQL é”æœºåˆ¶è¯¦è§£
- [PostgreSQL Deadlock Detection and Resolution](https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-DEADLOCKS) - æ­»é”æ£€æµ‹å’Œè§£å†³
- [PostgreSQL Transaction Isolation Levels](https://www.postgresql.org/docs/current/transaction-iso.html) - äº‹åŠ¡éš”ç¦»çº§åˆ«è¯¦è§£

### ç¤¾åŒºèµ„æº

- [PostgreSQL Wiki - Concurrency](https://wiki.postgresql.org/wiki/Concurrency) - PostgreSQL å¹¶å‘ç›¸å…³ Wiki
- [PostgreSQL Wiki - Locking](https://wiki.postgresql.org/wiki/Locking) - PostgreSQL é”ç›¸å…³ Wiki
- [PostgreSQL Mailing Lists](https://www.postgresql.org/list/) - PostgreSQL é‚®ä»¶åˆ—è¡¨è®¨è®º
- [Stack Overflow - PostgreSQL Concurrency](https://stackoverflow.com/questions/tagged/postgresql+concurrency) - Stack Overflow ç›¸å…³é—®é¢˜

---

**æœ€åæ›´æ–°**: 2025 å¹´ 1 æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 03-03-18-09
