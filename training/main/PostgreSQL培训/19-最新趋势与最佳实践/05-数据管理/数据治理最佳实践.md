# PostgreSQLæ•°æ®æ²»ç†æœ€ä½³å®è·µ

> **æ›´æ–°æ—¶é—´**: 2025å¹´1æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 17+/18+
> **æ–‡æ¡£ç¼–å·**: 19-05-04

---

## ğŸ“‘ ç›®å½•

- [PostgreSQLæ•°æ®æ²»ç†æœ€ä½³å®è·µ](#postgresqlæ•°æ®æ²»ç†æœ€ä½³å®è·µ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æ•°æ®æ²»ç†ä»·å€¼](#11-æ•°æ®æ²»ç†ä»·å€¼)
  - [2. æ•°æ®æ²»ç†ç­–ç•¥çŸ©é˜µ](#2-æ•°æ®æ²»ç†ç­–ç•¥çŸ©é˜µ)
  - [3. æ•°æ®è´¨é‡å†³ç­–æ ‘](#3-æ•°æ®è´¨é‡å†³ç­–æ ‘)
  - [4. å®é™…åº”ç”¨æ¡ˆä¾‹](#4-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [4.1 æ¡ˆä¾‹ï¼šé‡‘èç³»ç»Ÿæ•°æ®æ²»ç†](#41-æ¡ˆä¾‹é‡‘èç³»ç»Ÿæ•°æ®æ²»ç†)
  - [5. æ•°æ®åˆ†ç±»ä¸æ ‡è®°](#5-æ•°æ®åˆ†ç±»ä¸æ ‡è®°)
    - [5.1 æ•°æ®åˆ†ç±»ç­–ç•¥](#51-æ•°æ®åˆ†ç±»ç­–ç•¥)
    - [5.2 æ•°æ®æ ‡è®°ä¸æ ‡ç­¾](#52-æ•°æ®æ ‡è®°ä¸æ ‡ç­¾)
  - [6. æ•°æ®è´¨é‡ä¿è¯](#6-æ•°æ®è´¨é‡ä¿è¯)
    - [6.1 æ•°æ®éªŒè¯è§„åˆ™](#61-æ•°æ®éªŒè¯è§„åˆ™)
    - [6.2 æ•°æ®è´¨é‡ç›‘æ§](#62-æ•°æ®è´¨é‡ç›‘æ§)
  - [7. æ•°æ®è®¿é—®å®¡è®¡](#7-æ•°æ®è®¿é—®å®¡è®¡)
    - [7.1 å®¡è®¡æ—¥å¿—å¢å¼º](#71-å®¡è®¡æ—¥å¿—å¢å¼º)
    - [7.2 å®¡è®¡æ—¥å¿—åˆ†æ](#72-å®¡è®¡æ—¥å¿—åˆ†æ)
  - [8. å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰](#8-å¸¸è§é—®é¢˜faq)
    - [8.1 æ•°æ®æ²»ç†åŸºç¡€å¸¸è§é—®é¢˜](#81-æ•°æ®æ²»ç†åŸºç¡€å¸¸è§é—®é¢˜)
      - [Q1: å¦‚ä½•å®æ–½æ•°æ®åˆ†ç±»ï¼Ÿ](#q1-å¦‚ä½•å®æ–½æ•°æ®åˆ†ç±»)
      - [Q2: å¦‚ä½•ä¿è¯æ•°æ®è´¨é‡ï¼Ÿ](#q2-å¦‚ä½•ä¿è¯æ•°æ®è´¨é‡)
    - [8.2 æ•°æ®å®‰å…¨å¸¸è§é—®é¢˜](#82-æ•°æ®å®‰å…¨å¸¸è§é—®é¢˜)
      - [Q3: å¦‚ä½•å®ç°æ•°æ®åŠ å¯†ï¼Ÿ](#q3-å¦‚ä½•å®ç°æ•°æ®åŠ å¯†)

---

## 1. æ¦‚è¿°

### 1.1 æ•°æ®æ²»ç†ä»·å€¼

**æ•°æ®æ²»ç†çš„æ ¸å¿ƒä»·å€¼**ï¼š

| ä»·å€¼ç»´åº¦ | è¯´æ˜ | é‡åŒ–æ•°æ® |
|---------|------|---------|
| **æ•°æ®è´¨é‡** | æ•°æ®å‡†ç¡®æ€§ | **+50%** è´¨é‡ |
| **åˆè§„æ€§** | æ³•è§„éµå¾ª | **100%** åˆè§„ |
| **æ•°æ®å®‰å…¨** | æ•°æ®ä¿æŠ¤ | **+80%** å®‰å…¨æ€§ |

---

## 2. æ•°æ®æ²»ç†ç­–ç•¥çŸ©é˜µ

| ç­–ç•¥ | å®æ–½éš¾åº¦ | æ•ˆæœ | æˆæœ¬ | ä¼˜å…ˆçº§ |
|------|---------|------|------|--------|
| **æ•°æ®åˆ†ç±»** | â­â­ | â­â­â­â­ | ä½ | P0 |
| **è®¿é—®æ§åˆ¶** | â­â­â­ | â­â­â­â­â­ | ä¸­ | P0 |
| **æ•°æ®åŠ å¯†** | â­â­â­ | â­â­â­â­â­ | ä¸­ | P1 |
| **å®¡è®¡æ—¥å¿—** | â­â­ | â­â­â­â­ | ä½ | P1 |

---

## 3. æ•°æ®è´¨é‡å†³ç­–æ ‘

```text
æ•°æ®è´¨é‡é—®é¢˜ï¼Ÿ
â”œâ”€ æ•°æ®å‡†ç¡®æ€§
â”‚  â””â”€ æ•°æ®éªŒè¯è§„åˆ™
â”œâ”€ æ•°æ®å®Œæ•´æ€§
â”‚  â””â”€ çº¦æŸæ£€æŸ¥
â””â”€ æ•°æ®ä¸€è‡´æ€§
   â””â”€ äº‹åŠ¡ä¿è¯
```

---

## 4. å®é™…åº”ç”¨æ¡ˆä¾‹

### 4.1 æ¡ˆä¾‹ï¼šé‡‘èç³»ç»Ÿæ•°æ®æ²»ç†

**ä¸šåŠ¡åœºæ™¯**ï¼š

- é“¶è¡Œæ ¸å¿ƒç³»ç»Ÿ
- 1000ä¸‡+è´¦æˆ·æ•°æ®
- ä¸¥æ ¼çš„åˆè§„è¦æ±‚ï¼ˆGDPRã€PCI-DSSï¼‰

**å®æ–½æ–¹æ¡ˆ**ï¼š

```sql
-- 1. æ•°æ®åˆ†ç±»
CREATE TABLE account_data (
    id BIGSERIAL PRIMARY KEY,
    account_number TEXT,
    balance DECIMAL(15, 2),
    data_classification TEXT CHECK (data_classification IN ('public', 'internal', 'confidential', 'restricted')),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. è®¿é—®æ§åˆ¶ï¼ˆè¡Œçº§å®‰å…¨ï¼‰
ALTER TABLE account_data ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_access_policy ON account_data
    FOR SELECT
    USING (
        CASE data_classification
            WHEN 'public' THEN true
            WHEN 'internal' THEN current_user IN (SELECT username FROM authorized_users)
            WHEN 'confidential' THEN current_user IN (SELECT username FROM managers)
            WHEN 'restricted' THEN current_user = 'admin'
        END
    );

-- 3. æ•°æ®åŠ å¯†
CREATE EXTENSION IF NOT EXISTS pgcrypto;

ALTER TABLE account_data
ADD COLUMN encrypted_account_number BYTEA;

-- åŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_account_number(account_num TEXT)
RETURNS BYTEA AS $$
BEGIN
    RETURN pgp_sym_encrypt(account_num, current_setting('app.encryption_key'));
END;
$$ LANGUAGE plpgsql;

-- 4. å®¡è®¡æ—¥å¿—
CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    table_name TEXT,
    operation TEXT,
    old_data JSONB,
    new_data JSONB,
    user_name TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, new_data, user_name)
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        row_to_json(OLD)::JSONB,
        row_to_json(NEW)::JSONB,
        current_user
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER account_data_audit
    AFTER INSERT OR UPDATE OR DELETE ON account_data
    FOR EACH ROW EXECUTE FUNCTION audit_trigger();
```

**å®æ–½æ•ˆæœ**ï¼š

| æŒ‡æ ‡ | å®æ–½å‰ | å®æ–½å | æå‡ |
|------|--------|--------|------|
| **æ•°æ®è´¨é‡** | 75% | 95% | **+27%** |
| **åˆè§„æ€§** | 60% | 100% | **+67%** |
| **å®‰å…¨äº‹ä»¶** | 10æ¬¡/å¹´ | 0æ¬¡/å¹´ | **-100%** |

---

## 5. æ•°æ®åˆ†ç±»ä¸æ ‡è®°

### 5.1 æ•°æ®åˆ†ç±»ç­–ç•¥

**æ•°æ®åˆ†ç±»çŸ©é˜µ**ï¼š

| åˆ†ç±»çº§åˆ« | è¯´æ˜ | è®¿é—®æ§åˆ¶ | åŠ å¯†è¦æ±‚ | å®¡è®¡è¦æ±‚ |
|---------|------|---------|---------|---------|
| **å…¬å¼€ï¼ˆPublicï¼‰** | å…¬å¼€æ•°æ® | æ‰€æœ‰äºº | å¦ | ä½ |
| **å†…éƒ¨ï¼ˆInternalï¼‰** | å†…éƒ¨æ•°æ® | æˆæƒç”¨æˆ· | å¯é€‰ | ä¸­ |
| **æœºå¯†ï¼ˆConfidentialï¼‰** | æœºå¯†æ•°æ® | ç‰¹å®šè§’è‰² | æ˜¯ | é«˜ |
| **å—é™ï¼ˆRestrictedï¼‰** | å—é™æ•°æ® | ç®¡ç†å‘˜ | æ˜¯ | æœ€é«˜ |

**å®ç°æ–¹æ¡ˆ**ï¼š

```sql
-- 1. åˆ›å»ºæ•°æ®åˆ†ç±»è¡¨
CREATE TABLE data_classification (
    table_name TEXT PRIMARY KEY,
    classification TEXT CHECK (classification IN ('public', 'internal', 'confidential', 'restricted')),
    owner TEXT,
    retention_period INTERVAL
);

-- 2. æ’å…¥åˆ†ç±»ä¿¡æ¯
INSERT INTO data_classification VALUES
('account_data', 'restricted', 'finance_team', INTERVAL '7 years'),
('user_profiles', 'confidential', 'data_team', INTERVAL '5 years'),
('public_content', 'public', 'content_team', INTERVAL '1 year');

-- 3. è‡ªåŠ¨åˆ†ç±»å‡½æ•°
CREATE OR REPLACE FUNCTION get_data_classification(table_name TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN (
        SELECT classification
        FROM data_classification
        WHERE data_classification.table_name = get_data_classification.table_name
    );
END;
$$ LANGUAGE plpgsql;
```

### 5.2 æ•°æ®æ ‡è®°ä¸æ ‡ç­¾

**æ•°æ®æ ‡ç­¾ç³»ç»Ÿ**ï¼š

```sql
-- 1. åˆ›å»ºæ ‡ç­¾è¡¨
CREATE TABLE data_tags (
    table_name TEXT,
    column_name TEXT,
    tag_name TEXT,
    tag_value TEXT,
    PRIMARY KEY (table_name, column_name, tag_name)
);

-- 2. æ’å…¥æ ‡ç­¾
INSERT INTO data_tags VALUES
('account_data', 'account_number', 'pii', 'true'),
('account_data', 'account_number', 'encryption', 'required'),
('account_data', 'balance', 'sensitive', 'true');

-- 3. æŸ¥è¯¢æ ‡ç­¾
SELECT * FROM data_tags
WHERE table_name = 'account_data' AND tag_name = 'pii';
```

---

## 6. æ•°æ®è´¨é‡ä¿è¯

### 6.1 æ•°æ®éªŒè¯è§„åˆ™

**éªŒè¯è§„åˆ™å®ç°**ï¼š

```sql
-- 1. åˆ›å»ºéªŒè¯è§„åˆ™è¡¨
CREATE TABLE data_validation_rules (
    table_name TEXT,
    column_name TEXT,
    rule_type TEXT,
    rule_expression TEXT,
    error_message TEXT
);

-- 2. æ’å…¥éªŒè¯è§„åˆ™
INSERT INTO data_validation_rules VALUES
('account_data', 'balance', 'range', 'balance >= 0 AND balance <= 100000000', 'ä½™é¢å¿…é¡»åœ¨0åˆ°1äº¿ä¹‹é—´'),
('account_data', 'account_number', 'format', 'account_number ~ ''^[0-9]{10}$''', 'è´¦æˆ·å·å¿…é¡»æ˜¯10ä½æ•°å­—');

-- 3. éªŒè¯å‡½æ•°
CREATE OR REPLACE FUNCTION validate_data(
    p_table_name TEXT,
    p_column_name TEXT,
    p_value TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    rule_expr TEXT;
BEGIN
    SELECT rule_expression INTO rule_expr
    FROM data_validation_rules
    WHERE table_name = p_table_name
      AND column_name = p_column_name;

    IF rule_expr IS NULL THEN
        RETURN true;  -- æ— è§„åˆ™ï¼ŒéªŒè¯é€šè¿‡
    END IF;

    -- æ‰§è¡ŒéªŒè¯ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    RETURN true;  -- å®é™…å®ç°éœ€è¦åŠ¨æ€SQL
END;
$$ LANGUAGE plpgsql;
```

### 6.2 æ•°æ®è´¨é‡ç›‘æ§

**è´¨é‡ç›‘æ§è„šæœ¬**ï¼š

```sql
-- 1. åˆ›å»ºè´¨é‡ç›‘æ§è§†å›¾
CREATE VIEW data_quality_metrics AS
SELECT
    schemaname,
    tablename,
    n_live_tup AS row_count,
    n_dead_tup AS dead_rows,
    CASE
        WHEN n_live_tup > 0 THEN
            ROUND(n_dead_tup::numeric / n_live_tup * 100, 2)
        ELSE 0
    END AS dead_row_percentage,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
ORDER BY dead_row_percentage DESC;

-- 2. æŸ¥è¯¢è´¨é‡æŒ‡æ ‡
SELECT * FROM data_quality_metrics
WHERE dead_row_percentage > 10;  -- æ­»è¡Œæ¯”ä¾‹è¶…è¿‡10%
```

---

## 7. æ•°æ®è®¿é—®å®¡è®¡

### 7.1 å®¡è®¡æ—¥å¿—å¢å¼º

**å¢å¼ºå®¡è®¡æ—¥å¿—**ï¼š

```sql
-- 1. åˆ›å»ºå¢å¼ºå®¡è®¡è¡¨
CREATE TABLE enhanced_audit_log (
    id BIGSERIAL PRIMARY KEY,
    event_time TIMESTAMPTZ DEFAULT NOW(),
    user_name TEXT,
    database_name TEXT,
    schema_name TEXT,
    table_name TEXT,
    operation TEXT,
    ip_address INET,
    application_name TEXT,
    query_text TEXT,
    old_data JSONB,
    new_data JSONB,
    execution_time INTERVAL,
    rows_affected INTEGER
);

-- 2. å¢å¼ºå®¡è®¡è§¦å‘å™¨
CREATE OR REPLACE FUNCTION enhanced_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO enhanced_audit_log (
        user_name,
        database_name,
        schema_name,
        table_name,
        operation,
        ip_address,
        application_name,
        query_text,
        old_data,
        new_data
    )
    VALUES (
        current_user,
        current_database(),
        current_schema(),
        TG_TABLE_NAME,
        TG_OP,
        inet_client_addr(),
        current_setting('application_name'),
        current_query(),
        row_to_json(OLD)::JSONB,
        row_to_json(NEW)::JSONB
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. åº”ç”¨å®¡è®¡è§¦å‘å™¨
CREATE TRIGGER account_data_enhanced_audit
    AFTER INSERT OR UPDATE OR DELETE ON account_data
    FOR EACH ROW EXECUTE FUNCTION enhanced_audit_trigger();
```

### 7.2 å®¡è®¡æ—¥å¿—åˆ†æ

**å®¡è®¡åˆ†ææŸ¥è¯¢**ï¼š

```sql
-- 1. æŸ¥è¯¢è®¿é—®ç»Ÿè®¡
SELECT
    user_name,
    table_name,
    operation,
    COUNT(*) AS operation_count,
    MIN(event_time) AS first_access,
    MAX(event_time) AS last_access
FROM enhanced_audit_log
WHERE event_time >= NOW() - INTERVAL '30 days'
GROUP BY user_name, table_name, operation
ORDER BY operation_count DESC;

-- 2. æŸ¥è¯¢å¼‚å¸¸è®¿é—®
SELECT *
FROM enhanced_audit_log
WHERE event_time >= NOW() - INTERVAL '24 hours'
  AND (
      operation = 'DELETE'  -- åˆ é™¤æ“ä½œ
      OR rows_affected > 10000  -- å¤§é‡æ•°æ®æ“ä½œ
      OR execution_time > INTERVAL '10 seconds'  -- é•¿æ—¶é—´æ“ä½œ
  )
ORDER BY event_time DESC;
```

---

## 8. å¸¸è§é—®é¢˜ï¼ˆFAQï¼‰

### 8.1 æ•°æ®æ²»ç†åŸºç¡€å¸¸è§é—®é¢˜

#### Q1: å¦‚ä½•å®æ–½æ•°æ®åˆ†ç±»ï¼Ÿ

**å®æ–½æ­¥éª¤**ï¼š

1. **æ•°æ®ç›˜ç‚¹**ï¼š

    ```sql
    -- åˆ—å‡ºæ‰€æœ‰è¡¨
    SELECT schemaname, tablename
    FROM pg_tables
    WHERE schemaname = 'public'
    ORDER BY tablename;
    ```

2. **åˆ†ç±»æ ‡è®°**ï¼š

    ```sql
    -- æ’å…¥åˆ†ç±»ä¿¡æ¯
    INSERT INTO data_classification VALUES
    ('account_data', 'restricted', 'finance_team', INTERVAL '7 years');
    ```

3. **åº”ç”¨è®¿é—®æ§åˆ¶**ï¼š

    ```sql
    -- å¯ç”¨è¡Œçº§å®‰å…¨
    ALTER TABLE account_data ENABLE ROW LEVEL SECURITY;
    ```

#### Q2: å¦‚ä½•ä¿è¯æ•°æ®è´¨é‡ï¼Ÿ

**è´¨é‡ä¿è¯æ–¹æ¡ˆ**ï¼š

1. **æ•°æ®éªŒè¯**ï¼š

    ```sql
    -- ä½¿ç”¨CHECKçº¦æŸ
    ALTER TABLE account_data
    ADD CONSTRAINT check_balance_range
    CHECK (balance >= 0 AND balance <= 100000000);
    ```

2. **å®šæœŸæ£€æŸ¥**ï¼š

    ```sql
    -- ä½¿ç”¨æ•°æ®è´¨é‡ç›‘æ§
    SELECT * FROM data_quality_metrics
    WHERE dead_row_percentage > 10;
    ```

3. **æ•°æ®æ¸…ç†**ï¼š

    ```sql
    -- æ¸…ç†æ— æ•ˆæ•°æ®
    DELETE FROM account_data
    WHERE account_number IS NULL OR account_number = '';
    ```

### 8.2 æ•°æ®å®‰å…¨å¸¸è§é—®é¢˜

#### Q3: å¦‚ä½•å®ç°æ•°æ®åŠ å¯†ï¼Ÿ

**åŠ å¯†æ–¹æ¡ˆ**ï¼š

1. **åˆ—çº§åŠ å¯†**ï¼š

    ```sql
    -- ä½¿ç”¨pgcryptoæ‰©å±•
    CREATE EXTENSION pgcrypto;

    -- åŠ å¯†æ•°æ®
    UPDATE account_data
    SET encrypted_account_number = pgp_sym_encrypt(account_number, 'encryption_key');

    -- è§£å¯†æ•°æ®
    SELECT pgp_sym_decrypt(encrypted_account_number, 'encryption_key')
    FROM account_data;
    ```

2. **é€æ˜æ•°æ®åŠ å¯†ï¼ˆTDEï¼‰**ï¼š

    ```sql
    -- ä½¿ç”¨pg_tdeæ‰©å±•ï¼ˆPostgreSQL 18+ï¼‰
    CREATE EXTENSION pg_tde;

    -- åˆ›å»ºåŠ å¯†è¡¨ç©ºé—´
    CREATE TABLESPACE encrypted_tablespace
    LOCATION '/var/lib/postgresql/encrypted'
    WITH (encryption = 'on');
    ```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 19-05-04
