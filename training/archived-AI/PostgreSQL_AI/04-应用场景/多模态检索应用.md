# å¤šæ¨¡æ€æ£€ç´¢åº”ç”¨

> **æ–‡æ¡£ç¼–å·**: AI-04-06
> **æœ€åæ›´æ–°**: 2025å¹´1æœˆ
> **ä¸»é¢˜**: 04-åº”ç”¨åœºæ™¯
> **å­ä¸»é¢˜**: 06-å¤šæ¨¡æ€æ£€ç´¢åº”ç”¨

## ğŸ“‘ ç›®å½•

- [å¤šæ¨¡æ€æ£€ç´¢åº”ç”¨](#å¤šæ¨¡æ€æ£€ç´¢åº”ç”¨)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ¦‚è¿°](#ä¸€æ¦‚è¿°)
    - [1.1 å¤šæ¨¡æ€æ£€ç´¢æ€ç»´å¯¼å›¾](#11-å¤šæ¨¡æ€æ£€ç´¢æ€ç»´å¯¼å›¾)
  - [äºŒã€æ¶æ„è®¾è®¡](#äºŒæ¶æ„è®¾è®¡)
    - [2.1 ç³»ç»Ÿæ¶æ„](#21-ç³»ç»Ÿæ¶æ„)
    - [2.2 æ•°æ®æµ](#22-æ•°æ®æµ)
  - [ä¸‰ã€æ•°æ®æ¨¡å‹è®¾è®¡](#ä¸‰æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 å¤šæ¨¡æ€æ•°æ®è¡¨](#31-å¤šæ¨¡æ€æ•°æ®è¡¨)
    - [3.2 æ–‡æœ¬å‘é‡è¡¨](#32-æ–‡æœ¬å‘é‡è¡¨)
    - [3.3 å›¾åƒå‘é‡è¡¨](#33-å›¾åƒå‘é‡è¡¨)
  - [å››ã€æ ¸å¿ƒåŠŸèƒ½å®ç°](#å››æ ¸å¿ƒåŠŸèƒ½å®ç°)
    - [4.1 æ–‡æœ¬+å›¾åƒæ£€ç´¢](#41-æ–‡æœ¬å›¾åƒæ£€ç´¢)
    - [4.2 è·¨æ¨¡æ€ç›¸ä¼¼åº¦](#42-è·¨æ¨¡æ€ç›¸ä¼¼åº¦)
    - [4.3 ç»Ÿä¸€æŸ¥è¯¢æ¥å£](#43-ç»Ÿä¸€æŸ¥è¯¢æ¥å£)
    - [4.4 å¤šæ¨¡æ€èåˆ](#44-å¤šæ¨¡æ€èåˆ)
  - [äº”ã€æ€§èƒ½ä¼˜åŒ–](#äº”æ€§èƒ½ä¼˜åŒ–)
    - [5.1 å‘é‡ç´¢å¼•ä¼˜åŒ–](#51-å‘é‡ç´¢å¼•ä¼˜åŒ–)
    - [5.2 æŸ¥è¯¢ä¼˜åŒ–](#52-æŸ¥è¯¢ä¼˜åŒ–)
    - [5.3 ç¼“å­˜ç­–ç•¥](#53-ç¼“å­˜ç­–ç•¥)
  - [å…­ã€æœ€ä½³å®è·µ](#å…­æœ€ä½³å®è·µ)
  - [ä¸ƒã€å…³è”ä¸»é¢˜](#ä¸ƒå…³è”ä¸»é¢˜)
  - [å…«ã€å¯¹æ ‡èµ„æº](#å…«å¯¹æ ‡èµ„æº)
    - [æŠ€æœ¯æ–‡æ¡£](#æŠ€æœ¯æ–‡æ¡£)
    - [ä¼ä¸šæ¡ˆä¾‹](#ä¼ä¸šæ¡ˆä¾‹)

## ä¸€ã€æ¦‚è¿°

åŸºäºPostgreSQLçš„å¤šæ¨¡æ€æ£€ç´¢åº”ç”¨ï¼Œæ”¯æŒæ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘ç­‰å¤šç§æ•°æ®ç±»å‹çš„ç»Ÿä¸€å­˜å‚¨å’Œæ£€ç´¢ï¼Œé€šè¿‡å‘é‡ç›¸ä¼¼åº¦å®ç°è·¨æ¨¡æ€æœç´¢ï¼Œæ»¡è¶³"ä»¥å›¾æœå›¾"ã€"ä»¥æ–‡æœå›¾"ç­‰å¤æ‚æ£€ç´¢éœ€æ±‚ã€‚

### 1.1 å¤šæ¨¡æ€æ£€ç´¢æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((å¤šæ¨¡æ€æ£€ç´¢åº”ç”¨))
    æ•°æ®ç±»å‹
      æ–‡æœ¬
        æ–‡æ¡£
        å¯¹è¯
      å›¾åƒ
        å›¾ç‰‡
        è§†é¢‘å¸§
      éŸ³é¢‘
        è¯­éŸ³
        éŸ³ä¹
    æ£€ç´¢èƒ½åŠ›
      æ–‡æœ¬æ£€ç´¢
        è¯­ä¹‰æ£€ç´¢
        å…³é”®è¯æ£€ç´¢
      å›¾åƒæ£€ç´¢
        ä»¥å›¾æœå›¾
        ä»¥æ–‡æœå›¾
      è·¨æ¨¡æ€æ£€ç´¢
        æ–‡æœ¬-å›¾åƒ
        å›¾åƒ-æ–‡æœ¬
    æŠ€æœ¯æ¶æ„
      PostgreSQL
        pgvector
        å¤šå‘é‡åˆ—
      æ•°æ®æ¨¡å‹
        æ–‡æœ¬å‘é‡è¡¨
        å›¾åƒå‘é‡è¡¨
        ç»Ÿä¸€ç´¢å¼•
    æ€§èƒ½ä¼˜åŒ–
      å‘é‡ç´¢å¼•ä¼˜åŒ–
        HNSWç´¢å¼•
        å¤šç´¢å¼•ç­–ç•¥
      æŸ¥è¯¢ä¼˜åŒ–
        è·¨æ¨¡æ€èåˆ
        ç»“æœæ’åº
```

## äºŒã€æ¶æ„è®¾è®¡

### 2.1 ç³»ç»Ÿæ¶æ„

```mermaid
graph TD
    A[ç”¨æˆ·æŸ¥è¯¢] --> B{æŸ¥è¯¢ç±»å‹}
    B -->|æ–‡æœ¬| C[æ–‡æœ¬å‘é‡åŒ–]
    B -->|å›¾åƒ| D[å›¾åƒå‘é‡åŒ–]
    B -->|æ··åˆ| E[å¤šæ¨¡æ€å‘é‡åŒ–]

    C --> F[PostgreSQL]
    D --> F
    E --> F

    F --> G[æ–‡æœ¬å‘é‡ç´¢å¼•]
    F --> H[å›¾åƒå‘é‡ç´¢å¼•]

    G --> I[è·¨æ¨¡æ€æ£€ç´¢]
    H --> I
    I --> J[ç»“æœèåˆ]
    J --> K[è¿”å›ç»“æœ]
```

### 2.2 æ•°æ®æµ

1. **æ•°æ®æ³¨å…¥æµ**:
   - å¤šæ¨¡æ€æ•°æ® â†’ åˆ†åˆ«å‘é‡åŒ– â†’ å­˜å‚¨åˆ°PostgreSQL

2. **æ£€ç´¢æµ**:
   - æŸ¥è¯¢è¾“å…¥ â†’ å‘é‡åŒ– â†’ è·¨æ¨¡æ€æ£€ç´¢ â†’ ç»“æœèåˆ â†’ è¿”å›

## ä¸‰ã€æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 å¤šæ¨¡æ€æ•°æ®è¡¨

```sql
-- å¤šæ¨¡æ€æ•°æ®è¡¨
CREATE TABLE multimodal_data (
    id SERIAL PRIMARY KEY,
    title TEXT,
    text_content TEXT,
    image_url TEXT,
    audio_url TEXT,
    data_type TEXT,  -- 'text', 'image', 'audio', 'mixed'
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- æ–‡æœ¬å‘é‡è¡¨
CREATE TABLE text_embeddings (
    id SERIAL PRIMARY KEY,
    data_id INTEGER REFERENCES multimodal_data(id),
    text_vector vector(1536),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å›¾åƒå‘é‡è¡¨
CREATE TABLE image_embeddings (
    id SERIAL PRIMARY KEY,
    data_id INTEGER REFERENCES multimodal_data(id),
    image_vector vector(512),  -- CLIPæ¨¡å‹ç»´åº¦
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- å‘é‡ç´¢å¼•
CREATE INDEX ON text_embeddings
USING hnsw (text_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 100);

CREATE INDEX ON image_embeddings
USING hnsw (image_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 100);
```

### 3.2 æ–‡æœ¬å‘é‡è¡¨

```sql
-- æ–‡æœ¬å‘é‡ç”Ÿæˆ
CREATE OR REPLACE FUNCTION generate_text_embedding(
    p_data_id INTEGER,
    p_text TEXT
) RETURNS void AS $$
DECLARE
    v_text_vector vector(1536);
BEGIN
    -- ä½¿ç”¨OpenAIç”Ÿæˆæ–‡æœ¬å‘é‡
    v_text_vector := ai.embedding('text-embedding-3-small', p_text);

    -- å­˜å‚¨å‘é‡
    INSERT INTO text_embeddings (data_id, text_vector)
    VALUES (p_data_id, v_text_vector)
    ON CONFLICT (data_id) DO UPDATE
    SET text_vector = v_text_vector;
END;
$$ LANGUAGE plpgsql;
```

### 3.3 å›¾åƒå‘é‡è¡¨

```sql
-- å›¾åƒå‘é‡ç”Ÿæˆï¼ˆä½¿ç”¨å¤–éƒ¨æœåŠ¡ï¼‰
-- é€šè¿‡HTTP APIè°ƒç”¨å›¾åƒç¼–ç æ¨¡å‹
CREATE OR REPLACE FUNCTION generate_image_embedding(
    p_data_id INTEGER,
    p_image_url TEXT
) RETURNS void AS $$
DECLARE
    v_image_vector vector(512);
BEGIN
    -- è°ƒç”¨å›¾åƒç¼–ç APIï¼ˆå¦‚CLIPï¼‰
    -- è¿™é‡Œä½¿ç”¨pg_httpæ‰©å±•æˆ–å¤–éƒ¨å‡½æ•°
    v_image_vector := call_image_encoder_api(p_image_url);

    -- å­˜å‚¨å‘é‡
    INSERT INTO image_embeddings (data_id, image_vector)
    VALUES (p_data_id, v_image_vector)
    ON CONFLICT (data_id) DO UPDATE
    SET image_vector = v_image_vector;
END;
$$ LANGUAGE plpgsql;
```

## å››ã€æ ¸å¿ƒåŠŸèƒ½å®ç°

### 4.1 æ–‡æœ¬+å›¾åƒæ£€ç´¢

```sql
-- æ–‡æœ¬æ£€ç´¢å›¾åƒ
CREATE OR REPLACE FUNCTION text_to_image_search(
    p_query_text TEXT,
    p_limit INTEGER DEFAULT 10
) RETURNS TABLE (
    data_id INTEGER,
    image_url TEXT,
    similarity DECIMAL
) AS $$
DECLARE
    v_text_vector vector(1536);
    v_image_vector vector(512);
BEGIN
    -- ç”ŸæˆæŸ¥è¯¢æ–‡æœ¬å‘é‡
    v_text_vector := ai.embedding('text-embedding-3-small', p_query_text);

    -- ä½¿ç”¨è·¨æ¨¡æ€æ¨¡å‹å°†æ–‡æœ¬å‘é‡æ˜ å°„åˆ°å›¾åƒç©ºé—´
    -- è¿™é‡Œå‡è®¾æœ‰è·¨æ¨¡æ€æ˜ å°„å‡½æ•°
    v_image_vector := cross_modal_map(v_text_vector);

    -- æ£€ç´¢ç›¸ä¼¼å›¾åƒ
    RETURN QUERY
    SELECT
        ie.data_id,
        md.image_url,
        (1 - (ie.image_vector <=> v_image_vector))::DECIMAL(5,4) AS similarity
    FROM image_embeddings ie
    JOIN multimodal_data md ON ie.data_id = md.id
    WHERE ie.image_vector <=> v_image_vector < 0.8
    ORDER BY ie.image_vector <=> v_image_vector
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

### 4.2 è·¨æ¨¡æ€ç›¸ä¼¼åº¦

```sql
-- è®¡ç®—è·¨æ¨¡æ€ç›¸ä¼¼åº¦
CREATE OR REPLACE FUNCTION cross_modal_similarity(
    p_text_id INTEGER,
    p_image_id INTEGER
) RETURNS DECIMAL AS $$
DECLARE
    v_text_vector vector(1536);
    v_image_vector vector(512);
    v_mapped_vector vector(512);
BEGIN
    -- è·å–æ–‡æœ¬å‘é‡
    SELECT text_vector INTO v_text_vector
    FROM text_embeddings
    WHERE data_id = p_text_id;

    -- è·å–å›¾åƒå‘é‡
    SELECT image_vector INTO v_image_vector
    FROM image_embeddings
    WHERE data_id = p_image_id;

    -- æ˜ å°„æ–‡æœ¬å‘é‡åˆ°å›¾åƒç©ºé—´
    v_mapped_vector := cross_modal_map(v_text_vector);

    -- è®¡ç®—ç›¸ä¼¼åº¦
    RETURN (1 - (v_mapped_vector <=> v_image_vector))::DECIMAL(5,4);
END;
$$ LANGUAGE plpgsql;
```

### 4.3 ç»Ÿä¸€æŸ¥è¯¢æ¥å£

```sql
-- ç»Ÿä¸€å¤šæ¨¡æ€æŸ¥è¯¢æ¥å£
CREATE OR REPLACE FUNCTION multimodal_search(
    p_query_text TEXT DEFAULT NULL,
    p_query_image_url TEXT DEFAULT NULL,
    p_query_type TEXT DEFAULT 'text',  -- 'text', 'image', 'both'
    p_limit INTEGER DEFAULT 10
) RETURNS TABLE (
    data_id INTEGER,
    title TEXT,
    data_type TEXT,
    similarity DECIMAL,
    match_type TEXT  -- 'text', 'image', 'both'
) AS $$
DECLARE
    v_text_vector vector(1536);
    v_image_vector vector(512);
BEGIN
    -- å¤„ç†æ–‡æœ¬æŸ¥è¯¢
    IF p_query_text IS NOT NULL THEN
        v_text_vector := ai.embedding('text-embedding-3-small', p_query_text);
    END IF;

    -- å¤„ç†å›¾åƒæŸ¥è¯¢
    IF p_query_image_url IS NOT NULL THEN
        v_image_vector := call_image_encoder_api(p_query_image_url);
    END IF;

    -- å¤šæ¨¡æ€æ£€ç´¢
    RETURN QUERY
    WITH text_results AS (
        SELECT
            te.data_id,
            md.title,
            md.data_type,
            (1 - (te.text_vector <=> v_text_vector))::DECIMAL(5,4) AS similarity,
            'text'::TEXT AS match_type
        FROM text_embeddings te
        JOIN multimodal_data md ON te.data_id = md.id
        WHERE p_query_text IS NOT NULL
          AND te.text_vector <=> v_text_vector < 0.8
    ),
    image_results AS (
        SELECT
            ie.data_id,
            md.title,
            md.data_type,
            (1 - (ie.image_vector <=> v_image_vector))::DECIMAL(5,4) AS similarity,
            'image'::TEXT AS match_type
        FROM image_embeddings ie
        JOIN multimodal_data md ON ie.data_id = md.id
        WHERE p_query_image_url IS NOT NULL
          AND ie.image_vector <=> v_image_vector < 0.8
    )
    SELECT
        COALESCE(tr.data_id, ir.data_id) AS data_id,
        COALESCE(tr.title, ir.title) AS title,
        COALESCE(tr.data_type, ir.data_type) AS data_type,
        COALESCE(tr.similarity, 0) * 0.5 + COALESCE(ir.similarity, 0) * 0.5 AS similarity,
        CASE
            WHEN tr.data_id IS NOT NULL AND ir.data_id IS NOT NULL THEN 'both'
            WHEN tr.data_id IS NOT NULL THEN 'text'
            WHEN ir.data_id IS NOT NULL THEN 'image'
        END AS match_type
    FROM text_results tr
    FULL OUTER JOIN image_results ir ON tr.data_id = ir.data_id
    ORDER BY similarity DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

### 4.4 å¤šæ¨¡æ€èåˆ

```sql
-- å¤šæ¨¡æ€ç»“æœèåˆï¼ˆRRFç®—æ³•ï¼‰
CREATE OR REPLACE FUNCTION multimodal_fusion(
    p_text_results JSONB,
    p_image_results JSONB,
    p_k INTEGER DEFAULT 60
) RETURNS JSONB AS $$
DECLARE
    v_fused_results JSONB;
BEGIN
    -- ä½¿ç”¨Reciprocal Rank Fusionèåˆç»“æœ
    SELECT jsonb_agg(
        jsonb_build_object(
            'data_id', data_id,
            'title', title,
            'rrf_score', rrf_score
        ) ORDER BY rrf_score DESC
    ) INTO v_fused_results
    FROM (
        SELECT
            COALESCE(tr.data_id, ir.data_id) AS data_id,
            COALESCE(tr.title, ir.title) AS title,
            (
                COALESCE(1.0 / (p_k + tr.rank), 0) +
                COALESCE(1.0 / (p_k + ir.rank), 0)
            ) AS rrf_score
        FROM (
            SELECT
                (value->>'data_id')::INTEGER AS data_id,
                value->>'title' AS title,
                ROW_NUMBER() OVER (ORDER BY (value->>'similarity')::DECIMAL DESC) AS rank
            FROM jsonb_array_elements(p_text_results)
        ) tr
        FULL OUTER JOIN (
            SELECT
                (value->>'data_id')::INTEGER AS data_id,
                value->>'title' AS title,
                ROW_NUMBER() OVER (ORDER BY (value->>'similarity')::DECIMAL DESC) AS rank
            FROM jsonb_array_elements(p_image_results)
        ) ir ON tr.data_id = ir.data_id
    ) fused
    ORDER BY rrf_score DESC
    LIMIT 20;

    RETURN v_fused_results;
END;
$$ LANGUAGE plpgsql;
```

## äº”ã€æ€§èƒ½ä¼˜åŒ–

### 5.1 å‘é‡ç´¢å¼•ä¼˜åŒ–

```sql
-- ä¸ºä¸åŒæ¨¡æ€ä½¿ç”¨ä¸åŒç´¢å¼•å‚æ•°
-- æ–‡æœ¬å‘é‡ç´¢å¼•ï¼ˆé«˜ç»´ï¼‰
CREATE INDEX ON text_embeddings
USING hnsw (text_vector vector_cosine_ops)
WITH (m = 32, ef_construction = 200);

-- å›¾åƒå‘é‡ç´¢å¼•ï¼ˆä½ç»´ï¼‰
CREATE INDEX ON image_embeddings
USING hnsw (image_vector vector_cosine_ops)
WITH (m = 16, ef_construction = 100);

-- æŸ¥è¯¢æ—¶ä¼˜åŒ–
SET hnsw.ef_search = 200;  -- æå‡å¬å›ç‡
```

### 5.2 æŸ¥è¯¢ä¼˜åŒ–

```sql
-- ä½¿ç”¨ç‰©åŒ–è§†å›¾é¢„è®¡ç®—è·¨æ¨¡æ€æ˜ å°„
CREATE MATERIALIZED VIEW cross_modal_mapping AS
SELECT
    te.data_id,
    te.text_vector,
    cross_modal_map(te.text_vector) AS mapped_image_vector
FROM text_embeddings te;

CREATE INDEX ON cross_modal_mapping
USING hnsw (mapped_image_vector vector_cosine_ops);

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY cross_modal_mapping;
```

### 5.3 ç¼“å­˜ç­–ç•¥

```sql
-- å¤šæ¨¡æ€æŸ¥è¯¢ç¼“å­˜
CREATE TABLE multimodal_cache (
    query_hash TEXT PRIMARY KEY,
    query_text TEXT,
    query_image_url TEXT,
    results JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '1 hour'
);

-- ä½¿ç”¨ç¼“å­˜
CREATE OR REPLACE FUNCTION cached_multimodal_search(
    p_query_text TEXT,
    p_query_image_url TEXT
) RETURNS JSONB AS $$
DECLARE
    v_cache_key TEXT;
    v_results JSONB;
BEGIN
    v_cache_key := md5(COALESCE(p_query_text, '') || COALESCE(p_query_image_url, ''));

    -- æ£€æŸ¥ç¼“å­˜
    SELECT results INTO v_results
    FROM multimodal_cache
    WHERE query_hash = v_cache_key
      AND expires_at > NOW();

    IF v_results IS NOT NULL THEN
        RETURN v_results;
    END IF;

    -- æ‰§è¡ŒæŸ¥è¯¢
    SELECT jsonb_agg(
        jsonb_build_object(
            'data_id', data_id,
            'title', title,
            'similarity', similarity
        )
    ) INTO v_results
    FROM multimodal_search(p_query_text, p_query_image_url);

    -- æ›´æ–°ç¼“å­˜
    INSERT INTO multimodal_cache (query_hash, query_text, query_image_url, results)
    VALUES (v_cache_key, p_query_text, p_query_image_url, v_results)
    ON CONFLICT (query_hash) DO UPDATE
    SET results = v_results,
        expires_at = NOW() + INTERVAL '1 hour';

    RETURN v_results;
END;
$$ LANGUAGE plpgsql;
```

## å…­ã€æœ€ä½³å®è·µ

1. **å‘é‡ç»´åº¦é€‰æ‹©**:
   - æ–‡æœ¬ï¼šä½¿ç”¨1536ç»´ï¼ˆOpenAI text-embedding-3-smallï¼‰
   - å›¾åƒï¼šä½¿ç”¨512ç»´ï¼ˆCLIPæ¨¡å‹ï¼‰
   - éŸ³é¢‘ï¼šä½¿ç”¨128ç»´ï¼ˆéŸ³é¢‘ç¼–ç æ¨¡å‹ï¼‰

2. **è·¨æ¨¡æ€æ˜ å°„**:
   - ä½¿ç”¨é¢„è®­ç»ƒçš„è·¨æ¨¡æ€æ¨¡å‹
   - å®šæœŸæ›´æ–°æ˜ å°„å…³ç³»
   - ä½¿ç”¨ç‰©åŒ–è§†å›¾åŠ é€ŸæŸ¥è¯¢

3. **ç»“æœèåˆ**:
   - ä½¿ç”¨RRFç®—æ³•èåˆå¤šæ¨¡æ€ç»“æœ
   - æ ¹æ®ä¸šåŠ¡éœ€æ±‚è°ƒæ•´æƒé‡
   - è€ƒè™‘æ¨¡æ€ç›¸å…³æ€§

4. **æ€§èƒ½ä¼˜åŒ–**:
   - ä¸ºä¸åŒæ¨¡æ€ä½¿ç”¨ä¸åŒç´¢å¼•å‚æ•°
   - ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è®¡ç®—
   - é¢„è®¡ç®—è·¨æ¨¡æ€æ˜ å°„

## ä¸ƒã€å…³è”ä¸»é¢˜

- [æ··åˆæŸ¥è¯¢èƒ½åŠ›](../03-æ ¸å¿ƒèƒ½åŠ›/æ··åˆæŸ¥è¯¢èƒ½åŠ›.md) - æ··åˆæŸ¥è¯¢æŠ€æœ¯
- [å‘é‡å¤„ç†èƒ½åŠ› (pgvector)](../03-æ ¸å¿ƒèƒ½åŠ›/å‘é‡å¤„ç†èƒ½åŠ›-pgvector.md) - å‘é‡æ£€ç´¢åŸºç¡€
- [æ™ºèƒ½æ¨èç³»ç»Ÿ](./æ™ºèƒ½æ¨èç³»ç»Ÿ.md) - å¤šæ¨¡æ€æ¨èåº”ç”¨

## å…«ã€å¯¹æ ‡èµ„æº

### æŠ€æœ¯æ–‡æ¡£

- [CLIPæ¨¡å‹æ–‡æ¡£](https://openai.com/research/clip)
- [å¤šæ¨¡æ€æ£€ç´¢ç ”ç©¶](https://arxiv.org/abs/2103.00020)

### ä¼ä¸šæ¡ˆä¾‹

- **Google**: å¤šæ¨¡æ€æœç´¢åº”ç”¨
- **æ€§èƒ½**: è·¨æ¨¡æ€æ£€ç´¢å‡†ç¡®ç‡>90%

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: AI-04-06
