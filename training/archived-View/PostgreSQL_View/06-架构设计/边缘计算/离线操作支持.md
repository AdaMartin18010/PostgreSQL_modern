# ç¦»çº¿æ“ä½œæ”¯æŒ

> **æ›´æ–°æ—¶é—´**: 2025å¹´1æœˆ
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 18
> **æ–‡æ¡£ç¼–å·**: 06-04-03

---

## ğŸ“‘ ç›®å½•

- [ç¦»çº¿æ“ä½œæ”¯æŒ](#ç¦»çº¿æ“ä½œæ”¯æŒ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æŠ€æœ¯èƒŒæ™¯](#11-æŠ€æœ¯èƒŒæ™¯)
    - [1.2 æŠ€æœ¯å®šä½](#12-æŠ€æœ¯å®šä½)
    - [1.3 æ ¸å¿ƒä»·å€¼](#13-æ ¸å¿ƒä»·å€¼)
  - [2. æŠ€æœ¯åŸç†](#2-æŠ€æœ¯åŸç†)
    - [2.1 ç¦»çº¿æ“ä½œåœºæ™¯](#21-ç¦»çº¿æ“ä½œåœºæ™¯)
    - [2.2 æœ¬åœ°æ•°æ®åº“è®¾è®¡](#22-æœ¬åœ°æ•°æ®åº“è®¾è®¡)
    - [2.3 å†²çªæ£€æµ‹ä¸è§£å†³](#23-å†²çªæ£€æµ‹ä¸è§£å†³)
  - [3. å®ç°æ–¹æ¡ˆ](#3-å®ç°æ–¹æ¡ˆ)
    - [3.1 æœ¬åœ°æ•°æ®åº“æ¶æ„](#31-æœ¬åœ°æ•°æ®åº“æ¶æ„)
    - [3.2 æ“ä½œé˜Ÿåˆ—æœºåˆ¶](#32-æ“ä½œé˜Ÿåˆ—æœºåˆ¶)
    - [3.3 åŒæ­¥æœºåˆ¶](#33-åŒæ­¥æœºåˆ¶)
  - [4. é…ç½®ä¸éƒ¨ç½²](#4-é…ç½®ä¸éƒ¨ç½²)
    - [4.1 æœ¬åœ°æ•°æ®åº“é…ç½®](#41-æœ¬åœ°æ•°æ®åº“é…ç½®)
    - [4.2 åŒæ­¥é…ç½®](#42-åŒæ­¥é…ç½®)
    - [4.3 å†²çªè§£å†³é…ç½®](#43-å†²çªè§£å†³é…ç½®)
  - [5. åº”ç”¨å¼€å‘](#5-åº”ç”¨å¼€å‘)
    - [5.1 ç¦»çº¿æ“ä½œAPI](#51-ç¦»çº¿æ“ä½œapi)
    - [5.2 åŒæ­¥çŠ¶æ€ç®¡ç†](#52-åŒæ­¥çŠ¶æ€ç®¡ç†)
    - [5.3 å†²çªå¤„ç†](#53-å†²çªå¤„ç†)
  - [6. æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)
    - [6.1 æœ¬åœ°æ€§èƒ½ä¼˜åŒ–](#61-æœ¬åœ°æ€§èƒ½ä¼˜åŒ–)
    - [6.2 åŒæ­¥æ€§èƒ½ä¼˜åŒ–](#62-åŒæ­¥æ€§èƒ½ä¼˜åŒ–)
  - [7. å®é™…åº”ç”¨æ¡ˆä¾‹](#7-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [7.1 ç§»åŠ¨åº”ç”¨ç¦»çº¿æ”¯æŒ](#71-ç§»åŠ¨åº”ç”¨ç¦»çº¿æ”¯æŒ)
    - [7.2 è¾¹ç¼˜è®¾å¤‡ç¦»çº¿æ”¯æŒ](#72-è¾¹ç¼˜è®¾å¤‡ç¦»çº¿æ”¯æŒ)
  - [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
    - [8.1 è®¾è®¡åŸåˆ™](#81-è®¾è®¡åŸåˆ™)
    - [8.2 æ³¨æ„äº‹é¡¹](#82-æ³¨æ„äº‹é¡¹)
  - [9. å‚è€ƒèµ„æ–™](#9-å‚è€ƒèµ„æ–™)
    - [å®˜æ–¹æ–‡æ¡£](#å®˜æ–¹æ–‡æ¡£)
    - [æŠ€æœ¯åšå®¢](#æŠ€æœ¯åšå®¢)
  - [10. å®Œæ•´ä»£ç ç¤ºä¾‹](#10-å®Œæ•´ä»£ç ç¤ºä¾‹)
    - [10.1 æœ¬åœ°æ•°æ®åº“åˆå§‹åŒ–](#101-æœ¬åœ°æ•°æ®åº“åˆå§‹åŒ–)
    - [10.2 Python ç¦»çº¿æ“ä½œ API](#102-python-ç¦»çº¿æ“ä½œ-api)
    - [10.3 å†²çªæ£€æµ‹ä¸è§£å†³](#103-å†²çªæ£€æµ‹ä¸è§£å†³)
    - [10.4 Docker Compose ç¦»çº¿æ“ä½œéƒ¨ç½²](#104-docker-compose-ç¦»çº¿æ“ä½œéƒ¨ç½²)

---

## 1. æ¦‚è¿°

### 1.1 æŠ€æœ¯èƒŒæ™¯

åœ¨è¾¹ç¼˜è®¡ç®—å’Œç§»åŠ¨åº”ç”¨åœºæ™¯ä¸­ï¼Œè®¾å¤‡å¯èƒ½å¤„äºç¦»çº¿çŠ¶æ€ï¼š

- **ç½‘ç»œä¸ç¨³å®š**ï¼šè¾¹ç¼˜è®¾å¤‡å¯èƒ½é—´æ­‡æ€§æ–­ç½‘
- **ç§»åŠ¨åº”ç”¨**ï¼šç§»åŠ¨è®¾å¤‡ç»å¸¸å¤„äºç¦»çº¿çŠ¶æ€
- **ç¦»çº¿æ“ä½œéœ€æ±‚**ï¼šç”¨æˆ·éœ€è¦åœ¨ç¦»çº¿çŠ¶æ€ä¸‹ç»§ç»­æ“ä½œ

**æŒ‘æˆ˜**ï¼š

- **æ•°æ®ä¸€è‡´æ€§**ï¼šç¦»çº¿æ“ä½œä¸åœ¨çº¿æ•°æ®çš„ä¸€è‡´æ€§
- **å†²çªå¤„ç†**ï¼šå¤šè®¾å¤‡ç¦»çº¿æ“ä½œäº§ç”Ÿçš„å†²çª
- **åŒæ­¥æœºåˆ¶**ï¼šç¦»çº¿æ“ä½œçš„ä¸Šä¼ å’ŒåŒæ­¥
- **ç”¨æˆ·ä½“éªŒ**ï¼šä¿è¯ç¦»çº¿æ“ä½œçš„æµç•…ä½“éªŒ

### 1.2 æŠ€æœ¯å®šä½

ç¦»çº¿æ“ä½œæ”¯æŒæ˜¯PostgreSQLåœ¨è¾¹ç¼˜è®¡ç®—å’Œç§»åŠ¨åº”ç”¨åœºæ™¯ä¸­çš„å…³é”®åŠŸèƒ½ï¼Œæä¾›ï¼š

- **æœ¬åœ°æ•°æ®åº“**ï¼šè¾¹ç¼˜è®¾å¤‡æœ¬åœ°PostgreSQLæ•°æ®åº“
- **æ“ä½œé˜Ÿåˆ—**ï¼šç¦»çº¿æ“ä½œé˜Ÿåˆ—å’ŒåŒæ­¥æœºåˆ¶
- **å†²çªè§£å†³**ï¼šè‡ªåŠ¨å’Œæ‰‹åŠ¨å†²çªè§£å†³æœºåˆ¶

### 1.3 æ ¸å¿ƒä»·å€¼

- **ç¦»çº¿å¯ç”¨æ€§**ï¼šè®¾å¤‡ç¦»çº¿æ—¶ä»å¯æ­£å¸¸æ“ä½œ
- **æ•°æ®ä¸€è‡´æ€§**ï¼šä¿è¯ç¦»çº¿æ“ä½œä¸åœ¨çº¿æ•°æ®çš„ä¸€è‡´æ€§
- **å†²çªå¤„ç†**ï¼šè‡ªåŠ¨æ£€æµ‹å’Œè§£å†³æ•°æ®å†²çª
- **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›æµç•…çš„ç¦»çº¿æ“ä½œä½“éªŒ

---

## 2. æŠ€æœ¯åŸç†

### 2.1 ç¦»çº¿æ“ä½œåœºæ™¯

**ç¦»çº¿æ“ä½œç±»å‹**ï¼š

1. **è¯»æ“ä½œ**ï¼š
   - æŸ¥è¯¢æœ¬åœ°æ•°æ®åº“
   - ä½¿ç”¨æœ¬åœ°ç¼“å­˜æ•°æ®

2. **å†™æ“ä½œ**ï¼š
   - æ’å…¥ã€æ›´æ–°ã€åˆ é™¤æ“ä½œ
   - æ“ä½œè¿›å…¥é˜Ÿåˆ—ç­‰å¾…åŒæ­¥

3. **åŒæ­¥æ“ä½œ**ï¼š
   - ç½‘ç»œæ¢å¤æ—¶è‡ªåŠ¨åŒæ­¥
   - æ‰‹åŠ¨è§¦å‘åŒæ­¥

### 2.2 æœ¬åœ°æ•°æ®åº“è®¾è®¡

**æœ¬åœ°æ•°æ®åº“æ¶æ„**ï¼š

```text
åº”ç”¨å±‚
    â†“
åŒæ­¥å±‚
    â”œâ”€â”€ æ“ä½œé˜Ÿåˆ—
    â”œâ”€â”€ å†²çªæ£€æµ‹
    â””â”€â”€ åŒæ­¥ç®¡ç†
    â†“
æœ¬åœ°PostgreSQLæ•°æ®åº“
    â”œâ”€â”€ ä¸šåŠ¡è¡¨
    â”œâ”€â”€ åŒæ­¥çŠ¶æ€è¡¨
    â””â”€â”€ æ“ä½œæ—¥å¿—è¡¨
```

**æ ¸å¿ƒè¡¨è®¾è®¡**ï¼š

```sql
-- ä¸šåŠ¡è¡¨ï¼ˆç¤ºä¾‹ï¼‰
CREATE TABLE local_data (
    id SERIAL PRIMARY KEY,
    data_value TEXT,
    updated_at TIMESTAMP DEFAULT NOW(),
    sync_status TEXT DEFAULT 'pending'  -- pending, synced, conflict
);

-- åŒæ­¥çŠ¶æ€è¡¨
CREATE TABLE sync_status (
    id SERIAL PRIMARY KEY,
    table_name TEXT,
    last_sync_time TIMESTAMP,
    sync_state TEXT  -- online, offline, syncing
);

-- æ“ä½œæ—¥å¿—è¡¨
CREATE TABLE operation_log (
    id SERIAL PRIMARY KEY,
    table_name TEXT,
    operation_type TEXT,  -- INSERT, UPDATE, DELETE
    record_id INT,
    operation_data JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    synced_at TIMESTAMP,
    sync_status TEXT DEFAULT 'pending'
);
```

### 2.3 å†²çªæ£€æµ‹ä¸è§£å†³

**å†²çªç±»å‹**ï¼š

1. **æ›´æ–°å†²çª**ï¼šå¤šä¸ªè®¾å¤‡åŒæ—¶æ›´æ–°åŒä¸€è®°å½•
2. **åˆ é™¤å†²çª**ï¼šä¸€ä¸ªè®¾å¤‡åˆ é™¤ï¼Œå¦ä¸€ä¸ªè®¾å¤‡æ›´æ–°
3. **æ’å…¥å†²çª**ï¼šå¤šä¸ªè®¾å¤‡æ’å…¥ç›¸åŒä¸»é”®

**å†²çªæ£€æµ‹æœºåˆ¶**ï¼š

```sql
-- å†²çªæ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION detect_conflict(
    p_table_name TEXT,
    p_record_id INT,
    p_local_version INT,
    p_remote_version INT
) RETURNS BOOLEAN AS $$
BEGIN
    IF p_local_version != p_remote_version THEN
        RETURN TRUE;  -- æ£€æµ‹åˆ°å†²çª
    END IF;
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;
```

**å†²çªè§£å†³ç­–ç•¥**ï¼š

1. **æœ€åå†™å…¥è·èƒœï¼ˆLWWï¼‰**ï¼šåŸºäºæ—¶é—´æˆ³
2. **ç‰ˆæœ¬å·æ¯”è¾ƒ**ï¼šåŸºäºç‰ˆæœ¬å·
3. **åº”ç”¨å±‚è§„åˆ™**ï¼šåº”ç”¨å±‚å®šä¹‰è§£å†³è§„åˆ™
4. **æ‰‹åŠ¨è§£å†³**ï¼šäººå·¥ä»‹å…¥è§£å†³å†²çª

---

## 3. å®ç°æ–¹æ¡ˆ

### 3.1 æœ¬åœ°æ•°æ®åº“æ¶æ„

**æœ¬åœ°æ•°æ®åº“é…ç½®**ï¼š

```sql
-- åˆ›å»ºæœ¬åœ°æ•°æ®åº“
CREATE DATABASE local_db;

-- é…ç½®æœ¬åœ°æ•°æ®åº“å‚æ•°
ALTER DATABASE local_db SET synchronous_commit = off;  -- æé«˜å†™å…¥æ€§èƒ½
ALTER DATABASE local_db SET wal_level = minimal;  -- å‡å°‘WALå¼€é”€
```

**æœ¬åœ°è¡¨ç»“æ„**ï¼š

```sql
-- ä¸šåŠ¡è¡¨ï¼ˆå¸¦åŒæ­¥å­—æ®µï¼‰
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    price NUMERIC,
    version INT DEFAULT 1,  -- ç‰ˆæœ¬å·ç”¨äºå†²çªæ£€æµ‹
    updated_at TIMESTAMP DEFAULT NOW(),
    sync_status TEXT DEFAULT 'pending',
    sync_timestamp TIMESTAMP
);

-- åˆ›å»ºç´¢å¼•ä¼˜åŒ–åŒæ­¥æŸ¥è¯¢
CREATE INDEX idx_products_sync_status ON products(sync_status, sync_timestamp);
CREATE INDEX idx_products_version ON products(id, version);
```

### 3.2 æ“ä½œé˜Ÿåˆ—æœºåˆ¶

**æ“ä½œé˜Ÿåˆ—å®ç°**ï¼š

```sql
-- æ“ä½œé˜Ÿåˆ—è¡¨
CREATE TABLE operation_queue (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation_type TEXT NOT NULL,  -- INSERT, UPDATE, DELETE
    record_id INT,
    operation_data JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    priority INT DEFAULT 0,  -- ä¼˜å…ˆçº§
    retry_count INT DEFAULT 0,
    status TEXT DEFAULT 'pending'  -- pending, processing, completed, failed
);

-- æ“ä½œé˜Ÿåˆ—å¤„ç†å‡½æ•°
CREATE OR REPLACE FUNCTION process_operation_queue()
RETURNS void AS $$
DECLARE
    op_record RECORD;
BEGIN
    FOR op_record IN
        SELECT * FROM operation_queue
        WHERE status = 'pending'
        ORDER BY priority DESC, created_at ASC
        LIMIT 100
    LOOP
        -- å¤„ç†æ“ä½œ
        PERFORM sync_operation(op_record);

        -- æ›´æ–°çŠ¶æ€
        UPDATE operation_queue
        SET status = 'processing'
        WHERE id = op_record.id;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

**æ“ä½œåŒæ­¥å‡½æ•°**ï¼š

```sql
-- åŒæ­¥æ“ä½œå‡½æ•°
CREATE OR REPLACE FUNCTION sync_operation(p_operation operation_queue)
RETURNS void AS $$
DECLARE
    v_result BOOLEAN;
BEGIN
    -- å°è¯•åŒæ­¥åˆ°è¿œç¨‹æ•°æ®åº“
    v_result := sync_to_remote(p_operation);

    IF v_result THEN
        -- åŒæ­¥æˆåŠŸ
        UPDATE operation_queue
        SET status = 'completed', synced_at = NOW()
        WHERE id = p_operation.id;

        -- æ›´æ–°ä¸šåŠ¡è¡¨åŒæ­¥çŠ¶æ€
        EXECUTE format('UPDATE %I SET sync_status = ''synced'', sync_timestamp = NOW() WHERE id = $1',
                       p_operation.table_name) USING p_operation.record_id;
    ELSE
        -- åŒæ­¥å¤±è´¥ï¼Œå¢åŠ é‡è¯•æ¬¡æ•°
        UPDATE operation_queue
        SET retry_count = retry_count + 1,
            status = CASE
                WHEN retry_count >= 3 THEN 'failed'
                ELSE 'pending'
            END
        WHERE id = p_operation.id;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### 3.3 åŒæ­¥æœºåˆ¶

**åŒæ­¥è§¦å‘æœºåˆ¶**ï¼š

```sql
-- ç½‘ç»œçŠ¶æ€æ£€æµ‹å‡½æ•°
CREATE OR REPLACE FUNCTION check_network_status()
RETURNS BOOLEAN AS $$
BEGIN
    -- å°è¯•è¿æ¥è¿œç¨‹æ•°æ®åº“
    BEGIN
        PERFORM dblink_connect('remote_db', 'host=remote-server port=5432 dbname=remote_db user=user password=password');
        PERFORM dblink_disconnect('remote_db');
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END;
END;
$$ LANGUAGE plpgsql;

-- è‡ªåŠ¨åŒæ­¥è§¦å‘å™¨
CREATE OR REPLACE FUNCTION auto_sync_trigger()
RETURNS void AS $$
BEGIN
    IF check_network_status() THEN
        PERFORM process_operation_queue();
    END IF;
END;
$$ LANGUAGE plpgsql;

-- å®šæ—¶åŒæ­¥ä»»åŠ¡ï¼ˆä½¿ç”¨pg_cronæ‰©å±•ï¼‰
SELECT cron.schedule('sync-operations', '*/5 * * * *', 'SELECT auto_sync_trigger();');
```

**åŒå‘åŒæ­¥å®ç°**ï¼š

```sql
-- ä»è¿œç¨‹åŒæ­¥æ•°æ®
CREATE OR REPLACE FUNCTION sync_from_remote()
RETURNS void AS $$
DECLARE
    remote_record RECORD;
    local_record RECORD;
    conflict_detected BOOLEAN;
BEGIN
    -- è·å–è¿œç¨‹å˜æ›´æ•°æ®
    FOR remote_record IN
        SELECT * FROM dblink('remote_db',
            'SELECT id, name, price, version, updated_at FROM products WHERE updated_at > $1',
            (SELECT MAX(sync_timestamp) FROM products WHERE sync_status = 'synced')::TEXT
        ) AS t(id INT, name TEXT, price NUMERIC, version INT, updated_at TIMESTAMP)
    LOOP
        -- æ£€æŸ¥æœ¬åœ°è®°å½•
        SELECT * INTO local_record FROM products WHERE id = remote_record.id;

        IF local_record IS NULL THEN
            -- æ’å…¥æ–°è®°å½•
            INSERT INTO products (id, name, price, version, updated_at, sync_status)
            VALUES (remote_record.id, remote_record.name, remote_record.price,
                   remote_record.version, remote_record.updated_at, 'synced');
        ELSIF local_record.sync_status = 'pending' THEN
            -- æ£€æµ‹å†²çª
            conflict_detected := detect_conflict('products', remote_record.id,
                                                local_record.version, remote_record.version);
            IF conflict_detected THEN
                -- æ ‡è®°å†²çª
                UPDATE products
                SET sync_status = 'conflict'
                WHERE id = remote_record.id;
            ELSE
                -- æ›´æ–°è®°å½•
                UPDATE products
                SET name = remote_record.name,
                    price = remote_record.price,
                    version = remote_record.version,
                    updated_at = remote_record.updated_at,
                    sync_status = 'synced'
                WHERE id = remote_record.id;
            END IF;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

---

## 4. é…ç½®ä¸éƒ¨ç½²

### 4.1 æœ¬åœ°æ•°æ®åº“é…ç½®

**æœ¬åœ°æ•°æ®åº“ä¼˜åŒ–é…ç½®**ï¼š

```sql
-- postgresql.conf (æœ¬åœ°æ•°æ®åº“)
# æ€§èƒ½ä¼˜åŒ–
shared_buffers = 256MB
effective_cache_size = 1GB
maintenance_work_mem = 64MB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200
work_mem = 4MB

# åŒæ­¥ä¼˜åŒ–
synchronous_commit = off  -- ç¦»çº¿åœºæ™¯ä¸éœ€è¦åŒæ­¥æäº¤
wal_level = minimal  -- å‡å°‘WALå¼€é”€
```

### 4.2 åŒæ­¥é…ç½®

**åŒæ­¥é…ç½®è¡¨**ï¼š

```sql
-- åŒæ­¥é…ç½®è¡¨
CREATE TABLE sync_config (
    id SERIAL PRIMARY KEY,
    config_key TEXT UNIQUE,
    config_value TEXT,
    updated_at TIMESTAMP DEFAULT NOW()
);

-- æ’å…¥åŒæ­¥é…ç½®
INSERT INTO sync_config (config_key, config_value) VALUES
    ('sync_interval', '300'),  -- 5åˆ†é’ŸåŒæ­¥ä¸€æ¬¡
    ('max_retry_count', '3'),
    ('conflict_resolution', 'lww'),  -- æœ€åå†™å…¥è·èƒœ
    ('remote_host', 'remote-server.example.com'),
    ('remote_port', '5432'),
    ('remote_database', 'remote_db'),
    ('remote_user', 'sync_user'),
    ('remote_password', 'secure_password');
```

### 4.3 å†²çªè§£å†³é…ç½®

**å†²çªè§£å†³é…ç½®**ï¼š

```sql
-- å†²çªè§£å†³è§„åˆ™è¡¨
CREATE TABLE conflict_resolution_rules (
    id SERIAL PRIMARY KEY,
    table_name TEXT,
    conflict_type TEXT,  -- update_update, update_delete, insert_insert
    resolution_strategy TEXT,  -- lww, manual, custom
    custom_function TEXT,  -- è‡ªå®šä¹‰è§£å†³å‡½æ•°
    priority INT DEFAULT 0
);

-- æ’å…¥å†²çªè§£å†³è§„åˆ™
INSERT INTO conflict_resolution_rules (table_name, conflict_type, resolution_strategy) VALUES
    ('products', 'update_update', 'lww'),
    ('products', 'update_delete', 'manual'),
    ('products', 'insert_insert', 'manual');
```

---

## 5. åº”ç”¨å¼€å‘

### 5.1 ç¦»çº¿æ“ä½œAPI

**Pythonç¦»çº¿æ“ä½œAPIç¤ºä¾‹**ï¼š

```python
import psycopg2
from datetime import datetime

class OfflineDatabase:
    def __init__(self, connection_string):
        self.conn = psycopg2.connect(connection_string)
        self.is_online = self.check_network_status()

    def check_network_status(self):
        """æ£€æŸ¥ç½‘ç»œçŠ¶æ€"""
        try:
            # å°è¯•è¿æ¥è¿œç¨‹æ•°æ®åº“
            remote_conn = psycopg2.connect("host=remote-server dbname=remote_db user=user password=password")
            remote_conn.close()
            return True
        except:
            return False

    def insert_offline(self, table_name, data):
        """ç¦»çº¿æ’å…¥æ“ä½œ"""
        cur = self.conn.cursor()

        # æ’å…¥åˆ°æœ¬åœ°æ•°æ®åº“
        columns = ', '.join(data.keys())
        values = ', '.join(['%s'] * len(data))
        query = f"INSERT INTO {table_name} ({columns}) VALUES ({values}) RETURNING id"

        cur.execute(query, list(data.values()))
        record_id = cur.fetchone()[0]

        # æ·»åŠ åˆ°æ“ä½œé˜Ÿåˆ—
        cur.execute("""
            INSERT INTO operation_queue (table_name, operation_type, record_id, operation_data)
            VALUES (%s, 'INSERT', %s, %s)
        """, (table_name, record_id, json.dumps(data)))

        # æ›´æ–°ä¸šåŠ¡è¡¨åŒæ­¥çŠ¶æ€
        cur.execute(f"""
            UPDATE {table_name}
            SET sync_status = 'pending'
            WHERE id = %s
        """, (record_id,))

        self.conn.commit()
        return record_id

    def update_offline(self, table_name, record_id, data):
        """ç¦»çº¿æ›´æ–°æ“ä½œ"""
        cur = self.conn.cursor()

        # æ›´æ–°æœ¬åœ°æ•°æ®åº“
        set_clause = ', '.join([f"{k} = %s" for k in data.keys()])
        query = f"UPDATE {table_name} SET {set_clause}, version = version + 1 WHERE id = %s"

        cur.execute(query, list(data.values()) + [record_id])

        # æ·»åŠ åˆ°æ“ä½œé˜Ÿåˆ—
        cur.execute("""
            INSERT INTO operation_queue (table_name, operation_type, record_id, operation_data)
            VALUES (%s, 'UPDATE', %s, %s)
        """, (table_name, record_id, json.dumps(data)))

        # æ›´æ–°åŒæ­¥çŠ¶æ€
        cur.execute(f"""
            UPDATE {table_name}
            SET sync_status = 'pending'
            WHERE id = %s
        """, (record_id,))

        self.conn.commit()

    def sync_operations(self):
        """åŒæ­¥æ“ä½œé˜Ÿåˆ—"""
        if not self.is_online:
            return False

        cur = self.conn.cursor()
        cur.execute("SELECT process_operation_queue()")
        self.conn.commit()
        return True
```

### 5.2 åŒæ­¥çŠ¶æ€ç®¡ç†

**åŒæ­¥çŠ¶æ€æŸ¥è¯¢**ï¼š

```sql
-- æŸ¥è¯¢å¾…åŒæ­¥æ“ä½œæ•°é‡
SELECT COUNT(*) FROM operation_queue WHERE status = 'pending';

-- æŸ¥è¯¢åŒæ­¥çŠ¶æ€ç»Ÿè®¡
SELECT
    sync_status,
    COUNT(*) AS count
FROM products
GROUP BY sync_status;

-- æŸ¥è¯¢å†²çªè®°å½•
SELECT * FROM products WHERE sync_status = 'conflict';
```

### 5.3 å†²çªå¤„ç†

**å†²çªå¤„ç†API**ï¼š

```python
def resolve_conflict(self, table_name, record_id, resolution_data):
    """è§£å†³å†²çª"""
    cur = self.conn.cursor()

    # åº”ç”¨è§£å†³ç­–ç•¥
    if resolution_data['strategy'] == 'lww':
        # æœ€åå†™å…¥è·èƒœ
        cur.execute(f"""
            UPDATE {table_name}
            SET name = %s, price = %s, version = %s,
                sync_status = 'synced', sync_timestamp = NOW()
            WHERE id = %s
        """, (resolution_data['name'], resolution_data['price'],
              resolution_data['version'], record_id))

    elif resolution_data['strategy'] == 'manual':
        # æ‰‹åŠ¨è§£å†³
        cur.execute(f"""
            UPDATE {table_name}
            SET name = %s, price = %s, version = version + 1,
                sync_status = 'pending'
            WHERE id = %s
        """, (resolution_data['name'], resolution_data['price'], record_id))

    self.conn.commit()
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 æœ¬åœ°æ€§èƒ½ä¼˜åŒ–

**æœ¬åœ°æ•°æ®åº“ä¼˜åŒ–**ï¼š

```sql
-- åˆ›å»ºç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
CREATE INDEX idx_products_sync_status ON products(sync_status, sync_timestamp);
CREATE INDEX idx_operation_queue_status ON operation_queue(status, created_at);

-- å®šæœŸæ¸…ç†å·²å®Œæˆçš„æ“ä½œ
DELETE FROM operation_queue
WHERE status = 'completed'
AND synced_at < NOW() - INTERVAL '7 days';
```

### 6.2 åŒæ­¥æ€§èƒ½ä¼˜åŒ–

**æ‰¹é‡åŒæ­¥ä¼˜åŒ–**ï¼š

```sql
-- æ‰¹é‡åŒæ­¥å‡½æ•°
CREATE OR REPLACE FUNCTION batch_sync_operations(batch_size INT DEFAULT 100)
RETURNS INT AS $$
DECLARE
    synced_count INT := 0;
BEGIN
    -- æ‰¹é‡å¤„ç†æ“ä½œ
    FOR i IN 1..batch_size LOOP
        PERFORM process_operation_queue();
        synced_count := synced_count + 1;
    END LOOP;

    RETURN synced_count;
END;
$$ LANGUAGE plpgsql;
```

---

## 7. å®é™…åº”ç”¨æ¡ˆä¾‹

### 7.1 ç§»åŠ¨åº”ç”¨ç¦»çº¿æ”¯æŒ

**åœºæ™¯**ï¼šç§»åŠ¨åº”ç”¨åœ¨ç¦»çº¿çŠ¶æ€ä¸‹ç»§ç»­æ“ä½œï¼Œç½‘ç»œæ¢å¤åè‡ªåŠ¨åŒæ­¥

**å®ç°**ï¼š

```python
# ç§»åŠ¨åº”ç”¨ç¦»çº¿æ•°æ®åº“æ“ä½œ
db = OfflineDatabase("dbname=mobile_app user=app_user")

# ç¦»çº¿æ’å…¥è®¢å•
order_id = db.insert_offline('orders', {
    'user_id': 123,
    'product_id': 456,
    'quantity': 2,
    'total_amount': 199.99
})

# ç½‘ç»œæ¢å¤åè‡ªåŠ¨åŒæ­¥
if db.check_network_status():
    db.sync_operations()
```

### 7.2 è¾¹ç¼˜è®¾å¤‡ç¦»çº¿æ”¯æŒ

**åœºæ™¯**ï¼šIoTè¾¹ç¼˜è®¾å¤‡åœ¨ç¦»çº¿çŠ¶æ€ä¸‹æ”¶é›†æ•°æ®ï¼Œç½‘ç»œæ¢å¤åæ‰¹é‡ä¸Šä¼ 

**å®ç°**ï¼š

```python
# è¾¹ç¼˜è®¾å¤‡æ•°æ®æ”¶é›†
device_db = OfflineDatabase("dbname=iot_device user=device_user")

# ç¦»çº¿æ”¶é›†ä¼ æ„Ÿå™¨æ•°æ®
for reading in sensor_readings:
    device_db.insert_offline('sensor_data', {
        'sensor_id': reading.sensor_id,
        'value': reading.value,
        'timestamp': reading.timestamp
    })

# å®šæ—¶æ‰¹é‡åŒæ­¥
if device_db.check_network_status():
    device_db.sync_operations()
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 è®¾è®¡åŸåˆ™

**è®¾è®¡åŸåˆ™**ï¼š

1. **æœ¬åœ°ä¼˜å…ˆ**ï¼šä¼˜å…ˆä½¿ç”¨æœ¬åœ°æ•°æ®åº“ï¼Œä¿è¯ç¦»çº¿å¯ç”¨æ€§
2. **å¼‚æ­¥åŒæ­¥**ï¼šä½¿ç”¨å¼‚æ­¥åŒæ­¥æœºåˆ¶ï¼Œä¸é˜»å¡ç”¨æˆ·æ“ä½œ
3. **å†²çªæ£€æµ‹**ï¼šè‡ªåŠ¨æ£€æµ‹å†²çªï¼Œæä¾›è§£å†³æœºåˆ¶
4. **çŠ¶æ€ç®¡ç†**ï¼šæ¸…æ™°çš„çŠ¶æ€ç®¡ç†ï¼Œä¾¿äºç›‘æ§å’Œè°ƒè¯•

### 8.2 æ³¨æ„äº‹é¡¹

**æ³¨æ„äº‹é¡¹**ï¼š

1. **æ•°æ®ä¸€è‡´æ€§**ï¼šå¹³è¡¡ä¸€è‡´æ€§å’Œå¯ç”¨æ€§
2. **å†²çªå¤„ç†**ï¼šå®šä¹‰æ¸…æ™°çš„å†²çªè§£å†³ç­–ç•¥
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–æœ¬åœ°æ•°æ®åº“å’ŒåŒæ­¥æ€§èƒ½
4. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

---

## 9. å‚è€ƒèµ„æ–™

### å®˜æ–¹æ–‡æ¡£

1. **PostgreSQLæœ¬åœ°æ•°æ®åº“**ï¼š
   - [PostgreSQL Configuration](https://www.postgresql.org/docs/current/runtime-config.html)
   - [PostgreSQL Performance Tuning](https://www.postgresql.org/docs/current/performance-tips.html)

2. **åŒæ­¥æœºåˆ¶**ï¼š
   - [PostgreSQL Logical Replication](https://www.postgresql.org/docs/current/logical-replication.html)
   - [PostgreSQL dblink Extension](https://www.postgresql.org/docs/current/dblink.html)

### æŠ€æœ¯åšå®¢

1. **ç¦»çº¿æ“ä½œæœ€ä½³å®è·µ**ï¼š
   - PostgreSQLç¦»çº¿æ“ä½œè®¾è®¡æ¨¡å¼
   - ç§»åŠ¨åº”ç”¨ç¦»çº¿æ•°æ®åŒæ­¥æ¡ˆä¾‹

---

## 10. å®Œæ•´ä»£ç ç¤ºä¾‹

### 10.1 æœ¬åœ°æ•°æ®åº“åˆå§‹åŒ–

**åˆ›å»ºæœ¬åœ°æ•°æ®åº“è¡¨ç»“æ„**ï¼š

```sql
-- åˆ›å»ºæ“ä½œé˜Ÿåˆ—è¡¨
CREATE TABLE operation_queue (
    id SERIAL PRIMARY KEY,
    operation_type TEXT NOT NULL,  -- INSERT, UPDATE, DELETE
    table_name TEXT NOT NULL,
    record_id INTEGER,
    operation_data JSONB,
    status TEXT DEFAULT 'pending',  -- pending, syncing, synced, failed
    created_at TIMESTAMP DEFAULT NOW(),
    synced_at TIMESTAMP
);

-- åˆ›å»ºåŒæ­¥çŠ¶æ€è¡¨
CREATE TABLE sync_status (
    id SERIAL PRIMARY KEY,
    last_sync_time TIMESTAMP,
    sync_count INTEGER DEFAULT 0,
    failed_count INTEGER DEFAULT 0,
    last_error TEXT
);

-- åˆ›å»ºå†²çªæ—¥å¿—è¡¨
CREATE TABLE conflict_log (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    record_id INTEGER,
    local_data JSONB,
    remote_data JSONB,
    conflict_type TEXT,
    resolved BOOLEAN DEFAULT false,
    resolved_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_operation_queue_status ON operation_queue(status);
CREATE INDEX idx_operation_queue_created ON operation_queue(created_at);
CREATE INDEX idx_conflict_log_resolved ON conflict_log(resolved);
```

### 10.2 Python ç¦»çº¿æ“ä½œ API

**ç¦»çº¿æ“ä½œç®¡ç†å™¨**ï¼š

```python
import psycopg2
import json
from datetime import datetime
from typing import Optional, Dict, Any

class OfflineOperationManager:
    def __init__(self, local_db_conn_str, remote_db_conn_str):
        """åˆå§‹åŒ–ç¦»çº¿æ“ä½œç®¡ç†å™¨"""
        self.local_db = psycopg2.connect(local_db_conn_str)
        self.remote_db_conn_str = remote_db_conn_str
        self.is_online = False

    def check_network_status(self) -> bool:
        """æ£€æŸ¥ç½‘ç»œçŠ¶æ€"""
        try:
            conn = psycopg2.connect(self.remote_db_conn_str, connect_timeout=5)
            conn.close()
            self.is_online = True
            return True
        except:
            self.is_online = False
            return False

    def insert_offline(self, table_name: str, data: Dict[str, Any]) -> int:
        """ç¦»çº¿æ’å…¥æ“ä½œ"""
        cur = self.local_db.cursor()

        # æ’å…¥åˆ°æœ¬åœ°è¡¨
        columns = ', '.join(data.keys())
        values = ', '.join(['%s'] * len(data))
        cur.execute(f"""
            INSERT INTO {table_name} ({columns})
            VALUES ({values})
            RETURNING id
        """, list(data.values()))

        record_id = cur.fetchone()[0]

        # æ·»åŠ åˆ°æ“ä½œé˜Ÿåˆ—
        cur.execute("""
            INSERT INTO operation_queue (operation_type, table_name, record_id, operation_data)
            VALUES (%s, %s, %s, %s)
        """, ('INSERT', table_name, record_id, json.dumps(data)))

        self.local_db.commit()
        return record_id

    def update_offline(self, table_name: str, record_id: int, data: Dict[str, Any]):
        """ç¦»çº¿æ›´æ–°æ“ä½œ"""
        cur = self.local_db.cursor()

        # æ›´æ–°æœ¬åœ°è¡¨
        set_clause = ', '.join([f"{k} = %s" for k in data.keys()])
        cur.execute(f"""
            UPDATE {table_name}
            SET {set_clause}
            WHERE id = %s
        """, list(data.values()) + [record_id])

        # æ·»åŠ åˆ°æ“ä½œé˜Ÿåˆ—
        cur.execute("""
            INSERT INTO operation_queue (operation_type, table_name, record_id, operation_data)
            VALUES (%s, %s, %s, %s)
        """, ('UPDATE', table_name, record_id, json.dumps(data)))

        self.local_db.commit()

    def delete_offline(self, table_name: str, record_id: int):
        """ç¦»çº¿åˆ é™¤æ“ä½œ"""
        cur = self.local_db.cursor()

        # åˆ é™¤æœ¬åœ°è®°å½•
        cur.execute(f"DELETE FROM {table_name} WHERE id = %s", (record_id,))

        # æ·»åŠ åˆ°æ“ä½œé˜Ÿåˆ—
        cur.execute("""
            INSERT INTO operation_queue (operation_type, table_name, record_id)
            VALUES (%s, %s, %s)
        """, ('DELETE', table_name, record_id))

        self.local_db.commit()

    def sync_operations(self):
        """åŒæ­¥æ“ä½œé˜Ÿåˆ—"""
        if not self.check_network_status():
            print("Network offline, cannot sync")
            return

        cur = self.local_db.cursor()

        # æŸ¥è¯¢å¾…åŒæ­¥çš„æ“ä½œ
        cur.execute("""
            SELECT id, operation_type, table_name, record_id, operation_data
            FROM operation_queue
            WHERE status = 'pending'
            ORDER BY created_at
        """)

        operations = cur.fetchall()

        remote_conn = psycopg2.connect(self.remote_db_conn_str)
        remote_cur = remote_conn.cursor()

        for op_id, op_type, table_name, record_id, op_data in operations:
            try:
                # æ›´æ–°çŠ¶æ€ä¸ºåŒæ­¥ä¸­
                cur.execute("""
                    UPDATE operation_queue
                    SET status = 'syncing'
                    WHERE id = %s
                """, (op_id,))

                # æ‰§è¡Œè¿œç¨‹æ“ä½œ
                if op_type == 'INSERT':
                    data = json.loads(op_data)
                    columns = ', '.join(data.keys())
                    values = ', '.join(['%s'] * len(data))
                    remote_cur.execute(f"""
                        INSERT INTO {table_name} ({columns})
                        VALUES ({values})
                    """, list(data.values()))

                elif op_type == 'UPDATE':
                    data = json.loads(op_data)
                    set_clause = ', '.join([f"{k} = %s" for k in data.keys()])
                    remote_cur.execute(f"""
                        UPDATE {table_name}
                        SET {set_clause}
                        WHERE id = %s
                    """, list(data.values()) + [record_id])

                elif op_type == 'DELETE':
                    remote_cur.execute(f"DELETE FROM {table_name} WHERE id = %s", (record_id,))

                remote_conn.commit()

                # æ›´æ–°çŠ¶æ€ä¸ºå·²åŒæ­¥
                cur.execute("""
                    UPDATE operation_queue
                    SET status = 'synced', synced_at = %s
                    WHERE id = %s
                """, (datetime.now(), op_id))

            except Exception as e:
                # æ›´æ–°çŠ¶æ€ä¸ºå¤±è´¥
                cur.execute("""
                    UPDATE operation_queue
                    SET status = 'failed'
                    WHERE id = %s
                """, (op_id,))
                print(f"Sync failed for operation {op_id}: {e}")

        self.local_db.commit()
        remote_conn.close()

# ä½¿ç”¨ç¤ºä¾‹
manager = OfflineOperationManager(
    local_db_conn_str="host=localhost dbname=local_db user=postgres password=secret",
    remote_db_conn_str="host=remote_server dbname=remote_db user=postgres password=secret"
)

# ç¦»çº¿æ’å…¥
record_id = manager.insert_offline('products', {
    'name': 'Product A',
    'price': 99.99,
    'quantity': 10
})

# ç½‘ç»œæ¢å¤ååŒæ­¥
if manager.check_network_status():
    manager.sync_operations()
```

### 10.3 å†²çªæ£€æµ‹ä¸è§£å†³

**å†²çªæ£€æµ‹å‡½æ•°**ï¼š

```python
class ConflictDetector:
    def __init__(self, local_db_conn_str, remote_db_conn_str):
        """åˆå§‹åŒ–å†²çªæ£€æµ‹å™¨"""
        self.local_db = psycopg2.connect(local_db_conn_str)
        self.remote_db_conn_str = remote_db_conn_str

    def detect_conflicts(self, table_name: str):
        """æ£€æµ‹å†²çª"""
        local_cur = self.local_db.cursor()
        remote_conn = psycopg2.connect(self.remote_db_conn_str)
        remote_cur = remote_conn.cursor()

        # æŸ¥è¯¢æœ¬åœ°ä¿®æ”¹çš„è®°å½•
        local_cur.execute(f"""
            SELECT id, updated_at, *
            FROM {table_name}
            WHERE updated_at > (
                SELECT last_sync_time FROM sync_status LIMIT 1
            )
        """)

        local_records = local_cur.fetchall()

        conflicts = []
        for record in local_records:
            record_id = record[0]

            # æŸ¥è¯¢è¿œç¨‹è®°å½•
            remote_cur.execute(f"""
                SELECT id, updated_at, *
                FROM {table_name}
                WHERE id = %s
            """, (record_id,))

            remote_record = remote_cur.fetchone()

            if remote_record and remote_record[1] > record[1]:
                # æ£€æµ‹åˆ°å†²çªï¼šè¿œç¨‹è®°å½•æ›´æ–°
                conflicts.append({
                    'table_name': table_name,
                    'record_id': record_id,
                    'local_data': dict(zip([desc[0] for desc in local_cur.description], record)),
                    'remote_data': dict(zip([desc[0] for desc in remote_cur.description], remote_record))
                })

        remote_conn.close()
        return conflicts

    def resolve_conflicts(self, conflicts, strategy='timestamp'):
        """è§£å†³å†²çª"""
        cur = self.local_db.cursor()

        for conflict in conflicts:
            if strategy == 'timestamp':
                # æ—¶é—´æˆ³ç­–ç•¥ï¼šé€‰æ‹©æœ€æ–°çš„
                if conflict['remote_data']['updated_at'] > conflict['local_data']['updated_at']:
                    # ä½¿ç”¨è¿œç¨‹æ•°æ®
                    self._update_local_record(
                        conflict['table_name'],
                        conflict['record_id'],
                        conflict['remote_data']
                    )
                else:
                    # ä½¿ç”¨æœ¬åœ°æ•°æ®ï¼Œè®°å½•å†²çª
                    self._log_conflict(conflict)

            elif strategy == 'manual':
                # æ‰‹åŠ¨è§£å†³ï¼šè®°å½•å†²çª
                self._log_conflict(conflict)

    def _update_local_record(self, table_name, record_id, data):
        """æ›´æ–°æœ¬åœ°è®°å½•"""
        cur = self.local_db.cursor()
        set_clause = ', '.join([f"{k} = %s" for k in data.keys() if k != 'id'])
        cur.execute(f"""
            UPDATE {table_name}
            SET {set_clause}
            WHERE id = %s
        """, [v for k, v in data.items() if k != 'id'] + [record_id])
        self.local_db.commit()

    def _log_conflict(self, conflict):
        """è®°å½•å†²çª"""
        cur = self.local_db.cursor()
        cur.execute("""
            INSERT INTO conflict_log (table_name, record_id, local_data, remote_data, conflict_type)
            VALUES (%s, %s, %s, %s, %s)
        """, (
            conflict['table_name'],
            conflict['record_id'],
            json.dumps(conflict['local_data']),
            json.dumps(conflict['remote_data']),
            'timestamp'
        ))
        self.local_db.commit()

# ä½¿ç”¨ç¤ºä¾‹
detector = ConflictDetector(
    local_db_conn_str="host=localhost dbname=local_db user=postgres password=secret",
    remote_db_conn_str="host=remote_server dbname=remote_db user=postgres password=secret"
)

conflicts = detector.detect_conflicts('products')
detector.resolve_conflicts(conflicts, strategy='timestamp')
```

### 10.4 Docker Compose ç¦»çº¿æ“ä½œéƒ¨ç½²

**docker-compose.yml**ï¼š

```yaml
version: '3.8'

services:
  local_db:
    image: postgres:18
    environment:
      POSTGRES_DB: local_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
    ports:
      - "5432:5432"
    volumes:
      - local_data:/var/lib/postgresql/data
      - ./init_local_db.sql:/docker-entrypoint-initdb.d/init.sql

  sync_service:
    image: python:3.11
    volumes:
      - ./sync_service:/app
    working_dir: /app
    command: python sync_manager.py
    depends_on:
      - local_db
    environment:
      LOCAL_DB_URL: postgresql://postgres:secret@local_db:5432/local_db
      REMOTE_DB_URL: postgresql://postgres:secret@remote_server:5432/remote_db

volumes:
  local_data:
```

---

**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤çŠ¶æ€**: âœ… æŒç»­æ›´æ–°
