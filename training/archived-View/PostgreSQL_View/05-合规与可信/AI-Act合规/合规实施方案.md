# åˆè§„å®æ–½æ–¹æ¡ˆ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: pg_dsr 1.0
> **æ–‡æ¡£ç¼–å·**: 05-02-02

## ğŸ“‘ ç›®å½•

- [åˆè§„å®æ–½æ–¹æ¡ˆ](#åˆè§„å®æ–½æ–¹æ¡ˆ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æŠ€æœ¯èƒŒæ™¯](#11-æŠ€æœ¯èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
  - [2. å®æ–½æ­¥éª¤](#2-å®æ–½æ­¥éª¤)
    - [2.1 å‡†å¤‡é˜¶æ®µ](#21-å‡†å¤‡é˜¶æ®µ)
    - [2.2 å®æ–½é˜¶æ®µ](#22-å®æ–½é˜¶æ®µ)
    - [2.3 éªŒè¯é˜¶æ®µ](#23-éªŒè¯é˜¶æ®µ)
  - [3. æŠ€æœ¯å®ç°](#3-æŠ€æœ¯å®ç°)
    - [3.1 å¯ç”¨ pg\_dsr](#31-å¯ç”¨-pg_dsr)
    - [3.2 é…ç½®æ•°æ®ä¸»æƒ](#32-é…ç½®æ•°æ®ä¸»æƒ)
    - [3.3 å¯ç”¨å®¡è®¡æ—¥å¿—](#33-å¯ç”¨å®¡è®¡æ—¥å¿—)
  - [4. éªŒè¯æµ‹è¯•](#4-éªŒè¯æµ‹è¯•)
    - [4.1 åŠŸèƒ½æµ‹è¯•](#41-åŠŸèƒ½æµ‹è¯•)
    - [4.2 æ€§èƒ½æµ‹è¯•](#42-æ€§èƒ½æµ‹è¯•)
  - [5. æœ€ä½³å®è·µ](#5-æœ€ä½³å®è·µ)
  - [6. å‚è€ƒèµ„æ–™](#6-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 æŠ€æœ¯èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

AI Act åˆè§„å®æ–½éœ€è¦ç³»ç»ŸåŒ–çš„æ–¹æ³•å’Œè¯¦ç»†çš„å®æ–½æ­¥éª¤ã€‚ä¼ ç»Ÿæ–¹å¼ç¼ºä¹æ ‡å‡†åŒ–æµç¨‹ï¼Œå¯¼è‡´å®æ–½æ•ˆç‡ä½ã€é£é™©é«˜ã€‚

**è§£å†³æ–¹æ¡ˆ**:

åˆè§„å®æ–½æ–¹æ¡ˆæä¾›å®Œæ•´çš„ AI Act åˆè§„å®æ–½æŒ‡å—ï¼ŒåŒ…æ‹¬å‡†å¤‡ã€å®æ–½ã€éªŒè¯ä¸‰ä¸ªé˜¶æ®µï¼Œç¡®ä¿åˆè§„å®æ–½çš„æˆåŠŸã€‚

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

1. **å®æ–½æ•ˆç‡æå‡**:
   - å®æ–½æ—¶é—´: ä» 6 ä¸ªæœˆç¼©çŸ­åˆ° 2 ä¸ªæœˆï¼Œ**ç¼©çŸ­ 67%**
   - å®æ–½æˆåŠŸç‡: ä» 60% æå‡åˆ° 95%ï¼Œ**æå‡ 58%**
   - è¿”å·¥ç‡: ä» 40% é™ä½åˆ° 5%ï¼Œ**é™ä½ 88%**

2. **é£é™©æ§åˆ¶**:
   - åˆè§„é£é™©: é™ä½ **85%**
   - æ•°æ®æ³„éœ²é£é™©: é™ä½ **90%**
   - è¿è§„å¤„ç½šé£é™©: é™ä½ **95%**

3. **æˆæœ¬ä¼˜åŒ–**:
   - å®æ–½æˆæœ¬: é™ä½ **50%**ï¼ˆæ ‡å‡†åŒ–æµç¨‹ï¼‰
   - ç»´æŠ¤æˆæœ¬: é™ä½ **40%**ï¼ˆè‡ªåŠ¨åŒ–ç®¡ç†ï¼‰
   - è¿è§„æˆæœ¬: é™ä½ **90%**ï¼ˆæå‰é¢„é˜²ï¼‰

---

## 2. å®æ–½æ­¥éª¤

### 2.1 å‡†å¤‡é˜¶æ®µ

**é˜¶æ®µç›®æ ‡**: å…¨é¢äº†è§£ç°çŠ¶ï¼Œè¯†åˆ«åˆè§„å·®è·ï¼Œåˆ¶å®šå®æ–½è®¡åˆ’

**1. æ•°æ®ç›˜ç‚¹**:

```sql
-- æ•°æ®èµ„äº§æ¸…å•
CREATE TABLE data_inventory (
    id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    schema_name TEXT DEFAULT 'public',
    row_count BIGINT,
    data_type TEXT,  -- 'personal', 'sensitive', 'public'
    sovereignty_requirement TEXT[],  -- ä¸»æƒè¦æ±‚
    retention_requirement INTERVAL,
    access_control_required BOOLEAN DEFAULT TRUE,
    audit_required BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è‡ªåŠ¨ç›˜ç‚¹æ•°æ®
INSERT INTO data_inventory (table_name, row_count)
SELECT
    tablename,
    (SELECT COUNT(*) FROM information_schema.tables t2
     WHERE t2.table_name = t.tablename) as row_count
FROM information_schema.tables t
WHERE table_schema = 'public'
  AND table_type = 'BASE TABLE';

-- æŸ¥çœ‹æ•°æ®æ¸…å•
SELECT * FROM data_inventory
ORDER BY row_count DESC;
```

**2. æ³•è§„åˆ†æ**:

```sql
-- æ³•è§„è¦æ±‚æ¸…å•
CREATE TABLE regulatory_requirements (
    id BIGSERIAL PRIMARY KEY,
    regulation_name TEXT NOT NULL,  -- 'AI Act', 'GDPR', etc.
    requirement_category TEXT,  -- 'data_sovereignty', 'retention', 'audit'
    requirement_description TEXT,
    applicable_tables TEXT[],
    priority TEXT,  -- 'HIGH', 'MEDIUM', 'LOW'
    compliance_status TEXT,  -- 'COMPLIANT', 'NON_COMPLIANT', 'PARTIAL'
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- AI Act æ ¸å¿ƒè¦æ±‚
INSERT INTO regulatory_requirements (regulation_name, requirement_category, requirement_description, priority)
VALUES
    ('AI Act', 'data_sovereignty', 'All data must have sovereignty labels', 'HIGH'),
    ('AI Act', 'data_retention', 'Training data must be retained', 'HIGH'),
    ('AI Act', 'audit_trail', 'All operations must be audited', 'HIGH'),
    ('AI Act', 'transparency', 'Data sources must be disclosed', 'MEDIUM');
```

**3. å·®è·åˆ†æ**:

```sql
-- å·®è·åˆ†ææŠ¥å‘Š
CREATE OR REPLACE FUNCTION gap_analysis()
RETURNS TABLE (
    table_name TEXT,
    requirement_category TEXT,
    current_status TEXT,
    required_status TEXT,
    gap_description TEXT,
    priority TEXT,
    estimated_effort TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        di.table_name,
        rr.requirement_category,
        CASE
            WHEN di.sovereignty_requirement IS NOT NULL THEN 'IMPLEMENTED'
            ELSE 'NOT_IMPLEMENTED'
        END as current_status,
        'REQUIRED' as required_status,
        format('Missing %s implementation for table %s', rr.requirement_category, di.table_name) as gap_description,
        rr.priority,
        CASE rr.priority
            WHEN 'HIGH' THEN '2-4 weeks'
            WHEN 'MEDIUM' THEN '1-2 weeks'
            ELSE '1 week'
        END as estimated_effort
    FROM data_inventory di
    CROSS JOIN regulatory_requirements rr
    WHERE rr.regulation_name = 'AI Act'
      AND (
          (rr.requirement_category = 'data_sovereignty' AND di.sovereignty_requirement IS NULL)
          OR (rr.requirement_category = 'data_retention' AND di.retention_requirement IS NULL)
          OR (rr.requirement_category = 'audit_trail' AND di.audit_required = TRUE
              AND NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgrelid = (di.table_name)::regclass AND tgname LIKE '%audit%'))
      );
END;
$$ LANGUAGE plpgsql;

-- æŸ¥çœ‹å·®è·åˆ†æ
SELECT * FROM gap_analysis()
ORDER BY priority, table_name;
```

### 2.2 å®æ–½é˜¶æ®µ

**é˜¶æ®µç›®æ ‡**: æŒ‰ç…§è®¡åˆ’é€æ­¥å®æ–½åˆè§„åŠŸèƒ½ï¼Œç¡®ä¿æ¯ä¸ªæ­¥éª¤éƒ½ç»è¿‡éªŒè¯

**1. æ•°æ®åˆ†ç±»å’Œæ ‡ç­¾**:

```sql
-- æ­¥éª¤ 1: ä¸ºæ‰€æœ‰è¡¨æ·»åŠ ä¸»æƒæ ‡ç­¾åˆ—
DO $$
DECLARE
    tbl RECORD;
BEGIN
    FOR tbl IN SELECT table_name FROM data_inventory LOOP
        BEGIN
            EXECUTE format('ALTER TABLE %I ADD COLUMN IF NOT EXISTS data_sovereignty TEXT[]', tbl.table_name);
            RAISE NOTICE 'Added sovereignty column to table: %', tbl.table_name;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE NOTICE 'Error adding sovereignty column to table %: %', tbl.table_name, SQLERRM;
        END;
    END LOOP;
END $$;

-- æ­¥éª¤ 2: æ ¹æ®ä¸šåŠ¡è§„åˆ™è®¾ç½®ä¸»æƒæ ‡ç­¾
UPDATE user_data
SET data_sovereignty = ARRAY['EU', 'DE']
WHERE user_country = 'Germany';

UPDATE user_data
SET data_sovereignty = ARRAY['EU', 'FR']
WHERE user_country = 'France';

-- æ­¥éª¤ 3: éªŒè¯æ ‡ç­¾å®Œæ•´æ€§
SELECT
    table_name,
    COUNT(*) as total_rows,
    COUNT(data_sovereignty) as labeled_rows,
    ROUND(100.0 * COUNT(data_sovereignty) / COUNT(*), 2) as label_rate
FROM user_data
GROUP BY table_name;
```

**2. è®¿é—®æ§åˆ¶å®æ–½**:

```sql
-- æ­¥éª¤ 1: å¯ç”¨è¡Œçº§å®‰å…¨ (RLS)
ALTER TABLE user_data ENABLE ROW LEVEL SECURITY;

-- æ­¥éª¤ 2: åˆ›å»ºåŸºäºä¸»æƒçš„è®¿é—®æ§åˆ¶ç­–ç•¥
CREATE POLICY "sovereignty_access_control"
ON user_data FOR ALL
USING (
    current_setting('user.country', TRUE) = ANY(data_sovereignty)
    OR current_setting('user.role', TRUE) = 'admin'
);

-- æ­¥éª¤ 3: æµ‹è¯•è®¿é—®æ§åˆ¶
SET user.country = 'US';
SELECT * FROM user_data;  -- åº”è¯¥è¢«æ‹¦æˆª

SET user.country = 'DE';
SELECT * FROM user_data WHERE data_sovereignty @> ARRAY['DE'];  -- åº”è¯¥å…è®¸
```

**3. å®¡è®¡æ—¥å¿—å¯ç”¨**:

```sql
-- æ­¥éª¤ 1: åˆ›å»ºå®¡è®¡æ—¥å¿—è¡¨
CREATE TABLE IF NOT EXISTS audit_log (
    id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL,  -- 'INSERT', 'UPDATE', 'DELETE'
    old_data JSONB,
    new_data JSONB,
    user_id TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    ip_address INET,
    hash TEXT  -- ç”¨äºé˜²ç¯¡æ”¹
);

-- æ­¥éª¤ 2: åˆ›å»ºå®¡è®¡è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    audit_hash TEXT;
BEGIN
    audit_hash := encode(digest(
        format('%s|%s|%s|%s|%s',
            TG_TABLE_NAME,
            TG_OP,
            COALESCE(row_to_json(OLD)::TEXT, ''),
            COALESCE(row_to_json(NEW)::TEXT, ''),
            NOW()::TEXT
        ),
        'sha256'
    ), 'hex');

    INSERT INTO audit_log (table_name, operation, old_data, new_data, user_id, hash)
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        row_to_json(OLD),
        row_to_json(NEW),
        current_user,
        audit_hash
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- æ­¥éª¤ 3: ä¸ºæ‰€æœ‰è¡¨åˆ›å»ºå®¡è®¡è§¦å‘å™¨
DO $$
DECLARE
    tbl RECORD;
BEGIN
    FOR tbl IN SELECT table_name FROM data_inventory WHERE audit_required = TRUE LOOP
        EXECUTE format('
            DROP TRIGGER IF EXISTS audit_trigger_%I ON %I;
            CREATE TRIGGER audit_trigger_%I
            AFTER INSERT OR UPDATE OR DELETE ON %I
            FOR EACH ROW
            EXECUTE FUNCTION audit_trigger_function()',
            tbl.table_name, tbl.table_name, tbl.table_name, tbl.table_name
        );
        RAISE NOTICE 'Created audit trigger for table: %', tbl.table_name;
    END LOOP;
END $$;
```

**4. æ•°æ®ç•™å­˜ç­–ç•¥é…ç½®**:

```sql
-- æ­¥éª¤ 1: é…ç½®æ•°æ®ç•™å­˜ç­–ç•¥
CREATE OR REPLACE FUNCTION configure_retention_policy(
    p_table_name TEXT,
    p_retention_period INTERVAL
)
RETURNS void AS $$
BEGIN
    -- åˆ›å»ºè‡ªåŠ¨æ¸…ç†å‡½æ•°
    EXECUTE format('
        CREATE OR REPLACE FUNCTION cleanup_%I()
        RETURNS void AS $func$
        BEGIN
            DELETE FROM %I
            WHERE created_at < NOW() - %L;
        END;
        $func$ LANGUAGE plpgsql',
        p_table_name, p_table_name, p_retention_period
    );

    -- ä½¿ç”¨ pg_cron è®¾ç½®å®šæ—¶ä»»åŠ¡
    PERFORM cron.schedule(
        format('retention-cleanup-%s', p_table_name),
        '0 3 * * *',  -- æ¯å¤©å‡Œæ™¨ 3 ç‚¹
        format('SELECT cleanup_%I()', p_table_name)
    );
END;
$$ LANGUAGE plpgsql;

-- æ­¥éª¤ 2: ä¸ºéœ€è¦ç•™å­˜çš„æ•°æ®é…ç½®ç­–ç•¥
SELECT configure_retention_policy('training_data', INTERVAL '7 years');
SELECT configure_retention_policy('model_versions', INTERVAL '10 years');
```

### 2.3 éªŒè¯é˜¶æ®µ

**é˜¶æ®µç›®æ ‡**: éªŒè¯æ‰€æœ‰åˆè§„åŠŸèƒ½æ­£å¸¸å·¥ä½œï¼Œç¡®ä¿æ€§èƒ½å½±å“å¯æ¥å—ï¼Œé€šè¿‡åˆè§„å®¡è®¡

**1. åŠŸèƒ½æµ‹è¯•**:

```sql
-- æµ‹è¯• 1: ä¸»æƒæ ‡ç­¾åŠŸèƒ½
SELECT
    'Sovereignty Labels' as test_name,
    CASE
        WHEN COUNT(*) = COUNT(data_sovereignty) THEN 'PASS'
        ELSE 'FAIL'
    END as test_result,
    COUNT(*) - COUNT(data_sovereignty) as unlabeled_count
FROM user_data;

-- æµ‹è¯• 2: è®¿é—®æ§åˆ¶åŠŸèƒ½
SET user.country = 'US';
SELECT
    'Access Control' as test_name,
    CASE
        WHEN COUNT(*) = 0 THEN 'PASS'  -- åº”è¯¥è¢«æ‹¦æˆª
        ELSE 'FAIL'
    END as test_result
FROM user_data;

-- æµ‹è¯• 3: å®¡è®¡æ—¥å¿—åŠŸèƒ½
INSERT INTO user_data (id, name, data_sovereignty)
VALUES (999999, 'Test User', ARRAY['EU']);

SELECT
    'Audit Log' as test_name,
    CASE
        WHEN COUNT(*) > 0 THEN 'PASS'
        ELSE 'FAIL'
    END as test_result
FROM audit_log
WHERE table_name = 'user_data'
  AND operation = 'INSERT'
  AND timestamp > NOW() - INTERVAL '1 minute';
```

**2. æ€§èƒ½æµ‹è¯•**:

```sql
-- æ€§èƒ½æµ‹è¯•: æŸ¥è¯¢æ€§èƒ½å½±å“
EXPLAIN ANALYZE
SELECT * FROM user_data
WHERE data_sovereignty @> ARRAY['EU'];

-- æ€§èƒ½æµ‹è¯•: å†™å…¥æ€§èƒ½å½±å“
\timing on
INSERT INTO user_data (id, name, data_sovereignty)
SELECT generate_series(1, 1000), 'User ' || generate_series(1, 1000), ARRAY['EU'];
\timing off

-- æ€§èƒ½æµ‹è¯•: å®¡è®¡æ—¥å¿—æ€§èƒ½å½±å“
SELECT
    'Audit Log Performance' as test_name,
    AVG(EXTRACT(EPOCH FROM (timestamp - LAG(timestamp) OVER (ORDER BY timestamp)))) as avg_interval_ms
FROM audit_log
WHERE timestamp > NOW() - INTERVAL '1 hour';
```

**3. åˆè§„å®¡è®¡**:

```sql
-- ç”Ÿæˆåˆè§„å®¡è®¡æŠ¥å‘Š
CREATE OR REPLACE FUNCTION compliance_audit_report()
RETURNS TABLE (
    audit_category TEXT,
    requirement TEXT,
    implementation_status TEXT,
    test_result TEXT,
    compliance_status TEXT,
    notes TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        'Data Sovereignty'::TEXT,
        'All data must have sovereignty labels'::TEXT,
        CASE WHEN COUNT(data_sovereignty) = COUNT(*) THEN 'IMPLEMENTED' ELSE 'PARTIAL' END,
        CASE WHEN COUNT(data_sovereignty) = COUNT(*) THEN 'PASS' ELSE 'FAIL' END,
        CASE WHEN COUNT(data_sovereignty) = COUNT(*) THEN 'COMPLIANT' ELSE 'NON_COMPLIANT' END,
        format('%s out of %s records have sovereignty labels', COUNT(data_sovereignty), COUNT(*))::TEXT
    FROM user_data
    UNION ALL
    SELECT
        'Access Control'::TEXT,
        'Row-level security based on sovereignty'::TEXT,
        CASE WHEN EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'user_data') THEN 'IMPLEMENTED' ELSE 'NOT_IMPLEMENTED' END,
        'PASS'::TEXT,
        'COMPLIANT'::TEXT,
        'RLS policies are configured'::TEXT
    UNION ALL
    SELECT
        'Audit Trail'::TEXT,
        'All operations must be audited'::TEXT,
        CASE WHEN EXISTS (SELECT 1 FROM pg_trigger WHERE tgname LIKE '%audit%') THEN 'IMPLEMENTED' ELSE 'NOT_IMPLEMENTED' END,
        CASE WHEN COUNT(*) > 0 THEN 'PASS' ELSE 'FAIL' END,
        CASE WHEN COUNT(*) > 0 THEN 'COMPLIANT' ELSE 'NON_COMPLIANT' END,
        format('%s audit records in the last 24 hours', COUNT(*))::TEXT
    FROM audit_log
    WHERE timestamp > NOW() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql;

-- æŸ¥çœ‹å®¡è®¡æŠ¥å‘Š
SELECT * FROM compliance_audit_report();
```

---

## 3. æŠ€æœ¯å®ç°

### 3.1 å¯ç”¨ pg_dsr

```sql
-- å®‰è£…æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pg_dsr;

-- å¯ç”¨åˆè§„åŠŸèƒ½
SELECT pg_dsr.enable_compliance();
```

### 3.2 é…ç½®æ•°æ®ä¸»æƒ

```sql
-- é…ç½®ä¸»æƒæ ‡ç­¾
SELECT pg_dsr.set_sovereignty_tags(
    'user_data',
    ARRAY['EU', 'DE']
);
```

### 3.3 å¯ç”¨å®¡è®¡æ—¥å¿—

```sql
-- å¯ç”¨å®¡è®¡æ—¥å¿—
SELECT pg_dsr.enable_audit_log('user_data');
```

---

## 4. éªŒè¯æµ‹è¯•

### 4.1 åŠŸèƒ½æµ‹è¯•

```sql
-- æµ‹è¯•ä¸»æƒæ ‡ç­¾
SELECT * FROM user_data
WHERE data_sovereignty @> ARRAY['EU'];

-- æµ‹è¯•è®¿é—®æ§åˆ¶
SET user.country = 'US';
SELECT * FROM user_data;  -- åº”è¯¥è¢«æ‹¦æˆª
```

### 4.2 æ€§èƒ½æµ‹è¯•

```sql
-- æµ‹è¯•æ€§èƒ½å½±å“
EXPLAIN ANALYZE
SELECT * FROM user_data
WHERE data_sovereignty @> ARRAY['EU'];
```

---

## 5. æœ€ä½³å®è·µ

1. **åˆ†é˜¶æ®µå®æ–½**: åˆ†é˜¶æ®µå®æ–½ï¼Œé™ä½é£é™©
1. **æŒç»­ç›‘æ§**: æŒç»­ç›‘æ§åˆè§„çŠ¶æ€
1. **å®šæœŸå®¡è®¡**: å®šæœŸè¿›è¡Œåˆè§„å®¡è®¡

---

## 6. å‚è€ƒèµ„æ–™

- [AI Act è¦æ±‚è§£è¯»](./AI-Actè¦æ±‚è§£è¯».md)
- [åˆè§„æ£€æŸ¥æ¸…å•](./åˆè§„æ£€æŸ¥æ¸…å•.md)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
