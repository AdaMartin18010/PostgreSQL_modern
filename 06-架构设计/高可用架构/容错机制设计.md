# PostgreSQL 容错机制设计

> **更新时间**: 2025 年 11 月 1 日
> **技术版本**: PostgreSQL 14+, pgvector 0.7.0+
> **文档编号**: 06-04-03

## 📑 目录

- [PostgreSQL 容错机制设计](#postgresql-容错机制设计)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 技术背景](#11-技术背景)
    - [1.2 核心价值](#12-核心价值)
  - [2. 容错机制](#2-容错机制)
    - [2.1 连接容错](#21-连接容错)
    - [2.2 查询容错](#22-查询容错)
    - [2.3 事务容错](#23-事务容错)
  - [3. 故障检测](#3-故障检测)
    - [3.1 健康检查](#31-健康检查)
    - [3.2 故障检测](#32-故障检测)
  - [4. 自动恢复](#4-自动恢复)
    - [4.1 连接重试](#41-连接重试)
    - [4.2 查询重试](#42-查询重试)
  - [5. 实践案例](#5-实践案例)
    - [5.1 生产环境容错设计](#51-生产环境容错设计)
  - [6. 参考资料](#6-参考资料)

---

## 1. 概述

### 1.1 技术背景

**问题需求**:

PostgreSQL 容错机制需要：

- **故障隔离**: 隔离故障，防止级联故障
- **自动恢复**: 自动检测和恢复故障
- **数据一致性**: 保证数据一致性
- **服务可用性**: 提高服务可用性

**技术方案**:

- **连接池**: PgBouncer、pgpool-II
- **健康检查**: 定期健康检查
- **故障转移**: 自动故障转移

### 1.2 核心价值

- **可用性**: 提升至 99.99%
- **故障恢复**: 自动故障恢复
- **数据一致性**: 100% 数据一致性

## 2. 容错机制

### 2.1 连接容错

```python
# 连接池容错设计
import psycopg2
from psycopg2 import pool
import time

class FaultTolerantConnectionPool:
    def __init__(self, dsn, minconn=5, maxconn=20):
        self.dsn = dsn
        self.pool = psycopg2.pool.ThreadedConnectionPool(
            minconn, maxconn, dsn
        )
        self.retry_count = 3
        self.retry_delay = 1

    def get_connection(self):
        """获取连接（带重试）"""
        for attempt in range(self.retry_count):
            try:
                return self.pool.getconn()
            except Exception as e:
                if attempt < self.retry_count - 1:
                    time.sleep(self.retry_delay * (attempt + 1))
                    continue
                raise

    def execute_query(self, query, params=None):
        """执行查询（带重试）"""
        conn = None
        for attempt in range(self.retry_count):
            try:
                conn = self.get_connection()
                cursor = conn.cursor()
                cursor.execute(query, params)
                result = cursor.fetchall()
                conn.commit()
                return result
            except psycopg2.OperationalError as e:
                if attempt < self.retry_count - 1:
                    time.sleep(self.retry_delay * (attempt + 1))
                    if conn:
                        try:
                            conn.rollback()
                        except:
                            pass
                    continue
                raise
            finally:
                if conn:
                    self.pool.putconn(conn)
```

### 2.2 查询容错

```python
# 查询容错设计
class FaultTolerantQuery:
    def __init__(self, connection_pool):
        self.pool = connection_pool
        self.max_retries = 3
        self.timeout = 30

    def execute_with_retry(self, query, params=None):
        """执行查询（带重试和超时）"""
        for attempt in range(self.max_retries):
            try:
                conn = self.pool.get_connection()
                conn.set_session(timeout=self.timeout)
                cursor = conn.cursor()
                cursor.execute(query, params)
                result = cursor.fetchall()
                conn.commit()
                return result
            except psycopg2.errors.QueryCanceled:
                # 查询超时，重试
                if attempt < self.max_retries - 1:
                    time.sleep(1)
                    continue
                raise
            except psycopg2.errors.DeadlockDetected:
                # 死锁，重试
                if attempt < self.max_retries - 1:
                    time.sleep(0.1 * (attempt + 1))
                    continue
                raise
            finally:
                if conn:
                    try:
                        conn.rollback()
                    except:
                        pass
                    self.pool.putconn(conn)
```

### 2.3 事务容错

```python
# 事务容错设计
class FaultTolerantTransaction:
    def __init__(self, connection_pool):
        self.pool = connection_pool

    @contextmanager
    def transaction(self):
        """事务上下文（带自动回滚）"""
        conn = None
        try:
            conn = self.pool.get_connection()
            yield conn
            conn.commit()
        except Exception as e:
            if conn:
                conn.rollback()
            raise
        finally:
            if conn:
                self.pool.putconn(conn)

    def execute_transaction(self, operations):
        """执行事务操作（带重试）"""
        for attempt in range(3):
            try:
                with self.transaction() as conn:
                    cursor = conn.cursor()
                    for operation in operations:
                        cursor.execute(operation['query'], operation.get('params'))
                    return True
            except psycopg2.errors.SerializationFailure:
                # 序列化失败，重试
                if attempt < 2:
                    time.sleep(0.1 * (attempt + 1))
                    continue
                raise
```

## 3. 故障检测

### 3.1 健康检查

```python
# 健康检查设计
class HealthChecker:
    def __init__(self, connection_pool, check_interval=30):
        self.pool = connection_pool
        self.check_interval = check_interval
        self.is_healthy = True

    def check_health(self):
        """健康检查"""
        try:
            conn = self.pool.get_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            cursor.fetchone()
            self.pool.putconn(conn)
            self.is_healthy = True
            return True
        except Exception as e:
            self.is_healthy = False
            return False

    def start_monitoring(self):
        """启动健康检查监控"""
        import threading
        def monitor():
            while True:
                self.check_health()
                time.sleep(self.check_interval)
        thread = threading.Thread(target=monitor, daemon=True)
        thread.start()
```

### 3.2 故障检测

```sql
-- 数据库故障检测查询
SELECT
    CASE
        WHEN pg_is_in_recovery() THEN 'standby'
        ELSE 'primary'
    END AS role,
    pg_is_in_recovery() AS is_recovery,
    (SELECT count(*) FROM pg_stat_activity WHERE state = 'active') AS active_connections,
    (SELECT count(*) FROM pg_stat_activity WHERE wait_event_type IS NOT NULL) AS waiting_queries;

-- 检查复制延迟
SELECT
    client_addr,
    state,
    sync_state,
    pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) AS replication_lag_bytes
FROM pg_stat_replication;
```

## 4. 自动恢复

### 4.1 连接重试

```python
# 自动连接重试
class AutoRetryConnection:
    def __init__(self, dsn, max_retries=5, retry_delay=1):
        self.dsn = dsn
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.conn = None

    def connect(self):
        """连接数据库（带重试）"""
        for attempt in range(self.max_retries):
            try:
                self.conn = psycopg2.connect(self.dsn)
                return self.conn
            except psycopg2.OperationalError as e:
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay * (attempt + 1))
                    continue
                raise

    def ensure_connection(self):
        """确保连接可用"""
        if self.conn is None or self.conn.closed:
            self.connect()
        else:
            try:
                cursor = self.conn.cursor()
                cursor.execute("SELECT 1")
            except:
                self.connect()
```

### 4.2 查询重试

```python
# 查询自动重试
def execute_with_auto_retry(query, params=None, max_retries=3):
    """执行查询（自动重试）"""
    for attempt in range(max_retries):
        try:
            conn = get_connection()
            cursor = conn.cursor()
            cursor.execute(query, params)
            result = cursor.fetchall()
            conn.commit()
            return result
        except (psycopg2.OperationalError, psycopg2.InterfaceError) as e:
            # 连接错误，重试
            if attempt < max_retries - 1:
                time.sleep(1 * (attempt + 1))
                continue
            raise
        except psycopg2.errors.DeadlockDetected:
            # 死锁，重试
            if attempt < max_retries - 1:
                time.sleep(0.1 * (attempt + 1))
                continue
            raise
        finally:
            if conn:
                try:
                    conn.rollback()
                except:
                    pass
                release_connection(conn)
```

## 5. 实践案例

### 5.1 生产环境容错设计

**案例背景**:

某企业生产环境（2025 年 11 月）：

- **数据规模**: 1TB 数据
- **查询 QPS**: 10,000+
- **需求**: 99.99% 可用性

**实现方案**:

```python
# 生产环境容错设计
class ProductionFaultTolerance:
    def __init__(self):
        # 连接池配置
        self.primary_pool = FaultTolerantConnectionPool(
            dsn="host=primary dbname=mydb",
            minconn=10,
            maxconn=50
        )
        self.standby_pool = FaultTolerantConnectionPool(
            dsn="host=standby dbname=mydb",
            minconn=5,
            maxconn=20
        )

        # 健康检查
        self.health_checker = HealthChecker(self.primary_pool)
        self.health_checker.start_monitoring()

    def execute_query(self, query, params=None, use_read_replica=False):
        """执行查询（自动故障转移）"""
        pool = self.standby_pool if use_read_replica else self.primary_pool

        try:
            return pool.execute_query(query, params)
        except psycopg2.OperationalError:
            # 主节点故障，切换到备用节点
            if not use_read_replica:
                return self.standby_pool.execute_query(query, params)
            raise
```

**效果**:

- **可用性**: 99.99% SLA
- **故障恢复**: 自动故障恢复
- **数据一致性**: 100% 数据一致性

## 6. 参考资料

- [高可用架构设计](./高可用架构设计.md)
- [灾难恢复方案](./灾难恢复方案.md)
- [企业级架构设计](../系统架构/企业级架构设计.md)

---

**最后更新**: 2025 年 11 月 1 日
**维护者**: PostgreSQL Modern Team
**文档编号**: 06-04-03
