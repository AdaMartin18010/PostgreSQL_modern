# å¤šæ¨¡æ•°æ®æ¨¡å‹è®¾è®¡

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› PostgreSQL 18 å¤šæ¨¡æ•°æ®æ¨¡å‹è®¾è®¡æŒ‡å—ï¼Œæ¶µç›– JSONBã€æ—¶åºã€å›¾ã€å‘é‡å››ç§æ•°æ®æ¨¡å‹çš„ç»Ÿä¸€è®¾è®¡ã€‚

## ğŸ¯ è®¾è®¡åŸåˆ™

### 1. ç»Ÿä¸€æ•°æ®æ¨¡å‹

- **å•è¡¨å¤šæ¨¡**: åŒä¸€è¡¨æ”¯æŒå¤šç§æ•°æ®æ¨¡å‹
- **ç»Ÿä¸€æŸ¥è¯¢**: ä¸€æ¡ SQL æŸ¥è¯¢å¤šç§æ•°æ®æ¨¡å‹
- **å…±äº«ç´¢å¼•**: ä¸åŒæ•°æ®æ¨¡å‹å…±äº«ç´¢å¼•ç»“æ„
- **å…±ç°‡å­˜å‚¨**: ç›¸å…³æ•°æ®å…±ç°‡å­˜å‚¨æé«˜æ€§èƒ½

### 2. æ€§èƒ½ä¼˜åŒ–

- **åˆ†åŒºç­–ç•¥**: æŒ‰ä¸šåŠ¡é€»è¾‘åˆ†åŒº
- **ç´¢å¼•ç­–ç•¥**: é’ˆå¯¹ä¸åŒæ•°æ®ç±»å‹ä¼˜åŒ–ç´¢å¼•
- **å­˜å‚¨ç­–ç•¥**: çƒ­æ•°æ®è¡Œå­˜ï¼Œå†·æ•°æ®åˆ—å­˜

## ğŸ—ï¸ æ•°æ®æ¨¡å‹æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Application Layer                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ ä¸šåŠ¡åº”ç”¨  â”‚  â”‚ AIåº”ç”¨   â”‚  â”‚ åˆ†æåº”ç”¨  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         PostgreSQL 18 Multi-Model               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚      Unified Table Schema                â”‚   â”‚
â”‚  â”‚  - JSONB Fields (Document)               â”‚   â”‚
â”‚  â”‚  - Time-Series Fields                    â”‚   â”‚
â”‚  â”‚  - Vector Fields                         â”‚   â”‚
â”‚  â”‚  - Graph Relationships                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚      Unified Index Strategy              â”‚   â”‚
â”‚  â”‚  - GIN Index (JSONB)                     â”‚   â”‚
â”‚  â”‚  - B-Tree Index (Time)                   â”‚   â”‚
â”‚  â”‚  - HNSW Index (Vector)                   â”‚   â”‚
â”‚  â”‚  - AGE Index (Graph)                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» è®¾è®¡æ¨¡å¼

### æ¨¡å¼ 1: IoT è®¾å¤‡æ•°æ®æ¨¡å‹

```sql
-- åˆ›å»ºè®¾å¤‡æ•°æ®è¡¨ï¼ˆJSONB + æ—¶åº + å‘é‡ï¼‰
CREATE TABLE device_metrics (
    time TIMESTAMPTZ NOT NULL,
    device_id TEXT NOT NULL,

    -- JSONB: è®¾å¤‡å…ƒæ•°æ®å’ŒåŠ¨æ€å±æ€§
    metadata JSONB,
    config JSONB,

    -- æ—¶åºæ•°æ®: ä¼ æ„Ÿå™¨è¯»æ•°
    temperature NUMERIC,
    humidity NUMERIC,
    pressure NUMERIC,
    vibration NUMERIC,

    -- å‘é‡: è®¾å¤‡çŠ¶æ€å‘é‡ï¼ˆç”¨äºå¼‚å¸¸æ£€æµ‹ï¼‰
    state_vector vector(128),

    -- ä¼ ç»Ÿå­—æ®µ
    location POINT,
    status TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- è½¬æ¢ä¸ºè¶…è¡¨ï¼ˆTimescaleDBï¼‰
SELECT create_hypertable('device_metrics', 'time');

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON device_metrics (device_id, time DESC);
CREATE INDEX ON device_metrics USING GIN (metadata);
CREATE INDEX ON device_metrics USING GIN (config);
CREATE INDEX ON device_metrics USING hnsw (state_vector vector_cosine_ops);
```

### æ¨¡å¼ 2: ç”µå•†å•†å“æ•°æ®æ¨¡å‹

```sql
-- åˆ›å»ºå•†å“è¡¨ï¼ˆJSONB + å‘é‡ï¼‰
CREATE TABLE products (
    id SERIAL PRIMARY KEY,

    -- JSONB: å•†å“è¯¦ç»†ä¿¡æ¯
    details JSONB,  -- {category, brand, specs, ...}
    pricing JSONB,  -- {price, discount, currency, ...}
    inventory JSONB,  -- {stock, warehouse, ...}

    -- ä¼ ç»Ÿå­—æ®µï¼ˆç”¨äºç´¢å¼•ï¼‰
    name TEXT,
    category TEXT,
    price NUMERIC,

    -- å‘é‡: å•†å“è¯­ä¹‰å‘é‡ï¼ˆç”¨äºæ¨èï¼‰
    embedding vector(768),

    -- æ—¶é—´å­—æ®µ
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON products USING GIN (details);
CREATE INDEX ON products USING GIN (pricing);
CREATE INDEX ON products (category, price);
CREATE INDEX ON products USING GIN (to_tsvector('english', name || ' ' || COALESCE((details->>'description')::TEXT, '')));
CREATE INDEX ON products USING hnsw (embedding vector_cosine_ops);
```

### æ¨¡å¼ 3: çŸ¥è¯†å›¾è°±æ•°æ®æ¨¡å‹

```sql
-- åŠ è½½ AGE æ‰©å±•
LOAD 'age';
SET search_path = ag_catalog, "$user", public;

-- åˆ›å»ºå›¾
SELECT create_graph('knowledge_graph');

-- åˆ›å»ºèŠ‚ç‚¹è¡¨ï¼ˆå¸¦å‘é‡ï¼‰
SELECT * FROM cypher('knowledge_graph', $$
    CREATE (:Document {
        id: 'doc1',
        title: 'PostgreSQL Guide',
        content: '...',
        embedding: [0.1, 0.2, 0.3, ...],
        metadata: {author: 'John', date: '2025-11-01'}
    })
$$);

-- åˆ›å»ºè¾¹ï¼ˆå…³ç³»ï¼‰
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (a:Document), (b:Document)
    WHERE a.id = 'doc1' AND b.id = 'doc2'
    CREATE (a)-[:RELATED {
        weight: 0.8,
        type: 'reference'
    }]->(b)
$$);

-- å‘é‡ç›¸ä¼¼åº¦æŸ¥è¯¢
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (d:Document)
    WHERE d.embedding <=> query_vector < 0.3
    RETURN d
    ORDER BY d.embedding <=> query_vector
    LIMIT 10
$$);
```

## ğŸ” æ··åˆæŸ¥è¯¢æ¨¡å¼

### 1. JSONB + å‘é‡ + å…¨æ–‡æœç´¢

```sql
-- æ··åˆæœç´¢ï¼šJSONBè¿‡æ»¤ + å…¨æ–‡æœç´¢ + å‘é‡æœç´¢
WITH text_search AS (
    SELECT
        id,
        name,
        details,
        ts_rank(to_tsvector('english', name || ' ' ||
                           COALESCE((details->>'description')::TEXT, '')),
                to_tsquery('english', 'PostgreSQL')) as text_score,
        ROW_NUMBER() OVER (ORDER BY text_score DESC) as text_rank
    FROM products
    WHERE to_tsvector('english', name || ' ' ||
                     COALESCE((details->>'description')::TEXT, '')) @@
          to_tsquery('english', 'PostgreSQL')
        AND details @> '{"category": "database"}'
    LIMIT 100
),
vector_search AS (
    SELECT
        id,
        name,
        details,
        1 - (embedding <=> query_vector) as vector_score,
        ROW_NUMBER() OVER (ORDER BY vector_score DESC) as vector_rank
    FROM products
    WHERE details @> '{"category": "database"}'
    ORDER BY embedding <=> query_vector
    LIMIT 100
),
rrf_fusion AS (
    SELECT
        COALESCE(t.id, v.id) as id,
        COALESCE(t.name, v.name) as name,
        (1.0 / (60 + COALESCE(t.text_rank, 999))) +
        (1.0 / (60 + COALESCE(v.vector_rank, 999))) as rrf_score
    FROM text_search t
    FULL OUTER JOIN vector_search v ON t.id = v.id
)
SELECT id, name, rrf_score
FROM rrf_fusion
ORDER BY rrf_score DESC
LIMIT 10;
```

### 2. æ—¶åº + å‘é‡æ··åˆåˆ†æ

```sql
-- æ—¶åº+å‘é‡æ··åˆå¼‚å¸¸æ£€æµ‹
WITH recent_metrics AS (
    SELECT
        device_id,
        time,
        temperature,
        vibration,
        state_vector
    FROM device_metrics
    WHERE time > NOW() - INTERVAL '1 hour'
        AND device_id = 'device-001'
    ORDER BY time DESC
    LIMIT 1000
),
normal_pattern AS (
    SELECT
        AVG(state_vector)::vector(128) as avg_vector
    FROM device_metrics
    WHERE time > NOW() - INTERVAL '30 days'
        AND device_id = 'device-001'
        AND metadata->>'status' = 'normal'
),
anomaly_detection AS (
    SELECT
        rm.device_id,
        rm.time,
        rm.temperature,
        rm.vibration,
        1 - (rm.state_vector <=> np.avg_vector) as similarity,
        CASE
            WHEN 1 - (rm.state_vector <=> np.avg_vector) < 0.7 THEN true
            ELSE false
        END as is_anomaly
    FROM recent_metrics rm
    CROSS JOIN normal_pattern np
)
SELECT
    device_id,
    time,
    temperature,
    vibration,
    similarity,
    is_anomaly
FROM anomaly_detection
WHERE is_anomaly = true
ORDER BY time DESC;
```

### 3. å›¾ + å‘é‡æ··åˆæ£€ç´¢

```sql
-- å›¾+å‘é‡æ··åˆæ£€ç´¢ï¼ˆé‡‘èåæ¬ºè¯ˆï¼‰
WITH suspicious_paths AS (
    SELECT * FROM cypher('transaction_graph', $$
        MATCH path = (a:Account)-[:TRANSFER*2..5]->(b:Account)
        WHERE a.risk_score > 0.8
        RETURN
            a.account_id as source_account,
            b.account_id as target_account,
            length(path) as path_length,
            sum([r in relationships(path) | r.risk_score]) as path_risk_score
        LIMIT 100
    $$)
),
account_vectors AS (
    SELECT account_id, behavior_vector
    FROM account_behaviors
    WHERE account_id IN (
        SELECT DISTINCT source_account FROM suspicious_paths
        UNION
        SELECT DISTINCT target_account FROM suspicious_paths
    )
),
similar_accounts AS (
    SELECT
        av1.account_id as account1,
        av2.account_id as account2,
        1 - (av1.behavior_vector <=> av2.behavior_vector) as similarity
    FROM account_vectors av1
    CROSS JOIN account_vectors av2
    WHERE av1.account_id < av2.account_id
        AND av1.behavior_vector <=> av2.behavior_vector < 0.2
),
combined_scores AS (
    SELECT
        sp.source_account,
        sp.target_account,
        sp.path_length,
        sp.path_risk_score,
        -- å›¾ç»“æ„é£é™©åˆ†æ•°
        (1.0 / sp.path_length) * sp.path_risk_score as graph_score,
        -- å‘é‡ç›¸ä¼¼åº¦é£é™©åˆ†æ•°
        COALESCE(sa.similarity * 0.8, 0) as vector_score,
        -- ç»¼åˆé£é™©åˆ†æ•°
        (1.0 / sp.path_length) * sp.path_risk_score * 0.6 +
        COALESCE(sa.similarity * 0.8, 0) * 0.4 as combined_risk_score
    FROM suspicious_paths sp
    LEFT JOIN similar_accounts sa ON
        (sa.account1 = sp.source_account AND sa.account2 = sp.target_account) OR
        (sa.account2 = sp.source_account AND sa.account1 = sp.target_account)
)
SELECT
    source_account,
    target_account,
    path_length,
    graph_score,
    vector_score,
    combined_risk_score
FROM combined_scores
WHERE combined_risk_score > 0.7
ORDER BY combined_risk_score DESC
LIMIT 20;
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. åˆ†åŒºç­–ç•¥

```sql
-- æŒ‰æ—¶é—´åˆ†åŒºï¼ˆæ—¶åºæ•°æ®ï¼‰
CREATE TABLE device_metrics (
    time TIMESTAMPTZ NOT NULL,
    device_id TEXT NOT NULL,
    metrics JSONB,
    state_vector vector(128)
) PARTITION BY RANGE (time);

-- åˆ›å»ºåˆ†åŒº
CREATE TABLE device_metrics_2025_11 PARTITION OF device_metrics
FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

-- åœ¨åˆ†åŒºä¸Šåˆ›å»ºç´¢å¼•
CREATE INDEX ON device_metrics_2025_11
USING hnsw (state_vector vector_cosine_ops);
```

### 2. ç‰©åŒ–è§†å›¾ä¼˜åŒ–

```sql
-- åˆ›å»ºç‰©åŒ–è§†å›¾é¢„è®¡ç®—æ··åˆæŸ¥è¯¢ç»“æœ
CREATE MATERIALIZED VIEW device_anomaly_cache AS
SELECT
    device_id,
    time_bucket('1 hour', time) as hour,
    AVG(temperature) as avg_temp,
    AVG(vibration) as avg_vibration,
    AVG(state_vector)::vector(128) as avg_vector,
    COUNT(*) as metric_count
FROM device_metrics
GROUP BY device_id, hour;

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON device_anomaly_cache (device_id, hour DESC);

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY device_anomaly_cache;
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. æ•°æ®ç±»å‹é€‰æ‹©

- **JSONB**: åŠç»“æ„åŒ–æ•°æ®ã€åŠ¨æ€å­—æ®µã€é…ç½®ä¿¡æ¯
- **Timescale**: æ—¶åºæ•°æ®ã€IoT æŒ‡æ ‡ã€ç›‘æ§æ•°æ®
- **pgvector**: å‘é‡æ•°æ®ã€è¯­ä¹‰æœç´¢ã€æ¨èç³»ç»Ÿ
- **Apache AGE**: å›¾æ•°æ®ã€å…³ç³»åˆ†æã€çŸ¥è¯†å›¾è°±

### 2. ç´¢å¼•ç­–ç•¥

- **JSONB**: GIN ç´¢å¼•ç”¨äº JSONB æŸ¥è¯¢
- **æ—¶åº**: æ—¶é—´å­—æ®µç´¢å¼• + TimescaleDB åˆ†åŒº
- **å‘é‡**: HNSW æˆ– IVFFlat ç´¢å¼•
- **å›¾**: AGE è‡ªåŠ¨ç®¡ç†å›¾ç´¢å¼•

### 3. æŸ¥è¯¢ä¼˜åŒ–

- **é¿å…è·¨æ¨¡å‹ JOIN**: å°½é‡åœ¨å•è¡¨å†…å®ŒæˆæŸ¥è¯¢
- **ä½¿ç”¨ç‰©åŒ–è§†å›¾**: é¢„è®¡ç®—å¤æ‚æ··åˆæŸ¥è¯¢
- **åˆ†åŒºè£å‰ª**: åˆ©ç”¨ TimescaleDB åˆ†åŒºä¼˜åŒ–
- **ç´¢å¼•ç»„åˆ**: åˆç†ç»„åˆä¸åŒç´¢å¼•ç±»å‹

## ğŸ“š å‚è€ƒèµ„æ–™

- [PostgreSQL 18 æ–°ç‰¹æ€§](../04-å¤šæ¨¡ä¸€ä½“åŒ–/PostgreSQL-18æ–°ç‰¹æ€§/å¼‚æ­¥I-Oæœºåˆ¶.md)
- [å¤šæ¨¡æ•°æ®æ¨¡å‹è®¾è®¡](../04-å¤šæ¨¡ä¸€ä½“åŒ–/æŠ€æœ¯åŸç†/å¤šæ¨¡æ•°æ®æ¨¡å‹è®¾è®¡.md)
- [TimescaleDB æ–‡æ¡£](https://docs.timescale.com/)
- [Apache AGE æ–‡æ¡£](https://age.apache.org/)

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥  
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
