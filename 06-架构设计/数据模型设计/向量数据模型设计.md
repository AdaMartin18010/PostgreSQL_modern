# 向量数据模型设计

> **更新时间**: 2025 年 11 月 1 日
> **技术版本**: PostgreSQL 14+, pgvector 0.7.0+
> **文档编号**: 06-02-02

## 📑 目录

- [向量数据模型设计](#向量数据模型设计)
  - [📑 目录](#-目录)
  - [1. 概述](#1-概述)
    - [1.1 技术背景](#11-技术背景)
    - [1.2 核心价值](#12-核心价值)
  - [2. 数据模型设计](#2-数据模型设计)
    - [2.1 基础向量表设计](#21-基础向量表设计)
    - [2.2 多模态向量表设计](#22-多模态向量表设计)
    - [2.3 向量元数据设计](#23-向量元数据设计)
  - [3. 索引策略](#3-索引策略)
    - [3.1 HNSW 索引](#31-hnsw-索引)
    - [3.2 IVFFlat 索引](#32-ivfflat-索引)
    - [3.3 混合索引策略](#33-混合索引策略)
  - [4. 查询优化](#4-查询优化)
    - [4.1 向量查询优化](#41-向量查询优化)
    - [4.2 混合查询优化](#42-混合查询优化)
  - [5. 最佳实践](#5-最佳实践)
    - [5.1 表设计建议](#51-表设计建议)
    - [5.2 查询优化建议](#52-查询优化建议)
  - [6. 参考资料](#6-参考资料)

---

## 1. 概述

### 1.1 技术背景

**问题需求**:

向量数据模型设计需要：

- **高效存储**: 高效存储高维向量数据
- **快速查询**: 毫秒级向量相似度查询
- **灵活扩展**: 支持不同维度的向量
- **元数据管理**: 管理向量相关的元数据

**技术方案**:

- **pgvector**: PostgreSQL 向量扩展
- **HNSW/IVFFlat**: 向量索引算法
- **JSONB**: 元数据存储

### 1.2 核心价值

- **查询性能**: 毫秒级查询响应
- **存储效率**: 高效存储向量数据
- **灵活性**: 支持多种向量维度

## 2. 数据模型设计

### 2.1 基础向量表设计

```sql
-- 基础向量表设计
CREATE TABLE vectors (
    id SERIAL PRIMARY KEY,
    embedding vector(1536),  -- 向量维度
    metadata JSONB,          -- 元数据
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 创建元数据索引
CREATE INDEX ON vectors USING GIN (metadata);
```

### 2.2 多模态向量表设计

```sql
-- 多模态向量表（文本 + 图像）
CREATE TABLE multimodal_vectors (
    id SERIAL PRIMARY KEY,
    text_embedding vector(1536),    -- 文本向量
    image_embedding vector(2048),    -- 图像向量
    content TEXT,                    -- 原始内容
    content_type TEXT,              -- 内容类型
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 创建多向量索引
CREATE INDEX ON multimodal_vectors USING hnsw (text_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

CREATE INDEX ON multimodal_vectors USING hnsw (image_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

### 2.3 向量元数据设计

```sql
-- 向量元数据表设计
CREATE TABLE vector_metadata (
    vector_id INTEGER REFERENCES vectors(id),
    source_type TEXT,        -- 数据源类型
    source_id TEXT,          -- 数据源 ID
    tags TEXT[],             -- 标签
    attributes JSONB,        -- 属性
    created_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX ON vector_metadata (vector_id);
CREATE INDEX ON vector_metadata USING GIN (tags);
CREATE INDEX ON vector_metadata USING GIN (attributes);
```

## 3. 索引策略

### 3.1 HNSW 索引

```sql
-- HNSW 索引（适合高精度查询）
CREATE INDEX ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 16,              -- 每个节点的最大连接数
    ef_construction = 64 -- 构建时的候选数
);

-- 查询时设置参数
SET hnsw.ef_search = 100;  -- 搜索时的候选数
```

### 3.2 IVFFlat 索引

```sql
-- IVFFlat 索引（适合大规模数据）
CREATE INDEX ON vectors USING ivfflat (embedding vector_cosine_ops)
WITH (
    lists = 1000  -- 聚类中心数
);

-- 注意：需要先有数据才能创建 IVFFlat 索引
```

### 3.3 混合索引策略

```sql
-- 混合索引策略：HNSW + 元数据索引
CREATE INDEX ON vectors USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

CREATE INDEX ON vectors USING GIN (metadata);
CREATE INDEX ON vectors (created_at);

-- 混合查询：向量 + 元数据过滤
SELECT
    id,
    metadata,
    1 - (embedding <=> $1::vector) AS similarity
FROM vectors
WHERE metadata @> '{"category": "technology"}'::jsonb
  AND created_at > NOW() - INTERVAL '30 days'
  AND 1 - (embedding <=> $1::vector) > 0.8
ORDER BY embedding <=> $1::vector
LIMIT 10;
```

## 4. 查询优化

### 4.1 向量查询优化

```sql
-- 1. 使用索引提示
SET enable_seqscan = off;

-- 2. 限制查询结果
SELECT
    id,
    1 - (embedding <=> $1::vector) AS similarity
FROM vectors
WHERE 1 - (embedding <=> $1::vector) > 0.8
ORDER BY embedding <=> $1::vector
LIMIT 100;

-- 3. 批量查询优化
WITH query_vectors AS (
    SELECT unnest($1::vector[]) AS query_vector
)
SELECT
    v.id,
    qv.query_vector,
    1 - (v.embedding <=> qv.query_vector) AS similarity
FROM vectors v
CROSS JOIN query_vectors qv
WHERE 1 - (v.embedding <=> qv.query_vector) > 0.8
ORDER BY v.embedding <=> qv.query_vector
LIMIT 100;
```

### 4.2 混合查询优化

```sql
-- 向量 + 全文搜索混合查询
SELECT
    v.id,
    v.metadata,
    1 - (v.embedding <=> $1::vector) AS vector_similarity,
    ts_rank(to_tsvector('english', v.metadata->>'content'),
            plainto_tsquery('english', $2)) AS text_rank
FROM vectors v
WHERE 1 - (v.embedding <=> $1::vector) > 0.7
  AND to_tsvector('english', v.metadata->>'content') @@
      plainto_tsquery('english', $2)
ORDER BY
    (1 - (v.embedding <=> $1::vector)) * 0.7 +
    ts_rank(to_tsvector('english', v.metadata->>'content'),
            plainto_tsquery('english', $2)) * 0.3 DESC
LIMIT 10;
```

## 5. 最佳实践

### 5.1 表设计建议

1. **向量维度**: 根据应用需求选择合适的维度（128/256/512/1536）
2. **元数据存储**: 使用 JSONB 存储灵活的元数据
3. **索引选择**:
   - 小规模数据（<100万）: HNSW
   - 大规模数据（>100万）: IVFFlat
   - 高精度需求: HNSW

### 5.2 查询优化建议

1. **相似度阈值**: 设置合理的相似度阈值（>0.7）
2. **结果限制**: 使用 LIMIT 限制返回结果数量
3. **索引参数**: 根据数据规模调整索引参数

## 6. 参考资料

- [多模数据模型设计](./多模数据模型设计.md)
- [图数据模型设计](./图数据模型设计.md)
- [pgvector 核心原理](../../01-向量与混合搜索/技术原理/pgvector核心原理.md)

---

**最后更新**: 2025 年 11 月 1 日
**维护者**: PostgreSQL Modern Team
**文档编号**: 06-02-02
