# 可串行化理论 - PostgreSQL MVCC形式化论证

> **文档编号**: THEORY-SERIALIZABILITY-001
> **主题**: 可串行化理论
> **版本**: PostgreSQL 17 & 18

---

## 📑 目录

- [可串行化理论 - PostgreSQL MVCC形式化论证](#可串行化理论---postgresql-mvcc形式化论证)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [🔍 第一部分：可串行化定义](#-第一部分可串行化定义)
    - [1.1 基本定义](#11-基本定义)
      - [事务历史](#事务历史)
      - [串行历史](#串行历史)
      - [可串行化历史](#可串行化历史)
    - [1.2 等价性](#12-等价性)
      - [结果等价](#结果等价)
      - [视图等价](#视图等价)
      - [冲突等价](#冲突等价)
  - [🚀 第二部分：冲突可串行化](#-第二部分冲突可串行化)
    - [2.1 冲突操作](#21-冲突操作)
      - [读写冲突](#读写冲突)
      - [写读冲突](#写读冲突)
      - [写写冲突](#写写冲突)
    - [2.2 冲突图](#22-冲突图)
      - [冲突图构建](#冲突图构建)
      - [可串行化判定](#可串行化判定)
    - [2.3 形式化证明](#23-形式化证明)
      - [冲突可串行化定理](#冲突可串行化定理)
      - [证明过程](#证明过程)
  - [📊 第三部分：视图可串行化](#-第三部分视图可串行化)
    - [3.1 视图等价定义](#31-视图等价定义)
      - [读视图](#读视图)
      - [最终写](#最终写)
    - [3.2 视图可串行化判定](#32-视图可串行化判定)
      - [视图图](#视图图)
      - [判定算法](#判定算法)
    - [3.3 PostgreSQL实现](#33-postgresql实现)
      - [快照隔离](#快照隔离)
      - [SSI机制](#ssi机制)
  - [🔧 第四部分：实际案例分析](#-第四部分实际案例分析)
    - [4.1 冲突可串行化案例](#41-冲突可串行化案例)
    - [4.2 视图可串行化案例](#42-视图可串行化案例)
    - [4.3 不可串行化案例](#43-不可串行化案例)
  - [📝 总结](#-总结)
    - [核心理论](#核心理论)
    - [形式化关系](#形式化关系)
    - [PostgreSQL实现](#postgresql实现)
    - [应用场景](#应用场景)

---

## 📋 概述

可串行化是并发控制的核心理论，保证并发执行的事务结果与某种串行执行的结果等价。本文档深入分析可串行化理论，包括冲突可串行化和视图可串行化，并提供形式化证明。

---

## 🔍 第一部分：可串行化定义

### 1.1 基本定义

#### 事务历史

```text
事务历史 H = (T₁, T₂, ..., Tₙ, <)

其中：
- Tᵢ：事务i的操作序列
- <：操作间的偏序关系（happens-before）

操作类型：
- rᵢ[x]：事务Tᵢ读取数据项x
- wᵢ[x]：事务Tᵢ写入数据项x
- cᵢ：事务Tᵢ提交
- aᵢ：事务Tᵢ中止
```

#### 串行历史

```text
串行历史 S：
- 所有事务的操作完全串行执行
- 不存在并发操作

形式化定义：
S = T₁; T₂; ...; Tₙ

其中：
- Tᵢ的所有操作在Tᵢ₊₁之前完成
- 不存在操作重叠
```

#### 可串行化历史

```text
可串行化历史 H：
- 存在串行历史S，使得H与S等价
- 等价性包括：结果等价、视图等价、冲突等价

形式化定义：
H ≈ S（H等价于S）

其中：
- ≈：等价关系
- S：串行历史
```

### 1.2 等价性

#### 结果等价

```text
结果等价：
- 两个历史产生相同的最终状态
- 所有数据项的最终值相同

形式化定义：
H₁ ≈ᵣ H₂ ⟺ ∀x: final_value(H₁, x) = final_value(H₂, x)

其中：
- ≈ᵣ：结果等价
- final_value(H, x)：历史H中数据项x的最终值
```

#### 视图等价

```text
视图等价：
- 每个事务读取相同的值
- 每个数据项的最终写入者相同

形式化定义：
H₁ ≈ᵥ H₂ ⟺
  (∀Tᵢ: read_set(H₁, Tᵢ) = read_set(H₂, Tᵢ)) ∧
  (∀x: final_writer(H₁, x) = final_writer(H₂, x))

其中：
- ≈ᵥ：视图等价
- read_set(H, Tᵢ)：事务Tᵢ读取的数据项集合
- final_writer(H, x)：数据项x的最终写入者
```

#### 冲突等价

```text
冲突等价：
- 冲突操作的相对顺序相同
- 非冲突操作可以重排序

形式化定义：
H₁ ≈c H₂ ⟺
  ∀conflicting ops o₁, o₂:
    o₁ <H₁ o₂ ⟺ o₁ <H₂ o₂

其中：
- ≈c：冲突等价
- conflicting ops：冲突操作对
```

---

## 🚀 第二部分：冲突可串行化

### 2.1 冲突操作

#### 读写冲突

```text
读写冲突（Read-Write Conflict）：
- 事务Tᵢ读取数据项x
- 事务Tⱼ写入数据项x（i ≠ j）
- 操作顺序影响结果

形式化定义：
rᵢ[x] 与 wⱼ[x] 冲突 ⟺ i ≠ j

冲突顺序：
- rᵢ[x] < wⱼ[x]：Tᵢ读取旧值
- wⱼ[x] < rᵢ[x]：Tᵢ读取新值
```

#### 写读冲突

```text
写读冲突（Write-Read Conflict）：
- 事务Tᵢ写入数据项x
- 事务Tⱼ读取数据项x（i ≠ j）
- 操作顺序影响结果

形式化定义：
wᵢ[x] 与 rⱼ[x] 冲突 ⟺ i ≠ j

冲突顺序：
- wᵢ[x] < rⱼ[x]：Tⱼ读取Tᵢ的写入
- rⱼ[x] < wᵢ[x]：Tⱼ读取旧值
```

#### 写写冲突

```text
写写冲突（Write-Write Conflict）：
- 事务Tᵢ写入数据项x
- 事务Tⱼ写入数据项x（i ≠ j）
- 操作顺序影响最终值

形式化定义：
wᵢ[x] 与 wⱼ[x] 冲突 ⟺ i ≠ j

冲突顺序：
- wᵢ[x] < wⱼ[x]：Tⱼ的写入覆盖Tᵢ的写入
- wⱼ[x] < wᵢ[x]：Tᵢ的写入覆盖Tⱼ的写入
```

### 2.2 冲突图

#### 冲突图构建

```text
冲突图（Conflict Graph）G = (V, E)：

顶点V：
- 每个事务Tᵢ对应一个顶点vᵢ

边E：
- 如果存在冲突操作oᵢ和oⱼ，且oᵢ < oⱼ
- 则添加边 vᵢ → vⱼ

形式化定义：
E = {(vᵢ, vⱼ) | ∃x:
  (rᵢ[x] < wⱼ[x]) ∨
  (wᵢ[x] < rⱼ[x]) ∨
  (wᵢ[x] < wⱼ[x])}
```

#### 可串行化判定

```text
冲突可串行化判定定理：
历史H是冲突可串行化的 ⟺ 冲突图G是无环的（DAG）

证明思路：
1. 如果G有环，则存在循环依赖，无法串行化
2. 如果G无环，则存在拓扑排序，对应串行历史

算法：
1. 构建冲突图G
2. 检查G是否有环（DFS/BFS）
3. 如果无环，则拓扑排序得到串行顺序
```

### 2.3 形式化证明

#### 冲突可串行化定理

```text
定理：历史H是冲突可串行化的 ⟺ 冲突图G是无环的

证明（⟹）：
假设H是冲突可串行化的，存在串行历史S使得H ≈c S。
如果G有环：v₁ → v₂ → ... → vₖ → v₁
则存在冲突操作序列：
  o₁ < o₂ < ... < oₖ < o₁
这与偏序关系的传递性和反对称性矛盾。
因此G必须无环。

证明（⟸）：
假设G无环，则存在拓扑排序：vᵢ₁, vᵢ₂, ..., vᵢₙ
构造串行历史S = Tᵢ₁; Tᵢ₂; ...; Tᵢₙ
对于任意冲突操作o₁ <H o₂：
- 如果o₁ ∈ Tᵢ, o₂ ∈ Tⱼ，且vᵢ在拓扑排序中在vⱼ之前
- 则o₁ <S o₂
因此H ≈c S，H是冲突可串行化的。
```

#### 证明过程

```text
形式化证明步骤：

1. 定义冲突图G = (V, E)
   - V = {vᵢ | Tᵢ ∈ H}
   - E = {(vᵢ, vⱼ) | ∃冲突操作oᵢ < oⱼ}

2. 证明必要性（⟹）：
   - 假设H可串行化，存在S使得H ≈c S
   - 如果G有环，则存在循环依赖
   - 与串行化矛盾，因此G无环

3. 证明充分性（⟸）：
   - 假设G无环，存在拓扑排序
   - 构造串行历史S
   - 证明H ≈c S

4. 结论：
   - H可串行化 ⟺ G无环
```

---

## 📊 第三部分：视图可串行化

### 3.1 视图等价定义

#### 读视图

```text
读视图（Read View）：
- 事务Tᵢ读取数据项x的值
- 该值由某个事务Tⱼ写入

形式化定义：
read_view(H, Tᵢ, x) = Tⱼ ⟺
  wⱼ[x] < rᵢ[x] ∧
  (¬∃Tₖ: wⱼ[x] < wₖ[x] < rᵢ[x])
```

#### 最终写

```text
最终写（Final Write）：
- 数据项x的最终写入者
- 最后一次写入操作

形式化定义：
final_writer(H, x) = Tᵢ ⟺
  wᵢ[x] ∈ H ∧
  (¬∃Tⱼ: wᵢ[x] < wⱼ[x])
```

### 3.2 视图可串行化判定

#### 视图图

```text
视图图（View Graph）Gᵥ = (V, E)：

顶点V：
- 每个事务Tᵢ对应一个顶点vᵢ

边E：
- 读依赖边：如果Tᵢ读取Tⱼ写入的值，则vⱼ → vᵢ
- 写依赖边：如果Tᵢ写入x，Tⱼ是x的最终写入者，则vᵢ → vⱼ

形式化定义：
E = {(vⱼ, vᵢ) | read_view(H, Tᵢ, x) = Tⱼ} ∪
    {(vᵢ, vⱼ) | final_writer(H, x) = Tⱼ ∧ wᵢ[x] ∈ H}
```

#### 判定算法

```text
视图可串行化判定：
- 检查视图图Gᵥ是否有环
- 如果有环，则不是视图可串行化的
- 如果无环，则存在视图等价的串行历史

算法复杂度：
- 构建视图图：O(n²)
- 环检测：O(n + m)
- 总复杂度：O(n²)
```

### 3.3 PostgreSQL实现

#### 快照隔离

```text
PostgreSQL快照隔离：
- 每个事务获得一个快照
- 快照包含事务开始时的数据视图
- 读取操作基于快照，不看到后续写入

形式化定义：
snapshot(Tᵢ) = {x | ∃Tⱼ: wⱼ[x] < start(Tᵢ) ∧ committed(Tⱼ)}

读操作：
rᵢ[x] 读取 snapshot(Tᵢ) 中x的值
```

#### SSI机制

```text
可串行化快照隔离（SSI）：
- PostgreSQL SERIALIZABLE隔离级别
- 检测写偏序异常
- 通过SIREAD锁和谓词锁检测冲突

形式化定义：
SSI冲突检测：
- 如果Tᵢ读取x，Tⱼ写入x，且Tⱼ在Tᵢ提交后提交
- 则检测到冲突，中止其中一个事务
```

---

## 🔧 第四部分：实际案例分析

### 4.1 冲突可串行化案例

```sql
-- 案例1：冲突可串行化历史
-- T1: r₁[x] w₁[y] c₁
-- T2: r₂[y] w₂[x] c₂

-- 冲突操作：
-- r₁[x] 与 w₂[x] 冲突（写读冲突）
-- w₁[y] 与 r₂[y] 冲突（写读冲突）

-- 冲突图：
-- v₁ → v₂（因为w₁[y] < r₂[y]）
-- v₂ → v₁（因为r₁[x] < w₂[x]）
-- 存在环：v₁ → v₂ → v₁

-- 结论：不是冲突可串行化的
```

### 4.2 视图可串行化案例

```sql
-- 案例2：视图可串行化但非冲突可串行化
-- T1: w₁[x] c₁
-- T2: w₂[x] c₂
-- T3: r₃[x] c₃

-- 冲突图：
-- 无冲突边（因为T3读取的是最终写入者）
-- 但存在写写冲突：w₁[x] 与 w₂[x]

-- 视图图：
-- v₂ → v₃（因为T3读取T2写入的值）
-- v₁ → v₂（因为T2是x的最终写入者）

-- 结论：视图可串行化（串行顺序：T1; T2; T3）
```

### 4.3 不可串行化案例

```sql
-- 案例3：写偏序异常（Write Skew）
-- T1: r₁[x] r₁[y] w₁[x] c₁
-- T2: r₂[x] r₂[y] w₂[y] c₂

-- 假设约束：x + y ≥ 0
-- 初始值：x = 50, y = 50

-- 执行历史：
-- T1读取x=50, y=50，写入x=100（满足约束）
-- T2读取x=50, y=50，写入y=-100（满足约束）
-- 最终值：x=100, y=-100（违反约束）

-- 冲突图：
-- 无直接冲突（因为操作不同数据项）
-- 但存在间接冲突（通过约束）

-- 结论：不是可串行化的（SSI可以检测）
```

---

## 📝 总结

### 核心理论

1. **冲突可串行化**：基于冲突操作的相对顺序
2. **视图可串行化**：基于读视图和最终写
3. **冲突可串行化 ⊆ 视图可串行化**

### 形式化关系

```text
冲突可串行化 ⟹ 视图可串行化 ⟹ 结果正确性

但：
视图可串行化 ⇏ 冲突可串行化
```

### PostgreSQL实现

- **READ COMMITTED**：不保证可串行化
- **REPEATABLE READ**：快照隔离，不保证可串行化
- **SERIALIZABLE**：SSI机制，保证可串行化

### 应用场景

| 隔离级别 | 可串行化保证 | 性能影响 |
|---------|------------|---------|
| READ COMMITTED | ❌ | 低 |
| REPEATABLE READ | ❌ | 中 |
| SERIALIZABLE | ✅ | 高 |

PostgreSQL通过SSI机制在SERIALIZABLE隔离级别下保证可串行化，同时通过优化减少性能开销。
