# 可用性量化与测量

> **文档编号**: CAP-THEORY-004
> **主题**: 可用性量化与测量
> **版本**: PostgreSQL 17 & 18
> **状态**: ✅ 已完成

---

## 📑 目录

- [可用性量化与测量](#可用性量化与测量)
  - [📑 目录](#-目录)
  - [📋 概述](#-概述)
  - [📊 第一部分：可用性指标定义](#-第一部分可用性指标定义)
    - [1.1 SLA定义](#11-sla定义)
    - [1.2 SLO定义](#12-slo定义)
    - [1.3 SLI定义](#13-sli定义)
  - [📊 第二部分：可用性测量方法](#-第二部分可用性测量方法)
    - [2.1 故障检测机制](#21-故障检测机制)
    - [2.2 故障恢复时间](#22-故障恢复时间)
    - [2.3 可用性计算公式](#23-可用性计算公式)
  - [📊 第三部分：PostgreSQL高可用实现](#-第三部分postgresql高可用实现)
    - [3.1 流复制高可用](#31-流复制高可用)
    - [3.2 逻辑复制高可用](#32-逻辑复制高可用)
    - [3.3 故障转移机制](#33-故障转移机制)
  - [📊 第四部分：可用性监控与告警](#-第四部分可用性监控与告警)
    - [4.1 监控指标](#41-监控指标)
    - [4.2 告警规则](#42-告警规则)
    - [4.3 可用性Dashboard](#43-可用性dashboard)
  - [📝 总结](#-总结)
    - [核心结论](#核心结论)
    - [实践建议](#实践建议)

---

## 📋 概述

可用性是CAP定理中的核心属性之一，它定义了系统在任意时刻都能响应请求的能力。理解可用性的量化指标和测量方法，对于系统设计和运维至关重要。

本文档从可用性指标定义、测量方法、PostgreSQL实现和监控告警四个维度，全面阐述可用性量化与测量的完整体系。

**核心观点**：

- **SLA/SLO/SLI**：定义可用性的三个层次指标
- **故障检测与恢复**：可用性的关键测量维度
- **PostgreSQL高可用**：通过流复制和故障转移实现高可用性
- **监控与告警**：实时监控可用性指标，及时发现问题

---

## 📊 第一部分：可用性指标定义

### 1.1 SLA定义

**SLA（Service Level Agreement）服务级别协议**：

SLA是服务提供者和用户之间的协议，定义了服务的可用性目标。

**常见SLA级别**：

| SLA级别 | 可用性百分比 | 年停机时间 | 月停机时间 | 适用场景 |
|---------|-------------|-----------|-----------|---------|
| **99%** | 99% | 87.6小时 | 7.3小时 | 一般服务 |
| **99.9%** | 99.9% | 8.76小时 | 43.8分钟 | 企业服务 |
| **99.99%** | 99.99% | 52.56分钟 | 4.38分钟 | 关键服务 |
| **99.999%** | 99.999% | 5.26分钟 | 26.3秒 | 关键基础设施 |

**PostgreSQL SLA目标**：

```sql
-- PostgreSQL高可用配置（99.99% SLA）
-- 目标：年停机时间 < 52.56分钟
-- 实现：流复制 + 自动故障转移
```

### 1.2 SLO定义

**SLO（Service Level Objective）服务级别目标**：

SLO是SLA中的具体目标，定义了可测量的服务指标。

**PostgreSQL SLO指标**：

| SLO指标 | 目标值 | 测量方法 |
|---------|--------|---------|
| **数据库可用性** | 99.99% | 监控数据库连接成功率 |
| **查询响应时间** | P95 < 100ms | 监控查询延迟 |
| **故障恢复时间** | RTO < 5分钟 | 监控故障转移时间 |
| **数据丢失窗口** | RPO < 1分钟 | 监控复制延迟 |

### 1.3 SLI定义

**SLI（Service Level Indicator）服务级别指标**：

SLI是SLO的具体测量指标，用于评估服务是否达到SLO目标。

**PostgreSQL SLI指标**：

```sql
-- 数据库连接成功率SLI
SELECT
    COUNT(*) FILTER (WHERE state = 'active')::float / COUNT(*)::float * 100 AS connection_success_rate
FROM pg_stat_activity;

-- 查询响应时间SLI
SELECT
    percentile_cont(0.95) WITHIN GROUP (ORDER BY query_duration) AS p95_latency
FROM pg_stat_statements;
```

---

## 📊 第二部分：可用性测量方法

### 2.1 故障检测机制

**故障检测方法**：

1. **心跳检测**
   - 定期发送心跳包
   - 检测节点是否存活
   - 超时判定故障

2. **健康检查**
   - 定期执行健康检查查询
   - 检测数据库是否正常
   - 返回健康状态

**PostgreSQL实现**：

```sql
-- 健康检查查询
SELECT 1;

-- 监控查询
SELECT
    pg_is_in_recovery() AS is_standby,
    pg_last_wal_receive_lsn() AS receive_lsn,
    pg_last_wal_replay_lsn() AS replay_lsn;
```

### 2.2 故障恢复时间

**故障恢复时间指标**：

| 指标 | 定义 | PostgreSQL实现 |
|------|------|---------------|
| **MTTR** | 平均故障恢复时间 | 故障转移时间 |
| **MTBF** | 平均故障间隔时间 | 系统正常运行时间 |
| **RTO** | 恢复时间目标 | 故障转移目标时间 |
| **RPO** | 恢复点目标 | 数据丢失窗口 |

**PostgreSQL RTO/RPO配置**：

```sql
-- RTO配置：故障转移时间 < 5分钟
-- 实现：自动故障转移 + 快速检测

-- RPO配置：数据丢失窗口 < 1分钟
-- 实现：同步复制或低延迟异步复制
ALTER SYSTEM SET synchronous_standby_names = 'standby1';
ALTER SYSTEM SET synchronous_commit = 'remote_write';
```

### 2.3 可用性计算公式

**可用性计算公式**：

$$
\text{Availability} = \frac{\text{Uptime}}{\text{Uptime} + \text{Downtime}} \times 100\%
$$

**MTTR和MTBF关系**：

$$
\text{Availability} = \frac{\text{MTBF}}{\text{MTBF} + \text{MTTR}} \times 100\%
$$

**PostgreSQL可用性计算**：

```sql
-- 计算数据库可用性
SELECT
    (EXTRACT(EPOCH FROM (now() - pg_postmaster_start_time())) -
     EXTRACT(EPOCH FROM (SELECT SUM(downtime) FROM downtime_log)))::float /
    EXTRACT(EPOCH FROM (now() - pg_postmaster_start_time()))::float * 100 AS availability_percent;
```

---

## 📊 第三部分：PostgreSQL高可用实现

### 3.1 流复制高可用

**流复制高可用配置**：

```sql
-- 主库配置
wal_level = replica
max_wal_senders = 10
synchronous_standby_names = 'standby1'  -- 至少一个同步备库

-- 备库配置
primary_conninfo = 'host=primary_host port=5432 user=replicator'
```

**高可用特征**：

- ✅ **自动故障转移**：主库故障时自动切换到备库
- ✅ **数据同步**：保证数据一致性
- ✅ **快速恢复**：RTO < 5分钟

### 3.2 逻辑复制高可用

**逻辑复制高可用配置**：

```sql
-- 主库：创建发布
CREATE PUBLICATION mypub FOR ALL TABLES;

-- 备库：创建订阅
CREATE SUBSCRIPTION mysub
CONNECTION 'host=primary_host port=5432 dbname=mydb user=replicator'
PUBLICATION mypub;
```

**高可用特征**：

- ✅ **表级复制**：可以选择性复制表
- ✅ **跨版本支持**：支持不同PostgreSQL版本
- ✅ **灵活配置**：可以自定义复制规则

### 3.3 故障转移机制

**故障转移流程**：

```text
1. 检测主库故障
   │
2. 选择最佳备库
   │
3. 提升备库为主库
   │
4. 更新连接配置
   │
5. 恢复服务
```

**PostgreSQL故障转移工具**：

- **pg_auto_failover**：自动故障转移
- **Patroni**：高可用管理工具
- **repmgr**：复制管理器

---

## 📊 第四部分：可用性监控与告警

### 4.1 监控指标

**关键监控指标**：

```sql
-- 数据库连接数
SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active';

-- 复制延迟
SELECT
    application_name,
    pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes
FROM pg_stat_replication;

-- 数据库大小
SELECT pg_size_pretty(pg_database_size(current_database()));

-- 事务统计
SELECT
    xact_commit,
    xact_rollback,
    blks_read,
    blks_hit
FROM pg_stat_database
WHERE datname = current_database();
```

### 4.2 告警规则

**告警规则配置**：

```yaml
# Prometheus告警规则
groups:
  - name: postgresql_availability
    rules:
      - alert: DatabaseDown
        expr: up{job="postgresql"} == 0
        for: 1m
        annotations:
          summary: "PostgreSQL数据库不可用"

      - alert: HighReplicationLag
        expr: pg_replication_lag_bytes > 104857600  # 100MB
        for: 5m
        annotations:
          summary: "复制延迟过高"
```

### 4.3 可用性Dashboard

**Grafana Dashboard配置**：

- **可用性指标**：数据库连接成功率、查询成功率
- **性能指标**：查询延迟、吞吐量
- **复制指标**：复制延迟、同步状态
- **故障指标**：故障次数、恢复时间

---

## 📝 总结

### 核心结论

1. **SLA/SLO/SLI**：定义可用性的三个层次指标
2. **故障检测与恢复**：可用性的关键测量维度
3. **PostgreSQL高可用**：通过流复制和故障转移实现高可用性
4. **监控与告警**：实时监控可用性指标，及时发现问题

### 实践建议

1. **定义可用性目标**：根据业务需求定义SLA/SLO
2. **实现高可用架构**：使用流复制和故障转移
3. **监控可用性指标**：实时监控数据库可用性
4. **设置告警规则**：及时发现和处理故障

---

**最后更新**: 2024年
**维护状态**: ✅ 已完成
