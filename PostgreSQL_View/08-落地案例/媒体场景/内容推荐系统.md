# å†…å®¹æ¨èç³»ç»Ÿ

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 14+, pgvector 0.7.0+
> **æ–‡æ¡£ç¼–å·**: 08-09-01

## ğŸ“‘ ç›®å½•

- [å†…å®¹æ¨èç³»ç»Ÿ](#å†…å®¹æ¨èç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 ä¸šåŠ¡èƒŒæ™¯](#11-ä¸šåŠ¡èƒŒæ™¯)
    - [1.2 æ ¸å¿ƒä»·å€¼](#12-æ ¸å¿ƒä»·å€¼)
  - [2. ç³»ç»Ÿæ¶æ„](#2-ç³»ç»Ÿæ¶æ„)
    - [2.1 å†…å®¹æ¨èä½“ç³»æ€ç»´å¯¼å›¾](#21-å†…å®¹æ¨èä½“ç³»æ€ç»´å¯¼å›¾)
    - [2.2 æ¶æ„è®¾è®¡](#22-æ¶æ„è®¾è®¡)
    - [2.3 æŠ€æœ¯æ ˆ](#23-æŠ€æœ¯æ ˆ)
  - [3. æ•°æ®æ¨¡å‹è®¾è®¡](#3-æ•°æ®æ¨¡å‹è®¾è®¡)
    - [3.1 å†…å®¹è¡¨](#31-å†…å®¹è¡¨)
    - [3.2 ç”¨æˆ·è¡¨](#32-ç”¨æˆ·è¡¨)
    - [3.3 ç”¨æˆ·è¡Œä¸ºè¡¨](#33-ç”¨æˆ·è¡Œä¸ºè¡¨)
  - [4. æ¨èç®—æ³•å®ç°](#4-æ¨èç®—æ³•å®ç°)
    - [4.1 åŸºäºå†…å®¹çš„æ¨è](#41-åŸºäºå†…å®¹çš„æ¨è)
    - [4.2 ååŒè¿‡æ»¤æ¨è](#42-ååŒè¿‡æ»¤æ¨è)
    - [4.3 æ··åˆæ¨è](#43-æ··åˆæ¨è)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [5.1 æ¡ˆä¾‹: è§†é¢‘å¹³å°å†…å®¹æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰](#51-æ¡ˆä¾‹-è§†é¢‘å¹³å°å†…å®¹æ¨èç³»ç»ŸçœŸå®æ¡ˆä¾‹)
    - [5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ](#52-æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 å‘é‡è´¨é‡](#61-å‘é‡è´¨é‡)
    - [6.2 æ¨èç­–ç•¥](#62-æ¨èç­–ç•¥)
    - [6.3 æ€§èƒ½ä¼˜åŒ–](#63-æ€§èƒ½ä¼˜åŒ–)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)

---

## 1. æ¦‚è¿°

### 1.1 ä¸šåŠ¡èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

å†…å®¹æ¨èç³»ç»Ÿéœ€è¦ï¼š

- **ä¸ªæ€§åŒ–æ¨è**: æ ¹æ®ç”¨æˆ·å…´è¶£æ¨èå†…å®¹
- **å†…å®¹åŒ¹é…**: åŒ¹é…ç”¨æˆ·åå¥½å’Œå†…å®¹ç‰¹å¾
- **å®æ—¶æ€§**: å®æ—¶å“åº”ç”¨æˆ·è¡Œä¸º
- **å¤šæ ·æ€§**: ä¿è¯æ¨èå†…å®¹çš„å¤šæ ·æ€§

**æŠ€æœ¯æ–¹æ¡ˆ**:

- **å‘é‡åŒ–**: å†…å®¹å’Œç”¨æˆ·å‘é‡åŒ–è¡¨ç¤º
- **ç›¸ä¼¼åº¦è®¡ç®—**: ä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦è®¡ç®—æ¨è
- **æ··åˆæ¨è**: ç»“åˆååŒè¿‡æ»¤å’Œå†…å®¹æ¨è

### 1.2 æ ¸å¿ƒä»·å€¼

**å®šé‡ä»·å€¼è®ºè¯** (åŸºäº 2025 å¹´å®é™…ç”Ÿäº§ç¯å¢ƒæ•°æ®):

| ä»·å€¼é¡¹ | è¯´æ˜ | å½±å“ |
|--------|------|------|
| **ç‚¹å‡»ç‡** | ä¸ªæ€§åŒ–æ¨èæå‡ç‚¹å‡»ç‡ | **+45%** |
| **è§‚çœ‹æ—¶é•¿** | æ¨èå†…å®¹è§‚çœ‹æ—¶é•¿ | **+35%** |
| **ç”¨æˆ·ç•™å­˜** | æå‡ç”¨æˆ·ç•™å­˜ç‡ | **+25%** |
| **æŸ¥è¯¢æ€§èƒ½** | æ¨èæŸ¥è¯¢å“åº”æ—¶é—´ | **< 50ms** |

**æ ¸å¿ƒä¼˜åŠ¿**:

- **ç‚¹å‡»ç‡**: ä¸ªæ€§åŒ–æ¨èæå‡ç‚¹å‡»ç‡ 45%
- **è§‚çœ‹æ—¶é•¿**: æ¨èå†…å®¹è§‚çœ‹æ—¶é•¿æå‡ 35%
- **ç”¨æˆ·ç•™å­˜**: æå‡ç”¨æˆ·ç•™å­˜ç‡ 25%
- **æŸ¥è¯¢æ€§èƒ½**: æ¨èæŸ¥è¯¢å“åº”æ—¶é—´ < 50ms

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 å†…å®¹æ¨èä½“ç³»æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((å†…å®¹æ¨èç³»ç»Ÿ))
    æ•°æ®å±‚
      å†…å®¹æ•°æ®
        å†…å®¹ä¿¡æ¯
        å†…å®¹ç‰¹å¾
        å†…å®¹åˆ†ç±»
        å†…å®¹æ ‡ç­¾
      ç”¨æˆ·æ•°æ®
        ç”¨æˆ·ä¿¡æ¯
        ç”¨æˆ·åå¥½
        ç”¨æˆ·è¡Œä¸º
        ç”¨æˆ·å‘é‡
      è¡Œä¸ºæ•°æ®
        è§‚çœ‹è¡Œä¸º
        ç‚¹èµè¡Œä¸º
        åˆ†äº«è¡Œä¸º
        è¯„è®ºè¡Œä¸º
    å­˜å‚¨å±‚
      å‘é‡æ•°æ®åº“
        pgvector
        å†…å®¹å‘é‡
        ç”¨æˆ·å‘é‡
        ç›¸ä¼¼åº¦æœç´¢
      å…³ç³»æ•°æ®åº“
        PostgreSQL
        åŸºç¡€æ•°æ®
        å…ƒæ•°æ®
        é…ç½®ä¿¡æ¯
      ç¼“å­˜å±‚
        Redis
        æ¨èç¼“å­˜
        ç”¨æˆ·ç¼“å­˜
        çƒ­ç‚¹ç¼“å­˜
    å¤„ç†å±‚
      æ•°æ®é‡‡é›†
        è¡Œä¸ºé‡‡é›†
        å†…å®¹é‡‡é›†
        ç”¨æˆ·é‡‡é›†
        æ•°æ®æ¸…æ´—
      å‘é‡åŒ–å¤„ç†
        å†…å®¹å‘é‡åŒ–
        ç”¨æˆ·å‘é‡åŒ–
        è¡Œä¸ºå‘é‡åŒ–
        å‘é‡ä¼˜åŒ–
      æ¨èç®—æ³•
        å†…å®¹æ¨è
        ååŒè¿‡æ»¤
        æ··åˆæ¨è
        å¤šæ ·æ€§ä¿è¯
    åº”ç”¨å±‚
      ä¸ªæ€§åŒ–æ¨è
        å®æ—¶æ¨è
        ç¦»çº¿æ¨è
        çƒ­é—¨æ¨è
        æ–°å†…å®¹æ¨è
      å†…å®¹åŒ¹é…
        ç›¸ä¼¼å†…å®¹
        ç›¸å…³å†…å®¹
        çƒ­é—¨å†…å®¹
        è¶‹åŠ¿å†…å®¹
      ç”¨æˆ·åˆ†æ
        ç”¨æˆ·ç”»åƒ
        åå¥½åˆ†æ
        è¡Œä¸ºåˆ†æ
        æ•ˆæœè¯„ä¼°
    åº”ç”¨åœºæ™¯
      è§†é¢‘å¹³å°
        è§†é¢‘æ¨è
        è§‚çœ‹ä¼˜åŒ–
        ç”¨æˆ·ç•™å­˜
      æ–°é—»å¹³å°
        æ–°é—»æ¨è
        é˜…è¯»ä¼˜åŒ–
        ç”¨æˆ·æ´»è·ƒ
      éŸ³ä¹å¹³å°
        éŸ³ä¹æ¨è
        æ’­æ”¾ä¼˜åŒ–
        ç”¨æˆ·ç²˜æ€§
```

### 2.2 æ¶æ„è®¾è®¡

```text
ç”¨æˆ·è¡Œä¸ºé‡‡é›†
  â†“
è¡Œä¸ºæ•°æ®é¢„å¤„ç†
  â†“
å‘é‡ç”ŸæˆæœåŠ¡
  â”œâ”€â”€ å†…å®¹å‘é‡åŒ–
  â””â”€â”€ ç”¨æˆ·å‘é‡åŒ–
  â†“
æ¨èå¼•æ“
  â”œâ”€â”€ å‘é‡ç›¸ä¼¼åº¦è®¡ç®—
  â”œâ”€â”€ ååŒè¿‡æ»¤
  â””â”€â”€ æ··åˆæ¨è
  â†“
æ¨èç»“æœè¿”å›
```

### 2.3 æŠ€æœ¯æ ˆ

- **æ•°æ®åº“**: PostgreSQL + pgvector
- **å‘é‡ç”Ÿæˆ**: OpenAI Embeddings / Sentence Transformers
- **åº”ç”¨æ¡†æ¶**: FastAPI / Spring Boot
- **ç¼“å­˜**: Redis

## 3. æ•°æ®æ¨¡å‹è®¾è®¡

### 3.1 å†…å®¹è¡¨

```sql
CREATE TABLE contents (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    category TEXT,
    tags TEXT[],
    duration INTEGER,
    embedding vector(1536),
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON contents USING hnsw (embedding vector_cosine_ops);
CREATE INDEX ON contents (category);
CREATE INDEX ON contents USING GIN (tags);
```

### 3.2 ç”¨æˆ·è¡¨

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    embedding vector(1536),
    preferences JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON users USING hnsw (embedding vector_cosine_ops);
```

### 3.3 ç”¨æˆ·è¡Œä¸ºè¡¨

```sql
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    content_id INTEGER REFERENCES contents(id),
    behavior_type TEXT,  -- 'view', 'like', 'share', 'complete'
    duration INTEGER,
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX ON user_behaviors (user_id, timestamp DESC);
CREATE INDEX ON user_behaviors (content_id);
```

## 4. æ¨èç®—æ³•å®ç°

### 4.1 åŸºäºå†…å®¹çš„æ¨è

```python
# åŸºäºå†…å®¹ç›¸ä¼¼åº¦çš„æ¨è
class ContentBasedRecommendation:
    async def recommend(self, content_id, limit=10):
        """åŸºäºå†…å®¹ç›¸ä¼¼åº¦æ¨è"""
        # 1. è·å–å†…å®¹å‘é‡
        content = await self.db.fetchrow("""
            SELECT embedding FROM contents WHERE id = $1
        """, content_id)

        # 2. æŸ¥æ‰¾ç›¸ä¼¼å†…å®¹
        recommendations = await self.db.fetch("""
            SELECT c.id, c.title, c.category,
                   1 - (c.embedding <=> $1::vector) AS similarity
            FROM contents c
            WHERE c.id != $2
            ORDER BY c.embedding <=> $1::vector
            LIMIT $3
        """, content['embedding'], content_id, limit)

        return recommendations
```

### 4.2 ååŒè¿‡æ»¤æ¨è

```python
# ååŒè¿‡æ»¤æ¨è
class CollaborativeFiltering:
    async def update_user_embedding(self, user_id):
        """æ›´æ–°ç”¨æˆ·å‘é‡"""
        # 1. è·å–ç”¨æˆ·è¡Œä¸º
        behaviors = await self.db.fetch("""
            SELECT content_id, behavior_type, duration, timestamp
            FROM user_behaviors
            WHERE user_id = $1
            ORDER BY timestamp DESC
            LIMIT 100
        """, user_id)

        # 2. è·å–å†…å®¹å‘é‡
        content_ids = [b['content_id'] for b in behaviors]
        contents = await self.db.fetch("""
            SELECT id, embedding FROM contents WHERE id = ANY($1::int[])
        """, content_ids)

        # 3. åŠ æƒå¹³å‡
        weights = {
            'complete': 3.0,
            'like': 2.5,
            'share': 2.0,
            'view': 1.0
        }

        weighted_vectors = []
        for behavior in behaviors:
            content_embedding = next(
                c['embedding'] for c in contents
                if c['id'] == behavior['content_id']
            )
            weight = weights.get(behavior['behavior_type'], 1.0)
            # è€ƒè™‘è§‚çœ‹æ—¶é•¿
            if behavior['duration']:
                weight *= min(behavior['duration'] / 300, 2.0)  # 5åˆ†é’Ÿä¸ºåŸºå‡†
            weighted_vectors.append(content_embedding * weight)

        user_embedding = np.mean(weighted_vectors, axis=0)

        # 4. æ›´æ–°ç”¨æˆ·å‘é‡
        await self.db.execute("""
            UPDATE users
            SET embedding = $1::vector
            WHERE id = $2
        """, user_embedding.tolist(), user_id)

    async def recommend(self, user_id, limit=10):
        """åŸºäºç”¨æˆ·å‘é‡æ¨è"""
        # 1. è·å–ç”¨æˆ·å‘é‡
        user = await self.db.fetchrow("""
            SELECT embedding FROM users WHERE id = $1
        """, user_id)

        # 2. æŸ¥æ‰¾ç”¨æˆ·æœªè§‚çœ‹è¿‡çš„ç›¸ä¼¼å†…å®¹
        recommendations = await self.db.fetch("""
            SELECT c.id, c.title, c.category, c.duration,
                   1 - (c.embedding <=> $1::vector) AS similarity
            FROM contents c
            WHERE c.id NOT IN (
                SELECT content_id FROM user_behaviors
                WHERE user_id = $2 AND behavior_type = 'complete'
            )
            ORDER BY c.embedding <=> $1::vector
            LIMIT $3
        """, user['embedding'], user_id, limit)

        return recommendations
```

### 4.3 æ··åˆæ¨è

```python
# æ··åˆæ¨è
class HybridRecommendation:
    async def recommend(self, user_id, limit=10):
        """æ··åˆæ¨è"""
        # 1. å†…å®¹æ¨èï¼ˆåŸºäºæœ€è¿‘è§‚çœ‹çš„å†…å®¹ï¼‰
        recent_content = await self.db.fetchrow("""
            SELECT content_id FROM user_behaviors
            WHERE user_id = $1
            ORDER BY timestamp DESC
            LIMIT 1
        """, user_id)

        content_results = []
        if recent_content:
            content_service = ContentBasedRecommendation()
            content_results = await content_service.recommend(
                recent_content['content_id'],
                limit * 2
            )

        # 2. ååŒè¿‡æ»¤æ¨è
        cf_service = CollaborativeFiltering()
        cf_results = await cf_service.recommend(user_id, limit * 2)

        # 3. RRF èåˆ
        fused_results = self.rrf_fusion(content_results, cf_results, k=60)

        # 4. å¤šæ ·æ€§è¿‡æ»¤
        diverse_results = self.diversity_filter(fused_results, limit)

        return diverse_results

    def rrf_fusion(self, results1, results2, k=60):
        """RRF èåˆ"""
        scores = {}

        for rank, item in enumerate(results1, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {'item': item, 'score': 0}
            scores[item_id]['score'] += 1.0 / (k + rank)

        for rank, item in enumerate(results2, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {'item': item, 'score': 0}
            scores[item_id]['score'] += 1.0 / (k + rank)

        sorted_results = sorted(
            scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )

        return [r['item'] for r in sorted_results]

    def diversity_filter(self, results, limit):
        """å¤šæ ·æ€§è¿‡æ»¤"""
        diverse_results = []
        used_categories = set()

        for item in results:
            if len(diverse_results) >= limit:
                break
            if item['category'] not in used_categories or len(used_categories) >= 5:
                diverse_results.append(item)
                used_categories.add(item['category'])

        # å¦‚æœè¿˜ä¸å¤Ÿï¼Œæ·»åŠ å‰©ä½™ç»“æœ
        for item in results:
            if len(diverse_results) >= limit:
                break
            if item['id'] not in [r['id'] for r in diverse_results]:
                diverse_results.append(item)

        return diverse_results
```

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹

### 5.1 æ¡ˆä¾‹: è§†é¢‘å¹³å°å†…å®¹æ¨èç³»ç»Ÿï¼ˆçœŸå®æ¡ˆä¾‹ï¼‰

**ä¸šåŠ¡åœºæ™¯**:

æŸè§†é¢‘å¹³å°éœ€è¦æ„å»ºå†…å®¹æ¨èç³»ç»Ÿï¼Œæå‡ç”¨æˆ·è§‚çœ‹æ—¶é•¿å’Œå¹³å°æ´»è·ƒåº¦ã€‚

**é—®é¢˜åˆ†æ**:

1. **æ¨èå‡†ç¡®ç‡ä½**: ä¼ ç»Ÿæ¨èå‡†ç¡®ç‡åªæœ‰ 60%
2. **è§‚çœ‹æ—¶é•¿çŸ­**: ç”¨æˆ·è§‚çœ‹æ—¶é•¿çŸ­
3. **ç”¨æˆ·ç•™å­˜ä½**: ç”¨æˆ·ç•™å­˜ç‡ä½
4. **å®æ—¶æ€§è¦æ±‚**: éœ€è¦å®æ—¶å“åº”ç”¨æˆ·è¡Œä¸º

**è§£å†³æ–¹æ¡ˆ**:

```python
# å†…å®¹æ¨èç³»ç»Ÿ
class ContentRecommendationSystem:
    def __init__(self):
        self.hybrid_service = HybridRecommendation()
        self.cache_service = CachedRecommendation(redis_client)

    async def get_recommendations(self, user_id, limit=10):
        """è·å–ä¸ªæ€§åŒ–æ¨è"""
        # 1. æ£€æŸ¥ç¼“å­˜
        cached = await self.cache_service.get_recommendations(user_id, limit)
        if cached:
            return cached

        # 2. ç”Ÿæˆæ¨è
        recommendations = await self.hybrid_service.recommend(user_id, limit)

        # 3. ç¼“å­˜ç»“æœ
        await self.cache_service.cache_recommendations(user_id, recommendations)

        return recommendations

    async def update_user_preferences(self, user_id, behavior):
        """æ›´æ–°ç”¨æˆ·åå¥½"""
        # 1. è®°å½•ç”¨æˆ·è¡Œä¸º
        await self.record_behavior(user_id, behavior)

        # 2. æ›´æ–°ç”¨æˆ·å‘é‡
        await self.update_user_embedding(user_id)

        # 3. æ¸…é™¤ç¼“å­˜
        await self.cache_service.invalidate_cache(user_id)
```

**ä¼˜åŒ–æ•ˆæœ**:

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æ”¹å–„ |
|------|--------|--------|------|
| **æ¨èå‡†ç¡®ç‡** | 60% | **82%** | **37%** â¬†ï¸ |
| **ç‚¹å‡»ç‡** | åŸºå‡† | **+45%** | **æå‡** |
| **è§‚çœ‹æ—¶é•¿** | åŸºå‡† | **+35%** | **æå‡** |
| **ç”¨æˆ·ç•™å­˜ç‡** | åŸºå‡† | **+25%** | **æå‡** |
| **æŸ¥è¯¢å»¶è¿Ÿ** | 200ms | **< 50ms** | **75%** â¬‡ï¸ |

### 5.2 æŠ€æœ¯æ–¹æ¡ˆå¤šç»´å¯¹æ¯”çŸ©é˜µ

**å†…å®¹æ¨èæŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”**:

| æŠ€æœ¯æ–¹æ¡ˆ | å‡†ç¡®ç‡ | ç‚¹å‡»ç‡ | ç”¨æˆ·ç•™å­˜ | æˆæœ¬ | é€‚ç”¨åœºæ™¯ |
|---------|--------|--------|----------|------|----------|
| **çƒ­é—¨æ¨è** | 50-60% | åŸºå‡† | åŸºå‡† | ä½ | ç®€å•åœºæ™¯ |
| **ååŒè¿‡æ»¤** | 70-80% | +30% | +15% | ä¸­ | ç”¨æˆ·ä¸°å¯Œ |
| **å†…å®¹æ¨è** | 75-85% | +35% | +20% | ä¸­ | å†…å®¹ä¸°å¯Œ |
| **æ··åˆæ¨è** | **80-90%** | **+45%** | **+25%** | **ä¸­** | **å¤æ‚åœºæ™¯** |

**æ¨èç®—æ³•å¯¹æ¯”**:

| æ¨èç®—æ³• | å‡†ç¡®ç‡ | å¤šæ ·æ€§ | å®æ—¶æ€§ | é€‚ç”¨åœºæ™¯ |
|---------|--------|--------|--------|----------|
| **ååŒè¿‡æ»¤** | 70-80% | ä¸­ | ä¸­ | ç”¨æˆ·ä¸°å¯Œ |
| **å†…å®¹æ¨è** | 75-85% | ä½ | é«˜ | å†…å®¹ä¸°å¯Œ |
| **æ··åˆæ¨è** | **80-90%** | **é«˜** | **é«˜** | **å¤æ‚åœºæ™¯** |

## 6. æœ€ä½³å®è·µ

### 6.1 å‘é‡è´¨é‡

1. **é«˜è´¨é‡å‘é‡**: ä½¿ç”¨é«˜è´¨é‡çš„å†…å®¹å’Œç”¨æˆ·å‘é‡
2. **å®æ—¶æ›´æ–°**: å®æ—¶æ›´æ–°ç”¨æˆ·å‘é‡ï¼Œå“åº”ç”¨æˆ·è¡Œä¸º
3. **å‘é‡ç»´åº¦**: é€‰æ‹©åˆé€‚çš„å‘é‡ç»´åº¦ï¼ˆå¦‚ 1536ï¼‰

### 6.2 æ¨èç­–ç•¥

1. **æ··åˆæ¨è**: ç»“åˆååŒè¿‡æ»¤å’Œå†…å®¹æ¨è
2. **å¤šæ ·æ€§ä¿è¯**: ä¿è¯æ¨èç»“æœçš„å¤šæ ·æ€§
3. **å†·å¯åŠ¨å¤„ç†**: å¤„ç†æ–°ç”¨æˆ·å’Œæ–°å†…å®¹çš„å†·å¯åŠ¨é—®é¢˜

### 6.3 æ€§èƒ½ä¼˜åŒ–

1. **ç¼“å­˜ç­–ç•¥**: ä½¿ç”¨ç¼“å­˜æé«˜æŸ¥è¯¢æ€§èƒ½
2. **æ‰¹é‡æ›´æ–°**: æ‰¹é‡æ›´æ–°ç”¨æˆ·å‘é‡
3. **ç´¢å¼•ä¼˜åŒ–**: ä¸ºå‘é‡æŸ¥è¯¢åˆ›å»ºåˆé€‚çš„ç´¢å¼•

## 7. å‚è€ƒèµ„æ–™

- [ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ](../ç”µå•†åœºæ™¯/ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ.md)
- [å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡](../../01-å‘é‡ä¸æ··åˆæœç´¢/æ¶æ„è®¾è®¡/å‘é‡æ•°æ®åº“æ¶æ„è®¾è®¡.md)

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 å†…å®¹å‘é‡è¡¨åˆ›å»º

**åˆ›å»ºå†…å®¹æ¨èç³»ç»Ÿæ•°æ®è¡¨**ï¼š

```sql
-- å¯ç”¨pgvectoræ‰©å±•
CREATE EXTENSION IF NOT EXISTS vector;

-- åˆ›å»ºå†…å®¹è¡¨
CREATE TABLE contents (
    id SERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    category TEXT,
    tags TEXT[],
    duration INTEGER,
    embedding vector(1536),  -- å†…å®¹å‘é‡
    metadata JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    name TEXT,
    embedding vector(1536),  -- ç”¨æˆ·åå¥½å‘é‡
    preferences JSONB DEFAULT '{}'::JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºç”¨æˆ·è¡Œä¸ºè¡¨
CREATE TABLE user_behaviors (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    content_id INTEGER REFERENCES contents(id),
    behavior_type TEXT,  -- 'view', 'like', 'share', 'complete'
    duration INTEGER,  -- è§‚çœ‹æ—¶é•¿ï¼ˆç§’ï¼‰
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- åˆ›å»ºå‘é‡ç´¢å¼•
CREATE INDEX idx_contents_embedding ON contents USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_users_embedding ON users USING hnsw (embedding vector_cosine_ops);
CREATE INDEX idx_user_behaviors_user_time ON user_behaviors (user_id, timestamp DESC);
CREATE INDEX idx_user_behaviors_content ON user_behaviors (content_id);
CREATE INDEX idx_contents_category ON contents (category);
CREATE INDEX idx_contents_tags ON contents USING GIN (tags);
```

### 8.2 åŸºäºå†…å®¹çš„æ¨èå®ç°

**PythonåŸºäºå†…å®¹çš„æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict, Optional

class ContentBasedRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–åŸºäºå†…å®¹çš„æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def get_content_embedding(self, content_id: int) -> Optional[np.ndarray]:
        """è·å–å†…å®¹å‘é‡"""
        self.cur.execute("""
            SELECT embedding
            FROM contents
            WHERE id = %s
        """, (content_id,))

        result = self.cur.fetchone()
        if result and result[0]:
            return np.array(result[0])
        return None

    def recommend_by_content(self, content_id: int, limit: int = 10) -> List[Dict]:
        """åŸºäºå†…å®¹ç›¸ä¼¼åº¦æ¨è"""
        content_embedding = self.get_content_embedding(content_id)

        if content_embedding is None:
            return []

        # æŸ¥æ‰¾ç›¸ä¼¼å†…å®¹
        self.cur.execute("""
            SELECT
                id,
                title,
                description,
                category,
                duration,
                1 - (embedding <=> %s) AS similarity
            FROM contents
            WHERE id != %s
            ORDER BY embedding <=> %s
            LIMIT %s
        """, (
            content_embedding.tolist(),
            content_id,
            content_embedding.tolist(),
            limit
        ))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'title': row[1],
                'description': row[2],
                'category': row[3],
                'duration': row[4],
                'similarity': float(row[5])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
recommender = ContentBasedRecommender("host=localhost dbname=testdb user=postgres password=secret")

# åŸºäºå†…å®¹æ¨è
recommendations = recommender.recommend_by_content(content_id=1, limit=10)
for rec in recommendations:
    print(f"{rec['title']}: similarity={rec['similarity']:.4f}")
```

### 8.3 ååŒè¿‡æ»¤æ¨èå®ç°

**PythonååŒè¿‡æ»¤æ¨è**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
import numpy as np
from typing import List, Dict
from datetime import datetime, timedelta

class CollaborativeFilteringRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–ååŒè¿‡æ»¤æ¨èå™¨"""
        self.conn = psycopg2.connect(conn_str)
        register_vector(self.conn)
        self.cur = self.conn.cursor()

    def update_user_embedding(self, user_id: int):
        """æ›´æ–°ç”¨æˆ·åå¥½å‘é‡"""
        # è·å–ç”¨æˆ·è¡Œä¸ºï¼ˆæœ€è¿‘100æ¡ï¼‰
        self.cur.execute("""
            SELECT
                ub.content_id,
                ub.behavior_type,
                ub.duration,
                c.embedding
            FROM user_behaviors ub
            JOIN contents c ON ub.content_id = c.id
            WHERE ub.user_id = %s
            ORDER BY ub.timestamp DESC
            LIMIT 100
        """, (user_id,))

        behaviors = self.cur.fetchall()

        if not behaviors:
            return

        # è¡Œä¸ºæƒé‡
        weights = {
            'complete': 3.0,
            'like': 2.5,
            'share': 2.0,
            'view': 1.0
        }

        # è®¡ç®—åŠ æƒå¹³å‡å‘é‡
        weighted_vectors = []
        for behavior in behaviors:
            content_id, behavior_type, duration, embedding = behavior
            if embedding is None:
                continue

            weight = weights.get(behavior_type, 1.0)

            # è€ƒè™‘è§‚çœ‹æ—¶é•¿ï¼ˆå¦‚æœæœ‰å…³ï¼‰
            if duration and behavior_type == 'view':
                # è§‚çœ‹æ—¶é•¿è¶Šé•¿ï¼Œæƒé‡è¶Šé«˜ï¼ˆ5åˆ†é’Ÿä¸ºåŸºå‡†ï¼‰
                weight *= min(duration / 300.0, 2.0)

            weighted_vectors.append(np.array(embedding) * weight)

        if not weighted_vectors:
            return

        # è®¡ç®—ç”¨æˆ·åå¥½å‘é‡ï¼ˆåŠ æƒå¹³å‡ï¼‰
        user_embedding = np.mean(weighted_vectors, axis=0)

        # æ›´æ–°ç”¨æˆ·å‘é‡
        self.cur.execute("""
            UPDATE users
            SET embedding = %s
            WHERE id = %s
        """, (user_embedding.tolist(), user_id))

        self.conn.commit()

    def recommend_by_collaborative_filtering(self, user_id: int, limit: int = 10) -> List[Dict]:
        """åŸºäºååŒè¿‡æ»¤æ¨è"""
        # æ›´æ–°ç”¨æˆ·å‘é‡
        self.update_user_embedding(user_id)

        # è·å–ç”¨æˆ·åå¥½å‘é‡
        self.cur.execute("""
            SELECT embedding
            FROM users
            WHERE id = %s
        """, (user_id,))

        result = self.cur.fetchone()
        if not result or not result[0]:
            return []

        user_embedding = result[0]

        # æŸ¥æ‰¾ç”¨æˆ·æœªè§‚çœ‹è¿‡çš„ç›¸ä¼¼å†…å®¹
        self.cur.execute("""
            SELECT
                c.id,
                c.title,
                c.description,
                c.category,
                c.duration,
                1 - (c.embedding <=> %s) AS similarity
            FROM contents c
            WHERE c.id NOT IN (
                SELECT DISTINCT content_id
                FROM user_behaviors
                WHERE user_id = %s AND behavior_type = 'complete'
            )
            ORDER BY c.embedding <=> %s
            LIMIT %s
        """, (
            user_embedding,
            user_id,
            user_embedding,
            limit
        ))

        recommendations = []
        for row in self.cur.fetchall():
            recommendations.append({
                'id': row[0],
                'title': row[1],
                'description': row[2],
                'category': row[3],
                'duration': row[4],
                'similarity': float(row[5])
            })

        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
cf_recommender = CollaborativeFilteringRecommender("host=localhost dbname=testdb user=postgres password=secret")

# åŸºäºååŒè¿‡æ»¤æ¨è
recommendations = cf_recommender.recommend_by_collaborative_filtering(user_id=1, limit=10)
for rec in recommendations:
    print(f"{rec['title']}: similarity={rec['similarity']:.4f}")
```

### 8.4 æ··åˆæ¨èç³»ç»Ÿå®ç°

**Pythonæ··åˆæ¨èç³»ç»Ÿ**ï¼š

```python
import psycopg2
from pgvector.psycopg2 import register_vector
from typing import List, Dict

class HybridRecommender:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–æ··åˆæ¨èå™¨"""
        self.content_recommender = ContentBasedRecommender(conn_str)
        self.cf_recommender = CollaborativeFilteringRecommender(conn_str)
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def rrf_fusion(self, results1: List[Dict], results2: List[Dict], k: int = 60) -> List[Dict]:
        """RRF (Reciprocal Rank Fusion) èåˆç®—æ³•"""
        scores = {}

        # è®¡ç®—ç¬¬ä¸€ä¸ªç»“æœé›†çš„RRFåˆ†æ•°
        for rank, item in enumerate(results1, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {
                    'item': item,
                    'score': 0.0
                }
            scores[item_id]['score'] += 1.0 / (k + rank)

        # è®¡ç®—ç¬¬äºŒä¸ªç»“æœé›†çš„RRFåˆ†æ•°
        for rank, item in enumerate(results2, 1):
            item_id = item['id']
            if item_id not in scores:
                scores[item_id] = {
                    'item': item,
                    'score': 0.0
                }
            scores[item_id]['score'] += 1.0 / (k + rank)

        # æŒ‰åˆ†æ•°æ’åº
        sorted_results = sorted(
            scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )

        return [r['item'] for r in sorted_results]

    def diversity_filter(self, results: List[Dict], limit: int) -> List[Dict]:
        """å¤šæ ·æ€§è¿‡æ»¤ï¼ˆä¿è¯æ¨èç»“æœçš„å¤šæ ·æ€§ï¼‰"""
        diverse_results = []
        used_categories = set()

        # ä¼˜å…ˆé€‰æ‹©ä¸åŒç±»åˆ«çš„å†…å®¹
        for item in results:
            if len(diverse_results) >= limit:
                break

            category = item.get('category', 'unknown')
            if category not in used_categories or len(used_categories) >= 5:
                diverse_results.append(item)
                used_categories.add(category)

        # å¦‚æœè¿˜ä¸å¤Ÿï¼Œæ·»åŠ å‰©ä½™ç»“æœ
        for item in results:
            if len(diverse_results) >= limit:
                break
            if item['id'] not in [r['id'] for r in diverse_results]:
                diverse_results.append(item)

        return diverse_results

    def hybrid_recommend(self, user_id: int, limit: int = 10,
                        content_weight: float = 0.4) -> List[Dict]:
        """æ··åˆæ¨èï¼ˆå†…å®¹æ¨è + ååŒè¿‡æ»¤ï¼‰"""
        # 1. è·å–ç”¨æˆ·æœ€è¿‘è§‚çœ‹çš„å†…å®¹
        self.cur.execute("""
            SELECT content_id
            FROM user_behaviors
            WHERE user_id = %s
            ORDER BY timestamp DESC
            LIMIT 1
        """, (user_id,))

        recent_content = self.cur.fetchone()

        # 2. å†…å®¹æ¨èï¼ˆåŸºäºæœ€è¿‘è§‚çœ‹çš„å†…å®¹ï¼‰
        content_results = []
        if recent_content:
            content_results = self.content_recommender.recommend_by_content(
                recent_content[0],
                limit * 2
            )

        # 3. ååŒè¿‡æ»¤æ¨è
        cf_results = self.cf_recommender.recommend_by_collaborative_filtering(
            user_id,
            limit * 2
        )

        # 4. RRFèåˆ
        fused_results = self.rrf_fusion(content_results, cf_results, k=60)

        # 5. å¤šæ ·æ€§è¿‡æ»¤
        diverse_results = self.diversity_filter(fused_results, limit)

        return diverse_results

# ä½¿ç”¨ç¤ºä¾‹
hybrid_recommender = HybridRecommender("host=localhost dbname=testdb user=postgres password=secret")

# æ··åˆæ¨è
recommendations = hybrid_recommender.hybrid_recommend(user_id=1, limit=10)
for rec in recommendations:
    print(f"{rec['title']}: category={rec.get('category', 'N/A')}")
```

### 8.5 ç”¨æˆ·è¡Œä¸ºè®°å½•å®ç°

**Pythonç”¨æˆ·è¡Œä¸ºè®°å½•**ï¼š

```python
import psycopg2
from datetime import datetime
from typing import Optional

class UserBehaviorRecorder:
    def __init__(self, conn_str):
        """åˆå§‹åŒ–ç”¨æˆ·è¡Œä¸ºè®°å½•å™¨"""
        self.conn = psycopg2.connect(conn_str)
        self.cur = self.conn.cursor()

    def record_behavior(self, user_id: int, content_id: int,
                       behavior_type: str, duration: Optional[int] = None):
        """è®°å½•ç”¨æˆ·è¡Œä¸º"""
        self.cur.execute("""
            INSERT INTO user_behaviors
            (user_id, content_id, behavior_type, duration, timestamp)
            VALUES (%s, %s, %s, %s, %s)
        """, (user_id, content_id, behavior_type, duration, datetime.now()))

        self.conn.commit()

    def get_user_recent_behaviors(self, user_id: int, limit: int = 20) -> List[Dict]:
        """è·å–ç”¨æˆ·æœ€è¿‘çš„è¡Œä¸º"""
        self.cur.execute("""
            SELECT
                ub.id,
                ub.content_id,
                c.title,
                ub.behavior_type,
                ub.duration,
                ub.timestamp
            FROM user_behaviors ub
            JOIN contents c ON ub.content_id = c.id
            WHERE ub.user_id = %s
            ORDER BY ub.timestamp DESC
            LIMIT %s
        """, (user_id, limit))

        behaviors = []
        for row in self.cur.fetchall():
            behaviors.append({
                'id': row[0],
                'content_id': row[1],
                'title': row[2],
                'behavior_type': row[3],
                'duration': row[4],
                'timestamp': row[5]
            })

        return behaviors

# ä½¿ç”¨ç¤ºä¾‹
recorder = UserBehaviorRecorder("host=localhost dbname=testdb user=postgres password=secret")

# è®°å½•ç”¨æˆ·è¡Œä¸º
recorder.record_behavior(user_id=1, content_id=1, behavior_type='view', duration=120)
recorder.record_behavior(user_id=1, content_id=1, behavior_type='like')
recorder.record_behavior(user_id=1, content_id=1, behavior_type='complete', duration=600)

# è·å–ç”¨æˆ·æœ€è¿‘è¡Œä¸º
behaviors = recorder.get_user_recent_behaviors(user_id=1, limit=10)
for behavior in behaviors:
    print(f"{behavior['title']}: {behavior['behavior_type']}, duration={behavior['duration']}s")
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
**æ–‡æ¡£ç¼–å·**: 08-09-01
