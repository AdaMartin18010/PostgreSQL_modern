# å®¡è®¡æ—¥å¿—æœºåˆ¶

> **æ›´æ–°æ—¶é—´**: 2025 å¹´ 11 æœˆ 1 æ—¥
> **æŠ€æœ¯ç‰ˆæœ¬**: PostgreSQL 18+
> **æ–‡æ¡£ç¼–å·**: 05-01-03

## ğŸ“‘ ç›®å½•

- [å®¡è®¡æ—¥å¿—æœºåˆ¶](#å®¡è®¡æ—¥å¿—æœºåˆ¶)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æŠ€æœ¯èƒŒæ™¯](#11-æŠ€æœ¯èƒŒæ™¯)
    - [1.2 æŠ€æœ¯å®šä½](#12-æŠ€æœ¯å®šä½)
    - [1.3 æ ¸å¿ƒä»·å€¼](#13-æ ¸å¿ƒä»·å€¼)
  - [2. æŠ€æœ¯åŸç†](#2-æŠ€æœ¯åŸç†)
    - [2.1 å®¡è®¡æ—¥å¿—åŸç†](#21-å®¡è®¡æ—¥å¿—åŸç†)
    - [2.2 æ—¥å¿—è®°å½•æœºåˆ¶](#22-æ—¥å¿—è®°å½•æœºåˆ¶)
    - [2.3 å®Œæ•´æ€§ä¿è¯](#23-å®Œæ•´æ€§ä¿è¯)
    - [2.4 ä¸å¯ç¯¡æ”¹æœºåˆ¶](#24-ä¸å¯ç¯¡æ”¹æœºåˆ¶)
  - [3. æ¶æ„è®¾è®¡](#3-æ¶æ„è®¾è®¡)
    - [3.1 æ•´ä½“æ¶æ„](#31-æ•´ä½“æ¶æ„)
    - [3.2 æ—¥å¿—å­˜å‚¨](#32-æ—¥å¿—å­˜å‚¨)
    - [3.3 æ—¥å¿—æŸ¥è¯¢](#33-æ—¥å¿—æŸ¥è¯¢)
  - [4. å®ç°ç»†èŠ‚](#4-å®ç°ç»†èŠ‚)
    - [4.1 æ—¥å¿—è¡¨è®¾è®¡](#41-æ—¥å¿—è¡¨è®¾è®¡)
    - [4.2 è§¦å‘å™¨å®ç°](#42-è§¦å‘å™¨å®ç°)
    - [4.3 å“ˆå¸Œé“¾æœºåˆ¶](#43-å“ˆå¸Œé“¾æœºåˆ¶)
  - [5. æ€§èƒ½åˆ†æ](#5-æ€§èƒ½åˆ†æ)
  - [6. æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
    - [6.1 æ—¥å¿—è®¾è®¡](#61-æ—¥å¿—è®¾è®¡)
    - [6.2 å®Œæ•´æ€§ä¿è¯](#62-å®Œæ•´æ€§ä¿è¯)
  - [7. å‚è€ƒèµ„æ–™](#7-å‚è€ƒèµ„æ–™)
    - [7.1 å®˜æ–¹æ–‡æ¡£](#71-å®˜æ–¹æ–‡æ¡£)
    - [7.2 å­¦æœ¯è®ºæ–‡](#72-å­¦æœ¯è®ºæ–‡)
    - [7.3 æŠ€æœ¯åšå®¢](#73-æŠ€æœ¯åšå®¢)
    - [7.4 ç›¸å…³èµ„æº](#74-ç›¸å…³èµ„æº)
  - [8. å®Œæ•´ä»£ç ç¤ºä¾‹](#8-å®Œæ•´ä»£ç ç¤ºä¾‹)
    - [8.1 å®¡è®¡æ—¥å¿—è¡¨åˆ›å»ºä¸é…ç½®](#81-å®¡è®¡æ—¥å¿—è¡¨åˆ›å»ºä¸é…ç½®)
    - [8.2 å®¡è®¡æ—¥å¿—å®Œæ•´æ€§éªŒè¯ç¤ºä¾‹](#82-å®¡è®¡æ—¥å¿—å®Œæ•´æ€§éªŒè¯ç¤ºä¾‹)

---

## 1. æ¦‚è¿°

### 1.1 æŠ€æœ¯èƒŒæ™¯

**é—®é¢˜éœ€æ±‚**:

åˆè§„è¦æ±‚éœ€è¦å®Œæ•´è®°å½•æ‰€æœ‰æ•°æ®è®¿é—®å’Œä¿®æ”¹æ“ä½œï¼Œç¡®ä¿å®¡è®¡è¿½è¸ªçš„å®Œæ•´æ€§å’Œä¸å¯ç¯¡æ”¹æ€§ã€‚

**æŠ€æœ¯æ¼”è¿›**:

1. **2010 å¹´**: PostgreSQL æ·»åŠ å®¡è®¡æ—¥å¿—åŠŸèƒ½
2. **2018 å¹´**: ä¸å¯ç¯¡æ”¹å®¡è®¡æ—¥å¿—éœ€æ±‚å¢å¼º
3. **2024 å¹´**: AI Act è¦æ±‚ä¸å¯ç¯¡æ”¹å®¡è®¡æ—¥å¿—
4. **2025 å¹´**: PostgreSQL 18 å¢å¼ºå®¡è®¡æ—¥å¿—åŠŸèƒ½

**å¸‚åœºéœ€æ±‚**:

- **å®Œæ•´è®°å½•**: è®°å½•æ‰€æœ‰æ•°æ®æ“ä½œ
- **ä¸å¯ç¯¡æ”¹**: ä¿è¯æ—¥å¿—ä¸å¯ç¯¡æ”¹
- **å¿«é€ŸæŸ¥è¯¢**: æ”¯æŒå¿«é€ŸæŸ¥è¯¢å’Œåˆ†æ
- **åˆè§„å®¡è®¡**: æ»¡è¶³åˆè§„å®¡è®¡è¦æ±‚

### 1.2 æŠ€æœ¯å®šä½

å®¡è®¡æ—¥å¿—æœºåˆ¶æ˜¯åˆè§„æ•°æ®åº“çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œé€šè¿‡ä¸å¯ç¯¡æ”¹çš„æ—¥å¿—è®°å½•ï¼Œç¡®ä¿æ•°æ®æ“ä½œçš„å®Œæ•´å®¡è®¡è¿½è¸ªã€‚

### 1.3 æ ¸å¿ƒä»·å€¼

- **å®Œæ•´å®¡è®¡**: å®Œæ•´è®°å½•æ‰€æœ‰æ“ä½œ
- **ä¸å¯ç¯¡æ”¹**: ä¿è¯æ—¥å¿—å®Œæ•´æ€§
- **å¿«é€ŸæŸ¥è¯¢**: æ”¯æŒé«˜æ•ˆæŸ¥è¯¢
- **åˆè§„ä¿éšœ**: æ»¡è¶³åˆè§„è¦æ±‚

---

## 2. æŠ€æœ¯åŸç†

### 2.1 å®¡è®¡æ—¥å¿—åŸç†

**æ—¥å¿—å†…å®¹**:

- **æ“ä½œç±»å‹**: SELECT, INSERT, UPDATE, DELETE
- **æ“ä½œæ—¶é—´**: æ“ä½œæ—¶é—´æˆ³
- **æ“ä½œç”¨æˆ·**: æ‰§è¡Œæ“ä½œçš„ç”¨æˆ·
- **æ“ä½œå¯¹è±¡**: è¡¨ã€è¡Œã€åˆ—
- **æ“ä½œå†…å®¹**: æ“ä½œå‰åçš„æ•°æ®

### 2.2 æ—¥å¿—è®°å½•æœºåˆ¶

**è®°å½•æ–¹å¼**:

- **è§¦å‘å™¨**: ä½¿ç”¨è§¦å‘å™¨è‡ªåŠ¨è®°å½•
- **æ‰©å±•**: ä½¿ç”¨å®¡è®¡æ‰©å±•è®°å½•
- **WAL**: åŸºäº WAL è®°å½•

### 2.3 å®Œæ•´æ€§ä¿è¯

**å®Œæ•´æ€§æœºåˆ¶**:

- **å“ˆå¸Œé“¾**: ä½¿ç”¨å“ˆå¸Œé“¾ä¿è¯å®Œæ•´æ€§
- **æ•°å­—ç­¾å**: ä½¿ç”¨æ•°å­—ç­¾åéªŒè¯
- **å®šæœŸæ ¡éªŒ**: å®šæœŸæ ¡éªŒæ—¥å¿—å®Œæ•´æ€§

### 2.4 ä¸å¯ç¯¡æ”¹æœºåˆ¶

**ä¸å¯ç¯¡æ”¹å®ç°**:

```sql
-- ä½¿ç”¨ Ledger è¡¨å®ç°ä¸å¯ç¯¡æ”¹
CREATE TABLE audit_ledger (
    id BIGSERIAL PRIMARY KEY,
    previous_hash TEXT,
    current_hash TEXT,
    operation_type TEXT,
    table_name TEXT,
    row_id BIGINT,
    old_data JSONB,
    new_data JSONB,
    user_name TEXT,
    operation_time TIMESTAMPTZ DEFAULT NOW()
);
```

---

## 3. æ¶æ„è®¾è®¡

### 3.1 æ•´ä½“æ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Audit Log System                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Log Collector                   â”‚  â”‚
â”‚  â”‚  - Trigger-based                 â”‚  â”‚
â”‚  â”‚  - Extension-based               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Hash Chain Manager              â”‚  â”‚
â”‚  â”‚  - Hash Calculation              â”‚  â”‚
â”‚  â”‚  - Chain Verification            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Log Storage                     â”‚  â”‚
â”‚  â”‚  - Ledger Table                  â”‚  â”‚
â”‚  â”‚  - Partitioned Storage           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ—¥å¿—å­˜å‚¨

**å­˜å‚¨ç­–ç•¥**:

- **åˆ†åŒºå­˜å‚¨**: æŒ‰æ—¶é—´åˆ†åŒºå­˜å‚¨
- **å‹ç¼©å­˜å‚¨**: å‹ç¼©å†å²æ—¥å¿—
- **å½’æ¡£å­˜å‚¨**: å½’æ¡£æ—§æ—¥å¿—

### 3.3 æ—¥å¿—æŸ¥è¯¢

**æŸ¥è¯¢åŠŸèƒ½**:

- **æ—¶é—´èŒƒå›´æŸ¥è¯¢**: æŒ‰æ—¶é—´èŒƒå›´æŸ¥è¯¢
- **ç”¨æˆ·æŸ¥è¯¢**: æŒ‰ç”¨æˆ·æŸ¥è¯¢
- **æ“ä½œç±»å‹æŸ¥è¯¢**: æŒ‰æ“ä½œç±»å‹æŸ¥è¯¢
- **æ•°æ®å˜æ›´è¿½è¸ª**: è¿½è¸ªæ•°æ®å˜æ›´å†å²

---

## 4. å®ç°ç»†èŠ‚

### 4.1 æ—¥å¿—è¡¨è®¾è®¡

**è¡¨ç»“æ„**:

```sql
CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    previous_hash TEXT,
    current_hash TEXT NOT NULL,
    operation_type TEXT NOT NULL,
    schema_name TEXT,
    table_name TEXT NOT NULL,
    row_id BIGINT,
    old_data JSONB,
    new_data JSONB,
    user_name TEXT NOT NULL,
    application_name TEXT,
    client_addr INET,
    operation_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    transaction_id BIGINT
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_audit_time ON audit_log(operation_time);
CREATE INDEX idx_audit_user ON audit_log(user_name);
CREATE INDEX idx_audit_table ON audit_log(table_name);
CREATE INDEX idx_audit_hash ON audit_log(current_hash);
```

### 4.2 è§¦å‘å™¨å®ç°

**è§¦å‘å™¨å‡½æ•°**:

```sql
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    prev_hash TEXT;
    curr_hash TEXT;
    log_data JSONB;
BEGIN
    -- è·å–å‰ä¸€æ¡è®°å½•çš„å“ˆå¸Œ
    SELECT current_hash INTO prev_hash
    FROM audit_log
    ORDER BY id DESC
    LIMIT 1;

    -- æ„å»ºæ—¥å¿—æ•°æ®
    log_data := jsonb_build_object(
        'operation', TG_OP,
        'old', row_to_json(OLD),
        'new', row_to_json(NEW)
    );

    -- è®¡ç®—å½“å‰å“ˆå¸Œ
    curr_hash := encode(
        digest(
            COALESCE(prev_hash, '') || log_data::text,
            'sha256'
        ),
        'hex'
    );

    -- æ’å…¥å®¡è®¡æ—¥å¿—
    INSERT INTO audit_log (
        previous_hash,
        current_hash,
        operation_type,
        table_name,
        row_id,
        old_data,
        new_data,
        user_name
    ) VALUES (
        prev_hash,
        curr_hash,
        TG_OP,
        TG_TABLE_NAME,
        COALESCE(NEW.id, OLD.id),
        row_to_json(OLD),
        row_to_json(NEW),
        current_user
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 4.3 å“ˆå¸Œé“¾æœºåˆ¶

**å“ˆå¸Œé“¾å®ç°**:

```python
class HashChain:
    """å“ˆå¸Œé“¾"""

    def __init__(self):
        self.chain = []

    def add_record(self, record):
        """æ·»åŠ è®°å½•"""
        # è·å–å‰ä¸€ä¸ªå“ˆå¸Œ
        prev_hash = self.chain[-1].hash if self.chain else None

        # è®¡ç®—å½“å‰å“ˆå¸Œ
        current_hash = self.calculate_hash(prev_hash, record)

        # åˆ›å»ºé“¾èŠ‚ç‚¹
        node = {
            'prev_hash': prev_hash,
            'hash': current_hash,
            'record': record
        }

        # æ·»åŠ åˆ°é“¾
        self.chain.append(node)

        return node

    def verify_chain(self):
        """éªŒè¯é“¾å®Œæ•´æ€§"""
        for i in range(1, len(self.chain)):
            prev_node = self.chain[i-1]
            curr_node = self.chain[i]

            # éªŒè¯å“ˆå¸Œ
            expected_hash = self.calculate_hash(
                prev_node['hash'],
                curr_node['record']
            )

            if expected_hash != curr_node['hash']:
                return False, i  # é“¾åœ¨ä½ç½® i è¢«ç ´å

        return True, None
```

---

## 5. æ€§èƒ½åˆ†æ

**æ€§èƒ½å½±å“**:

- **æ’å…¥å¼€é”€**: <5ms æ¯æ¡è®°å½•
- **æŸ¥è¯¢æ€§èƒ½**: ç´¢å¼•ä¼˜åŒ–å <10ms
- **å­˜å‚¨å¼€é”€**: çº¦ä¸ºåŸå§‹æ•°æ®çš„ 20-30%

**ä¼˜åŒ–å»ºè®®**:

- ä½¿ç”¨åˆ†åŒºè¡¨ç®¡ç†æ—¥å¿—
- å®šæœŸå½’æ¡£æ—§æ—¥å¿—
- ä½¿ç”¨ GIN ç´¢å¼•åŠ é€Ÿ JSONB æŸ¥è¯¢

---

## 6. æœ€ä½³å®è·µ

### 6.1 æ—¥å¿—è®¾è®¡

- **å®Œæ•´è®°å½•**: è®°å½•æ‰€æœ‰å¿…è¦ä¿¡æ¯
- **ç»“æ„åŒ–å­˜å‚¨**: ä½¿ç”¨ç»“æ„åŒ–æ ¼å¼å­˜å‚¨
- **å®šæœŸæ¸…ç†**: å®šæœŸæ¸…ç†è¿‡æœŸæ—¥å¿—

### 6.2 å®Œæ•´æ€§ä¿è¯

- **å“ˆå¸Œé“¾**: ä½¿ç”¨å“ˆå¸Œé“¾ä¿è¯å®Œæ•´æ€§
- **å®šæœŸæ ¡éªŒ**: å®šæœŸæ ¡éªŒæ—¥å¿—å®Œæ•´æ€§
- **å¤‡ä»½ä¿æŠ¤**: å¤‡ä»½æ—¥å¿—æ•°æ®

---

## 7. å‚è€ƒèµ„æ–™

### 7.1 å®˜æ–¹æ–‡æ¡£

- **[PostgreSQL å®¡è®¡æ‰©å±• (pgAudit) æ–‡æ¡£](https://www.postgresql.org/docs/current/pgaudit.html)**
  - ç‰ˆæœ¬: pgAudit 1.6+
  - å†…å®¹: PostgreSQL å®¡è®¡æ‰©å±•çš„å®Œæ•´æ–‡æ¡£
  - GitHub: <https://github.com/pgaudit/pgaudit>
  - æœ€åæ›´æ–°: 2025å¹´

- **[PostgreSQL è§¦å‘å™¨æ–‡æ¡£](https://www.postgresql.org/docs/current/triggers.html)**
  - å†…å®¹: PostgreSQL è§¦å‘å™¨çš„è¯¦ç»†è¯´æ˜ï¼Œç”¨äºå®ç°å®¡è®¡æ—¥å¿—

- **[PostgreSQL WAL æ–‡æ¡£](https://www.postgresql.org/docs/current/wal.html)**
  - å†…å®¹: PostgreSQL WAL (Write-Ahead Logging) çš„è¯¦ç»†è¯´æ˜

### 7.2 å­¦æœ¯è®ºæ–‡

- **Merkle, R. C. (1988). "A Digital Signature Based on a Conventional Encryption Function."**
  - ä¼šè®®: CRYPTO 1987
  - **DOI**: [10.1007/3-540-48184-2_32](https://doi.org/10.1007/3-540-48184-2_32)
  - **é‡è¦æ€§**: Merkle æ ‘çš„åŸå§‹è®ºæ–‡ï¼Œä¸ºå“ˆå¸Œé“¾æä¾›äº†ç†è®ºåŸºç¡€

- **Nakamoto, S. (2008). "Bitcoin: A Peer-to-Peer Electronic Cash System."**
  - **é‡è¦æ€§**: åŒºå—é“¾æŠ€æœ¯çš„ç»å…¸è®ºæ–‡ï¼Œä¸ºä¸å¯ç¯¡æ”¹æ—¥å¿—æä¾›äº†ç†è®ºåŸºç¡€

### 7.3 æŠ€æœ¯åšå®¢

- **[PostgreSQL å®¡è®¡æ—¥å¿—æœ€ä½³å®è·µ](https://www.postgresql.org/docs/current/pgaudit.html)**
  - å†…å®¹: PostgreSQL å®¡è®¡æ—¥å¿—çš„é…ç½®å’Œæœ€ä½³å®è·µ

- **[ä¸å¯ç¯¡æ”¹å®¡è®¡æ—¥å¿—å®ç°](https://www.postgresql.org/docs/current/ledger.html)**
  - å†…å®¹: ä¸å¯ç¯¡æ”¹å®¡è®¡æ—¥å¿—çš„è®¾è®¡å’Œå®ç°æ–¹æ³•

### 7.4 ç›¸å…³èµ„æº

- **[GDPR åˆè§„æŒ‡å—](https://gdpr.eu/)**
  - æ¥æº: GDPR.eu
  - å†…å®¹: GDPR åˆè§„çš„å®Œæ•´æŒ‡å—

- **[AI Act è¦æ±‚](https://digital-strategy.ec.europa.eu/en/policies/regulatory-framework-ai)**
  - æ¥æº: European Commission
  - å†…å®¹: AI Act çš„å®Œæ•´è¦æ±‚å’Œåˆè§„æŒ‡å—

---

## 8. å®Œæ•´ä»£ç ç¤ºä¾‹

### 8.1 å®¡è®¡æ—¥å¿—è¡¨åˆ›å»ºä¸é…ç½®

**åˆ›å»ºå®¡è®¡æ—¥å¿—è¡¨**:

```sql
-- 1. åˆ›å»ºå®¡è®¡æ—¥å¿—è¡¨
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL,  -- INSERT, UPDATE, DELETE
    old_data JSONB,
    new_data JSONB,
    user_name TEXT NOT NULL,
    ip_address INET,
    application_name TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    previous_hash TEXT NOT NULL,
    current_hash TEXT NOT NULL
);

-- 2. åˆ›å»ºç´¢å¼•
CREATE INDEX ON audit_log (table_name, timestamp);
CREATE INDEX ON audit_log (user_name, timestamp);
CREATE INDEX ON audit_log USING GIN (old_data);
CREATE INDEX ON audit_log USING GIN (new_data);

-- 3. åˆ›å»ºå“ˆå¸Œè®¡ç®—å‡½æ•°
CREATE OR REPLACE FUNCTION calculate_hash(
    prev_hash TEXT,
    data JSONB,
    timestamp TIMESTAMPTZ
) RETURNS TEXT AS $$
BEGIN
    RETURN encode(
        digest(
            prev_hash || data::TEXT || timestamp::TEXT,
            'sha256'
        ),
        'hex'
    );
END;
$$ LANGUAGE plpgsql;

-- 4. åˆ›å»ºå®¡è®¡è§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    prev_hash TEXT;
    curr_hash TEXT;
BEGIN
    -- è·å–å‰ä¸€ä¸ªè®°å½•çš„å“ˆå¸Œ
    SELECT current_hash INTO prev_hash
    FROM audit_log
    ORDER BY id DESC
    LIMIT 1;

    IF prev_hash IS NULL THEN
        prev_hash := '0'::TEXT;
    END IF;

    -- è®¡ç®—å½“å‰å“ˆå¸Œ
    curr_hash := calculate_hash(
        prev_hash,
        row_to_json(NEW)::JSONB,
        NOW()
    );

    -- æ’å…¥å®¡è®¡è®°å½•
    INSERT INTO audit_log (
        table_name, operation, new_data,
        previous_hash, current_hash,
        user_name, ip_address, application_name
    ) VALUES (
        TG_TABLE_NAME,
        TG_OP,
        row_to_json(NEW)::JSONB,
        prev_hash,
        curr_hash,
        current_user,
        inet_client_addr(),
        current_setting('application_name')
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 8.2 å®¡è®¡æ—¥å¿—å®Œæ•´æ€§éªŒè¯ç¤ºä¾‹

**Python å®Œæ•´æ€§éªŒè¯è„šæœ¬**:

```python
import psycopg2
import hashlib
from typing import Tuple, Optional

class AuditLogVerifier:
    """å®¡è®¡æ—¥å¿—å®Œæ•´æ€§éªŒè¯å™¨"""

    def __init__(self, connection_string: str):
        self.conn = psycopg2.connect(connection_string)
        self.cur = self.conn.cursor()

    def calculate_hash(self, prev_hash: str, data: str, timestamp: str) -> str:
        """è®¡ç®—å“ˆå¸Œå€¼"""
        hash_input = prev_hash + data + timestamp
        return hashlib.sha256(hash_input.encode()).hexdigest()

    def verify_integrity(self) -> Tuple[bool, Optional[int]]:
        """éªŒè¯å®¡è®¡æ—¥å¿—å®Œæ•´æ€§"""
        self.cur.execute("""
            SELECT id, previous_hash, current_hash, new_data, timestamp
            FROM audit_log
            ORDER BY id
        """)

        prev_record = None
        violation_position = None

        for record in self.cur.fetchall():
            record_id, prev_hash, curr_hash, new_data, timestamp = record

            if prev_record is None:
                # ç¬¬ä¸€æ¡è®°å½•
                if prev_hash != '0':
                    return False, record_id
            else:
                # è®¡ç®—é¢„æœŸå“ˆå¸Œ
                expected_hash = self.calculate_hash(
                    prev_record['current_hash'],
                    str(new_data),
                    str(timestamp)
                )

                # éªŒè¯å“ˆå¸Œ
                if expected_hash != curr_hash:
                    violation_position = record_id
                    return False, violation_position

            prev_record = {
                'id': record_id,
                'current_hash': curr_hash
            }

        return True, None

    def get_audit_trail(self, table_name: str, record_id: int) -> List[Dict]:
        """è·å–æ•°æ®å˜æ›´å†å²"""
        self.cur.execute("""
            SELECT
                id,
                operation,
                old_data,
                new_data,
                user_name,
                timestamp,
                current_hash
            FROM audit_log
            WHERE table_name = %s
              AND (new_data->>'id')::INTEGER = %s
            ORDER BY timestamp
        """, (table_name, record_id))

        columns = [desc[0] for desc in self.cur.description]
        return [dict(zip(columns, row)) for row in self.cur.fetchall()]

    def close(self):
        """å…³é—­è¿æ¥"""
        self.cur.close()
        self.conn.close()

# ä½¿ç”¨ç¤ºä¾‹
verifier = AuditLogVerifier(
    "host=localhost dbname=testdb user=postgres password=secret"
)

# éªŒè¯å®Œæ•´æ€§
is_valid, violation_pos = verifier.verify_integrity()
if is_valid:
    print("å®¡è®¡æ—¥å¿—å®Œæ•´æ€§éªŒè¯é€šè¿‡")
else:
    print(f"å®¡è®¡æ—¥å¿—å®Œæ•´æ€§éªŒè¯å¤±è´¥ï¼Œä½ç½®: {violation_pos}")

# è·å–æ•°æ®å˜æ›´å†å²
history = verifier.get_audit_trail('users', 123)
print(f"æ•°æ®å˜æ›´å†å²: {len(history)} æ¡è®°å½•")

verifier.close()
```

---

**æœ€åæ›´æ–°**: 2025 å¹´ 11 æœˆ 1 æ—¥
**ç»´æŠ¤è€…**: PostgreSQL Modern Team
