# PostgreSQL 事务管理详解

> **更新时间**: 2025 年 11 月 1 日
> **技术版本**: PostgreSQL 14+
> **文档编号**: 03-03-02

## 📑 目录

- [PostgreSQL 事务管理详解](#postgresql-事务管理详解)
  - [📑 目录](#-目录)
  - [1. 事务基础](#1-事务基础)
    - [1.1 ACID 特性](#11-acid-特性)
    - [1.2 事务基本操作](#12-事务基本操作)
  - [2. 事务隔离级别](#2-事务隔离级别)
    - [2.1 隔离级别说明](#21-隔离级别说明)
    - [2.2 隔离级别设置](#22-隔离级别设置)
  - [3. 并发控制](#3-并发控制)
    - [3.1 悲观锁](#31-悲观锁)
    - [3.2 乐观锁](#32-乐观锁)
  - [4. 死锁处理](#4-死锁处理)
  - [5. 实践练习](#5-实践练习)
    - [练习 1: 基本事务操作](#练习-1-基本事务操作)
    - [练习 2: 使用保存点](#练习-2-使用保存点)
  - [6. 参考资料](#6-参考资料)

---

## 1. 事务基础

### 1.1 ACID 特性

**Atomicity（原子性）**:

- 事务中的所有操作要么全部成功，要么全部失败
- 如果任何操作失败，整个事务回滚

**Consistency（一致性）**:

- 事务前后数据库保持一致状态
- 所有约束和规则都被遵守

**Isolation（隔离性）**:

- 并发事务之间相互隔离
- 一个事务的中间状态对其他事务不可见

**Durability（持久性）**:

- 提交的事务永久保存
- 即使系统崩溃也不会丢失

### 1.2 事务基本操作

```sql
-- 开始事务
BEGIN;

-- 或者
BEGIN TRANSACTION;

-- 提交事务
COMMIT;

-- 回滚事务
ROLLBACK;

-- 示例：银行转账
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 如果出错，回滚
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 发生错误
ROLLBACK;
```

**保存点（Savepoint）**:

```sql
BEGIN;
INSERT INTO users (name, email) VALUES ('User1', 'user1@example.com');
SAVEPOINT sp1;
INSERT INTO users (name, email) VALUES ('User2', 'user2@example.com');
ROLLBACK TO SAVEPOINT sp1;  -- 回滚到保存点
COMMIT;  -- User1 会被提交，User2 会被回滚
```

## 2. 事务隔离级别

### 2.1 隔离级别说明

**READ UNCOMMITTED（未提交读）**:

- PostgreSQL 不支持，实际是 READ COMMITTED
- 可能读取到未提交的数据（脏读）

**READ COMMITTED（提交读，默认）**:

- 只能读取已提交的数据
- 可能发生不可重复读
- 可能发生幻读

**REPEATABLE READ（可重复读）**:

- 保证同一事务中多次读取结果一致
- 可能发生幻读

**SERIALIZABLE（串行化）**:

- 最高隔离级别
- 完全避免脏读、不可重复读、幻读
- 性能最低

### 2.2 隔离级别设置

```sql
-- 设置事务隔离级别
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM users WHERE id = 1;
COMMIT;

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM users WHERE id = 1;
COMMIT;

BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM users WHERE id = 1;
COMMIT;

-- 查看当前隔离级别
SHOW transaction_isolation;
```

## 3. 并发控制

### 3.1 悲观锁

```sql
-- SELECT FOR UPDATE（行级排他锁）
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- SELECT FOR SHARE（行级共享锁）
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR SHARE;
-- 其他事务可以读取，但不能修改
COMMIT;

-- SELECT FOR UPDATE NOWAIT（不等待锁）
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT;
-- 如果锁被占用，立即返回错误
COMMIT;
```

### 3.2 乐观锁

```sql
-- 使用版本号
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    price DECIMAL,
    version INTEGER DEFAULT 1
);

-- 更新时检查版本
UPDATE products
SET price = 100, version = version + 1
WHERE id = 1 AND version = 1;
-- 如果 version 不匹配，更新失败（说明数据已被修改）
```

## 4. 死锁处理

```sql
-- 死锁示例
-- 事务 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- 事务 2（同时执行）
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 2;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
COMMIT;

-- PostgreSQL 会自动检测死锁并回滚其中一个事务

-- 查看锁信息
SELECT
    locktype,
    relation::regclass,
    mode,
    granted
FROM pg_locks
WHERE relation = 'accounts'::regclass;
```

## 5. 实践练习

### 练习 1: 基本事务操作

```sql
-- 任务: 实现一个安全的转账操作
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- 检查余额
SELECT balance FROM accounts WHERE id = 1;
-- 如果余额不足，回滚
-- 否则提交
COMMIT;
```

### 练习 2: 使用保存点

```sql
-- 任务: 使用保存点实现部分回滚
BEGIN;
INSERT INTO users (name) VALUES ('User1');
SAVEPOINT sp1;
INSERT INTO users (name) VALUES ('User2');
-- 如果 User2 插入失败，回滚到 sp1
ROLLBACK TO SAVEPOINT sp1;
COMMIT;
```

## 6. 参考资料

- [PostgreSQL 官方文档 - 事务](https://www.postgresql.org/docs/current/tutorial-transactions.html)
- [PostgreSQL 官方文档 - 锁](https://www.postgresql.org/docs/current/explicit-locking.html)

---

**最后更新**: 2025 年 11 月 1 日
**维护者**: PostgreSQL Modern Team
**文档编号**: 03-03-02
