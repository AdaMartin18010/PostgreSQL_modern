# PostgreSQL索引选择算法深度解析

## 1. 索引选择问题

### 1.1 优化器决策过程

```text
查询: SELECT * FROM users WHERE age > 25 AND city = 'NYC';

可用索引:
├─ idx_age: (age)
├─ idx_city: (city)
└─ idx_age_city: (age, city)

优化器评估:
1. 全表扫描
   Cost = seq_page_cost × pages + cpu_tuple_cost × rows

2. idx_age扫描
   Cost = index_scan_cost + filter_cost(city)

3. idx_city扫描
   Cost = index_scan_cost + filter_cost(age)

4. idx_age_city扫描
   Cost = index_scan_cost (最优)

5. Bitmap扫描(idx_age + idx_city)
   Cost = bitmap_cost + recheck_cost

选择成本最低的计划
```

---

## 2. 选择性分析

### 2.1 计算选择性

```sql
-- 查看列的选择性
SELECT
    attname,
    n_distinct,
    CASE
        WHEN n_distinct > 0 THEN 1.0 / n_distinct
        WHEN n_distinct < 0 THEN -n_distinct
        ELSE 0
    END AS selectivity
FROM pg_stats
WHERE tablename = 'users';

/*
列         n_distinct   selectivity
user_id    -1.0         1.0 (唯一)
email      -0.99        0.99 (几乎唯一)
city       50           0.02 (50个城市)
status     3            0.33 (3种状态)

selectivity越低，索引越有效
*/

-- 组合选择性
SELECT
    COUNT(DISTINCT (age, city))::float / COUNT(*) AS combined_selectivity
FROM users;
```

---

## 3. 成本估算

### 3.1 索引扫描成本

```sql
-- 查看成本参数
SHOW seq_page_cost;        -- 1.0
SHOW random_page_cost;     -- 4.0 (HDD) / 1.1 (SSD)
SHOW cpu_tuple_cost;       -- 0.01
SHOW cpu_index_tuple_cost; -- 0.005

-- 估算公式
/*
Index Scan成本:
= index_startup_cost
+ index_pages × random_page_cost
+ index_tuples × cpu_index_tuple_cost
+ heap_pages × random_page_cost
+ heap_tuples × cpu_tuple_cost

Seq Scan成本:
= pages × seq_page_cost
+ tuples × cpu_tuple_cost
*/

-- 查看实际成本
EXPLAIN (COSTS, BUFFERS)
SELECT * FROM users WHERE city = 'NYC';
```

---

## 4. 多列索引顺序

### 4.1 最优顺序选择

```sql
-- 查询模式分析
/*
查询1: WHERE a = ? AND b = ?          (频率: 1000次/秒)
查询2: WHERE a = ?                     (频率: 500次/秒)
查询3: WHERE b = ?                     (频率: 100次/秒)
查询4: WHERE a = ? ORDER BY c          (频率: 200次/秒)
*/

-- 方案1: (a, b, c)
CREATE INDEX idx_abc ON table(a, b, c);
-- 查询1: ✓ 完全使用
-- 查询2: ✓ 使用a
-- 查询3: ✗ 无法使用 (PostgreSQL 18: Skip Scan可以!)
-- 查询4: ✓ 使用a，排序c

-- 方案2: (b, a, c)
CREATE INDEX idx_bac ON table(b, a, c);
-- 查询1: ✓ 完全使用
-- 查询2: ✗ 无法使用
-- 查询3: ✓ 使用b
-- 查询4: ✗ 无法优化排序

-- 选择: 方案1 (高频查询优先)
```

### 4.2 选择性排序

```sql
-- 规则: 选择性高的列在前

-- 列选择性
SELECT
    'age' AS column,
    COUNT(DISTINCT age)::float / COUNT(*) AS selectivity
FROM users
UNION ALL
SELECT 'city', COUNT(DISTINCT city)::float / COUNT(*) FROM users
UNION ALL
SELECT 'status', COUNT(DISTINCT status)::float / COUNT(*) FROM users;

/*
column    selectivity
age       0.05 (20种年龄段)
city      0.02 (50个城市)
status    0.33 (3种状态)

排序: city, age, status
*/

CREATE INDEX idx_city_age_status ON users(city, age, status);
```

---

## 5. 部分索引决策

### 5.1 何时使用

```sql
-- 场景: 查询只关注活跃用户（占10%）

-- 方案1: 全索引
CREATE INDEX idx_status_full ON users(status);
-- 大小: 100MB
-- 查询活跃用户: 使用索引

-- 方案2: 部分索引
CREATE INDEX idx_status_active ON users(status) WHERE status = 'active';
-- 大小: 10MB (-90%)
-- 查询活跃用户: 使用索引
-- 查询非活跃: 全表扫描（但数据少）

-- 选择: 部分索引（节省90%空间和写入开销）

-- 适用条件:
-- ✓ 查询集中在某个子集
-- ✓ 子集占比<20%
-- ✓ 其他数据查询频率低
```

---

## 6. 索引维护策略

### 6.1 何时重建

```sql
-- 检查索引膨胀
WITH index_stats AS (
    SELECT
        schemaname,
        tablename,
        indexname,
        pg_relation_size(indexrelid) AS index_size,
        idx_scan,
        idx_tup_read,
        idx_tup_fetch
    FROM pg_stat_user_indexes
)
SELECT
    indexname,
    pg_size_pretty(index_size) AS size,
    idx_scan,
    CASE
        WHEN idx_scan = 0 THEN '未使用'
        WHEN idx_tup_fetch::float / idx_scan < 10 THEN '效率低'
        WHEN index_size > 1073741824 THEN '考虑重建'
        ELSE '正常'
    END AS status
FROM index_stats
WHERE index_size > 104857600  -- >100MB
ORDER BY index_size DESC;

-- 重建索引
REINDEX INDEX CONCURRENTLY idx_users_email;

-- 定期维护
-- 每月重建大索引（>1GB）
-- 每季度重建所有索引
```

---

## 7. 实战案例

### 7.1 电商订单索引设计

```sql
-- 订单表
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL,
    amount NUMERIC(12,2) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 查询模式分析
/*
Q1: WHERE user_id = ? ORDER BY created_at DESC  (90%)
Q2: WHERE status = 'pending'                     (5%)
Q3: WHERE created_at > ? AND status = ?          (3%)
Q4: WHERE amount > 1000                          (2%)
*/

-- 索引设计
-- 主索引（覆盖Q1）
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at DESC);

-- 部分索引（覆盖Q2）
CREATE INDEX idx_orders_pending ON orders(status, created_at)
WHERE status = 'pending';

-- 组合索引（覆盖Q3）
CREATE INDEX idx_orders_created_status ON orders(created_at, status);

-- Q4: 频率低，全表扫描可接受

-- 验证
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 123 ORDER BY created_at DESC LIMIT 10;
-- 使用: idx_orders_user_created
```

---

**完成**: PostgreSQL索引选择算法深度解析
**字数**: ~10,000字
**涵盖**: 优化器决策、选择性分析、成本估算、多列索引、部分索引、实战案例
