# 连接问题诊断案例

> **PostgreSQL 18**
> **连接池、超时、连接泄漏**

---

## 案例1：连接数耗尽

### 症状

```text
错误信息：
FATAL: remaining connection slots are reserved for non-replication superuser connections

应用无法建立新连接
现有连接正常
```

### 诊断

```sql
-- 检查当前连接数
SELECT
    count(*) AS total_connections,
    count(*) FILTER (WHERE state = 'active') AS active,
    count(*) FILTER (WHERE state = 'idle') AS idle,
    count(*) FILTER (WHERE state = 'idle in transaction') AS idle_in_transaction,
    setting AS max_connections
FROM pg_stat_activity
CROSS JOIN pg_settings
WHERE name = 'max_connections'
GROUP BY setting;

/*
total_connections: 98
max_connections: 100
idle_in_transaction: 45 (问题！)
*/

-- 查找连接来源
SELECT
    usename,
    application_name,
    client_addr,
    count(*) AS connection_count,
    count(*) FILTER (WHERE state = 'idle in transaction') AS idle_tx_count
FROM pg_stat_activity
WHERE datname = current_database()
GROUP BY usename, application_name, client_addr
ORDER BY connection_count DESC;

/*
application_name: web_app
connection_count: 50
idle_tx_count: 30 (问题！)
*/
```

### 解决

```sql
-- 立即：终止空闲事务
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle in transaction'
  AND now() - state_change > interval '5 minutes';

-- 长期：使用连接池
-- 方案1：PgBouncer（推荐）
-- 配置：pool_mode = transaction
-- max_client_conn = 1000
-- default_pool_size = 25

-- 方案2：应用层连接池
-- 限制每个应用实例的连接数
-- 使用连接池库（如HikariCP）

-- 方案3：设置超时
ALTER DATABASE mydb SET idle_in_transaction_session_timeout = '10min';
ALTER DATABASE mydb SET statement_timeout = '30s';
```

---

## 案例2：连接超时

### 症状

```text
错误信息：
timeout expired
connection timed out

应用间歇性无法连接
网络正常
```

### 诊断

```sql
-- 检查连接等待
SELECT
    pid,
    usename,
    state,
    wait_event_type,
    wait_event,
    query_start,
    now() - query_start AS query_duration
FROM pg_stat_activity
WHERE wait_event_type IS NOT NULL
ORDER BY query_duration DESC;

-- 检查锁等待
SELECT
    blocked.pid AS blocked_pid,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query,
    now() - blocking.query_start AS blocking_duration
FROM pg_stat_activity blocked
JOIN pg_locks blocked_lock ON blocked.pid = blocked_lock.pid
JOIN pg_locks blocking_lock ON blocking_lock.locktype = blocked_lock.locktype
    AND blocking_lock.pid != blocked_lock.pid
JOIN pg_stat_activity blocking ON blocking.pid = blocking_lock.pid
WHERE NOT blocked_lock.granted
  AND blocking_lock.granted;

-- 检查网络延迟
SELECT
    client_addr,
    count(*) AS connections,
    avg(now() - backend_start) AS avg_connection_age
FROM pg_stat_activity
WHERE client_addr IS NOT NULL
GROUP BY client_addr;
```

### 解决

```sql
-- 1. 优化慢查询
-- 使用EXPLAIN ANALYZE找到慢查询
-- 添加索引、优化JOIN

-- 2. 设置合理的超时
ALTER DATABASE mydb SET statement_timeout = '30s';
ALTER DATABASE mydb SET lock_timeout = '10s';

-- 3. 使用连接池（减少连接建立开销）
-- PgBouncer配置：
-- pool_mode = transaction
-- server_connect_timeout = 15

-- 4. 应用层重试机制
-- 指数退避重试
-- 连接健康检查
```

---

## 案例3：连接泄漏

### 症状

```text
连接数持续增长
应用重启后连接数下降
内存使用持续增加
```

### 诊断

```sql
-- 查找长时间空闲连接
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    backend_start,
    state,
    state_change,
    now() - backend_start AS connection_age,
    now() - state_change AS idle_duration,
    query
FROM pg_stat_activity
WHERE datname = current_database()
  AND state IN ('idle', 'idle in transaction')
ORDER BY idle_duration DESC;

-- 查找应用连接模式
SELECT
    application_name,
    client_addr,
    count(*) AS connection_count,
    min(backend_start) AS first_connection,
    max(backend_start) AS last_connection
FROM pg_stat_activity
WHERE datname = current_database()
GROUP BY application_name, client_addr
ORDER BY connection_count DESC;

/*
application_name: web_app
connection_count: 200 (异常高！)
*/
```

### 解决

```python
# 应用层：确保连接关闭
# 错误示例
def bad_query():
    conn = psycopg2.connect(...)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")
    # 忘记关闭连接！❌
    return cursor.fetchall()

# 正确示例1：使用上下文管理器
def good_query():
    with psycopg2.connect(...) as conn:
        with conn.cursor() as cursor:
            cursor.execute("SELECT * FROM users")
            return cursor.fetchall()
    # 自动关闭连接 ✓

# 正确示例2：使用连接池
from psycopg2 import pool

connection_pool = pool.SimpleConnectionPool(
    minconn=1,
    maxconn=10,  # 限制最大连接数
    ...
)

def query_with_pool():
    conn = connection_pool.getconn()
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users")
        return cursor.fetchall()
    finally:
        connection_pool.putconn(conn)  # 归还连接
```

```sql
-- 数据库层：自动清理空闲连接
ALTER DATABASE mydb SET idle_in_transaction_session_timeout = '10min';
ALTER DATABASE mydb SET idle_session_timeout = '1h';

-- 监控连接趋势
CREATE VIEW connection_stats AS
SELECT
    date_trunc('minute', now()) AS time,
    count(*) AS total_connections,
    count(*) FILTER (WHERE state = 'active') AS active,
    count(*) FILTER (WHERE state = 'idle') AS idle
FROM pg_stat_activity
GROUP BY time;
```

---

## 案例4：连接池配置不当

### 症状

```text
使用PgBouncer后性能下降
连接池命中率低
查询变慢
```

### 诊断

```sql
-- 检查PgBouncer统计（如果启用pg_stat_statements）
SELECT
    datname,
    usename,
    count(*) AS connections,
    sum(xact_count) AS transactions,
    sum(query_count) AS queries
FROM pg_stat_database
GROUP BY datname, usename;

-- 检查连接池使用情况
-- PgBouncer管理界面：
-- SHOW POOLS;
-- SHOW STATS;
```

### 解决

```ini
# PgBouncer配置优化

# 1. 选择合适的pool_mode
# transaction: 适合OLTP（推荐）
# session: 适合需要会话状态的场景
# statement: 适合简单查询

pool_mode = transaction

# 2. 设置合理的连接池大小
# 公式：max_client_conn / max_pool_size ≈ 10-20
max_client_conn = 1000
default_pool_size = 25  # 每个数据库的连接数

# 3. 设置超时
server_idle_timeout = 600  # 10分钟
query_timeout = 0  # 不限制查询时间（由PostgreSQL控制）
query_wait_timeout = 120  # 等待可用连接的时间

# 4. 启用连接复用
reserve_pool_size = 5  # 保留连接数
reserve_pool_timeout = 3  # 等待保留连接的时间
```

---

**文档完成** ✅
