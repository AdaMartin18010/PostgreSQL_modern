# 锁冲突诊断案例

> **PostgreSQL 18**

---

## 案例1：长事务阻塞

### 症状

```
应用报错：timeout waiting for lock
大量查询等待
```

### 诊断

```sql
-- 查找锁等待
SELECT
    blocked.pid AS blocked_pid,
    blocked.query AS blocked_query,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query,
    blocking.state,
    blocking.query_start
FROM pg_stat_activity blocked
JOIN pg_locks blocked_lock ON blocked.pid = blocked_lock.pid
JOIN pg_locks blocking_lock ON blocking_lock.locktype = blocked_lock.locktype
    AND blocking_lock.pid != blocked_lock.pid
JOIN pg_stat_activity blocking ON blocking.pid = blocking_lock.pid
WHERE NOT blocked_lock.granted
  AND blocking_lock.granted;

/*
blocking_pid: 12345
blocking_query: UPDATE orders SET ...（已运行30分钟）
state: idle in transaction  -- 忘记COMMIT！
*/
```

### 解决

```sql
-- 立即：杀死阻塞会话
SELECT pg_terminate_backend(12345);

-- 长期：设置超时
ALTER DATABASE mydb SET statement_timeout = '30s';
ALTER DATABASE mydb SET idle_in_transaction_session_timeout = '10min';
```

---

## 案例2：死锁

### 症状

```
ERROR: deadlock detected
DETAIL: Process 123 waits for ShareLock on transaction 456
Process 456 waits for ShareLock on transaction 123
```

### 诊断

```sql
-- 查看日志
SELECT * FROM pg_stat_database WHERE datname = current_database();

-- deadlocks字段显示死锁次数

-- 启用死锁日志
ALTER SYSTEM SET deadlock_timeout = '1s';
ALTER SYSTEM SET log_lock_waits = on;
```

### 解决

```sql
-- 代码层面：统一表访问顺序

-- 错误代码（可能死锁）
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';  -- 事务1
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';  -- 事务1

-- 同时
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 'B';  -- 事务2
UPDATE accounts SET balance = balance + 50 WHERE account_id = 'A';  -- 事务2
-- 死锁！

-- 正确代码（按account_id排序）
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'A';
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'B';
COMMIT;
```

---

## 案例3：表级锁冲突

### 症状

```sql
-- DDL操作被阻塞
ALTER TABLE orders ADD COLUMN new_col INT;
-- 一直等待...
```

### 诊断

```sql
-- 查看表锁
SELECT
    l.pid,
    l.mode,
    l.granted,
    a.query,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.relation = 'orders'::regclass;

/*
mode: AccessShareLock, granted: true（查询持有）
mode: AccessExclusiveLock, granted: false（DDL等待）
*/
```

### 解决

```sql
-- 方案1：使用CONCURRENTLY（不阻塞）
CREATE INDEX CONCURRENTLY idx_orders_new ON orders(new_col);

-- 方案2：在业务低峰期执行DDL
-- 方案3：使用pg_terminate_backend杀死长查询（谨慎）
```

---

**文档完成** ✅
