# 存储问题诊断案例

> **PostgreSQL 18**
> **表膨胀、VACUUM、磁盘空间**

---

## 案例1：表膨胀严重

### 症状

```text
表大小持续增长
查询变慢
磁盘空间不足
n_dead_tup比例高（>30%）
```

### 诊断

```sql
-- 检查表膨胀情况
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    n_live_tup,
    n_dead_tup,
    round(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE n_dead_tup > 0
ORDER BY n_dead_tup DESC;

/*
tablename: orders
total_size: 50GB
table_size: 45GB
n_live_tup: 10,000,000
n_dead_tup: 5,000,000
dead_ratio: 33.33% (严重膨胀！)
last_autovacuum: 2025-12-01 (一周前)
*/

-- 检查索引膨胀
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexrelid) > 1024 * 1024 * 1024  -- >1GB
ORDER BY pg_relation_size(indexrelid) DESC;

-- 检查VACUUM进度
SELECT
    pid,
    datname,
    usename,
    application_name,
    state,
    query,
    phase,
    heap_blks_total,
    heap_blks_scanned,
    heap_blks_vacuumed,
    index_vacuum_count,
    max_dead_tuples,
    num_dead_tuples
FROM pg_stat_progress_vacuum;
```

### 解决

```sql
-- 1. 立即VACUUM（不锁表）
VACUUM ANALYZE orders;

-- 2. 如果无效，使用VACUUM FULL（锁表，需谨慎）
-- 在业务低峰期执行
VACUUM FULL ANALYZE orders;

-- 3. 重建表（推荐，不锁表）
BEGIN;
CREATE TABLE orders_new (LIKE orders INCLUDING ALL);
INSERT INTO orders_new SELECT * FROM orders;
ALTER TABLE orders RENAME TO orders_old;
ALTER TABLE orders_new RENAME TO orders;
-- 重建索引
CREATE INDEX CONCURRENTLY idx_orders_customer ON orders(customer_id);
-- ... 其他索引
COMMIT;
DROP TABLE orders_old;

-- 4. 调整autovacuum参数
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.1,  -- 10%死元组触发
    autovacuum_vacuum_threshold = 1000,
    autovacuum_analyze_scale_factor = 0.05,
    autovacuum_analyze_threshold = 500
);

-- 5. 使用fillfactor预留空间（减少未来膨胀）
ALTER TABLE orders SET (fillfactor = 80);  -- 预留20%空间
```

---

## 案例2：磁盘空间不足

### 症状

```text
错误：could not extend file
磁盘使用率>90%
无法写入数据
```

### 诊断

```sql
-- 检查数据库大小
SELECT
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC;

-- 检查表大小
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) -
                   pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;

-- 检查WAL大小
SELECT
    pg_size_pretty(pg_wal_lsn_diff(
        pg_current_wal_lsn(),
        '0/0'
    )) AS total_wal_size;

-- 检查WAL目录大小（需要系统命令）
-- SELECT pg_ls_waldir();

-- 检查临时文件
SELECT
    datname,
    temp_files,
    pg_size_pretty(temp_bytes) AS temp_size
FROM pg_stat_database
WHERE temp_bytes > 0
ORDER BY temp_bytes DESC;

-- 检查TOAST表大小
SELECT
    schemaname,
    tablename,
    pg_size_pretty(
        (SELECT pg_total_relation_size(oid)
         FROM pg_class
         WHERE relname = tablename || '_toast')
    ) AS toast_size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY toast_size DESC NULLS LAST
LIMIT 10;
```

### 解决

```sql
-- 1. 清理死元组（释放空间）
VACUUM FULL;

-- 2. 清理WAL（如果使用归档）
-- 检查归档配置
SHOW archive_mode;
SHOW archive_command;

-- 如果使用pg_wal_archive，清理旧WAL
-- 注意：确保已归档到备份位置

-- 3. 删除不需要的数据
-- 删除旧数据
DELETE FROM orders WHERE order_date < '2020-01-01';
VACUUM FULL orders;

-- 4. 使用表分区（管理大表）
-- 按月分区，删除旧分区
DROP TABLE orders_2020_01;  -- 删除整个分区

-- 5. 压缩大对象
-- 检查大对象
SELECT
    oid,
    pg_size_pretty(pg_largeobject_length(oid)) AS size
FROM pg_largeobject_metadata
ORDER BY pg_largeobject_length(oid) DESC
LIMIT 10;

-- 6. 扩展磁盘（如果可能）
-- 添加新的表空间
CREATE TABLESPACE new_tablespace LOCATION '/new/disk/path';
ALTER TABLE orders SET TABLESPACE new_tablespace;
```

---

## 案例3：VACUUM不工作

### 症状

```text
autovacuum未运行
表持续膨胀
last_autovacuum为NULL或很久以前
```

### 诊断

```sql
-- 检查autovacuum状态
SELECT
    name,
    setting,
    unit,
    context
FROM pg_settings
WHERE name LIKE '%autovacuum%'
ORDER BY name;

/*
autovacuum = on (应该开启)
autovacuum_max_workers = 3
autovacuum_naptime = 1min
*/

-- 检查autovacuum进程
SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    query_start
FROM pg_stat_activity
WHERE query LIKE '%autovacuum%'
   OR application_name = 'autovacuum launcher'
   OR application_name LIKE 'autovacuum worker%';

-- 检查表级autovacuum设置
SELECT
    schemaname,
    tablename,
    reloptions
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
  AND reloptions IS NOT NULL;

-- 检查autovacuum统计
SELECT
    schemaname,
    tablename,
    n_dead_tup,
    n_live_tup,
    last_vacuum,
    last_autovacuum,
    vacuum_count,
    autovacuum_count,
    last_analyze,
    last_autoanalyze,
    analyze_count,
    autoanalyze_count
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;

-- 检查autovacuum日志（需要配置）
-- log_autovacuum_min_duration = 0
-- 查看PostgreSQL日志文件
```

### 解决

```sql
-- 1. 确保autovacuum开启
ALTER SYSTEM SET autovacuum = on;
SELECT pg_reload_conf();

-- 2. 调整autovacuum参数
-- postgresql.conf
autovacuum_max_workers = 3  -- 增加worker数
autovacuum_naptime = 30s  -- 减少等待时间
autovacuum_vacuum_scale_factor = 0.1  -- 10%死元组触发
autovacuum_analyze_scale_factor = 0.05  -- 5%变化触发ANALYZE

-- 3. 表级调整（针对大表）
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.05,  -- 更频繁
    autovacuum_vacuum_threshold = 5000,
    autovacuum_analyze_scale_factor = 0.02
);

-- 4. 手动触发VACUUM
VACUUM ANALYZE orders;

-- 5. 检查autovacuum阻塞
SELECT
    blocked.pid AS blocked_pid,
    blocking.pid AS blocking_pid,
    blocking.query AS blocking_query
FROM pg_stat_activity blocked
JOIN pg_locks blocked_lock ON blocked.pid = blocked_lock.pid
JOIN pg_locks blocking_lock ON blocking_lock.locktype = blocked_lock.locktype
    AND blocking_lock.pid != blocked_lock.pid
JOIN pg_stat_activity blocking ON blocking.pid = blocking_lock.pid
WHERE blocked.query LIKE '%autovacuum%'
  AND NOT blocked_lock.granted
  AND blocking_lock.granted;
```

---

## 案例4：索引膨胀

### 症状

```text
索引大小异常大
查询性能下降
索引扫描慢
```

### 诊断

```sql
-- 检查索引大小
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
    pg_size_pretty(pg_relation_size(indrelid)) AS table_size,
    round(100.0 * pg_relation_size(indexrelid) /
          NULLIF(pg_relation_size(indrelid), 0), 2) AS index_ratio,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE pg_relation_size(indexrelid) > 1024 * 1024 * 1024  -- >1GB
ORDER BY pg_relation_size(indexrelid) DESC;

/*
indexname: idx_orders_customer
index_size: 15GB
table_size: 10GB
index_ratio: 150% (异常！索引比表还大)
idx_scan: 1000 (使用频率低)
*/

-- 检查索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN '未使用'
        WHEN idx_scan < 100 THEN '使用频率低'
        ELSE '正常使用'
    END AS usage_status
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;

-- 检查重复索引
SELECT
    a.schemaname,
    a.tablename,
    a.indexname AS index1,
    b.indexname AS index2,
    a.indexdef AS def1,
    b.indexdef AS def2
FROM pg_indexes a
JOIN pg_indexes b ON a.schemaname = b.schemaname
    AND a.tablename = b.tablename
    AND a.indexname < b.indexname
WHERE a.indexdef = b.indexdef;  -- 完全相同的索引
```

### 解决

```sql
-- 1. 重建索引（不锁表）
REINDEX INDEX CONCURRENTLY idx_orders_customer;

-- 2. 重建表的所有索引
REINDEX TABLE CONCURRENTLY orders;

-- 3. 删除未使用的索引
DROP INDEX CONCURRENTLY idx_unused_index;

-- 4. 合并重复索引
-- 如果两个索引功能相同，删除一个
DROP INDEX CONCURRENTLY idx_orders_customer_old;

-- 5. 优化索引定义
-- 使用部分索引（如果适用）
DROP INDEX idx_orders_status;
CREATE INDEX idx_orders_status_active
ON orders(status)
WHERE status = 'active';

-- 使用覆盖索引（INCLUDE列）
DROP INDEX idx_orders_customer;
CREATE INDEX idx_orders_customer
ON orders(customer_id)
INCLUDE (order_date, amount);
```

---

## 案例5：WAL空间占用过大

### 症状

```text
WAL目录占用大量空间
磁盘空间不足
pg_wal目录>50GB
```

### 诊断

```sql
-- 检查WAL使用情况
SELECT
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            '0/0'
        )
    ) AS total_wal_size;

-- 检查WAL段数量（需要系统访问）
-- SELECT count(*) FROM pg_ls_waldir();

-- 检查复制槽（可能阻止WAL清理）
SELECT
    slot_name,
    slot_type,
    database,
    active,
    restart_lsn,
    confirmed_flush_lsn,
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            COALESCE(confirmed_flush_lsn, restart_lsn)
        )
    ) AS retained_wal_size
FROM pg_replication_slots;

-- 检查checkpoint配置
SELECT
    name,
    setting,
    unit
FROM pg_settings
WHERE name IN (
    'checkpoint_timeout',
    'max_wal_size',
    'min_wal_size',
    'wal_keep_size'
);
```

### 解决

```sql
-- 1. 调整checkpoint参数
ALTER SYSTEM SET max_wal_size = '4GB';  -- 限制WAL大小
ALTER SYSTEM SET checkpoint_timeout = '15min';  -- 更频繁checkpoint
SELECT pg_reload_conf();

-- 2. 手动checkpoint
CHECKPOINT;

-- 3. 清理不活跃的复制槽
SELECT pg_drop_replication_slot('old_slot_name');

-- 4. 如果使用归档，确保归档正常
-- 检查归档命令
SHOW archive_command;

-- 5. 监控WAL生成速度
CREATE VIEW wal_generation_rate AS
SELECT
    now() AS time,
    pg_current_wal_lsn() AS current_lsn,
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            '0/0'
        )
    ) AS total_wal_size;

-- 6. 优化写入模式（如果允许）
-- 批量提交事务
-- 减少不必要的WAL（使用UNLOGGED表，如果允许）
```

---

**文档完成** ✅
