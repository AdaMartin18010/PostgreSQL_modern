# 慢查询诊断案例

> **PostgreSQL 18**

---

## 案例1：缺失索引

### 症状

```sql
-- 查询慢（15秒）
SELECT * FROM orders WHERE customer_id = 12345;
```

### 诊断

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE customer_id = 12345;

/*
Seq Scan on orders (cost=0.00..150000.00 rows=1250 width=120)
                   (actual time=0.5..15000ms rows=1250 loops=1)
  Filter: (customer_id = 12345)
  Rows Removed by Filter: 9998750
  Buffers: shared hit=75000
*/

-- 问题：全表扫描，扫描1000万行
```

### 解决

```sql
-- 创建索引
CREATE INDEX idx_orders_customer ON orders(customer_id);

-- 查询时间：15秒 → 8ms（-99.9%）
```

---

## 案例2：统计信息过期

### 症状

```sql
-- JOIN查询慢（45秒）
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date = '2025-12-04';
```

### 诊断

```sql
EXPLAIN ANALYZE ...

/*
Hash Join (cost=... rows=100 width=...)  -- 估计100行
           (actual time=... rows=125000 ...)  -- 实际125000行
  -- 基数估计严重偏离
*/

-- 检查统计信息
SELECT
    schemaname,
    tablename,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE tablename = 'orders';
```

### 解决

```sql
-- 更新统计信息
ANALYZE orders;

-- ⭐ PostgreSQL 18：创建多变量统计
CREATE STATISTICS orders_stats (dependencies, ndistinct)
ON customer_id, order_date FROM orders;

ANALYZE orders;

-- 查询时间：45秒 → 6秒（-87%）
```

---

## 案例3：N+1查询

### 症状

```python
# 应用代码
for order in orders:
    customer = db.query("SELECT * FROM customers WHERE id = ?", order.customer_id)
    # 执行1000次查询！
```

### 诊断

```sql
-- pg_stat_statements显示
SELECT query, calls FROM pg_stat_statements
WHERE query LIKE '%customers WHERE id%';

-- calls = 1000（异常高）
```

### 解决

```python
# 使用JOIN一次查询
orders_with_customers = db.query("""
    SELECT o.*, c.*
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
    WHERE o.order_date = '2025-12-04'
""")

# 查询次数：1000 → 1
# 时间：10秒 → 0.5秒（-95%）
```

---

**文档完成** ✅
