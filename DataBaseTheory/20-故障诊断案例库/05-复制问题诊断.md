# 复制问题诊断案例

> **PostgreSQL 18**
> **流复制、逻辑复制、延迟**

---

## 案例1：复制延迟高

### 症状

```text
主从延迟持续增长
从库查询数据滞后
监控显示replay_lag > 1分钟
```

### 诊断

```sql
-- 在主库检查复制状态
SELECT
    client_addr,
    usename,
    application_name,
    state,
    sync_state,
    write_lag,
    flush_lag,
    replay_lag,
    sync_priority,
    sync_state
FROM pg_stat_replication;

/*
replay_lag: 00:05:23.456789 (5分钟延迟！)
state: streaming
*/

-- 检查WAL生成速度
SELECT
    pg_size_pretty(pg_wal_lsn_diff(
        pg_current_wal_lsn(),
        '0/0'
    )) AS total_wal_size;

-- 检查从库状态
SELECT
    pg_is_in_recovery() AS is_replica,
    pg_last_wal_receive_lsn() AS receive_lsn,
    pg_last_wal_replay_lsn() AS replay_lsn,
    pg_wal_lsn_diff(
        pg_last_wal_receive_lsn(),
        pg_last_wal_replay_lsn()
    ) AS lag_bytes;

-- 检查从库应用延迟原因
SELECT
    pid,
    usename,
    application_name,
    state,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE backend_type = 'walreceiver'
   OR backend_type = 'walsender';
```

### 解决

```sql
-- 1. 检查网络带宽
-- 从库执行
SELECT pg_size_pretty(
    pg_wal_lsn_diff(
        pg_last_wal_receive_lsn(),
        pg_last_wal_replay_lsn()
    )
) AS lag_size;

-- 2. 优化从库配置
-- postgresql.conf (从库)
max_connections = 200
shared_buffers = 8GB
wal_receiver_timeout = 60s
wal_receiver_status_interval = 10s

-- 3. 检查从库查询负载
SELECT
    count(*) AS active_queries,
    sum(EXTRACT(EPOCH FROM (now() - query_start))) AS total_query_time
FROM pg_stat_activity
WHERE state = 'active'
  AND pid != pg_backend_pid();

-- 4. 使用同步复制（如果延迟不可接受）
-- 主库配置
synchronous_standby_names = 'ANY 1 (standby1, standby2)'
synchronous_commit = on

-- 5. 优化WAL生成
-- 减少不必要的WAL
-- 使用UNLOGGED表（如果允许）
-- 批量提交事务
```

---

## 案例2：复制中断

### 症状

```text
从库状态：not streaming
主库日志：could not receive data from WAL stream
从库无法接收WAL
```

### 诊断

```sql
-- 主库检查复制连接
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    sync_state,
    write_lag,
    flush_lag,
    replay_lag
FROM pg_stat_replication;

-- 如果查询返回空，说明复制连接断开

-- 检查主库WAL配置
SHOW wal_level;  -- 应该是 replica 或 logical
SHOW max_wal_senders;  -- 应该 > 0

-- 从库检查连接状态
SELECT
    pid,
    usename,
    application_name,
    state,
    wait_event_type,
    wait_event
FROM pg_stat_activity
WHERE backend_type = 'walreceiver';

-- 检查从库配置
SHOW primary_conninfo;
SHOW primary_slot_name;
```

### 解决

```sql
-- 1. 检查网络连通性
-- 从库执行
SELECT pg_is_in_recovery();  -- 应该返回 true

-- 2. 检查复制槽（如果使用）
-- 主库
SELECT
    slot_name,
    slot_type,
    active,
    restart_lsn,
    confirmed_flush_lsn
FROM pg_replication_slots;

-- 如果slot不存在或inactive，重新创建
SELECT pg_create_physical_replication_slot('standby1_slot');

-- 3. 检查从库recovery配置
-- postgresql.conf (从库)
primary_conninfo = 'host=primary_host port=5432 user=replicator password=xxx'
primary_slot_name = 'standby1_slot'
restore_command = 'cp /path/to/archive/%f %p'

-- 4. 重启从库WAL接收进程
-- 从库执行
SELECT pg_wal_replay_resume();  -- 如果暂停了

-- 5. 重新同步（如果数据不一致）
-- 使用pg_basebackup重新同步
pg_basebackup -h primary_host -D /var/lib/postgresql/data -U replicator -v -P -W
```

---

## 案例3：逻辑复制延迟

### 症状

```text
逻辑复制订阅延迟
pg_stat_subscription显示延迟
数据不同步
```

### 诊断

```sql
-- 检查订阅状态
SELECT
    subid,
    subname,
    pid,
    relid,
    received_lsn,
    last_msg_send_time,
    last_msg_receipt_time,
    latest_end_lsn,
    latest_end_time
FROM pg_stat_subscription;

-- 检查复制槽状态
SELECT
    slot_name,
    slot_type,
    database,
    active,
    restart_lsn,
    confirmed_flush_lsn,
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            confirmed_flush_lsn
        )
    ) AS lag_size
FROM pg_replication_slots
WHERE slot_type = 'logical';

-- 检查发布端状态
SELECT
    pubname,
    puballtables,
    pubinsert,
    pubupdate,
    pubdelete,
    pubtruncate
FROM pg_publication;

-- 检查订阅端状态
SELECT
    subname,
    subenabled,
    subpublications
FROM pg_subscription;
```

### 解决

```sql
-- 1. 检查订阅进程
SELECT
    pid,
    usename,
    application_name,
    state,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE backend_type = 'logical replication worker';

-- 2. 优化逻辑复制配置
-- 发布端
max_replication_slots = 10
max_wal_senders = 10
wal_level = logical

-- 订阅端
max_logical_replication_workers = 4
max_sync_workers_per_subscription = 2

-- 3. 检查表大小（大表可能延迟）
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- 4. 重新同步特定表
ALTER SUBSCRIPTION my_subscription REFRESH PUBLICATION;
ALTER SUBSCRIPTION my_subscription SET (synchronous_commit = off);

-- 5. 监控复制延迟
CREATE VIEW replication_lag AS
SELECT
    slot_name,
    pg_size_pretty(
        pg_wal_lsn_diff(
            pg_current_wal_lsn(),
            confirmed_flush_lsn
        )
    ) AS lag_size,
    pg_wal_lsn_diff(
        pg_current_wal_lsn(),
        confirmed_flush_lsn
    ) / 1024 / 1024 AS lag_mb
FROM pg_replication_slots
WHERE slot_type = 'logical';
```

---

## 案例4：复制冲突

### 症状

```text
从库日志：conflict with recovery
查询被取消
数据不一致
```

### 诊断

```sql
-- 检查冲突统计
SELECT
    datname,
    confl_tablespace,
    confl_lock,
    confl_snapshot,
    confl_bufferpin,
    confl_deadlock
FROM pg_stat_database_conflicts;

-- 检查从库查询
SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    query_start
FROM pg_stat_activity
WHERE datname = current_database()
  AND state = 'active';
```

### 解决

```sql
-- 1. 设置冲突处理策略
-- postgresql.conf (从库)
max_standby_streaming_delay = 30s  -- 允许延迟30秒
hot_standby_feedback = on  -- 向主库反馈查询信息

-- 2. 取消长时间运行的查询
-- 从库执行
SELECT pg_cancel_backend(pid)
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '30 seconds';

-- 3. 使用只读查询（避免冲突）
-- 设置事务为只读
SET TRANSACTION READ ONLY;

-- 4. 检查表锁冲突
SELECT
    l.pid,
    l.mode,
    l.granted,
    a.query,
    a.state
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.relation = 'problematic_table'::regclass;
```

---

**文档完成** ✅
