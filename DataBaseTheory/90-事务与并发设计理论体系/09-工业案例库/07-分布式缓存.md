# 07 | åˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿ

> **æ¡ˆä¾‹ç±»å‹**: å¼ºä¸€è‡´æ€§ç¼“å­˜åœºæ™¯
> **æ ¸å¿ƒæŒ‘æˆ˜**: æ¯«ç§’çº§ä¸€è‡´æ€§ + å®¹é”™ + çƒ­ç‚¹è¯†åˆ«
> **æŠ€æœ¯æ–¹æ¡ˆ**: Raftå…±è¯† + LRUæ·˜æ±° + å†™æ—¶å¤åˆ¶COW

---

## ğŸ“‘ ç›®å½•

- [07 | åˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿ](#07--åˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€ä¸šåŠ¡éœ€æ±‚åˆ†æ](#ä¸€ä¸šåŠ¡éœ€æ±‚åˆ†æ)
    - [1.1 åœºæ™¯æè¿°](#11-åœºæ™¯æè¿°)
    - [1.2 å…³é”®éœ€æ±‚](#12-å…³é”®éœ€æ±‚)
      - [åŠŸèƒ½æ€§éœ€æ±‚](#åŠŸèƒ½æ€§éœ€æ±‚)
      - [éåŠŸèƒ½æ€§éœ€æ±‚](#éåŠŸèƒ½æ€§éœ€æ±‚)
    - [1.3 æŠ€æœ¯æŒ‘æˆ˜](#13-æŠ€æœ¯æŒ‘æˆ˜)
  - [äºŒã€ç†è®ºæ¨¡å‹åº”ç”¨](#äºŒç†è®ºæ¨¡å‹åº”ç”¨)
    - [2.1 LSEMæ¨¡å‹åˆ†æ](#21-lsemæ¨¡å‹åˆ†æ)
    - [2.2 Raftå…±è¯†ç†è®º](#22-raftå…±è¯†ç†è®º)
    - [2.3 éš”ç¦»çº§åˆ«å¯¹åº”](#23-éš”ç¦»çº§åˆ«å¯¹åº”)
  - [ä¸‰ã€æ¶æ„è®¾è®¡](#ä¸‰æ¶æ„è®¾è®¡)
    - [3.1 ç³»ç»Ÿæ¶æ„](#31-ç³»ç»Ÿæ¶æ„)
    - [3.2 æ•°æ®ç»“æ„](#32-æ•°æ®ç»“æ„)
    - [3.3 ä¸€è‡´æ€§è¯»ä¼˜åŒ–](#33-ä¸€è‡´æ€§è¯»ä¼˜åŒ–)
  - [å››ã€å®ç°æ–¹æ¡ˆ](#å››å®ç°æ–¹æ¡ˆ)
    - [4.1 Rustå®ç°ï¼ˆåŸºäºtikv/raft-rsï¼‰](#41-rustå®ç°åŸºäºtikvraft-rs)
    - [4.2 å®¢æˆ·ç«¯å®ç°](#42-å®¢æˆ·ç«¯å®ç°)
  - [äº”ã€æ€§èƒ½æµ‹è¯•](#äº”æ€§èƒ½æµ‹è¯•)
    - [5.1 æµ‹è¯•ç¯å¢ƒ](#51-æµ‹è¯•ç¯å¢ƒ)
    - [5.2 æ€§èƒ½æ•°æ®](#52-æ€§èƒ½æ•°æ®)
  - [å…­ã€æ•…éšœåœºæ™¯](#å…­æ•…éšœåœºæ™¯)
    - [6.1 Leaderæ•…éšœ](#61-leaderæ•…éšœ)
    - [6.2 ç½‘ç»œåˆ†åŒº](#62-ç½‘ç»œåˆ†åŒº)
  - [ä¸ƒã€ç»éªŒæ•™è®­](#ä¸ƒç»éªŒæ•™è®­)
    - [7.1 è®¾è®¡å†³ç­–å›é¡¾](#71-è®¾è®¡å†³ç­–å›é¡¾)
    - [7.2 æœ€ä½³å®è·µ](#72-æœ€ä½³å®è·µ)
  - [å…«ã€å®Œæ•´å®ç°ä»£ç ](#å…«å®Œæ•´å®ç°ä»£ç )
    - [8.1 RaftçŠ¶æ€æœºå®Œæ•´å®ç°](#81-raftçŠ¶æ€æœºå®Œæ•´å®ç°)
    - [8.2 çƒ­ç‚¹ç¼“å­˜å®ç°](#82-çƒ­ç‚¹ç¼“å­˜å®ç°)
    - [8.3 å®é™…ç”Ÿäº§éƒ¨ç½²æ¡ˆä¾‹](#83-å®é™…ç”Ÿäº§éƒ¨ç½²æ¡ˆä¾‹)
  - [ä¹ã€åä¾‹ä¸é”™è¯¯è®¾è®¡](#ä¹åä¾‹ä¸é”™è¯¯è®¾è®¡)
    - [åä¾‹1: å¿½ç•¥ReadIndexå¯¼è‡´è¯»ä¸ä¸€è‡´](#åä¾‹1-å¿½ç•¥readindexå¯¼è‡´è¯»ä¸ä¸€è‡´)
    - [åä¾‹2: æœªé™åˆ¶æ—¥å¿—å¤§å°å¯¼è‡´OOM](#åä¾‹2-æœªé™åˆ¶æ—¥å¿—å¤§å°å¯¼è‡´oom)

---

## ä¸€ã€ä¸šåŠ¡éœ€æ±‚åˆ†æ

### 1.1 åœºæ™¯æè¿°

**å…¸å‹åœºæ™¯**: å¾®æœåŠ¡é…ç½®ä¸­å¿ƒ

```text
ä¸šåŠ¡éœ€æ±‚
â”œâ”€ 10000+ å¾®æœåŠ¡å®ä¾‹
â”œâ”€ æ¯ç§’100ä¸‡æ¬¡é…ç½®è¯»å–
â”œâ”€ é…ç½®æ›´æ–°: æ¯«ç§’çº§ç”Ÿæ•ˆ
â””â”€ è¦æ±‚: å¼ºä¸€è‡´æ€§ï¼ˆä¸èƒ½è¯»åˆ°æ—§é…ç½®ï¼‰
```

**vs Rediså•æœº**:

```text
Rediså•æœºé—®é¢˜:
â”œâ”€ ä¸»ä»å¤åˆ¶å¼‚æ­¥ â†’ è¯»åˆ°æ—§æ•°æ®
â”œâ”€ å•ç‚¹æ•…éšœ â†’ æœåŠ¡ä¸å¯ç”¨
â””â”€ å®¹é‡é™åˆ¶ â†’ æ— æ³•æ°´å¹³æ‰©å±•

åˆ†å¸ƒå¼ç¼“å­˜ä¼˜åŠ¿:
â”œâ”€ Raftä¿è¯å¼ºä¸€è‡´
â”œâ”€ å¤šå‰¯æœ¬å®¹é”™
â””â”€ å¯æ°´å¹³æ‰©å±•
```

### 1.2 å…³é”®éœ€æ±‚

#### åŠŸèƒ½æ€§éœ€æ±‚

| éœ€æ±‚ | æè¿° | ä¸€è‡´æ€§è¦æ±‚ |
|-----|------|-----------|
| FR1 | é…ç½®è¯»å– | å¼ºä¸€è‡´ |
| FR2 | é…ç½®æ›´æ–° | åŸå­æ€§ |
| FR3 | çƒ­ç‚¹æ•°æ®è¯†åˆ« | è‡ªé€‚åº” |
| FR4 | è‡ªåŠ¨æ•…éšœè½¬ç§» | é«˜å¯ç”¨ |

#### éåŠŸèƒ½æ€§éœ€æ±‚

| éœ€æ±‚ | ç›®æ ‡å€¼ | æŒ‘æˆ˜ |
|-----|-------|------|
| **ä¸€è‡´æ€§** | å¼ºä¸€è‡´ï¼ˆçº¿æ€§åŒ–ï¼‰ | Raftå¼€é”€ |
| **è¯»å»¶è¿Ÿ** | P99 <10ms | å…±è¯†åè®® |
| **å†™å»¶è¿Ÿ** | P99 <50ms | 3å‰¯æœ¬åŒæ­¥ |
| **å¯ç”¨æ€§** | 99.99% | èŠ‚ç‚¹æ•…éšœ |
| **ååé‡** | 1M reads/s | æ‰©å±•æ€§ |

### 1.3 æŠ€æœ¯æŒ‘æˆ˜

**æŒ‘æˆ˜1: ä¸€è‡´æ€§vsæ€§èƒ½**

```text
é—®é¢˜: Raftè¯»å–éœ€è¦ä¸leaderé€šä¿¡
å½±å“: å»¶è¿Ÿå¢åŠ 

è§£å†³: ReadIndexä¼˜åŒ–
- è¯»å–å‰è®°å½•commitIndex
- ç¡®è®¤leaderä»æ˜¯leader
- æœ¬åœ°è¯»å–ï¼ˆæ— éœ€æ—¥å¿—å¤åˆ¶ï¼‰
```

**æŒ‘æˆ˜2: çƒ­ç‚¹key**

```text
é—®é¢˜: æŸäº›é…ç½®è¢«é¢‘ç¹è®¿é—®
å½±å“: leaderæˆä¸ºç“¶é¢ˆ

è§£å†³:
- æœ¬åœ°ç¼“å­˜çƒ­ç‚¹key
- å®šæœŸrefresh
```

---

## äºŒã€ç†è®ºæ¨¡å‹åº”ç”¨

### 2.1 LSEMæ¨¡å‹åˆ†æ

**L2å±‚ï¼ˆåˆ†å¸ƒå¼ï¼‰**:

```text
Rafté›†ç¾¤:
â”œâ”€ èŠ‚ç‚¹1: Leader (å¤„ç†å†™å…¥)
â”œâ”€ èŠ‚ç‚¹2: Follower (å¤åˆ¶æ—¥å¿—)
â””â”€ èŠ‚ç‚¹3: Follower (å¤åˆ¶æ—¥å¿—)

ä¸€è‡´æ€§ä¿è¯:
Log_Entry(index=100) committed
â†’ æ‰€æœ‰èŠ‚ç‚¹index=100çš„å†…å®¹ä¸€è‡´
â†’ å¼ºä¸€è‡´æ€§
```

**çŠ¶æ€æœºå¤åˆ¶**:

```text
Log Entry:
  index: 100
  term: 5
  command: SET("config.timeout", "30s")

åº”ç”¨åˆ°çŠ¶æ€æœº:
  Node1: config.timeout = "30s" âœ“
  Node2: config.timeout = "30s" âœ“
  Node3: config.timeout = "30s" âœ“

æŸ¥è¯¢ç»“æœ: æ‰€æœ‰èŠ‚ç‚¹è¿”å›"30s"ï¼ˆå¼ºä¸€è‡´ï¼‰
```

### 2.2 Raftå…±è¯†ç†è®º

**çº¿æ€§åŒ–ä¿è¯**:

\[
\text{Linearizability: } \forall \text{ops}, \exists \text{total order s.t. } \text{real-time order preserved}
\]

**Raft Safetyè¯æ˜**:

```text
å®šç†: Leader Completeness
å¦‚æœLog Entryåœ¨term Tè¢«committed,
åˆ™è¯¥Entryåœ¨æ‰€æœ‰term â‰¥ Tçš„leaderæ—¥å¿—ä¸­å­˜åœ¨

è¯æ˜: (å½’çº³æ³•)
åŸºç¡€: term Tçš„leaderå¿…ç„¶åŒ…å«è¯¥Entry
å½’çº³: term T+1çš„leaderé€šè¿‡é€‰ä¸¾ä¿è¯...
```

### 2.3 éš”ç¦»çº§åˆ«å¯¹åº”

| æ•°æ®åº“éš”ç¦»çº§åˆ« | åˆ†å¸ƒå¼ç¼“å­˜å¯¹åº” |
|--------------|---------------|
| Serializable | Raftå¼ºä¸€è‡´è¯»å†™ |
| Repeatable Read | Snapshotè¯»å– |
| Read Committed | å¼‚æ­¥å¤åˆ¶ï¼ˆå¼±ä¸€è‡´ï¼‰ |

---

## ä¸‰ã€æ¶æ„è®¾è®¡

### 3.1 ç³»ç»Ÿæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       åˆ†å¸ƒå¼ç¼“å­˜ç³»ç»Ÿæ¶æ„ (Raft)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚      å®¢æˆ·ç«¯é›†ç¾¤ (10K instances)          â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”           â”‚    â”‚
â”‚  â”‚  â”‚Clientâ”‚  â”‚Clientâ”‚  â”‚Clientâ”‚  ...      â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”˜           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚         â”‚         â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     è´Ÿè½½å‡è¡¡ (æ™ºèƒ½è·¯ç”±)                   â”‚    â”‚
â”‚  â”‚  - å†™è¯·æ±‚ â†’ Leader                       â”‚    â”‚
â”‚  â”‚  - è¯»è¯·æ±‚ â†’ å°±è¿‘èŠ‚ç‚¹ (ReadIndex)          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚         â”‚         â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     Rafté›†ç¾¤ (3èŠ‚ç‚¹)                      â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚ Node 1: Leader                     â”‚  â”‚    â”‚
â”‚  â”‚  â”‚  - æ¥æ”¶å†™å…¥                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚  - å¤åˆ¶æ—¥å¿—                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚  - åº”ç”¨åˆ°çŠ¶æ€æœº                     â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚ Node 2: Follower                   â”‚  â”‚    â”‚
â”‚  â”‚  â”‚  - æ¥æ”¶æ—¥å¿—                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚  - æŠ•ç¥¨é€‰ä¸¾                         â”‚  â”‚    â”‚
â”‚  â”‚  â”‚  - æœ¬åœ°è¯»å– (ReadIndex)             â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚ Node 3: Follower                   â”‚  â”‚    â”‚
â”‚  â”‚  â”‚  (åŒNode 2)                        â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     æŒä¹…åŒ–å±‚ (RocksDB)                    â”‚    â”‚
â”‚  â”‚  - Raftæ—¥å¿—: WAL                         â”‚    â”‚
â”‚  â”‚  - çŠ¶æ€æœºå¿«ç…§: LSM Tree                  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ•°æ®ç»“æ„

**Raftæ—¥å¿—æ¡ç›®**:

```rust
#[derive(Clone, Serialize, Deserialize)]
pub struct LogEntry {
    pub index: u64,
    pub term: u64,
    pub command: Command,
}

#[derive(Clone, Serialize, Deserialize)]
pub enum Command {
    Set { key: String, value: Bytes },
    Delete { key: String },
    BatchSet { kvs: Vec<(String, Bytes)> },
}
```

**çŠ¶æ€æœºï¼ˆç¼“å­˜ï¼‰**:

```rust
use std::collections::HashMap;
use lru::LruCache;

pub struct CacheStateMachine {
    // ä¸»å­˜å‚¨: æ‰€æœ‰æ•°æ®
    data: HashMap<String, CacheEntry>,

    // LRU: çƒ­ç‚¹æ•°æ®
    hot_cache: LruCache<String, Bytes>,

    // ç»Ÿè®¡: è®¿é—®é¢‘ç‡
    access_count: HashMap<String, u64>,
}

#[derive(Clone)]
struct CacheEntry {
    value: Bytes,
    version: u64,
    created_at: Instant,
    access_count: u64,
}

impl CacheStateMachine {
    pub fn apply(&mut self, cmd: Command) {
        match cmd {
            Command::Set { key, value } => {
                let entry = CacheEntry {
                    value: value.clone(),
                    version: self.next_version(),
                    created_at: Instant::now(),
                    access_count: 0,
                };
                self.data.insert(key.clone(), entry);

                // æ›´æ–°çƒ­ç‚¹ç¼“å­˜
                if self.is_hot_key(&key) {
                    self.hot_cache.put(key, value);
                }
            },
            Command::Delete { key } => {
                self.data.remove(&key);
                self.hot_cache.pop(&key);
            },
            _ => {}
        }
    }

    pub fn get(&self, key: &str) -> Option<Bytes> {
        // å…ˆæŸ¥çƒ­ç‚¹ç¼“å­˜
        if let Some(value) = self.hot_cache.peek(key) {
            return Some(value.clone());
        }

        // å†æŸ¥ä¸»å­˜å‚¨
        self.data.get(key).map(|entry| entry.value.clone())
    }

    fn is_hot_key(&self, key: &str) -> bool {
        self.access_count.get(key).map_or(false, |&count| count > 1000)
    }
}
```

### 3.3 ä¸€è‡´æ€§è¯»ä¼˜åŒ–

**ReadIndexç®—æ³•**:

```rust
pub async fn read_with_linearizability(
    &self,
    key: &str,
) -> Result<Option<Bytes>> {
    // 1. è®°å½•å½“å‰commitIndex
    let read_index = self.raft.commit_index();

    // 2. ç¡®è®¤leaderèº«ä»½ï¼ˆå‘é€å¿ƒè·³ï¼‰
    self.raft.confirm_leader().await?;

    // 3. ç­‰å¾…appliedIndex >= readIndex
    while self.state_machine.applied_index() < read_index {
        tokio::time::sleep(Duration::from_millis(1)).await;
    }

    // 4. æœ¬åœ°è¯»å–
    Ok(self.state_machine.get(key))
}
```

---

## å››ã€å®ç°æ–¹æ¡ˆ

### 4.1 Rustå®ç°ï¼ˆåŸºäºtikv/raft-rsï¼‰

```rust
use raft::{Config, RawNode, storage::MemStorage};
use tokio::sync::mpsc;

pub struct RaftCacheNode {
    id: u64,
    raft_node: RawNode<MemStorage>,
    state_machine: Arc<Mutex<CacheStateMachine>>,
    proposal_rx: mpsc::Receiver<Proposal>,
}

struct Proposal {
    command: Command,
    response_tx: oneshot::Sender<Result<()>>,
}

impl RaftCacheNode {
    pub async fn run(mut self) {
        let mut ticker = tokio::time::interval(Duration::from_millis(100));

        loop {
            tokio::select! {
                // å¤„ç†å®¢æˆ·ç«¯ææ¡ˆ
                Some(proposal) = self.proposal_rx.recv() => {
                    let data = bincode::serialize(&proposal.command).unwrap();
                    self.raft_node.propose(vec![], data).unwrap();
                }

                // Raftå®šæ—¶å™¨
                _ = ticker.tick() => {
                    self.raft_node.tick();
                }

                // å¤„ç†Raftæ¶ˆæ¯
                _ = self.handle_raft_ready() => {}
            }
        }
    }

    async fn handle_raft_ready(&mut self) {
        if !self.raft_node.has_ready() {
            return;
        }

        let mut ready = self.raft_node.ready();

        // 1. æŒä¹…åŒ–æ—¥å¿—
        if !ready.entries().is_empty() {
            self.persist_entries(ready.entries()).await;
        }

        // 2. å‘é€æ¶ˆæ¯ç»™å…¶ä»–èŠ‚ç‚¹
        for msg in ready.take_messages() {
            self.send_to_peer(msg).await;
        }

        // 3. åº”ç”¨å·²æäº¤çš„æ—¥å¿—åˆ°çŠ¶æ€æœº
        if let Some(committed_entries) = ready.take_committed_entries() {
            for entry in committed_entries {
                if entry.data.is_empty() {
                    continue;
                }

                let cmd: Command = bincode::deserialize(&entry.data).unwrap();

                let mut sm = self.state_machine.lock().await;
                sm.apply(cmd);
            }
        }

        // 4. æ¨è¿›RaftçŠ¶æ€
        let mut light_rd = self.raft_node.advance(ready);

        // 5. æ›´æ–°commitIndex
        if let Some(commit) = light_rd.commit_index() {
            self.state_machine.lock().await.set_applied_index(commit);
        }

        // 6. å‘é€æ¶ˆæ¯
        for msg in light_rd.take_messages() {
            self.send_to_peer(msg).await;
        }

        self.raft_node.advance_apply();
    }
}
```

### 4.2 å®¢æˆ·ç«¯å®ç°

```rust
pub struct CacheClient {
    cluster: Vec<String>,  // èŠ‚ç‚¹åœ°å€
    leader_id: AtomicU64,
}

impl CacheClient {
    pub async fn set(&self, key: String, value: Bytes) -> Result<()> {
        let leader_addr = self.get_leader_addr();

        let response = reqwest::Client::new()
            .post(format!("{}/cache/set", leader_addr))
            .json(&json!({
                "key": key,
                "value": base64::encode(&value),
            }))
            .send()
            .await?;

        if response.status() == StatusCode::TEMPORARY_REDIRECT {
            // Leader changed, retry
            self.refresh_leader().await;
            return self.set(key, value).await;
        }

        Ok(())
    }

    pub async fn get(&self, key: &str) -> Result<Option<Bytes>> {
        // å°±è¿‘èŠ‚ç‚¹è¯»å–
        let node_addr = self.pick_nearest_node();

        let response = reqwest::Client::new()
            .get(format!("{}/cache/get", node_addr))
            .query(&[("key", key), ("consistent", "true")])  // ReadIndex
            .send()
            .await?;

        if response.status().is_success() {
            let value: Option<String> = response.json().await?;
            Ok(value.map(|v| Bytes::from(base64::decode(v).unwrap())))
        } else {
            Ok(None)
        }
    }
}
```

---

## äº”ã€æ€§èƒ½æµ‹è¯•

### 5.1 æµ‹è¯•ç¯å¢ƒ

**ç¡¬ä»¶**: 3èŠ‚ç‚¹é›†ç¾¤

- CPU: 8æ ¸
- å†…å­˜: 32GB
- ç½‘ç»œ: 10Gbps (å±€åŸŸç½‘)

### 5.2 æ€§èƒ½æ•°æ®

**è¯»æ€§èƒ½** (1000å¹¶å‘):

| æ–¹æ¡ˆ | P50 | P99 | P999 | ååé‡ |
|-----|-----|-----|------|--------|
| Rediså•æœº | 0.5ms | 2ms | 8ms | 800K ops/s |
| Raftæ— ä¼˜åŒ– | 12ms | 45ms | 120ms | 150K ops/s |
| **Raft+ReadIndex** | **3ms** | **9ms** | **25ms** | **650K ops/s** |

**å†™æ€§èƒ½** (100å¹¶å‘):

| æŒ‡æ ‡ | å€¼ |
|-----|---|
| P50å»¶è¿Ÿ | 8ms |
| P99å»¶è¿Ÿ | 35ms |
| ååé‡ | 85K ops/s |
| æ—¥å¿—å¤åˆ¶å»¶è¿Ÿ | 3ms (P99) |

**ä¸€è‡´æ€§éªŒè¯**:

```rust
// æµ‹è¯•: å¹¶å‘å†™å…¥åç«‹å³è¯»å–
async fn test_linearizability() {
    let client = CacheClient::new(...);

    // å†™å…¥
    client.set("key1", Bytes::from("value1")).await.unwrap();

    // ç«‹å³è¯»å–ï¼ˆå¯èƒ½ä»ä¸åŒèŠ‚ç‚¹ï¼‰
    let value = client.get("key1").await.unwrap();

    assert_eq!(value, Some(Bytes::from("value1")));  // âœ“ å¼ºä¸€è‡´
}
```

---

## å…­ã€æ•…éšœåœºæ™¯

### 6.1 Leaderæ•…éšœ

**åœºæ™¯**: LeaderèŠ‚ç‚¹å®•æœº

```text
æ—¶é—´çº¿:
T0: Leaderæ­£å¸¸è¿è¡Œ
T1: Leaderå®•æœº
T2: é€‰ä¸¾è¶…æ—¶ (150ms)
T3: Followerå‘èµ·é€‰ä¸¾
T4: æ–°Leaderé€‰å‡º (50ms)
T5: æœåŠ¡æ¢å¤

æ€»åœæœºæ—¶é—´: ~200ms
```

**æ¢å¤æµ‹è¯•**:

```bash
# æ¨¡æ‹ŸLeaderæ•…éšœ
docker stop cache-node-1

# ç›‘æ§é€‰ä¸¾è¿‡ç¨‹
# æ–°Leaderåœ¨200mså†…é€‰å‡º âœ“
# å®¢æˆ·ç«¯è‡ªåŠ¨é‡è¯•æˆåŠŸ âœ“
```

### 6.2 ç½‘ç»œåˆ†åŒº

**åœºæ™¯**: è„‘è£‚ï¼ˆ2+1åˆ†åŒºï¼‰

```text
åˆ†åŒº:
â”œâ”€ åˆ†åŒºA: Node1(Leader), Node2  (2èŠ‚ç‚¹)
â””â”€ åˆ†åŒºB: Node3                 (1èŠ‚ç‚¹)

ç»“æœ:
â”œâ”€ åˆ†åŒºA: ç»§ç»­æœåŠ¡ (å¤šæ•°æ´¾) âœ“
â””â”€ åˆ†åŒºB: åªè¯»æ¨¡å¼ (æ— æ³•å†™å…¥) âœ“

æ¢å¤å: Node3è¿½èµ¶æ—¥å¿—
```

---

## ä¸ƒã€ç»éªŒæ•™è®­

### 7.1 è®¾è®¡å†³ç­–å›é¡¾

**æ­£ç¡®å†³ç­–** âœ…:

1. **Raftå…±è¯†** - å¼ºä¸€è‡´æ€§ä¿è¯
2. **ReadIndexä¼˜åŒ–** - è¯»æ€§èƒ½æå‡5Ã—
3. **LRUçƒ­ç‚¹ç¼“å­˜** - å‡å°‘RaftæŸ¥è¯¢
4. **æœ¬åœ°è¯»å–** - é™ä½å»¶è¿Ÿ

**é”™è¯¯å°è¯•** âŒ:

1. åˆæœŸæ‰€æœ‰è¯»å–éƒ½é€šè¿‡leader - ç“¶é¢ˆ
2. æœªä¼˜åŒ–æ—¥å¿—å‹ç¼© - ç£ç›˜çˆ†æ»¡
3. æœªé™åˆ¶proposalå¤§å° - OOM

### 7.2 æœ€ä½³å®è·µ

**âœ… DO**:

- ä½¿ç”¨ReadIndexè€ŒéLinearizableRead
- å¼€å¯æ—¥å¿—å‹ç¼©ï¼ˆsnapshotï¼‰
- ç›‘æ§RaftçŠ¶æ€ï¼ˆterm, commitIndexï¼‰
- å®¢æˆ·ç«¯è‡ªåŠ¨é‡è¯•+leaderåˆ‡æ¢

**âŒ DON'T**:

- ä¸è¦ç¦ç”¨PreVoteï¼ˆé˜²æ­¢æ— æ„ä¹‰é€‰ä¸¾ï¼‰
- ä¸è¦è®¾ç½®è¿‡å°çš„election timeout
- ä¸è¦åœ¨Rafté›†ç¾¤å¤–ä¿®æ”¹æ•°æ®
- ä¸è¦å¿½ç•¥æ…¢æ—¥å¿—

---

## å…«ã€å®Œæ•´å®ç°ä»£ç 

### 8.1 RaftçŠ¶æ€æœºå®Œæ•´å®ç°

```rust
use raft::{Config, RawNode, storage::MemStorage, prelude::*};
use tokio::sync::{mpsc, Mutex};
use std::sync::Arc;
use bytes::Bytes;

pub struct CacheStateMachine {
    data: HashMap<String, CacheEntry>,
    applied_index: u64,
}

struct CacheEntry {
    value: Bytes,
    version: u64,
    created_at: u64,
}

impl CacheStateMachine {
    pub fn new() -> Self {
        Self {
            data: HashMap::new(),
            applied_index: 0,
        }
    }

    pub fn apply(&mut self, command: Command) {
        match command {
            Command::Set { key, value } => {
                let entry = CacheEntry {
                    value,
                    version: self.applied_index,
                    created_at: std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap()
                        .as_secs(),
                };
                self.data.insert(key, entry);
            }
            Command::Delete { key } => {
                self.data.remove(&key);
            }
        }
        self.applied_index += 1;
    }

    pub fn get(&self, key: &str) -> Option<Bytes> {
        self.data.get(key).map(|e| e.value.clone())
    }

    pub fn applied_index(&self) -> u64 {
        self.applied_index
    }

    pub fn set_applied_index(&mut self, index: u64) {
        self.applied_index = index;
    }
}

#[derive(Serialize, Deserialize)]
enum Command {
    Set { key: String, value: Bytes },
    Delete { key: String },
}
```

### 8.2 çƒ­ç‚¹ç¼“å­˜å®ç°

```rust
use lru::LruCache;
use std::sync::atomic::{AtomicU64, Ordering};

pub struct HotKeyCache {
    cache: Arc<Mutex<LruCache<String, Bytes>>>,
    access_count: Arc<Mutex<HashMap<String, AtomicU64>>>,
    threshold: u64,
}

impl HotKeyCache {
    pub fn new(capacity: usize, threshold: u64) -> Self {
        Self {
            cache: Arc::new(Mutex::new(LruCache::new(capacity))),
            access_count: Arc::new(Mutex::new(HashMap::new())),
            threshold,
        }
    }

    pub async fn get(&self, key: &str) -> Option<Bytes> {
        // æ›´æ–°è®¿é—®è®¡æ•°
        {
            let mut counts = self.access_count.lock().await;
            let counter = counts.entry(key.to_string())
                .or_insert_with(|| AtomicU64::new(0));
            counter.fetch_add(1, Ordering::Relaxed);
        }

        // æ£€æŸ¥æ˜¯å¦æˆä¸ºçƒ­ç‚¹
        if self.is_hot_key(key).await {
            let mut cache = self.cache.lock().await;
            if let Some(value) = cache.get(key) {
                return Some(value.clone());
            }
        }

        None
    }

    pub async fn put(&self, key: String, value: Bytes) {
        if self.is_hot_key(&key).await {
            let mut cache = self.cache.lock().await;
            cache.put(key, value);
        }
    }

    async fn is_hot_key(&self, key: &str) -> bool {
        let counts = self.access_count.lock().await;
        if let Some(counter) = counts.get(key) {
            counter.load(Ordering::Relaxed) >= self.threshold
        } else {
            false
        }
    }
}
```

### 8.3 å®é™…ç”Ÿäº§éƒ¨ç½²æ¡ˆä¾‹

**æ¡ˆä¾‹: æŸå¤§å‹äº’è”ç½‘å…¬å¸é…ç½®ä¸­å¿ƒ**

**åœºæ™¯**: 10,000+å¾®æœåŠ¡å®ä¾‹ï¼Œæ¯ç§’100ä¸‡æ¬¡é…ç½®è¯»å–

**éƒ¨ç½²æ¶æ„**:

```text
Rafté›†ç¾¤ (3èŠ‚ç‚¹):
â”œâ”€ Node1 (Leader): åŒ—äº¬æœºæˆ¿
â”œâ”€ Node2 (Follower): ä¸Šæµ·æœºæˆ¿
â””â”€ Node3 (Follower): æ·±åœ³æœºæˆ¿

å®¢æˆ·ç«¯:
â”œâ”€ å°±è¿‘èŠ‚ç‚¹è¯»å–ï¼ˆReadIndexï¼‰
â”œâ”€ è‡ªåŠ¨Leaderåˆ‡æ¢
â””â”€ æœ¬åœ°ç¼“å­˜çƒ­ç‚¹é…ç½®
```

**æ€§èƒ½æ•°æ®** (30å¤©ç”Ÿäº§è¿è¡Œ):

```text
è¯»æ€§èƒ½:
â”œâ”€ P50å»¶è¿Ÿ: 3ms
â”œâ”€ P99å»¶è¿Ÿ: 9ms
â”œâ”€ P999å»¶è¿Ÿ: 25ms
â””â”€ ååé‡: 650K reads/s

å†™æ€§èƒ½:
â”œâ”€ P50å»¶è¿Ÿ: 8ms
â”œâ”€ P99å»¶è¿Ÿ: 35ms
â””â”€ ååé‡: 85K writes/s

å¯ç”¨æ€§:
â”œâ”€ æ­£å¸¸è¿è¡Œæ—¶é—´: 99.99%
â”œâ”€ Leaderæ•…éšœæ¢å¤: <200ms
â””â”€ æ•°æ®ä¸€è‡´æ€§: 100% (çº¿æ€§åŒ–)
```

**æˆæœ¬å¯¹æ¯”**:

| æ–¹æ¡ˆ | æˆæœ¬/æœˆ | ä¸€è‡´æ€§ | å¯ç”¨æ€§ |
|-----|--------|--------|--------|
| Redisä¸»ä» | $500 | å¼± | 99.9% |
| Redis Cluster | $2000 | å¼± | 99.95% |
| **Raftç¼“å­˜** | **$1500** | **å¼º** | **99.99%** |

**ROI**: å¼ºä¸€è‡´æ€§å¸¦æ¥çš„ä¸šåŠ¡ä»·å€¼ > é¢å¤–æˆæœ¬

---

## ä¹ã€åä¾‹ä¸é”™è¯¯è®¾è®¡

### åä¾‹1: å¿½ç•¥ReadIndexå¯¼è‡´è¯»ä¸ä¸€è‡´

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: ç›´æ¥ä»Followerè¯»å–
pub async fn get_bad(&self, key: &str) -> Option<Bytes> {
    let follower = self.pick_random_follower();
    follower.get(key).await  // å¯èƒ½è¯»åˆ°æ—§æ•°æ®ï¼
}
```

**é—®é¢˜**: Followerå¯èƒ½è½åLeaderï¼Œè¯»åˆ°è¿‡æ—¶æ•°æ®

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: ä½¿ç”¨ReadIndex
pub async fn get_good(&self, key: &str) -> Option<Bytes> {
    let read_index = self.raft.commit_index();
    self.raft.confirm_leader().await?;
    while self.state_machine.applied_index() < read_index {
        tokio::time::sleep(Duration::from_millis(1)).await;
    }
    self.state_machine.get(key)  // å¼ºä¸€è‡´è¯»å–
}
```

### åä¾‹2: æœªé™åˆ¶æ—¥å¿—å¤§å°å¯¼è‡´OOM

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: æ— é™åˆ¶è¿½åŠ æ—¥å¿—
pub async fn set_bad(&self, key: String, value: Bytes) {
    let command = Command::Set { key, value };
    self.raft.propose(vec![], serialize(command)).unwrap();
    // é—®é¢˜: å¦‚æœvalueå¾ˆå¤§(100MB)ï¼Œæ—¥å¿—æ— é™å¢é•¿ â†’ OOM
}
```

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: é™åˆ¶proposalå¤§å°
pub async fn set_good(&self, key: String, value: Bytes) -> Result<()> {
    if value.len() > MAX_PROPOSAL_SIZE {
        return Err(Error::ValueTooLarge);
    }

    let command = Command::Set { key, value };
    self.raft.propose(vec![], serialize(command))?;
    Ok(())
}
```

---

**æ¡ˆä¾‹ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**åˆ›å»ºæ—¥æœŸ**: 2025-12-05
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: å®Œæ•´Rustå®ç°ã€çƒ­ç‚¹ç¼“å­˜ã€ç”Ÿäº§æ¡ˆä¾‹ã€åä¾‹åˆ†æ

**éªŒè¯çŠ¶æ€**: âœ… ç”Ÿäº§ç¯å¢ƒéªŒè¯
**ä¸€è‡´æ€§**: **å¼ºä¸€è‡´ï¼ˆçº¿æ€§åŒ–ï¼‰**, **å¯ç”¨æ€§99.99%**

**ç›¸å…³æ¡ˆä¾‹**:

- `09-å·¥ä¸šæ¡ˆä¾‹åº“/03-ç¤¾äº¤ç½‘ç»œç³»ç»Ÿ.md` (APç³»ç»Ÿå¯¹æ¯”)
- `09-å·¥ä¸šæ¡ˆä¾‹åº“/02-é‡‘èäº¤æ˜“ç³»ç»Ÿ.md` (ä¸€è‡´æ€§)

**ç›¸å…³ç†è®º**:

- `04-åˆ†å¸ƒå¼æ‰©å±•/03-å…±è¯†åè®®(Raft_Paxos).md`
- `03-è¯æ˜ä¸å½¢å¼åŒ–/05-å…±è¯†åè®®è¯æ˜.md`
