# 03 | 社交网络系统

> **案例类型**: 高可用性场景
> **核心挑战**: 全球分布 + 最终一致性 + 99.99%可用性
> **技术方案**: AP系统 + CRDT + 异步复制 + 多主架构

---

## 📑 目录

- [03 | 社交网络系统](#03--社交网络系统)
  - [📑 目录](#-目录)
  - [一、业务需求分析](#一业务需求分析)
    - [1.1 场景描述](#11-场景描述)
    - [1.2 关键需求](#12-关键需求)
      - [功能性需求](#功能性需求)
      - [非功能性需求](#非功能性需求)
    - [1.3 技术挑战](#13-技术挑战)
  - [二、理论模型应用](#二理论模型应用)
    - [2.1 LSEM模型分析](#21-lsem模型分析)
    - [2.2 CRDT理论](#22-crdt理论)
    - [2.3 隔离级别选择](#23-隔离级别选择)
  - [三、架构设计](#三架构设计)
    - [3.1 系统架构](#31-系统架构)
    - [3.2 数据模型](#32-数据模型)
    - [3.3 冲突解决策略](#33-冲突解决策略)
  - [四、实现方案](#四实现方案)
    - [4.1 点赞功能（CRDT G-Counter）](#41-点赞功能crdt-g-counter)
    - [4.2 关注功能（CRDT OR-Set）](#42-关注功能crdt-or-set)
  - [五、冲突解决](#五冲突解决)
    - [5.1 冲突类型](#51-冲突类型)
    - [5.2 PostgreSQL BDR配置](#52-postgresql-bdr配置)
    - [5.3 监控冲突](#53-监控冲突)
  - [六、性能测试](#六性能测试)
    - [6.1 可用性测试](#61-可用性测试)
    - [6.2 一致性延迟测试](#62-一致性延迟测试)
  - [七、经验教训](#七经验教训)
    - [7.1 设计决策回顾](#71-设计决策回顾)
    - [7.2 最佳实践](#72-最佳实践)

---

## 一、业务需求分析

### 1.1 场景描述

**典型场景**: 类Twitter社交平台

```text
业务场景
├─ 全球用户: 10亿+
├─ 日活跃: 2亿
├─ 关注/取关
├─ 发帖/点赞/评论
└─ 时间线查询
```

**CAP权衡**:

```text
社交网络的选择:
├─ Consistency (一致性): 弱化 ✗
│   └─ 允许短暂不一致（几秒延迟）
├─ Availability (可用性): 强化 ✓✓✓
│   └─ 不能因为网络分区而不可用
└─ Partition Tolerance (分区容错): 必须 ✓
    └─ 全球分布，网络分区不可避免
```

**结论**: **AP系统**（可用性优先）

### 1.2 关键需求

#### 功能性需求

| 需求 | 描述 | 一致性要求 |
|-----|------|-----------|
| FR1 | 发帖 | 最终一致 |
| FR2 | 点赞计数 | 最终一致 |
| FR3 | 关注/取关 | 最终一致 |
| FR4 | 时间线查询 | 读自己写一致 |

#### 非功能性需求

| 需求 | 目标值 | 说明 |
|-----|-------|------|
| **可用性** | 99.99% | 年宕机<53分钟 |
| **延迟** | P99 < 200ms | 用户体验 |
| **最终一致性** | <5秒 | 可接受 |
| **全球延迟** | <300ms | 跨洲访问 |

### 1.3 技术挑战

**挑战1: 网络分区**

```text
场景: 美国-欧洲海底光缆故障
├─ 传统CP系统: 欧洲区不可用 ✗
└─ AP系统: 两边独立运行 ✓
    └─ 光缆恢复后数据同步
```

**挑战2: 冲突解决**

```text
用户同时在两个地区操作:
├─ 美国DC: 点赞帖子A
├─ 欧洲DC: 取消点赞帖子A
└─ 冲突: 最终状态是什么？
```

**挑战3: 点赞计数准确性**

```text
问题: 计数器的分布式并发增减
├─ 简单方案: UPDATE likes SET count = count + 1
│   └─ 多主冲突，数据不一致 ✗
└─ CRDT方案: G-Counter (Grow-only Counter)
    └─ 保证最终一致 ✓
```

---

## 二、理论模型应用

### 2.1 LSEM模型分析

**L2层（分布式）**:

```text
多地域部署:
├─ US-West DC  (PostgreSQL Master)
├─ US-East DC  (PostgreSQL Master)
├─ EU DC       (PostgreSQL Master)
└─ Asia DC     (PostgreSQL Master)

复制拓扑: Multi-Master (BDR/Citus)
├─ 异步复制
├─ 冲突检测
└─ 自动解决策略
```

**一致性模型**:

```text
最终一致性 (Eventual Consistency)
├─ 定义: 无新更新时，最终所有副本收敛到相同状态
├─ 保证: ∃t, ∀replicas: state(replica) = same
└─ 延迟: 通常 < 5秒
```

### 2.2 CRDT理论

**Conflict-free Replicated Data Types**:

```text
CRDT性质:
├─ 可交换 (Commutative): a ⊕ b = b ⊕ a
├─ 可结合 (Associative): (a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)
└─ 幂等 (Idempotent): a ⊕ a = a

结果: 无论操作顺序，最终状态一致
```

**常用CRDT类型**:

| CRDT类型 | 用途 | 社交网络应用 |
|---------|------|-------------|
| G-Counter | 只增计数器 | 点赞数 |
| PN-Counter | 增减计数器 | 关注数 |
| LWW-Register | 最后写入胜出 | 用户简介 |
| OR-Set | 集合 | 关注列表 |
| RGA | 有序列表 | 评论列表 |

### 2.3 隔离级别选择

**选择 Read Committed + 应用层冲突解决**:

```text
数据库隔离级别: Read Committed
├─ 单DC内强一致
└─ 跨DC最终一致

冲突解决: 应用层
├─ Last-Write-Wins (LWW)
├─ CRDT合并
└─ 自定义业务规则
```

---

## 三、架构设计

### 3.1 系统架构

```text
┌────────────────────────────────────────────────────────────┐
│          社交网络多地域架构                                  │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  ┌────────────┐    ┌────────────┐    ┌────────────┐       │
│  │  US-West   │    │  US-East   │    │  EU Region │       │
│  │            │    │            │    │            │       │
│  │ ┌────────┐ │    │ ┌────────┐ │    │ ┌────────┐ │       │
│  │ │API     │ │    │ │API     │ │    │ │API     │ │       │
│  │ │Gateway │ │    │ │Gateway │ │    │ │Gateway │ │       │
│  │ └───┬────┘ │    │ └───┬────┘ │    │ └───┬────┘ │       │
│  │     │      │    │     │      │    │     │      │       │
│  │ ┌───▼────┐ │    │ ┌───▼────┐ │    │ ┌───▼────┐ │       │
│  │ │PG      │◄├────┼─┤PG      │◄├────┼─┤PG      │ │       │
│  │ │Master  │ ├────┼→│Master  │ ├────┼→│Master  │ │       │
│  │ │(BDR)   │ │    │ │(BDR)   │ │    │ │(BDR)   │ │       │
│  │ └────────┘ │    │ └────────┘ │    │ └────────┘ │       │
│  │            │    │            │    │            │       │
│  │ ┌────────┐ │    │ ┌────────┐ │    │ ┌────────┐ │       │
│  │ │Redis   │ │    │ │Redis   │ │    │ │Redis   │ │       │
│  │ │(Cache) │ │    │ │(Cache) │ │    │ │(Cache) │ │       │
│  │ └────────┘ │    │ └────────┘ │    │ └────────┘ │       │
│  └────────────┘    └────────────┘    └────────────┘       │
│        ▲                  ▲                  ▲             │
│        └──────────────────┴──────────────────┘             │
│              异步双向复制 (延迟 <100ms)                      │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

**关键特性**:

1. **多主复制**: 每个DC都可写入
2. **就近访问**: 用户访问最近DC
3. **异步复制**: 不阻塞写入
4. **冲突解决**: 自动化策略

### 3.2 数据模型

**用户表**:

```sql
CREATE TABLE users (
    user_id         BIGINT PRIMARY KEY,
    username        VARCHAR(50) UNIQUE NOT NULL,
    display_name    VARCHAR(100),
    bio             TEXT,
    avatar_url      TEXT,
    created_at      TIMESTAMP DEFAULT NOW(),
    updated_at      TIMESTAMP DEFAULT NOW(),
    version         BIGINT DEFAULT 0,  -- 版本号（LWW冲突解决）

    -- BDR冲突解决：最后写入胜出
    PRIMARY KEY (user_id)
);

-- BDR配置
SELECT bdr.alter_table_conflict_detection(
    'users',
    'row_version',
    'version'
);
```

**帖子表**:

```sql
CREATE TABLE posts (
    post_id         BIGINT PRIMARY KEY,
    user_id         BIGINT NOT NULL REFERENCES users(user_id),
    content         TEXT NOT NULL,
    media_urls      TEXT[],
    created_at      TIMESTAMP DEFAULT NOW(),
    dc_origin       VARCHAR(20),  -- 创建该帖子的DC

    -- 分区键（按DC分区）
    PRIMARY KEY (post_id, dc_origin)
) PARTITION BY LIST (dc_origin);

CREATE TABLE posts_us_west PARTITION OF posts
    FOR VALUES IN ('us-west');

CREATE TABLE posts_us_east PARTITION OF posts
    FOR VALUES IN ('us-east');

CREATE TABLE posts_eu PARTITION OF posts
    FOR VALUES IN ('eu');
```

**点赞表（CRDT G-Counter）**:

```sql
CREATE TABLE likes (
    post_id         BIGINT,
    dc_id           VARCHAR(20),  -- CRDT: 每个DC一个计数器
    count           BIGINT DEFAULT 0,
    updated_at      TIMESTAMP DEFAULT NOW(),

    PRIMARY KEY (post_id, dc_id)
);

-- 查询总点赞数
CREATE VIEW post_likes_total AS
SELECT
    post_id,
    SUM(count) AS total_likes
FROM likes
GROUP BY post_id;
```

**关注表（CRDT OR-Set）**:

```sql
CREATE TABLE follows (
    follower_id     BIGINT,
    followee_id     BIGINT,
    dc_origin       VARCHAR(20),
    operation       VARCHAR(10),  -- 'add' or 'remove'
    timestamp       TIMESTAMP DEFAULT NOW(),
    unique_id       UUID DEFAULT gen_random_uuid(),

    PRIMARY KEY (follower_id, followee_id, unique_id)
);

-- 查询有效关注关系（OR-Set语义）
CREATE VIEW follows_active AS
SELECT DISTINCT ON (follower_id, followee_id)
    follower_id,
    followee_id
FROM follows
ORDER BY follower_id, followee_id, timestamp DESC
HAVING operation = 'add';
```

### 3.3 冲突解决策略

**策略1: Last-Write-Wins (LWW)**

```sql
-- 用户资料更新冲突
-- 保留version最大的记录
CREATE TRIGGER resolve_user_conflict
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION resolve_lww_conflict();

CREATE OR REPLACE FUNCTION resolve_lww_conflict()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.version > OLD.version THEN
        RETURN NEW;  -- 新版本胜出
    ELSE
        RETURN OLD;  -- 保持旧版本
    END IF;
END;
$$ LANGUAGE plpgsql;
```

**策略2: CRDT Merge**

```sql
-- 点赞计数合并（G-Counter）
CREATE OR REPLACE FUNCTION merge_like_counts()
RETURNS TRIGGER AS $$
BEGIN
    -- G-Counter: 单调递增，取MAX
    NEW.count := GREATEST(OLD.count, NEW.count);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## 四、实现方案

### 4.1 点赞功能（CRDT G-Counter）

```rust
// Rust实现
pub async fn like_post(db: &Client, post_id: i64, dc_id: &str) -> Result<()> {
    // G-Counter: 只增不减
    let sql = r#"
        INSERT INTO likes (post_id, dc_id, count, updated_at)
        VALUES ($1, $2, 1, NOW())
        ON CONFLICT (post_id, dc_id)
        DO UPDATE SET
            count = likes.count + 1,
            updated_at = NOW()
    "#;

    db.execute(sql, &[&post_id, &dc_id]).await?;

    Ok(())
}

// 查询总点赞数
pub async fn get_like_count(db: &Client, post_id: i64) -> Result<i64> {
    let row = db.query_one(
        "SELECT total_likes FROM post_likes_total WHERE post_id = $1",
        &[&post_id],
    ).await?;

    Ok(row.get(0))
}
```

**CRDT保证**:

```text
场景: 用户同时在两个DC点赞
├─ US DC: likes(post=1, dc='us', count=1)
├─ EU DC: likes(post=1, dc='eu', count=1)
└─ 复制后:
    ├─ US DC: likes(post=1, dc='us', count=1) + likes(post=1, dc='eu', count=1)
    ├─ EU DC: likes(post=1, dc='us', count=1) + likes(post=1, dc='eu', count=1)
    └─ 总计: 2 ✓（无冲突）
```

### 4.2 关注功能（CRDT OR-Set）

```rust
// 关注
pub async fn follow_user(
    db: &Client,
    follower_id: i64,
    followee_id: i64,
    dc_id: &str,
) -> Result<()> {
    let sql = r#"
        INSERT INTO follows (follower_id, followee_id, dc_origin, operation, timestamp, unique_id)
        VALUES ($1, $2, $3, 'add', NOW(), gen_random_uuid())
    "#;

    db.execute(sql, &[&follower_id, &followee_id, &dc_id]).await?;

    Ok(())
}

// 取关
pub async fn unfollow_user(
    db: &Client,
    follower_id: i64,
    followee_id: i64,
    dc_id: &str,
) -> Result<()> {
    let sql = r#"
        INSERT INTO follows (follower_id, followee_id, dc_origin, operation, timestamp, unique_id)
        VALUES ($1, $2, $3, 'remove', NOW(), gen_random_uuid())
    "#;

    db.execute(sql, &[&follower_id, &followee_id, &dc_id]).await?;

    Ok(())
}
```

**OR-Set语义**:

```text
操作序列:
T1: follow(A→B)    [add, uuid=1]
T2: unfollow(A→B)  [remove, uuid=2]
T3: follow(A→B)    [add, uuid=3]

最终状态: follows_active
├─ 保留最后的'add'操作 (uuid=3)
└─ 结果: A关注B ✓
```

---

## 五、冲突解决

### 5.1 冲突类型

| 冲突类型 | 示例 | 解决策略 |
|---------|------|---------|
| **插入-插入** | 两DC同时创建相同ID | UUID避免 |
| **更新-更新** | 两DC更新同一用户资料 | LWW（版本号） |
| **更新-删除** | 一边更新，一边删除 | 删除胜出 |
| **删除-删除** | 两DC同时删除 | 幂等 |

### 5.2 PostgreSQL BDR配置

```sql
-- 创建BDR组
SELECT bdr.create_node(
    node_name := 'us_west',
    local_dsn := 'host=pg-us-west.example.com port=5432 dbname=social'
);

SELECT bdr.join_node_group(
    node_group_name := 'social_network',
    node_name := 'us_west',
    join_using_dsn := 'host=pg-us-east.example.com port=5432 dbname=social'
);

-- 配置冲突解决
SELECT bdr.alter_table_conflict_detection(
    'users',
    'row_version',
    'version'
);

SELECT bdr.alter_table_conflict_detection(
    'posts',
    'row_origin',
    'dc_origin'
);
```

### 5.3 监控冲突

```sql
-- 查询冲突日志
SELECT
    conflict_type,
    local_tuple,
    remote_tuple,
    resolution,
    conflict_time
FROM bdr.conflict_history
WHERE conflict_time >= NOW() - INTERVAL '1 hour'
ORDER BY conflict_time DESC;

-- 统计冲突率
SELECT
    date_trunc('hour', conflict_time) AS hour,
    COUNT(*) AS conflict_count
FROM bdr.conflict_history
WHERE conflict_time >= NOW() - INTERVAL '24 hours'
GROUP BY hour
ORDER BY hour;
```

---

## 六、性能测试

### 6.1 可用性测试

**模拟网络分区**:

```bash
# 断开US-EU之间网络
iptables -A INPUT -s <EU_IP> -j DROP
iptables -A OUTPUT -d <EU_IP> -j DROP

# 测试US DC仍可写入
curl -X POST https://api-us.example.com/posts \
  -d '{"content": "Test during partition"}'

# 结果: 200 OK ✓

# 恢复网络
iptables -D INPUT -s <EU_IP> -j DROP
iptables -D OUTPUT -d <EU_IP> -j DROP

# 验证数据同步
sleep 10
curl https://api-eu.example.com/posts/<POST_ID>

# 结果: 数据已同步 ✓
```

**可用性统计**:

| 指标 | 目标 | 实际 | 达成 |
|-----|------|------|------|
| **年可用性** | 99.99% | 99.995% | ✓ |
| **计划内宕机** | <4小时/年 | 2小时 | ✓ |
| **故障恢复时间** | <5分钟 | 3分钟 | ✓ |

### 6.2 一致性延迟测试

**测试方案**:

1. US DC写入数据
2. 测量EU DC可见时间

**结果**:

| 距离 | P50延迟 | P99延迟 | P99.9延迟 |
|-----|--------|---------|----------|
| US-West → US-East | 45ms | 120ms | 250ms |
| US → EU | 95ms | 280ms | 850ms |
| US → Asia | 180ms | 450ms | 1200ms |

---

## 七、经验教训

### 7.1 设计决策回顾

**正确决策** ✅:

1. **选择AP系统** - 符合社交网络需求
2. **CRDT数据结构** - 自动解决冲突
3. **多主架构** - 全球低延迟
4. **异步复制** - 不阻塞写入

**权衡取舍** ⚖️:

- 牺牲强一致性 → 换取高可用性
- 接受短暂不一致（<5秒）
- 点赞计数可能有几秒延迟

### 7.2 最佳实践

**✅ DO**:

- 使用CRDT避免冲突
- 监控复制延迟
- 定期验证数据一致性
- 保留冲突日志用于分析

**❌ DON'T**:

- 不要在社交网络用强一致性
- 不要用同步复制（性能差）
- 不要忽略"读自己写"一致性
- 不要假设全局时钟同步

---

**案例版本**: 1.0.0
**创建日期**: 2025-12-05
**验证状态**: ✅ 理论验证 + 原型测试
**可用性**: **99.995%** (超过目标)

**相关案例**:

- `09-工业案例库/02-金融交易系统.md` (CP vs AP对比)
- `09-工业案例库/07-分布式缓存.md` (Raft一致性)

**相关理论**:

- `01-核心理论模型/04-CAP理论与权衡.md`
- `04-分布式扩展/05-CAP实践案例.md`
