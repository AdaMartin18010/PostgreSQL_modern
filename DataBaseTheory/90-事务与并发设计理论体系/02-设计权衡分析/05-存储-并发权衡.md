# 05 | 存储-并发权衡

> **决策工具**: 本文档分析MVCC的存储开销与并发性能的权衡关系，提供优化策略。

---

## 📑 目录

- [05 | 存储-并发权衡](#05--存储-并发权衡)
  - [📑 目录](#-目录)
  - [一、权衡基本原理](#一权衡基本原理)
    - [1.1 核心矛盾](#11-核心矛盾)
    - [1.2 数学模型](#12-数学模型)
  - [二、版本链长度分析](#二版本链长度分析)
    - [2.1 版本累积模型](#21-版本累积模型)
    - [2.2 长事务影响](#22-长事务影响)
    - [2.3 检测长事务](#23-检测长事务)
  - [三、表膨胀问题](#三表膨胀问题)
    - [3.1 膨胀率定义](#31-膨胀率定义)
    - [3.2 膨胀阈值](#32-膨胀阈值)
  - [四、索引膨胀](#四索引膨胀)
    - [4.1 索引膨胀原因](#41-索引膨胀原因)
    - [4.2 提高HOT率](#42-提高hot率)
  - [五、VACUUM策略](#五vacuum策略)
    - [5.1 VACUUM频率权衡](#51-vacuum频率权衡)
    - [5.2 VACUUM成本模型](#52-vacuum成本模型)
    - [5.3 Freeze策略](#53-freeze策略)
  - [六、存储优化技术](#六存储优化技术)
    - [6.1 TOAST压缩](#61-toast压缩)
    - [6.2 分区表](#62-分区表)
    - [6.3 BRIN索引](#63-brin索引)
  - [七、In-place vs MVCC对比](#七in-place-vs-mvcc对比)
    - [7.1 全面对比矩阵](#71-全面对比矩阵)
    - [7.2 性能曲线对比](#72-性能曲线对比)
    - [7.3 选择建议](#73-选择建议)
  - [八、实践指南](#八实践指南)
    - [8.1 监控指标](#81-监控指标)
    - [8.2 调优清单](#82-调优清单)
    - [8.3 最佳实践](#83-最佳实践)
  - [九、总结](#九总结)
    - [9.1 核心贡献](#91-核心贡献)
    - [9.2 关键公式](#92-关键公式)
    - [9.3 设计原则](#93-设计原则)
  - [十、延伸阅读](#十延伸阅读)

---

## 一、权衡基本原理

### 1.1 核心矛盾

**MVCC基本权衡**:

$$\text{High Concurrency} \xleftrightarrow[\text{Storage Cost}]{\text{Trade-off}} \text{Storage Overhead}$$

**图示**:

```
并发性能
  ↑
  │   ● MVCC (读无锁)
  │  /
  │ /
  │/   ● In-place Update
  │
  └────────────────────→ 存储开销
    1×      2×      5×
```

### 1.2 数学模型

**存储开销公式**:

$$Storage = BaseSize + VersionSpace + IndexSpace + DeadTupleSpace$$

**版本空间**:

$$VersionSpace = \sum_{row} ChainLength(row) \times TupleSize$$

**期望版本链长度**:

$$E[ChainLength] = UpdateRate \times AvgTxDuration$$

---

## 二、版本链长度分析

### 2.1 版本累积模型

**累积速率**:

$$\frac{dVersions}{dt} = UpdateRate - VacuumRate$$

**稳态条件**:

$$UpdateRate = VacuumRate \implies \text{Stable chain length}$$

**不稳态**:

$$UpdateRate > VacuumRate \implies \text{Unbounded growth}$$

### 2.2 长事务影响

**版本保留时间**:

$$RetentionTime = \max(\text{OldestActiveTransaction}, \text{LastVacuum})$$

**版本数量**:

$$VersionCount = UpdateRate \times RetentionTime$$

**量化示例**:

| 长事务时长 | 更新频率 | 累积版本数 | 存储膨胀 |
|-----------|---------|-----------|---------|
| 1分钟 | 100/s | 6,000 | 1.2× |
| 10分钟 | 100/s | 60,000 | 2× |
| 1小时 | 100/s | 360,000 | 5× |
| 10小时 | 100/s | 3,600,000 | 50× ⚠️ |

**警示**: 长事务是表膨胀的主因！

### 2.3 检测长事务

```sql
-- 查找运行超过5分钟的事务
SELECT
    pid,
    now() - xact_start AS duration,
    state,
    query
FROM pg_stat_activity
WHERE xact_start < now() - interval '5 minutes'
    AND state != 'idle'
ORDER BY duration DESC;

-- 终止长事务
SELECT pg_terminate_backend(pid);
```

---

## 三、表膨胀问题

### 3.1 膨胀率定义

**膨胀率**:

$$BloatRate = \frac{DeadTuples + UnusedSpace}{TotalSpace}$$

**计算查询**:

```sql
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS bloat,
    round(100 * (pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename))::numeric /
          NULLIF(pg_total_relation_size(schemaname||'.'||tablename), 0), 2) AS bloat_pct
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY bloat_pct DESC
LIMIT 10;
```

### 3.2 膨胀阈值

| 膨胀率 | 状态 | 行动 |
|-------|------|------|
| <10% | 健康 | 无需处理 |
| 10-30% | 警告 | 调整autovacuum |
| 30-50% | 严重 | 手动VACUUM FULL |
| >50% | 紧急 | 重建表 |

**重建表方案**:

```sql
-- 方案1: VACUUM FULL（锁表，停机）
VACUUM FULL table_name;

-- 方案2: pg_repack（在线，推荐）
pg_repack -t table_name database_name;

-- 方案3: 手动重建（灵活）
BEGIN;
CREATE TABLE table_new AS SELECT * FROM table_old;
DROP TABLE table_old;
ALTER TABLE table_new RENAME TO table_old;
-- 重建索引
COMMIT;
```

---

## 四、索引膨胀

### 4.1 索引膨胀原因

**MVCC索引特点**: 每个元组版本都有索引项

$$IndexEntries = \sum_{version} 1 \quad \text{(vs In-place: 1 entry/row)}$$

**膨胀率**:

$$IndexBloat = AvgChainLength \times (1 - HOTRate)$$

**HOT优化效果**:

| HOT率 | 索引膨胀 | 说明 |
|------|---------|------|
| 0% | 5× | 无HOT |
| 50% | 2.5× | 部分HOT |
| 90% | 1.5× | 高HOT率 |
| 100% | 1× | 完美HOT |

### 4.2 提高HOT率

**条件**:

1. ✅ 未更新索引列
2. ✅ 新版本在同页
3. ✅ 页面有空间

**优化策略**:

```sql
-- 1. 降低Fillfactor，预留HOT空间
ALTER TABLE orders SET (fillfactor = 70);  -- 默认100

-- 2. 减少索引数量（权衡查询性能）
DROP INDEX IF EXISTS orders_non_critical_idx;

-- 3. 分离频繁更新的列
-- 将status列移到独立表（避免更新主表）
CREATE TABLE order_status (
    order_id INT PRIMARY KEY REFERENCES orders(id),
    status VARCHAR(20),
    updated_at TIMESTAMPTZ
);
```

---

## 五、VACUUM策略

### 5.1 VACUUM频率权衡

**过于频繁**:

- ❌ CPU/IO开销大
- ❌ 锁竞争（扫描表需共享锁）

**不够频繁**:

- ❌ 表膨胀严重
- ❌ 查询性能下降（版本链长）

**最优频率**:

$$OptimalFreq = \frac{UpdateRate}{VacuumCost} \times TargetBloat$$

**配置建议**:

| 更新频率 | 表大小 | autovacuum_scale_factor | vacuum_threshold |
|---------|-------|------------------------|------------------|
| 低 (<100/s) | 小 | 0.2 (默认) | 50 |
| 中 (100-1K/s) | 中 | 0.1 | 100 |
| 高 (>1K/s) | 大 | 0.05 | 500 |

### 5.2 VACUUM成本模型

**时间开销**:

$$T_{vacuum} = \frac{TableSize}{ScanRate} + \frac{DeadTuples \times IndexCount}{CleanRate}$$

**I/O开销**:

$$IO_{vacuum} = TableSize + IndexSize \times IndexCount$$

**CPU开销**:

$$CPU_{vacuum} = DeadTuples \times (CheckCost + MarkCost)$$

**配置优化**:

```sql
-- 降低VACUUM对生产的影响
ALTER SYSTEM SET vacuum_cost_delay = 10;  -- 每页延迟10ms
ALTER SYSTEM SET vacuum_cost_limit = 200; -- 累计成本上限

-- 并行VACUUM（PostgreSQL 13+）
SET max_parallel_maintenance_workers = 4;
VACUUM (PARALLEL 4) large_table;
```

### 5.3 Freeze策略

**Freeze开销**:

$$FreezeCost = \frac{FrozenTuples}{FreezeRate} + UpdateFSMCost$$

**配置权衡**:

| 参数 | 激进策略 | 保守策略 | 推荐 |
|-----|---------|---------|------|
| vacuum_freeze_min_age | 10M | 50M | 50M |
| vacuum_freeze_table_age | 100M | 150M | 150M |
| autovacuum_freeze_max_age | 150M | 200M | 200M |

**激进策略**:

- ✅ 减少突发Freeze
- ❌ 频繁修改元组

**保守策略**:

- ✅ 减少日常开销
- ❌ 接近回卷时大量Freeze

---

## 六、存储优化技术

### 6.1 TOAST压缩

**TOAST (The Oversized-Attribute Storage Technique)**:

```sql
-- 大列压缩存储
ALTER TABLE documents
ALTER COLUMN content SET STORAGE EXTENDED;  -- 压缩+外部存储

-- 策略选择
-- PLAIN: 不压缩不外部（小列）
-- EXTENDED: 压缩+外部（大文本）
-- EXTERNAL: 仅外部（已压缩数据）
-- MAIN: 优先压缩（常用大列）
```

**效果**:

| 数据类型 | 原始大小 | EXTENDED后 | 压缩比 |
|---------|---------|-----------|--------|
| JSON | 10MB | 2MB | 5:1 |
| 文本 | 5MB | 1MB | 5:1 |
| 二进制 | 20MB | 15MB | 1.3:1 |

### 6.2 分区表

**目的**: 降低VACUUM粒度，提升并发

```sql
-- 按时间分区
CREATE TABLE orders (
    id SERIAL,
    created_at DATE,
    ...
) PARTITION BY RANGE (created_at);

CREATE TABLE orders_2024 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

CREATE TABLE orders_2025 PARTITION OF orders
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

**收益**:

| 指标 | 单表 | 分区表 | 提升 |
|-----|------|--------|------|
| VACUUM时间 | 1小时 | 6分钟/分区 | 10× |
| 查询性能 | 全表扫描 | 分区裁剪 | 5-10× |
| 维护灵活性 | 低 | 高 | - |

### 6.3 BRIN索引

**适用场景**: 顺序数据（时序、日志）

```sql
-- 传统B-tree索引
CREATE INDEX idx_orders_date ON orders(created_at);  -- 大小: 5GB

-- BRIN索引
CREATE INDEX idx_orders_date_brin ON orders USING BRIN(created_at);  -- 大小: 50MB
```

**权衡**:

| 维度 | B-tree | BRIN |
|-----|--------|------|
| 索引大小 | 大（5-10%表大小） | 极小（<1%） |
| 查询性能 | 快 | 中（需扫描块） |
| 更新性能 | 慢 | 快 |
| 适用场景 | 随机查询 | 范围查询+顺序数据 |

---

## 七、In-place vs MVCC对比

### 7.1 全面对比矩阵

| 维度 | In-place (MySQL InnoDB) | MVCC (PostgreSQL) |
|-----|------------------------|-------------------|
| **读性能** | 中（需Undo） | 高（直接读历史） |
| **写性能** | 高（原地更新） | 中（创建版本） |
| **存储开销** | 低（Undo独立） | 高（版本链） |
| **VACUUM** | Purge线程 | 必须频繁 |
| **长事务影响** | Undo链长 | 版本链长 |
| **实现复杂度** | 高 | 中 |

### 7.2 性能曲线对比

```
TPS
  ↑
  │     MVCC ───────
  │    /
  │   /
  │  / In-place ────
  │ /
  │/
  └────────────────────→ 读写比
    1:10  1:1  10:1  100:1
```

**交叉点**: 读写比约3:1时性能相当

### 7.3 选择建议

| 工作负载 | 读写比 | 推荐 | 理由 |
|---------|-------|------|------|
| **OLTP** | 10:1 | MVCC | 读多 |
| **批处理** | 1:10 | In-place | 写多 |
| **混合** | 1:1 | MVCC | 读写分离优势 |
| **分析** | 1000:1 | MVCC | 极度读密集 |

---

## 八、实践指南

### 8.1 监控指标

**关键SQL**:

```sql
-- 1. 表膨胀率
SELECT
    relname,
    n_dead_tup,
    n_live_tup,
    round(100.0 * n_dead_tup / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_pct
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY dead_pct DESC;

-- 2. 长事务
SELECT
    pid,
    usename,
    application_name,
    state,
    now() - xact_start AS duration
FROM pg_stat_activity
WHERE state != 'idle'
    AND xact_start < now() - interval '10 minutes'
ORDER BY duration DESC;

-- 3. VACUUM活动
SELECT
    relname,
    last_vacuum,
    last_autovacuum,
    n_dead_tup,
    autovacuum_count
FROM pg_stat_user_tables
WHERE last_autovacuum < now() - interval '1 hour'
    AND n_dead_tup > 1000;
```

### 8.2 调优清单

**级别1: 基础调优**

- [ ] 终止长事务（>1小时）
- [ ] 调整autovacuum参数
- [ ] 监控表膨胀率

**级别2: 深度优化**

- [ ] 降低Fillfactor提高HOT率
- [ ] 分区表减少VACUUM粒度
- [ ] 使用BRIN索引（顺序数据）

**级别3: 架构调整**

- [ ] 读写分离（只读副本）
- [ ] 冷热数据分离
- [ ] 考虑列存储（OLAP）

### 8.3 最佳实践

**DO**:

- ✅ 避免长事务
- ✅ 定期监控膨胀率
- ✅ 为热表调整autovacuum
- ✅ 使用分区表
- ✅ 选择合适的索引类型

**DON'T**:

- ❌ 禁用autovacuum
- ❌ 忽视死元组告警
- ❌ 过度索引（>10个/表）
- ❌ 在生产高峰VACUUM FULL
- ❌ 忽视Fillfactor配置

---

## 九、总结

### 9.1 核心贡献

**量化模型**:

1. 版本链长度公式（第2.2节）
2. 存储膨胀率计算（第3.1节）
3. VACUUM频率优化（第5.1节）

**优化策略**:

1. HOT优化（降低索引膨胀）
2. 分区表（降低VACUUM粒度）
3. BRIN索引（减少存储）

### 9.2 关键公式

**存储开销**:

$$Storage = BaseSize \times (1 + AvgChainLength \times (1 - HOTRate))$$

**最优VACUUM频率**:

$$VacuumFreq = UpdateRate \times \frac{TargetBloat}{VacuumCost}$$

### 9.3 设计原则

1. **预防优于治疗**: 避免长事务，而非频繁VACUUM
2. **分而治之**: 分区表降低维护粒度
3. **监控驱动**: 基于实际数据调优
4. **权衡清晰**: 明确存储成本换并发性能

---

## 十、延伸阅读

**PostgreSQL存储**:

- *PostgreSQL Internals* (Bruce Momjian)
- PostgreSQL Wiki: VACUUM详解

**性能优化**:

- *PostgreSQL 14 Internals* (Egor Rogov)
- Cybertec博客: VACUUM最佳实践

**扩展方向**:

- `01-核心理论模型/02-MVCC理论完整解析.md` → MVCC机制详解
- `05-实现机制/03-PostgreSQL-VACUUM机制.md` → VACUUM源码分析
- `06-性能分析/03-存储开销分析.md` → 详细量化分析

---

**版本**: 1.0.0
**最后更新**: 2025-12-05
**关联文档**:

- `01-核心理论模型/02-MVCC理论完整解析.md`
- `02-设计权衡分析/04-性能-正确性权衡.md`
- `06-性能分析/03-存储开销分析.md`
