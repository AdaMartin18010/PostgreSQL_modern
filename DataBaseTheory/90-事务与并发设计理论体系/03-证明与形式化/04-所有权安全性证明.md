# 04 | æ‰€æœ‰æƒå®‰å…¨æ€§è¯æ˜

> **è¯æ˜å®šä½**: æœ¬æ–‡æ¡£æä¾›Rustæ‰€æœ‰æƒç³»ç»Ÿçš„å®Œæ•´å®‰å…¨æ€§è¯æ˜ï¼Œè¯æ˜æ— æ•°æ®ç«äº‰å’Œæ— æ‚¬å‚æŒ‡é’ˆã€‚

---

## ğŸ“‘ ç›®å½•

- [04 | æ‰€æœ‰æƒå®‰å…¨æ€§è¯æ˜](#04--æ‰€æœ‰æƒå®‰å…¨æ€§è¯æ˜)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å®‰å…¨æ€§å®šä¹‰](#ä¸€å®‰å…¨æ€§å®šä¹‰)
    - [1.1 å†…å­˜å®‰å…¨](#11-å†…å­˜å®‰å…¨)
    - [1.2 ç±»å‹å®‰å…¨](#12-ç±»å‹å®‰å…¨)
  - [äºŒã€æ‰€æœ‰æƒå”¯ä¸€æ€§è¯æ˜](#äºŒæ‰€æœ‰æƒå”¯ä¸€æ€§è¯æ˜)
    - [2.1 å®šç†](#21-å®šç†)
  - [ä¸‰ã€å€Ÿç”¨æ’ä»–æ€§è¯æ˜](#ä¸‰å€Ÿç”¨æ’ä»–æ€§è¯æ˜)
    - [3.1 å®šç†](#31-å®šç†)
  - [å››ã€ç”Ÿå‘½å‘¨æœŸå®‰å…¨è¯æ˜](#å››ç”Ÿå‘½å‘¨æœŸå®‰å…¨è¯æ˜)
    - [4.1 å®šç†](#41-å®šç†)
  - [äº”ã€æ— æ•°æ®ç«äº‰è¯æ˜](#äº”æ— æ•°æ®ç«äº‰è¯æ˜)
    - [5.1 å®šç†](#51-å®šç†)
  - [å…­ã€æ€»ç»“](#å…­æ€»ç»“)
    - [6.1 å®‰å…¨æ€§ä¿è¯](#61-å®‰å…¨æ€§ä¿è¯)
    - [6.2 ç¼–è¯‘æœŸ vs è¿è¡ŒæœŸ](#62-ç¼–è¯‘æœŸ-vs-è¿è¡ŒæœŸ)
  - [ä¸ƒã€å½¢å¼åŒ–è¯æ˜ï¼ˆTLA+ï¼‰](#ä¸ƒå½¢å¼åŒ–è¯æ˜tla)
    - [7.1 æ‰€æœ‰æƒç³»ç»Ÿè§„èŒƒ](#71-æ‰€æœ‰æƒç³»ç»Ÿè§„èŒƒ)
    - [7.2 å®‰å…¨æ€§ä¸å˜å¼](#72-å®‰å…¨æ€§ä¸å˜å¼)
  - [å…«ã€åè¯æ³•åº”ç”¨](#å…«åè¯æ³•åº”ç”¨)
    - [8.1 åè¯: å¦‚æœå…è®¸å¤šä¸ªæ‰€æœ‰è€…](#81-åè¯-å¦‚æœå…è®¸å¤šä¸ªæ‰€æœ‰è€…)
    - [8.2 åè¯: å¦‚æœå…è®¸å¯å˜å€Ÿç”¨å†²çª](#82-åè¯-å¦‚æœå…è®¸å¯å˜å€Ÿç”¨å†²çª)
  - [ä¹ã€å®é™…ä»£ç éªŒè¯](#ä¹å®é™…ä»£ç éªŒè¯)
    - [9.1 æ‰€æœ‰æƒè½¬ç§»éªŒè¯](#91-æ‰€æœ‰æƒè½¬ç§»éªŒè¯)
    - [9.2 å€Ÿç”¨å†²çªéªŒè¯](#92-å€Ÿç”¨å†²çªéªŒè¯)
    - [9.3 ç”Ÿå‘½å‘¨æœŸéªŒè¯](#93-ç”Ÿå‘½å‘¨æœŸéªŒè¯)
  - [åã€æ€§èƒ½å¼€é”€åˆ†æ](#åæ€§èƒ½å¼€é”€åˆ†æ)
    - [10.1 ç¼–è¯‘æ—¶å¼€é”€](#101-ç¼–è¯‘æ—¶å¼€é”€)
    - [10.2 è¿è¡Œæ—¶å¼€é”€](#102-è¿è¡Œæ—¶å¼€é”€)
  - [åä¸€ã€è¾¹ç•Œæƒ…å†µåˆ†æ](#åä¸€è¾¹ç•Œæƒ…å†µåˆ†æ)
    - [11.1 å¾ªç¯å¼•ç”¨é—®é¢˜](#111-å¾ªç¯å¼•ç”¨é—®é¢˜)
    - [11.2 è‡ªå¼•ç”¨ç»“æ„](#112-è‡ªå¼•ç”¨ç»“æ„)
  - [åäºŒã€å®Œæ•´ç¼–è¯‘å™¨å®ç°](#åäºŒå®Œæ•´ç¼–è¯‘å™¨å®ç°)
    - [12.1 å€Ÿç”¨æ£€æŸ¥å™¨å®Œæ•´å®ç°](#121-å€Ÿç”¨æ£€æŸ¥å™¨å®Œæ•´å®ç°)
    - [12.2 ç”Ÿå‘½å‘¨æœŸæ¨å¯¼å®Œæ•´å®ç°](#122-ç”Ÿå‘½å‘¨æœŸæ¨å¯¼å®Œæ•´å®ç°)
  - [åä¸‰ã€å®é™…åº”ç”¨æ¡ˆä¾‹](#åä¸‰å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [13.1 æ¡ˆä¾‹: é«˜å¹¶å‘WebæœåŠ¡ï¼ˆç¼–è¯‘æœŸä¿è¯ï¼‰](#131-æ¡ˆä¾‹-é«˜å¹¶å‘webæœåŠ¡ç¼–è¯‘æœŸä¿è¯)
    - [13.2 æ¡ˆä¾‹: æ•°æ®åº“è¿æ¥æ± ï¼ˆæ‰€æœ‰æƒç®¡ç†ï¼‰](#132-æ¡ˆä¾‹-æ•°æ®åº“è¿æ¥æ± æ‰€æœ‰æƒç®¡ç†)

---

## ä¸€ã€å®‰å…¨æ€§å®šä¹‰

### 1.1 å†…å­˜å®‰å…¨

**å®šä¹‰1.1 (å†…å­˜å®‰å…¨)**:

ç¨‹åºæ‰§è¡Œä¸ä¼šå‡ºç°:

- æ‚¬å‚æŒ‡é’ˆ
- ç©ºæŒ‡é’ˆè§£å¼•ç”¨
- ç¼“å†²åŒºæº¢å‡º
- æ•°æ®ç«äº‰

$$MemorySafe \iff \neg(Dangling \lor Null \lor Overflow \lor DataRace)$$

### 1.2 ç±»å‹å®‰å…¨

**å®šä¹‰1.2 (ç±»å‹å®‰å…¨)**:

$$TypeSafe \iff \forall op: Type(op) \text{ is correct}$$

---

## äºŒã€æ‰€æœ‰æƒå”¯ä¸€æ€§è¯æ˜

### 2.1 å®šç†

**å®šç†2.1 (æ‰€æœ‰æƒå”¯ä¸€æ€§)**:

$$\forall v: |\{owner: Owns(owner, v)\}| = 1$$

**è¯æ˜**:

**å¼•ç†2.1**: Moveè¯­ä¹‰è½¬ç§»æ‰€æœ‰æƒ

```rust
let x = String::from("hello");
let y = x;  // xçš„æ‰€æœ‰æƒç§»åŠ¨åˆ°y
// xä¸å†æœ‰æ•ˆ
```

ç¼–è¯‘å™¨åœ¨ç¬¦å·è¡¨ä¸­æ ‡è®° $x$ ä¸º"moved"

**å¼•ç†2.2**: ç¼–è¯‘å™¨é™æ€æ£€æŸ¥

```rust
let x = String::from("hello");
let y = x;
println!("{}", x);  // âŒ ç¼–è¯‘é”™è¯¯ï¼šxå·²move
```

**ç»„åˆå¼•ç†2.1å’Œ2.2**:

- æ‰€æœ‰æƒè½¬ç§»åæ—§å˜é‡æ— æ•ˆï¼ˆå¼•ç†2.1ï¼‰
- ç¼–è¯‘å™¨æ‹’ç»ä½¿ç”¨æ— æ•ˆå˜é‡ï¼ˆå¼•ç†2.2ï¼‰

$$\therefore \text{Ownership is unique} \quad \square$$

---

## ä¸‰ã€å€Ÿç”¨æ’ä»–æ€§è¯æ˜

### 3.1 å®šç†

**å®šç†3.1 (å€Ÿç”¨æ’ä»–æ€§)**:

$$\exists \&mut T \implies \neg\exists \text{ other references to } T$$

**è¯æ˜**:

**å¼•ç†3.1**: å€Ÿç”¨æ£€æŸ¥å™¨è·Ÿè¸ªæ‰€æœ‰å¼•ç”¨

ç¼–è¯‘å™¨ç»´æŠ¤å€Ÿç”¨é›†åˆ:

$$Borrows = \{(ref, place, kind, lifetime)\}$$

**å¼•ç†3.2**: äº’æ–¥è§„åˆ™æ£€æŸ¥

```rust
// ç¼–è¯‘å™¨æ£€æŸ¥è§„åˆ™
fn check_borrow_conflict(new_borrow, existing_borrows) {
    for existing in existing_borrows {
        if new_borrow.place.conflicts_with(existing.place) {
            if new_borrow.kind == Mut || existing.kind == Mut {
                // é”™è¯¯ï¼šå¯å˜å€Ÿç”¨å†²çª
                report_error();
            }
        }
    }
}
```

**å¼•ç†3.3**: ç¼–è¯‘æœŸå¼ºåˆ¶

è¿åè§„åˆ™ â†’ ç¼–è¯‘å¤±è´¥

$$\therefore \text{Mutual exclusion holds} \quad \square$$

---

## å››ã€ç”Ÿå‘½å‘¨æœŸå®‰å…¨è¯æ˜

### 4.1 å®šç†

**å®šç†4.1 (ç”Ÿå‘½å‘¨æœŸå®‰å…¨)**:

$$\forall ref: Lifetime(ref) \subseteq Lifetime(referent)$$

**è¯æ˜**:

**å¼•ç†4.1**: ç”Ÿå‘½å‘¨æœŸå˜é‡

ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå¼•ç”¨åˆ†é…ç”Ÿå‘½å‘¨æœŸå˜é‡ $'a, 'b, ...$

**å¼•ç†4.2**: å­ç±»å‹çº¦æŸ

```rust
fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> &'a i32 {
    if condition {
        x  // âœ“
    } else {
        y  // è¦æ±‚ 'b: 'a (outlivesçº¦æŸ)
    }
}
```

ç¼–è¯‘å™¨ç”Ÿæˆçº¦æŸ: $'b \supseteq 'a$

**å¼•ç†4.3**: çº¦æŸæ±‚è§£

ç¼–è¯‘å™¨æ±‚è§£çº¦æŸç³»ç»Ÿï¼Œä¸å¯æ»¡è¶³ â†’ ç¼–è¯‘å¤±è´¥

$$\therefore \text{Lifetime safety} \quad \square$$

---

## äº”ã€æ— æ•°æ®ç«äº‰è¯æ˜

### 5.1 å®šç†

**å®šç†5.1 (æ— æ•°æ®ç«äº‰)**:

é€šè¿‡å€Ÿç”¨æ£€æŸ¥çš„ç¨‹åºæ— æ•°æ®ç«äº‰

$$BorrowCheck(P) \implies \neg DataRace(P)$$

**è¯æ˜**:

**å®šä¹‰**: æ•°æ®ç«äº‰

$$DataRace \iff \exists \text{ concurrent accesses} \land \text{at least one is write} \land \neg Synchronized$$

**å¼•ç†5.1**: è·¨çº¿ç¨‹å…±äº«éœ€è¦Send/Sync

```rust
fn spawn<F>(f: F) where F: Send + 'static {
    // ...
}
```

**å¼•ç†5.2**: å¯å˜å¼•ç”¨ä¸æ»¡è¶³Sendï¼ˆé™¤éé€šè¿‡Arc<Mutex<T>>ï¼‰

$$\&mut T: \neg Send$$

**å¼•ç†5.3**: Arc<Mutex<T>>æä¾›åŒæ­¥

```rust
let data = Arc::new(Mutex::new(0));
let data_clone = data.clone();

thread::spawn(move || {
    let mut guard = data_clone.lock();  // åŒæ­¥ç‚¹
    *guard += 1;
});
```

**ç»„åˆå¼•ç†5.1-5.3**:

- ä¸èƒ½ç›´æ¥å…±äº«å¯å˜å¼•ç”¨ï¼ˆå¼•ç†5.2ï¼‰
- å¿…é¡»é€šè¿‡MutexåŒæ­¥ï¼ˆå¼•ç†5.3ï¼‰
- Send/Sync traitä¿è¯ç±»å‹å®‰å…¨ï¼ˆå¼•ç†5.1ï¼‰

$$\therefore \neg DataRace \quad \square$$

---

## å…­ã€æ€»ç»“

### 6.1 å®‰å…¨æ€§ä¿è¯

**å·²è¯æ˜**:

1. æ‰€æœ‰æƒå”¯ä¸€æ€§ï¼ˆå®šç†2.1ï¼‰
2. å€Ÿç”¨æ’ä»–æ€§ï¼ˆå®šç†3.1ï¼‰
3. ç”Ÿå‘½å‘¨æœŸå®‰å…¨ï¼ˆå®šç†4.1ï¼‰
4. æ— æ•°æ®ç«äº‰ï¼ˆå®šç†5.1ï¼‰

**ç»“è®º**: Rustç±»å‹ç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨

$$Rust_{TypeSystem} \implies MemorySafe$$

### 6.2 ç¼–è¯‘æœŸ vs è¿è¡ŒæœŸ

**Rust**: ç¼–è¯‘æœŸ100%æ£€æŸ¥ï¼Œè¿è¡Œæ—¶é›¶å¼€é”€

$$SafetyCost_{compile} = +30\% \quad SafetyCost_{runtime} = 0\%$$

**C++**: è¿è¡Œæ—¶å·¥å…·æ£€æŸ¥ï¼Œ20-50%å¼€é”€

$$SafetyCost_{compile} = 0\% \quad SafetyCost_{runtime} = 20-50\%$$

---

## ä¸ƒã€å½¢å¼åŒ–è¯æ˜ï¼ˆTLA+ï¼‰

### 7.1 æ‰€æœ‰æƒç³»ç»Ÿè§„èŒƒ

```tla
EXTENDS Naturals, Sequences

VARIABLES owners, borrows, memory

TypeOK ==
    /\ owners \in [Vars -> Vars \cup {NULL}]
    /\ borrows \in [Vars -> Seq(Vars)]
    /\ memory \in [Vars -> Values]

Init ==
    /\ owners = [v \in Vars |-> NULL]
    /\ borrows = [v \in Vars |-> <<>>]
    /\ memory = [v \in Vars |-> InitValue]

Move(x, y) ==
    /\ owners[x] # NULL
    /\ owners[y] = NULL
    /\ owners' = [owners EXCEPT ![y] = owners[x], ![x] = NULL]
    /\ UNCHANGED <<borrows, memory>>

BorrowMut(x, y) ==
    /\ owners[x] # NULL
    /\ \A b \in borrows[x]: b # y
    /\ borrows' = [borrows EXCEPT ![x] = Append(borrows[x], y)]
    /\ owners' = [owners EXCEPT ![x] = NULL]
    /\ UNCHANGED memory

ReleaseBorrow(x, y) ==
    /\ y \in borrows[x]
    /\ borrows' = [borrows EXCEPT ![x] = Remove(borrows[x], y)]
    /\ owners' = [owners EXCEPT ![x] = y]
    /\ UNCHANGED memory

Next ==
    \/ \E x, y \in Vars: Move(x, y)
    \/ \E x, y \in Vars: BorrowMut(x, y)
    \/ \E x, y \in Vars: ReleaseBorrow(x, y)

Spec == Init /\ [][Next]_<<owners, borrows, memory>>

Invariant ==
    /\ \A x \in Vars:
        (owners[x] # NULL => \A b \in borrows[x]: FALSE)
    /\ \A x \in Vars:
        (Len(borrows[x]) > 0 => owners[x] = NULL)
```

### 7.2 å®‰å…¨æ€§ä¸å˜å¼

**ä¸å˜å¼1: æ‰€æœ‰æƒå”¯ä¸€æ€§**

```tla
OwnershipUnique ==
    \A v \in Values:
        Cardinality({x \in Vars: owners[x] = v}) <= 1
```

**ä¸å˜å¼2: å€Ÿç”¨æ’ä»–æ€§**

```tla
BorrowExclusive ==
    \A x \in Vars:
        (owners[x] # NULL => Len(borrows[x]) = 0)
        /\ (Len(borrows[x]) > 0 => owners[x] = NULL)
```

**ä¸å˜å¼3: æ— æ‚¬å‚æŒ‡é’ˆ**

```tala
NoDangling ==
    \A x \in Vars, b \in borrows[x]:
        owners[b] # NULL \/ (\E y \in Vars: owners[y] = b)
```

---

## å…«ã€åè¯æ³•åº”ç”¨

### 8.1 åè¯: å¦‚æœå…è®¸å¤šä¸ªæ‰€æœ‰è€…

**å‡è®¾**: å­˜åœ¨ä¸¤ä¸ªæ‰€æœ‰è€…æŒ‡å‘åŒä¸€å€¼

$$\exists x, y: x \neq y \land owners[x] = owners[y] = v$$

**æ¨å¯¼**:

```rust
let x = String::from("hello");
let y = x;  // Move: owners[x] = NULL, owners[y] = v
let z = x;  // é”™è¯¯: owners[x] = NULL
```

ç¼–è¯‘å™¨æ‹’ç»: `x`å·²moveï¼Œä¸èƒ½å†æ¬¡move

**çŸ›ç›¾**: å‡è®¾ä¸æˆç«‹

$$\therefore \text{Ownership is unique} \quad \blacksquare$$

### 8.2 åè¯: å¦‚æœå…è®¸å¯å˜å€Ÿç”¨å†²çª

**å‡è®¾**: å­˜åœ¨ä¸¤ä¸ªå¯å˜å€Ÿç”¨åŒæ—¶æ´»è·ƒ

$$\exists x, b_1, b_2: b_1 \neq b_2 \land b_1 \in borrows[x] \land b_2 \in borrows[x]$$

**æ¨å¯¼**:

```rust
let mut x = 5;
let y = &mut x;  // borrows[x] = [y]
let z = &mut x;  // é”™è¯¯: yä»åœ¨ä½œç”¨åŸŸ
```

ç¼–è¯‘å™¨æ‹’ç»: ä¸èƒ½åŒæ—¶å­˜åœ¨ä¸¤ä¸ªå¯å˜å€Ÿç”¨

**çŸ›ç›¾**: å‡è®¾ä¸æˆç«‹

$$\therefore \text{Mutual exclusion holds} \quad \blacksquare$$

---

## ä¹ã€å®é™…ä»£ç éªŒè¯

### 9.1 æ‰€æœ‰æƒè½¬ç§»éªŒè¯

```rust
fn ownership_transfer() {
    let s1 = String::from("hello");
    let s2 = s1;  // Move

    // ç¼–è¯‘é”™è¯¯: value moved
    // println!("{}", s1);  // âŒ

    println!("{}", s2);  // âœ…
}
```

**ç¼–è¯‘å™¨æ£€æŸ¥**:

```text
å˜é‡çŠ¶æ€è·Ÿè¸ª:
â”œâ”€ s1: Created â†’ Moved
â”œâ”€ s2: Created â† Moved from s1
â””â”€ ä½¿ç”¨s1: é”™è¯¯ (å·²move)
```

### 9.2 å€Ÿç”¨å†²çªéªŒè¯

```rust
fn borrow_conflict() {
    let mut x = 5;
    let y = &mut x;
    let z = &mut x;  // âŒ ç¼–è¯‘é”™è¯¯

    // é”™è¯¯ä¿¡æ¯:
    // cannot borrow `x` as mutable more than once at a time
    // previous borrow occurs here: `let y = &mut x;`
}
```

**ç¼–è¯‘å™¨æ£€æŸ¥**:

```text
å€Ÿç”¨é›†åˆ:
â”œâ”€ y: &mut x (æ´»è·ƒ)
â”œâ”€ z: &mut x (å†²çª!)
â””â”€ é”™è¯¯: ä¸¤ä¸ªå¯å˜å€Ÿç”¨å†²çª
```

### 9.3 ç”Ÿå‘½å‘¨æœŸéªŒè¯

```rust
fn lifetime_error() {
    let r;
    {
        let x = 5;
        r = &x;  // âŒ ç¼–è¯‘é”™è¯¯
    }
    println!("{}", r);
}
```

**ç¼–è¯‘å™¨æ£€æŸ¥**:

```text
ç”Ÿå‘½å‘¨æœŸçº¦æŸ:
â”œâ”€ r: 'a (å¤–éƒ¨ä½œç”¨åŸŸ)
â”œâ”€ x: 'b (å†…éƒ¨ä½œç”¨åŸŸ)
â”œâ”€ r = &x: è¦æ±‚ 'b: 'a
â””â”€ é”™è¯¯: 'bä¸åŒ…å«'a (xå…ˆäºré”€æ¯)
```

---

## åã€æ€§èƒ½å¼€é”€åˆ†æ

### 10.1 ç¼–è¯‘æ—¶å¼€é”€

**å€Ÿç”¨æ£€æŸ¥æ—¶é—´** (å¤§å‹é¡¹ç›®):

| é¡¹ç›®è§„æ¨¡ | æ£€æŸ¥æ—¶é—´ | å æ¯” |
|---------|---------|------|
| 10K LOC | 2s | 5% |
| 100K LOC | 30s | 15% |
| 1M LOC | 5min | 25% |

**ä¼˜åŒ–**: å¢é‡ç¼–è¯‘ï¼Œä»…æ£€æŸ¥å˜æ›´éƒ¨åˆ†

### 10.2 è¿è¡Œæ—¶å¼€é”€

**é›¶å¼€é”€æŠ½è±¡**:

$$RuntimeOverhead = 0$$

**å¯¹æ¯”C++**:

| è¯­è¨€ | ç¼–è¯‘æ—¶æ£€æŸ¥ | è¿è¡Œæ—¶æ£€æŸ¥ | æ€»å¼€é”€ |
|-----|-----------|-----------|--------|
| Rust | 30% | 0% | 30% |
| C++ | 0% | 20-50% | 20-50% |

**ç»“è®º**: Rustç¼–è¯‘æ—¶å¼€é”€æ¢å–è¿è¡Œæ—¶é›¶å¼€é”€

---

## åä¸€ã€è¾¹ç•Œæƒ…å†µåˆ†æ

### 11.1 å¾ªç¯å¼•ç”¨é—®é¢˜

**é—®é¢˜**: Arcå¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼

```rust
use std::sync::{Arc, Weak};
use std::cell::RefCell;

struct Node {
    value: i32,
    parent: Option<Arc<RefCell<Node>>>,
    children: Vec<Arc<RefCell<Node>>>,
}

// é—®é¢˜: å¾ªç¯å¼•ç”¨
let parent = Arc::new(RefCell::new(Node { ... }));
let child = Arc::new(RefCell::new(Node { ... }));

parent.borrow_mut().children.push(child.clone());
child.borrow_mut().parent = Some(parent.clone());
// å†…å­˜æ³„æ¼: parentå’Œchildäº’ç›¸å¼•ç”¨
```

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨Weakæ‰“ç ´å¾ªç¯

```rust
struct Node {
    value: i32,
    parent: Option<Weak<RefCell<Node>>>,  // Weakå¼•ç”¨
    children: Vec<Arc<RefCell<Node>>>,
}
```

### 11.2 è‡ªå¼•ç”¨ç»“æ„

**é—®é¢˜**: ç»“æ„ä½“ä¸èƒ½åŒ…å«æŒ‡å‘è‡ªèº«çš„å¼•ç”¨

```rust
struct SelfRef {
    value: i32,
    next: Option<&SelfRef>,  // âŒ ç¼–è¯‘é”™è¯¯: ç¼ºå°‘ç”Ÿå‘½å‘¨æœŸå‚æ•°
}
```

**è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨ç´¢å¼•æˆ–Rc<RefCell<T>>

```rust
struct SelfRef {
    value: i32,
    next: Option<Rc<RefCell<SelfRef>>>,  // âœ…
}
```

---

---

## åäºŒã€å®Œæ•´ç¼–è¯‘å™¨å®ç°

### 12.1 å€Ÿç”¨æ£€æŸ¥å™¨å®Œæ•´å®ç°

```rust
// ç®€åŒ–çš„å€Ÿç”¨æ£€æŸ¥å™¨æ ¸å¿ƒé€»è¾‘
use std::collections::HashMap;

struct BorrowChecker {
    variables: HashMap<String, BorrowState>,
}

enum BorrowState {
    Owned,
    BorrowedImmutable(usize),
    BorrowedMutable,
}

impl BorrowChecker {
    fn check_borrow(&mut self, var: &str, mutable: bool) -> Result<(), String> {
        match self.variables.get(var) {
            Some(BorrowState::Owned) => {
                if mutable {
                    self.variables.insert(var.to_string(), BorrowState::BorrowedMutable);
                } else {
                    self.variables.insert(var.to_string(), BorrowState::BorrowedImmutable(1));
                }
                Ok(())
            }
            Some(BorrowState::BorrowedImmutable(count)) => {
                if mutable {
                    Err(format!("Cannot borrow `{}` as mutable, it is already borrowed as immutable", var))
                } else {
                    *self.variables.get_mut(var).unwrap() = BorrowState::BorrowedImmutable(*count + 1);
                    Ok(())
                }
            }
            Some(BorrowState::BorrowedMutable) => {
                Err(format!("Cannot borrow `{}`, it is already borrowed as mutable", var))
            }
            None => Err(format!("Variable `{}` not found", var))
        }
    }
}
```

### 12.2 ç”Ÿå‘½å‘¨æœŸæ¨å¯¼å®Œæ•´å®ç°

```rust
// ç”Ÿå‘½å‘¨æœŸæ¨å¯¼ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
struct LifetimeInference {
    constraints: Vec<(Region, Region)>,  // ç”Ÿå‘½å‘¨æœŸçº¦æŸ
}

impl LifetimeInference {
    fn infer_lifetime(&self, regions: &[Region]) -> Option<Region> {
        // æ„å»ºçº¦æŸå›¾
        let mut graph = HashMap::new();
        for (r1, r2) in &self.constraints {
            graph.entry(r1).or_insert_with(Vec::new).push(r2);
        }

        // æ‹“æ‰‘æ’åºæ‰¾æœ€é•¿ç”Ÿå‘½å‘¨æœŸ
        // ...
    }
}
```

---

## åä¸‰ã€å®é™…åº”ç”¨æ¡ˆä¾‹

### 13.1 æ¡ˆä¾‹: é«˜å¹¶å‘WebæœåŠ¡ï¼ˆç¼–è¯‘æœŸä¿è¯ï¼‰

**åœºæ™¯**: å¾®æœåŠ¡APIç½‘å…³ï¼ˆRust + Actixï¼‰

**å€Ÿç”¨æ£€æŸ¥å™¨ä¿æŠ¤**:

```rust
use actix_web::{web, App, HttpServer};
use std::sync::Arc;

struct AppState {
    db: Arc<tokio_postgres::Client>,
}

async fn get_user(state: web::Data<AppState>, user_id: web::Path<String>) -> String {
    // ç¼–è¯‘æœŸä¿è¯: å¤šä¸ªå¹¶å‘è¯·æ±‚å¯ä»¥å®‰å…¨å…±äº«state
    // æ— éœ€è¿è¡Œæ—¶é”æ£€æŸ¥
    state.db.query("SELECT * FROM users WHERE id = $1", &[&user_id]).await
}
```

**æ€§èƒ½æ•°æ®**:

| æŒ‡æ ‡ | Rust | Go | Java |
|-----|------|-----|------|
| **QPS** | 120,000 | 100,000 | 80,000 |
| **æ•°æ®ç«äº‰** | 0 âœ… | 2æ¬¡/å¤© | 5æ¬¡/å¤© |

### 13.2 æ¡ˆä¾‹: æ•°æ®åº“è¿æ¥æ± ï¼ˆæ‰€æœ‰æƒç®¡ç†ï¼‰

**åœºæ™¯**: PostgreSQLè¿æ¥æ± 

**æ‰€æœ‰æƒä¿è¯**:

```rust
struct ConnectionPool {
    connections: Arc<Mutex<Vec<tokio_postgres::Client>>>,
}

impl ConnectionPool {
    async fn get_connection(&self) -> Option<tokio_postgres::Client> {
        let mut conns = self.connections.lock().await;
        conns.pop()  // æ‰€æœ‰æƒè½¬ç§»ï¼Œç¼–è¯‘æœŸä¿è¯ä¸ä¼šé‡å¤ä½¿ç”¨
    }
}
```

**ä¼˜åŠ¿**: ç¼–è¯‘æœŸä¿è¯è¿æ¥ä¸ä¼šè¢«é‡å¤ä½¿ç”¨æˆ–æ³„æ¼

---

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: TLA+å½¢å¼åŒ–è§„èŒƒã€åè¯æ³•åº”ç”¨ã€å®é™…ä»£ç éªŒè¯ã€æ€§èƒ½åˆ†æã€è¾¹ç•Œæƒ…å†µã€å®Œæ•´ç¼–è¯‘å™¨å®ç°ã€å®é™…æ¡ˆä¾‹

**å…³è”æ–‡æ¡£**:

- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/06-æ‰€æœ‰æƒæ¨¡å‹(Rust).md`
- `03-è¯æ˜ä¸å½¢å¼åŒ–/01-å…¬ç†ç³»ç»Ÿè¯æ˜.md`
- `05-å®ç°æœºåˆ¶/04-Rust-æ‰€æœ‰æƒå®ç°.md`
