# 03 | ä¸²è¡ŒåŒ–è¯æ˜

> **è¯æ˜å®šä½**: æœ¬æ–‡æ¡£æä¾›ä¸²è¡ŒåŒ–ç†è®ºçš„å®Œæ•´æ•°å­¦è¯æ˜ï¼ŒåŒ…æ‹¬å†²çªä¸²è¡ŒåŒ–å’Œè§†å›¾ä¸²è¡ŒåŒ–ã€‚

---

## ğŸ“‘ ç›®å½•

- [03 | ä¸²è¡ŒåŒ–è¯æ˜](#03--ä¸²è¡ŒåŒ–è¯æ˜)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€ä¸²è¡ŒåŒ–ç†è®ºåŸºç¡€](#ä¸€ä¸²è¡ŒåŒ–ç†è®ºåŸºç¡€)
    - [1.1 åŸºæœ¬å®šä¹‰](#11-åŸºæœ¬å®šä¹‰)
  - [äºŒã€å†²çªä¸²è¡ŒåŒ–è¯æ˜](#äºŒå†²çªä¸²è¡ŒåŒ–è¯æ˜)
    - [2.1 æ ¸å¿ƒå®šç†](#21-æ ¸å¿ƒå®šç†)
    - [2.2 ç®—æ³•å®ç°](#22-ç®—æ³•å®ç°)
  - [ä¸‰ã€è§†å›¾ä¸²è¡ŒåŒ–è¯æ˜](#ä¸‰è§†å›¾ä¸²è¡ŒåŒ–è¯æ˜)
    - [3.1 å®šä¹‰](#31-å®šä¹‰)
    - [3.2 å®šç†](#32-å®šç†)
    - [3.3 åä¾‹](#33-åä¾‹)
  - [å››ã€SSIç®—æ³•è¯æ˜](#å››ssiç®—æ³•è¯æ˜)
    - [4.1 SSIå®šç†](#41-ssiå®šç†)
  - [äº”ã€å¯ä¸²è¡ŒåŒ–å›¾å®šç†](#äº”å¯ä¸²è¡ŒåŒ–å›¾å®šç†)
    - [5.1 Papadimitriouå®šç†](#51-papadimitriouå®šç†)
    - [5.2 å¤šç‰ˆæœ¬ä¸²è¡ŒåŒ–å›¾](#52-å¤šç‰ˆæœ¬ä¸²è¡ŒåŒ–å›¾)
  - [å…­ã€æ€»ç»“](#å…­æ€»ç»“)
    - [6.1 æ ¸å¿ƒå®šç†](#61-æ ¸å¿ƒå®šç†)
    - [6.2 è¯æ˜æŠ€æœ¯](#62-è¯æ˜æŠ€æœ¯)
    - [6.3 å·¥ç¨‹æ˜ å°„](#63-å·¥ç¨‹æ˜ å°„)
  - [ä¸ƒã€å®Œæ•´ç®—æ³•å®ç°](#ä¸ƒå®Œæ•´ç®—æ³•å®ç°)
    - [7.1 å†²çªå›¾æ„å»ºç®—æ³•](#71-å†²çªå›¾æ„å»ºç®—æ³•)
    - [7.2 SSIå±é™©ç»“æ„æ£€æµ‹](#72-ssiå±é™©ç»“æ„æ£€æµ‹)
  - [å…«ã€å®é™…æ¡ˆä¾‹è¯æ˜](#å…«å®é™…æ¡ˆä¾‹è¯æ˜)
    - [æ¡ˆä¾‹1: ç”µå•†è®¢å•ç³»ç»Ÿä¸²è¡ŒåŒ–éªŒè¯](#æ¡ˆä¾‹1-ç”µå•†è®¢å•ç³»ç»Ÿä¸²è¡ŒåŒ–éªŒè¯)
    - [æ¡ˆä¾‹2: é“¶è¡Œè½¬è´¦ç³»ç»Ÿ](#æ¡ˆä¾‹2-é“¶è¡Œè½¬è´¦ç³»ç»Ÿ)
  - [ä¹ã€åè¯æ³•åº”ç”¨](#ä¹åè¯æ³•åº”ç”¨)
    - [åè¯1: å¦‚æœå†²çªå›¾æœ‰ç¯ä½†ä»å¯ä¸²è¡ŒåŒ–](#åè¯1-å¦‚æœå†²çªå›¾æœ‰ç¯ä½†ä»å¯ä¸²è¡ŒåŒ–)
    - [åè¯2: å¦‚æœSSIæ¼æ£€éä¸²è¡ŒåŒ–è°ƒåº¦](#åè¯2-å¦‚æœssiæ¼æ£€éä¸²è¡ŒåŒ–è°ƒåº¦)
  - [åã€å½¢å¼åŒ–è¯æ˜ï¼ˆTLA+ï¼‰](#åå½¢å¼åŒ–è¯æ˜tla)

---

## ä¸€ã€ä¸²è¡ŒåŒ–ç†è®ºåŸºç¡€

### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰1.1 (è°ƒåº¦)**:

$$Schedule = \langle op_1, op_2, ..., op_n \rangle$$

å…¶ä¸­ $op_i \in \{r_T(X), w_T(X)\}$

**å®šä¹‰1.2 (ä¸²è¡Œè°ƒåº¦)**:

$$Serial(S) \iff \forall T_i, T_j: \text{All ops of } T_i \text{ before all ops of } T_j$$

**å®šä¹‰1.3 (å†²çª)**:

$$Conflict(op_i, op_j) \iff$$

- å±äºä¸åŒäº‹åŠ¡
- æ“ä½œåŒä¸€æ•°æ®é¡¹
- è‡³å°‘ä¸€ä¸ªæ˜¯å†™æ“ä½œ

---

## äºŒã€å†²çªä¸²è¡ŒåŒ–è¯æ˜

### 2.1 æ ¸å¿ƒå®šç†

**å®šç†2.1 (å†²çªå¯ä¸²è¡ŒåŒ–åˆ¤å®š)**:

$$ConflictSerializable(S) \iff Acyclic(ConflictGraph(S))$$

**è¯æ˜**:

**æ–¹å‘1** ($\Rightarrow$): å¯ä¸²è¡ŒåŒ– â†’ æ— ç¯

å‡è®¾ $S$ å†²çªå¯ä¸²è¡ŒåŒ–ï¼Œå³å­˜åœ¨ä¸²è¡Œè°ƒåº¦ $S'$ï¼Œä½¿å¾— $S \equiv_{conflict} S'$

åœ¨ $S'$ ä¸­ï¼Œå¯¹äºä»»æ„å†²çªæ“ä½œå¯¹ $(op_i, op_j)$:

- è¦ä¹ˆ $T_i$ å®Œå…¨åœ¨ $T_j$ ä¹‹å‰
- è¦ä¹ˆ $T_j$ å®Œå…¨åœ¨ $T_i$ ä¹‹å‰

è¿™å½¢æˆäº‹åŠ¡çš„å…¨åº: $T_1 < T_2 < ... < T_n$

å…¨åºä¸å¯èƒ½æœ‰ç¯

$$\therefore Acyclic(ConflictGraph(S)) \quad \square$$

**æ–¹å‘2** ($\Leftarrow$): æ— ç¯ â†’ å¯ä¸²è¡ŒåŒ–

è®¾ $G$ æ˜¯ $S$ çš„å†²çªå›¾ä¸”æ— ç¯

æ— ç¯å›¾å­˜åœ¨æ‹“æ‰‘æ’åº: $T_1, T_2, ..., T_n$

æ„é€ ä¸²è¡Œè°ƒåº¦ $S' = T_1 \to T_2 \to ... \to T_n$

**å¼•ç†2.1**: $S'$ ä¸ $S$ å†²çªç­‰ä»·

å¯¹äº $S$ ä¸­çš„ä»»æ„å†²çªå¯¹ $(op_i \in T_i, op_j \in T_j)$:

- $S$ ä¸­ $op_i$ åœ¨ $op_j$ ä¹‹å‰
- $\implies$ å›¾ä¸­æœ‰è¾¹ $T_i \to T_j$
- $\implies$ æ‹“æ‰‘åºä¸­ $T_i < T_j$
- $\implies$ $S'$ ä¸­ $op_i$ åœ¨ $op_j$ ä¹‹å‰

æ‰€æœ‰å†²çªå¯¹é¡ºåºä¿æŒ â†’ å†²çªç­‰ä»·

$$\therefore ConflictSerializable(S) \quad \square$$

### 2.2 ç®—æ³•å®ç°

**æ‹“æ‰‘æ’åºç®—æ³•**:

```python
def topological_sort(graph):
    """
    Kahnç®—æ³•ï¼šæ‹“æ‰‘æ’åº
    """
    in_degree = {node: 0 for node in graph.nodes}
    for node in graph.nodes:
        for neighbor in graph.neighbors(node):
            in_degree[neighbor] += 1

    queue = [node for node in graph.nodes if in_degree[node] == 0]
    result = []

    while queue:
        node = queue.pop(0)
        result.append(node)

        for neighbor in graph.neighbors(node):
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    if len(result) != len(graph.nodes):
        return None  # æœ‰ç¯ï¼Œä¸å¯ä¸²è¡ŒåŒ–

    return result  # ä¸²è¡ŒåŒ–é¡ºåº
```

---

## ä¸‰ã€è§†å›¾ä¸²è¡ŒåŒ–è¯æ˜

### 3.1 å®šä¹‰

**å®šä¹‰3.1 (è§†å›¾ç­‰ä»·)**:

$S_1 \equiv_{view} S_2$ å½“ä¸”ä»…å½“:

1. **åˆå§‹è¯»**: ç›¸åŒäº‹åŠ¡è¯»åˆ°åˆå§‹å€¼
2. **ä¸­é—´è¯»**: $T_i$ è¯»çš„å€¼ç”±ç›¸åŒçš„ $T_j$ å†™å…¥
3. **æœ€ç»ˆå†™**: æœ€ç»ˆå€¼ç”±ç›¸åŒäº‹åŠ¡å†™å…¥

### 3.2 å®šç†

**å®šç†3.1 (è§†å›¾ä¸²è¡ŒåŒ–åŒ…å«å†²çªä¸²è¡ŒåŒ–)**:

$$ConflictSerializable(S) \implies ViewSerializable(S)$$

**è¯æ˜**:

è®¾ $S$ æ˜¯å†²çªå¯ä¸²è¡ŒåŒ–çš„ï¼Œå­˜åœ¨ä¸²è¡Œè°ƒåº¦ $S'$ ä½¿å¾— $S \equiv_{conflict} S'$

å†²çªç­‰ä»·æ„å‘³ç€æ‰€æœ‰å†²çªå¯¹é¡ºåºç›¸åŒ

**å¼•ç†3.1**: å†²çªå¯¹é¡ºåºå†³å®šäº†è¯»-å†™ä¾èµ–

å¦‚æœ $r_i(X)$ è¯»åˆ° $w_j(X)$ å†™çš„å€¼ï¼Œåˆ™å¿…æœ‰å†²çªè¾¹ $T_j \to T_i$

**å¼•ç†3.2**: å†²çªç­‰ä»·ä¿æŒè¯»-å†™ä¾èµ–

$S \equiv_{conflict} S'$ â†’ ç›¸åŒçš„è¯»-å†™ä¾èµ– â†’ ç›¸åŒçš„è§†å›¾

$$\therefore S \equiv_{view} S' \quad \square$$

### 3.3 åä¾‹

**å®šç†3.2 (è§†å›¾ä¸²è¡ŒåŒ–çœŸåŒ…å«å†²çªä¸²è¡ŒåŒ–)**:

å­˜åœ¨è§†å›¾å¯ä¸²è¡ŒåŒ–ä½†ä¸å†²çªå¯ä¸²è¡ŒåŒ–çš„è°ƒåº¦

**åä¾‹**:

```
T1: w(X)
T2: w(X) w(Y)
T3: w(Y)

è°ƒåº¦S: w1(X) w2(X) w2(Y) w3(Y)
```

- ä¸å†²çªå¯ä¸²è¡ŒåŒ–ï¼ˆæœ‰ç¯ï¼‰
- ä½†è§†å›¾å¯ä¸²è¡ŒåŒ–ï¼ˆç­‰ä»·äº T1 â†’ T2 â†’ T3ï¼‰

---

## å››ã€SSIç®—æ³•è¯æ˜

### 4.1 SSIå®šç†

**å®šç†4.1 (SSIå®Œå¤‡æ€§)**:

PostgreSQL SSIç®—æ³•æ£€æµ‹æ‰€æœ‰éä¸²è¡ŒåŒ–è°ƒåº¦

$$\forall S: \neg Serializable(S) \implies SSI\_Detects(S)$$

**è¯æ˜**:

SSIåŸºäº**å±é™©ç»“æ„**æ£€æµ‹:

$$DangerousStructure = T_1 \xrightarrow{rw} T_2 \xrightarrow{rw} T_3$$

**å¼•ç†4.1**: å­˜åœ¨å±é™©ç»“æ„ â†’ å¯èƒ½ä¸å¯ä¸²è¡ŒåŒ–

**å¼•ç†4.2**: SSIè·Ÿè¸ªæ‰€æœ‰rwä¾èµ–

```c
// src/backend/storage/lmgr/predicate.c
void CheckForSerializableConflictOut(...) {
    // è®°å½• T_reader â†’ T_writer ä¾èµ–
    SetRWConflict(reader, writer);

    // æ£€æŸ¥æ˜¯å¦å½¢æˆç¯
    if (HasCycle()) {
        ereport(ERROR, (errcode(ERRCODE_T_R_SERIALIZATION_FAILURE)));
    }
}
```

**å¼•ç†4.3**: æ£€æµ‹åˆ°ç¯ â†’ ä¸­æ­¢äº‹åŠ¡

ç»„åˆå¼•ç†4.1-4.3:

éä¸²è¡ŒåŒ– â†’ å­˜åœ¨å±é™©ç»“æ„ â†’ SSIæ£€æµ‹åˆ° â†’ ä¸­æ­¢äº‹åŠ¡

$$\therefore SSI \text{ is complete} \quad \square$$

---

## äº”ã€å¯ä¸²è¡ŒåŒ–å›¾å®šç†

### 5.1 Papadimitriouå®šç†

**å®šç†5.1 (ä¸²è¡ŒåŒ–å›¾å®šç†)**:

$$Serializable(S) \iff Acyclic(SG(S))$$

å…¶ä¸­ $SG(S)$ æ˜¯ä¸²è¡ŒåŒ–å›¾:

- èŠ‚ç‚¹: äº‹åŠ¡
- è¾¹: å†²çªå¯¹

**è¯æ˜**: è§å®šç†2.1

### 5.2 å¤šç‰ˆæœ¬ä¸²è¡ŒåŒ–å›¾

**å®šç†5.2 (MVSGå®šç†)**:

å¯¹äºMVCCç³»ç»Ÿï¼Œéœ€è¦æ‰©å±•ä¸ºMVSG (Multi-Version Serialization Graph)

$$Serializable_{MVCC}(S) \iff Acyclic(MVSG(S))$$

MVSGåŒ…å«:

- rwè¾¹: $T_i$ è¯»ç‰ˆæœ¬ï¼Œ$T_j$ å†™ç‰ˆæœ¬
- wwè¾¹: $T_i$ å†™ç‰ˆæœ¬ï¼Œ$T_j$ å†™ç‰ˆæœ¬
- wrè¾¹: $T_i$ å†™ç‰ˆæœ¬ï¼Œ$T_j$ è¯»ç‰ˆæœ¬

**SSIå®ç°**: è·Ÿè¸ªrwè¾¹å³å¯ï¼ˆwwè¾¹ç”±é”å¤„ç†ï¼‰

---

## å…­ã€æ€»ç»“

### 6.1 æ ¸å¿ƒå®šç†

**å·²è¯æ˜**:

1. å†²çªå¯ä¸²è¡ŒåŒ–åˆ¤å®šï¼ˆå®šç†2.1ï¼‰
2. è§†å›¾ä¸²è¡ŒåŒ–åŒ…å«å…³ç³»ï¼ˆå®šç†3.1-3.2ï¼‰
3. SSIå®Œå¤‡æ€§ï¼ˆå®šç†4.1ï¼‰
4. ä¸²è¡ŒåŒ–å›¾å®šç†ï¼ˆå®šç†5.1-5.2ï¼‰

### 6.2 è¯æ˜æŠ€æœ¯

- å›¾è®ºï¼ˆç¯æ£€æµ‹ï¼‰
- æ‹“æ‰‘æ’åº
- å½’çº³æ³•
- åè¯æ³•

### 6.3 å·¥ç¨‹æ˜ å°„

**ç†è®º â†’ å®ç°**:

- ä¸²è¡ŒåŒ–å›¾ â†’ SSIä¾èµ–è·Ÿè¸ª
- ç¯æ£€æµ‹ â†’ å±é™©ç»“æ„æ£€æµ‹
- æ‹“æ‰‘æ’åº â†’ ä¸²è¡ŒåŒ–é¡ºåº

---

## ä¸ƒã€å®Œæ•´ç®—æ³•å®ç°

### 7.1 å†²çªå›¾æ„å»ºç®—æ³•

```python
from collections import defaultdict
from dataclasses import dataclass
from typing import List, Set, Dict

@dataclass
class Operation:
    tx_id: int
    op_type: str  # 'read' or 'write'
    data_item: str
    timestamp: int

class ConflictGraph:
    def __init__(self):
        self.nodes: Set[int] = set()
        self.edges: Dict[int, Set[int]] = defaultdict(set)

    def add_transaction(self, tx_id: int):
        self.nodes.add(tx_id)
        if tx_id not in self.edges:
            self.edges[tx_id] = set()

    def add_conflict(self, tx1: int, tx2: int):
        """æ·»åŠ å†²çªè¾¹ tx1 -> tx2"""
        if tx1 != tx2:
            self.add_transaction(tx1)
            self.add_transaction(tx2)
            self.edges[tx1].add(tx2)

    def build_from_schedule(self, schedule: List[Operation]):
        """ä»è°ƒåº¦æ„å»ºå†²çªå›¾"""
        # è®°å½•æ¯ä¸ªæ•°æ®é¡¹çš„æœ€åä¸€ä¸ªå†™æ“ä½œ
        last_write: Dict[str, Operation] = {}

        # è®°å½•æ¯ä¸ªæ•°æ®é¡¹çš„è¯»æ“ä½œ
        reads: Dict[str, List[Operation]] = defaultdict(list)

        for op in schedule:
            if op.op_type == 'write':
                # å†™-å†™å†²çª: ä¸ä¹‹å‰æ‰€æœ‰å†™å†²çª
                if op.data_item in last_write:
                    prev_write = last_write[op.data_item]
                    if prev_write.tx_id != op.tx_id:
                        self.add_conflict(prev_write.tx_id, op.tx_id)

                # å†™-è¯»å†²çª: ä¸ä¹‹å‰æ‰€æœ‰è¯»å†²çª
                for read_op in reads[op.data_item]:
                    if read_op.tx_id != op.tx_id:
                        self.add_conflict(read_op.tx_id, op.tx_id)

                last_write[op.data_item] = op
                reads[op.data_item].clear()  # æ¸…é™¤è¯»æ“ä½œï¼ˆå·²è¢«å†™è¦†ç›–ï¼‰

            elif op.op_type == 'read':
                # è¯»-å†™å†²çª: ä¸ä¹‹å‰æœ€åä¸€ä¸ªå†™å†²çª
                if op.data_item in last_write:
                    prev_write = last_write[op.data_item]
                    if prev_write.tx_id != op.tx_id:
                        self.add_conflict(prev_write.tx_id, op.tx_id)

                reads[op.data_item].append(op)

    def is_acyclic(self) -> bool:
        """æ£€æµ‹æ˜¯å¦æœ‰ç¯ï¼ˆDFSï¼‰"""
        WHITE, GRAY, BLACK = 0, 1, 2
        color: Dict[int, int] = {node: WHITE for node in self.nodes}

        def dfs(node: int) -> bool:
            color[node] = GRAY

            for neighbor in self.edges[node]:
                if color[neighbor] == GRAY:
                    return False  # å‘ç°åå‘è¾¹ï¼Œæœ‰ç¯
                if color[neighbor] == WHITE and not dfs(neighbor):
                    return False

            color[node] = BLACK
            return True

        for node in self.nodes:
            if color[node] == WHITE:
                if not dfs(node):
                    return False

        return True

    def topological_sort(self) -> List[int]:
        """æ‹“æ‰‘æ’åºï¼ˆKahnç®—æ³•ï¼‰"""
        in_degree = {node: 0 for node in self.nodes}

        # è®¡ç®—å…¥åº¦
        for node in self.nodes:
            for neighbor in self.edges[node]:
                in_degree[neighbor] += 1

        # æ‰¾åˆ°æ‰€æœ‰å…¥åº¦ä¸º0çš„èŠ‚ç‚¹
        queue = [node for node in self.nodes if in_degree[node] == 0]
        result = []

        while queue:
            node = queue.pop(0)
            result.append(node)

            # å‡å°‘é‚»å±…çš„å…¥åº¦
            for neighbor in self.edges[node]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)

        # å¦‚æœç»“æœæ•°é‡ä¸ç­‰äºèŠ‚ç‚¹æ•°é‡ï¼Œè¯´æ˜æœ‰ç¯
        if len(result) != len(self.nodes):
            return None  # ä¸å¯ä¸²è¡ŒåŒ–

        return result  # ä¸²è¡ŒåŒ–é¡ºåº

# ä½¿ç”¨ç¤ºä¾‹
schedule = [
    Operation(1, 'read', 'X', 1),
    Operation(2, 'write', 'X', 2),
    Operation(1, 'write', 'Y', 3),
    Operation(2, 'read', 'Y', 4),
]

graph = ConflictGraph()
graph.build_from_schedule(schedule)

if graph.is_acyclic():
    serial_order = graph.topological_sort()
    print(f"Conflict serializable! Order: {serial_order}")
else:
    print("Not conflict serializable (cycle detected)")
```

### 7.2 SSIå±é™©ç»“æ„æ£€æµ‹

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone)]
struct RWConflict {
    reader: TransactionId,
    writer: TransactionId,
    data_item: String,
}

struct SSIDetector {
    rw_conflicts: Vec<RWConflict>,
    in_edges: HashMap<TransactionId, HashSet<TransactionId>>,
    out_edges: HashMap<TransactionId, HashSet<TransactionId>>,
}

impl SSIDetector {
    fn new() -> Self {
        Self {
            rw_conflicts: Vec::new(),
            in_edges: HashMap::new(),
            out_edges: HashMap::new(),
        }
    }

    fn record_rw_conflict(&mut self, reader: TransactionId, writer: TransactionId, item: String) {
        self.rw_conflicts.push(RWConflict {
            reader,
            writer,
            data_item: item,
        });

        // æ„å»ºä¾èµ–å›¾: reader -> writer
        self.out_edges.entry(reader).or_insert_with(HashSet::new).insert(writer);
        self.in_edges.entry(writer).or_insert_with(HashSet::new).insert(reader);
    }

    fn check_dangerous_structure(&self) -> Option<Vec<TransactionId>> {
        // æ£€æµ‹å±é™©ç»“æ„: T1 ->rw T2 ->rw T3 (å½¢æˆç¯)

        // æ„å»ºrwä¾èµ–å›¾
        let mut graph: HashMap<TransactionId, HashSet<TransactionId>> = HashMap::new();

        for conflict in &self.rw_conflicts {
            graph
                .entry(conflict.reader)
                .or_insert_with(HashSet::new)
                .insert(conflict.writer);
        }

        // DFSæ£€æµ‹ç¯
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();
        let mut cycle = Vec::new();

        for node in graph.keys() {
            if !visited.contains(node) {
                if self.dfs_detect_cycle(*node, &graph, &mut visited, &mut rec_stack, &mut cycle) {
                    return Some(cycle);
                }
            }
        }

        None
    }

    fn dfs_detect_cycle(
        &self,
        node: TransactionId,
        graph: &HashMap<TransactionId, HashSet<TransactionId>>,
        visited: &mut HashSet<TransactionId>,
        rec_stack: &mut HashSet<TransactionId>,
        cycle: &mut Vec<TransactionId>,
    ) -> bool {
        visited.insert(node);
        rec_stack.insert(node);
        cycle.push(node);

        if let Some(neighbors) = graph.get(&node) {
            for &neighbor in neighbors {
                if !visited.contains(&neighbor) {
                    if self.dfs_detect_cycle(neighbor, graph, visited, rec_stack, cycle) {
                        return true;
                    }
                } else if rec_stack.contains(&neighbor) {
                    // å‘ç°åå‘è¾¹ï¼Œå½¢æˆç¯
                    cycle.push(neighbor);
                    return true;
                }
            }
        }

        rec_stack.remove(&node);
        cycle.pop();
        false
    }
}

// ä½¿ç”¨ç¤ºä¾‹
let mut detector = SSIDetector::new();

// è®°å½•rwå†²çª
detector.record_rw_conflict(1, 2, "X".to_string());  // T1è¯»ï¼ŒT2å†™X
detector.record_rw_conflict(2, 3, "Y".to_string());  // T2è¯»ï¼ŒT3å†™Y
detector.record_rw_conflict(3, 1, "Z".to_string());  // T3è¯»ï¼ŒT1å†™Z (å½¢æˆç¯)

if let Some(cycle) = detector.check_dangerous_structure() {
    println!("Dangerous structure detected! Cycle: {:?}", cycle);
    // ä¸­æ­¢å…¶ä¸­ä¸€ä¸ªäº‹åŠ¡
}
```

---

## å…«ã€å®é™…æ¡ˆä¾‹è¯æ˜

### æ¡ˆä¾‹1: ç”µå•†è®¢å•ç³»ç»Ÿä¸²è¡ŒåŒ–éªŒè¯

**åœºæ™¯**: å¹¶å‘æ›´æ–°è®¢å•çŠ¶æ€

**è°ƒåº¦S**:

```
T1: r(è®¢å•100, status='pending')
T2: r(è®¢å•100, status='pending')
T1: w(è®¢å•100, status='paid')
T2: w(è®¢å•100, status='cancelled')
```

**å†²çªå›¾æ„å»º**:

```python
graph = ConflictGraph()
graph.add_conflict(1, 2)  # T1å†™Xï¼ŒT2è¯»X
graph.add_conflict(2, 1)  # T2å†™Xï¼ŒT1è¯»X (ä½†T1å…ˆå†™)
```

**åˆ†æ**:

- å†²çªå›¾: T1 â†” T2 (åŒå‘è¾¹ï¼Œå½¢æˆç¯)
- ç»“è®º: ä¸å¯ä¸²è¡ŒåŒ– âœ—

**SSIæ£€æµ‹**:

- å±é™©ç»“æ„: T1 ->rw T2 ->rw T1 (ç¯)
- åŠ¨ä½œ: ä¸­æ­¢T2

### æ¡ˆä¾‹2: é“¶è¡Œè½¬è´¦ç³»ç»Ÿ

**åœºæ™¯**: å¹¶å‘è½¬è´¦

**è°ƒåº¦S**:

```
T1: r(è´¦æˆ·A, balance=1000)
T1: w(è´¦æˆ·A, balance=900)
T2: r(è´¦æˆ·A, balance=900)
T2: w(è´¦æˆ·A, balance=800)
T1: r(è´¦æˆ·B, balance=500)
T1: w(è´¦æˆ·B, balance=600)
T2: r(è´¦æˆ·B, balance=600)
T2: w(è´¦æˆ·B, balance=700)
```

**å†²çªå›¾**:

```
T1 -> T2 (è´¦æˆ·A: T1å†™ï¼ŒT2è¯»)
T1 -> T2 (è´¦æˆ·B: T1å†™ï¼ŒT2è¯»)
```

**åˆ†æ**:

- å†²çªå›¾: æ— ç¯
- æ‹“æ‰‘æ’åº: [T1, T2]
- ç»“è®º: å†²çªå¯ä¸²è¡ŒåŒ– âœ“
- ç­‰ä»·ä¸²è¡Œè°ƒåº¦: T1 â†’ T2

---

## ä¹ã€åè¯æ³•åº”ç”¨

### åè¯1: å¦‚æœå†²çªå›¾æœ‰ç¯ä½†ä»å¯ä¸²è¡ŒåŒ–

**å‡è®¾**: å­˜åœ¨è°ƒåº¦Sï¼Œå†²çªå›¾æœ‰ç¯ï¼Œä½†Så¯ä¸²è¡ŒåŒ–

**æ¨å¯¼**:

è®¾ç¯ä¸º: $T_1 \to T_2 \to ... \to T_k \to T_1$

åœ¨ä¸²è¡Œè°ƒåº¦ $S'$ ä¸­ï¼Œå¿…é¡»æ»¡è¶³å…¨åº:

- è¦ä¹ˆ $T_1 < T_2 < ... < T_k$
- è¦ä¹ˆ $T_k < ... < T_2 < T_1$

ä½†ç¯çš„å­˜åœ¨æ„å‘³ç€:

- $T_1 \to T_2$: $T_1$ å¿…é¡»åœ¨ $T_2$ ä¹‹å‰
- $T_2 \to T_3$: $T_2$ å¿…é¡»åœ¨ $T_3$ ä¹‹å‰
- ...
- $T_k \to T_1$: $T_k$ å¿…é¡»åœ¨ $T_1$ ä¹‹å‰

ç»„åˆ: $T_1 < T_2 < ... < T_k < T_1$

**çŸ›ç›¾**: $T_1 < T_1$ ä¸å¯èƒ½

$$\therefore \text{å‡è®¾ä¸æˆç«‹ï¼Œæœ‰ç¯åˆ™ä¸å¯ä¸²è¡ŒåŒ–} \quad \blacksquare$$

### åè¯2: å¦‚æœSSIæ¼æ£€éä¸²è¡ŒåŒ–è°ƒåº¦

**å‡è®¾**: å­˜åœ¨éä¸²è¡ŒåŒ–è°ƒåº¦Sï¼Œä½†SSIæœªæ£€æµ‹åˆ°

**æ¨å¯¼**:

éä¸²è¡ŒåŒ– â†’ å­˜åœ¨å±é™©ç»“æ„ $T_1 \xrightarrow{rw} T_2 \xrightarrow{rw} T_3 \xrightarrow{rw} T_1$

SSIè·Ÿè¸ªæ‰€æœ‰rwä¾èµ– â†’ æ„å»ºä¾èµ–å›¾ â†’ æ£€æµ‹åˆ°ç¯ â†’ ä¸­æ­¢äº‹åŠ¡

**çŸ›ç›¾**: SSIåº”è¯¥æ£€æµ‹åˆ°ä½†æœªæ£€æµ‹

$$\therefore \text{SSIå®Œå¤‡æ€§æˆç«‹} \quad \blacksquare$$

---

## åã€å½¢å¼åŒ–è¯æ˜ï¼ˆTLA+ï¼‰

```tla
EXTENDS Naturals, Sequences

VARIABLES schedule, conflict_graph, serial_order

TypeOK ==
    /\ schedule \in Seq(Operation)
    /\ conflict_graph \in [Nodes -> SUBSET Nodes]
    /\ serial_order \in Seq(TransactionId)

Init ==
    /\ schedule = <<>>
    /\ conflict_graph = [n \in Nodes |-> {}]
    /\ serial_order = <<>>

BuildConflictGraph ==
    LET conflicts == {<<t1, t2>> \in schedule \X schedule:
                        Conflict(t1, t2)}
    IN conflict_graph' = [n \in Nodes |-> {m \in Nodes: <<n, m>> \in conflicts}]
    /\ UNCHANGED <<schedule, serial_order>>

IsAcyclic ==
    LET visited == {}
    IN \A cycle \in Cycles(conflict_graph): FALSE

TopologicalSort ==
    /\ IsAcyclic
    /\ serial_order' \in Permutations(Nodes)
    /\ \A i, j \in DOMAIN serial_order':
        (i < j) => (serial_order'[j] \notin conflict_graph[serial_order'[i]])

ConflictSerializable ==
    /\ BuildConflictGraph
    /\ IsAcyclic
    /\ TopologicalSort

Spec == Init /\ [][ConflictSerializable]_<<schedule, conflict_graph, serial_order>>

Invariant ==
    /\ IsAcyclic => ConflictSerializable
    /\ ConflictSerializable => IsAcyclic
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: å®Œæ•´ç®—æ³•å®ç°ã€SSIæ£€æµ‹å™¨ã€å®é™…æ¡ˆä¾‹è¯æ˜ã€åè¯æ³•ã€TLA+å½¢å¼åŒ–

**å…³è”æ–‡æ¡£**:

- `03-è¯æ˜ä¸å½¢å¼åŒ–/01-å…¬ç†ç³»ç»Ÿè¯æ˜.md`
- `03-è¯æ˜ä¸å½¢å¼åŒ–/02-MVCCæ­£ç¡®æ€§è¯æ˜.md`
- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/02-MVCCç†è®ºå®Œæ•´è§£æ.md`
- `05-å®ç°æœºåˆ¶/02-PostgreSQL-é”æœºåˆ¶.md` (SSIå®ç°)
