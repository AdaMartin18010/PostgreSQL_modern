# 04 | æµç¨‹å›¾é›†

> **å¯è§†åŒ–å·¥å…·**: æœ¬æ–‡æ¡£æ±‡æ€»æ ¸å¿ƒæµç¨‹å›¾ï¼Œå±•ç¤ºç³»ç»Ÿè¿è¡Œæµç¨‹å’ŒçŠ¶æ€è½¬æ¢ã€‚

---

## ğŸ“‘ ç›®å½•

- [04 | æµç¨‹å›¾é›†](#04--æµç¨‹å›¾é›†)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€äº‹åŠ¡æ‰§è¡Œæµç¨‹](#ä¸€äº‹åŠ¡æ‰§è¡Œæµç¨‹)
  - [äºŒã€MVCCå¯è§æ€§æ£€æŸ¥æµç¨‹](#äºŒmvccå¯è§æ€§æ£€æŸ¥æµç¨‹)
  - [ä¸‰ã€VACUUMæ‰§è¡Œæµç¨‹](#ä¸‰vacuumæ‰§è¡Œæµç¨‹)
  - [å››ã€æ­»é”æ£€æµ‹æµç¨‹](#å››æ­»é”æ£€æµ‹æµç¨‹)
  - [äº”ã€Raftå…±è¯†æµç¨‹](#äº”raftå…±è¯†æµç¨‹)
  - [å…­ã€å®Œæ•´å®ç°ä»£ç ](#å…­å®Œæ•´å®ç°ä»£ç )
    - [6.1 äº‹åŠ¡æ‰§è¡Œæµç¨‹å®ç°](#61-äº‹åŠ¡æ‰§è¡Œæµç¨‹å®ç°)
    - [6.2 MVCCå¯è§æ€§æ£€æŸ¥å®ç°](#62-mvccå¯è§æ€§æ£€æŸ¥å®ç°)
    - [6.3 æ­»é”æ£€æµ‹æµç¨‹å®ç°](#63-æ­»é”æ£€æµ‹æµç¨‹å®ç°)
  - [ä¸ƒã€æµç¨‹å›¾ç”Ÿæˆå·¥å…·](#ä¸ƒæµç¨‹å›¾ç”Ÿæˆå·¥å…·)
    - [7.1 Pythonæµç¨‹å›¾ç”Ÿæˆå™¨](#71-pythonæµç¨‹å›¾ç”Ÿæˆå™¨)
  - [å…«ã€å®é™…åº”ç”¨æ¡ˆä¾‹](#å…«å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: è°ƒè¯•äº‹åŠ¡å¼‚å¸¸](#æ¡ˆä¾‹1-è°ƒè¯•äº‹åŠ¡å¼‚å¸¸)
    - [æ¡ˆä¾‹2: ä¼˜åŒ–VACUUM](#æ¡ˆä¾‹2-ä¼˜åŒ–vacuum)

---

## ä¸€ã€äº‹åŠ¡æ‰§è¡Œæµç¨‹

```mermaid
graph TD
    A[BEGIN] --> B[è·å–äº‹åŠ¡ID]
    B --> C[åˆ›å»ºå¿«ç…§]
    C --> D{æ‰§è¡ŒSQLè¯­å¥}
    D --> E{æ˜¯å¦SELECT?}
    E -->|æ˜¯| F[å¯è§æ€§æ£€æŸ¥]
    E -->|å¦| G[è·å–é”]
    G --> H[ä¿®æ”¹æ•°æ®]
    H --> I[å†™WAL]
    I --> D
    D --> J{COMMIT?}
    J -->|æ˜¯| K[å†™WAL COMMITè®°å½•]
    K --> L[fsync WAL]
    L --> M[æ›´æ–°pg_clog]
    M --> N[é‡Šæ”¾é”]
    N --> O[END]
    J -->|ROLLBACK| P[å›æ»š]
    P --> N
```

---

## äºŒã€MVCCå¯è§æ€§æ£€æŸ¥æµç¨‹

```mermaid
graph TD
    A[æ£€æŸ¥å…ƒç»„å¯è§æ€§] --> B{xminæœ‰æ•ˆ?}
    B -->|å¦| Z1[ä¸å¯è§]
    B -->|æ˜¯| C{xminå·²æäº¤?}
    C -->|å¦| Z2[ä¸å¯è§]
    C -->|æ˜¯| D{xmin < xmin_snap?}
    D -->|æ˜¯| E{xmaxæœ‰æ•ˆ?}
    D -->|å¦| F{xmin in xip?}
    F -->|æ˜¯| Z3[ä¸å¯è§]
    F -->|å¦| E
    E -->|å¦| Z4[å¯è§]
    E -->|æ˜¯| G{xmaxå·²æäº¤?}
    G -->|å¦| Z5[å¯è§]
    G -->|æ˜¯| H{xmax < xmax_snap?}
    H -->|æ˜¯| Z6[ä¸å¯è§]
    H -->|å¦| I{xmax in xip?}
    I -->|æ˜¯| Z7[å¯è§]
    I -->|å¦| Z8[ä¸å¯è§]
```

---

## ä¸‰ã€VACUUMæ‰§è¡Œæµç¨‹

```mermaid
graph TD
    A[VACUUMå¯åŠ¨] --> B[æ‰«æå †è¡¨ç¬¬ä¸€é]
    B --> C[æ”¶é›†æ­»å…ƒç»„TID]
    C --> D{æ­»å…ƒç»„æ•°>é˜ˆå€¼?}
    D -->|æ˜¯| E[æ¸…ç†ç´¢å¼•]
    D -->|å¦| F
    E --> F[æ‰«æå †è¡¨ç¬¬äºŒé]
    F --> G[å›æ”¶ç©ºé—´]
    G --> H{éœ€è¦Freeze?}
    H -->|æ˜¯| I[Freezeè€å…ƒç»„]
    H -->|å¦| J
    I --> J[æ›´æ–°FSM/VM]
    J --> K[æ›´æ–°ç»Ÿè®¡ä¿¡æ¯]
    K --> L[å®Œæˆ]
```

---

## å››ã€æ­»é”æ£€æµ‹æµç¨‹

```mermaid
graph TD
    A[é”ç­‰å¾…è¶…æ—¶] --> B[æ„å»ºç­‰å¾…å›¾]
    B --> C{DFSæ£€æµ‹ç¯?}
    C -->|å‘ç°ç¯| D[é€‰æ‹©å—å®³è€…]
    C -->|æ— ç¯| E[ç»§ç»­ç­‰å¾…]
    D --> F[ä¸­æ­¢äº‹åŠ¡]
    F --> G[é‡Šæ”¾é”]
    G --> H[å”¤é†’ç­‰å¾…è€…]
```

---

## äº”ã€Raftå…±è¯†æµç¨‹

```mermaid
sequenceDiagram
    participant Client
    participant Leader
    participant Follower1
    participant Follower2

    Client->>Leader: æäº¤è¯·æ±‚
    Leader->>Leader: è¿½åŠ æ—¥å¿—
    Leader->>Follower1: AppendEntries
    Leader->>Follower2: AppendEntries
    Follower1->>Leader: ACK
    Follower2->>Leader: ACK
    Leader->>Leader: æäº¤(å¤šæ•°æ´¾ç¡®è®¤)
    Leader->>Client: è¿”å›æˆåŠŸ
    Leader->>Follower1: é€šçŸ¥æäº¤
    Leader->>Follower2: é€šçŸ¥æäº¤
```

---

---

## å…­ã€å®Œæ•´å®ç°ä»£ç 

### 6.1 äº‹åŠ¡æ‰§è¡Œæµç¨‹å®ç°

```python
class TransactionExecutor:
    """äº‹åŠ¡æ‰§è¡Œå™¨ï¼ˆå¯¹åº”æµç¨‹å›¾ï¼‰"""

    def execute_transaction(self, sql_statements):
        """
        æ‰§è¡Œäº‹åŠ¡çš„å®Œæ•´æµç¨‹
        å¯¹åº”"ä¸€ã€äº‹åŠ¡æ‰§è¡Œæµç¨‹"å›¾
        """
        conn = self.get_connection()

        try:
            # Step 1: BEGIN
            xid = self.begin_transaction(conn)
            snapshot = self.create_snapshot()

            # Step 2: æ‰§è¡ŒSQLè¯­å¥
            for stmt in sql_statements:
                if stmt.type == 'SELECT':
                    # å¯è§æ€§æ£€æŸ¥åˆ†æ”¯
                    result = self.execute_select(stmt, snapshot)
                else:
                    # ä¿®æ”¹æ“ä½œåˆ†æ”¯
                    lock_acquired = self.acquire_locks(stmt)
                    if not lock_acquired:
                        raise LockTimeout()

                    self.modify_data(stmt)
                    self.write_wal(stmt)

            # Step 3: COMMIT
            self.write_wal_commit_record(xid)
            self.fsync_wal()
            self.update_clog(xid, status='COMMITTED')
            self.release_locks()

            return {'status': 'committed', 'xid': xid}

        except Exception as e:
            # ROLLBACKåˆ†æ”¯
            self.rollback_transaction(xid)
            self.release_locks()
            return {'status': 'aborted', 'error': str(e)}
```

### 6.2 MVCCå¯è§æ€§æ£€æŸ¥å®ç°

```python
def check_tuple_visibility(tuple, snapshot):
    """
    å®Œæ•´å¯è§æ€§æ£€æŸ¥æµç¨‹
    å¯¹åº”"äºŒã€MVCCå¯è§æ€§æ£€æŸ¥æµç¨‹"å›¾
    """
    xmin = tuple.xmin
    xmax = tuple.xmax

    # Step 1: xminæœ‰æ•ˆ?
    if not xmin_valid(xmin):
        return False  # ä¸å¯è§

    # Step 2: xminå·²æäº¤?
    if not xmin_committed(xmin):
        return False  # ä¸å¯è§

    # Step 3: xmin < xmin_snap?
    if xmin >= snapshot.xmin:
        # Step 4: xmin in xip? (æ´»è·ƒäº‹åŠ¡åˆ—è¡¨)
        if xmin in snapshot.xip:
            return False  # åˆ›å»ºè€…æœªæäº¤

    # Step 5: xmaxæœ‰æ•ˆ?
    if not xmax_valid(xmax):
        return True  # å¯è§ï¼ˆæœªè¢«åˆ é™¤ï¼‰

    # Step 6: xmaxå·²æäº¤?
    if not xmax_committed(xmax):
        return True  # å¯è§ï¼ˆåˆ é™¤è€…æœªæäº¤ï¼‰

    # Step 7: xmax < xmax_snap?
    if xmax < snapshot.xmax:
        # Step 8: xmax in xip?
        if xmax in snapshot.xip:
            return True  # åˆ é™¤è€…æœªæäº¤
        else:
            return False  # åˆ é™¤è€…å·²æäº¤
    else:
        return True  # åˆ é™¤è€…åœ¨å¿«ç…§ä¹‹å
```

### 6.3 æ­»é”æ£€æµ‹æµç¨‹å®ç°

```rust
pub struct DeadlockDetector {
    wait_graph: HashMap<TransactionId, Vec<TransactionId>>,
    detection_interval: Duration,
}

impl DeadlockDetector {
    pub fn detect_deadlock(&mut self) -> Option<Vec<TransactionId>> {
        // Step 1: é”ç­‰å¾…è¶…æ—¶è§¦å‘
        if !self.should_check_deadlock() {
            return None;
        }

        // Step 2: æ„å»ºç­‰å¾…å›¾
        self.build_wait_graph();

        // Step 3: DFSæ£€æµ‹ç¯
        if let Some(cycle) = self.detect_cycle_dfs() {
            // Step 4: é€‰æ‹©å—å®³è€…
            let victim = self.select_victim(&cycle);

            // Step 5: ä¸­æ­¢äº‹åŠ¡
            self.abort_transaction(victim);

            // Step 6: é‡Šæ”¾é”
            self.release_locks(victim);

            // Step 7: å”¤é†’ç­‰å¾…è€…
            self.wake_up_waiters(victim);

            return Some(cycle);
        }

        // æ— ç¯: ç»§ç»­ç­‰å¾…
        None
    }
}
```

---

## ä¸ƒã€æµç¨‹å›¾ç”Ÿæˆå·¥å…·

### 7.1 Pythonæµç¨‹å›¾ç”Ÿæˆå™¨

```python
class FlowchartGenerator:
    """æµç¨‹å›¾è‡ªåŠ¨ç”Ÿæˆå·¥å…·"""

    def generate_from_code(self, function_ast):
        """ä»Pythonå‡½æ•°ASTç”Ÿæˆæµç¨‹å›¾"""
        import ast

        nodes = []
        edges = []

        def visit_node(node, parent_id=None):
            if isinstance(node, ast.If):
                # æ¡ä»¶èŠ‚ç‚¹
                cond_id = f"cond_{len(nodes)}"
                nodes.append({
                    'id': cond_id,
                    'type': 'decision',
                    'label': ast.unparse(node.test)
                })

                if parent_id:
                    edges.append((parent_id, cond_id))

                # éå†thenåˆ†æ”¯
                for stmt in node.body:
                    visit_node(stmt, cond_id + '_yes')

                # éå†elseåˆ†æ”¯
                for stmt in node.orelse:
                    visit_node(stmt, cond_id + '_no')

            elif isinstance(node, ast.Return):
                # ç»“æŸèŠ‚ç‚¹
                ret_id = f"ret_{len(nodes)}"
                nodes.append({
                    'id': ret_id,
                    'type': 'terminator',
                    'label': f"return {ast.unparse(node.value)}"
                })

                if parent_id:
                    edges.append((parent_id, ret_id))

            elif isinstance(node, ast.Assign):
                # å¤„ç†èŠ‚ç‚¹
                assign_id = f"assign_{len(nodes)}"
                nodes.append({
                    'id': assign_id,
                    'type': 'process',
                    'label': ast.unparse(node)
                })

                if parent_id:
                    edges.append((parent_id, assign_id))

        visit_node(function_ast)

        return self.render_mermaid(nodes, edges)

    def render_mermaid(self, nodes, edges):
        """æ¸²æŸ“ä¸ºMermaidè¯­æ³•"""
        lines = ['graph TD']

        for node in nodes:
            if node['type'] == 'decision':
                lines.append(f"    {node['id']}{{{node['label']}}}")
            elif node['type'] == 'terminator':
                lines.append(f"    {node['id']}[{node['label']}]")
            else:
                lines.append(f"    {node['id']}[{node['label']}]")

        for src, dst in edges:
            lines.append(f"    {src} --> {dst}")

        return '\n'.join(lines)

# ä½¿ç”¨ç¤ºä¾‹
code = """
def transfer(from_id, to_id, amount):
    if check_balance(from_id, amount):
        deduct(from_id, amount)
        add(to_id, amount)
        return True
    else:
        return False
"""

generator = FlowchartGenerator()
tree = ast.parse(code)
mermaid = generator.generate_from_code(tree.body[0])
print(mermaid)
```

---

## å…«ã€å®é™…åº”ç”¨æ¡ˆä¾‹

### æ¡ˆä¾‹1: è°ƒè¯•äº‹åŠ¡å¼‚å¸¸

**é—®é¢˜**: äº‹åŠ¡å¶å°”å¤±è´¥ï¼Œä¸çŸ¥åŸå› 

**ä½¿ç”¨æµç¨‹å›¾æ’æŸ¥**:

```text
å‚è€ƒ"ä¸€ã€äº‹åŠ¡æ‰§è¡Œæµç¨‹"å›¾:

BEGIN â†’ æˆåŠŸ âœ“
æ‰§è¡ŒSQL1 â†’ æˆåŠŸ âœ“
æ‰§è¡ŒSQL2 â†’ æˆåŠŸ âœ“
æ‰§è¡ŒSQL3 â†’ å¤±è´¥ âœ—

å®šä½åˆ°"è·å–é”"æ­¥éª¤:
â†’ æŸ¥çœ‹æ˜¯å¦æœ‰é”ç­‰å¾…
â†’ SELECT * FROM pg_locks WHERE NOT granted

å‘ç°: é•¿äº‹åŠ¡æŒé”
â†’ ä¼˜åŒ–: ç¼©çŸ­äº‹åŠ¡æ—¶é—´
```

### æ¡ˆä¾‹2: ä¼˜åŒ–VACUUM

**ä½¿ç”¨"ä¸‰ã€VACUUMæ‰§è¡Œæµç¨‹"**:

```text
å‘ç°: VACUUMè€—æ—¶4å°æ—¶ï¼ˆå¤ªæ…¢ï¼ï¼‰

åˆ†ææµç¨‹å›¾:
â”œâ”€ æ‰«æå †è¡¨ç¬¬ä¸€é â†’ 1.5å°æ—¶
â”œâ”€ æ¸…ç†ç´¢å¼• â†’ 2å°æ—¶ âš ï¸ ç“¶é¢ˆï¼
â””â”€ æ‰«æå †è¡¨ç¬¬äºŒé â†’ 0.5å°æ—¶

ä¼˜åŒ–æ–¹å‘: å‡å°‘ç´¢å¼•æ•°é‡
â”œâ”€ DROPæœªä½¿ç”¨ç´¢å¼•
â”œâ”€ åˆå¹¶é‡å¤ç´¢å¼•
â””â”€ æ•ˆæœ: VACUUM 4å°æ—¶ â†’ 45åˆ†é’Ÿ (-81%)
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: å®Œæ•´ä»£ç å®ç°ã€ç”Ÿæˆå·¥å…·ã€å®é™…æ¡ˆä¾‹

**å·¥å…·**: æµç¨‹å›¾ç”Ÿæˆå™¨ï¼ˆä»ä»£ç è‡ªåŠ¨ç”Ÿæˆï¼‰
**GitHub**: <https://github.com/db-theory/flowchart-tools>

**å…³è”æ–‡æ¡£**:

- `07-å¯è§†åŒ–ä¸æ€ç»´æ¨¡å‹/01-æ ¸å¿ƒæ€ç»´å¯¼å›¾é›†.md`
- `07-å¯è§†åŒ–ä¸æ€ç»´æ¨¡å‹/03-å†³ç­–æ ‘å›¾é›†.md`
- `05-å®ç°æœºåˆ¶/01-PostgreSQL-MVCCå®ç°.md` (æºç åˆ†æ)
