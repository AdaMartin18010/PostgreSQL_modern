# 01 | 核心思维导图集

> **可视化工具**: 本文档汇总理论体系的核心思维导图，帮助建立系统化的知识结构。

---

## 📑 目录

- [01 | 核心思维导图集](#01--核心思维导图集)
  - [📑 目录](#-目录)
  - [一、总览思维导图](#一总览思维导图)
    - [1.1 理论体系全景](#11-理论体系全景)
  - [二、分层状态演化模型 (LSEM)](#二分层状态演化模型-lsem)
    - [2.1 三层架构思维导图](#21-三层架构思维导图)
  - [三、MVCC理论思维导图](#三mvcc理论思维导图)
    - [3.1 MVCC核心机制](#31-mvcc核心机制)
  - [四、ACID与隔离级别思维导图](#四acid与隔离级别思维导图)
    - [4.1 ACID实现机制](#41-acid实现机制)
  - [五、CAP理论思维导图](#五cap理论思维导图)
    - [5.1 CAP权衡空间](#51-cap权衡空间)
  - [六、Rust并发思维导图](#六rust并发思维导图)
    - [6.1 所有权与借用系统](#61-所有权与借用系统)
  - [七、使用指南](#七使用指南)
    - [7.1 如何阅读思维导图](#71-如何阅读思维导图)
    - [7.2 学习建议](#72-学习建议)

---

## 一、总览思维导图

### 1.1 理论体系全景

```text
事务与并发设计理论体系 (TCDT)
├─ 基础理论层
│  ├─ 三大公理
│  │  ├─ 公理1: 状态原子性
│  │  ├─ 公理2: 可见性偏序
│  │  └─ 公理3: 冲突可串行化
│  │
│  ├─ 形式化定义
│  │  ├─ 状态空间 S
│  │  ├─ 时空戳系统 T
│  │  ├─ 可见性谓词 Visible
│  │  └─ 冲突检测 Conflict
│  │
│  └─ 数学证明
│     ├─ MVCC正确性
│     ├─ 串行化证明
│     └─ 所有权安全性
│
├─ 设计空间层
│  ├─ 并发控制模型
│  │  ├─ 乐观并发 (MVCC)
│  │  ├─ 悲观并发 (锁)
│  │  └─ 编译期检查 (所有权)
│  │
│  ├─ 隔离级别设计
│  │  ├─ Read Committed
│  │  ├─ Repeatable Read
│  │  └─ Serializable
│  │
│  ├─ CAP权衡决策
│  │  ├─ CP系统 (一致性+分区容错)
│  │  ├─ AP系统 (可用性+分区容错)
│  │  └─ CA系统 (一致性+可用性)
│  │
│  ├─ 性能优化策略
│  │  ├─ 读优化 (MVCC无锁读)
│  │  ├─ 写优化 (批量提交)
│  │  └─ 空间优化 (VACUUM)
│  │
│  └─ 容错机制设计
│     ├─ WAL日志
│     ├─ Checkpoint
│     └─ 共识协议
│
└─ 实现验证层
   ├─ PostgreSQL实现
   │  ├─ MVCC机制
   │  ├─ 锁管理
   │  └─ VACUUM
   │
   ├─ Rust所有权
   │  ├─ 借用检查
   │  ├─ 生命周期
   │  └─ 并发原语
   │
   └─ 分布式共识
      ├─ Raft协议
      ├─ 2PC事务
      └─ HLC时钟
```

---

## 二、分层状态演化模型 (LSEM)

### 2.1 三层架构思维导图

```text
LSEM: Layered State Evolution Model
│
├─ L0: 存储引擎层 (PostgreSQL)
│  │
│  ├─ 状态表示
│  │  ├─ 元组版本链
│  │  │  ├─ xmin (创建事务ID)
│  │  │  ├─ xmax (删除事务ID)
│  │  │  ├─ cid (命令ID)
│  │  │  └─ ctid (物理位置)
│  │  │
│  │  └─ 事务状态 (pg_clog)
│  │     ├─ 00: 运行中
│  │     ├─ 01: 已提交
│  │     └─ 02: 已回滚
│  │
│  ├─ 时空戳
│  │  ├─ TransactionId (全序)
│  │  └─ CommitLSN (日志序列号)
│  │
│  ├─ 可见性规则
│  │  ├─ 规则1: 本事务创建 → 可见
│  │  ├─ 规则2: 创建未提交 → 不可见
│  │  ├─ 规则3: 创建在快照后 → 不可见
│  │  ├─ 规则4: 创建在活跃列表 → 不可见
│  │  └─ 规则5: 检查删除标记xmax
│  │
│  ├─ 冲突解决
│  │  ├─ 行级锁 (FOR UPDATE/SHARE)
│  │  ├─ 死锁检测 (等待图)
│  │  └─ SSI检测 (谓词锁)
│  │
│  └─ 设计模式
│     └─ 多版本时间旅行 (MVTT)
│        ├─ 写时复制 (Copy-on-Write)
│        ├─ 读无锁 (Lock-free Read)
│        └─ 延迟清理 (VACUUM)
│
├─ L1: 运行时层 (Rust)
│  │
│  ├─ 状态表示
│  │  ├─ 堆内存 (Box<T>, Arc<T>)
│  │  └─ 栈内存 (局部变量)
│  │
│  ├─ 时空戳
│  │  ├─ 生命周期标记 'a
│  │  └─ 内存排序 (Ordering)
│  │     ├─ Relaxed (无同步)
│  │     ├─ Release/Acquire (建立hb)
│  │     └─ SeqCst (全序)
│  │
│  ├─ 可见性规则
│  │  ├─ 借用检查器规则
│  │  │  ├─ 唯一可变引用 (&mut T)
│  │  │  ├─ 共享不可变引用 (&T)
│  │  │  └─ 不可同时存在
│  │  │
│  │  └─ happens-before关系
│  │     ├─ 传递性
│  │     ├─ 非自反性
│  │     └─ 反对称性
│  │
│  ├─ 冲突解决
│  │  ├─ 编译期拒绝 (借用冲突)
│  │  ├─ 运行时锁 (Mutex/RwLock)
│  │  └─ 原子操作 (Atomic)
│  │
│  └─ 设计模式
│     └─ 所有权时序隔离 (OTI)
│        ├─ 所有权转移 (move)
│        ├─ 借用隔离 (borrow)
│        └─ 生命周期证明 (lifetime)
│
└─ L2: 分布式层 (共识协议)
   │
   ├─ 状态表示
   │  ├─ 复制日志 (Raft Log)
   │  └─ 状态机 (Key-Value Store)
   │
   ├─ 时空戳
   │  ├─ 混合逻辑时钟 (HLC)
   │  │  ├─ 物理时间 pt
   │  │  └─ 逻辑计数 lc
   │  │
   │  └─ 向量时钟 (Vector Clock)
   │
   ├─ 可见性规则
   │  ├─ 提交索引 (commitIndex)
   │  │  ├─ index ≤ commitIndex → 可见
   │  │  └─ index > commitIndex → 不可见
   │  │
   │  └─ 一致性级别
   │     ├─ Linearizable (强一致)
   │     ├─ Causal (因果一致)
   │     └─ Eventual (最终一致)
   │
   ├─ 冲突解决
   │  ├─ Raft共识投票
   │  ├─ 2PC两阶段提交
   │  └─ CRDT无冲突合并
   │
   └─ 设计模式
      └─ 时空共识日志 (SCL)
         ├─ Leader选举
         ├─ 日志复制
         └─ 安全性保证
```

---

## 三、MVCC理论思维导图

### 3.1 MVCC核心机制

```text
MVCC: Multi-Version Concurrency Control
│
├─ 核心原理
│  ├─ 版本链机制
│  │  ├─ 每次UPDATE创建新版本
│  │  ├─ 旧版本标记xmax
│  │  └─ 新版本写入xmin
│  │
│  ├─ 快照隔离
│  │  ├─ 事务启动时获取快照
│  │  │  ├─ xmin: 最小活跃事务ID
│  │  │  ├─ xmax: 最大已提交ID+1
│  │  │  └─ xip: 活跃事务列表
│  │  │
│  │  └─ 基于快照判断可见性
│  │
│  └─ 读写分离
│     ├─ 读操作: 访问历史版本 (无锁)
│     └─ 写操作: 创建新版本 (加锁)
│
├─ 操作语义
│  ├─ INSERT
│  │  ├─ 创建新元组
│  │  ├─ xmin = 当前事务ID
│  │  └─ xmax = 0
│  │
│  ├─ DELETE
│  │  ├─ 标记xmax = 当前事务ID
│  │  ├─ 元组仍保留 (死元组)
│  │  └─ 延迟物理删除 (VACUUM)
│  │
│  └─ UPDATE
│     ├─ 旧元组: xmax = 当前事务ID
│     ├─ 新元组: xmin = 当前事务ID
│     └─ HOT优化 (页内链接)
│
├─ 可见性判断
│  ├─ 创建事务检查
│  │  ├─ 已提交? (查pg_clog)
│  │  ├─ 在快照前? (xmin < xmax)
│  │  └─ 不在活跃列表? (xmin ∉ xip)
│  │
│  └─ 删除事务检查
│     ├─ 未设置? (xmax = 0)
│     ├─ 未提交? (查pg_clog)
│     └─ 在快照后? (xmax >= xmin)
│
├─ 锁机制
│  ├─ 行级锁类型
│  │  ├─ FOR UPDATE (排他锁)
│  │  ├─ FOR SHARE (共享锁)
│  │  ├─ FOR NO KEY UPDATE
│  │  └─ FOR KEY SHARE
│  │
│  ├─ 锁冲突矩阵
│  │  ├─ UPDATE vs UPDATE → 阻塞
│  │  ├─ UPDATE vs SHARE → 阻塞
│  │  └─ SHARE vs SHARE → 允许
│  │
│  └─ 死锁检测
│     ├─ 等待图构建
│     ├─ 环检测算法
│     └─ 牺牲事务回滚
│
├─ VACUUM机制
│  ├─ 触发条件
│  │  ├─ 死元组数超过阈值
│  │  ├─ 事务ID接近回卷
│  │  └─ 手动执行VACUUM
│  │
│  ├─ 清理过程
│  │  ├─ 计算oldestXmin
│  │  ├─ 标记死元组为可用空间
│  │  ├─ 清理索引指针
│  │  └─ 更新FSM (空闲空间映射)
│  │
│  └─ Freeze操作
│     ├─ 将旧元组xmin设为冻结ID
│     ├─ 防止事务ID回卷
│     └─ 使元组永久可见
│
└─ 优化技术
   ├─ HOT (Heap-Only Tuple)
   │  ├─ 条件: 未更新索引列
   │  ├─ 效果: 不插入新索引项
   │  └─ 优势: 减少索引写放大
   │
   ├─ Index-Only Scan
   │  ├─ 仅扫描索引不访问表
   │  ├─ 需要Visibility Map
   │  └─ 适用于覆盖索引
   │
   └─ Parallel VACUUM
      ├─ 多工作进程并行清理
      ├─ 减少锁持有时间
      └─ 提升清理效率
```

---

## 四、ACID与隔离级别思维导图

### 4.1 ACID实现机制

```text
ACID特性
│
├─ A: 原子性 (Atomicity)
│  ├─ WAL预写日志
│  │  ├─ 修改前先写日志
│  │  ├─ 日志包含Redo信息
│  │  └─ 崩溃后重放日志
│  │
│  ├─ 事务状态管理
│  │  ├─ BEGIN: 分配事务ID
│  │  ├─ COMMIT: 标记pg_clog
│  │  └─ ROLLBACK: 忽略修改
│  │
│  └─ 全或无保证
│     ├─ 成功: 所有修改生效
│     └─ 失败: 所有修改回滚
│
├─ C: 一致性 (Consistency)
│  ├─ 约束检查
│  │  ├─ 主键约束 (PRIMARY KEY)
│  │  ├─ 唯一约束 (UNIQUE)
│  │  ├─ 外键约束 (FOREIGN KEY)
│  │  ├─ 检查约束 (CHECK)
│  │  └─ 非空约束 (NOT NULL)
│  │
│  ├─ 触发器执行
│  │  ├─ BEFORE触发器 (验证)
│  │  └─ AFTER触发器 (级联)
│  │
│  └─ 规则系统
│     └─ 自定义业务规则
│
├─ I: 隔离性 (Isolation)
│  ├─ 隔离级别
│  │  ├─ Read Uncommitted (不支持)
│  │  ├─ Read Committed (默认)
│  │  │  ├─ 语句级快照
│  │  │  ├─ 允许不可重复读
│  │  │  └─ 允许幻读
│  │  │
│  │  ├─ Repeatable Read
│  │  │  ├─ 事务级快照
│  │  │  ├─ 防止不可重复读
│  │  │  └─ 防止幻读 (PostgreSQL扩展)
│  │  │
│  │  └─ Serializable
│  │     ├─ SSI检测
│  │     ├─ 谓词锁
│  │     └─ 主动中止冲突事务
│  │
│  ├─ 异常现象
│  │  ├─ 脏读 (Dirty Read)
│  │  │  └─ 读到未提交数据
│  │  ├─ 不可重复读 (Non-repeatable Read)
│  │  │  └─ 同一查询返回不同结果
│  │  ├─ 幻读 (Phantom Read)
│  │  │  └─ 范围查询出现新行
│  │  └─ 串行化异常
│  │     └─ 无法等价于串行执行
│  │
│  └─ 实现机制
│     ├─ MVCC快照隔离
│     ├─ 锁机制 (读写冲突)
│     └─ SSI检测 (串行化)
│
└─ D: 持久性 (Durability)
   ├─ WAL持久化
   │  ├─ fsync刷盘
   │  ├─ synchronous_commit配置
   │  └─ wal_level设置
   │
   ├─ Checkpoint机制
   │  ├─ 定期将脏页刷盘
   │  ├─ 记录checkpoint位置
   │  └─ 缩短恢复时间
   │
   └─ 恢复机制
      ├─ Crash Recovery
      │  ├─ 从最近checkpoint开始
      │  ├─ 重放WAL日志
      │  └─ 恢复到一致点
      │
      └─ PITR (Point-in-Time Recovery)
         ├─ 归档WAL日志
         ├─ 恢复到指定时间点
         └─ 用于灾难恢复
```

---

## 五、CAP理论思维导图

### 5.1 CAP权衡空间

```text
CAP理论
│
├─ 三大特性
│  ├─ C: 一致性 (Consistency)
│  │  ├─ 定义: 所有节点同时看到相同数据
│  │  ├─ 强一致性
│  │  │  ├─ Linearizability (线性一致)
│  │  │  └─ Sequential Consistency (顺序一致)
│  │  │
│  │  └─ 弱一致性
│  │     ├─ Causal (因果一致)
│  │     ├─ Eventual (最终一致)
│  │     └─ Weak (弱一致)
│  │
│  ├─ A: 可用性 (Availability)
│  │  ├─ 定义: 每个请求都能得到响应
│  │  ├─ 可用性指标
│  │  │  ├─ 99.9% (3个9)
│  │  │  ├─ 99.99% (4个9)
│  │  │  └─ 99.999% (5个9)
│  │  │
│  │  └─ 影响因素
│  │     ├─ 节点故障
│  │     ├─ 网络延迟
│  │     └─ 负载压力
│  │
│  └─ P: 分区容错性 (Partition Tolerance)
│     ├─ 定义: 网络分区时系统继续运行
│     ├─ 网络分区场景
│     │  ├─ 机房断网
│     │  ├─ 交换机故障
│     │  └─ 网络拥塞
│     │
│     └─ 容错策略
│        ├─ 多副本
│        ├─ 共识协议
│        └─ 故障检测
│
├─ CAP不可能三角
│  ├─ CP系统 (一致性+分区容错)
│  │  ├─ 特点: 牺牲可用性
│  │  ├─ 适用场景
│  │  │  ├─ 金融系统
│  │  │  ├─ 库存管理
│  │  │  └─ 配置中心
│  │  │
│  │  └─ 典型实现
│  │     ├─ PostgreSQL同步复制
│  │     ├─ etcd (Raft)
│  │     ├─ ZooKeeper (Zab)
│  │     └─ TiDB
│  │
│  ├─ AP系统 (可用性+分区容错)
│  │  ├─ 特点: 最终一致性
│  │  ├─ 适用场景
│  │  │  ├─ 社交网络 (点赞、评论)
│  │  │  ├─ 日志收集
│  │  │  └─ 监控系统
│  │  │
│  │  └─ 典型实现
│  │     ├─ Cassandra
│  │     ├─ DynamoDB
│  │     ├─ Riak
│  │     └─ CouchDB
│  │
│  └─ CA系统 (一致性+可用性)
│     ├─ 特点: 不容忍分区
│     ├─ 适用场景
│     │  ├─ 单数据中心
│     │  ├─ 局域网环境
│     │  └─ 无分区风险
│     │
│     └─ 典型实现
│        ├─ PostgreSQL单机
│        ├─ MySQL单机
│        └─ Redis单机
│
├─ PACELC扩展
│  ├─ PA/EL: 分区时选A,其他时选L(低延迟)
│  │  └─ 示例: DynamoDB
│  │
│  ├─ PA/EC: 分区时选A,其他时选C(一致性)
│  │  └─ 示例: Cassandra (可调)
│  │
│  ├─ PC/EL: 分区时选C,其他时选L(低延迟)
│  │  └─ 示例: MongoDB
│  │
│  └─ PC/EC: 分区时选C,其他时选C(一致性)
│     └─ 示例: etcd, ZooKeeper
│
└─ PostgreSQL的CAP定位
   ├─ 单机模式: CA系统
   │  ├─ 强一致性 (ACID)
   │  ├─ 高可用 (无网络分区)
   │  └─ 不容忍分区
   │
   ├─ 同步流复制: CP系统
   │  ├─ 强一致性 (多数派确认)
   │  ├─ 可用性降低 (等待复制)
   │  └─ 容忍分区 (主从切换)
   │
   └─ 异步流复制: AP系统
      ├─ 最终一致性 (异步延迟)
      ├─ 高可用 (不等待复制)
      └─ 容忍分区 (允许数据延迟)
```

---

## 六、Rust并发思维导图

### 6.1 所有权与借用系统

```text
Rust并发安全
│
├─ 所有权系统 (Ownership)
│  ├─ 三大规则
│  │  ├─ 规则1: 每个值有唯一所有者
│  │  ├─ 规则2: 所有权可转移 (move)
│  │  └─ 规则3: 所有者离开作用域时释放
│  │
│  ├─ 所有权转移
│  │  ├─ 函数传参 (move)
│  │  ├─ 函数返回值
│  │  └─ 线程spawn (move ||)
│  │
│  └─ 编译期保证
│     ├─ 无悬垂指针
│     ├─ 无二次释放
│     └─ 无use-after-free
│
├─ 借用系统 (Borrowing)
│  ├─ 不可变借用 (&T)
│  │  ├─ 可多个并存
│  │  ├─ 只读访问
│  │  └─ 生命周期受限
│  │
│  ├─ 可变借用 (&mut T)
│  │  ├─ 唯一性保证
│  │  ├─ 读写访问
│  │  └─ 与不可变借用互斥
│  │
│  └─ 借用检查规则
│     ├─ 规则1: 同时只能有一个&mut T
│     ├─ 规则2: &mut T 与 &T 不能共存
│     └─ 规则3: 借用不能超出所有者生命周期
│
├─ 生命周期系统 (Lifetime)
│  ├─ 生命周期标记 'a
│  │  ├─ 显式标注: fn foo<'a>(x: &'a i32)
│  │  ├─ 隐式推导: 编译器自动推断
│  │  └─ 静态生命周期: 'static
│  │
│  ├─ 生命周期规则
│  │  ├─ 输入生命周期
│  │  ├─ 输出生命周期
│  │  └─ 生命周期子类型 ('a: 'b)
│  │
│  └─ 编译期检查
│     ├─ 防止悬垂引用
│     ├─ 保证引用有效性
│     └─ 零运行时开销
│
├─ 并发原语
│  ├─ Send trait
│  │  ├─ 定义: 可跨线程转移所有权
│  │  ├─ 自动实现: 大多数类型
│  │  └─ 不实现: Rc<T>, 裸指针
│  │
│  ├─ Sync trait
│  │  ├─ 定义: 可跨线程共享引用
│  │  ├─ 条件: &T可以Send
│  │  └─ 不实现: Cell<T>, RefCell<T>
│  │
│  ├─ Mutex<T>
│  │  ├─ 互斥锁
│  │  ├─ lock()获取锁
│  │  └─ RAII自动解锁
│  │
│  ├─ RwLock<T>
│  │  ├─ 读写锁
│  │  ├─ read()共享读
│  │  └─ write()独占写
│  │
│  ├─ Arc<T>
│  │  ├─ 原子引用计数
│  │  ├─ 跨线程共享
│  │  └─ 线程安全的Rc<T>
│  │
│  └─ Atomic类型
│     ├─ AtomicUsize, AtomicI64, ...
│     ├─ 无锁编程
│     └─ 内存排序控制
│
└─ 内存排序 (Ordering)
   ├─ Relaxed
   │  ├─ 无同步保证
   │  ├─ 仅保证原子性
   │  └─ 最高性能
   │
   ├─ Release/Acquire
   │  ├─ 建立happens-before
   │  ├─ Release: 写操作可见
   │  └─ Acquire: 读取最新值
   │
   ├─ AcqRel
   │  ├─ 读写操作均同步
   │  └─ 用于Compare-and-Swap
   │
   └─ SeqCst
      ├─ 全局顺序一致性
      ├─ 最强保证
      └─ 性能开销最大
```

---

## 七、使用指南

### 7.1 如何阅读思维导图

**步骤1**: 从顶层开始，理解整体结构
**步骤2**: 逐层展开，关注分支关系
**步骤3**: 识别同级节点的对比和关联
**步骤4**: 结合形式化定义加深理解

### 7.2 学习建议

1. **打印或导出**: 将思维导图打印或导出为图片，便于随时查看
2. **补充笔记**: 在关键节点添加自己的理解和案例
3. **对照源码**: 结合PostgreSQL/Rust源码验证理论
4. **绘制自己的导图**: 尝试不看原图重新绘制，检验掌握程度

---

**版本**: 1.0.0
**最后更新**: 2025-12-05
**工具推荐**:

- Mermaid (嵌入Markdown)
- XMind (专业思维导图)
- draw.io (流程图)
- Graphviz (自动布局)

**相关文档**:

- [理论体系全景图](../00-理论框架总览/00-理论体系全景图.md)
- [概念关系图集](./02-概念关系图集.md)
- [决策树图集](./03-决策树图集.md)
