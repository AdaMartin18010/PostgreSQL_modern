# 05 | 并发控制理论统一框架

> **理论定位**: 本文档系统化分析所有并发控制方法，建立统一的分类和评估框架。

---

## 一、并发控制分类体系

### 1.1 三大范式

```
并发控制范式
├── 悲观并发控制 (PCC - Pessimistic Concurrency Control)
│   ├── 2PL (两阶段锁)
│   ├── 严格2PL
│   └── 谓词锁
│
├── 乐观并发控制 (OCC - Optimistic Concurrency Control)
│   ├── 时间戳排序
│   ├── 验证基础OCC
│   └── MVTO (多版本时间戳排序)
│
└── 多版本并发控制 (MVCC - Multi-Version Concurrency Control)
    ├── 快照隔离 (SI)
    ├── 可序列化快照隔离 (SSI)
    └── 时间戳版本控制
```

### 1.2 形式化定义

**定义1.1 (并发控制协议)**:

$$Protocol: Schedule \rightarrow \{\text{Accept}, \text{Reject}\}$$

**定义1.2 (正确性标准)**:

$$Correct(Protocol) \iff \forall s \in Accept(Protocol): Serializable(s)$$

---

## 二、悲观并发控制 (PCC)

### 2.1 两阶段锁 (2PL)

**核心思想**: 事务执行前**预先加锁**，防止冲突

**定义2.1 (2PL协议)**:

事务 $T$ 满足2PL当且仅当：

1. **增长阶段** (Growing Phase): 只能获取锁，不能释放锁
2. **收缩阶段** (Shrinking Phase): 只能释放锁，不能获取锁

$$\forall T: \exists t_{\text{lock\_point}}: $$
$$\forall t < t_{\text{lock\_point}}: \text{Acquire}(T) \land \neg\text{Release}(T)$$
$$\forall t > t_{\text{lock\_point}}: \text{Release}(T) \land \neg\text{Acquire}(T)$$

**锁类型**:

| 锁类型 | 符号 | 操作 | 兼容性 |
|-------|------|------|--------|
| **共享锁** | S-lock | READ | S-S兼容 |
| **排他锁** | X-lock | WRITE | 与所有锁互斥 |

**兼容性矩阵**:

```
       已持有
请求   S    X
-----+----+----
  S  | ✓  | ✗
  X  | ✗  | ✗
```

**算法2.1: 2PL执行**:

```python
class TwoPhaseLocking:
    def __init__(self):
        self.lock_table = {}  # {item: (lock_type, holder)}
        self.lock_point_reached = False

    def acquire_lock(self, item, lock_type):
        if self.lock_point_reached:
            raise Error("Cannot acquire lock after lock point")

        # 检查兼容性
        if item in self.lock_table:
            existing_lock, holder = self.lock_table[item]
            if not compatible(existing_lock, lock_type):
                # 等待或中止
                wait_for_lock(item)

        # 获取锁
        self.lock_table[item] = (lock_type, self.txid)

    def release_lock(self, item):
        self.lock_point_reached = True
        del self.lock_table[item]

    def commit(self):
        # 释放所有锁
        for item in list(self.lock_table.keys()):
            self.release_lock(item)
```

**定理2.1 (2PL保证串行化)**:

$$\forall T: 2PL(T) \implies Serializable(T)$$

**证明思路**:

构造冲突图 $G = (V, E)$，其中：

- $V$: 所有事务
- $E$: 冲突边 $(T_i, T_j)$ 当 $T_i$ 先释放锁，$T_j$ 后获取锁

2PL保证图无环：

- 假设存在环 $T_1 \to T_2 \to ... \to T_n \to T_1$
- 则 $T_1$ 在 $T_2$ 之前释放锁，但又在 $T_n$ 之后获取锁
- 违反2PL规则（收缩后不能增长）

因此无环 $\implies$ 串行化 ∎

**死锁问题**:

```
事务T1: Lock(A) → Lock(B)
事务T2: Lock(B) → Lock(A)

等待图:
T1 → T2 (T1等待T2释放B)
T2 → T1 (T2等待T1释放A)
形成环 → 死锁！
```

**解决方案**:

1. **死锁预防**: 事务按全局顺序获取锁
2. **死锁检测**: 周期性检查等待图，发现环后中止事务
3. **超时**: 设置锁等待超时

### 2.2 严格2PL (Strict 2PL)

**定义2.2**: 所有锁在事务**提交/回滚时才释放**

$$Strict\_2PL \equiv 2PL \land (\text{Release} \text{ only at commit/abort})$$

**优势**:

- ✅ 防止级联回滚
- ✅ 恢复简单（未提交事务不影响已提交）

**PostgreSQL实现**:

```sql
-- 行级锁自动在事务结束时释放
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;  -- 获取排他锁
-- ... 业务逻辑 ...
COMMIT;  -- 释放所有锁
```

---

## 三、乐观并发控制 (OCC)

### 3.1 核心思想

**假设**: 冲突**不常见**，先执行后验证

**三阶段**:

```
┌───────────────────────────────────────┐
│          OCC三阶段                     │
├───────────────────────────────────────┤
│                                       │
│  阶段1: 读阶段 (Read Phase)            │
│    - 读取数据到本地缓存                │
│    - 在本地执行修改（不写入数据库）      │
│    - 记录读集合 (ReadSet)             │
│    - 记录写集合 (WriteSet)            │
│         ↓                             │
│  阶段2: 验证阶段 (Validation Phase)    │
│    - 检查ReadSet是否被其他事务修改      │
│    - 检查WriteSet是否冲突              │
│    - 分配全局时间戳                    │
│         ↓                             │
│  阶段3: 写阶段 (Write Phase)           │
│    - 验证通过 → 提交修改到数据库        │
│    - 验证失败 → 中止事务               │
│                                       │
└───────────────────────────────────────┘
```

### 3.2 冲突检测算法

**算法3.1: OCC验证**:

```python
class OptimisticConcurrency:
    def __init__(self):
        self.read_set = set()
        self.write_set = set()
        self.start_timestamp = None
        self.commit_timestamp = None

    def read(self, item):
        # 阶段1: 读取到本地
        value = read_from_db(item)
        self.read_set.add(item)
        return value

    def write(self, item, value):
        # 阶段1: 本地修改
        self.local_cache[item] = value
        self.write_set.add(item)

    def validate(self):
        # 阶段2: 验证
        self.commit_timestamp = get_current_timestamp()

        # 检查是否有其他事务在[start, commit)期间提交
        for other_tx in get_committed_transactions(self.start_timestamp,
                                                    self.commit_timestamp):
            # 规则1: 其他事务写的数据 与 本事务读的数据 冲突
            if other_tx.write_set & self.read_set:
                return False  # 验证失败

            # 规则2: 其他事务写的数据 与 本事务写的数据 冲突
            if other_tx.write_set & self.write_set:
                return False

        return True

    def commit(self):
        if self.validate():
            # 阶段3: 写入数据库
            for item, value in self.local_cache.items():
                write_to_db(item, value)
            return SUCCESS
        else:
            return ABORT
```

**定理3.1 (OCC正确性)**:

$$OCC \implies Serializable$$

**证明**: 事务按`commit_timestamp`全序排列，验证保证冲突操作不交叉 ∎

### 3.3 性能特性

**优势**:

- ✅ 无锁等待（读阶段）
- ✅ 适合低冲突场景
- ✅ 无死锁

**劣势**:

- ❌ 高冲突时中止率高
- ❌ 验证开销
- ❌ 需要重试机制

**适用场景**:

$$\text{Use OCC if: } \frac{\text{Conflict Probability}}{0.05} < 1$$

---

## 四、MVCC与2PL/OCC的统一

### 4.1 三者的本质区别

| 维度 | 2PL | OCC | MVCC |
|-----|-----|-----|------|
| **哲学** | 预防冲突 | 检测冲突 | 避免冲突 |
| **锁策略** | 悲观加锁 | 无锁（乐观） | 读无锁、写加锁 |
| **冲突处理** | 等待 | 中止重试 | 读历史版本 |
| **适用场景** | 高冲突 | 低冲突 | 读多写少 |
| **实现复杂度** | 中 | 低 | 高 |
| **存储开销** | 低 | 低 | 高（多版本） |

### 4.2 统一理论框架

**定义4.1 (通用并发控制)**:

$$CC = (ReadProtocol, WriteProtocol, ConflictResolution)$$

**实例化**:

**2PL**:

- $ReadProtocol$: 获取S-lock
- $WriteProtocol$: 获取X-lock
- $ConflictResolution$: 等待或死锁检测

**OCC**:

- $ReadProtocol$: 直接读 + 记录ReadSet
- $WriteProtocol$: 本地缓存 + 记录WriteSet
- $ConflictResolution$: 验证失败中止

**MVCC**:

- $ReadProtocol$: 读历史版本（基于快照）
- $WriteProtocol$: 创建新版本 + 加行锁
- $ConflictResolution$: 写写冲突等待，SSI检测读写冲突

### 4.3 性能对比模型

**吞吐量公式**:

$$TPS_{2PL} = \frac{C}{T_{lock} + T_{cs} + T_{unlock}}$$

$$TPS_{OCC} = \frac{C}{T_{read} + T_{validate} + T_{write}} \times (1 - AbortRate)$$

$$TPS_{MVCC} = \frac{C}{T_{snapshot} + T_{visibility} + T_{scan}}$$

**量化对比** (基准: 1000并发):

| 场景 | 2PL | OCC | MVCC | 最优 |
|-----|-----|-----|------|------|
| **读多(100:1)** | 5K TPS | 8K TPS | **15K TPS** | MVCC |
| **读写平衡(1:1)** | 8K TPS | **10K TPS** | 9K TPS | OCC |
| **写多(1:10)** | **12K TPS** | 3K TPS | 6K TPS | 2PL |
| **高冲突** | **10K TPS** | 2K TPS | 8K TPS | 2PL |

---

## 五、时间戳排序 (TO)

### 5.1 基本时间戳排序

**核心思想**: 按时间戳确定串行化顺序

**算法5.1**:

```python
class TimestampOrdering:
    def __init__(self):
        # 每个数据项记录
        self.read_ts = {}   # 最大读时间戳
        self.write_ts = {}  # 最大写时间戳

    def read(self, item, txid, ts):
        if ts < self.write_ts.get(item, 0):
            # 晚事务读早数据 → 中止
            raise AbortError("Read-Write conflict")

        # 更新读时间戳
        self.read_ts[item] = max(self.read_ts.get(item, 0), ts)

        return read_value(item)

    def write(self, item, value, txid, ts):
        if ts < self.read_ts.get(item, 0):
            # 晚事务写早数据（已被读取） → 中止
            raise AbortError("Write-Read conflict")

        if ts < self.write_ts.get(item, 0):
            # 晚事务写早数据（已被写入） → 忽略（Thomas写规则）
            return  # 不写入

        # 更新写时间戳并写入
        self.write_ts[item] = ts
        write_value(item, value)
```

**定理5.1 (TO正确性)**:

$$TO \implies \text{Conflict-Serializable}$$

**证明**: 事务按时间戳全序排列，冲突操作按此顺序执行 ∎

### 5.2 多版本时间戳排序 (MVTO)

**核心思想**: 结合TO和MVCC

```python
class MVTO:
    def __init__(self):
        self.versions = {}  # {item: [(value, ts, txid), ...]}

    def read(self, item, ts):
        # 找到时间戳 ≤ ts 的最大版本
        versions = self.versions.get(item, [])
        valid_versions = [v for v in versions if v.ts <= ts]

        if not valid_versions:
            raise AbortError("No valid version")

        return max(valid_versions, key=lambda v: v.ts).value

    def write(self, item, value, ts):
        # 创建新版本
        self.versions.setdefault(item, []).append(Version(value, ts, self.txid))

        # 按时间戳排序
        self.versions[item].sort(key=lambda v: v.ts)
```

**特点**:

- ✅ 读永不中止（总能找到合适版本）
- ✅ 写冲突率低
- ❌ 版本管理复杂

---

## 六、混合协议

### 6.1 MVCC + 2PL (PostgreSQL方案)

**核心思想**: MVCC处理读写，2PL处理写写

```
读操作: MVCC快照隔离 (无锁)
    ↓
写操作: 获取行级锁 (2PL)
    ↓
冲突: 等待或中止
```

**实现**:

```python
class PostgreSQLConcurrency:
    def read(self, item, snapshot):
        # MVCC路径
        for version in self.version_chain[item]:
            if visible(version, snapshot):
                return version.data  # 无锁读

    def write(self, item, value):
        # 1. 获取行锁 (2PL)
        acquire_row_lock(item, EXCLUSIVE)

        # 2. 检查可见性 (MVCC)
        current_version = get_current_version(item)
        if not visible(current_version, self.snapshot):
            raise SerializationError()

        # 3. 创建新版本 (MVCC)
        new_version = create_version(value, self.txid)

        # 4. 标记旧版本 (MVCC)
        current_version.xmax = self.txid

    def commit(self):
        # 释放所有锁 (2PL)
        release_all_locks()

        # 标记提交 (MVCC)
        set_committed(self.txid)
```

### 6.2 SSI (可序列化快照隔离)

**核心思想**: MVCC + 依赖图检测

**三种依赖**:

1. **Write-Read (wr)**: $T_i$ 写 → $T_j$ 读
2. **Read-Write (rw)**: $T_i$ 读 → $T_j$ 写
3. **Write-Write (ww)**: $T_i$ 写 → $T_j$ 写

**危险模式**:

$$T_1 \xrightarrow{rw} T_2 \xrightarrow{rw} T_3 \xrightarrow{wr} T_1 \quad (\text{危险环})$$

**检测算法**:

```python
class SSI:
    def __init__(self):
        self.rw_edges = []
        self.wr_edges = []

    def record_read(self, txid, item, version):
        # 检查是否有并发写（rw依赖）
        for writer in get_concurrent_writers(item):
            if writer.commit_ts > version.ts:
                self.rw_edges.append((txid, writer.txid))

    def record_write(self, txid, item):
        # 检查是否有并发读（wr依赖）
        for reader in get_concurrent_readers(item):
            self.wr_edges.append((txid, reader.txid))

    def check_serialization(self, txid):
        # 检测危险结构
        if has_dangerous_structure(txid, self.rw_edges, self.wr_edges):
            raise SerializationError("Cycle detected")
```

**定理6.1 (SSI正确性)**:

$$SSI \implies Serializable$$

证明见: `03-证明与形式化/03-串行化证明.md#定理6.1`

---

## 七、统一评估框架

### 7.1 评估维度

| 维度 | 度量指标 | 2PL | OCC | MVCC |
|-----|---------|-----|-----|------|
| **吞吐量** | TPS | 中 | 高（低冲突） | 高（读多） |
| **延迟** | 响应时间 | 高（锁等待） | 低（无等待） | 低（无锁读） |
| **中止率** | % | 低（死锁） | 高（冲突） | 中（SSI） |
| **存储开销** | 空间 | 低 | 低 | 高（版本） |
| **实现复杂度** | LOC | 中 | 低 | 高 |
| **可扩展性** | 线性度 | 低（锁竞争） | 高 | 高 |

### 7.2 决策公式

$$Score = w_1 \cdot TPS + w_2 \cdot (1 - Latency) + w_3 \cdot (1 - AbortRate) - w_4 \cdot StorageCost$$

**权重配置** (按场景):

| 场景 | $w_1$ (吞吐) | $w_2$ (延迟) | $w_3$ (中止) | $w_4$ (存储) |
|-----|------------|------------|------------|------------|
| **OLTP** | 0.4 | 0.3 | 0.2 | 0.1 |
| **OLAP** | 0.2 | 0.1 | 0.1 | 0.6 |
| **实时系统** | 0.2 | 0.6 | 0.1 | 0.1 |
| **嵌入式** | 0.3 | 0.2 | 0.1 | 0.4 |

### 7.3 选择决策树

```
1. 冲突概率评估
   ├─ 高冲突 (>20%) → 2PL
   ├─ 中冲突 (5-20%) → MVCC
   └─ 低冲突 (<5%) → OCC

2. 读写比例
   ├─ 读多 (>10:1) → MVCC
   ├─ 平衡 (1:1-10:1) → OCC或MVCC
   └─ 写多 (<1:1) → 2PL

3. 存储约束
   ├─ 紧张 → 2PL或OCC
   └─ 宽松 → MVCC

4. 延迟敏感度
   ├─ 高 → OCC或MVCC
   └─ 中 → 2PL
```

---

## 八、实际系统映射

### 8.1 数据库系统

| 系统 | 并发控制 | 特点 |
|-----|---------|------|
| **PostgreSQL** | MVCC + 严格2PL | 读无锁，写加锁 |
| **MySQL InnoDB** | MVCC + 2PL | Undo日志版本 |
| **Oracle** | MVCC + 多粒度锁 | Undo表空间 |
| **SQL Server** | MVCC + 锁提示 | 可选锁粒度 |
| **DB2** | 2PL | 传统锁机制 |

### 8.2 分布式系统

| 系统 | 并发控制 | 说明 |
|-----|---------|------|
| **Google Spanner** | MVCC + 2PL + TrueTime | 全球分布式MVCC |
| **CockroachDB** | MVCC + Raft | 开源Spanner替代 |
| **TiDB** | MVCC + Percolator | 分布式MVCC |
| **Cassandra** | LWW + Vector Clock | 最终一致性 |
| **DynamoDB** | OCC + 向量时钟 | 可调一致性 |

---

## 九、总结

### 9.1 核心贡献

**理论贡献**:

1. **统一分类体系**（三大范式）
2. **形式化定义**（定义1.1-4.1）
3. **正确性证明**（定理2.1、3.1、6.1）
4. **统一评估框架**（第7.1节）

**工程价值**:

1. **选择决策树**（第7.3节）
2. **性能对比模型**（第4.3节）
3. **实际系统映射**（第八章）

### 9.2 关键洞察

> **本质区别**: 2PL预防冲突，OCC检测冲突，MVCC避免冲突

> **选择原则**:
>
> - 高冲突 → 2PL（预防比处理便宜）
> - 低冲突 → OCC（乐观执行效率高）
> - 读多 → MVCC（版本分离读写）

> **混合策略**: PostgreSQL的MVCC+2PL是最佳实践

### 9.3 统一公式

$$\boxed{ConcurrencyControl = ConflictDetection + ConflictResolution}$$

**分解**:

- **ConflictDetection**: 何时检测（编译期/执行前/执行后）
- **ConflictResolution**: 如何解决（等待/中止/版本）

---

## 十、延伸阅读

**理论基础**:

- Bernstein, P. A., & Goodman, N. (1981). "Concurrency Control in Distributed Database Systems"
- Kung, H. T., & Robinson, J. T. (1981). "On Optimistic Methods for Concurrency Control"
- Berenson, H., et al. (1995). "A Critique of ANSI SQL Isolation Levels"

**实现参考**:

- PostgreSQL MVCC: `src/backend/storage/lmgr/lock.c`
- MySQL源码: `storage/innobase/lock/lock0lock.cc`

**扩展方向**:

- `02-设计权衡分析/01-并发控制决策树.md` → 选择合适的并发控制
- `03-证明与形式化/03-串行化证明.md` → 各协议的正确性证明
- `06-性能分析/01-吞吐量公式推导.md` → 性能模型量化

---

**版本**: 1.0.0
**最后更新**: 2025-12-05
**关联文档**:

- `01-核心理论模型/02-MVCC理论完整解析.md`
- `02-设计权衡分析/01-并发控制决策树.md`
