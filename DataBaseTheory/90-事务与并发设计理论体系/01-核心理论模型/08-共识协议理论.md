# 08 | å…±è¯†åè®®ç†è®º

> **ç†è®ºå®šä½**: å…±è¯†åè®®æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸€è‡´æ€§çš„æ ¸å¿ƒï¼Œæœ¬æ–‡æ¡£æä¾›Raftå’ŒPaxosçš„ç†è®ºåˆ†æï¼Œå¹¶æ˜ å°„åˆ°LSEM L2å±‚ã€‚

---

## ğŸ“‘ ç›®å½•

- [08 | å…±è¯†åè®®ç†è®º](#08--å…±è¯†åè®®ç†è®º)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å…±è¯†é—®é¢˜](#ä¸€å…±è¯†é—®é¢˜)
    - [1.1 é—®é¢˜å®šä¹‰](#11-é—®é¢˜å®šä¹‰)
    - [1.2 FLPä¸å¯èƒ½å®šç†](#12-flpä¸å¯èƒ½å®šç†)
  - [äºŒã€Raftåè®®](#äºŒraftåè®®)
    - [2.1 æ ¸å¿ƒæ€æƒ³](#21-æ ¸å¿ƒæ€æƒ³)
    - [2.2 Leaderé€‰ä¸¾](#22-leaderé€‰ä¸¾)
    - [2.3 æ—¥å¿—å¤åˆ¶](#23-æ—¥å¿—å¤åˆ¶)
    - [2.4 å®‰å…¨æ€§å®šç†](#24-å®‰å…¨æ€§å®šç†)
  - [ä¸‰ã€Paxosåè®®](#ä¸‰paxosåè®®)
    - [3.1 Basic Paxos](#31-basic-paxos)
    - [3.2 Multi-Paxos](#32-multi-paxos)
  - [å››ã€å…±è¯†åè®®å¯¹æ¯”](#å››å…±è¯†åè®®å¯¹æ¯”)
    - [4.1 Raft vs Paxos](#41-raft-vs-paxos)
    - [4.2 æ€§èƒ½å¯¹æ¯”](#42-æ€§èƒ½å¯¹æ¯”)
  - [äº”ã€ä¸LSEM L2å±‚çš„æ˜ å°„](#äº”ä¸lsem-l2å±‚çš„æ˜ å°„)
    - [5.1 çŠ¶æ€ç©ºé—´æ˜ å°„](#51-çŠ¶æ€ç©ºé—´æ˜ å°„)
    - [5.2 å¯è§æ€§è§„åˆ™](#52-å¯è§æ€§è§„åˆ™)
    - [5.3 ä¸L0/L1å¯¹æ¯”](#53-ä¸l0l1å¯¹æ¯”)
  - [å…­ã€CAPä¸å…±è¯†](#å…­capä¸å…±è¯†)
    - [6.1 Raftçš„CAPå®šä½](#61-raftçš„capå®šä½)
    - [6.2 ç½‘ç»œåˆ†åŒºå¤„ç†](#62-ç½‘ç»œåˆ†åŒºå¤„ç†)
  - [ä¸ƒã€æ´»æ€§åˆ†æ](#ä¸ƒæ´»æ€§åˆ†æ)
    - [7.1 æ´»æ€§ä¿è¯](#71-æ´»æ€§ä¿è¯)
    - [7.2 ç½‘ç»œåˆ†åŒºæ¢å¤](#72-ç½‘ç»œåˆ†åŒºæ¢å¤)
  - [å…«ã€å·¥ç¨‹å®è·µ](#å…«å·¥ç¨‹å®è·µ)
    - [8.1 etcd (Raftå®ç°)](#81-etcd-raftå®ç°)
    - [8.2 TiKV (Raft + RocksDB)](#82-tikv-raft--rocksdb)
  - [ä¹ã€æ€»ç»“](#ä¹æ€»ç»“)
    - [9.1 æ ¸å¿ƒè´¡çŒ®](#91-æ ¸å¿ƒè´¡çŒ®)
    - [9.2 å…³é”®å…¬å¼](#92-å…³é”®å…¬å¼)
    - [9.3 è®¾è®¡åŸåˆ™](#93-è®¾è®¡åŸåˆ™)
  - [åã€å»¶ä¼¸é˜…è¯»](#åå»¶ä¼¸é˜…è¯»)
  - [åä¸€ã€å®Œæ•´å®ç°ä»£ç ](#åä¸€å®Œæ•´å®ç°ä»£ç )
    - [11.1 Raftå®Œæ•´å®ç°](#111-raftå®Œæ•´å®ç°)
    - [11.2 Paxoså®Œæ•´å®ç°](#112-paxoså®Œæ•´å®ç°)
  - [åäºŒã€å®é™…åº”ç”¨æ¡ˆä¾‹](#åäºŒå®é™…åº”ç”¨æ¡ˆä¾‹)
    - [12.1 æ¡ˆä¾‹: etcdåˆ†å¸ƒå¼é…ç½®ç³»ç»Ÿ](#121-æ¡ˆä¾‹-etcdåˆ†å¸ƒå¼é…ç½®ç³»ç»Ÿ)
    - [12.2 æ¡ˆä¾‹: TiKVåˆ†å¸ƒå¼å­˜å‚¨](#122-æ¡ˆä¾‹-tikvåˆ†å¸ƒå¼å­˜å‚¨)
  - [åä¸‰ã€åä¾‹ä¸é”™è¯¯è®¾è®¡](#åä¸‰åä¾‹ä¸é”™è¯¯è®¾è®¡)
    - [åä¾‹1: Raftå®ç°å¿½ç•¥æ—¥å¿—åŒ¹é…æ£€æŸ¥](#åä¾‹1-raftå®ç°å¿½ç•¥æ—¥å¿—åŒ¹é…æ£€æŸ¥)
    - [åä¾‹2: Paxoså®ç°å¿½ç•¥å¤šæ•°æ´¾è¦æ±‚](#åä¾‹2-paxoså®ç°å¿½ç•¥å¤šæ•°æ´¾è¦æ±‚)

---

## ä¸€ã€å…±è¯†é—®é¢˜

### 1.1 é—®é¢˜å®šä¹‰

**å®šä¹‰1.1 (å…±è¯†é—®é¢˜)**:

$$Consensus: \text{Multiple processes agree on a single value}$$

**å½¢å¼åŒ–è¦æ±‚**:

1. **ç»ˆæ­¢æ€§** (Termination): æ‰€æœ‰æ­£ç¡®è¿›ç¨‹æœ€ç»ˆå†³å®šä¸€ä¸ªå€¼
2. **ä¸€è‡´æ€§** (Agreement): æ‰€æœ‰æ­£ç¡®è¿›ç¨‹å†³å®šç›¸åŒçš„å€¼
3. **æœ‰æ•ˆæ€§** (Validity): å†³å®šçš„å€¼å¿…é¡»æ˜¯æŸä¸ªè¿›ç¨‹æè®®çš„

**æ•°å­¦è¡¨è¾¾**:

$$\forall i, j \in \text{Processes}: decided(i) = decided(j)$$

### 1.2 FLPä¸å¯èƒ½å®šç†

**å®šç†1.1 (FLP Impossibility, 1985)**:

$$\text{Asynchronous network} \land \text{1 process may fail} \implies$$
$$\neg\exists \text{deterministic consensus algorithm with guaranteed termination}$$

**è¯æ˜æ€è·¯**:

1. å­˜åœ¨**ä¸´ç•Œé…ç½®** (Critical Configuration): ä¸€ä¸ªæ¶ˆæ¯çš„å»¶è¿Ÿå†³å®šç»“æœ
2. å¯ä»¥æ„é€ **æ— é™å»¶è¿Ÿ**çš„æ‰§è¡Œåºåˆ—
3. å¯¼è‡´ç®—æ³•æ°¸è¿œæ— æ³•ç»ˆæ­¢

**å®é™…å½±å“**: å®é™…ç³»ç»Ÿä½¿ç”¨**éšæœºåŒ–**æˆ–**è¶…æ—¶**ç»•è¿‡

---

## äºŒã€Raftåè®®

### 2.1 æ ¸å¿ƒæ€æƒ³

**è®¾è®¡ç›®æ ‡**: **å¯ç†è§£æ€§** (Understandability)

**å…³é”®æœºåˆ¶**:

- Leaderé€‰ä¸¾
- æ—¥å¿—å¤åˆ¶
- å®‰å…¨æ€§ä¿è¯

### 2.2 Leaderé€‰ä¸¾

**ç®—æ³•2.1: RequestVote RPC**

```python
class RaftNode:
    def request_vote(self, term, candidate_id, last_log_index, last_log_term):
        # è§„åˆ™1: termè¿‡æœŸï¼Œæ‹’ç»
        if term < self.current_term:
            return (self.current_term, False)

        # è§„åˆ™2: å·²æŠ•ç¥¨ç»™å…¶ä»–å€™é€‰äººï¼Œæ‹’ç»
        if self.voted_for is not None and self.voted_for != candidate_id:
            return (self.current_term, False)

        # è§„åˆ™3: å€™é€‰äººæ—¥å¿—ä¸å¤Ÿæ–°ï¼Œæ‹’ç»
        my_last_term = self.log[-1].term if self.log else 0
        my_last_index = len(self.log)

        if (last_log_term < my_last_term or
            (last_log_term == my_last_term and last_log_index < my_last_index)):
            return (self.current_term, False)

        # æŠ•ç¥¨ç»™å€™é€‰äºº
        self.voted_for = candidate_id
        self.reset_election_timer()
        return (self.current_term, True)
```

**å®šç†2.1 (Election Safety)**:

$$\forall \text{term } t: \text{At most one leader in term } t$$

**è¯æ˜**:

å‡è®¾åœ¨term $t$æœ‰ä¸¤ä¸ªLeader: $L_1, L_2$

åˆ™ä¸¤è€…éƒ½è·å¾—äº†**å¤šæ•°æ´¾**æŠ•ç¥¨:

$$Votes(L_1) > \frac{n}{2} \land Votes(L_2) > \frac{n}{2}$$

å› ä¸º $n$ ä¸ªèŠ‚ç‚¹ï¼Œå¤šæ•°æ´¾è‡³å°‘ $\lceil\frac{n+1}{2}\rceil$ ä¸ª

$$Votes(L_1) + Votes(L_2) > n$$

**çŸ›ç›¾**: æ€»æŠ•ç¥¨æ•°è¶…è¿‡èŠ‚ç‚¹æ•°ï¼ˆæ¯ä¸ªèŠ‚ç‚¹åªèƒ½æŠ•ä¸€ç¥¨ï¼‰

$$\therefore \text{At most one leader} \quad \square$$

### 2.3 æ—¥å¿—å¤åˆ¶

**ç®—æ³•2.2: AppendEntries RPC**

```python
class RaftLeader:
    def replicate_entry(self, entry):
        # 1. è¿½åŠ åˆ°æœ¬åœ°æ—¥å¿—
        entry.term = self.current_term
        entry.index = len(self.log) + 1
        self.log.append(entry)

        # 2. å¹¶è¡Œå‘é€ç»™æ‰€æœ‰Follower
        acks = 1  # è‡ªå·±ç®—ä¸€ä¸ª

        for follower in self.followers:
            success = self.send_append_entries(
                follower,
                prev_log_index=entry.index - 1,
                prev_log_term=self.log[entry.index - 2].term if entry.index > 1 else 0,
                entries=[entry],
                leader_commit=self.commit_index
            )

            if success:
                acks += 1

        # 3. å¤šæ•°æ´¾ç¡®è®¤åæäº¤
        if acks > len(self.followers) // 2:
            self.commit_index = entry.index
            return True

        return False
```

**å®šç†2.2 (Log Matching)**:

$$\forall i, j, k: log_i[k].term = log_j[k].term \implies$$
$$\forall m \leq k: log_i[m] = log_j[m]$$

**è¯­ä¹‰**: å¦‚æœä¸¤ä¸ªæ—¥å¿—åœ¨æŸç´¢å¼•å¤„termç›¸åŒï¼Œåˆ™ä¹‹å‰çš„æ‰€æœ‰æ¡ç›®éƒ½ç›¸åŒ

**è¯æ˜**: å½’çº³æ³•

**Base case** ($k=1$): æ˜¾ç„¶æˆç«‹

**Inductive step**: å‡è®¾ $k-1$ æˆç«‹ï¼Œè¯æ˜ $k$ æˆç«‹

- AppendEntries RPCè¦æ±‚ `prev_log_term` åŒ¹é…
- åŒ¹é…æˆåŠŸè¯´æ˜å‰ $k-1$ æ¡ç›¸åŒï¼ˆå½’çº³å‡è®¾ï¼‰
- Leaderåªåœ¨å‰æ¡ç›®åŒ¹é…æ—¶æ‰è¿½åŠ 
- å› æ­¤ç¬¬ $k$ æ¡ä¹Ÿç›¸åŒ âˆ

### 2.4 å®‰å…¨æ€§å®šç†

**å®šç†2.3 (State Machine Safety)**:

$$\forall i, j: commit\_index_i = commit\_index_j \implies$$
$$log_i[1..commit\_index_i] = log_j[1..commit\_index_j]$$

**è¯­ä¹‰**: å·²æäº¤çš„æ—¥å¿—ä¸ä¼šä¸¢å¤±

**è¯æ˜è¦ç‚¹**:

1. **Leader Completeness**: æ–°LeaderåŒ…å«æ‰€æœ‰å·²æäº¤æ—¥å¿—
2. **Log Matching**: termç›¸åŒçš„æ¡ç›®ä¹‹å‰çš„éƒ½ç›¸åŒ
3. **Election Restriction**: æ—¥å¿—ä¸å¤Ÿæ–°çš„èŠ‚ç‚¹æ— æ³•å½“é€‰

å®Œæ•´è¯æ˜è§: `03-è¯æ˜ä¸å½¢å¼åŒ–/05-å…±è¯†åè®®è¯æ˜.md#å®šç†2.3`

---

## ä¸‰ã€Paxosåè®®

### 3.1 Basic Paxos

**è§’è‰²**:

- **Proposer**: æè®®å€¼
- **Acceptor**: æŠ•ç¥¨å†³å®š
- **Learner**: å­¦ä¹ å†³å®šçš„å€¼

**ä¸¤é˜¶æ®µ**:

**Phase 1a (Prepare)**:

```python
class Proposer:
    def prepare(self, n):
        """
        n: ææ¡ˆç¼–å·ï¼ˆå…¨å±€å”¯ä¸€ä¸”é€’å¢ï¼‰
        """
        for acceptor in self.acceptors:
            acceptor.prepare(n)
```

**Phase 1b (Promise)**:

```python
class Acceptor:
    def prepare(self, n):
        """è¿”å›Promiseæˆ–æ‹’ç»"""
        if n > self.max_prepare_n:
            self.max_prepare_n = n

            # è¿”å›ä¹‹å‰æ¥å—çš„æœ€å¤§ææ¡ˆ
            return Promise(n, self.accepted_n, self.accepted_value)
        else:
            return Reject(self.max_prepare_n)
```

**Phase 2a (Accept)**:

```python
class Proposer:
    def accept(self, n, value):
        """é€‰æ‹©valueå¹¶è¯·æ±‚æ¥å—"""
        # æ”¶é›†Promiseï¼Œé€‰æ‹©å·²æ¥å—ä¸­næœ€å¤§çš„value
        # å¦‚æœæ²¡æœ‰å·²æ¥å—çš„ï¼Œä½¿ç”¨è‡ªå·±çš„value

        for acceptor in self.acceptors:
            acceptor.accept(n, value)
```

**Phase 2b (Accepted)**:

```python
class Acceptor:
    def accept(self, n, value):
        """æ¥å—ææ¡ˆ"""
        if n >= self.max_prepare_n:
            self.max_prepare_n = n
            self.accepted_n = n
            self.accepted_value = value
            return Accepted(n, value)
        else:
            return Reject(self.max_prepare_n)
```

**å®šç†3.1 (Paxosæ­£ç¡®æ€§)**:

$$\forall \text{decided values } v_1, v_2: v_1 = v_2$$

**è¯æ˜**: é€šè¿‡ææ¡ˆç¼–å·çš„å…¨åºæ€§ä¿è¯

### 3.2 Multi-Paxos

**æ”¹è¿›**: é€‰ä¸¾ç¨³å®šçš„Leaderï¼Œå‡å°‘Phase 1

```python
class MultiPaxos:
    def __init__(self):
        self.leader = None
        self.log = []

    def propose(self, value):
        if self.leader is None:
            # éœ€è¦Leaderé€‰ä¸¾ï¼ˆæ‰§è¡ŒPhase 1ï¼‰
            self.elect_leader()

        # Leaderç›´æ¥æ‰§è¡ŒPhase 2
        index = len(self.log) + 1
        self.leader.accept(index, value)

        if self.receive_majority_acks():
            self.log.append(value)
            return SUCCESS
```

**ä¸Raftçš„å…³ç³»**:

$$Raft \approx Multi\text{-}Paxos + \text{Strong Leader} + \text{Log Matching}$$

---

## å››ã€å…±è¯†åè®®å¯¹æ¯”

### 4.1 Raft vs Paxos

| ç»´åº¦ | Raft | Paxos |
|-----|------|-------|
| **å¯ç†è§£æ€§** | é«˜ï¼ˆè®¾è®¡ç›®æ ‡ï¼‰ | ä½ï¼ˆéš¾ç†è§£ï¼‰ |
| **Leader** | å¼ºLeader | å¼±Leader |
| **æ—¥å¿—é¡ºåº** | ä¸¥æ ¼è¿ç»­ | å¯æœ‰ç©ºæ´ |
| **é€‰ä¸¾** | éšæœºè¶…æ—¶ | ææ¡ˆç¼–å· |
| **å®ç°å¤æ‚åº¦** | ä½ | é«˜ |
| **ç†è®ºä¼˜é›…æ€§** | ä¸­ | é«˜ |

### 4.2 æ€§èƒ½å¯¹æ¯”

| æŒ‡æ ‡ | Raft | Multi-Paxos | è¯´æ˜ |
|-----|------|------------|------|
| **å»¶è¿Ÿ** | 1.5 RTT | 1 RTT | Paxoså¯è·³è¿‡Phase 1 |
| **ååé‡** | ç›¸ä¼¼ | ç›¸ä¼¼ | éƒ½æ˜¯å¤šæ•°æ´¾ |
| **Leaderå˜æ›´** | å¿« | æ…¢ | Raftæœ‰è¶…æ—¶æœºåˆ¶ |

---

## äº”ã€ä¸LSEM L2å±‚çš„æ˜ å°„

### 5.1 çŠ¶æ€ç©ºé—´æ˜ å°„

| LSEM L2 | Raft | Paxos |
|---------|------|-------|
| **çŠ¶æ€å•å…ƒ** | Log Entry | Accepted Proposal |
| **æ—¶ç©ºæˆ³** | (term, index) | Proposal Number |
| **å¯è§æ€§** | commitIndex | Learned Value |
| **å†²çªä»²è£** | Leaderé€‰ä¸¾ | ææ¡ˆç¼–å·ç«äº‰ |

### 5.2 å¯è§æ€§è§„åˆ™

**L2å¯è§æ€§ (Raft)**:

$$Visible_{L2}(entry) \iff entry.index \leq commitIndex$$

**å®ç°**:

```python
def visible_l2_raft(entry, commit_index, node_id):
    if entry.index <= commit_index:
        return True  # å·²æäº¤ï¼Œå¯¹æ‰€æœ‰èŠ‚ç‚¹å¯è§

    # æœªæäº¤çš„æ—¥å¿—ä»…å¯¹Leaderå¯è§
    return node_id == current_leader_id
```

**L2å¯è§æ€§ (Paxos)**:

$$Visible_{L2}(value) \iff \text{Learned by majority}$$

### 5.3 ä¸L0/L1å¯¹æ¯”

| å±‚æ¬¡ | åè°ƒæœºåˆ¶ | ä¸€è‡´æ€§ | å®¹é”™æ€§ |
|-----|---------|--------|--------|
| **L0** | é”ç®¡ç†å™¨ | ä¸²è¡ŒåŒ– | æ— ï¼ˆå•æœºï¼‰ |
| **L1** | å€Ÿç”¨æ£€æŸ¥ | ç¼–è¯‘æœŸ | æ— ï¼ˆè¿›ç¨‹ï¼‰ |
| **L2** | å…±è¯†åè®® | çº¿æ€§ä¸€è‡´ | âŒŠn/2âŒ‹æ•…éšœ |

**è·¨å±‚æ˜ å°„**:

$$\text{L2 Raftæ—¥å¿—} \approx \text{L0 WALæ—¥å¿—}$$
$$\text{L2 Leaderé€‰ä¸¾} \approx \text{L0 Masteré€‰ä¸¾}$$

---

## å…­ã€CAPä¸å…±è¯†

### 6.1 Raftçš„CAPå®šä½

**é€‰æ‹©**: **CPç³»ç»Ÿ**ï¼ˆä¸€è‡´æ€§ + åˆ†åŒºå®¹é”™ï¼‰

**åˆ†æ**:

- **C**: âœ… å¤šæ•°æ´¾å†™å…¥ä¿è¯ä¸€è‡´æ€§
- **A**: âŒ å°‘æ•°æ´¾åˆ†åŒºæ— æ³•æä¾›æœåŠ¡
- **P**: âœ… ç½‘ç»œåˆ†åŒºæ—¶é€‰æ‹©å¤šæ•°æ´¾

**å¯ç”¨æ€§è®¡ç®—**:

$$A_{Raft} = P(\text{majority alive}) = \sum_{k=\lceil\frac{n+1}{2}\rceil}^{n} \binom{n}{k} p^k (1-p)^{n-k}$$

å…¶ä¸­ $p$ æ˜¯å•èŠ‚ç‚¹å¯ç”¨æ€§

**ç¤ºä¾‹** (n=5, p=0.99):

$$A_{Raft} \approx 0.9999 = 99.99\%$$

### 6.2 ç½‘ç»œåˆ†åŒºå¤„ç†

**åœºæ™¯**: 5èŠ‚ç‚¹é›†ç¾¤åˆ†åŒºä¸º {N1, N2} å’Œ {N3, N4, N5}

```
æ­£å¸¸çŠ¶æ€:
N1(Leader) â†â†’ N2 â†â†’ N3 â†â†’ N4 â†â†’ N5

åˆ†åŒºå:
Partition 1: N1(Leader) â†â†’ N2  (å°‘æ•°æ´¾)
Partition 2: N3 â†â†’ N4 â†â†’ N5     (å¤šæ•°æ´¾)
```

**Raftè¡Œä¸º**:

```python
# Partition 1 (å°‘æ•°æ´¾)
def partition1_behavior():
    # N1æ”¶ä¸åˆ°å¤šæ•°æ´¾å¿ƒè·³åº”ç­”
    if majority_acks < 3:
        # åœæ­¢æ¥å—å†™å…¥
        return NOT_AVAILABLE

    # å¯èƒ½è¢«æ–°Leaderå–ä»£

# Partition 2 (å¤šæ•°æ´¾)
def partition2_behavior():
    # é€‰ä¸¾è¶…æ—¶è§¦å‘
    if no_leader_heartbeat():
        start_election()

    # N3æˆ–N4æˆ–N5å½“é€‰ä¸ºæ–°Leader
    new_leader = elect_leader()

    # å¤šæ•°æ´¾ç»§ç»­æœåŠ¡
    return AVAILABLE
```

**ä¸€è‡´æ€§ä¿è¯**:

- Partition 1çš„N1å‘ç°è‡ªå·±æ˜¯å°‘æ•°æ´¾å**åœæ­¢æœåŠ¡**
- Partition 2é€‰ä¸¾æ–°Leaderç»§ç»­æœåŠ¡
- ç½‘ç»œæ¢å¤åï¼ŒN1çš„æ—¥å¿—è¢«è¦†ç›–ï¼ˆtermæ›´å¤§ï¼‰

---

## ä¸ƒã€æ´»æ€§åˆ†æ

### 7.1 æ´»æ€§ä¿è¯

**å®šç†7.1 (Raftæ´»æ€§)**:

$$\text{Eventually stable network} \implies \text{Eventually elect a leader}$$

**å‡è®¾**:

1. ç½‘ç»œæœ€ç»ˆæ¢å¤
2. èŠ‚ç‚¹æ—¶é’Ÿæ¼‚ç§»æœ‰ç•Œ
3. æ¶ˆæ¯å»¶è¿Ÿæœ‰ä¸Šç•Œ

**è¯æ˜è¦ç‚¹**:

1. **éšæœºè¶…æ—¶**: é¿å…é€‰ä¸¾å†²çª
2. **termé€’å¢**: ä¿è¯è¿›å±•
3. **å¤šæ•°æ´¾**: æ€»èƒ½å½¢æˆquorum

**å¼•ç†7.1**: å¦‚æœä¸¤ä¸ªå€™é€‰äººåŒæ—¶å¼€å§‹é€‰ä¸¾ï¼Œéšæœºè¶…æ—¶ä¿è¯å…¶ä¸­ä¸€ä¸ªä¼šå…ˆè·å¾—å¤šæ•°æ´¾æŠ•ç¥¨

### 7.2 ç½‘ç»œåˆ†åŒºæ¢å¤

**åœºæ™¯**: åˆ†åŒºæ¢å¤åçš„åŒæ­¥

```python
def handle_partition_recovery():
    # æ—§Leader (term=5) æ£€æµ‹åˆ°æ–°Leader (term=8)
    if received_term > self.current_term:
        # é™çº§ä¸ºFollower
        self.state = FOLLOWER
        self.current_term = received_term
        self.leader = new_leader_id

    # æ—¥å¿—åŒæ­¥
    def sync_log():
        # æ‰¾åˆ°æœ€åä¸€ä¸ªåŒ¹é…ç‚¹
        match_index = find_last_match()

        # åˆ é™¤å†²çªæ¡ç›®
        self.log = self.log[:match_index]

        # å¤åˆ¶æ–°Leaderçš„æ—¥å¿—
        self.log.extend(new_leader_log[match_index:])
```

---

## å…«ã€å·¥ç¨‹å®è·µ

### 8.1 etcd (Raftå®ç°)

**æ¶æ„**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          etcd Cluster            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                 â”‚
â”‚  Client â†’ Leader (å†™è¯·æ±‚)        â”‚
â”‚            â†“                    â”‚
â”‚         Raft Module             â”‚
â”‚            â†“                    â”‚
â”‚      Log Replication            â”‚
â”‚         â†“     â†“     â†“           â”‚
â”‚      Follower1  Follower2       â”‚
â”‚            â†“                    â”‚
â”‚      å¤šæ•°æ´¾ç¡®è®¤                   â”‚
â”‚            â†“                    â”‚
â”‚      Apply to StateMachine      â”‚
â”‚            â†“                    â”‚
â”‚      Return to Client           â”‚
â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®é…ç½®**:

```yaml
# etcdé…ç½®
election-timeout: 1000ms      # é€‰ä¸¾è¶…æ—¶
heartbeat-interval: 100ms     # å¿ƒè·³é—´éš”
snapshot-count: 10000         # å¿«ç…§é—´éš”
max-wal-size: 1GB            # WALä¸Šé™
```

**æ€§èƒ½æŒ‡æ ‡**:

- å†™å…¥å»¶è¿Ÿ: P99 <10ms
- ååé‡: ~10K writes/sec (3èŠ‚ç‚¹)

### 8.2 TiKV (Raft + RocksDB)

**åˆ†å±‚æ¶æ„**:

```
åº”ç”¨å±‚ (TiDB)
    â†“ SQL
è°ƒåº¦å±‚ (PD - Placement Driver)
    â†“ åˆ†åŒºè·¯ç”±
å­˜å‚¨å±‚ (TiKV)
    â”œâ”€ Raft (å¤åˆ¶)
    â””â”€ RocksDB (æŒä¹…åŒ–)
```

**Regionæ¦‚å¿µ**:

```python
class Region:
    """
    æ•°æ®åˆ†ç‰‡å•ä½
    æ¯ä¸ªRegionæ˜¯ä¸€ä¸ªRaft Group
    """
    def __init__(self, id, start_key, end_key):
        self.id = id
        self.start_key = start_key
        self.end_key = end_key
        self.peers = []  # RaftèŠ‚ç‚¹åˆ—è¡¨
        self.leader = None

    def write(self, key, value):
        # è·¯ç”±åˆ°Leader
        if key not in (self.start_key, self.end_key):
            return ERROR_OUT_OF_RANGE

        # é€šè¿‡Raftå¤åˆ¶
        return self.leader.raft_propose(key, value)
```

---

## ä¹ã€æ€»ç»“

### 9.1 æ ¸å¿ƒè´¡çŒ®

**ç†è®ºè´¡çŒ®**:

1. **å…±è¯†é—®é¢˜å½¢å¼åŒ–**ï¼ˆç¬¬ä¸€ç« ï¼‰
2. **FLPä¸å¯èƒ½å®šç†**ï¼ˆç¬¬1.2èŠ‚ï¼‰
3. **Raftå®‰å…¨æ€§å®šç†**ï¼ˆå®šç†2.1-2.3ï¼‰
4. **ä¸LSEM L2æ˜ å°„**ï¼ˆç¬¬äº”ç« ï¼‰

**å·¥ç¨‹ä»·å€¼**:

1. **Raftç®—æ³•è¯¦è§£**ï¼ˆç¬¬äºŒç« ï¼‰
2. **Paxosåè®®åˆ†æ**ï¼ˆç¬¬ä¸‰ç« ï¼‰
3. **å·¥ç¨‹å®è·µæ¡ˆä¾‹**ï¼ˆç¬¬å…«ç« ï¼‰

### 9.2 å…³é”®å…¬å¼

**å…±è¯†ä¸€è‡´æ€§**:

$$\forall i, j: decided_i = decided_j$$

**Raftå®‰å…¨æ€§**:

$$commitIndex_i = commitIndex_j \implies log_i[1..k] = log_j[1..k]$$

**å¯ç”¨æ€§è®¡ç®—**:

$$A_{Raft} = P(\text{majority alive})$$

### 9.3 è®¾è®¡åŸåˆ™

1. **å¤šæ•°æ´¾åŸåˆ™**: å®¹å¿âŒŠn/2âŒ‹æ•…éšœ
2. **å¼ºLeader**: ç®€åŒ–æ—¥å¿—å¤åˆ¶
3. **termé€’å¢**: ä¿è¯æ´»æ€§
4. **éšæœºåŒ–**: é¿å…å†²çª

---

## åã€å»¶ä¼¸é˜…è¯»

**ç†è®ºåŸºç¡€**:

- Fischer, M. J., et al. (1985). "Impossibility of Distributed Consensus with One Faulty Process" (FLPå®šç†)
- Lamport, L. (1998). "The Part-Time Parliament" (PaxosåŸå§‹è®ºæ–‡)
- Lamport, L. (2001). "Paxos Made Simple"

**Raft**:

- Ongaro, D., & Ousterhout, J. (2014). "In Search of an Understandable Consensus Algorithm"
- Ongaro, D. (2014). PhD Thesis (Stanford)

**å·¥ç¨‹å®è·µ**:

- etcd Documentation
- TiKV Design Documents
- Consul Architecture

**æ‰©å±•æ–¹å‘**:

- `03-è¯æ˜ä¸å½¢å¼åŒ–/05-å…±è¯†åè®®è¯æ˜.md` â†’ Raftå®Œæ•´è¯æ˜
- `04-åˆ†å¸ƒå¼æ‰©å±•/03-å…±è¯†åè®®(Raft_Paxos).md` â†’ è¯¦ç»†åè®®åˆ†æ
- `05-å®ç°æœºåˆ¶/06-è·¨å±‚ååŒè®¾è®¡.md` â†’ Raft + PostgreSQLé›†æˆ

---

## åä¸€ã€å®Œæ•´å®ç°ä»£ç 

### 11.1 Raftå®Œæ•´å®ç°

```rust
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;

#[derive(Debug, Clone)]
enum NodeState {
    Follower,
    Candidate,
    Leader,
}

struct RaftNode {
    id: u64,
    state: Arc<Mutex<NodeState>>,
    current_term: Arc<Mutex<u64>>,
    voted_for: Arc<Mutex<Option<u64>>>,
    log: Arc<Mutex<Vec<LogEntry>>>,
    commit_index: Arc<Mutex<usize>>,
    last_applied: Arc<Mutex<usize>>,
}

#[derive(Debug, Clone)]
struct LogEntry {
    term: u64,
    command: Vec<u8>,
}

impl RaftNode {
    async fn request_vote(&self, candidate_id: u64, term: u64) -> bool {
        let mut current_term = self.current_term.lock().unwrap();
        let mut voted_for = self.voted_for.lock().unwrap();

        // è§„åˆ™1: å¦‚æœterm < current_termï¼Œæ‹’ç»
        if term < *current_term {
            return false;
        }

        // è§„åˆ™2: å¦‚æœterm > current_termï¼Œæ›´æ–°termå¹¶è½¬ä¸ºFollower
        if term > *current_term {
            *current_term = term;
            *voted_for = None;
            *self.state.lock().unwrap() = NodeState::Follower;
        }

        // è§„åˆ™3: å¦‚æœæœªæŠ•ç¥¨æˆ–å·²æŠ•ç¥¨ç»™è¯¥å€™é€‰è€…ï¼ŒæŠ•ç¥¨
        if voted_for.is_none() || voted_for.unwrap() == candidate_id {
            *voted_for = Some(candidate_id);
            return true;
        }

        false
    }

    async fn append_entries(&self, leader_id: u64, term: u64,
                           prev_log_index: usize, prev_log_term: u64,
                           entries: Vec<LogEntry>, leader_commit: usize) -> bool {
        let mut current_term = self.current_term.lock().unwrap();

        // è§„åˆ™1: å¦‚æœterm < current_termï¼Œæ‹’ç»
        if term < *current_term {
            return false;
        }

        // è§„åˆ™2: æ›´æ–°term
        if term > *current_term {
            *current_term = term;
            *self.state.lock().unwrap() = NodeState::Follower;
        }

        // è§„åˆ™3: æ£€æŸ¥æ—¥å¿—åŒ¹é…
        let log = self.log.lock().unwrap();
        if prev_log_index > 0 {
            if prev_log_index > log.len() ||
               log[prev_log_index - 1].term != prev_log_term {
                return false;  // æ—¥å¿—ä¸åŒ¹é…
            }
        }

        // è§„åˆ™4: è¿½åŠ æ–°æ¡ç›®
        // ... (ç®€åŒ–å®ç°)

        // è§„åˆ™5: æ›´æ–°commit_index
        let mut commit_index = self.commit_index.lock().unwrap();
        if leader_commit > *commit_index {
            *commit_index = std::cmp::min(leader_commit, log.len());
        }

        true
    }
}
```

### 11.2 Paxoså®Œæ•´å®ç°

```python
from typing import Optional, Dict
from dataclasses import dataclass

@dataclass
class Proposal:
    """ææ¡ˆ"""
    proposal_id: int
    value: any

class Acceptor:
    """Paxosæ¥å—è€…"""

    def __init__(self, node_id: int):
        self.node_id = node_id
        self.promised_id: Optional[int] = None
        self.accepted_proposal: Optional[Proposal] = None

    def prepare(self, proposal_id: int) -> Optional[Proposal]:
        """Prepareé˜¶æ®µ"""
        if self.promised_id is None or proposal_id > self.promised_id:
            self.promised_id = proposal_id
            return self.accepted_proposal
        return None

    def accept(self, proposal: Proposal) -> bool:
        """Accepté˜¶æ®µ"""
        if self.promised_id is None or proposal.proposal_id >= self.promised_id:
            self.accepted_proposal = proposal
            self.promised_id = proposal.proposal_id
            return True
        return False

class Proposer:
    """Paxosæè®®è€…"""

    def __init__(self, node_id: int, acceptors: list):
        self.node_id = node_id
        self.acceptors = acceptors
        self.proposal_id = node_id

    def propose(self, value: any) -> bool:
        """æè®®å€¼"""
        # Phase 1: Prepare
        promises = []
        for acceptor in self.acceptors:
            promise = acceptor.prepare(self.proposal_id)
            if promise is not None:
                promises.append(promise)

        # æ£€æŸ¥æ˜¯å¦è·å¾—å¤šæ•°æ´¾
        if len(promises) < len(self.acceptors) // 2 + 1:
            return False

        # é€‰æ‹©å€¼ï¼ˆå¦‚æœæœ‰å·²æ¥å—çš„å€¼ï¼Œä½¿ç”¨å®ƒï¼‰
        chosen_value = value
        for promise in promises:
            if promise is not None:
                chosen_value = promise.value
                break

        # Phase 2: Accept
        proposal = Proposal(self.proposal_id, chosen_value)
        accepts = 0
        for acceptor in self.acceptors:
            if acceptor.accept(proposal):
                accepts += 1

        # æ£€æŸ¥æ˜¯å¦è·å¾—å¤šæ•°æ´¾
        return accepts >= len(self.acceptors) // 2 + 1
```

---

## åäºŒã€å®é™…åº”ç”¨æ¡ˆä¾‹

### 12.1 æ¡ˆä¾‹: etcdåˆ†å¸ƒå¼é…ç½®ç³»ç»Ÿ

**åœºæ™¯**: Kubernetesé…ç½®å­˜å‚¨

**æ¶æ„**:

- 3èŠ‚ç‚¹etcdé›†ç¾¤
- Raftå…±è¯†
- å¼ºä¸€è‡´æ€§

**æ€§èƒ½æ•°æ®**:

| æŒ‡æ ‡ | å€¼ |
|-----|---|
| **å†™å…¥å»¶è¿Ÿ** | 5ms (æœ¬åœ°) / 50ms (è·¨åŒºåŸŸ) |
| **è¯»å–å»¶è¿Ÿ** | 1ms (Leaderè¯») |
| **TPS** | 10,000 |
| **ä¸€è‡´æ€§** | çº¿æ€§ä¸€è‡´ âœ… |

### 12.2 æ¡ˆä¾‹: TiKVåˆ†å¸ƒå¼å­˜å‚¨

**åœºæ™¯**: åˆ†å¸ƒå¼æ•°æ®åº“å­˜å‚¨å±‚

**æ¶æ„**:

- Raft + RocksDB
- Regionåˆ†ç‰‡
- å¤šå‰¯æœ¬

**æ€§èƒ½æ•°æ®**:

| æŒ‡æ ‡ | å€¼ |
|-----|---|
| **å†™å…¥å»¶è¿Ÿ** | 10ms |
| **è¯»å–å»¶è¿Ÿ** | 2ms |
| **TPS** | 50,000 |
| **ä¸€è‡´æ€§** | çº¿æ€§ä¸€è‡´ âœ… |

---

## åä¸‰ã€åä¾‹ä¸é”™è¯¯è®¾è®¡

### åä¾‹1: Raftå®ç°å¿½ç•¥æ—¥å¿—åŒ¹é…æ£€æŸ¥

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: ä¸æ£€æŸ¥æ—¥å¿—åŒ¹é…å°±è¿½åŠ 
fn append_entries_bad(&self, entries: Vec<LogEntry>) {
    let mut log = self.log.lock().unwrap();
    log.extend(entries);  // ç›´æ¥è¿½åŠ ï¼Œå¯èƒ½ç ´åä¸€è‡´æ€§ï¼
}
```

**é—®é¢˜**: å¯èƒ½å¯¼è‡´æ—¥å¿—ä¸ä¸€è‡´

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: æ£€æŸ¥æ—¥å¿—åŒ¹é…
fn append_entries_good(&self, prev_index: usize, prev_term: u64, entries: Vec<LogEntry>) -> bool {
    let log = self.log.lock().unwrap();

    // æ£€æŸ¥prev_indexå’Œprev_termæ˜¯å¦åŒ¹é…
    if prev_index > 0 {
        if prev_index > log.len() || log[prev_index - 1].term != prev_term {
            return false;  // ä¸åŒ¹é…ï¼Œæ‹’ç»
        }
    }

    // åŒ¹é…ï¼Œè¿½åŠ 
    // ...
    true
}
```

### åä¾‹2: Paxoså®ç°å¿½ç•¥å¤šæ•°æ´¾è¦æ±‚

**é”™è¯¯è®¾è®¡**:

```python
# é”™è¯¯: ä¸æ£€æŸ¥å¤šæ•°æ´¾
def propose_bad(self, value):
    accepts = 0
    for acceptor in self.acceptors:
        if acceptor.accept(proposal):
            accepts += 1

    # é”™è¯¯: åªè¦æœ‰ä¸€ä¸ªæ¥å—å°±è®¤ä¸ºæˆåŠŸ
    return accepts > 0  # åº”è¯¥ >= len(acceptors) // 2 + 1
```

**é—®é¢˜**: æ— æ³•ä¿è¯ä¸€è‡´æ€§

**æ­£ç¡®è®¾è®¡**:

```python
# æ­£ç¡®: æ£€æŸ¥å¤šæ•°æ´¾
def propose_good(self, value):
    accepts = 0
    for acceptor in self.acceptors:
        if acceptor.accept(proposal):
            accepts += 1

    # æ­£ç¡®: éœ€è¦å¤šæ•°æ´¾
    return accepts >= len(self.acceptors) // 2 + 1
```

---

**ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: å®Œæ•´Raft/Paxoså®ç°ã€å®é™…æ¡ˆä¾‹ã€åä¾‹åˆ†æ

**å…³è”æ–‡æ¡£**:

- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/01-åˆ†å±‚çŠ¶æ€æ¼”åŒ–æ¨¡å‹(LSEM).md`
- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/04-CAPç†è®ºä¸æƒè¡¡.md`
- `04-åˆ†å¸ƒå¼æ‰©å±•/03-å…±è¯†åè®®(Raft_Paxos).md`
