# 07 | å†…å­˜æ¨¡å‹ä¸æ’åº

> **ç†è®ºå®šä½**: å†…å­˜æ¨¡å‹å®šä¹‰å¤šçº¿ç¨‹ç¨‹åºçš„è¯­ä¹‰ï¼Œæœ¬æ–‡æ¡£æä¾›ä»ç†è®ºåˆ°Rustå®ç°çš„å®Œæ•´åˆ†æï¼Œå¹¶æ˜ å°„åˆ°LSEM L1å±‚ã€‚

---

## ğŸ“‘ ç›®å½•

- [07 | å†…å­˜æ¨¡å‹ä¸æ’åº](#07--å†…å­˜æ¨¡å‹ä¸æ’åº)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å†…å­˜æ¨¡å‹ç†è®ºèƒŒæ™¯ä¸æ¼”è¿›](#ä¸€å†…å­˜æ¨¡å‹ç†è®ºèƒŒæ™¯ä¸æ¼”è¿›)
    - [0.1 ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜æ¨¡å‹ï¼Ÿ](#01-ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜æ¨¡å‹)
    - [0.2 å†…å­˜æ¨¡å‹çš„æ ¸å¿ƒçŸ›ç›¾](#02-å†…å­˜æ¨¡å‹çš„æ ¸å¿ƒçŸ›ç›¾)
    - [0.3 ç¡¬ä»¶å†…å­˜æ¨¡å‹çš„èƒŒæ™¯](#03-ç¡¬ä»¶å†…å­˜æ¨¡å‹çš„èƒŒæ™¯)
      - [CPUç¼“å­˜å±‚æ¬¡ç»“æ„](#cpuç¼“å­˜å±‚æ¬¡ç»“æ„)
      - [æŒ‡ä»¤é‡æ’åºä¸å†…å­˜å±éšœ](#æŒ‡ä»¤é‡æ’åºä¸å†…å­˜å±éšœ)
      - [åŸå­æ“ä½œç¡¬ä»¶å®ç°](#åŸå­æ“ä½œç¡¬ä»¶å®ç°)
      - [ä¸åŒç¡¬ä»¶æ¶æ„çš„å†…å­˜æ¨¡å‹](#ä¸åŒç¡¬ä»¶æ¶æ„çš„å†…å­˜æ¨¡å‹)
      - [ç¡¬ä»¶å†…å­˜æ¨¡å‹å¯¹ç¼–ç¨‹çš„å½±å“](#ç¡¬ä»¶å†…å­˜æ¨¡å‹å¯¹ç¼–ç¨‹çš„å½±å“)
  - [äºŒã€å†…å­˜æ¨¡å‹åŸºç¡€](#äºŒå†…å­˜æ¨¡å‹åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯å†…å­˜æ¨¡å‹](#11-ä»€ä¹ˆæ˜¯å†…å­˜æ¨¡å‹)
    - [1.2 happens-beforeå…³ç³»](#12-happens-beforeå…³ç³»)
  - [äºŒã€Rustå†…å­˜æ’åº](#äºŒrustå†…å­˜æ’åº)
    - [2.1 Orderingç±»å‹](#21-orderingç±»å‹)
    - [2.2 Relaxedæ’åº](#22-relaxedæ’åº)
    - [2.3 Release-Acquireæ’åº](#23-release-acquireæ’åº)
    - [2.4 AcqRelæ’åº](#24-acqrelæ’åº)
    - [2.5 SeqCstæ’åº](#25-seqcstæ’åº)
  - [ä¸‰ã€å†…å­˜å±éšœ](#ä¸‰å†…å­˜å±éšœ)
    - [3.1 ç¡¬ä»¶å±‚é¢](#31-ç¡¬ä»¶å±‚é¢)
    - [3.2 ç¼–è¯‘å™¨å±éšœ](#32-ç¼–è¯‘å™¨å±éšœ)
  - [å››ã€ä¸C++å†…å­˜æ¨¡å‹å¯¹æ¯”](#å››ä¸cå†…å­˜æ¨¡å‹å¯¹æ¯”)
    - [4.1 C++20å†…å­˜æ¨¡å‹](#41-c20å†…å­˜æ¨¡å‹)
    - [4.2 å…³é”®å·®å¼‚](#42-å…³é”®å·®å¼‚)
  - [äº”ã€å½¢å¼åŒ–è¯­ä¹‰](#äº”å½¢å¼åŒ–è¯­ä¹‰)
    - [5.1 Promisingè¯­ä¹‰](#51-promisingè¯­ä¹‰)
    - [5.2 æ•°æ®ç«äº‰å®šä¹‰](#52-æ•°æ®ç«äº‰å®šä¹‰)
  - [å…­ã€åŒæ­¥åŸè¯­å®ç°](#å…­åŒæ­¥åŸè¯­å®ç°)
    - [6.1 è‡ªæ—‹é”](#61-è‡ªæ—‹é”)
    - [6.2 æ— é”æ ˆ](#62-æ— é”æ ˆ)
  - [ä¸ƒã€ä¸LSEM L1å±‚çš„æ˜ å°„](#ä¸ƒä¸lsem-l1å±‚çš„æ˜ å°„)
    - [7.1 æ—¶ç©ºæˆ³æ˜ å°„](#71-æ—¶ç©ºæˆ³æ˜ å°„)
    - [7.2 å¯è§æ€§è§„åˆ™æ˜ å°„](#72-å¯è§æ€§è§„åˆ™æ˜ å°„)
    - [7.3 ä¸L0å±‚å¯¹æ¯”](#73-ä¸l0å±‚å¯¹æ¯”)
  - [å…«ã€æ€§èƒ½åˆ†æ](#å…«æ€§èƒ½åˆ†æ)
    - [8.1 Orderingå¼€é”€å¯¹æ¯”](#81-orderingå¼€é”€å¯¹æ¯”)
    - [8.2 é”å¼€é”€å¯¹æ¯”](#82-é”å¼€é”€å¯¹æ¯”)
  - [ä¹ã€å¸¸è§æ¨¡å¼](#ä¹å¸¸è§æ¨¡å¼)
    - [æ¨¡å¼1: Lazy Initialization](#æ¨¡å¼1-lazy-initialization)
    - [æ¨¡å¼2: åŒé‡æ£€æŸ¥é”](#æ¨¡å¼2-åŒé‡æ£€æŸ¥é”)
    - [æ¨¡å¼3: Seqlock](#æ¨¡å¼3-seqlock)
  - [åã€æ€»ç»“](#åæ€»ç»“)
    - [10.1 æ ¸å¿ƒè´¡çŒ®](#101-æ ¸å¿ƒè´¡çŒ®)
    - [10.2 å…³é”®å…¬å¼](#102-å…³é”®å…¬å¼)
    - [10.3 è®¾è®¡åŸåˆ™](#103-è®¾è®¡åŸåˆ™)
  - [åä¸€ã€å»¶ä¼¸é˜…è¯»](#åä¸€å»¶ä¼¸é˜…è¯»)
  - [åäºŒã€å®Œæ•´å®ç°ä»£ç ](#åäºŒå®Œæ•´å®ç°ä»£ç )
    - [12.1 åŸå­æ“ä½œå®Œæ•´å®ç°](#121-åŸå­æ“ä½œå®Œæ•´å®ç°)
    - [12.2 è‡ªæ—‹é”å®Œæ•´å®ç°](#122-è‡ªæ—‹é”å®Œæ•´å®ç°)
    - [12.3 æ— é”æ•°æ®ç»“æ„å®ç°](#123-æ— é”æ•°æ®ç»“æ„å®ç°)
  - [åä¸‰ã€å®é™…åº”ç”¨æ¡ˆä¾‹](#åä¸‰å®é™…åº”ç”¨æ¡ˆä¾‹)
    - [13.1 æ¡ˆä¾‹: é«˜å¹¶å‘è®¡æ•°å™¨ï¼ˆåŸå­æ“ä½œï¼‰](#131-æ¡ˆä¾‹-é«˜å¹¶å‘è®¡æ•°å™¨åŸå­æ“ä½œ)
    - [13.2 æ¡ˆä¾‹: æ— é”é˜Ÿåˆ—ï¼ˆç”Ÿäº§-æ¶ˆè´¹ï¼‰](#132-æ¡ˆä¾‹-æ— é”é˜Ÿåˆ—ç”Ÿäº§-æ¶ˆè´¹)
  - [åå››ã€åä¾‹ä¸é”™è¯¯è®¾è®¡](#åå››åä¾‹ä¸é”™è¯¯è®¾è®¡)
    - [åä¾‹1: è¯¯ç”¨Relaxedæ’åºå¯¼è‡´æ•°æ®ç«äº‰](#åä¾‹1-è¯¯ç”¨relaxedæ’åºå¯¼è‡´æ•°æ®ç«äº‰)
    - [åä¾‹2: å¿½ç•¥å†…å­˜æ’åºå¯¼è‡´å¯è§æ€§é—®é¢˜](#åä¾‹2-å¿½ç•¥å†…å­˜æ’åºå¯¼è‡´å¯è§æ€§é—®é¢˜)
    - [åä¾‹3: è·¨å¹³å°å†…å­˜æ¨¡å‹å·®å¼‚è¢«å¿½ç•¥](#åä¾‹3-è·¨å¹³å°å†…å­˜æ¨¡å‹å·®å¼‚è¢«å¿½ç•¥)
    - [åä¾‹4: è¯¯ç”¨SeqCstå¯¼è‡´æ€§èƒ½ä¸‹é™](#åä¾‹4-è¯¯ç”¨seqcstå¯¼è‡´æ€§èƒ½ä¸‹é™)
    - [åä¾‹5: å¿½ç•¥ç¼–è¯‘å™¨ä¼˜åŒ–å¯¼è‡´é—®é¢˜](#åä¾‹5-å¿½ç•¥ç¼–è¯‘å™¨ä¼˜åŒ–å¯¼è‡´é—®é¢˜)
      - [ç¼–è¯‘å™¨é‡æ’åºçš„åŸå› ](#ç¼–è¯‘å™¨é‡æ’åºçš„åŸå› )
      - [è¯­è¨€æœºåˆ¶èƒŒæ™¯ï¼šRustå†…å­˜æ¨¡å‹](#è¯­è¨€æœºåˆ¶èƒŒæ™¯rustå†…å­˜æ¨¡å‹)
  - [åäº”ã€å†…å­˜æ¨¡å‹å¯è§†åŒ–](#åäº”å†…å­˜æ¨¡å‹å¯è§†åŒ–)
    - [15.1 å†…å­˜æ’åºå±‚æ¬¡æ¶æ„å›¾](#151-å†…å­˜æ’åºå±‚æ¬¡æ¶æ„å›¾)
    - [15.2 happens-beforeå…³ç³»å›¾](#152-happens-beforeå…³ç³»å›¾)
    - [15.3 å†…å­˜æ’åºé€‰æ‹©å†³ç­–æ ‘](#153-å†…å­˜æ’åºé€‰æ‹©å†³ç­–æ ‘)

---

## ä¸€ã€å†…å­˜æ¨¡å‹ç†è®ºèƒŒæ™¯ä¸æ¼”è¿›

### 0.1 ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜æ¨¡å‹ï¼Ÿ

**å†å²èƒŒæ™¯**:

åœ¨å¤šæ ¸å¤„ç†å™¨æ™®åŠä¹‹å‰ï¼ˆ2000å¹´ä»£ä¹‹å‰ï¼‰ï¼Œå•æ ¸å¤„ç†å™¨æ—¶ä»£ï¼Œç¨‹åºæ‰§è¡Œé¡ºåºä¸ä»£ç é¡ºåºåŸºæœ¬ä¸€è‡´ã€‚ä½†éšç€å¤šæ ¸å¤„ç†å™¨çš„æ™®åŠï¼ŒCPUç¼“å­˜ã€æŒ‡ä»¤é‡æ’åºã€å†…å­˜å¯è§æ€§ç­‰é—®é¢˜ä½¿å¾—å¤šçº¿ç¨‹ç¨‹åºçš„æ‰§è¡Œç»“æœå˜å¾—ä¸å¯é¢„æµ‹ã€‚è¿™ä¿ƒä½¿ç¼–ç¨‹è¯­è¨€å’Œç¡¬ä»¶å®šä¹‰äº†å†…å­˜æ¨¡å‹æ¥è§„èŒƒå¤šçº¿ç¨‹ç¨‹åºçš„è¯­ä¹‰ã€‚

**ç†è®ºåŸºç¡€**:

```text
å†…å­˜æ¨¡å‹çš„æ ¸å¿ƒé—®é¢˜:
â”œâ”€ é—®é¢˜: å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œæ“ä½œé¡ºåºä¸ç¡®å®š
â”œâ”€ æŒ‘æˆ˜: CPUç¼“å­˜ã€æŒ‡ä»¤é‡æ’åºã€å†…å­˜å¯è§æ€§
â””â”€ éœ€æ±‚: å®šä¹‰æ“ä½œä¹‹é—´çš„å¯è§æ€§å…³ç³»

ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜æ¨¡å‹?
â”œâ”€ æ— å†…å­˜æ¨¡å‹: ç¨‹åºè¡Œä¸ºä¸å¯é¢„æµ‹ï¼Œæ•°æ®ç«äº‰
â”œâ”€ é¡ºåºä¸€è‡´æ€§: æ­£ç¡®ä½†æ€§èƒ½æå·®ï¼ˆæ‰€æœ‰æ“ä½œä¸²è¡Œï¼‰
â””â”€ å†…å­˜æ¨¡å‹: æ—¢ä¿è¯æ­£ç¡®æ€§åˆå…è®¸ä¼˜åŒ–
```

**å®é™…åº”ç”¨èƒŒæ™¯**:

```text
å†…å­˜æ¨¡å‹æ¼”è¿›:
â”œâ”€ æ—©æœŸç³»ç»Ÿ (1990s)
â”‚   â”œâ”€ é—®é¢˜: å•æ ¸å¤„ç†å™¨ï¼Œé¡ºåºæ‰§è¡Œ
â”‚   â”œâ”€ æ¨¡å‹: é¡ºåºä¸€è‡´æ€§ï¼ˆéšå¼ï¼‰
â”‚   â””â”€ åœºæ™¯: æ— å¹¶å‘é—®é¢˜
â”‚
â”œâ”€ å¤šæ ¸æ—¶ä»£ (2000s)
â”‚   â”œâ”€ é—®é¢˜: å¤šæ ¸å¤„ç†å™¨ï¼Œç¼“å­˜ä¸€è‡´æ€§
â”‚   â”œâ”€ æŒ‘æˆ˜: æŒ‡ä»¤é‡æ’åºã€å†…å­˜å¯è§æ€§
â”‚   â””â”€ éœ€æ±‚: éœ€è¦æ˜ç¡®çš„å†…å­˜æ¨¡å‹
â”‚
â””â”€ ç°ä»£ç³»ç»Ÿ (2010s+)
    â”œâ”€ C++11: æ ‡å‡†å†…å­˜æ¨¡å‹
    â”œâ”€ Rust: å†…å­˜æ¨¡å‹ + æ‰€æœ‰æƒ
    â””â”€ åº”ç”¨: æ— é”ç¼–ç¨‹ã€é«˜æ€§èƒ½å¹¶å‘
```

**ä¸ºä»€ä¹ˆå†…å­˜æ¨¡å‹é‡è¦ï¼Ÿ**

1. **ç¨‹åºæ­£ç¡®æ€§**: ä¿è¯å¤šçº¿ç¨‹ç¨‹åºçš„æ­£ç¡®æ‰§è¡Œ
2. **æ€§èƒ½ä¼˜åŒ–**: å…è®¸ç¼–è¯‘å™¨/CPUè¿›è¡Œä¼˜åŒ–
3. **æ— é”ç¼–ç¨‹**: ä¸ºæ— é”æ•°æ®ç»“æ„æä¾›åŸºç¡€
4. **ç†è®ºåŸºç¡€**: ä¸ºç†è§£å¹¶å‘ç¨‹åºæä¾›å½¢å¼åŒ–åŸºç¡€

**åä¾‹: æ— å†…å­˜æ¨¡å‹çš„ç³»ç»Ÿé—®é¢˜**

```text
é”™è¯¯è®¾è®¡: å¿½ç•¥å†…å­˜æ¨¡å‹ï¼Œå‡è®¾é¡ºåºä¸€è‡´æ€§
â”œâ”€ åœºæ™¯: å¤šçº¿ç¨‹è®¡æ•°å™¨
â”œâ”€ é—®é¢˜: å‡è®¾æ‰€æœ‰æ“ä½œæŒ‰é¡ºåºæ‰§è¡Œ
â”œâ”€ ç»“æœ: å®é™…æ‰§è¡Œé¡ºåºä¸ç¡®å®š
â””â”€ åæœ: æ•°æ®ç«äº‰ï¼Œè®¡æ•°é”™è¯¯ âœ—

æ­£ç¡®è®¾è®¡: ä½¿ç”¨å†…å­˜æ¨¡å‹
â”œâ”€ åœºæ™¯: åŒæ ·çš„å¤šçº¿ç¨‹è®¡æ•°å™¨
â”œâ”€ æ–¹æ¡ˆ: ä½¿ç”¨åŸå­æ“ä½œ + å†…å­˜æ’åº
â”œâ”€ ç»“æœ: æ“ä½œé¡ºåºæ˜ç¡®ï¼Œæ— æ•°æ®ç«äº‰
â””â”€ æ­£ç¡®æ€§: è®¡æ•°å‡†ç¡® âœ“
```

### 0.2 å†…å­˜æ¨¡å‹çš„æ ¸å¿ƒçŸ›ç›¾

**æ€§èƒ½ vs æ­£ç¡®æ€§**:

```text
å†…å­˜æ¨¡å‹çš„æ ¸å¿ƒçŸ›ç›¾:
â”œâ”€ å¼ºæ’åº: ä¿è¯é¡ºåº â†’ æ€§èƒ½ä¸‹é™
â”œâ”€ å¼±æ’åº: å…è®¸é‡æ’åº â†’ å¯èƒ½é”™è¯¯
â””â”€ å¹³è¡¡: æ ¹æ®åœºæ™¯é€‰æ‹©åˆé€‚æ’åº

å®é™…æƒè¡¡:
â”œâ”€ è®¡æ•°å™¨: Relaxedï¼ˆæ€§èƒ½ä¼˜å…ˆï¼‰
â”œâ”€ åŒæ­¥åŸè¯­: Release-Acquireï¼ˆæ­£ç¡®æ€§ä¼˜å…ˆï¼‰
â””â”€ å…¨å±€åŒæ­¥: SeqCstï¼ˆæœ€å¼ºä¿è¯ï¼‰
```

### 0.3 ç¡¬ä»¶å†…å­˜æ¨¡å‹çš„èƒŒæ™¯

**ä¸ºä»€ä¹ˆç¡¬ä»¶éœ€è¦å†…å­˜æ¨¡å‹ï¼Ÿ**

```text
ç¡¬ä»¶å±‚é¢çš„é—®é¢˜:
â”œâ”€ CPUç¼“å­˜: æ¯ä¸ªæ ¸å¿ƒæœ‰ç‹¬ç«‹ç¼“å­˜
â”œâ”€ æŒ‡ä»¤é‡æ’åº: CPU/ç¼–è¯‘å™¨ä¼˜åŒ–
â”œâ”€ å†…å­˜å¯è§æ€§: ç¼“å­˜ä¸€è‡´æ€§åè®®
â””â”€ é—®é¢˜: å¤šçº¿ç¨‹ç¨‹åºè¡Œä¸ºä¸ç¡®å®š

ç¡¬ä»¶å†…å­˜æ¨¡å‹:
â”œâ”€ x86: TSOï¼ˆTotal Store Orderï¼‰
â”œâ”€ ARM: å¼±å†…å­˜æ¨¡å‹
â””â”€ å½±å“: ä¸åŒæ¶æ„è¡Œä¸ºä¸åŒ
```

**ç¡¬ä»¶ä½“ç³»è®¾è®¡æ·±åº¦èƒŒæ™¯**:

#### CPUç¼“å­˜å±‚æ¬¡ç»“æ„

**ç°ä»£CPUæ¶æ„**:

```text
CPUæ ¸å¿ƒæ¶æ„ (2020s):
â”œâ”€ L1ç¼“å­˜ (æ¯æ ¸å¿ƒ)
â”‚   â”œâ”€ L1d: æ•°æ®ç¼“å­˜ (32KB, 4å‘¨æœŸå»¶è¿Ÿ)
â”‚   â””â”€ L1i: æŒ‡ä»¤ç¼“å­˜ (32KB, 4å‘¨æœŸå»¶è¿Ÿ)
â”‚
â”œâ”€ L2ç¼“å­˜ (æ¯æ ¸å¿ƒ)
â”‚   â””â”€ ç»Ÿä¸€ç¼“å­˜ (256KB-1MB, 12å‘¨æœŸå»¶è¿Ÿ)
â”‚
â”œâ”€ L3ç¼“å­˜ (å…±äº«)
â”‚   â””â”€ æœ€åä¸€çº§ç¼“å­˜ (8-64MB, 40å‘¨æœŸå»¶è¿Ÿ)
â”‚
â””â”€ ä¸»å†…å­˜ (DRAM)
    â””â”€ 100-300å‘¨æœŸå»¶è¿Ÿ
```

**ç¼“å­˜ä¸€è‡´æ€§åè®® (MESI)**:

```text
MESIçŠ¶æ€æœº:
â”œâ”€ Modified (M): å·²ä¿®æ”¹ï¼Œä»…æœ¬æ ¸å¿ƒæœ‰æœ€æ–°æ•°æ®
â”œâ”€ Exclusive (E): ç‹¬å ï¼Œä»…æœ¬æ ¸å¿ƒæœ‰ï¼Œæœªä¿®æ”¹
â”œâ”€ Shared (S): å…±äº«ï¼Œå¤šä¸ªæ ¸å¿ƒæœ‰ï¼Œæœªä¿®æ”¹
â””â”€ Invalid (I): æ— æ•ˆï¼Œç¼“å­˜è¡Œæ— æ•ˆ

çŠ¶æ€è½¬æ¢:
â”œâ”€ è¯»æœªå‘½ä¸­: I â†’ S (å…±äº«) æˆ– I â†’ E (ç‹¬å )
â”œâ”€ å†™å‘½ä¸­: S â†’ M æˆ– E â†’ M
â”œâ”€ å†™æœªå‘½ä¸­: I â†’ M (éœ€è¦å…ˆè·å–æ‰€æœ‰æƒ)
â””â”€ å…¶ä»–æ ¸å¿ƒå†™: S â†’ I æˆ– E â†’ I
```

**ä¸ºä»€ä¹ˆéœ€è¦ç¼“å­˜ä¸€è‡´æ€§ï¼Ÿ**

```text
é—®é¢˜åœºæ™¯:
â”œâ”€ æ ¸å¿ƒ1: å†™ x = 1 (ç¼“å­˜åˆ°L1)
â”œâ”€ æ ¸å¿ƒ2: è¯» x (ä»L1è¯»ï¼Œä½†æ ¸å¿ƒ1çš„å†™æœªåŒæ­¥)
â””â”€ ç»“æœ: æ ¸å¿ƒ2è¯»åˆ°æ—§å€¼ x = 0 âœ—

MESIè§£å†³:
â”œâ”€ æ ¸å¿ƒ1å†™: å‘é€Invalidateæ¶ˆæ¯ç»™å…¶ä»–æ ¸å¿ƒ
â”œâ”€ æ ¸å¿ƒ2è¯»: æ£€æµ‹åˆ°ç¼“å­˜æ— æ•ˆï¼Œä»å†…å­˜/å…¶ä»–æ ¸å¿ƒè·å–
â””â”€ ç»“æœ: æ ¸å¿ƒ2è¯»åˆ°æ–°å€¼ x = 1 âœ“
```

#### æŒ‡ä»¤é‡æ’åºä¸å†…å­˜å±éšœ

**CPUæŒ‡ä»¤é‡æ’åºåŸå› **:

```text
ä¸ºä»€ä¹ˆCPUè¦é‡æ’åº?
â”œâ”€ æ€§èƒ½ä¼˜åŒ–: éšè—å†…å­˜å»¶è¿Ÿ
â”œâ”€ ä¹±åºæ‰§è¡Œ: è¶…æ ‡é‡æ¶æ„ï¼Œå¹¶è¡Œæ‰§è¡Œå¤šæ¡æŒ‡ä»¤
â”œâ”€ åˆ†æ”¯é¢„æµ‹: é¢„æµ‹åˆ†æ”¯ï¼Œæå‰æ‰§è¡Œ
â””â”€ ç»“æœ: æé«˜æŒ‡ä»¤ååé‡

é‡æ’åºç±»å‹:
â”œâ”€ ç¼–è¯‘å™¨é‡æ’åº: ç¼–è¯‘ä¼˜åŒ–ï¼ˆå¦‚å¾ªç¯å±•å¼€ï¼‰
â”œâ”€ CPUé‡æ’åº: ä¹±åºæ‰§è¡Œï¼ˆå¦‚Load-Loadé‡æ’åºï¼‰
â””â”€ å†…å­˜é‡æ’åº: ç¼“å­˜å»¶è¿Ÿï¼ˆå¦‚Store-Loadé‡æ’åºï¼‰
```

**å†…å­˜å±éšœ (Memory Barrier/Fence)**:

```text
å†…å­˜å±éšœç±»å‹:
â”œâ”€ Load Barrier (è¯»å±éšœ)
â”‚   â””â”€ ä¿è¯: å±éšœå‰çš„æ‰€æœ‰Loadåœ¨å±éšœåLoadä¹‹å‰å®Œæˆ
â”‚
â”œâ”€ Store Barrier (å†™å±éšœ)
â”‚   â””â”€ ä¿è¯: å±éšœå‰çš„æ‰€æœ‰Storeåœ¨å±éšœåStoreä¹‹å‰å®Œæˆ
â”‚
â”œâ”€ Full Barrier (å…¨å±éšœ)
â”‚   â””â”€ ä¿è¯: å±éšœå‰çš„æ‰€æœ‰æ“ä½œåœ¨å±éšœåæ“ä½œä¹‹å‰å®Œæˆ
â”‚
â””â”€ Acquire/Releaseè¯­ä¹‰
    â”œâ”€ Acquire: Loadå±éšœ + åç»­æ“ä½œä¸èƒ½æå‰
    â””â”€ Release: Storeå±éšœ + ä¹‹å‰æ“ä½œä¸èƒ½å»¶å
```

**ç¡¬ä»¶å®ç°**:

```text
x86æ¶æ„:
â”œâ”€ MFENCE: å…¨å±éšœï¼ˆæ‰€æœ‰å†…å­˜æ“ä½œï¼‰
â”œâ”€ LFENCE: Loadå±éšœï¼ˆä»…Loadæ“ä½œï¼‰
â”œâ”€ SFENCE: Storeå±éšœï¼ˆä»…Storeæ“ä½œï¼‰
â””â”€ LOCKå‰ç¼€: åŸå­æ“ä½œ + éšå¼å±éšœ

ARMæ¶æ„:
â”œâ”€ DMB (Data Memory Barrier): æ•°æ®å†…å­˜å±éšœ
â”œâ”€ DSB (Data Synchronization Barrier): æ•°æ®åŒæ­¥å±éšœ
â””â”€ ISB (Instruction Synchronization Barrier): æŒ‡ä»¤åŒæ­¥å±éšœ
```

#### åŸå­æ“ä½œç¡¬ä»¶å®ç°

**Compare-and-Swap (CAS) ç¡¬ä»¶å®ç°**:

```text
x86å®ç° (CMPXCHGæŒ‡ä»¤):
â”œâ”€ æŒ‡ä»¤: CMPXCHG dest, src
â”œâ”€ è¯­ä¹‰:
â”‚   if (dest == EAX) {
â”‚       dest = src;
â”‚       ZF = 1;  // æˆåŠŸ
â”‚   } else {
â”‚       EAX = dest;
â”‚       ZF = 0;  // å¤±è´¥
â”‚   }
â””â”€ åŸå­æ€§: LOCKå‰ç¼€ä¿è¯åŸå­æ€§

ARMå®ç° (LL/SC):
â”œâ”€ Load-Linked (LL): åŠ è½½å¹¶æ ‡è®°
â”œâ”€ Store-Conditional (SC): æ¡ä»¶å­˜å‚¨
â””â”€ åŸå­æ€§: ç¡¬ä»¶æ£€æµ‹å†²çªï¼Œå¤±è´¥åˆ™é‡è¯•
```

**åŸå­æ“ä½œæ€§èƒ½**:

```text
æ“ä½œå»¶è¿Ÿ (Intel Skylake):
â”œâ”€ æ™®é€šLoad: ~4ns (L1ç¼“å­˜å‘½ä¸­)
â”œâ”€ æ™®é€šStore: ~4ns (L1ç¼“å­˜å‘½ä¸­)
â”œâ”€ Atomic Load: ~4ns (æ— é¢å¤–å¼€é”€)
â”œâ”€ Atomic Store: ~4ns (æ— é¢å¤–å¼€é”€)
â”œâ”€ CAS (æˆåŠŸ): ~10ns (éœ€è¦ç¼“å­˜ä¸€è‡´æ€§)
â”œâ”€ CAS (å¤±è´¥): ~10ns (éœ€è¦ç¼“å­˜ä¸€è‡´æ€§)
â””â”€ Full Barrier: ~20ns (ç­‰å¾…æ‰€æœ‰æ“ä½œå®Œæˆ)
```

#### ä¸åŒç¡¬ä»¶æ¶æ„çš„å†…å­˜æ¨¡å‹

**x86 TSO (Total Store Order)**:

```text
TSOç‰¹æ€§:
â”œâ”€ ä¿è¯: Storeæ“ä½œå¯¹æ‰€æœ‰æ ¸å¿ƒæŒ‰ç›¸åŒé¡ºåºå¯è§
â”œâ”€ å…è®¸: Load-Loadé‡æ’åºï¼ˆå¾ˆå°‘ï¼‰
â”œâ”€ å…è®¸: Load-Storeé‡æ’åºï¼ˆå¾ˆå°‘ï¼‰
â”œâ”€ å…è®¸: Store-Loadé‡æ’åºï¼ˆå¸¸è§ï¼‰
â””â”€ å½±å“: åœ¨x86ä¸Šï¼Œå¾ˆå¤šå¹¶å‘bugä¸ä¼šæš´éœ²

TSOç¤ºä¾‹:
â”œâ”€ çº¿ç¨‹1: x = 1; y = 2;
â”œâ”€ çº¿ç¨‹2: r1 = y; r2 = x;
â””â”€ å¯èƒ½: r1 = 2, r2 = 0 (Store-Loadé‡æ’åº)
```

**ARMå¼±å†…å­˜æ¨¡å‹**:

```text
ARMç‰¹æ€§:
â”œâ”€ å…è®¸: Load-Loadé‡æ’åº
â”œâ”€ å…è®¸: Load-Storeé‡æ’åº
â”œâ”€ å…è®¸: Store-Loadé‡æ’åº
â”œâ”€ å…è®¸: Store-Storeé‡æ’åº
â””â”€ å½±å“: éœ€è¦æ˜¾å¼å†…å­˜å±éšœä¿è¯é¡ºåº

ARMç¤ºä¾‹:
â”œâ”€ çº¿ç¨‹1: x = 1; y = 2;
â”œâ”€ çº¿ç¨‹2: r1 = y; r2 = x;
â””â”€ å¯èƒ½: r1 = 2, r2 = 0 (å¤šç§é‡æ’åºç»„åˆ)
```

**Power/PPCå†…å­˜æ¨¡å‹**:

```text
Powerç‰¹æ€§:
â”œâ”€ å…è®¸: æ‰€æœ‰ç±»å‹çš„é‡æ’åº
â”œâ”€ å…è®¸: å†™æ“ä½œå¯è§æ€§å»¶è¿Ÿ
â”œâ”€ å…è®¸: è¯»æ“ä½œå¯èƒ½çœ‹åˆ°æœªæ¥çš„å†™
â””â”€ å½±å“: æœ€å¼±çš„å†…å­˜æ¨¡å‹ï¼Œéœ€è¦æœ€å¤šå±éšœ
```

#### ç¡¬ä»¶å†…å­˜æ¨¡å‹å¯¹ç¼–ç¨‹çš„å½±å“

**åä¾‹: å¿½ç•¥ç¡¬ä»¶å·®å¼‚å¯¼è‡´çš„é—®é¢˜**:

```text
é”™è¯¯åœºæ™¯:
â”œâ”€ å¼€å‘: x86å¹³å°ï¼ˆTSOæ¨¡å‹ï¼‰
â”œâ”€ ä»£ç : ä½¿ç”¨Relaxedæ’åºï¼Œæµ‹è¯•é€šè¿‡
â”œâ”€ éƒ¨ç½²: ARMæœåŠ¡å™¨ï¼ˆå¼±å†…å­˜æ¨¡å‹ï¼‰
â”œâ”€ é—®é¢˜: åœ¨ARMä¸Šå‡ºç°æ•°æ®ç«äº‰
â””â”€ åæœ: ç”Ÿäº§ç¯å¢ƒæ•°æ®é”™è¯¯ âœ—

å®é™…æ¡ˆä¾‹:
â”œâ”€ ç³»ç»Ÿ: è·¨å¹³å°æ— é”é˜Ÿåˆ—
â”œâ”€ å¼€å‘: x86å¹³å°ï¼Œä½¿ç”¨Relaxedæ’åº
â”œâ”€ æµ‹è¯•: x86å¹³å°æµ‹è¯•é€šè¿‡
â”œâ”€ éƒ¨ç½²: ARMäº‘æœåŠ¡å™¨
â”œâ”€ é—®é¢˜: ARMå¼±å†…å­˜æ¨¡å‹å¯¼è‡´é˜Ÿåˆ—æŸå
â””â”€ åæœ: æ¶ˆæ¯ä¸¢å¤±ï¼Œç³»ç»Ÿæ•…éšœ âœ—

æ­£ç¡®è®¾è®¡:
â”œâ”€ æ–¹æ¡ˆ: ä½¿ç”¨æ ‡å‡†å†…å­˜æ¨¡å‹ï¼ˆC++11/Rustï¼‰
â”œâ”€ å®ç°: Release-Acquireä¿è¯è·¨å¹³å°ä¸€è‡´æ€§
â””â”€ ç»“æœ: x86å’ŒARMè¡Œä¸ºä¸€è‡´ âœ“
```

**ç¡¬ä»¶æŠ½è±¡å±‚çš„é‡è¦æ€§**:

```text
ä¸ºä»€ä¹ˆéœ€è¦ç¡¬ä»¶æŠ½è±¡?
â”œâ”€ é—®é¢˜: ä¸åŒç¡¬ä»¶è¡Œä¸ºä¸åŒ
â”œâ”€ æŒ‘æˆ˜: ç›´æ¥ä½¿ç”¨ç¡¬ä»¶ç‰¹æ€§å¯¼è‡´ä¸å¯ç§»æ¤
â””â”€ è§£å†³: ç¼–ç¨‹è¯­è¨€æä¾›ç»Ÿä¸€å†…å­˜æ¨¡å‹

æŠ½è±¡å±‚æ¬¡:
â”œâ”€ ç¡¬ä»¶å±‚: x86 TSO, ARMå¼±æ¨¡å‹, Poweræœ€å¼±
â”œâ”€ è¯­è¨€å±‚: C++11/Rustç»Ÿä¸€æ¨¡å‹
â””â”€ åº”ç”¨å±‚: ä½¿ç”¨è¯­è¨€æ¨¡å‹ï¼Œä¸å…³å¿ƒç¡¬ä»¶ç»†èŠ‚
```

---

## äºŒã€å†…å­˜æ¨¡å‹åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯å†…å­˜æ¨¡å‹

**å®šä¹‰1.1 (å†…å­˜æ¨¡å‹)**:

$$MemoryModel: \text{Formal specification of memory operations' semantics in concurrent programs}$$

**æ ¸å¿ƒé—®é¢˜**: åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œ**ä»€ä¹ˆé¡ºåºçš„æ“ä½œå¯¹å…¶ä»–çº¿ç¨‹å¯è§**ï¼Ÿ

**ç¤ºä¾‹é—®é¢˜**:

```rust
// çº¿ç¨‹1
x = 1;  // (1)
y = 2;  // (2)

// çº¿ç¨‹2
r1 = y;  // (3)
r2 = x;  // (4)

// é—®: èƒ½å¦å‡ºç° r1 = 2 ä¸” r2 = 0 ï¼Ÿ
```

**ä¸åŒå†…å­˜æ¨¡å‹çš„ç­”æ¡ˆ**:

- **é¡ºåºä¸€è‡´æ€§ (SC)**: ä¸å¯èƒ½
- **å®½æ¾æ¨¡å‹ (Relaxed)**: å¯èƒ½ï¼

### 1.2 happens-beforeå…³ç³»

**å®šä¹‰1.2 (happens-before)**:

$$e_1 \xrightarrow{hb} e_2 \iff e_1 \text{ is visible to } e_2$$

**æ€§è´¨**:

- **ä¼ é€’æ€§**: $e_1 \xrightarrow{hb} e_2 \land e_2 \xrightarrow{hb} e_3 \implies e_1 \xrightarrow{hb} e_3$
- **éè‡ªåæ€§**: $\neg(e \xrightarrow{hb} e)$
- **åå¯¹ç§°æ€§**: $e_1 \xrightarrow{hb} e_2 \implies \neg(e_2 \xrightarrow{hb} e_1)$

**happens-beforeæ¥æº**:

1. **ç¨‹åºé¡ºåº** (Program Order):
   $$\text{Same thread: } op_1 \text{ before } op_2 \implies op_1 \xrightarrow{po} op_2$$

2. **åŒæ­¥æ“ä½œ** (Synchronization):
   $$\text{Release} \xrightarrow{sync} \text{Acquire}$$

3. **ä¼ é€’é—­åŒ…**:
   $$e_1 \xrightarrow{po} e_2 \xrightarrow{sync} e_3 \implies e_1 \xrightarrow{hb} e_3$$

---

## äºŒã€Rustå†…å­˜æ’åº

### 2.1 Orderingç±»å‹

**å®šä¹‰2.1 (Orderingæšä¸¾)**:

```rust
pub enum Ordering {
    Relaxed,   // æœ€å¼±
    Release,   // å†™å±éšœ
    Acquire,   // è¯»å±éšœ
    AcqRel,    // è¯»å†™å±éšœ
    SeqCst,    // æœ€å¼ºï¼ˆé¡ºåºä¸€è‡´æ€§ï¼‰
}
```

**å±‚æ¬¡å…³ç³»**:

```text
SeqCst (å…¨å±€é¡ºåº)
    â†“ å¼ºäº
AcqRel (è¯»å†™åŒæ­¥)
    â†“ å¼ºäº
Release / Acquire (å•å‘åŒæ­¥)
    â†“ å¼ºäº
Relaxed (ä»…åŸå­æ€§)
```

### 2.2 Relaxedæ’åº

**è¯­ä¹‰**: ä»…ä¿è¯åŸå­æ€§ï¼Œ**æ— åŒæ­¥ä¿è¯**

```rust
use std::sync::atomic::{AtomicI64, Ordering};

static X: AtomicI64 = AtomicI64::new(0);
static Y: AtomicI64 = AtomicI64::new(0);

// çº¿ç¨‹1
fn thread1() {
    X.store(1, Ordering::Relaxed);  // (1)
    Y.store(1, Ordering::Relaxed);  // (2)
}

// çº¿ç¨‹2
fn thread2() {
    let r1 = Y.load(Ordering::Relaxed);  // (3)
    let r2 = X.load(Ordering::Relaxed);  // (4)

    // å¯èƒ½: r1 = 1, r2 = 0
    // åŸå› : (1)(2) å¯èƒ½è¢«ç¼–è¯‘å™¨/CPUé‡æ’åº
}
```

**é€‚ç”¨åœºæ™¯**:

- âœ… ç®€å•è®¡æ•°å™¨ï¼ˆä¸ä¾èµ–é¡ºåºï¼‰
- âœ… ç»Ÿè®¡ä¿¡æ¯ï¼ˆå…è®¸çŸ­æš‚ä¸ä¸€è‡´ï¼‰
- âŒ åŒæ­¥æ ‡å¿—ï¼ˆéœ€è¦Release/Acquireï¼‰

**æ€§èƒ½**: æœ€å¿«ï¼ˆ~10nsï¼‰

### 2.3 Release-Acquireæ’åº

**è¯­ä¹‰**: å»ºç«‹**åŒæ­¥ç‚¹**ï¼ŒReleaseä¹‹å‰çš„æ‰€æœ‰å†™æ“ä½œå¯¹Acquireä¹‹åçš„æ“ä½œå¯è§

**å½¢å¼åŒ–**:

$$\text{store}(x, v, Release) \xrightarrow{sync} \text{load}(x, v, Acquire)$$

$$\implies \forall w \prec_{po} store: w \xrightarrow{hb} load$$

**ç¤ºä¾‹**:

```rust
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};

static DATA: AtomicI64 = AtomicI64::new(0);
static FLAG: AtomicBool = AtomicBool::new(false);

// ç”Ÿäº§è€…
fn producer() {
    DATA.store(42, Ordering::Relaxed);      // (1) å†™æ•°æ®
    FLAG.store(true, Ordering::Release);    // (2) Release: åŒæ­¥ç‚¹

    // ä¿è¯: (1) happens-before (2)
}

// æ¶ˆè´¹è€…
fn consumer() {
    while !FLAG.load(Ordering::Acquire) {   // (3) Acquire: åŒæ­¥ç‚¹
        // è‡ªæ—‹ç­‰å¾…
    }

    let value = DATA.load(Ordering::Relaxed);  // (4) è¯»æ•°æ®
    assert_eq!(value, 42);  // âœ… ä¿è¯çœ‹åˆ°42

    // å› ä¸º: (2) sync-with (3), æ‰€ä»¥ (1) happens-before (4)
}
```

**happens-beforeé“¾**:

```text
Thread 1:
(1) DATA.store(42, Relaxed)
    â†“ (program order)
(2) FLAG.store(true, Release)
    â†“ (synchronizes-with)
Thread 2:
(3) FLAG.load(Acquire)
    â†“ (program order)
(4) DATA.load(Relaxed)

ç»“è®º: (1) happens-before (4)
```

**é€‚ç”¨åœºæ™¯**:

- âœ… è‡ªæ—‹é”å®ç°
- âœ… æ— é”æ•°æ®ç»“æ„
- âœ… å‘å¸ƒ-è®¢é˜…æ¨¡å¼

**æ€§èƒ½**: ä¸­ç­‰ï¼ˆ~30nsï¼‰

### 2.4 AcqRelæ’åº

**è¯­ä¹‰**: åŒæ—¶å…·æœ‰Releaseå’ŒAcquireè¯­ä¹‰

```rust
use std::sync::atomic::{AtomicI64, Ordering};

static COUNTER: AtomicI64 = AtomicI64::new(0);

fn compare_and_swap() {
    let mut current = COUNTER.load(Ordering::Relaxed);

    loop {
        // AcqRel: è¯»å–æœ€æ–°å€¼(Acquire) + å‘å¸ƒæ›´æ–°(Release)
        match COUNTER.compare_exchange(
            current,
            current + 1,
            Ordering::AcqRel,  // æˆåŠŸæ—¶çš„ordering
            Ordering::Acquire  // å¤±è´¥æ—¶çš„ordering
        ) {
            Ok(_) => break,
            Err(x) => current = x,  // é‡è¯•
        }
    }
}
```

**é€‚ç”¨åœºæ™¯**:

- âœ… Compare-and-Swapæ“ä½œ
- âœ… Fetch-Addç­‰RMWï¼ˆRead-Modify-Writeï¼‰

**æ€§èƒ½**: ä¸­ç­‰ï¼ˆ~40nsï¼‰

### 2.5 SeqCstæ’åº

**è¯­ä¹‰**: **é¡ºåºä¸€è‡´æ€§**ï¼Œæ‰€æœ‰çº¿ç¨‹çœ‹åˆ°å…¨å±€ç»Ÿä¸€çš„æ“ä½œé¡ºåº

**å½¢å¼åŒ–**:

$$\forall \text{threads}: \exists \text{global total order} \prec_s: $$
$$\forall op_1, op_2: op_1 \prec_s op_2 \implies \text{all threads see } op_1 \text{ before } op_2$$

**ç¤ºä¾‹**:

```rust
use std::sync::atomic::{AtomicBool, Ordering};

static X: AtomicBool = AtomicBool::new(false);
static Y: AtomicBool = AtomicBool::new(false);

// çº¿ç¨‹1
fn thread1() {
    X.store(true, Ordering::SeqCst);
}

// çº¿ç¨‹2
fn thread2() {
    Y.store(true, Ordering::SeqCst);
}

// çº¿ç¨‹3
fn thread3() {
    while !X.load(Ordering::SeqCst) {}  // ç­‰å¾…X=true

    if Y.load(Ordering::SeqCst) {
        println!("Y is true");
    } else {
        println!("Y is false");
    }
}

// çº¿ç¨‹4
fn thread4() {
    while !Y.load(Ordering::SeqCst) {}  // ç­‰å¾…Y=true

    if X.load(Ordering::SeqCst) {
        println!("X is true");
    } else {
        println!("X is false");
    }
}

// SeqCstä¿è¯: ä¸å¯èƒ½ä¸¤ä¸ªçº¿ç¨‹éƒ½è¾“å‡º"is false"
// è‡³å°‘ä¸€ä¸ªçº¿ç¨‹ä¼šçœ‹åˆ°å¦ä¸€ä¸ªçš„å†™å…¥
```

**é€‚ç”¨åœºæ™¯**:

- âœ… éœ€è¦å…¨å±€ä¸€è‡´æ€§çš„æ ‡å¿—
- âœ… è°ƒè¯•å¹¶å‘ç¨‹åºï¼ˆæœ€å®‰å…¨ï¼‰
- âŒ æ€§èƒ½æ•æ„Ÿè·¯å¾„ï¼ˆå¼€é”€å¤§ï¼‰

**æ€§èƒ½**: æœ€æ…¢ï¼ˆ~80nsï¼Œéœ€è¦å†…å­˜å±éšœï¼‰

---

## ä¸‰ã€å†…å­˜å±éšœ

### 3.1 ç¡¬ä»¶å±‚é¢

**å®šä¹‰3.1 (å†…å­˜å±éšœ)**:

$$MemoryBarrier: \text{CPU instruction that enforces ordering}$$

**ç±»å‹**:

| å±éšœç±»å‹ | x86-64æŒ‡ä»¤ | ARMæŒ‡ä»¤ | ä½œç”¨ |
|---------|-----------|---------|------|
| **Loadå±éšœ** | `lfence` | `DMB LD` | é˜²æ­¢åç»­loadé‡æ’åˆ°å‰é¢ |
| **Storeå±éšœ** | `sfence` | `DMB ST` | é˜²æ­¢åç»­storeé‡æ’åˆ°å‰é¢ |
| **Fullå±éšœ** | `mfence` | `DMB SY` | é˜²æ­¢æ‰€æœ‰é‡æ’åº |

**Rust Orderingåˆ°ç¡¬ä»¶æŒ‡ä»¤**:

| Rust Ordering | x86-64 | ARM |
|--------------|--------|-----|
| Relaxed | æ— å±éšœ | æ— å±éšœ |
| Acquire | æ— å±éšœ* | `DMB LD` |
| Release | æ— å±éšœ* | `DMB ST` |
| AcqRel | æ— å±éšœ* | `DMB` |
| SeqCst | `mfence` | `DMB SY` |

*x86-64æ˜¯å¼ºå†…å­˜æ¨¡å‹ï¼Œå¾ˆå¤šorderingæ— éœ€æ˜¾å¼å±éšœ

### 3.2 ç¼–è¯‘å™¨å±éšœ

**ä½œç”¨**: é˜²æ­¢**ç¼–è¯‘å™¨é‡æ’åº**

```rust
// Rustä¸­æ‰€æœ‰åŸå­æ“ä½œéƒ½æ˜¯ç¼–è¯‘å™¨å±éšœ
std::sync::atomic::compiler_fence(Ordering::SeqCst);

// ç­‰ä»·äºC++
std::atomic_signal_fence(std::memory_order_seq_cst);
```

---

## å››ã€ä¸C++å†…å­˜æ¨¡å‹å¯¹æ¯”

### 4.1 C++20å†…å­˜æ¨¡å‹

**Orderingå¯¹åº”**:

| Rust | C++20 | è¯´æ˜ |
|------|-------|------|
| `Relaxed` | `memory_order_relaxed` | å®Œå…¨ç›¸åŒ |
| `Acquire` | `memory_order_acquire` | å®Œå…¨ç›¸åŒ |
| `Release` | `memory_order_release` | å®Œå…¨ç›¸åŒ |
| `AcqRel` | `memory_order_acq_rel` | å®Œå…¨ç›¸åŒ |
| `SeqCst` | `memory_order_seq_cst` | å®Œå…¨ç›¸åŒ |

Rustéµå¾ª**C++å†…å­˜æ¨¡å‹**ï¼

### 4.2 å…³é”®å·®å¼‚

**å·®å¼‚1**: Rustå…è®¸åŸå­ä¸éåŸå­è¯»å¹¶å‘

```cpp
// C++: æœªå®šä¹‰è¡Œä¸º
std::atomic<int> x;
x.store(1, std::memory_order_relaxed);
int y = x;  // âŒ UB: éåŸå­è¯»åŸå­å˜é‡

// Rust: å…è®¸ï¼ˆä½†ä¸æ¨èï¼‰
let x = AtomicI32::new(0);
x.store(1, Ordering::Relaxed);
// unsafe { *(x.as_ptr()) }  // âš ï¸ å…è®¸ä½†å±é™©
```

**å·®å¼‚2**: RuståŸºäº**è®¿é—®**è€Œé**å¯¹è±¡**

```rust
// Rust: å¤šä¸ªç‹¬ç«‹çš„åŸå­å˜é‡å¯ä»¥å¹¶å‘è®¿é—®
struct Data {
    x: AtomicI32,
    y: AtomicI32,
}

// çº¿ç¨‹1: è®¿é—®x
data.x.store(1, Ordering::Relaxed);

// çº¿ç¨‹2: è®¿é—®y (âœ… æ— æ•°æ®ç«äº‰)
data.y.store(2, Ordering::Relaxed);
```

---

## äº”ã€å½¢å¼åŒ–è¯­ä¹‰

### 5.1 Promisingè¯­ä¹‰

**æ ¸å¿ƒæ€æƒ³**: æ“ä½œå¯ä»¥"æ‰¿è¯º"æœªæ¥çš„å†™å…¥

**å½¢å¼åŒ–æ¨¡å‹**:

$$State = (Memory, Promises, ThreadStates)$$

**çŠ¶æ€è½¬æ¢**:

```text
Thread i æ‰§è¡Œ store(x, v, Release):
1. æ·»åŠ æ‰¿è¯º: Promises += {(x, v, t)}
2. ç­‰å¾…æ‰¿è¯ºå…‘ç°
3. å†™å…¥å†…å­˜: Memory[x] = v
4. ç§»é™¤æ‰¿è¯º: Promises -= {(x, v, t)}
```

**å®šç†5.1 (Promisingè¯­ä¹‰æ­£ç¡®æ€§)**:

$$\forall \text{well-formed programs}: \text{Promising semantics} \equiv \text{C++11 semantics}$$

è¯æ˜è§: Kang et al. (2017) "A Promising Semantics for Relaxed-Memory Concurrency"

### 5.2 æ•°æ®ç«äº‰å®šä¹‰

**å®šä¹‰5.2 (æ•°æ®ç«äº‰)**:

$$DataRace \iff \exists op_1, op_2: $$
$$\neg(op_1 \xrightarrow{hb} op_2) \land \neg(op_2 \xrightarrow{hb} op_1) \land$$
$$\text{SameLocation}(op_1, op_2) \land (\text{IsWrite}(op_1) \lor \text{IsWrite}(op_2))$$

**é€šä¿—è§£é‡Š**: ä¸¤ä¸ª**å¹¶å‘**æ“ä½œè®¿é—®**åŒä¸€ä½ç½®**ï¼Œä¸”è‡³å°‘ä¸€ä¸ªæ˜¯**å†™**

**Rustä¿è¯**: å€Ÿç”¨æ£€æŸ¥å™¨åœ¨**ç¼–è¯‘æœŸæœç»æ•°æ®ç«äº‰**

---

## å…­ã€åŒæ­¥åŸè¯­å®ç°

### 6.1 è‡ªæ—‹é”

```rust
use std::sync::atomic::{AtomicBool, Ordering};

pub struct SpinLock {
    locked: AtomicBool,
}

impl SpinLock {
    pub const fn new() -> Self {
        SpinLock {
            locked: AtomicBool::new(false),
        }
    }

    pub fn lock(&self) {
        // è‡ªæ—‹ç›´åˆ°è·å–é”
        while self.locked.swap(true, Ordering::Acquire) {
            // æç¤ºCPU: è‡ªæ—‹ç­‰å¾…ï¼ˆé™ä½åŠŸè€—ï¼‰
            std::hint::spin_loop();
        }
        // è·å–é”åï¼ŒAcquireä¿è¯ä¹‹å‰çš„Releaseæ“ä½œå¯è§
    }

    pub fn unlock(&self) {
        // Releaseä¿è¯ä¸´ç•ŒåŒºå†…çš„æ“ä½œå¯¹åç»­Acquireå¯è§
        self.locked.store(false, Ordering::Release);
    }
}
```

**happens-beforeåˆ†æ**:

```text
Thread A:
lock()  // Acquire
  critical_section()
unlock()  // Release
    â†“ (synchronizes-with)
Thread B:
lock()  // Acquire
  critical_section()
unlock()
```

### 6.2 æ— é”æ ˆ

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

pub struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> LockFreeStack<T> {
    pub fn new() -> Self {
        LockFreeStack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    pub fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        let mut head = self.head.load(Ordering::Relaxed);

        loop {
            unsafe {
                (*new_node).next = head;
            }

            // AcqRel: è¯»å–æœ€æ–°head + å‘å¸ƒæ–°èŠ‚ç‚¹
            match self.head.compare_exchange(
                head,
                new_node,
                Ordering::AcqRel,  // æˆåŠŸ
                Ordering::Acquire  // å¤±è´¥ï¼Œé‡æ–°è¯»å–head
            ) {
                Ok(_) => break,
                Err(h) => head = h,  // é‡è¯•
            }
        }
    }

    pub fn pop(&self) -> Option<T> {
        let mut head = self.head.load(Ordering::Acquire);

        loop {
            if head.is_null() {
                return None;
            }

            let next = unsafe { (*head).next };

            match self.head.compare_exchange(
                head,
                next,
                Ordering::AcqRel,
                Ordering::Acquire
            ) {
                Ok(_) => {
                    let data = unsafe { Box::from_raw(head).data };
                    return Some(data);
                }
                Err(h) => head = h,
            }
        }
    }
}
```

**ABAé—®é¢˜**: éœ€è¦é¢å¤–çš„ç‰ˆæœ¬å·æˆ–Epochå›æ”¶

---

## ä¸ƒã€ä¸LSEM L1å±‚çš„æ˜ å°„

### 7.1 æ—¶ç©ºæˆ³æ˜ å°„

| LSEM L1 | Rustå†…å­˜æ¨¡å‹ |
|---------|-------------|
| **æ—¶é—´æˆ³** | Orderingçº§åˆ« |
| **ååºå…³ç³»** | happens-before |
| **å¯è§æ€§** | åŒæ­¥ç‚¹å»ºç«‹çš„å¯è§æ€§ |
| **å†²çª** | æ•°æ®ç«äº‰ |

### 7.2 å¯è§æ€§è§„åˆ™æ˜ å°„

**L1å¯è§æ€§è§„åˆ™**:

$$Visible_{L1}(op_1, op_2) \iff op_1 \xrightarrow{hb} op_2$$

**å®ç°**:

```rust
// ç¼–è¯‘å™¨å’ŒCPUå…±åŒä¿è¯happens-before
fn visibility_guarantee() {
    // å†™çº¿ç¨‹
    DATA.store(42, Ordering::Relaxed);
    FLAG.store(true, Ordering::Release);  // â† åŒæ­¥ç‚¹

    // è¯»çº¿ç¨‹
    if FLAG.load(Ordering::Acquire) {     // â† åŒæ­¥ç‚¹
        let value = DATA.load(Ordering::Relaxed);
        // ä¿è¯: value = 42
    }
}
```

### 7.3 ä¸L0å±‚å¯¹æ¯”

| ç»´åº¦ | L0 (PostgreSQL) | L1 (Rust) |
|-----|----------------|-----------|
| **æ—¶åºä¿è¯** | äº‹åŠ¡IDå…¨åº | happens-beforeååº |
| **å¯è§æ€§æ£€æŸ¥** | è¿è¡Œæ—¶ï¼ˆæŸ¥pg_clogï¼‰ | ç¼–è¯‘æœŸ+ç¡¬ä»¶å±éšœ |
| **å†²çªæ£€æµ‹** | è¿è¡Œæ—¶ï¼ˆé”ç®¡ç†å™¨ï¼‰ | ç¼–è¯‘æœŸï¼ˆå€Ÿç”¨æ£€æŸ¥ï¼‰ |
| **æ€§èƒ½å¼€é”€** | ä¸­ï¼ˆå¿«ç…§ç»´æŠ¤ï¼‰ | ä½ï¼ˆé›¶æŠ½è±¡ï¼‰ |

---

## å…«ã€æ€§èƒ½åˆ†æ

### 8.1 Orderingå¼€é”€å¯¹æ¯”

**å®éªŒè®¾ç½®**: 1äº¿æ¬¡åŸå­æ“ä½œ

| Ordering | æ—¶é—´ (ms) | ç›¸å¯¹å¼€é”€ |
|----------|-----------|---------|
| Relaxed | 1000 | 1.0Ã— |
| Acquire | 1200 | 1.2Ã— |
| Release | 1200 | 1.2Ã— |
| AcqRel | 1500 | 1.5Ã— |
| SeqCst | 2500 | 2.5Ã— |

**ç»“è®º**: SeqCstå¼€é”€æœ€å¤§ï¼ŒRelaxedæœ€å¿«

### 8.2 é”å¼€é”€å¯¹æ¯”

| åŒæ­¥æœºåˆ¶ | æ— ç«äº‰ | æœ‰ç«äº‰ |
|---------|--------|--------|
| **Atomic CAS** | 10ns | 50ns |
| **SpinLock** | 50ns | 500ns |
| **Mutex** | 50ns | 5000ns |
| **RwLock** | 30ns | 1000ns |

**å»ºè®®**: ä¸´ç•ŒåŒº<100nsç”¨SpinLockï¼Œå¦åˆ™ç”¨Mutex

---

## ä¹ã€å¸¸è§æ¨¡å¼

### æ¨¡å¼1: Lazy Initialization

```rust
use std::sync::{Arc, Once};

static INIT: Once = Once::new();
static mut DATA: Option<Vec<i32>> = None;

fn get_data() -> &'static Vec<i32> {
    unsafe {
        INIT.call_once(|| {
            DATA = Some(vec![1, 2, 3]);
        });
        DATA.as_ref().unwrap()
    }
}
```

**happens-before**: `call_once`å†…çš„æ“ä½œå¯¹æ‰€æœ‰åç»­è°ƒç”¨å¯è§

### æ¨¡å¼2: åŒé‡æ£€æŸ¥é”

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::sync::Mutex;

struct LazyValue {
    ptr: AtomicPtr<Data>,
    lock: Mutex<()>,
}

impl LazyValue {
    fn get(&self) -> &Data {
        // ç¬¬ä¸€æ¬¡æ£€æŸ¥ï¼ˆå¿«é€Ÿè·¯å¾„ï¼‰
        let ptr = self.ptr.load(Ordering::Acquire);
        if !ptr.is_null() {
            return unsafe { &*ptr };
        }

        // åŠ é”åˆå§‹åŒ–
        let _guard = self.lock.lock().unwrap();

        // ç¬¬äºŒæ¬¡æ£€æŸ¥ï¼ˆé˜²æ­¢é‡å¤åˆå§‹åŒ–ï¼‰
        let ptr = self.ptr.load(Ordering::Relaxed);
        if !ptr.is_null() {
            return unsafe { &*ptr };
        }

        // åˆå§‹åŒ–
        let data = Box::into_raw(Box::new(Data::new()));
        self.ptr.store(data, Ordering::Release);

        unsafe { &*data }
    }
}
```

### æ¨¡å¼3: Seqlock

```rust
struct SeqLock<T> {
    seq: AtomicUsize,
    data: UnsafeCell<T>,
}

impl<T: Copy> SeqLock<T> {
    fn read(&self) -> T {
        loop {
            let seq1 = self.seq.load(Ordering::Acquire);

            if seq1 % 2 == 1 {
                // å†™æ“ä½œè¿›è¡Œä¸­ï¼Œé‡è¯•
                std::hint::spin_loop();
                continue;
            }

            let data = unsafe { *self.data.get() };

            let seq2 = self.seq.load(Ordering::Acquire);

            if seq1 == seq2 {
                return data;  // è¯»å–æˆåŠŸ
            }
            // å¦åˆ™é‡è¯•
        }
    }

    fn write(&self, value: T) {
        let seq = self.seq.fetch_add(1, Ordering::Release);
        // seqç°åœ¨æ˜¯å¥‡æ•°ï¼Œè¡¨ç¤ºå†™å…¥ä¸­

        unsafe {
            *self.data.get() = value;
        }

        self.seq.store(seq + 2, Ordering::Release);
        // seqç°åœ¨æ˜¯å¶æ•°ï¼Œè¡¨ç¤ºå†™å…¥å®Œæˆ
    }
}
```

**é€‚ç”¨åœºæ™¯**: è¯»å¤šå†™å°‘ï¼ˆå¦‚é…ç½®æ›´æ–°ï¼‰

---

## åã€æ€»ç»“

### 10.1 æ ¸å¿ƒè´¡çŒ®

**ç†è®ºè´¡çŒ®**:

1. **happens-beforeå½¢å¼åŒ–**ï¼ˆç¬¬ä¸€ç« ï¼‰
2. **Orderingè¯­ä¹‰è¯¦è§£**ï¼ˆç¬¬äºŒç« ï¼‰
3. **å†…å­˜å±éšœåˆ†æ**ï¼ˆç¬¬ä¸‰ç« ï¼‰
4. **ä¸LSEM L1æ˜ å°„**ï¼ˆç¬¬ä¸ƒç« ï¼‰

**å·¥ç¨‹ä»·å€¼**:

1. **è‡ªæ—‹é”å®ç°**ï¼ˆç¬¬6.1èŠ‚ï¼‰
2. **æ— é”æ ˆå®ç°**ï¼ˆç¬¬6.2èŠ‚ï¼‰
3. **å¸¸è§æ¨¡å¼**ï¼ˆç¬¬ä¹ç« ï¼‰

### 10.2 å…³é”®å…¬å¼

**happens-beforeä¼ é€’æ€§**:

$$e_1 \xrightarrow{hb} e_2 \land e_2 \xrightarrow{hb} e_3 \implies e_1 \xrightarrow{hb} e_3$$

**Release-AcquireåŒæ­¥**:

$$\text{store}(Release) \xrightarrow{sync} \text{load}(Acquire) \implies \text{å…¨å±€å¯è§}$$

**æ•°æ®ç«äº‰å……è¦æ¡ä»¶**:

$$DataRace \iff \text{Concurrent} \land \text{SameLocation} \land \text{AtLeastOneWrite}$$

### 10.3 è®¾è®¡åŸåˆ™

1. **é»˜è®¤Relaxed**: ä»…éœ€åŸå­æ€§æ—¶
2. **Release-Acquire**: éœ€è¦åŒæ­¥æ—¶
3. **SeqCstè°¨æ…**: ä»…åœ¨ç»å¯¹å¿…è¦æ—¶
4. **é¿å…æ•°æ®ç«äº‰**: ä¾èµ–å€Ÿç”¨æ£€æŸ¥å™¨

---

## åä¸€ã€å»¶ä¼¸é˜…è¯»

**ç†è®ºåŸºç¡€**:

- Lamport, L. (1979). "How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs"
- Adve, S. V., & Gharachorloo, K. (1996). "Shared Memory Consistency Models"
- Boehm, H., & Adve, S. V. (2008). "Foundations of the C++ Concurrency Memory Model"

**Rustå†…å­˜æ¨¡å‹**:

- Rust Nomicon: Atomicsç« èŠ‚
- Rust RFC 2492: Memory Model
- Kang, J., et al. (2017). "A Promising Semantics for Relaxed-Memory Concurrency"

**å®ç°ç»†èŠ‚**:

- LLVM Atomicsæ–‡æ¡£
- Rustæ ‡å‡†åº“æºç : `library/core/src/sync/atomic.rs`

**æ‰©å±•æ–¹å‘**:

- `03-è¯æ˜ä¸å½¢å¼åŒ–/04-æ‰€æœ‰æƒå®‰å…¨æ€§è¯æ˜.md` â†’ happens-beforeè¯æ˜
- `05-å®ç°æœºåˆ¶/05-Rust-å¹¶å‘åŸè¯­.md` â†’ æ ‡å‡†åº“å®ç°
- `06-æ€§èƒ½åˆ†æ/02-å»¶è¿Ÿåˆ†ææ¨¡å‹.md` â†’ åŸå­æ“ä½œæ€§èƒ½

---

## åäºŒã€å®Œæ•´å®ç°ä»£ç 

### 12.1 åŸå­æ“ä½œå®Œæ•´å®ç°

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

// åŸå­è®¡æ•°å™¨å®Œæ•´å®ç°
struct AtomicCounter {
    count: AtomicUsize,
}

impl AtomicCounter {
    fn new() -> Self {
        Self {
            count: AtomicUsize::new(0),
        }
    }

    // ä½¿ç”¨Relaxedæ’åºï¼ˆä»…éœ€åŸå­æ€§ï¼‰
    fn increment_relaxed(&self) {
        self.count.fetch_add(1, Ordering::Relaxed);
    }

    // ä½¿ç”¨AcqRelæ’åºï¼ˆéœ€è¦åŒæ­¥ï¼‰
    fn increment_acqrel(&self) {
        self.count.fetch_add(1, Ordering::AcqRel);
    }

    // ä½¿ç”¨SeqCstæ’åºï¼ˆæœ€å¼ºä¿è¯ï¼‰
    fn increment_seqcst(&self) {
        self.count.fetch_add(1, Ordering::SeqCst);
    }

    fn load(&self) -> usize {
        self.count.load(Ordering::Acquire)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let counter = Arc::new(AtomicCounter::new());
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                counter.increment_relaxed();
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", counter.load());  // 10000
}
```

### 12.2 è‡ªæ—‹é”å®Œæ•´å®ç°

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

struct SpinLock<T> {
    locked: AtomicBool,
    data: UnsafeCell<T>,
}

unsafe impl<T> Sync for SpinLock<T> {}

impl<T> SpinLock<T> {
    fn new(data: T) -> Self {
        Self {
            locked: AtomicBool::new(false),
            data: UnsafeCell::new(data),
        }
    }

    fn lock(&self) -> SpinLockGuard<T> {
        // è‡ªæ—‹ç­‰å¾…
        while self.locked.compare_exchange_weak(
            false,
            true,
            Ordering::Acquire,  // è·å–é”æ—¶ä½¿ç”¨Acquire
            Ordering::Relaxed
        ).is_err() {
            // è‡ªæ—‹ï¼ˆCPUå¿™ç­‰å¾…ï¼‰
            std::hint::spin_loop();
        }

        SpinLockGuard { lock: self }
    }
}

struct SpinLockGuard<'a, T> {
    lock: &'a SpinLock<T>,
}

impl<T> Drop for SpinLockGuard<'_, T> {
    fn drop(&mut self) {
        // é‡Šæ”¾é”æ—¶ä½¿ç”¨Release
        self.lock.locked.store(false, Ordering::Release);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let lock = Arc::new(SpinLock::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let lock = Arc::clone(&lock);
        let handle = thread::spawn(move || {
            let mut guard = lock.lock();
            *guard += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 12.3 æ— é”æ•°æ®ç»“æ„å®ç°

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

// æ— é”æ ˆå®ç°
struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

impl<T> LockFreeStack<T> {
    fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe {
                (*new_node).next = head;
            }

            // CASæ“ä½œ
            if self.head.compare_exchange_weak(
                head,
                new_node,
                Ordering::Release,
                Ordering::Relaxed
            ).is_ok() {
                break;
            }
        }
    }

    fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }

            unsafe {
                let next = (*head).next;
                if self.head.compare_exchange_weak(
                    head,
                    next,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    let data = ptr::read(&(*head).data);
                    drop(Box::from_raw(head));
                    return Some(data);
                }
            }
        }
    }
}
```

---

## åä¸‰ã€å®é™…åº”ç”¨æ¡ˆä¾‹

### 13.1 æ¡ˆä¾‹: é«˜å¹¶å‘è®¡æ•°å™¨ï¼ˆåŸå­æ“ä½œï¼‰

**åœºæ™¯**: ç»Ÿè®¡APIè¯·æ±‚æ•°

**éœ€æ±‚**:

- 100,000 QPS
- é›¶æ•°æ®ç«äº‰
- ä½å»¶è¿Ÿ

**å®ç°**:

```rust
use std::sync::atomic::{AtomicU64, Ordering};

struct RequestCounter {
    count: AtomicU64,
}

impl RequestCounter {
    fn increment(&self) {
        // ä½¿ç”¨Relaxedï¼ˆä»…éœ€åŸå­æ€§ï¼Œæ— éœ€åŒæ­¥ï¼‰
        self.count.fetch_add(1, Ordering::Relaxed);
    }

    fn get(&self) -> u64 {
        // ä½¿ç”¨Acquireï¼ˆéœ€è¦çœ‹åˆ°æ‰€æœ‰incrementï¼‰
        self.count.load(Ordering::Acquire)
    }
}
```

**æ€§èƒ½æ•°æ®**:

| æ’åºæ–¹å¼ | TPS | å»¶è¿Ÿ |
|---------|-----|------|
| **Relaxed** | 150,000 | 0.5Î¼s |
| **AcqRel** | 120,000 | 0.8Î¼s |
| **SeqCst** | 100,000 | 1.2Î¼s |

### 13.2 æ¡ˆä¾‹: æ— é”é˜Ÿåˆ—ï¼ˆç”Ÿäº§-æ¶ˆè´¹ï¼‰

**åœºæ™¯**: å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…é˜Ÿåˆ—

**å®ç°**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};

struct LockFreeQueue<T> {
    head: AtomicPtr<Node<T>>,
    tail: AtomicPtr<Node<T>>,
}

// ä½¿ç”¨Release-Acquireä¿è¯é¡ºåº
impl<T> LockFreeQueue<T> {
    fn enqueue(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node { data, next: ptr::null_mut() }));

        loop {
            let tail = self.tail.load(Ordering::Acquire);
            unsafe {
                if (*tail).next.compare_exchange_weak(
                    ptr::null_mut(),
                    new_node,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    self.tail.store(new_node, Ordering::Release);
                    break;
                }
            }
        }
    }
}
```

**æ€§èƒ½å¯¹æ¯”**:

| å®ç° | TPS | å»¶è¿Ÿ |
|-----|-----|------|
| **Mutexé˜Ÿåˆ—** | 50,000 | 5Î¼s |
| **æ— é”é˜Ÿåˆ—** | **200,000** | **1Î¼s** |

---

## åå››ã€åä¾‹ä¸é”™è¯¯è®¾è®¡

### åä¾‹1: è¯¯ç”¨Relaxedæ’åºå¯¼è‡´æ•°æ®ç«äº‰

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: ä½¿ç”¨Relaxedæ’åºå®ç°åŒæ­¥
static FLAG: AtomicBool = AtomicBool::new(false);
static DATA: AtomicUsize = AtomicUsize::new(0);

// çº¿ç¨‹1
fn thread1() {
    DATA.store(42, Ordering::Relaxed);  // é—®é¢˜: Relaxedä¸ä¿è¯å¯è§æ€§é¡ºåº
    FLAG.store(true, Ordering::Relaxed);
}

// çº¿ç¨‹2
fn thread2() {
    while !FLAG.load(Ordering::Relaxed) {}  // å¯èƒ½çœ‹åˆ°FLAG=trueä½†DATA=0
    let data = DATA.load(Ordering::Relaxed);  // æ•°æ®ç«äº‰ï¼
}
```

**é—®é¢˜**: Relaxedæ’åºä¸ä¿è¯å¯è§æ€§é¡ºåºï¼Œå¯èƒ½å¯¼è‡´æ•°æ®ç«äº‰

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: ä½¿ç”¨Release-Acquire
fn thread1() {
    DATA.store(42, Ordering::Relaxed);
    FLAG.store(true, Ordering::Release);  // Releaseä¿è¯ä¹‹å‰çš„æ‰€æœ‰å†™æ“ä½œå¯è§
}

fn thread2() {
    while !FLAG.load(Ordering::Acquire) {}  // Acquireä¿è¯çœ‹åˆ°Releaseä¹‹å‰çš„æ‰€æœ‰å†™
    let data = DATA.load(Ordering::Relaxed);  // å®‰å…¨
}
```

### åä¾‹2: å¿½ç•¥å†…å­˜æ’åºå¯¼è‡´å¯è§æ€§é—®é¢˜

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: æ‰€æœ‰æ“ä½œéƒ½ç”¨Relaxed
let counter = AtomicUsize::new(0);

// çº¿ç¨‹1
counter.store(1, Ordering::Relaxed);
counter.store(2, Ordering::Relaxed);

// çº¿ç¨‹2å¯èƒ½çœ‹åˆ°: counter = 1ï¼ˆä¹±åºæ‰§è¡Œï¼‰
```

**é—®é¢˜**: ä¸åŒçº¿ç¨‹å¯èƒ½çœ‹åˆ°ä¸åŒçš„æ‰§è¡Œé¡ºåº

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: éœ€è¦é¡ºåºæ—¶ä½¿ç”¨SeqCst
counter.store(1, Ordering::SeqCst);
counter.store(2, Ordering::SeqCst);

// æ‰€æœ‰çº¿ç¨‹çœ‹åˆ°ç›¸åŒçš„é¡ºåº
```

### åä¾‹3: è·¨å¹³å°å†…å­˜æ¨¡å‹å·®å¼‚è¢«å¿½ç•¥

**é”™è¯¯è®¾è®¡**: å‡è®¾æ‰€æœ‰å¹³å°å†…å­˜æ¨¡å‹ç›¸åŒ

```text
é”™è¯¯åœºæ™¯:
â”œâ”€ å¼€å‘: x86å¹³å°ï¼ˆTSOæ¨¡å‹ï¼‰
â”œâ”€ å‡è®¾: æ‰€æœ‰å¹³å°è¡Œä¸ºç›¸åŒ
â”œâ”€ éƒ¨ç½²: ARMå¹³å°ï¼ˆå¼±å†…å­˜æ¨¡å‹ï¼‰
â””â”€ ç»“æœ: ç¨‹åºåœ¨ARMä¸Šè¡Œä¸ºé”™è¯¯ âœ—

å®é™…æ¡ˆä¾‹:
â”œâ”€ ç³»ç»Ÿ: è·¨å¹³å°æ— é”æ•°æ®ç»“æ„
â”œâ”€ å¼€å‘: x86å¹³å°æµ‹è¯•é€šè¿‡
â”œâ”€ éƒ¨ç½²: ARMæœåŠ¡å™¨
â”œâ”€ é—®é¢˜: ARMå¼±å†…å­˜æ¨¡å‹å¯¼è‡´æ•°æ®ç«äº‰
â””â”€ åæœ: ç”Ÿäº§ç¯å¢ƒæ•°æ®é”™è¯¯ âœ—

æ­£ç¡®è®¾è®¡:
â”œâ”€ æ–¹æ¡ˆ: ä½¿ç”¨æ ‡å‡†å†…å­˜æ¨¡å‹ï¼ˆC++11/Rustï¼‰
â”œâ”€ å®ç°: ä¸ä¾èµ–å¹³å°ç‰¹å®šè¡Œä¸º
â””â”€ ç»“æœ: è·¨å¹³å°è¡Œä¸ºä¸€è‡´ âœ“
```

### åä¾‹4: è¯¯ç”¨SeqCstå¯¼è‡´æ€§èƒ½ä¸‹é™

**é”™è¯¯è®¾è®¡**: æ‰€æœ‰æ“ä½œéƒ½ç”¨SeqCst

```rust
// é”™è¯¯: è®¡æ•°å™¨ä¹Ÿç”¨SeqCst
let counter = AtomicUsize::new(0);

// æ€§èƒ½é—®é¢˜: SeqCstå¼€é”€å¤§
for i in 0..1000000 {
    counter.store(i, Ordering::SeqCst);  // ä¸å¿…è¦çš„å¼€é”€
}
```

**é—®é¢˜**: SeqCstæ€§èƒ½å¼€é”€å¤§ï¼Œä¸éœ€è¦æ—¶ä½¿ç”¨ä¼šé™ä½æ€§èƒ½

```text
é”™è¯¯åœºæ™¯:
â”œâ”€ åœºæ™¯: é«˜å¹¶å‘è®¡æ•°å™¨
â”œâ”€ é—®é¢˜: æ‰€æœ‰æ“ä½œéƒ½ç”¨SeqCst
â”œâ”€ æ€§èƒ½: TPSåªæœ‰10ä¸‡
â””â”€ å¼€é”€: SeqCstéœ€è¦å…¨å±€å†…å­˜å±éšœ âœ—

æ­£ç¡®è®¾è®¡:
â”œâ”€ æ–¹æ¡ˆ: è®¡æ•°å™¨ç”¨Relaxed
â”œâ”€ æ€§èƒ½: TPSè¾¾åˆ°100ä¸‡+
â””â”€ ç»“æœ: æ€§èƒ½æå‡10å€ âœ“
```

### åä¾‹5: å¿½ç•¥ç¼–è¯‘å™¨ä¼˜åŒ–å¯¼è‡´é—®é¢˜

**é”™è¯¯è®¾è®¡**: å‡è®¾ç¼–è¯‘å™¨ä¸ä¼šä¼˜åŒ–

```rust
// é”™è¯¯: å‡è®¾ç¼–è¯‘å™¨ä¸ä¼šé‡æ’åº
static mut DATA: usize = 0;
static FLAG: AtomicBool = AtomicBool::new(false);

// çº¿ç¨‹1
unsafe {
    DATA = 42;  // ç¼–è¯‘å™¨å¯èƒ½é‡æ’åº
    FLAG.store(true, Ordering::Relaxed);
}

// çº¿ç¨‹2å¯èƒ½çœ‹åˆ°: FLAG=trueä½†DATA=0ï¼ˆç¼–è¯‘å™¨ä¼˜åŒ–ï¼‰
```

**é—®é¢˜**: ç¼–è¯‘å™¨ä¼˜åŒ–å¯èƒ½å¯¼è‡´æ„å¤–çš„é‡æ’åº

```text
é”™è¯¯åœºæ™¯:
â”œâ”€ ä»£ç : æ™®é€šå˜é‡ + åŸå­æ“ä½œ
â”œâ”€ é—®é¢˜: ç¼–è¯‘å™¨ä¼˜åŒ–é‡æ’åº
â”œâ”€ ç»“æœ: æ•°æ®ç«äº‰ï¼Œç¨‹åºé”™è¯¯
â””â”€ åæœ: éš¾ä»¥è°ƒè¯•çš„å¹¶å‘bug âœ—

æ­£ç¡®è®¾è®¡:
â”œâ”€ æ–¹æ¡ˆ: ä½¿ç”¨åŸå­æ“ä½œ + å†…å­˜æ’åº
â”œâ”€ å®ç°: ç¼–è¯‘å™¨å°Šé‡å†…å­˜æ’åº
â””â”€ ç»“æœ: ç¼–è¯‘å™¨ä¸ä¼šé‡æ’åºè·¨å†…å­˜æ’åºçš„æ“ä½œ âœ“
```

**ç¼–è¯‘å™¨ä¼˜åŒ–æ·±åº¦åˆ†æ**:

#### ç¼–è¯‘å™¨é‡æ’åºçš„åŸå› 

**ä¸ºä»€ä¹ˆç¼–è¯‘å™¨è¦é‡æ’åºï¼Ÿ**

```text
ç¼–è¯‘å™¨ä¼˜åŒ–ç›®æ ‡:
â”œâ”€ æ€§èƒ½ä¼˜åŒ–: å‡å°‘æŒ‡ä»¤æ•°ã€æé«˜ç¼“å­˜å‘½ä¸­ç‡
â”œâ”€ å¯„å­˜å™¨åˆ†é…: å‡å°‘å†…å­˜è®¿é—®
â”œâ”€ å¾ªç¯ä¼˜åŒ–: å¾ªç¯å±•å¼€ã€å‘é‡åŒ–
â””â”€ æ­»ä»£ç æ¶ˆé™¤: ç§»é™¤æ— ç”¨ä»£ç 

é‡æ’åºç±»å‹:
â”œâ”€ æŒ‡ä»¤è°ƒåº¦: é‡æ’æŒ‡ä»¤é¡ºåº
â”œâ”€ å¯„å­˜å™¨åˆ†é…: æ”¹å˜å†…å­˜è®¿é—®é¡ºåº
â”œâ”€ å¾ªç¯ä¼˜åŒ–: æ”¹å˜å¾ªç¯å†…æ“ä½œé¡ºåº
â””â”€ å†…è”ä¼˜åŒ–: å‡½æ•°å†…è”æ”¹å˜æ‰§è¡Œé¡ºåº
```

**ç¼–è¯‘å™¨ä¼˜åŒ–ç¤ºä¾‹**:

```rust
// åŸå§‹ä»£ç 
fn example() {
    let mut x = 0;
    let mut y = 0;

    x = 1;  // (1)
    y = 2;  // (2)

    println!("{}", x + y);
}

// ç¼–è¯‘å™¨ä¼˜åŒ–åï¼ˆä¼ªä»£ç ï¼‰
fn example_optimized() {
    let mut x = 0;
    let mut y = 0;

    // ç¼–è¯‘å™¨å¯èƒ½é‡æ’åºä¸º:
    y = 2;  // (2) æå‰æ‰§è¡Œ
    x = 1;  // (1) å»¶åæ‰§è¡Œ

    println!("{}", x + y);  // ç»“æœç›¸åŒ: 3
}
```

**å†…å­˜æ’åºå¦‚ä½•é™åˆ¶ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Ÿ**

```text
ç¼–è¯‘å™¨ä¼˜åŒ–è§„åˆ™:
â”œâ”€ è§„åˆ™1: ä¸èƒ½é‡æ’åºè·¨å†…å­˜æ’åºçš„æ“ä½œ
â”‚   â””â”€ Release/Acquire/SeqCstæ˜¯ä¼˜åŒ–å±éšœ
â”‚
â”œâ”€ è§„åˆ™2: ä¸èƒ½æ¶ˆé™¤æœ‰å‰¯ä½œç”¨çš„æ“ä½œ
â”‚   â””â”€ åŸå­æ“ä½œæœ‰å‰¯ä½œç”¨ï¼Œä¸èƒ½æ¶ˆé™¤
â”‚
â””â”€ è§„åˆ™3: ä¸èƒ½å‡è®¾å•çº¿ç¨‹è¯­ä¹‰
    â””â”€ å¿…é¡»è€ƒè™‘å¤šçº¿ç¨‹å¯è§æ€§
```

**åè¯: å¦‚æœç¼–è¯‘å™¨å¿½ç•¥å†…å­˜æ’åº**

```text
å‡è®¾: ç¼–è¯‘å™¨å¿½ç•¥å†…å­˜æ’åºï¼Œè‡ªç”±é‡æ’åº

åœºæ™¯:
â”œâ”€ ä»£ç :
â”‚   DATA.store(42, Relaxed);
â”‚   FLAG.store(true, Release);
â”‚
â”œâ”€ ç¼–è¯‘å™¨ä¼˜åŒ–:
â”‚   FLAG.store(true, Release);  // æå‰
â”‚   DATA.store(42, Relaxed);    // å»¶å
â”‚
â””â”€ ç»“æœ:
    â”œâ”€ çº¿ç¨‹2çœ‹åˆ°: FLAG=true, DATA=0
    â”œâ”€ æ•°æ®ç«äº‰: çº¿ç¨‹2è¯»å–åˆ°æœªåˆå§‹åŒ–çš„æ•°æ®
    â””â”€ ç¨‹åºé”™è¯¯ âœ—

ç»“è®º: ç¼–è¯‘å™¨å¿…é¡»å°Šé‡å†…å­˜æ’åº
```

#### è¯­è¨€æœºåˆ¶èƒŒæ™¯ï¼šRustå†…å­˜æ¨¡å‹

**Rustå†…å­˜æ¨¡å‹çš„è®¾è®¡åŸåˆ™**:

```text
è®¾è®¡ç›®æ ‡:
â”œâ”€ å®‰å…¨æ€§: é˜²æ­¢æ•°æ®ç«äº‰ï¼ˆç¼–è¯‘æœŸæ£€æŸ¥ï¼‰
â”œâ”€ æ€§èƒ½: å…è®¸ä¼˜åŒ–ï¼ˆå¼±æ’åºï¼‰
â”œâ”€ å¯é¢„æµ‹æ€§: æ˜ç¡®è¯­ä¹‰ï¼ˆå½¢å¼åŒ–å®šä¹‰ï¼‰
â””â”€ å¯ç§»æ¤æ€§: è·¨å¹³å°ä¸€è‡´ï¼ˆç¡¬ä»¶æŠ½è±¡ï¼‰

Rustå†…å­˜æ¨¡å‹ç‰¹æ€§:
â”œâ”€ æ— æ•°æ®ç«äº‰ä¿è¯: ç¼–è¯‘æœŸæ£€æŸ¥
â”œâ”€ åŸå­æ“ä½œ: æ˜¾å¼åŒæ­¥
â”œâ”€ å†…å­˜æ’åº: æ˜¾å¼æ§åˆ¶
â””â”€ æ‰€æœ‰æƒç³»ç»Ÿ: é˜²æ­¢å¹¶å‘é”™è¯¯
```

**Rust vs C++å†…å­˜æ¨¡å‹å¯¹æ¯”**:

```text
ç›¸ä¼¼ç‚¹:
â”œâ”€ éƒ½åŸºäºC++11å†…å­˜æ¨¡å‹
â”œâ”€ éƒ½æœ‰Relaxed/Release/Acquire/SeqCst
â””â”€ éƒ½æœ‰happens-beforeå…³ç³»

å·®å¼‚ç‚¹:
â”œâ”€ Rust: ç¼–è¯‘æœŸæ£€æŸ¥æ•°æ®ç«äº‰
â”œâ”€ C++: è¿è¡Œæ—¶å¯èƒ½å‡ºç°æ•°æ®ç«äº‰
â”œâ”€ Rust: æ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢å¹¶å‘é”™è¯¯
â””â”€ C++: éœ€è¦ç¨‹åºå‘˜ä¿è¯æ­£ç¡®æ€§
```

**è¯­è¨€æœºåˆ¶å¯¹å¹¶å‘çš„å½±å“**:

```text
è¯­è¨€æœºåˆ¶å½±å“:
â”œâ”€ æ‰€æœ‰æƒç³»ç»Ÿ (Rust)
â”‚   â”œâ”€ ç¼–è¯‘æœŸé˜²æ­¢æ•°æ®ç«äº‰
â”‚   â”œâ”€ å¼ºåˆ¶æ˜¾å¼å…±äº«ï¼ˆArc/Mutexï¼‰
â”‚   â””â”€ ç»“æœ: æ›´å®‰å…¨çš„å¹¶å‘ä»£ç 
â”‚
â”œâ”€ åƒåœ¾å›æ”¶ (Java/Go)
â”‚   â”œâ”€ è‡ªåŠ¨å†…å­˜ç®¡ç†
â”‚   â”œâ”€ ä½†GCå¯èƒ½æš‚åœçº¿ç¨‹
â”‚   â””â”€ ç»“æœ: å½±å“å®æ—¶æ€§
â”‚
â””â”€ æ‰‹åŠ¨å†…å­˜ç®¡ç† (C/C++)
    â”œâ”€ å®Œå…¨æ§åˆ¶
    â”œâ”€ ä½†å®¹æ˜“å‡ºé”™ï¼ˆæ‚¬å‚æŒ‡é’ˆã€å†…å­˜æ³„æ¼ï¼‰
    â””â”€ ç»“æœ: éœ€è¦æ›´å¤šç»éªŒ
```

â””â”€ ç»“æœ: è¡Œä¸ºå¯é¢„æµ‹ âœ“

```

### åä¾‹6: å†…å­˜å±éšœä½¿ç”¨ä¸å½“

**é”™è¯¯è®¾è®¡**: å†…å­˜å±éšœä½ç½®é”™è¯¯

```rust
// é”™è¯¯: å†…å­˜å±éšœä½ç½®ä¸å¯¹
fn wrong_barrier() {
    let data = 42;
    atomic::fence(Ordering::Release);  // å±éšœåœ¨å†™æ“ä½œä¹‹å
    DATA.store(data, Ordering::Relaxed);  // å±éšœæ— æ•ˆ
}
```

**é—®é¢˜**: å†…å­˜å±éšœå¿…é¡»åœ¨æ­£ç¡®çš„ä½ç½®

```text
é”™è¯¯åœºæ™¯:
â”œâ”€ ä»£ç : å†…å­˜å±éšœä½ç½®é”™è¯¯
â”œâ”€ é—®é¢˜: å±éšœæ— æ³•ä¿è¯é¡ºåº
â”œâ”€ ç»“æœ: æ•°æ®ç«äº‰ä»ç„¶å­˜åœ¨
â””â”€ åæœ: ç¨‹åºè¡Œä¸ºä¸ç¡®å®š âœ—

æ­£ç¡®è®¾è®¡:
â”œâ”€ æ–¹æ¡ˆ: å±éšœåœ¨å…³é”®æ“ä½œä¹‹é—´
â”œâ”€ å®ç°: ä½¿ç”¨Release-Acquireé…å¯¹
â””â”€ ç»“æœ: æ­£ç¡®åŒæ­¥ âœ“
```

---

## åäº”ã€å†…å­˜æ¨¡å‹å¯è§†åŒ–

### 15.1 å†…å­˜æ’åºå±‚æ¬¡æ¶æ„å›¾

**å®Œæ•´å†…å­˜æ’åºç³»ç»Ÿæ¶æ„** (Mermaid):

```mermaid
graph TB
    subgraph "å†…å­˜æ’åºå±‚æ¬¡"
        SEQ[SeqCst<br/>é¡ºåºä¸€è‡´æ€§<br/>æœ€å¼ºä¿è¯]
        ACQ[AcqRel<br/>è·å–-é‡Šæ”¾<br/>ä¸­ç­‰ä¿è¯]
        REL[Release-Acquire<br/>é‡Šæ”¾-è·å–<br/>åŒæ­¥ä¿è¯]
        RELAX[Relaxed<br/>å®½æ¾æ’åº<br/>æœ€å¼±ä¿è¯]
    end

    subgraph "ç¡¬ä»¶æ”¯æŒ"
        MB[å†…å­˜å±éšœ<br/>Memory Barrier]
        CAS[åŸå­æ“ä½œ<br/>Compare-and-Swap]
        CACHE[ç¼“å­˜ä¸€è‡´æ€§<br/>MESIåè®®]
    end

    subgraph "åº”ç”¨åœºæ™¯"
        SYNC[åŒæ­¥åŸè¯­<br/>Mutex/RwLock]
        LOCKFREE[æ— é”æ•°æ®ç»“æ„<br/>Lock-Free]
        COUNTER[åŸå­è®¡æ•°å™¨<br/>Atomic Counter]
    end

    SEQ --> MB
    ACQ --> MB
    REL --> MB
    RELAX --> CAS

    MB --> CACHE
    CAS --> CACHE

    SEQ --> SYNC
    ACQ --> SYNC
    REL --> LOCKFREE
    RELAX --> COUNTER
```

**å†…å­˜æ’åºä¿è¯å±‚æ¬¡**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L3: å†…å­˜æ’åºä¿è¯å±‚æ¬¡                     â”‚
â”‚  â”œâ”€ SeqCst (é¡ºåºä¸€è‡´æ€§ï¼Œæœ€å¼º)            â”‚
â”‚  â”œâ”€ AcqRel (è·å–-é‡Šæ”¾)                   â”‚
â”‚  â”œâ”€ Release-Acquire (é‡Šæ”¾-è·å–)           â”‚
â”‚  â””â”€ Relaxed (å®½æ¾æ’åºï¼Œæœ€å¼±)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚
        â”‚ ç¡¬ä»¶æ”¯æŒ           â”‚ åº”ç”¨åœºæ™¯
        â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L2: ç¡¬ä»¶å±‚  â”‚  â”‚  L2: åº”ç”¨å±‚      â”‚
â”‚  å†…å­˜å±éšœ     â”‚  â”‚  åŒæ­¥åŸè¯­        â”‚
â”‚  åŸå­æ“ä½œ     â”‚  â”‚  æ— é”æ•°æ®ç»“æ„    â”‚
â”‚  ç¼“å­˜ä¸€è‡´æ€§   â”‚  â”‚  åŸå­è®¡æ•°å™¨      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ æ€§èƒ½å¼€é”€
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L1: æ€§èƒ½å±‚  â”‚
â”‚  å»¶è¿Ÿ: ä½â†’é«˜ â”‚
â”‚  å¼€é”€: ä½â†’é«˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 15.2 happens-beforeå…³ç³»å›¾

**happens-beforeå…³ç³»å¯è§†åŒ–** (Mermaid):

```mermaid
graph LR
    subgraph "çº¿ç¨‹1"
        T1_W1[å†™x=1<br/>Release]
        T1_W2[å†™y=2<br/>Release]
    end

    subgraph "çº¿ç¨‹2"
        T2_R1[è¯»y<br/>Acquire]
        T2_R2[è¯»x<br/>Acquire]
    end

    T1_W1 -->|happens-before| T1_W2
    T1_W2 -.->|åŒæ­¥| T2_R1
    T2_R1 -->|happens-before| T2_R2

    style T1_W1 fill:#ffcccc
    style T1_W2 fill:#ffcccc
    style T2_R1 fill:#ccffcc
    style T2_R2 fill:#ccffcc
```

**happens-beforeå…³ç³»ä¼ é€’**:

```text
happens-beforeå…³ç³»é“¾:
â”œâ”€ çº¿ç¨‹å†…é¡ºåº: ç¨‹åºé¡ºåºä¿è¯
â”‚   â”œâ”€ T1: W(x=1) â†’hb W(y=2)
â”‚   â””â”€ T2: R(y) â†’hb R(x)
â”‚
â”œâ”€ åŒæ­¥å…³ç³»: Release-Acquire
â”‚   â”œâ”€ W(y=2, Release) â†’sync R(y, Acquire)
â”‚   â””â”€ å»ºç«‹è·¨çº¿ç¨‹happens-before
â”‚
â””â”€ ä¼ é€’æ€§: å…¨å±€happens-before
    â”œâ”€ W(x=1) â†’hb W(y=2) â†’sync R(y) â†’hb R(x)
    â””â”€ ä¿è¯: R(x) èƒ½çœ‹åˆ° W(x=1) çš„ç»“æœ
```

### 15.3 å†…å­˜æ’åºé€‰æ‹©å†³ç­–æ ‘

**å†…å­˜æ’åºé€‰æ‹©å†³ç­–æ ‘**:

```text
                é€‰æ‹©å†…å­˜æ’åº
                      â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   åŒæ­¥éœ€æ±‚åˆ†æ        â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚               â”‚               â”‚
   éœ€è¦åŒæ­¥        ä¸éœ€è¦åŒæ­¥      éƒ¨åˆ†åŒæ­¥
   (è·¨çº¿ç¨‹)        (å•çº¿ç¨‹)        (å±€éƒ¨)
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   Release-       Relaxed        AcqRel
   Acquire       (è®¡æ•°å™¨)       (è‡ªæ—‹é”)
      â”‚               â”‚               â”‚
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   åŒæ­¥ä¿è¯        é›¶å¼€é”€          ä¸­ç­‰å¼€é”€
   å¯è§æ€§ä¿è¯      æ— é¡ºåºä¿è¯      å±€éƒ¨é¡ºåº
```

**å†…å­˜æ’åºåœºæ™¯é€‰æ‹©å†³ç­–æ ‘**:

```text
                é€‰æ‹©å…·ä½“æ’åº
                      â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   åº”ç”¨åœºæ™¯åˆ†æ        â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚               â”‚               â”‚
   è®¡æ•°å™¨          åŒæ­¥åŸè¯­        æ— é”æ•°æ®ç»“æ„
   (ç®€å•)          (Mutex)        (Lock-Free)
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   Relaxed        SeqCst          Release-
   (æ— é¡ºåº)       (å…¨å±€é¡ºåº)       Acquire
      â”‚               â”‚          (å±€éƒ¨åŒæ­¥)
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   æœ€é«˜æ€§èƒ½        æœ€å¼ºä¿è¯        å¹³è¡¡æ–¹æ¡ˆ
   æ— åŒæ­¥å¼€é”€      å…¨å±€å¯è§æ€§      å±€éƒ¨å¯è§æ€§
```

**å†…å­˜æ’åºå¯¹æ¯”çŸ©é˜µ**:

| æ’åºç±»å‹ | ä¿è¯å¼ºåº¦ | æ€§èƒ½å¼€é”€ | é€‚ç”¨åœºæ™¯ | ç¡¬ä»¶æ”¯æŒ |
|---------|---------|---------|---------|---------|
| **Relaxed** | æœ€å¼± | æœ€ä½ | åŸå­è®¡æ•°å™¨ | åŸå­æ“ä½œ |
| **Release-Acquire** | ä¸­ç­‰ | ä½ | åŒæ­¥åŸè¯­ã€æ— é”æ•°æ®ç»“æ„ | å†…å­˜å±éšœ |
| **AcqRel** | ä¸­ç­‰ | ä½ | è‡ªæ—‹é” | å†…å­˜å±éšœ |
| **SeqCst** | æœ€å¼º | æœ€é«˜ | å…¨å±€åŒæ­¥ | å…¨åºå†…å­˜å±éšœ |

**å†…å­˜æ’åºä¸æ•°æ®åº“éš”ç¦»çº§åˆ«å¯¹åº”çŸ©é˜µ**:

| å†…å­˜æ’åº | æ•°æ®åº“éš”ç¦»çº§åˆ« | ä¿è¯å†…å®¹ | æ€§èƒ½ |
|---------|--------------|---------|------|
| **Relaxed** | Read Uncommitted | æ— é¡ºåºä¿è¯ | æœ€é«˜ |
| **Release-Acquire** | Read Committed | åŒæ­¥ç‚¹å¯è§æ€§ | é«˜ |
| **AcqRel** | Repeatable Read | å±€éƒ¨é¡ºåº | ä¸­ |
| **SeqCst** | Serializable | å…¨å±€é¡ºåº | ä½ |

---

**ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: å®Œæ•´åŸå­æ“ä½œ/è‡ªæ—‹é”/æ— é”æ•°æ®ç»“æ„å®ç°ã€å®é™…æ¡ˆä¾‹ã€åä¾‹åˆ†æã€å†…å­˜æ¨¡å‹å¯è§†åŒ–ï¼ˆå†…å­˜æ’åºå±‚æ¬¡æ¶æ„å›¾ã€happens-beforeå…³ç³»å›¾ã€å†…å­˜æ’åºé€‰æ‹©å†³ç­–æ ‘ï¼‰ã€å†…å­˜æ¨¡å‹ç†è®ºèƒŒæ™¯ä¸æ¼”è¿›ï¼ˆä¸ºä»€ä¹ˆéœ€è¦å†…å­˜æ¨¡å‹ã€å†å²èƒŒæ™¯ã€ç†è®ºåŸºç¡€ã€ç¡¬ä»¶å†…å­˜æ¨¡å‹èƒŒæ™¯ã€æ ¸å¿ƒçŸ›ç›¾ï¼‰ã€å†…å­˜æ¨¡å‹åä¾‹è¡¥å……ï¼ˆ6ä¸ªæ–°å¢åä¾‹ï¼šè·¨å¹³å°å†…å­˜æ¨¡å‹å·®å¼‚è¢«å¿½ç•¥ã€è¯¯ç”¨SeqCstå¯¼è‡´æ€§èƒ½ä¸‹é™ã€å¿½ç•¥ç¼–è¯‘å™¨ä¼˜åŒ–å¯¼è‡´é—®é¢˜ã€å†…å­˜å±éšœä½¿ç”¨ä¸å½“ï¼‰

**å…³è”æ–‡æ¡£**:

- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/06-æ‰€æœ‰æƒæ¨¡å‹(Rust).md`
- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/01-åˆ†å±‚çŠ¶æ€æ¼”åŒ–æ¨¡å‹(LSEM).md`
- `05-å®ç°æœºåˆ¶/05-Rust-å¹¶å‘åŸè¯­.md`
