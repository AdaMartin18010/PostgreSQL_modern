# 07 | å†…å­˜æ¨¡å‹ä¸æ’åº

> **ç†è®ºå®šä½**: å†…å­˜æ¨¡å‹å®šä¹‰å¤šçº¿ç¨‹ç¨‹åºçš„è¯­ä¹‰ï¼Œæœ¬æ–‡æ¡£æä¾›ä»ç†è®ºåˆ°Rustå®ç°çš„å®Œæ•´åˆ†æï¼Œå¹¶æ˜ å°„åˆ°LSEM L1å±‚ã€‚

---

## ğŸ“‘ ç›®å½•

- [07 | å†…å­˜æ¨¡å‹ä¸æ’åº](#07--å†…å­˜æ¨¡å‹ä¸æ’åº)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å†…å­˜æ¨¡å‹åŸºç¡€](#ä¸€å†…å­˜æ¨¡å‹åŸºç¡€)
    - [1.1 ä»€ä¹ˆæ˜¯å†…å­˜æ¨¡å‹](#11-ä»€ä¹ˆæ˜¯å†…å­˜æ¨¡å‹)
    - [1.2 happens-beforeå…³ç³»](#12-happens-beforeå…³ç³»)
  - [äºŒã€Rustå†…å­˜æ’åº](#äºŒrustå†…å­˜æ’åº)
    - [2.1 Orderingç±»å‹](#21-orderingç±»å‹)
    - [2.2 Relaxedæ’åº](#22-relaxedæ’åº)
    - [2.3 Release-Acquireæ’åº](#23-release-acquireæ’åº)
    - [2.4 AcqRelæ’åº](#24-acqrelæ’åº)
    - [2.5 SeqCstæ’åº](#25-seqcstæ’åº)
  - [ä¸‰ã€å†…å­˜å±éšœ](#ä¸‰å†…å­˜å±éšœ)
    - [3.1 ç¡¬ä»¶å±‚é¢](#31-ç¡¬ä»¶å±‚é¢)
    - [3.2 ç¼–è¯‘å™¨å±éšœ](#32-ç¼–è¯‘å™¨å±éšœ)
  - [å››ã€ä¸C++å†…å­˜æ¨¡å‹å¯¹æ¯”](#å››ä¸cå†…å­˜æ¨¡å‹å¯¹æ¯”)
    - [4.1 C++20å†…å­˜æ¨¡å‹](#41-c20å†…å­˜æ¨¡å‹)
    - [4.2 å…³é”®å·®å¼‚](#42-å…³é”®å·®å¼‚)
  - [äº”ã€å½¢å¼åŒ–è¯­ä¹‰](#äº”å½¢å¼åŒ–è¯­ä¹‰)
    - [5.1 Promisingè¯­ä¹‰](#51-promisingè¯­ä¹‰)
    - [5.2 æ•°æ®ç«äº‰å®šä¹‰](#52-æ•°æ®ç«äº‰å®šä¹‰)
  - [å…­ã€åŒæ­¥åŸè¯­å®ç°](#å…­åŒæ­¥åŸè¯­å®ç°)
    - [6.1 è‡ªæ—‹é”](#61-è‡ªæ—‹é”)
    - [6.2 æ— é”æ ˆ](#62-æ— é”æ ˆ)
  - [ä¸ƒã€ä¸LSEM L1å±‚çš„æ˜ å°„](#ä¸ƒä¸lsem-l1å±‚çš„æ˜ å°„)
    - [7.1 æ—¶ç©ºæˆ³æ˜ å°„](#71-æ—¶ç©ºæˆ³æ˜ å°„)
    - [7.2 å¯è§æ€§è§„åˆ™æ˜ å°„](#72-å¯è§æ€§è§„åˆ™æ˜ å°„)
    - [7.3 ä¸L0å±‚å¯¹æ¯”](#73-ä¸l0å±‚å¯¹æ¯”)
  - [å…«ã€æ€§èƒ½åˆ†æ](#å…«æ€§èƒ½åˆ†æ)
    - [8.1 Orderingå¼€é”€å¯¹æ¯”](#81-orderingå¼€é”€å¯¹æ¯”)
    - [8.2 é”å¼€é”€å¯¹æ¯”](#82-é”å¼€é”€å¯¹æ¯”)
  - [ä¹ã€å¸¸è§æ¨¡å¼](#ä¹å¸¸è§æ¨¡å¼)
    - [æ¨¡å¼1: Lazy Initialization](#æ¨¡å¼1-lazy-initialization)
    - [æ¨¡å¼2: åŒé‡æ£€æŸ¥é”](#æ¨¡å¼2-åŒé‡æ£€æŸ¥é”)
    - [æ¨¡å¼3: Seqlock](#æ¨¡å¼3-seqlock)
  - [åã€æ€»ç»“](#åæ€»ç»“)
    - [10.1 æ ¸å¿ƒè´¡çŒ®](#101-æ ¸å¿ƒè´¡çŒ®)
    - [10.2 å…³é”®å…¬å¼](#102-å…³é”®å…¬å¼)
    - [10.3 è®¾è®¡åŸåˆ™](#103-è®¾è®¡åŸåˆ™)
  - [åä¸€ã€å»¶ä¼¸é˜…è¯»](#åä¸€å»¶ä¼¸é˜…è¯»)

---

## ä¸€ã€å†…å­˜æ¨¡å‹åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯å†…å­˜æ¨¡å‹

**å®šä¹‰1.1 (å†…å­˜æ¨¡å‹)**:

$$MemoryModel: \text{Formal specification of memory operations' semantics in concurrent programs}$$

**æ ¸å¿ƒé—®é¢˜**: åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œ**ä»€ä¹ˆé¡ºåºçš„æ“ä½œå¯¹å…¶ä»–çº¿ç¨‹å¯è§**ï¼Ÿ

**ç¤ºä¾‹é—®é¢˜**:

```rust
// çº¿ç¨‹1
x = 1;  // (1)
y = 2;  // (2)

// çº¿ç¨‹2
r1 = y;  // (3)
r2 = x;  // (4)

// é—®: èƒ½å¦å‡ºç° r1 = 2 ä¸” r2 = 0 ï¼Ÿ
```

**ä¸åŒå†…å­˜æ¨¡å‹çš„ç­”æ¡ˆ**:

- **é¡ºåºä¸€è‡´æ€§ (SC)**: ä¸å¯èƒ½
- **å®½æ¾æ¨¡å‹ (Relaxed)**: å¯èƒ½ï¼

### 1.2 happens-beforeå…³ç³»

**å®šä¹‰1.2 (happens-before)**:

$$e_1 \xrightarrow{hb} e_2 \iff e_1 \text{ is visible to } e_2$$

**æ€§è´¨**:

- **ä¼ é€’æ€§**: $e_1 \xrightarrow{hb} e_2 \land e_2 \xrightarrow{hb} e_3 \implies e_1 \xrightarrow{hb} e_3$
- **éè‡ªåæ€§**: $\neg(e \xrightarrow{hb} e)$
- **åå¯¹ç§°æ€§**: $e_1 \xrightarrow{hb} e_2 \implies \neg(e_2 \xrightarrow{hb} e_1)$

**happens-beforeæ¥æº**:

1. **ç¨‹åºé¡ºåº** (Program Order):
   $$\text{Same thread: } op_1 \text{ before } op_2 \implies op_1 \xrightarrow{po} op_2$$

2. **åŒæ­¥æ“ä½œ** (Synchronization):
   $$\text{Release} \xrightarrow{sync} \text{Acquire}$$

3. **ä¼ é€’é—­åŒ…**:
   $$e_1 \xrightarrow{po} e_2 \xrightarrow{sync} e_3 \implies e_1 \xrightarrow{hb} e_3$$

---

## äºŒã€Rustå†…å­˜æ’åº

### 2.1 Orderingç±»å‹

**å®šä¹‰2.1 (Orderingæšä¸¾)**:

```rust
pub enum Ordering {
    Relaxed,   // æœ€å¼±
    Release,   // å†™å±éšœ
    Acquire,   // è¯»å±éšœ
    AcqRel,    // è¯»å†™å±éšœ
    SeqCst,    // æœ€å¼ºï¼ˆé¡ºåºä¸€è‡´æ€§ï¼‰
}
```

**å±‚æ¬¡å…³ç³»**:

```text
SeqCst (å…¨å±€é¡ºåº)
    â†“ å¼ºäº
AcqRel (è¯»å†™åŒæ­¥)
    â†“ å¼ºäº
Release / Acquire (å•å‘åŒæ­¥)
    â†“ å¼ºäº
Relaxed (ä»…åŸå­æ€§)
```

### 2.2 Relaxedæ’åº

**è¯­ä¹‰**: ä»…ä¿è¯åŸå­æ€§ï¼Œ**æ— åŒæ­¥ä¿è¯**

```rust
use std::sync::atomic::{AtomicI64, Ordering};

static X: AtomicI64 = AtomicI64::new(0);
static Y: AtomicI64 = AtomicI64::new(0);

// çº¿ç¨‹1
fn thread1() {
    X.store(1, Ordering::Relaxed);  // (1)
    Y.store(1, Ordering::Relaxed);  // (2)
}

// çº¿ç¨‹2
fn thread2() {
    let r1 = Y.load(Ordering::Relaxed);  // (3)
    let r2 = X.load(Ordering::Relaxed);  // (4)

    // å¯èƒ½: r1 = 1, r2 = 0
    // åŸå› : (1)(2) å¯èƒ½è¢«ç¼–è¯‘å™¨/CPUé‡æ’åº
}
```

**é€‚ç”¨åœºæ™¯**:

- âœ… ç®€å•è®¡æ•°å™¨ï¼ˆä¸ä¾èµ–é¡ºåºï¼‰
- âœ… ç»Ÿè®¡ä¿¡æ¯ï¼ˆå…è®¸çŸ­æš‚ä¸ä¸€è‡´ï¼‰
- âŒ åŒæ­¥æ ‡å¿—ï¼ˆéœ€è¦Release/Acquireï¼‰

**æ€§èƒ½**: æœ€å¿«ï¼ˆ~10nsï¼‰

### 2.3 Release-Acquireæ’åº

**è¯­ä¹‰**: å»ºç«‹**åŒæ­¥ç‚¹**ï¼ŒReleaseä¹‹å‰çš„æ‰€æœ‰å†™æ“ä½œå¯¹Acquireä¹‹åçš„æ“ä½œå¯è§

**å½¢å¼åŒ–**:

$$\text{store}(x, v, Release) \xrightarrow{sync} \text{load}(x, v, Acquire)$$

$$\implies \forall w \prec_{po} store: w \xrightarrow{hb} load$$

**ç¤ºä¾‹**:

```rust
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};

static DATA: AtomicI64 = AtomicI64::new(0);
static FLAG: AtomicBool = AtomicBool::new(false);

// ç”Ÿäº§è€…
fn producer() {
    DATA.store(42, Ordering::Relaxed);      // (1) å†™æ•°æ®
    FLAG.store(true, Ordering::Release);    // (2) Release: åŒæ­¥ç‚¹

    // ä¿è¯: (1) happens-before (2)
}

// æ¶ˆè´¹è€…
fn consumer() {
    while !FLAG.load(Ordering::Acquire) {   // (3) Acquire: åŒæ­¥ç‚¹
        // è‡ªæ—‹ç­‰å¾…
    }

    let value = DATA.load(Ordering::Relaxed);  // (4) è¯»æ•°æ®
    assert_eq!(value, 42);  // âœ… ä¿è¯çœ‹åˆ°42

    // å› ä¸º: (2) sync-with (3), æ‰€ä»¥ (1) happens-before (4)
}
```

**happens-beforeé“¾**:

```text
Thread 1:
(1) DATA.store(42, Relaxed)
    â†“ (program order)
(2) FLAG.store(true, Release)
    â†“ (synchronizes-with)
Thread 2:
(3) FLAG.load(Acquire)
    â†“ (program order)
(4) DATA.load(Relaxed)

ç»“è®º: (1) happens-before (4)
```

**é€‚ç”¨åœºæ™¯**:

- âœ… è‡ªæ—‹é”å®ç°
- âœ… æ— é”æ•°æ®ç»“æ„
- âœ… å‘å¸ƒ-è®¢é˜…æ¨¡å¼

**æ€§èƒ½**: ä¸­ç­‰ï¼ˆ~30nsï¼‰

### 2.4 AcqRelæ’åº

**è¯­ä¹‰**: åŒæ—¶å…·æœ‰Releaseå’ŒAcquireè¯­ä¹‰

```rust
use std::sync::atomic::{AtomicI64, Ordering};

static COUNTER: AtomicI64 = AtomicI64::new(0);

fn compare_and_swap() {
    let mut current = COUNTER.load(Ordering::Relaxed);

    loop {
        // AcqRel: è¯»å–æœ€æ–°å€¼(Acquire) + å‘å¸ƒæ›´æ–°(Release)
        match COUNTER.compare_exchange(
            current,
            current + 1,
            Ordering::AcqRel,  // æˆåŠŸæ—¶çš„ordering
            Ordering::Acquire  // å¤±è´¥æ—¶çš„ordering
        ) {
            Ok(_) => break,
            Err(x) => current = x,  // é‡è¯•
        }
    }
}
```

**é€‚ç”¨åœºæ™¯**:

- âœ… Compare-and-Swapæ“ä½œ
- âœ… Fetch-Addç­‰RMWï¼ˆRead-Modify-Writeï¼‰

**æ€§èƒ½**: ä¸­ç­‰ï¼ˆ~40nsï¼‰

### 2.5 SeqCstæ’åº

**è¯­ä¹‰**: **é¡ºåºä¸€è‡´æ€§**ï¼Œæ‰€æœ‰çº¿ç¨‹çœ‹åˆ°å…¨å±€ç»Ÿä¸€çš„æ“ä½œé¡ºåº

**å½¢å¼åŒ–**:

$$\forall \text{threads}: \exists \text{global total order} \prec_s: $$
$$\forall op_1, op_2: op_1 \prec_s op_2 \implies \text{all threads see } op_1 \text{ before } op_2$$

**ç¤ºä¾‹**:

```rust
use std::sync::atomic::{AtomicBool, Ordering};

static X: AtomicBool = AtomicBool::new(false);
static Y: AtomicBool = AtomicBool::new(false);

// çº¿ç¨‹1
fn thread1() {
    X.store(true, Ordering::SeqCst);
}

// çº¿ç¨‹2
fn thread2() {
    Y.store(true, Ordering::SeqCst);
}

// çº¿ç¨‹3
fn thread3() {
    while !X.load(Ordering::SeqCst) {}  // ç­‰å¾…X=true

    if Y.load(Ordering::SeqCst) {
        println!("Y is true");
    } else {
        println!("Y is false");
    }
}

// çº¿ç¨‹4
fn thread4() {
    while !Y.load(Ordering::SeqCst) {}  // ç­‰å¾…Y=true

    if X.load(Ordering::SeqCst) {
        println!("X is true");
    } else {
        println!("X is false");
    }
}

// SeqCstä¿è¯: ä¸å¯èƒ½ä¸¤ä¸ªçº¿ç¨‹éƒ½è¾“å‡º"is false"
// è‡³å°‘ä¸€ä¸ªçº¿ç¨‹ä¼šçœ‹åˆ°å¦ä¸€ä¸ªçš„å†™å…¥
```

**é€‚ç”¨åœºæ™¯**:

- âœ… éœ€è¦å…¨å±€ä¸€è‡´æ€§çš„æ ‡å¿—
- âœ… è°ƒè¯•å¹¶å‘ç¨‹åºï¼ˆæœ€å®‰å…¨ï¼‰
- âŒ æ€§èƒ½æ•æ„Ÿè·¯å¾„ï¼ˆå¼€é”€å¤§ï¼‰

**æ€§èƒ½**: æœ€æ…¢ï¼ˆ~80nsï¼Œéœ€è¦å†…å­˜å±éšœï¼‰

---

## ä¸‰ã€å†…å­˜å±éšœ

### 3.1 ç¡¬ä»¶å±‚é¢

**å®šä¹‰3.1 (å†…å­˜å±éšœ)**:

$$MemoryBarrier: \text{CPU instruction that enforces ordering}$$

**ç±»å‹**:

| å±éšœç±»å‹ | x86-64æŒ‡ä»¤ | ARMæŒ‡ä»¤ | ä½œç”¨ |
|---------|-----------|---------|------|
| **Loadå±éšœ** | `lfence` | `DMB LD` | é˜²æ­¢åç»­loadé‡æ’åˆ°å‰é¢ |
| **Storeå±éšœ** | `sfence` | `DMB ST` | é˜²æ­¢åç»­storeé‡æ’åˆ°å‰é¢ |
| **Fullå±éšœ** | `mfence` | `DMB SY` | é˜²æ­¢æ‰€æœ‰é‡æ’åº |

**Rust Orderingåˆ°ç¡¬ä»¶æŒ‡ä»¤**:

| Rust Ordering | x86-64 | ARM |
|--------------|--------|-----|
| Relaxed | æ— å±éšœ | æ— å±éšœ |
| Acquire | æ— å±éšœ* | `DMB LD` |
| Release | æ— å±éšœ* | `DMB ST` |
| AcqRel | æ— å±éšœ* | `DMB` |
| SeqCst | `mfence` | `DMB SY` |

*x86-64æ˜¯å¼ºå†…å­˜æ¨¡å‹ï¼Œå¾ˆå¤šorderingæ— éœ€æ˜¾å¼å±éšœ

### 3.2 ç¼–è¯‘å™¨å±éšœ

**ä½œç”¨**: é˜²æ­¢**ç¼–è¯‘å™¨é‡æ’åº**

```rust
// Rustä¸­æ‰€æœ‰åŸå­æ“ä½œéƒ½æ˜¯ç¼–è¯‘å™¨å±éšœ
std::sync::atomic::compiler_fence(Ordering::SeqCst);

// ç­‰ä»·äºC++
std::atomic_signal_fence(std::memory_order_seq_cst);
```

---

## å››ã€ä¸C++å†…å­˜æ¨¡å‹å¯¹æ¯”

### 4.1 C++20å†…å­˜æ¨¡å‹

**Orderingå¯¹åº”**:

| Rust | C++20 | è¯´æ˜ |
|------|-------|------|
| `Relaxed` | `memory_order_relaxed` | å®Œå…¨ç›¸åŒ |
| `Acquire` | `memory_order_acquire` | å®Œå…¨ç›¸åŒ |
| `Release` | `memory_order_release` | å®Œå…¨ç›¸åŒ |
| `AcqRel` | `memory_order_acq_rel` | å®Œå…¨ç›¸åŒ |
| `SeqCst` | `memory_order_seq_cst` | å®Œå…¨ç›¸åŒ |

Rustéµå¾ª**C++å†…å­˜æ¨¡å‹**ï¼

### 4.2 å…³é”®å·®å¼‚

**å·®å¼‚1**: Rustå…è®¸åŸå­ä¸éåŸå­è¯»å¹¶å‘

```cpp
// C++: æœªå®šä¹‰è¡Œä¸º
std::atomic<int> x;
x.store(1, std::memory_order_relaxed);
int y = x;  // âŒ UB: éåŸå­è¯»åŸå­å˜é‡

// Rust: å…è®¸ï¼ˆä½†ä¸æ¨èï¼‰
let x = AtomicI32::new(0);
x.store(1, Ordering::Relaxed);
// unsafe { *(x.as_ptr()) }  // âš ï¸ å…è®¸ä½†å±é™©
```

**å·®å¼‚2**: RuståŸºäº**è®¿é—®**è€Œé**å¯¹è±¡**

```rust
// Rust: å¤šä¸ªç‹¬ç«‹çš„åŸå­å˜é‡å¯ä»¥å¹¶å‘è®¿é—®
struct Data {
    x: AtomicI32,
    y: AtomicI32,
}

// çº¿ç¨‹1: è®¿é—®x
data.x.store(1, Ordering::Relaxed);

// çº¿ç¨‹2: è®¿é—®y (âœ… æ— æ•°æ®ç«äº‰)
data.y.store(2, Ordering::Relaxed);
```

---

## äº”ã€å½¢å¼åŒ–è¯­ä¹‰

### 5.1 Promisingè¯­ä¹‰

**æ ¸å¿ƒæ€æƒ³**: æ“ä½œå¯ä»¥"æ‰¿è¯º"æœªæ¥çš„å†™å…¥

**å½¢å¼åŒ–æ¨¡å‹**:

$$State = (Memory, Promises, ThreadStates)$$

**çŠ¶æ€è½¬æ¢**:

```
Thread i æ‰§è¡Œ store(x, v, Release):
1. æ·»åŠ æ‰¿è¯º: Promises += {(x, v, t)}
2. ç­‰å¾…æ‰¿è¯ºå…‘ç°
3. å†™å…¥å†…å­˜: Memory[x] = v
4. ç§»é™¤æ‰¿è¯º: Promises -= {(x, v, t)}
```

**å®šç†5.1 (Promisingè¯­ä¹‰æ­£ç¡®æ€§)**:

$$\forall \text{well-formed programs}: \text{Promising semantics} \equiv \text{C++11 semantics}$$

è¯æ˜è§: Kang et al. (2017) "A Promising Semantics for Relaxed-Memory Concurrency"

### 5.2 æ•°æ®ç«äº‰å®šä¹‰

**å®šä¹‰5.2 (æ•°æ®ç«äº‰)**:

$$DataRace \iff \exists op_1, op_2: $$
$$\neg(op_1 \xrightarrow{hb} op_2) \land \neg(op_2 \xrightarrow{hb} op_1) \land$$
$$\text{SameLocation}(op_1, op_2) \land (\text{IsWrite}(op_1) \lor \text{IsWrite}(op_2))$$

**é€šä¿—è§£é‡Š**: ä¸¤ä¸ª**å¹¶å‘**æ“ä½œè®¿é—®**åŒä¸€ä½ç½®**ï¼Œä¸”è‡³å°‘ä¸€ä¸ªæ˜¯**å†™**

**Rustä¿è¯**: å€Ÿç”¨æ£€æŸ¥å™¨åœ¨**ç¼–è¯‘æœŸæœç»æ•°æ®ç«äº‰**

---

## å…­ã€åŒæ­¥åŸè¯­å®ç°

### 6.1 è‡ªæ—‹é”

```rust
use std::sync::atomic::{AtomicBool, Ordering};

pub struct SpinLock {
    locked: AtomicBool,
}

impl SpinLock {
    pub const fn new() -> Self {
        SpinLock {
            locked: AtomicBool::new(false),
        }
    }

    pub fn lock(&self) {
        // è‡ªæ—‹ç›´åˆ°è·å–é”
        while self.locked.swap(true, Ordering::Acquire) {
            // æç¤ºCPU: è‡ªæ—‹ç­‰å¾…ï¼ˆé™ä½åŠŸè€—ï¼‰
            std::hint::spin_loop();
        }
        // è·å–é”åï¼ŒAcquireä¿è¯ä¹‹å‰çš„Releaseæ“ä½œå¯è§
    }

    pub fn unlock(&self) {
        // Releaseä¿è¯ä¸´ç•ŒåŒºå†…çš„æ“ä½œå¯¹åç»­Acquireå¯è§
        self.locked.store(false, Ordering::Release);
    }
}
```

**happens-beforeåˆ†æ**:

```text
Thread A:
lock()  // Acquire
  critical_section()
unlock()  // Release
    â†“ (synchronizes-with)
Thread B:
lock()  // Acquire
  critical_section()
unlock()
```

### 6.2 æ— é”æ ˆ

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

pub struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> LockFreeStack<T> {
    pub fn new() -> Self {
        LockFreeStack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    pub fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        let mut head = self.head.load(Ordering::Relaxed);

        loop {
            unsafe {
                (*new_node).next = head;
            }

            // AcqRel: è¯»å–æœ€æ–°head + å‘å¸ƒæ–°èŠ‚ç‚¹
            match self.head.compare_exchange(
                head,
                new_node,
                Ordering::AcqRel,  // æˆåŠŸ
                Ordering::Acquire  // å¤±è´¥ï¼Œé‡æ–°è¯»å–head
            ) {
                Ok(_) => break,
                Err(h) => head = h,  // é‡è¯•
            }
        }
    }

    pub fn pop(&self) -> Option<T> {
        let mut head = self.head.load(Ordering::Acquire);

        loop {
            if head.is_null() {
                return None;
            }

            let next = unsafe { (*head).next };

            match self.head.compare_exchange(
                head,
                next,
                Ordering::AcqRel,
                Ordering::Acquire
            ) {
                Ok(_) => {
                    let data = unsafe { Box::from_raw(head).data };
                    return Some(data);
                }
                Err(h) => head = h,
            }
        }
    }
}
```

**ABAé—®é¢˜**: éœ€è¦é¢å¤–çš„ç‰ˆæœ¬å·æˆ–Epochå›æ”¶

---

## ä¸ƒã€ä¸LSEM L1å±‚çš„æ˜ å°„

### 7.1 æ—¶ç©ºæˆ³æ˜ å°„

| LSEM L1 | Rustå†…å­˜æ¨¡å‹ |
|---------|-------------|
| **æ—¶é—´æˆ³** | Orderingçº§åˆ« |
| **ååºå…³ç³»** | happens-before |
| **å¯è§æ€§** | åŒæ­¥ç‚¹å»ºç«‹çš„å¯è§æ€§ |
| **å†²çª** | æ•°æ®ç«äº‰ |

### 7.2 å¯è§æ€§è§„åˆ™æ˜ å°„

**L1å¯è§æ€§è§„åˆ™**:

$$Visible_{L1}(op_1, op_2) \iff op_1 \xrightarrow{hb} op_2$$

**å®ç°**:

```rust
// ç¼–è¯‘å™¨å’ŒCPUå…±åŒä¿è¯happens-before
fn visibility_guarantee() {
    // å†™çº¿ç¨‹
    DATA.store(42, Ordering::Relaxed);
    FLAG.store(true, Ordering::Release);  // â† åŒæ­¥ç‚¹

    // è¯»çº¿ç¨‹
    if FLAG.load(Ordering::Acquire) {     // â† åŒæ­¥ç‚¹
        let value = DATA.load(Ordering::Relaxed);
        // ä¿è¯: value = 42
    }
}
```

### 7.3 ä¸L0å±‚å¯¹æ¯”

| ç»´åº¦ | L0 (PostgreSQL) | L1 (Rust) |
|-----|----------------|-----------|
| **æ—¶åºä¿è¯** | äº‹åŠ¡IDå…¨åº | happens-beforeååº |
| **å¯è§æ€§æ£€æŸ¥** | è¿è¡Œæ—¶ï¼ˆæŸ¥pg_clogï¼‰ | ç¼–è¯‘æœŸ+ç¡¬ä»¶å±éšœ |
| **å†²çªæ£€æµ‹** | è¿è¡Œæ—¶ï¼ˆé”ç®¡ç†å™¨ï¼‰ | ç¼–è¯‘æœŸï¼ˆå€Ÿç”¨æ£€æŸ¥ï¼‰ |
| **æ€§èƒ½å¼€é”€** | ä¸­ï¼ˆå¿«ç…§ç»´æŠ¤ï¼‰ | ä½ï¼ˆé›¶æŠ½è±¡ï¼‰ |

---

## å…«ã€æ€§èƒ½åˆ†æ

### 8.1 Orderingå¼€é”€å¯¹æ¯”

**å®éªŒè®¾ç½®**: 1äº¿æ¬¡åŸå­æ“ä½œ

| Ordering | æ—¶é—´ (ms) | ç›¸å¯¹å¼€é”€ |
|----------|-----------|---------|
| Relaxed | 1000 | 1.0Ã— |
| Acquire | 1200 | 1.2Ã— |
| Release | 1200 | 1.2Ã— |
| AcqRel | 1500 | 1.5Ã— |
| SeqCst | 2500 | 2.5Ã— |

**ç»“è®º**: SeqCstå¼€é”€æœ€å¤§ï¼ŒRelaxedæœ€å¿«

### 8.2 é”å¼€é”€å¯¹æ¯”

| åŒæ­¥æœºåˆ¶ | æ— ç«äº‰ | æœ‰ç«äº‰ |
|---------|--------|--------|
| **Atomic CAS** | 10ns | 50ns |
| **SpinLock** | 50ns | 500ns |
| **Mutex** | 50ns | 5000ns |
| **RwLock** | 30ns | 1000ns |

**å»ºè®®**: ä¸´ç•ŒåŒº<100nsç”¨SpinLockï¼Œå¦åˆ™ç”¨Mutex

---

## ä¹ã€å¸¸è§æ¨¡å¼

### æ¨¡å¼1: Lazy Initialization

```rust
use std::sync::{Arc, Once};

static INIT: Once = Once::new();
static mut DATA: Option<Vec<i32>> = None;

fn get_data() -> &'static Vec<i32> {
    unsafe {
        INIT.call_once(|| {
            DATA = Some(vec![1, 2, 3]);
        });
        DATA.as_ref().unwrap()
    }
}
```

**happens-before**: `call_once`å†…çš„æ“ä½œå¯¹æ‰€æœ‰åç»­è°ƒç”¨å¯è§

### æ¨¡å¼2: åŒé‡æ£€æŸ¥é”

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::sync::Mutex;

struct LazyValue {
    ptr: AtomicPtr<Data>,
    lock: Mutex<()>,
}

impl LazyValue {
    fn get(&self) -> &Data {
        // ç¬¬ä¸€æ¬¡æ£€æŸ¥ï¼ˆå¿«é€Ÿè·¯å¾„ï¼‰
        let ptr = self.ptr.load(Ordering::Acquire);
        if !ptr.is_null() {
            return unsafe { &*ptr };
        }

        // åŠ é”åˆå§‹åŒ–
        let _guard = self.lock.lock().unwrap();

        // ç¬¬äºŒæ¬¡æ£€æŸ¥ï¼ˆé˜²æ­¢é‡å¤åˆå§‹åŒ–ï¼‰
        let ptr = self.ptr.load(Ordering::Relaxed);
        if !ptr.is_null() {
            return unsafe { &*ptr };
        }

        // åˆå§‹åŒ–
        let data = Box::into_raw(Box::new(Data::new()));
        self.ptr.store(data, Ordering::Release);

        unsafe { &*data }
    }
}
```

### æ¨¡å¼3: Seqlock

```rust
struct SeqLock<T> {
    seq: AtomicUsize,
    data: UnsafeCell<T>,
}

impl<T: Copy> SeqLock<T> {
    fn read(&self) -> T {
        loop {
            let seq1 = self.seq.load(Ordering::Acquire);

            if seq1 % 2 == 1 {
                // å†™æ“ä½œè¿›è¡Œä¸­ï¼Œé‡è¯•
                std::hint::spin_loop();
                continue;
            }

            let data = unsafe { *self.data.get() };

            let seq2 = self.seq.load(Ordering::Acquire);

            if seq1 == seq2 {
                return data;  // è¯»å–æˆåŠŸ
            }
            // å¦åˆ™é‡è¯•
        }
    }

    fn write(&self, value: T) {
        let seq = self.seq.fetch_add(1, Ordering::Release);
        // seqç°åœ¨æ˜¯å¥‡æ•°ï¼Œè¡¨ç¤ºå†™å…¥ä¸­

        unsafe {
            *self.data.get() = value;
        }

        self.seq.store(seq + 2, Ordering::Release);
        // seqç°åœ¨æ˜¯å¶æ•°ï¼Œè¡¨ç¤ºå†™å…¥å®Œæˆ
    }
}
```

**é€‚ç”¨åœºæ™¯**: è¯»å¤šå†™å°‘ï¼ˆå¦‚é…ç½®æ›´æ–°ï¼‰

---

## åã€æ€»ç»“

### 10.1 æ ¸å¿ƒè´¡çŒ®

**ç†è®ºè´¡çŒ®**:

1. **happens-beforeå½¢å¼åŒ–**ï¼ˆç¬¬ä¸€ç« ï¼‰
2. **Orderingè¯­ä¹‰è¯¦è§£**ï¼ˆç¬¬äºŒç« ï¼‰
3. **å†…å­˜å±éšœåˆ†æ**ï¼ˆç¬¬ä¸‰ç« ï¼‰
4. **ä¸LSEM L1æ˜ å°„**ï¼ˆç¬¬ä¸ƒç« ï¼‰

**å·¥ç¨‹ä»·å€¼**:

1. **è‡ªæ—‹é”å®ç°**ï¼ˆç¬¬6.1èŠ‚ï¼‰
2. **æ— é”æ ˆå®ç°**ï¼ˆç¬¬6.2èŠ‚ï¼‰
3. **å¸¸è§æ¨¡å¼**ï¼ˆç¬¬ä¹ç« ï¼‰

### 10.2 å…³é”®å…¬å¼

**happens-beforeä¼ é€’æ€§**:

$$e_1 \xrightarrow{hb} e_2 \land e_2 \xrightarrow{hb} e_3 \implies e_1 \xrightarrow{hb} e_3$$

**Release-AcquireåŒæ­¥**:

$$\text{store}(Release) \xrightarrow{sync} \text{load}(Acquire) \implies \text{å…¨å±€å¯è§}$$

**æ•°æ®ç«äº‰å……è¦æ¡ä»¶**:

$$DataRace \iff \text{Concurrent} \land \text{SameLocation} \land \text{AtLeastOneWrite}$$

### 10.3 è®¾è®¡åŸåˆ™

1. **é»˜è®¤Relaxed**: ä»…éœ€åŸå­æ€§æ—¶
2. **Release-Acquire**: éœ€è¦åŒæ­¥æ—¶
3. **SeqCstè°¨æ…**: ä»…åœ¨ç»å¯¹å¿…è¦æ—¶
4. **é¿å…æ•°æ®ç«äº‰**: ä¾èµ–å€Ÿç”¨æ£€æŸ¥å™¨

---

## åä¸€ã€å»¶ä¼¸é˜…è¯»

**ç†è®ºåŸºç¡€**:

- Lamport, L. (1979). "How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs"
- Adve, S. V., & Gharachorloo, K. (1996). "Shared Memory Consistency Models"
- Boehm, H., & Adve, S. V. (2008). "Foundations of the C++ Concurrency Memory Model"

**Rustå†…å­˜æ¨¡å‹**:

- Rust Nomicon: Atomicsç« èŠ‚
- Rust RFC 2492: Memory Model
- Kang, J., et al. (2017). "A Promising Semantics for Relaxed-Memory Concurrency"

**å®ç°ç»†èŠ‚**:

- LLVM Atomicsæ–‡æ¡£
- Rustæ ‡å‡†åº“æºç : `library/core/src/sync/atomic.rs`

**æ‰©å±•æ–¹å‘**:

- `03-è¯æ˜ä¸å½¢å¼åŒ–/04-æ‰€æœ‰æƒå®‰å…¨æ€§è¯æ˜.md` â†’ happens-beforeè¯æ˜
- `05-å®ç°æœºåˆ¶/05-Rust-å¹¶å‘åŸè¯­.md` â†’ æ ‡å‡†åº“å®ç°
- `06-æ€§èƒ½åˆ†æ/02-å»¶è¿Ÿåˆ†ææ¨¡å‹.md` â†’ åŸå­æ“ä½œæ€§èƒ½

---

**ç‰ˆæœ¬**: 1.0.0
**æœ€åæ›´æ–°**: 2025-12-05
**å…³è”æ–‡æ¡£**:

- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/06-æ‰€æœ‰æƒæ¨¡å‹(Rust).md`
- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/01-åˆ†å±‚çŠ¶æ€æ¼”åŒ–æ¨¡å‹(LSEM).md`
- `05-å®ç°æœºåˆ¶/05-Rust-å¹¶å‘åŸè¯­.md`
