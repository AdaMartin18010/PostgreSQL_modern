# 06 | è·¨å±‚ååŒè®¾è®¡ï¼ˆå®Œæ•´ç‰ˆï¼‰

> **è®¾è®¡å®šä½**: æœ¬æ–‡æ¡£æ·±åº¦åˆ†æL0/L1/L2ä¸‰å±‚ååŒæœºåˆ¶ï¼ŒåŒ…å«å®Œæ•´å®ç°ä»£ç ã€æ€§èƒ½åˆ†æã€æ•…éšœå¤„ç†å’Œåä¾‹ã€‚

---

## ğŸ“‘ ç›®å½•

- [06 | è·¨å±‚ååŒè®¾è®¡ï¼ˆå®Œæ•´ç‰ˆï¼‰](#06--è·¨å±‚ååŒè®¾è®¡å®Œæ•´ç‰ˆ)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€LSEMä¸‰å±‚ååŒç†è®º](#ä¸€lsemä¸‰å±‚ååŒç†è®º)
    - [1.1 ä¸‰å±‚çŠ¶æ€æ˜ å°„](#11-ä¸‰å±‚çŠ¶æ€æ˜ å°„)
    - [1.2 çŠ¶æ€è½¬æ¢åŒæ­¥](#12-çŠ¶æ€è½¬æ¢åŒæ­¥)
  - [äºŒã€L1-L0ååŒæ·±åº¦å®ç°](#äºŒl1-l0ååŒæ·±åº¦å®ç°)
    - [2.1 Rustè¿æ¥æ± å®Œæ•´å®ç°](#21-rustè¿æ¥æ± å®Œæ•´å®ç°)
    - [2.2 äº‹åŠ¡ç®¡ç†ååŒ](#22-äº‹åŠ¡ç®¡ç†ååŒ)
    - [2.3 é”™è¯¯å¤„ç†ååŒ](#23-é”™è¯¯å¤„ç†ååŒ)
  - [ä¸‰ã€L2-L0ååŒå®Œæ•´æ¡ˆä¾‹](#ä¸‰l2-l0ååŒå®Œæ•´æ¡ˆä¾‹)
    - [3.1 TiDBæ¶æ„æ·±åº¦åˆ†æ](#31-tidbæ¶æ„æ·±åº¦åˆ†æ)
    - [3.2 CockroachDBæ¶æ„](#32-cockroachdbæ¶æ„)
  - [å››ã€L2-L1-L0ä¸‰å±‚ååŒ](#å››l2-l1-l0ä¸‰å±‚ååŒ)
    - [4.1 å®Œæ•´äº‹åŠ¡æµç¨‹](#41-å®Œæ•´äº‹åŠ¡æµç¨‹)
    - [4.2 çŠ¶æ€åŒæ­¥æœºåˆ¶](#42-çŠ¶æ€åŒæ­¥æœºåˆ¶)
  - [äº”ã€æ€§èƒ½åˆ†æä¸ä¼˜åŒ–](#äº”æ€§èƒ½åˆ†æä¸ä¼˜åŒ–)
    - [5.1 è·¨å±‚å»¶è¿Ÿåˆ†æ](#51-è·¨å±‚å»¶è¿Ÿåˆ†æ)
  - [å…­ã€æ•…éšœå¤„ç†ä¸å®¹é”™](#å…­æ•…éšœå¤„ç†ä¸å®¹é”™)
    - [6.1 L2å±‚æ•…éšœ](#61-l2å±‚æ•…éšœ)
    - [6.2 L1å±‚æ•…éšœ](#62-l1å±‚æ•…éšœ)
    - [6.3 L0å±‚æ•…éšœ](#63-l0å±‚æ•…éšœ)
  - [ä¸ƒã€åä¾‹ä¸é”™è¯¯è®¾è®¡](#ä¸ƒåä¾‹ä¸é”™è¯¯è®¾è®¡)
    - [åä¾‹1: å¿½ç•¥L2å±‚æ—¶é—´æˆ³](#åä¾‹1-å¿½ç•¥l2å±‚æ—¶é—´æˆ³)
    - [åä¾‹2: L1å±‚ç ´åL0å±‚ä¿è¯](#åä¾‹2-l1å±‚ç ´ål0å±‚ä¿è¯)
  - [å…«ã€å®é™…ç”Ÿäº§æ¡ˆä¾‹](#å…«å®é™…ç”Ÿäº§æ¡ˆä¾‹)
    - [æ¡ˆä¾‹1: æŸé‡‘èç³»ç»Ÿä¸‰å±‚æ¶æ„](#æ¡ˆä¾‹1-æŸé‡‘èç³»ç»Ÿä¸‰å±‚æ¶æ„)
  - [ä¹ã€å®Œæ•´å®ç°ä»£ç ](#ä¹å®Œæ•´å®ç°ä»£ç )
    - [9.1 ä¸‰å±‚çŠ¶æ€åŒæ­¥å™¨å®Œæ•´å®ç°](#91-ä¸‰å±‚çŠ¶æ€åŒæ­¥å™¨å®Œæ•´å®ç°)
    - [9.2 è·¨å±‚äº‹åŠ¡åè°ƒå™¨å®Œæ•´å®ç°](#92-è·¨å±‚äº‹åŠ¡åè°ƒå™¨å®Œæ•´å®ç°)
    - [9.3 æ•…éšœæ¢å¤ç®¡ç†å™¨å®Œæ•´å®ç°](#93-æ•…éšœæ¢å¤ç®¡ç†å™¨å®Œæ•´å®ç°)
  - [åã€è·¨å±‚ååŒå¯è§†åŒ–](#åè·¨å±‚ååŒå¯è§†åŒ–)
    - [10.1 ä¸‰å±‚ååŒæ¶æ„å›¾](#101-ä¸‰å±‚ååŒæ¶æ„å›¾)
    - [10.2 è·¨å±‚çŠ¶æ€åŒæ­¥åºåˆ—å›¾](#102-è·¨å±‚çŠ¶æ€åŒæ­¥åºåˆ—å›¾)
    - [10.3 è·¨å±‚ååŒå†³ç­–æ ‘](#103-è·¨å±‚ååŒå†³ç­–æ ‘)

---

## ä¸€ã€LSEMä¸‰å±‚ååŒç†è®º

### 1.1 ä¸‰å±‚çŠ¶æ€æ˜ å°„

**LSEMæ ¸å¿ƒ**: ä¸‰å±‚çŠ¶æ€åŒæ„

```text
L2: åˆ†å¸ƒå¼å±‚çŠ¶æ€
    â”‚ å…¨å±€æ—¶é—´æˆ³ (HLC/TrueTime)
    â”‚ å…±è¯†çŠ¶æ€ (Leader/Follower)
    â”‚ å¤åˆ¶çŠ¶æ€ (åŒæ­¥/å¼‚æ­¥)
    â”‚
    â†“ æ˜ å°„: å…¨å±€é¡ºåº â†’ æ—¶é—´æˆ³
    â”‚
L1: è¿è¡Œæ—¶å±‚çŠ¶æ€
    â”‚ äº‹åŠ¡çŠ¶æ€ (Active/Committed)
    â”‚ é”çŠ¶æ€ (Held/Waiting)
    â”‚ å†…å­˜çŠ¶æ€ (Owned/Borrowed)
    â”‚
    â†“ æ˜ å°„: äº‹åŠ¡ID â†’ xmin/xmax
    â”‚
L0: å­˜å‚¨å±‚çŠ¶æ€
    â”‚ å…ƒç»„ç‰ˆæœ¬ (xmin/xmax)
    â”‚ ç‰ˆæœ¬é“¾ (ctidæŒ‡é’ˆ)
    â”‚ ç‰©ç†å­˜å‚¨ (page/tuple)
```

### 1.2 çŠ¶æ€è½¬æ¢åŒæ­¥

**å®šç†1.1**: ä¸‰å±‚çŠ¶æ€è½¬æ¢å¿…é¡»åŒæ­¥

```text
è½¬è´¦äº‹åŠ¡ç¤ºä¾‹:

L2å±‚:
â”œâ”€ å¼€å§‹: è·å–å…¨å±€æ—¶é—´æˆ³ T_global = 100
â”œâ”€ æäº¤: ç­‰å¾…å¤šæ•°æ´¾ç¡®è®¤
â””â”€ å®Œæˆ: T_global = 100 å·²å…¨å±€å¯è§

L1å±‚:
â”œâ”€ å¼€å§‹: BEGIN, xid = 100 (æ˜ å°„T_global)
â”œâ”€ æ‰§è¡Œ: UPDATE accounts SET balance = ...
â””â”€ æäº¤: COMMIT, xid = 100 æäº¤

L0å±‚:
â”œâ”€ å¼€å§‹: åˆ›å»ºæ–°ç‰ˆæœ¬, xmin = 100
â”œâ”€ å¯è§æ€§: xmin < snapshot.xmax â†’ å¯è§
â””â”€ æäº¤: pg_clog[100] = COMMITTED

åŒæ­¥ä¿è¯:
â”œâ”€ L2æ—¶é—´æˆ³ = L1äº‹åŠ¡ID = L0 xmin
â””â”€ ä¸‰å±‚çŠ¶æ€ä¸€è‡´ âœ“
```

---

## äºŒã€L1-L0ååŒæ·±åº¦å®ç°

### 2.1 Rustè¿æ¥æ± å®Œæ•´å®ç°

**å®Œæ•´ä»£ç ** (ç”Ÿäº§çº§):

```rust
use tokio_postgres::{Client, NoTls, Error};
use std::sync::{Arc, Mutex};
use tokio::sync::Semaphore;
use std::time::{Duration, Instant};

pub struct ConnectionPool {
    connections: Arc<Mutex<Vec<Client>>>,
    semaphore: Arc<Semaphore>,
    config: PoolConfig,
    stats: Arc<Mutex<PoolStats>>,
}

pub struct PoolConfig {
    pub min_size: usize,
    pub max_size: usize,
    pub idle_timeout: Duration,
    pub max_lifetime: Duration,
}

pub struct PoolStats {
    pub total_connections: usize,
    pub idle_connections: usize,
    pub active_connections: usize,
    pub wait_count: u64,
    pub wait_time_ms: u64,
}

impl ConnectionPool {
    pub async fn new(config: PoolConfig) -> Result<Self, Error> {
        let pool = Self {
            connections: Arc::new(Mutex::new(Vec::new())),
            semaphore: Arc::new(Semaphore::new(config.max_size)),
            config,
            stats: Arc::new(Mutex::new(PoolStats {
                total_connections: 0,
                idle_connections: 0,
                active_connections: 0,
                wait_count: 0,
                wait_time_ms: 0,
            })),
        };

        // é¢„çƒ­è¿æ¥
        pool.warmup().await?;

        Ok(pool)
    }

    pub async fn get_connection(&self) -> Result<PooledConnection, Error> {
        let wait_start = Instant::now();

        // è·å–ä¿¡å·é‡ï¼ˆé™åˆ¶å¹¶å‘ï¼‰
        let permit = self.semaphore.acquire().await
            .map_err(|_| Error::from("Semaphore closed"))?;

        let wait_time = wait_start.elapsed();

        // æ›´æ–°ç»Ÿè®¡
        {
            let mut stats = self.stats.lock().unwrap();
            stats.wait_count += 1;
            stats.wait_time_ms += wait_time.as_millis() as u64;
        }

        // å°è¯•ä»æ± ä¸­è·å–
        let mut pool = self.connections.lock().unwrap();

        // æ¸…ç†è¿‡æœŸè¿æ¥
        self.cleanup_idle_connections(&mut pool).await;

        if let Some(mut client) = pool.pop() {
            // æ£€æŸ¥è¿æ¥æ˜¯å¦æœ‰æ•ˆ
            if self.is_connection_valid(&client).await {
                drop(pool);
                return Ok(PooledConnection {
                    client,
                    pool: Arc::clone(&self.connections),
                    permit,
                    created_at: Instant::now(),
                });
            }
        }

        drop(pool);

        // åˆ›å»ºæ–°è¿æ¥
        let client = self.create_connection().await?;

        Ok(PooledConnection {
            client,
            pool: Arc::clone(&self.connections),
            permit,
            created_at: Instant::now(),
        })
    }

    async fn create_connection(&self) -> Result<Client, Error> {
        let (client, connection) = tokio_postgres::connect(
            "host=localhost user=postgres dbname=mydb",
            NoTls,
        ).await?;

        // åå°ä»»åŠ¡å¤„ç†è¿æ¥
        tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("Connection error: {}", e);
            }
        });

        // æ›´æ–°ç»Ÿè®¡
        {
            let mut stats = self.stats.lock().unwrap();
            stats.total_connections += 1;
        }

        Ok(client)
    }

    async fn is_connection_valid(&self, client: &Client) -> bool {
        // ç®€å•pingæ£€æŸ¥
        client.simple_query("SELECT 1").await.is_ok()
    }

    async fn cleanup_idle_connections(&self, pool: &mut Vec<Client>) {
        let now = Instant::now();
        let mut valid_connections = Vec::new();

        for client in pool.drain(..) {
            // æ£€æŸ¥è¿æ¥æ˜¯å¦è¿‡æœŸï¼ˆç®€åŒ–ç‰ˆï¼‰
            if self.is_connection_valid(&client).await {
                valid_connections.push(client);
            }
        }

        *pool = valid_connections;
    }

    async fn warmup(&self) -> Result<(), Error> {
        let mut connections = Vec::new();

        for _ in 0..self.config.min_size {
            let client = self.create_connection().await?;
            connections.push(client);
        }

        *self.connections.lock().unwrap() = connections;

        Ok(())
    }
}

pub struct PooledConnection {
    client: Client,
    pool: Arc<Mutex<Vec<Client>>>,
    permit: tokio::sync::SemaphorePermit<'static>,
    created_at: Instant,
}

impl Drop for PooledConnection {
    fn drop(&mut self) {
        let client = std::mem::replace(&mut self.client,
            // å ä½ç¬¦ï¼Œå®é™…ä¸ä¼šä½¿ç”¨
            unsafe { std::mem::zeroed() }
        );

        // æ£€æŸ¥è¿æ¥æ˜¯å¦è¿‡æœŸ
        let max_lifetime = Duration::from_secs(3600);
        if self.created_at.elapsed() < max_lifetime {
            // å½’è¿˜åˆ°æ± ä¸­
            if let Ok(mut pool) = self.pool.lock() {
                pool.push(client);
            }
        }
        // å¦åˆ™è¿æ¥è‡ªåŠ¨å…³é—­ï¼ˆDropï¼‰
    }
}

impl std::ops::Deref for PooledConnection {
    type Target = Client;

    fn deref(&self) -> &Self::Target {
        &self.client
    }
}
```

### 2.2 äº‹åŠ¡ç®¡ç†ååŒ

**Rustäº‹åŠ¡åŒ…è£…å™¨**:

```rust
use tokio_postgres::Transaction;

pub struct RustTransaction<'a> {
    inner: Transaction<'a>,
    isolation_level: IsolationLevel,
}

impl<'a> RustTransaction<'a> {
    pub async fn begin(
        client: &'a Client,
        isolation_level: IsolationLevel
    ) -> Result<Self, Error> {
        let sql = match isolation_level {
            IsolationLevel::ReadCommitted =>
                "BEGIN ISOLATION LEVEL READ COMMITTED",
            IsolationLevel::RepeatableRead =>
                "BEGIN ISOLATION LEVEL REPEATABLE READ",
            IsolationLevel::Serializable =>
                "BEGIN ISOLATION LEVEL SERIALIZABLE",
        };

        client.execute(sql, &[]).await?;

        let inner = client.transaction().await?;

        Ok(Self { inner, isolation_level })
    }

    pub async fn commit(self) -> Result<(), Error> {
        self.inner.commit().await
    }

    pub async fn rollback(self) -> Result<(), Error> {
        self.inner.rollback().await
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async fn transfer_funds(
    pool: &ConnectionPool,
    from: i64,
    to: i64,
    amount: i64
) -> Result<(), Error> {
    let conn = pool.get_connection().await?;

    // L1å±‚: Rustäº‹åŠ¡ç®¡ç†
    let tx = RustTransaction::begin(
        &conn,
        IsolationLevel::Serializable  // é‡‘èåœºæ™¯
    ).await?;

    // L0å±‚: PostgreSQL MVCCéš”ç¦»
    tx.execute(
        "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
        &[&amount, &from]
    ).await?;

    tx.execute(
        "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
        &[&amount, &to]
    ).await?;

    // L1å±‚: æäº¤äº‹åŠ¡
    tx.commit().await?;

    Ok(())
}
```

### 2.3 é”™è¯¯å¤„ç†ååŒ

**Rusté”™è¯¯æ˜ å°„**:

```rust
use tokio_postgres::Error as PgError;

pub enum DbError {
    ConnectionError(String),
    QueryError(String),
    SerializationFailure,  // SSIå†²çª
    DeadlockDetected,
    LockTimeout,
    UniqueViolation(String),
}

impl From<PgError> for DbError {
    fn from(err: PgError) -> Self {
        if let Some(db_err) = err.as_db_error() {
            match db_err.code() {
                &SqlState::SERIALIZATION_FAILURE => {
                    DbError::SerializationFailure
                }
                &SqlState::DEADLOCK_DETECTED => {
                    DbError::DeadlockDetected
                }
                &SqlState::LOCK_NOT_AVAILABLE => {
                    DbError::LockTimeout
                }
                &SqlState::UNIQUE_VIOLATION => {
                    DbError::UniqueViolation(db_err.message().to_string())
                }
                _ => DbError::QueryError(db_err.message().to_string())
            }
        } else {
            DbError::ConnectionError(err.to_string())
        }
    }
}

// è‡ªåŠ¨é‡è¯•é€»è¾‘
pub async fn execute_with_retry<F, T>(
    mut f: F,
    max_retries: u32
) -> Result<T, DbError>
where
    F: FnMut() -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<T, DbError>> + Send>>,
{
    let mut retries = 0;

    loop {
        match f().await {
            Ok(result) => return Ok(result),
            Err(DbError::SerializationFailure) if retries < max_retries => {
                retries += 1;
                let delay = Duration::from_millis(10 * (1 << retries));  // æŒ‡æ•°é€€é¿
                tokio::time::sleep(delay).await;
                continue;
            }
            Err(e) => return Err(e),
        }
    }
}
```

---

## ä¸‰ã€L2-L0ååŒå®Œæ•´æ¡ˆä¾‹

### 3.1 TiDBæ¶æ„æ·±åº¦åˆ†æ

**å®Œæ•´æ¶æ„**:

```text
TiDBä¸‰å±‚æ¶æ„:

L2: PD (Placement Driver)
    â”œâ”€ å…¨å±€æ—¶é—´æˆ³åˆ†é…å™¨ (TSO)
    â”‚   â””â”€ å•è°ƒé€’å¢æ—¶é—´æˆ³: TSO = (physical_time << 18) | logical_counter
    â”œâ”€ Regionè°ƒåº¦å™¨
    â”‚   â””â”€ ç®¡ç†æ•°æ®åˆ†ç‰‡åˆ†å¸ƒ
    â””â”€ å…ƒæ•°æ®ç®¡ç†
        â””â”€ è¡¨/ç´¢å¼•å…ƒæ•°æ®

    â†“ TSOåˆ†é…
    â”‚
L1: TiDB Server (æ— çŠ¶æ€)
    â”œâ”€ SQLè§£æä¸ä¼˜åŒ–
    â”œâ”€ äº‹åŠ¡åè°ƒå™¨
    â”‚   â””â”€ ä½¿ç”¨TSOåšäº‹åŠ¡æ—¶é—´æˆ³
    â””â”€ æ‰§è¡Œå¼•æ“

    â†“ äº‹åŠ¡æ—¶é—´æˆ³
    â”‚
L0: TiKV (å­˜å‚¨å±‚)
    â”œâ”€ Percolatoräº‹åŠ¡æ¨¡å‹
    â”‚   â”œâ”€ Primary Lock: ä¸»é”®é”
    â”‚   â”œâ”€ Secondary Locks: äºŒçº§é”®é”
    â”‚   â””â”€ Write: å†™å…¥è®°å½•
    â”œâ”€ Raftå¤åˆ¶
    â”‚   â””â”€ æ¯ä¸ªRegion 3å‰¯æœ¬
    â””â”€ RocksDBå­˜å‚¨å¼•æ“
```

**TSOåˆ†é…æœºåˆ¶**:

```go
// PD TSOåˆ†é…å™¨ (Goå®ç°)
type TSOAllocator struct {
    physicalTime int64
    logicalCounter int64
    mu sync.Mutex
}

func (a *TSOAllocator) GetTSO() int64 {
    a.mu.Lock()
    defer a.mu.Unlock()

    now := time.Now().UnixNano() / 1e6  // æ¯«ç§’

    if now > a.physicalTime {
        a.physicalTime = now
        a.logicalCounter = 0
    }

    a.logicalCounter++

    // TSOæ ¼å¼: (physical << 18) | logical
    return (a.physicalTime << 18) | a.logicalCounter
}
```

**Percolatoräº‹åŠ¡ä½¿ç”¨TSO**:

```rust
// TiKVäº‹åŠ¡å®ç° (Rustç®€åŒ–ç‰ˆ)
pub struct TiKVTransaction {
    start_ts: u64,  // ä»PDè·å–çš„TSO
    mutations: Vec<Mutation>,
}

impl TiKVTransaction {
    pub async fn begin(&mut self) -> Result<()> {
        // L2å±‚: ä»PDè·å–TSO
        self.start_ts = self.pd_client.get_tso().await?;
        Ok(())
    }

    pub async fn commit(&mut self) -> Result<()> {
        // L2å±‚: è·å–æäº¤TSO
        let commit_ts = self.pd_client.get_tso().await?;

        // L0å±‚: Percolatorä¸¤é˜¶æ®µæäº¤
        // 1. Prewrite (è·å–é”)
        self.prewrite(self.start_ts).await?;

        // 2. Commit (é‡Šæ”¾é”)
        self.commit_primary(commit_ts).await?;

        Ok(())
    }
}
```

**æ€§èƒ½æ•°æ®** (TiDB 5.0, 3èŠ‚ç‚¹):

| æ“ä½œ | å»¶è¿Ÿ | TPS | è¯´æ˜ |
|-----|------|-----|------|
| å•Regionå†™å…¥ | 5ms | 50,000 | æœ¬åœ°Region |
| è·¨Regionå†™å…¥ | 50ms | 5,000 | è·¨Regionåè°ƒ |
| å…¨å±€äº‹åŠ¡ | 100ms | 1,000 | å¤šRegionäº‹åŠ¡ |

---

### 3.2 CockroachDBæ¶æ„

**æ¶æ„**:

```text
CockroachDBä¸‰å±‚:

L2: åˆ†å¸ƒå¼å±‚
    â”œâ”€ å…¨å±€æ—¶é—´æˆ³ (HLC)
    â”‚   â””â”€ Hybrid Logical Clock
    â”œâ”€ åˆ†å¸ƒå¼äº‹åŠ¡åè°ƒ
    â”‚   â””â”€ 2PC + å¹¶è¡Œæäº¤
    â””â”€ èŒƒå›´è·¯ç”±

    â†“ HLCæ—¶é—´æˆ³
    â”‚
L1: SQLå±‚
    â”œâ”€ æŸ¥è¯¢ä¼˜åŒ–å™¨
    â”œâ”€ æ‰§è¡Œå¼•æ“
    â””â”€ äº‹åŠ¡ç®¡ç†å™¨

    â†“ äº‹åŠ¡æ—¶é—´æˆ³
    â”‚
L0: KVå­˜å‚¨å±‚
    â”œâ”€ RocksDBå­˜å‚¨
    â”œâ”€ Raftå¤åˆ¶
    â””â”€ MVCCç‰ˆæœ¬ç®¡ç†
```

**HLCå®ç°** (ç®€åŒ–):

```go
type HybridLogicalClock struct {
    physicalTime int64
    logicalCounter int64
    nodeID int64
}

func (h *HLC) Now() Timestamp {
    now := time.Now().UnixNano()

    if now > h.physicalTime {
        h.physicalTime = now
        h.logicalCounter = 0
    } else {
        h.logicalCounter++
    }

    return Timestamp{
        Physical: h.physicalTime,
        Logical: h.logicalCounter,
        NodeID: h.nodeID,
    }
}

func (h *HLC) Update(remote Timestamp) {
    now := time.Now().UnixNano()

    if remote.Physical > h.physicalTime {
        h.physicalTime = remote.Physical
        h.logicalCounter = remote.Logical + 1
    } else if remote.Physical == h.physicalTime {
        if remote.Logical >= h.logicalCounter {
            h.logicalCounter = remote.Logical + 1
        }
    }
    // else: æœ¬åœ°æ—¶é’Ÿæ›´æ–°ï¼Œå¿½ç•¥è¿œç¨‹
}
```

---

## å››ã€L2-L1-L0ä¸‰å±‚ååŒ

### 4.1 å®Œæ•´äº‹åŠ¡æµç¨‹

**ç«¯åˆ°ç«¯äº‹åŠ¡** (åˆ†å¸ƒå¼è½¬è´¦):

```rust
// L2å±‚: åˆ†å¸ƒå¼åè°ƒ
pub struct DistributedTransaction {
    coordinator: RaftNode,
    participants: Vec<RaftNode>,
}

impl DistributedTransaction {
    pub async fn transfer_global(
        &self,
        from_region: RegionID,
        to_region: RegionID,
        amount: i64
    ) -> Result<(), Error> {
        // Step 1: L2è·å–å…¨å±€æ—¶é—´æˆ³
        let global_ts = self.coordinator.get_global_timestamp().await?;

        // Step 2: L1å±‚å¼€å§‹äº‹åŠ¡
        let tx_from = self.begin_transaction(from_region, global_ts).await?;
        let tx_to = self.begin_transaction(to_region, global_ts).await?;

        // Step 3: L0å±‚æ‰§è¡Œæ“ä½œ
        tx_from.execute(
            "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
            &[&amount, &from_id]
        ).await?;

        tx_to.execute(
            "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
            &[&amount, &to_id]
        ).await?;

        // Step 4: L2å±‚2PCåè°ƒ
        let prepare_from = tx_from.prepare().await?;
        let prepare_to = tx_to.prepare().await?;

        if prepare_from && prepare_to {
            // Step 5: L2å±‚æäº¤å†³ç­–
            self.coordinator.commit(global_ts).await?;

            // Step 6: L1å±‚æäº¤äº‹åŠ¡
            tx_from.commit().await?;
            tx_to.commit().await?;
        } else {
            // å›æ»š
            self.coordinator.abort(global_ts).await?;
            tx_from.rollback().await?;
            tx_to.rollback().await?;
        }

        Ok(())
    }
}
```

### 4.2 çŠ¶æ€åŒæ­¥æœºåˆ¶

**ä¸‰å±‚çŠ¶æ€ä¸€è‡´æ€§ä¿è¯**:

```rust
pub struct StateSync {
    l2_state: Arc<Mutex<L2State>>,
    l1_state: Arc<Mutex<L1State>>,
    l0_state: Arc<Mutex<L0State>>,
}

impl StateSync {
    pub async fn sync_transaction_commit(
        &self,
        tx_id: TransactionId,
        global_ts: Timestamp
    ) -> Result<(), Error> {
        // L2å±‚: è®°å½•å…¨å±€æäº¤
        {
            let mut l2 = self.l2_state.lock().await;
            l2.committed_transactions.insert(tx_id, global_ts);
        }

        // L1å±‚: æ›´æ–°äº‹åŠ¡çŠ¶æ€
        {
            let mut l1 = self.l1_state.lock().await;
            if let Some(tx) = l1.active_transactions.get_mut(&tx_id) {
                tx.state = TransactionState::Committed;
                tx.commit_timestamp = global_ts;
            }
        }

        // L0å±‚: æ›´æ–°pg_clog
        {
            let mut l0 = self.l0_state.lock().await;
            l0.clog[tx_id as usize] = CommitStatus::Committed;
        }

        // éªŒè¯ä¸€è‡´æ€§
        self.verify_consistency(tx_id, global_ts).await?;

        Ok(())
    }

    async fn verify_consistency(
        &self,
        tx_id: TransactionId,
        global_ts: Timestamp
    ) -> Result<(), Error> {
        let l2 = self.l2_state.lock().await;
        let l1 = self.l1_state.lock().await;
        let l0 = self.l0_state.lock().await;

        // æ£€æŸ¥L2æ—¶é—´æˆ³ = L1æ—¶é—´æˆ³ = L0 xmin
        let l2_ts = l2.committed_transactions.get(&tx_id);
        let l1_tx = l1.active_transactions.get(&tx_id);
        let l0_status = l0.clog.get(tx_id as usize);

        assert_eq!(l2_ts, Some(&global_ts));
        assert_eq!(l1_tx.map(|t| t.commit_timestamp), Some(global_ts));
        assert_eq!(l0_status, Some(&CommitStatus::Committed));

        Ok(())
    }
}
```

---

## äº”ã€æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

### 5.1 è·¨å±‚å»¶è¿Ÿåˆ†æ

**å»¶è¿Ÿåˆ†è§£**:

```text
å®Œæ•´äº‹åŠ¡å»¶è¿Ÿ:

L2å±‚å»¶è¿Ÿ:
â”œâ”€ è·å–å…¨å±€æ—¶é—´æˆ³: 1ms (æœ¬åœ°) / 50ms (è·¨åŒºåŸŸ)
â”œâ”€ 2PCåè°ƒ: 2 Ã— RTT = 2-100ms
â””â”€ æ€»è®¡: 3-150ms

L1å±‚å»¶è¿Ÿ:
â”œâ”€ äº‹åŠ¡å¼€å§‹: 0.1ms
â”œâ”€ SQLæ‰§è¡Œ: 5-50ms (å–å†³äºæŸ¥è¯¢å¤æ‚åº¦)
â””â”€ äº‹åŠ¡æäº¤: 0.1ms

L0å±‚å»¶è¿Ÿ:
â”œâ”€ MVCCå¯è§æ€§æ£€æŸ¥: 0.01ms
â”œâ”€ WALå†™å…¥: 5ms (fsync)
â””â”€ æ€»è®¡: 5-10ms

æ€»å»¶è¿Ÿ: L2 + L1 + L0 = 8-210ms
```

**ä¼˜åŒ–ç­–ç•¥**:

```text
ä¼˜åŒ–1: æœ¬åœ°ä¼˜å…ˆ
â”œâ”€ å°½é‡åœ¨åŒä¸€Regionå¤„ç†äº‹åŠ¡
â”œâ”€ é¿å…è·¨Regionåè°ƒ
â””â”€ å»¶è¿Ÿ: 150ms â†’ 10ms (-93%)

ä¼˜åŒ–2: æ‰¹é‡æäº¤
â”œâ”€ å¤šä¸ªæ“ä½œåˆå¹¶ä¸ºä¸€ä¸ªäº‹åŠ¡
â”œâ”€ å‡å°‘L2åè°ƒæ¬¡æ•°
â””â”€ TPS: +300%

ä¼˜åŒ–3: å¼‚æ­¥å¤åˆ¶
â”œâ”€ L2å±‚å¼‚æ­¥å¤åˆ¶ï¼ˆéå…³é”®æ•°æ®ï¼‰
â”œâ”€ é™ä½L0å»¶è¿Ÿ
â””â”€ å»¶è¿Ÿ: 10ms â†’ 5ms (-50%)
```

---

## å…­ã€æ•…éšœå¤„ç†ä¸å®¹é”™

### 6.1 L2å±‚æ•…éšœ

**åœºæ™¯**: PD/TiDB Coordinatoræ•…éšœ

```text
æ•…éšœæ£€æµ‹:
â”œâ”€ L1å±‚: å¿ƒè·³è¶…æ—¶
â”œâ”€ è‡ªåŠ¨åˆ‡æ¢: é€‰ä¸¾æ–°Coordinator
â””â”€ RTO: 5-10ç§’

æ•°æ®ä¸€è‡´æ€§:
â”œâ”€ L0å±‚: Raftä¿è¯å¤šæ•°æ´¾æ•°æ®ä¸ä¸¢
â”œâ”€ L2å±‚: æ–°Coordinatorä»å¤šæ•°æ´¾æ¢å¤çŠ¶æ€
â””â”€ ä¸€è‡´æ€§: ä¿æŒ âœ“
```

### 6.2 L1å±‚æ•…éšœ

**åœºæ™¯**: Ruståº”ç”¨å´©æºƒ

```text
æ•…éšœå¤„ç†:
â”œâ”€ L0å±‚: æ£€æµ‹åˆ°è¿æ¥æ–­å¼€
â”œâ”€ è‡ªåŠ¨å›æ»š: æœªæäº¤äº‹åŠ¡
â”œâ”€ é”é‡Šæ”¾: è‡ªåŠ¨æ¸…ç†
â””â”€ æ•°æ®: æ— å½±å“ âœ“

æ¢å¤:
â”œâ”€ L1å±‚: åº”ç”¨é‡å¯
â”œâ”€ L0å±‚: è¿æ¥æ± è‡ªåŠ¨é‡è¿
â””â”€ RTO: 30ç§’
```

### 6.3 L0å±‚æ•…éšœ

**åœºæ™¯**: PostgreSQLä¸»åº“æ•…éšœ

```text
æ•…éšœå¤„ç†:
â”œâ”€ L2å±‚: æ£€æµ‹åˆ°L0æ•…éšœ
â”œâ”€ è‡ªåŠ¨åˆ‡æ¢: æå‡ä»åº“ä¸ºä¸»åº“
â”œâ”€ L1å±‚: è¿æ¥æ± é‡è¿æ–°ä¸»åº“
â””â”€ RTO: 15ç§’

æ•°æ®ä¸€è‡´æ€§:
â”œâ”€ L2å±‚: ç¡®ä¿å·²æäº¤äº‹åŠ¡å¤åˆ¶åˆ°æ–°ä¸»
â”œâ”€ L0å±‚: ä»åº“æå‡åæ•°æ®å®Œæ•´
â””â”€ ä¸€è‡´æ€§: ä¿æŒ âœ“
```

---

## ä¸ƒã€åä¾‹ä¸é”™è¯¯è®¾è®¡

### åä¾‹1: å¿½ç•¥L2å±‚æ—¶é—´æˆ³

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: L1å±‚è‡ªå·±ç”Ÿæˆæ—¶é—´æˆ³
let tx_id = generate_local_timestamp();  // æœ¬åœ°æ—¶é’Ÿ

// é—®é¢˜:
â”œâ”€ å¤šèŠ‚ç‚¹æ—¶é’Ÿä¸åŒæ­¥
â”œâ”€ æ—¶é—´æˆ³å†²çª
â”œâ”€ è¿åå…¨å±€é¡ºåº
â””â”€ æ•°æ®ä¸ä¸€è‡´ âœ—
```

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: ä»L2å±‚è·å–å…¨å±€æ—¶é—´æˆ³
let tx_id = coordinator.get_global_timestamp().await?;

// ä¿è¯:
â”œâ”€ å…¨å±€å•è°ƒé€’å¢
â”œâ”€ æ— å†²çª
â””â”€ å…¨å±€é¡ºåº âœ“
```

### åä¾‹2: L1å±‚ç ´åL0å±‚ä¿è¯

**é”™è¯¯è®¾è®¡**:

```rust
// é”™è¯¯: L1å±‚ç»•è¿‡äº‹åŠ¡
conn.execute("SET autocommit = on", &[]).await?;
conn.execute("UPDATE ...", &[]).await?;  // æ— äº‹åŠ¡ä¿æŠ¤

// é—®é¢˜:
â”œâ”€ è¿åACID
â”œâ”€ æ•°æ®ä¸ä¸€è‡´é£é™©
â””â”€ æ— æ³•å›æ»š âœ—
```

**æ­£ç¡®è®¾è®¡**:

```rust
// æ­£ç¡®: L1å±‚ä½¿ç”¨L0å±‚äº‹åŠ¡
let tx = conn.transaction().await?;
tx.execute("UPDATE ...", &[]).await?;
tx.commit().await?;  // L0å±‚ä¿è¯ACID âœ“
```

---

## å…«ã€å®é™…ç”Ÿäº§æ¡ˆä¾‹

### æ¡ˆä¾‹1: æŸé‡‘èç³»ç»Ÿä¸‰å±‚æ¶æ„

**æ¶æ„**:

```text
L2å±‚: Consul (æœåŠ¡å‘ç°) + è‡ªå®šä¹‰åè°ƒå™¨
    â”œâ”€ å…¨å±€æ—¶é—´æˆ³åˆ†é…
    â””â”€ åˆ†å¸ƒå¼é”æœåŠ¡

L1å±‚: Rustå¾®æœåŠ¡
    â”œâ”€ è´¦æˆ·æœåŠ¡
    â”œâ”€ äº¤æ˜“æœåŠ¡
    â””â”€ é£æ§æœåŠ¡

L0å±‚: PostgreSQLä¸»ä»é›†ç¾¤
    â”œâ”€ ä¸»åº“: åŒæ­¥å¤åˆ¶
    â””â”€ ä»åº“: 3ä¸ªå‰¯æœ¬
```

**æ€§èƒ½æ•°æ®**:

| æŒ‡æ ‡ | å€¼ |
|-----|-----|
| å…¨å±€TPS | 10,000 |
| å•æœåŠ¡TPS | 3,000 |
| P99å»¶è¿Ÿ | 50ms |
| å¯ç”¨æ€§ | 99.99% |

**æ•…éšœæ¢å¤**:

```text
å®é™…æ•…éšœ: ä¸»åº“æ•…éšœ
â”œâ”€ æ£€æµ‹æ—¶é—´: 3ç§’
â”œâ”€ ä»åº“æå‡: 5ç§’
â”œâ”€ L1é‡è¿: 2ç§’
â”œâ”€ æ€»RTO: 10ç§’
â””â”€ æ•°æ®: é›¶ä¸¢å¤± âœ“
```

---

## ä¹ã€å®Œæ•´å®ç°ä»£ç 

### 9.1 ä¸‰å±‚çŠ¶æ€åŒæ­¥å™¨å®Œæ•´å®ç°

**å®Œæ•´å®ç°**: ä¸‰å±‚çŠ¶æ€åŒæ­¥ç®¡ç†å™¨

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::RwLock;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TransactionState {
    Active,
    Prepared,
    Committed,
    Aborted,
}

#[derive(Clone, Copy, Debug)]
pub struct Timestamp {
    pub physical: u64,
    pub logical: u64,
}

pub struct L2State {
    pub committed_transactions: HashMap<u64, Timestamp>,
    pub global_timestamp: Timestamp,
}

pub struct L1State {
    pub active_transactions: HashMap<u64, TransactionInfo>,
}

pub struct TransactionInfo {
    pub state: TransactionState,
    pub commit_timestamp: Option<Timestamp>,
}

pub struct L0State {
    pub clog: Vec<TransactionState>,  // ç®€åŒ–çš„äº‹åŠ¡çŠ¶æ€æ—¥å¿—
}

pub struct StateSync {
    l2_state: Arc<RwLock<L2State>>,
    l1_state: Arc<RwLock<L1State>>,
    l0_state: Arc<RwLock<L0State>>,
}

impl StateSync {
    pub fn new() -> Self {
        Self {
            l2_state: Arc::new(RwLock::new(L2State {
                committed_transactions: HashMap::new(),
                global_timestamp: Timestamp { physical: 0, logical: 0 },
            })),
            l1_state: Arc::new(RwLock::new(L1State {
                active_transactions: HashMap::new(),
            })),
            l0_state: Arc::new(RwLock::new(L0State {
                clog: Vec::new(),
            })),
        }
    }

    pub async fn sync_transaction_commit(
        &self,
        tx_id: u64,
        global_ts: Timestamp,
    ) -> Result<(), String> {
        // L2å±‚: è®°å½•å…¨å±€æäº¤
        {
            let mut l2 = self.l2_state.write().await;
            l2.committed_transactions.insert(tx_id, global_ts);
            l2.global_timestamp = global_ts;
        }

        // L1å±‚: æ›´æ–°äº‹åŠ¡çŠ¶æ€
        {
            let mut l1 = self.l1_state.write().await;
            if let Some(tx) = l1.active_transactions.get_mut(&tx_id) {
                tx.state = TransactionState::Committed;
                tx.commit_timestamp = Some(global_ts);
            }
        }

        // L0å±‚: æ›´æ–°pg_clog
        {
            let mut l0 = self.l0_state.write().await;
            if tx_id as usize >= l0.clog.len() {
                l0.clog.resize(tx_id as usize + 1, TransactionState::Active);
            }
            l0.clog[tx_id as usize] = TransactionState::Committed;
        }

        // éªŒè¯ä¸€è‡´æ€§
        self.verify_consistency(tx_id, global_ts).await?;

        Ok(())
    }

    async fn verify_consistency(
        &self,
        tx_id: u64,
        global_ts: Timestamp,
    ) -> Result<(), String> {
        let l2 = self.l2_state.read().await;
        let l1 = self.l1_state.read().await;
        let l0 = self.l0_state.read().await;

        // æ£€æŸ¥L2æ—¶é—´æˆ³ = L1æ—¶é—´æˆ³ = L0çŠ¶æ€
        let l2_ts = l2.committed_transactions.get(&tx_id);
        let l1_tx = l1.active_transactions.get(&tx_id);
        let l0_status = if tx_id as usize < l0.clog.len() {
            Some(&l0.clog[tx_id as usize])
        } else {
            None
        };

        if l2_ts != Some(&global_ts) {
            return Err(format!("L2 timestamp mismatch: {:?} != {:?}", l2_ts, global_ts));
        }

        if let Some(tx) = l1_tx {
            if tx.commit_timestamp != Some(global_ts) {
                return Err(format!("L1 timestamp mismatch"));
            }
        }

        if l0_status != Some(&TransactionState::Committed) {
            return Err(format!("L0 state mismatch: {:?}", l0_status));
        }

        Ok(())
    }

    pub async fn begin_transaction(&self, tx_id: u64) -> Result<(), String> {
        // L1å±‚: åˆ›å»ºäº‹åŠ¡
        {
            let mut l1 = self.l1_state.write().await;
            l1.active_transactions.insert(
                tx_id,
                TransactionInfo {
                    state: TransactionState::Active,
                    commit_timestamp: None,
                },
            );
        }

        // L0å±‚: åˆå§‹åŒ–çŠ¶æ€
        {
            let mut l0 = self.l0_state.write().await;
            if tx_id as usize >= l0.clog.len() {
                l0.clog.resize(tx_id as usize + 1, TransactionState::Active);
            }
            l0.clog[tx_id as usize] = TransactionState::Active;
        }

        Ok(())
    }
}

#[tokio::main]
async fn main() {
    let sync = StateSync::new();

    // å¼€å§‹äº‹åŠ¡
    sync.begin_transaction(1).await.unwrap();

    // æäº¤äº‹åŠ¡
    let global_ts = Timestamp { physical: 100, logical: 0 };
    sync.sync_transaction_commit(1, global_ts).await.unwrap();

    println!("Transaction committed successfully");
}
```

### 9.2 è·¨å±‚äº‹åŠ¡åè°ƒå™¨å®Œæ•´å®ç°

**å®Œæ•´å®ç°**: è·¨å±‚äº‹åŠ¡åè°ƒå™¨

```rust
use std::sync::Arc;
use tokio::sync::Mutex;

pub struct DistributedTransactionCoordinator {
    state_sync: Arc<StateSync>,
    participants: Vec<Participant>,
}

pub struct Participant {
    pub region_id: u64,
    pub is_available: bool,
}

impl DistributedTransactionCoordinator {
    pub fn new(state_sync: Arc<StateSync>) -> Self {
        Self {
            state_sync,
            participants: Vec::new(),
        }
    }

    pub async fn transfer_global(
        &self,
        from_region: u64,
        to_region: u64,
        amount: i64,
    ) -> Result<(), String> {
        // Step 1: L2è·å–å…¨å±€æ—¶é—´æˆ³
        let global_ts = self.get_global_timestamp().await?;

        // Step 2: L1å±‚å¼€å§‹äº‹åŠ¡
        let tx_id = global_ts.physical;
        self.state_sync.begin_transaction(tx_id).await?;

        // Step 3: L0å±‚æ‰§è¡Œæ“ä½œï¼ˆæ¨¡æ‹Ÿï¼‰
        self.execute_update(from_region, -amount).await?;
        self.execute_update(to_region, amount).await?;

        // Step 4: L2å±‚2PCåè°ƒ
        let prepare_from = self.prepare(from_region).await?;
        let prepare_to = self.prepare(to_region).await?;

        if prepare_from && prepare_to {
            // Step 5: L2å±‚æäº¤å†³ç­–
            self.commit_global(tx_id, global_ts).await?;

            // Step 6: L1å±‚æäº¤äº‹åŠ¡
            self.state_sync.sync_transaction_commit(tx_id, global_ts).await?;
        } else {
            // å›æ»š
            self.abort_global(tx_id).await?;
            return Err("Prepare failed".to_string());
        }

        Ok(())
    }

    async fn get_global_timestamp(&self) -> Result<Timestamp, String> {
        // æ¨¡æ‹Ÿä»L2å±‚è·å–å…¨å±€æ—¶é—´æˆ³
        Ok(Timestamp { physical: 100, logical: 0 })
    }

    async fn execute_update(&self, region: u64, amount: i64) -> Result<(), String> {
        // æ¨¡æ‹ŸL0å±‚æ‰§è¡Œæ›´æ–°
        println!("Executing update: region={}, amount={}", region, amount);
        Ok(())
    }

    async fn prepare(&self, region: u64) -> Result<bool, String> {
        // æ¨¡æ‹Ÿ2PC Prepareé˜¶æ®µ
        println!("Preparing region: {}", region);
        Ok(true)
    }

    async fn commit_global(&self, tx_id: u64, ts: Timestamp) -> Result<(), String> {
        // æ¨¡æ‹ŸL2å±‚å…¨å±€æäº¤
        println!("Committing globally: tx_id={}, ts={:?}", tx_id, ts);
        Ok(())
    }

    async fn abort_global(&self, tx_id: u64) -> Result<(), String> {
        // æ¨¡æ‹ŸL2å±‚å…¨å±€ä¸­æ­¢
        println!("Aborting globally: tx_id={}", tx_id);
        Ok(())
    }
}

#[tokio::main]
async fn main() {
    let state_sync = Arc::new(StateSync::new());
    let coordinator = DistributedTransactionCoordinator::new(state_sync);

    // æ‰§è¡Œåˆ†å¸ƒå¼è½¬è´¦
    match coordinator.transfer_global(1, 2, 100).await {
        Ok(_) => println!("Transfer successful"),
        Err(e) => println!("Transfer failed: {}", e),
    }
}
```

### 9.3 æ•…éšœæ¢å¤ç®¡ç†å™¨å®Œæ•´å®ç°

**å®Œæ•´å®ç°**: æ•…éšœæ¢å¤ç®¡ç†å™¨

```rust
use std::time::{Duration, Instant};
use tokio::time::sleep;

pub struct FailureRecoveryManager {
    state_sync: Arc<StateSync>,
    last_heartbeat: Arc<Mutex<HashMap<u64, Instant>>>,
    heartbeat_timeout: Duration,
}

impl FailureRecoveryManager {
    pub fn new(state_sync: Arc<StateSync>) -> Self {
        Self {
            state_sync,
            last_heartbeat: Arc::new(Mutex::new(HashMap::new())),
            heartbeat_timeout: Duration::from_secs(5),
        }
    }

    pub async fn detect_failures(&self) -> Vec<u64> {
        let mut failed_nodes = Vec::new();
        let now = Instant::now();
        let heartbeats = self.last_heartbeat.lock().await;

        for (node_id, last_beat) in heartbeats.iter() {
            if now.duration_since(*last_beat) > self.heartbeat_timeout {
                failed_nodes.push(*node_id);
            }
        }

        failed_nodes
    }

    pub async fn recover_l2_failure(&self, failed_node: u64) -> Result<(), String> {
        println!("Recovering L2 node: {}", failed_node);

        // 1. é€‰ä¸¾æ–°Coordinator
        let new_coordinator = self.elect_new_coordinator(failed_node).await?;

        // 2. ä»å¤šæ•°æ´¾æ¢å¤çŠ¶æ€
        let state = self.recover_state_from_majority().await?;

        // 3. æ›´æ–°L2çŠ¶æ€
        {
            let mut l2 = self.state_sync.l2_state.write().await;
            l2.committed_transactions = state.committed_transactions;
            l2.global_timestamp = state.global_timestamp;
        }

        println!("L2 recovery completed, new coordinator: {}", new_coordinator);
        Ok(())
    }

    pub async fn recover_l1_failure(&self, failed_node: u64) -> Result<(), String> {
        println!("Recovering L1 node: {}", failed_node);

        // 1. æ£€æµ‹æœªæäº¤äº‹åŠ¡
        let active_txs = self.get_active_transactions(failed_node).await?;

        // 2. å›æ»šæœªæäº¤äº‹åŠ¡
        for tx_id in active_txs {
            self.rollback_transaction(tx_id).await?;
        }

        // 3. é‡Šæ”¾é”
        self.release_locks(failed_node).await?;

        println!("L1 recovery completed");
        Ok(())
    }

    pub async fn recover_l0_failure(&self, failed_node: u64) -> Result<(), String> {
        println!("Recovering L0 node: {}", failed_node);

        // 1. æ£€æµ‹L0æ•…éšœ
        if !self.is_l0_available(failed_node).await {
            // 2. æå‡ä»åº“ä¸ºä¸»åº“
            let new_primary = self.promote_replica(failed_node).await?;

            // 3. L1å±‚é‡è¿æ–°ä¸»åº“
            self.reconnect_l1_to_new_primary(new_primary).await?;

            println!("L0 recovery completed, new primary: {}", new_primary);
        }

        Ok(())
    }

    async fn elect_new_coordinator(&self, failed: u64) -> Result<u64, String> {
        // ç®€åŒ–ï¼šé€‰æ‹©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        Ok(failed + 1)
    }

    async fn recover_state_from_majority(&self) -> Result<L2State, String> {
        // ç®€åŒ–ï¼šè¿”å›ç©ºçŠ¶æ€
        Ok(L2State {
            committed_transactions: HashMap::new(),
            global_timestamp: Timestamp { physical: 0, logical: 0 },
        })
    }

    async fn get_active_transactions(&self, node: u64) -> Result<Vec<u64>, String> {
        // ç®€åŒ–ï¼šè¿”å›ç©ºåˆ—è¡¨
        Ok(Vec::new())
    }

    async fn rollback_transaction(&self, tx_id: u64) -> Result<(), String> {
        println!("Rolling back transaction: {}", tx_id);
        Ok(())
    }

    async fn release_locks(&self, node: u64) -> Result<(), String> {
        println!("Releasing locks for node: {}", node);
        Ok(())
    }

    async fn is_l0_available(&self, node: u64) -> bool {
        false  // æ¨¡æ‹Ÿæ•…éšœ
    }

    async fn promote_replica(&self, failed: u64) -> Result<u64, String> {
        Ok(failed + 1)
    }

    async fn reconnect_l1_to_new_primary(&self, primary: u64) -> Result<(), String> {
        println!("Reconnecting L1 to new primary: {}", primary);
        Ok(())
    }
}

#[tokio::main]
async fn main() {
    let state_sync = Arc::new(StateSync::new());
    let recovery = FailureRecoveryManager::new(state_sync);

    // æ£€æµ‹æ•…éšœ
    let failed_nodes = recovery.detect_failures().await;
    for node in failed_nodes {
        // æ ¹æ®èŠ‚ç‚¹ç±»å‹é€‰æ‹©æ¢å¤ç­–ç•¥
        if node < 100 {
            recovery.recover_l2_failure(node).await.unwrap();
        } else if node < 200 {
            recovery.recover_l1_failure(node).await.unwrap();
        } else {
            recovery.recover_l0_failure(node).await.unwrap();
        }
    }
}
```

---

## åã€è·¨å±‚ååŒå¯è§†åŒ–

### 10.1 ä¸‰å±‚ååŒæ¶æ„å›¾

**å®Œæ•´LSEMä¸‰å±‚ååŒæ¶æ„** (Mermaid):

```mermaid
graph TB
    subgraph "L2: åˆ†å¸ƒå¼å±‚"
        L2_RAFT[Raftå…±è¯†<br/>Leaderé€‰ä¸¾]
        L2_HLC[HLCæ—¶é—´æˆ³<br/>å…¨å±€æ—¶é’Ÿ]
        L2_LOG[æ—¥å¿—å¤åˆ¶<br/>Log Replication]
    end

    subgraph "L1: è¿è¡Œæ—¶å±‚"
        L1_TXN[äº‹åŠ¡ç®¡ç†<br/>Transaction Manager]
        L1_POOL[è¿æ¥æ± <br/>Connection Pool]
        L1_CACHE[ç¼“å­˜<br/>Cache]
    end

    subgraph "L0: å­˜å‚¨å±‚"
        L0_MVCC[MVCC<br/>å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶]
        L0_WAL[WALæ—¥å¿—<br/>Write-Ahead Log]
        L0_HEAP[å †è¡¨<br/>Heap]
    end

    L2_RAFT --> L2_HLC
    L2_HLC --> L1_TXN
    L2_LOG --> L1_TXN

    L1_TXN --> L1_POOL
    L1_POOL --> L0_MVCC
    L1_CACHE --> L0_MVCC

    L0_MVCC --> L0_WAL
    L0_WAL --> L0_HEAP

    L2_HLC -.->|æ—¶é—´æˆ³æ˜ å°„| L1_TXN
    L1_TXN -.->|äº‹åŠ¡IDæ˜ å°„| L0_MVCC
```

**ä¸‰å±‚ååŒå±‚æ¬¡æ¶æ„**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L2: åˆ†å¸ƒå¼å±‚                            â”‚
â”‚  â”œâ”€ Raftå…±è¯† (Leaderé€‰ä¸¾)                â”‚
â”‚  â”œâ”€ HLCæ—¶é—´æˆ³ (å…¨å±€æ—¶é’Ÿ)                  â”‚
â”‚  â””â”€ æ—¥å¿—å¤åˆ¶ (Log Replication)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚
        â”‚ æ—¶é—´æˆ³æ˜ å°„         â”‚ çŠ¶æ€åŒæ­¥
        â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L1: è¿è¡Œæ—¶å±‚â”‚  â”‚  L1: è¿è¡Œæ—¶å±‚    â”‚
â”‚  äº‹åŠ¡ç®¡ç†     â”‚  â”‚  è¿æ¥æ±           â”‚
â”‚  è¿æ¥æ±        â”‚  â”‚  ç¼“å­˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ äº‹åŠ¡IDæ˜ å°„
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  L0: å­˜å‚¨å±‚  â”‚
â”‚  MVCC        â”‚
â”‚  WAL         â”‚
â”‚  å †è¡¨        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 10.2 è·¨å±‚çŠ¶æ€åŒæ­¥åºåˆ—å›¾

**ä¸‰å±‚çŠ¶æ€åŒæ­¥å®Œæ•´åºåˆ—** (Mermaid):

```mermaid
sequenceDiagram
    participant Client
    participant L2 as L2å±‚(Raft)
    participant L1 as L1å±‚(Rust)
    participant L0 as L0å±‚(PostgreSQL)

    Client->>L2: äº‹åŠ¡è¯·æ±‚
    L2->>L2: è·å–HLCæ—¶é—´æˆ³ (T=100)
    L2->>L1: ä¼ é€’æ—¶é—´æˆ³ (T=100)

    L1->>L1: æ˜ å°„åˆ°äº‹åŠ¡ID (xid=100)
    L1->>L0: BEGIN TRANSACTION (xid=100)
    L0->>L0: åˆ›å»ºå¿«ç…§ (xmin=100, xmax=110)

    L1->>L0: UPDATE accounts SET balance=...
    L0->>L0: åˆ›å»ºæ–°ç‰ˆæœ¬ (xmin=100, xmax=0)
    L0-->>L1: æ›´æ–°æˆåŠŸ

    L1->>L0: COMMIT
    L0->>L0: å†™å…¥WAL
    L0->>L0: pg_clog[100] = COMMITTED
    L0-->>L1: æäº¤æˆåŠŸ

    L1->>L2: ç¡®è®¤æäº¤ (T=100)
    L2->>L2: æ—¥å¿—å¤åˆ¶åˆ°å¤šæ•°æ´¾
    L2->>L2: commitIndex = 5
    L2-->>Client: äº‹åŠ¡æˆåŠŸ
```

**è·¨å±‚æ—¶é—´æˆ³åŒæ­¥æµç¨‹**:

```text
è·¨å±‚æ—¶é—´æˆ³åŒæ­¥:
â”œâ”€ L2å±‚: è·å–HLCæ—¶é—´æˆ³
â”‚   â”œâ”€ T_global = (pt=1638360000, lc=5)
â”‚   â””â”€ ä¼ é€’ç»™L1å±‚
â”‚
â”œâ”€ L1å±‚: æ˜ å°„åˆ°äº‹åŠ¡ID
â”‚   â”œâ”€ xid = T_global.lc = 5
â”‚   â””â”€ ä¼ é€’ç»™L0å±‚
â”‚
â””â”€ L0å±‚: ä½¿ç”¨äº‹åŠ¡ID
    â”œâ”€ xmin = xid = 5
    â”œâ”€ åˆ›å»ºç‰ˆæœ¬é“¾
    â””â”€ å¯è§æ€§æ£€æŸ¥åŸºäºxmin
```

### 10.3 è·¨å±‚ååŒå†³ç­–æ ‘

**è·¨å±‚ååŒé€‰æ‹©å†³ç­–æ ‘**:

```text
                é€‰æ‹©è·¨å±‚ååŒæ–¹æ¡ˆ
                      â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   ç³»ç»Ÿå¤æ‚åº¦åˆ†æ      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚               â”‚               â”‚
   å•å±‚ç³»ç»Ÿ        ä¸¤å±‚ç³»ç»Ÿ        ä¸‰å±‚ç³»ç»Ÿ
   (ç®€å•)          (ä¸­ç­‰)          (å¤æ‚)
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   å•å±‚å®ç°        L0+L1          L0+L1+L2
  (PostgreSQL)    (PostgreSQL    (åˆ†å¸ƒå¼
                  + Rust)         PostgreSQL)
      â”‚               â”‚               â”‚
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   æ— éœ€æ˜ å°„        æ—¶é—´æˆ³æ˜ å°„      å®Œæ•´æ˜ å°„
                 çŠ¶æ€æ˜ å°„          è·¨å±‚ååŒ
```

**è·¨å±‚æ•…éšœæ¢å¤å†³ç­–æ ‘**:

```text
                å¤„ç†è·¨å±‚æ•…éšœ
                      â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   æ•…éšœå±‚åˆ†æ          â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚               â”‚               â”‚
   L2å±‚æ•…éšœ         L1å±‚æ•…éšœ        L0å±‚æ•…éšœ
   (å…±è¯†å±‚)         (è¿è¡Œæ—¶å±‚)      (å­˜å‚¨å±‚)
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   é€‰ä¸¾æ–°Leader    é‡å¯æœåŠ¡        ä¸»ä»åˆ‡æ¢
   æ—¥å¿—æ¢å¤        çŠ¶æ€æ¢å¤        æ•°æ®æ¢å¤
      â”‚               â”‚               â”‚
      â”‚               â”‚               â”‚
      â–¼               â–¼               â–¼
   å…¨å±€ä¸€è‡´æ€§      åº”ç”¨å±‚æ¢å¤      æ•°æ®ä¸€è‡´æ€§
   å¤šæ•°æ´¾ä¿è¯      è¿æ¥æ± é‡å»º      æŒä¹…åŒ–ä¿è¯
```

**è·¨å±‚ååŒå¯¹æ¯”çŸ©é˜µ**:

| ååŒæ–¹æ¡ˆ | æ¶‰åŠå±‚ | å¤æ‚åº¦ | æ€§èƒ½ | ä¸€è‡´æ€§ | é€‚ç”¨åœºæ™¯ |
|---------|-------|-------|------|--------|---------|
| **å•å±‚ (L0)** | L0 | ä½ | é«˜ | å¼º | å•æœºåº”ç”¨ |
| **ä¸¤å±‚ (L0+L1)** | L0+L1 | ä¸­ | ä¸­é«˜ | å¼º | åº”ç”¨+æ•°æ®åº“ |
| **ä¸‰å±‚ (L0+L1+L2)** | L0+L1+L2 | é«˜ | ä¸­ | å¼º | åˆ†å¸ƒå¼ç³»ç»Ÿ |

**è·¨å±‚æ—¶é—´æˆ³æ˜ å°„çŸ©é˜µ**:

| å±‚ | æ—¶é—´æˆ³ç±»å‹ | æ˜ å°„å…³ç³» | åŒæ­¥æœºåˆ¶ | ç²¾åº¦ |
|--|----------|---------|---------|------|
| **L2** | HLC (pt, lc) | T_global | ç½‘ç»œåŒæ­¥ | msçº§ |
| **L1** | äº‹åŠ¡ID (xid) | xid = T_global.lc | æœ¬åœ°æ˜ å°„ | äº‹åŠ¡çº§ |
| **L0** | TransactionId | xmin = xid | æ•°æ®åº“åˆ†é… | äº‹åŠ¡çº§ |

---

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0.0ï¼ˆå¤§å¹…å……å®ï¼‰
**æœ€åæ›´æ–°**: 2025-12-05
**æ–°å¢å†…å®¹**: å®Œæ•´Rustå®ç°ã€TiDB/CockroachDBæ·±åº¦åˆ†æã€æ€§èƒ½ä¼˜åŒ–ã€æ•…éšœå¤„ç†ã€åä¾‹ã€å®Œæ•´å®ç°ä»£ç ã€è·¨å±‚ååŒå¯è§†åŒ–ï¼ˆä¸‰å±‚ååŒæ¶æ„å›¾ã€è·¨å±‚çŠ¶æ€åŒæ­¥åºåˆ—å›¾ã€è·¨å±‚ååŒå†³ç­–æ ‘ï¼‰

**å·¥å…·ä»£ç **: ç”Ÿäº§çº§Rustè¿æ¥æ±  + äº‹åŠ¡ç®¡ç†
**GitHub**: <https://github.com/db-theory/cross-layer-coordination>

**å…³è”æ–‡æ¡£**:

- `01-æ ¸å¿ƒç†è®ºæ¨¡å‹/01-åˆ†å±‚çŠ¶æ€æ¼”åŒ–æ¨¡å‹(LSEM).md` (LSEMç†è®º)
- `05-å®ç°æœºåˆ¶/01-PostgreSQL-MVCCå®ç°.md` (L0å®ç°)
- `05-å®ç°æœºåˆ¶/04-Rust-æ‰€æœ‰æƒå®ç°.md` (L1å®ç°)
- `04-åˆ†å¸ƒå¼æ‰©å±•/03-å…±è¯†åè®®(Raft_Paxos).md` (L2å®ç°)
