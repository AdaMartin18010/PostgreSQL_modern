# 07 | æ— é”æ•°æ®ç»“æ„å®ç°

> **å®ç°å®šä½**: æœ¬æ–‡æ¡£æä¾›æ— é”æ•°æ®ç»“æ„çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬æ ˆã€é˜Ÿåˆ—ã€å“ˆå¸Œè¡¨ç­‰ç»å…¸ç»“æ„ï¼Œæ¶µç›–ABAé—®é¢˜è§£å†³æ–¹æ¡ˆå’Œæ€§èƒ½ä¼˜åŒ–æŠ€å·§ã€‚

---

## ğŸ“‘ ç›®å½•

- [07 | æ— é”æ•°æ®ç»“æ„å®ç°](#07--æ— é”æ•°æ®ç»“æ„å®ç°)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€æ— é”æ•°æ®ç»“æ„å®ç°èƒŒæ™¯](#ä¸€æ— é”æ•°æ®ç»“æ„å®ç°èƒŒæ™¯)
    - [1.1 å®ç°æŒ‘æˆ˜](#11-å®ç°æŒ‘æˆ˜)
    - [1.2 å®ç°åŸåˆ™](#12-å®ç°åŸåˆ™)
    - [1.3 æµ‹è¯•ç­–ç•¥](#13-æµ‹è¯•ç­–ç•¥)
  - [äºŒã€æ— é”æ ˆå®ç°](#äºŒæ— é”æ ˆå®ç°)
    - [2.1 Treiberæ ˆåŸºç¡€å®ç°](#21-treiberæ ˆåŸºç¡€å®ç°)
    - [2.2 æ ‡è®°æŒ‡é’ˆç‰ˆæœ¬ï¼ˆé˜²ABAï¼‰](#22-æ ‡è®°æŒ‡é’ˆç‰ˆæœ¬é˜²aba)
    - [2.3 å±é™©æŒ‡é’ˆç‰ˆæœ¬ï¼ˆå†…å­˜å®‰å…¨ï¼‰](#23-å±é™©æŒ‡é’ˆç‰ˆæœ¬å†…å­˜å®‰å…¨)
    - [2.4 æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬](#24-æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬)
  - [ä¸‰ã€æ— é”é˜Ÿåˆ—å®ç°](#ä¸‰æ— é”é˜Ÿåˆ—å®ç°)
    - [3.1 Michael \& Scotté˜Ÿåˆ—åŸºç¡€å®ç°](#31-michael--scotté˜Ÿåˆ—åŸºç¡€å®ç°)
    - [3.2 å¸®åŠ©æœºåˆ¶ä¼˜åŒ–](#32-å¸®åŠ©æœºåˆ¶ä¼˜åŒ–)
    - [3.3 æ‰¹é‡æ“ä½œä¼˜åŒ–](#33-æ‰¹é‡æ“ä½œä¼˜åŒ–)
    - [3.4 æ— é”é˜Ÿåˆ—å˜ä½“](#34-æ— é”é˜Ÿåˆ—å˜ä½“)
  - [å››ã€æ— é”å“ˆå¸Œè¡¨å®ç°](#å››æ— é”å“ˆå¸Œè¡¨å®ç°)
    - [4.1 æ— é”å“ˆå¸Œè¡¨è®¾è®¡](#41-æ— é”å“ˆå¸Œè¡¨è®¾è®¡)
    - [4.2 åˆ†æ®µé”å“ˆå¸Œè¡¨](#42-åˆ†æ®µé”å“ˆå¸Œè¡¨)
    - [4.3 å®Œå…¨æ— é”å“ˆå¸Œè¡¨](#43-å®Œå…¨æ— é”å“ˆå¸Œè¡¨)
    - [4.4 åŠ¨æ€æ‰©å®¹å®ç°](#44-åŠ¨æ€æ‰©å®¹å®ç°)
  - [äº”ã€æ— é”é“¾è¡¨å®ç°](#äº”æ— é”é“¾è¡¨å®ç°)
    - [5.1 æ— é”é“¾è¡¨åŸºç¡€å®ç°](#51-æ— é”é“¾è¡¨åŸºç¡€å®ç°)
    - [5.2 æ— é”æœ‰åºé“¾è¡¨](#52-æ— é”æœ‰åºé“¾è¡¨)
    - [5.3 æ— é”è·³è¡¨](#53-æ— é”è·³è¡¨)
  - [å…­ã€æ— é”æ ‘ç»“æ„å®ç°](#å…­æ— é”æ ‘ç»“æ„å®ç°)
    - [6.1 æ— é”æ ‘æŒ‘æˆ˜](#61-æ— é”æ ‘æŒ‘æˆ˜)
    - [6.2 æ— é”B+æ ‘å°è¯•](#62-æ— é”bæ ‘å°è¯•)
    - [6.3 æ›¿ä»£æ–¹æ¡ˆ](#63-æ›¿ä»£æ–¹æ¡ˆ)
  - [ä¸ƒã€å†…å­˜ç®¡ç†å®ç°](#ä¸ƒå†…å­˜ç®¡ç†å®ç°)
    - [7.1 å±é™©æŒ‡é’ˆå®ç°](#71-å±é™©æŒ‡é’ˆå®ç°)
    - [7.2 Epoch-Basedå›æ”¶å®ç°](#72-epoch-basedå›æ”¶å®ç°)
    - [7.3 å¼•ç”¨è®¡æ•°å®ç°](#73-å¼•ç”¨è®¡æ•°å®ç°)
  - [å…«ã€æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#å…«æ€§èƒ½ä¼˜åŒ–æŠ€å·§)
    - [8.1 ç¼“å­˜è¡Œå¯¹é½](#81-ç¼“å­˜è¡Œå¯¹é½)
    - [8.2 NUMAæ„ŸçŸ¥è®¾è®¡](#82-numaæ„ŸçŸ¥è®¾è®¡)
    - [8.3 å†…å­˜æ’åºä¼˜åŒ–](#83-å†…å­˜æ’åºä¼˜åŒ–)
    - [8.4 æ‰¹é‡æ“ä½œä¼˜åŒ–](#84-æ‰¹é‡æ“ä½œä¼˜åŒ–)
  - [ä¹ã€æµ‹è¯•ä¸éªŒè¯](#ä¹æµ‹è¯•ä¸éªŒè¯)
    - [9.1 å•å…ƒæµ‹è¯•](#91-å•å…ƒæµ‹è¯•)
    - [9.2 å¹¶å‘æµ‹è¯•](#92-å¹¶å‘æµ‹è¯•)
    - [9.3 æ¨¡å‹æ£€æŸ¥](#93-æ¨¡å‹æ£€æŸ¥)
    - [9.4 å‹åŠ›æµ‹è¯•](#94-å‹åŠ›æµ‹è¯•)
  - [åã€å®é™…åº”ç”¨æ¡ˆä¾‹](#åå®é™…åº”ç”¨æ¡ˆä¾‹)
    - [10.1 Rustæ ‡å‡†åº“å®ç°](#101-rustæ ‡å‡†åº“å®ç°)
    - [10.2 é«˜æ€§èƒ½æ•°æ®åº“åº”ç”¨](#102-é«˜æ€§èƒ½æ•°æ®åº“åº”ç”¨)
    - [10.3 å®æ—¶ç³»ç»Ÿåº”ç”¨](#103-å®æ—¶ç³»ç»Ÿåº”ç”¨)
  - [åä¸€ã€æ€»ç»“](#åä¸€æ€»ç»“)
    - [å®ç°è¦ç‚¹æ€»ç»“](#å®ç°è¦ç‚¹æ€»ç»“)
    - [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## ä¸€ã€æ— é”æ•°æ®ç»“æ„å®ç°èƒŒæ™¯

### 1.1 å®ç°æŒ‘æˆ˜

**æ ¸å¿ƒæŒ‘æˆ˜**:

```text
æ— é”æ•°æ®ç»“æ„å®ç°æŒ‘æˆ˜:
â”œâ”€ ABAé—®é¢˜: æŒ‡é’ˆé‡ç”¨å¯¼è‡´é”™è¯¯
â”œâ”€ å†…å­˜ç®¡ç†: ä½•æ—¶å®‰å…¨é‡Šæ”¾èŠ‚ç‚¹
â”œâ”€ å†…å­˜æ’åº: æ­£ç¡®ä½¿ç”¨å†…å­˜å±éšœ
â”œâ”€ æ€§èƒ½ä¼˜åŒ–: å‡å°‘CASç«äº‰
â””â”€ æ­£ç¡®æ€§éªŒè¯: ç¡®ä¿çº¿æ€§åŒ–æ€§
```

### 1.2 å®ç°åŸåˆ™

**å®ç°åŸåˆ™**:

```text
æ— é”æ•°æ®ç»“æ„å®ç°åŸåˆ™:
â”œâ”€ åŸåˆ™1: è¯†åˆ«çº¿æ€§åŒ–ç‚¹
â”‚   â”œâ”€ æ¯ä¸ªæ“ä½œ: æ˜ç¡®çš„çº¿æ€§åŒ–ç‚¹
â”‚   â””â”€ é€šå¸¸: CASæˆåŠŸæ—¶åˆ»
â”‚
â”œâ”€ åŸåˆ™2: å¤„ç†ABAé—®é¢˜
â”‚   â”œâ”€ æ–¹æ¡ˆ: æ ‡è®°æŒ‡é’ˆ/å±é™©æŒ‡é’ˆ/ç‰ˆæœ¬å·
â”‚   â””â”€ ç›®æ ‡: åŒºåˆ†ä¸åŒå¯¹è±¡
â”‚
â”œâ”€ åŸåˆ™3: å†…å­˜å®‰å…¨
â”‚   â”œâ”€ æ–¹æ¡ˆ: å±é™©æŒ‡é’ˆ/å¼•ç”¨è®¡æ•°
â”‚   â””â”€ ç›®æ ‡: é˜²æ­¢ä½¿ç”¨å·²é‡Šæ”¾å†…å­˜
â”‚
â””â”€ åŸåˆ™4: æ€§èƒ½ä¼˜åŒ–
    â”œâ”€ æ–¹æ¡ˆ: å‡å°‘CASç«äº‰ï¼Œæ‰¹é‡æ“ä½œ
    â””â”€ ç›®æ ‡: é«˜å¹¶å‘æ€§èƒ½
```

### 1.3 æµ‹è¯•ç­–ç•¥

**æµ‹è¯•ç­–ç•¥**:

```text
æ— é”æ•°æ®ç»“æ„æµ‹è¯•:
â”œâ”€ å•å…ƒæµ‹è¯•: åŸºæœ¬åŠŸèƒ½æ­£ç¡®æ€§
â”œâ”€ å¹¶å‘æµ‹è¯•: å¤šçº¿ç¨‹å¹¶å‘æ­£ç¡®æ€§
â”œâ”€ æ¨¡å‹æ£€æŸ¥: Loom/TLA+å½¢å¼åŒ–éªŒè¯
â””â”€ å‹åŠ›æµ‹è¯•: é«˜å¹¶å‘å‹åŠ›æµ‹è¯•
```

---

## äºŒã€æ— é”æ ˆå®ç°

### 2.1 Treiberæ ˆåŸºç¡€å®ç°

**å®Œæ•´å®ç°**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

#[derive(Debug)]
struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

pub struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> LockFreeStack<T> {
    pub fn new() -> Self {
        LockFreeStack {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }

    pub fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe {
                (*new_node).next = head;
            }

            if self.head.compare_exchange_weak(
                head,
                new_node,
                Ordering::Release,
                Ordering::Relaxed
            ).is_ok() {
                break;
            }
        }
    }

    pub fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }

            unsafe {
                let next = (*head).next;
                if self.head.compare_exchange_weak(
                    head,
                    next,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    let node = Box::from_raw(head);
                    return Some(node.data);
                }
            }
        }
    }

    pub fn is_empty(&self) -> bool {
        self.head.load(Ordering::Acquire).is_null()
    }
}

impl<T> Drop for LockFreeStack<T> {
    fn drop(&mut self) {
        while self.pop().is_some() {}
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::sync::Arc;

    #[test]
    fn test_basic() {
        let stack = LockFreeStack::new();
        stack.push(1);
        stack.push(2);
        assert_eq!(stack.pop(), Some(2));
        assert_eq!(stack.pop(), Some(1));
        assert_eq!(stack.pop(), None);
    }

    #[test]
    fn test_concurrent() {
        let stack = Arc::new(LockFreeStack::new());
        let mut handles = vec![];

        // 10ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªpush 100ä¸ªå…ƒç´ 
        for i in 0..10 {
            let stack = stack.clone();
            handles.push(thread::spawn(move || {
                for j in 0..100 {
                    stack.push(i * 100 + j);
                }
            }));
        }

        for handle in handles {
            handle.join().unwrap();
        }

        // éªŒè¯æ‰€æœ‰å…ƒç´ éƒ½è¢«push
        let mut count = 0;
        while stack.pop().is_some() {
            count += 1;
        }
        assert_eq!(count, 1000);
    }
}
```

**å®ç°è¦ç‚¹**:

```text
Treiberæ ˆå®ç°è¦ç‚¹:
â”œâ”€ çº¿æ€§åŒ–ç‚¹: CASæˆåŠŸæ—¶åˆ»
â”œâ”€ å†…å­˜æ’åº: Acquire-Releaseé…å¯¹
â”œâ”€ ABAé—®é¢˜: åŸºç¡€ç‰ˆæœ¬å­˜åœ¨ABAé£é™©
â””â”€ å†…å­˜å®‰å…¨: éœ€è¦å±é™©æŒ‡é’ˆä¿æŠ¤
```

### 2.2 æ ‡è®°æŒ‡é’ˆç‰ˆæœ¬ï¼ˆé˜²ABAï¼‰

**æ ‡è®°æŒ‡é’ˆå®ç°**:

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

// æ ‡è®°æŒ‡é’ˆ: ä½2ä½ä½œä¸ºç‰ˆæœ¬å·
#[derive(Clone, Copy)]
struct TaggedPtr<T> {
    ptr: usize,
}

impl<T> TaggedPtr<T> {
    fn new(ptr: *mut Node<T>, tag: u8) -> Self {
        TaggedPtr {
            ptr: (ptr as usize) | ((tag as usize) & 0x3),
        }
    }

    fn ptr(&self) -> *mut Node<T> {
        (self.ptr & !0x3) as *mut Node<T>
    }

    fn tag(&self) -> u8 {
        (self.ptr & 0x3) as u8
    }

    fn with_tag(&self, tag: u8) -> Self {
        TaggedPtr {
            ptr: (self.ptr & !0x3) | ((tag as usize) & 0x3),
        }
    }
}

pub struct LockFreeStackTagged<T> {
    head: AtomicUsize,  // å­˜å‚¨TaggedPtr
    version: AtomicUsize,  // å…¨å±€ç‰ˆæœ¬å·ï¼ˆå¯é€‰ï¼‰
}

impl<T> LockFreeStackTagged<T> {
    pub fn new() -> Self {
        LockFreeStackTagged {
            head: AtomicUsize::new(0),
            version: AtomicUsize::new(0),
        }
    }

    pub fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));

        loop {
            let head_val = self.head.load(Ordering::Acquire);
            let head = TaggedPtr::<T> { ptr: head_val };
            let head_ptr = head.ptr();
            let head_tag = head.tag();

            unsafe {
                (*new_node).next = head_ptr;
            }

            let new_head = TaggedPtr::new(new_node, head_tag.wrapping_add(1));

            if self.head.compare_exchange_weak(
                head_val,
                new_head.ptr,
                Ordering::Release,
                Ordering::Relaxed
            ).is_ok() {
                break;
            }
        }
    }

    pub fn pop(&self) -> Option<T> {
        loop {
            let head_val = self.head.load(Ordering::Acquire);
            let head = TaggedPtr::<T> { ptr: head_val };
            let head_ptr = head.ptr();

            if head_ptr.is_null() {
                return None;
            }

            unsafe {
                let next = (*head_ptr).next;
                let next_tagged = TaggedPtr::new(next, head.tag().wrapping_add(1));

                if self.head.compare_exchange_weak(
                    head_val,
                    next_tagged.ptr,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    let node = Box::from_raw(head_ptr);
                    return Some(node.data);
                }
            }
        }
    }
}
```

**æ ‡è®°æŒ‡é’ˆä¼˜åŠ¿**:

```text
æ ‡è®°æŒ‡é’ˆä¼˜åŠ¿:
â”œâ”€ ç®€å•: å®ç°ç®€å•ï¼Œå¼€é”€å°
â”œâ”€ æœ‰æ•ˆ: é˜²æ­¢ABAé—®é¢˜
â”œâ”€ æ€§èƒ½: å‡ ä¹æ— é¢å¤–å¼€é”€
â””â”€ å±€é™: ä»…é€‚ç”¨äºæŒ‡é’ˆä½2ä½å¯ç”¨
```

### 2.3 å±é™©æŒ‡é’ˆç‰ˆæœ¬ï¼ˆå†…å­˜å®‰å…¨ï¼‰

**å±é™©æŒ‡é’ˆå®ç°**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::collections::HashSet;
use std::sync::Mutex;

const MAX_THREADS: usize = 128;

struct HazardPointerManager {
    hazard_ptrs: [AtomicPtr<()>; MAX_THREADS],
    retired: Mutex<Vec<*mut ()>>,
}

impl HazardPointerManager {
    fn new() -> Self {
        HazardPointerManager {
            hazard_ptrs: [const { AtomicPtr::new(ptr::null_mut()) }; MAX_THREADS],
            retired: Mutex::new(Vec::new()),
        }
    }

    fn protect(&self, ptr: *mut ()) {
        let thread_id = thread_id();
        self.hazard_ptrs[thread_id].store(ptr, Ordering::Release);
    }

    fn retire(&self, ptr: *mut ()) {
        self.retired.lock().unwrap().push(ptr);
        self.try_reclaim();
    }

    fn try_reclaim(&self) {
        let mut retired = self.retired.lock().unwrap();
        retired.retain(|&ptr| {
            !self.hazard_ptrs.iter().any(|hp| {
                hp.load(Ordering::Acquire) == ptr
            })
        });
    }

    fn clear(&self) {
        let thread_id = thread_id();
        self.hazard_ptrs[thread_id].store(ptr::null_mut(), Ordering::Release);
    }
}

thread_local! {
    static HP_MANAGER: HazardPointerManager = HazardPointerManager::new();
}

pub struct LockFreeStackHP<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> LockFreeStackHP<T> {
    pub fn pop(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            if head.is_null() {
                return None;
            }

            // ä¿æŠ¤headæŒ‡é’ˆ
            HP_MANAGER.with(|hp| {
                hp.protect(head as *mut ());
            });

            // é‡æ–°æ£€æŸ¥ï¼ˆå¯èƒ½å·²è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹ï¼‰
            let current_head = self.head.load(Ordering::Acquire);
            if current_head != head {
                continue;
            }

            unsafe {
                let next = (*head).next;
                if self.head.compare_exchange_weak(
                    head,
                    next,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    // æ¸…é™¤ä¿æŠ¤
                    HP_MANAGER.with(|hp| {
                        hp.clear();
                    });

                    // å»¶è¿Ÿå›æ”¶
                    HP_MANAGER.with(|hp| {
                        hp.retire(head as *mut ());
                    });

                    let node = Box::from_raw(head);
                    return Some(node.data);
                }
            }

            // æ¸…é™¤ä¿æŠ¤
            HP_MANAGER.with(|hp| {
                hp.clear();
            });
        }
    }
}
```

### 2.4 æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬

**æ‰¹é‡æ“ä½œä¼˜åŒ–**:

```rust
pub struct LockFreeStackBatch<T> {
    head: AtomicPtr<Node<T>>,
    batch_size: usize,
}

impl<T> LockFreeStackBatch<T> {
    pub fn push_batch(&self, items: Vec<T>) {
        // æ„å»ºé“¾è¡¨
        let mut tail = ptr::null_mut();
        for item in items.into_iter().rev() {
            let node = Box::into_raw(Box::new(Node {
                data: item,
                next: tail,
            }));
            tail = node;
        }

        // ä¸€æ¬¡æ€§CASæ·»åŠ æ•´ä¸ªé“¾è¡¨
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe {
                // æ‰¾åˆ°é“¾è¡¨å°¾éƒ¨
                let mut current = tail;
                while !(*current).next.is_null() {
                    current = (*current).next;
                }
                (*current).next = head;
            }

            if self.head.compare_exchange_weak(
                head,
                tail,
                Ordering::Release,
                Ordering::Relaxed
            ).is_ok() {
                break;
            }
        }
    }
}
```

---

## ä¸‰ã€æ— é”é˜Ÿåˆ—å®ç°

### 3.1 Michael & Scotté˜Ÿåˆ—åŸºç¡€å®ç°

**å®Œæ•´å®ç°**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: Option<T>,
    next: AtomicPtr<Node<T>>,
}

pub struct LockFreeQueue<T> {
    head: AtomicPtr<Node<T>>,
    tail: AtomicPtr<Node<T>>,
}

impl<T> LockFreeQueue<T> {
    pub fn new() -> Self {
        let dummy = Box::into_raw(Box::new(Node {
            data: None,
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        LockFreeQueue {
            head: AtomicPtr::new(dummy),
            tail: AtomicPtr::new(dummy),
        }
    }

    pub fn enqueue(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data: Some(data),
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        loop {
            let tail = self.tail.load(Ordering::Acquire);
            unsafe {
                let next = (*tail).next.load(Ordering::Acquire);

                // å¸®åŠ©å…¶ä»–çº¿ç¨‹å®Œæˆæ“ä½œ
                if !next.is_null() {
                    self.tail.compare_exchange_weak(
                        tail, next,
                        Ordering::Release,
                        Ordering::Relaxed
                    ).ok();
                    continue;
                }

                // å°è¯•æ·»åŠ æ–°èŠ‚ç‚¹
                if (*tail).next.compare_exchange_weak(
                    ptr::null_mut(),
                    new_node,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    // æ›´æ–°tailæŒ‡é’ˆ
                    self.tail.compare_exchange_weak(
                        tail, new_node,
                        Ordering::Release,
                        Ordering::Relaxed
                    ).ok();
                    break;
                }
            }
        }
    }

    pub fn dequeue(&self) -> Option<T> {
        loop {
            let head = self.head.load(Ordering::Acquire);
            unsafe {
                let tail = self.tail.load(Ordering::Acquire);
                let next = (*head).next.load(Ordering::Acquire);

                if head == tail {
                    if next.is_null() {
                        return None;  // é˜Ÿåˆ—ä¸ºç©º
                    }
                    // å¸®åŠ©ç§»åŠ¨tailæŒ‡é’ˆ
                    self.tail.compare_exchange_weak(
                        tail, next,
                        Ordering::Release,
                        Ordering::Relaxed
                    ).ok();
                    continue;
                }

                if next.is_null() {
                    continue;
                }

                let data = (*next).data.take();

                if self.head.compare_exchange_weak(
                    head, next,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    // é‡Šæ”¾æ—§å¤´èŠ‚ç‚¹
                    drop(Box::from_raw(head));
                    return data;
                }
            }
        }
    }
}
```

### 3.2 å¸®åŠ©æœºåˆ¶ä¼˜åŒ–

**å¸®åŠ©æœºåˆ¶è¯´æ˜**:

```text
å¸®åŠ©æœºåˆ¶ä¼˜åŠ¿:
â”œâ”€ å‡å°‘é‡è¯•: å¸®åŠ©å…¶ä»–çº¿ç¨‹å®Œæˆæ“ä½œ
â”œâ”€ æé«˜æ€§èƒ½: å‡å°‘CASç«äº‰
â””â”€ ä¿è¯è¿›åº¦: ç³»ç»Ÿæ•´ä½“æœ‰è¿›å±•
```

### 3.3 æ‰¹é‡æ“ä½œä¼˜åŒ–

**æ‰¹é‡enqueueå®ç°**:

```rust
impl<T> LockFreeQueue<T> {
    pub fn enqueue_batch(&self, items: Vec<T>) {
        if items.is_empty() {
            return;
        }

        // æ„å»ºé“¾è¡¨
        let mut nodes: Vec<*mut Node<T>> = Vec::with_capacity(items.len());
        for item in items {
            let node = Box::into_raw(Box::new(Node {
                data: Some(item),
                next: AtomicPtr::new(ptr::null_mut()),
            }));
            nodes.push(node);
        }

        // è¿æ¥é“¾è¡¨
        for i in 0..nodes.len() - 1 {
            unsafe {
                (*nodes[i]).next.store(nodes[i + 1], Ordering::Relaxed);
            }
        }

        // ä¸€æ¬¡æ€§æ·»åŠ æ•´ä¸ªé“¾è¡¨
        loop {
            let tail = self.tail.load(Ordering::Acquire);
            unsafe {
                let next = (*tail).next.load(Ordering::Acquire);

                if !next.is_null() {
                    self.tail.compare_exchange_weak(
                        tail, next,
                        Ordering::Release,
                        Ordering::Relaxed
                    ).ok();
                    continue;
                }

                if (*tail).next.compare_exchange_weak(
                    ptr::null_mut(),
                    nodes[0],
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    self.tail.compare_exchange_weak(
                        tail, *nodes.last().unwrap(),
                        Ordering::Release,
                        Ordering::Relaxed
                    ).ok();
                    break;
                }
            }
        }
    }
}
```

### 3.4 æ— é”é˜Ÿåˆ—å˜ä½“

**å·¥ä½œçªƒå–é˜Ÿåˆ—**:

```rust
pub struct WorkStealingQueue<T> {
    local_queue: LockFreeQueue<T>,
    // å…¶ä»–çº¿ç¨‹çš„é˜Ÿåˆ—å¼•ç”¨
}

impl<T> WorkStealingQueue<T> {
    pub fn steal(&self, target: &LockFreeQueue<T>) -> Option<T> {
        // ä»å…¶ä»–çº¿ç¨‹é˜Ÿåˆ—çªƒå–
        target.dequeue()
    }
}
```

---

## å››ã€æ— é”å“ˆå¸Œè¡¨å®ç°

### 4.1 æ— é”å“ˆå¸Œè¡¨è®¾è®¡

**è®¾è®¡æ€è·¯**:

```text
æ— é”å“ˆå¸Œè¡¨è®¾è®¡:
â”œâ”€ ç»“æ„: æ¡¶æ•°ç»„ + æ— é”é“¾è¡¨
â”œâ”€ æ’å…¥: CASæ·»åŠ åˆ°é“¾è¡¨å¤´
â”œâ”€ æŸ¥æ‰¾: éå†é“¾è¡¨
â””â”€ åˆ é™¤: æ ‡è®°åˆ é™¤ + å»¶è¿Ÿæ¸…ç†
```

**åŸºç¡€å®ç°**:

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::hash::{Hash, Hasher};

const BUCKET_COUNT: usize = 1024;

struct HashNode<K, V> {
    key: K,
    value: V,
    next: AtomicPtr<HashNode<K, V>>,
    deleted: AtomicBool,
}

pub struct LockFreeHashMap<K, V> {
    buckets: [AtomicPtr<HashNode<K, V>>; BUCKET_COUNT],
}

impl<K, V> LockFreeHashMap<K, V>
where
    K: Hash + Eq,
{
    pub fn new() -> Self {
        LockFreeHashMap {
            buckets: [const { AtomicPtr::new(ptr::null_mut()) }; BUCKET_COUNT],
        }
    }

    fn bucket_index(&self, key: &K) -> usize {
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        key.hash(&mut hasher);
        (hasher.finish() as usize) % BUCKET_COUNT
    }

    pub fn insert(&self, key: K, value: V) -> Option<V> {
        let bucket_idx = self.bucket_index(&key);
        let new_node = Box::into_raw(Box::new(HashNode {
            key,
            value,
            next: AtomicPtr::new(ptr::null_mut()),
            deleted: AtomicBool::new(false),
        }));

        loop {
            let head = self.buckets[bucket_idx].load(Ordering::Acquire);

            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            unsafe {
                let mut current = head;
                while !current.is_null() {
                    if (*current).key == (*new_node).key {
                        if (*current).deleted.load(Ordering::Acquire) {
                            break;  // å·²åˆ é™¤ï¼Œå¯ä»¥æ›¿æ¢
                        }
                        // å·²å­˜åœ¨ï¼Œæ›´æ–°å€¼
                        let old_value = std::mem::replace(&mut (*current).value, (*new_node).value);
                        drop(Box::from_raw(new_node));
                        return Some(old_value);
                    }
                    current = (*current).next.load(Ordering::Acquire);
                }

                (*new_node).next.store(head, Ordering::Relaxed);
            }

            if self.buckets[bucket_idx].compare_exchange_weak(
                head,
                new_node,
                Ordering::Release,
                Ordering::Relaxed
            ).is_ok() {
                return None;
            }
        }
    }

    pub fn get(&self, key: &K) -> Option<&V> {
        let bucket_idx = self.bucket_index(key);
        let head = self.buckets[bucket_idx].load(Ordering::Acquire);

        unsafe {
            let mut current = head;
            while !current.is_null() {
                if (*current).key == *key
                    && !(*current).deleted.load(Ordering::Acquire) {
                    return Some(&(*current).value);
                }
                current = (*current).next.load(Ordering::Acquire);
            }
        }

        None
    }

    pub fn remove(&self, key: &K) -> Option<V> {
        let bucket_idx = self.bucket_index(key);
        let head = self.buckets[bucket_idx].load(Ordering::Acquire);

        unsafe {
            let mut current = head;
            while !current.is_null() {
                if (*current).key == *key {
                    // æ ‡è®°åˆ é™¤
                    if (*current).deleted.compare_exchange(
                        false,
                        true,
                        Ordering::Release,
                        Ordering::Relaxed
                    ).is_ok() {
                        return Some(std::ptr::read(&(*current).value));
                    }
                }
                current = (*current).next.load(Ordering::Acquire);
            }
        }

        None
    }
}
```

### 4.2 åˆ†æ®µé”å“ˆå¸Œè¡¨

**åˆ†æ®µé”è®¾è®¡**:

```text
åˆ†æ®µé”å“ˆå¸Œè¡¨:
â”œâ”€ ç»“æ„: å¤šä¸ªæ®µï¼Œæ¯æ®µä¸€ä¸ªé”
â”œâ”€ ä¼˜åŠ¿: å‡å°‘é”ç«äº‰
â””â”€ æ€§èƒ½: ä»‹äºé”å’Œæ— é”ä¹‹é—´
```

### 4.3 å®Œå…¨æ— é”å“ˆå¸Œè¡¨

[è§4.1åŸºç¡€å®ç°]

### 4.4 åŠ¨æ€æ‰©å®¹å®ç°

**åŠ¨æ€æ‰©å®¹**:

```rust
impl<K, V> LockFreeHashMap<K, V> {
    fn resize(&self) {
        // åˆ›å»ºæ–°æ¡¶æ•°ç»„ï¼ˆ2å€å¤§å°ï¼‰
        // é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 
        // CASæ›´æ–°æ¡¶æ•°ç»„æŒ‡é’ˆ
    }
}
```

---

## äº”ã€æ— é”é“¾è¡¨å®ç°

### 5.1 æ— é”é“¾è¡¨åŸºç¡€å®ç°

**å®ç°è¦ç‚¹**:

```text
æ— é”é“¾è¡¨å®ç°:
â”œâ”€ æ’å…¥: CASæ›´æ–°å‰é©±èŠ‚ç‚¹çš„next
â”œâ”€ åˆ é™¤: æ ‡è®°åˆ é™¤ + å»¶è¿Ÿæ¸…ç†
â””â”€ æŸ¥æ‰¾: éå†é“¾è¡¨
```

### 5.2 æ— é”æœ‰åºé“¾è¡¨

**æœ‰åºé“¾è¡¨**:

```rust
pub struct LockFreeSortedList<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> LockFreeSortedList<T>
where
    T: Ord,
{
    pub fn insert(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: AtomicPtr::new(ptr::null_mut()),
        }));

        loop {
            let mut prev = &self.head;
            let mut current = prev.load(Ordering::Acquire);

            unsafe {
                // æ‰¾åˆ°æ’å…¥ä½ç½®
                while !current.is_null() && (*current).data < (*new_node).data {
                    prev = &(*current).next;
                    current = prev.load(Ordering::Acquire);
                }

                (*new_node).next.store(current, Ordering::Relaxed);

                if prev.compare_exchange_weak(
                    current,
                    new_node,
                    Ordering::Release,
                    Ordering::Relaxed
                ).is_ok() {
                    break;
                }
            }
        }
    }
}
```

### 5.3 æ— é”è·³è¡¨

**è·³è¡¨è®¾è®¡**:

```text
æ— é”è·³è¡¨:
â”œâ”€ æŒ‘æˆ˜: å¤šå±‚ç»“æ„ï¼ŒCASå¤æ‚
â”œâ”€ æ–¹æ¡ˆ: ä½¿ç”¨æ ‡è®°æŒ‡é’ˆ
â””â”€ æ€§èƒ½: æŸ¥æ‰¾O(log N)
```

---

## å…­ã€æ— é”æ ‘ç»“æ„å®ç°

### 6.1 æ— é”æ ‘æŒ‘æˆ˜

**æŒ‘æˆ˜åˆ†æ**:

```text
æ— é”æ ‘æŒ‘æˆ˜:
â”œâ”€ é—®é¢˜1: æ ‘ç»“æ„å¤æ‚ï¼ŒCASéš¾ä»¥å¤„ç†
â”œâ”€ é—®é¢˜2: å¹³è¡¡æ“ä½œéš¾ä»¥æ— é”å®ç°
â”œâ”€ é—®é¢˜3: å†…å­˜ç®¡ç†å¤æ‚
â””â”€ ç»“è®º: æ— é”æ ‘å®ç°å›°éš¾
```

### 6.2 æ— é”B+æ ‘å°è¯•

**ç ”ç©¶ç°çŠ¶**:

```text
æ— é”B+æ ‘ç ”ç©¶:
â”œâ”€ çŠ¶æ€: ç ”ç©¶é˜¶æ®µï¼Œå®ç°å¤æ‚
â”œâ”€ æ–¹æ¡ˆ: ä½¿ç”¨CAS + å¸®åŠ©æœºåˆ¶
â””â”€ æ€§èƒ½: ä¸å¦‚é”ç‰ˆæœ¬ç¨³å®š
```

### 6.3 æ›¿ä»£æ–¹æ¡ˆ

**æ›¿ä»£æ–¹æ¡ˆ**:

```text
æ— é”æ ‘æ›¿ä»£æ–¹æ¡ˆ:
â”œâ”€ æ–¹æ¡ˆ1: æ— é”å“ˆå¸Œè¡¨ + æœ‰åºç´¢å¼•
â”œâ”€ æ–¹æ¡ˆ2: æ— é”è·³è¡¨
â””â”€ æ–¹æ¡ˆ3: åˆ†æ®µé”æ ‘
```

---

## ä¸ƒã€å†…å­˜ç®¡ç†å®ç°

### 7.1 å±é™©æŒ‡é’ˆå®ç°

[è§2.3èŠ‚]

### 7.2 Epoch-Basedå›æ”¶å®ç°

**Epoch-Basedå›æ”¶**:

```rust
struct EpochManager {
    global_epoch: AtomicUsize,
    thread_epochs: [AtomicUsize; MAX_THREADS],
    retired: [Mutex<Vec<*mut ()>>; EPOCH_COUNT],
}

impl EpochManager {
    fn enter_epoch(&self) -> usize {
        let thread_id = thread_id();
        let epoch = self.global_epoch.load(Ordering::Acquire);
        self.thread_epochs[thread_id].store(epoch, Ordering::Release);
        epoch
    }

    fn retire(&self, ptr: *mut (), epoch: usize) {
        let retired_idx = epoch % EPOCH_COUNT;
        self.retired[retired_idx].lock().unwrap().push(ptr);
        self.try_reclaim();
    }

    fn try_reclaim(&self) {
        let current_epoch = self.global_epoch.load(Ordering::Acquire);
        let safe_epoch = current_epoch - 2;

        // å›æ”¶safe_epochçš„èŠ‚ç‚¹
        let retired_idx = safe_epoch % EPOCH_COUNT;
        let mut retired = self.retired[retired_idx].lock().unwrap();
        for ptr in retired.drain(..) {
            unsafe {
                drop(Box::from_raw(ptr));
            }
        }
    }
}
```

### 7.3 å¼•ç”¨è®¡æ•°å®ç°

**å¼•ç”¨è®¡æ•°**:

```rust
struct RefCountedNode<T> {
    data: T,
    ref_count: AtomicUsize,
    next: AtomicPtr<RefCountedNode<T>>,
}

impl<T> RefCountedNode<T> {
    fn acquire(&self) {
        self.ref_count.fetch_add(1, Ordering::Relaxed);
    }

    fn release(&self) {
        if self.ref_count.fetch_sub(1, Ordering::Release) == 1 {
            // æœ€åä¸€ä¸ªå¼•ç”¨ï¼Œå¯ä»¥é‡Šæ”¾
            unsafe {
                drop(Box::from_raw(self as *const _ as *mut _));
            }
        }
    }
}
```

---

## å…«ã€æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 8.1 ç¼“å­˜è¡Œå¯¹é½

**ç¼“å­˜è¡Œå¯¹é½**:

```rust
#[repr(align(64))]
struct CacheLineAligned<T> {
    value: T,
}

// é˜²æ­¢false sharing
struct LockFreeCounter {
    counters: [CacheLineAligned<AtomicUsize>; MAX_THREADS],
}
```

### 8.2 NUMAæ„ŸçŸ¥è®¾è®¡

**NUMAæ„ŸçŸ¥**:

```rust
use numa_utils::Node;

impl<T> LockFreeQueue<T> {
    fn new_numa_aware() -> Self {
        let node = Node::current();
        // åœ¨æœ¬åœ°NUMAèŠ‚ç‚¹åˆ†é…å†…å­˜
        // ...
    }
}
```

### 8.3 å†…å­˜æ’åºä¼˜åŒ–

**å†…å­˜æ’åºé€‰æ‹©**:

```text
å†…å­˜æ’åºä¼˜åŒ–:
â”œâ”€ è¯»å–: Acquireï¼ˆä¿è¯åç»­æ“ä½œé¡ºåºï¼‰
â”œâ”€ å†™å…¥: Releaseï¼ˆä¿è¯ä¹‹å‰æ“ä½œé¡ºåºï¼‰
â”œâ”€ CAS: AcqRelï¼ˆè¯»-ä¿®æ”¹-å†™ï¼‰
â””â”€ è®¡æ•°å™¨: Relaxedï¼ˆä»…éœ€åŸå­æ€§ï¼‰
```

### 8.4 æ‰¹é‡æ“ä½œä¼˜åŒ–

[è§2.4å’Œ3.3èŠ‚]

---

## ä¹ã€æµ‹è¯•ä¸éªŒè¯

### 9.1 å•å…ƒæµ‹è¯•

[è§å„å®ç°ä¸­çš„æµ‹è¯•ä»£ç ]

### 9.2 å¹¶å‘æµ‹è¯•

**å¹¶å‘æµ‹è¯•æ¡†æ¶**:

```rust
#[test]
fn test_concurrent_stress() {
    let stack = Arc::new(LockFreeStack::new());
    let mut handles = vec![];

    // ç”Ÿäº§è€…çº¿ç¨‹
    for i in 0..10 {
        let stack = stack.clone();
        handles.push(thread::spawn(move || {
            for j in 0..1000 {
                stack.push(i * 1000 + j);
            }
        }));
    }

    // æ¶ˆè´¹è€…çº¿ç¨‹
    for _ in 0..10 {
        let stack = stack.clone();
        handles.push(thread::spawn(move || {
            for _ in 0..1000 {
                stack.pop();
            }
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 9.3 æ¨¡å‹æ£€æŸ¥

**Loomæ¨¡å‹æ£€æŸ¥**:

```rust
#[test]
fn test_loom() {
    loom::model(|| {
        let stack = Arc::new(LockFreeStack::new());
        // ... æµ‹è¯•ä»£ç 
    });
}
```

### 9.4 å‹åŠ›æµ‹è¯•

**å‹åŠ›æµ‹è¯•**:

```rust
#[test]
#[ignore]  // é•¿æ—¶é—´è¿è¡Œ
fn test_stress() {
    // é•¿æ—¶é—´é«˜å¹¶å‘æµ‹è¯•
    // æ£€æŸ¥å†…å­˜æ³„æ¼ã€æ€§èƒ½é€€åŒ–ç­‰
}
```

---

## åã€å®é™…åº”ç”¨æ¡ˆä¾‹

### 10.1 Rustæ ‡å‡†åº“å®ç°

**Rustæ ‡å‡†åº“**:

```text
Rustæ ‡å‡†åº“æ— é”å®ç°:
â”œâ”€ Arc: åŸå­å¼•ç”¨è®¡æ•°
â”œâ”€ Mutex: å†…éƒ¨ä½¿ç”¨åŸå­æ“ä½œ
â””â”€ Channel: æ— é”é˜Ÿåˆ—å®ç°
```

### 10.2 é«˜æ€§èƒ½æ•°æ®åº“åº”ç”¨

**æ•°æ®åº“åº”ç”¨**:

```text
æ•°æ®åº“æ— é”åº”ç”¨:
â”œâ”€ WALå†™å…¥: æ— é”WALæŒ‡é’ˆæ›´æ–°
â”œâ”€ äº‹åŠ¡IDåˆ†é…: æ— é”è®¡æ•°å™¨
â””â”€ ç¼“å­˜ç®¡ç†: æ— é”LRUç¼“å­˜
```

### 10.3 å®æ—¶ç³»ç»Ÿåº”ç”¨

**å®æ—¶ç³»ç»Ÿåº”ç”¨**:

```text
å®æ—¶ç³»ç»Ÿæ— é”åº”ç”¨:
â”œâ”€ ä»»åŠ¡é˜Ÿåˆ—: Wait-Freeé˜Ÿåˆ—
â”œâ”€ äº‹ä»¶å¤„ç†: Lock-Freeäº‹ä»¶é˜Ÿåˆ—
â””â”€ æ•°æ®é‡‡é›†: æ— é”ç¯å½¢ç¼“å†²åŒº
```

---

## åä¸€ã€æ€»ç»“

### å®ç°è¦ç‚¹æ€»ç»“

```text
æ— é”æ•°æ®ç»“æ„å®ç°è¦ç‚¹:
â”œâ”€ çº¿æ€§åŒ–ç‚¹: æ˜ç¡®æ¯ä¸ªæ“ä½œçš„çº¿æ€§åŒ–ç‚¹
â”œâ”€ ABAé—®é¢˜: ä½¿ç”¨æ ‡è®°æŒ‡é’ˆ/å±é™©æŒ‡é’ˆ/ç‰ˆæœ¬å·
â”œâ”€ å†…å­˜å®‰å…¨: ä½¿ç”¨å±é™©æŒ‡é’ˆ/å¼•ç”¨è®¡æ•°
â”œâ”€ æ€§èƒ½ä¼˜åŒ–: ç¼“å­˜å¯¹é½ã€NUMAæ„ŸçŸ¥ã€æ‰¹é‡æ“ä½œ
â””â”€ æµ‹è¯•éªŒè¯: å•å…ƒæµ‹è¯•ã€å¹¶å‘æµ‹è¯•ã€æ¨¡å‹æ£€æŸ¥
```

### æœ€ä½³å®è·µ

```text
æ— é”æ•°æ®ç»“æ„æœ€ä½³å®è·µ:
â”œâ”€ ç®€å•ä¼˜å…ˆ: ä¼˜å…ˆä½¿ç”¨ç®€å•ç»“æ„ï¼ˆæ ˆã€é˜Ÿåˆ—ï¼‰
â”œâ”€ æ­£ç¡®æ€§ç¬¬ä¸€: ç¡®ä¿æ­£ç¡®æ€§å†ä¼˜åŒ–æ€§èƒ½
â”œâ”€ å……åˆ†æµ‹è¯•: ä½¿ç”¨æ¨¡å‹æ£€æŸ¥å·¥å…·éªŒè¯
â””â”€ æ–‡æ¡£å®Œå–„: è®°å½•çº¿æ€§åŒ–ç‚¹å’Œæ­£ç¡®æ€§ä¿è¯
```

---

**æœ€åæ›´æ–°**: 2025-12-05
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0
