# PostgreSQL 18最佳实践

> **版本**: PostgreSQL 18.x
> **更新**: 2025-12-04

---

## 配置优化

### 内存配置

```ini
# postgresql.conf

# 共享缓冲区（25%总内存）
shared_buffers = 32GB

# 有效缓存大小（70%总内存）
effective_cache_size = 90GB

# 工作内存（总内存/max_connections/2）
work_mem = 256MB

# 维护工作内存
maintenance_work_mem = 2GB
```

### 并行查询配置

```ini
# ⭐ PostgreSQL 18：并行查询优化

# 最大并行worker
max_parallel_workers = 16
max_parallel_workers_per_gather = 8
max_parallel_maintenance_workers = 4

# 代价参数（降低启用门槛）
parallel_tuple_cost = 0.001
parallel_setup_cost = 100

# 最小表大小
min_parallel_table_scan_size = 8MB
min_parallel_index_scan_size = 512kB
```

### 连接池配置

```ini
# ⭐ PostgreSQL 18：内置连接池

# 启用内置连接池
enable_builtin_connection_pooling = on

# 最大连接数
max_connections = 500

# 池大小
connection_pool_size = 200
```

---

## 索引最佳实践

### 选择合适的索引类型

```sql
-- B-tree：默认，最常用
CREATE INDEX idx_orders_customer ON orders(customer_id);

-- BRIN：时序数据（索引小95%）
CREATE INDEX idx_sensor_time ON sensor_data USING BRIN (timestamp);

-- GIN：数组、JSONB、全文搜索
CREATE INDEX idx_products_tags ON products USING GIN (tags);

-- GiST：地理数据、范围类型
CREATE INDEX idx_locations_geom ON locations USING GIST (geom);

-- Hash：仅等值查询（少用）
CREATE INDEX idx_users_email_hash ON users USING HASH (email);
```

### ⭐ PostgreSQL 18：Skip Scan优化

```sql
-- 多列索引，自动Skip Scan
CREATE INDEX idx_orders_store_date ON orders(store_id, order_date);

-- 查询（只用date，也能用索引）
SELECT * FROM orders WHERE order_date = '2025-12-04';

-- PG 18：自动Skip Scan，-86%时间
```

---

## 查询优化

### 使用EXPLAIN ANALYZE

```sql
-- ⭐ PostgreSQL 18：增强的EXPLAIN
EXPLAIN (
    ANALYZE,
    BUFFERS,
    SUMMARY,
    WAL,
    COSTS OFF
)
SELECT * FROM orders WHERE customer_id = 12345;

-- 新增输出：
-- - I/O Timings（读写延迟）
-- - JIT详细信息
-- - WAL统计
```

### 统计信息维护

```sql
-- ⭐ PostgreSQL 18：多变量统计
CREATE STATISTICS orders_stats (dependencies, ndistinct, mcv)
ON customer_id, product_id, order_date FROM orders;

-- 提高统计精度
ALTER TABLE orders ALTER COLUMN customer_id SET STATISTICS 500;

-- 定期ANALYZE
ANALYZE orders;
```

---

## 分区表最佳实践

### 按时间分区

```sql
-- 声明式分区
CREATE TABLE orders (
    order_id BIGINT,
    customer_id BIGINT,
    order_date DATE,
    amount NUMERIC(10,2),
    PRIMARY KEY (order_id, order_date)
) PARTITION BY RANGE (order_date);

-- 创建分区
CREATE TABLE orders_2025_12 PARTITION OF orders
FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- ⭐ PostgreSQL 18：分区裁剪性能+35%
```

### 自动分区管理

```sql
CREATE OR REPLACE FUNCTION create_monthly_partitions()
RETURNS void AS $$
DECLARE
    start_date DATE;
BEGIN
    FOR i IN 0..5 LOOP  -- 未来6个月
        start_date := DATE_TRUNC('month', CURRENT_DATE + (i || ' months')::INTERVAL);
        -- 创建分区逻辑...
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 定时任务
SELECT cron.schedule('create-partitions', '0 1 1 * *',
    'SELECT create_monthly_partitions()');
```

---

## VACUUM最佳实践

```sql
-- ⭐ PostgreSQL 18：并行VACUUM
VACUUM (PARALLEL 8, VERBOSE, ANALYZE) large_table;

-- 性能：-31%时间

-- Autovacuum配置
ALTER TABLE orders SET (
    autovacuum_vacuum_scale_factor = 0.05,
    autovacuum_analyze_scale_factor = 0.02,
    autovacuum_vacuum_cost_delay = 2
);
```

---

## 监控SQL

```sql
-- 慢查询监控
SELECT
    queryid,
    left(query, 80),
    calls,
    mean_exec_time,
    stddev_exec_time,
    rows
FROM pg_stat_statements
WHERE mean_exec_time > 100  -- >100ms
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 表膨胀检查
SELECT
    schemaname,
    tablename,
    n_live_tup,
    n_dead_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) as dead_pct
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY dead_pct DESC;

-- ⭐ PostgreSQL 18：新增监控字段
SELECT
    relname,
    last_autovacuum,
    autovacuum_elapsed_time,  -- 新增
    autoanalyze_elapsed_time   -- 新增
FROM pg_stat_all_tables;
```

---

**文档完成** ✅
