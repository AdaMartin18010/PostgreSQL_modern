# 思维表征：03-事务与并发控制模块完整本体图

> **创建日期**: 2025-12-03
> **模块**: 03-事务与并发控制
> **概念数**: 85+
> **关系边**: 150+
> **定理数**: 15+
> **状态**: ✅ Phase 2详细本体图

---

## 📋 完整概念本体图

### 1. 事务并发控制全景图

```mermaid
graph TB
    %% ========== 根概念 ==========
    ROOT[事务与并发控制] --> TX[事务管理]
    ROOT --> CC[并发控制]
    ROOT --> ISO[隔离性]
    ROOT --> SCHED[调度理论]
    ROOT --> LOCK[锁机制]

    %% ========== 事务管理分支 ==========
    TX --> TX_ACID[ACID属性]
    TX --> TX_STATE[事务状态]
    TX --> TX_OP[事务操作]

    TX_ACID --> ATOM[原子性A]
    TX_ACID --> CONS[一致性C]
    TX_ACID --> ISOL[隔离性I]
    TX_ACID --> DUR[持久性D]

    TX_STATE --> S_ACTIVE[活跃]
    TX_STATE --> S_COMMIT[已提交]
    TX_STATE --> S_ABORT[已回滚]

    TX_OP --> OP_BEGIN[BEGIN]
    TX_OP --> OP_READ[READ]
    TX_OP --> OP_WRITE[WRITE]
    TX_OP --> OP_COMMIT[COMMIT]
    TX_OP --> OP_ABORT[ABORT]

    %% ========== 并发控制分支 ==========
    CC --> CC_MVCC[MVCC多版本]
    CC --> CC_2PL[2PL两阶段锁]
    CC --> CC_OCC[OCC乐观控制]
    CC --> CC_TO[TO时间戳排序]

    %% MVCC展开
    CC_MVCC --> MVCC_VC[版本链]
    CC_MVCC --> MVCC_SNAP[快照]
    CC_MVCC --> MVCC_VIS[可见性规则]
    CC_MVCC --> MVCC_VAC[VACUUM]

    MVCC_VC --> VC_XMIN[xmin创建者]
    MVCC_VC --> VC_XMAX[xmax删除者]
    MVCC_VC --> VC_CTID[ctid指针]

    MVCC_SNAP --> SNAP_XIP[xip进行中事务]
    MVCC_SNAP --> SNAP_XMIN[xmin最小事务]
    MVCC_SNAP --> SNAP_XMAX[xmax最大事务]

    MVCC_VIS --> VIS_RULE1[创建者已提交]
    MVCC_VIS --> VIS_RULE2[删除者未提交]
    MVCC_VIS --> VIS_RULE3[快照可见]

    MVCC_VAC --> VAC_DEAD[清理死元组]
    MVCC_VAC --> VAC_FREEZE[冻结元组]
    MVCC_VAC --> VAC_AUTO[自动VACUUM]

    %% 2PL展开
    CC_2PL --> PL_GROW[增长阶段]
    CC_2PL --> PL_SHRINK[收缩阶段]
    CC_2PL --> PL_STRICT[严格2PL]

    %% ========== 隔离性分支 ==========
    ISO --> ISO_RU[读未提交RU]
    ISO --> ISO_RC[读已提交RC]
    ISO --> ISO_RR[可重复读RR]
    ISO --> ISO_SER[串行化SER]

    ISO --> ISO_ANOM[异常]
    ISO_ANOM --> ANOM_DR[脏读]
    ISO_ANOM --> ANOM_NR[不可重复读]
    ISO_ANOM --> ANOM_PR[幻读]
    ISO_ANOM --> ANOM_WS[写偏序]

    ISO --> ISO_SI[快照隔离SI]
    ISO_SI --> ISO_SSI[可串行化快照隔离SSI]

    %% ========== 调度理论分支 ==========
    SCHED --> SCHED_SER[串行调度]
    SCHED --> SCHED_CONF[冲突可串行化]
    SCHED --> SCHED_VIEW[视图可串行化]

    SCHED_CONF --> CONF[冲突]
    CONF --> CONF_RW[读-写冲突]
    CONF --> CONF_WR[写-读冲突]
    CONF --> CONF_WW[写-写冲突]

    SCHED --> SCHED_GRAPH[依赖图]
    SCHED_GRAPH --> SG_NODE[事务节点]
    SCHED_GRAPH --> SG_EDGE[依赖边]
    SCHED_GRAPH --> SG_CYCLE[环检测]

    %% ========== 锁机制分支 ==========
    LOCK --> LOCK_TYPE[锁类型]
    LOCK --> LOCK_GRAN[锁粒度]
    LOCK --> LOCK_ESC[锁升级]
    LOCK --> LOCK_DL[死锁]

    LOCK_TYPE --> LT_S[共享锁S]
    LOCK_TYPE --> LT_X[排他锁X]
    LOCK_TYPE --> LT_IS[意向共享IS]
    LOCK_TYPE --> LT_IX[意向排他IX]
    LOCK_TYPE --> LT_SIX[共享+意向排他]

    LOCK_GRAN --> LG_DB[数据库级]
    LOCK_GRAN --> LG_TABLE[表级]
    LOCK_GRAN --> LG_PAGE[页级]
    LOCK_GRAN --> LG_ROW[行级]
    LOCK_GRAN --> LG_PRED[谓词级]

    LOCK_ESC --> ESC_UP[锁升级]
    LOCK_ESC --> ESC_DOWN[锁降级]

    LOCK_DL --> DL_DETECT[死锁检测]
    LOCK_DL --> DL_WAIT[等待图]
    LOCK_DL --> DL_VICTIM[受害者选择]
    LOCK_DL --> DL_TIMEOUT[超时检测]

    %% ========== 谓词锁分支 ==========
    LOCK --> PRED_LOCK[谓词锁]
    PRED_LOCK --> PHANTOM[幽灵现象]
    PRED_LOCK --> GAP[间隙锁]
    PRED_LOCK --> NEXTKEY[Next-Key锁]

    %% ========== 样式 ==========
    classDef root fill:#FF6B6B,stroke:#333,stroke-width:4px
    classDef level1 fill:#FFD700,stroke:#333,stroke-width:3px
    classDef level2 fill:#90EE90,stroke:#333,stroke-width:2px
    classDef level3 fill:#87CEEB,stroke:#333,stroke-width:2px
    classDef mvcc fill:#FFA07A,stroke:#333,stroke-width:3px

    class ROOT root
    class TX,CC,ISO,SCHED,LOCK level1
    class CC_MVCC,CC_2PL,ISO_SI,LOCK_DL mvcc
```

---

## 2. 核心定理推理链图

### 2.1 MVCC正确性完整证明推理链

```mermaid
graph TD
    %% ========== 定义和前提 ==========
    DEF[定义: MVCC系统M<br/>版本链、快照、可见性规则] --> BASE[基础]

    AXIOM1[公理1: 每个版本有唯一xmin] --> BASE
    AXIOM2[公理2: 版本链按时间顺序] --> BASE
    AXIOM3[公理3: 快照包含xmin,xmax,xip] --> BASE

    BASE --> STEP1{步骤1:<br/>定义状态转换系统}

    %% ========== 步骤1：状态转换 ==========
    STEP1 --> STATE_DEF[状态 = Versions × Snapshots × Transactions]
    STATE_DEF --> TRANS_DEF[转换 = Begin | Read | Write | Commit]

    TRANS_DEF --> STEP2{步骤2:<br/>归纳证明不变式}

    %% ========== 步骤2：不变式 ==========
    STEP2 --> INV1[不变式1: 版本链一致]
    STEP2 --> INV2[不变式2: 快照有效]
    STEP2 --> INV3[不变式3: 可见性正确]

    %% 归纳基础
    INV1 --> BASE_CASE[基础情况: 初始状态满足]
    INV2 --> BASE_CASE
    INV3 --> BASE_CASE

    %% 归纳步骤
    BASE_CASE --> IND_STEP[归纳步骤: 每个操作保持不变式]

    IND_STEP --> OP_BEGIN[Begin操作验证]
    IND_STEP --> OP_READ[Read操作验证]
    IND_STEP --> OP_WRITE[Write操作验证]
    IND_STEP --> OP_COMMIT[Commit操作验证]

    OP_BEGIN --> INV_KEPT1[不变式保持✓]
    OP_READ --> INV_KEPT1
    OP_WRITE --> INV_KEPT1
    OP_COMMIT --> INV_KEPT1

    INV_KEPT1 --> STEP3{步骤3:<br/>证明快照一致性}

    %% ========== 步骤3：快照一致性 ==========
    STEP3 --> SNAP_CONS[快照一致性定义]
    SNAP_CONS --> SC1[事务读取的版本<br/>在快照时刻已提交]

    SC1 --> SC_PROOF[证明:<br/>可见性规则保证此性质]
    SC_PROOF --> VIS_RULE[可见性规则应用]
    VIS_RULE --> SC_RESULT[快照一致性成立✓]

    SC_RESULT --> STEP4{步骤4:<br/>证明隔离性}

    %% ========== 步骤4：隔离性 ==========
    STEP4 --> ISO_DEF[隔离性定义:<br/>并发事务不相互干扰]

    ISO_DEF --> ISO_PROOF1[证明1: 读操作]
    ISO_PROOF1 --> READ_SNAP[事务只读自己的快照]
    READ_SNAP --> READ_ISO[读隔离✓]

    ISO_DEF --> ISO_PROOF2[证明2: 写操作]
    ISO_PROOF2 --> WRITE_NEW[写操作创建新版本]
    WRITE_NEW --> WRITE_ISO[写隔离✓]

    READ_ISO --> STEP5{步骤5:<br/>证明快照隔离}
    WRITE_ISO --> STEP5

    %% ========== 步骤5：快照隔离 ==========
    STEP5 --> SI_DEF[快照隔离定义]
    SI_DEF --> SI_PROP1[性质1: First-Committer-Wins]
    SI_DEF --> SI_PROP2[性质2: 读取快照时刻数据]

    SI_PROP1 --> SI_PROOF[证明: MVCC实现这两个性质]
    SI_PROP2 --> SI_PROOF

    SI_PROOF --> SI_RESULT[快照隔离成立✓]

    SI_RESULT --> STEP6{步骤6:<br/>SSI扩展（可选）}

    %% ========== 步骤6：SSI ==========
    STEP6 --> SSI[可串行化快照隔离]
    SSI --> SSI_CHECK[检测危险结构]
    SSI_CHECK --> SSI_RW[RW-冲突检测]
    SSI_RW --> SSI_SER[串行化保证✓]

    %% ========== 最终结论 ==========
    INV_KEPT1 --> FINAL[最终结论]
    SC_RESULT --> FINAL
    SI_RESULT --> FINAL
    SSI_SER --> FINAL

    FINAL[MVCC正确性:<br/>1. 不变式保持<br/>2. 快照一致<br/>3. 快照隔离<br/>4. 可扩展到SSI]

    %% ========== 样式 ==========
    style DEF fill:#FFE4B5
    style BASE fill:#E0E0E0
    style STEP1,STEP2,STEP3,STEP4,STEP5,STEP6 fill:#FFD700
    style INV_KEPT1,SC_RESULT,READ_ISO,WRITE_ISO,SI_RESULT,SSI_SER fill:#90EE90
    style FINAL fill:#FF6B6B,stroke:#333,stroke-width:4px
```

### 2.2 快照隔离推理链（详细版）

```mermaid
graph TD
    %% 前提
    P1[前提1: 事务T1读x<br/>快照时刻=10] --> C1[观察点]
    P2[前提2: 事务T2写x<br/>提交时刻=15] --> C1
    P3[前提3: T1的快照<br/>xmin=5, xmax=20] --> C1

    %% 推理链
    C1 --> R1[推理1: T2提交于T1快照之后]
    R1 --> R2[推理2: T2的xmin=15 > T1的xmax=20? No]
    R2 --> R3[推理3: T2在T1快照范围内]

    R3 --> Q1{问题: T1能看到T2的写入吗?}

    Q1 --> CHECK1[检查1: T2是否在xip中?]
    CHECK1 -->|是| VIS_NO1[不可见:<br/>T2进行中]
    CHECK1 -->|否| CHECK2[检查2: T2提交时刻]

    CHECK2 -->|< 快照时刻| VIS_YES[可见:<br/>快照前已提交]
    CHECK2 -->|> 快照时刻| VIS_NO2[不可见:<br/>快照后提交]

    VIS_NO1 --> CONCL[结论: 快照隔离保证]
    VIS_NO2 --> CONCL
    VIS_YES --> CONCL2[例外: 若T2在快照前提交]

    CONCL --> FINAL[First-Committer-Wins规则]
    CONCL2 --> FINAL

    FINAL --> GUARANTEE[保证:<br/>1. 读一致性<br/>2. 写冲突检测<br/>3. 隔离性]

    style P1,P2,P3 fill:#FFE4B5
    style Q1 fill:#FFA500
    style VIS_NO1,VIS_NO2,CONCL fill:#90EE90
    style FINAL fill:#FFD700,stroke:#333,stroke-width:3px
    style GUARANTEE fill:#FF6B6B,stroke:#333,stroke-width:4px
```

---

## 3. 多维矩阵集合

### 3.1 并发控制机制 × 特性对比

| 机制 ↓ / 特性 → | 读性能 | 写性能 | 空间开销 | 实现复杂度 | 死锁风险 | 适用场景 |
|---------------|--------|--------|---------|-----------|---------|---------|
| **MVCC** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ (高) | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ (低) | 读多写少 |
| **2PL** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ (高) | 写密集 |
| **OCC** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 冲突少 |
| **TO** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | 只读事务多 |

### 3.2 隔离级别 × 异常防护矩阵

| 隔离级别 ↓ / 异常 → | 脏读 | 不可重复读 | 幻读 | 写偏序 | 性能 | PostgreSQL实现 |
|-------------------|-----|----------|-----|--------|------|----------------|
| **读未提交 RU** | ❌ 允许 | ❌ 允许 | ❌ 允许 | ❌ 允许 | ⭐⭐⭐⭐⭐ | 实际映射到RC |
| **读已提交 RC** | ✅ 防止 | ❌ 允许 | ❌ 允许 | ❌ 允许 | ⭐⭐⭐⭐ | 默认级别 |
| **可重复读 RR** | ✅ 防止 | ✅ 防止 | ⚠️ 防止 | ❌ 允许 | ⭐⭐⭐ | 快照隔离 |
| **串行化 SER** | ✅ 防止 | ✅ 防止 | ✅ 防止 | ✅ 防止 | ⭐⭐ | SSI实现 |

### 3.3 锁类型兼容性矩阵

| 已持有 ↓ / 请求 → | S共享 | X排他 | IS意向共享 | IX意向排他 | SIX |
|------------------|------|------|-----------|-----------|-----|
| **S共享** | ✅ | ❌ | ✅ | ❌ | ❌ |
| **X排他** | ❌ | ❌ | ❌ | ❌ | ❌ |
| **IS意向共享** | ✅ | ❌ | ✅ | ✅ | ✅ |
| **IX意向排他** | ❌ | ❌ | ✅ | ✅ | ❌ |
| **SIX** | ❌ | ❌ | ✅ | ❌ | ❌ |

### 3.4 MVCC vs 2PL详细对比

| 对比维度 | MVCC | 2PL | 说明 |
|---------|------|-----|------|
| **读-写冲突** | 不阻塞 | 阻塞 | MVCC核心优势 |
| **写-写冲突** | First-Committer-Wins | 阻塞等待 | 不同策略 |
| **读性能** | 高（无锁） | 中（需锁） | MVCC读优 |
| **写性能** | 中（创建版本） | 中（等锁） | 相近 |
| **空间** | 高（多版本） | 低（单版本） | MVCC劣势 |
| **VACUUM** | 需要 | 不需要 | MVCC开销 |
| **死锁** | 极少 | 较多 | MVCC优势 |
| **实现** | 复杂 | 中等 | 2PL较简单 |

---

## 4. 决策树集合

### 4.1 隔离级别选择决策树

```mermaid
flowchart TD
    START[选择隔离级别] --> Q1{应用类型?}

    Q1 -->|读密集| Q2{能容忍幻读?}
    Q1 -->|写密集| Q3{需要严格串行化?}
    Q1 -->|混合| Q4{性能优先?}

    Q2 -->|是| RC[读已提交 RC<br/>最佳性能]
    Q2 -->|否| RR[可重复读 RR<br/>快照隔离]

    Q3 -->|是| SER[串行化 SER<br/>SSI实现]
    Q3 -->|否| RR2[可重复读 RR]

    Q4 -->|是| RC2[读已提交 RC]
    Q4 -->|否| RR3[可重复读 RR]

    RC --> PERF1[性能: ⭐⭐⭐⭐⭐<br/>隔离: ⭐⭐]
    RR --> PERF2[性能: ⭐⭐⭐⭐<br/>隔离: ⭐⭐⭐⭐]
    SER --> PERF3[性能: ⭐⭐⭐<br/>隔离: ⭐⭐⭐⭐⭐]

    style START fill:#FFD700
    style RC,RR,SER fill:#90EE90
    style PERF1,PERF2,PERF3 fill:#87CEEB
```

### 4.2 死锁处理决策树

```mermaid
flowchart TD
    START[检测到死锁] --> Q1{死锁类型?}

    Q1 -->|简单死锁<br/>2个事务| SIMPLE[简单死锁处理]
    Q1 -->|复杂死锁<br/>3+个事务| COMPLEX[复杂死锁处理]

    SIMPLE --> S1[选择受害者:<br/>最小代价事务]
    S1 --> S2[回滚受害者]
    S2 --> S3[释放锁]
    S3 --> S4[通知应用重试]

    COMPLEX --> C1[构建等待图]
    C1 --> C2[检测环]
    C2 --> C3{多个环?}

    C3 -->|是| C4[选择涉及最多环的事务]
    C3 -->|否| C5[选择环中代价最小事务]

    C4 --> C6[回滚选中事务]
    C5 --> C6
    C6 --> C7[更新等待图]
    C7 --> C8{环已消除?}

    C8 -->|是| DONE[死锁解除]
    C8 -->|否| C2

    S4 --> MONITOR[记录死锁事件]
    DONE --> MONITOR
    MONITOR --> ANALYSIS[分析死锁原因]

    ANALYSIS --> PREVENT[预防措施:<br/>1. 按序获取锁<br/>2. 超时设置<br/>3. 索引优化]

    style START fill:#FF6B6B
    style DONE fill:#90EE90
    style PREVENT fill:#87CEEB
```

### 4.3 VACUUM策略选择决策树

```mermaid
flowchart TD
    START[VACUUM策略选择] --> Q1{表大小?}

    Q1 -->|小表<br/>< 1GB| SMALL[小表策略]
    Q1 -->|中表<br/>1-100GB| MEDIUM[中表策略]
    Q1 -->|大表<br/>> 100GB| LARGE[大表策略]

    SMALL --> Q2{膨胀率?}
    Q2 -->|> 50%| FULL1[VACUUM FULL]
    Q2 -->|< 50%| AUTO1[Auto VACUUM]

    MEDIUM --> Q3{更新频率?}
    Q3 -->|高| FREQ[频繁VACUUM<br/>每小时]
    Q3 -->|中| NORMAL[正常VACUUM<br/>每天]
    Q3 -->|低| LAZY[延迟VACUUM<br/>每周]

    LARGE --> Q4{分区表?}
    Q4 -->|是| PART[分区VACUUM<br/>并行执行]
    Q4 -->|否| INCR[增量VACUUM<br/>分批执行]

    AUTO1 --> TUNE1[调优:<br/>autovacuum_vacuum_scale_factor]
    FREQ --> TUNE2[调优:<br/>降低threshold]
    PART --> TUNE3[调优:<br/>max_parallel_maintenance_workers]

    style START fill:#FFD700
    style FULL1 fill:#FF6B6B
    style AUTO1,FREQ,NORMAL,LAZY,PART,INCR fill:#90EE90
```

---

## 5. 概念层次树（完整展开）

### 5.1 MVCC概念层次树

```mermaid
graph TD
    %% Level 1: 根
    MVCC[MVCC<br/>Multi-Version<br/>Concurrency Control]

    %% Level 2: 核心组件
    MVCC --> VER[版本管理]
    MVCC --> SNAP[快照管理]
    MVCC --> VIS[可见性判断]
    MVCC --> GC[垃圾回收]

    %% Level 3: 版本管理细节
    VER --> VER_CHAIN[版本链]
    VER --> VER_META[版本元数据]
    VER --> VER_HOT[HOT优化]

    VER_META --> xmin[xmin字段]
    VER_META --> xmax[xmax字段]
    VER_META --> ctid[ctid字段]
    VER_META --> infomask[infomask标志]

    infomask --> HINT[提示位]
    HINT --> XMIN_COMMITTED[xmin已提交]
    HINT --> XMAX_COMMITTED[xmax已提交]

    %% Level 3: 快照管理细节
    SNAP --> SNAP_DATA[SnapshotData结构]
    SNAP --> SNAP_CREATE[快照创建]
    SNAP --> SNAP_SHARE[快照共享]

    SNAP_DATA --> xip[xip数组]
    SNAP_DATA --> xmin_snap[xmin快照]
    SNAP_DATA --> xmax_snap[xmax快照]

    %% Level 3: 可见性判断细节
    VIS --> VIS_FUNC[可见性函数]
    VIS --> VIS_RULE[可见性规则]
    VIS --> VIS_OPT[可见性优化]

    VIS_FUNC --> HTSS[HeapTupleSatisfiesSnapshot]
    VIS_FUNC --> HTSMVCC[HeapTupleSatisfiesMVCC]

    VIS_RULE --> RULE1[创建者可见性]
    VIS_RULE --> RULE2[删除者可见性]
    VIS_RULE --> RULE3[快照范围检查]

    %% Level 3: 垃圾回收细节
    GC --> VAC[VACUUM]
    GC --> AUTO_VAC[Auto VACUUM]
    GC --> FREEZE[Freeze冻结]

    VAC --> VAC_STD[标准VACUUM]
    VAC --> VAC_FULL[VACUUM FULL]
    VAC --> VAC_ANALYZE[VACUUM ANALYZE]

    AUTO_VAC --> VAC_DAEMON[autovacuum daemon]
    AUTO_VAC --> VAC_WORKER[autovacuum worker]

    FREEZE --> XID_WRAP[XID回卷防护]
    FREEZE --> FROZEN_XID[FROZEN_XID标记]

    %% 样式
    classDef level1 fill:#FF6B6B,stroke:#333,stroke-width:4px
    classDef level2 fill:#FFD700,stroke:#333,stroke-width:3px
    classDef level3 fill:#90EE90,stroke:#333,stroke-width:2px
    classDef level4 fill:#87CEEB,stroke:#333,stroke-width:1px

    class MVCC level1
    class VER,SNAP,VIS,GC level2
    class VER_CHAIN,VER_META,SNAP_DATA,VIS_FUNC,VAC level3
```

---

## 6. PostgreSQL 18事务特性本体

### 6.1 异步I/O在事务中的应用

```mermaid
graph TB
    PG18[PostgreSQL 18<br/>异步I/O] --> BENEFIT[性能提升]
    PG18 --> IMPL[实现机制]
    PG18 --> IMPACT[对事务的影响]

    %% 性能提升
    BENEFIT --> B1[顺序扫描提升3x]
    BENEFIT --> B2[VACUUM提升2x]
    BENEFIT --> B3[位图扫描提升]

    %% 实现机制
    IMPL --> I1[io_uring Linux]
    IMPL --> I2[IOCP Windows]
    IMPL --> I3[异步预读]
    IMPL --> I4[异步写入]

    %% 对事务的影响
    IMPACT --> IM1[WAL写入优化]
    IMPACT --> IM2[VACUUM并发性提升]
    IMPACT --> IM3[可见性判断不变]

    IM1 --> WAL_ASYNC[WAL异步刷盘]
    IM2 --> VAC_ASYNC[VACUUM异步读]
    IM3 --> VIS_COMPAT[向后兼容]

    style PG18 fill:#FFA07A,stroke:#333,stroke-width:4px
    style BENEFIT fill:#90EE90
    style IMPACT fill:#87CEEB
```

---

## 7. 跨模块概念关联网络

### 7.1 事务模块与其他模块的关系

```mermaid
graph LR
    %% 事务模块核心
    TX[03-事务模块] --> MVCC[MVCC核心]

    %% 与存储模块
    MVCC -->|depends-on| WAL[06-存储: WAL]
    MVCC -->|depends-on| PAGE[06-存储: 页结构]
    MVCC -->|uses| VACUUM[06-存储: VACUUM]

    %% 与查询模块
    MVCC -->|影响| PLAN[05-查询: 查询计划]
    SNAP[快照] -->|影响| VIS_CHECK[05-查询: 可见性过滤]

    %% 与索引模块
    VIS[可见性] -->|结合| IDX_SCAN[05-索引: 索引扫描]
    xmin_xmax[xmin/xmax] -->|存储在| HEAP[06-存储: 堆元组]

    %% 与分布式模块
    TX -->|扩展| DIST_TX[04-分布式: 分布式事务]
    SI[快照隔离] -->|理论基础| CAP[04-分布式: CAP权衡]

    %% 与形式化模块
    MVCC -->|形式化| TLA[01-形式化: TLA+规范]
    PROOF[MVCC证明] -->|使用| INDUCTION[01-形式化: 归纳法]

    %% 与AI模块
    STAT[事务统计] -->|用于| ML[11-AI: 模型训练]
    PERF[性能数据] -->|用于| AI_OPT[11-AI: 自适应优化]
```

---

## 8. 学习路径（事务专家）

### 8.1 事务专家完整学习路径

```mermaid
graph TB
    %% ========== 基础阶段 ==========
    START[开始] --> ACID[理解ACID]
    ACID --> TX_BASIC[事务基础操作]
    TX_BASIC --> ISO_BASIC[隔离级别基础]

    %% ========== 核心阶段 ==========
    ISO_BASIC --> CC_THEORY[并发控制理论]
    CC_THEORY --> MVCC_INTRO[MVCC入门]

    MVCC_INTRO --> MVCC_DEEP[MVCC深入]
    MVCC_DEEP --> VER_CHAIN[版本链机制]
    MVCC_DEEP --> SNAPSHOT[快照机制]
    MVCC_DEEP --> VISIBILITY[可见性判断]

    VER_CHAIN --> XID[XID事务ID]
    SNAPSHOT --> SNAP_DATA[SnapshotData结构]
    VISIBILITY --> VIS_ALGO[可见性算法]

    %% ========== 高级阶段 ==========
    MVCC_DEEP --> SI[快照隔离理论]
    SI --> SI_PROOF[快照隔离证明]
    SI --> SSI[SSI可串行化]

    SSI --> SSI_CHECK[危险结构检测]
    SSI --> SSI_IMPL[PostgreSQL SSI实现]

    %% ========== 实践阶段 ==========
    MVCC_DEEP --> VACUUM_STUDY[VACUUM机制]
    VACUUM_STUDY --> VAC_TUNE[VACUUM调优]
    VAC_TUNE --> BLOAT[膨胀问题]

    %% ========== 对比阶段 ==========
    CC_THEORY --> 2PL_STUDY[2PL两阶段锁]
    2PL_STUDY --> LOCK_STUDY[锁机制深入]
    LOCK_STUDY --> DEADLOCK[死锁检测]

    %% ========== 专家阶段 ==========
    SSI --> FORMAL[形式化验证]
    FORMAL --> TLA_MVCC[TLA+ MVCC规范]
    TLA_MVCC --> PROOF_WRITE[编写形式化证明]

    DEADLOCK --> ADV_TOPICS[高级主题]
    VAC_TUNE --> ADV_TOPICS

    ADV_TOPICS --> DIST_TX[分布式事务]
    ADV_TOPICS --> PERF_OPT[性能优化]
    ADV_TOPICS --> SOURCE_CODE[源码分析]

    %% 样式
    style START fill:#FFD700
    style MVCC_DEEP fill:#90EE90,stroke:#333,stroke-width:3px
    style SSI fill:#87CEEB,stroke:#333,stroke-width:3px
    style ADV_TOPICS fill:#FFA07A,stroke:#333,stroke-width:3px
```

---

## 9. 概念依赖分析

### 9.1 MVCC核心概念依赖图

```mermaid
graph TD
    %% 基础依赖
    ACID[ACID属性] --> TX[事务]
    TX --> CC[并发控制]

    %% MVCC依赖
    CC --> MVCC[MVCC]
    MVCC --> XID_SYS[XID系统]
    MVCC --> VER_SYS[版本系统]
    MVCC --> VIS_SYS[可见性系统]

    %% XID系统依赖
    XID_SYS --> XID[事务ID]
    XID --> XID_ALLOC[XID分配]
    XID --> XID_WRAP[XID回卷]

    %% 版本系统依赖
    VER_SYS --> HEAP[堆元组]
    HEAP --> xmin[xmin字段]
    HEAP --> xmax[xmax字段]
    HEAP --> ctid[ctid字段]

    xmin --> CLOG[CLOG提交状态]
    xmax --> CLOG

    %% 可见性系统依赖
    VIS_SYS --> SNAP[快照]
    SNAP --> xip[xip数组]
    SNAP --> xmin_snap[xmin字段]
    SNAP --> xmax_snap[xmax字段]

    VIS_SYS --> VIS_FUNC[可见性函数]
    VIS_FUNC --> SNAP
    VIS_FUNC --> CLOG

    %% VACUUM依赖
    VIS_SYS --> VACUUM[VACUUM]
    VACUUM --> VIS_FUNC
    VACUUM --> DEAD_TUPLE[死元组检测]

    %% WAL依赖
    MVCC --> WAL[WAL日志]
    WAL --> LSN[LSN]

    %% 样式
    classDef base fill:#FFE4B5
    classDef core fill:#90EE90
    classDef impl fill:#87CEEB

    class ACID,TX,CC base
    class MVCC,XID_SYS,VER_SYS,VIS_SYS core
    class xmin,xmax,SNAP,VIS_FUNC impl
```

---

## 10. 概念属性完整定义

### 10.1 核心概念属性卡片

#### MVCC (T01)

**基本信息**：

- **ID**: T01
- **名称**: Multi-Version Concurrency Control
- **中文**: 多版本并发控制
- **抽象层次**: M2(理论层)
- **模块**: 03-事务与并发控制

**属性**：

```yaml
实现方式: 版本链 + 快照
隔离级别:
  - 读已提交: ✅ 原生支持
  - 可重复读: ✅ 快照隔离
  - 串行化: ✅ SSI实现
性能:
  读性能: 极高（无锁读取）
  写性能: 中等（创建新版本）
  空间开销: 高（多版本存储）
优势:
  - 读不阻塞写
  - 写不阻塞读
  - 高并发性能
劣势:
  - 空间开销大
  - 需要VACUUM
  - 写偏序可能
适用场景:
  - 读多写少
  - 高并发读
  - OLTP系统
```

**操作**：

```text
BEGIN:  创建事务，分配XID，创建快照
READ:   根据快照判断版本可见性
WRITE:  创建新版本，设置xmin
COMMIT: 标记事务提交，版本对后续可见
ABORT:  标记事务回滚，版本无效
```

**不变式**：

```text
INV1: ∀v ∈ Versions. ∃!t ∈ Transactions. v.xmin = t.id
INV2: ∀v1, v2 ∈ VersionChain. v1.xmin < v2.xmin → v1.ctid = v2
INV3: ∀t ∈ Transactions, v ∈ Versions. visible(t, v) → committed(v.xmin)
```

**定理**：

- 快照隔离正确性定理
- MVCC不变式保持定理
- 可串行化定理（SSI）

**PostgreSQL实现**：

```c
// 核心数据结构
typedef struct HeapTupleHeaderData {
    TransactionId t_xmin;    // 创建者XID
    TransactionId t_xmax;    // 删除者XID
    ItemPointerData t_ctid;  // 当前或下一版本位置
    uint16 t_infomask;       // 标志位
} HeapTupleHeaderData;

// 快照结构
typedef struct SnapshotData {
    TransactionId xmin;      // 最小活跃XID
    TransactionId xmax;      // 最大已分配XID
    TransactionId *xip;      // 活跃事务数组
    uint32 xcnt;             // 活跃事务数量
} SnapshotData;
```

**相关概念**：

- 依赖: 并发控制(MC01), 事务(MC02), XID系统
- 组成: 版本链(T07), 快照(I02), 可见性规则(T08), VACUUM(I06)
- 实现: xmin(I03), xmax(I04), SnapshotData
- 扩展: 快照隔离(T05), SSI(T06)

---

## 11. Phase 2进度更新

### 11.1 已完成本体图

| 模块 | 概念数 | 关系边 | 推理链图 | 决策树 | 矩阵 | 状态 |
|-----|-------|--------|---------|--------|------|------|
| 07-安全 | 45+ | 80+ | 2 | 1 | 3 | ✅ |
| 03-事务 | 85+ | 150+ | 2 | 3 | 4 | ✅ |

**总计**: 2/18模块，进度11%

### 11.2 思维表征统计

| 表征类型 | 已创建 | 待创建 | 覆盖率 |
|---------|-------|--------|--------|
| **详细本体图** | 2 | 16 | 11% |
| **推理链图** | 4 | 36+ | 10% |
| **决策树** | 4 | 30+ | 12% |
| **多维矩阵** | 7 | 10+ | 41% |
| **概念卡片** | 11 | 889 | 1% |

---

## 12. 下一步行动

### 立即继续

- [ ] 创建05-索引模块详细本体图（120+概念）
- [ ] 创建01-形式化方法模块详细本体图（75+概念）
- [ ] 创建查询优化器推理链图

### 今日目标

- [ ] 完成3-4个模块详细本体图
- [ ] 总进度达到Phase 2的20-25%

---

**创建日期**: 2025-12-03
**状态**: ✅ 第2个详细本体图完成
**质量**: ⭐⭐⭐⭐⭐
**下一步**: 🚀 继续创建索引模块本体图
