# 金融反欺诈系统 - 核心实现

> **案例类型**: 实时欺诈检测系统
> **难度等级**: ⭐⭐⭐⭐⭐
> **PostgreSQL版本**: 18.x
> **创建日期**: 2025年1月

---

## 📋 目录

- [一、核心检测函数](#一核心检测函数)
- [二、规则引擎实现](#二规则引擎实现)
- [三、特征提取函数](#三特征提取函数)
- [四、决策融合函数](#四决策融合函数)
- [五、辅助函数](#五辅助函数)

---

## 一、核心检测函数

### 1.1 主检测函数 (detect_fraud)

```sql
-- 欺诈检测主函数
CREATE OR REPLACE FUNCTION detect_fraud(
    p_user_id BIGINT,
    p_amount NUMERIC,
    p_merchant_id BIGINT,
    p_device_id VARCHAR(100),
    p_ip_address INET
) RETURNS TABLE (
    risk_score NUMERIC,
    final_decision VARCHAR(20),
    decision_reason TEXT,
    matched_rules JSONB
) AS $$
DECLARE
    v_transaction_id BIGINT;
    v_rule_score NUMERIC := 0;
    v_ml_score NUMERIC := 0;
    v_final_score NUMERIC;
    v_decision VARCHAR(20);
    v_reason TEXT;
    v_matched_rules JSONB := '[]'::jsonb;
    v_features JSONB;
BEGIN
    -- 1. 创建交易记录
    INSERT INTO transactions (
        user_id, amount, merchant_id, device_id, ip_address, status
    ) VALUES (
        p_user_id, p_amount, p_merchant_id, p_device_id, p_ip_address, 'pending'
    )
    RETURNING transaction_id INTO v_transaction_id;

    -- 2. 提取特征
    v_features := extract_features(p_user_id, p_device_id);

    -- 3. 规则引擎匹配（异步I/O批量查询）
    SELECT
        COALESCE(SUM(score), 0),
        jsonb_agg(rule_info)
    INTO
        v_rule_score,
        v_matched_rules
    FROM match_rules(p_user_id, p_amount, p_merchant_id, p_device_id, v_features);

    -- 4. ML模型评分（如果启用）
    -- v_ml_score := ml_predict_fraud(v_features);

    -- 5. 决策融合
    v_final_score := (v_rule_score * 0.6) + (COALESCE(v_ml_score, 0) * 0.4);
    v_decision := CASE
        WHEN v_final_score >= 80 THEN 'reject'
        WHEN v_final_score >= 60 THEN 'review'
        ELSE 'pass'
    END;
    v_reason := format('规则分数: %s, ML分数: %s, 最终分数: %s',
                       v_rule_score, v_ml_score, v_final_score);

    -- 6. 记录检测结果
    INSERT INTO detection_results (
        transaction_id, risk_score, final_decision, decision_reason,
        matched_rules, rule_score, ml_score, feature_snapshot
    ) VALUES (
        v_transaction_id, v_final_score, v_decision, v_reason,
        v_matched_rules, v_rule_score, v_ml_score, v_features
    );

    -- 7. 更新交易状态
    UPDATE transactions
    SET status = CASE
        WHEN v_decision = 'reject' THEN 'failed'
        ELSE 'success'
    END,
    completed_at = CURRENT_TIMESTAMP
    WHERE transaction_id = v_transaction_id;

    -- 8. 返回结果
    RETURN QUERY SELECT
        v_final_score,
        v_decision,
        v_reason,
        v_matched_rules;
END;
$$ LANGUAGE plpgsql;
```

---

## 二、规则引擎实现

### 2.1 规则匹配函数 (match_rules)

```sql
-- 规则匹配函数（批量匹配）
CREATE OR REPLACE FUNCTION match_rules(
    p_user_id BIGINT,
    p_amount NUMERIC,
    p_merchant_id BIGINT,
    p_device_id VARCHAR(100),
    p_features JSONB
) RETURNS TABLE (
    rule_id VARCHAR(50),
    rule_name VARCHAR(200),
    score NUMERIC,
    reason TEXT,
    rule_info JSONB
) AS $$
BEGIN
    RETURN QUERY
    WITH matched AS (
        SELECT
            fr.rule_id,
            fr.rule_name,
            (fr.actions->>'score')::NUMERIC as score,
            fr.actions->>'reason' as reason,
            jsonb_build_object(
                'rule_id', fr.rule_id,
                'rule_name', fr.rule_name,
                'score', (fr.actions->>'score')::NUMERIC,
                'reason', fr.actions->>'reason'
            ) as rule_info
        FROM fraud_rules fr
        WHERE fr.is_active = true
          AND evaluate_rule_conditions(fr.conditions, p_user_id, p_amount,
                                      p_merchant_id, p_device_id, p_features)
        ORDER BY fr.priority DESC
    )
    SELECT * FROM matched;
END;
$$ LANGUAGE plpgsql;
```

### 2.2 规则条件评估函数 (evaluate_rule_conditions)

```sql
-- 规则条件评估函数
CREATE OR REPLACE FUNCTION evaluate_rule_conditions(
    p_conditions JSONB,
    p_user_id BIGINT,
    p_amount NUMERIC,
    p_merchant_id BIGINT,
    p_device_id VARCHAR(100),
    p_features JSONB
) RETURNS BOOLEAN AS $$
DECLARE
    v_result BOOLEAN := true;
    v_condition JSONB;
BEGIN
    -- 金额条件
    IF p_conditions ? 'amount' THEN
        v_condition := p_conditions->'amount';
        IF v_condition ? '$gt' THEN
            v_result := v_result AND (p_amount > (v_condition->>'$gt')::NUMERIC);
        END IF;
        IF v_condition ? '$lt' THEN
            v_result := v_result AND (p_amount < (v_condition->>'$lt')::NUMERIC);
        END IF;
    END IF;

    -- 时间条件
    IF p_conditions ? 'time' THEN
        v_condition := p_conditions->'time';
        IF v_condition ? 'hour' THEN
            v_result := v_result AND (EXTRACT(HOUR FROM NOW()) = ANY(
                ARRAY(SELECT jsonb_array_elements_text(v_condition->'hour'))::INT[]
            ));
        END IF;
    END IF;

    -- 设备条件
    IF p_conditions ? 'device' THEN
        v_condition := p_conditions->'device';
        IF v_condition ? 'new_device' AND (v_condition->>'new_device')::BOOLEAN THEN
            v_result := v_result AND (
                SELECT COUNT(*) = 0
                FROM transactions
                WHERE device_id = p_device_id
                  AND created_at >= NOW() - INTERVAL '7 days'
            );
        END IF;
    END IF;

    -- 用户特征条件
    IF p_conditions ? 'user_features' THEN
        v_condition := p_conditions->'user_features';
        IF v_condition ? 'tx_count_24h' THEN
            v_result := v_result AND (
                (p_features->>'tx_count_24h')::INT >=
                (v_condition->>'tx_count_24h')::INT
            );
        END IF;
    END IF;

    RETURN v_result;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## 三、特征提取函数

### 3.1 主特征提取函数 (extract_features)

```sql
-- 特征提取函数
CREATE OR REPLACE FUNCTION extract_features(
    p_user_id BIGINT,
    p_device_id VARCHAR(100)
) RETURNS JSONB AS $$
DECLARE
    v_features JSONB;
    v_user_features JSONB;
    v_device_features JSONB;
BEGIN
    -- 提取用户特征
    v_user_features := extract_user_features(p_user_id);

    -- 提取设备特征
    v_device_features := extract_device_features(p_device_id);

    -- 合并特征
    v_features := jsonb_build_object(
        'user_features', v_user_features,
        'device_features', v_device_features,
        'timestamp', EXTRACT(EPOCH FROM NOW())
    );

    RETURN v_features;
END;
$$ LANGUAGE plpgsql;
```

### 3.2 用户特征提取 (extract_user_features)

```sql
-- 用户特征提取
CREATE OR REPLACE FUNCTION extract_user_features(
    p_user_id BIGINT
) RETURNS JSONB AS $$
DECLARE
    v_features JSONB;
BEGIN
    SELECT jsonb_build_object(
        'tx_count_1h', COALESCE(tx_count_1h, 0),
        'tx_amount_1h', COALESCE(tx_amount_1h, 0),
        'tx_count_24h', COALESCE(tx_count_24h, 0),
        'tx_amount_24h', COALESCE(tx_amount_24h, 0),
        'tx_count_7d', COALESCE(tx_count_7d, 0),
        'avg_amount_24h', COALESCE(avg_amount_24h, 0),
        'top_merchants', COALESCE(top_merchants, '[]'::jsonb)
    )
    INTO v_features
    FROM user_features
    WHERE user_id = p_user_id;

    -- 如果不存在，返回默认值
    IF v_features IS NULL THEN
        v_features := jsonb_build_object(
            'tx_count_1h', 0,
            'tx_amount_1h', 0,
            'tx_count_24h', 0,
            'tx_amount_24h', 0,
            'tx_count_7d', 0,
            'avg_amount_24h', 0,
            'top_merchants', '[]'::jsonb
        );
    END IF;

    RETURN v_features;
END;
$$ LANGUAGE plpgsql;
```

### 3.3 设备特征提取 (extract_device_features)

```sql
-- 设备特征提取
CREATE OR REPLACE FUNCTION extract_device_features(
    p_device_id VARCHAR(100)
) RETURNS JSONB AS $$
DECLARE
    v_features JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user_count', COALESCE(user_count, 0),
        'tx_count_24h', COALESCE(tx_count_24h, 0),
        'tx_amount_24h', COALESCE(tx_amount_24h, 0),
        'risk_score', COALESCE(risk_score, 0),
        'is_blacklisted', COALESCE(is_blacklisted, false),
        'first_seen', first_seen,
        'last_seen', last_seen
    )
    INTO v_features
    FROM device_features
    WHERE device_id = p_device_id;

    -- 如果不存在，创建新记录
    IF v_features IS NULL THEN
        INSERT INTO device_features (device_id, first_seen, last_seen)
        VALUES (p_device_id, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        ON CONFLICT (device_id) DO NOTHING;

        v_features := jsonb_build_object(
            'user_count', 0,
            'tx_count_24h', 0,
            'tx_amount_24h', 0,
            'risk_score', 0,
            'is_blacklisted', false,
            'first_seen', CURRENT_TIMESTAMP,
            'last_seen', CURRENT_TIMESTAMP
        );
    END IF;

    RETURN v_features;
END;
$$ LANGUAGE plpgsql;
```

### 3.4 特征更新函数 (update_user_features)

```sql
-- 用户特征更新（新交易完成后调用）
CREATE OR REPLACE FUNCTION update_user_features(
    p_user_id BIGINT,
    p_amount NUMERIC,
    p_merchant_id BIGINT
) RETURNS VOID AS $$
BEGIN
    -- 使用UPSERT更新特征
    INSERT INTO user_features (
        user_id,
        tx_count_1h, tx_amount_1h,
        tx_count_24h, tx_amount_24h,
        tx_count_7d, avg_amount_24h,
        last_updated
    )
    SELECT
        p_user_id,
        COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '1 hour'),
        COALESCE(SUM(amount) FILTER (WHERE created_at >= NOW() - INTERVAL '1 hour'), 0),
        COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '24 hours'),
        COALESCE(SUM(amount) FILTER (WHERE created_at >= NOW() - INTERVAL '24 hours'), 0),
        COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '7 days'),
        COALESCE(AVG(amount) FILTER (WHERE created_at >= NOW() - INTERVAL '24 hours'), 0),
        CURRENT_TIMESTAMP
    FROM transactions
    WHERE user_id = p_user_id
    GROUP BY user_id
    ON CONFLICT (user_id) DO UPDATE SET
        tx_count_1h = EXCLUDED.tx_count_1h,
        tx_amount_1h = EXCLUDED.tx_amount_1h,
        tx_count_24h = EXCLUDED.tx_count_24h,
        tx_amount_24h = EXCLUDED.tx_amount_24h,
        tx_count_7d = EXCLUDED.tx_count_7d,
        avg_amount_24h = EXCLUDED.avg_amount_24h,
        last_updated = EXCLUDED.last_updated;
END;
$$ LANGUAGE plpgsql;
```

---

## 四、决策融合函数

### 4.1 融合决策函数 (fuse_decision)

```sql
-- 决策融合函数
CREATE OR REPLACE FUNCTION fuse_decision(
    p_rule_score NUMERIC,
    p_ml_score NUMERIC DEFAULT NULL,
    p_rule_weight NUMERIC DEFAULT 0.6,
    p_ml_weight NUMERIC DEFAULT 0.4
) RETURNS TABLE (
    final_score NUMERIC,
    decision VARCHAR(20),
    reason TEXT
) AS $$
DECLARE
    v_final_score NUMERIC;
    v_decision VARCHAR(20);
    v_reason TEXT;
BEGIN
    -- 计算融合分数
    v_final_score := (p_rule_score * p_rule_weight) +
                     (COALESCE(p_ml_score, 0) * p_ml_weight);

    -- 决策逻辑
    v_decision := CASE
        WHEN v_final_score >= 80 THEN 'reject'
        WHEN v_final_score >= 60 THEN 'review'
        ELSE 'pass'
    END;

    -- 生成原因
    v_reason := format(
        '规则分数: %s (权重: %s%%) + ML分数: %s (权重: %s%%) = 最终分数: %s',
        p_rule_score, p_rule_weight * 100,
        COALESCE(p_ml_score, 0), p_ml_weight * 100,
        v_final_score
    );

    RETURN QUERY SELECT v_final_score, v_decision, v_reason;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

---

## 五、辅助函数

### 5.1 规则命中统计更新

```sql
-- 更新规则命中统计
CREATE OR REPLACE FUNCTION update_rule_statistics(
    p_rule_id VARCHAR(50)
) RETURNS VOID AS $$
BEGIN
    UPDATE fraud_rules
    SET
        hit_count = hit_count + 1,
        last_hit_time = CURRENT_TIMESTAMP
    WHERE rule_id = p_rule_id;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 规则管理函数

```sql
-- 创建/更新规则
CREATE OR REPLACE FUNCTION upsert_fraud_rule(
    p_rule_id VARCHAR(50),
    p_rule_name VARCHAR(200),
    p_conditions JSONB,
    p_actions JSONB,
    p_priority INTEGER DEFAULT 0,
    p_rule_type VARCHAR(50) DEFAULT NULL,
    p_created_by VARCHAR(100) DEFAULT CURRENT_USER
) RETURNS VOID AS $$
BEGIN
    INSERT INTO fraud_rules (
        rule_id, rule_name, conditions, actions,
        priority, rule_type, created_by, version
    ) VALUES (
        p_rule_id, p_rule_name, p_conditions, p_actions,
        p_priority, p_rule_type, p_created_by, 1
    )
    ON CONFLICT (rule_id) DO UPDATE SET
        rule_name = EXCLUDED.rule_name,
        conditions = EXCLUDED.conditions,
        actions = EXCLUDED.actions,
        priority = EXCLUDED.priority,
        rule_type = EXCLUDED.rule_type,
        version = fraud_rules.version + 1,
        updated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- 启用/禁用规则
CREATE OR REPLACE FUNCTION toggle_rule(
    p_rule_id VARCHAR(50),
    p_is_active BOOLEAN
) RETURNS VOID AS $$
BEGIN
    UPDATE fraud_rules
    SET is_active = p_is_active,
        updated_at = CURRENT_TIMESTAMP
    WHERE rule_id = p_rule_id;
END;
$$ LANGUAGE plpgsql;
```

### 5.3 审计日志记录

```sql
-- 记录审计日志
CREATE OR REPLACE FUNCTION log_audit(
    p_transaction_id BIGINT,
    p_result_id BIGINT,
    p_action_type VARCHAR(50),
    p_action_details JSONB DEFAULT '{}'::jsonb,
    p_user_id BIGINT DEFAULT NULL,
    p_ip_address INET DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
    INSERT INTO audit_logs (
        transaction_id, result_id, action_type,
        action_details, user_id, ip_address
    ) VALUES (
        p_transaction_id, p_result_id, p_action_type,
        p_action_details, p_user_id, p_ip_address
    );
END;
$$ LANGUAGE plpgsql;
```

---

## 六、使用示例

### 6.1 检测单笔交易

```sql
-- 检测交易
SELECT * FROM detect_fraud(
    p_user_id := 12345,
    p_amount := 15000.00,
    p_merchant_id := 1001,
    p_device_id := 'device_abc123',
    p_ip_address := '192.168.1.100'::INET
);
```

### 6.2 创建规则

```sql
-- 创建大额交易规则
SELECT upsert_fraud_rule(
    p_rule_id := 'R001',
    p_rule_name := '大额交易检测',
    p_conditions := '{"amount": {"$gt": 10000}}'::jsonb,
    p_actions := '{"score": 80, "reason": "大额交易"}'::jsonb,
    p_priority := 1,
    p_rule_type := 'amount'
);
```

### 6.3 查询检测结果

```sql
-- 查询高风险交易
SELECT
    dr.result_id,
    dr.transaction_id,
    dr.risk_score,
    dr.final_decision,
    dr.decision_reason,
    t.amount,
    t.user_id
FROM detection_results dr
JOIN transactions t ON dr.transaction_id = t.transaction_id
WHERE dr.risk_score > 80
  AND dr.detection_time >= NOW() - INTERVAL '24 hours'
ORDER BY dr.risk_score DESC
LIMIT 100;
```

---

## 七、性能优化

### 7.1 函数优化技巧

1. **使用并行查询**: 特征提取使用并行查询
2. **缓存结果**: 用户特征使用物化视图
3. **批量操作**: 规则匹配使用批量查询
4. **索引优化**: 确保所有查询都使用索引

### 7.2 PostgreSQL 18特性应用

- **异步I/O**: 批量规则查询
- **并行查询**: 特征提取并行化
- **物化视图**: 实时特征聚合
- **JSONB索引**: 加速规则匹配

---

**文档版本**: v1.0
**最后更新**: 2025年1月
**状态**: ✅ 完成
