# 案例6：全文搜索系统 - 核心实现

## 元数据

- **创建日期**: 2025-12-04
- **技术栈**: PostgreSQL 18 + Python + FastAPI
- **性能**: ms级搜索响应

---

## 1. 搜索引擎模块

```python
"""
全文搜索引擎
"""

import psycopg2
from psycopg2.extras import RealDictCursor
from fastapi import FastAPI, Query
import time

app = FastAPI()

DB_CONFIG = {
    'dbname': 'search_db',
    'user': 'postgres',
    'host': 'localhost'
}

def get_connection():
    return psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)

@app.get("/api/search")
async def search(
    q: str = Query(..., description="搜索关键词"),
    category: str = Query(None, description="分类过滤"),
    limit: int = Query(20, le=100),
    offset: int = Query(0, ge=0)
):
    """
    全文搜索API

    支持:
    - 中文分词
    - 相关性排序
    - 高亮显示
    - 分类过滤
    """

    start_time = time.time()

    conn = get_connection()
    cursor = conn.cursor()

    try:
        # 构建查询
        if category:
            query = """
                SELECT
                    doc_id,
                    title,
                    ts_headline('zh_parser', content, query,
                        'MaxWords=50, MinWords=30, StartSel=<b>, StopSel=</b>') AS snippet,
                    ts_rank_cd(search_vector, query) AS rank
                FROM documents,
                     to_tsquery('zh_parser', %s) query
                WHERE search_vector @@ query
                  AND category = %s
                ORDER BY rank DESC, created_at DESC
                LIMIT %s OFFSET %s;
            """
            cursor.execute(query, (q, category, limit, offset))
        else:
            query = """
                SELECT
                    doc_id,
                    title,
                    ts_headline('zh_parser', content, query,
                        'MaxWords=50, MinWords=30, StartSel=<b>, StopSel=</b>') AS snippet,
                    ts_rank_cd(search_vector, query) AS rank
                FROM documents,
                     to_tsquery('zh_parser', %s) query
                WHERE search_vector @@ query
                ORDER BY rank DESC, created_at DESC
                LIMIT %s OFFSET %s;
            """
            cursor.execute(query, (q, limit, offset))

        results = cursor.fetchall()
        duration = (time.time() - start_time) * 1000

        # 记录搜索日志
        cursor.execute("""
            INSERT INTO search_logs (query_text, result_count, duration_ms)
            VALUES (%s, %s, %s);
        """, (q, len(results), duration))
        conn.commit()

        return {
            'success': True,
            'results': results,
            'count': len(results),
            'duration_ms': duration
        }

    finally:
        cursor.close()
        conn.close()

@app.get("/api/search/suggest")
async def search_suggest(q: str = Query(..., min_length=2)):
    """搜索建议"""

    conn = get_connection()
    cursor = conn.cursor()

    try:
        # 基于历史搜索的建议
        cursor.execute("""
            SELECT DISTINCT query_text, COUNT(*) as freq
            FROM search_logs
            WHERE query_text LIKE %s
            GROUP BY query_text
            ORDER BY freq DESC
            LIMIT 10;
        """, (f'{q}%',))

        suggestions = cursor.fetchall()

        return {
            'success': True,
            'suggestions': [s['query_text'] for s in suggestions]
        }

    finally:
        cursor.close()
        conn.close()

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8002)
```

---

## 2. 索引管理模块

```python
class SearchIndexManager:
    """搜索索引管理器"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def rebuild_search_index(self):
        """重建搜索索引"""

        # 1. 删除旧索引
        self.cursor.execute("DROP INDEX IF EXISTS idx_documents_search;")

        # 2. 重新创建（PostgreSQL 18并行构建）
        self.cursor.execute("""
            CREATE INDEX idx_documents_search
            ON documents
            USING GIN (search_vector);
        """)

        self.conn.commit()
        print("✅ 搜索索引重建完成")

    def get_index_stats(self):
        """获取索引统计"""

        self.cursor.execute("""
            SELECT
                pg_size_pretty(pg_relation_size('idx_documents_search')) AS index_size,
                pg_stat_get_numscans('idx_documents_search'::regclass) AS scan_count
        """)

        return self.cursor.fetchone()
```

---

**完成日期**: 2025-12-04
**搜索引擎**: PostgreSQL内置
**响应时间**: <100ms

**返回**: [案例6主页](./README.md)
