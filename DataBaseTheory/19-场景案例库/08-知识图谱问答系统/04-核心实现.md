# 案例8：知识图谱问答系统 - 核心实现

```python
"""
知识图谱问答系统
技术栈: PostgreSQL 18 + Apache AGE + LangChain
"""

import psycopg2
from psycopg2.extras import RealDictCursor
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
import re

class KnowledgeGraphQA:
    """知识图谱问答系统"""

    def __init__(self, conn_str, openai_api_key):
        self.conn = psycopg2.connect(conn_str, cursor_factory=RealDictCursor)
        self.cursor = self.conn.cursor()
        self.llm = OpenAI(api_key=openai_api_key, temperature=0)

        # 加载AGE扩展
        self.cursor.execute("LOAD 'age';")
        self.cursor.execute("SET search_path = ag_catalog, '$user', public;")

    def nl2cypher(self, question: str) -> str:
        """
        自然语言转Cypher查询
        """

        # NL2Cypher提示词
        prompt = PromptTemplate(
            input_variables=["question"],
            template="""
你是一个Cypher查询生成专家。将以下自然语言问题转换为Cypher查询。

图Schema:
- 节点类型: Document, Concept, Person, Product
- 关系类型: MENTIONS, RELATED_TO, IS_A, USED_IN

问题: {question}

只返回Cypher查询，不要解释:
"""
        )

        cypher_query = self.llm(prompt.format(question=question))
        cypher_query = cypher_query.strip()

        return cypher_query

    def execute_cypher(self, cypher_query: str) -> list:
        """
        执行Cypher查询
        """

        try:
            # 使用AGE执行Cypher
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    {cypher_query}
                $$) AS (result agtype);
            """)

            results = [row['result'] for row in self.cursor.fetchall()]
            return results

        except Exception as e:
            print(f"查询执行失败: {e}")
            return []

    def answer_question(self, question: str) -> dict:
        """
        回答问题（完整流程）
        """

        import time
        start_time = time.time()

        # 1. 问题分类
        question_type = self._classify_question(question)

        # 2. 生成Cypher
        if question_type == 'simple':
            cypher_query = self._template_match(question)
        else:
            cypher_query = self.nl2cypher(question)

        # 3. 执行查询
        results = self.execute_cypher(cypher_query)

        # 4. 生成答案
        answer = self._generate_answer(question, results)

        duration = (time.time() - start_time) * 1000

        return {
            'question': question,
            'cypher': cypher_query,
            'raw_results': results,
            'answer': answer,
            'duration_ms': duration
        }

    def _classify_question(self, question: str) -> str:
        """问题分类"""

        # 简单规则分类
        if any(kw in question for kw in ['什么是', 'what is']):
            return 'simple'
        elif any(kw in question for kw in ['有哪些', 'list', '所有']):
            return 'list'
        elif any(kw in question for kw in ['相关', 'related', '关联']):
            return 'relation'
        else:
            return 'complex'

    def _template_match(self, question: str) -> str:
        """模板匹配生成Cypher"""

        # 提取实体（简化版）
        entity = re.search(r'什么是(.+?)[\?？]', question)
        if entity:
            entity_name = entity.group(1).strip()
            return f"""
                MATCH (n:Concept {{name: '{entity_name}'}})
                RETURN n.name AS name, n.description AS description
            """

        return "MATCH (n) RETURN n LIMIT 10"

    def _generate_answer(self, question: str, results: list) -> str:
        """根据查询结果生成自然语言答案"""

        if not results:
            return "抱歉，我没有找到相关信息。"

        # 使用LLM生成答案
        prompt = PromptTemplate(
            input_variables=["question", "results"],
            template="""
基于以下数据回答问题。

问题: {question}

数据: {results}

简洁回答:
"""
        )

        answer = self.llm(prompt.format(question=question, results=str(results)))
        return answer.strip()

# ============================================================
# 知识抽取模块
# ============================================================

class KnowledgeExtractor:
    """从文本中抽取知识"""

    def __init__(self, conn_str):
        self.conn = psycopg2.connect(conn_str)
        self.cursor = self.conn.cursor()

    def extract_from_document(self, doc_id: int, content: str):
        """
        从文档中抽取实体和关系
        """

        # 1. 实体识别（简化版，实际应使用NER模型）
        entities = self._ner(content)

        # 2. 关系抽取
        relations = self._extract_relations(content, entities)

        # 3. 写入图数据库
        self._insert_to_graph(doc_id, entities, relations)

    def _ner(self, text: str) -> list:
        """实体识别（示例）"""
        # 实际应使用SpaCy或BERT等NER模型
        return [
            {'name': 'PostgreSQL', 'type': 'Concept'},
            {'name': 'MVCC', 'type': 'Concept'}
        ]

    def _extract_relations(self, text: str, entities: list) -> list:
        """关系抽取（示例）"""
        # 实际应使用关系抽取模型
        return [
            {'from': 'PostgreSQL', 'to': 'MVCC', 'type': 'USES'}
        ]

    def _insert_to_graph(self, doc_id: int, entities: list, relations: list):
        """插入图数据库"""

        # 插入实体
        for entity in entities:
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    MERGE (n:{entity['type']} {{name: '{entity['name']}'}})
                    RETURN n
                $$) AS (n agtype);
            """)

        # 插入关系
        for rel in relations:
            self.cursor.execute(f"""
                SELECT * FROM cypher('knowledge_graph', $$
                    MATCH (a {{name: '{rel['from']}'}}), (b {{name: '{rel['to']}'}}
                    MERGE (a)-[r:{rel['type']}]->(b)
                    RETURN r
                $$) AS (r agtype);
            """)

        self.conn.commit()

# ============================================================
# FastAPI接口
# ============================================================

from fastapi import FastAPI, Query as FastAPIQuery

app = FastAPI()

qa_system = KnowledgeGraphQA(
    conn_str="dbname=knowledge_db user=postgres",
    openai_api_key="your-api-key"
)

@app.get("/api/qa")
async def ask_question(q: str = FastAPIQuery(..., description="问题")):
    """问答接口"""
    result = qa_system.answer_question(q)
    return result

@app.get("/api/graph/subgraph")
async def get_subgraph(entity: str, radius: int = 2):
    """获取子图"""
    cursor = qa_system.cursor
    cursor.execute("""
        SELECT extract_subgraph(%s, %s);
    """, (entity, radius))
    subgraph = cursor.fetchone()[0]
    return {'entity': entity, 'subgraph': subgraph}

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8004)
```

---

**返回**: [案例8主页](./README.md)
