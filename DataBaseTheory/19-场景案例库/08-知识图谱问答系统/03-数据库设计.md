# 案例8：知识图谱问答系统 - 数据库设计

## Apache AGE图Schema

```sql
-- 1. 创建图
SELECT create_graph('knowledge_graph');

-- 2. 创建顶点标签
SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Document
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Concept
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Person
$$) as (v agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE VLABEL Product
$$) as (v agtype);

-- 3. 创建边标签
SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL MENTIONS
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL RELATED_TO
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL IS_A
$$) as (e agtype);

SELECT * FROM cypher('knowledge_graph', $$
    CREATE ELABEL USED_IN
$$) as (e agtype);
```

---

## 辅助表

```sql
-- 实体向量表（用于语义搜索）
CREATE TABLE entity_embeddings (
    entity_id VARCHAR(100) PRIMARY KEY,
    entity_type VARCHAR(50),
    entity_name TEXT,
    embedding vector(768),  -- BERT embedding
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_entity_embeddings_vector
ON entity_embeddings USING hnsw (embedding vector_l2_ops);

-- 查询日志
CREATE TABLE query_logs (
    log_id BIGSERIAL PRIMARY KEY,
    question TEXT,
    cypher_query TEXT,
    result_count INT,
    duration_ms FLOAT,
    success BOOLEAN,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_query_logs_created ON query_logs (created_at);
```

---

## 核心查询函数

```sql
-- 1. 单跳查询
CREATE OR REPLACE FUNCTION find_related_concepts(
    concept_name TEXT
) RETURNS TABLE (
    related_name TEXT,
    relation_type TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM cypher('knowledge_graph', $$
        MATCH (c:Concept {name: $concept_name})-[r]->(related:Concept)
        RETURN related.name AS related_name, type(r) AS relation_type
    $$, jsonb_build_object('concept_name', concept_name))
    AS (related_name TEXT, relation_type TEXT);
END;
$$ LANGUAGE plpgsql;

-- 2. 多跳查询（最短路径）
CREATE OR REPLACE FUNCTION find_shortest_path(
    start_concept TEXT,
    end_concept TEXT,
    max_depth INT DEFAULT 5
) RETURNS TEXT AS $$
DECLARE
    path_result TEXT;
BEGIN
    SELECT * INTO path_result FROM cypher('knowledge_graph', $$
        MATCH path = shortestPath((start:Concept {name: $start})-[*1..$max_depth]-(end:Concept {name: $end}))
        RETURN [n IN nodes(path) | n.name] AS path
    $$, jsonb_build_object('start', start_concept, 'end', end_concept, 'max_depth', max_depth))
    AS (path TEXT);

    RETURN path_result;
END;
$$ LANGUAGE plpgsql;

-- 3. 子图提取
CREATE OR REPLACE FUNCTION extract_subgraph(
    center_concept TEXT,
    radius INT DEFAULT 2
) RETURNS JSONB AS $$
DECLARE
    subgraph JSONB;
BEGIN
    SELECT jsonb_agg(row_to_json(t)) INTO subgraph
    FROM (
        SELECT * FROM cypher('knowledge_graph', $$
            MATCH (center:Concept {name: $center})-[r*1..$radius]-(node)
            RETURN DISTINCT node.name AS entity, labels(node) AS labels
        $$, jsonb_build_object('center', center_concept, 'radius', radius))
        AS (entity TEXT, labels TEXT[])
    ) t;

    RETURN subgraph;
END;
$$ LANGUAGE plpgsql;

-- 4. 聚合查询
CREATE OR REPLACE FUNCTION count_entity_relations(
    entity_name TEXT
) RETURNS TABLE (
    relation_type TEXT,
    count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM cypher('knowledge_graph', $$
        MATCH (:Concept {name: $entity})-[r]->()
        RETURN type(r) AS relation_type, count(*) AS count
        ORDER BY count DESC
    $$, jsonb_build_object('entity', entity_name))
    AS (relation_type TEXT, count BIGINT);
END;
$$ LANGUAGE plpgsql;
```

---

## 数据导入示例

```sql
-- 批量插入实体
DO $$
DECLARE
    concepts TEXT[] := ARRAY['PostgreSQL', 'MVCC', 'ACID', 'Transaction', 'Index'];
    c TEXT;
BEGIN
    FOREACH c IN ARRAY concepts LOOP
        PERFORM * FROM cypher('knowledge_graph', $$
            CREATE (n:Concept {name: $name, description: 'Database concept'})
        $$, jsonb_build_object('name', c)) AS (v agtype);
    END LOOP;
END $$;

-- 批量插入关系
SELECT * FROM cypher('knowledge_graph', $$
    MATCH (pg:Concept {name: 'PostgreSQL'}), (mvcc:Concept {name: 'MVCC'})
    CREATE (pg)-[:USES]->(mvcc)
$$) AS (e agtype);
```

---

**返回**: [案例8主页](./README.md)
