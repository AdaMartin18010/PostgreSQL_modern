# 案例4：多租户SaaS系统 - 核心实现

## 元数据

- **创建日期**: 2025-12-04
- **技术栈**: FastAPI + PostgreSQL 18 + RLS
- **代码量**: ~1,800行

---

## 1. 租户管理模块

```python
"""
多租户管理模块
"""

import psycopg2
from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from datetime import datetime, timedelta

app = FastAPI()
security = HTTPBearer()

# JWT配置
JWT_SECRET = "your-secret-key"
JWT_ALGORITHM = "HS256"

class TenantManager:
    """租户管理器"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def create_tenant(self, tenant_name, plan_type='free'):
        """
        创建新租户

        Args:
            tenant_name: 租户名称
            plan_type: 套餐类型 (free/pro/enterprise)
        """

        # 根据套餐设置配额
        quotas = {
            'free': {'storage_gb': 1, 'connections': 5},
            'pro': {'storage_gb': 10, 'connections': 20},
            'enterprise': {'storage_gb': 100, 'connections': 100}
        }

        quota = quotas.get(plan_type, quotas['free'])

        self.cursor.execute("""
            INSERT INTO tenants (tenant_name, plan_type, storage_quota_gb, connection_quota)
            VALUES (%s, %s, %s, %s)
            RETURNING tenant_id;
        """, (tenant_name, plan_type, quota['storage_gb'], quota['connections']))

        tenant_id = self.cursor.fetchone()[0]
        self.conn.commit()

        # 初始化租户数据
        self._initialize_tenant_data(tenant_id)

        return tenant_id

    def _initialize_tenant_data(self, tenant_id):
        """初始化租户数据"""

        # 设置租户上下文
        self.cursor.execute(f"SET app.current_tenant = {tenant_id};")

        # 创建默认管理员用户
        self.cursor.execute("""
            INSERT INTO users (tenant_id, username, email, password_hash)
            VALUES (%s, 'admin', 'admin@example.com', 'hashed_password');
        """, (tenant_id,))

        self.conn.commit()
        print(f"✅ 租户 {tenant_id} 初始化完成")
```

---

## 2. 租户上下文中间件

```python
from contextvars import ContextVar

# 当前租户ID上下文
current_tenant_id = ContextVar('current_tenant_id', default=None)

def get_current_tenant() -> int:
    """获取当前租户ID"""
    tenant_id = current_tenant_id.get()
    if tenant_id is None:
        raise HTTPException(status_code=401, detail="未设置租户上下文")
    return tenant_id

async def set_tenant_context(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    从JWT Token解析租户ID并设置上下文
    """

    try:
        token = credentials.credentials
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        tenant_id = payload.get('tenant_id')

        if not tenant_id:
            raise HTTPException(status_code=401, detail="Token中无租户信息")

        # 设置上下文
        current_tenant_id.set(tenant_id)

        return tenant_id

    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Token无效")

# 数据库连接 + 设置RLS上下文
def get_db_with_tenant():
    """获取带租户上下文的数据库连接"""

    tenant_id = get_current_tenant()

    conn = psycopg2.connect("dbname=saas_db user=postgres")
    cursor = conn.cursor()

    # 设置租户ID（RLS使用）
    cursor.execute(f"SET app.current_tenant = {tenant_id};")

    return conn
```

---

## 3. API实现

```python
@app.post("/api/documents")
async def create_document(
    document: dict,
    tenant_id: int = Depends(set_tenant_context),
    conn = Depends(get_db_with_tenant)
):
    """
    创建文档（自动应用RLS）
    """

    cursor = conn.cursor()

    try:
        cursor.execute("""
            INSERT INTO documents (tenant_id, user_id, title, content, size_bytes)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id;
        """, (tenant_id, document['user_id'], document['title'],
              document['content'], len(document['content'])))

        doc_id = cursor.fetchone()[0]
        conn.commit()

        return {"success": True, "document_id": doc_id}

    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))

    finally:
        cursor.close()
        conn.close()

@app.get("/api/documents")
async def list_documents(
    tenant_id: int = Depends(set_tenant_context),
    conn = Depends(get_db_with_tenant)
):
    """
    列出文档（RLS自动过滤租户数据）
    """

    cursor = conn.cursor()

    try:
        # RLS会自动过滤，只返回当前租户的数据
        cursor.execute("""
            SELECT id, title, size_bytes, created_at
            FROM documents
            ORDER BY created_at DESC
            LIMIT 100;
        """)

        results = cursor.fetchall()

        return {
            "success": True,
            "documents": [
                {"id": r[0], "title": r[1], "size_bytes": r[2], "created_at": r[3]}
                for r in results
            ]
        }

    finally:
        cursor.close()
        conn.close()
```

---

## 4. 配额检查模块

```python
class QuotaChecker:
    """配额检查器"""

    def __init__(self, conn, tenant_id):
        self.conn = conn
        self.cursor = conn.cursor()
        self.tenant_id = tenant_id

    def check_storage_quota(self) -> bool:
        """检查存储配额"""

        self.cursor.execute("""
            SELECT
                COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS used_gb,
                t.storage_quota_gb
            FROM tenants t
            LEFT JOIN documents d ON t.tenant_id = d.tenant_id
            WHERE t.tenant_id = %s
            GROUP BY t.storage_quota_gb;
        """, (self.tenant_id,))

        result = self.cursor.fetchone()
        if not result:
            return True

        used_gb, quota_gb = result
        return used_gb < quota_gb

    def get_quota_usage(self):
        """获取配额使用情况"""

        self.cursor.execute("""
            SELECT
                t.storage_quota_gb,
                COALESCE(SUM(d.size_bytes), 0) / 1024.0 / 1024.0 / 1024.0 AS used_gb,
                COUNT(DISTINCT d.id) AS document_count,
                COUNT(DISTINCT u.id) AS user_count
            FROM tenants t
            LEFT JOIN documents d ON t.tenant_id = d.tenant_id
            LEFT JOIN users u ON t.tenant_id = u.tenant_id
            WHERE t.tenant_id = %s
            GROUP BY t.storage_quota_gb;
        """, (self.tenant_id,))

        result = self.cursor.fetchone()

        return {
            'quota_gb': result[0],
            'used_gb': float(result[1]),
            'usage_percent': (float(result[1]) / result[0] * 100) if result[0] > 0 else 0,
            'document_count': result[2],
            'user_count': result[3]
        }
```

---

**完成日期**: 2025-12-04
**RLS策略**: tenant_id隔离
**配额**: 存储 + 连接 + API

**返回**: [案例4主页](./README.md)
