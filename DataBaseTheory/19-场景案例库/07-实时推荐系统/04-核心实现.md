# 案例7：实时推荐系统 - 核心实现

```python
"""
实时推荐系统
技术栈: PostgreSQL 18 + pgvector + FastAPI
"""

import psycopg2
from psycopg2.extras import RealDictCursor
import numpy as np
from fastapi import FastAPI, Query
from typing import List
import redis
import json
import time

app = FastAPI()

# 数据库配置
DB_CONFIG = {
    'dbname': 'recommendation_db',
    'user': 'postgres',
    'host': 'localhost'
}

# Redis配置
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

def get_db():
    return psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)

# ============================================================
# 推荐API
# ============================================================

@app.get("/api/recommend/{user_id}")
async def get_recommendations(
    user_id: int,
    limit: int = Query(50, le=100),
    use_cache: bool = True
):
    """
    获取用户推荐

    流程:
    1. 检查缓存
    2. 多路召回 (User CF + Item CF + Vector + Popular)
    3. 排序打分
    4. 返回Top-N
    """

    start_time = time.time()

    # 1. 检查缓存
    if use_cache:
        cache_key = f"recommend:{user_id}"
        cached = redis_client.get(cache_key)
        if cached:
            result = json.loads(cached)
            result['from_cache'] = True
            result['latency_ms'] = (time.time() - start_time) * 1000
            return result

    # 2. 数据库召回
    conn = get_db()
    cursor = conn.cursor()

    try:
        cursor.execute("""
            SELECT item_id, final_score
            FROM recommend_items(%s, %s);
        """, (user_id, limit))

        recommendations = cursor.fetchall()

        # 3. 补充商品信息
        item_ids = [r['item_id'] for r in recommendations]

        cursor.execute("""
            SELECT item_id, title, price, rating, sales_count
            FROM items
            WHERE item_id = ANY(%s);
        """, (item_ids,))

        items_info = {item['item_id']: item for item in cursor.fetchall()}

        # 4. 合并结果
        result = []
        for rec in recommendations:
            item = items_info.get(rec['item_id'])
            if item:
                result.append({
                    'item_id': rec['item_id'],
                    'title': item['title'],
                    'price': float(item['price']),
                    'rating': float(item['rating']),
                    'sales': item['sales_count'],
                    'score': float(rec['final_score'])
                })

        response = {
            'user_id': user_id,
            'recommendations': result,
            'count': len(result),
            'from_cache': False,
            'latency_ms': (time.time() - start_time) * 1000
        }

        # 5. 写入缓存（5分钟）
        if use_cache:
            redis_client.setex(
                f"recommend:{user_id}",
                300,
                json.dumps(response)
            )

        return response

    finally:
        cursor.close()
        conn.close()

# ============================================================
# 行为记录API
# ============================================================

@app.post("/api/behavior")
async def record_behavior(
    user_id: int,
    item_id: int,
    behavior_type: str  # view/click/cart/buy
):
    """
    记录用户行为
    异步写入，立即返回
    """

    conn = get_db()
    cursor = conn.cursor()

    try:
        cursor.execute("""
            INSERT INTO user_behavior (user_id, item_id, behavior_type)
            VALUES (%s, %s, %s);
        """, (user_id, item_id, behavior_type))

        conn.commit()

        # 清除用户推荐缓存
        redis_client.delete(f"recommend:{user_id}")

        # 异步更新用户画像（实际应该用消息队列）
        if behavior_type == 'buy':
            update_user_profile_async(user_id, item_id)

        return {'success': True}

    finally:
        cursor.close()
        conn.close()

# ============================================================
# 相似度计算（离线任务）
# ============================================================

class SimilarityCalculator:
    """相似度计算器"""

    def __init__(self, conn):
        self.conn = conn
        self.cursor = conn.cursor()

    def calculate_item_similarity(self, min_common_users=5):
        """
        计算商品相似度（Item-Based CF）
        基于共同购买用户的Jaccard相似度
        """

        print("开始计算商品相似度...")

        # 1. 获取热门商品（计算量大，只算Top商品）
        self.cursor.execute("""
            SELECT item_id FROM items
            WHERE sales_count > 10
            ORDER BY sales_count DESC
            LIMIT 10000;
        """)

        popular_items = [row[0] for row in self.cursor.fetchall()]

        # 2. 批量计算相似度
        batch_size = 100
        for i in range(0, len(popular_items), batch_size):
            batch = popular_items[i:i+batch_size]

            self.cursor.execute("""
                WITH item_users AS (
                    SELECT item_id, array_agg(DISTINCT user_id) AS users
                    FROM user_behavior
                    WHERE item_id = ANY(%s)
                      AND behavior_type IN ('buy', 'cart')
                      AND timestamp > CURRENT_TIMESTAMP - INTERVAL '90 days'
                    GROUP BY item_id
                ),
                pairs AS (
                    SELECT
                        a.item_id AS item_a,
                        b.item_id AS item_b,
                        a.users AS users_a,
                        b.users AS users_b
                    FROM item_users a
                    CROSS JOIN item_users b
                    WHERE a.item_id < b.item_id
                ),
                similarities AS (
                    SELECT
                        item_a,
                        item_b,
                        cardinality(users_a & users_b)::NUMERIC /
                        NULLIF(cardinality(users_a | users_b), 0) AS jaccard_sim
                    FROM pairs
                    WHERE cardinality(users_a & users_b) >= %s
                )
                INSERT INTO item_similarity (item_id, similar_item_id, similarity_score)
                SELECT item_a, item_b, jaccard_sim FROM similarities
                UNION ALL
                SELECT item_b, item_a, jaccard_sim FROM similarities
                ON CONFLICT (item_id, similar_item_id) DO UPDATE
                SET similarity_score = EXCLUDED.similarity_score;
            """, (batch, min_common_users))

            self.conn.commit()
            print(f"已处理 {i+len(batch)}/{len(popular_items)} 个商品")

        print("✅ 商品相似度计算完成")

    def calculate_user_similarity(self):
        """
        计算用户相似度（User-Based CF）
        基于余弦相似度
        """

        print("开始计算用户相似度...")

        # 活跃用户（最近30天有行为）
        self.cursor.execute("""
            WITH active_users AS (
                SELECT DISTINCT user_id
                FROM user_behavior
                WHERE timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
                LIMIT 50000
            ),
            user_vectors AS (
                SELECT
                    ub.user_id,
                    array_agg(ub.item_id) AS items
                FROM user_behavior ub
                JOIN active_users au ON ub.user_id = au.user_id
                WHERE ub.behavior_type IN ('buy', 'cart')
                  AND ub.timestamp > CURRENT_TIMESTAMP - INTERVAL '90 days'
                GROUP BY ub.user_id
            ),
            pairs AS (
                SELECT
                    a.user_id AS user_a,
                    b.user_id AS user_b,
                    a.items AS items_a,
                    b.items AS items_b
                FROM user_vectors a
                CROSS JOIN user_vectors b
                WHERE a.user_id < b.user_id
                  AND a.items && b.items  -- 有共同商品
            ),
            similarities AS (
                SELECT
                    user_a,
                    user_b,
                    cardinality(items_a & items_b)::NUMERIC /
                    SQRT(cardinality(items_a) * cardinality(items_b)) AS cosine_sim
                FROM pairs
                WHERE cardinality(items_a & items_b) >= 3
            )
            INSERT INTO user_similarity (user_id, similar_user_id, similarity_score)
            SELECT user_a, user_b, cosine_sim FROM similarities WHERE cosine_sim > 0.1
            UNION ALL
            SELECT user_b, user_a, cosine_sim FROM similarities WHERE cosine_sim > 0.1
            ON CONFLICT (user_id, similar_user_id) DO UPDATE
            SET similarity_score = EXCLUDED.similarity_score;
        """)

        self.conn.commit()
        print("✅ 用户相似度计算完成")

# ============================================================
# 特征向量更新（离线任务）
# ============================================================

def update_item_embeddings():
    """
    更新商品向量
    使用商品属性和用户行为计算embedding
    """

    conn = get_db()
    cursor = conn.cursor()

    # 简化版：基于商品属性生成向量
    cursor.execute("""
        SELECT item_id, category_id, brand_id, price, sales_count
        FROM items;
    """)

    items = cursor.fetchall()

    for item in items:
        # 实际应该用复杂的embedding模型
        # 这里简化为基于属性的向量
        embedding = np.random.rand(128).tolist()  # 占位

        cursor.execute("""
            UPDATE items
            SET embedding = %s::vector
            WHERE item_id = %s;
        """, (embedding, item['item_id']))

    conn.commit()
    cursor.close()
    conn.close()

    print("✅ 商品向量更新完成")

def update_user_profile_async(user_id, item_id):
    """异步更新用户画像（简化版）"""
    # 实际应该用消息队列
    pass

# ============================================================
# 性能监控
# ============================================================

@app.get("/api/stats")
async def get_stats():
    """系统统计"""

    conn = get_db()
    cursor = conn.cursor()

    cursor.execute("""
        SELECT
            (SELECT COUNT(*) FROM users) AS user_count,
            (SELECT COUNT(*) FROM items) AS item_count,
            (SELECT COUNT(*) FROM user_behavior
             WHERE timestamp > CURRENT_TIMESTAMP - INTERVAL '1 day') AS behavior_24h,
            (SELECT COUNT(*) FROM item_similarity) AS item_sim_pairs,
            (SELECT COUNT(*) FROM user_similarity) AS user_sim_pairs;
    """)

    stats = cursor.fetchone()

    cursor.close()
    conn.close()

    return stats

if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8003)
```

---

**返回**: [案例7主页](./README.md)
