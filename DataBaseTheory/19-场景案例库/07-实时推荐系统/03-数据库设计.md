# 案例7：实时推荐系统 - 数据库设计

## Schema设计

```sql
-- 1. 用户表
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    age_group INT,
    gender VARCHAR(10),
    city_level INT,
    register_date DATE,
    active_days INT DEFAULT 0,
    purchase_count INT DEFAULT 0,
    avg_price NUMERIC(10,2),
    preference_vector vector(128),  -- pgvector
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_vector ON users USING hnsw (preference_vector vector_l2_ops);

-- 2. 商品表
CREATE TABLE items (
    item_id BIGSERIAL PRIMARY KEY,
    title VARCHAR(500),
    category_id INT,
    brand_id INT,
    price NUMERIC(10,2),
    sales_count INT DEFAULT 0,
    rating NUMERIC(3,2),
    ctr_7d NUMERIC(5,4),
    cvr_7d NUMERIC(5,4),
    embedding vector(128),  -- 商品向量
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_items_category ON items (category_id);
CREATE INDEX idx_items_embedding ON items USING hnsw (embedding vector_l2_ops);
CREATE INDEX idx_items_sales ON items (sales_count DESC);

-- 3. 用户行为表（分区）
CREATE TABLE user_behavior (
    behavior_id BIGSERIAL,
    user_id BIGINT NOT NULL,
    item_id BIGINT NOT NULL,
    behavior_type VARCHAR(20) NOT NULL,  -- view/click/cart/buy
    timestamp TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (behavior_id, timestamp)
) PARTITION BY RANGE (timestamp);

-- 创建分区（最近30天）
DO $$
DECLARE
    partition_date DATE;
BEGIN
    FOR i IN 0..29 LOOP
        partition_date := CURRENT_DATE - i;
        EXECUTE format('
            CREATE TABLE IF NOT EXISTS user_behavior_%s
            PARTITION OF user_behavior
            FOR VALUES FROM (%L) TO (%L);
        ', to_char(partition_date, 'YYYYMMDD'), partition_date, partition_date + 1);

        EXECUTE format('
            CREATE INDEX IF NOT EXISTS idx_behavior_%s_user
            ON user_behavior_%s (user_id, timestamp);
        ', to_char(partition_date, 'YYYYMMDD'), to_char(partition_date, 'YYYYMMDD'));

        EXECUTE format('
            CREATE INDEX IF NOT EXISTS idx_behavior_%s_item
            ON user_behavior_%s (item_id, timestamp);
        ', to_char(partition_date, 'YYYYMMDD'), to_char(partition_date, 'YYYYMMDD'));
    END LOOP;
END $$;

-- 4. 用户-商品交互统计（物化视图）
CREATE MATERIALIZED VIEW user_item_stats AS
SELECT
    user_id,
    item_id,
    COUNT(*) FILTER (WHERE behavior_type = 'view') AS view_count,
    COUNT(*) FILTER (WHERE behavior_type = 'click') AS click_count,
    COUNT(*) FILTER (WHERE behavior_type = 'cart') AS cart_count,
    COUNT(*) FILTER (WHERE behavior_type = 'buy') AS buy_count,
    MAX(timestamp) AS last_interaction
FROM user_behavior
WHERE timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
GROUP BY user_id, item_id;

CREATE INDEX idx_user_item_stats_user ON user_item_stats (user_id);
CREATE INDEX idx_user_item_stats_item ON user_item_stats (item_id);

-- 定时刷新（每小时）
CREATE OR REPLACE FUNCTION refresh_user_item_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_item_stats;
END;
$$ LANGUAGE plpgsql;

-- 5. 商品相似度表
CREATE TABLE item_similarity (
    item_id BIGINT NOT NULL,
    similar_item_id BIGINT NOT NULL,
    similarity_score NUMERIC(5,4),
    PRIMARY KEY (item_id, similar_item_id)
);

CREATE INDEX idx_item_similarity_score ON item_similarity (item_id, similarity_score DESC);

-- 6. 用户相似度表
CREATE TABLE user_similarity (
    user_id BIGINT NOT NULL,
    similar_user_id BIGINT NOT NULL,
    similarity_score NUMERIC(5,4),
    PRIMARY KEY (user_id, similar_user_id)
);

CREATE INDEX idx_user_similarity_score ON user_similarity (user_id, similarity_score DESC);

-- 7. 推荐结果缓存表
CREATE TABLE recommendation_cache (
    user_id BIGINT PRIMARY KEY,
    recommended_items BIGINT[],
    scores NUMERIC[],
    generated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMPTZ
);

CREATE INDEX idx_recommendation_expires ON recommendation_cache (expires_at);
```

---

## 核心函数

```sql
-- 1. 协同过滤推荐（User-Based）
CREATE OR REPLACE FUNCTION recommend_user_cf(
    p_user_id BIGINT,
    p_limit INT DEFAULT 200
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH similar_users AS (
        SELECT similar_user_id, similarity_score
        FROM user_similarity
        WHERE user_id = p_user_id
        ORDER BY similarity_score DESC
        LIMIT 50
    ),
    similar_user_items AS (
        SELECT
            ub.item_id,
            SUM(su.similarity_score) AS weighted_score
        FROM similar_users su
        JOIN user_behavior ub ON su.similar_user_id = ub.user_id
        WHERE ub.behavior_type IN ('buy', 'cart')
          AND ub.timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
          AND ub.item_id NOT IN (
              SELECT item_id FROM user_behavior
              WHERE user_id = p_user_id AND behavior_type = 'buy'
          )
        GROUP BY ub.item_id
    )
    SELECT sui.item_id, sui.weighted_score
    FROM similar_user_items sui
    ORDER BY weighted_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 2. 协同过滤推荐（Item-Based）
CREATE OR REPLACE FUNCTION recommend_item_cf(
    p_user_id BIGINT,
    p_limit INT DEFAULT 200
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH user_history AS (
        SELECT DISTINCT item_id
        FROM user_behavior
        WHERE user_id = p_user_id
          AND behavior_type IN ('buy', 'cart', 'click')
          AND timestamp > CURRENT_TIMESTAMP - INTERVAL '30 days'
        LIMIT 20
    ),
    similar_items AS (
        SELECT
            isim.similar_item_id AS item_id,
            AVG(isim.similarity_score) AS avg_score
        FROM user_history uh
        JOIN item_similarity isim ON uh.item_id = isim.item_id
        WHERE isim.similar_item_id NOT IN (
            SELECT item_id FROM user_behavior
            WHERE user_id = p_user_id AND behavior_type = 'buy'
        )
        GROUP BY isim.similar_item_id
    )
    SELECT si.item_id, si.avg_score
    FROM similar_items si
    ORDER BY avg_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 3. 向量召回（pgvector）
CREATE OR REPLACE FUNCTION recommend_vector(
    p_user_id BIGINT,
    p_limit INT DEFAULT 200
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
DECLARE
    user_vec vector(128);
BEGIN
    -- 获取用户偏好向量
    SELECT preference_vector INTO user_vec
    FROM users WHERE user_id = p_user_id;

    IF user_vec IS NULL THEN
        RETURN;
    END IF;

    RETURN QUERY
    SELECT
        i.item_id,
        1 - (i.embedding <-> user_vec) AS similarity
    FROM items i
    WHERE i.item_id NOT IN (
        SELECT item_id FROM user_behavior
        WHERE user_id = p_user_id AND behavior_type = 'buy'
    )
    ORDER BY i.embedding <-> user_vec
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 4. 热门推荐
CREATE OR REPLACE FUNCTION recommend_popular(
    p_category_id INT DEFAULT NULL,
    p_limit INT DEFAULT 100
) RETURNS TABLE (
    item_id BIGINT,
    score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        i.item_id,
        (i.sales_count::NUMERIC / 1000.0 + i.ctr_7d * 10) AS popularity_score
    FROM items i
    WHERE (p_category_id IS NULL OR i.category_id = p_category_id)
      AND i.sales_count > 10
    ORDER BY popularity_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- 5. 综合推荐（多路召回）
CREATE OR REPLACE FUNCTION recommend_items(
    p_user_id BIGINT,
    p_limit INT DEFAULT 50
) RETURNS TABLE (
    item_id BIGINT,
    final_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    WITH all_candidates AS (
        -- 路径1: User-Based CF
        SELECT item_id, score * 0.3 AS weighted_score, 'user_cf' AS source
        FROM recommend_user_cf(p_user_id, 200)

        UNION ALL

        -- 路径2: Item-Based CF
        SELECT item_id, score * 0.3 AS weighted_score, 'item_cf' AS source
        FROM recommend_item_cf(p_user_id, 200)

        UNION ALL

        -- 路径3: 向量召回
        SELECT item_id, score * 0.25 AS weighted_score, 'vector' AS source
        FROM recommend_vector(p_user_id, 200)

        UNION ALL

        -- 路径4: 热门推荐
        SELECT item_id, score * 0.15 AS weighted_score, 'popular' AS source
        FROM recommend_popular(NULL, 100)
    ),
    merged AS (
        SELECT
            item_id,
            SUM(weighted_score) AS total_score
        FROM all_candidates
        GROUP BY item_id
    )
    SELECT
        m.item_id,
        m.total_score
    FROM merged m
    JOIN items i ON m.item_id = i.item_id
    WHERE i.sales_count > 0  -- 过滤无效商品
    ORDER BY total_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;
```

---

**返回**: [案例7主页](./README.md)
