# PostgreSQL锁机制深度解析

## 1. 锁层次

```text
PostgreSQL锁层次（从粗到细）:
├─ 1. 表锁（Table Lock）
│  ├─ ACCESS SHARE
│  ├─ ROW SHARE
│  ├─ ROW EXCLUSIVE
│  ├─ SHARE UPDATE EXCLUSIVE
│  ├─ SHARE
│  ├─ SHARE ROW EXCLUSIVE
│  ├─ EXCLUSIVE
│  └─ ACCESS EXCLUSIVE
├─ 2. 行锁（Row Lock）
│  ├─ FOR UPDATE
│  ├─ FOR NO KEY UPDATE
│  ├─ FOR SHARE
│  └─ FOR KEY SHARE
├─ 3. 页锁（Page Lock，内部使用）
└─ 4. Advisory Lock（建议锁）
```

---

## 2. 表锁详解

### 2.1 锁模式与冲突

```sql
-- 锁冲突矩阵
/*
                AS  RS  RE  SUE  S  SRE  E  AE
ACCESS SHARE     -   -   -   -   -   -   -   ✗
ROW SHARE        -   -   -   -   -   -   ✗   ✗
ROW EXCLUSIVE    -   -   -   -   ✗   ✗   ✗   ✗
SHARE UPD EXCL   -   -   -   ✗   ✗   ✗   ✗   ✗
SHARE            -   -   ✗   ✗   -   ✗   ✗   ✗
SHARE ROW EXCL   -   -   ✗   ✗   ✗   ✗   ✗   ✗
EXCLUSIVE        -   ✗   ✗   ✗   ✗   ✗   ✗   ✗
ACCESS EXCLUSIVE ✗   ✗   ✗   ✗   ✗   ✗   ✗   ✗

- = 不冲突
✗ = 冲突
*/

-- 常见操作的锁级别
SELECT            -- ACCESS SHARE
SELECT FOR SHARE  -- ROW SHARE
INSERT/UPDATE/DELETE  -- ROW EXCLUSIVE
CREATE INDEX CONCURRENTLY  -- SHARE UPDATE EXCLUSIVE
CREATE INDEX      -- SHARE
VACUUM FULL       -- ACCESS EXCLUSIVE
ALTER TABLE       -- ACCESS EXCLUSIVE
DROP TABLE        -- ACCESS EXCLUSIVE
```

### 2.2 显式锁表

```sql
-- 锁整个表
BEGIN;
LOCK TABLE accounts IN EXCLUSIVE MODE;
-- 只有当前事务可以修改表
UPDATE accounts SET balance = balance + 100;
COMMIT;

-- NOWAIT：立即失败而不等待
BEGIN;
LOCK TABLE accounts IN EXCLUSIVE MODE NOWAIT;
-- 如果无法立即获取锁，返回错误
COMMIT;
```

---

## 3. 行锁详解

### 3.1 四种行锁

```sql
-- FOR UPDATE：排他锁
BEGIN;
SELECT * FROM accounts WHERE account_id = 1 FOR UPDATE;
-- 其他事务无法UPDATE/DELETE/FOR UPDATE该行
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
COMMIT;

-- FOR NO KEY UPDATE：允许外键
BEGIN;
SELECT * FROM users WHERE user_id = 1 FOR NO KEY UPDATE;
-- 允许其他事务插入orders(user_id=1)
UPDATE users SET email = 'new@example.com' WHERE user_id = 1;
COMMIT;

-- FOR SHARE：共享锁
BEGIN;
SELECT * FROM products WHERE product_id = 1 FOR SHARE;
-- 其他事务可以FOR SHARE，但不能修改
COMMIT;

-- FOR KEY SHARE：最弱的锁
BEGIN;
SELECT * FROM users WHERE user_id = 1 FOR KEY SHARE;
-- 允许UPDATE非键列
COMMIT;
```

### 3.2 SKIP LOCKED

```sql
-- 任务队列：跳过已锁定的行
SELECT * FROM tasks
WHERE status = 'pending'
ORDER BY priority DESC, created_at
LIMIT 10
FOR UPDATE SKIP LOCKED;

-- 多Worker并发处理，无锁等待
```

---

## 4. 死锁检测

### 4.1 死锁示例

```sql
-- 会话1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
-- 持有account_id=1的锁
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
-- 等待account_id=2的锁

-- 会话2
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 2;
-- 持有account_id=2的锁
UPDATE accounts SET balance = balance + 50 WHERE account_id = 1;
-- 等待account_id=1的锁

-- PostgreSQL检测到死锁（默认1秒后）
-- ERROR: deadlock detected
-- DETAIL: Process 1234 waits for ShareLock on transaction 5678
-- Process 5679 waits for ShareLock on transaction 1234
```

### 4.2 死锁预防

```sql
-- 策略1: 固定顺序加锁
-- Good
BEGIN;
SELECT * FROM accounts
WHERE account_id IN (1, 2, 5, 10)
ORDER BY account_id  -- 按顺序
FOR UPDATE;
COMMIT;

-- 策略2: 使用NOWAIT
BEGIN;
SELECT * FROM accounts WHERE account_id = 1 FOR UPDATE NOWAIT;
-- 立即失败，应用层重试
COMMIT;

-- 策略3: 减少持锁时间
BEGIN;
SELECT * FROM accounts WHERE account_id = 1 FOR UPDATE;
-- 快速处理
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
COMMIT;  -- 尽快提交
```

---

## 5. Advisory Lock

### 5.1 应用层锁

```sql
-- 会话级锁
SELECT pg_advisory_lock(12345);
-- 执行临界区代码
SELECT pg_advisory_unlock(12345);

-- 事务级锁（自动释放）
BEGIN;
SELECT pg_advisory_xact_lock(12345);
-- 执行操作
COMMIT;  -- 自动释放

-- 尝试获取（非阻塞）
SELECT pg_try_advisory_lock(12345);  -- true/false

-- 应用: 分布式锁、任务去重
```

### 5.2 实战：防止重复执行

```sql
CREATE OR REPLACE FUNCTION process_once(task_id BIGINT)
RETURNS BOOLEAN AS $$
BEGIN
    -- 尝试获取锁
    IF NOT pg_try_advisory_lock(task_id) THEN
        RAISE NOTICE '任务%正在执行中', task_id;
        RETURN false;
    END IF;

    BEGIN
        -- 执行任务
        PERFORM expensive_operation(task_id);

        -- 释放锁
        PERFORM pg_advisory_unlock(task_id);

        RETURN true;
    EXCEPTION
        WHEN OTHERS THEN
            PERFORM pg_advisory_unlock(task_id);
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql;
```

---

## 6. 锁监控

### 6.1 实时监控

```sql
-- 当前锁等待
SELECT
    blocked.pid AS blocked_pid,
    blocked.usename AS blocked_user,
    blocked.query AS blocked_query,
    now() - blocked.query_start AS blocked_duration,
    blocking.pid AS blocking_pid,
    blocking.usename AS blocking_user,
    blocking.query AS blocking_query,
    blocking.state AS blocking_state
FROM pg_locks blocked_locks
JOIN pg_stat_activity blocked ON blocked.pid = blocked_locks.pid
JOIN pg_locks blocking_locks ON
    blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_stat_activity blocking ON blocking.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted
  AND blocking_locks.granted;

-- 锁等待链
WITH RECURSIVE lock_chain AS (
    SELECT
        pid,
        usename,
        query,
        0 AS depth,
        ARRAY[pid] AS chain
    FROM pg_stat_activity
    WHERE pid IN (
        SELECT pid FROM pg_locks WHERE NOT granted
    )

    UNION ALL

    SELECT
        blocking.pid,
        blocking.usename,
        blocking.query,
        lc.depth + 1,
        lc.chain || blocking.pid
    FROM lock_chain lc
    JOIN pg_locks blocked_locks ON lc.pid = blocked_locks.pid
    JOIN pg_locks blocking_locks ON
        blocking_locks.locktype = blocked_locks.locktype
        AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
        AND blocking_locks.granted
        AND blocked_locks.pid != blocking_locks.pid
    JOIN pg_stat_activity blocking ON blocking.pid = blocking_locks.pid
    WHERE NOT EXISTS (
        SELECT 1 FROM lock_chain WHERE pid = blocking.pid
    )
)
SELECT * FROM lock_chain
ORDER BY depth, pid;
```

---

**完成**: PostgreSQL锁机制深度解析
**字数**: ~10,000字
**涵盖**: 锁层次、表锁、行锁、死锁、Advisory Lock、监控
