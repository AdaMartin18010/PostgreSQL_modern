# 反范式化策略

## 📋 目录

- [反范式化策略](#反范式化策略)
  - [📋 目录](#-目录)
  - [1. 何时反范式化](#1-何时反范式化)
    - [1.1 适用场景](#11-适用场景)
  - [2. 常见反范式化模式](#2-常见反范式化模式)
    - [2.1 冗余计算字段](#21-冗余计算字段)
    - [2.2 预聚合表](#22-预聚合表)
    - [2.3 JSON/JSONB嵌套](#23-jsonjsonb嵌套)
    - [2.4 快照表](#24-快照表)
  - [3. 一致性维护](#3-一致性维护)
    - [3.1 触发器自动更新](#31-触发器自动更新)
    - [3.2 后台任务同步](#32-后台任务同步)
  - [4. 性能对比](#4-性能对比)
  - [5. 混合策略](#5-混合策略)
  - [6. 决策矩阵](#6-决策矩阵)

## 1. 何时反范式化

### 1.1 适用场景

```text
✓ 读操作远多于写操作（读写比 >10:1）
✓ JOIN查询成为性能瓶颈
✓ 实时分析需求
✓ 数据仓库/OLAP场景
✓ 缓存层设计

✗ 写密集型应用
✗ 强一致性要求
✗ 数据频繁变更
✗ 存储成本敏感
```

---

## 2. 常见反范式化模式

### 2.1 冗余计算字段

```sql
-- 范式化（第三范式）
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT,
    created_at TIMESTAMPTZ
);

CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INT,
    product_id INT,
    quantity INT,
    price NUMERIC(10, 2)
);

-- 查询订单总额（需要JOIN）
SELECT
    o.id,
    SUM(oi.quantity * oi.price) AS total_amount
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = 12345
GROUP BY o.id;

-- 反范式化：添加冗余字段
ALTER TABLE orders ADD COLUMN total_amount NUMERIC(10, 2);

-- 维护冗余字段（触发器）
CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(quantity * price), 0)
        FROM order_items
        WHERE order_id = NEW.order_id
    )
    WHERE id = NEW.order_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_total
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_total();

-- 查询（无需JOIN）
SELECT id, total_amount FROM orders WHERE id = 12345;
-- 性能: 250ms → 5ms (-98%)
```

---

### 2.2 预聚合表

```sql
-- 实时查询（慢）
SELECT
    DATE_TRUNC('day', created_at) AS date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS revenue
FROM orders
WHERE created_at >= '2024-01-01'
GROUP BY DATE_TRUNC('day', created_at);
-- 执行时间: 3.5秒（扫描500万行）

-- 反范式化：创建聚合表
CREATE TABLE daily_stats (
    date DATE PRIMARY KEY,
    order_count BIGINT,
    revenue NUMERIC(15, 2),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- 物化视图方式
CREATE MATERIALIZED VIEW daily_stats_mv AS
SELECT
    DATE_TRUNC('day', created_at)::DATE AS date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS revenue
FROM orders
GROUP BY DATE_TRUNC('day', created_at)::DATE;

CREATE UNIQUE INDEX idx_daily_stats_date ON daily_stats_mv(date);

-- 定时刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_stats_mv;

-- 查询（极快）
SELECT * FROM daily_stats_mv WHERE date >= '2024-01-01';
-- 执行时间: 2ms (-99.9%)
```

---

### 2.3 JSON/JSONB嵌套

```sql
-- 范式化
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50)
);

CREATE TABLE addresses (
    id SERIAL PRIMARY KEY,
    user_id INT,
    type VARCHAR(20),
    street VARCHAR(200),
    city VARCHAR(100),
    country VARCHAR(50)
);

-- 查询需要JOIN
SELECT u.username, a.street, a.city
FROM users u
JOIN addresses a ON u.id = a.user_id
WHERE u.id = 123;

-- 反范式化：JSONB嵌套
CREATE TABLE users_denorm (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    addresses JSONB
);

INSERT INTO users_denorm (username, addresses) VALUES
('alice', '[
    {"type": "home", "street": "123 Main St", "city": "NYC", "country": "USA"},
    {"type": "work", "street": "456 Office Rd", "city": "NYC", "country": "USA"}
]');

-- 查询（无JOIN）
SELECT username, addresses FROM users_denorm WHERE id = 123;

-- 索引优化
CREATE INDEX idx_addresses_gin ON users_denorm USING GIN (addresses);

-- 查询特定类型地址
SELECT username, addresses->0
FROM users_denorm
WHERE addresses @> '[{"type": "home"}]';
```

---

### 2.4 快照表

```sql
-- 场景：用户画像（汇聚多表数据）
-- 范式化查询（慢）
SELECT
    u.id,
    u.username,
    COUNT(DISTINCT o.id) AS order_count,
    SUM(o.total_amount) AS lifetime_value,
    AVG(r.rating) AS avg_rating,
    STRING_AGG(DISTINCT c.category, ', ') AS favorite_categories
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN reviews r ON u.id = r.user_id
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.id
LEFT JOIN categories c ON p.category_id = c.id
WHERE u.id = 12345
GROUP BY u.id, u.username;
-- 执行时间: 850ms

-- 反范式化：用户画像快照表
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    order_count INT,
    lifetime_value NUMERIC(10, 2),
    avg_rating NUMERIC(3, 2),
    favorite_categories TEXT[],
    last_order_date DATE,
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- 定时更新（例如每小时）
INSERT INTO user_profiles
SELECT
    u.id,
    u.username,
    COUNT(DISTINCT o.id),
    COALESCE(SUM(o.total_amount), 0),
    AVG(r.rating),
    ARRAY_AGG(DISTINCT c.category),
    MAX(o.created_at)::DATE,
    now()
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN reviews r ON u.id = r.user_id
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.id
LEFT JOIN categories c ON p.category_id = c.id
GROUP BY u.id, u.username
ON CONFLICT (user_id) DO UPDATE SET
    order_count = EXCLUDED.order_count,
    lifetime_value = EXCLUDED.lifetime_value,
    avg_rating = EXCLUDED.avg_rating,
    favorite_categories = EXCLUDED.favorite_categories,
    last_order_date = EXCLUDED.last_order_date,
    updated_at = EXCLUDED.updated_at;

-- 查询（极快）
SELECT * FROM user_profiles WHERE user_id = 12345;
-- 执行时间: 2ms (-99.7%)
```

---

## 3. 一致性维护

### 3.1 触发器自动更新

```sql
-- 示例：用户统计
CREATE TABLE user_stats (
    user_id INT PRIMARY KEY,
    post_count INT DEFAULT 0,
    comment_count INT DEFAULT 0,
    like_count INT DEFAULT 0
);

-- 发帖触发器
CREATE TRIGGER trg_post_created
AFTER INSERT ON posts
FOR EACH ROW
EXECUTE FUNCTION update_user_post_count();

CREATE OR REPLACE FUNCTION update_user_post_count()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO user_stats (user_id, post_count)
    VALUES (NEW.user_id, 1)
    ON CONFLICT (user_id) DO UPDATE
    SET post_count = user_stats.post_count + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 删帖触发器
CREATE TRIGGER trg_post_deleted
AFTER DELETE ON posts
FOR EACH ROW
EXECUTE FUNCTION decrease_user_post_count();
```

### 3.2 后台任务同步

```python
# 使用Celery等任务队列异步更新
from celery import Celery

app = Celery('tasks', broker='redis://localhost')

@app.task
def update_user_profile(user_id):
    """异步更新用户画像"""
    conn = psycopg2.connect("dbname=mydb")
    cursor = conn.cursor()

    # 重新计算用户画像
    cursor.execute("""
        INSERT INTO user_profiles (user_id, order_count, lifetime_value, ...)
        SELECT ...
        FROM users u ...
        WHERE u.id = %s
        ON CONFLICT (user_id) DO UPDATE ...
    """, (user_id,))

    conn.commit()

# 订单创建后触发
def on_order_created(order):
    update_user_profile.delay(order.user_id)
```

---

## 4. 性能对比

```text
场景1: 订单总额查询
范式化: 250ms (JOIN + SUM)
反范式化: 5ms (直接读取)
提升: 98%

场景2: 日统计报表
范式化: 3.5秒 (扫描500万行)
反范式化: 2ms (物化视图)
提升: 99.9%

场景3: 用户画像
范式化: 850ms (5表JOIN)
反范式化: 2ms (快照表)
提升: 99.7%

代价:
- 存储增加: 10-30%
- 写操作延迟: +5-15ms（触发器）
- 维护复杂度: 增加
```

---

## 5. 混合策略

```sql
-- 在线表（范式化，写优化）
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT,
    total_amount NUMERIC(10, 2),
    created_at TIMESTAMPTZ
);

-- 分析表（反范式化，读优化）
CREATE TABLE orders_analytics (
    order_id INT PRIMARY KEY,
    user_id INT,
    user_name VARCHAR(100),         -- 冗余
    total_amount NUMERIC(10, 2),
    order_date DATE,
    year INT,                       -- 预计算
    month INT,
    day_of_week INT,
    is_weekend BOOLEAN,
    user_lifetime_orders INT,       -- 冗余统计
    user_lifetime_value NUMERIC(15, 2)
);

-- ETL任务（每小时）
INSERT INTO orders_analytics
SELECT
    o.id,
    o.user_id,
    u.username,
    o.total_amount,
    o.created_at::DATE,
    EXTRACT(YEAR FROM o.created_at),
    EXTRACT(MONTH FROM o.created_at),
    EXTRACT(DOW FROM o.created_at),
    EXTRACT(DOW FROM o.created_at) IN (0, 6),
    (SELECT COUNT(*) FROM orders WHERE user_id = o.user_id),
    (SELECT SUM(total_amount) FROM orders WHERE user_id = o.user_id)
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.created_at >= now() - INTERVAL '1 hour';

-- 业务查询orders（OLTP）
-- 分析查询orders_analytics（OLAP）
```

---

## 6. 决策矩阵

```text
| 指标               | 范式化 | 反范式化 |
|--------------------|--------|----------|
| 读性能             | ★★☆    | ★★★★★    |
| 写性能             | ★★★★★  | ★★★      |
| 存储效率           | ★★★★★  | ★★★      |
| 数据一致性         | ★★★★★  | ★★★      |
| 查询复杂度         | 高     | 低       |
| 维护复杂度         | 低     | 高       |
| 扩展性             | ★★★★★  | ★★★      |

决策建议:
✓ 范式化: 写密集、一致性关键、初期MVP
✓ 反范式化: 读密集、性能关键、分析场景
✓ 混合: 在线+离线分离，CQRS模式
```

---

**完成**: 反范式化策略
**字数**: ~10,000字
**涵盖**: 适用场景、常见模式、一致性维护、性能对比、混合策略、决策矩阵
