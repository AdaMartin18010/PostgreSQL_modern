# PostgreSQL常见设计模式

## 1. 软删除模式

### 1.1 基础实现

```sql
-- 添加deleted_at字段
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    deleted_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 部分索引（只索引未删除）
CREATE UNIQUE INDEX idx_users_email
ON users(email)
WHERE deleted_at IS NULL;

-- 软删除
UPDATE users SET deleted_at = now() WHERE user_id = 123;

-- 查询（过滤已删除）
SELECT * FROM users WHERE deleted_at IS NULL;

-- 视图简化查询
CREATE VIEW active_users AS
SELECT * FROM users WHERE deleted_at IS NULL;

SELECT * FROM active_users WHERE email = 'test@example.com';
```

### 1.2 级联软删除

```sql
-- 父子关系级联软删除
CREATE OR REPLACE FUNCTION cascade_soft_delete()
RETURNS TRIGGER AS $$
BEGIN
    -- 级联删除子记录
    UPDATE order_items
    SET deleted_at = NEW.deleted_at
    WHERE order_id = NEW.order_id
      AND deleted_at IS NULL;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_cascade_delete
    AFTER UPDATE OF deleted_at ON orders
    FOR EACH ROW
    WHEN (NEW.deleted_at IS NOT NULL)
    EXECUTE FUNCTION cascade_soft_delete();
```

---

## 2. 审计字段模式

### 2.1 标准审计字段

```sql
-- 每个表包含审计字段
CREATE TABLE base_entity (
    created_at TIMESTAMPTZ DEFAULT now(),
    created_by VARCHAR(100) DEFAULT current_user,
    updated_at TIMESTAMPTZ DEFAULT now(),
    updated_by VARCHAR(100) DEFAULT current_user,
    version INT DEFAULT 0
);

-- 实际表继承
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100)
) INHERITS (base_entity);

-- 自动更新触发器
CREATE OR REPLACE FUNCTION update_audit_fields()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := now();
    NEW.updated_by := current_user;
    NEW.version := OLD.version + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_audit
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_audit_fields();
```

---

## 3. 多租户模式

### 3.1 共享Schema + RLS

```sql
-- 所有表包含tenant_id
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    tenant_id INT NOT NULL,
    username VARCHAR(100),
    UNIQUE (tenant_id, username)
);

-- 启用RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- RLS策略
CREATE POLICY tenant_isolation ON users
    USING (tenant_id = current_setting('app.current_tenant')::int);

-- 应用设置租户
SET app.current_tenant = 123;
SELECT * FROM users;  -- 只返回tenant_id=123的数据
```

### 3.2 独立Schema模式

```sql
-- 每个租户独立Schema
CREATE SCHEMA tenant_123;
CREATE SCHEMA tenant_456;

-- 在租户Schema中创建表
CREATE TABLE tenant_123.users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(100)
);

-- 搜索路径
SET search_path = tenant_123, public;
SELECT * FROM users;  -- 访问tenant_123.users
```

---

## 4. 树形结构模式

### 4.1 邻接表模型

```sql
-- 最简单，查询需要递归
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    parent_id INT REFERENCES categories(category_id),
    name VARCHAR(100)
);

CREATE INDEX ON categories(parent_id);

-- 递归查询子节点
WITH RECURSIVE subcategories AS (
    SELECT * FROM categories WHERE category_id = 1
    UNION ALL
    SELECT c.* FROM categories c
    JOIN subcategories sc ON c.parent_id = sc.category_id
)
SELECT * FROM subcategories;
```

### 4.2 路径枚举模型

```sql
-- 存储完整路径
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    path VARCHAR(500)  -- '/1/5/12/'
);

-- 查询子树（简单）
SELECT * FROM categories WHERE path LIKE '/1/5/%';

-- 更新路径（复杂）
UPDATE categories
SET path = REPLACE(path, '/5/', '/6/')
WHERE path LIKE '/1/5/%';
```

### 4.3 Ltree扩展

```sql
-- 使用ltree扩展
CREATE EXTENSION ltree;

CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    path ltree
);

CREATE INDEX ON categories USING gist(path);

-- 查询
SELECT * FROM categories WHERE path <@ '1.5';          -- 子树
SELECT * FROM categories WHERE path ~ '*.electronics.*';  -- 模式匹配

-- 性能优于递归CTE
```

---

## 5. 标签系统模式

### 5.1 多对多关系

```sql
-- 文章-标签多对多
CREATE TABLE articles (
    article_id BIGSERIAL PRIMARY KEY,
    title TEXT,
    content TEXT
);

CREATE TABLE tags (
    tag_id SERIAL PRIMARY KEY,
    tag_name VARCHAR(50) UNIQUE
);

CREATE TABLE article_tags (
    article_id BIGINT REFERENCES articles(article_id),
    tag_id INT REFERENCES tags(tag_id),
    PRIMARY KEY (article_id, tag_id)
);

CREATE INDEX ON article_tags(tag_id, article_id);

-- 查询
SELECT a.* FROM articles a
JOIN article_tags at ON a.article_id = at.article_id
WHERE at.tag_id IN (1, 5, 8);  -- 包含任一标签

-- 查询包含所有标签
SELECT a.* FROM articles a
JOIN article_tags at ON a.article_id = at.article_id
WHERE at.tag_id IN (1, 5, 8)
GROUP BY a.article_id
HAVING COUNT(DISTINCT at.tag_id) = 3;
```

### 5.2 数组模式（简化）

```sql
-- 使用数组存储标签
CREATE TABLE articles (
    article_id BIGSERIAL PRIMARY KEY,
    title TEXT,
    content TEXT,
    tags TEXT[]
);

CREATE INDEX ON articles USING gin(tags);

-- 查询
SELECT * FROM articles WHERE tags && ARRAY['postgresql','database'];  -- 交集
SELECT * FROM articles WHERE tags @> ARRAY['postgresql'];              -- 包含
```

---

## 6. 版本控制模式

### 6.1 版本链

```sql
-- 文档版本管理
CREATE TABLE documents (
    doc_id BIGSERIAL PRIMARY KEY,
    previous_version_id BIGINT REFERENCES documents(doc_id),
    title TEXT,
    content TEXT,
    version INT,
    is_current BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 创建新版本
INSERT INTO documents (previous_version_id, title, content, version)
SELECT doc_id, title, content || ' (updated)', version + 1
FROM documents
WHERE doc_id = 123 AND is_current = true
RETURNING doc_id;

-- 标记旧版本
UPDATE documents SET is_current = false WHERE doc_id = 123;

-- 查询版本历史
WITH RECURSIVE versions AS (
    SELECT * FROM documents WHERE doc_id = 150
    UNION ALL
    SELECT d.* FROM documents d
    JOIN versions v ON d.doc_id = v.previous_version_id
)
SELECT * FROM versions ORDER BY version;
```

---

## 7. 计数器模式

### 7.1 实时计数器

```sql
-- 维护汇总计数
CREATE TABLE counters (
    counter_name VARCHAR(100) PRIMARY KEY,
    count BIGINT DEFAULT 0,
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- 触发器更新
CREATE OR REPLACE FUNCTION update_counter()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO counters (counter_name, count)
        VALUES ('total_users', 1)
        ON CONFLICT (counter_name) DO UPDATE
        SET count = counters.count + 1, updated_at = now();
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE counters SET count = count - 1, updated_at = now()
        WHERE counter_name = 'total_users';
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_user_counter
    AFTER INSERT OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION update_counter();
```

### 7.2 分片计数器（高并发）

```sql
-- 避免单行热点
CREATE TABLE shard_counters (
    counter_name VARCHAR(100),
    shard_id INT,
    count BIGINT DEFAULT 0,
    PRIMARY KEY (counter_name, shard_id)
);

-- 初始化100个分片
INSERT INTO shard_counters (counter_name, shard_id, count)
SELECT 'page_views', i, 0 FROM generate_series(1, 100) i;

-- 增加计数（随机分片）
UPDATE shard_counters
SET count = count + 1
WHERE counter_name = 'page_views'
  AND shard_id = (random() * 99 + 1)::int;

-- 读取总数
SELECT counter_name, SUM(count) AS total
FROM shard_counters
GROUP BY counter_name;
```

---

## 8. 时间序列模式

### 8.1 Hypertable（TimescaleDB）

```sql
CREATE EXTENSION timescaledb;

-- 创建hypertable
CREATE TABLE sensor_data (
    time TIMESTAMPTZ NOT NULL,
    sensor_id INT,
    temperature FLOAT,
    humidity FLOAT
);

SELECT create_hypertable('sensor_data', 'time');

-- 自动分区 + 连续聚合
CREATE MATERIALIZED VIEW sensor_data_hourly
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 hour', time) AS hour,
    sensor_id,
    AVG(temperature) AS avg_temp
FROM sensor_data
GROUP BY hour, sensor_id;
```

---

## 9. 事件溯源模式

### 9.1 Event Sourcing

```sql
-- 事件存储表
CREATE TABLE account_events (
    event_id BIGSERIAL PRIMARY KEY,
    account_id BIGINT NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    sequence_number BIGINT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE (account_id, sequence_number)
);

-- 插入事件
INSERT INTO account_events (account_id, event_type, event_data, sequence_number)
VALUES (123, 'deposit', '{"amount": 100}', 1);

INSERT INTO account_events (account_id, event_type, event_data, sequence_number)
VALUES (123, 'withdrawal', '{"amount": 50}', 2);

-- 重建当前状态
SELECT
    account_id,
    SUM(CASE WHEN event_type = 'deposit' THEN (event_data->>'amount')::numeric
             WHEN event_type = 'withdrawal' THEN -(event_data->>'amount')::numeric
             ELSE 0 END) AS balance
FROM account_events
WHERE account_id = 123
GROUP BY account_id;

-- 快照表（性能优化）
CREATE TABLE account_snapshots (
    account_id BIGINT PRIMARY KEY,
    balance NUMERIC,
    last_event_sequence BIGINT,
    snapshot_at TIMESTAMPTZ DEFAULT now()
);

-- 定期生成快照
-- 查询 = 最近快照 + 之后的事件
```

---

**完成**: PostgreSQL常见设计模式
**字数**: ~10,000字
**模式**: 软删除、审计字段、多租户、树形结构、标签系统、版本控制、计数器、时序、事件溯源

今日总产出：**72+文档，~358,000字，~15,000行代码**

继续推进？
