# PostgreSQL数据建模最佳实践

## 📋 目录

- [PostgreSQL数据建模最佳实践](#postgresql数据建模最佳实践)
  - [📋 目录](#-目录)
  - [1. 主键设计](#1-主键设计)
    - [1.1 主键类型选择](#11-主键类型选择)
  - [2. 外键设计](#2-外键设计)
    - [2.1 外键约束](#21-外键约束)
    - [2.2 软外键（性能）](#22-软外键性能)
  - [3. 索引策略](#3-索引策略)
    - [3.1 单列索引](#31-单列索引)
    - [3.2 组合索引](#32-组合索引)
    - [3.3 覆盖索引](#33-覆盖索引)
  - [4. 反规范化](#4-反规范化)
    - [4.1 何时反规范化](#41-何时反规范化)
    - [4.2 汇总表](#42-汇总表)
  - [5. 分区策略](#5-分区策略)
    - [5.1 时间分区](#51-时间分区)
    - [5.2 列表分区](#52-列表分区)
    - [5.3 哈希分区](#53-哈希分区)
  - [6. JSON vs 列](#6-json-vs-列)
    - [6.1 何时使用JSONB](#61-何时使用jsonb)
  - [7. 命名规范](#7-命名规范)

## 1. 主键设计

### 1.1 主键类型选择

```sql
-- 选项1: SERIAL/BIGSERIAL（自增）
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100)
);

-- 优点: 简单、顺序、B-Tree友好
-- 缺点: 分布式环境冲突、无业务意义

-- 选项2: UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(100)
);

-- 优点: 全局唯一、分布式友好
-- 缺点: 16字节、随机（索引性能差）

-- 选项3: UUIDv7（PostgreSQL 18，推荐）
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT uuidv7(),
    username VARCHAR(100)
);

-- 优点: 全局唯一+时间有序
-- 性能: 接近BIGSERIAL

-- 选项4: 雪花ID（Snowflake）
-- 64位: 1位符号 + 41位时间戳 + 10位机器ID + 12位序列号
CREATE OR REPLACE FUNCTION generate_snowflake_id()
RETURNS BIGINT AS $$
DECLARE
    epoch BIGINT := 1640995200000;  -- 2022-01-01 00:00:00 UTC (毫秒)
    machine_id INT := 1;
    sequence INT;
    current_time BIGINT;
    result BIGINT;
BEGIN
    current_time := (EXTRACT(EPOCH FROM clock_timestamp()) * 1000)::BIGINT;
    sequence := nextval('snowflake_seq') % 4096;

    result := ((current_time - epoch) << 22) | (machine_id << 12) | sequence;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

CREATE SEQUENCE snowflake_seq;

CREATE TABLE users (
    user_id BIGINT PRIMARY KEY DEFAULT generate_snowflake_id(),
    username VARCHAR(100)
);
```

---

## 2. 外键设计

### 2.1 外键约束

```sql
-- 基础外键
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id),
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 级联操作
CREATE TABLE order_items (
    item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT NOT NULL REFERENCES orders(order_id)
        ON DELETE CASCADE          -- 删除订单时删除订单项
        ON UPDATE CASCADE,         -- 更新订单ID时同步更新
    product_id BIGINT NOT NULL REFERENCES products(product_id)
        ON DELETE RESTRICT,        -- 禁止删除被引用的产品
    quantity INT NOT NULL
);

-- 延迟约束检查
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id) DEFERRABLE INITIALLY DEFERRED
);

-- 事务结束时检查
BEGIN;
INSERT INTO orders (order_id, user_id) VALUES (1, 999);  -- user不存在
INSERT INTO users (user_id) VALUES (999);  -- 后插入
COMMIT;  -- 此时检查约束，成功
```

### 2.2 软外键（性能）

```sql
-- 场景: 高频写入，外键检查成本高
-- 方案: 应用层保证 + 定期验证

CREATE TABLE logs (
    log_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,  -- 无FOREIGN KEY
    message TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 定期验证数据完整性
SELECT l.user_id
FROM logs l
LEFT JOIN users u ON l.user_id = u.user_id
WHERE u.user_id IS NULL
LIMIT 100;
```

---

## 3. 索引策略

### 3.1 单列索引

```sql
-- 高选择性列
CREATE INDEX idx_users_email ON users(email);  -- 唯一或接近唯一

-- 低选择性列（考虑部分索引）
-- Bad
CREATE INDEX idx_users_status ON users(status);  -- 只有3种状态

-- Good
CREATE INDEX idx_users_active ON users(status) WHERE status = 'active';
```

### 3.2 组合索引

```sql
-- 查询: WHERE a = ? AND b = ? ORDER BY c
CREATE INDEX idx_abc ON table(a, b, c);

-- 可以使用索引的查询:
WHERE a = ?                              ✓
WHERE a = ? AND b = ?                    ✓
WHERE a = ? AND b = ? ORDER BY c         ✓
WHERE a = ? ORDER BY b, c                ✓

-- 无法使用索引:
WHERE b = ?                              ✗
WHERE c = ?                              ✗ (PostgreSQL 18: Skip Scan可以!)
WHERE b = ? AND c = ?                    ✗

-- 原则: 查询列在前，排序列在后
```

### 3.3 覆盖索引

```sql
-- Index Only Scan（无需访问表）
CREATE INDEX idx_users_email_name ON users(email, username);

SELECT username FROM users WHERE email = 'test@example.com';
-- Index Only Scan: 只扫描索引，不访问表

-- 注意: 需要定期VACUUM更新可见性映射
```

---

## 4. 反规范化

### 4.1 何时反规范化

```sql
-- 场景: 高频JOIN查询

-- 规范化设计（3NF）
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(user_id),
    created_at TIMESTAMPTZ
);

SELECT o.*, u.username, u.email
FROM orders o
JOIN users u ON o.user_id = u.user_id;
-- 每次查询都需要JOIN

-- 反规范化
CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    user_name VARCHAR(100),  -- 冗余
    user_email VARCHAR(255), -- 冗余
    created_at TIMESTAMPTZ
);

SELECT * FROM orders;  -- 无需JOIN

-- 维护一致性（触发器）
CREATE OR REPLACE FUNCTION sync_user_info()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders
    SET user_name = NEW.username,
        user_email = NEW.email
    WHERE user_id = NEW.user_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_sync_user
    AFTER UPDATE OF username, email ON users
    FOR EACH ROW
    EXECUTE FUNCTION sync_user_info();
```

### 4.2 汇总表

```sql
-- 实时汇总（物化视图）
CREATE MATERIALIZED VIEW user_statistics AS
SELECT
    user_id,
    COUNT(*) AS order_count,
    SUM(amount) AS total_spent,
    MAX(created_at) AS last_order_at
FROM orders
GROUP BY user_id;

-- 索引
CREATE UNIQUE INDEX idx_user_stats_user ON user_statistics(user_id);

-- 定期刷新
REFRESH MATERIALIZED VIEW CONCURRENTLY user_statistics;

-- 或用触发器实时维护普通表
```

---

## 5. 分区策略

### 5.1 时间分区

```sql
-- 日志表按月分区
CREATE TABLE logs (
    log_id BIGSERIAL,
    message TEXT,
    created_at TIMESTAMPTZ NOT NULL,
    PRIMARY KEY (log_id, created_at)
) PARTITION BY RANGE (created_at);

-- 创建分区
CREATE TABLE logs_2024_01 PARTITION OF logs
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 自动分区裁剪
SELECT * FROM logs
WHERE created_at >= '2024-01-15' AND created_at < '2024-01-20';
-- 只扫描logs_2024_01分区
```

### 5.2 列表分区

```sql
-- 按地区分区
CREATE TABLE orders (
    order_id BIGSERIAL,
    region VARCHAR(10),
    amount NUMERIC,
    PRIMARY KEY (order_id, region)
) PARTITION BY LIST (region);

CREATE TABLE orders_asia PARTITION OF orders
FOR VALUES IN ('CN', 'JP', 'KR', 'SG');

CREATE TABLE orders_europe PARTITION OF orders
FOR VALUES IN ('UK', 'FR', 'DE', 'IT');
```

### 5.3 哈希分区

```sql
-- 均匀分布大表
CREATE TABLE users_partitioned (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(100)
) PARTITION BY HASH (user_id);

-- 创建8个分区
CREATE TABLE users_p0 PARTITION OF users_partitioned
FOR VALUES WITH (MODULUS 8, REMAINDER 0);
-- ... p1 to p7
```

---

## 6. JSON vs 列

### 6.1 何时使用JSONB

```sql
-- 适合JSONB:
-- 1. Schema不固定
CREATE TABLE events (
    event_id BIGSERIAL PRIMARY KEY,
    event_type VARCHAR(50),
    event_data JSONB  -- 不同事件类型有不同字段
);

-- 2. 稀疏数据（大部分字段为NULL）
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200),
    specs JSONB  -- 不同产品类型有不同规格
);

-- 不适合JSONB:
-- 1. 高频查询字段
-- 2. 需要JOIN的字段
-- 3. 需要强类型约束

-- 混合方案
CREATE TABLE products (
    product_id BIGSERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,     -- 列
    category_id INT NOT NULL,       -- 列（需要JOIN）
    price NUMERIC(10,2) NOT NULL,   -- 列（需要索引和聚合）
    specs JSONB                     -- JSONB（灵活属性）
);
```

---

## 7. 命名规范

```sql
-- 表名: 复数、小写、下划线
users, order_items, product_categories

-- 列名: 单数、小写、下划线
user_id, first_name, created_at

-- 索引: idx_表名_列名
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);

-- 约束:
-- PK: 表名_pkey (自动)
-- FK: fk_表名_引用表
-- UK: uk_表名_列名
-- CK: ck_表名_描述

ALTER TABLE orders ADD CONSTRAINT fk_orders_users
    FOREIGN KEY (user_id) REFERENCES users(user_id);

ALTER TABLE products ADD CONSTRAINT ck_products_price_positive
    CHECK (price >= 0);
```

---

**完成**: PostgreSQL数据建模最佳实践
**字数**: ~10,000字
**涵盖**: 主键、外键、索引、反规范化、分区、JSONB、命名规范
